<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/DragController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DragClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DragController.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DragController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  66 #include &quot;Page.h&quot;
  67 #include &quot;Pasteboard.h&quot;
  68 #include &quot;PlatformKeyboardEvent.h&quot;
  69 #include &quot;PluginDocument.h&quot;
  70 #include &quot;PluginViewBase.h&quot;
  71 #include &quot;Position.h&quot;
  72 #include &quot;PromisedAttachmentInfo.h&quot;
  73 #include &quot;RenderAttachment.h&quot;
  74 #include &quot;RenderFileUploadControl.h&quot;
  75 #include &quot;RenderImage.h&quot;
  76 #include &quot;RenderView.h&quot;
  77 #include &quot;ReplaceSelectionCommand.h&quot;
  78 #include &quot;ResourceRequest.h&quot;
  79 #include &quot;SecurityOrigin.h&quot;
  80 #include &quot;Settings.h&quot;
  81 #include &quot;ShadowRoot.h&quot;
  82 #include &quot;StyleProperties.h&quot;
  83 #include &quot;Text.h&quot;
  84 #include &quot;TextEvent.h&quot;
  85 #include &quot;VisiblePosition.h&quot;

  86 #include &quot;markup.h&quot;
  87 
  88 #if ENABLE(DATA_INTERACTION)
  89 #include &quot;SelectionRect.h&quot;
  90 #endif
  91 
  92 #include &lt;wtf/RefPtr.h&gt;
  93 #include &lt;wtf/SetForScope.h&gt;
  94 #endif
  95 
  96 #if ENABLE(DATA_DETECTION)
  97 #include &quot;DataDetection.h&quot;
  98 #endif
  99 
 100 namespace WebCore {
 101 
 102 bool isDraggableLink(const Element&amp; element)
 103 {
 104     if (is&lt;HTMLAnchorElement&gt;(element)) {
 105         auto&amp; anchorElement = downcast&lt;HTMLAnchorElement&gt;(element);
</pre>
<hr />
<pre>
 115         return element.isLink();
 116     return false;
 117 }
 118 
 119 #if ENABLE(DRAG_SUPPORT)
 120 
 121 static PlatformMouseEvent createMouseEvent(const DragData&amp; dragData)
 122 {
 123     bool shiftKey = false;
 124     bool ctrlKey = false;
 125     bool altKey = false;
 126     bool metaKey = false;
 127 
 128     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
 129 
 130     return PlatformMouseEvent(dragData.clientPosition(), dragData.globalPosition(),
 131                               LeftButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey,
 132                               metaKey, WallTime::now(), ForceAtClick, NoTap);
 133 }
 134 
<span class="line-modified"> 135 DragController::DragController(Page&amp; page, DragClient&amp; client)</span>
 136     : m_page(page)
<span class="line-modified"> 137     , m_client(client)</span>
 138 {
 139 }
 140 
<span class="line-modified"> 141 DragController::~DragController()</span>
<span class="line-removed"> 142 {</span>
<span class="line-removed"> 143     m_client.dragControllerDestroyed();</span>
<span class="line-removed"> 144 }</span>
 145 
 146 static RefPtr&lt;DocumentFragment&gt; documentFragmentFromDragData(const DragData&amp; dragData, Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
 147 {
 148     chosePlainText = false;
 149 
 150     Document&amp; document = context.ownerDocument();
 151     if (dragData.containsCompatibleContent()) {
 152         if (auto fragment = frame.editor().webContentFromPasteboard(*Pasteboard::createForDragAndDrop(dragData), context, allowPlainText, chosePlainText))
 153             return fragment;
 154 
 155         if (dragData.containsURL(DragData::DoNotConvertFilenames)) {
 156             String title;
 157             String url = dragData.asURL(DragData::DoNotConvertFilenames, &amp;title);
 158             if (!url.isEmpty()) {
 159                 auto anchor = HTMLAnchorElement::create(document);
 160                 anchor-&gt;setHref(url);
 161                 if (title.isEmpty()) {
 162                     // Try the plain text first because the url might be normalized or escaped.
 163                     if (dragData.containsPlainText())
 164                         title = dragData.asPlainText();
</pre>
<hr />
<pre>
 189 
 190 #endif
 191 
 192 bool DragController::dragIsMove(FrameSelection&amp; selection, const DragData&amp; dragData)
 193 {
 194     const VisibleSelection&amp; visibleSelection = selection.selection();
 195     return m_documentUnderMouse == m_dragInitiator &amp;&amp; visibleSelection.isContentEditable() &amp;&amp; visibleSelection.isRange() &amp;&amp; !isCopyKeyDown(dragData);
 196 }
 197 
 198 void DragController::clearDragCaret()
 199 {
 200     m_page.dragCaretController().clear();
 201 }
 202 
 203 void DragController::dragEnded()
 204 {
 205     m_dragInitiator = nullptr;
 206     m_didInitiateDrag = false;
 207     m_documentUnderMouse = nullptr;
 208     clearDragCaret();

 209 
<span class="line-modified"> 210     m_client.dragEnded();</span>
 211 }
 212 
 213 DragOperation DragController::dragEntered(const DragData&amp; dragData)
 214 {
 215     return dragEnteredOrUpdated(dragData);
 216 }
 217 
 218 void DragController::dragExited(const DragData&amp; dragData)
 219 {
 220     auto&amp; mainFrame = m_page.mainFrame();
 221     if (mainFrame.view())
 222         mainFrame.eventHandler().cancelDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 223     mouseMovedIntoDocument(nullptr);
 224     if (m_fileInputElementUnderMouse)
 225         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 226     m_fileInputElementUnderMouse = nullptr;
 227 }
 228 
 229 DragOperation DragController::dragUpdated(const DragData&amp; dragData)
 230 {
 231     return dragEnteredOrUpdated(dragData);
 232 }
 233 
 234 inline static bool dragIsHandledByDocument(DragHandlingMethod dragHandlingMethod)
 235 {
 236     return dragHandlingMethod != DragHandlingMethod::None &amp;&amp; dragHandlingMethod != DragHandlingMethod::PageLoad;
 237 }
 238 
 239 bool DragController::performDragOperation(const DragData&amp; dragData)
 240 {










 241     SetForScope&lt;bool&gt; isPerformingDrop(m_isPerformingDrop, true);
 242     TemporarySelectionChange ignoreSelectionChanges(m_page.focusController().focusedOrMainFrame(), WTF::nullopt, TemporarySelectionOption::IgnoreSelectionChanges);
 243 
 244     m_documentUnderMouse = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 245 
 246     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = ShouldOpenExternalURLsPolicy::ShouldNotAllow;
 247     if (m_documentUnderMouse)
 248         shouldOpenExternalURLsPolicy = m_documentUnderMouse-&gt;shouldOpenExternalURLsPolicyToPropagate();
 249 
 250     if ((m_dragDestinationAction &amp; DragDestinationActionDHTML) &amp;&amp; dragIsHandledByDocument(m_dragHandlingMethod)) {
<span class="line-modified"> 251         m_client.willPerformDragDestinationAction(DragDestinationActionDHTML, dragData);</span>
 252         Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 253         bool preventedDefault = false;
 254         if (mainFrame-&gt;view())
 255             preventedDefault = mainFrame-&gt;eventHandler().performDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 256         if (preventedDefault) {
 257             clearDragCaret();
 258             m_documentUnderMouse = nullptr;
 259             return true;
 260         }
 261     }
 262 
 263     if ((m_dragDestinationAction &amp; DragDestinationActionEdit) &amp;&amp; concludeEditDrag(dragData)) {
<span class="line-modified"> 264         m_client.didConcludeEditDrag();</span>
 265         m_documentUnderMouse = nullptr;
 266         clearDragCaret();
 267         return true;
 268     }
 269 
 270     m_documentUnderMouse = nullptr;
 271     clearDragCaret();
 272 
 273     if (operationForLoad(dragData) == DragOperationNone)
 274         return false;
 275 
 276     auto urlString = dragData.asURL();
 277     if (urlString.isEmpty())
 278         return false;
 279 
<span class="line-modified"> 280     m_client.willPerformDragDestinationAction(DragDestinationActionLoad, dragData);</span>
 281     FrameLoadRequest frameLoadRequest { m_page.mainFrame(), ResourceRequest { urlString }, shouldOpenExternalURLsPolicy };
 282     frameLoadRequest.setIsRequestFromClientOrUserInput();
 283     m_page.mainFrame().loader().load(WTFMove(frameLoadRequest));
 284     return true;
 285 }
 286 
 287 void DragController::mouseMovedIntoDocument(Document* newDocument)
 288 {
 289     if (m_documentUnderMouse == newDocument)
 290         return;
 291 
 292     // If we were over another document clear the selection
 293     if (m_documentUnderMouse)
 294         clearDragCaret();
 295     m_documentUnderMouse = newDocument;
 296 }
 297 
 298 DragOperation DragController::dragEnteredOrUpdated(const DragData&amp; dragData)
 299 {
 300     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(dragData.clientPosition()));
</pre>
<hr />
<pre>
 459 
 460         if (m_fileInputElementUnderMouse)
 461             return DragHandlingMethod::UploadFile;
 462 
 463         if (m_page.dragCaretController().isContentRichlyEditable())
 464             return DragHandlingMethod::EditRichText;
 465 
 466         return DragHandlingMethod::EditPlainText;
 467     }
 468 
 469     // We are not over an editable region. Make sure we&#39;re clearing any prior drag cursor.
 470     clearDragCaret();
 471     if (m_fileInputElementUnderMouse)
 472         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 473     m_fileInputElementUnderMouse = nullptr;
 474     return DragHandlingMethod::None;
 475 }
 476 
 477 DragSourceAction DragController::delegateDragSourceAction(const IntPoint&amp; rootViewPoint)
 478 {
<span class="line-modified"> 479     m_dragSourceAction = m_client.dragSourceActionMaskForPoint(rootViewPoint);</span>
 480     return m_dragSourceAction;
 481 }
 482 
 483 DragOperation DragController::operationForLoad(const DragData&amp; dragData)
 484 {
 485     Document* document = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 486 
 487     bool pluginDocumentAcceptsDrags = false;
 488 
 489     if (is&lt;PluginDocument&gt;(document)) {
 490         const Widget* widget = downcast&lt;PluginDocument&gt;(*document).pluginWidget();
 491         const PluginViewBase* pluginView = is&lt;PluginViewBase&gt;(widget) ? downcast&lt;PluginViewBase&gt;(widget) : nullptr;
 492 
 493         if (pluginView)
 494             pluginDocumentAcceptsDrags = pluginView-&gt;shouldAllowNavigationFromDrags();
 495     }
 496 
 497     if (document &amp;&amp; (m_didInitiateDrag || (is&lt;PluginDocument&gt;(*document) &amp;&amp; !pluginDocumentAcceptsDrags) || document-&gt;hasEditableStyle()))
 498         return DragOperationNone;
 499     return dragOperation(dragData);
</pre>
<hr />
<pre>
 544         return true;
 545 
 546     if (dragData.containsColor()) {
 547         Color color = dragData.asColor();
 548         if (!color.isValid())
 549             return false;
 550 #if ENABLE(INPUT_TYPE_COLOR)
 551         if (isEnabledColorInput(*element)) {
 552             auto&amp; input = downcast&lt;HTMLInputElement&gt;(*element);
 553             input.setValue(color.serialized(), DispatchInputAndChangeEvent);
 554             return true;
 555         }
 556 #endif
 557         auto innerRange = innerFrame-&gt;selection().toNormalizedRange();
 558         if (!innerRange)
 559             return false;
 560         auto style = MutableStyleProperties::create();
 561         style-&gt;setProperty(CSSPropertyColor, color.serialized(), false);
 562         if (!innerFrame-&gt;editor().shouldApplyStyle(style.ptr(), innerRange.get()))
 563             return false;
<span class="line-modified"> 564         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
 565         innerFrame-&gt;editor().applyStyle(style.ptr(), EditAction::SetColor);
 566         return true;
 567     }
 568 
 569     if (dragData.containsFiles() &amp;&amp; fileInput) {
 570         // fileInput should be the element we hit tested for, unless it was made
 571         // display:none in a drop event handler.
 572         ASSERT(fileInput == element || !fileInput-&gt;renderer());
 573         if (fileInput-&gt;isDisabledFormControl())
 574             return false;
 575 
 576         return fileInput-&gt;receiveDroppedFiles(dragData);
 577     }
 578 
 579     if (!m_page.dragController().canProcessDrag(dragData))
 580         return false;
 581 
 582     VisibleSelection dragCaret = m_page.dragCaretController().caretPosition();
 583     RefPtr&lt;Range&gt; range = dragCaret.toNormalizedRange();
 584     RefPtr&lt;Element&gt; rootEditableElement = innerFrame-&gt;selection().selection().rootEditableElement();
 585 
 586     // For range to be null a WebKit client must have done something bad while
 587     // manually controlling drag behaviour
 588     if (!range)
 589         return false;
 590 
 591     ResourceCacheValidationSuppressor validationSuppressor(range-&gt;ownerDocument().cachedResourceLoader());
 592     auto&amp; editor = innerFrame-&gt;editor();
 593     bool isMove = dragIsMove(innerFrame-&gt;selection(), dragData);
 594     if (isMove || dragCaret.isContentRichlyEditable()) {
 595         bool chosePlainText = false;
 596         RefPtr&lt;DocumentFragment&gt; fragment = documentFragmentFromDragData(dragData, *innerFrame, *range, true, chosePlainText);
 597         if (!fragment || !editor.shouldInsertFragment(*fragment, range.get(), EditorInsertAction::Dropped))
 598             return false;
 599 
<span class="line-modified"> 600         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
 601 
 602         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 603             return true;
 604 
 605         if (isMove) {
 606             // NSTextView behavior is to always smart delete on moving a selection,
 607             // but only to smart insert if the selection granularity is word granularity.
 608             bool smartDelete = editor.smartInsertDeleteEnabled();
 609             bool smartInsert = smartDelete &amp;&amp; innerFrame-&gt;selection().granularity() == WordGranularity &amp;&amp; dragData.canSmartReplace();
 610             MoveSelectionCommand::create(fragment.releaseNonNull(), dragCaret.base(), smartInsert, smartDelete)-&gt;apply();
 611         } else {
 612             if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point)) {
 613                 OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::PreventNesting };
 614                 if (dragData.canSmartReplace())
 615                     options.add(ReplaceSelectionCommand::SmartReplace);
 616                 if (chosePlainText)
 617                     options.add(ReplaceSelectionCommand::MatchStyle);
 618                 ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.releaseNonNull(), options, EditAction::InsertFromDrop)-&gt;apply();
 619             }
 620         }
 621     } else {
 622         String text = dragData.asPlainText();
 623         if (text.isEmpty() || !editor.shouldInsertText(text, range.get(), EditorInsertAction::Dropped))
 624             return false;
 625 
<span class="line-modified"> 626         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
 627         RefPtr&lt;DocumentFragment&gt; fragment = createFragmentFromText(*range, text);
 628         if (!fragment)
 629             return false;
 630 
 631         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 632             return true;
 633 
 634         if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point))
 635             ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.get(), { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::MatchStyle, ReplaceSelectionCommand::PreventNesting }, EditAction::InsertFromDrop)-&gt;apply();
 636     }
 637 
 638     if (rootEditableElement) {
 639         if (Frame* frame = rootEditableElement-&gt;document().frame())
 640             frame-&gt;eventHandler().updateDragStateAfterEditDragIfNeeded(*rootEditableElement);
 641     }
 642 
 643     return true;
 644 }
 645 
 646 bool DragController::canProcessDrag(const DragData&amp; dragData)
</pre>
<hr />
<pre>
 927     if (state.type == DragSourceActionDHTML) {
 928         dragImage = DragImage { dataTransfer.createDragImage(dragImageOffset) };
 929         // We allow DHTML/JS to set the drag image, even if its a link, image or text we&#39;re dragging.
 930         // This is in the spirit of the IE API, which allows overriding of pasteboard data and DragOp.
 931         if (dragImage) {
 932             dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, !linkURL.isEmpty());
 933             m_dragOffset = dragImageOffset;
 934         }
 935     }
 936 
 937     if (state.type == DragSourceActionSelection || !imageURL.isEmpty() || !linkURL.isEmpty()) {
 938         // Selection, image, and link drags receive a default set of allowed drag operations that
 939         // follows from:
 940         // http://trac.webkit.org/browser/trunk/WebKit/mac/WebView/WebHTMLView.mm?rev=48526#L3430
 941         m_sourceDragOperation = static_cast&lt;DragOperation&gt;(m_sourceDragOperation | DragOperationGeneric | DragOperationCopy);
 942     }
 943 
 944     ASSERT(state.source);
 945     Element&amp; element = *state.source;
 946 
<span class="line-modified"> 947     bool mustUseLegacyDragClient = hasData == HasNonDefaultPasteboardData::Yes || m_client.useLegacyDragClient();</span>
 948 
 949     IntRect dragImageBounds;
 950     Image* image = getImage(element);
 951     if (state.type == DragSourceActionSelection) {
 952         PasteboardWriterData pasteboardWriterData;
 953 
 954         if (hasData == HasNonDefaultPasteboardData::No) {
 955             if (src.selection().selection().isNone()) {
 956                 // The page may have cleared out the selection in the dragstart handler, in which case we should bail
 957                 // out of the drag, since there is no content to write to the pasteboard.
 958                 return false;
 959             }
 960 
 961             // FIXME: This entire block is almost identical to the code in Editor::copy, and the code should be shared.
 962             RefPtr&lt;Range&gt; selectionRange = src.selection().toNormalizedRange();
 963             ASSERT(selectionRange);
 964 
 965             src.editor().willWriteSelectionToPasteboard(selectionRange.get());
 966 
 967             if (enclosingTextFormControl(src.selection().selection().start())) {
</pre>
<hr />
<pre>
 973                     plainText.text = src.editor().selectedTextForDataTransfer();
 974                     pasteboardWriterData.setPlainText(WTFMove(plainText));
 975                 }
 976             } else {
 977                 if (mustUseLegacyDragClient) {
 978 #if PLATFORM(COCOA) || PLATFORM(GTK)
 979                     src.editor().writeSelectionToPasteboard(dataTransfer.pasteboard());
 980 #else
 981                     // FIXME: Convert all other platforms to match Mac and delete this.
 982                     dataTransfer.pasteboard().writeSelection(*selectionRange, src.editor().canSmartCopyOrDelete(), src, IncludeImageAltTextForDataTransfer);
 983 #endif
 984                 } else {
 985 #if PLATFORM(COCOA)
 986                     src.editor().writeSelection(pasteboardWriterData);
 987 #endif
 988                 }
 989             }
 990 
 991             src.editor().didWriteSelectionToPasteboard();
 992         }
<span class="line-modified"> 993         m_client.willPerformDragSourceAction(DragSourceActionSelection, dragOrigin, dataTransfer);</span>
 994         if (!dragImage) {
 995             TextIndicatorData textIndicator;
 996             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
 997             if (textIndicator.contentImage)
 998                 dragImage.setIndicatorData(textIndicator);
 999             dragLoc = dragLocForSelectionDrag(src);
1000             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1001         }
1002 
1003         if (!dragImage)
1004             return false;
1005 
1006         if (mustUseLegacyDragClient) {
1007             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1008             return true;
1009         }
1010 
1011         DragItem dragItem;
1012         dragItem.imageAnchorPoint = dragImageAnchorPointForSelectionDrag(src, mouseDraggedPoint);
1013         dragItem.image = WTFMove(dragImage);
</pre>
<hr />
<pre>
1025 
1026     if (!imageURL.isEmpty() &amp;&amp; image &amp;&amp; !image-&gt;isNull() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionImage)) {
1027         // We shouldn&#39;t be starting a drag for an image that can&#39;t provide an extension.
1028         // This is an early detection for problems encountered later upon drop.
1029         ASSERT(!image-&gt;filenameExtension().isEmpty());
1030 
1031 #if ENABLE(ATTACHMENT_ELEMENT)
1032         auto attachmentInfo = promisedAttachmentInfo(src, element);
1033 #else
1034         PromisedAttachmentInfo attachmentInfo;
1035 #endif
1036 
1037         if (hasData == HasNonDefaultPasteboardData::No) {
1038             m_draggingImageURL = imageURL;
1039             if (element.isContentRichlyEditable())
1040                 selectElement(element);
1041             if (!attachmentInfo)
1042                 declareAndWriteDragImage(dataTransfer, element, !linkURL.isEmpty() ? linkURL : imageURL, hitTestResult.altDisplayString());
1043         }
1044 
<span class="line-modified">1045         m_client.willPerformDragSourceAction(DragSourceActionImage, dragOrigin, dataTransfer);</span>
1046 
1047         if (!dragImage)
1048             doImageDrag(element, dragOrigin, hitTestResult.imageRect(), src, m_dragOffset, state, WTFMove(attachmentInfo));
1049         else {
1050             // DHTML defined drag image
1051             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(attachmentInfo));
1052         }
1053 
1054         return true;
1055     }
1056 
1057     if (!linkURL.isEmpty() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionLink)) {
1058         PasteboardWriterData pasteboardWriterData;
1059 
1060         String textContentWithSimplifiedWhiteSpace = hitTestResult.textContent().simplifyWhiteSpace();
1061 
1062         if (hasData == HasNonDefaultPasteboardData::No) {
1063             // Simplify whitespace so the title put on the dataTransfer resembles what the user sees
1064             // on the web page. This includes replacing newlines with spaces.
1065             if (mustUseLegacyDragClient)
</pre>
<hr />
<pre>
1069         } else {
1070             // Make sure the pasteboard also contains trustworthy link data
1071             // but don&#39;t overwrite more general pasteboard types.
1072             PasteboardURL pasteboardURL;
1073             pasteboardURL.url = linkURL;
1074             pasteboardURL.title = hitTestResult.textContent();
1075             dataTransfer.pasteboard().writeTrustworthyWebURLsPboardType(pasteboardURL);
1076         }
1077 
1078         const VisibleSelection&amp; sourceSelection = src.selection().selection();
1079         if (sourceSelection.isCaret() &amp;&amp; sourceSelection.isContentEditable()) {
1080             // a user can initiate a drag on a link without having any text
1081             // selected.  In this case, we should expand the selection to
1082             // the enclosing anchor element
1083             Position pos = sourceSelection.base();
1084             Node* node = enclosingAnchorElement(pos);
1085             if (node)
1086                 src.selection().setSelection(VisibleSelection::selectionFromContentsOfNode(node));
1087         }
1088 
<span class="line-modified">1089         m_client.willPerformDragSourceAction(DragSourceActionLink, dragOrigin, dataTransfer);</span>
1090         if (!dragImage) {
1091             TextIndicatorData textIndicator;
1092             dragImage = DragImage { createDragImageForLink(element, linkURL, textContentWithSimplifiedWhiteSpace, textIndicator, src.settings().fontRenderingMode(), m_page.deviceScaleFactor()) };
1093             if (dragImage) {
1094                 m_dragOffset = dragOffsetForLinkDragImage(dragImage.get());
1095                 dragLoc = IntPoint(dragOrigin.x() + m_dragOffset.x(), dragOrigin.y() + m_dragOffset.y());
1096                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1097                 if (textIndicator.contentImage)
1098                     dragImage.setIndicatorData(textIndicator);
1099             }
1100         }
1101 
1102         if (mustUseLegacyDragClient) {
1103             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1104             return true;
1105         }
1106 
1107         DragItem dragItem;
1108         dragItem.imageAnchorPoint = dragImage ? anchorPointForLinkDragImage(dragImage.get()) : FloatPoint();
1109         dragItem.image = WTFMove(dragImage);
</pre>
<hr />
<pre>
1120         auto* attachmentRenderer = attachment.renderer();
1121 
1122         src.editor().setIgnoreSelectionChanges(true);
1123         auto previousSelection = src.selection().selection();
1124         selectElement(element);
1125 
1126         PromisedAttachmentInfo promisedAttachment;
1127         if (hasData == HasNonDefaultPasteboardData::No) {
1128             promisedAttachment = promisedAttachmentInfo(src, attachment);
1129             auto&amp; editor = src.editor();
1130             if (!promisedAttachment &amp;&amp; editor.client()) {
1131 #if PLATFORM(COCOA)
1132                 // Otherwise, if no file URL is specified, call out to the injected bundle to populate the pasteboard with data.
1133                 editor.willWriteSelectionToPasteboard(src.selection().toNormalizedRange().get());
1134                 editor.writeSelectionToPasteboard(dataTransfer.pasteboard());
1135                 editor.didWriteSelectionToPasteboard();
1136 #endif
1137             }
1138         }
1139 
<span class="line-modified">1140         m_client.willPerformDragSourceAction(DragSourceActionAttachment, dragOrigin, dataTransfer);</span>
1141 
1142         if (!dragImage) {
1143             TextIndicatorData textIndicator;
1144             if (attachmentRenderer)
1145                 attachmentRenderer-&gt;setShouldDrawBorder(false);
1146             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1147             if (attachmentRenderer)
1148                 attachmentRenderer-&gt;setShouldDrawBorder(true);
1149             if (textIndicator.contentImage)
1150                 dragImage.setIndicatorData(textIndicator);
1151             dragLoc = dragLocForSelectionDrag(src);
1152             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1153         }
1154         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(promisedAttachment));
1155         if (!element.isContentRichlyEditable())
1156             src.selection().setSelection(previousSelection);
1157         src.editor().setIgnoreSelectionChanges(false);
1158         return true;
1159     }
1160 #endif
1161 
1162 #if ENABLE(INPUT_TYPE_COLOR)
1163     bool isColorControl = is&lt;HTMLInputElement&gt;(state.source) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*state.source).isColorControl();
1164     if (isColorControl &amp;&amp; m_dragSourceAction &amp; DragSourceActionColor) {
1165         auto&amp; input = downcast&lt;HTMLInputElement&gt;(*state.source);
1166         auto color = input.valueAsColor();
1167 
1168         Path visiblePath;
1169         dragImage = DragImage { createDragImageForColor(color, input.boundsInRootViewSpace(), input.document().page()-&gt;pageScaleFactor(), visiblePath) };
1170         dragImage.setVisiblePath(visiblePath);
1171         dataTransfer.pasteboard().write(color);
1172         dragImageOffset = IntPoint { dragImageSize(dragImage.get()) };
1173         dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, false);
1174 
<span class="line-modified">1175         m_client.willPerformDragSourceAction(DragSourceActionColor, dragOrigin, dataTransfer);</span>
1176         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1177         return true;
1178     }
1179 #endif
1180 
1181     if (state.type == DragSourceActionDHTML &amp;&amp; dragImage) {
1182         ASSERT(m_dragSourceAction &amp; DragSourceActionDHTML);
<span class="line-modified">1183         m_client.willPerformDragSourceAction(DragSourceActionDHTML, dragOrigin, dataTransfer);</span>
1184         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1185         return true;
1186     }
1187 
1188     return false;
1189 }
1190 
1191 void DragController::doImageDrag(Element&amp; element, const IntPoint&amp; dragOrigin, const IntRect&amp; layoutRect, Frame&amp; frame, IntPoint&amp; dragImageOffset, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; attachmentInfo)
1192 {
1193     IntPoint mouseDownPoint = dragOrigin;
1194     DragImage dragImage;
1195     IntPoint scaledOrigin;
1196 
1197     if (!element.renderer())
1198         return;
1199 
1200     ImageOrientation orientation = element.renderer()-&gt;imageOrientation();
1201 
1202     Image* image = getImage(element);
1203     if (image &amp;&amp; !layoutRect.isEmpty() &amp;&amp; shouldUseCachedImageForDragImage(*image) &amp;&amp; (dragImage = DragImage { createDragImageFromImage(image, orientation) })) {
</pre>
<hr />
<pre>
1219         scaledOrigin = IntPoint((int)(dx + 0.5), (int)(dy + 0.5));
1220     } else {
1221         if (CachedImage* cachedImage = getCachedImage(element)) {
1222             dragImage = DragImage { createDragImageIconForCachedImageFilename(cachedImage-&gt;response().suggestedFilename()) };
1223             if (dragImage) {
1224                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1225                 scaledOrigin = IntPoint(DragIconRightInset - dragImageSize(dragImage.get()).width(), DragIconBottomInset);
1226             }
1227         }
1228     }
1229 
1230     if (!dragImage)
1231         return;
1232 
1233     dragImageOffset = mouseDownPoint + scaledOrigin;
1234     doSystemDrag(WTFMove(dragImage), dragImageOffset, dragOrigin, frame, state, WTFMove(attachmentInfo));
1235 }
1236 
1237 void DragController::beginDrag(DragItem dragItem, Frame&amp; frame, const IntPoint&amp; mouseDownPoint, const IntPoint&amp; mouseDraggedPoint, DataTransfer&amp; dataTransfer, DragSourceAction dragSourceAction)
1238 {
<span class="line-modified">1239     ASSERT(!m_client.useLegacyDragClient());</span>
1240 
1241     m_didInitiateDrag = true;
1242     m_dragInitiator = frame.document();
1243 
1244     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1245     Ref&lt;Frame&gt; mainFrameProtector(m_page.mainFrame());
1246     RefPtr&lt;FrameView&gt; viewProtector = mainFrameProtector-&gt;view();
1247 
1248     auto mouseDownPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDownPoint));
1249     auto mouseDraggedPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDraggedPoint));
1250 
<span class="line-modified">1251     m_client.beginDrag(WTFMove(dragItem), frame, mouseDownPointInRootViewCoordinates, mouseDraggedPointInRootViewCoordinates, dataTransfer, dragSourceAction);</span>
1252 }
1253 
1254 void DragController::doSystemDrag(DragImage image, const IntPoint&amp; dragLoc, const IntPoint&amp; eventPos, Frame&amp; frame, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; promisedAttachmentInfo)
1255 {
1256     m_didInitiateDrag = true;
1257     m_dragInitiator = frame.document();
1258     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1259     Ref&lt;Frame&gt; frameProtector(m_page.mainFrame());
1260     RefPtr&lt;FrameView&gt; viewProtector = frameProtector-&gt;view();
1261 
1262     DragItem item;
1263     item.image = WTFMove(image);
1264     item.sourceAction = state.type;
1265     item.promisedAttachmentInfo = WTFMove(promisedAttachmentInfo);
1266 
1267     auto eventPositionInRootViewCoordinates = frame.view()-&gt;contentsToRootView(eventPos);
1268     auto dragLocationInRootViewCoordinates = frame.view()-&gt;contentsToRootView(dragLoc);
1269     item.eventPositionInContentCoordinates = viewProtector-&gt;rootViewToContents(eventPositionInRootViewCoordinates);
1270     item.dragLocationInContentCoordinates = viewProtector-&gt;rootViewToContents(dragLocationInRootViewCoordinates);
1271     item.dragLocationInWindowCoordinates = viewProtector-&gt;contentsToWindow(item.dragLocationInContentCoordinates);
</pre>
<hr />
<pre>
1287             item.dragPreviewFrameInRootViewCoordinates = element-&gt;boundsInRootViewSpace();
1288         }
1289 
1290         RefPtr&lt;Element&gt; link;
1291         if (element-&gt;isLink())
1292             link = element;
1293         else {
1294             for (auto&amp; currentElement : elementLineage(element.get())) {
1295                 if (currentElement.isLink()) {
1296                     link = &amp;currentElement;
1297                     break;
1298                 }
1299             }
1300         }
1301         if (link) {
1302             auto titleAttribute = link-&gt;attributeWithoutSynchronization(HTMLNames::titleAttr);
1303             item.title = titleAttribute.isEmpty() ? link-&gt;innerText() : titleAttribute.string();
1304             item.url = frame.document()-&gt;completeURL(stripLeadingAndTrailingHTMLSpaces(link-&gt;getAttribute(HTMLNames::hrefAttr)));
1305         }
1306     }
<span class="line-modified">1307     m_client.startDrag(WTFMove(item), *state.dataTransfer, frameProtector.get());</span>
1308     // DragClient::startDrag can cause our Page to dispear, deallocating |this|.
1309     if (!frameProtector-&gt;page())
1310         return;
1311 
1312     cleanupAfterSystemDrag();
1313 }
1314 




































































































































1315 // Manual drag caret manipulation
1316 void DragController::placeDragCaret(const IntPoint&amp; windowPoint)
1317 {
1318     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(windowPoint));
1319     if (!m_documentUnderMouse)
1320         return;
1321     Frame* frame = m_documentUnderMouse-&gt;frame();
1322     FrameView* frameView = frame-&gt;view();
1323     if (!frameView)
1324         return;
1325     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
1326 
1327     m_page.dragCaretController().setCaretPosition(frame-&gt;visiblePositionForPoint(framePoint));
1328 }
1329 
1330 bool DragController::shouldUseCachedImageForDragImage(const Image&amp; image) const
1331 {
1332 #if ENABLE(DATA_INTERACTION)
1333     UNUSED_PARAM(image);
1334     return true;
</pre>
</td>
<td>
<hr />
<pre>
  66 #include &quot;Page.h&quot;
  67 #include &quot;Pasteboard.h&quot;
  68 #include &quot;PlatformKeyboardEvent.h&quot;
  69 #include &quot;PluginDocument.h&quot;
  70 #include &quot;PluginViewBase.h&quot;
  71 #include &quot;Position.h&quot;
  72 #include &quot;PromisedAttachmentInfo.h&quot;
  73 #include &quot;RenderAttachment.h&quot;
  74 #include &quot;RenderFileUploadControl.h&quot;
  75 #include &quot;RenderImage.h&quot;
  76 #include &quot;RenderView.h&quot;
  77 #include &quot;ReplaceSelectionCommand.h&quot;
  78 #include &quot;ResourceRequest.h&quot;
  79 #include &quot;SecurityOrigin.h&quot;
  80 #include &quot;Settings.h&quot;
  81 #include &quot;ShadowRoot.h&quot;
  82 #include &quot;StyleProperties.h&quot;
  83 #include &quot;Text.h&quot;
  84 #include &quot;TextEvent.h&quot;
  85 #include &quot;VisiblePosition.h&quot;
<span class="line-added">  86 #include &quot;WebContentReader.h&quot;</span>
  87 #include &quot;markup.h&quot;
  88 
  89 #if ENABLE(DATA_INTERACTION)
  90 #include &quot;SelectionRect.h&quot;
  91 #endif
  92 
  93 #include &lt;wtf/RefPtr.h&gt;
  94 #include &lt;wtf/SetForScope.h&gt;
  95 #endif
  96 
  97 #if ENABLE(DATA_DETECTION)
  98 #include &quot;DataDetection.h&quot;
  99 #endif
 100 
 101 namespace WebCore {
 102 
 103 bool isDraggableLink(const Element&amp; element)
 104 {
 105     if (is&lt;HTMLAnchorElement&gt;(element)) {
 106         auto&amp; anchorElement = downcast&lt;HTMLAnchorElement&gt;(element);
</pre>
<hr />
<pre>
 116         return element.isLink();
 117     return false;
 118 }
 119 
 120 #if ENABLE(DRAG_SUPPORT)
 121 
 122 static PlatformMouseEvent createMouseEvent(const DragData&amp; dragData)
 123 {
 124     bool shiftKey = false;
 125     bool ctrlKey = false;
 126     bool altKey = false;
 127     bool metaKey = false;
 128 
 129     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
 130 
 131     return PlatformMouseEvent(dragData.clientPosition(), dragData.globalPosition(),
 132                               LeftButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey,
 133                               metaKey, WallTime::now(), ForceAtClick, NoTap);
 134 }
 135 
<span class="line-modified"> 136 DragController::DragController(Page&amp; page, std::unique_ptr&lt;DragClient&gt;&amp;&amp; client)</span>
 137     : m_page(page)
<span class="line-modified"> 138     , m_client(WTFMove(client))</span>
 139 {
 140 }
 141 
<span class="line-modified"> 142 DragController::~DragController() = default;</span>



 143 
 144 static RefPtr&lt;DocumentFragment&gt; documentFragmentFromDragData(const DragData&amp; dragData, Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
 145 {
 146     chosePlainText = false;
 147 
 148     Document&amp; document = context.ownerDocument();
 149     if (dragData.containsCompatibleContent()) {
 150         if (auto fragment = frame.editor().webContentFromPasteboard(*Pasteboard::createForDragAndDrop(dragData), context, allowPlainText, chosePlainText))
 151             return fragment;
 152 
 153         if (dragData.containsURL(DragData::DoNotConvertFilenames)) {
 154             String title;
 155             String url = dragData.asURL(DragData::DoNotConvertFilenames, &amp;title);
 156             if (!url.isEmpty()) {
 157                 auto anchor = HTMLAnchorElement::create(document);
 158                 anchor-&gt;setHref(url);
 159                 if (title.isEmpty()) {
 160                     // Try the plain text first because the url might be normalized or escaped.
 161                     if (dragData.containsPlainText())
 162                         title = dragData.asPlainText();
</pre>
<hr />
<pre>
 187 
 188 #endif
 189 
 190 bool DragController::dragIsMove(FrameSelection&amp; selection, const DragData&amp; dragData)
 191 {
 192     const VisibleSelection&amp; visibleSelection = selection.selection();
 193     return m_documentUnderMouse == m_dragInitiator &amp;&amp; visibleSelection.isContentEditable() &amp;&amp; visibleSelection.isRange() &amp;&amp; !isCopyKeyDown(dragData);
 194 }
 195 
 196 void DragController::clearDragCaret()
 197 {
 198     m_page.dragCaretController().clear();
 199 }
 200 
 201 void DragController::dragEnded()
 202 {
 203     m_dragInitiator = nullptr;
 204     m_didInitiateDrag = false;
 205     m_documentUnderMouse = nullptr;
 206     clearDragCaret();
<span class="line-added"> 207     removeAllDroppedImagePlaceholders();</span>
 208 
<span class="line-modified"> 209     client().dragEnded();</span>
 210 }
 211 
 212 DragOperation DragController::dragEntered(const DragData&amp; dragData)
 213 {
 214     return dragEnteredOrUpdated(dragData);
 215 }
 216 
 217 void DragController::dragExited(const DragData&amp; dragData)
 218 {
 219     auto&amp; mainFrame = m_page.mainFrame();
 220     if (mainFrame.view())
 221         mainFrame.eventHandler().cancelDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 222     mouseMovedIntoDocument(nullptr);
 223     if (m_fileInputElementUnderMouse)
 224         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 225     m_fileInputElementUnderMouse = nullptr;
 226 }
 227 
 228 DragOperation DragController::dragUpdated(const DragData&amp; dragData)
 229 {
 230     return dragEnteredOrUpdated(dragData);
 231 }
 232 
 233 inline static bool dragIsHandledByDocument(DragHandlingMethod dragHandlingMethod)
 234 {
 235     return dragHandlingMethod != DragHandlingMethod::None &amp;&amp; dragHandlingMethod != DragHandlingMethod::PageLoad;
 236 }
 237 
 238 bool DragController::performDragOperation(const DragData&amp; dragData)
 239 {
<span class="line-added"> 240     if (!m_droppedImagePlaceholders.isEmpty() &amp;&amp; m_droppedImagePlaceholderRange &amp;&amp; tryToUpdateDroppedImagePlaceholders(dragData)) {</span>
<span class="line-added"> 241         m_droppedImagePlaceholders.clear();</span>
<span class="line-added"> 242         m_droppedImagePlaceholderRange = nullptr;</span>
<span class="line-added"> 243         m_documentUnderMouse = nullptr;</span>
<span class="line-added"> 244         clearDragCaret();</span>
<span class="line-added"> 245         return true;</span>
<span class="line-added"> 246     }</span>
<span class="line-added"> 247 </span>
<span class="line-added"> 248     removeAllDroppedImagePlaceholders();</span>
<span class="line-added"> 249 </span>
 250     SetForScope&lt;bool&gt; isPerformingDrop(m_isPerformingDrop, true);
 251     TemporarySelectionChange ignoreSelectionChanges(m_page.focusController().focusedOrMainFrame(), WTF::nullopt, TemporarySelectionOption::IgnoreSelectionChanges);
 252 
 253     m_documentUnderMouse = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 254 
 255     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = ShouldOpenExternalURLsPolicy::ShouldNotAllow;
 256     if (m_documentUnderMouse)
 257         shouldOpenExternalURLsPolicy = m_documentUnderMouse-&gt;shouldOpenExternalURLsPolicyToPropagate();
 258 
 259     if ((m_dragDestinationAction &amp; DragDestinationActionDHTML) &amp;&amp; dragIsHandledByDocument(m_dragHandlingMethod)) {
<span class="line-modified"> 260         client().willPerformDragDestinationAction(DragDestinationActionDHTML, dragData);</span>
 261         Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
 262         bool preventedDefault = false;
 263         if (mainFrame-&gt;view())
 264             preventedDefault = mainFrame-&gt;eventHandler().performDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
 265         if (preventedDefault) {
 266             clearDragCaret();
 267             m_documentUnderMouse = nullptr;
 268             return true;
 269         }
 270     }
 271 
 272     if ((m_dragDestinationAction &amp; DragDestinationActionEdit) &amp;&amp; concludeEditDrag(dragData)) {
<span class="line-modified"> 273         client().didConcludeEditDrag();</span>
 274         m_documentUnderMouse = nullptr;
 275         clearDragCaret();
 276         return true;
 277     }
 278 
 279     m_documentUnderMouse = nullptr;
 280     clearDragCaret();
 281 
 282     if (operationForLoad(dragData) == DragOperationNone)
 283         return false;
 284 
 285     auto urlString = dragData.asURL();
 286     if (urlString.isEmpty())
 287         return false;
 288 
<span class="line-modified"> 289     client().willPerformDragDestinationAction(DragDestinationActionLoad, dragData);</span>
 290     FrameLoadRequest frameLoadRequest { m_page.mainFrame(), ResourceRequest { urlString }, shouldOpenExternalURLsPolicy };
 291     frameLoadRequest.setIsRequestFromClientOrUserInput();
 292     m_page.mainFrame().loader().load(WTFMove(frameLoadRequest));
 293     return true;
 294 }
 295 
 296 void DragController::mouseMovedIntoDocument(Document* newDocument)
 297 {
 298     if (m_documentUnderMouse == newDocument)
 299         return;
 300 
 301     // If we were over another document clear the selection
 302     if (m_documentUnderMouse)
 303         clearDragCaret();
 304     m_documentUnderMouse = newDocument;
 305 }
 306 
 307 DragOperation DragController::dragEnteredOrUpdated(const DragData&amp; dragData)
 308 {
 309     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(dragData.clientPosition()));
</pre>
<hr />
<pre>
 468 
 469         if (m_fileInputElementUnderMouse)
 470             return DragHandlingMethod::UploadFile;
 471 
 472         if (m_page.dragCaretController().isContentRichlyEditable())
 473             return DragHandlingMethod::EditRichText;
 474 
 475         return DragHandlingMethod::EditPlainText;
 476     }
 477 
 478     // We are not over an editable region. Make sure we&#39;re clearing any prior drag cursor.
 479     clearDragCaret();
 480     if (m_fileInputElementUnderMouse)
 481         m_fileInputElementUnderMouse-&gt;setCanReceiveDroppedFiles(false);
 482     m_fileInputElementUnderMouse = nullptr;
 483     return DragHandlingMethod::None;
 484 }
 485 
 486 DragSourceAction DragController::delegateDragSourceAction(const IntPoint&amp; rootViewPoint)
 487 {
<span class="line-modified"> 488     m_dragSourceAction = client().dragSourceActionMaskForPoint(rootViewPoint);</span>
 489     return m_dragSourceAction;
 490 }
 491 
 492 DragOperation DragController::operationForLoad(const DragData&amp; dragData)
 493 {
 494     Document* document = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
 495 
 496     bool pluginDocumentAcceptsDrags = false;
 497 
 498     if (is&lt;PluginDocument&gt;(document)) {
 499         const Widget* widget = downcast&lt;PluginDocument&gt;(*document).pluginWidget();
 500         const PluginViewBase* pluginView = is&lt;PluginViewBase&gt;(widget) ? downcast&lt;PluginViewBase&gt;(widget) : nullptr;
 501 
 502         if (pluginView)
 503             pluginDocumentAcceptsDrags = pluginView-&gt;shouldAllowNavigationFromDrags();
 504     }
 505 
 506     if (document &amp;&amp; (m_didInitiateDrag || (is&lt;PluginDocument&gt;(*document) &amp;&amp; !pluginDocumentAcceptsDrags) || document-&gt;hasEditableStyle()))
 507         return DragOperationNone;
 508     return dragOperation(dragData);
</pre>
<hr />
<pre>
 553         return true;
 554 
 555     if (dragData.containsColor()) {
 556         Color color = dragData.asColor();
 557         if (!color.isValid())
 558             return false;
 559 #if ENABLE(INPUT_TYPE_COLOR)
 560         if (isEnabledColorInput(*element)) {
 561             auto&amp; input = downcast&lt;HTMLInputElement&gt;(*element);
 562             input.setValue(color.serialized(), DispatchInputAndChangeEvent);
 563             return true;
 564         }
 565 #endif
 566         auto innerRange = innerFrame-&gt;selection().toNormalizedRange();
 567         if (!innerRange)
 568             return false;
 569         auto style = MutableStyleProperties::create();
 570         style-&gt;setProperty(CSSPropertyColor, color.serialized(), false);
 571         if (!innerFrame-&gt;editor().shouldApplyStyle(style.ptr(), innerRange.get()))
 572             return false;
<span class="line-modified"> 573         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
 574         innerFrame-&gt;editor().applyStyle(style.ptr(), EditAction::SetColor);
 575         return true;
 576     }
 577 
 578     if (dragData.containsFiles() &amp;&amp; fileInput) {
 579         // fileInput should be the element we hit tested for, unless it was made
 580         // display:none in a drop event handler.
 581         ASSERT(fileInput == element || !fileInput-&gt;renderer());
 582         if (fileInput-&gt;isDisabledFormControl())
 583             return false;
 584 
 585         return fileInput-&gt;receiveDroppedFiles(dragData);
 586     }
 587 
 588     if (!m_page.dragController().canProcessDrag(dragData))
 589         return false;
 590 
 591     VisibleSelection dragCaret = m_page.dragCaretController().caretPosition();
 592     RefPtr&lt;Range&gt; range = dragCaret.toNormalizedRange();
 593     RefPtr&lt;Element&gt; rootEditableElement = innerFrame-&gt;selection().selection().rootEditableElement();
 594 
 595     // For range to be null a WebKit client must have done something bad while
 596     // manually controlling drag behaviour
 597     if (!range)
 598         return false;
 599 
 600     ResourceCacheValidationSuppressor validationSuppressor(range-&gt;ownerDocument().cachedResourceLoader());
 601     auto&amp; editor = innerFrame-&gt;editor();
 602     bool isMove = dragIsMove(innerFrame-&gt;selection(), dragData);
 603     if (isMove || dragCaret.isContentRichlyEditable()) {
 604         bool chosePlainText = false;
 605         RefPtr&lt;DocumentFragment&gt; fragment = documentFragmentFromDragData(dragData, *innerFrame, *range, true, chosePlainText);
 606         if (!fragment || !editor.shouldInsertFragment(*fragment, range.get(), EditorInsertAction::Dropped))
 607             return false;
 608 
<span class="line-modified"> 609         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
 610 
 611         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 612             return true;
 613 
 614         if (isMove) {
 615             // NSTextView behavior is to always smart delete on moving a selection,
 616             // but only to smart insert if the selection granularity is word granularity.
 617             bool smartDelete = editor.smartInsertDeleteEnabled();
 618             bool smartInsert = smartDelete &amp;&amp; innerFrame-&gt;selection().granularity() == WordGranularity &amp;&amp; dragData.canSmartReplace();
 619             MoveSelectionCommand::create(fragment.releaseNonNull(), dragCaret.base(), smartInsert, smartDelete)-&gt;apply();
 620         } else {
 621             if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point)) {
 622                 OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::PreventNesting };
 623                 if (dragData.canSmartReplace())
 624                     options.add(ReplaceSelectionCommand::SmartReplace);
 625                 if (chosePlainText)
 626                     options.add(ReplaceSelectionCommand::MatchStyle);
 627                 ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.releaseNonNull(), options, EditAction::InsertFromDrop)-&gt;apply();
 628             }
 629         }
 630     } else {
 631         String text = dragData.asPlainText();
 632         if (text.isEmpty() || !editor.shouldInsertText(text, range.get(), EditorInsertAction::Dropped))
 633             return false;
 634 
<span class="line-modified"> 635         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
 636         RefPtr&lt;DocumentFragment&gt; fragment = createFragmentFromText(*range, text);
 637         if (!fragment)
 638             return false;
 639 
 640         if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
 641             return true;
 642 
 643         if (setSelectionToDragCaret(innerFrame.get(), dragCaret, range, point))
 644             ReplaceSelectionCommand::create(*m_documentUnderMouse, fragment.get(), { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::MatchStyle, ReplaceSelectionCommand::PreventNesting }, EditAction::InsertFromDrop)-&gt;apply();
 645     }
 646 
 647     if (rootEditableElement) {
 648         if (Frame* frame = rootEditableElement-&gt;document().frame())
 649             frame-&gt;eventHandler().updateDragStateAfterEditDragIfNeeded(*rootEditableElement);
 650     }
 651 
 652     return true;
 653 }
 654 
 655 bool DragController::canProcessDrag(const DragData&amp; dragData)
</pre>
<hr />
<pre>
 936     if (state.type == DragSourceActionDHTML) {
 937         dragImage = DragImage { dataTransfer.createDragImage(dragImageOffset) };
 938         // We allow DHTML/JS to set the drag image, even if its a link, image or text we&#39;re dragging.
 939         // This is in the spirit of the IE API, which allows overriding of pasteboard data and DragOp.
 940         if (dragImage) {
 941             dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, !linkURL.isEmpty());
 942             m_dragOffset = dragImageOffset;
 943         }
 944     }
 945 
 946     if (state.type == DragSourceActionSelection || !imageURL.isEmpty() || !linkURL.isEmpty()) {
 947         // Selection, image, and link drags receive a default set of allowed drag operations that
 948         // follows from:
 949         // http://trac.webkit.org/browser/trunk/WebKit/mac/WebView/WebHTMLView.mm?rev=48526#L3430
 950         m_sourceDragOperation = static_cast&lt;DragOperation&gt;(m_sourceDragOperation | DragOperationGeneric | DragOperationCopy);
 951     }
 952 
 953     ASSERT(state.source);
 954     Element&amp; element = *state.source;
 955 
<span class="line-modified"> 956     bool mustUseLegacyDragClient = hasData == HasNonDefaultPasteboardData::Yes || client().useLegacyDragClient();</span>
 957 
 958     IntRect dragImageBounds;
 959     Image* image = getImage(element);
 960     if (state.type == DragSourceActionSelection) {
 961         PasteboardWriterData pasteboardWriterData;
 962 
 963         if (hasData == HasNonDefaultPasteboardData::No) {
 964             if (src.selection().selection().isNone()) {
 965                 // The page may have cleared out the selection in the dragstart handler, in which case we should bail
 966                 // out of the drag, since there is no content to write to the pasteboard.
 967                 return false;
 968             }
 969 
 970             // FIXME: This entire block is almost identical to the code in Editor::copy, and the code should be shared.
 971             RefPtr&lt;Range&gt; selectionRange = src.selection().toNormalizedRange();
 972             ASSERT(selectionRange);
 973 
 974             src.editor().willWriteSelectionToPasteboard(selectionRange.get());
 975 
 976             if (enclosingTextFormControl(src.selection().selection().start())) {
</pre>
<hr />
<pre>
 982                     plainText.text = src.editor().selectedTextForDataTransfer();
 983                     pasteboardWriterData.setPlainText(WTFMove(plainText));
 984                 }
 985             } else {
 986                 if (mustUseLegacyDragClient) {
 987 #if PLATFORM(COCOA) || PLATFORM(GTK)
 988                     src.editor().writeSelectionToPasteboard(dataTransfer.pasteboard());
 989 #else
 990                     // FIXME: Convert all other platforms to match Mac and delete this.
 991                     dataTransfer.pasteboard().writeSelection(*selectionRange, src.editor().canSmartCopyOrDelete(), src, IncludeImageAltTextForDataTransfer);
 992 #endif
 993                 } else {
 994 #if PLATFORM(COCOA)
 995                     src.editor().writeSelection(pasteboardWriterData);
 996 #endif
 997                 }
 998             }
 999 
1000             src.editor().didWriteSelectionToPasteboard();
1001         }
<span class="line-modified">1002         client().willPerformDragSourceAction(DragSourceActionSelection, dragOrigin, dataTransfer);</span>
1003         if (!dragImage) {
1004             TextIndicatorData textIndicator;
1005             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1006             if (textIndicator.contentImage)
1007                 dragImage.setIndicatorData(textIndicator);
1008             dragLoc = dragLocForSelectionDrag(src);
1009             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1010         }
1011 
1012         if (!dragImage)
1013             return false;
1014 
1015         if (mustUseLegacyDragClient) {
1016             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1017             return true;
1018         }
1019 
1020         DragItem dragItem;
1021         dragItem.imageAnchorPoint = dragImageAnchorPointForSelectionDrag(src, mouseDraggedPoint);
1022         dragItem.image = WTFMove(dragImage);
</pre>
<hr />
<pre>
1034 
1035     if (!imageURL.isEmpty() &amp;&amp; image &amp;&amp; !image-&gt;isNull() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionImage)) {
1036         // We shouldn&#39;t be starting a drag for an image that can&#39;t provide an extension.
1037         // This is an early detection for problems encountered later upon drop.
1038         ASSERT(!image-&gt;filenameExtension().isEmpty());
1039 
1040 #if ENABLE(ATTACHMENT_ELEMENT)
1041         auto attachmentInfo = promisedAttachmentInfo(src, element);
1042 #else
1043         PromisedAttachmentInfo attachmentInfo;
1044 #endif
1045 
1046         if (hasData == HasNonDefaultPasteboardData::No) {
1047             m_draggingImageURL = imageURL;
1048             if (element.isContentRichlyEditable())
1049                 selectElement(element);
1050             if (!attachmentInfo)
1051                 declareAndWriteDragImage(dataTransfer, element, !linkURL.isEmpty() ? linkURL : imageURL, hitTestResult.altDisplayString());
1052         }
1053 
<span class="line-modified">1054         client().willPerformDragSourceAction(DragSourceActionImage, dragOrigin, dataTransfer);</span>
1055 
1056         if (!dragImage)
1057             doImageDrag(element, dragOrigin, hitTestResult.imageRect(), src, m_dragOffset, state, WTFMove(attachmentInfo));
1058         else {
1059             // DHTML defined drag image
1060             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(attachmentInfo));
1061         }
1062 
1063         return true;
1064     }
1065 
1066     if (!linkURL.isEmpty() &amp;&amp; (m_dragSourceAction &amp; DragSourceActionLink)) {
1067         PasteboardWriterData pasteboardWriterData;
1068 
1069         String textContentWithSimplifiedWhiteSpace = hitTestResult.textContent().simplifyWhiteSpace();
1070 
1071         if (hasData == HasNonDefaultPasteboardData::No) {
1072             // Simplify whitespace so the title put on the dataTransfer resembles what the user sees
1073             // on the web page. This includes replacing newlines with spaces.
1074             if (mustUseLegacyDragClient)
</pre>
<hr />
<pre>
1078         } else {
1079             // Make sure the pasteboard also contains trustworthy link data
1080             // but don&#39;t overwrite more general pasteboard types.
1081             PasteboardURL pasteboardURL;
1082             pasteboardURL.url = linkURL;
1083             pasteboardURL.title = hitTestResult.textContent();
1084             dataTransfer.pasteboard().writeTrustworthyWebURLsPboardType(pasteboardURL);
1085         }
1086 
1087         const VisibleSelection&amp; sourceSelection = src.selection().selection();
1088         if (sourceSelection.isCaret() &amp;&amp; sourceSelection.isContentEditable()) {
1089             // a user can initiate a drag on a link without having any text
1090             // selected.  In this case, we should expand the selection to
1091             // the enclosing anchor element
1092             Position pos = sourceSelection.base();
1093             Node* node = enclosingAnchorElement(pos);
1094             if (node)
1095                 src.selection().setSelection(VisibleSelection::selectionFromContentsOfNode(node));
1096         }
1097 
<span class="line-modified">1098         client().willPerformDragSourceAction(DragSourceActionLink, dragOrigin, dataTransfer);</span>
1099         if (!dragImage) {
1100             TextIndicatorData textIndicator;
1101             dragImage = DragImage { createDragImageForLink(element, linkURL, textContentWithSimplifiedWhiteSpace, textIndicator, src.settings().fontRenderingMode(), m_page.deviceScaleFactor()) };
1102             if (dragImage) {
1103                 m_dragOffset = dragOffsetForLinkDragImage(dragImage.get());
1104                 dragLoc = IntPoint(dragOrigin.x() + m_dragOffset.x(), dragOrigin.y() + m_dragOffset.y());
1105                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1106                 if (textIndicator.contentImage)
1107                     dragImage.setIndicatorData(textIndicator);
1108             }
1109         }
1110 
1111         if (mustUseLegacyDragClient) {
1112             doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1113             return true;
1114         }
1115 
1116         DragItem dragItem;
1117         dragItem.imageAnchorPoint = dragImage ? anchorPointForLinkDragImage(dragImage.get()) : FloatPoint();
1118         dragItem.image = WTFMove(dragImage);
</pre>
<hr />
<pre>
1129         auto* attachmentRenderer = attachment.renderer();
1130 
1131         src.editor().setIgnoreSelectionChanges(true);
1132         auto previousSelection = src.selection().selection();
1133         selectElement(element);
1134 
1135         PromisedAttachmentInfo promisedAttachment;
1136         if (hasData == HasNonDefaultPasteboardData::No) {
1137             promisedAttachment = promisedAttachmentInfo(src, attachment);
1138             auto&amp; editor = src.editor();
1139             if (!promisedAttachment &amp;&amp; editor.client()) {
1140 #if PLATFORM(COCOA)
1141                 // Otherwise, if no file URL is specified, call out to the injected bundle to populate the pasteboard with data.
1142                 editor.willWriteSelectionToPasteboard(src.selection().toNormalizedRange().get());
1143                 editor.writeSelectionToPasteboard(dataTransfer.pasteboard());
1144                 editor.didWriteSelectionToPasteboard();
1145 #endif
1146             }
1147         }
1148 
<span class="line-modified">1149         client().willPerformDragSourceAction(DragSourceActionAttachment, dragOrigin, dataTransfer);</span>
1150 
1151         if (!dragImage) {
1152             TextIndicatorData textIndicator;
1153             if (attachmentRenderer)
1154                 attachmentRenderer-&gt;setShouldDrawBorder(false);
1155             dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
1156             if (attachmentRenderer)
1157                 attachmentRenderer-&gt;setShouldDrawBorder(true);
1158             if (textIndicator.contentImage)
1159                 dragImage.setIndicatorData(textIndicator);
1160             dragLoc = dragLocForSelectionDrag(src);
1161             m_dragOffset = IntPoint(dragOrigin.x() - dragLoc.x(), dragOrigin.y() - dragLoc.y());
1162         }
1163         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, WTFMove(promisedAttachment));
1164         if (!element.isContentRichlyEditable())
1165             src.selection().setSelection(previousSelection);
1166         src.editor().setIgnoreSelectionChanges(false);
1167         return true;
1168     }
1169 #endif
1170 
1171 #if ENABLE(INPUT_TYPE_COLOR)
1172     bool isColorControl = is&lt;HTMLInputElement&gt;(state.source) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*state.source).isColorControl();
1173     if (isColorControl &amp;&amp; m_dragSourceAction &amp; DragSourceActionColor) {
1174         auto&amp; input = downcast&lt;HTMLInputElement&gt;(*state.source);
1175         auto color = input.valueAsColor();
1176 
1177         Path visiblePath;
1178         dragImage = DragImage { createDragImageForColor(color, input.boundsInRootViewSpace(), input.document().page()-&gt;pageScaleFactor(), visiblePath) };
1179         dragImage.setVisiblePath(visiblePath);
1180         dataTransfer.pasteboard().write(color);
1181         dragImageOffset = IntPoint { dragImageSize(dragImage.get()) };
1182         dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, false);
1183 
<span class="line-modified">1184         client().willPerformDragSourceAction(DragSourceActionColor, dragOrigin, dataTransfer);</span>
1185         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1186         return true;
1187     }
1188 #endif
1189 
1190     if (state.type == DragSourceActionDHTML &amp;&amp; dragImage) {
1191         ASSERT(m_dragSourceAction &amp; DragSourceActionDHTML);
<span class="line-modified">1192         client().willPerformDragSourceAction(DragSourceActionDHTML, dragOrigin, dataTransfer);</span>
1193         doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
1194         return true;
1195     }
1196 
1197     return false;
1198 }
1199 
1200 void DragController::doImageDrag(Element&amp; element, const IntPoint&amp; dragOrigin, const IntRect&amp; layoutRect, Frame&amp; frame, IntPoint&amp; dragImageOffset, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; attachmentInfo)
1201 {
1202     IntPoint mouseDownPoint = dragOrigin;
1203     DragImage dragImage;
1204     IntPoint scaledOrigin;
1205 
1206     if (!element.renderer())
1207         return;
1208 
1209     ImageOrientation orientation = element.renderer()-&gt;imageOrientation();
1210 
1211     Image* image = getImage(element);
1212     if (image &amp;&amp; !layoutRect.isEmpty() &amp;&amp; shouldUseCachedImageForDragImage(*image) &amp;&amp; (dragImage = DragImage { createDragImageFromImage(image, orientation) })) {
</pre>
<hr />
<pre>
1228         scaledOrigin = IntPoint((int)(dx + 0.5), (int)(dy + 0.5));
1229     } else {
1230         if (CachedImage* cachedImage = getCachedImage(element)) {
1231             dragImage = DragImage { createDragImageIconForCachedImageFilename(cachedImage-&gt;response().suggestedFilename()) };
1232             if (dragImage) {
1233                 dragImage = DragImage { platformAdjustDragImageForDeviceScaleFactor(dragImage.get(), m_page.deviceScaleFactor()) };
1234                 scaledOrigin = IntPoint(DragIconRightInset - dragImageSize(dragImage.get()).width(), DragIconBottomInset);
1235             }
1236         }
1237     }
1238 
1239     if (!dragImage)
1240         return;
1241 
1242     dragImageOffset = mouseDownPoint + scaledOrigin;
1243     doSystemDrag(WTFMove(dragImage), dragImageOffset, dragOrigin, frame, state, WTFMove(attachmentInfo));
1244 }
1245 
1246 void DragController::beginDrag(DragItem dragItem, Frame&amp; frame, const IntPoint&amp; mouseDownPoint, const IntPoint&amp; mouseDraggedPoint, DataTransfer&amp; dataTransfer, DragSourceAction dragSourceAction)
1247 {
<span class="line-modified">1248     ASSERT(!client().useLegacyDragClient());</span>
1249 
1250     m_didInitiateDrag = true;
1251     m_dragInitiator = frame.document();
1252 
1253     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1254     Ref&lt;Frame&gt; mainFrameProtector(m_page.mainFrame());
1255     RefPtr&lt;FrameView&gt; viewProtector = mainFrameProtector-&gt;view();
1256 
1257     auto mouseDownPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDownPoint));
1258     auto mouseDraggedPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDraggedPoint));
1259 
<span class="line-modified">1260     client().beginDrag(WTFMove(dragItem), frame, mouseDownPointInRootViewCoordinates, mouseDraggedPointInRootViewCoordinates, dataTransfer, dragSourceAction);</span>
1261 }
1262 
1263 void DragController::doSystemDrag(DragImage image, const IntPoint&amp; dragLoc, const IntPoint&amp; eventPos, Frame&amp; frame, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; promisedAttachmentInfo)
1264 {
1265     m_didInitiateDrag = true;
1266     m_dragInitiator = frame.document();
1267     // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
1268     Ref&lt;Frame&gt; frameProtector(m_page.mainFrame());
1269     RefPtr&lt;FrameView&gt; viewProtector = frameProtector-&gt;view();
1270 
1271     DragItem item;
1272     item.image = WTFMove(image);
1273     item.sourceAction = state.type;
1274     item.promisedAttachmentInfo = WTFMove(promisedAttachmentInfo);
1275 
1276     auto eventPositionInRootViewCoordinates = frame.view()-&gt;contentsToRootView(eventPos);
1277     auto dragLocationInRootViewCoordinates = frame.view()-&gt;contentsToRootView(dragLoc);
1278     item.eventPositionInContentCoordinates = viewProtector-&gt;rootViewToContents(eventPositionInRootViewCoordinates);
1279     item.dragLocationInContentCoordinates = viewProtector-&gt;rootViewToContents(dragLocationInRootViewCoordinates);
1280     item.dragLocationInWindowCoordinates = viewProtector-&gt;contentsToWindow(item.dragLocationInContentCoordinates);
</pre>
<hr />
<pre>
1296             item.dragPreviewFrameInRootViewCoordinates = element-&gt;boundsInRootViewSpace();
1297         }
1298 
1299         RefPtr&lt;Element&gt; link;
1300         if (element-&gt;isLink())
1301             link = element;
1302         else {
1303             for (auto&amp; currentElement : elementLineage(element.get())) {
1304                 if (currentElement.isLink()) {
1305                     link = &amp;currentElement;
1306                     break;
1307                 }
1308             }
1309         }
1310         if (link) {
1311             auto titleAttribute = link-&gt;attributeWithoutSynchronization(HTMLNames::titleAttr);
1312             item.title = titleAttribute.isEmpty() ? link-&gt;innerText() : titleAttribute.string();
1313             item.url = frame.document()-&gt;completeURL(stripLeadingAndTrailingHTMLSpaces(link-&gt;getAttribute(HTMLNames::hrefAttr)));
1314         }
1315     }
<span class="line-modified">1316     client().startDrag(WTFMove(item), *state.dataTransfer, frameProtector.get());</span>
1317     // DragClient::startDrag can cause our Page to dispear, deallocating |this|.
1318     if (!frameProtector-&gt;page())
1319         return;
1320 
1321     cleanupAfterSystemDrag();
1322 }
1323 
<span class="line-added">1324 void DragController::removeAllDroppedImagePlaceholders()</span>
<span class="line-added">1325 {</span>
<span class="line-added">1326     m_droppedImagePlaceholderRange = nullptr;</span>
<span class="line-added">1327     for (auto&amp; placeholder : std::exchange(m_droppedImagePlaceholders, { })) {</span>
<span class="line-added">1328         if (placeholder-&gt;isConnected())</span>
<span class="line-added">1329             placeholder-&gt;remove();</span>
<span class="line-added">1330     }</span>
<span class="line-added">1331 }</span>
<span class="line-added">1332 </span>
<span class="line-added">1333 bool DragController::tryToUpdateDroppedImagePlaceholders(const DragData&amp; dragData)</span>
<span class="line-added">1334 {</span>
<span class="line-added">1335     ASSERT(!m_droppedImagePlaceholders.isEmpty());</span>
<span class="line-added">1336     ASSERT(m_droppedImagePlaceholderRange);</span>
<span class="line-added">1337 </span>
<span class="line-added">1338     auto document = makeRef(m_droppedImagePlaceholders[0]-&gt;document());</span>
<span class="line-added">1339     auto frame = makeRefPtr(document-&gt;frame());</span>
<span class="line-added">1340     if (!frame)</span>
<span class="line-added">1341         return false;</span>
<span class="line-added">1342 </span>
<span class="line-added">1343     WebContentReader reader(*frame, *m_droppedImagePlaceholderRange, true);</span>
<span class="line-added">1344     auto pasteboard = Pasteboard::createForDragAndDrop(dragData);</span>
<span class="line-added">1345     pasteboard-&gt;read(reader);</span>
<span class="line-added">1346 </span>
<span class="line-added">1347     if (!reader.fragment)</span>
<span class="line-added">1348         return false;</span>
<span class="line-added">1349 </span>
<span class="line-added">1350     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; imageElements;</span>
<span class="line-added">1351     for (auto&amp; imageElement : descendantsOfType&lt;HTMLImageElement&gt;(*reader.fragment))</span>
<span class="line-added">1352         imageElements.append(imageElement);</span>
<span class="line-added">1353 </span>
<span class="line-added">1354     if (imageElements.size() != m_droppedImagePlaceholders.size()) {</span>
<span class="line-added">1355         ASSERT_NOT_REACHED();</span>
<span class="line-added">1356         return false;</span>
<span class="line-added">1357     }</span>
<span class="line-added">1358 </span>
<span class="line-added">1359     for (size_t i = 0; i &lt; imageElements.size(); ++i) {</span>
<span class="line-added">1360         auto&amp; imageElement = imageElements[i];</span>
<span class="line-added">1361         auto&amp; placeholder = m_droppedImagePlaceholders[i];</span>
<span class="line-added">1362         placeholder-&gt;setAttributeWithoutSynchronization(HTMLNames::srcAttr, imageElement-&gt;attributeWithoutSynchronization(HTMLNames::srcAttr));</span>
<span class="line-added">1363 #if ENABLE(ATTACHMENT_ELEMENT)</span>
<span class="line-added">1364         if (auto attachment = imageElement-&gt;attachmentElement())</span>
<span class="line-added">1365             placeholder-&gt;setAttachmentElement(attachment.releaseNonNull());</span>
<span class="line-added">1366 #endif</span>
<span class="line-added">1367     }</span>
<span class="line-added">1368     return true;</span>
<span class="line-added">1369 }</span>
<span class="line-added">1370 </span>
<span class="line-added">1371 void DragController::insertDroppedImagePlaceholdersAtCaret(const Vector&lt;IntSize&gt;&amp; imageSizes)</span>
<span class="line-added">1372 {</span>
<span class="line-added">1373     auto&amp; caretController = m_page.dragCaretController();</span>
<span class="line-added">1374     if (!caretController.isContentRichlyEditable())</span>
<span class="line-added">1375         return;</span>
<span class="line-added">1376 </span>
<span class="line-added">1377     auto dropCaret = caretController.caretPosition();</span>
<span class="line-added">1378     if (dropCaret.isNull())</span>
<span class="line-added">1379         return;</span>
<span class="line-added">1380 </span>
<span class="line-added">1381     auto document = makeRefPtr(dropCaret.deepEquivalent().document());</span>
<span class="line-added">1382     if (!document)</span>
<span class="line-added">1383         return;</span>
<span class="line-added">1384 </span>
<span class="line-added">1385     auto frame = makeRefPtr(document-&gt;frame());</span>
<span class="line-added">1386     if (!frame)</span>
<span class="line-added">1387         return;</span>
<span class="line-added">1388 </span>
<span class="line-added">1389     TemporarySelectionChange selectionChange(*frame, WTF::nullopt, { TemporarySelectionOption::IgnoreSelectionChanges });</span>
<span class="line-added">1390 </span>
<span class="line-added">1391     auto fragment = DocumentFragment::create(*document);</span>
<span class="line-added">1392     for (auto&amp; size : imageSizes) {</span>
<span class="line-added">1393         ASSERT(!size.isEmpty());</span>
<span class="line-added">1394         auto image = HTMLImageElement::create(*document);</span>
<span class="line-added">1395         image-&gt;setAttributeWithoutSynchronization(HTMLNames::widthAttr, AtomString::number(size.width()));</span>
<span class="line-added">1396         image-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(size.height()));</span>
<span class="line-added">1397         image-&gt;setInlineStyleProperty(CSSPropertyMaxWidth, 100, CSSUnitType::CSS_PERCENTAGE);</span>
<span class="line-added">1398         image-&gt;setInlineStyleProperty(CSSPropertyBackgroundColor, Color(Color::black).colorWithAlpha(0.05).cssText());</span>
<span class="line-added">1399         image-&gt;setIsDroppedImagePlaceholder();</span>
<span class="line-added">1400         fragment-&gt;appendChild(WTFMove(image));</span>
<span class="line-added">1401     }</span>
<span class="line-added">1402 </span>
<span class="line-added">1403     frame-&gt;selection().setSelection(dropCaret);</span>
<span class="line-added">1404 </span>
<span class="line-added">1405     auto command = ReplaceSelectionCommand::create(*document, WTFMove(fragment), { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SmartReplace }, EditAction::InsertFromDrop);</span>
<span class="line-added">1406     command-&gt;apply();</span>
<span class="line-added">1407 </span>
<span class="line-added">1408     auto insertedContentRange = command-&gt;insertedContentRange();</span>
<span class="line-added">1409     if (!insertedContentRange) {</span>
<span class="line-added">1410         ASSERT_NOT_REACHED();</span>
<span class="line-added">1411         return;</span>
<span class="line-added">1412     }</span>
<span class="line-added">1413 </span>
<span class="line-added">1414     auto container = makeRefPtr(insertedContentRange-&gt;commonAncestorContainer());</span>
<span class="line-added">1415     if (!is&lt;ContainerNode&gt;(container)) {</span>
<span class="line-added">1416         ASSERT_NOT_REACHED();</span>
<span class="line-added">1417         return;</span>
<span class="line-added">1418     }</span>
<span class="line-added">1419 </span>
<span class="line-added">1420     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; placeholders;</span>
<span class="line-added">1421     for (auto&amp; placeholder : descendantsOfType&lt;HTMLImageElement&gt;(downcast&lt;ContainerNode&gt;(*container))) {</span>
<span class="line-added">1422         auto intersectsNode = insertedContentRange-&gt;intersectsNode(placeholder);</span>
<span class="line-added">1423         if (!intersectsNode.hasException() &amp;&amp; intersectsNode.returnValue())</span>
<span class="line-added">1424             placeholders.append(placeholder);</span>
<span class="line-added">1425     }</span>
<span class="line-added">1426 </span>
<span class="line-added">1427     if (placeholders.size() != imageSizes.size()) {</span>
<span class="line-added">1428         ASSERT_NOT_REACHED();</span>
<span class="line-added">1429         return;</span>
<span class="line-added">1430     }</span>
<span class="line-added">1431 </span>
<span class="line-added">1432     for (size_t i = 0; i &lt; placeholders.size(); ++i) {</span>
<span class="line-added">1433         auto&amp; placeholder = placeholders[i];</span>
<span class="line-added">1434         auto imageSize = imageSizes[i];</span>
<span class="line-added">1435         double clientWidth = placeholder-&gt;clientWidth();</span>
<span class="line-added">1436         double heightRespectingAspectRatio = (imageSize.height() * clientWidth) / imageSize.width();</span>
<span class="line-added">1437         placeholder-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(heightRespectingAspectRatio));</span>
<span class="line-added">1438     }</span>
<span class="line-added">1439 </span>
<span class="line-added">1440     document-&gt;updateLayout();</span>
<span class="line-added">1441 </span>
<span class="line-added">1442     m_droppedImagePlaceholders = WTFMove(placeholders);</span>
<span class="line-added">1443     m_droppedImagePlaceholderRange = WTFMove(insertedContentRange);</span>
<span class="line-added">1444 </span>
<span class="line-added">1445     frame-&gt;selection().clear();</span>
<span class="line-added">1446     caretController.setCaretPosition(m_droppedImagePlaceholderRange-&gt;startPosition());</span>
<span class="line-added">1447 }</span>
<span class="line-added">1448 </span>
<span class="line-added">1449 void DragController::finalizeDroppedImagePlaceholder(HTMLImageElement&amp; placeholder)</span>
<span class="line-added">1450 {</span>
<span class="line-added">1451     ASSERT(placeholder.isDroppedImagePlaceholder());</span>
<span class="line-added">1452     placeholder.removeAttribute(HTMLNames::heightAttr);</span>
<span class="line-added">1453     placeholder.removeInlineStyleProperty(CSSPropertyBackgroundColor);</span>
<span class="line-added">1454 }</span>
<span class="line-added">1455 </span>
1456 // Manual drag caret manipulation
1457 void DragController::placeDragCaret(const IntPoint&amp; windowPoint)
1458 {
1459     mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(windowPoint));
1460     if (!m_documentUnderMouse)
1461         return;
1462     Frame* frame = m_documentUnderMouse-&gt;frame();
1463     FrameView* frameView = frame-&gt;view();
1464     if (!frameView)
1465         return;
1466     IntPoint framePoint = frameView-&gt;windowToContents(windowPoint);
1467 
1468     m_page.dragCaretController().setCaretPosition(frame-&gt;visiblePositionForPoint(framePoint));
1469 }
1470 
1471 bool DragController::shouldUseCachedImageForDragImage(const Image&amp; image) const
1472 {
1473 #if ENABLE(DATA_INTERACTION)
1474     UNUSED_PARAM(image);
1475     return true;
</pre>
</td>
</tr>
</table>
<center><a href="DragClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DragController.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
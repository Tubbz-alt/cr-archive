<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameLoadRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  *     its contributors may be used to endorse or promote products derived
  21  *     from this software without specific prior written permission.
  22  *
  23  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  24  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  27  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;

  40 #include &quot;BackForwardController.h&quot;
  41 #include &quot;BeforeUnloadEvent.h&quot;
  42 #include &quot;CachedPage.h&quot;
  43 #include &quot;CachedResourceLoader.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ContentFilter.h&quot;
  48 #include &quot;ContentRuleListResults.h&quot;
  49 #include &quot;ContentSecurityPolicy.h&quot;
  50 #include &quot;CustomHeaderFields.h&quot;
  51 #include &quot;DOMWindow.h&quot;
  52 #include &quot;DatabaseManager.h&quot;
  53 #include &quot;DiagnosticLoggingClient.h&quot;
  54 #include &quot;DiagnosticLoggingKeys.h&quot;
  55 #include &quot;Document.h&quot;
  56 #include &quot;DocumentLoader.h&quot;
  57 #include &quot;Editor.h&quot;
  58 #include &quot;EditorClient.h&quot;
  59 #include &quot;Element.h&quot;
  60 #include &quot;Event.h&quot;
  61 #include &quot;EventHandler.h&quot;
  62 #include &quot;EventNames.h&quot;
  63 #include &quot;FloatRect.h&quot;
  64 #include &quot;FormState.h&quot;
  65 #include &quot;FormSubmission.h&quot;
  66 #include &quot;Frame.h&quot;
  67 #include &quot;FrameLoadRequest.h&quot;
  68 #include &quot;FrameLoaderClient.h&quot;
  69 #include &quot;FrameNetworkingContext.h&quot;
  70 #include &quot;FrameTree.h&quot;
  71 #include &quot;FrameView.h&quot;
  72 #include &quot;GCController.h&quot;
  73 #include &quot;HTMLFormElement.h&quot;
  74 #include &quot;HTMLInputElement.h&quot;
  75 #include &quot;HTMLNames.h&quot;
  76 #include &quot;HTMLObjectElement.h&quot;
  77 #include &quot;HTMLParserIdioms.h&quot;
  78 #include &quot;HTTPHeaderNames.h&quot;

  79 #include &quot;HTTPParsers.h&quot;
  80 #include &quot;HistoryController.h&quot;
  81 #include &quot;HistoryItem.h&quot;
  82 #include &quot;IgnoreOpensDuringUnloadCountIncrementer.h&quot;
  83 #include &quot;InspectorController.h&quot;
  84 #include &quot;InspectorInstrumentation.h&quot;
  85 #include &quot;LinkLoader.h&quot;
  86 #include &quot;LoadTiming.h&quot;
  87 #include &quot;LoaderStrategy.h&quot;
  88 #include &quot;Logging.h&quot;
  89 #include &quot;MemoryCache.h&quot;
  90 #include &quot;MemoryRelease.h&quot;
  91 #include &quot;NavigationDisabler.h&quot;
  92 #include &quot;NavigationScheduler.h&quot;
  93 #include &quot;Node.h&quot;
  94 #include &quot;Page.h&quot;
<span class="line-removed">  95 #include &quot;PageCache.h&quot;</span>
  96 #include &quot;PageTransitionEvent.h&quot;
  97 #include &quot;PerformanceLogging.h&quot;
  98 #include &quot;PlatformStrategies.h&quot;
  99 #include &quot;PluginData.h&quot;
 100 #include &quot;PluginDocument.h&quot;
 101 #include &quot;PolicyChecker.h&quot;
 102 #include &quot;ProgressTracker.h&quot;
 103 #include &quot;ResourceHandle.h&quot;
 104 #include &quot;ResourceLoadInfo.h&quot;
 105 #include &quot;ResourceLoadObserver.h&quot;
 106 #include &quot;ResourceRequest.h&quot;
 107 #include &quot;SVGDocument.h&quot;
 108 #include &quot;SVGLocatable.h&quot;
 109 #include &quot;SVGNames.h&quot;
 110 #include &quot;SVGViewElement.h&quot;
 111 #include &quot;SVGViewSpec.h&quot;
 112 #include &quot;ScriptController.h&quot;
 113 #include &quot;ScriptSourceCode.h&quot;
 114 #include &quot;ScrollAnimator.h&quot;
 115 #include &quot;SecurityOrigin.h&quot;
</pre>
<hr />
<pre>
 133 #include &lt;wtf/SetForScope.h&gt;
 134 #include &lt;wtf/StdLibExtras.h&gt;
 135 #include &lt;wtf/SystemTracing.h&gt;
 136 #include &lt;wtf/text/CString.h&gt;
 137 #include &lt;wtf/text/WTFString.h&gt;
 138 
 139 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 140 #include &quot;Archive.h&quot;
 141 #endif
 142 
 143 #if ENABLE(DATA_DETECTION)
 144 #include &quot;DataDetection.h&quot;
 145 #endif
 146 
 147 #if PLATFORM(IOS_FAMILY)
 148 #include &quot;DocumentType.h&quot;
 149 #include &quot;ResourceLoader.h&quot;
 150 #include &quot;RuntimeApplicationChecks.h&quot;
 151 #endif
 152 
<span class="line-modified"> 153 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - FrameLoader::&quot; fmt, this, ##__VA_ARGS__)</span>



 154 
 155 namespace WebCore {
 156 
 157 using namespace HTMLNames;
 158 using namespace SVGNames;
 159 
 160 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 161 
 162 bool isBackForwardLoadType(FrameLoadType type)
 163 {
 164     switch (type) {
 165     case FrameLoadType::Standard:
 166     case FrameLoadType::Reload:
 167     case FrameLoadType::ReloadFromOrigin:
 168     case FrameLoadType::ReloadExpiredOnly:
 169     case FrameLoadType::Same:
 170     case FrameLoadType::RedirectWithLockedBackForwardList:
 171     case FrameLoadType::Replace:
 172         return false;
 173     case FrameLoadType::Back:
</pre>
<hr />
<pre>
 193     case FrameLoadType::Back:
 194     case FrameLoadType::Forward:
 195     case FrameLoadType::IndexedBackForward:
 196         return false;
 197     }
 198     ASSERT_NOT_REACHED();
 199     return false;
 200 }
 201 
 202 // This is not in the FrameLoader class to emphasize that it does not depend on
 203 // private FrameLoader data, and to avoid increasing the number of public functions
 204 // with access to private data.  Since only this .cpp file needs it, making it
 205 // non-member lets us exclude it from the header file, thus keeping FrameLoader.h&#39;s
 206 // API simpler.
 207 //
 208 static bool isDocumentSandboxed(Frame&amp; frame, SandboxFlags mask)
 209 {
 210     return frame.document() &amp;&amp; frame.document()-&gt;isSandboxed(mask);
 211 }
 212 
<span class="line-modified"> 213 struct ForbidPromptsScope {</span>
<span class="line-modified"> 214     ForbidPromptsScope(Page* page) : m_page(page)</span>


 215     {
<span class="line-modified"> 216         if (!m_page)</span>
<span class="line-modified"> 217             return;</span>
<span class="line-modified"> 218         m_page-&gt;forbidPrompts();</span>










 219     }
 220 
 221     ~ForbidPromptsScope()
 222     {
<span class="line-modified"> 223         if (!m_page)</span>
<span class="line-modified"> 224             return;</span>
<span class="line-removed"> 225         m_page-&gt;allowPrompts();</span>
 226     }

 227 
<span class="line-modified"> 228     Page* m_page;</span>












 229 };
 230 
 231 class FrameLoader::FrameProgressTracker {
 232     WTF_MAKE_FAST_ALLOCATED;
 233 public:
 234     explicit FrameProgressTracker(Frame&amp; frame)
 235         : m_frame(frame)
 236         , m_inProgress(false)
 237     {
 238     }
 239 
 240     ~FrameProgressTracker()
 241     {
 242         if (m_inProgress &amp;&amp; m_frame.page())
 243             m_frame.page()-&gt;progress().progressCompleted(m_frame);
 244     }
 245 
 246     void progressStarted()
 247     {
 248         ASSERT(m_frame.page());
 249         if (!m_inProgress)
 250             m_frame.page()-&gt;progress().progressStarted(m_frame);
 251         m_inProgress = true;
 252     }
 253 
 254     void progressCompleted()
 255     {
 256         ASSERT(m_inProgress);
 257         ASSERT(m_frame.page());
 258         m_inProgress = false;
 259         m_frame.page()-&gt;progress().progressCompleted(m_frame);
<span class="line-modified"> 260 </span>
<span class="line-removed"> 261         if (auto pageID = m_frame.loader().client().pageID())</span>
<span class="line-removed"> 262             platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(pageID.value());</span>
 263     }
 264 
 265 private:
 266     Frame&amp; m_frame;
 267     bool m_inProgress;
 268 };
 269 
 270 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 271     : m_frame(frame)
 272     , m_client(client)
 273     , m_policyChecker(makeUnique&lt;PolicyChecker&gt;(frame))
 274     , m_history(makeUnique&lt;HistoryController&gt;(frame))
 275     , m_notifier(frame)
 276     , m_subframeLoader(makeUnique&lt;SubframeLoader&gt;(frame))
 277     , m_mixedContentChecker(frame)
 278     , m_state(FrameStateProvisional)
 279     , m_loadType(FrameLoadType::Standard)
 280     , m_quickRedirectComing(false)
 281     , m_sentRedirectNotification(false)
 282     , m_inStopAllLoaders(false)
 283     , m_isExecutingJavaScriptFormAction(false)
 284     , m_didCallImplicitClose(true)
 285     , m_wasUnloadEventEmitted(false)
 286     , m_isComplete(false)
 287     , m_needsClear(false)
 288     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 289     , m_shouldCallCheckCompleted(false)
 290     , m_shouldCallCheckLoadComplete(false)
 291     , m_opener(nullptr)
 292     , m_loadingFromCachedPage(false)
 293     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 294     , m_loadsSynchronously(false)
 295     , m_forcedSandboxFlags(SandboxNone)
 296 {
 297 }
 298 
 299 FrameLoader::~FrameLoader()
 300 {
 301     setOpener(nullptr);
<span class="line-modified"> 302 </span>
<span class="line-removed"> 303     for (auto&amp; frame : m_openedFrames)</span>
<span class="line-removed"> 304         frame-&gt;loader().m_opener = nullptr;</span>
 305 
 306     m_client.frameLoaderDestroyed();
 307 
 308     if (m_networkingContext)
 309         m_networkingContext-&gt;invalidate();
 310 }
 311 







 312 void FrameLoader::init()
 313 {
 314     // This somewhat odd set of steps gives the frame an initial empty document.
 315     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 316     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 317     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 318 
 319     Ref&lt;Frame&gt; protect(m_frame);
 320     m_frame.document()-&gt;cancelParsing();
 321     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 322 
 323     m_networkingContext = m_client.createNetworkingContext();
 324     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);
 325 }
 326 
 327 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 328 {
 329     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 330     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 331 
</pre>
<hr />
<pre>
 376     // FIXME: Validate the policy check identifier.
 377     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, activeDocumentLoader()-&gt;downloadAttribute(), WTFMove(function));
 378 }
 379 
 380 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 381 {
 382     urlSelected(WTFMove(request), nullptr);
 383 }
 384 
 385 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 386 {
 387     auto* frame = lexicalFrameFromCommonVM();
 388     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 389 
 390     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 391     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 392 }
 393 
 394 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 395 {
<span class="line-modified"> 396     RELEASE_LOG_IF_ALLOWED(&quot;urlSelected: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
 397 
 398     Ref&lt;Frame&gt; protect(m_frame);
 399 
<span class="line-modified"> 400     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), frameRequest.shouldReplaceDocumentIfJavaScriptURL()))</span>

 401         return;

 402 
 403     if (frameRequest.frameName().isEmpty())
 404         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 405 
 406     addHTTPOriginIfNeeded(frameRequest.resourceRequest(), outgoingOrigin());
 407     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(frameRequest.resourceRequest(), ContentSecurityPolicy::InsecureRequestType::Navigation);
 408 
 409     loadFrameRequest(WTFMove(frameRequest), triggeringEvent, { }, WTFMove(adClickAttribution));
 410 }
 411 
 412 void FrameLoader::submitForm(Ref&lt;FormSubmission&gt;&amp;&amp; submission)
 413 {
 414     ASSERT(submission-&gt;method() == FormSubmission::Method::Post || submission-&gt;method() == FormSubmission::Method::Get);
 415 
 416     // FIXME: Find a good spot for these.
 417     ASSERT(!submission-&gt;state().sourceDocument().frame() || submission-&gt;state().sourceDocument().frame() == &amp;m_frame);
 418 
 419     if (!m_frame.page())
 420         return;
 421 
 422     if (submission-&gt;action().isEmpty())
 423         return;
 424 
 425     if (isDocumentSandboxed(m_frame, SandboxForms)) {
 426         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
 427         m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked form submission to &#39;&quot; + submission-&gt;action().stringCenterEllipsizedToLength() + &quot;&#39; because the form&#39;s frame is sandboxed and the &#39;allow-forms&#39; permission is not set.&quot;);
 428         return;
 429     }
 430 
 431     if (WTF::protocolIsJavaScript(submission-&gt;action())) {
 432         if (!m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(URL(submission-&gt;action())))
 433             return;
 434         m_isExecutingJavaScriptFormAction = true;
 435         Ref&lt;Frame&gt; protect(m_frame);
<span class="line-modified"> 436         m_frame.script().executeIfJavaScriptURL(submission-&gt;action(), DoNotReplaceDocumentIfJavaScriptURL);</span>
 437         m_isExecutingJavaScriptFormAction = false;
 438         return;
 439     }
 440 
 441     Frame* targetFrame = findFrameForNavigation(submission-&gt;target(), &amp;submission-&gt;state().sourceDocument());
 442     if (!targetFrame) {
 443         if (!DOMWindow::allowPopUp(m_frame) &amp;&amp; !UserGestureIndicator::processingUserGesture())
 444             return;
 445 
 446         // FIXME: targetFrame can be null for two distinct reasons:
 447         // 1. The frame was not found by name, so we should try opening a new window.
 448         // 2. The frame was found, but navigating it was not allowed, e.g. by HTML5 sandbox or by origin checks.
 449         // Continuing form submission makes no sense in the latter case.
 450         // There is a repeat check after timer fires, so this is not a correctness issue.
 451 
 452         targetFrame = &amp;m_frame;
 453     } else
 454         submission-&gt;clearTarget();
 455 
 456     if (!targetFrame-&gt;page())
 457         return;
 458 
<span class="line-modified"> 459     // FIXME: We&#39;d like to remove this altogether and fix the multiple form submission issue another way.</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461     // We do not want to submit more than one form from the same page, nor do we want to submit a single</span>
<span class="line-removed"> 462     // form more than once. This flag prevents these from happening; not sure how other browsers prevent this.</span>
<span class="line-removed"> 463     // The flag is reset in each time we start dispatching a new mouse or key down event, and</span>
<span class="line-removed"> 464     // also in setView since this part may get reused for a page from the back/forward cache.</span>
<span class="line-removed"> 465     // The form multi-submit logic here is only needed when we are submitting a form that affects this frame.</span>
<span class="line-removed"> 466 </span>
<span class="line-removed"> 467     // FIXME: Frame targeting is only one of the ways the submission could end up doing something other</span>
<span class="line-removed"> 468     // than replacing this frame&#39;s content, so this check is flawed. On the other hand, the check is hardly</span>
<span class="line-removed"> 469     // needed any more now that we reset m_submittedFormURL on each mouse or key down event.</span>
<span class="line-removed"> 470 </span>
<span class="line-removed"> 471     if (m_frame.tree().isDescendantOf(targetFrame)) {</span>
<span class="line-removed"> 472         if (m_submittedFormURL == submission-&gt;requestURL())</span>
<span class="line-removed"> 473             return;</span>
 474         m_submittedFormURL = submission-&gt;requestURL();
<span class="line-removed"> 475     }</span>
 476 
 477     submission-&gt;setReferrer(outgoingReferrer());
 478     submission-&gt;setOrigin(outgoingOrigin());
 479 
 480     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 481 }
 482 
 483 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 484 {
 485     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 486         m_frame.document()-&gt;parser()-&gt;stopParsing();
 487 
 488     if (unloadEventPolicy != UnloadEventPolicyNone)
 489         dispatchUnloadEvents(unloadEventPolicy);
 490 
 491     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 492     m_didCallImplicitClose = true; // don&#39;t want that one either
 493 
 494     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 495         finishedParsing();
</pre>
<hr />
<pre>
 526     if (m_frame.editor().hasComposition()) {
 527         // The text was already present in DOM, so it&#39;s better to confirm than to cancel the composition.
 528         m_frame.editor().confirmComposition();
 529         if (EditorClient* editorClient = m_frame.editor().client()) {
 530             editorClient-&gt;respondToChangedSelection(&amp;m_frame);
 531             editorClient-&gt;discardedComposition(&amp;m_frame);
 532         }
 533     }
 534 }
 535 
 536 bool FrameLoader::closeURL()
 537 {
 538     history().saveDocumentState();
 539 
 540     Document* currentDocument = m_frame.document();
 541     UnloadEventPolicy unloadEventPolicy;
 542     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;chrome().client().isSVGImageChromeClient()) {
 543         // If this is the SVGDocument of an SVGImage, no need to dispatch events or recalcStyle.
 544         unloadEventPolicy = UnloadEventPolicyNone;
 545     } else {
<span class="line-modified"> 546         // Should only send the pagehide event here if the current document exists and has not been placed in the page cache.</span>
<span class="line-modified"> 547         unloadEventPolicy = currentDocument &amp;&amp; currentDocument-&gt;pageCacheState() == Document::NotInPageCache ? UnloadEventPolicyUnloadAndPageHide : UnloadEventPolicyUnloadOnly;</span>
 548     }
 549 
 550     stopLoading(unloadEventPolicy);
 551 
 552     m_frame.editor().clearUndoRedoOperations();
 553     return true;
 554 }
 555 
 556 bool FrameLoader::didOpenURL()
 557 {
 558     if (m_frame.navigationScheduler().redirectScheduledDuringLoad()) {
 559         // A redirect was scheduled before the document was created.
 560         // This can happen when one frame changes another frame&#39;s location.
 561         return false;
 562     }
 563 
 564     m_frame.navigationScheduler().cancel();
 565     m_frame.editor().clearLastEditCommand();
 566 
 567     m_isComplete = false;
</pre>
<hr />
<pre>
 573     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 574         DOMWindow* window = m_frame.document()-&gt;domWindow();
 575         window-&gt;setStatus(String());
 576         window-&gt;setDefaultStatus(String());
 577     }
 578 
 579     started();
 580 
 581     return true;
 582 }
 583 
 584 void FrameLoader::didExplicitOpen()
 585 {
 586     m_isComplete = false;
 587     m_didCallImplicitClose = false;
 588 
 589     // Calling document.open counts as committing the first real document load.
 590     if (!m_stateMachine.committedFirstRealDocumentLoad())
 591         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 592 
<span class="line-modified"> 593     m_client.dispatchDidExplicitOpen(m_frame.document() ? m_frame.document()-&gt;url() : URL());</span>

 594 
 595     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 596     // from a subsequent window.document.open / window.document.write call.
 597     // Canceling redirection here works for all cases because document.open
 598     // implicitly precedes document.write.
 599     m_frame.navigationScheduler().cancel();
 600 }
 601 
 602 
 603 void FrameLoader::cancelAndClear()
 604 {
 605     m_frame.navigationScheduler().cancel();
 606 
 607     if (!m_isComplete)
 608         closeURL();
 609 
 610     clear(m_frame.document(), false);
 611     m_frame.script().updatePlatformScriptObjects();
 612 }
 613 
 614 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 615 {
 616     if (!frame.isMainFrame())
 617         return false;
 618 
 619     if (frame.loader().opener())
 620         return false;
 621 
 622     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 623 }
 624 
 625 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation)
 626 {
 627     m_frame.editor().clear();
 628 
 629     bool neededClear = m_needsClear;
 630     m_needsClear = false;
 631 
<span class="line-modified"> 632     if (neededClear &amp;&amp; m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {</span>
 633         m_frame.document()-&gt;cancelParsing();
 634         m_frame.document()-&gt;stopActiveDOMObjects();
 635         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 636         m_frame.document()-&gt;prepareForDestruction();
 637         if (hadLivingRenderTree)
 638             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 639     }
 640 
 641     if (handleDOMWindowCreation)
 642         handleDOMWindowCreation();
 643 
 644     if (!neededClear)
 645         return;
 646 
 647     // Do this after detaching the document so that the unload event works.
 648     if (clearWindowProperties) {
 649         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 650         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
<span class="line-modified"> 651         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache);</span>
 652 
 653         if (shouldClearWindowName(m_frame, *newDocument))
 654             m_frame.tree().setName(nullAtom());
 655     }
 656 
 657     m_frame.selection().prepareForDestruction();
 658     m_frame.eventHandler().clear();
 659 
 660     if (clearFrameView &amp;&amp; m_frame.view())
 661         m_frame.view()-&gt;clear();
 662 
 663     // Do not drop the document before the ScriptController and view are cleared
 664     // as some destructors might still try to access the document.
 665     m_frame.setDocument(nullptr);
 666 
 667     subframeLoader().clear();
 668 
 669     if (clearWindowProperties)
 670         m_frame.windowProxy().setDOMWindow(newDocument-&gt;domWindow());
 671 
</pre>
<hr />
<pre>
 688 {
 689     dispatchDidCommitLoad(WTF::nullopt);
 690     dispatchDidClearWindowObjectsInAllWorlds();
 691     dispatchGlobalObjectAvailableInAllWorlds();
 692 
 693     if (!m_documentLoader)
 694         return;
 695 
 696     auto&amp; documentLoader = *m_documentLoader;
 697     auto&amp; title = documentLoader.title();
 698     if (!title.string.isNull())
 699         m_client.dispatchDidReceiveTitle(title);
 700 
 701     ASSERT(m_frame.document());
 702     auto&amp; document = *m_frame.document();
 703 
 704     LinkLoader::loadLinksFromHeader(documentLoader.response().httpHeaderField(HTTPHeaderName::Link), document.url(), document, LinkLoader::MediaAttributeCheck::MediaAttributeEmpty);
 705 
 706     double delay;
 707     String urlString;
<span class="line-modified"> 708     if (!parseHTTPRefresh(documentLoader.response().httpHeaderField(HTTPHeaderName::Refresh), delay, urlString))</span>
 709         return;
 710     auto completedURL = urlString.isEmpty() ? document.url() : document.completeURL(urlString);
 711     if (!WTF::protocolIsJavaScript(completedURL))
 712         m_frame.navigationScheduler().scheduleRedirect(document, delay, completedURL);
 713     else {
 714         auto message = &quot;Refused to refresh &quot; + document.url().stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
 715         document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 716     }
 717 }
 718 
 719 void FrameLoader::setOutgoingReferrer(const URL&amp; url)
 720 {
 721     m_outgoingReferrer = url.strippedForUseAsReferrer();
 722 }
 723 
<span class="line-modified"> 724 void FrameLoader::didBeginDocument(bool dispatch, ContentSecurityPolicy* previousPolicy)</span>
 725 {
 726     m_needsClear = true;
 727     m_isComplete = false;
 728     m_didCallImplicitClose = false;
 729     m_frame.document()-&gt;setReadyState(Document::Loading);
 730 
 731     if (m_pendingStateObject) {
 732         m_frame.document()-&gt;statePopped(*m_pendingStateObject);
 733         m_pendingStateObject = nullptr;
 734     }
 735 
 736     if (dispatch)
 737         dispatchDidClearWindowObjectsInAllWorlds();
 738 
 739     updateFirstPartyForCookies();
<span class="line-modified"> 740     m_frame.document()-&gt;initContentSecurityPolicy(previousPolicy);</span>
 741 
 742     const Settings&amp; settings = m_frame.settings();
 743     m_frame.document()-&gt;cachedResourceLoader().setImagesEnabled(settings.areImagesEnabled());
 744     m_frame.document()-&gt;cachedResourceLoader().setAutoLoadImages(settings.loadsImagesAutomatically());
 745 
 746     if (m_documentLoader) {
 747         String dnsPrefetchControl = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::XDNSPrefetchControl);
 748         if (!dnsPrefetchControl.isEmpty())
 749             m_frame.document()-&gt;parseDNSPrefetchControlHeader(dnsPrefetchControl);
 750 
 751         m_frame.document()-&gt;contentSecurityPolicy()-&gt;didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader-&gt;response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);
 752 
 753         String referrerPolicy = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ReferrerPolicy);
 754         if (!referrerPolicy.isNull())
 755             m_frame.document()-&gt;processReferrerPolicy(referrerPolicy, ReferrerPolicySource::HTTPHeader);
 756 
 757         String headerContentLanguage = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ContentLanguage);
 758         if (!headerContentLanguage.isEmpty()) {
 759             size_t commaIndex = headerContentLanguage.find(&#39;,&#39;);
 760             headerContentLanguage.truncate(commaIndex); // notFound == -1 == don&#39;t truncate
</pre>
<hr />
<pre>
 821 }
 822 
 823 bool FrameLoader::allAncestorsAreComplete() const
 824 {
 825     for (Frame* ancestor = &amp;m_frame; ancestor; ancestor = ancestor-&gt;tree().parent()) {
 826         if (!ancestor-&gt;loader().m_isComplete)
 827             return false;
 828     }
 829     return true;
 830 }
 831 
 832 void FrameLoader::checkCompleted()
 833 {
 834     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
 835     m_shouldCallCheckCompleted = false;
 836 
 837     // Have we completed before?
 838     if (m_isComplete)
 839         return;
 840 
<span class="line-removed"> 841 #if ENABLE(VIDEO)</span>
<span class="line-removed"> 842     // FIXME: Remove this code once https://webkit.org/b/185284 is fixed.</span>
<span class="line-removed"> 843     if (HTMLMediaElement::isRunningDestructor()) {</span>
<span class="line-removed"> 844         ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 845         scheduleCheckCompleted();</span>
<span class="line-removed"> 846         return;</span>
<span class="line-removed"> 847     }</span>
<span class="line-removed"> 848 #endif</span>
<span class="line-removed"> 849 </span>
 850     // FIXME: It would be better if resource loads were kicked off after render tree update (or didn&#39;t complete synchronously).
 851     //        https://bugs.webkit.org/show_bug.cgi?id=171729
 852     if (m_frame.document()-&gt;inRenderTreeUpdate()) {
 853         scheduleCheckCompleted();
 854         return;
 855     }
 856 
 857     // Are we still parsing?
 858     if (m_frame.document()-&gt;parsing())
 859         return;
 860 
 861     // Still waiting for images/scripts?
 862     if (m_frame.document()-&gt;cachedResourceLoader().requestCount())
 863         return;
 864 
 865     // Still waiting for elements that don&#39;t go through a FrameLoader?
 866     if (m_frame.document()-&gt;isDelayingLoadEvent())
 867         return;
 868 
 869     auto* scriptableParser = m_frame.document()-&gt;scriptableDocumentParser();
 870     if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
 871         return;
 872 
 873     // Any frame that hasn&#39;t completed yet?
 874     if (!allChildrenAreComplete())
 875         return;
 876 
 877     // Important not to protect earlier in this function, because earlier parts
 878     // of this function can be called in the frame&#39;s destructor, and it&#39;s not legal
 879     // to ref an object while it&#39;s being destroyed.
 880     Ref&lt;Frame&gt; protect(m_frame);
 881 
 882     // OK, completed.
 883     m_isComplete = true;
 884     m_requestedHistoryItem = nullptr;
 885     m_frame.document()-&gt;setReadyState(Document::Complete);
 886 
<span class="line-removed"> 887 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed"> 888     if (m_frame.document()-&gt;url().isEmpty()) {</span>
<span class="line-removed"> 889         // We need to update the document URL of a PDF document to be non-empty so that both back/forward history navigation</span>
<span class="line-removed"> 890         // between PDF pages and fragment navigation works. See &lt;rdar://problem/9544769&gt; for more details.</span>
<span class="line-removed"> 891         // FIXME: Is there a better place for this code, say DocumentLoader? Also, we should explicitly only update the URL</span>
<span class="line-removed"> 892         // of the document when it&#39;s a PDFDocument object instead of assuming that a Document object with an empty URL is a PDFDocument.</span>
<span class="line-removed"> 893         // FIXME: This code is incorrect for a synthesized document (which also has an empty URL). The URL for a synthesized</span>
<span class="line-removed"> 894         // document should be the URL specified to FrameLoader::initForSynthesizedDocument().</span>
<span class="line-removed"> 895         m_frame.document()-&gt;setURL(activeDocumentLoader()-&gt;documentURL());</span>
<span class="line-removed"> 896     }</span>
<span class="line-removed"> 897 #endif</span>
<span class="line-removed"> 898 </span>
 899     checkCallImplicitClose(); // if we didn&#39;t do it before
 900 
 901     m_frame.navigationScheduler().startTimer();
 902 
 903     completed();
 904     if (m_frame.page())
 905         checkLoadComplete();
 906 }
 907 
 908 void FrameLoader::checkTimerFired()
 909 {
 910     checkCompletenessNow();
 911 }
 912 
 913 void FrameLoader::checkCompletenessNow()
 914 {
 915     Ref&lt;Frame&gt; protect(m_frame);
 916 
 917     if (Page* page = m_frame.page()) {
 918         if (page-&gt;defersLoading())
</pre>
<hr />
<pre>
 943 {
 944     m_shouldCallCheckLoadComplete = true;
 945     startCheckCompleteTimer();
 946 }
 947 
 948 void FrameLoader::checkCallImplicitClose()
 949 {
 950     if (m_didCallImplicitClose || m_frame.document()-&gt;parsing() || m_frame.document()-&gt;isDelayingLoadEvent())
 951         return;
 952 
 953     if (!allChildrenAreComplete())
 954         return; // still got a frame running -&gt; too early
 955 
 956     m_didCallImplicitClose = true;
 957     m_wasUnloadEventEmitted = false;
 958     m_frame.document()-&gt;implicitClose();
 959 }
 960 
 961 void FrameLoader::loadURLIntoChildFrame(const URL&amp; url, const String&amp; referer, Frame* childFrame)
 962 {
<span class="line-modified"> 963     RELEASE_LOG_IF_ALLOWED(&quot;loadURLIntoChildFrame: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
 964 
 965     ASSERT(childFrame);
 966 
 967 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 968     if (auto activeLoader = activeDocumentLoader()) {
 969         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 970             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 971             return;
 972         }
 973     }
 974 #endif
 975 
 976     // If we&#39;re moving in the back/forward list, we might want to replace the content
 977     // of this child frame with whatever was there at that point.
 978     auto* parentItem = history().currentItem();
 979     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 980         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 981             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
 982             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, nullptr, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
 983             return;
 984         }
 985     }
 986 
 987     auto* lexicalFrame = lexicalFrameFromCommonVM();
 988     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 989 
 990     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 991     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 992 }
 993 
 994 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 995 
 996 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 997 {
<span class="line-modified"> 998     RELEASE_LOG_IF_ALLOWED(&quot;loadArchive: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
 999 
1000     ArchiveResource* mainResource = archive-&gt;mainResource();
1001     ASSERT(mainResource);
1002     if (!mainResource)
1003         return;
1004 
1005     ResourceResponse response(URL(), mainResource-&gt;mimeType(), mainResource-&gt;data().size(), mainResource-&gt;textEncoding());
1006     SubstituteData substituteData(&amp;mainResource-&gt;data(), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1007 
1008     ResourceRequest request(mainResource-&gt;url());
1009 
1010     auto documentLoader = m_client.createDocumentLoader(request, substituteData);
1011     documentLoader-&gt;setArchive(WTFMove(archive));
1012     load(documentLoader.get());
1013 }
1014 
1015 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1016 
1017 String FrameLoader::outgoingReferrer() const
1018 {
</pre>
<hr />
<pre>
1106     else
1107         setFirstPartyForCookies(m_frame.document()-&gt;url());
1108 }
1109 
1110 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1111 {
1112     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1113         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1114 
1115     RegistrableDomain registrableDomain(url);
1116     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
1117         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomain.matches(frame-&gt;document()-&gt;url()))
1118             frame-&gt;document()-&gt;setSiteForCookies(url);
1119     }
1120 }
1121 
1122 // This does the same kind of work that didOpenURL does, except it relies on the fact
1123 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1124 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1125 {
<span class="line-modified">1126     RELEASE_LOG_IF_ALLOWED(&quot;loadInSameDocument: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1127 
1128     // If we have a state object, we cannot also be a new navigation.
1129     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1130 
1131     // Update the data source&#39;s request with the new URL to fake the URL change
1132     URL oldURL = m_frame.document()-&gt;url();
1133     m_frame.document()-&gt;setURL(url);
1134     setOutgoingReferrer(url);
1135     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1136     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1137         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
1138         // based on the current request. Must also happen before we openURL and displace the
1139         // scroll position, since adding the BF item will save away scroll state.
1140 
1141         // NB2: If we were loading a long, slow doc, and the user fragment navigated before
1142         // it was done, currItem is now set the that slow doc, and prevItem is whatever was
1143         // before it.  Adding the b/f item will bump the slow doc down to prevItem, even
1144         // though its load is not yet done.  I think this all works out OK, for one because
1145         // we have already saved away the scroll and doc state for the long slow load,
1146         // but it&#39;s not an obvious case.
</pre>
<hr />
<pre>
1205     Ref&lt;Frame&gt; protect(m_frame);
1206 
1207     for (Frame* descendant = m_frame.tree().traverseNext(&amp;m_frame); descendant; descendant = descendant-&gt;tree().traverseNext(&amp;m_frame))
1208         descendant-&gt;navigationScheduler().startTimer();
1209 
1210     if (Frame* parent = m_frame.tree().parent())
1211         parent-&gt;loader().checkCompleted();
1212 
1213     if (m_frame.view())
1214         m_frame.view()-&gt;maintainScrollPositionAtAnchor(nullptr);
1215 }
1216 
1217 void FrameLoader::started()
1218 {
1219     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().parent())
1220         frame-&gt;loader().m_isComplete = false;
1221 }
1222 
1223 void FrameLoader::prepareForLoadStart()
1224 {
<span class="line-modified">1225     RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart: Starting frame load (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1226 
1227     m_progressTracker-&gt;progressStarted();
1228     m_client.dispatchDidStartProvisionalLoad();
1229 
1230     if (AXObjectCache::accessibilityEnabled()) {
1231         if (AXObjectCache* cache = m_frame.document()-&gt;existingAXObjectCache()) {
1232             AXObjectCache::AXLoadingEvent loadingEvent = loadType() == FrameLoadType::Reload ? AXObjectCache::AXLoadingReloaded : AXObjectCache::AXLoadingStarted;
1233             cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
1234         }
1235     }
1236 }
1237 
1238 void FrameLoader::setupForReplace()
1239 {
1240     m_client.revertToProvisionalState(m_documentLoader.get());
1241     setState(FrameStateProvisional);
1242     m_provisionalDocumentLoader = m_documentLoader;

1243     m_documentLoader = nullptr;
1244     detachChildren();
1245 }
1246 
1247 void FrameLoader::loadFrameRequest(FrameLoadRequest&amp;&amp; request, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
1248 {
<span class="line-modified">1249     RELEASE_LOG_IF_ALLOWED(&quot;loadFrameRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1250 
1251     // Protect frame from getting blown away inside dispatchBeforeLoadEvent in loadWithDocumentLoader.
1252     auto protectFrame = makeRef(m_frame);
1253 
1254     URL url = request.resourceRequest().url();
1255 
1256     ASSERT(m_frame.document());
1257     if (!request.requesterSecurityOrigin().canDisplay(url)) {
1258         reportLocalLoadFailed(&amp;m_frame, url.stringCenterEllipsizedToLength());
1259         return;
1260     }
1261 
1262     String argsReferrer = request.resourceRequest().httpReferrer();
1263     if (argsReferrer.isEmpty())
1264         argsReferrer = outgoingReferrer();
1265 
1266     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), url, argsReferrer);
1267     if (request.shouldSendReferrer() == NeverSendReferrer)
1268         referrer = String();
1269 
</pre>
<hr />
<pre>
1318     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1319 }
1320 
1321 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1322 {
1323     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1324 }
1325 
1326 bool FrameLoader::isNavigationAllowed() const
1327 {
1328     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; !m_frame.script().willReplaceWithResultOfExecutingJavascriptURL() &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);
1329 }
1330 
1331 bool FrameLoader::isStopLoadingAllowed() const
1332 {
1333     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1334 }
1335 
1336 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1337 {
<span class="line-modified">1338     RELEASE_LOG_IF_ALLOWED(&quot;loadURL: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1339 
1340     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1341     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1342         return;
1343 
1344     Ref&lt;Frame&gt; protect(m_frame);
1345 
1346     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1347     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1348     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
1349     NewFrameOpenerPolicy openerPolicy = frameLoadRequest.newFrameOpenerPolicy();
1350     LockHistory lockHistory = frameLoadRequest.lockHistory();
1351     bool isFormSubmission = formState;
1352 
1353     const URL&amp; newURL = frameLoadRequest.resourceRequest().url();
1354     ResourceRequest request(newURL);
1355     if (!referrer.isEmpty()) {
1356         request.setHTTPReferrer(referrer);
1357         auto referrerOrigin = SecurityOrigin::createFromString(referrer);
1358         addHTTPOriginIfNeeded(request, referrerOrigin-&gt;toString());
</pre>
<hr />
<pre>
1368 
1369     // The search for a target frame is done earlier in the case of form submission.
1370     Frame* targetFrame = isFormSubmission ? nullptr : findFrameForNavigation(effectiveFrameName);
1371     if (targetFrame &amp;&amp; targetFrame != &amp;m_frame) {
1372         frameLoadRequest.setFrameName(&quot;_self&quot;);
1373         targetFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referrer, newLoadType, event, WTFMove(formState), WTFMove(adClickAttribution), completionHandlerCaller.release());
1374         return;
1375     }
1376 
1377     if (!isNavigationAllowed())
1378         return;
1379 
1380     NavigationAction action { frameLoadRequest.requester(), request, frameLoadRequest.initiatedByMainFrame(), newLoadType, isFormSubmission, event, frameLoadRequest.shouldOpenExternalURLsPolicy(), frameLoadRequest.downloadAttribute() };
1381     action.setLockHistory(lockHistory);
1382     action.setLockBackForwardList(frameLoadRequest.lockBackForwardList());
1383     if (adClickAttribution &amp;&amp; m_frame.isMainFrame())
1384         action.setAdClickAttribution(WTFMove(*adClickAttribution));
1385 
1386     if (!targetFrame &amp;&amp; !effectiveFrameName.isEmpty()) {
1387         action = action.copyWithShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(m_frame, frameLoadRequest));
<span class="line-modified">1388         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request), WTFMove(formState), effectiveFrameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {</span>
1389             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
1390             completionHandler();
1391         });
1392         return;
1393     }
1394 
1395     RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1396 
1397     bool sameURL = shouldTreatURLAsSameAsCurrent(newURL);
1398     const String&amp; httpMethod = request.httpMethod();
1399 
1400     // Make sure to do scroll to fragment processing even if the URL is
1401     // exactly the same so pages with &#39;#&#39; links and DHTML side effects
1402     // work properly.
1403     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1404         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1405         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1406         policyChecker().stopCheck();
1407         policyChecker().setLoadType(newLoadType);
1408         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1409         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1410             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1411         }, PolicyDecisionMode::Synchronous);
1412         return;
1413     }
1414 
1415     // Must grab this now, since this load may stop the previous load and clear this flag.
1416     bool isRedirect = m_quickRedirectComing;
1417 #if USE(SYSTEM_PREVIEW)
1418     bool isSystemPreview = frameLoadRequest.isSystemPreview();
<span class="line-removed">1419     request.setSystemPreview(isSystemPreview);</span>
1420     if (isSystemPreview)
<span class="line-modified">1421         request.setSystemPreviewRect(frameLoadRequest.systemPreviewRect());</span>
1422 #endif
1423     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, frameLoadRequest.downloadAttribute(), [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {
1424         if (isRedirect) {
1425             m_quickRedirectComing = false;
1426             if (m_provisionalDocumentLoader)
1427                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1428             else if (m_policyDocumentLoader)
1429                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1430         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1431             // Example of this case are sites that reload the same URL with a different cookie
1432             // driving the generated content, or a master frame with links that drive a target
1433             // frame, where the user has clicked on the same link repeatedly.
1434             m_loadType = FrameLoadType::Same;
1435         }
1436         completionHandler();
1437     });
1438 }
1439 
1440 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1441 {
1442     if (!shouldTreatURLAsSrcdocDocument(url))
1443         return SubstituteData();
1444     auto&amp; srcdoc = m_frame.ownerElement()-&gt;attributeWithoutSynchronization(srcdocAttr);
1445     ASSERT(!srcdoc.isNull());
1446     CString encodedSrcdoc = srcdoc.string().utf8();
1447 
1448     ResourceResponse response(URL(), &quot;text/html&quot;_s, encodedSrcdoc.length(), &quot;UTF-8&quot;_s);
1449     return SubstituteData(SharedBuffer::create(encodedSrcdoc.data(), encodedSrcdoc.length()), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1450 }
1451 
1452 void FrameLoader::load(FrameLoadRequest&amp;&amp; request)
1453 {
<span class="line-modified">1454     RELEASE_LOG_IF_ALLOWED(&quot;load (FrameLoadRequest): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1455 
1456     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1457         return;
1458 
1459     if (!request.frameName().isEmpty()) {
1460         Frame* frame = findFrameForNavigation(request.frameName());
1461         if (frame) {
1462             request.setShouldCheckNewWindowPolicy(false);
1463             if (&amp;frame-&gt;loader() != this) {
1464                 frame-&gt;loader().load(WTFMove(request));
1465                 return;
1466             }
1467         }
1468     }
1469 
1470     if (request.shouldCheckNewWindowPolicy()) {
1471         NavigationAction action { request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() };
<span class="line-modified">1472         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request.resourceRequest()), { }, request.frameName(), [this] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) {</span>
1473             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);
1474         });
1475 
1476         return;
1477     }
1478 
1479     if (!request.hasSubstituteData())
1480         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1481 
1482     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1483     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());

1484     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1485     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1486 
1487     if (request.shouldTreatAsContinuingLoad()) {
1488         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1489         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1490             loader-&gt;setIsClientRedirect(true);
1491             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1492         }
1493     }
1494 
1495     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1496     load(loader.get());
1497 }
1498 
1499 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, const String&amp; downloadAttribute, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1500 {
<span class="line-modified">1501     RELEASE_LOG_IF_ALLOWED(&quot;loadWithNavigationAction: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1502 
1503     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1504     loader-&gt;setDownloadAttribute(downloadAttribute);
1505     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1506 
1507     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1508         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1509 
1510     loader-&gt;setTriggeringAction(WTFMove(action));
1511     if (m_documentLoader)
1512         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1513 
1514     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1515 }
1516 
1517 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1518 {
<span class="line-modified">1519     RELEASE_LOG_IF_ALLOWED(&quot;load (DocumentLoader): frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1520 
1521     ResourceRequest&amp; r = newDocumentLoader.request();
1522     addExtraFieldsToMainResourceRequest(r);
1523     FrameLoadType type;
1524 
1525     if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.originalRequest().url())) {
1526         r.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1527         type = FrameLoadType::Same;
1528     } else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.unreachableURL()) &amp;&amp; isReload(m_loadType))
1529         type = m_loadType;
1530     else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; ((!newDocumentLoader.unreachableURL().isEmpty() &amp;&amp; newDocumentLoader.substituteData().isValid()) || shouldTreatCurrentLoadAsContinuingLoad()))
1531         type = FrameLoadType::RedirectWithLockedBackForwardList;
1532     else
1533         type = FrameLoadType::Standard;
1534 
1535     if (m_documentLoader)
1536         newDocumentLoader.setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1537 
1538     // When we loading alternate content for an unreachable URL that we&#39;re
1539     // visiting in the history list, we treat it as a reload so the history list
1540     // is appropriately maintained.
1541     //
1542     // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadType::Reload&quot; ...
1543     // shouldn&#39;t a more explicit type of reload be defined, that means roughly
1544     // &quot;load without affecting history&quot; ?
1545     if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) {
1546         // shouldReloadToHandleUnreachableURL returns true only when the original load type is back-forward.
1547         // In this case we should save the document state now. Otherwise the state can be lost because load type is
1548         // changed and updateForBackForwardNavigation() will not be called when loading is committed.
1549         history().saveDocumentAndScrollState();
1550 
1551         ASSERT(type == FrameLoadType::Standard);
1552         type = FrameLoadType::Reload;
1553     }
1554 
1555     loadWithDocumentLoader(&amp;newDocumentLoader, type, nullptr, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1556 }
1557 
1558 void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1559 {
<span class="line-modified">1560     RELEASE_LOG_IF_ALLOWED(&quot;loadWithDocumentLoader: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1561 
1562     // Retain because dispatchBeforeLoadEvent may release the last reference to it.
1563     Ref&lt;Frame&gt; protect(m_frame);
1564 
1565     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1566 
1567     ASSERT(m_client.hasWebView());
1568 
1569     // Unfortunately the view must be non-nil, this is ultimately due
1570     // to parser requiring a FrameView.  We should fix this dependency.
1571 
1572     ASSERT(m_frame.view());
1573 
1574     if (!isNavigationAllowed())
1575         return;
1576 
1577     if (m_frame.document())
1578         m_previousURL = m_frame.document()-&gt;url();
1579 
1580     const URL&amp; newURL = loader-&gt;request().url();
1581 
1582     // Only the first iframe navigation or the first iframe navigation after about:blank should be reported.
1583     // https://www.w3.org/TR/resource-timing-2/#resources-included-in-the-performanceresourcetiming-interface
1584     if (m_shouldReportResourceTimingToParentFrame &amp;&amp; !m_previousURL.isNull() &amp;&amp; m_previousURL != WTF::blankURL())
1585         m_shouldReportResourceTimingToParentFrame = false;
1586 
1587     // Log main frame navigation types.
1588     if (m_frame.isMainFrame()) {
1589         if (auto* page = m_frame.page()) {
<span class="line-modified">1590             RELEASE_LOG_IF_ALLOWED(&quot;loadWithDocumentLoader: main frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1591             page-&gt;mainFrameLoadStarted(newURL, type);
1592             page-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);
1593         }
1594     }
1595 
1596     policyChecker().setLoadType(type);
1597     RELEASE_ASSERT(!isBackForwardLoadType(type) || history().provisionalItem());
1598     bool isFormSubmission = formState;
1599 
1600     const String&amp; httpMethod = loader-&gt;request().httpMethod();
1601 
1602     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) {
1603         RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1604         NavigationAction action { *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission };
1605 
1606         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1607         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1608         policyChecker().stopCheck();
1609         RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1610         policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { }  /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
</pre>
<hr />
<pre>
1638 
1639     if (shouldTreatCurrentLoadAsContinuingLoad()) {
1640         continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::ContinueLoad, allowNavigationToInvalidURL);
1641         return;
1642     }
1643 
1644     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1645     policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { } /* redirectResponse */, loader, WTFMove(formState), [this, protectedFrame = makeRef(m_frame), allowNavigationToInvalidURL, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecision navigationPolicyDecision) mutable {
1646         continueLoadAfterNavigationPolicy(request, formState.get(), navigationPolicyDecision, allowNavigationToInvalidURL);
1647         completionHandler();
1648     }, PolicyDecisionMode::Asynchronous);
1649 }
1650 
1651 void FrameLoader::clearProvisionalLoadForPolicyCheck()
1652 {
1653     if (!m_policyDocumentLoader || !m_provisionalDocumentLoader || m_inClearProvisionalLoadForPolicyCheck)
1654         return;
1655 
1656     SetForScope&lt;bool&gt; change(m_inClearProvisionalLoadForPolicyCheck, true);
1657     m_provisionalDocumentLoader-&gt;stopLoading();

1658     setProvisionalDocumentLoader(nullptr);
1659 }
1660 
1661 void FrameLoader::reportLocalLoadFailed(Frame* frame, const String&amp; url)
1662 {
1663     ASSERT(!url.isEmpty());
1664     if (!frame)
1665         return;
1666 
1667     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to load local resource: &quot; + url);
1668 }
1669 
1670 void FrameLoader::reportBlockedPortFailed(Frame* frame, const String&amp; url)
1671 {
1672     ASSERT(!url.isEmpty());
1673     if (!frame)
1674         return;
1675 
1676     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to use restricted network port: &quot; + url);
1677 }
</pre>
<hr />
<pre>
1720 
1721     if (!isBackForwardLoadType(policyChecker().loadType()))
1722         return false;
1723 
1724     // We only treat unreachableURLs specially during the delegate callbacks
1725     // for provisional load errors and navigation policy decisions. The former
1726     // case handles well-formed URLs that can&#39;t be loaded, and the latter
1727     // case handles malformed URLs and unknown schemes. Loading alternate content
1728     // at other times behaves like a standard load.
1729     if (policyChecker().delegateIsDecidingNavigationPolicy() || policyChecker().delegateIsHandlingUnimplementablePolicy())
1730         return m_policyDocumentLoader &amp;&amp; unreachableURL == m_policyDocumentLoader-&gt;request().url();
1731 
1732     return unreachableURL == m_provisionalLoadErrorBeingHandledURL;
1733 }
1734 
1735 void FrameLoader::reloadWithOverrideEncoding(const String&amp; encoding)
1736 {
1737     if (!m_documentLoader)
1738         return;
1739 
<span class="line-modified">1740     RELEASE_LOG_IF_ALLOWED(&quot;reloadWithOverrideEncoding: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1741 
1742     ResourceRequest request = m_documentLoader-&gt;request();
1743     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1744     if (!unreachableURL.isEmpty())
1745         request.setURL(unreachableURL);
1746 
1747     // FIXME: If the resource is a result of form submission and is not cached, the form will be silently resubmitted.
1748     // We should ask the user for confirmation in this case.
1749     request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
1750 
1751     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1752     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1753 
1754     setPolicyDocumentLoader(loader.ptr());
1755 
1756     loader-&gt;setOverrideEncoding(encoding);
1757 
1758     loadWithDocumentLoader(loader.ptr(), FrameLoadType::Reload, { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1759 }
1760 
1761 void FrameLoader::reload(OptionSet&lt;ReloadOption&gt; options)
1762 {
1763     if (!m_documentLoader)
1764         return;
1765 
1766     // If a window is created by javascript, its main frame can have an empty but non-nil URL.
1767     // Reloading in this case will lose the current contents (see 4151001).
1768     if (m_documentLoader-&gt;request().url().isEmpty())
1769         return;
1770 
<span class="line-modified">1771     RELEASE_LOG_IF_ALLOWED(&quot;reload: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1772 
1773     // Replace error-page URL with the URL we were trying to reach.
1774     ResourceRequest initialRequest = m_documentLoader-&gt;request();
1775     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1776     if (!unreachableURL.isEmpty())
1777         initialRequest.setURL(unreachableURL);
1778 
1779     // Create a new document loader for the reload, this will become m_documentLoader eventually,
1780     // but first it has to be the &quot;policy&quot; document loader, and then the &quot;provisional&quot; document loader.
1781     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(initialRequest, defaultSubstituteDataForURL(initialRequest.url()));
1782     loader-&gt;setAllowsWebArchiveForMainFrame(m_documentLoader-&gt;allowsWebArchiveForMainFrame());

1783     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1784 
1785     loader-&gt;setUserContentExtensionsEnabled(!options.contains(ReloadOption::DisableContentBlockers));
1786 
1787     ResourceRequest&amp; request = loader-&gt;request();
1788 
1789     // FIXME: We don&#39;t have a mechanism to revalidate the main resource without reloading at the moment.
1790     request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1791 
1792     addSameSiteInfoToRequestIfNeeded(request);
1793 
1794     // If we&#39;re about to re-post, set up action so the application can warn the user.
1795     if (request.httpMethod() == &quot;POST&quot;)
1796         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1797 
1798     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1799 
1800     auto frameLoadTypeForReloadOptions = [] (auto options) {
1801         if (options &amp; ReloadOption::FromOrigin)
1802             return FrameLoadType::ReloadFromOrigin;
1803         if (options &amp; ReloadOption::ExpiredOnly)
1804             return FrameLoadType::ReloadExpiredOnly;
1805         return FrameLoadType::Reload;
1806     };
1807 
1808     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1809 }
1810 
1811 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy, StopLoadingPolicy stopLoadingPolicy)
1812 {
<span class="line-modified">1813     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;pageCacheState() == Document::InPageCache)</span>
1814         return;
1815 
1816     if (stopLoadingPolicy == StopLoadingPolicy::PreventDuringUnloadEvents &amp;&amp; !isStopLoadingAllowed())
1817         return;
1818 
1819     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1820     if (m_inStopAllLoaders)
1821         return;
1822 
1823     // This method might dispatch events.
1824     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1825 
1826     // Calling stopLoading() on the provisional document loader can blow away
1827     // the frame from underneath.
1828     Ref&lt;Frame&gt; protect(m_frame);
1829 
1830     m_inStopAllLoaders = true;
1831 
1832     policyChecker().stopCheck();
1833 
1834     // If no new load is in progress, we should clear the provisional item from history
1835     // before we call stopLoading.
1836     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
1837         history().setProvisionalItem(nullptr);
1838 
1839     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1840         child-&gt;loader().stopAllLoaders(clearProvisionalItemPolicy);
1841     if (m_provisionalDocumentLoader)
1842         m_provisionalDocumentLoader-&gt;stopLoading();
1843     if (m_documentLoader)
1844         m_documentLoader-&gt;stopLoading();
1845 

1846     setProvisionalDocumentLoader(nullptr);
1847 
1848     m_inStopAllLoaders = false;
1849 }
1850 























1851 void FrameLoader::stopAllLoadersAndCheckCompleteness()
1852 {
1853     stopAllLoaders();
1854 
1855     if (!m_checkTimer.isActive())
1856         return;
1857 
1858     m_checkTimer.stop();
1859     m_checkingLoadCompleteForDetachment = true;
1860     checkCompletenessNow();
1861     m_checkingLoadCompleteForDetachment = false;
1862 }
1863 
1864 void FrameLoader::stopForUserCancel(bool deferCheckLoadComplete)
1865 {
1866     // Calling stopAllLoaders can cause the frame to be deallocated, including the frame loader.
1867     Ref&lt;Frame&gt; protectedFrame(m_frame);
1868 
1869     stopAllLoaders();
1870 
</pre>
<hr />
<pre>
1932     m_documentLoader = loader;
1933 }
1934 
1935 void FrameLoader::setPolicyDocumentLoader(DocumentLoader* loader)
1936 {
1937     if (m_policyDocumentLoader == loader)
1938         return;
1939 
1940     if (loader)
1941         loader-&gt;attachToFrame(m_frame);
1942     if (m_policyDocumentLoader
1943             &amp;&amp; m_policyDocumentLoader != m_provisionalDocumentLoader
1944             &amp;&amp; m_policyDocumentLoader != m_documentLoader)
1945         m_policyDocumentLoader-&gt;detachFromFrame();
1946 
1947     m_policyDocumentLoader = loader;
1948 }
1949 
1950 void FrameLoader::setProvisionalDocumentLoader(DocumentLoader* loader)
1951 {


1952     ASSERT(!loader || !m_provisionalDocumentLoader);
1953     ASSERT(!loader || loader-&gt;frameLoader() == this);
1954 
1955     if (m_provisionalDocumentLoader &amp;&amp; m_provisionalDocumentLoader != m_documentLoader)
1956         m_provisionalDocumentLoader-&gt;detachFromFrame();
1957 
1958     m_provisionalDocumentLoader = loader;
1959 }
1960 
1961 void FrameLoader::setState(FrameState newState)
1962 {
1963     FrameState oldState = m_state;
1964     m_state = newState;
1965 
1966     if (newState == FrameStateProvisional)
1967         provisionalLoadStarted();
1968     else if (newState == FrameStateComplete) {
1969         frameLoadCompleted();
1970         if (m_documentLoader)
1971             m_documentLoader-&gt;stopRecordingResponses();
1972         if (m_frame.isMainFrame() &amp;&amp; oldState != newState) {
<span class="line-modified">1973             RELEASE_LOG_IF_ALLOWED(&quot;setState: main frame load completed (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
1974             m_frame.page()-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadCompleted);
1975         }
1976     }
1977 }
1978 
1979 void FrameLoader::clearProvisionalLoad()
1980 {

1981     setProvisionalDocumentLoader(nullptr);
1982     m_progressTracker-&gt;progressCompleted();
1983     setState(FrameStateComplete);
1984 }
1985 
1986 void FrameLoader::commitProvisionalLoad()
1987 {
1988     RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
1989     Ref&lt;Frame&gt; protect(m_frame);
1990 
1991     std::unique_ptr&lt;CachedPage&gt; cachedPage;
1992     if (m_loadingFromCachedPage &amp;&amp; history().provisionalItem())
<span class="line-modified">1993         cachedPage = PageCache::singleton().take(*history().provisionalItem(), m_frame.page());</span>
1994 
<span class="line-modified">1995     LOG(PageCache, &quot;WebCoreLoading %s: About to commit provisional load from previous URL &#39;%s&#39; to new URL &#39;%s&#39; with cached page %p&quot;, m_frame.tree().uniqueName().string().utf8().data(),</span>
1996         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;,
1997         pdl ? pdl-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&lt;no provisional DocumentLoader&gt;&quot;, cachedPage.get());
1998 
1999     willTransitionToCommitted();
2000 
2001     if (!m_frame.tree().parent() &amp;&amp; history().currentItem() &amp;&amp; history().currentItem() != history().provisionalItem()) {
2002         // Check to see if we need to cache the page we are navigating away from into the back/forward cache.
2003         // We are doing this here because we know for sure that a new page is about to be loaded.
<span class="line-modified">2004         PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());</span>
2005 
2006         WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();
2007     }
2008 
2009     if (m_loadType != FrameLoadType::Replace)
2010         closeOldDataSources();
2011 
2012     if (!cachedPage &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument())
2013         m_client.makeRepresentation(pdl.get());
2014 
2015     transitionToCommitted(cachedPage.get());
2016 
2017     if (pdl &amp;&amp; m_documentLoader) {
2018         // Check if the destination page is allowed to access the previous page&#39;s timing information.
2019         Ref&lt;SecurityOrigin&gt; securityOrigin(SecurityOrigin::create(pdl-&gt;request().url()));
2020         m_documentLoader-&gt;timing().setHasSameOriginAsPreviousDocument(securityOrigin.get().canRequest(m_previousURL));
2021     }
2022 
2023     // Call clientRedirectCancelledOrFinished() here so that the frame load delegate is notified that the redirect&#39;s
2024     // status has changed, if there was a redirect.  The frame load delegate may have saved some state about
</pre>
<hr />
<pre>
2061             m_client.dispatchDidReceiveTitle(title);
2062 
2063         // Send remaining notifications for the main resource.
2064         notifier().sendRemainingDelegateMessages(m_documentLoader.get(), mainResourceIdentifier, mainResourceRequest, ResourceResponse(),
2065             nullptr, static_cast&lt;int&gt;(m_documentLoader-&gt;response().expectedContentLength()), 0, mainResouceError);
2066 
2067         checkCompleted();
2068     } else
2069         didOpenURL();
2070 
2071     LOG(Loading, &quot;WebCoreLoading %s: Finished committing provisional load to URL %s&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2072         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;);
2073 
2074     if (m_loadType == FrameLoadType::Standard &amp;&amp; m_documentLoader &amp;&amp; m_documentLoader-&gt;isClientRedirect())
2075         history().updateForClientRedirect();
2076 
2077     if (m_loadingFromCachedPage) {
2078         // Note, didReceiveDocType is expected to be called for cached pages. See &lt;rdar://problem/5906758&gt; for more details.
2079         if (auto* page = m_frame.page())
2080             page-&gt;chrome().didReceiveDocType(m_frame);
<span class="line-modified">2081         m_frame.document()-&gt;resume(ReasonForSuspension::PageCache);</span>
2082 
2083         // Force a layout to update view size and thereby update scrollbars.
2084 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2085         if (!m_client.forceLayoutOnRestoreFromPageCache())</span>
2086             m_frame.view()-&gt;forceLayout();
2087 #else
2088         m_frame.view()-&gt;forceLayout();
2089 #endif
2090 
2091         // Main resource delegates were already sent, so we skip the first response here.
2092         for (unsigned i = 1; i &lt; m_documentLoader-&gt;responses().size(); ++i) {
2093             const auto&amp; response = m_documentLoader-&gt;responses()[i];
2094             // FIXME: If the WebKit client changes or cancels the request, this is not respected.
2095             ResourceError error;
2096             unsigned long identifier;
2097             ResourceRequest request(response.url());
2098             requestFromDelegate(request, identifier, error);
2099             // FIXME: If we get a resource with more than 2B bytes, this code won&#39;t do the right thing.
2100             // However, with today&#39;s computers and networking speeds, this won&#39;t happen in practice.
2101             // Could be an issue with a giant local file.
2102             notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, 0, static_cast&lt;int&gt;(response.expectedContentLength()), 0, error);
2103         }
2104 
2105         // FIXME: Why only this frame and not parent frames?
</pre>
<hr />
<pre>
2126     // The call to closeURL() invokes the unload event handler, which can execute arbitrary
2127     // JavaScript. If the script initiates a new load, we need to abandon the current load,
2128     // or the two will stomp each other.
2129     DocumentLoader* pdl = m_provisionalDocumentLoader.get();
2130     if (m_documentLoader)
2131         closeURL();
2132     if (pdl != m_provisionalDocumentLoader)
2133         return;
2134 
2135     if (m_documentLoader)
2136         m_documentLoader-&gt;stopLoadingSubresources();
2137     if (m_documentLoader)
2138         m_documentLoader-&gt;stopLoadingPlugIns();
2139 
2140     // Setting our document loader invokes the unload event handler of our child frames.
2141     // Script can do anything. If the script initiates a new load, we need to abandon the
2142     // current load or the two will stomp each other.
2143     setDocumentLoader(m_provisionalDocumentLoader.get());
2144     if (pdl != m_provisionalDocumentLoader)
2145         return;

2146     setProvisionalDocumentLoader(nullptr);
2147 
2148     // Nothing else can interrupt this commit - set the Provisional-&gt;Committed transition in stone
2149     setState(FrameStateCommittedPage);
2150 
2151     // Handle adding the URL to the back/forward list.
2152     DocumentLoader* dl = m_documentLoader.get();
2153 
2154     switch (m_loadType) {
2155     case FrameLoadType::Forward:
2156     case FrameLoadType::Back:
2157     case FrameLoadType::IndexedBackForward:
2158         if (m_frame.page()) {
2159             // If the first load within a frame is a navigation within a back/forward list that was attached
2160             // without any of the items being loaded then we need to update the history in a similar manner as
2161             // for a standard load with the exception of updating the back/forward list (&lt;rdar://problem/8091103&gt;).
2162             if (!m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; m_frame.isMainFrame())
2163                 history().updateForStandardLoad(HistoryController::UpdateAllExceptBackForwardList);
2164 
2165             history().updateForBackForwardNavigation();
</pre>
<hr />
<pre>
2287 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2288 {
2289     m_isComplete = false;
2290 
2291     // Don&#39;t re-emit the load event.
2292     m_didCallImplicitClose = true;
2293 
2294     URL url = cachedFrame.url();
2295 
2296     // FIXME: I suspect this block of code doesn&#39;t do anything.
2297     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2298         url.setPath(&quot;/&quot;);
2299 
2300     started();
2301     auto document = makeRef(*cachedFrame.document());
2302     ASSERT(document-&gt;domWindow());
2303 
2304     clear(document.ptr(), true, true, cachedFrame.isMainFrame());
2305 
2306     document-&gt;attachToCachedFrame(cachedFrame);
<span class="line-modified">2307     document-&gt;setPageCacheState(Document::NotInPageCache);</span>
2308 
2309     m_needsClear = true;
2310     m_isComplete = false;
2311     m_didCallImplicitClose = false;
2312     setOutgoingReferrer(url);
2313 
2314     FrameView* view = cachedFrame.view();
2315 
2316     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2317     ASSERT(view);
2318     view-&gt;setWasScrolledByUser(false);
2319 
2320     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2321     m_frame.setView(view);
2322 
2323     // Use the previous ScrollView&#39;s frame rect.
2324     if (previousViewFrameRect)
2325         view-&gt;setFrameRect(previousViewFrameRect.value());
2326 
2327 
2328     // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,
2329     // including loading a child frame before its been re-attached to the frame tree as part of this restore.
2330     // For example, the HTML object element may load its content into a frame in a post style resolution callback.
2331     Style::PostResolutionCallbackDisabler disabler(document.get());
2332     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2333     NavigationDisabler disableNavigation { &amp;m_frame };
2334 
2335     m_frame.setDocument(document.copyRef());
2336 
<span class="line-modified">2337     document-&gt;domWindow()-&gt;resumeFromPageCache();</span>
2338 
2339     updateFirstPartyForCookies();
2340 
2341     cachedFrame.restore();
2342 }
2343 
2344 bool FrameLoader::isHostedByObjectElement() const
2345 {
2346     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2347     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2348 }
2349 
2350 bool FrameLoader::isReplacing() const
2351 {
2352     return m_loadType == FrameLoadType::Replace;
2353 }
2354 
2355 void FrameLoader::setReplacing()
2356 {
2357     m_loadType = FrameLoadType::Replace;
</pre>
<hr />
<pre>
2371         documentLoader = childLoader.policyDocumentLoader();
2372         if (documentLoader)
2373             return true;
2374     }
2375     return false;
2376 }
2377 
2378 void FrameLoader::willChangeTitle(DocumentLoader* loader)
2379 {
2380     m_client.willChangeTitle(loader);
2381 }
2382 
2383 FrameLoadType FrameLoader::loadType() const
2384 {
2385     return m_loadType;
2386 }
2387 
2388 CachePolicy FrameLoader::subresourceCachePolicy(const URL&amp; url) const
2389 {
2390     if (Page* page = m_frame.page()) {
<span class="line-modified">2391         if (page-&gt;isResourceCachingDisabled())</span>
2392             return CachePolicyReload;
2393     }
2394 
2395     if (m_isComplete)
2396         return CachePolicyVerify;
2397 
2398     if (m_loadType == FrameLoadType::ReloadFromOrigin)
2399         return CachePolicyReload;
2400 
2401     if (Frame* parentFrame = m_frame.tree().parent()) {
2402         CachePolicy parentCachePolicy = parentFrame-&gt;loader().subresourceCachePolicy(url);
2403         if (parentCachePolicy != CachePolicyVerify)
2404             return parentCachePolicy;
2405     }
2406 
2407     switch (m_loadType) {
2408     case FrameLoadType::Reload:
2409         return CachePolicyRevalidate;
2410     case FrameLoadType::Back:
2411     case FrameLoadType::Forward:
</pre>
<hr />
<pre>
2479 
2480             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2481             if (!pdl)
2482                 return;
2483 
2484             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2485             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2486             if (error.isNull())
2487                 return;
2488 
2489             // Check all children first.
2490             RefPtr&lt;HistoryItem&gt; item;
2491             if (Page* page = m_frame.page())
2492                 if (isBackForwardLoadType(loadType()))
2493                     // Reset the back forward list to the last committed history item at the top level.
2494                     item = page-&gt;mainFrame().loader().history().currentItem();
2495 
2496             // Only reset if we aren&#39;t already going to a new provisional item.
2497             bool shouldReset = !history().provisionalItem();
2498             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
<span class="line-modified">2499                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Failed provisional load (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());</span>
2500 
2501                 dispatchDidFailProvisionalLoad(*pdl, error);
2502                 ASSERT(!pdl-&gt;isLoading());
2503 
2504                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2505                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2506                     setDocumentLoader(m_provisionalDocumentLoader.get());
2507 
2508                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2509                 // delegate callback.
2510                 if (pdl == m_provisionalDocumentLoader)
2511                     clearProvisionalLoad();
2512                 else if (activeDocumentLoader()) {
2513                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2514                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2515                         shouldReset = false;
2516                 }
2517             }
2518             if (shouldReset &amp;&amp; item)
2519                 if (Page* page = m_frame.page()) {
</pre>
<hr />
<pre>
2541                 if (isBackForwardLoadType(m_loadType) || isReload(m_loadType))
2542                     history().restoreScrollPositionAndViewState();
2543             }
2544 
2545             if (m_stateMachine.creatingInitialEmptyDocument() || !m_stateMachine.committedFirstRealDocumentLoad())
2546                 return;
2547 
2548             m_progressTracker-&gt;progressCompleted();
2549             Page* page = m_frame.page();
2550             if (page) {
2551                 if (m_frame.isMainFrame()) {
2552                     tracePoint(MainResourceLoadDidEnd);
2553                     page-&gt;didFinishLoad();
2554                 }
2555             }
2556 
2557             const ResourceError&amp; error = m_documentLoader-&gt;mainDocumentError();
2558 
2559             AXObjectCache::AXLoadingEvent loadingEvent;
2560             if (!error.isNull()) {
<span class="line-modified">2561                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Finished frame load with error (frame = %p, main = %d, isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, &amp;m_frame, m_frame.isMainFrame(), error.isTimeout(), error.isCancellation(), error.errorCode());</span>
2562                 m_client.dispatchDidFailLoad(error);
2563                 loadingEvent = AXObjectCache::AXLoadingFailed;
2564             } else {
<span class="line-modified">2565                 RELEASE_LOG_IF_ALLOWED(&quot;checkLoadCompleteForThisFrame: Finished frame load (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
2566 #if ENABLE(DATA_DETECTION)
2567                 auto* document = m_frame.document();
2568                 if (m_frame.settings().dataDetectorTypes() != DataDetectorTypeNone &amp;&amp; document) {
2569                     if (auto* documentElement = document-&gt;documentElement()) {
2570                         RefPtr&lt;Range&gt; documentRange = makeRange(firstPositionInNode(documentElement), lastPositionInNode(documentElement));
2571                         m_frame.setDataDetectionResults(DataDetection::detectContentInRange(documentRange, m_frame.settings().dataDetectorTypes(), m_client.dataDetectionContext()));
2572                         if (m_frame.isMainFrame())
2573                             m_client.dispatchDidFinishDataDetection(m_frame.dataDetectionResults());
2574                     }
2575                 }
2576 #endif
2577                 m_client.dispatchDidFinishLoad();
2578                 loadingEvent = AXObjectCache::AXLoadingFinished;
2579             }
2580 
2581             // Notify accessibility.
2582             if (auto* document = m_frame.document()) {
2583                 if (AXObjectCache* cache = document-&gt;existingAXObjectCache())
2584                     cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
2585             }
</pre>
<hr />
<pre>
2727         if ((*frame)-&gt;page())
2728             (*frame)-&gt;loader().checkLoadCompleteForThisFrame();
2729     }
2730 }
2731 
2732 int FrameLoader::numPendingOrLoadingRequests(bool recurse) const
2733 {
2734     if (!recurse)
2735         return m_frame.document()-&gt;cachedResourceLoader().requestCount();
2736 
2737     int count = 0;
2738     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
2739         count += frame-&gt;document()-&gt;cachedResourceLoader().requestCount();
2740     return count;
2741 }
2742 
2743 String FrameLoader::userAgent(const URL&amp; url) const
2744 {
2745     String userAgent;
2746 
<span class="line-removed">2747     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader())</span>
<span class="line-removed">2748         userAgent = documentLoader-&gt;customUserAgent();</span>
<span class="line-removed">2749 </span>
<span class="line-removed">2750     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);</span>
<span class="line-removed">2751 </span>
<span class="line-removed">2752     if (!userAgent.isEmpty())</span>
<span class="line-removed">2753         return userAgent;</span>
<span class="line-removed">2754 </span>
<span class="line-removed">2755     return m_client.userAgent(url);</span>
<span class="line-removed">2756 }</span>
<span class="line-removed">2757 </span>
<span class="line-removed">2758 String FrameLoader::userAgentForJavaScript(const URL&amp; url) const</span>
<span class="line-removed">2759 {</span>
<span class="line-removed">2760     String userAgent;</span>
<span class="line-removed">2761 </span>
2762     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2763         if (m_frame.settings().needsSiteSpecificQuirks())
<span class="line-modified">2764             userAgent = documentLoader-&gt;customJavaScriptUserAgentAsSiteSpecificQuirks();</span>
2765         if (userAgent.isEmpty())
2766             userAgent = documentLoader-&gt;customUserAgent();
2767     }
2768 
2769     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2770 
2771     if (!userAgent.isEmpty())
2772         return userAgent;
2773 
2774     return m_client.userAgent(url);
2775 }
2776 
2777 String FrameLoader::navigatorPlatform() const
2778 {
2779     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2780         auto&amp; customNavigatorPlatform = documentLoader-&gt;customNavigatorPlatform();
2781         if (!customNavigatorPlatform.isEmpty())
2782             return customNavigatorPlatform;
2783     }
2784     return String();
2785 }
2786 
2787 void FrameLoader::dispatchOnloadEvents()
2788 {
2789     m_client.dispatchDidDispatchOnloadEvents();
2790 
2791     if (documentLoader())
2792         documentLoader()-&gt;dispatchOnloadEvents();
2793 }
2794 
2795 void FrameLoader::frameDetached()
2796 {
2797     // Calling stopAllLoadersAndCheckCompleteness() can cause the frame to be deallocated, including the frame loader.
2798     Ref&lt;Frame&gt; protectedFrame(m_frame);
2799 
2800     if (m_checkTimer.isActive()) {
2801         m_checkTimer.stop();
2802         checkCompletenessNow();
2803     }
2804 
<span class="line-modified">2805     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {</span>
2806         stopAllLoadersAndCheckCompleteness();
2807         m_frame.document()-&gt;stopActiveDOMObjects();
2808     }
2809 
2810     detachFromParent();
2811 }
2812 
2813 void FrameLoader::detachFromParent()
2814 {
2815     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2816     Ref&lt;Frame&gt; protect(m_frame);
2817 
2818     closeURL();
2819     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2820     detachChildren();
<span class="line-modified">2821     if (m_frame.document()-&gt;pageCacheState() != Document::InPageCache) {</span>
<span class="line-modified">2822         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the page cache,</span>
2823         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2824         // handlers might start a new subresource load in this frame.
2825         stopAllLoaders(ShouldClearProvisionalItem, StopLoadingPolicy::AlwaysStopLoading);
2826     }
2827 
2828     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2829 
2830     detachViewsAndDocumentLoader();
2831 
2832     m_progressTracker = nullptr;
2833 
2834     if (Frame* parent = m_frame.tree().parent()) {
2835         parent-&gt;loader().closeAndRemoveChild(m_frame);
2836         parent-&gt;loader().scheduleCheckCompleted();
2837         parent-&gt;loader().scheduleCheckLoadComplete();
2838     } else {
2839         m_frame.setView(nullptr);
2840         m_frame.willDetachPage();
2841         m_frame.detachFromPage();
2842     }
</pre>
<hr />
<pre>
2912             request.setFirstPartyForCookies(document-&gt;firstPartyForCookies());
2913     }
2914 
2915     if (request.isSameSiteUnspecified()) {
2916         auto* initiator = m_frame.document();
2917         if (isMainResource) {
2918             auto* ownerFrame = m_frame.tree().parent();
2919             if (!ownerFrame &amp;&amp; m_stateMachine.isDisplayingInitialEmptyDocument())
2920                 ownerFrame = m_opener;
2921             if (ownerFrame)
2922                 initiator = ownerFrame-&gt;document();
2923             ASSERT(ownerFrame || m_frame.isMainFrame());
2924         }
2925         addSameSiteInfoToRequestIfNeeded(request, initiator);
2926     }
2927     request.setIsTopSite(isMainFrameMainResource);
2928 
2929     Page* page = frame().page();
2930     bool hasSpecificCachePolicy = request.cachePolicy() != ResourceRequestCachePolicy::UseProtocolCachePolicy;
2931 
<span class="line-modified">2932     if (page &amp;&amp; page-&gt;isResourceCachingDisabled()) {</span>
2933         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
2934         loadType = FrameLoadType::ReloadFromOrigin;
2935     } else if (!hasSpecificCachePolicy)
2936         request.setCachePolicy(defaultRequestCachingPolicy(request, loadType, isMainResource));
2937 
2938     // The remaining modifications are only necessary for HTTP and HTTPS.
2939     if (!request.url().isEmpty() &amp;&amp; !request.url().protocolIsInHTTPFamily())
2940         return;
2941 
2942     if (!hasSpecificCachePolicy &amp;&amp; request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData) {
2943         if (loadType == FrameLoadType::Reload)
<span class="line-modified">2944             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;max-age=0&quot;);</span>
2945         else if (loadType == FrameLoadType::ReloadFromOrigin) {
<span class="line-modified">2946             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;no-cache&quot;);</span>
<span class="line-modified">2947             request.setHTTPHeaderField(HTTPHeaderName::Pragma, &quot;no-cache&quot;);</span>
2948         }
2949     }
2950 
2951     if (m_overrideResourceLoadPriorityForTesting)
2952         request.setPriority(m_overrideResourceLoadPriorityForTesting.value());
2953 
2954     applyUserAgentIfNeeded(request);
2955 
2956     if (isMainResource)
2957         request.setHTTPAccept(defaultAcceptHeader);
2958 
2959     // Make sure we send the Origin header.
2960     addHTTPOriginIfNeeded(request, String());
2961 
2962     // Only set fallback array if it&#39;s still empty (later attempts may be incorrect, see bug 117818).
2963     if (request.responseContentDispositionEncodingFallbackArray().isEmpty()) {
2964         // Always try UTF-8. If that fails, try frame encoding (if any) and then the default.
2965         request.setResponseContentDispositionEncodingFallbackArray(&quot;UTF-8&quot;, m_frame.document()-&gt;encoding(), m_frame.settings().defaultTextEncodingName());
2966     }
2967 }
</pre>
<hr />
<pre>
3006     }
3007     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
3008         request.setIsSameSite(true);
3009         return;
3010     }
3011     request.setIsSameSite(areRegistrableDomainsEqual(initiator-&gt;siteForCookies(), request.url()));
3012 }
3013 
3014 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
3015 {
3016     if (request.url().protocolIs(&quot;https&quot;)) {
3017         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
3018         return;
3019     }
3020 
3021     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
3022 }
3023 
3024 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
3025 {
<span class="line-modified">3026     RELEASE_LOG_IF_ALLOWED(&quot;loadPostRequest: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
3027 
3028     String frameName = request.frameName();
3029     LockHistory lockHistory = request.lockHistory();
3030     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
3031     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
3032 
3033     const ResourceRequest&amp; inRequest = request.resourceRequest();
3034     const URL&amp; url = inRequest.url();
3035     const String&amp; contentType = inRequest.httpContentType();
3036     String origin = inRequest.httpOrigin();
3037 
3038     ResourceRequest workingResourceRequest(url);
3039 
3040     if (!referrer.isEmpty())
3041         workingResourceRequest.setHTTPReferrer(referrer);
3042     workingResourceRequest.setHTTPOrigin(origin);
3043     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3044     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3045     workingResourceRequest.setHTTPContentType(contentType);
3046     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3047 
3048     if (Document* document = m_frame.document())
3049         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3050 
3051     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3052 
3053     if (!frameName.isEmpty()) {
3054         // The search for a target frame is done earlier in the case of form submission.
3055         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
3056             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, WTFMove(completionHandler));
3057             return;
3058         }
3059 
<span class="line-modified">3060         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue) mutable {</span>
3061             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3062             completionHandler();
3063         });
3064         return;
3065     }
3066 
3067     // must grab this now, since this load may stop the previous load and clear this flag
3068     bool isRedirect = m_quickRedirectComing;
3069     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {
3070         if (isRedirect) {
3071             m_quickRedirectComing = false;
3072             if (m_provisionalDocumentLoader)
3073                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3074             else if (m_policyDocumentLoader)
3075                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3076         }
3077         completionHandler();
3078     });
3079 }
3080 
</pre>
<hr />
<pre>
3109                     newRequest = { };
3110                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3111                     response = { };
3112                     data = nullptr;
3113                 }
3114             }
3115         }
3116     }
3117 #endif
3118 
3119     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3120 
3121     if (error.isNull()) {
3122         ASSERT(!newRequest.isNull());
3123 
3124         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3125             Vector&lt;char&gt; buffer;
3126             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3127             data = SharedBuffer::create(WTFMove(buffer));
3128             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
<span class="line-modified">3129             ResourceLoadObserver::shared().logSubresourceLoading(&amp;m_frame, newRequest, response);</span>

3130         }
3131     }
3132     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, data ? data-&gt;data() : nullptr, data ? data-&gt;size() : 0, -1, error);
3133     return identifier;
3134 }
3135 
3136 const ResourceRequest&amp; FrameLoader::originalRequest() const
3137 {
3138     return activeDocumentLoader()-&gt;originalRequestCopy();
3139 }
3140 
3141 void FrameLoader::receivedMainResourceError(const ResourceError&amp; error)
3142 {
3143     // Retain because the stop may release the last reference to it.
3144     Ref&lt;Frame&gt; protect(m_frame);
3145 
3146     RefPtr&lt;DocumentLoader&gt; loader = activeDocumentLoader();
3147     // FIXME: Don&#39;t want to do this if an entirely new load is going, so should check
3148     // that both data sources on the frame are either this or nil.
3149     stop();
3150     if (m_client.shouldFallBack(error))
3151         handleFallbackContent();
3152 
3153     if (m_state == FrameStateProvisional &amp;&amp; m_provisionalDocumentLoader) {
3154         if (m_submittedFormURL == m_provisionalDocumentLoader-&gt;originalRequestCopy().url())
3155             m_submittedFormURL = URL();
3156 
<span class="line-modified">3157         // We might have made a page cache item, but now we&#39;re bailing out due to an error before we ever</span>
3158         // transitioned to the new page (before WebFrameState == commit).  The goal here is to restore any state
3159         // so that the existing view (that wenever got far enough to replace) can continue being used.
3160         history().invalidateCurrentItemCachedPage();
3161 
3162         // Call clientRedirectCancelledOrFinished here so that the frame load delegate is notified that the redirect&#39;s
3163         // status has changed, if there was a redirect. The frame load delegate may have saved some state about
3164         // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:. Since we are definitely
3165         // not going to use this provisional resource, as it was cancelled, notify the frame load delegate that the redirect
3166         // has ended.
3167         if (m_sentRedirectNotification)
3168             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3169     }
3170 
3171     checkCompleted();
3172     if (m_frame.page())
3173         checkLoadComplete();
3174 }
3175 
3176 void FrameLoader::continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp; request, bool shouldContinue)
3177 {
3178     m_quickRedirectComing = false;
3179 
3180     if (!shouldContinue)
3181         return;
3182 
3183     // Calling stopLoading() on the provisional document loader can cause the underlying
3184     // frame to be deallocated.
3185     Ref&lt;Frame&gt; protectedFrame(m_frame);
3186 
3187     // If we have a provisional request for a different document, a fragment scroll should cancel it.
3188     if (m_provisionalDocumentLoader &amp;&amp; !equalIgnoringFragmentIdentifier(m_provisionalDocumentLoader-&gt;request().url(), request.url())) {
3189         m_provisionalDocumentLoader-&gt;stopLoading();

3190         setProvisionalDocumentLoader(nullptr);
3191     }
3192 
3193     bool isRedirect = m_quickRedirectComing || policyChecker().loadType() == FrameLoadType::RedirectWithLockedBackForwardList;
3194     loadInSameDocument(request.url(), 0, !isRedirect);
3195 }
3196 
3197 bool FrameLoader::shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType loadType, const URL&amp; url)
3198 {
3199     // We don&#39;t do this if we are submitting a form with method other than &quot;GET&quot;, explicitly reloading,
3200     // currently displaying a frameset, or if the URL does not have a fragment.
3201     // These rules were originally based on what KHTML was doing in KHTMLPart::openURL.
3202 
3203     // FIXME: What about load types other than Standard and Reload?
3204 
3205     return (!isFormSubmission || equalLettersIgnoringASCIICase(httpMethod, &quot;get&quot;))
3206         &amp;&amp; !isReload(loadType)
3207         &amp;&amp; loadType != FrameLoadType::Same
<span class="line-modified">3208         &amp;&amp; m_frame.document()-&gt;pageCacheState() != Document::InPageCache</span>
3209         &amp;&amp; !shouldReload(m_frame.document()-&gt;url(), url)
3210         // We don&#39;t want to just scroll if a link from within a
3211         // frameset is trying to reload the frameset into _top.
3212         &amp;&amp; !m_frame.document()-&gt;isFrameSet();
3213 }
3214 
3215 static bool itemAllowsScrollRestoration(HistoryItem* historyItem)
3216 {
3217     return !historyItem || historyItem-&gt;shouldRestoreScrollPosition();
3218 }
3219 
3220 static bool isSameDocumentReload(bool isNewNavigation, FrameLoadType loadType)
3221 {
3222     return !isNewNavigation &amp;&amp; !isBackForwardLoadType(loadType);
3223 }
3224 
3225 void FrameLoader::scrollToFragmentWithParentBoundary(const URL&amp; url, bool isNewNavigation)
3226 {
<span class="line-modified">3227     FrameView* view = m_frame.view();</span>
<span class="line-modified">3228     if (!view)</span>

3229         return;
3230 
<span class="line-modified">3231     if (isSameDocumentReload(isNewNavigation, m_loadType) || itemAllowsScrollRestoration(history().currentItem()))</span>
<span class="line-modified">3232         view-&gt;scrollToFragment(url);</span>






3233 }
3234 
3235 bool FrameLoader::shouldClose()
3236 {
3237     Page* page = m_frame.page();
3238     if (!page)
3239         return true;
3240     if (!page-&gt;chrome().canRunBeforeUnloadConfirmPanel())
3241         return true;
3242 
3243     // Store all references to each subframe in advance since beforeunload&#39;s event handler may modify frame
3244     Vector&lt;Ref&lt;Frame&gt;, 16&gt; targetFrames;
3245     targetFrames.append(m_frame);
3246     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().traverseNext(&amp;m_frame))
3247         targetFrames.append(*child);
3248 
3249     bool shouldClose = false;
3250     {
3251         NavigationDisabler navigationDisabler(&amp;m_frame);
3252         IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
</pre>
<hr />
<pre>
3263             shouldClose = true;
3264     }
3265 
3266     if (!shouldClose)
3267         m_submittedFormURL = URL();
3268 
3269     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3270     return shouldClose;
3271 }
3272 
3273 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3274 {
3275     if (!m_frame.document())
3276         return;
3277 
3278     if (m_pageDismissalEventBeingDispatched != PageDismissalType::None)
3279         return;
3280 
3281     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3282     ForbidPromptsScope forbidPrompts(m_frame.page());

3283     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3284 
3285     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3286         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3287         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3288             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3289         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3290             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3291                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
<span class="line-modified">3292                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;pageCacheState() == Document::AboutToEnterPageCache), m_frame.document());</span>
3293             }
3294 
3295             // FIXME: update Page Visibility state here.
3296             // https://bugs.webkit.org/show_bug.cgi?id=116770
3297 
<span class="line-modified">3298             if (m_frame.document()-&gt;pageCacheState() == Document::NotInPageCache) {</span>
3299                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3300                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
3301                 // while dispatching the event, so protect it to prevent writing the end
3302                 // time into freed memory.
3303                 RefPtr&lt;DocumentLoader&gt; documentLoader = m_provisionalDocumentLoader;
3304                 m_pageDismissalEventBeingDispatched = PageDismissalType::Unload;
3305                 if (documentLoader &amp;&amp; documentLoader-&gt;timing().startTime() &amp;&amp; !documentLoader-&gt;timing().unloadEventStart() &amp;&amp; !documentLoader-&gt;timing().unloadEventEnd()) {
3306                     auto&amp; timing = documentLoader-&gt;timing();
3307                     timing.markUnloadEventStart();
3308                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3309                     timing.markUnloadEventEnd();
3310                 } else
3311                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3312             }
3313         }
3314         m_pageDismissalEventBeingDispatched = PageDismissalType::None;
3315         m_wasUnloadEventEmitted = true;
3316     }
3317 
3318     // Dispatching the unload event could have made m_frame.document() null.
3319     if (!m_frame.document())
3320         return;
3321 
<span class="line-modified">3322     if (m_frame.document()-&gt;pageCacheState() != Document::NotInPageCache)</span>
3323         return;
3324 
3325     // Don&#39;t remove event listeners from a transitional empty document (see bug 28716 for more information).
3326     bool keepEventListeners = m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_provisionalDocumentLoader
3327         &amp;&amp; m_frame.document()-&gt;isSecureTransitionTo(m_provisionalDocumentLoader-&gt;url());
3328 
3329     if (!keepEventListeners)
3330         m_frame.document()-&gt;removeAllEventListeners();
3331 }
3332 
3333 static bool shouldAskForNavigationConfirmation(Document&amp; document, const BeforeUnloadEvent&amp; event)
3334 {
3335     // Confirmation dialog should not be displayed when the allow-modals flag is not set.
3336     if (document.isSandboxed(SandboxModals))
3337         return false;
3338 
3339     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3340     // Web pages can request we ask for confirmation before navigating by:
3341     // - Cancelling the BeforeUnloadEvent (modern way)
3342     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3343     // - Returning a non-empty string from the event handler, which is then set as returnValue
3344     //   attribute on the BeforeUnloadEvent.
3345     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3346 }
3347 
3348 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3349 {
3350     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3351     if (!domWindow)
3352         return true;
3353 
3354     RefPtr&lt;Document&gt; document = m_frame.document();
3355     if (!document-&gt;bodyOrFrameset())
3356         return true;
3357 
3358     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();
3359 
3360     {
3361         SetForScope&lt;PageDismissalType&gt; change(m_pageDismissalEventBeingDispatched, PageDismissalType::BeforeUnload);
3362         ForbidPromptsScope forbidPrompts(m_frame.page());

3363         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3364     }
3365 
3366     if (!beforeUnloadEvent-&gt;defaultPrevented())
3367         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3368 
3369     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3370         return true;
3371 
3372     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3373     // this frame is not allowed to cause another one to be shown.
3374     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3375         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3376         return true;
3377     }
3378 
3379     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3380     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3381     if (frameLoaderBeingNavigated != this) {
3382         Frame* parentFrame = m_frame.tree().parent();
</pre>
<hr />
<pre>
3402 
3403     frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel = true;
3404 
3405     String text = document-&gt;displayStringModifiedByEncoding(beforeUnloadEvent-&gt;returnValue());
3406     return chrome.runBeforeUnloadConfirmPanel(text, m_frame);
3407 }
3408 
3409 void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, NavigationPolicyDecision navigationPolicyDecision, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
3410 {
3411     // If we loaded an alternate page to replace an unreachableURL, we&#39;ll get in here with a
3412     // nil policyDataSource because loading the alternate page will have passed
3413     // through this method already, nested; otherwise, policyDataSource should still be set.
3414     ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());
3415 
3416     bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;
3417 
3418     bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();
3419     bool canContinue = navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;
3420 
3421     if (!canContinue) {
<span class="line-modified">3422         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame due to the following reasons (&quot;</span>
<span class="line-removed">3423             &quot;frame = %p, &quot;</span>
<span class="line-removed">3424             &quot;main = %d, &quot;</span>
3425             &quot;allowNavigationToInvalidURL = %d, &quot;
3426             &quot;requestURLIsValid = %d, &quot;
3427             &quot;navigationPolicyDecision = %d)&quot;,
<span class="line-removed">3428             &amp;m_frame,</span>
<span class="line-removed">3429             m_frame.isMainFrame(),</span>
3430             static_cast&lt;int&gt;(allowNavigationToInvalidURL),
3431             request.url().isValid(),
3432             static_cast&lt;int&gt;(navigationPolicyDecision));
3433 
3434         // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we
3435         // need to report that the client redirect was cancelled.
3436         // FIXME: The client should be told about ignored non-quick redirects, too.
3437         if (m_quickRedirectComing)
3438             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3439 
3440         if (navigationPolicyDecision == NavigationPolicyDecision::StopAllLoads) {
3441             stopAllLoaders();
3442             m_checkTimer.stop();
3443         }
3444 
3445         setPolicyDocumentLoader(nullptr);
3446         checkCompleted();
3447 
3448         if (navigationPolicyDecision != NavigationPolicyDecision::StopAllLoads)
3449             checkLoadComplete();
3450 
3451         // If the navigation request came from the back/forward menu, and we punt on it, we have the
3452         // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,
3453         // we only do this when punting a navigation for the target frame or top-level frame.
3454         if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) {
3455             if (Page* page = m_frame.page()) {
3456                 if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem())
3457                     page-&gt;backForward().setCurrentItem(*resetItem);
3458             }
3459         }
3460         return;
3461     }
3462 
3463     FrameLoadType type = policyChecker().loadType();
3464     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3465     stopAllLoaders(ShouldNotClearProvisionalItem);
3466 
3467     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3468     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3469     if (!m_frame.page()) {
<span class="line-modified">3470         RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
3471         return;
3472     }
3473 
3474     setProvisionalDocumentLoader(m_policyDocumentLoader.get());

3475     m_loadType = type;
3476     setState(FrameStateProvisional);
3477 
3478     setPolicyDocumentLoader(nullptr);
3479 
3480     if (isBackForwardLoadType(type)) {
3481         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
<span class="line-modified">3482         if (history().provisionalItem() &amp;&amp; history().provisionalItem()-&gt;isInPageCache()) {</span>
<span class="line-modified">3483             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);</span>
3484             loadProvisionalItemFromCachedPage();
<span class="line-modified">3485             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
3486             return;
3487         }
<span class="line-modified">3488         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);</span>
3489     }
3490 
3491     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3492         if (!m_provisionalDocumentLoader) {
<span class="line-modified">3493             RELEASE_LOG_IF_ALLOWED(&quot;continueLoadAfterNavigationPolicy completionHandler: Frame load canceled #1 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
3494             return;
3495         }
3496 
3497         prepareForLoadStart();
3498 
3499         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3500         // so we need to null check it again.
3501         if (!m_provisionalDocumentLoader) {
<span class="line-modified">3502             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Frame load canceled #2 (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
3503             return;
3504         }
3505 
3506         DocumentLoader* activeDocLoader = activeDocumentLoader();
3507         if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource()) {
<span class="line-modified">3508             RELEASE_LOG_IF_ALLOWED(&quot;prepareForLoadStart completionHandler: Main frame already being loaded (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
3509             return;
3510         }
3511 
3512         m_loadingFromCachedPage = false;
3513 
3514         m_provisionalDocumentLoader-&gt;startLoadingMainResource();
3515     };
3516 
3517     if (!formState) {
3518         completionHandler();
3519         return;
3520     }
3521 
3522     m_client.dispatchWillSubmitForm(*formState, WTFMove(completionHandler));
3523 }
3524 
3525 void FrameLoader::continueLoadAfterNewWindowPolicy(const ResourceRequest&amp; request,
<span class="line-modified">3526     FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, ShouldContinue shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL, NewFrameOpenerPolicy openerPolicy)</span>
3527 {
<span class="line-modified">3528     if (shouldContinue != ShouldContinue::Yes)</span>
3529         return;
3530 
3531     Ref&lt;Frame&gt; frame(m_frame);
3532     RefPtr&lt;Frame&gt; mainFrame = m_client.dispatchCreatePage(action);
3533     if (!mainFrame)
3534         return;
3535 
3536     SandboxFlags sandboxFlags = frame-&gt;loader().effectiveSandboxFlags();
3537     if (sandboxFlags &amp; SandboxPropagatesToAuxiliaryBrowsingContexts)
3538         mainFrame-&gt;loader().forceSandboxFlags(sandboxFlags);
3539 
3540     if (!equalIgnoringASCIICase(frameName, &quot;_blank&quot;))
3541         mainFrame-&gt;tree().setName(frameName);
3542 
3543     mainFrame-&gt;page()-&gt;setOpenedByDOM();
3544     mainFrame-&gt;loader().m_client.dispatchShow();
3545     if (openerPolicy == NewFrameOpenerPolicy::Allow) {
3546         mainFrame-&gt;loader().setOpener(frame.ptr());
3547         mainFrame-&gt;document()-&gt;setReferrerPolicy(frame-&gt;document()-&gt;referrerPolicy());
3548     }
</pre>
<hr />
<pre>
3637     case XFrameOptionsDeny:
3638         return true;
3639     case XFrameOptionsAllowAll:
3640         return false;
3641     case XFrameOptionsConflict:
3642         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Multiple &#39;X-Frame-Options&#39; headers with conflicting values (&#39;&quot; + content + &quot;&#39;) encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;. Falling back to &#39;DENY&#39;.&quot;, requestIdentifier);
3643         return true;
3644     case XFrameOptionsInvalid:
3645         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Invalid &#39;X-Frame-Options&#39; header encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;: &#39;&quot; + content + &quot;&#39; is not a recognized directive. The header will be ignored.&quot;, requestIdentifier);
3646         return false;
3647     case XFrameOptionsNone:
3648         return false;
3649     }
3650     ASSERT_NOT_REACHED();
3651     return false;
3652 }
3653 
3654 void FrameLoader::loadProvisionalItemFromCachedPage()
3655 {
3656     DocumentLoader* provisionalLoader = provisionalDocumentLoader();
<span class="line-modified">3657     LOG(PageCache, &quot;WebCorePageCache: Loading provisional DocumentLoader %p with URL &#39;%s&#39; from CachedPage&quot;, provisionalDocumentLoader(), provisionalDocumentLoader()-&gt;url().stringCenterEllipsizedToLength().utf8().data());</span>
3658 
3659     prepareForLoadStart();
3660 
3661     m_loadingFromCachedPage = true;
3662 
3663     // Should have timing data from previous time(s) the page was shown.
3664     ASSERT(provisionalLoader-&gt;timing().startTime());
3665     provisionalLoader-&gt;resetTiming();
3666     provisionalLoader-&gt;timing().markStartTime();
3667 
3668     provisionalLoader-&gt;setCommitted(true);
3669     commitProvisionalLoad();
3670 }
3671 
3672 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3673 {
3674     if (!history().currentItem())
3675         return false;
3676     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3677 }
</pre>
<hr />
<pre>
3711     // Save user view state to the current history item here since we don&#39;t do a normal load.
3712     // FIXME: Does form state need to be saved here too?
3713     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3714     if (FrameView* view = m_frame.view())
3715         view-&gt;setWasScrolledByUser(false);
3716 
3717     history().setCurrentItem(item);
3718 
3719     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3720     loadInSameDocument(item.url(), item.stateObject(), false);
3721 
3722     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3723     history().restoreScrollPositionAndViewState();
3724 }
3725 
3726 // FIXME: This function should really be split into a couple pieces, some of
3727 // which should be methods of HistoryController and some of which should be
3728 // methods of FrameLoader.
3729 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3730 {
<span class="line-modified">3731     RELEASE_LOG_IF_ALLOWED(&quot;loadDifferentDocumentItem: frame load started (frame = %p, main = %d)&quot;, &amp;m_frame, m_frame.isMainFrame());</span>
3732 
3733     Ref&lt;Frame&gt; protectedFrame(m_frame);
3734 
3735     // History items should not be reported to the parent.
3736     m_shouldReportResourceTimingToParentFrame = false;
3737 
3738     // Remember this item so we can traverse any child items as child frames load
3739     history().setProvisionalItem(&amp;item);
3740 
3741     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3742 
3743     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3744 
<span class="line-modified">3745     if (CachedPage* cachedPage = PageCache::singleton().get(item, m_frame.page())) {</span>
3746         auto documentLoader = cachedPage-&gt;documentLoader();
3747         m_client.updateCachedDocumentLoader(*documentLoader);
3748 
3749         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3750         action.setTargetBackForwardItem(item);
3751         action.setSourceBackForwardItem(fromItem);
3752         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3753 
3754         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3755         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3756         return;
3757     }
3758 
3759     URL itemURL = item.url();
3760     URL itemOriginalURL = item.originalURL();
3761     URL currentURL;
3762     if (documentLoader())
3763         currentURL = documentLoader()-&gt;url();
3764     RefPtr&lt;FormData&gt; formData = item.formData();
3765 
</pre>
<hr />
<pre>
3854     else
3855         loadDifferentDocumentItem(item, fromItem, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);
3856 }
3857 
3858 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3859 {
3860     ASSERT(m_state == FrameStateProvisional);
3861     ASSERT(!m_loadingFromCachedPage);
3862     ASSERT(history().provisionalItem());
3863     ASSERT(history().provisionalItem()-&gt;formData());
3864     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3865 
3866     FrameLoadType loadType = m_loadType;
3867     HistoryItem* item = history().provisionalItem();
3868 
3869     stopAllLoaders(ShouldNotClearProvisionalItem);
3870     if (item)
3871         loadDifferentDocumentItem(*item, history().currentItem(), loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
3872     else {
3873         ASSERT_NOT_REACHED();
<span class="line-modified">3874         RELEASE_LOG_ERROR(ResourceLoading, &quot;Retrying load after failed cache-only main resource load failed because there is no provisional history item.&quot;);</span>
3875     }
3876 }
3877 
3878 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3879 {
3880     ResourceError error = m_client.cancelledError(request);
3881     error.setType(ResourceError::Type::Cancellation);
3882     return error;
3883 }
3884 
3885 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3886 {
3887     return m_client.blockedByContentBlockerError(request);
3888 }
3889 
3890 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3891 {
3892     ResourceError error = m_client.blockedError(request);
3893     error.setType(ResourceError::Type::Cancellation);
3894     return error;
</pre>
</td>
<td>
<hr />
<pre>
  20  *     its contributors may be used to endorse or promote products derived
  21  *     from this software without specific prior written permission.
  22  *
  23  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  24  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  27  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  32  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33  */
  34 
  35 #include &quot;config.h&quot;
  36 #include &quot;FrameLoader.h&quot;
  37 
  38 #include &quot;AXObjectCache.h&quot;
  39 #include &quot;ApplicationCacheHost.h&quot;
<span class="line-added">  40 #include &quot;BackForwardCache.h&quot;</span>
  41 #include &quot;BackForwardController.h&quot;
  42 #include &quot;BeforeUnloadEvent.h&quot;
  43 #include &quot;CachedPage.h&quot;
  44 #include &quot;CachedResourceLoader.h&quot;
  45 #include &quot;Chrome.h&quot;
  46 #include &quot;ChromeClient.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ContentFilter.h&quot;
  49 #include &quot;ContentRuleListResults.h&quot;
  50 #include &quot;ContentSecurityPolicy.h&quot;
  51 #include &quot;CustomHeaderFields.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;DatabaseManager.h&quot;
  54 #include &quot;DiagnosticLoggingClient.h&quot;
  55 #include &quot;DiagnosticLoggingKeys.h&quot;
  56 #include &quot;Document.h&quot;
  57 #include &quot;DocumentLoader.h&quot;
  58 #include &quot;Editor.h&quot;
  59 #include &quot;EditorClient.h&quot;
  60 #include &quot;Element.h&quot;
  61 #include &quot;Event.h&quot;
  62 #include &quot;EventHandler.h&quot;
  63 #include &quot;EventNames.h&quot;
  64 #include &quot;FloatRect.h&quot;
  65 #include &quot;FormState.h&quot;
  66 #include &quot;FormSubmission.h&quot;
  67 #include &quot;Frame.h&quot;
  68 #include &quot;FrameLoadRequest.h&quot;
  69 #include &quot;FrameLoaderClient.h&quot;
  70 #include &quot;FrameNetworkingContext.h&quot;
  71 #include &quot;FrameTree.h&quot;
  72 #include &quot;FrameView.h&quot;
  73 #include &quot;GCController.h&quot;
  74 #include &quot;HTMLFormElement.h&quot;
  75 #include &quot;HTMLInputElement.h&quot;
  76 #include &quot;HTMLNames.h&quot;
  77 #include &quot;HTMLObjectElement.h&quot;
  78 #include &quot;HTMLParserIdioms.h&quot;
  79 #include &quot;HTTPHeaderNames.h&quot;
<span class="line-added">  80 #include &quot;HTTPHeaderValues.h&quot;</span>
  81 #include &quot;HTTPParsers.h&quot;
  82 #include &quot;HistoryController.h&quot;
  83 #include &quot;HistoryItem.h&quot;
  84 #include &quot;IgnoreOpensDuringUnloadCountIncrementer.h&quot;
  85 #include &quot;InspectorController.h&quot;
  86 #include &quot;InspectorInstrumentation.h&quot;
  87 #include &quot;LinkLoader.h&quot;
  88 #include &quot;LoadTiming.h&quot;
  89 #include &quot;LoaderStrategy.h&quot;
  90 #include &quot;Logging.h&quot;
  91 #include &quot;MemoryCache.h&quot;
  92 #include &quot;MemoryRelease.h&quot;
  93 #include &quot;NavigationDisabler.h&quot;
  94 #include &quot;NavigationScheduler.h&quot;
  95 #include &quot;Node.h&quot;
  96 #include &quot;Page.h&quot;

  97 #include &quot;PageTransitionEvent.h&quot;
  98 #include &quot;PerformanceLogging.h&quot;
  99 #include &quot;PlatformStrategies.h&quot;
 100 #include &quot;PluginData.h&quot;
 101 #include &quot;PluginDocument.h&quot;
 102 #include &quot;PolicyChecker.h&quot;
 103 #include &quot;ProgressTracker.h&quot;
 104 #include &quot;ResourceHandle.h&quot;
 105 #include &quot;ResourceLoadInfo.h&quot;
 106 #include &quot;ResourceLoadObserver.h&quot;
 107 #include &quot;ResourceRequest.h&quot;
 108 #include &quot;SVGDocument.h&quot;
 109 #include &quot;SVGLocatable.h&quot;
 110 #include &quot;SVGNames.h&quot;
 111 #include &quot;SVGViewElement.h&quot;
 112 #include &quot;SVGViewSpec.h&quot;
 113 #include &quot;ScriptController.h&quot;
 114 #include &quot;ScriptSourceCode.h&quot;
 115 #include &quot;ScrollAnimator.h&quot;
 116 #include &quot;SecurityOrigin.h&quot;
</pre>
<hr />
<pre>
 134 #include &lt;wtf/SetForScope.h&gt;
 135 #include &lt;wtf/StdLibExtras.h&gt;
 136 #include &lt;wtf/SystemTracing.h&gt;
 137 #include &lt;wtf/text/CString.h&gt;
 138 #include &lt;wtf/text/WTFString.h&gt;
 139 
 140 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 141 #include &quot;Archive.h&quot;
 142 #endif
 143 
 144 #if ENABLE(DATA_DETECTION)
 145 #include &quot;DataDetection.h&quot;
 146 #endif
 147 
 148 #if PLATFORM(IOS_FAMILY)
 149 #include &quot;DocumentType.h&quot;
 150 #include &quot;ResourceLoader.h&quot;
 151 #include &quot;RuntimeApplicationChecks.h&quot;
 152 #endif
 153 
<span class="line-modified"> 154 #define FRAMELOADER_RELEASE_LOG(channel, fmt, ...) RELEASE_LOG(channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)</span>
<span class="line-added"> 155 #define FRAMELOADER_RELEASE_LOG_ERROR(channel, fmt, ...) RELEASE_LOG(channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)</span>
<span class="line-added"> 156 #define FRAMELOADER_RELEASE_LOG_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)</span>
<span class="line-added"> 157 #define FRAMELOADER_RELEASE_LOG_ERROR_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameLoader::&quot; fmt, this, &amp;m_frame, m_frame.isMainFrame(), ##__VA_ARGS__)</span>
 158 
 159 namespace WebCore {
 160 
 161 using namespace HTMLNames;
 162 using namespace SVGNames;
 163 
 164 static const char defaultAcceptHeader[] = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;;
 165 
 166 bool isBackForwardLoadType(FrameLoadType type)
 167 {
 168     switch (type) {
 169     case FrameLoadType::Standard:
 170     case FrameLoadType::Reload:
 171     case FrameLoadType::ReloadFromOrigin:
 172     case FrameLoadType::ReloadExpiredOnly:
 173     case FrameLoadType::Same:
 174     case FrameLoadType::RedirectWithLockedBackForwardList:
 175     case FrameLoadType::Replace:
 176         return false;
 177     case FrameLoadType::Back:
</pre>
<hr />
<pre>
 197     case FrameLoadType::Back:
 198     case FrameLoadType::Forward:
 199     case FrameLoadType::IndexedBackForward:
 200         return false;
 201     }
 202     ASSERT_NOT_REACHED();
 203     return false;
 204 }
 205 
 206 // This is not in the FrameLoader class to emphasize that it does not depend on
 207 // private FrameLoader data, and to avoid increasing the number of public functions
 208 // with access to private data.  Since only this .cpp file needs it, making it
 209 // non-member lets us exclude it from the header file, thus keeping FrameLoader.h&#39;s
 210 // API simpler.
 211 //
 212 static bool isDocumentSandboxed(Frame&amp; frame, SandboxFlags mask)
 213 {
 214     return frame.document() &amp;&amp; frame.document()-&gt;isSandboxed(mask);
 215 }
 216 
<span class="line-modified"> 217 class PageLevelForbidScope {</span>
<span class="line-modified"> 218 protected:</span>
<span class="line-added"> 219     explicit PageLevelForbidScope(Page* page)</span>
<span class="line-added"> 220         : m_page(makeWeakPtr(page))</span>
 221     {
<span class="line-modified"> 222     }</span>
<span class="line-modified"> 223 </span>
<span class="line-modified"> 224     ~PageLevelForbidScope() = default;</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226     WeakPtr&lt;Page&gt; m_page;</span>
<span class="line-added"> 227 };</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229 struct ForbidPromptsScope : public PageLevelForbidScope {</span>
<span class="line-added"> 230     explicit ForbidPromptsScope(Page* page)</span>
<span class="line-added"> 231         : PageLevelForbidScope(page)</span>
<span class="line-added"> 232     {</span>
<span class="line-added"> 233         if (m_page)</span>
<span class="line-added"> 234             m_page-&gt;forbidPrompts();</span>
 235     }
 236 
 237     ~ForbidPromptsScope()
 238     {
<span class="line-modified"> 239         if (m_page)</span>
<span class="line-modified"> 240             m_page-&gt;allowPrompts();</span>

 241     }
<span class="line-added"> 242 };</span>
 243 
<span class="line-modified"> 244 struct ForbidSynchronousLoadsScope : public PageLevelForbidScope {</span>
<span class="line-added"> 245     explicit ForbidSynchronousLoadsScope(Page* page)</span>
<span class="line-added"> 246         : PageLevelForbidScope(page)</span>
<span class="line-added"> 247     {</span>
<span class="line-added"> 248         if (m_page)</span>
<span class="line-added"> 249             m_page-&gt;forbidSynchronousLoads();</span>
<span class="line-added"> 250     }</span>
<span class="line-added"> 251 </span>
<span class="line-added"> 252     ~ForbidSynchronousLoadsScope()</span>
<span class="line-added"> 253     {</span>
<span class="line-added"> 254         if (m_page)</span>
<span class="line-added"> 255             m_page-&gt;allowSynchronousLoads();</span>
<span class="line-added"> 256     }</span>
 257 };
 258 
 259 class FrameLoader::FrameProgressTracker {
 260     WTF_MAKE_FAST_ALLOCATED;
 261 public:
 262     explicit FrameProgressTracker(Frame&amp; frame)
 263         : m_frame(frame)
 264         , m_inProgress(false)
 265     {
 266     }
 267 
 268     ~FrameProgressTracker()
 269     {
 270         if (m_inProgress &amp;&amp; m_frame.page())
 271             m_frame.page()-&gt;progress().progressCompleted(m_frame);
 272     }
 273 
 274     void progressStarted()
 275     {
 276         ASSERT(m_frame.page());
 277         if (!m_inProgress)
 278             m_frame.page()-&gt;progress().progressStarted(m_frame);
 279         m_inProgress = true;
 280     }
 281 
 282     void progressCompleted()
 283     {
 284         ASSERT(m_inProgress);
 285         ASSERT(m_frame.page());
 286         m_inProgress = false;
 287         m_frame.page()-&gt;progress().progressCompleted(m_frame);
<span class="line-modified"> 288         platformStrategies()-&gt;loaderStrategy()-&gt;pageLoadCompleted(*m_frame.page());</span>


 289     }
 290 
 291 private:
 292     Frame&amp; m_frame;
 293     bool m_inProgress;
 294 };
 295 
 296 FrameLoader::FrameLoader(Frame&amp; frame, FrameLoaderClient&amp; client)
 297     : m_frame(frame)
 298     , m_client(client)
 299     , m_policyChecker(makeUnique&lt;PolicyChecker&gt;(frame))
 300     , m_history(makeUnique&lt;HistoryController&gt;(frame))
 301     , m_notifier(frame)
 302     , m_subframeLoader(makeUnique&lt;SubframeLoader&gt;(frame))
 303     , m_mixedContentChecker(frame)
 304     , m_state(FrameStateProvisional)
 305     , m_loadType(FrameLoadType::Standard)
 306     , m_quickRedirectComing(false)
 307     , m_sentRedirectNotification(false)
 308     , m_inStopAllLoaders(false)
 309     , m_isExecutingJavaScriptFormAction(false)
 310     , m_didCallImplicitClose(true)
 311     , m_wasUnloadEventEmitted(false)
 312     , m_isComplete(false)
 313     , m_needsClear(false)
 314     , m_checkTimer(*this, &amp;FrameLoader::checkTimerFired)
 315     , m_shouldCallCheckCompleted(false)
 316     , m_shouldCallCheckLoadComplete(false)
 317     , m_opener(nullptr)
 318     , m_loadingFromCachedPage(false)
 319     , m_currentNavigationHasShownBeforeUnloadConfirmPanel(false)
 320     , m_loadsSynchronously(false)
 321     , m_forcedSandboxFlags(SandboxNone)
 322 {
 323 }
 324 
 325 FrameLoader::~FrameLoader()
 326 {
 327     setOpener(nullptr);
<span class="line-modified"> 328     detachFromAllOpenedFrames();</span>


 329 
 330     m_client.frameLoaderDestroyed();
 331 
 332     if (m_networkingContext)
 333         m_networkingContext-&gt;invalidate();
 334 }
 335 
<span class="line-added"> 336 void FrameLoader::detachFromAllOpenedFrames()</span>
<span class="line-added"> 337 {</span>
<span class="line-added"> 338     for (auto&amp; frame : m_openedFrames)</span>
<span class="line-added"> 339         frame-&gt;loader().m_opener = nullptr;</span>
<span class="line-added"> 340     m_openedFrames.clear();</span>
<span class="line-added"> 341 }</span>
<span class="line-added"> 342 </span>
 343 void FrameLoader::init()
 344 {
 345     // This somewhat odd set of steps gives the frame an initial empty document.
 346     setPolicyDocumentLoader(m_client.createDocumentLoader(ResourceRequest(URL({ }, emptyString())), SubstituteData()).ptr());
 347     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
 348     m_provisionalDocumentLoader-&gt;startLoadingMainResource();
 349 
 350     Ref&lt;Frame&gt; protect(m_frame);
 351     m_frame.document()-&gt;cancelParsing();
 352     m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocument);
 353 
 354     m_networkingContext = m_client.createNetworkingContext();
 355     m_progressTracker = makeUnique&lt;FrameProgressTracker&gt;(m_frame);
 356 }
 357 
 358 void FrameLoader::initForSynthesizedDocument(const URL&amp;)
 359 {
 360     // FIXME: We need to initialize the document URL to the specified URL. Currently the URL is empty and hence
 361     // FrameLoader::checkCompleted() will overwrite the URL of the document to be activeDocumentLoader()-&gt;documentURL().
 362 
</pre>
<hr />
<pre>
 407     // FIXME: Validate the policy check identifier.
 408     client().dispatchDecidePolicyForResponse(response, activeDocumentLoader()-&gt;request(), identifier, activeDocumentLoader()-&gt;downloadAttribute(), WTFMove(function));
 409 }
 410 
 411 void FrameLoader::changeLocation(FrameLoadRequest&amp;&amp; request)
 412 {
 413     urlSelected(WTFMove(request), nullptr);
 414 }
 415 
 416 void FrameLoader::urlSelected(const URL&amp; url, const String&amp; passedTarget, Event* triggeringEvent, LockHistory lockHistory, LockBackForwardList lockBackForwardList, ShouldSendReferrer shouldSendReferrer, ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; openerPolicy, const AtomString&amp; downloadAttribute, const SystemPreviewInfo&amp; systemPreviewInfo, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 417 {
 418     auto* frame = lexicalFrameFromCommonVM();
 419     auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 420 
 421     NewFrameOpenerPolicy newFrameOpenerPolicy = openerPolicy.valueOr(shouldSendReferrer == NeverSendReferrer ? NewFrameOpenerPolicy::Suppress : NewFrameOpenerPolicy::Allow);
 422     urlSelected(FrameLoadRequest(*m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, passedTarget, lockHistory, lockBackForwardList, shouldSendReferrer, AllowNavigationToInvalidURL::Yes, newFrameOpenerPolicy, shouldOpenExternalURLsPolicy, initiatedByMainFrame, DoNotReplaceDocumentIfJavaScriptURL, downloadAttribute, systemPreviewInfo), triggeringEvent, WTFMove(adClickAttribution));
 423 }
 424 
 425 void FrameLoader::urlSelected(FrameLoadRequest&amp;&amp; frameRequest, Event* triggeringEvent, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
 426 {
<span class="line-modified"> 427     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;urlSelected: frame load started&quot;);</span>
 428 
 429     Ref&lt;Frame&gt; protect(m_frame);
 430 
<span class="line-modified"> 431     if (m_frame.script().executeIfJavaScriptURL(frameRequest.resourceRequest().url(), &amp;frameRequest.requester().securityOrigin(), frameRequest.shouldReplaceDocumentIfJavaScriptURL())) {</span>
<span class="line-added"> 432         m_quickRedirectComing = false;</span>
 433         return;
<span class="line-added"> 434     }</span>
 435 
 436     if (frameRequest.frameName().isEmpty())
 437         frameRequest.setFrameName(m_frame.document()-&gt;baseTarget());
 438 
 439     addHTTPOriginIfNeeded(frameRequest.resourceRequest(), outgoingOrigin());
 440     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(frameRequest.resourceRequest(), ContentSecurityPolicy::InsecureRequestType::Navigation);
 441 
 442     loadFrameRequest(WTFMove(frameRequest), triggeringEvent, { }, WTFMove(adClickAttribution));
 443 }
 444 
 445 void FrameLoader::submitForm(Ref&lt;FormSubmission&gt;&amp;&amp; submission)
 446 {
 447     ASSERT(submission-&gt;method() == FormSubmission::Method::Post || submission-&gt;method() == FormSubmission::Method::Get);
 448 
 449     // FIXME: Find a good spot for these.
 450     ASSERT(!submission-&gt;state().sourceDocument().frame() || submission-&gt;state().sourceDocument().frame() == &amp;m_frame);
 451 
 452     if (!m_frame.page())
 453         return;
 454 
 455     if (submission-&gt;action().isEmpty())
 456         return;
 457 
 458     if (isDocumentSandboxed(m_frame, SandboxForms)) {
 459         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
 460         m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked form submission to &#39;&quot; + submission-&gt;action().stringCenterEllipsizedToLength() + &quot;&#39; because the form&#39;s frame is sandboxed and the &#39;allow-forms&#39; permission is not set.&quot;);
 461         return;
 462     }
 463 
 464     if (WTF::protocolIsJavaScript(submission-&gt;action())) {
 465         if (!m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowFormAction(URL(submission-&gt;action())))
 466             return;
 467         m_isExecutingJavaScriptFormAction = true;
 468         Ref&lt;Frame&gt; protect(m_frame);
<span class="line-modified"> 469         m_frame.script().executeIfJavaScriptURL(submission-&gt;action(), nullptr, DoNotReplaceDocumentIfJavaScriptURL);</span>
 470         m_isExecutingJavaScriptFormAction = false;
 471         return;
 472     }
 473 
 474     Frame* targetFrame = findFrameForNavigation(submission-&gt;target(), &amp;submission-&gt;state().sourceDocument());
 475     if (!targetFrame) {
 476         if (!DOMWindow::allowPopUp(m_frame) &amp;&amp; !UserGestureIndicator::processingUserGesture())
 477             return;
 478 
 479         // FIXME: targetFrame can be null for two distinct reasons:
 480         // 1. The frame was not found by name, so we should try opening a new window.
 481         // 2. The frame was found, but navigating it was not allowed, e.g. by HTML5 sandbox or by origin checks.
 482         // Continuing form submission makes no sense in the latter case.
 483         // There is a repeat check after timer fires, so this is not a correctness issue.
 484 
 485         targetFrame = &amp;m_frame;
 486     } else
 487         submission-&gt;clearTarget();
 488 
 489     if (!targetFrame-&gt;page())
 490         return;
 491 
<span class="line-modified"> 492     if (m_frame.tree().isDescendantOf(targetFrame))</span>














 493         m_submittedFormURL = submission-&gt;requestURL();

 494 
 495     submission-&gt;setReferrer(outgoingReferrer());
 496     submission-&gt;setOrigin(outgoingOrigin());
 497 
 498     targetFrame-&gt;navigationScheduler().scheduleFormSubmission(WTFMove(submission));
 499 }
 500 
 501 void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy)
 502 {
 503     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parser())
 504         m_frame.document()-&gt;parser()-&gt;stopParsing();
 505 
 506     if (unloadEventPolicy != UnloadEventPolicyNone)
 507         dispatchUnloadEvents(unloadEventPolicy);
 508 
 509     m_isComplete = true; // to avoid calling completed() in finishedParsing()
 510     m_didCallImplicitClose = true; // don&#39;t want that one either
 511 
 512     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;parsing()) {
 513         finishedParsing();
</pre>
<hr />
<pre>
 544     if (m_frame.editor().hasComposition()) {
 545         // The text was already present in DOM, so it&#39;s better to confirm than to cancel the composition.
 546         m_frame.editor().confirmComposition();
 547         if (EditorClient* editorClient = m_frame.editor().client()) {
 548             editorClient-&gt;respondToChangedSelection(&amp;m_frame);
 549             editorClient-&gt;discardedComposition(&amp;m_frame);
 550         }
 551     }
 552 }
 553 
 554 bool FrameLoader::closeURL()
 555 {
 556     history().saveDocumentState();
 557 
 558     Document* currentDocument = m_frame.document();
 559     UnloadEventPolicy unloadEventPolicy;
 560     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;chrome().client().isSVGImageChromeClient()) {
 561         // If this is the SVGDocument of an SVGImage, no need to dispatch events or recalcStyle.
 562         unloadEventPolicy = UnloadEventPolicyNone;
 563     } else {
<span class="line-modified"> 564         // Should only send the pagehide event here if the current document exists and has not been placed in the back/forward cache.</span>
<span class="line-modified"> 565         unloadEventPolicy = currentDocument &amp;&amp; currentDocument-&gt;backForwardCacheState() == Document::NotInBackForwardCache ? UnloadEventPolicyUnloadAndPageHide : UnloadEventPolicyUnloadOnly;</span>
 566     }
 567 
 568     stopLoading(unloadEventPolicy);
 569 
 570     m_frame.editor().clearUndoRedoOperations();
 571     return true;
 572 }
 573 
 574 bool FrameLoader::didOpenURL()
 575 {
 576     if (m_frame.navigationScheduler().redirectScheduledDuringLoad()) {
 577         // A redirect was scheduled before the document was created.
 578         // This can happen when one frame changes another frame&#39;s location.
 579         return false;
 580     }
 581 
 582     m_frame.navigationScheduler().cancel();
 583     m_frame.editor().clearLastEditCommand();
 584 
 585     m_isComplete = false;
</pre>
<hr />
<pre>
 591     if (!m_stateMachine.creatingInitialEmptyDocument()) {
 592         DOMWindow* window = m_frame.document()-&gt;domWindow();
 593         window-&gt;setStatus(String());
 594         window-&gt;setDefaultStatus(String());
 595     }
 596 
 597     started();
 598 
 599     return true;
 600 }
 601 
 602 void FrameLoader::didExplicitOpen()
 603 {
 604     m_isComplete = false;
 605     m_didCallImplicitClose = false;
 606 
 607     // Calling document.open counts as committing the first real document load.
 608     if (!m_stateMachine.committedFirstRealDocumentLoad())
 609         m_stateMachine.advanceTo(FrameLoaderStateMachine::DisplayingInitialEmptyDocumentPostCommit);
 610 
<span class="line-modified"> 611     if (auto* document = m_frame.document())</span>
<span class="line-added"> 612         m_client.dispatchDidExplicitOpen(document-&gt;url(), document-&gt;contentType());</span>
 613 
 614     // Prevent window.open(url) -- eg window.open(&quot;about:blank&quot;) -- from blowing away results
 615     // from a subsequent window.document.open / window.document.write call.
 616     // Canceling redirection here works for all cases because document.open
 617     // implicitly precedes document.write.
 618     m_frame.navigationScheduler().cancel();
 619 }
 620 
 621 
 622 void FrameLoader::cancelAndClear()
 623 {
 624     m_frame.navigationScheduler().cancel();
 625 
 626     if (!m_isComplete)
 627         closeURL();
 628 
 629     clear(m_frame.document(), false);
 630     m_frame.script().updatePlatformScriptObjects();
 631 }
 632 
 633 static inline bool shouldClearWindowName(const Frame&amp; frame, const Document&amp; newDocument)
 634 {
 635     if (!frame.isMainFrame())
 636         return false;
 637 
 638     if (frame.loader().opener())
 639         return false;
 640 
 641     return !newDocument.securityOrigin().isSameOriginAs(frame.document()-&gt;securityOrigin());
 642 }
 643 
 644 void FrameLoader::clear(Document* newDocument, bool clearWindowProperties, bool clearScriptObjects, bool clearFrameView, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation)
 645 {
 646     m_frame.editor().clear();
 647 
 648     bool neededClear = m_needsClear;
 649     m_needsClear = false;
 650 
<span class="line-modified"> 651     if (neededClear &amp;&amp; m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {</span>
 652         m_frame.document()-&gt;cancelParsing();
 653         m_frame.document()-&gt;stopActiveDOMObjects();
 654         bool hadLivingRenderTree = m_frame.document()-&gt;hasLivingRenderTree();
 655         m_frame.document()-&gt;prepareForDestruction();
 656         if (hadLivingRenderTree)
 657             m_frame.document()-&gt;adjustFocusedNodeOnNodeRemoval(*m_frame.document());
 658     }
 659 
 660     if (handleDOMWindowCreation)
 661         handleDOMWindowCreation();
 662 
 663     if (!neededClear)
 664         return;
 665 
 666     // Do this after detaching the document so that the unload event works.
 667     if (clearWindowProperties) {
 668         InspectorInstrumentation::frameWindowDiscarded(m_frame, m_frame.document()-&gt;domWindow());
 669         m_frame.document()-&gt;domWindow()-&gt;resetUnlessSuspendedForDocumentSuspension();
<span class="line-modified"> 670         m_frame.windowProxy().clearJSWindowProxiesNotMatchingDOMWindow(newDocument-&gt;domWindow(), m_frame.document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache);</span>
 671 
 672         if (shouldClearWindowName(m_frame, *newDocument))
 673             m_frame.tree().setName(nullAtom());
 674     }
 675 
 676     m_frame.selection().prepareForDestruction();
 677     m_frame.eventHandler().clear();
 678 
 679     if (clearFrameView &amp;&amp; m_frame.view())
 680         m_frame.view()-&gt;clear();
 681 
 682     // Do not drop the document before the ScriptController and view are cleared
 683     // as some destructors might still try to access the document.
 684     m_frame.setDocument(nullptr);
 685 
 686     subframeLoader().clear();
 687 
 688     if (clearWindowProperties)
 689         m_frame.windowProxy().setDOMWindow(newDocument-&gt;domWindow());
 690 
</pre>
<hr />
<pre>
 707 {
 708     dispatchDidCommitLoad(WTF::nullopt);
 709     dispatchDidClearWindowObjectsInAllWorlds();
 710     dispatchGlobalObjectAvailableInAllWorlds();
 711 
 712     if (!m_documentLoader)
 713         return;
 714 
 715     auto&amp; documentLoader = *m_documentLoader;
 716     auto&amp; title = documentLoader.title();
 717     if (!title.string.isNull())
 718         m_client.dispatchDidReceiveTitle(title);
 719 
 720     ASSERT(m_frame.document());
 721     auto&amp; document = *m_frame.document();
 722 
 723     LinkLoader::loadLinksFromHeader(documentLoader.response().httpHeaderField(HTTPHeaderName::Link), document.url(), document, LinkLoader::MediaAttributeCheck::MediaAttributeEmpty);
 724 
 725     double delay;
 726     String urlString;
<span class="line-modified"> 727     if (!parseMetaHTTPEquivRefresh(documentLoader.response().httpHeaderField(HTTPHeaderName::Refresh), delay, urlString))</span>
 728         return;
 729     auto completedURL = urlString.isEmpty() ? document.url() : document.completeURL(urlString);
 730     if (!WTF::protocolIsJavaScript(completedURL))
 731         m_frame.navigationScheduler().scheduleRedirect(document, delay, completedURL);
 732     else {
 733         auto message = &quot;Refused to refresh &quot; + document.url().stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
 734         document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 735     }
 736 }
 737 
 738 void FrameLoader::setOutgoingReferrer(const URL&amp; url)
 739 {
 740     m_outgoingReferrer = url.strippedForUseAsReferrer();
 741 }
 742 
<span class="line-modified"> 743 void FrameLoader::didBeginDocument(bool dispatch)</span>
 744 {
 745     m_needsClear = true;
 746     m_isComplete = false;
 747     m_didCallImplicitClose = false;
 748     m_frame.document()-&gt;setReadyState(Document::Loading);
 749 
 750     if (m_pendingStateObject) {
 751         m_frame.document()-&gt;statePopped(*m_pendingStateObject);
 752         m_pendingStateObject = nullptr;
 753     }
 754 
 755     if (dispatch)
 756         dispatchDidClearWindowObjectsInAllWorlds();
 757 
 758     updateFirstPartyForCookies();
<span class="line-modified"> 759     m_frame.document()-&gt;initContentSecurityPolicy();</span>
 760 
 761     const Settings&amp; settings = m_frame.settings();
 762     m_frame.document()-&gt;cachedResourceLoader().setImagesEnabled(settings.areImagesEnabled());
 763     m_frame.document()-&gt;cachedResourceLoader().setAutoLoadImages(settings.loadsImagesAutomatically());
 764 
 765     if (m_documentLoader) {
 766         String dnsPrefetchControl = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::XDNSPrefetchControl);
 767         if (!dnsPrefetchControl.isEmpty())
 768             m_frame.document()-&gt;parseDNSPrefetchControlHeader(dnsPrefetchControl);
 769 
 770         m_frame.document()-&gt;contentSecurityPolicy()-&gt;didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader-&gt;response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);
 771 
 772         String referrerPolicy = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ReferrerPolicy);
 773         if (!referrerPolicy.isNull())
 774             m_frame.document()-&gt;processReferrerPolicy(referrerPolicy, ReferrerPolicySource::HTTPHeader);
 775 
 776         String headerContentLanguage = m_documentLoader-&gt;response().httpHeaderField(HTTPHeaderName::ContentLanguage);
 777         if (!headerContentLanguage.isEmpty()) {
 778             size_t commaIndex = headerContentLanguage.find(&#39;,&#39;);
 779             headerContentLanguage.truncate(commaIndex); // notFound == -1 == don&#39;t truncate
</pre>
<hr />
<pre>
 840 }
 841 
 842 bool FrameLoader::allAncestorsAreComplete() const
 843 {
 844     for (Frame* ancestor = &amp;m_frame; ancestor; ancestor = ancestor-&gt;tree().parent()) {
 845         if (!ancestor-&gt;loader().m_isComplete)
 846             return false;
 847     }
 848     return true;
 849 }
 850 
 851 void FrameLoader::checkCompleted()
 852 {
 853     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
 854     m_shouldCallCheckCompleted = false;
 855 
 856     // Have we completed before?
 857     if (m_isComplete)
 858         return;
 859 









 860     // FIXME: It would be better if resource loads were kicked off after render tree update (or didn&#39;t complete synchronously).
 861     //        https://bugs.webkit.org/show_bug.cgi?id=171729
 862     if (m_frame.document()-&gt;inRenderTreeUpdate()) {
 863         scheduleCheckCompleted();
 864         return;
 865     }
 866 
 867     // Are we still parsing?
 868     if (m_frame.document()-&gt;parsing())
 869         return;
 870 
 871     // Still waiting for images/scripts?
 872     if (m_frame.document()-&gt;cachedResourceLoader().requestCount())
 873         return;
 874 
 875     // Still waiting for elements that don&#39;t go through a FrameLoader?
 876     if (m_frame.document()-&gt;isDelayingLoadEvent())
 877         return;
 878 
 879     auto* scriptableParser = m_frame.document()-&gt;scriptableDocumentParser();
 880     if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
 881         return;
 882 
 883     // Any frame that hasn&#39;t completed yet?
 884     if (!allChildrenAreComplete())
 885         return;
 886 
 887     // Important not to protect earlier in this function, because earlier parts
 888     // of this function can be called in the frame&#39;s destructor, and it&#39;s not legal
 889     // to ref an object while it&#39;s being destroyed.
 890     Ref&lt;Frame&gt; protect(m_frame);
 891 
 892     // OK, completed.
 893     m_isComplete = true;
 894     m_requestedHistoryItem = nullptr;
 895     m_frame.document()-&gt;setReadyState(Document::Complete);
 896 












 897     checkCallImplicitClose(); // if we didn&#39;t do it before
 898 
 899     m_frame.navigationScheduler().startTimer();
 900 
 901     completed();
 902     if (m_frame.page())
 903         checkLoadComplete();
 904 }
 905 
 906 void FrameLoader::checkTimerFired()
 907 {
 908     checkCompletenessNow();
 909 }
 910 
 911 void FrameLoader::checkCompletenessNow()
 912 {
 913     Ref&lt;Frame&gt; protect(m_frame);
 914 
 915     if (Page* page = m_frame.page()) {
 916         if (page-&gt;defersLoading())
</pre>
<hr />
<pre>
 941 {
 942     m_shouldCallCheckLoadComplete = true;
 943     startCheckCompleteTimer();
 944 }
 945 
 946 void FrameLoader::checkCallImplicitClose()
 947 {
 948     if (m_didCallImplicitClose || m_frame.document()-&gt;parsing() || m_frame.document()-&gt;isDelayingLoadEvent())
 949         return;
 950 
 951     if (!allChildrenAreComplete())
 952         return; // still got a frame running -&gt; too early
 953 
 954     m_didCallImplicitClose = true;
 955     m_wasUnloadEventEmitted = false;
 956     m_frame.document()-&gt;implicitClose();
 957 }
 958 
 959 void FrameLoader::loadURLIntoChildFrame(const URL&amp; url, const String&amp; referer, Frame* childFrame)
 960 {
<span class="line-modified"> 961     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadURLIntoChildFrame: frame load started&quot;);</span>
 962 
 963     ASSERT(childFrame);
 964 
 965 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 966     if (auto activeLoader = activeDocumentLoader()) {
 967         if (auto subframeArchive = activeLoader-&gt;popArchiveForSubframe(childFrame-&gt;tree().uniqueName(), url)) {
 968             childFrame-&gt;loader().loadArchive(RefPtr&lt;Archive&gt; { subframeArchive }.releaseNonNull());
 969             return;
 970         }
 971     }
 972 #endif
 973 
 974     // If we&#39;re moving in the back/forward list, we might want to replace the content
 975     // of this child frame with whatever was there at that point.
 976     auto* parentItem = history().currentItem();
 977     if (parentItem &amp;&amp; parentItem-&gt;children().size() &amp;&amp; isBackForwardLoadType(loadType()) &amp;&amp; !m_frame.document()-&gt;loadEventFinished()) {
 978         if (auto* childItem = parentItem-&gt;childItemWithTarget(childFrame-&gt;tree().uniqueName())) {
 979             childFrame-&gt;loader().m_requestedHistoryItem = childItem;
 980             childFrame-&gt;loader().loadDifferentDocumentItem(*childItem, nullptr, loadType(), MayAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
 981             return;
 982         }
 983     }
 984 
 985     auto* lexicalFrame = lexicalFrameFromCommonVM();
 986     auto initiatedByMainFrame = lexicalFrame &amp;&amp; lexicalFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
 987 
 988     FrameLoadRequest frameLoadRequest { *m_frame.document(), m_frame.document()-&gt;securityOrigin(), { url }, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::Yes, ShouldSendReferrer::MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress, ShouldOpenExternalURLsPolicy::ShouldNotAllow, initiatedByMainFrame };
 989     childFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referer, FrameLoadType::RedirectWithLockedBackForwardList, nullptr, { }, WTF::nullopt, [] { });
 990 }
 991 
 992 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 993 
 994 void FrameLoader::loadArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
 995 {
<span class="line-modified"> 996     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadArchive: frame load started&quot;);</span>
 997 
 998     ArchiveResource* mainResource = archive-&gt;mainResource();
 999     ASSERT(mainResource);
1000     if (!mainResource)
1001         return;
1002 
1003     ResourceResponse response(URL(), mainResource-&gt;mimeType(), mainResource-&gt;data().size(), mainResource-&gt;textEncoding());
1004     SubstituteData substituteData(&amp;mainResource-&gt;data(), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1005 
1006     ResourceRequest request(mainResource-&gt;url());
1007 
1008     auto documentLoader = m_client.createDocumentLoader(request, substituteData);
1009     documentLoader-&gt;setArchive(WTFMove(archive));
1010     load(documentLoader.get());
1011 }
1012 
1013 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1014 
1015 String FrameLoader::outgoingReferrer() const
1016 {
</pre>
<hr />
<pre>
1104     else
1105         setFirstPartyForCookies(m_frame.document()-&gt;url());
1106 }
1107 
1108 void FrameLoader::setFirstPartyForCookies(const URL&amp; url)
1109 {
1110     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
1111         frame-&gt;document()-&gt;setFirstPartyForCookies(url);
1112 
1113     RegistrableDomain registrableDomain(url);
1114     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
1115         if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(frame-&gt;document()-&gt;url()) || registrableDomain.matches(frame-&gt;document()-&gt;url()))
1116             frame-&gt;document()-&gt;setSiteForCookies(url);
1117     }
1118 }
1119 
1120 // This does the same kind of work that didOpenURL does, except it relies on the fact
1121 // that a higher level already checked that the URLs match and the scrolling is the right thing to do.
1122 void FrameLoader::loadInSameDocument(const URL&amp; url, SerializedScriptValue* stateObject, bool isNewNavigation)
1123 {
<span class="line-modified">1124     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadInSameDocument: frame load started&quot;);</span>
1125 
1126     // If we have a state object, we cannot also be a new navigation.
1127     ASSERT(!stateObject || (stateObject &amp;&amp; !isNewNavigation));
1128 
1129     // Update the data source&#39;s request with the new URL to fake the URL change
1130     URL oldURL = m_frame.document()-&gt;url();
1131     m_frame.document()-&gt;setURL(url);
1132     setOutgoingReferrer(url);
1133     documentLoader()-&gt;replaceRequestURLForSameDocumentNavigation(url);
1134     if (isNewNavigation &amp;&amp; !shouldTreatURLAsSameAsCurrent(url) &amp;&amp; !stateObject) {
1135         // NB: must happen after replaceRequestURLForSameDocumentNavigation(), since we add
1136         // based on the current request. Must also happen before we openURL and displace the
1137         // scroll position, since adding the BF item will save away scroll state.
1138 
1139         // NB2: If we were loading a long, slow doc, and the user fragment navigated before
1140         // it was done, currItem is now set the that slow doc, and prevItem is whatever was
1141         // before it.  Adding the b/f item will bump the slow doc down to prevItem, even
1142         // though its load is not yet done.  I think this all works out OK, for one because
1143         // we have already saved away the scroll and doc state for the long slow load,
1144         // but it&#39;s not an obvious case.
</pre>
<hr />
<pre>
1203     Ref&lt;Frame&gt; protect(m_frame);
1204 
1205     for (Frame* descendant = m_frame.tree().traverseNext(&amp;m_frame); descendant; descendant = descendant-&gt;tree().traverseNext(&amp;m_frame))
1206         descendant-&gt;navigationScheduler().startTimer();
1207 
1208     if (Frame* parent = m_frame.tree().parent())
1209         parent-&gt;loader().checkCompleted();
1210 
1211     if (m_frame.view())
1212         m_frame.view()-&gt;maintainScrollPositionAtAnchor(nullptr);
1213 }
1214 
1215 void FrameLoader::started()
1216 {
1217     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().parent())
1218         frame-&gt;loader().m_isComplete = false;
1219 }
1220 
1221 void FrameLoader::prepareForLoadStart()
1222 {
<span class="line-modified">1223     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;prepareForLoadStart: Starting frame load&quot;);</span>
1224 
1225     m_progressTracker-&gt;progressStarted();
1226     m_client.dispatchDidStartProvisionalLoad();
1227 
1228     if (AXObjectCache::accessibilityEnabled()) {
1229         if (AXObjectCache* cache = m_frame.document()-&gt;existingAXObjectCache()) {
1230             AXObjectCache::AXLoadingEvent loadingEvent = loadType() == FrameLoadType::Reload ? AXObjectCache::AXLoadingReloaded : AXObjectCache::AXLoadingStarted;
1231             cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
1232         }
1233     }
1234 }
1235 
1236 void FrameLoader::setupForReplace()
1237 {
1238     m_client.revertToProvisionalState(m_documentLoader.get());
1239     setState(FrameStateProvisional);
1240     m_provisionalDocumentLoader = m_documentLoader;
<span class="line-added">1241     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setupForReplace: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
1242     m_documentLoader = nullptr;
1243     detachChildren();
1244 }
1245 
1246 void FrameLoader::loadFrameRequest(FrameLoadRequest&amp;&amp; request, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution)
1247 {
<span class="line-modified">1248     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadFrameRequest: frame load started&quot;);</span>
1249 
1250     // Protect frame from getting blown away inside dispatchBeforeLoadEvent in loadWithDocumentLoader.
1251     auto protectFrame = makeRef(m_frame);
1252 
1253     URL url = request.resourceRequest().url();
1254 
1255     ASSERT(m_frame.document());
1256     if (!request.requesterSecurityOrigin().canDisplay(url)) {
1257         reportLocalLoadFailed(&amp;m_frame, url.stringCenterEllipsizedToLength());
1258         return;
1259     }
1260 
1261     String argsReferrer = request.resourceRequest().httpReferrer();
1262     if (argsReferrer.isEmpty())
1263         argsReferrer = outgoingReferrer();
1264 
1265     String referrer = SecurityPolicy::generateReferrerHeader(m_frame.document()-&gt;referrerPolicy(), url, argsReferrer);
1266     if (request.shouldSendReferrer() == NeverSendReferrer)
1267         referrer = String();
1268 
</pre>
<hr />
<pre>
1317     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, initiatedByMainFrame, propagatedPolicy));
1318 }
1319 
1320 static void applyShouldOpenExternalURLsPolicyToNewDocumentLoader(Frame&amp; frame, DocumentLoader&amp; documentLoader, const FrameLoadRequest&amp; frameLoadRequest)
1321 {
1322     documentLoader.setShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(frame, frameLoadRequest));
1323 }
1324 
1325 bool FrameLoader::isNavigationAllowed() const
1326 {
1327     return m_pageDismissalEventBeingDispatched == PageDismissalType::None &amp;&amp; !m_frame.script().willReplaceWithResultOfExecutingJavascriptURL() &amp;&amp; NavigationDisabler::isNavigationAllowed(m_frame);
1328 }
1329 
1330 bool FrameLoader::isStopLoadingAllowed() const
1331 {
1332     return m_pageDismissalEventBeingDispatched == PageDismissalType::None;
1333 }
1334 
1335 void FrameLoader::loadURL(FrameLoadRequest&amp;&amp; frameLoadRequest, const String&amp; referrer, FrameLoadType newLoadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, Optional&lt;AdClickAttribution&gt;&amp;&amp; adClickAttribution, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1336 {
<span class="line-modified">1337     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadURL: frame load started&quot;);</span>
1338 
1339     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1340     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1341         return;
1342 
1343     Ref&lt;Frame&gt; protect(m_frame);
1344 
1345     // Anchor target is ignored when the download attribute is set since it will download the hyperlink rather than follow it.
1346     String effectiveFrameName = frameLoadRequest.downloadAttribute().isNull() ? frameLoadRequest.frameName() : String();
1347     AllowNavigationToInvalidURL allowNavigationToInvalidURL = frameLoadRequest.allowNavigationToInvalidURL();
1348     NewFrameOpenerPolicy openerPolicy = frameLoadRequest.newFrameOpenerPolicy();
1349     LockHistory lockHistory = frameLoadRequest.lockHistory();
1350     bool isFormSubmission = formState;
1351 
1352     const URL&amp; newURL = frameLoadRequest.resourceRequest().url();
1353     ResourceRequest request(newURL);
1354     if (!referrer.isEmpty()) {
1355         request.setHTTPReferrer(referrer);
1356         auto referrerOrigin = SecurityOrigin::createFromString(referrer);
1357         addHTTPOriginIfNeeded(request, referrerOrigin-&gt;toString());
</pre>
<hr />
<pre>
1367 
1368     // The search for a target frame is done earlier in the case of form submission.
1369     Frame* targetFrame = isFormSubmission ? nullptr : findFrameForNavigation(effectiveFrameName);
1370     if (targetFrame &amp;&amp; targetFrame != &amp;m_frame) {
1371         frameLoadRequest.setFrameName(&quot;_self&quot;);
1372         targetFrame-&gt;loader().loadURL(WTFMove(frameLoadRequest), referrer, newLoadType, event, WTFMove(formState), WTFMove(adClickAttribution), completionHandlerCaller.release());
1373         return;
1374     }
1375 
1376     if (!isNavigationAllowed())
1377         return;
1378 
1379     NavigationAction action { frameLoadRequest.requester(), request, frameLoadRequest.initiatedByMainFrame(), newLoadType, isFormSubmission, event, frameLoadRequest.shouldOpenExternalURLsPolicy(), frameLoadRequest.downloadAttribute() };
1380     action.setLockHistory(lockHistory);
1381     action.setLockBackForwardList(frameLoadRequest.lockBackForwardList());
1382     if (adClickAttribution &amp;&amp; m_frame.isMainFrame())
1383         action.setAdClickAttribution(WTFMove(*adClickAttribution));
1384 
1385     if (!targetFrame &amp;&amp; !effectiveFrameName.isEmpty()) {
1386         action = action.copyWithShouldOpenExternalURLsPolicy(shouldOpenExternalURLsPolicyToApply(m_frame, frameLoadRequest));
<span class="line-modified">1387         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request), WTFMove(formState), effectiveFrameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) mutable {</span>
1388             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
1389             completionHandler();
1390         });
1391         return;
1392     }
1393 
1394     RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1395 
1396     bool sameURL = shouldTreatURLAsSameAsCurrent(newURL);
1397     const String&amp; httpMethod = request.httpMethod();
1398 
1399     // Make sure to do scroll to fragment processing even if the URL is
1400     // exactly the same so pages with &#39;#&#39; links and DHTML side effects
1401     // work properly.
1402     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, newLoadType, newURL)) {
1403         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1404         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1405         policyChecker().stopCheck();
1406         policyChecker().setLoadType(newLoadType);
1407         RELEASE_ASSERT(!isBackForwardLoadType(newLoadType) || history().provisionalItem());
1408         policyChecker().checkNavigationPolicy(WTFMove(request), ResourceResponse { } /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
1409             continueFragmentScrollAfterNavigationPolicy(request, navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad);
1410         }, PolicyDecisionMode::Synchronous);
1411         return;
1412     }
1413 
1414     // Must grab this now, since this load may stop the previous load and clear this flag.
1415     bool isRedirect = m_quickRedirectComing;
1416 #if USE(SYSTEM_PREVIEW)
1417     bool isSystemPreview = frameLoadRequest.isSystemPreview();

1418     if (isSystemPreview)
<span class="line-modified">1419         request.setSystemPreviewInfo(frameLoadRequest.systemPreviewInfo());</span>
1420 #endif
1421     loadWithNavigationAction(request, WTFMove(action), lockHistory, newLoadType, WTFMove(formState), allowNavigationToInvalidURL, frameLoadRequest.downloadAttribute(), [this, isRedirect, sameURL, newLoadType, protectedFrame = makeRef(m_frame), completionHandler = completionHandlerCaller.release()] () mutable {
1422         if (isRedirect) {
1423             m_quickRedirectComing = false;
1424             if (m_provisionalDocumentLoader)
1425                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
1426             else if (m_policyDocumentLoader)
1427                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
1428         } else if (sameURL &amp;&amp; !isReload(newLoadType)) {
1429             // Example of this case are sites that reload the same URL with a different cookie
1430             // driving the generated content, or a master frame with links that drive a target
1431             // frame, where the user has clicked on the same link repeatedly.
1432             m_loadType = FrameLoadType::Same;
1433         }
1434         completionHandler();
1435     });
1436 }
1437 
1438 SubstituteData FrameLoader::defaultSubstituteDataForURL(const URL&amp; url)
1439 {
1440     if (!shouldTreatURLAsSrcdocDocument(url))
1441         return SubstituteData();
1442     auto&amp; srcdoc = m_frame.ownerElement()-&gt;attributeWithoutSynchronization(srcdocAttr);
1443     ASSERT(!srcdoc.isNull());
1444     CString encodedSrcdoc = srcdoc.string().utf8();
1445 
1446     ResourceResponse response(URL(), &quot;text/html&quot;_s, encodedSrcdoc.length(), &quot;UTF-8&quot;_s);
1447     return SubstituteData(SharedBuffer::create(encodedSrcdoc.data(), encodedSrcdoc.length()), URL(), response, SubstituteData::SessionHistoryVisibility::Hidden);
1448 }
1449 
1450 void FrameLoader::load(FrameLoadRequest&amp;&amp; request)
1451 {
<span class="line-modified">1452     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;load (FrameLoadRequest): frame load started&quot;);</span>
1453 
1454     if (m_inStopAllLoaders || m_inClearProvisionalLoadForPolicyCheck)
1455         return;
1456 
1457     if (!request.frameName().isEmpty()) {
1458         Frame* frame = findFrameForNavigation(request.frameName());
1459         if (frame) {
1460             request.setShouldCheckNewWindowPolicy(false);
1461             if (&amp;frame-&gt;loader() != this) {
1462                 frame-&gt;loader().load(WTFMove(request));
1463                 return;
1464             }
1465         }
1466     }
1467 
1468     if (request.shouldCheckNewWindowPolicy()) {
1469         NavigationAction action { request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() };
<span class="line-modified">1470         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(request.resourceRequest()), { }, request.frameName(), [this] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) {</span>
1471             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);
1472         });
1473 
1474         return;
1475     }
1476 
1477     if (!request.hasSubstituteData())
1478         request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
1479 
1480     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
1481     loader-&gt;setAllowsWebArchiveForMainFrame(request.isRequestFromClientOrUserInput());
<span class="line-added">1482     loader-&gt;setAllowsDataURLsForMainFrame(request.isRequestFromClientOrUserInput());</span>
1483     addSameSiteInfoToRequestIfNeeded(loader-&gt;request());
1484     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);
1485 
1486     if (request.shouldTreatAsContinuingLoad()) {
1487         loader-&gt;setClientRedirectSourceForHistory(request.clientRedirectSourceForHistory());
1488         if (request.lockBackForwardList() == LockBackForwardList::Yes) {
1489             loader-&gt;setIsClientRedirect(true);
1490             m_loadType = FrameLoadType::RedirectWithLockedBackForwardList;
1491         }
1492     }
1493 
1494     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, request.shouldTreatAsContinuingLoad() ? LoadContinuingState::ContinuingWithRequest : LoadContinuingState::NotContinuing);
1495     load(loader.get());
1496 }
1497 
1498 void FrameLoader::loadWithNavigationAction(const ResourceRequest&amp; request, NavigationAction&amp;&amp; action, LockHistory lockHistory, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, const String&amp; downloadAttribute, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1499 {
<span class="line-modified">1500     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithNavigationAction: frame load started&quot;);</span>
1501 
1502     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1503     loader-&gt;setDownloadAttribute(downloadAttribute);
1504     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, action.initiatedByMainFrame(), action.shouldOpenExternalURLsPolicy());
1505 
1506     if (lockHistory == LockHistory::Yes &amp;&amp; m_documentLoader)
1507         loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());
1508 
1509     loader-&gt;setTriggeringAction(WTFMove(action));
1510     if (m_documentLoader)
1511         loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1512 
1513     loadWithDocumentLoader(loader.ptr(), type, WTFMove(formState), allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad::No, WTFMove(completionHandler));
1514 }
1515 
1516 void FrameLoader::load(DocumentLoader&amp; newDocumentLoader)
1517 {
<span class="line-modified">1518     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;load (DocumentLoader): frame load started&quot;);</span>
1519 
1520     ResourceRequest&amp; r = newDocumentLoader.request();
1521     addExtraFieldsToMainResourceRequest(r);
1522     FrameLoadType type;
1523 
1524     if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.originalRequest().url())) {
1525         r.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1526         type = FrameLoadType::Same;
1527     } else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader.unreachableURL()) &amp;&amp; isReload(m_loadType))
1528         type = m_loadType;
1529     else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; ((!newDocumentLoader.unreachableURL().isEmpty() &amp;&amp; newDocumentLoader.substituteData().isValid()) || shouldTreatCurrentLoadAsContinuingLoad()))
1530         type = FrameLoadType::RedirectWithLockedBackForwardList;
1531     else
1532         type = FrameLoadType::Standard;
1533 
1534     if (m_documentLoader)
1535         newDocumentLoader.setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1536 
1537     // When we loading alternate content for an unreachable URL that we&#39;re
1538     // visiting in the history list, we treat it as a reload so the history list
1539     // is appropriately maintained.
1540     //
1541     // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadType::Reload&quot; ...
1542     // shouldn&#39;t a more explicit type of reload be defined, that means roughly
1543     // &quot;load without affecting history&quot; ?
1544     if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) {
1545         // shouldReloadToHandleUnreachableURL returns true only when the original load type is back-forward.
1546         // In this case we should save the document state now. Otherwise the state can be lost because load type is
1547         // changed and updateForBackForwardNavigation() will not be called when loading is committed.
1548         history().saveDocumentAndScrollState();
1549 
1550         ASSERT(type == FrameLoadType::Standard);
1551         type = FrameLoadType::Reload;
1552     }
1553 
1554     loadWithDocumentLoader(&amp;newDocumentLoader, type, nullptr, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1555 }
1556 
1557 void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, RefPtr&lt;FormState&gt;&amp;&amp; formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL, ShouldTreatAsContinuingLoad, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
1558 {
<span class="line-modified">1559     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithDocumentLoader: frame load started&quot;);</span>
1560 
1561     // Retain because dispatchBeforeLoadEvent may release the last reference to it.
1562     Ref&lt;Frame&gt; protect(m_frame);
1563 
1564     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
1565 
1566     ASSERT(m_client.hasWebView());
1567 
1568     // Unfortunately the view must be non-nil, this is ultimately due
1569     // to parser requiring a FrameView.  We should fix this dependency.
1570 
1571     ASSERT(m_frame.view());
1572 
1573     if (!isNavigationAllowed())
1574         return;
1575 
1576     if (m_frame.document())
1577         m_previousURL = m_frame.document()-&gt;url();
1578 
1579     const URL&amp; newURL = loader-&gt;request().url();
1580 
1581     // Only the first iframe navigation or the first iframe navigation after about:blank should be reported.
1582     // https://www.w3.org/TR/resource-timing-2/#resources-included-in-the-performanceresourcetiming-interface
1583     if (m_shouldReportResourceTimingToParentFrame &amp;&amp; !m_previousURL.isNull() &amp;&amp; m_previousURL != WTF::blankURL())
1584         m_shouldReportResourceTimingToParentFrame = false;
1585 
1586     // Log main frame navigation types.
1587     if (m_frame.isMainFrame()) {
1588         if (auto* page = m_frame.page()) {
<span class="line-modified">1589             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadWithDocumentLoader: main frame load started&quot;);</span>
1590             page-&gt;mainFrameLoadStarted(newURL, type);
1591             page-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);
1592         }
1593     }
1594 
1595     policyChecker().setLoadType(type);
1596     RELEASE_ASSERT(!isBackForwardLoadType(type) || history().provisionalItem());
1597     bool isFormSubmission = formState;
1598 
1599     const String&amp; httpMethod = loader-&gt;request().httpMethod();
1600 
1601     if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) {
1602         RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;
1603         NavigationAction action { *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission };
1604 
1605         oldDocumentLoader-&gt;setTriggeringAction(WTFMove(action));
1606         oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
1607         policyChecker().stopCheck();
1608         RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1609         policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { }  /* redirectResponse */, oldDocumentLoader.get(), WTFMove(formState), [this, protectedFrame = makeRef(m_frame)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) {
</pre>
<hr />
<pre>
1637 
1638     if (shouldTreatCurrentLoadAsContinuingLoad()) {
1639         continueLoadAfterNavigationPolicy(loader-&gt;request(), formState.get(), NavigationPolicyDecision::ContinueLoad, allowNavigationToInvalidURL);
1640         return;
1641     }
1642 
1643     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker().loadType()) || history().provisionalItem());
1644     policyChecker().checkNavigationPolicy(ResourceRequest(loader-&gt;request()), ResourceResponse { } /* redirectResponse */, loader, WTFMove(formState), [this, protectedFrame = makeRef(m_frame), allowNavigationToInvalidURL, completionHandler = completionHandlerCaller.release()] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, NavigationPolicyDecision navigationPolicyDecision) mutable {
1645         continueLoadAfterNavigationPolicy(request, formState.get(), navigationPolicyDecision, allowNavigationToInvalidURL);
1646         completionHandler();
1647     }, PolicyDecisionMode::Asynchronous);
1648 }
1649 
1650 void FrameLoader::clearProvisionalLoadForPolicyCheck()
1651 {
1652     if (!m_policyDocumentLoader || !m_provisionalDocumentLoader || m_inClearProvisionalLoadForPolicyCheck)
1653         return;
1654 
1655     SetForScope&lt;bool&gt; change(m_inClearProvisionalLoadForPolicyCheck, true);
1656     m_provisionalDocumentLoader-&gt;stopLoading();
<span class="line-added">1657     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;clearProvisionalLoadForPolicyCheck: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
1658     setProvisionalDocumentLoader(nullptr);
1659 }
1660 
1661 void FrameLoader::reportLocalLoadFailed(Frame* frame, const String&amp; url)
1662 {
1663     ASSERT(!url.isEmpty());
1664     if (!frame)
1665         return;
1666 
1667     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to load local resource: &quot; + url);
1668 }
1669 
1670 void FrameLoader::reportBlockedPortFailed(Frame* frame, const String&amp; url)
1671 {
1672     ASSERT(!url.isEmpty());
1673     if (!frame)
1674         return;
1675 
1676     frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Not allowed to use restricted network port: &quot; + url);
1677 }
</pre>
<hr />
<pre>
1720 
1721     if (!isBackForwardLoadType(policyChecker().loadType()))
1722         return false;
1723 
1724     // We only treat unreachableURLs specially during the delegate callbacks
1725     // for provisional load errors and navigation policy decisions. The former
1726     // case handles well-formed URLs that can&#39;t be loaded, and the latter
1727     // case handles malformed URLs and unknown schemes. Loading alternate content
1728     // at other times behaves like a standard load.
1729     if (policyChecker().delegateIsDecidingNavigationPolicy() || policyChecker().delegateIsHandlingUnimplementablePolicy())
1730         return m_policyDocumentLoader &amp;&amp; unreachableURL == m_policyDocumentLoader-&gt;request().url();
1731 
1732     return unreachableURL == m_provisionalLoadErrorBeingHandledURL;
1733 }
1734 
1735 void FrameLoader::reloadWithOverrideEncoding(const String&amp; encoding)
1736 {
1737     if (!m_documentLoader)
1738         return;
1739 
<span class="line-modified">1740     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;reloadWithOverrideEncoding: frame load started&quot;);</span>
1741 
1742     ResourceRequest request = m_documentLoader-&gt;request();
1743     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1744     if (!unreachableURL.isEmpty())
1745         request.setURL(unreachableURL);
1746 
1747     // FIXME: If the resource is a result of form submission and is not cached, the form will be silently resubmitted.
1748     // We should ask the user for confirmation in this case.
1749     request.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
1750 
1751     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request, defaultSubstituteDataForURL(request.url()));
1752     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1753 
1754     setPolicyDocumentLoader(loader.ptr());
1755 
1756     loader-&gt;setOverrideEncoding(encoding);
1757 
1758     loadWithDocumentLoader(loader.ptr(), FrameLoadType::Reload, { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1759 }
1760 
1761 void FrameLoader::reload(OptionSet&lt;ReloadOption&gt; options)
1762 {
1763     if (!m_documentLoader)
1764         return;
1765 
1766     // If a window is created by javascript, its main frame can have an empty but non-nil URL.
1767     // Reloading in this case will lose the current contents (see 4151001).
1768     if (m_documentLoader-&gt;request().url().isEmpty())
1769         return;
1770 
<span class="line-modified">1771     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;reload: frame load started&quot;);</span>
1772 
1773     // Replace error-page URL with the URL we were trying to reach.
1774     ResourceRequest initialRequest = m_documentLoader-&gt;request();
1775     URL unreachableURL = m_documentLoader-&gt;unreachableURL();
1776     if (!unreachableURL.isEmpty())
1777         initialRequest.setURL(unreachableURL);
1778 
1779     // Create a new document loader for the reload, this will become m_documentLoader eventually,
1780     // but first it has to be the &quot;policy&quot; document loader, and then the &quot;provisional&quot; document loader.
1781     Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(initialRequest, defaultSubstituteDataForURL(initialRequest.url()));
1782     loader-&gt;setAllowsWebArchiveForMainFrame(m_documentLoader-&gt;allowsWebArchiveForMainFrame());
<span class="line-added">1783     loader-&gt;setAllowsDataURLsForMainFrame(m_documentLoader-&gt;allowsDataURLsForMainFrame());</span>
1784     applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, InitiatedByMainFrame::Unknown, m_documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
1785 
1786     loader-&gt;setUserContentExtensionsEnabled(!options.contains(ReloadOption::DisableContentBlockers));
1787 
1788     ResourceRequest&amp; request = loader-&gt;request();
1789 
1790     // FIXME: We don&#39;t have a mechanism to revalidate the main resource without reloading at the moment.
1791     request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
1792 
1793     addSameSiteInfoToRequestIfNeeded(request);
1794 
1795     // If we&#39;re about to re-post, set up action so the application can warn the user.
1796     if (request.httpMethod() == &quot;POST&quot;)
1797         loader-&gt;setTriggeringAction({ *m_frame.document(), request, InitiatedByMainFrame::Unknown, NavigationType::FormResubmitted });
1798 
1799     loader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
1800 
1801     auto frameLoadTypeForReloadOptions = [] (auto options) {
1802         if (options &amp; ReloadOption::FromOrigin)
1803             return FrameLoadType::ReloadFromOrigin;
1804         if (options &amp; ReloadOption::ExpiredOnly)
1805             return FrameLoadType::ReloadExpiredOnly;
1806         return FrameLoadType::Reload;
1807     };
1808 
1809     loadWithDocumentLoader(loader.ptr(), frameLoadTypeForReloadOptions(options), { }, AllowNavigationToInvalidURL::Yes, ShouldTreatAsContinuingLoad::No);
1810 }
1811 
1812 void FrameLoader::stopAllLoaders(ClearProvisionalItemPolicy clearProvisionalItemPolicy, StopLoadingPolicy stopLoadingPolicy)
1813 {
<span class="line-modified">1814     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;backForwardCacheState() == Document::InBackForwardCache)</span>
1815         return;
1816 
1817     if (stopLoadingPolicy == StopLoadingPolicy::PreventDuringUnloadEvents &amp;&amp; !isStopLoadingAllowed())
1818         return;
1819 
1820     // If this method is called from within this method, infinite recursion can occur (3442218). Avoid this.
1821     if (m_inStopAllLoaders)
1822         return;
1823 
1824     // This method might dispatch events.
1825     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
1826 
1827     // Calling stopLoading() on the provisional document loader can blow away
1828     // the frame from underneath.
1829     Ref&lt;Frame&gt; protect(m_frame);
1830 
1831     m_inStopAllLoaders = true;
1832 
1833     policyChecker().stopCheck();
1834 
1835     // If no new load is in progress, we should clear the provisional item from history
1836     // before we call stopLoading.
1837     if (clearProvisionalItemPolicy == ShouldClearProvisionalItem)
1838         history().setProvisionalItem(nullptr);
1839 
1840     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
1841         child-&gt;loader().stopAllLoaders(clearProvisionalItemPolicy);
1842     if (m_provisionalDocumentLoader)
1843         m_provisionalDocumentLoader-&gt;stopLoading();
1844     if (m_documentLoader)
1845         m_documentLoader-&gt;stopLoading();
1846 
<span class="line-added">1847     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;stopAllLoaders: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
1848     setProvisionalDocumentLoader(nullptr);
1849 
1850     m_inStopAllLoaders = false;
1851 }
1852 
<span class="line-added">1853 void FrameLoader::stopForBackForwardCache()</span>
<span class="line-added">1854 {</span>
<span class="line-added">1855     // Stop provisional loads in subframes (The one in the main frame is about to be committed).</span>
<span class="line-added">1856     if (!m_frame.isMainFrame()) {</span>
<span class="line-added">1857         if (m_provisionalDocumentLoader)</span>
<span class="line-added">1858             m_provisionalDocumentLoader-&gt;stopLoading();</span>
<span class="line-added">1859         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;stopForBackForwardCache: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
<span class="line-added">1860         setProvisionalDocumentLoader(nullptr);</span>
<span class="line-added">1861     }</span>
<span class="line-added">1862 </span>
<span class="line-added">1863     // Stop current loads.</span>
<span class="line-added">1864     if (m_documentLoader)</span>
<span class="line-added">1865         m_documentLoader-&gt;stopLoading();</span>
<span class="line-added">1866 </span>
<span class="line-added">1867     for (RefPtr&lt;Frame&gt; child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())</span>
<span class="line-added">1868         child-&gt;loader().stopForBackForwardCache();</span>
<span class="line-added">1869 </span>
<span class="line-added">1870     // We cancel pending navigations &amp; policy checks *after* cancelling loads because cancelling loads might end up</span>
<span class="line-added">1871     // running script, which could schedule new navigations.</span>
<span class="line-added">1872     policyChecker().stopCheck();</span>
<span class="line-added">1873     m_frame.navigationScheduler().cancel();</span>
<span class="line-added">1874 }</span>
<span class="line-added">1875 </span>
1876 void FrameLoader::stopAllLoadersAndCheckCompleteness()
1877 {
1878     stopAllLoaders();
1879 
1880     if (!m_checkTimer.isActive())
1881         return;
1882 
1883     m_checkTimer.stop();
1884     m_checkingLoadCompleteForDetachment = true;
1885     checkCompletenessNow();
1886     m_checkingLoadCompleteForDetachment = false;
1887 }
1888 
1889 void FrameLoader::stopForUserCancel(bool deferCheckLoadComplete)
1890 {
1891     // Calling stopAllLoaders can cause the frame to be deallocated, including the frame loader.
1892     Ref&lt;Frame&gt; protectedFrame(m_frame);
1893 
1894     stopAllLoaders();
1895 
</pre>
<hr />
<pre>
1957     m_documentLoader = loader;
1958 }
1959 
1960 void FrameLoader::setPolicyDocumentLoader(DocumentLoader* loader)
1961 {
1962     if (m_policyDocumentLoader == loader)
1963         return;
1964 
1965     if (loader)
1966         loader-&gt;attachToFrame(m_frame);
1967     if (m_policyDocumentLoader
1968             &amp;&amp; m_policyDocumentLoader != m_provisionalDocumentLoader
1969             &amp;&amp; m_policyDocumentLoader != m_documentLoader)
1970         m_policyDocumentLoader-&gt;detachFromFrame();
1971 
1972     m_policyDocumentLoader = loader;
1973 }
1974 
1975 void FrameLoader::setProvisionalDocumentLoader(DocumentLoader* loader)
1976 {
<span class="line-added">1977     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setProvisionalDocumentLoader: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, loader);</span>
<span class="line-added">1978 </span>
1979     ASSERT(!loader || !m_provisionalDocumentLoader);
1980     ASSERT(!loader || loader-&gt;frameLoader() == this);
1981 
1982     if (m_provisionalDocumentLoader &amp;&amp; m_provisionalDocumentLoader != m_documentLoader)
1983         m_provisionalDocumentLoader-&gt;detachFromFrame();
1984 
1985     m_provisionalDocumentLoader = loader;
1986 }
1987 
1988 void FrameLoader::setState(FrameState newState)
1989 {
1990     FrameState oldState = m_state;
1991     m_state = newState;
1992 
1993     if (newState == FrameStateProvisional)
1994         provisionalLoadStarted();
1995     else if (newState == FrameStateComplete) {
1996         frameLoadCompleted();
1997         if (m_documentLoader)
1998             m_documentLoader-&gt;stopRecordingResponses();
1999         if (m_frame.isMainFrame() &amp;&amp; oldState != newState) {
<span class="line-modified">2000             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;setState: main frame load completed&quot;);</span>
2001             m_frame.page()-&gt;performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadCompleted);
2002         }
2003     }
2004 }
2005 
2006 void FrameLoader::clearProvisionalLoad()
2007 {
<span class="line-added">2008     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;clearProvisionalLoad: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
2009     setProvisionalDocumentLoader(nullptr);
2010     m_progressTracker-&gt;progressCompleted();
2011     setState(FrameStateComplete);
2012 }
2013 
2014 void FrameLoader::commitProvisionalLoad()
2015 {
2016     RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2017     Ref&lt;Frame&gt; protect(m_frame);
2018 
2019     std::unique_ptr&lt;CachedPage&gt; cachedPage;
2020     if (m_loadingFromCachedPage &amp;&amp; history().provisionalItem())
<span class="line-modified">2021         cachedPage = BackForwardCache::singleton().take(*history().provisionalItem(), m_frame.page());</span>
2022 
<span class="line-modified">2023     LOG(BackForwardCache, &quot;WebCoreLoading %s: About to commit provisional load from previous URL &#39;%s&#39; to new URL &#39;%s&#39; with cached page %p&quot;, m_frame.tree().uniqueName().string().utf8().data(),</span>
2024         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;,
2025         pdl ? pdl-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&lt;no provisional DocumentLoader&gt;&quot;, cachedPage.get());
2026 
2027     willTransitionToCommitted();
2028 
2029     if (!m_frame.tree().parent() &amp;&amp; history().currentItem() &amp;&amp; history().currentItem() != history().provisionalItem()) {
2030         // Check to see if we need to cache the page we are navigating away from into the back/forward cache.
2031         // We are doing this here because we know for sure that a new page is about to be loaded.
<span class="line-modified">2032         BackForwardCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());</span>
2033 
2034         WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();
2035     }
2036 
2037     if (m_loadType != FrameLoadType::Replace)
2038         closeOldDataSources();
2039 
2040     if (!cachedPage &amp;&amp; !m_stateMachine.creatingInitialEmptyDocument())
2041         m_client.makeRepresentation(pdl.get());
2042 
2043     transitionToCommitted(cachedPage.get());
2044 
2045     if (pdl &amp;&amp; m_documentLoader) {
2046         // Check if the destination page is allowed to access the previous page&#39;s timing information.
2047         Ref&lt;SecurityOrigin&gt; securityOrigin(SecurityOrigin::create(pdl-&gt;request().url()));
2048         m_documentLoader-&gt;timing().setHasSameOriginAsPreviousDocument(securityOrigin.get().canRequest(m_previousURL));
2049     }
2050 
2051     // Call clientRedirectCancelledOrFinished() here so that the frame load delegate is notified that the redirect&#39;s
2052     // status has changed, if there was a redirect.  The frame load delegate may have saved some state about
</pre>
<hr />
<pre>
2089             m_client.dispatchDidReceiveTitle(title);
2090 
2091         // Send remaining notifications for the main resource.
2092         notifier().sendRemainingDelegateMessages(m_documentLoader.get(), mainResourceIdentifier, mainResourceRequest, ResourceResponse(),
2093             nullptr, static_cast&lt;int&gt;(m_documentLoader-&gt;response().expectedContentLength()), 0, mainResouceError);
2094 
2095         checkCompleted();
2096     } else
2097         didOpenURL();
2098 
2099     LOG(Loading, &quot;WebCoreLoading %s: Finished committing provisional load to URL %s&quot;, m_frame.tree().uniqueName().string().utf8().data(),
2100         m_frame.document() ? m_frame.document()-&gt;url().stringCenterEllipsizedToLength().utf8().data() : &quot;&quot;);
2101 
2102     if (m_loadType == FrameLoadType::Standard &amp;&amp; m_documentLoader &amp;&amp; m_documentLoader-&gt;isClientRedirect())
2103         history().updateForClientRedirect();
2104 
2105     if (m_loadingFromCachedPage) {
2106         // Note, didReceiveDocType is expected to be called for cached pages. See &lt;rdar://problem/5906758&gt; for more details.
2107         if (auto* page = m_frame.page())
2108             page-&gt;chrome().didReceiveDocType(m_frame);
<span class="line-modified">2109         m_frame.document()-&gt;resume(ReasonForSuspension::BackForwardCache);</span>
2110 
2111         // Force a layout to update view size and thereby update scrollbars.
2112 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2113         if (!m_client.forceLayoutOnRestoreFromBackForwardCache())</span>
2114             m_frame.view()-&gt;forceLayout();
2115 #else
2116         m_frame.view()-&gt;forceLayout();
2117 #endif
2118 
2119         // Main resource delegates were already sent, so we skip the first response here.
2120         for (unsigned i = 1; i &lt; m_documentLoader-&gt;responses().size(); ++i) {
2121             const auto&amp; response = m_documentLoader-&gt;responses()[i];
2122             // FIXME: If the WebKit client changes or cancels the request, this is not respected.
2123             ResourceError error;
2124             unsigned long identifier;
2125             ResourceRequest request(response.url());
2126             requestFromDelegate(request, identifier, error);
2127             // FIXME: If we get a resource with more than 2B bytes, this code won&#39;t do the right thing.
2128             // However, with today&#39;s computers and networking speeds, this won&#39;t happen in practice.
2129             // Could be an issue with a giant local file.
2130             notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, 0, static_cast&lt;int&gt;(response.expectedContentLength()), 0, error);
2131         }
2132 
2133         // FIXME: Why only this frame and not parent frames?
</pre>
<hr />
<pre>
2154     // The call to closeURL() invokes the unload event handler, which can execute arbitrary
2155     // JavaScript. If the script initiates a new load, we need to abandon the current load,
2156     // or the two will stomp each other.
2157     DocumentLoader* pdl = m_provisionalDocumentLoader.get();
2158     if (m_documentLoader)
2159         closeURL();
2160     if (pdl != m_provisionalDocumentLoader)
2161         return;
2162 
2163     if (m_documentLoader)
2164         m_documentLoader-&gt;stopLoadingSubresources();
2165     if (m_documentLoader)
2166         m_documentLoader-&gt;stopLoadingPlugIns();
2167 
2168     // Setting our document loader invokes the unload event handler of our child frames.
2169     // Script can do anything. If the script initiates a new load, we need to abandon the
2170     // current load or the two will stomp each other.
2171     setDocumentLoader(m_provisionalDocumentLoader.get());
2172     if (pdl != m_provisionalDocumentLoader)
2173         return;
<span class="line-added">2174     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;transitionToCommitted: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
2175     setProvisionalDocumentLoader(nullptr);
2176 
2177     // Nothing else can interrupt this commit - set the Provisional-&gt;Committed transition in stone
2178     setState(FrameStateCommittedPage);
2179 
2180     // Handle adding the URL to the back/forward list.
2181     DocumentLoader* dl = m_documentLoader.get();
2182 
2183     switch (m_loadType) {
2184     case FrameLoadType::Forward:
2185     case FrameLoadType::Back:
2186     case FrameLoadType::IndexedBackForward:
2187         if (m_frame.page()) {
2188             // If the first load within a frame is a navigation within a back/forward list that was attached
2189             // without any of the items being loaded then we need to update the history in a similar manner as
2190             // for a standard load with the exception of updating the back/forward list (&lt;rdar://problem/8091103&gt;).
2191             if (!m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; m_frame.isMainFrame())
2192                 history().updateForStandardLoad(HistoryController::UpdateAllExceptBackForwardList);
2193 
2194             history().updateForBackForwardNavigation();
</pre>
<hr />
<pre>
2316 void FrameLoader::open(CachedFrameBase&amp; cachedFrame)
2317 {
2318     m_isComplete = false;
2319 
2320     // Don&#39;t re-emit the load event.
2321     m_didCallImplicitClose = true;
2322 
2323     URL url = cachedFrame.url();
2324 
2325     // FIXME: I suspect this block of code doesn&#39;t do anything.
2326     if (url.protocolIsInHTTPFamily() &amp;&amp; !url.host().isEmpty() &amp;&amp; url.path().isEmpty())
2327         url.setPath(&quot;/&quot;);
2328 
2329     started();
2330     auto document = makeRef(*cachedFrame.document());
2331     ASSERT(document-&gt;domWindow());
2332 
2333     clear(document.ptr(), true, true, cachedFrame.isMainFrame());
2334 
2335     document-&gt;attachToCachedFrame(cachedFrame);
<span class="line-modified">2336     document-&gt;setBackForwardCacheState(Document::NotInBackForwardCache);</span>
2337 
2338     m_needsClear = true;
2339     m_isComplete = false;
2340     m_didCallImplicitClose = false;
2341     setOutgoingReferrer(url);
2342 
2343     FrameView* view = cachedFrame.view();
2344 
2345     // When navigating to a CachedFrame its FrameView should never be null.  If it is we&#39;ll crash in creative ways downstream.
2346     ASSERT(view);
2347     view-&gt;setWasScrolledByUser(false);
2348 
2349     Optional&lt;IntRect&gt; previousViewFrameRect = m_frame.view() ?  m_frame.view()-&gt;frameRect() : Optional&lt;IntRect&gt;(WTF::nullopt);
2350     m_frame.setView(view);
2351 
2352     // Use the previous ScrollView&#39;s frame rect.
2353     if (previousViewFrameRect)
2354         view-&gt;setFrameRect(previousViewFrameRect.value());
2355 
2356 
2357     // Setting the document builds the render tree and runs post style resolution callbacks that can do anything,
2358     // including loading a child frame before its been re-attached to the frame tree as part of this restore.
2359     // For example, the HTML object element may load its content into a frame in a post style resolution callback.
2360     Style::PostResolutionCallbackDisabler disabler(document.get());
2361     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2362     NavigationDisabler disableNavigation { &amp;m_frame };
2363 
2364     m_frame.setDocument(document.copyRef());
2365 
<span class="line-modified">2366     document-&gt;domWindow()-&gt;resumeFromBackForwardCache();</span>
2367 
2368     updateFirstPartyForCookies();
2369 
2370     cachedFrame.restore();
2371 }
2372 
2373 bool FrameLoader::isHostedByObjectElement() const
2374 {
2375     HTMLFrameOwnerElement* owner = m_frame.ownerElement();
2376     return owner &amp;&amp; owner-&gt;hasTagName(objectTag);
2377 }
2378 
2379 bool FrameLoader::isReplacing() const
2380 {
2381     return m_loadType == FrameLoadType::Replace;
2382 }
2383 
2384 void FrameLoader::setReplacing()
2385 {
2386     m_loadType = FrameLoadType::Replace;
</pre>
<hr />
<pre>
2400         documentLoader = childLoader.policyDocumentLoader();
2401         if (documentLoader)
2402             return true;
2403     }
2404     return false;
2405 }
2406 
2407 void FrameLoader::willChangeTitle(DocumentLoader* loader)
2408 {
2409     m_client.willChangeTitle(loader);
2410 }
2411 
2412 FrameLoadType FrameLoader::loadType() const
2413 {
2414     return m_loadType;
2415 }
2416 
2417 CachePolicy FrameLoader::subresourceCachePolicy(const URL&amp; url) const
2418 {
2419     if (Page* page = m_frame.page()) {
<span class="line-modified">2420         if (page-&gt;isResourceCachingDisabledByWebInspector())</span>
2421             return CachePolicyReload;
2422     }
2423 
2424     if (m_isComplete)
2425         return CachePolicyVerify;
2426 
2427     if (m_loadType == FrameLoadType::ReloadFromOrigin)
2428         return CachePolicyReload;
2429 
2430     if (Frame* parentFrame = m_frame.tree().parent()) {
2431         CachePolicy parentCachePolicy = parentFrame-&gt;loader().subresourceCachePolicy(url);
2432         if (parentCachePolicy != CachePolicyVerify)
2433             return parentCachePolicy;
2434     }
2435 
2436     switch (m_loadType) {
2437     case FrameLoadType::Reload:
2438         return CachePolicyRevalidate;
2439     case FrameLoadType::Back:
2440     case FrameLoadType::Forward:
</pre>
<hr />
<pre>
2508 
2509             RefPtr&lt;DocumentLoader&gt; pdl = m_provisionalDocumentLoader;
2510             if (!pdl)
2511                 return;
2512 
2513             // If we&#39;ve received any errors we may be stuck in the provisional state and actually complete.
2514             const ResourceError&amp; error = pdl-&gt;mainDocumentError();
2515             if (error.isNull())
2516                 return;
2517 
2518             // Check all children first.
2519             RefPtr&lt;HistoryItem&gt; item;
2520             if (Page* page = m_frame.page())
2521                 if (isBackForwardLoadType(loadType()))
2522                     // Reset the back forward list to the last committed history item at the top level.
2523                     item = page-&gt;mainFrame().loader().history().currentItem();
2524 
2525             // Only reset if we aren&#39;t already going to a new provisional item.
2526             bool shouldReset = !history().provisionalItem();
2527             if (!pdl-&gt;isLoadingInAPISense() || pdl-&gt;isStopping()) {
<span class="line-modified">2528                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Failed provisional load (isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, error.isTimeout(), error.isCancellation(), error.errorCode());</span>
2529 
2530                 dispatchDidFailProvisionalLoad(*pdl, error);
2531                 ASSERT(!pdl-&gt;isLoading());
2532 
2533                 // If we&#39;re in the middle of loading multipart data, we need to restore the document loader.
2534                 if (isReplacing() &amp;&amp; !m_documentLoader.get())
2535                     setDocumentLoader(m_provisionalDocumentLoader.get());
2536 
2537                 // Finish resetting the load state, but only if another load hasn&#39;t been started by the
2538                 // delegate callback.
2539                 if (pdl == m_provisionalDocumentLoader)
2540                     clearProvisionalLoad();
2541                 else if (activeDocumentLoader()) {
2542                     URL unreachableURL = activeDocumentLoader()-&gt;unreachableURL();
2543                     if (!unreachableURL.isEmpty() &amp;&amp; unreachableURL == pdl-&gt;request().url())
2544                         shouldReset = false;
2545                 }
2546             }
2547             if (shouldReset &amp;&amp; item)
2548                 if (Page* page = m_frame.page()) {
</pre>
<hr />
<pre>
2570                 if (isBackForwardLoadType(m_loadType) || isReload(m_loadType))
2571                     history().restoreScrollPositionAndViewState();
2572             }
2573 
2574             if (m_stateMachine.creatingInitialEmptyDocument() || !m_stateMachine.committedFirstRealDocumentLoad())
2575                 return;
2576 
2577             m_progressTracker-&gt;progressCompleted();
2578             Page* page = m_frame.page();
2579             if (page) {
2580                 if (m_frame.isMainFrame()) {
2581                     tracePoint(MainResourceLoadDidEnd);
2582                     page-&gt;didFinishLoad();
2583                 }
2584             }
2585 
2586             const ResourceError&amp; error = m_documentLoader-&gt;mainDocumentError();
2587 
2588             AXObjectCache::AXLoadingEvent loadingEvent;
2589             if (!error.isNull()) {
<span class="line-modified">2590                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Finished frame load with error (isTimeout = %d, isCancellation = %d, errorCode = %d)&quot;, error.isTimeout(), error.isCancellation(), error.errorCode());</span>
2591                 m_client.dispatchDidFailLoad(error);
2592                 loadingEvent = AXObjectCache::AXLoadingFailed;
2593             } else {
<span class="line-modified">2594                 FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;checkLoadCompleteForThisFrame: Finished frame load&quot;);</span>
2595 #if ENABLE(DATA_DETECTION)
2596                 auto* document = m_frame.document();
2597                 if (m_frame.settings().dataDetectorTypes() != DataDetectorTypeNone &amp;&amp; document) {
2598                     if (auto* documentElement = document-&gt;documentElement()) {
2599                         RefPtr&lt;Range&gt; documentRange = makeRange(firstPositionInNode(documentElement), lastPositionInNode(documentElement));
2600                         m_frame.setDataDetectionResults(DataDetection::detectContentInRange(documentRange, m_frame.settings().dataDetectorTypes(), m_client.dataDetectionContext()));
2601                         if (m_frame.isMainFrame())
2602                             m_client.dispatchDidFinishDataDetection(m_frame.dataDetectionResults());
2603                     }
2604                 }
2605 #endif
2606                 m_client.dispatchDidFinishLoad();
2607                 loadingEvent = AXObjectCache::AXLoadingFinished;
2608             }
2609 
2610             // Notify accessibility.
2611             if (auto* document = m_frame.document()) {
2612                 if (AXObjectCache* cache = document-&gt;existingAXObjectCache())
2613                     cache-&gt;frameLoadingEventNotification(&amp;m_frame, loadingEvent);
2614             }
</pre>
<hr />
<pre>
2756         if ((*frame)-&gt;page())
2757             (*frame)-&gt;loader().checkLoadCompleteForThisFrame();
2758     }
2759 }
2760 
2761 int FrameLoader::numPendingOrLoadingRequests(bool recurse) const
2762 {
2763     if (!recurse)
2764         return m_frame.document()-&gt;cachedResourceLoader().requestCount();
2765 
2766     int count = 0;
2767     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame))
2768         count += frame-&gt;document()-&gt;cachedResourceLoader().requestCount();
2769     return count;
2770 }
2771 
2772 String FrameLoader::userAgent(const URL&amp; url) const
2773 {
2774     String userAgent;
2775 















2776     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2777         if (m_frame.settings().needsSiteSpecificQuirks())
<span class="line-modified">2778             userAgent = documentLoader-&gt;customUserAgentAsSiteSpecificQuirks();</span>
2779         if (userAgent.isEmpty())
2780             userAgent = documentLoader-&gt;customUserAgent();
2781     }
2782 
2783     InspectorInstrumentation::applyUserAgentOverride(m_frame, userAgent);
2784 
2785     if (!userAgent.isEmpty())
2786         return userAgent;
2787 
2788     return m_client.userAgent(url);
2789 }
2790 
2791 String FrameLoader::navigatorPlatform() const
2792 {
2793     if (auto* documentLoader = m_frame.mainFrame().loader().activeDocumentLoader()) {
2794         auto&amp; customNavigatorPlatform = documentLoader-&gt;customNavigatorPlatform();
2795         if (!customNavigatorPlatform.isEmpty())
2796             return customNavigatorPlatform;
2797     }
2798     return String();
2799 }
2800 
2801 void FrameLoader::dispatchOnloadEvents()
2802 {
2803     m_client.dispatchDidDispatchOnloadEvents();
2804 
2805     if (documentLoader())
2806         documentLoader()-&gt;dispatchOnloadEvents();
2807 }
2808 
2809 void FrameLoader::frameDetached()
2810 {
2811     // Calling stopAllLoadersAndCheckCompleteness() can cause the frame to be deallocated, including the frame loader.
2812     Ref&lt;Frame&gt; protectedFrame(m_frame);
2813 
2814     if (m_checkTimer.isActive()) {
2815         m_checkTimer.stop();
2816         checkCompletenessNow();
2817     }
2818 
<span class="line-modified">2819     if (m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {</span>
2820         stopAllLoadersAndCheckCompleteness();
2821         m_frame.document()-&gt;stopActiveDOMObjects();
2822     }
2823 
2824     detachFromParent();
2825 }
2826 
2827 void FrameLoader::detachFromParent()
2828 {
2829     // Calling stopAllLoaders() can cause the frame to be deallocated, including the frame loader.
2830     Ref&lt;Frame&gt; protect(m_frame);
2831 
2832     closeURL();
2833     history().saveScrollPositionAndViewStateToItem(history().currentItem());
2834     detachChildren();
<span class="line-modified">2835     if (m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache) {</span>
<span class="line-modified">2836         // stopAllLoaders() needs to be called after detachChildren() if the document is not in the back/forward cache,</span>
2837         // because detachedChildren() will trigger the unload event handlers of any child frames, and those event
2838         // handlers might start a new subresource load in this frame.
2839         stopAllLoaders(ShouldClearProvisionalItem, StopLoadingPolicy::AlwaysStopLoading);
2840     }
2841 
2842     InspectorInstrumentation::frameDetachedFromParent(m_frame);
2843 
2844     detachViewsAndDocumentLoader();
2845 
2846     m_progressTracker = nullptr;
2847 
2848     if (Frame* parent = m_frame.tree().parent()) {
2849         parent-&gt;loader().closeAndRemoveChild(m_frame);
2850         parent-&gt;loader().scheduleCheckCompleted();
2851         parent-&gt;loader().scheduleCheckLoadComplete();
2852     } else {
2853         m_frame.setView(nullptr);
2854         m_frame.willDetachPage();
2855         m_frame.detachFromPage();
2856     }
</pre>
<hr />
<pre>
2926             request.setFirstPartyForCookies(document-&gt;firstPartyForCookies());
2927     }
2928 
2929     if (request.isSameSiteUnspecified()) {
2930         auto* initiator = m_frame.document();
2931         if (isMainResource) {
2932             auto* ownerFrame = m_frame.tree().parent();
2933             if (!ownerFrame &amp;&amp; m_stateMachine.isDisplayingInitialEmptyDocument())
2934                 ownerFrame = m_opener;
2935             if (ownerFrame)
2936                 initiator = ownerFrame-&gt;document();
2937             ASSERT(ownerFrame || m_frame.isMainFrame());
2938         }
2939         addSameSiteInfoToRequestIfNeeded(request, initiator);
2940     }
2941     request.setIsTopSite(isMainFrameMainResource);
2942 
2943     Page* page = frame().page();
2944     bool hasSpecificCachePolicy = request.cachePolicy() != ResourceRequestCachePolicy::UseProtocolCachePolicy;
2945 
<span class="line-modified">2946     if (page &amp;&amp; page-&gt;isResourceCachingDisabledByWebInspector()) {</span>
2947         request.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
2948         loadType = FrameLoadType::ReloadFromOrigin;
2949     } else if (!hasSpecificCachePolicy)
2950         request.setCachePolicy(defaultRequestCachingPolicy(request, loadType, isMainResource));
2951 
2952     // The remaining modifications are only necessary for HTTP and HTTPS.
2953     if (!request.url().isEmpty() &amp;&amp; !request.url().protocolIsInHTTPFamily())
2954         return;
2955 
2956     if (!hasSpecificCachePolicy &amp;&amp; request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData) {
2957         if (loadType == FrameLoadType::Reload)
<span class="line-modified">2958             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());</span>
2959         else if (loadType == FrameLoadType::ReloadFromOrigin) {
<span class="line-modified">2960             request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::noCache());</span>
<span class="line-modified">2961             request.setHTTPHeaderField(HTTPHeaderName::Pragma, HTTPHeaderValues::noCache());</span>
2962         }
2963     }
2964 
2965     if (m_overrideResourceLoadPriorityForTesting)
2966         request.setPriority(m_overrideResourceLoadPriorityForTesting.value());
2967 
2968     applyUserAgentIfNeeded(request);
2969 
2970     if (isMainResource)
2971         request.setHTTPAccept(defaultAcceptHeader);
2972 
2973     // Make sure we send the Origin header.
2974     addHTTPOriginIfNeeded(request, String());
2975 
2976     // Only set fallback array if it&#39;s still empty (later attempts may be incorrect, see bug 117818).
2977     if (request.responseContentDispositionEncodingFallbackArray().isEmpty()) {
2978         // Always try UTF-8. If that fails, try frame encoding (if any) and then the default.
2979         request.setResponseContentDispositionEncodingFallbackArray(&quot;UTF-8&quot;, m_frame.document()-&gt;encoding(), m_frame.settings().defaultTextEncodingName());
2980     }
2981 }
</pre>
<hr />
<pre>
3020     }
3021     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(request.url())) {
3022         request.setIsSameSite(true);
3023         return;
3024     }
3025     request.setIsSameSite(areRegistrableDomainsEqual(initiator-&gt;siteForCookies(), request.url()));
3026 }
3027 
3028 void FrameLoader::addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp; request)
3029 {
3030     if (request.url().protocolIs(&quot;https&quot;)) {
3031         // FIXME: Identify HSTS cases and avoid adding the header. &lt;https://bugs.webkit.org/show_bug.cgi?id=157885&gt;
3032         return;
3033     }
3034 
3035     request.setHTTPHeaderField(HTTPHeaderName::UpgradeInsecureRequests, &quot;1&quot;_s);
3036 }
3037 
3038 void FrameLoader::loadPostRequest(FrameLoadRequest&amp;&amp; request, const String&amp; referrer, FrameLoadType loadType, Event* event, RefPtr&lt;FormState&gt;&amp;&amp; formState, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
3039 {
<span class="line-modified">3040     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadPostRequest: frame load started&quot;);</span>
3041 
3042     String frameName = request.frameName();
3043     LockHistory lockHistory = request.lockHistory();
3044     AllowNavigationToInvalidURL allowNavigationToInvalidURL = request.allowNavigationToInvalidURL();
3045     NewFrameOpenerPolicy openerPolicy = request.newFrameOpenerPolicy();
3046 
3047     const ResourceRequest&amp; inRequest = request.resourceRequest();
3048     const URL&amp; url = inRequest.url();
3049     const String&amp; contentType = inRequest.httpContentType();
3050     String origin = inRequest.httpOrigin();
3051 
3052     ResourceRequest workingResourceRequest(url);
3053 
3054     if (!referrer.isEmpty())
3055         workingResourceRequest.setHTTPReferrer(referrer);
3056     workingResourceRequest.setHTTPOrigin(origin);
3057     workingResourceRequest.setHTTPMethod(&quot;POST&quot;);
3058     workingResourceRequest.setHTTPBody(inRequest.httpBody());
3059     workingResourceRequest.setHTTPContentType(contentType);
3060     addExtraFieldsToRequest(workingResourceRequest, loadType, true);
3061 
3062     if (Document* document = m_frame.document())
3063         document-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(workingResourceRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3064 
3065     NavigationAction action { request.requester(), workingResourceRequest, request.initiatedByMainFrame(), loadType, true, event, request.shouldOpenExternalURLsPolicy(), request.downloadAttribute() };
3066 
3067     if (!frameName.isEmpty()) {
3068         // The search for a target frame is done earlier in the case of form submission.
3069         if (auto* targetFrame = formState ? nullptr : findFrameForNavigation(frameName)) {
3070             targetFrame-&gt;loader().loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, WTFMove(completionHandler));
3071             return;
3072         }
3073 
<span class="line-modified">3074         policyChecker().checkNewWindowPolicy(WTFMove(action), WTFMove(workingResourceRequest), WTFMove(formState), frameName, [this, allowNavigationToInvalidURL, openerPolicy, completionHandler = WTFMove(completionHandler)] (const ResourceRequest&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp; formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue) mutable {</span>
3075             continueLoadAfterNewWindowPolicy(request, formState.get(), frameName, action, shouldContinue, allowNavigationToInvalidURL, openerPolicy);
3076             completionHandler();
3077         });
3078         return;
3079     }
3080 
3081     // must grab this now, since this load may stop the previous load and clear this flag
3082     bool isRedirect = m_quickRedirectComing;
3083     loadWithNavigationAction(workingResourceRequest, WTFMove(action), lockHistory, loadType, WTFMove(formState), allowNavigationToInvalidURL, { }, [this, isRedirect, protectedFrame = makeRef(m_frame), completionHandler = WTFMove(completionHandler)] () mutable {
3084         if (isRedirect) {
3085             m_quickRedirectComing = false;
3086             if (m_provisionalDocumentLoader)
3087                 m_provisionalDocumentLoader-&gt;setIsClientRedirect(true);
3088             else if (m_policyDocumentLoader)
3089                 m_policyDocumentLoader-&gt;setIsClientRedirect(true);
3090         }
3091         completionHandler();
3092     });
3093 }
3094 
</pre>
<hr />
<pre>
3123                     newRequest = { };
3124                     error = ResourceError(errorDomainWebKitInternal, 0, initialRequest.url(), emptyString());
3125                     response = { };
3126                     data = nullptr;
3127                 }
3128             }
3129         }
3130     }
3131 #endif
3132 
3133     m_frame.document()-&gt;contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(newRequest, ContentSecurityPolicy::InsecureRequestType::Load);
3134 
3135     if (error.isNull()) {
3136         ASSERT(!newRequest.isNull());
3137 
3138         if (!documentLoader()-&gt;applicationCacheHost().maybeLoadSynchronously(newRequest, error, response, data)) {
3139             Vector&lt;char&gt; buffer;
3140             platformStrategies()-&gt;loaderStrategy()-&gt;loadResourceSynchronously(*this, identifier, newRequest, clientCredentialPolicy, options, originalRequestHeaders, error, response, buffer);
3141             data = SharedBuffer::create(WTFMove(buffer));
3142             documentLoader()-&gt;applicationCacheHost().maybeLoadFallbackSynchronously(newRequest, error, response, data);
<span class="line-modified">3143             ResourceLoadObserver::shared().logSubresourceLoading(&amp;m_frame, newRequest, response,</span>
<span class="line-added">3144                 (isScriptLikeDestination(options.destination) ? ResourceLoadObserver::FetchDestinationIsScriptLike::Yes : ResourceLoadObserver::FetchDestinationIsScriptLike::No));</span>
3145         }
3146     }
3147     notifier().sendRemainingDelegateMessages(m_documentLoader.get(), identifier, request, response, data ? data-&gt;data() : nullptr, data ? data-&gt;size() : 0, -1, error);
3148     return identifier;
3149 }
3150 
3151 const ResourceRequest&amp; FrameLoader::originalRequest() const
3152 {
3153     return activeDocumentLoader()-&gt;originalRequestCopy();
3154 }
3155 
3156 void FrameLoader::receivedMainResourceError(const ResourceError&amp; error)
3157 {
3158     // Retain because the stop may release the last reference to it.
3159     Ref&lt;Frame&gt; protect(m_frame);
3160 
3161     RefPtr&lt;DocumentLoader&gt; loader = activeDocumentLoader();
3162     // FIXME: Don&#39;t want to do this if an entirely new load is going, so should check
3163     // that both data sources on the frame are either this or nil.
3164     stop();
3165     if (m_client.shouldFallBack(error))
3166         handleFallbackContent();
3167 
3168     if (m_state == FrameStateProvisional &amp;&amp; m_provisionalDocumentLoader) {
3169         if (m_submittedFormURL == m_provisionalDocumentLoader-&gt;originalRequestCopy().url())
3170             m_submittedFormURL = URL();
3171 
<span class="line-modified">3172         // We might have made a back/forward cache item, but now we&#39;re bailing out due to an error before we ever</span>
3173         // transitioned to the new page (before WebFrameState == commit).  The goal here is to restore any state
3174         // so that the existing view (that wenever got far enough to replace) can continue being used.
3175         history().invalidateCurrentItemCachedPage();
3176 
3177         // Call clientRedirectCancelledOrFinished here so that the frame load delegate is notified that the redirect&#39;s
3178         // status has changed, if there was a redirect. The frame load delegate may have saved some state about
3179         // the redirect in its -webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:. Since we are definitely
3180         // not going to use this provisional resource, as it was cancelled, notify the frame load delegate that the redirect
3181         // has ended.
3182         if (m_sentRedirectNotification)
3183             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3184     }
3185 
3186     checkCompleted();
3187     if (m_frame.page())
3188         checkLoadComplete();
3189 }
3190 
3191 void FrameLoader::continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp; request, bool shouldContinue)
3192 {
3193     m_quickRedirectComing = false;
3194 
3195     if (!shouldContinue)
3196         return;
3197 
3198     // Calling stopLoading() on the provisional document loader can cause the underlying
3199     // frame to be deallocated.
3200     Ref&lt;Frame&gt; protectedFrame(m_frame);
3201 
3202     // If we have a provisional request for a different document, a fragment scroll should cancel it.
3203     if (m_provisionalDocumentLoader &amp;&amp; !equalIgnoringFragmentIdentifier(m_provisionalDocumentLoader-&gt;request().url(), request.url())) {
3204         m_provisionalDocumentLoader-&gt;stopLoading();
<span class="line-added">3205         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueFragmentScrollAfterNavigationPolicy: Clearing provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
3206         setProvisionalDocumentLoader(nullptr);
3207     }
3208 
3209     bool isRedirect = m_quickRedirectComing || policyChecker().loadType() == FrameLoadType::RedirectWithLockedBackForwardList;
3210     loadInSameDocument(request.url(), 0, !isRedirect);
3211 }
3212 
3213 bool FrameLoader::shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType loadType, const URL&amp; url)
3214 {
3215     // We don&#39;t do this if we are submitting a form with method other than &quot;GET&quot;, explicitly reloading,
3216     // currently displaying a frameset, or if the URL does not have a fragment.
3217     // These rules were originally based on what KHTML was doing in KHTMLPart::openURL.
3218 
3219     // FIXME: What about load types other than Standard and Reload?
3220 
3221     return (!isFormSubmission || equalLettersIgnoringASCIICase(httpMethod, &quot;get&quot;))
3222         &amp;&amp; !isReload(loadType)
3223         &amp;&amp; loadType != FrameLoadType::Same
<span class="line-modified">3224         &amp;&amp; m_frame.document()-&gt;backForwardCacheState() != Document::InBackForwardCache</span>
3225         &amp;&amp; !shouldReload(m_frame.document()-&gt;url(), url)
3226         // We don&#39;t want to just scroll if a link from within a
3227         // frameset is trying to reload the frameset into _top.
3228         &amp;&amp; !m_frame.document()-&gt;isFrameSet();
3229 }
3230 
3231 static bool itemAllowsScrollRestoration(HistoryItem* historyItem)
3232 {
3233     return !historyItem || historyItem-&gt;shouldRestoreScrollPosition();
3234 }
3235 
3236 static bool isSameDocumentReload(bool isNewNavigation, FrameLoadType loadType)
3237 {
3238     return !isNewNavigation &amp;&amp; !isBackForwardLoadType(loadType);
3239 }
3240 
3241 void FrameLoader::scrollToFragmentWithParentBoundary(const URL&amp; url, bool isNewNavigation)
3242 {
<span class="line-modified">3243     auto view = makeRefPtr(m_frame.view());</span>
<span class="line-modified">3244     auto document = makeRefPtr(m_frame.document());</span>
<span class="line-added">3245     if (!view || !document)</span>
3246         return;
3247 
<span class="line-modified">3248     if (isSameDocumentReload(isNewNavigation, m_loadType) || itemAllowsScrollRestoration(history().currentItem())) {</span>
<span class="line-modified">3249         // https://html.spec.whatwg.org/multipage/browsing-the-web.html#try-to-scroll-to-the-fragment</span>
<span class="line-added">3250         if (!document-&gt;haveStylesheetsLoaded())</span>
<span class="line-added">3251             document-&gt;setGotoAnchorNeededAfterStylesheetsLoad(true);</span>
<span class="line-added">3252         else</span>
<span class="line-added">3253             view-&gt;scrollToFragment(url);</span>
<span class="line-added">3254     }</span>
<span class="line-added">3255 </span>
3256 }
3257 
3258 bool FrameLoader::shouldClose()
3259 {
3260     Page* page = m_frame.page();
3261     if (!page)
3262         return true;
3263     if (!page-&gt;chrome().canRunBeforeUnloadConfirmPanel())
3264         return true;
3265 
3266     // Store all references to each subframe in advance since beforeunload&#39;s event handler may modify frame
3267     Vector&lt;Ref&lt;Frame&gt;, 16&gt; targetFrames;
3268     targetFrames.append(m_frame);
3269     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().traverseNext(&amp;m_frame))
3270         targetFrames.append(*child);
3271 
3272     bool shouldClose = false;
3273     {
3274         NavigationDisabler navigationDisabler(&amp;m_frame);
3275         IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
</pre>
<hr />
<pre>
3286             shouldClose = true;
3287     }
3288 
3289     if (!shouldClose)
3290         m_submittedFormURL = URL();
3291 
3292     m_currentNavigationHasShownBeforeUnloadConfirmPanel = false;
3293     return shouldClose;
3294 }
3295 
3296 void FrameLoader::dispatchUnloadEvents(UnloadEventPolicy unloadEventPolicy)
3297 {
3298     if (!m_frame.document())
3299         return;
3300 
3301     if (m_pageDismissalEventBeingDispatched != PageDismissalType::None)
3302         return;
3303 
3304     // We store the frame&#39;s page in a local variable because the frame might get detached inside dispatchEvent.
3305     ForbidPromptsScope forbidPrompts(m_frame.page());
<span class="line-added">3306     ForbidSynchronousLoadsScope forbidSynchronousLoads(m_frame.page());</span>
3307     IgnoreOpensDuringUnloadCountIncrementer ignoreOpensDuringUnloadCountIncrementer(m_frame.document());
3308 
3309     if (m_didCallImplicitClose &amp;&amp; !m_wasUnloadEventEmitted) {
3310         auto* currentFocusedElement = m_frame.document()-&gt;focusedElement();
3311         if (is&lt;HTMLInputElement&gt;(currentFocusedElement))
3312             downcast&lt;HTMLInputElement&gt;(*currentFocusedElement).endEditing();
3313         if (m_pageDismissalEventBeingDispatched == PageDismissalType::None) {
3314             if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide) {
3315                 m_pageDismissalEventBeingDispatched = PageDismissalType::PageHide;
<span class="line-modified">3316                 m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, m_frame.document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache), m_frame.document());</span>
3317             }
3318 
3319             // FIXME: update Page Visibility state here.
3320             // https://bugs.webkit.org/show_bug.cgi?id=116770
3321 
<span class="line-modified">3322             if (m_frame.document()-&gt;backForwardCacheState() == Document::NotInBackForwardCache) {</span>
3323                 Ref&lt;Event&gt; unloadEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No));
3324                 // The DocumentLoader (and thus its LoadTiming) might get destroyed
3325                 // while dispatching the event, so protect it to prevent writing the end
3326                 // time into freed memory.
3327                 RefPtr&lt;DocumentLoader&gt; documentLoader = m_provisionalDocumentLoader;
3328                 m_pageDismissalEventBeingDispatched = PageDismissalType::Unload;
3329                 if (documentLoader &amp;&amp; documentLoader-&gt;timing().startTime() &amp;&amp; !documentLoader-&gt;timing().unloadEventStart() &amp;&amp; !documentLoader-&gt;timing().unloadEventEnd()) {
3330                     auto&amp; timing = documentLoader-&gt;timing();
3331                     timing.markUnloadEventStart();
3332                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3333                     timing.markUnloadEventEnd();
3334                 } else
3335                     m_frame.document()-&gt;domWindow()-&gt;dispatchEvent(unloadEvent, m_frame.document());
3336             }
3337         }
3338         m_pageDismissalEventBeingDispatched = PageDismissalType::None;
3339         m_wasUnloadEventEmitted = true;
3340     }
3341 
3342     // Dispatching the unload event could have made m_frame.document() null.
3343     if (!m_frame.document())
3344         return;
3345 
<span class="line-modified">3346     if (m_frame.document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache)</span>
3347         return;
3348 
3349     // Don&#39;t remove event listeners from a transitional empty document (see bug 28716 for more information).
3350     bool keepEventListeners = m_stateMachine.isDisplayingInitialEmptyDocument() &amp;&amp; m_provisionalDocumentLoader
3351         &amp;&amp; m_frame.document()-&gt;isSecureTransitionTo(m_provisionalDocumentLoader-&gt;url());
3352 
3353     if (!keepEventListeners)
3354         m_frame.document()-&gt;removeAllEventListeners();
3355 }
3356 
3357 static bool shouldAskForNavigationConfirmation(Document&amp; document, const BeforeUnloadEvent&amp; event)
3358 {
3359     // Confirmation dialog should not be displayed when the allow-modals flag is not set.
3360     if (document.isSandboxed(SandboxModals))
3361         return false;
3362 
3363     bool userDidInteractWithPage = document.topDocument().userDidInteractWithPage();
3364     // Web pages can request we ask for confirmation before navigating by:
3365     // - Cancelling the BeforeUnloadEvent (modern way)
3366     // - Setting the returnValue attribute on the BeforeUnloadEvent to a non-empty string.
3367     // - Returning a non-empty string from the event handler, which is then set as returnValue
3368     //   attribute on the BeforeUnloadEvent.
3369     return userDidInteractWithPage &amp;&amp; (event.defaultPrevented() || !event.returnValue().isEmpty());
3370 }
3371 
3372 bool FrameLoader::dispatchBeforeUnloadEvent(Chrome&amp; chrome, FrameLoader* frameLoaderBeingNavigated)
3373 {
3374     DOMWindow* domWindow = m_frame.document()-&gt;domWindow();
3375     if (!domWindow)
3376         return true;
3377 
3378     RefPtr&lt;Document&gt; document = m_frame.document();
3379     if (!document-&gt;bodyOrFrameset())
3380         return true;
3381 
3382     Ref&lt;BeforeUnloadEvent&gt; beforeUnloadEvent = BeforeUnloadEvent::create();
3383 
3384     {
3385         SetForScope&lt;PageDismissalType&gt; change(m_pageDismissalEventBeingDispatched, PageDismissalType::BeforeUnload);
3386         ForbidPromptsScope forbidPrompts(m_frame.page());
<span class="line-added">3387         ForbidSynchronousLoadsScope forbidSynchronousLoads(m_frame.page());</span>
3388         domWindow-&gt;dispatchEvent(beforeUnloadEvent, domWindow-&gt;document());
3389     }
3390 
3391     if (!beforeUnloadEvent-&gt;defaultPrevented())
3392         document-&gt;defaultEventHandler(beforeUnloadEvent.get());
3393 
3394     if (!shouldAskForNavigationConfirmation(*document, beforeUnloadEvent))
3395         return true;
3396 
3397     // If the navigating FrameLoader has already shown a beforeunload confirmation panel for the current navigation attempt,
3398     // this frame is not allowed to cause another one to be shown.
3399     if (frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel) {
3400         document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Blocked attempt to show multiple beforeunload confirmation dialogs for the same navigation.&quot;_s);
3401         return true;
3402     }
3403 
3404     // We should only display the beforeunload dialog for an iframe if its SecurityOrigin matches all
3405     // ancestor frame SecurityOrigins up through the navigating FrameLoader.
3406     if (frameLoaderBeingNavigated != this) {
3407         Frame* parentFrame = m_frame.tree().parent();
</pre>
<hr />
<pre>
3427 
3428     frameLoaderBeingNavigated-&gt;m_currentNavigationHasShownBeforeUnloadConfirmPanel = true;
3429 
3430     String text = document-&gt;displayStringModifiedByEncoding(beforeUnloadEvent-&gt;returnValue());
3431     return chrome.runBeforeUnloadConfirmPanel(text, m_frame);
3432 }
3433 
3434 void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, NavigationPolicyDecision navigationPolicyDecision, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
3435 {
3436     // If we loaded an alternate page to replace an unreachableURL, we&#39;ll get in here with a
3437     // nil policyDataSource because loading the alternate page will have passed
3438     // through this method already, nested; otherwise, policyDataSource should still be set.
3439     ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());
3440 
3441     bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;
3442 
3443     bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();
3444     bool canContinue = navigationPolicyDecision == NavigationPolicyDecision::ContinueLoad &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;
3445 
3446     if (!canContinue) {
<span class="line-modified">3447         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame due to the following reasons (&quot;</span>


3448             &quot;allowNavigationToInvalidURL = %d, &quot;
3449             &quot;requestURLIsValid = %d, &quot;
3450             &quot;navigationPolicyDecision = %d)&quot;,


3451             static_cast&lt;int&gt;(allowNavigationToInvalidURL),
3452             request.url().isValid(),
3453             static_cast&lt;int&gt;(navigationPolicyDecision));
3454 
3455         // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we
3456         // need to report that the client redirect was cancelled.
3457         // FIXME: The client should be told about ignored non-quick redirects, too.
3458         if (m_quickRedirectComing)
3459             clientRedirectCancelledOrFinished(NewLoadInProgress::No);
3460 
3461         if (navigationPolicyDecision == NavigationPolicyDecision::StopAllLoads) {
3462             stopAllLoaders();
3463             m_checkTimer.stop();
3464         }
3465 
3466         setPolicyDocumentLoader(nullptr);
3467         checkCompleted();
3468 
3469         if (navigationPolicyDecision != NavigationPolicyDecision::StopAllLoads)
3470             checkLoadComplete();
3471 
3472         // If the navigation request came from the back/forward menu, and we punt on it, we have the
3473         // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,
3474         // we only do this when punting a navigation for the target frame or top-level frame.
3475         if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) {
3476             if (Page* page = m_frame.page()) {
3477                 if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem())
3478                     page-&gt;backForward().setCurrentItem(*resetItem);
3479             }
3480         }
3481         return;
3482     }
3483 
3484     FrameLoadType type = policyChecker().loadType();
3485     // A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
3486     stopAllLoaders(ShouldNotClearProvisionalItem);
3487 
3488     // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
3489     // might detach the current FrameLoader, in which case we should bail on this newly defunct load.
3490     if (!m_frame.page()) {
<span class="line-modified">3491         FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it became defunct&quot;);</span>
3492         return;
3493     }
3494 
3495     setProvisionalDocumentLoader(m_policyDocumentLoader.get());
<span class="line-added">3496     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: Setting provisional document loader (m_provisionalDocumentLoader=%p)&quot;, m_provisionalDocumentLoader.get());</span>
3497     m_loadType = type;
3498     setState(FrameStateProvisional);
3499 
3500     setPolicyDocumentLoader(nullptr);
3501 
3502     if (isBackForwardLoadType(type)) {
3503         auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();
<span class="line-modified">3504         if (history().provisionalItem() &amp;&amp; history().provisionalItem()-&gt;isInBackForwardCache()) {</span>
<span class="line-modified">3505             diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::backForwardCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);</span>
3506             loadProvisionalItemFromCachedPage();
<span class="line-modified">3507             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy: can&#39;t continue loading frame because it will be loaded from cache&quot;);</span>
3508             return;
3509         }
<span class="line-modified">3510         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::backForwardCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);</span>
3511     }
3512 
3513     CompletionHandler&lt;void()&gt; completionHandler = [this, protectedFrame = makeRef(m_frame)] () mutable {
3514         if (!m_provisionalDocumentLoader) {
<span class="line-modified">3515             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Frame load canceled - no provisional document loader before prepareForLoadStart&quot;);</span>
3516             return;
3517         }
3518 
3519         prepareForLoadStart();
3520 
3521         // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,
3522         // so we need to null check it again.
3523         if (!m_provisionalDocumentLoader) {
<span class="line-modified">3524             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Frame load canceled - no provisional document loader after prepareForLoadStart&quot;);</span>
3525             return;
3526         }
3527 
3528         DocumentLoader* activeDocLoader = activeDocumentLoader();
3529         if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource()) {
<span class="line-modified">3530             FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;continueLoadAfterNavigationPolicy (completionHandler): Main frame already being loaded&quot;);</span>
3531             return;
3532         }
3533 
3534         m_loadingFromCachedPage = false;
3535 
3536         m_provisionalDocumentLoader-&gt;startLoadingMainResource();
3537     };
3538 
3539     if (!formState) {
3540         completionHandler();
3541         return;
3542     }
3543 
3544     m_client.dispatchWillSubmitForm(*formState, WTFMove(completionHandler));
3545 }
3546 
3547 void FrameLoader::continueLoadAfterNewWindowPolicy(const ResourceRequest&amp; request,
<span class="line-modified">3548     FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, PolicyChecker::ShouldContinue shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL, NewFrameOpenerPolicy openerPolicy)</span>
3549 {
<span class="line-modified">3550     if (shouldContinue != PolicyChecker::ShouldContinue::Yes)</span>
3551         return;
3552 
3553     Ref&lt;Frame&gt; frame(m_frame);
3554     RefPtr&lt;Frame&gt; mainFrame = m_client.dispatchCreatePage(action);
3555     if (!mainFrame)
3556         return;
3557 
3558     SandboxFlags sandboxFlags = frame-&gt;loader().effectiveSandboxFlags();
3559     if (sandboxFlags &amp; SandboxPropagatesToAuxiliaryBrowsingContexts)
3560         mainFrame-&gt;loader().forceSandboxFlags(sandboxFlags);
3561 
3562     if (!equalIgnoringASCIICase(frameName, &quot;_blank&quot;))
3563         mainFrame-&gt;tree().setName(frameName);
3564 
3565     mainFrame-&gt;page()-&gt;setOpenedByDOM();
3566     mainFrame-&gt;loader().m_client.dispatchShow();
3567     if (openerPolicy == NewFrameOpenerPolicy::Allow) {
3568         mainFrame-&gt;loader().setOpener(frame.ptr());
3569         mainFrame-&gt;document()-&gt;setReferrerPolicy(frame-&gt;document()-&gt;referrerPolicy());
3570     }
</pre>
<hr />
<pre>
3659     case XFrameOptionsDeny:
3660         return true;
3661     case XFrameOptionsAllowAll:
3662         return false;
3663     case XFrameOptionsConflict:
3664         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Multiple &#39;X-Frame-Options&#39; headers with conflicting values (&#39;&quot; + content + &quot;&#39;) encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;. Falling back to &#39;DENY&#39;.&quot;, requestIdentifier);
3665         return true;
3666     case XFrameOptionsInvalid:
3667         m_frame.document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Invalid &#39;X-Frame-Options&#39; header encountered when loading &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39;: &#39;&quot; + content + &quot;&#39; is not a recognized directive. The header will be ignored.&quot;, requestIdentifier);
3668         return false;
3669     case XFrameOptionsNone:
3670         return false;
3671     }
3672     ASSERT_NOT_REACHED();
3673     return false;
3674 }
3675 
3676 void FrameLoader::loadProvisionalItemFromCachedPage()
3677 {
3678     DocumentLoader* provisionalLoader = provisionalDocumentLoader();
<span class="line-modified">3679     LOG(BackForwardCache, &quot;FrameLoader::loadProvisionalItemFromCachedPage Loading provisional DocumentLoader %p with URL &#39;%s&#39; from CachedPage&quot;, provisionalDocumentLoader(), provisionalDocumentLoader()-&gt;url().stringCenterEllipsizedToLength().utf8().data());</span>
3680 
3681     prepareForLoadStart();
3682 
3683     m_loadingFromCachedPage = true;
3684 
3685     // Should have timing data from previous time(s) the page was shown.
3686     ASSERT(provisionalLoader-&gt;timing().startTime());
3687     provisionalLoader-&gt;resetTiming();
3688     provisionalLoader-&gt;timing().markStartTime();
3689 
3690     provisionalLoader-&gt;setCommitted(true);
3691     commitProvisionalLoad();
3692 }
3693 
3694 bool FrameLoader::shouldTreatURLAsSameAsCurrent(const URL&amp; url) const
3695 {
3696     if (!history().currentItem())
3697         return false;
3698     return url == history().currentItem()-&gt;url() || url == history().currentItem()-&gt;originalURL();
3699 }
</pre>
<hr />
<pre>
3733     // Save user view state to the current history item here since we don&#39;t do a normal load.
3734     // FIXME: Does form state need to be saved here too?
3735     history().saveScrollPositionAndViewStateToItem(history().currentItem());
3736     if (FrameView* view = m_frame.view())
3737         view-&gt;setWasScrolledByUser(false);
3738 
3739     history().setCurrentItem(item);
3740 
3741     // loadInSameDocument() actually changes the URL and notifies load delegates of a &quot;fake&quot; load
3742     loadInSameDocument(item.url(), item.stateObject(), false);
3743 
3744     // Restore user view state from the current history item here since we don&#39;t do a normal load.
3745     history().restoreScrollPositionAndViewState();
3746 }
3747 
3748 // FIXME: This function should really be split into a couple pieces, some of
3749 // which should be methods of HistoryController and some of which should be
3750 // methods of FrameLoader.
3751 void FrameLoader::loadDifferentDocumentItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType loadType, FormSubmissionCacheLoadPolicy cacheLoadPolicy, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
3752 {
<span class="line-modified">3753     FRAMELOADER_RELEASE_LOG_IF_ALLOWED(ResourceLoading, &quot;loadDifferentDocumentItem: frame load started&quot;);</span>
3754 
3755     Ref&lt;Frame&gt; protectedFrame(m_frame);
3756 
3757     // History items should not be reported to the parent.
3758     m_shouldReportResourceTimingToParentFrame = false;
3759 
3760     // Remember this item so we can traverse any child items as child frames load
3761     history().setProvisionalItem(&amp;item);
3762 
3763     auto initiatedByMainFrame = InitiatedByMainFrame::Unknown;
3764 
3765     SetForScope&lt;LoadContinuingState&gt; continuingLoadGuard(m_currentLoadContinuingState, shouldTreatAsContinuingLoad == ShouldTreatAsContinuingLoad::Yes ? LoadContinuingState::ContinuingWithHistoryItem : LoadContinuingState::NotContinuing);
3766 
<span class="line-modified">3767     if (CachedPage* cachedPage = BackForwardCache::singleton().get(item, m_frame.page())) {</span>
3768         auto documentLoader = cachedPage-&gt;documentLoader();
3769         m_client.updateCachedDocumentLoader(*documentLoader);
3770 
3771         auto action = NavigationAction { *m_frame.document(), documentLoader-&gt;request(), initiatedByMainFrame, loadType, false };
3772         action.setTargetBackForwardItem(item);
3773         action.setSourceBackForwardItem(fromItem);
3774         documentLoader-&gt;setTriggeringAction(WTFMove(action));
3775 
3776         documentLoader-&gt;setLastCheckedRequest(ResourceRequest());
3777         loadWithDocumentLoader(documentLoader, loadType, { }, AllowNavigationToInvalidURL::Yes, shouldTreatAsContinuingLoad);
3778         return;
3779     }
3780 
3781     URL itemURL = item.url();
3782     URL itemOriginalURL = item.originalURL();
3783     URL currentURL;
3784     if (documentLoader())
3785         currentURL = documentLoader()-&gt;url();
3786     RefPtr&lt;FormData&gt; formData = item.formData();
3787 
</pre>
<hr />
<pre>
3876     else
3877         loadDifferentDocumentItem(item, fromItem, loadType, MayAttemptCacheOnlyLoadForFormSubmissionItem, shouldTreatAsContinuingLoad);
3878 }
3879 
3880 void FrameLoader::retryAfterFailedCacheOnlyMainResourceLoad()
3881 {
3882     ASSERT(m_state == FrameStateProvisional);
3883     ASSERT(!m_loadingFromCachedPage);
3884     ASSERT(history().provisionalItem());
3885     ASSERT(history().provisionalItem()-&gt;formData());
3886     ASSERT(history().provisionalItem() == m_requestedHistoryItem.get());
3887 
3888     FrameLoadType loadType = m_loadType;
3889     HistoryItem* item = history().provisionalItem();
3890 
3891     stopAllLoaders(ShouldNotClearProvisionalItem);
3892     if (item)
3893         loadDifferentDocumentItem(*item, history().currentItem(), loadType, MayNotAttemptCacheOnlyLoadForFormSubmissionItem, ShouldTreatAsContinuingLoad::No);
3894     else {
3895         ASSERT_NOT_REACHED();
<span class="line-modified">3896         FRAMELOADER_RELEASE_LOG_ERROR(ResourceLoading, &quot;retryAfterFailedCacheOnlyMainResourceLoad: Retrying load after failed cache-only main resource load failed because there is no provisional history item.&quot;);</span>
3897     }
3898 }
3899 
3900 ResourceError FrameLoader::cancelledError(const ResourceRequest&amp; request) const
3901 {
3902     ResourceError error = m_client.cancelledError(request);
3903     error.setType(ResourceError::Type::Cancellation);
3904     return error;
3905 }
3906 
3907 ResourceError FrameLoader::blockedByContentBlockerError(const ResourceRequest&amp; request) const
3908 {
3909     return m_client.blockedByContentBlockerError(request);
3910 }
3911 
3912 ResourceError FrameLoader::blockedError(const ResourceRequest&amp; request) const
3913 {
3914     ResourceError error = m_client.blockedError(request);
3915     error.setType(ResourceError::Type::Cancellation);
3916     return error;
</pre>
</td>
</tr>
</table>
<center><a href="FrameLoadRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
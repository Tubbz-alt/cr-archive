<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyClients.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006 Eric Seidel &lt;eric@webkit.org&gt;
  3  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  4  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;EmptyClients.h&quot;
 30 
 31 #include &quot;ApplicationCacheStorage.h&quot;
 32 #include &quot;BackForwardClient.h&quot;
 33 #include &quot;CacheStorageProvider.h&quot;
 34 #include &quot;ColorChooser.h&quot;
 35 #include &quot;ContextMenuClient.h&quot;
 36 #include &quot;CookieJar.h&quot;
 37 #include &quot;DOMPasteAccess.h&quot;
 38 #include &quot;DataListSuggestionPicker.h&quot;
 39 #include &quot;DatabaseProvider.h&quot;
 40 #include &quot;DiagnosticLoggingClient.h&quot;
 41 #include &quot;DocumentFragment.h&quot;
 42 #include &quot;DocumentLoader.h&quot;
 43 #include &quot;DragClient.h&quot;
 44 #include &quot;EditorClient.h&quot;
 45 #include &quot;EmptyFrameLoaderClient.h&quot;
 46 #include &quot;FileChooser.h&quot;
 47 #include &quot;FormState.h&quot;
 48 #include &quot;Frame.h&quot;
 49 #include &quot;FrameLoaderClient.h&quot;
 50 #include &quot;FrameNetworkingContext.h&quot;
 51 #include &quot;HTMLFormElement.h&quot;
 52 #include &quot;HistoryItem.h&quot;
 53 #include &quot;IDBConnectionToServer.h&quot;
 54 #include &quot;InspectorClient.h&quot;
 55 #include &quot;LibWebRTCProvider.h&quot;
 56 #include &quot;MediaRecorderPrivate.h&quot;
 57 #include &quot;MediaRecorderProvider.h&quot;
 58 #include &quot;NetworkStorageSession.h&quot;
 59 #include &quot;Page.h&quot;
 60 #include &quot;PageConfiguration.h&quot;
 61 #include &quot;PaymentCoordinatorClient.h&quot;
 62 #include &quot;PluginInfoProvider.h&quot;
 63 #include &quot;ProgressTrackerClient.h&quot;
 64 #include &quot;SecurityOriginData.h&quot;
 65 #include &quot;SocketProvider.h&quot;
 66 #include &quot;StorageArea.h&quot;
 67 #include &quot;StorageNamespace.h&quot;
 68 #include &quot;StorageNamespaceProvider.h&quot;
 69 #include &quot;StorageType.h&quot;
 70 #include &quot;TextCheckerClient.h&quot;
 71 #include &quot;ThreadableWebSocketChannel.h&quot;
 72 #include &quot;UserContentProvider.h&quot;
 73 #include &quot;VisitedLinkStore.h&quot;
 74 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 75 #include &lt;pal/SessionID.h&gt;
 76 #include &lt;wtf/NeverDestroyed.h&gt;
 77 
 78 #if ENABLE(CONTENT_EXTENSIONS)
 79 #include &quot;CompiledContentExtension.h&quot;
 80 #endif
 81 
 82 #if USE(QUICK_LOOK)
 83 #include &quot;LegacyPreviewLoaderClient.h&quot;
 84 #endif
 85 
 86 namespace WebCore {
 87 
 88 class UserMessageHandlerDescriptor;
 89 
 90 class EmptyBackForwardClient final : public BackForwardClient {
 91     void addItem(Ref&lt;HistoryItem&gt;&amp;&amp;) final { }
 92     void goToItem(HistoryItem&amp;) final { }
 93     RefPtr&lt;HistoryItem&gt; itemAtIndex(int) final { return nullptr; }
 94     unsigned backListCount() const final { return 0; }
 95     unsigned forwardListCount() const final { return 0; }
 96     void close() final { }
 97 };
 98 
 99 #if ENABLE(CONTEXT_MENUS)
100 
101 class EmptyContextMenuClient final : public ContextMenuClient {
102     void contextMenuDestroyed() final { }
103 
104     void downloadURL(const URL&amp;) final { }
105     void searchWithGoogle(const Frame*) final { }
106     void lookUpInDictionary(Frame*) final { }
107     bool isSpeaking() final { return false; }
108     void speak(const String&amp;) final { }
109     void stopSpeaking() final { }
110 
111 #if PLATFORM(COCOA)
112     void searchWithSpotlight() final { }
113 #endif
114 
115 #if PLATFORM(GTK)
116     void insertEmoji(Frame&amp;) final { }
117 #endif
118 
119 #if USE(ACCESSIBILITY_CONTEXT_MENUS)
120     void showContextMenu() final { }
121 #endif
122 };
123 
124 #endif // ENABLE(CONTEXT_MENUS)
125 
126 class EmptyDatabaseProvider final : public DatabaseProvider {
127 #if ENABLE(INDEXED_DATABASE)
128     struct EmptyIDBConnectionToServerDeletegate final : public IDBClient::IDBConnectionToServerDelegate {
129         IDBConnectionIdentifier identifier() const final { return { }; }
130         void deleteDatabase(const IDBRequestData&amp;) final { }
131         void openDatabase(const IDBRequestData&amp;) final { }
132         void abortTransaction(const IDBResourceIdentifier&amp;) final { }
133         void commitTransaction(const IDBResourceIdentifier&amp;) final { }
134         void didFinishHandlingVersionChangeTransaction(uint64_t, const IDBResourceIdentifier&amp;) final { }
135         void createObjectStore(const IDBRequestData&amp;, const IDBObjectStoreInfo&amp;) final { }
136         void deleteObjectStore(const IDBRequestData&amp;, const String&amp;) final { }
137         void renameObjectStore(const IDBRequestData&amp;, uint64_t, const String&amp;) final { }
138         void clearObjectStore(const IDBRequestData&amp;, uint64_t) final { }
139         void createIndex(const IDBRequestData&amp;, const IDBIndexInfo&amp;) final { }
140         void deleteIndex(const IDBRequestData&amp;, uint64_t, const String&amp;) final { }
141         void renameIndex(const IDBRequestData&amp;, uint64_t, uint64_t, const String&amp;) final { }
142         void putOrAdd(const IDBRequestData&amp;, const IDBKeyData&amp;, const IDBValue&amp;, const IndexedDB::ObjectStoreOverwriteMode) final { }
143         void getRecord(const IDBRequestData&amp;, const IDBGetRecordData&amp;) final { }
144         void getAllRecords(const IDBRequestData&amp;, const IDBGetAllRecordsData&amp;) final { }
145         void getCount(const IDBRequestData&amp;, const IDBKeyRangeData&amp;) final { }
146         void deleteRecord(const IDBRequestData&amp;, const IDBKeyRangeData&amp;) final { }
147         void openCursor(const IDBRequestData&amp;, const IDBCursorInfo&amp;) final { }
148         void iterateCursor(const IDBRequestData&amp;, const IDBIterateCursorData&amp;) final { }
149         void establishTransaction(uint64_t, const IDBTransactionInfo&amp;) final { }
150         void databaseConnectionPendingClose(uint64_t) final { }
151         void databaseConnectionClosed(uint64_t) final { }
152         void abortOpenAndUpgradeNeeded(uint64_t, const IDBResourceIdentifier&amp;) final { }
153         void didFireVersionChangeEvent(uint64_t, const IDBResourceIdentifier&amp;, const IndexedDB::ConnectionClosedOnBehalfOfServer) final { }
154         void openDBRequestCancelled(const IDBRequestData&amp;) final { }
155         void getAllDatabaseNames(const SecurityOriginData&amp;, const SecurityOriginData&amp;, uint64_t) final { }
156         ~EmptyIDBConnectionToServerDeletegate() { }
157     };
158 
159     IDBClient::IDBConnectionToServer&amp; idbConnectionToServerForSession(const PAL::SessionID&amp;) final
160     {
161         static NeverDestroyed&lt;EmptyIDBConnectionToServerDeletegate&gt; emptyDelegate;
162         static auto&amp; emptyConnection = IDBClient::IDBConnectionToServer::create(emptyDelegate.get()).leakRef();
163         return emptyConnection;
164     }
165 #endif
166 };
167 
168 class EmptyDiagnosticLoggingClient final : public DiagnosticLoggingClient {
169     void logDiagnosticMessage(const String&amp;, const String&amp;, ShouldSample) final { }
170     void logDiagnosticMessageWithResult(const String&amp;, const String&amp;, DiagnosticLoggingResultType, ShouldSample) final { }
171     void logDiagnosticMessageWithValue(const String&amp;, const String&amp;, double, unsigned, ShouldSample) final { }
172     void logDiagnosticMessageWithEnhancedPrivacy(const String&amp;, const String&amp;, ShouldSample) final { }
173     void logDiagnosticMessageWithValueDictionary(const String&amp;, const String&amp;, const ValueDictionary&amp;, ShouldSample) final { }
174 };
175 
176 #if ENABLE(DRAG_SUPPORT)
177 
178 class EmptyDragClient final : public DragClient {
179     void willPerformDragDestinationAction(DragDestinationAction, const DragData&amp;) final { }
180     void willPerformDragSourceAction(DragSourceAction, const IntPoint&amp;, DataTransfer&amp;) final { }
181     DragSourceAction dragSourceActionMaskForPoint(const IntPoint&amp;) final { return DragSourceActionNone; }
182     void startDrag(DragItem, DataTransfer&amp;, Frame&amp;) final { }
183 };
184 
185 #endif // ENABLE(DRAG_SUPPORT)
186 
187 class EmptyEditorClient final : public EditorClient {
188     WTF_MAKE_FAST_ALLOCATED;
189 
190 public:
191     EmptyEditorClient() = default;
192 
193 private:
194     bool shouldDeleteRange(Range*) final { return false; }
195     bool smartInsertDeleteEnabled() final { return false; }
196     bool isSelectTrailingWhitespaceEnabled() const final { return false; }
197     bool isContinuousSpellCheckingEnabled() final { return false; }
198     void toggleContinuousSpellChecking() final { }
199     bool isGrammarCheckingEnabled() final { return false; }
200     void toggleGrammarChecking() final { }
201     int spellCheckerDocumentTag() final { return -1; }
202 
203     bool shouldBeginEditing(Range*) final { return false; }
204     bool shouldEndEditing(Range*) final { return false; }
205     bool shouldInsertNode(Node*, Range*, EditorInsertAction) final { return false; }
206     bool shouldInsertText(const String&amp;, Range*, EditorInsertAction) final { return false; }
207     bool shouldChangeSelectedRange(Range*, Range*, EAffinity, bool) final { return false; }
208 
209     bool shouldApplyStyle(StyleProperties*, Range*) final { return false; }
210     void didApplyStyle() final { }
211     bool shouldMoveRangeAfterDelete(Range*, Range*) final { return false; }
212 
213     void didBeginEditing() final { }
214     void respondToChangedContents() final { }
215     void respondToChangedSelection(Frame*) final { }
216     void updateEditorStateAfterLayoutIfEditabilityChanged() final { }
217     void discardedComposition(Frame*) final { }
218     void canceledComposition() final { }
219     void didUpdateComposition() final { }
220     void didEndEditing() final { }
221     void didEndUserTriggeredSelectionChanges() final { }
222     void willWriteSelectionToPasteboard(Range*) final { }
223     void didWriteSelectionToPasteboard() final { }
224     void getClientPasteboardDataForRange(Range*, Vector&lt;String&gt;&amp;, Vector&lt;RefPtr&lt;SharedBuffer&gt;&gt;&amp;) final { }
225     void requestCandidatesForSelection(const VisibleSelection&amp;) final { }
226     void handleAcceptedCandidateWithSoftSpaces(TextCheckingResult) final { }
227 
228     void registerUndoStep(UndoStep&amp;) final;
229     void registerRedoStep(UndoStep&amp;) final;
230     void clearUndoRedoOperations() final { }
231 
232     DOMPasteAccessResponse requestDOMPasteAccess(const String&amp;) final { return DOMPasteAccessResponse::DeniedForGesture; }
233 
234     bool canCopyCut(Frame*, bool defaultValue) const final { return defaultValue; }
235     bool canPaste(Frame*, bool defaultValue) const final { return defaultValue; }
236     bool canUndo() const final { return false; }
237     bool canRedo() const final { return false; }
238 
239     void undo() final { }
240     void redo() final { }
241 
242     void handleKeyboardEvent(KeyboardEvent&amp;) final { }
243     void handleInputMethodKeydown(KeyboardEvent&amp;) final { }
244 
245     void textFieldDidBeginEditing(Element*) final { }
246     void textFieldDidEndEditing(Element*) final { }
247     void textDidChangeInTextField(Element*) final { }
248     bool doTextFieldCommandFromEvent(Element*, KeyboardEvent*) final { return false; }
249     void textWillBeDeletedInTextField(Element*) final { }
250     void textDidChangeInTextArea(Element*) final { }
251     void overflowScrollPositionChanged() final { }
252     void subFrameScrollPositionChanged() final { }
253 
254 #if PLATFORM(IOS_FAMILY)
255     void startDelayingAndCoalescingContentChangeNotifications() final { }
256     void stopDelayingAndCoalescingContentChangeNotifications() final { }
257     bool hasRichlyEditableSelection() final { return false; }
258     int getPasteboardItemsCount() final { return 0; }
259     RefPtr&lt;DocumentFragment&gt; documentFragmentFromDelegate(int) final { return nullptr; }
260     bool performsTwoStepPaste(DocumentFragment*) final { return false; }
261     void updateStringForFind(const String&amp;) final { }
262 #endif
263 
264     bool performTwoStepDrop(DocumentFragment&amp;, Range&amp;, bool) final { return false; }
265 
266 #if PLATFORM(COCOA)
267     void setInsertionPasteboard(const String&amp;) final { };
268 #endif
269 
270 #if USE(APPKIT)
271     void uppercaseWord() final { }
272     void lowercaseWord() final { }
273     void capitalizeWord() final { }
274 #endif
275 
276 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
277     void showSubstitutionsPanel(bool) final { }
278     bool substitutionsPanelIsShowing() final { return false; }
279     void toggleSmartInsertDelete() final { }
280     bool isAutomaticQuoteSubstitutionEnabled() final { return false; }
281     void toggleAutomaticQuoteSubstitution() final { }
282     bool isAutomaticLinkDetectionEnabled() final { return false; }
283     void toggleAutomaticLinkDetection() final { }
284     bool isAutomaticDashSubstitutionEnabled() final { return false; }
285     void toggleAutomaticDashSubstitution() final { }
286     bool isAutomaticTextReplacementEnabled() final { return false; }
287     void toggleAutomaticTextReplacement() final { }
288     bool isAutomaticSpellingCorrectionEnabled() final { return false; }
289     void toggleAutomaticSpellingCorrection() final { }
290 #endif
291 
292 #if PLATFORM(GTK)
293     bool shouldShowUnicodeMenu() final { return false; }
294 #endif
295 
296     TextCheckerClient* textChecker() final { return &amp;m_textCheckerClient; }
297 
298     void updateSpellingUIWithGrammarString(const String&amp;, const GrammarDetail&amp;) final { }
299     void updateSpellingUIWithMisspelledWord(const String&amp;) final { }
300     void showSpellingUI(bool) final { }
301     bool spellingUIIsShowing() final { return false; }
302 
303     void willSetInputMethodState() final { }
304     void setInputMethodState(Element*) final { }
305 
306     bool canShowFontPanel() const final { return false; }
307 
308     class EmptyTextCheckerClient final : public TextCheckerClient {
309         bool shouldEraseMarkersAfterChangeSelection(TextCheckingType) const final { return true; }
310         void ignoreWordInSpellDocument(const String&amp;) final { }
311         void learnWord(const String&amp;) final { }
312         void checkSpellingOfString(StringView, int*, int*) final { }
313         String getAutoCorrectSuggestionForMisspelledWord(const String&amp;) final { return { }; }
314         void checkGrammarOfString(StringView, Vector&lt;GrammarDetail&gt;&amp;, int*, int*) final { }
315 
316 #if USE(UNIFIED_TEXT_CHECKING)
317         Vector&lt;TextCheckingResult&gt; checkTextOfParagraph(StringView, OptionSet&lt;TextCheckingType&gt;, const VisibleSelection&amp;) final { return Vector&lt;TextCheckingResult&gt;(); }
318 #endif
319 
320         void getGuessesForWord(const String&amp;, const String&amp;, const VisibleSelection&amp;, Vector&lt;String&gt;&amp;) final { }
321         void requestCheckingOfString(TextCheckingRequest&amp;, const VisibleSelection&amp;) final;
322     };
323 
324     EmptyTextCheckerClient m_textCheckerClient;
325 };
326 
327 class EmptyFrameNetworkingContext final : public FrameNetworkingContext {
328 public:
329     static Ref&lt;EmptyFrameNetworkingContext&gt; create() { return adoptRef(*new EmptyFrameNetworkingContext); }
330 
331 private:
332     EmptyFrameNetworkingContext();
333 
334     bool shouldClearReferrerOnHTTPSToHTTPRedirect() const { return true; }
335     NetworkStorageSession* storageSession() const final { return nullptr; }
336 
337 #if PLATFORM(COCOA)
338     bool localFileContentSniffingEnabled() const { return false; }
339     SchedulePairHashSet* scheduledRunLoopPairs() const { return nullptr; }
340     RetainPtr&lt;CFDataRef&gt; sourceApplicationAuditData() const { return nullptr; };
341 #endif
342 
343 #if PLATFORM(COCOA) || PLATFORM(WIN)
344     ResourceError blockedError(const ResourceRequest&amp;) const final { return { }; }
345 #endif
346 };
347 
348 class EmptyInspectorClient final : public InspectorClient {
349     void inspectedPageDestroyed() final { }
350     Inspector::FrontendChannel* openLocalFrontend(InspectorController*) final { return nullptr; }
351     void bringFrontendToFront() final { }
352     void highlight() final { }
353     void hideHighlight() final { }
354 };
355 
356 #if ENABLE(APPLE_PAY)
357 
358 class EmptyPaymentCoordinatorClient final : public PaymentCoordinatorClient {
359     Optional&lt;String&gt; validatedPaymentNetwork(const String&amp;) final { return WTF::nullopt; }
360     bool canMakePayments() final { return false; }
361     void canMakePaymentsWithActiveCard(const String&amp;, const String&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler) final { callOnMainThread([completionHandler = WTFMove(completionHandler)]() mutable { completionHandler(false); }); }
362     void openPaymentSetup(const String&amp;, const String&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp; completionHandler) final { callOnMainThread([completionHandler = WTFMove(completionHandler)]() mutable { completionHandler(false); }); }
363     bool showPaymentUI(const URL&amp;, const Vector&lt;URL&gt;&amp;, const ApplePaySessionPaymentRequest&amp;) final { return false; }
364     void completeMerchantValidation(const PaymentMerchantSession&amp;) final { }
365     void completeShippingMethodSelection(Optional&lt;ShippingMethodUpdate&gt;&amp;&amp;) final { }
366     void completeShippingContactSelection(Optional&lt;ShippingContactUpdate&gt;&amp;&amp;) final { }
367     void completePaymentMethodSelection(Optional&lt;PaymentMethodUpdate&gt;&amp;&amp;) final { }
368     void completePaymentSession(Optional&lt;PaymentAuthorizationResult&gt;&amp;&amp;) final { }
369     void cancelPaymentSession() final { }
370     void abortPaymentSession() final { }
371     void paymentCoordinatorDestroyed() final { }
372     bool supportsUnrestrictedApplePay() const final { return false; }
373 };
374 
375 #endif
376 
377 class EmptyPluginInfoProvider final : public PluginInfoProvider {
378     void refreshPlugins() final { };
379     Vector&lt;PluginInfo&gt; pluginInfo(Page&amp;, Optional&lt;Vector&lt;SupportedPluginIdentifier&gt;&gt;&amp;) final { return { }; }
380     Vector&lt;PluginInfo&gt; webVisiblePluginInfo(Page&amp;, const URL&amp;) final { return { }; }
381 };
382 
383 class EmptyPopupMenu : public PopupMenu {
384 public:
385     EmptyPopupMenu() = default;
386 private:
387     void show(const IntRect&amp;, FrameView*, int) final { }
388     void hide() final { }
389     void updateFromElement() final { }
390     void disconnectClient() final { }
391 };
392 
393 class EmptyProgressTrackerClient final : public ProgressTrackerClient {
394     void willChangeEstimatedProgress() final { }
395     void didChangeEstimatedProgress() final { }
396     void progressStarted(Frame&amp;) final { }
397     void progressEstimateChanged(Frame&amp;) final { }
398     void progressFinished(Frame&amp;) final { }
399 };
400 
401 class EmptySearchPopupMenu : public SearchPopupMenu {
402 public:
403     EmptySearchPopupMenu()
404         : m_popup(adoptRef(*new EmptyPopupMenu))
405     {
406     }
407 
408 private:
409     PopupMenu* popupMenu() final { return m_popup.ptr(); }
410     void saveRecentSearches(const AtomString&amp;, const Vector&lt;RecentSearch&gt;&amp;) final { }
411     void loadRecentSearches(const AtomString&amp;, Vector&lt;RecentSearch&gt;&amp;) final { }
412     bool enabled() final { return false; }
413 
414     Ref&lt;EmptyPopupMenu&gt; m_popup;
415 };
416 
417 class EmptyStorageNamespaceProvider final : public StorageNamespaceProvider {
418     struct EmptyStorageArea : public StorageArea {
419         unsigned length() final { return 0; }
420         String key(unsigned) final { return { }; }
421         String item(const String&amp;) final { return { }; }
422         void setItem(Frame*, const String&amp;, const String&amp;, bool&amp;) final { }
423         void removeItem(Frame*, const String&amp;) final { }
424         void clear(Frame*) final { }
425         bool contains(const String&amp;) final { return false; }
426         StorageType storageType() const final { return StorageType::Local; }
427         size_t memoryBytesUsedByCache() final { return 0; }
428     };
429 
430     struct EmptyStorageNamespace final : public StorageNamespace {
431         explicit EmptyStorageNamespace(PAL::SessionID sessionID)
432             : m_sessionID(sessionID)
433         {
434         }
435     private:
436         Ref&lt;StorageArea&gt; storageArea(const SecurityOriginData&amp;) final { return adoptRef(*new EmptyStorageArea); }
437         Ref&lt;StorageNamespace&gt; copy(Page&amp;) final { return adoptRef(*new EmptyStorageNamespace { m_sessionID }); }
438         PAL::SessionID sessionID() const final { return m_sessionID; }
439         void setSessionIDForTesting(PAL::SessionID sessionID) final { m_sessionID = sessionID; };
440 
441         PAL::SessionID m_sessionID;
442     };
443 
444     Ref&lt;StorageNamespace&gt; createSessionStorageNamespace(Page&amp;, unsigned) final;
445     Ref&lt;StorageNamespace&gt; createLocalStorageNamespace(unsigned, PAL::SessionID) final;
446     Ref&lt;StorageNamespace&gt; createTransientLocalStorageNamespace(SecurityOrigin&amp;, unsigned, PAL::SessionID) final;
447 
448 };
449 
450 class EmptyUserContentProvider final : public UserContentProvider {
451     void forEachUserScript(Function&lt;void(DOMWrapperWorld&amp;, const UserScript&amp;)&gt;&amp;&amp;) const final { }
452     void forEachUserStyleSheet(Function&lt;void(const UserStyleSheet&amp;)&gt;&amp;&amp;) const final { }
453 #if ENABLE(USER_MESSAGE_HANDLERS)
454     void forEachUserMessageHandler(Function&lt;void(const UserMessageHandlerDescriptor&amp;)&gt;&amp;&amp;) const final { }
455 #endif
456 #if ENABLE(CONTENT_EXTENSIONS)
457     ContentExtensions::ContentExtensionsBackend&amp; userContentExtensionBackend() final { static NeverDestroyed&lt;ContentExtensions::ContentExtensionsBackend&gt; backend; return backend.get(); };
458 #endif
459 };
460 
461 class EmptyVisitedLinkStore final : public VisitedLinkStore {
462     bool isLinkVisited(Page&amp;, SharedStringHash, const URL&amp;, const AtomString&amp;) final { return false; }
463     void addVisitedLink(Page&amp;, SharedStringHash) final { }
464 };
465 
466 RefPtr&lt;PopupMenu&gt; EmptyChromeClient::createPopupMenu(PopupMenuClient&amp;) const
467 {
468     return adoptRef(*new EmptyPopupMenu);
469 }
470 
471 RefPtr&lt;SearchPopupMenu&gt; EmptyChromeClient::createSearchPopupMenu(PopupMenuClient&amp;) const
472 {
473     return adoptRef(*new EmptySearchPopupMenu);
474 }
475 
476 #if ENABLE(INPUT_TYPE_COLOR)
477 
478 std::unique_ptr&lt;ColorChooser&gt; EmptyChromeClient::createColorChooser(ColorChooserClient&amp;, const Color&amp;)
479 {
480     return nullptr;
481 }
482 
483 #endif
484 
485 #if ENABLE(DATALIST_ELEMENT)
486 
487 std::unique_ptr&lt;DataListSuggestionPicker&gt; EmptyChromeClient::createDataListSuggestionPicker(DataListSuggestionsClient&amp;)
488 {
489     return nullptr;
490 }
491 
492 #endif
493 
494 void EmptyChromeClient::runOpenPanel(Frame&amp;, FileChooser&amp;)
495 {
496 }
497 
498 void EmptyChromeClient::showShareSheet(ShareDataWithParsedURL&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;)
499 {
500 }
501 
502 void EmptyFrameLoaderClient::dispatchDecidePolicyForNewWindowAction(const NavigationAction&amp;, const ResourceRequest&amp;, FormState*, const String&amp;, PolicyCheckIdentifier, FramePolicyFunction&amp;&amp;)
503 {
504 }
505 
506 void EmptyFrameLoaderClient::dispatchDecidePolicyForNavigationAction(const NavigationAction&amp;, const ResourceRequest&amp;, const ResourceResponse&amp;, FormState*, PolicyDecisionMode, PolicyCheckIdentifier, FramePolicyFunction&amp;&amp;)
507 {
508 }
509 
510 void EmptyFrameLoaderClient::dispatchWillSendSubmitEvent(Ref&lt;FormState&gt;&amp;&amp;)
511 {
512 }
513 
514 void EmptyFrameLoaderClient::dispatchWillSubmitForm(FormState&amp;, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
515 {
516     completionHandler();
517 }
518 
519 Ref&lt;DocumentLoader&gt; EmptyFrameLoaderClient::createDocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
520 {
521     return DocumentLoader::create(request, substituteData);
522 }
523 
524 RefPtr&lt;Frame&gt; EmptyFrameLoaderClient::createFrame(const URL&amp;, const String&amp;, HTMLFrameOwnerElement&amp;, const String&amp;)
525 {
526     return nullptr;
527 }
528 
529 RefPtr&lt;Widget&gt; EmptyFrameLoaderClient::createPlugin(const IntSize&amp;, HTMLPlugInElement&amp;, const URL&amp;, const Vector&lt;String&gt;&amp;, const Vector&lt;String&gt;&amp;, const String&amp;, bool)
530 {
531     return nullptr;
532 }
533 
534 RefPtr&lt;Widget&gt; EmptyFrameLoaderClient::createJavaAppletWidget(const IntSize&amp;, HTMLAppletElement&amp;, const URL&amp;, const Vector&lt;String&gt;&amp;, const Vector&lt;String&gt;&amp;)
535 {
536     return nullptr;
537 }
538 
539 inline EmptyFrameNetworkingContext::EmptyFrameNetworkingContext()
540     : FrameNetworkingContext { nullptr }
541 {
542 }
543 
544 Ref&lt;FrameNetworkingContext&gt; EmptyFrameLoaderClient::createNetworkingContext()
545 {
546     return EmptyFrameNetworkingContext::create();
547 }
548 
549 void EmptyEditorClient::EmptyTextCheckerClient::requestCheckingOfString(TextCheckingRequest&amp;, const VisibleSelection&amp;)
550 {
551 }
552 
553 void EmptyEditorClient::registerUndoStep(UndoStep&amp;)
554 {
555 }
556 
557 void EmptyEditorClient::registerRedoStep(UndoStep&amp;)
558 {
559 }
560 
561 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createSessionStorageNamespace(Page&amp; page, unsigned)
562 {
563     return adoptRef(*new EmptyStorageNamespace { page.sessionID() });
564 }
565 
566 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createLocalStorageNamespace(unsigned, PAL::SessionID sessionID)
567 {
568     return adoptRef(*new EmptyStorageNamespace { sessionID });
569 }
570 
571 Ref&lt;StorageNamespace&gt; EmptyStorageNamespaceProvider::createTransientLocalStorageNamespace(SecurityOrigin&amp;, unsigned, PAL::SessionID sessionID)
572 {
573     return adoptRef(*new EmptyStorageNamespace { sessionID });
574 }
575 
576 class EmptyStorageSessionProvider final : public StorageSessionProvider {
577     NetworkStorageSession* storageSession() const final { return nullptr; }
578 };
579 
580 class EmptyMediaRecorderProvider final : public MediaRecorderProvider {
581 public:
582     EmptyMediaRecorderProvider() = default;
583 private:
584 #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(COCOA)
585     std::unique_ptr&lt;MediaRecorderPrivate&gt; createMediaRecorderPrivate(const MediaStreamPrivate&amp;) final { return nullptr; }
586 #endif
587 };
588 
589 PageConfiguration pageConfigurationWithEmptyClients(PAL::SessionID sessionID)
590 {
591     PageConfiguration pageConfiguration {
592         sessionID,
593         makeUniqueRef&lt;EmptyEditorClient&gt;(),
594         SocketProvider::create(),
595         LibWebRTCProvider::create(),
596         CacheStorageProvider::create(),
597         adoptRef(*new EmptyBackForwardClient),
598         CookieJar::create(adoptRef(*new EmptyStorageSessionProvider)),
599         makeUniqueRef&lt;EmptyProgressTrackerClient&gt;(),
600         makeUniqueRef&lt;EmptyMediaRecorderProvider&gt;()
601     };
602 
603     static NeverDestroyed&lt;EmptyChromeClient&gt; dummyChromeClient;
604     pageConfiguration.chromeClient = &amp;dummyChromeClient.get();
605 
606 #if ENABLE(APPLE_PAY)
607     static NeverDestroyed&lt;EmptyPaymentCoordinatorClient&gt; dummyPaymentCoordinatorClient;
608     pageConfiguration.paymentCoordinatorClient = &amp;dummyPaymentCoordinatorClient.get();
609 #endif
610 
611 #if ENABLE(CONTEXT_MENUS)
612     static NeverDestroyed&lt;EmptyContextMenuClient&gt; dummyContextMenuClient;
613     pageConfiguration.contextMenuClient = &amp;dummyContextMenuClient.get();
614 #endif
615 
616 #if ENABLE(DRAG_SUPPORT)
617     pageConfiguration.dragClient = makeUnique&lt;EmptyDragClient&gt;();
618 #endif
619 
620     static NeverDestroyed&lt;EmptyInspectorClient&gt; dummyInspectorClient;
621     pageConfiguration.inspectorClient = &amp;dummyInspectorClient.get();
622 
623     static NeverDestroyed&lt;EmptyFrameLoaderClient&gt; dummyFrameLoaderClient;
624     pageConfiguration.loaderClientForMainFrame = &amp;dummyFrameLoaderClient.get();
625 
626     pageConfiguration.diagnosticLoggingClient = makeUnique&lt;EmptyDiagnosticLoggingClient&gt;();
627 
628     pageConfiguration.applicationCacheStorage = ApplicationCacheStorage::create({ }, { });
629     pageConfiguration.databaseProvider = adoptRef(*new EmptyDatabaseProvider);
630     pageConfiguration.pluginInfoProvider = adoptRef(*new EmptyPluginInfoProvider);
631     pageConfiguration.storageNamespaceProvider = adoptRef(*new EmptyStorageNamespaceProvider);
632     pageConfiguration.userContentProvider = adoptRef(*new EmptyUserContentProvider);
633     pageConfiguration.visitedLinkStore = adoptRef(*new EmptyVisitedLinkStore);
634 
635     return pageConfiguration;
636 }
637 
638 DiagnosticLoggingClient&amp; emptyDiagnosticLoggingClient()
639 {
640     static NeverDestroyed&lt;EmptyDiagnosticLoggingClient&gt; client;
641     return client;
642 }
643 
644 }
    </pre>
  </body>
</html>
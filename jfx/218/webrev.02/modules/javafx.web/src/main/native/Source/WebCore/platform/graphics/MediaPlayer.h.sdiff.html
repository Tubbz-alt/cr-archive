<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaPlayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayerEnums.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;AudioTrackPrivate.h&quot;
 31 #include &quot;ContentType.h&quot;
<span class="line-modified"> 32 #include &quot;GraphicsTypes3D.h&quot;</span>
<span class="line-removed"> 33 #include &quot;InbandTextTrackPrivate.h&quot;</span>
 34 #include &quot;LayoutRect.h&quot;
 35 #include &quot;LegacyCDMSession.h&quot;
 36 #include &quot;MediaPlayerEnums.h&quot;
 37 #include &quot;NativeImage.h&quot;
 38 #include &quot;PlatformLayer.h&quot;
 39 #include &quot;PlatformMediaResourceLoader.h&quot;
 40 #include &quot;PlatformMediaSession.h&quot;
 41 #include &quot;SecurityOriginHash.h&quot;
 42 #include &quot;Timer.h&quot;
 43 #include &lt;wtf/URL.h&gt;
 44 #include &quot;VideoTrackPrivate.h&quot;
 45 #include &lt;JavaScriptCore/Uint8Array.h&gt;
 46 #include &lt;wtf/Function.h&gt;
 47 #include &lt;wtf/HashSet.h&gt;
 48 #include &lt;wtf/Logger.h&gt;
 49 #include &lt;wtf/MediaTime.h&gt;
 50 #include &lt;wtf/WallTime.h&gt;
 51 #include &lt;wtf/text/StringHash.h&gt;
 52 
 53 #if ENABLE(AVF_CAPTIONS)
 54 #include &quot;PlatformTextTrack.h&quot;
 55 #endif
 56 
 57 OBJC_CLASS AVPlayer;
 58 OBJC_CLASS NSArray;
 59 
 60 namespace WebCore {
 61 
 62 class AudioSourceProvider;
 63 class CDMInstance;
 64 class CachedResourceLoader;
<span class="line-modified"> 65 class GraphicsContext3D;</span>
 66 class GraphicsContext;

 67 class LegacyCDMSessionClient;
 68 class MediaPlaybackTarget;
 69 class MediaPlayer;

 70 class MediaPlayerPrivateInterface;
 71 class MediaPlayerRequestInstallMissingPluginsCallback;
 72 class MediaSourcePrivateClient;
 73 class MediaStreamPrivate;
 74 class PlatformTimeRanges;
 75 class TextTrackRepresentation;
 76 
 77 struct Cookie;
 78 struct GraphicsDeviceAdapter;
<span class="line-removed"> 79 struct MediaPlayerFactory;</span>
 80 
 81 struct MediaEngineSupportParameters {
 82     ContentType type;
 83     URL url;
 84     bool isMediaSource { false };
 85     bool isMediaStream { false };
 86     Vector&lt;ContentType&gt; contentTypesRequiringHardwareSupport;









































 87 };
 88 
 89 struct VideoPlaybackQualityMetrics {
 90     uint32_t totalVideoFrames { 0 };
 91     uint32_t droppedVideoFrames { 0 };
 92     uint32_t corruptedVideoFrames { 0 };
 93     double totalFrameDelay { 0 };
 94     uint32_t displayCompositedVideoFrames { 0 };
 95 };
 96 
 97 class MediaPlayerClient {
 98 public:
 99     virtual ~MediaPlayerClient() = default;
100 
101     // the network state has changed
<span class="line-modified">102     virtual void mediaPlayerNetworkStateChanged(MediaPlayer*) { }</span>
103 
104     // the ready state has changed
<span class="line-modified">105     virtual void mediaPlayerReadyStateChanged(MediaPlayer*) { }</span>
106 
107     // the volume state has changed
<span class="line-modified">108     virtual void mediaPlayerVolumeChanged(MediaPlayer*) { }</span>
109 
110     // the mute state has changed
<span class="line-modified">111     virtual void mediaPlayerMuteChanged(MediaPlayer*) { }</span>
112 
113     // time has jumped, eg. not as a result of normal playback
<span class="line-modified">114     virtual void mediaPlayerTimeChanged(MediaPlayer*) { }</span>
115 
116     // the media file duration has changed, or is now known
<span class="line-modified">117     virtual void mediaPlayerDurationChanged(MediaPlayer*) { }</span>
118 
119     // the playback rate has changed
<span class="line-modified">120     virtual void mediaPlayerRateChanged(MediaPlayer*) { }</span>
121 
122     // the play/pause status changed
<span class="line-modified">123     virtual void mediaPlayerPlaybackStateChanged(MediaPlayer*) { }</span>
<span class="line-removed">124 </span>
<span class="line-removed">125     // The MediaPlayer has found potentially problematic media content.</span>
<span class="line-removed">126     // This is used internally to trigger swapping from a &lt;video&gt;</span>
<span class="line-removed">127     // element to an &lt;embed&gt; in standalone documents</span>
<span class="line-removed">128     virtual void mediaPlayerSawUnsupportedTracks(MediaPlayer*) { }</span>
129 
130     // The MediaPlayer could not discover an engine which supports the requested resource.
<span class="line-modified">131     virtual void mediaPlayerResourceNotSupported(MediaPlayer*) { }</span>
132 
133 // Presentation-related methods
134     // a new frame of video is available
<span class="line-modified">135     virtual void mediaPlayerRepaint(MediaPlayer*) { }</span>
136 
137     // the movie size has changed
<span class="line-modified">138     virtual void mediaPlayerSizeChanged(MediaPlayer*) { }</span>
139 
<span class="line-modified">140     virtual void mediaPlayerEngineUpdated(MediaPlayer*) { }</span>
141 
142     // The first frame of video is available to render. A media engine need only make this callback if the
143     // first frame is not available immediately when prepareForRendering is called.
<span class="line-modified">144     virtual void mediaPlayerFirstVideoFrameAvailable(MediaPlayer*) { }</span>
145 
146     // A characteristic of the media file, eg. video, audio, closed captions, etc, has changed.
<span class="line-modified">147     virtual void mediaPlayerCharacteristicChanged(MediaPlayer*) { }</span>
148 
149     // whether the rendering system can accelerate the display of this MediaPlayer.
<span class="line-modified">150     virtual bool mediaPlayerRenderingCanBeAccelerated(MediaPlayer*) { return false; }</span>
151 
152     // called when the media player&#39;s rendering mode changed, which indicates a change in the
153     // availability of the platformLayer().
<span class="line-modified">154     virtual void mediaPlayerRenderingModeChanged(MediaPlayer*) { }</span>
155 
156     // whether accelerated compositing is enabled for video rendering
157     virtual bool mediaPlayerAcceleratedCompositingEnabled() { return false; }
158 
<span class="line-modified">159     virtual void mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*) { }</span>
160 
161 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified">162     virtual GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const { return nullptr; }</span>
163 #endif
164 
165 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
166     virtual RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp;) const { return nullptr; }
<span class="line-modified">167     virtual bool mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array*) { return false; }</span>
168     virtual String mediaPlayerMediaKeysStorageDirectory() const { return emptyString(); }
169 #endif
170 
171 #if ENABLE(ENCRYPTED_MEDIA)
172     virtual void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) { }
173     virtual void mediaPlayerWaitingForKeyChanged() { }
174 #endif
175 
176 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">177     virtual void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*) { };</span>
178 #endif
179 
180     virtual String mediaPlayerReferrer() const { return String(); }
181     virtual String mediaPlayerUserAgent() const { return String(); }
182     virtual void mediaPlayerEnterFullscreen() { }
183     virtual void mediaPlayerExitFullscreen() { }
184     virtual bool mediaPlayerIsFullscreen() const { return false; }
185     virtual bool mediaPlayerIsFullscreenPermitted() const { return false; }
186     virtual bool mediaPlayerIsVideo() const { return false; }
187     virtual LayoutRect mediaPlayerContentBoxRect() const { return LayoutRect(); }
188     virtual float mediaPlayerContentsScale() const { return 1; }
<span class="line-removed">189     virtual void mediaPlayerSetSize(const IntSize&amp;) { }</span>
190     virtual void mediaPlayerPause() { }
191     virtual void mediaPlayerPlay() { }
192     virtual bool mediaPlayerPlatformVolumeConfigurationRequired() const { return false; }
<span class="line-removed">193     virtual bool mediaPlayerIsPaused() const { return true; }</span>
194     virtual bool mediaPlayerIsLooping() const { return false; }
195     virtual CachedResourceLoader* mediaPlayerCachedResourceLoader() { return nullptr; }
196     virtual RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() { return nullptr; }
197     virtual bool doesHaveAttribute(const AtomString&amp;, AtomString* = nullptr) const { return false; }
198     virtual bool mediaPlayerShouldUsePersistentCache() const { return true; }
199     virtual const String&amp; mediaPlayerMediaCacheDirectory() const { return emptyString(); }
200 
201 #if ENABLE(VIDEO_TRACK)
202     virtual void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) { }
203     virtual void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) { }
204     virtual void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) { }
205     virtual void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) { }
206     virtual void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) { }
207     virtual void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) { }
208 
209     virtual void textTrackRepresentationBoundsChanged(const IntRect&amp;) { }
210 #endif
211 
212 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
213     virtual Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources() { return { }; }
214 #endif
215 
216 #if PLATFORM(IOS_FAMILY)
217     virtual String mediaPlayerNetworkInterfaceName() const { return String(); }
218     virtual bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const { return false; }
219 #endif
220 
<span class="line-removed">221     virtual void mediaPlayerHandlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType) { }</span>
<span class="line-removed">222 </span>
223     virtual String mediaPlayerSourceApplicationIdentifier() const { return emptyString(); }
224 
<span class="line-removed">225     virtual bool mediaPlayerIsInMediaDocument() const { return false; }</span>
226     virtual void mediaPlayerEngineFailedToLoad() const { }
227 
228     virtual double mediaPlayerRequestedPlaybackRate() const { return 0; }
229     virtual MediaPlayerEnums::VideoFullscreenMode mediaPlayerFullscreenMode() const { return MediaPlayerEnums::VideoFullscreenModeNone; }
230     virtual bool mediaPlayerIsVideoFullscreenStandby() const { return false; }
231     virtual Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const { return Vector&lt;String&gt;(); }
232 
233 #if USE(GSTREAMER)
234     virtual void requestInstallMissingPlugins(const String&amp;, const String&amp;, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { };
235 #endif
236 
237     virtual bool mediaPlayerShouldDisableSleep() const { return false; }
<span class="line-modified">238     virtual const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const;</span>
239     virtual bool mediaPlayerShouldCheckHardwareSupport() const { return false; }
240 



241 #if !RELEASE_LOG_DISABLED
242     virtual const void* mediaPlayerLogIdentifier() { return nullptr; }
243     virtual const Logger&amp; mediaPlayerLogger() = 0;
244 #endif
245 };
246 
<span class="line-modified">247 class MediaPlayer : public MediaPlayerEnums, public RefCounted&lt;MediaPlayer&gt; {</span>
248     WTF_MAKE_NONCOPYABLE(MediaPlayer); WTF_MAKE_FAST_ALLOCATED;
249 public:
250     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;);

251     virtual ~MediaPlayer();
252 
253     void invalidate();
254 
255     // Media engine support.
256     using MediaPlayerEnums::SupportsType;

257     static SupportsType supportsType(const MediaEngineSupportParameters&amp;);
258     static void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;);
259     static bool isAvailable();
260     static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp; path);
261     static void clearMediaCache(const String&amp; path, WallTime modifiedSince);
262     static void clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
263     static bool supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType);
264 
265     bool supportsPictureInPicture() const;
266     bool supportsFullscreen() const;
267     bool supportsScanning() const;
268     bool canSaveMediaData() const;
269     bool requiresImmediateCompositing() const;
270     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const;
271     PlatformLayer* platformLayer() const;
272 
273 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
274     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
275     void setVideoFullscreenFrame(FloatRect);
276     void updateVideoFullscreenInlineImage();
277     using MediaPlayerEnums::VideoGravity;
278     void setVideoFullscreenGravity(VideoGravity);
279     void setVideoFullscreenMode(VideoFullscreenMode);
280     VideoFullscreenMode fullscreenMode() const;
281     void videoFullscreenStandbyChanged();
282     bool isVideoFullscreenStandby() const;
283 #endif
284 
285 #if PLATFORM(IOS_FAMILY)
286     NSArray *timedMetadata() const;
287     String accessLog() const;
288     String errorLog() const;
289 #endif
290 
291     FloatSize naturalSize();
292     bool hasVideo() const;
293     bool hasAudio() const;
294 
<span class="line-removed">295     bool inMediaDocument() const;</span>
<span class="line-removed">296 </span>
297     IntSize size() const { return m_size; }
298     void setSize(const IntSize&amp; size);
299 
300     bool load(const URL&amp;, const ContentType&amp;, const String&amp; keySystem);
301 #if ENABLE(MEDIA_SOURCE)
302     bool load(const URL&amp;, const ContentType&amp;, MediaSourcePrivateClient*);
303 #endif
304 #if ENABLE(MEDIA_STREAM)
305     bool load(MediaStreamPrivate&amp;);
306 #endif
307     void cancelLoad();
308 
309     bool visible() const;
310     void setVisible(bool);
311 
312     void prepareToPlay();
313     void play();
314     void pause();
315 
316     using MediaPlayerEnums::BufferingPolicy;
</pre>
<hr />
<pre>
338     static double invalidTime() { return -1.0;}
339     MediaTime duration() const;
340     MediaTime currentTime() const;
341     void seek(const MediaTime&amp;);
342     void seekWithTolerance(const MediaTime&amp;, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance);
343 
344     MediaTime startTime() const;
345     MediaTime initialTime() const;
346 
347     MediaTime getStartDate() const;
348 
349     double rate() const;
350     void setRate(double);
351     double requestedRate() const;
352 
353     bool preservesPitch() const;
354     void setPreservesPitch(bool);
355 
356     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered();
357     std::unique_ptr&lt;PlatformTimeRanges&gt; seekable();


358     MediaTime minTimeSeekable();
359     MediaTime maxTimeSeekable();
360 
361     double seekableTimeRangesLastModifiedTime();
362     double liveUpdateInterval();
363 
364     bool didLoadingProgress();
365 
366     double volume() const;
367     void setVolume(double);
368     bool platformVolumeConfigurationRequired() const { return client().mediaPlayerPlatformVolumeConfigurationRequired(); }
369 
370     bool muted() const;
371     void setMuted(bool);
372 
373     bool hasClosedCaptions() const;
374     void setClosedCaptionsVisible(bool closedCaptionsVisible);
375 
376     void paint(GraphicsContext&amp;, const FloatRect&amp;);
377     void paintCurrentFrameInContext(GraphicsContext&amp;, const FloatRect&amp;);
378 
379     // copyVideoTextureToPlatformTexture() is used to do the GPU-GPU textures copy without a readback to system memory.
380     // The first five parameters denote the corresponding GraphicsContext, destination texture, requested level, requested type and the required internalFormat for destination texture.
381     // The last two parameters premultiplyAlpha and flipY denote whether addtional premultiplyAlpha and flip operation are required during the copy.
382     // It returns true on success and false on failure.
383 
384     // In the GPU-GPU textures copy, the source texture(Video texture) should have valid target, internalFormat and size, etc.
385     // The destination texture may need to be resized to to the dimensions of the source texture or re-defined to the required internalFormat.
386     // The current restrictions require that format shoud be RGB or RGBA, type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
387 
<span class="line-modified">388     bool copyVideoTextureToPlatformTexture(GraphicsContext3D*, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY);</span>
389 
390     NativeImagePtr nativeImageForCurrentTime();
391 
392     using MediaPlayerEnums::NetworkState;
393     NetworkState networkState();
394 
395     using MediaPlayerEnums::ReadyState;
396     ReadyState readyState();
397 
398     using MediaPlayerEnums::MovieLoadType;
399     MovieLoadType movieLoadType() const;
400 
401     using MediaPlayerEnums::Preload;
402     Preload preload() const;
403     void setPreload(Preload);
404 
405     void networkStateChanged();
406     void readyStateChanged();
407     void volumeChanged(double);
408     void muteChanged(bool);
409     void timeChanged();
410     void sizeChanged();
411     void rateChanged();
412     void playbackStateChanged();
413     void durationChanged();
414     void firstVideoFrameAvailable();
415     void characteristicChanged();
416 
417     void repaint();
418 
<span class="line-removed">419     MediaPlayerClient&amp; client() const { return *m_client; }</span>
<span class="line-removed">420 </span>
421     bool hasAvailableVideoFrame() const;
422     void prepareForRendering();
423 
<span class="line-removed">424     bool canLoadPoster() const;</span>
<span class="line-removed">425     void setPoster(const String&amp;);</span>
<span class="line-removed">426 </span>
427 #if USE(NATIVE_FULLSCREEN_VIDEO)
428     void enterFullscreen();
429     void exitFullscreen();
430 #endif
431 
432 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
433     enum WirelessPlaybackTargetType { TargetTypeNone, TargetTypeAirPlay, TargetTypeTVOut };
434     WirelessPlaybackTargetType wirelessPlaybackTargetType() const;
435 
436     String wirelessPlaybackTargetName() const;
437 
438     bool wirelessVideoPlaybackDisabled() const;
439     void setWirelessVideoPlaybackDisabled(bool);
440 
<span class="line-modified">441     void currentPlaybackTargetIsWirelessChanged();</span>
442     void playbackTargetAvailabilityChanged();
443 
444     bool isCurrentPlaybackTargetWireless() const;
445     bool canPlayToWirelessPlaybackTarget() const;
446     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
447 
448     void setShouldPlayToPlaybackTarget(bool);
449 #endif
450 
451     double minFastReverseRate() const;
452     double maxFastForwardRate() const;
453 
454 #if USE(NATIVE_FULLSCREEN_VIDEO)
455     bool canEnterFullscreen() const;
456 #endif
457 
458     // whether accelerated rendering is supported by the media engine for the current media.
459     bool supportsAcceleratedRendering() const;
460     // called when the rendering system flips the into or out of accelerated rendering mode.
461     void acceleratedRenderingStateChanged();
</pre>
<hr />
<pre>
517 
518     bool requiresTextTrackRepresentation() const;
519     void setTextTrackRepresentation(TextTrackRepresentation*);
520     void syncTextTrackBounds();
521     void tracksChanged();
522 #endif
523 
524 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
525     void notifyTrackModeChanged();
526     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources();
527 #endif
528 
529 #if PLATFORM(IOS_FAMILY)
530     String mediaPlayerNetworkInterfaceName() const;
531     bool getRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const;
532 #endif
533 
534     static void resetMediaEngines();
535 
536 #if USE(GSTREAMER)
<span class="line-modified">537     WEBCORE_EXPORT void simulateAudioInterruption();</span>
538 #endif
539 
<span class="line-modified">540     WEBCORE_EXPORT void beginSimulatedHDCPError();</span>
<span class="line-modified">541     WEBCORE_EXPORT void endSimulatedHDCPError();</span>
542 
543     String languageOfPrimaryAudioTrack() const;
544 
545     size_t extraMemoryCost() const;
546 
547     unsigned long long fileSize() const;
548 
549     Optional&lt;VideoPlaybackQualityMetrics&gt; videoPlaybackQualityMetrics();
550 
<span class="line-removed">551     void handlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType);</span>
552     String sourceApplicationIdentifier() const;
553     Vector&lt;String&gt; preferredAudioCharacteristics() const;
554 
555     bool ended() const;
556 
557     void setShouldDisableSleep(bool);
558     bool shouldDisableSleep() const;
559 
560     String contentMIMEType() const { return m_contentType.containerType(); }
561     String contentTypeCodecs() const { return m_contentType.parameter(ContentType::codecsParameter()); }
562     bool contentMIMETypeWasInferredFromExtension() const { return m_contentMIMETypeWasInferredFromExtension; }
563 
564     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const;
565     bool shouldCheckHardwareSupport() const;
566 
567 #if !RELEASE_LOG_DISABLED
568     const Logger&amp; mediaPlayerLogger();
569     const void* mediaPlayerLogIdentifier() { return client().mediaPlayerLogIdentifier(); }
570 #endif
571 
572     void applicationWillResignActive();
573     void applicationDidBecomeActive();
574 
575 #if USE(AVFOUNDATION)
<span class="line-modified">576     WEBCORE_EXPORT AVPlayer *objCAVFoundationAVPlayer() const;</span>
577 #endif
578 
579     bool performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp;, MediaTime);
580 
581     bool shouldIgnoreIntrinsicSize();
582 



















583 private:
584     MediaPlayer(MediaPlayerClient&amp;);

585 
<span class="line-modified">586     const MediaPlayerFactory* nextBestMediaEngine(const MediaPlayerFactory*) const;</span>


587     void loadWithNextMediaEngine(const MediaPlayerFactory*);

588     void reloadTimerFired();
589 
590     MediaPlayerClient* m_client;
591     Timer m_reloadTimer;
592     std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; m_private;
593     const MediaPlayerFactory* m_currentMediaEngine { nullptr };
594     URL m_url;
595     ContentType m_contentType;
596     String m_keySystem;

597     IntSize m_size;
<span class="line-modified">598     Preload m_preload { Auto };</span>
599     double m_volume { 1 };
600     bool m_visible { false };
601     bool m_muted { false };
602     bool m_preservesPitch { true };
603     bool m_privateBrowsing { false };
604     bool m_shouldPrepareToRender { false };
605     bool m_contentMIMETypeWasInferredFromExtension { false };
606     bool m_initializingMediaEngine { false };
607 
608 #if ENABLE(MEDIA_SOURCE)
609     RefPtr&lt;MediaSourcePrivateClient&gt; m_mediaSource;
610 #endif
611 #if ENABLE(MEDIA_STREAM)
612     RefPtr&lt;MediaStreamPrivate&gt; m_mediaStream;
613 #endif
614 };
615 
<span class="line-modified">616 using CreateMediaEnginePlayer = WTF::Function&lt;std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; (MediaPlayer*)&gt;;</span>
<span class="line-modified">617 typedef void (*MediaEngineSupportedTypes)(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types);</span>
<span class="line-modified">618 typedef MediaPlayer::SupportsType (*MediaEngineSupportsType)(const MediaEngineSupportParameters&amp; parameters);</span>
<span class="line-modified">619 typedef HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; (*MediaEngineOriginsInMediaCache)(const String&amp; path);</span>
<span class="line-modified">620 typedef void (*MediaEngineClearMediaCache)(const String&amp; path, WallTime modifiedSince);</span>
<span class="line-modified">621 typedef void (*MediaEngineClearMediaCacheForOrigins)(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);</span>
<span class="line-modified">622 typedef bool (*MediaEngineSupportsKeySystem)(const String&amp; keySystem, const String&amp; mimeType);</span>









623 
<span class="line-modified">624 typedef void (*MediaEngineRegistrar)(CreateMediaEnginePlayer&amp;&amp;, MediaEngineSupportedTypes, MediaEngineSupportsType,</span>
<span class="line-modified">625     MediaEngineOriginsInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForOrigins, MediaEngineSupportsKeySystem);</span>
<span class="line-removed">626 typedef void (*MediaEngineRegister)(MediaEngineRegistrar);</span>
627 
628 class MediaPlayerFactorySupport {
629 public:
630     WEBCORE_EXPORT static void callRegisterMediaEngine(MediaEngineRegister);
631 };
632 







633 } // namespace WebCore
634 
635 #endif // ENABLE(VIDEO)
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;AudioTrackPrivate.h&quot;
 31 #include &quot;ContentType.h&quot;
<span class="line-modified"> 32 #include &quot;GraphicsTypesGL.h&quot;</span>

 33 #include &quot;LayoutRect.h&quot;
 34 #include &quot;LegacyCDMSession.h&quot;
 35 #include &quot;MediaPlayerEnums.h&quot;
 36 #include &quot;NativeImage.h&quot;
 37 #include &quot;PlatformLayer.h&quot;
 38 #include &quot;PlatformMediaResourceLoader.h&quot;
 39 #include &quot;PlatformMediaSession.h&quot;
 40 #include &quot;SecurityOriginHash.h&quot;
 41 #include &quot;Timer.h&quot;
 42 #include &lt;wtf/URL.h&gt;
 43 #include &quot;VideoTrackPrivate.h&quot;
 44 #include &lt;JavaScriptCore/Uint8Array.h&gt;
 45 #include &lt;wtf/Function.h&gt;
 46 #include &lt;wtf/HashSet.h&gt;
 47 #include &lt;wtf/Logger.h&gt;
 48 #include &lt;wtf/MediaTime.h&gt;
 49 #include &lt;wtf/WallTime.h&gt;
 50 #include &lt;wtf/text/StringHash.h&gt;
 51 
 52 #if ENABLE(AVF_CAPTIONS)
 53 #include &quot;PlatformTextTrack.h&quot;
 54 #endif
 55 
 56 OBJC_CLASS AVPlayer;
 57 OBJC_CLASS NSArray;
 58 
 59 namespace WebCore {
 60 
 61 class AudioSourceProvider;
 62 class CDMInstance;
 63 class CachedResourceLoader;
<span class="line-modified"> 64 class GraphicsContextGLOpenGL;</span>
 65 class GraphicsContext;
<span class="line-added"> 66 class InbandTextTrackPrivate;</span>
 67 class LegacyCDMSessionClient;
 68 class MediaPlaybackTarget;
 69 class MediaPlayer;
<span class="line-added"> 70 class MediaPlayerFactory;</span>
 71 class MediaPlayerPrivateInterface;
 72 class MediaPlayerRequestInstallMissingPluginsCallback;
 73 class MediaSourcePrivateClient;
 74 class MediaStreamPrivate;
 75 class PlatformTimeRanges;
 76 class TextTrackRepresentation;
 77 
 78 struct Cookie;
 79 struct GraphicsDeviceAdapter;

 80 
 81 struct MediaEngineSupportParameters {
 82     ContentType type;
 83     URL url;
 84     bool isMediaSource { false };
 85     bool isMediaStream { false };
 86     Vector&lt;ContentType&gt; contentTypesRequiringHardwareSupport;
<span class="line-added"> 87 </span>
<span class="line-added"> 88     template&lt;class Encoder&gt;</span>
<span class="line-added"> 89     void encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 90     {</span>
<span class="line-added"> 91         encoder &lt;&lt; type;</span>
<span class="line-added"> 92         encoder &lt;&lt; url;</span>
<span class="line-added"> 93         encoder &lt;&lt; isMediaSource;</span>
<span class="line-added"> 94         encoder &lt;&lt; isMediaStream;</span>
<span class="line-added"> 95         encoder &lt;&lt; contentTypesRequiringHardwareSupport;</span>
<span class="line-added"> 96     }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98     template &lt;class Decoder&gt;</span>
<span class="line-added"> 99     static Optional&lt;MediaEngineSupportParameters&gt; decode(Decoder&amp; decoder)</span>
<span class="line-added">100     {</span>
<span class="line-added">101         Optional&lt;ContentType&gt; type;</span>
<span class="line-added">102         decoder &gt;&gt; type;</span>
<span class="line-added">103         if (!type)</span>
<span class="line-added">104             return WTF::nullopt;</span>
<span class="line-added">105 </span>
<span class="line-added">106         Optional&lt;URL&gt; url;</span>
<span class="line-added">107         decoder &gt;&gt; url;</span>
<span class="line-added">108         if (!url)</span>
<span class="line-added">109             return WTF::nullopt;</span>
<span class="line-added">110 </span>
<span class="line-added">111         Optional&lt;bool&gt; isMediaSource;</span>
<span class="line-added">112         decoder &gt;&gt; isMediaSource;</span>
<span class="line-added">113         if (!isMediaSource)</span>
<span class="line-added">114             return WTF::nullopt;</span>
<span class="line-added">115 </span>
<span class="line-added">116         Optional&lt;bool&gt; isMediaStream;</span>
<span class="line-added">117         decoder &gt;&gt; isMediaStream;</span>
<span class="line-added">118         if (!isMediaStream)</span>
<span class="line-added">119             return WTF::nullopt;</span>
<span class="line-added">120 </span>
<span class="line-added">121         Optional&lt;Vector&lt;ContentType&gt;&gt; typesRequiringHardware;</span>
<span class="line-added">122         decoder &gt;&gt; typesRequiringHardware;</span>
<span class="line-added">123         if (!typesRequiringHardware)</span>
<span class="line-added">124             return WTF::nullopt;</span>
<span class="line-added">125 </span>
<span class="line-added">126         return {{ WTFMove(*type), WTFMove(*url), *isMediaSource, *isMediaStream, *typesRequiringHardware }};</span>
<span class="line-added">127     }</span>
128 };
129 
130 struct VideoPlaybackQualityMetrics {
131     uint32_t totalVideoFrames { 0 };
132     uint32_t droppedVideoFrames { 0 };
133     uint32_t corruptedVideoFrames { 0 };
134     double totalFrameDelay { 0 };
135     uint32_t displayCompositedVideoFrames { 0 };
136 };
137 
138 class MediaPlayerClient {
139 public:
140     virtual ~MediaPlayerClient() = default;
141 
142     // the network state has changed
<span class="line-modified">143     virtual void mediaPlayerNetworkStateChanged() { }</span>
144 
145     // the ready state has changed
<span class="line-modified">146     virtual void mediaPlayerReadyStateChanged() { }</span>
147 
148     // the volume state has changed
<span class="line-modified">149     virtual void mediaPlayerVolumeChanged() { }</span>
150 
151     // the mute state has changed
<span class="line-modified">152     virtual void mediaPlayerMuteChanged() { }</span>
153 
154     // time has jumped, eg. not as a result of normal playback
<span class="line-modified">155     virtual void mediaPlayerTimeChanged() { }</span>
156 
157     // the media file duration has changed, or is now known
<span class="line-modified">158     virtual void mediaPlayerDurationChanged() { }</span>
159 
160     // the playback rate has changed
<span class="line-modified">161     virtual void mediaPlayerRateChanged() { }</span>
162 
163     // the play/pause status changed
<span class="line-modified">164     virtual void mediaPlayerPlaybackStateChanged() { }</span>





165 
166     // The MediaPlayer could not discover an engine which supports the requested resource.
<span class="line-modified">167     virtual void mediaPlayerResourceNotSupported() { }</span>
168 
169 // Presentation-related methods
170     // a new frame of video is available
<span class="line-modified">171     virtual void mediaPlayerRepaint() { }</span>
172 
173     // the movie size has changed
<span class="line-modified">174     virtual void mediaPlayerSizeChanged() { }</span>
175 
<span class="line-modified">176     virtual void mediaPlayerEngineUpdated() { }</span>
177 
178     // The first frame of video is available to render. A media engine need only make this callback if the
179     // first frame is not available immediately when prepareForRendering is called.
<span class="line-modified">180     virtual void mediaPlayerFirstVideoFrameAvailable() { }</span>
181 
182     // A characteristic of the media file, eg. video, audio, closed captions, etc, has changed.
<span class="line-modified">183     virtual void mediaPlayerCharacteristicChanged() { }</span>
184 
185     // whether the rendering system can accelerate the display of this MediaPlayer.
<span class="line-modified">186     virtual bool mediaPlayerRenderingCanBeAccelerated() { return false; }</span>
187 
188     // called when the media player&#39;s rendering mode changed, which indicates a change in the
189     // availability of the platformLayer().
<span class="line-modified">190     virtual void mediaPlayerRenderingModeChanged() { }</span>
191 
192     // whether accelerated compositing is enabled for video rendering
193     virtual bool mediaPlayerAcceleratedCompositingEnabled() { return false; }
194 
<span class="line-modified">195     virtual void mediaPlayerActiveSourceBuffersChanged() { }</span>
196 
197 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified">198     virtual GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter() const { return nullptr; }</span>
199 #endif
200 
201 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
202     virtual RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp;) const { return nullptr; }
<span class="line-modified">203     virtual bool mediaPlayerKeyNeeded(Uint8Array*) { return false; }</span>
204     virtual String mediaPlayerMediaKeysStorageDirectory() const { return emptyString(); }
205 #endif
206 
207 #if ENABLE(ENCRYPTED_MEDIA)
208     virtual void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) { }
209     virtual void mediaPlayerWaitingForKeyChanged() { }
210 #endif
211 
212 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">213     virtual void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool) { };</span>
214 #endif
215 
216     virtual String mediaPlayerReferrer() const { return String(); }
217     virtual String mediaPlayerUserAgent() const { return String(); }
218     virtual void mediaPlayerEnterFullscreen() { }
219     virtual void mediaPlayerExitFullscreen() { }
220     virtual bool mediaPlayerIsFullscreen() const { return false; }
221     virtual bool mediaPlayerIsFullscreenPermitted() const { return false; }
222     virtual bool mediaPlayerIsVideo() const { return false; }
223     virtual LayoutRect mediaPlayerContentBoxRect() const { return LayoutRect(); }
224     virtual float mediaPlayerContentsScale() const { return 1; }

225     virtual void mediaPlayerPause() { }
226     virtual void mediaPlayerPlay() { }
227     virtual bool mediaPlayerPlatformVolumeConfigurationRequired() const { return false; }

228     virtual bool mediaPlayerIsLooping() const { return false; }
229     virtual CachedResourceLoader* mediaPlayerCachedResourceLoader() { return nullptr; }
230     virtual RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() { return nullptr; }
231     virtual bool doesHaveAttribute(const AtomString&amp;, AtomString* = nullptr) const { return false; }
232     virtual bool mediaPlayerShouldUsePersistentCache() const { return true; }
233     virtual const String&amp; mediaPlayerMediaCacheDirectory() const { return emptyString(); }
234 
235 #if ENABLE(VIDEO_TRACK)
236     virtual void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) { }
237     virtual void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) { }
238     virtual void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) { }
239     virtual void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) { }
240     virtual void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) { }
241     virtual void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) { }
242 
243     virtual void textTrackRepresentationBoundsChanged(const IntRect&amp;) { }
244 #endif
245 
246 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
247     virtual Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources() { return { }; }
248 #endif
249 
250 #if PLATFORM(IOS_FAMILY)
251     virtual String mediaPlayerNetworkInterfaceName() const { return String(); }
252     virtual bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const { return false; }
253 #endif
254 


255     virtual String mediaPlayerSourceApplicationIdentifier() const { return emptyString(); }
256 

257     virtual void mediaPlayerEngineFailedToLoad() const { }
258 
259     virtual double mediaPlayerRequestedPlaybackRate() const { return 0; }
260     virtual MediaPlayerEnums::VideoFullscreenMode mediaPlayerFullscreenMode() const { return MediaPlayerEnums::VideoFullscreenModeNone; }
261     virtual bool mediaPlayerIsVideoFullscreenStandby() const { return false; }
262     virtual Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const { return Vector&lt;String&gt;(); }
263 
264 #if USE(GSTREAMER)
265     virtual void requestInstallMissingPlugins(const String&amp;, const String&amp;, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { };
266 #endif
267 
268     virtual bool mediaPlayerShouldDisableSleep() const { return false; }
<span class="line-modified">269     virtual const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const = 0;</span>
270     virtual bool mediaPlayerShouldCheckHardwareSupport() const { return false; }
271 
<span class="line-added">272     virtual void mediaPlayerBufferedTimeRangesChanged() { }</span>
<span class="line-added">273     virtual void mediaPlayerSeekableTimeRangesChanged() { }</span>
<span class="line-added">274 </span>
275 #if !RELEASE_LOG_DISABLED
276     virtual const void* mediaPlayerLogIdentifier() { return nullptr; }
277     virtual const Logger&amp; mediaPlayerLogger() = 0;
278 #endif
279 };
280 
<span class="line-modified">281 class WEBCORE_EXPORT MediaPlayer : public MediaPlayerEnums, public RefCounted&lt;MediaPlayer&gt; {</span>
282     WTF_MAKE_NONCOPYABLE(MediaPlayer); WTF_MAKE_FAST_ALLOCATED;
283 public:
284     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;);
<span class="line-added">285     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);</span>
286     virtual ~MediaPlayer();
287 
288     void invalidate();
289 
290     // Media engine support.
291     using MediaPlayerEnums::SupportsType;
<span class="line-added">292     static const MediaPlayerFactory* mediaEngine(MediaPlayerEnums::MediaEngineIdentifier);</span>
293     static SupportsType supportsType(const MediaEngineSupportParameters&amp;);
294     static void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;);
295     static bool isAvailable();
296     static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp; path);
297     static void clearMediaCache(const String&amp; path, WallTime modifiedSince);
298     static void clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
299     static bool supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType);
300 
301     bool supportsPictureInPicture() const;
302     bool supportsFullscreen() const;
303     bool supportsScanning() const;
304     bool canSaveMediaData() const;
305     bool requiresImmediateCompositing() const;
306     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const;
307     PlatformLayer* platformLayer() const;
308 
309 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
310     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
311     void setVideoFullscreenFrame(FloatRect);
312     void updateVideoFullscreenInlineImage();
313     using MediaPlayerEnums::VideoGravity;
314     void setVideoFullscreenGravity(VideoGravity);
315     void setVideoFullscreenMode(VideoFullscreenMode);
316     VideoFullscreenMode fullscreenMode() const;
317     void videoFullscreenStandbyChanged();
318     bool isVideoFullscreenStandby() const;
319 #endif
320 
321 #if PLATFORM(IOS_FAMILY)
322     NSArray *timedMetadata() const;
323     String accessLog() const;
324     String errorLog() const;
325 #endif
326 
327     FloatSize naturalSize();
328     bool hasVideo() const;
329     bool hasAudio() const;
330 


331     IntSize size() const { return m_size; }
332     void setSize(const IntSize&amp; size);
333 
334     bool load(const URL&amp;, const ContentType&amp;, const String&amp; keySystem);
335 #if ENABLE(MEDIA_SOURCE)
336     bool load(const URL&amp;, const ContentType&amp;, MediaSourcePrivateClient*);
337 #endif
338 #if ENABLE(MEDIA_STREAM)
339     bool load(MediaStreamPrivate&amp;);
340 #endif
341     void cancelLoad();
342 
343     bool visible() const;
344     void setVisible(bool);
345 
346     void prepareToPlay();
347     void play();
348     void pause();
349 
350     using MediaPlayerEnums::BufferingPolicy;
</pre>
<hr />
<pre>
372     static double invalidTime() { return -1.0;}
373     MediaTime duration() const;
374     MediaTime currentTime() const;
375     void seek(const MediaTime&amp;);
376     void seekWithTolerance(const MediaTime&amp;, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance);
377 
378     MediaTime startTime() const;
379     MediaTime initialTime() const;
380 
381     MediaTime getStartDate() const;
382 
383     double rate() const;
384     void setRate(double);
385     double requestedRate() const;
386 
387     bool preservesPitch() const;
388     void setPreservesPitch(bool);
389 
390     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered();
391     std::unique_ptr&lt;PlatformTimeRanges&gt; seekable();
<span class="line-added">392     void bufferedTimeRangesChanged();</span>
<span class="line-added">393     void seekableTimeRangesChanged();</span>
394     MediaTime minTimeSeekable();
395     MediaTime maxTimeSeekable();
396 
397     double seekableTimeRangesLastModifiedTime();
398     double liveUpdateInterval();
399 
400     bool didLoadingProgress();
401 
402     double volume() const;
403     void setVolume(double);
404     bool platformVolumeConfigurationRequired() const { return client().mediaPlayerPlatformVolumeConfigurationRequired(); }
405 
406     bool muted() const;
407     void setMuted(bool);
408 
409     bool hasClosedCaptions() const;
410     void setClosedCaptionsVisible(bool closedCaptionsVisible);
411 
412     void paint(GraphicsContext&amp;, const FloatRect&amp;);
413     void paintCurrentFrameInContext(GraphicsContext&amp;, const FloatRect&amp;);
414 
415     // copyVideoTextureToPlatformTexture() is used to do the GPU-GPU textures copy without a readback to system memory.
416     // The first five parameters denote the corresponding GraphicsContext, destination texture, requested level, requested type and the required internalFormat for destination texture.
417     // The last two parameters premultiplyAlpha and flipY denote whether addtional premultiplyAlpha and flip operation are required during the copy.
418     // It returns true on success and false on failure.
419 
420     // In the GPU-GPU textures copy, the source texture(Video texture) should have valid target, internalFormat and size, etc.
421     // The destination texture may need to be resized to to the dimensions of the source texture or re-defined to the required internalFormat.
422     // The current restrictions require that format shoud be RGB or RGBA, type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
423 
<span class="line-modified">424     bool copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL*, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY);</span>
425 
426     NativeImagePtr nativeImageForCurrentTime();
427 
428     using MediaPlayerEnums::NetworkState;
429     NetworkState networkState();
430 
431     using MediaPlayerEnums::ReadyState;
432     ReadyState readyState();
433 
434     using MediaPlayerEnums::MovieLoadType;
435     MovieLoadType movieLoadType() const;
436 
437     using MediaPlayerEnums::Preload;
438     Preload preload() const;
439     void setPreload(Preload);
440 
441     void networkStateChanged();
442     void readyStateChanged();
443     void volumeChanged(double);
444     void muteChanged(bool);
445     void timeChanged();
446     void sizeChanged();
447     void rateChanged();
448     void playbackStateChanged();
449     void durationChanged();
450     void firstVideoFrameAvailable();
451     void characteristicChanged();
452 
453     void repaint();
454 


455     bool hasAvailableVideoFrame() const;
456     void prepareForRendering();
457 



458 #if USE(NATIVE_FULLSCREEN_VIDEO)
459     void enterFullscreen();
460     void exitFullscreen();
461 #endif
462 
463 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
464     enum WirelessPlaybackTargetType { TargetTypeNone, TargetTypeAirPlay, TargetTypeTVOut };
465     WirelessPlaybackTargetType wirelessPlaybackTargetType() const;
466 
467     String wirelessPlaybackTargetName() const;
468 
469     bool wirelessVideoPlaybackDisabled() const;
470     void setWirelessVideoPlaybackDisabled(bool);
471 
<span class="line-modified">472     void currentPlaybackTargetIsWirelessChanged(bool);</span>
473     void playbackTargetAvailabilityChanged();
474 
475     bool isCurrentPlaybackTargetWireless() const;
476     bool canPlayToWirelessPlaybackTarget() const;
477     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
478 
479     void setShouldPlayToPlaybackTarget(bool);
480 #endif
481 
482     double minFastReverseRate() const;
483     double maxFastForwardRate() const;
484 
485 #if USE(NATIVE_FULLSCREEN_VIDEO)
486     bool canEnterFullscreen() const;
487 #endif
488 
489     // whether accelerated rendering is supported by the media engine for the current media.
490     bool supportsAcceleratedRendering() const;
491     // called when the rendering system flips the into or out of accelerated rendering mode.
492     void acceleratedRenderingStateChanged();
</pre>
<hr />
<pre>
548 
549     bool requiresTextTrackRepresentation() const;
550     void setTextTrackRepresentation(TextTrackRepresentation*);
551     void syncTextTrackBounds();
552     void tracksChanged();
553 #endif
554 
555 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
556     void notifyTrackModeChanged();
557     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources();
558 #endif
559 
560 #if PLATFORM(IOS_FAMILY)
561     String mediaPlayerNetworkInterfaceName() const;
562     bool getRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const;
563 #endif
564 
565     static void resetMediaEngines();
566 
567 #if USE(GSTREAMER)
<span class="line-modified">568     void simulateAudioInterruption();</span>
569 #endif
570 
<span class="line-modified">571     void beginSimulatedHDCPError();</span>
<span class="line-modified">572     void endSimulatedHDCPError();</span>
573 
574     String languageOfPrimaryAudioTrack() const;
575 
576     size_t extraMemoryCost() const;
577 
578     unsigned long long fileSize() const;
579 
580     Optional&lt;VideoPlaybackQualityMetrics&gt; videoPlaybackQualityMetrics();
581 

582     String sourceApplicationIdentifier() const;
583     Vector&lt;String&gt; preferredAudioCharacteristics() const;
584 
585     bool ended() const;
586 
587     void setShouldDisableSleep(bool);
588     bool shouldDisableSleep() const;
589 
590     String contentMIMEType() const { return m_contentType.containerType(); }
591     String contentTypeCodecs() const { return m_contentType.parameter(ContentType::codecsParameter()); }
592     bool contentMIMETypeWasInferredFromExtension() const { return m_contentMIMETypeWasInferredFromExtension; }
593 
594     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const;
595     bool shouldCheckHardwareSupport() const;
596 
597 #if !RELEASE_LOG_DISABLED
598     const Logger&amp; mediaPlayerLogger();
599     const void* mediaPlayerLogIdentifier() { return client().mediaPlayerLogIdentifier(); }
600 #endif
601 
602     void applicationWillResignActive();
603     void applicationDidBecomeActive();
604 
605 #if USE(AVFOUNDATION)
<span class="line-modified">606     AVPlayer *objCAVFoundationAVPlayer() const;</span>
607 #endif
608 
609     bool performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp;, MediaTime);
610 
611     bool shouldIgnoreIntrinsicSize();
612 
<span class="line-added">613     bool renderingCanBeAccelerated() const { return client().mediaPlayerRenderingCanBeAccelerated(); }</span>
<span class="line-added">614     void renderingModeChanged() const  { client().mediaPlayerRenderingModeChanged(); }</span>
<span class="line-added">615     bool acceleratedCompositingEnabled() { return client().mediaPlayerAcceleratedCompositingEnabled(); }</span>
<span class="line-added">616     void activeSourceBuffersChanged() { client().mediaPlayerActiveSourceBuffersChanged(); }</span>
<span class="line-added">617     LayoutRect playerContentBoxRect() const { return client().mediaPlayerContentBoxRect(); }</span>
<span class="line-added">618     float playerContentsScale() const { return client().mediaPlayerContentsScale(); }</span>
<span class="line-added">619     bool shouldUsePersistentCache() const { return client().mediaPlayerShouldUsePersistentCache(); }</span>
<span class="line-added">620     const String&amp; mediaCacheDirectory() const { return client().mediaPlayerMediaCacheDirectory(); }</span>
<span class="line-added">621     bool isVideoPlayer() const { return client().mediaPlayerIsVideo(); }</span>
<span class="line-added">622     void mediaEngineUpdated() { client().mediaPlayerEngineUpdated(); }</span>
<span class="line-added">623     void resourceNotSupported() { client().mediaPlayerResourceNotSupported(); }</span>
<span class="line-added">624     bool isLooping() const { return client().mediaPlayerIsLooping(); }</span>
<span class="line-added">625 </span>
<span class="line-added">626     void remoteEngineFailedToLoad();</span>
<span class="line-added">627 </span>
<span class="line-added">628 #if USE(GSTREAMER)</span>
<span class="line-added">629     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback) { client().requestInstallMissingPlugins(details, description, callback); }</span>
<span class="line-added">630 #endif</span>
<span class="line-added">631 </span>
632 private:
633     MediaPlayer(MediaPlayerClient&amp;);
<span class="line-added">634     MediaPlayer(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);</span>
635 
<span class="line-modified">636     MediaPlayerClient&amp; client() const { return *m_client; }</span>
<span class="line-added">637 </span>
<span class="line-added">638     const MediaPlayerFactory* nextBestMediaEngine(const MediaPlayerFactory*);</span>
639     void loadWithNextMediaEngine(const MediaPlayerFactory*);
<span class="line-added">640     const MediaPlayerFactory* nextMediaEngine(const MediaPlayerFactory*);</span>
641     void reloadTimerFired();
642 
643     MediaPlayerClient* m_client;
644     Timer m_reloadTimer;
645     std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; m_private;
646     const MediaPlayerFactory* m_currentMediaEngine { nullptr };
647     URL m_url;
648     ContentType m_contentType;
649     String m_keySystem;
<span class="line-added">650     Optional&lt;MediaPlayerEnums::MediaEngineIdentifier&gt; m_activeEngineIdentifier;</span>
651     IntSize m_size;
<span class="line-modified">652     Preload m_preload { Preload::Auto };</span>
653     double m_volume { 1 };
654     bool m_visible { false };
655     bool m_muted { false };
656     bool m_preservesPitch { true };
657     bool m_privateBrowsing { false };
658     bool m_shouldPrepareToRender { false };
659     bool m_contentMIMETypeWasInferredFromExtension { false };
660     bool m_initializingMediaEngine { false };
661 
662 #if ENABLE(MEDIA_SOURCE)
663     RefPtr&lt;MediaSourcePrivateClient&gt; m_mediaSource;
664 #endif
665 #if ENABLE(MEDIA_STREAM)
666     RefPtr&lt;MediaStreamPrivate&gt; m_mediaStream;
667 #endif
668 };
669 
<span class="line-modified">670 class MediaPlayerFactory {</span>
<span class="line-modified">671     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">672 public:</span>
<span class="line-modified">673     MediaPlayerFactory() = default;</span>
<span class="line-modified">674     virtual ~MediaPlayerFactory() = default;</span>
<span class="line-modified">675 </span>
<span class="line-modified">676     virtual MediaPlayerEnums::MediaEngineIdentifier identifier() const  = 0;</span>
<span class="line-added">677     virtual std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; createMediaEnginePlayer(MediaPlayer*) const = 0;</span>
<span class="line-added">678     virtual void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;) const = 0;</span>
<span class="line-added">679     virtual MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters&amp;) const = 0;</span>
<span class="line-added">680 </span>
<span class="line-added">681     virtual HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;) const { return { }; }</span>
<span class="line-added">682     virtual void clearMediaCache(const String&amp;, WallTime) const { }</span>
<span class="line-added">683     virtual void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;) const { }</span>
<span class="line-added">684     virtual bool supportsKeySystem(const String&amp; /* keySystem */, const String&amp; /* mimeType */) const { return false; }</span>
<span class="line-added">685 };</span>
686 
<span class="line-modified">687 using MediaEngineRegistrar = void(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp;);</span>
<span class="line-modified">688 using MediaEngineRegister = void(MediaEngineRegistrar);</span>

689 
690 class MediaPlayerFactorySupport {
691 public:
692     WEBCORE_EXPORT static void callRegisterMediaEngine(MediaEngineRegister);
693 };
694 
<span class="line-added">695 class RemoteMediaPlayerSupport {</span>
<span class="line-added">696 public:</span>
<span class="line-added">697     using RegisterRemotePlayerCallback = WTF::Function&lt;void(MediaEngineRegistrar, MediaPlayerEnums::MediaEngineIdentifier)&gt;;</span>
<span class="line-added">698     WEBCORE_EXPORT static void setRegisterRemotePlayerCallback(RegisterRemotePlayerCallback&amp;&amp;);</span>
<span class="line-added">699 };</span>
<span class="line-added">700 </span>
<span class="line-added">701 </span>
702 } // namespace WebCore
703 
704 #endif // ENABLE(VIDEO)
</pre>
</td>
</tr>
</table>
<center><a href="MediaPlayer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayerEnums.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
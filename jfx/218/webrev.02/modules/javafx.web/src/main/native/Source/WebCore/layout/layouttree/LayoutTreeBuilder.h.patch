diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutTreeBuilder.h b/modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutTreeBuilder.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutTreeBuilder.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutTreeBuilder.h
@@ -25,31 +25,78 @@
 
 #pragma once
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
+#include "LayoutContainer.h"
+#include <wtf/IsoMalloc.h>
+#include <wtf/WeakPtr.h>
+
 namespace WebCore {
 
+class RenderBlockFlow;
+class RenderBox;
 class RenderElement;
 class RenderObject;
 class RenderTable;
 class RenderView;
 
 namespace Layout {
 
-class Box;
-class Container;
 class LayoutState;
 
+class LayoutTreeContent : public CanMakeWeakPtr<LayoutTreeContent> {
+    WTF_MAKE_ISO_ALLOCATED(LayoutTreeContent);
+public:
+    LayoutTreeContent(const RenderBox&, std::unique_ptr<Container>);
+    ~LayoutTreeContent();
+
+    const Container& rootLayoutBox() const { return *m_rootLayoutBox; }
+    Container& rootLayoutBox() { return *m_rootLayoutBox; }
+    const RenderBox& rootRenderer() const { return m_rootRenderer; }
+
+    void addBox(std::unique_ptr<Box> box)
+    {
+        ASSERT(!box->isContainer());
+        m_boxes.add(WTFMove(box));
+    }
+    void addContainer(std::unique_ptr<Container> container) { m_containers.add(WTFMove(container)); }
+
+    Box* layoutBoxForRenderer(const RenderObject& renderer) { return m_renderObjectToLayoutBox.get(&renderer); }
+    const Box* layoutBoxForRenderer(const RenderObject& renderer) const { return m_renderObjectToLayoutBox.get(&renderer); }
+
+    const RenderObject* rendererForLayoutBox(const Box& box) const { return m_layoutBoxToRenderObject.get(&box); }
+
+    void addLayoutBoxForRenderer(const RenderObject&, Box&);
+
+private:
+    const RenderBox& m_rootRenderer;
+    std::unique_ptr<Container> m_rootLayoutBox;
+    HashSet<std::unique_ptr<Box>> m_boxes;
+    HashSet<std::unique_ptr<Container>> m_containers;
+
+    HashMap<const RenderObject*, Box*> m_renderObjectToLayoutBox;
+    HashMap<const Box*, const RenderObject*> m_layoutBoxToRenderObject;
+};
+
 class TreeBuilder {
 public:
-    static std::unique_ptr<Container> createLayoutTree(const RenderView&);
+    static std::unique_ptr<Layout::LayoutTreeContent> buildLayoutTree(const RenderView&);
 
 private:
-    static void createSubTree(const RenderElement& rootRenderer, Container& rootContainer);
-    static void createTableStructure(const RenderTable& tableRenderer, Container& tableWrapperBox);
-    static std::unique_ptr<Box> createLayoutBox(const RenderElement& parentRenderer, const RenderObject& childRenderer);
+    TreeBuilder(LayoutTreeContent&);
+
+    void buildTree();
+    void buildSubTree(const RenderElement& parentRenderer, Container& parentContainer);
+    void buildTableStructure(const RenderTable& tableRenderer, Container& tableWrapperBox);
+    Box* createLayoutBox(const Container& parentContainer, const RenderObject& childRenderer);
+
+    Box& createBox(Optional<Box::ElementAttributes>, RenderStyle&&);
+    Box& createTextBox(TextContext&&, RenderStyle&&);
+    Container& createContainer(Optional<Box::ElementAttributes>, RenderStyle&&);
+
+    LayoutTreeContent& m_layoutTreeContent;
 };
 
 #if ENABLE(TREE_DEBUGGING)
 void showLayoutTree(const Box&, const LayoutState*);
 void showLayoutTree(const Box&);

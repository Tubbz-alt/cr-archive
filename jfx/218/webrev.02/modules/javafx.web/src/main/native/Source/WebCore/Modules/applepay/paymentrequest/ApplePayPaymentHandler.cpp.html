<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/applepay/paymentrequest/ApplePayPaymentHandler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ApplePayPaymentHandler.h&quot;
 28 
 29 #if ENABLE(APPLE_PAY) &amp;&amp; ENABLE(PAYMENT_REQUEST)
 30 
 31 #include &quot;AddressErrors.h&quot;
 32 #include &quot;ApplePayContactField.h&quot;
 33 #include &quot;ApplePayMerchantCapability.h&quot;
 34 #include &quot;ApplePayModifier.h&quot;
 35 #include &quot;ApplePayPayment.h&quot;
 36 #include &quot;ApplePaySessionPaymentRequest.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;EventNames.h&quot;
 39 #include &quot;Frame.h&quot;
 40 #include &quot;JSApplePayError.h&quot;
 41 #include &quot;JSApplePayPayment.h&quot;
 42 #include &quot;JSApplePayPaymentMethod.h&quot;
 43 #include &quot;JSApplePayRequest.h&quot;
 44 #include &quot;JSDOMConvert.h&quot;
 45 #include &quot;LinkIconCollector.h&quot;
 46 #include &quot;MerchantValidationEvent.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;PayerErrorFields.h&quot;
 49 #include &quot;Payment.h&quot;
 50 #include &quot;PaymentAuthorizationStatus.h&quot;
 51 #include &quot;PaymentContact.h&quot;
 52 #include &quot;PaymentCoordinator.h&quot;
 53 #include &quot;PaymentMerchantSession.h&quot;
 54 #include &quot;PaymentMethod.h&quot;
 55 #include &quot;PaymentMethodUpdate.h&quot;
 56 #include &quot;PaymentRequestValidator.h&quot;
 57 #include &quot;PaymentResponse.h&quot;
 58 #include &quot;PaymentValidationErrors.h&quot;
 59 #include &quot;Settings.h&quot;
 60 #include &lt;JavaScriptCore/JSONObject.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 static ExceptionOr&lt;ApplePayRequest&gt; convertAndValidate(ScriptExecutionContext&amp; context, JSC::JSValue data)
 65 {
 66     if (data.isEmpty())
 67         return Exception { TypeError, &quot;Missing payment method data.&quot; };
 68 
 69     auto throwScope = DECLARE_THROW_SCOPE(context.vm());
 70     auto applePayRequest = convertDictionary&lt;ApplePayRequest&gt;(*context.execState(), data);
 71     if (throwScope.exception())
 72         return Exception { ExistingExceptionError };
 73 
 74     return WTFMove(applePayRequest);
 75 }
 76 
 77 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::validateData(Document&amp; document, JSC::JSValue data)
 78 {
 79     auto requestOrException = convertAndValidate(document, data);
 80     if (requestOrException.hasException())
 81         return requestOrException.releaseException();
 82 
 83     return { };
 84 }
 85 
 86 bool ApplePayPaymentHandler::handlesIdentifier(const PaymentRequest::MethodIdentifier&amp; identifier)
 87 {
 88     if (!WTF::holds_alternative&lt;URL&gt;(identifier))
 89         return false;
 90 
 91     auto&amp; url = WTF::get&lt;URL&gt;(identifier);
 92     return url.host() == &quot;apple.com&quot; &amp;&amp; url.path() == &quot;/apple-pay&quot;;
 93 }
 94 
 95 static inline PaymentCoordinator&amp; paymentCoordinator(Document&amp; document)
 96 {
 97     ASSERT(document.page());
 98     return document.page()-&gt;paymentCoordinator();
 99 }
100 
101 bool ApplePayPaymentHandler::hasActiveSession(Document&amp; document)
102 {
103     return WebCore::paymentCoordinator(document).hasActiveSession();
104 }
105 
106 ApplePayPaymentHandler::ApplePayPaymentHandler(Document&amp; document, const PaymentRequest::MethodIdentifier&amp; identifier, PaymentRequest&amp; paymentRequest)
107     : ContextDestructionObserver { &amp;document }
108     , m_identifier { identifier }
109     , m_paymentRequest { paymentRequest }
110 {
111     ASSERT(handlesIdentifier(m_identifier));
112 }
113 
114 Document&amp; ApplePayPaymentHandler::document() const
115 {
116     return downcast&lt;Document&gt;(*scriptExecutionContext());
117 }
118 
119 PaymentCoordinator&amp; ApplePayPaymentHandler::paymentCoordinator() const
120 {
121     return WebCore::paymentCoordinator(document());
122 }
123 
124 static ExceptionOr&lt;void&gt; validate(const PaymentCurrencyAmount&amp; amount, const String&amp; expectedCurrency)
125 {
126     if (amount.currency != expectedCurrency)
127         return Exception { TypeError, makeString(&quot;\&quot;&quot;, amount.currency, &quot;\&quot; does not match the expected currency of \&quot;&quot;, expectedCurrency, &quot;\&quot;. Apple Pay requires all PaymentCurrencyAmounts to use the same currency code.&quot;) };
128     return { };
129 }
130 
131 static ExceptionOr&lt;ApplePaySessionPaymentRequest::LineItem&gt; convertAndValidate(const PaymentItem&amp; item, const String&amp; expectedCurrency)
132 {
133     auto exception = validate(item.amount, expectedCurrency);
134     if (exception.hasException())
135         return exception.releaseException();
136 
137     ApplePaySessionPaymentRequest::LineItem lineItem;
138     lineItem.amount = item.amount.value;
139     lineItem.type = item.pending ? ApplePaySessionPaymentRequest::LineItem::Type::Pending : ApplePaySessionPaymentRequest::LineItem::Type::Final;
140     lineItem.label = item.label;
141     return { WTFMove(lineItem) };
142 }
143 
144 static ExceptionOr&lt;Vector&lt;ApplePaySessionPaymentRequest::LineItem&gt;&gt; convertAndValidate(const Vector&lt;PaymentItem&gt;&amp; lineItems, const String&amp; expectedCurrency)
145 {
146     Vector&lt;ApplePaySessionPaymentRequest::LineItem&gt; result;
147     result.reserveInitialCapacity(lineItems.size());
148     for (auto&amp; lineItem : lineItems) {
149         auto convertedLineItem = convertAndValidate(lineItem, expectedCurrency);
150         if (convertedLineItem.hasException())
151             return convertedLineItem.releaseException();
152         result.uncheckedAppend(convertedLineItem.releaseReturnValue());
153     }
154     return { WTFMove(result) };
155 }
156 
157 static ApplePaySessionPaymentRequest::ShippingType convert(PaymentShippingType type)
158 {
159     switch (type) {
160     case PaymentShippingType::Shipping:
161         return ApplePaySessionPaymentRequest::ShippingType::Shipping;
162     case PaymentShippingType::Delivery:
163         return ApplePaySessionPaymentRequest::ShippingType::Delivery;
164     case PaymentShippingType::Pickup:
165         return ApplePaySessionPaymentRequest::ShippingType::StorePickup;
166     }
167 
168     ASSERT_NOT_REACHED();
169     return ApplePaySessionPaymentRequest::ShippingType::Shipping;
170 }
171 
172 static ExceptionOr&lt;ApplePaySessionPaymentRequest::ShippingMethod&gt; convertAndValidate(const PaymentShippingOption&amp; shippingOption, const String&amp; expectedCurrency)
173 {
174     auto exception = validate(shippingOption.amount, expectedCurrency);
175     if (exception.hasException())
176         return exception.releaseException();
177 
178     ApplePaySessionPaymentRequest::ShippingMethod result;
179     result.amount = shippingOption.amount.value;
180     result.label = shippingOption.label;
181     result.identifier = shippingOption.id;
182     return { WTFMove(result) };
183 }
184 
185 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::convertData(JSC::JSValue data)
186 {
187     auto requestOrException = convertAndValidate(*scriptExecutionContext(), data);
188     if (requestOrException.hasException())
189         return requestOrException.releaseException();
190 
191     m_applePayRequest = requestOrException.releaseReturnValue();
192     return { };
193 }
194 
195 static void mergePaymentOptions(const PaymentOptions&amp; options, ApplePaySessionPaymentRequest&amp; request)
196 {
197     auto requiredShippingContactFields = request.requiredShippingContactFields();
198     requiredShippingContactFields.email |= options.requestPayerEmail;
199     requiredShippingContactFields.name |= options.requestPayerName;
200     requiredShippingContactFields.phone |= options.requestPayerPhone;
201     requiredShippingContactFields.postalAddress |= options.requestShipping;
202     request.setRequiredShippingContactFields(requiredShippingContactFields);
203 
204     if (options.requestShipping)
205         request.setShippingType(convert(options.shippingType));
206 }
207 
208 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::show(Document&amp; document)
209 {
210     auto validatedRequest = convertAndValidate(document, m_applePayRequest-&gt;version, *m_applePayRequest, paymentCoordinator());
211     if (validatedRequest.hasException())
212         return validatedRequest.releaseException();
213 
214     ApplePaySessionPaymentRequest request = validatedRequest.releaseReturnValue();
215     request.setRequester(ApplePaySessionPaymentRequest::Requester::PaymentRequest);
216 
217     String expectedCurrency = m_paymentRequest-&gt;paymentDetails().total.amount.currency;
218     request.setCurrencyCode(expectedCurrency);
219 
220     auto total = convertAndValidate(m_paymentRequest-&gt;paymentDetails().total, expectedCurrency);
221     ASSERT(!total.hasException());
222     request.setTotal(total.releaseReturnValue());
223 
224     auto convertedLineItems = convertAndValidate(m_paymentRequest-&gt;paymentDetails().displayItems, expectedCurrency);
225     if (convertedLineItems.hasException())
226         return convertedLineItems.releaseException();
227     request.setLineItems(convertedLineItems.releaseReturnValue());
228 
229     mergePaymentOptions(m_paymentRequest-&gt;paymentOptions(), request);
230 
231     auto shippingMethods = computeShippingMethods();
232     if (shippingMethods.hasException())
233         return shippingMethods.releaseException();
234     request.setShippingMethods(shippingMethods.releaseReturnValue());
235 
236     auto exception = PaymentRequestValidator::validate(request);
237     if (exception.hasException())
238         return exception.releaseException();
239 
240     if (!paymentCoordinator().beginPaymentSession(document, *this, request))
241         return Exception { AbortError };
242 
243     return { };
244 }
245 
246 void ApplePayPaymentHandler::hide()
247 {
248     paymentCoordinator().abortPaymentSession();
249 }
250 
251 void ApplePayPaymentHandler::canMakePayment(Document&amp; document, Function&lt;void(bool)&gt;&amp;&amp; completionHandler)
252 {
253     completionHandler(paymentCoordinator().canMakePayments(document));
254 }
255 
256 ExceptionOr&lt;Vector&lt;ApplePaySessionPaymentRequest::ShippingMethod&gt;&gt; ApplePayPaymentHandler::computeShippingMethods()
257 {
258     auto&amp; details = m_paymentRequest-&gt;paymentDetails();
259     auto&amp; currency = details.total.amount.currency;
260     auto&amp; shippingOptions = details.shippingOptions;
261 
262     Vector&lt;ApplePaySessionPaymentRequest::ShippingMethod&gt; shippingMethods;
263     shippingMethods.reserveInitialCapacity(shippingOptions.size());
264 
265     for (auto&amp; shippingOption : shippingOptions) {
266         auto shippingMethod = convertAndValidate(shippingOption, currency);
267         if (shippingMethod.hasException())
268             return shippingMethod.releaseException();
269         shippingMethods.uncheckedAppend(shippingMethod.releaseReturnValue());
270     }
271 
272     return WTFMove(shippingMethods);
273 }
274 
275 ExceptionOr&lt;ApplePaySessionPaymentRequest::TotalAndLineItems&gt; ApplePayPaymentHandler::computeTotalAndLineItems() const
276 {
277     auto&amp; details = m_paymentRequest-&gt;paymentDetails();
278     String currency = details.total.amount.currency;
279 
280     auto convertedTotal = convertAndValidate(details.total, currency);
281     if (convertedTotal.hasException())
282         return convertedTotal.releaseException();
283     auto total = convertedTotal.releaseReturnValue();
284 
285     auto convertedLineItems = convertAndValidate(details.displayItems, currency);
286     if (convertedLineItems.hasException())
287         return convertedLineItems.releaseException();
288     auto lineItems = convertedLineItems.releaseReturnValue();
289 
290     if (!m_selectedPaymentMethodType)
291         return ApplePaySessionPaymentRequest::TotalAndLineItems { WTFMove(total), WTFMove(lineItems) };
292 
293     auto&amp; modifiers = details.modifiers;
294     auto&amp; serializedModifierData = m_paymentRequest-&gt;serializedModifierData();
295     ASSERT(modifiers.size() == serializedModifierData.size());
296     for (size_t i = 0; i &lt; modifiers.size(); ++i) {
297         auto convertedIdentifier = convertAndValidatePaymentMethodIdentifier(modifiers[i].supportedMethods);
298         if (!convertedIdentifier || !handlesIdentifier(*convertedIdentifier))
299             continue;
300 
301         if (serializedModifierData[i].isEmpty())
302             continue;
303 
304         auto&amp; lexicalGlobalObject = *document().execState();
305         auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());
306         JSC::JSValue data;
307         {
308             auto lock = JSC::JSLockHolder { &amp;lexicalGlobalObject };
309             data = JSONParse(&amp;lexicalGlobalObject, serializedModifierData[i]);
310             if (scope.exception())
311                 return Exception { ExistingExceptionError };
312         }
313 
314         auto applePayModifier = convertDictionary&lt;ApplePayModifier&gt;(lexicalGlobalObject, WTFMove(data));
315         if (scope.exception())
316             return Exception { ExistingExceptionError };
317 
318         if (applePayModifier.paymentMethodType != *m_selectedPaymentMethodType)
319             continue;
320 
321         if (modifiers[i].total) {
322             auto totalOverride = convertAndValidate(*modifiers[i].total, currency);
323             if (totalOverride.hasException())
324                 return totalOverride.releaseException();
325             total = totalOverride.releaseReturnValue();
326         }
327 
328         auto additionalDisplayItems = convertAndValidate(modifiers[i].additionalDisplayItems, currency);
329         if (additionalDisplayItems.hasException())
330             return additionalDisplayItems.releaseException();
331         lineItems.appendVector(additionalDisplayItems.releaseReturnValue());
332         break;
333     }
334 
335     return ApplePaySessionPaymentRequest::TotalAndLineItems { WTFMove(total), WTFMove(lineItems) };
336 }
337 
338 static inline void appendShippingContactInvalidError(String&amp;&amp; message, Optional&lt;PaymentError::ContactField&gt; contactField, Vector&lt;PaymentError&gt;&amp; errors)
339 {
340     if (!message.isNull())
341         errors.append({ PaymentError::Code::ShippingContactInvalid, WTFMove(message), WTFMove(contactField) });
342 }
343 
344 Vector&lt;PaymentError&gt; ApplePayPaymentHandler::computeErrors(String&amp;&amp; error, AddressErrors&amp;&amp; addressErrors, PayerErrorFields&amp;&amp; payerErrors, JSC::JSObject* paymentMethodErrors) const
345 {
346     Vector&lt;PaymentError&gt; errors;
347 
348     if (m_paymentRequest-&gt;paymentDetails().shippingOptions.isEmpty())
349         computeAddressErrors(WTFMove(error), WTFMove(addressErrors), errors);
350 
351     computePayerErrors(WTFMove(payerErrors), errors);
352 
353     auto scope = DECLARE_CATCH_SCOPE(scriptExecutionContext()-&gt;vm());
354     auto exception = computePaymentMethodErrors(paymentMethodErrors, errors);
355     if (exception.hasException()) {
356         ASSERT(scope.exception());
357         scope.clearException();
358     }
359 
360     return errors;
361 }
362 
363 void ApplePayPaymentHandler::computeAddressErrors(String&amp;&amp; error, AddressErrors&amp;&amp; addressErrors, Vector&lt;PaymentError&gt;&amp; errors) const
364 {
365     if (!m_paymentRequest-&gt;paymentOptions().requestShipping)
366         return;
367 
368     using ContactField = PaymentError::ContactField;
369     appendShippingContactInvalidError(WTFMove(error), WTF::nullopt, errors);
370     appendShippingContactInvalidError(WTFMove(addressErrors.addressLine), ContactField::AddressLines, errors);
371     appendShippingContactInvalidError(WTFMove(addressErrors.city), ContactField::Locality, errors);
372     appendShippingContactInvalidError(WTFMove(addressErrors.country), ContactField::Country, errors);
373     appendShippingContactInvalidError(WTFMove(addressErrors.dependentLocality), ContactField::SubLocality, errors);
374     appendShippingContactInvalidError(WTFMove(addressErrors.phone), ContactField::PhoneNumber, errors);
375     appendShippingContactInvalidError(WTFMove(addressErrors.postalCode), ContactField::PostalCode, errors);
376     appendShippingContactInvalidError(WTFMove(addressErrors.recipient), ContactField::Name, errors);
377     appendShippingContactInvalidError(WTFMove(addressErrors.region), ContactField::AdministrativeArea, errors);
378 }
379 
380 void ApplePayPaymentHandler::computePayerErrors(PayerErrorFields&amp;&amp; payerErrors, Vector&lt;PaymentError&gt;&amp; errors) const
381 {
382     auto&amp; options = m_paymentRequest-&gt;paymentOptions();
383     using ContactField = PaymentError::ContactField;
384 
385     if (options.requestPayerName)
386         appendShippingContactInvalidError(WTFMove(payerErrors.name), ContactField::Name, errors);
387 
388     if (options.requestPayerEmail)
389         appendShippingContactInvalidError(WTFMove(payerErrors.email), ContactField::EmailAddress, errors);
390 
391     if (options.requestPayerPhone)
392         appendShippingContactInvalidError(WTFMove(payerErrors.phone), ContactField::PhoneNumber, errors);
393 }
394 
395 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::computePaymentMethodErrors(JSC::JSObject* paymentMethodErrors, Vector&lt;PaymentError&gt;&amp; errors) const
396 {
397     if (!paymentMethodErrors)
398         return { };
399 
400 #if ENABLE(APPLE_PAY_SESSION_V3)
401     auto&amp; context = *scriptExecutionContext();
402     auto throwScope = DECLARE_THROW_SCOPE(context.vm());
403     auto applePayErrors = convert&lt;IDLSequence&lt;IDLInterface&lt;ApplePayError&gt;&gt;&gt;(*context.execState(), paymentMethodErrors);
404     if (throwScope.exception())
405         return Exception { ExistingExceptionError };
406 
407     for (auto&amp; applePayError : applePayErrors) {
408         if (applePayError)
409             errors.append({ applePayError-&gt;code(), applePayError-&gt;message(), applePayError-&gt;contactField() });
410     }
411 #else
412     UNUSED_PARAM(errors);
413 #endif
414 
415     return { };
416 }
417 
418 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::detailsUpdated(PaymentRequest::UpdateReason reason, String&amp;&amp; error, AddressErrors&amp;&amp; addressErrors, PayerErrorFields&amp;&amp; payerErrors, JSC::JSObject* paymentMethodErrors)
419 {
420     using Reason = PaymentRequest::UpdateReason;
421     switch (reason) {
422     case Reason::ShowDetailsResolved:
423         return { };
424     case Reason::ShippingAddressChanged:
425         return shippingAddressUpdated(computeErrors(WTFMove(error), WTFMove(addressErrors), WTFMove(payerErrors), paymentMethodErrors));
426     case Reason::ShippingOptionChanged:
427         return shippingOptionUpdated();
428     case Reason::PaymentMethodChanged:
429         return paymentMethodUpdated();
430     }
431 
432     ASSERT_NOT_REACHED();
433     return { };
434 }
435 
436 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::merchantValidationCompleted(JSC::JSValue&amp;&amp; merchantSessionValue)
437 {
438     if (!paymentCoordinator().hasActiveSession())
439         return Exception { InvalidStateError };
440 
441     if (!merchantSessionValue.isObject())
442         return Exception { TypeError };
443 
444     String errorMessage;
445     auto merchantSession = PaymentMerchantSession::fromJS(*document().execState(), asObject(merchantSessionValue), errorMessage);
446     if (!merchantSession)
447         return Exception { TypeError, WTFMove(errorMessage) };
448 
449     paymentCoordinator().completeMerchantValidation(*merchantSession);
450     return { };
451 }
452 
453 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::shippingAddressUpdated(Vector&lt;PaymentError&gt;&amp;&amp; errors)
454 {
455     ASSERT(m_isUpdating);
456     m_isUpdating = false;
457 
458     ShippingContactUpdate update;
459     update.errors = WTFMove(errors);
460 
461     auto newShippingMethods = computeShippingMethods();
462     if (newShippingMethods.hasException())
463         return newShippingMethods.releaseException();
464     update.newShippingMethods = newShippingMethods.releaseReturnValue();
465 
466     auto newTotalAndLineItems = computeTotalAndLineItems();
467     if (newTotalAndLineItems.hasException())
468         return newTotalAndLineItems.releaseException();
469     update.newTotalAndLineItems = newTotalAndLineItems.releaseReturnValue();
470 
471     paymentCoordinator().completeShippingContactSelection(WTFMove(update));
472     return { };
473 }
474 
475 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::shippingOptionUpdated()
476 {
477     ASSERT(m_isUpdating);
478     m_isUpdating = false;
479 
480     ShippingMethodUpdate update;
481 
482     auto newTotalAndLineItems = computeTotalAndLineItems();
483     if (newTotalAndLineItems.hasException())
484         return newTotalAndLineItems.releaseException();
485     update.newTotalAndLineItems = newTotalAndLineItems.releaseReturnValue();
486 
487     paymentCoordinator().completeShippingMethodSelection(WTFMove(update));
488     return { };
489 }
490 
491 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::paymentMethodUpdated()
492 {
493     ASSERT(m_isUpdating);
494     m_isUpdating = false;
495 
496     auto newTotalAndLineItems = computeTotalAndLineItems();
497     if (newTotalAndLineItems.hasException())
498         return newTotalAndLineItems.releaseException();
499 
500     paymentCoordinator().completePaymentMethodSelection(PaymentMethodUpdate { newTotalAndLineItems.releaseReturnValue() });
501     return { };
502 }
503 
504 void ApplePayPaymentHandler::complete(Optional&lt;PaymentComplete&gt;&amp;&amp; result)
505 {
506     if (!result) {
507         ASSERT(isFinalStateResult(WTF::nullopt));
508         paymentCoordinator().completePaymentSession(WTF::nullopt);
509         return;
510     }
511 
512     PaymentAuthorizationResult authorizationResult;
513     switch (*result) {
514     case PaymentComplete::Fail:
515     case PaymentComplete::Unknown:
516         authorizationResult.status = PaymentAuthorizationStatus::Failure;
517         break;
518     case PaymentComplete::Success:
519         authorizationResult.status = PaymentAuthorizationStatus::Success;
520         break;
521     }
522 
523     ASSERT(isFinalStateResult(authorizationResult));
524     paymentCoordinator().completePaymentSession(WTFMove(authorizationResult));
525 }
526 
527 ExceptionOr&lt;void&gt; ApplePayPaymentHandler::retry(PaymentValidationErrors&amp;&amp; validationErrors)
528 {
529     Vector&lt;PaymentError&gt; errors;
530 
531     computeAddressErrors(WTFMove(validationErrors.error), WTFMove(validationErrors.shippingAddress), errors);
532     computePayerErrors(WTFMove(validationErrors.payer), errors);
533 
534     auto exception = computePaymentMethodErrors(validationErrors.paymentMethod.get(), errors);
535     if (exception.hasException())
536         return exception.releaseException();
537 
538     // Ensure there is always at least one error to avoid having a final result.
539     if (errors.isEmpty())
540         errors.append({ PaymentError::Code::Unknown, { }, WTF::nullopt });
541 
542     PaymentAuthorizationResult authorizationResult { PaymentAuthorizationStatus::Failure, WTFMove(errors) };
543     ASSERT(!isFinalStateResult(authorizationResult));
544     paymentCoordinator().completePaymentSession(WTFMove(authorizationResult));
545     return { };
546 }
547 
548 unsigned ApplePayPaymentHandler::version() const
549 {
550     return m_applePayRequest ? m_applePayRequest-&gt;version : 0;
551 }
552 
553 void ApplePayPaymentHandler::validateMerchant(URL&amp;&amp; validationURL)
554 {
555     if (validationURL.isValid())
556         m_paymentRequest-&gt;dispatchEvent(MerchantValidationEvent::create(eventNames().merchantvalidationEvent, WTF::get&lt;URL&gt;(m_identifier).string(), WTFMove(validationURL)).get());
557 }
558 
559 static Ref&lt;PaymentAddress&gt; convert(const ApplePayPaymentContact&amp; contact)
560 {
561     return PaymentAddress::create(contact.countryCode, contact.addressLines.valueOr(Vector&lt;String&gt;()), contact.administrativeArea, contact.locality, contact.subLocality, contact.postalCode, String(), String(), contact.localizedName, contact.phoneNumber);
562 }
563 
564 template&lt;typename T&gt;
565 static JSC::Strong&lt;JSC::JSObject&gt; toJSDictionary(JSC::JSGlobalObject&amp; lexicalGlobalObject, const T&amp; value)
566 {
567     JSC::JSLockHolder lock { &amp;lexicalGlobalObject };
568     return { lexicalGlobalObject.vm(), asObject(toJS&lt;IDLDictionary&lt;T&gt;&gt;(lexicalGlobalObject, *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), value)) };
569 }
570 
571 void ApplePayPaymentHandler::didAuthorizePayment(const Payment&amp; payment)
572 {
573     ASSERT(!m_isUpdating);
574 
575     auto applePayPayment = payment.toApplePayPayment(version());
576     auto shippingContact = applePayPayment.shippingContact.valueOr(ApplePayPaymentContact());
577     auto detailsFunction = [applePayPayment = WTFMove(applePayPayment)](JSC::JSGlobalObject&amp; lexicalGlobalObject) {
578         return toJSDictionary(lexicalGlobalObject, applePayPayment);
579     };
580 
581     m_paymentRequest-&gt;accept(WTF::get&lt;URL&gt;(m_identifier).string(), WTFMove(detailsFunction), convert(shippingContact), shippingContact.localizedName, shippingContact.emailAddress, shippingContact.phoneNumber);
582 }
583 
584 void ApplePayPaymentHandler::didSelectShippingMethod(const ApplePaySessionPaymentRequest::ShippingMethod&amp; shippingMethod)
585 {
586     ASSERT(!m_isUpdating);
587     m_isUpdating = true;
588 
589     m_paymentRequest-&gt;shippingOptionChanged(shippingMethod.identifier);
590 }
591 
592 void ApplePayPaymentHandler::didSelectShippingContact(const PaymentContact&amp; shippingContact)
593 {
594     ASSERT(!m_isUpdating);
595     m_isUpdating = true;
596 
597     m_paymentRequest-&gt;shippingAddressChanged(convert(shippingContact.toApplePayPaymentContact(version())));
598 }
599 
600 void ApplePayPaymentHandler::didSelectPaymentMethod(const PaymentMethod&amp; paymentMethod)
601 {
602     ASSERT(!m_isUpdating);
603     m_isUpdating = true;
604 
605     auto applePayPaymentMethod = paymentMethod.toApplePayPaymentMethod();
606     m_selectedPaymentMethodType = applePayPaymentMethod.type;
607     m_paymentRequest-&gt;paymentMethodChanged(WTF::get&lt;URL&gt;(m_identifier).string(), [applePayPaymentMethod = WTFMove(applePayPaymentMethod)](JSC::JSGlobalObject&amp; lexicalGlobalObject) {
608         return toJSDictionary(lexicalGlobalObject, applePayPaymentMethod);
609     });
610 }
611 
612 void ApplePayPaymentHandler::didCancelPaymentSession(PaymentSessionError&amp;&amp;)
613 {
614     m_paymentRequest-&gt;cancel();
615 }
616 
617 } // namespace WebCore
618 
619 #endif // ENABLE(APPLE_PAY) &amp;&amp; ENABLE(PAYMENT_REQUEST)
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/LinkBuffer.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/LinkBuffer.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/LinkBuffer.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/LinkBuffer.cpp
@@ -31,10 +31,11 @@
 #include "CodeBlock.h"
 #include "Disassembler.h"
 #include "JITCode.h"
 #include "JSCInlines.h"
 #include "Options.h"
+#include "WasmCompilationMode.h"
 #include <wtf/CompilationThread.h>
 
 #if OS(LINUX)
 #include "PerfLog.h"
 #endif
@@ -46,10 +47,26 @@
     if (codeBlock && JITCode::isOptimizingJIT(codeBlock->jitType()) && Options::dumpDFGDisassembly())
         return true;
     return Options::dumpDisassembly();
 }
 
+bool shouldDumpDisassemblyFor(Wasm::CompilationMode mode)
+{
+    if (Options::asyncDisassembly() || Options::dumpDisassembly() || Options::dumpWasmDisassembly())
+        return true;
+    switch (mode) {
+    case Wasm::CompilationMode::BBQMode:
+        return Options::dumpBBQDisassembly();
+    case Wasm::CompilationMode::OMGMode:
+    case Wasm::CompilationMode::OMGForOSREntryMode:
+        return Options::dumpOMGDisassembly();
+    default:
+        break;
+    }
+    return false;
+}
+
 LinkBuffer::CodeRef<LinkBufferPtrTag> LinkBuffer::finalizeCodeWithoutDisassemblyImpl()
 {
     performFinalization();
 
     ASSERT(m_didAllocate);
@@ -191,11 +208,11 @@
                 }
             }
             jumpsToLink[i].setFrom(writePtr);
         }
     } else {
-        if (!ASSERT_DISABLED) {
+        if (ASSERT_ENABLED) {
             for (unsigned i = 0; i < jumpCount; ++i)
                 ASSERT(!MacroAssembler::canCompact(jumpsToLink[i].type()));
         }
     }
 
@@ -226,25 +243,28 @@
     }
 #endif
 
     recordLinkOffsets(m_assemblerStorage, readPtr, initialSize, readPtr - writePtr);
 
-#if CPU(ARM64E) && ENABLE(FAST_JIT_PERMISSIONS)
-    auto memcpyFunction = tagCFunctionPtr<CopyFunctionPtrTag>(memcpy);
-#else
-    auto memcpyFunction = tagCFunctionPtr<CopyFunctionPtrTag>(performJITMemcpy);
-#endif
     for (unsigned i = 0; i < jumpCount; ++i) {
         uint8_t* location = codeOutData + jumpsToLink[i].from();
         uint8_t* target = codeOutData + jumpsToLink[i].to() - executableOffsetFor(jumpsToLink[i].to());
-        MacroAssembler::link(jumpsToLink[i], outData + jumpsToLink[i].from(), location, target, memcpyFunction);
+#if CPU(ARM64E) && ENABLE(FAST_JIT_PERMISSIONS)
+        MacroAssembler::link<memcpy>(jumpsToLink[i], outData + jumpsToLink[i].from(), location, target);
+#else
+        MacroAssembler::link<performJITMemcpy>(jumpsToLink[i], outData + jumpsToLink[i].from(), location, target);
+#endif
     }
 
     size_t compactSize = writePtr + initialSize - readPtr;
     if (!m_executableMemory) {
         size_t nopSizeInBytes = initialSize - compactSize;
-        MacroAssembler::AssemblerType_T::fillNops(outData + compactSize, nopSizeInBytes, memcpy);
+#if CPU(ARM64E) && ENABLE(FAST_JIT_PERMISSIONS)
+        Assembler::fillNops<memcpy>(outData + compactSize, nopSizeInBytes);
+#else
+        Assembler::fillNops<performJITMemcpy>(outData + compactSize, nopSizeInBytes);
+#endif
     }
 
 #if CPU(ARM64E) && ENABLE(FAST_JIT_PERMISSIONS)
     os_thread_self_restrict_rwx_to_rx();
 #endif

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/InterpreterInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/InterpreterInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/InterpreterInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/InterpreterInlines.h
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 2016 Yusuke Suzuki <utatane.tea@gmail.com>
- * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -44,22 +44,22 @@
 
 inline OpcodeID Interpreter::getOpcodeID(Opcode opcode)
 {
 #if ENABLE(COMPUTED_GOTO_OPCODES)
     ASSERT(isOpcode(opcode));
-#if USE(LLINT_EMBEDDED_OPCODE_ID)
+#if ENABLE(LLINT_EMBEDDED_OPCODE_ID)
     // The OpcodeID is embedded in the int32_t word preceding the location of
     // the LLInt code for the opcode (see the EMBED_OPCODE_ID_IF_NEEDED macro
     // in LowLevelInterpreter.cpp).
     auto codePtr = MacroAssemblerCodePtr<BytecodePtrTag>::createFromExecutableAddress(opcode);
     int32_t* opcodeIDAddress = codePtr.dataLocation<int32_t*>() - 1;
     OpcodeID opcodeID = static_cast<OpcodeID>(WTF::unalignedLoad<int32_t>(opcodeIDAddress));
     ASSERT(opcodeID < NUMBER_OF_BYTECODE_IDS);
     return opcodeID;
 #else
     return opcodeIDTable().get(opcode);
-#endif // USE(LLINT_EMBEDDED_OPCODE_ID)
+#endif // ENABLE(LLINT_EMBEDDED_OPCODE_ID)
 
 #else // not ENABLE(COMPUTED_GOTO_OPCODES)
     return opcode;
 #endif
 }
@@ -72,13 +72,13 @@
     ASSERT(!vm.isCollectorBusyOnCurrentThread());
     ASSERT(vm.currentThreadIsHoldingAPILock());
 
     StackStats::CheckPoint stackCheckPoint;
 
-    VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
-    if (UNLIKELY(vm.needTrapHandling(mask))) {
-        vm.handleTraps(closure.oldCallFrame, mask);
+    constexpr auto trapsMask = VMTraps::interruptingTraps();
+    if (UNLIKELY(vm.needTrapHandling(trapsMask))) {
+        vm.handleTraps(closure.protoCallFrame->globalObject, closure.oldCallFrame, trapsMask);
         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
     }
 
     // Execute the code:
     throwScope.release();

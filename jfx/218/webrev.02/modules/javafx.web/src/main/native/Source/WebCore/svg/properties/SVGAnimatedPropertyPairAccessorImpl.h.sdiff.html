<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimatedPropertyPairAccessorImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGAnimatedPropertyAccessorImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimationAdditiveListFunctionImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimatedPropertyPairAccessorImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;SVGAnimatedPropertyAccessorImpl.h&quot;
 29 #include &quot;SVGAnimatedPropertyAnimatorImpl.h&quot;
 30 #include &quot;SVGAnimatedPropertyImpl.h&quot;
 31 #include &quot;SVGAnimatedPropertyPairAccessor.h&quot;
 32 #include &quot;SVGAnimatedPropertyPairAnimatorImpl.h&quot;
 33 #include &quot;SVGNames.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 template&lt;typename OwnerType&gt;
 38 class SVGAnimatedAngleOrientAccessor final : public SVGAnimatedPropertyPairAccessor&lt;OwnerType, SVGAnimatedAngleAccessor&lt;OwnerType&gt;, SVGAnimatedOrientTypeAccessor&lt;OwnerType&gt;&gt; {
 39     using Base = SVGAnimatedPropertyPairAccessor&lt;OwnerType, SVGAnimatedAngleAccessor&lt;OwnerType&gt;, SVGAnimatedOrientTypeAccessor&lt;OwnerType&gt;&gt;;
 40     using Base::property1;
 41     using Base::property2;


 42 
 43 public:
 44     using Base::Base;
 45     template&lt;Ref&lt;SVGAnimatedAngle&gt; OwnerType::*property1, Ref&lt;SVGAnimatedOrientType&gt; OwnerType::*property2&gt;
 46     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedAngleOrientAccessor, property1, property2&gt;(); }
 47 
 48 private:










 49     Optional&lt;String&gt; synchronize(const OwnerType&amp; owner) const final
 50     {
 51         bool dirty1 = property1(owner)-&gt;isDirty();
 52         bool dirty2 = property2(owner)-&gt;isDirty();
 53         if (!(dirty1 || dirty2))
 54             return WTF::nullopt;
 55 
 56         auto type = property2(owner)-&gt;baseVal();
 57 
 58         String string1 = dirty1 ? *property1(owner)-&gt;synchronize() : property1(owner)-&gt;baseValAsString();
 59         String string2 = dirty2 ? *property2(owner)-&gt;synchronize() : property2(owner)-&gt;baseValAsString();
 60         return type == SVGMarkerOrientAuto || type == SVGMarkerOrientAutoStartReverse ? string2 : string1;
 61     }
 62 
 63     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
 64     {
 65         return SVGAnimatedAngleOrientAnimator::create(attributeName, property1(owner), property2(owner), animationMode, calcMode, isAccumulated, isAdditive);
 66     }
 67 
 68     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;SVGAnimatedPropertyAccessorImpl.h&quot;
 29 #include &quot;SVGAnimatedPropertyAnimatorImpl.h&quot;
 30 #include &quot;SVGAnimatedPropertyImpl.h&quot;
 31 #include &quot;SVGAnimatedPropertyPairAccessor.h&quot;
 32 #include &quot;SVGAnimatedPropertyPairAnimatorImpl.h&quot;
 33 #include &quot;SVGNames.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 template&lt;typename OwnerType&gt;
 38 class SVGAnimatedAngleOrientAccessor final : public SVGAnimatedPropertyPairAccessor&lt;OwnerType, SVGAnimatedAngleAccessor&lt;OwnerType&gt;, SVGAnimatedOrientTypeAccessor&lt;OwnerType&gt;&gt; {
 39     using Base = SVGAnimatedPropertyPairAccessor&lt;OwnerType, SVGAnimatedAngleAccessor&lt;OwnerType&gt;, SVGAnimatedOrientTypeAccessor&lt;OwnerType&gt;&gt;;
 40     using Base::property1;
 41     using Base::property2;
<span class="line-added"> 42     using Base::m_accessor1;</span>
<span class="line-added"> 43     using Base::m_accessor2;</span>
 44 
 45 public:
 46     using Base::Base;
 47     template&lt;Ref&lt;SVGAnimatedAngle&gt; OwnerType::*property1, Ref&lt;SVGAnimatedOrientType&gt; OwnerType::*property2&gt;
 48     constexpr static const SVGMemberAccessor&lt;OwnerType&gt;&amp; singleton() { return Base::template singleton&lt;SVGAnimatedAngleOrientAccessor, property1, property2&gt;(); }
 49 
 50 private:
<span class="line-added"> 51     void setDirty(const OwnerType&amp; owner, SVGAnimatedProperty&amp; animatedProperty) const final</span>
<span class="line-added"> 52     {</span>
<span class="line-added"> 53         auto type = property2(owner)-&gt;baseVal();</span>
<span class="line-added"> 54         if (m_accessor1.matches(owner, animatedProperty) &amp;&amp; type != SVGMarkerOrientAngle)</span>
<span class="line-added"> 55             property2(owner)-&gt;setBaseValInternal(SVGMarkerOrientAngle);</span>
<span class="line-added"> 56         else if (m_accessor2.matches(owner, animatedProperty) &amp;&amp; type != SVGMarkerOrientAngle)</span>
<span class="line-added"> 57             property1(owner)-&gt;setBaseValInternal({ });</span>
<span class="line-added"> 58         animatedProperty.setDirty();</span>
<span class="line-added"> 59     }</span>
<span class="line-added"> 60 </span>
 61     Optional&lt;String&gt; synchronize(const OwnerType&amp; owner) const final
 62     {
 63         bool dirty1 = property1(owner)-&gt;isDirty();
 64         bool dirty2 = property2(owner)-&gt;isDirty();
 65         if (!(dirty1 || dirty2))
 66             return WTF::nullopt;
 67 
 68         auto type = property2(owner)-&gt;baseVal();
 69 
 70         String string1 = dirty1 ? *property1(owner)-&gt;synchronize() : property1(owner)-&gt;baseValAsString();
 71         String string2 = dirty2 ? *property2(owner)-&gt;synchronize() : property2(owner)-&gt;baseValAsString();
 72         return type == SVGMarkerOrientAuto || type == SVGMarkerOrientAutoStartReverse ? string2 : string1;
 73     }
 74 
 75     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(OwnerType&amp; owner, const QualifiedName&amp; attributeName, AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive) const final
 76     {
 77         return SVGAnimatedAngleOrientAnimator::create(attributeName, property1(owner), property2(owner), animationMode, calcMode, isAccumulated, isAdditive);
 78     }
 79 
 80     void appendAnimatedInstance(OwnerType&amp; owner, SVGAttributeAnimator&amp; animator) const final
</pre>
</td>
</tr>
</table>
<center><a href="SVGAnimatedPropertyAccessorImpl.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimationAdditiveListFunctionImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebGL2RenderingContext.h&quot;
  28 
  29 #if ENABLE(WEBGL2)
  30 
  31 #include &quot;CachedImage.h&quot;
  32 #include &quot;EXTTextureFilterAnisotropic.h&quot;
  33 #include &quot;EventLoop.h&quot;
  34 #include &quot;ExtensionsGL.h&quot;
  35 #include &quot;HTMLCanvasElement.h&quot;
  36 #include &quot;HTMLImageElement.h&quot;
  37 #include &quot;HTMLVideoElement.h&quot;
  38 #include &quot;ImageData.h&quot;
  39 #include &quot;InspectorInstrumentation.h&quot;
  40 #include &quot;Logging.h&quot;
  41 #include &quot;OESTextureFloat.h&quot;
  42 #include &quot;OESTextureFloatLinear.h&quot;
  43 #include &quot;OESTextureHalfFloat.h&quot;
  44 #include &quot;OESTextureHalfFloatLinear.h&quot;
  45 #include &quot;RenderBox.h&quot;
  46 #include &quot;WebGLActiveInfo.h&quot;
  47 #include &quot;WebGLCompressedTextureASTC.h&quot;
  48 #include &quot;WebGLCompressedTextureATC.h&quot;
  49 #include &quot;WebGLCompressedTextureETC.h&quot;
  50 #include &quot;WebGLCompressedTextureETC1.h&quot;
  51 #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  52 #include &quot;WebGLCompressedTextureS3TC.h&quot;
  53 #include &quot;WebGLDebugRendererInfo.h&quot;
  54 #include &quot;WebGLDebugShaders.h&quot;
  55 #include &quot;WebGLDepthTexture.h&quot;
  56 #include &quot;WebGLLoseContext.h&quot;
  57 #include &quot;WebGLQuery.h&quot;
  58 #include &quot;WebGLSampler.h&quot;
  59 #include &quot;WebGLSync.h&quot;
  60 #include &quot;WebGLTransformFeedback.h&quot;
  61 #include &quot;WebGLVertexArrayObject.h&quot;
  62 #include &lt;JavaScriptCore/GenericTypedArrayViewInlines.h&gt;
  63 #include &lt;JavaScriptCore/HeapInlines.h&gt;
  64 #include &lt;JavaScriptCore/JSGenericTypedArrayViewInlines.h&gt;
  65 #include &lt;JavaScriptCore/TypedArrayType.h&gt;
  66 #include &lt;wtf/IsoMallocInlines.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGL2RenderingContext);
  71 
  72 std::unique_ptr&lt;WebGL2RenderingContext&gt; WebGL2RenderingContext::create(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)
  73 {
  74     auto renderingContext = std::unique_ptr&lt;WebGL2RenderingContext&gt;(new WebGL2RenderingContext(canvas, attributes));
  75 
  76     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  77 
  78     return renderingContext;
  79 }
  80 
  81 std::unique_ptr&lt;WebGL2RenderingContext&gt; WebGL2RenderingContext::create(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)
  82 {
  83     auto renderingContext = std::unique_ptr&lt;WebGL2RenderingContext&gt;(new WebGL2RenderingContext(canvas, WTFMove(context), attributes));
  84 
  85     InspectorInstrumentation::didCreateCanvasRenderingContext(*renderingContext);
  86 
  87     return renderingContext;
  88 }
  89 
  90 WebGL2RenderingContext::WebGL2RenderingContext(CanvasBase&amp; canvas, GraphicsContextGLAttributes attributes)
  91     : WebGLRenderingContextBase(canvas, attributes)
  92 {
  93 }
  94 
  95 WebGL2RenderingContext::WebGL2RenderingContext(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, GraphicsContextGLAttributes attributes)
  96     : WebGLRenderingContextBase(canvas, WTFMove(context), attributes)
  97 {
  98     initializeShaderExtensions();
  99     initializeVertexArrayObjects();
 100     initializeTransformFeedbackBufferCache();
 101     initializeSamplerCache();
 102 }
 103 
 104 WebGL2RenderingContext::~WebGL2RenderingContext()
 105 {
 106     // Remove all references to WebGLObjects so if they are the last reference
 107     // they will be freed before the last context is removed from the context group.
 108     m_boundTransformFeedback = nullptr;
 109     m_boundTransformFeedbackBuffers.clear();
 110     m_activeQueries.clear();
 111 }
 112 
 113 void WebGL2RenderingContext::initializeVertexArrayObjects()
 114 {
 115     m_defaultVertexArrayObject = WebGLVertexArrayObject::create(*this, WebGLVertexArrayObject::Type::Default);
 116     addContextObject(*m_defaultVertexArrayObject);
 117 #if USE(OPENGL_ES)
 118     m_boundVertexArrayObject = m_defaultVertexArrayObject;
 119 #else
 120     bindVertexArray(nullptr); // The default VAO was removed in OpenGL 3.3 but not from WebGL 2; bind the default for WebGL to use.
 121 #endif
 122     if (!isGLES2Compliant())
 123         initVertexAttrib0();
 124 }
 125 
 126 void WebGL2RenderingContext::initializeShaderExtensions()
 127 {
 128     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_OES_standard_derivatives&quot;);
 129     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;);
 130     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_shader_texture_lod&quot;);
 131     m_context-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_frag_depth&quot;);
 132 }
 133 
 134 void WebGL2RenderingContext::initializeTransformFeedbackBufferCache()
 135 {
 136     int maxTransformFeedbackAttribs = getIntParameter(GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);
 137     ASSERT(maxTransformFeedbackAttribs &gt;= 4);
 138 
 139     m_boundTransformFeedbackBuffers.resize(maxTransformFeedbackAttribs);
 140 }
 141 
 142 void WebGL2RenderingContext::initializeSamplerCache()
 143 {
 144     ASSERT(m_textureUnits.size() &gt;= 8);
 145     m_boundSamplers.resize(m_textureUnits.size());
 146 }
 147 
 148 RefPtr&lt;ArrayBufferView&gt; WebGL2RenderingContext::arrayBufferViewSliceFactory(const char* const functionName, const ArrayBufferView&amp; data, unsigned startByte,  unsigned numElements)
 149 {
 150     RefPtr&lt;ArrayBufferView&gt; slice;
 151 
 152     switch (data.getType()) {
 153 #define FACTORY_CASE(type) \
 154     case JSC::Type##type: \
 155         slice = JSC::type##Array::tryCreate(data.possiblySharedBuffer(), startByte, numElements); \
 156         break;
 157 
 158     FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(FACTORY_CASE);
 159 #undef FACTORY_CASE
 160     case JSC::TypeDataView:
 161         slice = Uint8Array::tryCreate(data.possiblySharedBuffer(), startByte, numElements);
 162         break;
 163     default:
 164         ASSERT_NOT_REACHED();
 165         return nullptr;
 166     }
 167 
 168     if (!slice)
 169         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, functionName, &quot;Could not create intermediate ArrayBufferView&quot;);
 170 
 171     return slice;
 172 }
 173 
 174 RefPtr&lt;ArrayBufferView&gt; WebGL2RenderingContext::sliceArrayBufferView(const char* const functionName, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length)
 175 {
 176     if (data.getType() == JSC::NotTypedArray) {
 177         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Invalid type of Array Buffer View&quot;);
 178         return nullptr;
 179     }
 180 
 181     auto elementSize = JSC::elementSize(data.getType());
 182     Checked&lt;GCGLuint, RecordOverflow&gt; checkedElementSize(elementSize);
 183 
 184     Checked&lt;GCGLuint, RecordOverflow&gt; checkedSrcOffset(srcOffset);
 185     Checked&lt;GCGLuint, RecordOverflow&gt; checkedByteSrcOffset = checkedSrcOffset * checkedElementSize;
 186     Checked&lt;GCGLuint, RecordOverflow&gt; checkedLength(length);
 187     Checked&lt;GCGLuint, RecordOverflow&gt; checkedByteLength = checkedLength * checkedElementSize;
 188 
 189     if (checkedByteSrcOffset.hasOverflowed()
 190         || checkedByteLength.hasOverflowed()
 191         || checkedByteSrcOffset.unsafeGet() &gt; data.byteLength()
 192         || checkedByteLength.unsafeGet() &gt; data.byteLength() - checkedByteSrcOffset.unsafeGet()) {
 193         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;srcOffset or length is out of bounds&quot;);
 194         return nullptr;
 195     }
 196 
 197     return arrayBufferViewSliceFactory(functionName, data, data.byteOffset() + checkedByteSrcOffset.unsafeGet(), length);
 198 }
 199 
 200 void WebGL2RenderingContext::bufferData(GCGLenum target, const ArrayBufferView&amp; data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length)
 201 {
 202     if (auto slice = sliceArrayBufferView(&quot;bufferData&quot;, data, srcOffset, length))
 203         WebGLRenderingContextBase::bufferData(target, BufferDataSource(slice.get()), usage);
 204 }
 205 
 206 void WebGL2RenderingContext::bufferSubData(GCGLenum target, long long offset, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length)
 207 {
 208     if (auto slice = sliceArrayBufferView(&quot;bufferSubData&quot;, data, srcOffset, length))
 209         WebGLRenderingContextBase::bufferSubData(target, offset, BufferDataSource(slice.get()));
 210 }
 211 
 212 void WebGL2RenderingContext::copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLint64 readOffset, GCGLint64 writeOffset, GCGLint64 size)
 213 {
 214     if (isContextLostOrPending())
 215         return;
 216     if ((readTarget == GraphicsContextGL::ELEMENT_ARRAY_BUFFER &amp;&amp; writeTarget != GraphicsContextGL::ELEMENT_ARRAY_BUFFER)
 217         || (writeTarget == GraphicsContextGL::ELEMENT_ARRAY_BUFFER &amp;&amp; readTarget != GraphicsContextGL::ELEMENT_ARRAY_BUFFER)) {
 218         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyBufferSubData&quot;, &quot;Either both targets need to be ELEMENT_ARRAY_BUFFER or neither should be ELEMENT_ARRAY_BUFFER.&quot;);
 219         return;
 220     }
 221     if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0) {
 222         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;offset &lt; 0&quot;);
 223         return;
 224     }
 225     RefPtr&lt;WebGLBuffer&gt; readBuffer = validateBufferDataParameters(&quot;copyBufferSubData&quot;, readTarget, GraphicsContextGL::STATIC_DRAW);
 226     RefPtr&lt;WebGLBuffer&gt; writeBuffer = validateBufferDataParameters(&quot;copyBufferSubData&quot;, writeTarget, GraphicsContextGL::STATIC_DRAW);
 227     if (!readBuffer || !writeBuffer) {
 228         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;Invalid readTarget or writeTarget&quot;);
 229         return;
 230     }
 231 
 232     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadOffset(readOffset);
 233     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteOffset(writeOffset);
 234     Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedSize(size);
 235     if (checkedReadOffset.hasOverflowed() || checkedWriteOffset.hasOverflowed() || checkedSize.hasOverflowed()) {
 236         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;Offset or size is too big&quot;);
 237         return;
 238     }
 239 
 240     if (!writeBuffer-&gt;associateCopyBufferSubData(*readBuffer, checkedReadOffset.unsafeGet(), checkedWriteOffset.unsafeGet(), checkedSize.unsafeGet())) {
 241         this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyBufferSubData&quot;, &quot;offset out of range&quot;);
 242         return;
 243     }
 244 
 245     m_context-&gt;moveErrorsToSyntheticErrorList();
 246 #if PLATFORM(COCOA)
 247     m_context-&gt;copyBufferSubData(readTarget, writeTarget, checkedReadOffset.unsafeGet(), checkedWriteOffset.unsafeGet(), checkedSize.unsafeGet());
 248 #endif
 249     if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
 250         // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
 251         writeBuffer-&gt;disassociateBufferData();
 252     }
 253 }
 254 
 255 void WebGL2RenderingContext::getBufferSubData(GCGLenum target, long long srcByteOffset, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; dstData, GCGLuint dstOffset, GCGLuint length)
 256 {
 257     if (isContextLostOrPending())
 258         return;
 259     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContextGL::STATIC_DRAW);
 260     if (!buffer) {
 261         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;No WebGLBuffer is bound to target&quot;);
 262         return;
 263     }
 264 
 265     // FIXME: Implement &quot;If target is TRANSFORM_FEEDBACK_BUFFER, and any transform feedback object is currently active, an INVALID_OPERATION error is generated.&quot;
 266 
 267     if (!dstData) {
 268         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Null dstData&quot;);
 269         return;
 270     }
 271 
 272     if (dstData-&gt;getType() == JSC::NotTypedArray) {
 273         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Invalid type of Array Buffer View&quot;);
 274         return;
 275     }
 276 
 277     auto elementSize = JSC::elementSize(dstData-&gt;getType());
 278     auto dstDataLength = dstData-&gt;byteLength() / elementSize;
 279 
 280     if (dstOffset &gt; dstDataLength) {
 281         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;dstOffset is larger than the length of the destination buffer.&quot;);
 282         return;
 283     }
 284 
 285     GCGLuint copyLength = length ? length : dstDataLength - dstOffset;
 286 
 287     Checked&lt;GCGLuint, RecordOverflow&gt; checkedDstOffset(dstOffset);
 288     Checked&lt;GCGLuint, RecordOverflow&gt; checkedCopyLength(copyLength);
 289     auto checkedDestinationEnd = checkedDstOffset + checkedCopyLength;
 290     if (checkedDestinationEnd.hasOverflowed()) {
 291         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;dstOffset + copyLength is too high&quot;);
 292         return;
 293     }
 294 
 295     if (checkedDestinationEnd.unsafeGet() &gt; dstDataLength) {
 296         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;end of written destination is past the end of the buffer&quot;);
 297         return;
 298     }
 299 
 300     if (srcByteOffset &lt; 0) {
 301         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;srcByteOffset is less than 0&quot;);
 302         return;
 303     }
 304 
 305     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedSrcByteOffset(srcByteOffset);
 306     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedCopyLengthPtr(copyLength);
 307     Checked&lt;GCGLintptr, RecordOverflow&gt; checkedElementSize(elementSize);
 308     auto checkedSourceEnd = checkedSrcByteOffset + checkedCopyLengthPtr * checkedElementSize;
 309     if (checkedSourceEnd.hasOverflowed() || checkedSourceEnd.unsafeGet() &gt; buffer-&gt;byteLength()) {
 310         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Parameters would read outside the bounds of the source buffer&quot;);
 311         return;
 312     }
 313 
 314     m_context-&gt;moveErrorsToSyntheticErrorList();
 315 #if PLATFORM(COCOA)
 316     // FIXME: Coalesce multiple getBufferSubData() calls to use a single map() call
 317     void* ptr = m_context-&gt;mapBufferRange(target, checkedSrcByteOffset.unsafeGet(), static_cast&lt;GCGLsizeiptr&gt;(checkedCopyLengthPtr.unsafeGet() * checkedElementSize.unsafeGet()), GraphicsContextGL::MAP_READ_BIT);
 318     if (ptr)
 319         memcpy(static_cast&lt;char*&gt;(dstData-&gt;baseAddress()) + dstData-&gt;byteOffset() + dstOffset * elementSize, ptr, copyLength * elementSize);
 320 
 321     if (!m_context-&gt;unmapBuffer(target))
 322         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getBufferSubData&quot;, &quot;Failed while unmapping buffer&quot;);
 323 #endif
 324     m_context-&gt;moveErrorsToSyntheticErrorList();
 325 }
 326 
 327 void WebGL2RenderingContext::blitFramebuffer(GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLbitfield, GCGLenum)
 328 {
 329     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] blitFramebuffer()&quot;);
 330 }
 331 
 332 void WebGL2RenderingContext::framebufferTextureLayer(GCGLenum, GCGLenum, WebGLTexture*, GCGLint, GCGLint)
 333 {
 334     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] framebufferTextureLayer()&quot;);
 335 }
 336 
 337 #if !USE(OPENGL_ES)
 338 static bool isRenderableInternalformat(GCGLenum internalformat)
 339 {
 340     // OpenGL ES 3: internalformat must be a color-renderable, depth-renderable, or stencil-renderable format, as shown in Table 1 below.
 341     switch (internalformat) {
 342     case GraphicsContextGL::R8:
 343     case GraphicsContextGL::R8UI:
 344     case GraphicsContextGL::R16UI:
 345     case GraphicsContextGL::R16I:
 346     case GraphicsContextGL::R32UI:
 347     case GraphicsContextGL::R32I:
 348     case GraphicsContextGL::RG8:
 349     case GraphicsContextGL::RG8UI:
 350     case GraphicsContextGL::RG8I:
 351     case GraphicsContextGL::RG16UI:
 352     case GraphicsContextGL::RG16I:
 353     case GraphicsContextGL::RG32UI:
 354     case GraphicsContextGL::RG32I:
 355     case GraphicsContextGL::RGB8:
 356     case GraphicsContextGL::RGB565:
 357     case GraphicsContextGL::RGBA8:
 358     case GraphicsContextGL::SRGB8_ALPHA8:
 359     case GraphicsContextGL::RGB5_A1:
 360     case GraphicsContextGL::RGBA4:
 361     case GraphicsContextGL::RGB10_A2:
 362     case GraphicsContextGL::RGBA8UI:
 363     case GraphicsContextGL::RGBA8I:
 364     case GraphicsContextGL::RGB10_A2UI:
 365     case GraphicsContextGL::RGBA16UI:
 366     case GraphicsContextGL::RGBA16I:
 367     case GraphicsContextGL::RGBA32I:
 368     case GraphicsContextGL::RGBA32UI:
 369     case GraphicsContextGL::DEPTH_COMPONENT16:
 370     case GraphicsContextGL::DEPTH_COMPONENT24:
 371     case GraphicsContextGL::DEPTH_COMPONENT32F:
 372     case GraphicsContextGL::DEPTH24_STENCIL8:
 373     case GraphicsContextGL::DEPTH32F_STENCIL8:
 374     case GraphicsContextGL::STENCIL_INDEX8:
 375         return true;
 376     }
 377     return false;
 378 }
 379 #endif
 380 
 381 WebGLAny WebGL2RenderingContext::getInternalformatParameter(GCGLenum target, GCGLenum internalformat, GCGLenum pname)
 382 {
 383     if (isContextLostOrPending())
 384         return nullptr;
 385 
 386     if (pname != GraphicsContextGL::SAMPLES) {
 387         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid parameter name&quot;);
 388         return nullptr;
 389     }
 390 
 391     int numValues = 0;
 392 #if USE(OPENGL_ES)
 393     m_context-&gt;getInternalformativ(target, internalformat, GraphicsContextGL::NUM_SAMPLE_COUNTS, 1, &amp;numValues);
 394 
 395     GCGLint params[numValues];
 396     m_context-&gt;getInternalformativ(target, internalformat, pname, numValues, params);
 397 #else
 398     // On desktop OpenGL 4.1 or below we must emulate glGetInternalformativ.
 399 
 400     // GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER.
 401     if (target != GraphicsContextGL::RENDERBUFFER) {
 402         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid target&quot;);
 403         return nullptr;
 404     }
 405 
 406     // GL_INVALID_ENUM is generated if internalformat is not color-, depth-, or stencil-renderable.
 407     if (!isRenderableInternalformat(internalformat)) {
 408         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getInternalformatParameter&quot;, &quot;invalid internal format&quot;);
 409         return nullptr;
 410     }
 411 
 412     Vector&lt;GCGLint&gt; samples;
 413     // The way I understand this is that this will return a MINIMUM numSamples for all accepeted internalformats.
 414     // However, the true value of this on supported GL versions is gleaned via a getInternalformativ call that depends on internalformat.
 415     int numSamplesMask = getIntParameter(GraphicsContextGL::MAX_SAMPLES);
 416 
 417     while (numSamplesMask &gt; 0) {
 418         samples.append(numSamplesMask);
 419         numSamplesMask = numSamplesMask &gt;&gt; 1;
 420     }
 421 
 422     // Since multisampling is not supported for signed and unsigned integer internal formats,
 423     // the value of GL_NUM_SAMPLE_COUNTS will be zero for such formats.
 424     numValues = isIntegerFormat(internalformat) ? 0 : samples.size();
 425     GCGLint params[numValues];
 426     for (size_t i = 0; i &lt; samples.size(); ++i)
 427         params[i] = samples[i];
 428 #endif
 429 
 430     return Int32Array::tryCreate(params, numValues);
 431 }
 432 
 433 void WebGL2RenderingContext::invalidateFramebuffer(GCGLenum, const Vector&lt;GCGLenum&gt;&amp;)
 434 {
 435     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] invalidateFramebuffer()&quot;);
 436 }
 437 
 438 void WebGL2RenderingContext::invalidateSubFramebuffer(GCGLenum, const Vector&lt;GCGLenum&gt;&amp;, GCGLint, GCGLint, GCGLsizei, GCGLsizei)
 439 {
 440     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] invalidateSubFramebuffer()&quot;);
 441 }
 442 
 443 void WebGL2RenderingContext::readBuffer(GCGLenum)
 444 {
 445     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] readBuffer()&quot;);
 446 }
 447 
 448 void WebGL2RenderingContext::renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
 449 {
 450     // To be backward compatible with WebGL 1, also accepts internal format DEPTH_STENCIL,
 451     // which should be mapped to DEPTH24_STENCIL8 by implementations.
 452     if (internalformat == GraphicsContextGL::DEPTH_STENCIL)
 453         internalformat = GraphicsContextGL::DEPTH24_STENCIL8;
 454 
 455     // ES 3: GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than 0.
 456     if (isIntegerFormat(internalformat) &amp;&amp; samples &gt; 0) {
 457         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;renderbufferStorageMultisample&quot;, &quot;multisampling not supported for this format&quot;);
 458         return;
 459     }
 460 
 461     switch (internalformat) {
 462     case GraphicsContextGL::DEPTH_COMPONENT16:
 463     case GraphicsContextGL::DEPTH_COMPONENT32F:
 464     case GraphicsContextGL::DEPTH_COMPONENT24:
 465     case GraphicsContextGL::RGBA32I:
 466     case GraphicsContextGL::RGBA32UI:
 467     case GraphicsContextGL::RGBA16I:
 468     case GraphicsContextGL::RGBA16UI:
 469     case GraphicsContextGL::RGBA8:
 470     case GraphicsContextGL::RGBA8I:
 471     case GraphicsContextGL::RGBA8UI:
 472     case GraphicsContextGL::RGB10_A2:
 473     case GraphicsContextGL::RGB10_A2UI:
 474     case GraphicsContextGL::RGBA4:
 475     case GraphicsContextGL::RG32I:
 476     case GraphicsContextGL::RG32UI:
 477     case GraphicsContextGL::RG16I:
 478     case GraphicsContextGL::RG16UI:
 479     case GraphicsContextGL::RG8:
 480     case GraphicsContextGL::RG8I:
 481     case GraphicsContextGL::RG8UI:
 482     case GraphicsContextGL::R32I:
 483     case GraphicsContextGL::R32UI:
 484     case GraphicsContextGL::R16I:
 485     case GraphicsContextGL::R16UI:
 486     case GraphicsContextGL::R8:
 487     case GraphicsContextGL::R8I:
 488     case GraphicsContextGL::R8UI:
 489     case GraphicsContextGL::RGB5_A1:
 490     case GraphicsContextGL::RGB565:
 491     case GraphicsContextGL::RGB8:
 492     case GraphicsContextGL::STENCIL_INDEX8:
 493     case GraphicsContextGL::SRGB8_ALPHA8:
 494         m_context-&gt;renderbufferStorageMultisample(target, samples, internalformat, width, height);
 495         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
 496         m_renderbufferBinding-&gt;setIsValid(true);
 497         m_renderbufferBinding-&gt;setSize(width, height);
 498         break;
 499     case GraphicsContextGL::DEPTH32F_STENCIL8:
 500     case GraphicsContextGL::DEPTH24_STENCIL8:
 501         if (!isDepthStencilSupported()) {
 502             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
 503             return;
 504         }
 505         m_context-&gt;renderbufferStorageMultisample(target, samples, internalformat, width, height);
 506         m_renderbufferBinding-&gt;setSize(width, height);
 507         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
 508         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
 509         break;
 510     default:
 511         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
 512         return;
 513     }
 514     applyStencilTest();
 515 }
 516 
 517 bool WebGL2RenderingContext::validateTexStorageFuncParameters(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, const char* functionName)
 518 {
 519     if (width &lt; 0 || height &lt; 0) {
 520         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);
 521         return false;
 522     }
 523 
 524     if (width &gt; m_maxTextureSize || height &gt; m_maxTextureSize) {
 525         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;texture dimensions are larger than the maximum texture size&quot;);
 526         return false;
 527     }
 528 
 529     if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {
 530         if (width != height) {
 531             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);
 532             return false;
 533         }
 534     } else if (target != GraphicsContextGL::TEXTURE_2D) {
 535         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);
 536         return false;
 537     }
 538 
 539     if (levels &lt; 0 || levels &gt; m_maxTextureLevel) {
 540         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;number of levels is out of bounds&quot;);
 541         return false;
 542     }
 543 
 544     switch (internalFormat) {
 545     case GraphicsContextGL::R8:
 546     case GraphicsContextGL::R8_SNORM:
 547     case GraphicsContextGL::R16F:
 548     case GraphicsContextGL::R32F:
 549     case GraphicsContextGL::R8UI:
 550     case GraphicsContextGL::R8I:
 551     case GraphicsContextGL::R16UI:
 552     case GraphicsContextGL::R16I:
 553     case GraphicsContextGL::R32UI:
 554     case GraphicsContextGL::R32I:
 555     case GraphicsContextGL::RG8:
 556     case GraphicsContextGL::RG8_SNORM:
 557     case GraphicsContextGL::RG16F:
 558     case GraphicsContextGL::RG32F:
 559     case GraphicsContextGL::RG8UI:
 560     case GraphicsContextGL::RG8I:
 561     case GraphicsContextGL::RG16UI:
 562     case GraphicsContextGL::RG16I:
 563     case GraphicsContextGL::RG32UI:
 564     case GraphicsContextGL::RG32I:
 565     case GraphicsContextGL::RGB8:
 566     case GraphicsContextGL::SRGB8:
 567     case GraphicsContextGL::RGB565:
 568     case GraphicsContextGL::RGB8_SNORM:
 569     case GraphicsContextGL::R11F_G11F_B10F:
 570     case GraphicsContextGL::RGB9_E5:
 571     case GraphicsContextGL::RGB16F:
 572     case GraphicsContextGL::RGB32F:
 573     case GraphicsContextGL::RGB8UI:
 574     case GraphicsContextGL::RGB8I:
 575     case GraphicsContextGL::RGB16UI:
 576     case GraphicsContextGL::RGB16I:
 577     case GraphicsContextGL::RGB32UI:
 578     case GraphicsContextGL::RGB32I:
 579     case GraphicsContextGL::RGBA8:
 580     case GraphicsContextGL::SRGB8_ALPHA8:
 581     case GraphicsContextGL::RGBA8_SNORM:
 582     case GraphicsContextGL::RGB5_A1:
 583     case GraphicsContextGL::RGBA4:
 584     case GraphicsContextGL::RGB10_A2:
 585     case GraphicsContextGL::RGBA16F:
 586     case GraphicsContextGL::RGBA32F:
 587     case GraphicsContextGL::RGBA8UI:
 588     case GraphicsContextGL::RGBA8I:
 589     case GraphicsContextGL::RGB10_A2UI:
 590     case GraphicsContextGL::RGBA16UI:
 591     case GraphicsContextGL::RGBA16I:
 592     case GraphicsContextGL::RGBA32I:
 593     case GraphicsContextGL::RGBA32UI:
 594     case GraphicsContextGL::DEPTH_COMPONENT16:
 595     case GraphicsContextGL::DEPTH_COMPONENT24:
 596     case GraphicsContextGL::DEPTH_COMPONENT32F:
 597     case GraphicsContextGL::DEPTH24_STENCIL8:
 598     case GraphicsContextGL::DEPTH32F_STENCIL8:
 599         break;
 600     default:
 601         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;Unknown internalFormat&quot;);
 602         return false;
 603     }
 604 
 605     return true;
 606 }
 607 
 608 void WebGL2RenderingContext::texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height)
 609 {
 610     if (isContextLostOrPending())
 611         return;
 612 
 613     auto texture = validateTextureBinding(&quot;texStorage2D&quot;, target, false);
 614     if (!texture)
 615         return;
 616 
 617     if (!validateTexStorageFuncParameters(target, levels, internalFormat, width, height, &quot;texStorage2D&quot;))
 618         return;
 619 
 620     if (!validateNPOTTextureLevel(width, height, levels, &quot;texStorage2D&quot;))
 621         return;
 622 
 623     if (texture-&gt;immutable()) {
 624         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;texStorage2D&quot;, &quot;texStorage2D already called on this texture&quot;);
 625         return;
 626     }
 627     texture-&gt;setImmutable();
 628 
 629     m_context-&gt;texStorage2D(target, levels, internalFormat, width, height);
 630 
 631     {
 632         GCGLenum format;
 633         GCGLenum type;
 634         if (!GraphicsContextGLOpenGL::possibleFormatAndTypeForInternalFormat(internalFormat, format, type)) {
 635             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texStorage2D&quot;, &quot;Texture has unknown internal format&quot;);
 636             return;
 637         }
 638 
 639         GCGLsizei levelWidth = width;
 640         GCGLsizei levelHeight = height;
 641 
 642         unsigned size;
 643         GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);
 644         if (error != GraphicsContextGL::NO_ERROR) {
 645             synthesizeGLError(error, &quot;texStorage2D&quot;, &quot;bad dimensions&quot;);
 646             return;
 647         }
 648 
 649         Vector&lt;char&gt; data(size);
 650         memset(data.data(), 0, size);
 651 
 652         for (GCGLsizei level = 0; level &lt; levels; ++level) {
 653             if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {
 654                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 655                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 656                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 657                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 658                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 659                 m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 660             } else
 661                 m_context-&gt;texSubImage2D(target, level, 0, 0, levelWidth, levelHeight, format, type, data.data());
 662             levelWidth = std::max(1, levelWidth / 2);
 663             levelHeight = std::max(1, levelHeight / 2);
 664         }
 665     }
 666 
 667     for (GCGLsizei level = 0; level &lt; levels; ++level) {
 668         if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {
 669             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
 670             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
 671             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
 672             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
 673             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
 674             texture-&gt;setLevelInfo(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
 675         } else
 676             texture-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);
 677     }
 678 }
 679 
 680 void WebGL2RenderingContext::texStorage3D(GCGLenum, GCGLsizei, GCGLenum, GCGLsizei, GCGLsizei, GCGLsizei)
 681 {
 682     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texStorage3D()&quot;);
 683 }
 684 
 685 void WebGL2RenderingContext::texImage2D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, GCGLintptr)
 686 {
 687     // Covered by textures/misc/tex-unpack-params.html.
 688     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage2D(PIXEL_UNPACK_BUFFER)&quot;);
 689 }
 690 
 691 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texImage2D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)
 692 {
 693     // Covered by textures/misc/origin-clean-conformance-offscreencanvas.html?
 694     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage2D(TexImageSource)&quot;);
 695     return { };
 696 }
 697 
 698 RefPtr&lt;ArrayBufferView&gt; WebGL2RenderingContext::sliceTypedArrayBufferView(const char* const functionName, RefPtr&lt;ArrayBufferView&gt;&amp; srcData, GCGLuint srcOffset)
 699 {
 700     if (!srcData)
 701         return nullptr;
 702 
 703     if (!isTypedView(srcData-&gt;getType())) {
 704         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Invalid type of ArrayBufferView&quot;);
 705         return nullptr;
 706     }
 707 
 708     auto elementSize = JSC::elementSize(srcData-&gt;getType());
 709     auto startingByte = WTF::checkedProduct&lt;unsigned&gt;(elementSize, srcOffset);
 710     if (startingByte.hasOverflowed() || startingByte &gt;= srcData-&gt;byteLength()) {
 711         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Invalid element offset!&quot;);
 712         return nullptr;
 713     }
 714 
 715     auto numElements = (srcData-&gt;byteLength() - startingByte.unsafeGet()) / elementSize;
 716 
 717     return arrayBufferViewSliceFactory(functionName, *srcData, startingByte.unsafeGet(), numElements);
 718 }
 719 
 720 void WebGL2RenderingContext::texImage2D(GCGLenum target, GCGLint level, GCGLint internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset)
 721 {
 722     if (isContextLostOrPending())
 723         return;
 724 
 725     auto slicedData = sliceTypedArrayBufferView(&quot;texImage2D&quot;, srcData, srcOffset);
 726 
 727     WebGLRenderingContextBase::texImage2D(target, level, internalFormat, width, height, border, format, type, WTFMove(slicedData));
 728 }
 729 
 730 void WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, GCGLint64)
 731 {
 732     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(PIXEL_UNPACK_BUFFER)&quot;);
 733 }
 734 
 735 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)
 736 {
 737     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(TexImageSource)&quot;);
 738     return { };
 739 }
 740 
 741 void WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;)
 742 {
 743     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(ArrayBufferView?)&quot;);
 744 }
 745 
 746 void WebGL2RenderingContext::texImage3D(GCGLenum, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLenum, GCGLenum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GCGLuint)
 747 {
 748     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texImage3D(ArrayBufferView, srcOffset)&quot;);
 749 }
 750 
 751 void WebGL2RenderingContext::texSubImage2D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, GCGLintptr)
 752 {
 753     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage2D(PIXEL_UNPACK_BUFFER)&quot;);
 754 }
 755 
 756 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texSubImage2D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)
 757 {
 758     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage2D(TexImageSource)&quot;);
 759     return { };
 760 }
 761 
 762 void WebGL2RenderingContext::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset)
 763 {
 764     if (isContextLostOrPending())
 765         return;
 766 
 767     auto slicedData = sliceTypedArrayBufferView(&quot;texSubImage2D&quot;, srcData, srcOffset);
 768 
 769     WebGLRenderingContextBase::texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, WTFMove(slicedData));
 770 }
 771 
 772 void WebGL2RenderingContext::texSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, GCGLint64)
 773 {
 774     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D(PIXEL_UNPACK_BUFFER)&quot;);
 775 }
 776 
 777 void WebGL2RenderingContext::texSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;, GCGLuint)
 778 {
 779     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D(ArrayBufferView, srcOffset)&quot;);
 780 }
 781 
 782 ExceptionOr&lt;void&gt; WebGL2RenderingContext::texSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, TexImageSource&amp;&amp;)
 783 {
 784     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] texSubImage3D(TexImageSource)&quot;);
 785     return { };
 786 }
 787 
 788 void WebGL2RenderingContext::copyTexSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei)
 789 {
 790     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] copyTexSubImage3D()&quot;);
 791 }
 792 
 793 void WebGL2RenderingContext::compressedTexImage3D(GCGLenum, GCGLint, GCGLenum, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, GCGLsizei, GCGLint64)
 794 {
 795     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage3D(PIXEL_UNPACK_BUFFER)&quot;);
 796 }
 797 
 798 void WebGL2RenderingContext::compressedTexImage3D(GCGLenum, GCGLint, GCGLenum, GCGLsizei, GCGLsizei, GCGLsizei, GCGLint, ArrayBufferView&amp;, GCGLuint, GCGLuint)
 799 {
 800     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage3D(ArrayBufferView)&quot;);
 801 }
 802 
 803 void WebGL2RenderingContext::compressedTexSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, GCGLsizei, GCGLint64)
 804 {
 805     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage3D(PIXEL_UNPACK_BUFFER)&quot;);
 806 }
 807 
 808 void WebGL2RenderingContext::compressedTexSubImage3D(GCGLenum, GCGLint, GCGLint, GCGLint, GCGLint, GCGLsizei, GCGLsizei, GCGLsizei, GCGLenum, ArrayBufferView&amp;, GCGLuint, GCGLuint)
 809 {
 810     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage3D(ArrayBufferView)&quot;);
 811 }
 812 
 813 GCGLint WebGL2RenderingContext::getFragDataLocation(WebGLProgram&amp;, const String&amp;)
 814 {
 815     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getFragDataLocation()&quot;);
 816     return 0;
 817 }
 818 
 819 void WebGL2RenderingContext::uniform1ui(WebGLUniformLocation*, GCGLuint)
 820 {
 821     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1ui()&quot;);
 822 }
 823 
 824 void WebGL2RenderingContext::uniform2ui(WebGLUniformLocation*, GCGLuint, GCGLuint)
 825 {
 826     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2ui()&quot;);
 827 }
 828 
 829 void WebGL2RenderingContext::uniform3ui(WebGLUniformLocation*, GCGLuint, GCGLuint, GCGLuint)
 830 {
 831     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3ui()&quot;);
 832 }
 833 
 834 void WebGL2RenderingContext::uniform4ui(WebGLUniformLocation*, GCGLuint, GCGLuint, GCGLuint, GCGLuint)
 835 {
 836     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4ui()&quot;);
 837 }
 838 
 839 void WebGL2RenderingContext::uniform1uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)
 840 {
 841     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1uiv()&quot;);
 842 }
 843 
 844 void WebGL2RenderingContext::uniform2uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)
 845 {
 846     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2uiv()&quot;);
 847 }
 848 
 849 void WebGL2RenderingContext::uniform3uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)
 850 {
 851     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3uiv()&quot;);
 852 }
 853 
 854 void WebGL2RenderingContext::uniform4uiv(WebGLUniformLocation*, Uint32List&amp;&amp;, GCGLuint, GCGLuint)
 855 {
 856     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4uiv()&quot;);
 857 }
 858 
 859 void WebGL2RenderingContext::uniformMatrix2x3fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)
 860 {
 861     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2x3fv()&quot;);
 862 }
 863 
 864 void WebGL2RenderingContext::uniformMatrix3x2fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)
 865 {
 866     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3x2fv()&quot;);
 867 }
 868 
 869 void WebGL2RenderingContext::uniformMatrix2x4fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)
 870 {
 871     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2x4fv()&quot;);
 872 }
 873 
 874 void WebGL2RenderingContext::uniformMatrix4x2fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)
 875 {
 876     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4x2fv()&quot;);
 877 }
 878 
 879 void WebGL2RenderingContext::uniformMatrix3x4fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)
 880 {
 881     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3x4fv()&quot;);
 882 }
 883 
 884 void WebGL2RenderingContext::uniformMatrix4x3fv(WebGLUniformLocation*, GCGLboolean, Float32List&amp;&amp;, GCGLuint, GCGLuint)
 885 {
 886     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4x3fv()&quot;);
 887 }
 888 
 889 void WebGL2RenderingContext::vertexAttribI4i(GCGLuint, GCGLint, GCGLint, GCGLint, GCGLint)
 890 {
 891     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4i()&quot;);
 892 }
 893 
 894 void WebGL2RenderingContext::vertexAttribI4iv(GCGLuint, Int32List&amp;&amp;)
 895 {
 896     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4iv()&quot;);
 897 }
 898 
 899 void WebGL2RenderingContext::vertexAttribI4ui(GCGLuint, GCGLuint, GCGLuint, GCGLuint, GCGLuint)
 900 {
 901     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4ui()&quot;);
 902 }
 903 
 904 void WebGL2RenderingContext::vertexAttribI4uiv(GCGLuint, Uint32List&amp;&amp;)
 905 {
 906     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] vertexAttribI4uiv()&quot;);
 907 }
 908 
 909 void WebGL2RenderingContext::vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLint64 offset)
 910 {
 911     if (isContextLostOrPending())
 912         return;
 913 
 914     m_context-&gt;vertexAttribIPointer(index, size, type, stride, offset);
 915 }
 916 
 917 void WebGL2RenderingContext::clear(GCGLbitfield mask)
 918 {
 919     if (isContextLostOrPending())
 920         return;
 921     if (mask &amp; ~(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT)) {
 922         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clear&quot;, &quot;invalid mask&quot;);
 923         return;
 924     }
 925     const char* reason = &quot;framebuffer incomplete&quot;;
 926     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {
 927         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;clear&quot;, reason);
 928         return;
 929     }
 930     if (m_framebufferBinding &amp;&amp; (mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT) &amp;&amp; isIntegerFormat(m_framebufferBinding-&gt;getColorBufferFormat())) {
 931         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clear&quot;, &quot;cannot clear an integer buffer&quot;);
 932         return;
 933     }
 934     if (!clearIfComposited(mask))
 935         m_context-&gt;clear(mask);
 936     markContextChangedAndNotifyCanvasObserver();
 937 }
 938 
 939 void WebGL2RenderingContext::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)
 940 {
 941     if (isContextLostOrPending())
 942         return;
 943 
 944     WebGLRenderingContextBase::vertexAttribDivisor(index, divisor);
 945 }
 946 
 947 void WebGL2RenderingContext::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei instanceCount)
 948 {
 949     if (isContextLostOrPending())
 950         return;
 951 
 952     WebGLRenderingContextBase::drawArraysInstanced(mode, first, count, instanceCount);
 953 }
 954 
 955 void WebGL2RenderingContext::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLint64 offset, GCGLsizei instanceCount)
 956 {
 957     if (isContextLostOrPending())
 958         return;
 959 
 960     WebGLRenderingContextBase::drawElementsInstanced(mode, count, type, offset, instanceCount);
 961 }
 962 
 963 void WebGL2RenderingContext::drawRangeElements(GCGLenum, GCGLuint, GCGLuint, GCGLsizei, GCGLenum, GCGLint64)
 964 {
 965     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] drawRangeElements()&quot;);
 966 }
 967 
 968 void WebGL2RenderingContext::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers)
 969 {
 970     if (isContextLost())
 971         return;
 972     GCGLsizei n = buffers.size();
 973     const GCGLenum* bufs = buffers.data();
 974     if (!m_framebufferBinding) {
 975         if (n != 1) {
 976             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffers&quot;, &quot;more than one buffer&quot;);
 977             return;
 978         }
 979         if (bufs[0] != GraphicsContextGL::BACK &amp;&amp; bufs[0] != GraphicsContextGL::NONE) {
 980             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffers&quot;, &quot;BACK or NONE&quot;);
 981             return;
 982         }
 983         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
 984         GCGLenum value = (bufs[0] == GraphicsContextGL::BACK) ? GraphicsContextGL::COLOR_ATTACHMENT0 : GraphicsContextGL::NONE;
 985         graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);
 986         setBackDrawBuffer(bufs[0]);
 987     } else {
 988         if (n &gt; getMaxDrawBuffers()) {
 989             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffers&quot;, &quot;more than max draw buffers&quot;);
 990             return;
 991         }
 992         for (GCGLsizei i = 0; i &lt; n; ++i) {
 993             if (bufs[i] != GraphicsContextGL::NONE &amp;&amp; bufs[i] != static_cast&lt;GCGLenum&gt;(GraphicsContextGL::COLOR_ATTACHMENT0 + i)) {
 994                 synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffers&quot;, &quot;COLOR_ATTACHMENTi or NONE&quot;);
 995                 return;
 996             }
 997         }
 998         m_framebufferBinding-&gt;drawBuffers(buffers);
 999     }
1000 }
1001 
1002 void WebGL2RenderingContext::clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, Int32List&amp;&amp;, GCGLuint)
1003 {
1004     switch (buffer) {
1005     case GraphicsContextGL::COLOR:
1006         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
1007             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferiv&quot;, &quot;buffer index out of range&quot;);
1008             return;
1009         }
1010         // TODO: Call clearBufferiv, requires gl3.h and ES3/gl.h
1011         break;
1012     case GraphicsContextGL::STENCIL:
1013         if (drawbuffer) {
1014             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferiv&quot;, &quot;buffer index must be 0&quot;);
1015             return;
1016         }
1017         // TODO: Call clearBufferiv, requires gl3.h and ES3/gl.h
1018         break;
1019     case GraphicsContextGL::DEPTH:
1020     case GraphicsContextGL::DEPTH_STENCIL:
1021     default:
1022         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferiv&quot;, &quot;buffer argument must be COLOR or STENCIL&quot;);
1023         break;
1024     }
1025 }
1026 
1027 void WebGL2RenderingContext::clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, Uint32List&amp;&amp;, GCGLuint)
1028 {
1029     switch (buffer) {
1030     case GraphicsContextGL::COLOR:
1031         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
1032             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferuiv&quot;, &quot;buffer index out of range&quot;);
1033             return;
1034         }
1035         // TODO: Call clearBufferuiv, requires gl3.h and ES3/gl.h
1036         break;
1037     case GraphicsContextGL::DEPTH:
1038     case GraphicsContextGL::STENCIL:
1039     case GraphicsContextGL::DEPTH_STENCIL:
1040     default:
1041         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferuiv&quot;, &quot;buffer argument must be COLOR&quot;);
1042         break;
1043     }
1044 }
1045 
1046 void WebGL2RenderingContext::clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, Float32List&amp;&amp;, GCGLuint)
1047 {
1048     switch (buffer) {
1049     case GraphicsContextGL::COLOR:
1050         if (drawbuffer &lt; 0 || drawbuffer &gt;= getMaxDrawBuffers()) {
1051             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index out of range&quot;);
1052             return;
1053         }
1054         // TODO: Call clearBufferfv, requires gl3.h and ES3/gl.h
1055         break;
1056     case GraphicsContextGL::DEPTH:
1057         if (drawbuffer) {
1058             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index must be 0&quot;);
1059             return;
1060         }
1061         // TODO: Call clearBufferfv, requires gl3.h and ES3/gl.h
1062         break;
1063     case GraphicsContextGL::STENCIL:
1064     case GraphicsContextGL::DEPTH_STENCIL:
1065     default:
1066         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferfv&quot;, &quot;buffer argument must be COLOR OR DEPTH&quot;);
1067         break;
1068     }
1069 }
1070 
1071 void WebGL2RenderingContext::clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat, GCGLint)
1072 {
1073     switch (buffer) {
1074     case GraphicsContextGL::DEPTH_STENCIL:
1075         if (drawbuffer) {
1076             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;clearBufferfv&quot;, &quot;buffer index must be 0&quot;);
1077             return;
1078         }
1079         // TODO: Call clearBufferfi, requires gl3.h and ES3/gl.h
1080         break;
1081     case GraphicsContextGL::COLOR:
1082     case GraphicsContextGL::DEPTH:
1083     case GraphicsContextGL::STENCIL:
1084     default:
1085         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;clearBufferfv&quot;, &quot;buffer argument must be DEPTH_STENCIL&quot;);
1086         break;
1087     }
1088 }
1089 
1090 RefPtr&lt;WebGLQuery&gt; WebGL2RenderingContext::createQuery()
1091 {
1092     if (isContextLostOrPending())
1093         return nullptr;
1094 
1095     auto query = WebGLQuery::create(*this);
1096     addSharedObject(query.get());
1097     return query;
1098 }
1099 
1100 void WebGL2RenderingContext::deleteQuery(WebGLQuery*)
1101 {
1102     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteQuery()&quot;);
1103 }
1104 
1105 GCGLboolean WebGL2RenderingContext::isQuery(WebGLQuery*)
1106 {
1107     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isQuery()&quot;);
1108     return false;
1109 }
1110 
1111 void WebGL2RenderingContext::beginQuery(GCGLenum target, WebGLQuery&amp; query)
1112 {
1113     if (isContextLostOrPending())
1114         return;
1115 
1116     // FIXME: Add validation to prevent bad caching.
1117 
1118     // Only one query object can be active per target.
1119     auto targetKey = (target == GraphicsContextGL::ANY_SAMPLES_PASSED_CONSERVATIVE) ? GraphicsContextGL::ANY_SAMPLES_PASSED : target;
1120 
1121     auto addResult = m_activeQueries.add(targetKey, makeRefPtr(&amp;query));
1122 
1123     if (!addResult.isNewEntry) {
1124         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;beginQuery&quot;, &quot;Query object of target is already active&quot;);
1125         return;
1126     }
1127 
1128     m_context-&gt;beginQuery(target, query.object());
1129 }
1130 
1131 void WebGL2RenderingContext::endQuery(GCGLenum target)
1132 {
1133     if (isContextLostOrPending() || !scriptExecutionContext())
1134         return;
1135 
1136     auto targetKey = (target == GraphicsContextGL::ANY_SAMPLES_PASSED_CONSERVATIVE) ? GraphicsContextGL::ANY_SAMPLES_PASSED : target;
1137 
1138     auto query = m_activeQueries.take(targetKey);
1139     if (!query) {
1140         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;endQuery&quot;, &quot;Query object of target is not active&quot;);
1141         return;
1142     }
1143 
1144     m_context-&gt;endQuery(target);
1145 
1146     // A query&#39;s result must not be made available until control has returned to the user agent&#39;s main loop.
1147     scriptExecutionContext()-&gt;eventLoop().queueMicrotask([query] {
1148         query-&gt;makeResultAvailable();
1149     });
1150 }
1151 
1152 RefPtr&lt;WebGLQuery&gt; WebGL2RenderingContext::getQuery(GCGLenum, GCGLenum)
1153 {
1154     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getquery()&quot;);
1155     return nullptr;
1156 }
1157 
1158 WebGLAny WebGL2RenderingContext::getQueryParameter(WebGLQuery&amp; query, GCGLenum pname)
1159 {
1160     if (isContextLostOrPending())
1161         return nullptr;
1162 
1163     switch (pname) {
1164     case GraphicsContextGL::QUERY_RESULT:
1165     case GraphicsContextGL::QUERY_RESULT_AVAILABLE:
1166         if (!query.isResultAvailable())
1167             return 0;
1168         break;
1169     default:
1170         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getQueryParameter&quot;, &quot;Invalid pname&quot;);
1171         return nullptr;
1172     }
1173 
1174     unsigned result = 0;
1175     m_context-&gt;getQueryObjectuiv(query.object(), pname, &amp;result);
1176     return result;
1177 }
1178 
1179 RefPtr&lt;WebGLSampler&gt; WebGL2RenderingContext::createSampler()
1180 {
1181     if (isContextLostOrPending())
1182         return nullptr;
1183 
1184     auto sampler = WebGLSampler::create(*this);
1185     addSharedObject(sampler.get());
1186     return sampler;
1187 }
1188 
1189 void WebGL2RenderingContext::deleteSampler(WebGLSampler* sampler)
1190 {
1191     if (isContextLostOrPending())
1192         return;
1193 
1194     // One sampler can be bound to multiple texture units.
1195     if (sampler) {
1196         for (auto&amp; samplerSlot : m_boundSamplers) {
1197             if (samplerSlot == sampler)
1198                 samplerSlot = nullptr;
1199         }
1200     }
1201 
1202     deleteObject(sampler);
1203 }
1204 
1205 GCGLboolean WebGL2RenderingContext::isSampler(WebGLSampler* sampler)
1206 {
1207     if (isContextLostOrPending() || !sampler || sampler-&gt;isDeleted() || !validateWebGLObject(&quot;isSampler&quot;, sampler))
1208         return false;
1209 
1210     return m_context-&gt;isSampler(sampler-&gt;object());
1211 }
1212 
1213 void WebGL2RenderingContext::bindSampler(GCGLuint unit, WebGLSampler* sampler)
1214 {
1215     if (isContextLostOrPending() || m_boundSamplers[unit] == sampler)
1216         return;
1217 
1218     if (sampler &amp;&amp; sampler-&gt;isDeleted()) {
1219         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindSampler&quot;, &quot;cannot bind a deleted Sampler object&quot;);
1220         return;
1221     }
1222 
1223     m_context-&gt;bindSampler(unit, objectOrZero(sampler));
1224     m_boundSamplers[unit] = sampler;
1225 }
1226 
1227 void WebGL2RenderingContext::samplerParameteri(WebGLSampler&amp; sampler, GCGLenum pname, GCGLint value)
1228 {
1229     if (isContextLostOrPending())
1230         return;
1231 
1232     m_context-&gt;samplerParameteri(sampler.object(), pname, value);
1233 }
1234 
1235 void WebGL2RenderingContext::samplerParameterf(WebGLSampler&amp; sampler, GCGLenum pname, GCGLfloat value)
1236 {
1237     if (isContextLostOrPending())
1238         return;
1239 
1240     m_context-&gt;samplerParameterf(sampler.object(), pname, value);
1241 }
1242 
1243 WebGLAny WebGL2RenderingContext::getSamplerParameter(WebGLSampler&amp; sampler, GCGLenum pname)
1244 {
1245     if (isContextLostOrPending())
1246         return nullptr;
1247 
1248     switch (pname) {
1249     case GraphicsContextGL::TEXTURE_COMPARE_FUNC:
1250     case GraphicsContextGL::TEXTURE_COMPARE_MODE:
1251     case GraphicsContextGL::TEXTURE_MAG_FILTER:
1252     case GraphicsContextGL::TEXTURE_MIN_FILTER:
1253     case GraphicsContextGL::TEXTURE_WRAP_R:
1254     case GraphicsContextGL::TEXTURE_WRAP_S:
1255     case GraphicsContextGL::TEXTURE_WRAP_T: {
1256         int value = 0;
1257         m_context-&gt;getSamplerParameteriv(sampler.object(), pname, &amp;value);
1258         return value;
1259     }
1260     case GraphicsContextGL::TEXTURE_MAX_LOD:
1261     case GraphicsContextGL::TEXTURE_MIN_LOD: {
1262         float value = 0;
1263         m_context-&gt;getSamplerParameterfv(sampler.object(), pname, &amp;value);
1264         return value;
1265     }
1266     default:
1267         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getSamplerParameter&quot;, &quot;Invalid pname&quot;);
1268         return nullptr;
1269     }
1270 }
1271 
1272 RefPtr&lt;WebGLSync&gt; WebGL2RenderingContext::fenceSync(GCGLenum, GCGLbitfield)
1273 {
1274     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] fenceSync()&quot;);
1275     return nullptr;
1276 }
1277 
1278 GCGLboolean WebGL2RenderingContext::isSync(WebGLSync*)
1279 {
1280     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] isSync()&quot;);
1281     return false;
1282 }
1283 
1284 void WebGL2RenderingContext::deleteSync(WebGLSync*)
1285 {
1286     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] deleteSync()&quot;);
1287 }
1288 
1289 GCGLenum WebGL2RenderingContext::clientWaitSync(WebGLSync&amp;, GCGLbitfield, GCGLuint64)
1290 {
1291     // Note: Do not implement this function without consulting webkit-dev and WebGL
1292     // reviewers beforehand. Apple folks, see &lt;rdar://problem/36666458&gt;.
1293     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] clientWaitSync()&quot;);
1294     return 0;
1295 }
1296 
1297 void WebGL2RenderingContext::waitSync(WebGLSync&amp;, GCGLbitfield, GCGLint64)
1298 {
1299     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] waitSync()&quot;);
1300 }
1301 
1302 WebGLAny WebGL2RenderingContext::getSyncParameter(WebGLSync&amp;, GCGLenum)
1303 {
1304     // Note: Do not implement this function without consulting webkit-dev and WebGL
1305     // reviewers beforehand. Apple folks, see &lt;rdar://problem/36666458&gt;.
1306     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getSyncParameter()&quot;);
1307     return nullptr;
1308 }
1309 
1310 RefPtr&lt;WebGLTransformFeedback&gt; WebGL2RenderingContext::createTransformFeedback()
1311 {
1312     if (isContextLostOrPending())
1313         return nullptr;
1314 
1315     auto transformFeedback = WebGLTransformFeedback::create(*this);
1316     addSharedObject(transformFeedback.get());
1317     return transformFeedback;
1318 }
1319 
1320 void WebGL2RenderingContext::deleteTransformFeedback(WebGLTransformFeedback* feedbackObject)
1321 {
1322     if (isContextLostOrPending())
1323         return;
1324 
1325     if (m_boundTransformFeedback == feedbackObject)
1326         m_boundTransformFeedback = nullptr;
1327 
1328     deleteObject(feedbackObject);
1329 }
1330 
1331 GCGLboolean WebGL2RenderingContext::isTransformFeedback(WebGLTransformFeedback* feedbackObject)
1332 {
1333     if (isContextLostOrPending() || !feedbackObject || feedbackObject-&gt;isDeleted() || !validateWebGLObject(&quot;isTransformFeedback&quot;, feedbackObject))
1334         return false;
1335 
1336     return m_context-&gt;isTransformFeedback(feedbackObject-&gt;object());
1337 }
1338 
1339 void WebGL2RenderingContext::bindTransformFeedback(GCGLenum target, WebGLTransformFeedback* feedbackObject)
1340 {
1341     if (isContextLostOrPending())
1342         return;
1343 
1344     if (feedbackObject) {
1345         if (feedbackObject-&gt;isDeleted()) {
1346             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindTransformFeedback&quot;, &quot;cannot bind a deleted Transform Feedback object&quot;);
1347             return;
1348         }
1349 
1350         if (!validateWebGLObject(&quot;bindTransformFeedback&quot;, feedbackObject))
1351             return;
1352     }
1353 
1354     m_context-&gt;bindTransformFeedback(target, objectOrZero(feedbackObject));
1355     m_boundTransformFeedback = feedbackObject;
1356 }
1357 
1358 void WebGL2RenderingContext::beginTransformFeedback(GCGLenum primitiveMode)
1359 {
1360     if (isContextLostOrPending())
1361         return;
1362 
1363     m_context-&gt;beginTransformFeedback(primitiveMode);
1364 }
1365 
1366 void WebGL2RenderingContext::endTransformFeedback()
1367 {
1368     if (isContextLostOrPending())
1369         return;
1370 
1371     m_context-&gt;endTransformFeedback();
1372 }
1373 
1374 void WebGL2RenderingContext::transformFeedbackVaryings(WebGLProgram&amp; program, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode)
1375 {
1376     if (isContextLostOrPending() || varyings.isEmpty() || !validateWebGLObject(&quot;transformFeedbackVaryings&quot;, &amp;program))
1377         return;
1378 
1379     m_context-&gt;transformFeedbackVaryings(program.object(), varyings, bufferMode);
1380 }
1381 
1382 RefPtr&lt;WebGLActiveInfo&gt; WebGL2RenderingContext::getTransformFeedbackVarying(WebGLProgram&amp; program, GCGLuint index)
1383 {
1384     if (isContextLostOrPending() || !validateWebGLObject(&quot;getTransformFeedbackVarying&quot;, &amp;program))
1385         return nullptr;
1386 
1387     GraphicsContextGL::ActiveInfo info;
1388     m_context-&gt;getTransformFeedbackVarying(program.object(), index, info);
1389 
1390     if (!info.name || !info.type || !info.size)
1391         return nullptr;
1392 
1393     return WebGLActiveInfo::create(info.name, info.type, info.size);
1394 }
1395 
1396 void WebGL2RenderingContext::pauseTransformFeedback()
1397 {
1398     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] pauseTransformFeedback()&quot;);
1399 }
1400 
1401 void WebGL2RenderingContext::resumeTransformFeedback()
1402 {
1403     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] resumeTransformFeedback()&quot;);
1404 }
1405 
1406 void WebGL2RenderingContext::bindBufferBase(GCGLenum target, GCGLuint index, WebGLBuffer* buffer)
1407 {
1408     if (isContextLostOrPending())
1409         return;
1410 
1411     switch (target) {
1412     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:
1413         if (index &gt;= m_boundTransformFeedbackBuffers.size()) {
1414             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bindBufferBase&quot;, &quot;index out of range&quot;);
1415             return;
1416         }
1417         break;
1418     case GraphicsContextGL::UNIFORM_BUFFER:
1419         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBufferBase&quot;, &quot;target not yet supported&quot;);
1420         return;
1421     default:
1422         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBufferBase&quot;, &quot;invalid target&quot;);
1423         return;
1424     }
1425 
1426     if (!validateAndCacheBufferBinding(&quot;bindBufferBase&quot;, target, buffer))
1427         return;
1428 
1429     m_context-&gt;bindBufferBase(target, index, objectOrZero(buffer));
1430 }
1431 
1432 void WebGL2RenderingContext::bindBufferRange(GCGLenum, GCGLuint, WebGLBuffer*, GCGLint64, GCGLint64)
1433 {
1434     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] bindBufferRange()&quot;);
1435 }
1436 
1437 WebGLAny WebGL2RenderingContext::getIndexedParameter(GCGLenum target, GCGLuint index)
1438 {
1439     if (isContextLostOrPending())
1440         return nullptr;
1441 
1442     switch (target) {
1443     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_BINDING:
1444         if (index &gt;= m_boundTransformFeedbackBuffers.size()) {
1445             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getIndexedParameter&quot;, &quot;index out of range&quot;);
1446             return nullptr;
1447         }
1448         return m_boundTransformFeedbackBuffers[index];
1449     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_SIZE:
1450     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_START:
1451     case GraphicsContextGL::UNIFORM_BUFFER_BINDING:
1452     case GraphicsContextGL::UNIFORM_BUFFER_SIZE:
1453     case GraphicsContextGL::UNIFORM_BUFFER_START:
1454         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getIndexedParameter&quot;, &quot;parameter name not yet supported&quot;);
1455         return nullptr;
1456     default:
1457         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getIndexedParameter&quot;, &quot;invalid parameter name&quot;);
1458         return nullptr;
1459     }
1460 }
1461 
1462 Optional&lt;Vector&lt;GCGLuint&gt;&gt; WebGL2RenderingContext::getUniformIndices(WebGLProgram&amp;, const Vector&lt;String&gt;&amp;)
1463 {
1464     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getUniformIndices()&quot;);
1465     return WTF::nullopt;
1466 }
1467 
1468 WebGLAny WebGL2RenderingContext::getActiveUniforms(WebGLProgram&amp; program, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname)
1469 {
1470     if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniforms&quot;, &amp;program))
1471         return nullptr;
1472 
1473     switch (pname) {
1474     case GraphicsContextGL::UNIFORM_TYPE:
1475     case GraphicsContextGL::UNIFORM_SIZE:
1476     case GraphicsContextGL::UNIFORM_BLOCK_INDEX:
1477     case GraphicsContextGL::UNIFORM_OFFSET:
1478     case GraphicsContextGL::UNIFORM_ARRAY_STRIDE:
1479     case GraphicsContextGL::UNIFORM_MATRIX_STRIDE:
1480     case GraphicsContextGL::UNIFORM_IS_ROW_MAJOR:
1481         {
1482             Vector&lt;GCGLint&gt; params(uniformIndices.size(), 0);
1483             m_context-&gt;getActiveUniforms(program.object(), uniformIndices, pname, params);
1484             return WTFMove(params);
1485         }
1486     default:
1487         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getActiveUniforms&quot;, &quot;invalid parameter name&quot;);
1488         return nullptr;
1489     }
1490 }
1491 
1492 GCGLuint WebGL2RenderingContext::getUniformBlockIndex(WebGLProgram&amp;, const String&amp;)
1493 {
1494     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getUniformBlockIndex()&quot;);
1495     return 0;
1496 }
1497 
1498 WebGLAny WebGL2RenderingContext::getActiveUniformBlockParameter(WebGLProgram&amp;, GCGLuint, GCGLenum)
1499 {
1500     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getActiveUniformBlockParameter()&quot;);
1501     return nullptr;
1502 }
1503 
1504 WebGLAny WebGL2RenderingContext::getActiveUniformBlockName(WebGLProgram&amp;, GCGLuint)
1505 {
1506     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] getActiveUniformBlockName()&quot;);
1507     return nullptr;
1508 }
1509 
1510 void WebGL2RenderingContext::uniformBlockBinding(WebGLProgram&amp;, GCGLuint, GCGLuint)
1511 {
1512     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformBlockBinding()&quot;);
1513 }
1514 
1515 RefPtr&lt;WebGLVertexArrayObject&gt; WebGL2RenderingContext::createVertexArray()
1516 {
1517     if (isContextLost())
1518         return nullptr;
1519 
1520     auto object = WebGLVertexArrayObject::create(*this, WebGLVertexArrayObject::Type::User);
1521     addContextObject(object.get());
1522     return WTFMove(object);
1523 }
1524 
1525 void WebGL2RenderingContext::deleteVertexArray(WebGLVertexArrayObject* arrayObject)
1526 {
1527     if (!arrayObject || isContextLost())
1528         return;
1529 
1530     if (arrayObject-&gt;isDeleted())
1531         return;
1532 
1533     if (!arrayObject-&gt;isDefaultObject() &amp;&amp; arrayObject == m_boundVertexArrayObject)
1534 #if USE(OPENGL_ES)
1535         setBoundVertexArrayObject(nullptr);
1536 #else
1537         bindVertexArray(nullptr); // The default VAO was removed in OpenGL 3.3 but not from WebGL 2; bind the default for WebGL to use.
1538 #endif
1539 
1540     arrayObject-&gt;deleteObject(graphicsContextGL());
1541 }
1542 
1543 GCGLboolean WebGL2RenderingContext::isVertexArray(WebGLVertexArrayObject* arrayObject)
1544 {
1545     if (!arrayObject || isContextLost())
1546         return false;
1547 
1548     if (!arrayObject-&gt;hasEverBeenBound() || !arrayObject-&gt;validate(0, *this))
1549         return false;
1550 
1551     return m_context-&gt;isVertexArray(arrayObject-&gt;object());
1552 }
1553 
1554 void WebGL2RenderingContext::bindVertexArray(WebGLVertexArrayObject* arrayObject)
1555 {
1556     if (isContextLost())
1557         return;
1558 
1559     if (arrayObject &amp;&amp; (arrayObject-&gt;isDeleted() || !arrayObject-&gt;validate(0, *this) || !m_contextObjects.contains(arrayObject))) {
1560         m_context-&gt;synthesizeGLError(GraphicsContextGL::INVALID_OPERATION);
1561         return;
1562     }
1563     if (arrayObject &amp;&amp; !arrayObject-&gt;isDefaultObject() &amp;&amp; arrayObject-&gt;object()) {
1564         m_context-&gt;bindVertexArray(arrayObject-&gt;object());
1565 
1566         arrayObject-&gt;setHasEverBeenBound();
1567         setBoundVertexArrayObject(arrayObject);
1568     } else {
1569         m_context-&gt;bindVertexArray(m_defaultVertexArrayObject-&gt;object());
1570         setBoundVertexArrayObject(m_defaultVertexArrayObject.get());
1571     }
1572 }
1573 
1574 WebGLExtension* WebGL2RenderingContext::getExtension(const String&amp; name)
1575 {
1576     if (isContextLostOrPending())
1577         return nullptr;
1578 
1579 #define ENABLE_IF_REQUESTED(type, variable, nameLiteral, canEnable) \
1580     if (equalIgnoringASCIICase(name, nameLiteral)) { \
1581         if (!variable) { \
1582             variable = (canEnable) ? makeUnique&lt;type&gt;(*this) : nullptr; \
1583             if (variable != nullptr) \
1584                 InspectorInstrumentation::didEnableExtension(*this, name); \
1585         } \
1586         return variable.get(); \
1587     }
1588 
1589     ENABLE_IF_REQUESTED(EXTTextureFilterAnisotropic, m_extTextureFilterAnisotropic, &quot;EXT_texture_filter_anisotropic&quot;, enableSupportedExtension(&quot;GL_EXT_texture_filter_anisotropic&quot;_s));
1590     ENABLE_IF_REQUESTED(OESTextureFloat, m_oesTextureFloat, &quot;OES_texture_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_float&quot;_s));
1591     ENABLE_IF_REQUESTED(OESTextureFloatLinear, m_oesTextureFloatLinear, &quot;OES_texture_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_float_linear&quot;_s));
1592     ENABLE_IF_REQUESTED(OESTextureHalfFloat, m_oesTextureHalfFloat, &quot;OES_texture_half_float&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float&quot;_s));
1593     ENABLE_IF_REQUESTED(OESTextureHalfFloatLinear, m_oesTextureHalfFloatLinear, &quot;OES_texture_half_float_linear&quot;, enableSupportedExtension(&quot;GL_OES_texture_half_float_linear&quot;_s));
1594     ENABLE_IF_REQUESTED(WebGLLoseContext, m_webglLoseContext, &quot;WEBGL_lose_context&quot;, true);
1595     ENABLE_IF_REQUESTED(WebGLCompressedTextureASTC, m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;, WebGLCompressedTextureASTC::supported(*this));
1596     ENABLE_IF_REQUESTED(WebGLCompressedTextureATC, m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;, WebGLCompressedTextureATC::supported(*this));
1597     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC, m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;, WebGLCompressedTextureETC::supported(*this));
1598     ENABLE_IF_REQUESTED(WebGLCompressedTextureETC1, m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;, WebGLCompressedTextureETC1::supported(*this));
1599     ENABLE_IF_REQUESTED(WebGLCompressedTexturePVRTC, m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;, WebGLCompressedTexturePVRTC::supported(*this));
1600     ENABLE_IF_REQUESTED(WebGLCompressedTextureS3TC, m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;, WebGLCompressedTextureS3TC::supported(*this));
1601     ENABLE_IF_REQUESTED(WebGLDepthTexture, m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;, WebGLDepthTexture::supported(*graphicsContextGL()));
1602     ENABLE_IF_REQUESTED(WebGLDebugRendererInfo, m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;, true);
1603     ENABLE_IF_REQUESTED(WebGLDebugShaders, m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;, m_context-&gt;getExtensions().supports(&quot;GL_ANGLE_translated_shader_source&quot;_s));
1604     return nullptr;
1605 }
1606 
1607 Optional&lt;Vector&lt;String&gt;&gt; WebGL2RenderingContext::getSupportedExtensions()
1608 {
1609     if (isContextLost())
1610         return WTF::nullopt;
1611 
1612     Vector&lt;String&gt; result;
1613 
1614     if (m_isPendingPolicyResolution)
1615         return result;
1616 
1617     auto&amp; extensions = m_context-&gt;getExtensions();
1618     if (extensions.supports(&quot;GL_OES_texture_float&quot;_s))
1619         result.append(&quot;OES_texture_float&quot;_s);
1620     if (extensions.supports(&quot;GL_OES_texture_float_linear&quot;_s))
1621         result.append(&quot;OES_texture_float_linear&quot;_s);
1622     if (extensions.supports(&quot;GL_OES_texture_half_float&quot;_s))
1623         result.append(&quot;OES_texture_half_float&quot;_s);
1624     if (extensions.supports(&quot;GL_OES_texture_half_float_linear&quot;_s))
1625         result.append(&quot;OES_texture_half_float_linear&quot;_s);
1626     if (extensions.supports(&quot;GL_EXT_texture_filter_anisotropic&quot;_s))
1627         result.append(&quot;EXT_texture_filter_anisotropic&quot;_s);
1628     if (WebGLCompressedTextureASTC::supported(*this))
1629         result.append(&quot;WEBGL_compressed_texture_astc&quot;_s);
1630     if (WebGLCompressedTextureATC::supported(*this))
1631         result.append(&quot;WEBKIT_WEBGL_compressed_texture_atc&quot;_s);
1632     if (WebGLCompressedTextureETC::supported(*this))
1633         result.append(&quot;WEBGL_compressed_texture_etc&quot;_s);
1634     if (WebGLCompressedTextureETC1::supported(*this))
1635         result.append(&quot;WEBGL_compressed_texture_etc1&quot;_s);
1636     if (WebGLCompressedTexturePVRTC::supported(*this))
1637         result.append(&quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;_s);
1638     if (WebGLCompressedTextureS3TC::supported(*this))
1639         result.append(&quot;WEBGL_compressed_texture_s3tc&quot;_s);
1640     if (WebGLDepthTexture::supported(*graphicsContextGL()))
1641         result.append(&quot;WEBGL_depth_texture&quot;_s);
1642     result.append(&quot;WEBGL_lose_context&quot;_s);
1643     if (extensions.supports(&quot;GL_ANGLE_translated_shader_source&quot;_s))
1644         result.append(&quot;WEBGL_debug_shaders&quot;_s);
1645     result.append(&quot;WEBGL_debug_renderer_info&quot;_s);
1646 
1647     return result;
1648 }
1649 
1650 static bool validateDefaultFramebufferAttachment(GCGLenum&amp; attachment)
1651 {
1652     switch (attachment) {
1653     case GraphicsContextGL::BACK:
1654         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
1655         attachment = GraphicsContextGL::COLOR_ATTACHMENT0;
1656         return true;
1657     case GraphicsContextGL::DEPTH:
1658     case GraphicsContextGL::STENCIL:
1659         return true;
1660     }
1661 
1662     return false;
1663 }
1664 
1665 WebGLAny WebGL2RenderingContext::getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname)
1666 {
1667     const char* functionName = &quot;getFramebufferAttachmentParameter&quot;;
1668     if (isContextLostOrPending() || !validateFramebufferTarget(functionName, target))
1669         return nullptr;
1670 
1671     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;
1672 
1673     if (!targetFramebuffer) {
1674         // OpenGL ES 3: Default framebuffer is bound.
1675         if (!validateDefaultFramebufferAttachment(attachment)) {
1676             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);
1677             return nullptr;
1678         }
1679         GCGLint value = 0;
1680         m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1681         return value;
1682     }
1683     if (!validateNonDefaultFramebufferAttachment(functionName, attachment))
1684         return nullptr;
1685 
1686     auto object = makeRefPtr(targetFramebuffer-&gt;getAttachmentObject(attachment));
1687     if (!object) {
1688         if (pname == GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE)
1689             return static_cast&lt;unsigned&gt;(GraphicsContextGL::NONE);
1690         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid parameter name&quot;);
1691         return nullptr;
1692     }
1693 
1694     switch (pname) {
1695     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_RED_SIZE:
1696     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:
1697     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:
1698     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:
1699     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:
1700     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
1701     case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: {
1702         GCGLint value = 0;
1703         m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1704         return value;
1705     }
1706     }
1707 
1708     if (object-&gt;isTexture()) {
1709         switch (pname) {
1710         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
1711             return static_cast&lt;unsigned&gt;(GraphicsContextGL::TEXTURE);
1712         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
1713             return makeRefPtr(reinterpret_cast&lt;WebGLTexture&amp;&gt;(*object));
1714         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
1715         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
1716         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: {
1717             GCGLint value = 0;
1718             m_context-&gt;getFramebufferAttachmentParameteriv(target, attachment, pname, &amp;value);
1719             return value;
1720         }
1721         default:
1722             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid parameter name for texture attachment&quot;);
1723             return nullptr;
1724         }
1725     } else {
1726         ASSERT(object-&gt;isRenderbuffer());
1727         switch (pname) {
1728         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
1729             return static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER);
1730         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
1731             return makeRefPtr(reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object));
1732         case GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING : {
1733             auto&amp; renderBuffer = reinterpret_cast&lt;WebGLRenderbuffer&amp;&gt;(*object);
1734             auto format = renderBuffer.getInternalFormat();
1735             if (format == GraphicsContextGL::SRGB8_ALPHA8
1736                 || format == GraphicsContextGL::COMPRESSED_SRGB8_ETC2
1737                 || format == GraphicsContextGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
1738                 || format == GraphicsContextGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2) {
1739                 return static_cast&lt;unsigned&gt;(GraphicsContextGL::SRGB);
1740             }
1741             return static_cast&lt;unsigned&gt;(GraphicsContextGL::LINEAR);
1742         }
1743         default:
1744             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid parameter name for renderbuffer attachment&quot;);
1745             return nullptr;
1746         }
1747     }
1748 }
1749 
1750 bool WebGL2RenderingContext::validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment)
1751 {
1752     return validateFramebufferTarget(functionName, target) &amp;&amp; validateNonDefaultFramebufferAttachment(functionName, attachment);
1753 }
1754 
1755 bool WebGL2RenderingContext::validateFramebufferTarget(const char* functionName, GCGLenum target)
1756 {
1757     switch (target) {
1758     case GraphicsContextGL::FRAMEBUFFER:
1759     case GraphicsContextGL::DRAW_FRAMEBUFFER:
1760     case GraphicsContextGL::READ_FRAMEBUFFER:
1761         return true;
1762     }
1763 
1764     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);
1765     return false;
1766 }
1767 
1768 bool WebGL2RenderingContext::validateNonDefaultFramebufferAttachment(const char* functionName, GCGLenum attachment)
1769 {
1770     switch (attachment) {
1771     case GraphicsContextGL::DEPTH_ATTACHMENT:
1772     case GraphicsContextGL::STENCIL_ATTACHMENT:
1773     case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:
1774         return true;
1775     default:
1776         if (attachment &gt;= GraphicsContextGL::COLOR_ATTACHMENT0 &amp;&amp; attachment &lt; static_cast&lt;GCGLenum&gt;(GraphicsContextGL::COLOR_ATTACHMENT0 + getMaxColorAttachments()))
1777             return true;
1778     }
1779 
1780     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid attachment&quot;);
1781     return false;
1782 }
1783 
1784 GCGLint WebGL2RenderingContext::getMaxDrawBuffers()
1785 {
1786     if (!m_maxDrawBuffers)
1787         m_context-&gt;getIntegerv(GraphicsContextGL::MAX_DRAW_BUFFERS, &amp;m_maxDrawBuffers);
1788     return m_maxDrawBuffers;
1789 }
1790 
1791 GCGLint WebGL2RenderingContext::getMaxColorAttachments()
1792 {
1793     // DrawBuffers requires MAX_COLOR_ATTACHMENTS == MAX_DRAW_BUFFERS
1794     if (!m_maxColorAttachments)
1795         m_context-&gt;getIntegerv(GraphicsContextGL::MAX_DRAW_BUFFERS, &amp;m_maxColorAttachments);
1796     return m_maxColorAttachments;
1797 }
1798 
1799 void WebGL2RenderingContext::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
1800 {
1801     if (isContextLostOrPending())
1802         return;
1803     if (target != GraphicsContextGL::RENDERBUFFER) {
1804         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid target&quot;);
1805         return;
1806     }
1807     if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
1808         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;renderbufferStorage&quot;, &quot;no bound renderbuffer&quot;);
1809         return;
1810     }
1811     if (!validateSize(&quot;renderbufferStorage&quot;, width, height))
1812         return;
1813     switch (internalformat) {
1814     case GraphicsContextGL::DEPTH_COMPONENT16:
1815     case GraphicsContextGL::DEPTH_COMPONENT32F:
1816     case GraphicsContextGL::DEPTH_COMPONENT24:
1817     case GraphicsContextGL::RGBA32I:
1818     case GraphicsContextGL::RGBA32UI:
1819     case GraphicsContextGL::RGBA16I:
1820     case GraphicsContextGL::RGBA16UI:
1821     case GraphicsContextGL::RGBA8:
1822     case GraphicsContextGL::RGBA8I:
1823     case GraphicsContextGL::RGBA8UI:
1824     case GraphicsContextGL::RGB10_A2:
1825     case GraphicsContextGL::RGB10_A2UI:
1826     case GraphicsContextGL::RGBA4:
1827     case GraphicsContextGL::RG32I:
1828     case GraphicsContextGL::RG32UI:
1829     case GraphicsContextGL::RG16I:
1830     case GraphicsContextGL::RG16UI:
1831     case GraphicsContextGL::RG8:
1832     case GraphicsContextGL::RG8I:
1833     case GraphicsContextGL::RG8UI:
1834     case GraphicsContextGL::R32I:
1835     case GraphicsContextGL::R32UI:
1836     case GraphicsContextGL::R16I:
1837     case GraphicsContextGL::R16UI:
1838     case GraphicsContextGL::R8:
1839     case GraphicsContextGL::R8I:
1840     case GraphicsContextGL::R8UI:
1841     case GraphicsContextGL::RGB5_A1:
1842     case GraphicsContextGL::RGB565:
1843     case GraphicsContextGL::RGB8:
1844     case GraphicsContextGL::STENCIL_INDEX8:
1845     case GraphicsContextGL::SRGB8_ALPHA8:
1846         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
1847         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
1848         m_renderbufferBinding-&gt;setIsValid(true);
1849         m_renderbufferBinding-&gt;setSize(width, height);
1850         break;
1851     case GraphicsContextGL::DEPTH32F_STENCIL8:
1852     case GraphicsContextGL::DEPTH24_STENCIL8:
1853         if (!isDepthStencilSupported()) {
1854             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
1855             return;
1856         }
1857         m_context-&gt;renderbufferStorage(target, internalformat, width, height);
1858         m_renderbufferBinding-&gt;setSize(width, height);
1859         m_renderbufferBinding-&gt;setIsValid(isDepthStencilSupported());
1860         m_renderbufferBinding-&gt;setInternalFormat(internalformat);
1861         break;
1862     default:
1863         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;renderbufferStorage&quot;, &quot;invalid internalformat&quot;);
1864         return;
1865     }
1866     applyStencilTest();
1867 }
1868 
1869 void WebGL2RenderingContext::hint(GCGLenum target, GCGLenum mode)
1870 {
1871     if (isContextLostOrPending())
1872         return;
1873     bool isValid = false;
1874     switch (target) {
1875     case GraphicsContextGL::GENERATE_MIPMAP_HINT:
1876     case GraphicsContextGL::FRAGMENT_SHADER_DERIVATIVE_HINT:
1877         isValid = true;
1878         break;
1879     }
1880     if (!isValid) {
1881         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;hint&quot;, &quot;invalid target&quot;);
1882         return;
1883     }
1884     m_context-&gt;hint(target, mode);
1885 }
1886 
1887 GCGLenum WebGL2RenderingContext::baseInternalFormatFromInternalFormat(GCGLenum internalformat)
1888 {
1889     // Handles sized, unsized, and compressed internal formats.
1890     switch (internalformat) {
1891     case GraphicsContextGL::R8:
1892     case GraphicsContextGL::R8_SNORM:
1893     case GraphicsContextGL::R16F:
1894     case GraphicsContextGL::R32F:
1895     case GraphicsContextGL::COMPRESSED_R11_EAC:
1896     case GraphicsContextGL::COMPRESSED_SIGNED_R11_EAC:
1897         return GraphicsContextGL::RED;
1898     case GraphicsContextGL::R8I:
1899     case GraphicsContextGL::R8UI:
1900     case GraphicsContextGL::R16I:
1901     case GraphicsContextGL::R16UI:
1902     case GraphicsContextGL::R32I:
1903     case GraphicsContextGL::R32UI:
1904         return GraphicsContextGL::RED_INTEGER;
1905     case GraphicsContextGL::RG8:
1906     case GraphicsContextGL::RG8_SNORM:
1907     case GraphicsContextGL::RG16F:
1908     case GraphicsContextGL::RG32F:
1909     case GraphicsContextGL::COMPRESSED_RG11_EAC:
1910     case GraphicsContextGL::COMPRESSED_SIGNED_RG11_EAC:
1911         return GraphicsContextGL::RG;
1912     case GraphicsContextGL::RG8I:
1913     case GraphicsContextGL::RG8UI:
1914     case GraphicsContextGL::RG16I:
1915     case GraphicsContextGL::RG16UI:
1916     case GraphicsContextGL::RG32I:
1917     case GraphicsContextGL::RG32UI:
1918         return GraphicsContextGL::RG_INTEGER;
1919     case GraphicsContextGL::RGB8:
1920     case GraphicsContextGL::RGB8_SNORM:
1921     case GraphicsContextGL::RGB565:
1922     case GraphicsContextGL::SRGB8:
1923     case GraphicsContextGL::RGB16F:
1924     case GraphicsContextGL::RGB32F:
1925     case GraphicsContextGL::RGB:
1926     case GraphicsContextGL::COMPRESSED_RGB8_ETC2:
1927     case GraphicsContextGL::COMPRESSED_SRGB8_ETC2:
1928         return GraphicsContextGL::RGB;
1929     case GraphicsContextGL::RGB8I:
1930     case GraphicsContextGL::RGB8UI:
1931     case GraphicsContextGL::RGB16I:
1932     case GraphicsContextGL::RGB16UI:
1933     case GraphicsContextGL::RGB32I:
1934     case GraphicsContextGL::RGB32UI:
1935         return GraphicsContextGL::RGB_INTEGER;
1936     case GraphicsContextGL::RGBA4:
1937     case GraphicsContextGL::RGB5_A1:
1938     case GraphicsContextGL::RGBA8:
1939     case GraphicsContextGL::RGBA8_SNORM:
1940     case GraphicsContextGL::RGB10_A2:
1941     case GraphicsContextGL::SRGB8_ALPHA8:
1942     case GraphicsContextGL::RGBA16F:
1943     case GraphicsContextGL::RGBA32F:
1944     case GraphicsContextGL::RGBA:
1945     case GraphicsContextGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
1946     case GraphicsContextGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
1947     case GraphicsContextGL::COMPRESSED_RGBA8_ETC2_EAC:
1948     case GraphicsContextGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
1949         return GraphicsContextGL::RGBA;
1950     case GraphicsContextGL::RGBA8I:
1951     case GraphicsContextGL::RGBA8UI:
1952     case GraphicsContextGL::RGB10_A2UI:
1953     case GraphicsContextGL::RGBA16I:
1954     case GraphicsContextGL::RGBA16UI:
1955     case GraphicsContextGL::RGBA32I:
1956     case GraphicsContextGL::RGBA32UI:
1957         return GraphicsContextGL::RGBA_INTEGER;
1958     case GraphicsContextGL::DEPTH_COMPONENT16:
1959     case GraphicsContextGL::DEPTH_COMPONENT24:
1960     case GraphicsContextGL::DEPTH_COMPONENT32F:
1961         return GraphicsContextGL::DEPTH_COMPONENT;
1962     case GraphicsContextGL::DEPTH24_STENCIL8:
1963     case GraphicsContextGL::DEPTH32F_STENCIL8:
1964         return GraphicsContextGL::DEPTH_STENCIL;
1965     case GraphicsContextGL::LUMINANCE:
1966     case GraphicsContextGL::LUMINANCE_ALPHA:
1967     case GraphicsContextGL::ALPHA:
1968         return internalformat;
1969     default:
1970         ASSERT_NOT_REACHED();
1971         return GraphicsContextGL::NONE;
1972     }
1973 }
1974 
1975 bool WebGL2RenderingContext::isIntegerFormat(GCGLenum internalformat)
1976 {
1977     switch (baseInternalFormatFromInternalFormat(internalformat)) {
1978     case GraphicsContextGL::RED_INTEGER:
1979     case GraphicsContextGL::RG_INTEGER:
1980     case GraphicsContextGL::RGB_INTEGER:
1981     case GraphicsContextGL::RGBA_INTEGER:
1982         return true;
1983     }
1984     return false;
1985 }
1986 
1987 WebGLAny WebGL2RenderingContext::getParameter(GCGLenum pname)
1988 {
1989     if (isContextLostOrPending())
1990         return nullptr;
1991     switch (pname) {
1992     case GraphicsContextGL::ACTIVE_TEXTURE:
1993         return getUnsignedIntParameter(pname);
1994     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:
1995         return getWebGLFloatArrayParameter(pname);
1996     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:
1997         return getWebGLFloatArrayParameter(pname);
1998     case GraphicsContextGL::ALPHA_BITS:
1999         if (!m_framebufferBinding &amp;&amp; !m_attributes.alpha)
2000             return 0;
2001         return getIntParameter(pname);
2002     case GraphicsContextGL::ARRAY_BUFFER_BINDING:
2003         return m_boundArrayBuffer;
2004     case GraphicsContextGL::BLEND:
2005         return getBooleanParameter(pname);
2006     case GraphicsContextGL::BLEND_COLOR:
2007         return getWebGLFloatArrayParameter(pname);
2008     case GraphicsContextGL::BLEND_DST_ALPHA:
2009         return getUnsignedIntParameter(pname);
2010     case GraphicsContextGL::BLEND_DST_RGB:
2011         return getUnsignedIntParameter(pname);
2012     case GraphicsContextGL::BLEND_EQUATION_ALPHA:
2013         return getUnsignedIntParameter(pname);
2014     case GraphicsContextGL::BLEND_EQUATION_RGB:
2015         return getUnsignedIntParameter(pname);
2016     case GraphicsContextGL::BLEND_SRC_ALPHA:
2017         return getUnsignedIntParameter(pname);
2018     case GraphicsContextGL::BLEND_SRC_RGB:
2019         return getUnsignedIntParameter(pname);
2020     case GraphicsContextGL::BLUE_BITS:
2021         return getIntParameter(pname);
2022     case GraphicsContextGL::COLOR_CLEAR_VALUE:
2023         return getWebGLFloatArrayParameter(pname);
2024     case GraphicsContextGL::COLOR_WRITEMASK:
2025         return getBooleanArrayParameter(pname);
2026     case GraphicsContextGL::COMPRESSED_TEXTURE_FORMATS:
2027         return Uint32Array::tryCreate(m_compressedTextureFormats.data(), m_compressedTextureFormats.size());
2028     case GraphicsContextGL::CULL_FACE:
2029         return getBooleanParameter(pname);
2030     case GraphicsContextGL::CULL_FACE_MODE:
2031         return getUnsignedIntParameter(pname);
2032     case GraphicsContextGL::CURRENT_PROGRAM:
2033         return m_currentProgram;
2034     case GraphicsContextGL::DEPTH_BITS:
2035         if (!m_framebufferBinding &amp;&amp; !m_attributes.depth)
2036             return 0;
2037         return getIntParameter(pname);
2038     case GraphicsContextGL::DEPTH_CLEAR_VALUE:
2039         return getFloatParameter(pname);
2040     case GraphicsContextGL::DEPTH_FUNC:
2041         return getUnsignedIntParameter(pname);
2042     case GraphicsContextGL::DEPTH_RANGE:
2043         return getWebGLFloatArrayParameter(pname);
2044     case GraphicsContextGL::DEPTH_TEST:
2045         return getBooleanParameter(pname);
2046     case GraphicsContextGL::DEPTH_WRITEMASK:
2047         return getBooleanParameter(pname);
2048     case GraphicsContextGL::DITHER:
2049         return getBooleanParameter(pname);
2050     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER_BINDING:
2051         return makeRefPtr(m_boundVertexArrayObject-&gt;getElementArrayBuffer());
2052     case GraphicsContextGL::FRAMEBUFFER_BINDING:
2053         return m_framebufferBinding;
2054     case GraphicsContextGL::FRONT_FACE:
2055         return getUnsignedIntParameter(pname);
2056     case GraphicsContextGL::GENERATE_MIPMAP_HINT:
2057         return getUnsignedIntParameter(pname);
2058     case GraphicsContextGL::GREEN_BITS:
2059         return getIntParameter(pname);
2060     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_FORMAT:
2061         return getIntParameter(pname);
2062     case GraphicsContextGL::IMPLEMENTATION_COLOR_READ_TYPE:
2063         return getIntParameter(pname);
2064     case GraphicsContextGL::LINE_WIDTH:
2065         return getFloatParameter(pname);
2066     case GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS:
2067         return getIntParameter(pname);
2068     case GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE:
2069         return getIntParameter(pname);
2070     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_VECTORS:
2071         return getIntParameter(pname);
2072     case GraphicsContextGL::MAX_RENDERBUFFER_SIZE:
2073         return getIntParameter(pname);
2074     case GraphicsContextGL::MAX_TEXTURE_IMAGE_UNITS:
2075         return getIntParameter(pname);
2076     case GraphicsContextGL::MAX_TEXTURE_SIZE:
2077         return getIntParameter(pname);
2078     case GraphicsContextGL::MAX_VARYING_VECTORS:
2079         return getIntParameter(pname);
2080     case GraphicsContextGL::MAX_VERTEX_ATTRIBS:
2081         return getIntParameter(pname);
2082     case GraphicsContextGL::MAX_VERTEX_TEXTURE_IMAGE_UNITS:
2083         return getIntParameter(pname);
2084     case GraphicsContextGL::MAX_VERTEX_UNIFORM_VECTORS:
2085         return getIntParameter(pname);
2086     case GraphicsContextGL::MAX_VIEWPORT_DIMS:
2087         return getWebGLIntArrayParameter(pname);
2088     case GraphicsContextGL::NUM_SHADER_BINARY_FORMATS:
2089         return getIntParameter(pname);
2090     case GraphicsContextGL::PACK_ALIGNMENT:
2091         return getIntParameter(pname);
2092     case GraphicsContextGL::POLYGON_OFFSET_FACTOR:
2093         return getFloatParameter(pname);
2094     case GraphicsContextGL::POLYGON_OFFSET_FILL:
2095         return getBooleanParameter(pname);
2096     case GraphicsContextGL::POLYGON_OFFSET_UNITS:
2097         return getFloatParameter(pname);
2098     case GraphicsContextGL::RED_BITS:
2099         return getIntParameter(pname);
2100     case GraphicsContextGL::RENDERBUFFER_BINDING:
2101         return m_renderbufferBinding;
2102     case GraphicsContextGL::RENDERER:
2103         return &quot;WebKit WebGL&quot;_str;
2104     case GraphicsContextGL::SAMPLE_BUFFERS:
2105         return getIntParameter(pname);
2106     case GraphicsContextGL::SAMPLE_COVERAGE_INVERT:
2107         return getBooleanParameter(pname);
2108     case GraphicsContextGL::SAMPLE_COVERAGE_VALUE:
2109         return getFloatParameter(pname);
2110     case GraphicsContextGL::SAMPLES:
2111         return getIntParameter(pname);
2112     case GraphicsContextGL::SCISSOR_BOX:
2113         return getWebGLIntArrayParameter(pname);
2114     case GraphicsContextGL::SCISSOR_TEST:
2115         return getBooleanParameter(pname);
2116     case GraphicsContextGL::SHADING_LANGUAGE_VERSION:
2117         return &quot;WebGL GLSL ES 1.0 (&quot; + m_context-&gt;getString(GraphicsContextGL::SHADING_LANGUAGE_VERSION) + &quot;)&quot;;
2118     case GraphicsContextGL::STENCIL_BACK_FAIL:
2119         return getUnsignedIntParameter(pname);
2120     case GraphicsContextGL::STENCIL_BACK_FUNC:
2121         return getUnsignedIntParameter(pname);
2122     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_FAIL:
2123         return getUnsignedIntParameter(pname);
2124     case GraphicsContextGL::STENCIL_BACK_PASS_DEPTH_PASS:
2125         return getUnsignedIntParameter(pname);
2126     case GraphicsContextGL::STENCIL_BACK_REF:
2127         return getIntParameter(pname);
2128     case GraphicsContextGL::STENCIL_BACK_VALUE_MASK:
2129         return getUnsignedIntParameter(pname);
2130     case GraphicsContextGL::STENCIL_BACK_WRITEMASK:
2131         return getUnsignedIntParameter(pname);
2132     case GraphicsContextGL::STENCIL_BITS:
2133         if (!m_framebufferBinding &amp;&amp; !m_attributes.stencil)
2134             return 0;
2135         return getIntParameter(pname);
2136     case GraphicsContextGL::STENCIL_CLEAR_VALUE:
2137         return getIntParameter(pname);
2138     case GraphicsContextGL::STENCIL_FAIL:
2139         return getUnsignedIntParameter(pname);
2140     case GraphicsContextGL::STENCIL_FUNC:
2141         return getUnsignedIntParameter(pname);
2142     case GraphicsContextGL::STENCIL_PASS_DEPTH_FAIL:
2143         return getUnsignedIntParameter(pname);
2144     case GraphicsContextGL::STENCIL_PASS_DEPTH_PASS:
2145         return getUnsignedIntParameter(pname);
2146     case GraphicsContextGL::STENCIL_REF:
2147         return getIntParameter(pname);
2148     case GraphicsContextGL::STENCIL_TEST:
2149         return getBooleanParameter(pname);
2150     case GraphicsContextGL::STENCIL_VALUE_MASK:
2151         return getUnsignedIntParameter(pname);
2152     case GraphicsContextGL::STENCIL_WRITEMASK:
2153         return getUnsignedIntParameter(pname);
2154     case GraphicsContextGL::SUBPIXEL_BITS:
2155         return getIntParameter(pname);
2156     case GraphicsContextGL::TEXTURE_BINDING_2D:
2157         return m_textureUnits[m_activeTextureUnit].texture2DBinding;
2158     case GraphicsContextGL::TEXTURE_BINDING_CUBE_MAP:
2159         return m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
2160     case GraphicsContextGL::UNPACK_ALIGNMENT:
2161         return getIntParameter(pname);
2162     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:
2163         return m_unpackFlipY;
2164     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:
2165         return m_unpackPremultiplyAlpha;
2166     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:
2167         return m_unpackColorspaceConversion;
2168     case GraphicsContextGL::VENDOR:
2169         return &quot;WebKit&quot;_str;
2170     case GraphicsContextGL::VERSION:
2171         return &quot;WebGL 2.0&quot;_str;
2172     case GraphicsContextGL::VIEWPORT:
2173         return getWebGLIntArrayParameter(pname);
2174     case WebGLDebugRendererInfo::UNMASKED_RENDERER_WEBGL:
2175         if (m_webglDebugRendererInfo) {
2176 #if PLATFORM(IOS_FAMILY)
2177             return &quot;Apple GPU&quot;_str;
2178 #else
2179             return m_context-&gt;getString(GraphicsContextGL::RENDERER);
2180 #endif
2181         }
2182         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);
2183         return nullptr;
2184     case WebGLDebugRendererInfo::UNMASKED_VENDOR_WEBGL:
2185         if (m_webglDebugRendererInfo)
2186             return m_context-&gt;getString(GraphicsContextGL::VENDOR);
2187         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, WEBGL_debug_renderer_info not enabled&quot;);
2188         return nullptr;
2189     case ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic
2190         if (m_extTextureFilterAnisotropic)
2191             return getFloatParameter(ExtensionsGL::MAX_TEXTURE_MAX_ANISOTROPY_EXT);
2192         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);
2193         return nullptr;
2194     case GraphicsContextGL::FRAGMENT_SHADER_DERIVATIVE_HINT:
2195         return getIntParameter(pname);
2196     case GraphicsContextGL::MAX_3D_TEXTURE_SIZE:
2197         return getIntParameter(pname);
2198     case GraphicsContextGL::MAX_ARRAY_TEXTURE_LAYERS:
2199         return getIntParameter(pname);
2200     case GraphicsContextGL::MAX_COLOR_ATTACHMENTS:
2201         return getIntParameter(pname);
2202     case GraphicsContextGL::MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:
2203         return getInt64Parameter(pname);
2204     case GraphicsContextGL::MAX_COMBINED_UNIFORM_BLOCKS:
2205         return getIntParameter(pname);
2206     case GraphicsContextGL::MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:
2207         return getInt64Parameter(pname);
2208     case GraphicsContextGL::MAX_DRAW_BUFFERS:
2209         return getIntParameter(pname);
2210     case GraphicsContextGL::MAX_ELEMENT_INDEX:
2211         return getInt64Parameter(pname);
2212     case GraphicsContextGL::MAX_ELEMENTS_INDICES:
2213         return getIntParameter(pname);
2214     case GraphicsContextGL::MAX_ELEMENTS_VERTICES:
2215         return getIntParameter(pname);
2216     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_COMPONENTS:
2217         return getIntParameter(pname);
2218     case GraphicsContextGL::MAX_FRAGMENT_UNIFORM_BLOCKS:
2219         return getIntParameter(pname);
2220     case GraphicsContextGL::MAX_PROGRAM_TEXEL_OFFSET:
2221         return getIntParameter(pname);
2222     case GraphicsContextGL::MAX_SAMPLES:
2223         return getIntParameter(pname);
2224     case GraphicsContextGL::MAX_SERVER_WAIT_TIMEOUT:
2225         return getInt64Parameter(pname);
2226     case GraphicsContextGL::MAX_TEXTURE_LOD_BIAS:
2227         return getIntParameter(pname);
2228     case GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:
2229         return getIntParameter(pname);
2230     case GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:
2231         return getIntParameter(pname);
2232     case GraphicsContextGL::MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:
2233         return getIntParameter(pname);
2234     case GraphicsContextGL::MAX_UNIFORM_BLOCK_SIZE:
2235         return getInt64Parameter(pname);
2236     case GraphicsContextGL::MAX_UNIFORM_BUFFER_BINDINGS:
2237         return getIntParameter(pname);
2238     case GraphicsContextGL::MAX_VARYING_COMPONENTS:
2239         return getIntParameter(pname);
2240     case GraphicsContextGL::MAX_VERTEX_OUTPUT_COMPONENTS:
2241         return getIntParameter(pname);
2242     case GraphicsContextGL::MAX_VERTEX_UNIFORM_BLOCKS:
2243         return getIntParameter(pname);
2244     case GraphicsContextGL::MAX_VERTEX_UNIFORM_COMPONENTS:
2245         return getIntParameter(pname);
2246     case GraphicsContextGL::MIN_PROGRAM_TEXEL_OFFSET:
2247         return getIntParameter(pname);
2248     case GraphicsContextGL::PACK_ROW_LENGTH:
2249         return getIntParameter(pname);
2250     case GraphicsContextGL::PACK_SKIP_PIXELS:
2251         return getIntParameter(pname);
2252     case GraphicsContextGL::PACK_SKIP_ROWS:
2253         return getIntParameter(pname);
2254     case GraphicsContextGL::UNPACK_IMAGE_HEIGHT:
2255         return getIntParameter(pname);
2256     case GraphicsContextGL::UNPACK_ROW_LENGTH:
2257         return getIntParameter(pname);
2258     case GraphicsContextGL::UNPACK_SKIP_IMAGES:
2259         return getIntParameter(pname);
2260     case GraphicsContextGL::UNPACK_SKIP_PIXELS:
2261         return getIntParameter(pname);
2262     case GraphicsContextGL::UNPACK_SKIP_ROWS:
2263         return getIntParameter(pname);
2264     case GraphicsContextGL::RASTERIZER_DISCARD:
2265         return getBooleanParameter(pname);
2266     case GraphicsContextGL::SAMPLE_ALPHA_TO_COVERAGE:
2267         return getBooleanParameter(pname);
2268     case GraphicsContextGL::SAMPLE_COVERAGE:
2269         return getBooleanParameter(pname);
2270     case GraphicsContextGL::TRANSFORM_FEEDBACK_ACTIVE:
2271         return getBooleanParameter(pname);
2272     case GraphicsContextGL::TRANSFORM_FEEDBACK_PAUSED:
2273         return getBooleanParameter(pname);
2274     case GraphicsContextGL::UNIFORM_BUFFER_OFFSET_ALIGNMENT:
2275         return getIntParameter(pname);
2276     case GraphicsContextGL::VERTEX_ARRAY_BINDING:
2277         if (m_boundVertexArrayObject-&gt;isDefaultObject())
2278             return nullptr;
2279         return makeRefPtr(static_cast&lt;WebGLVertexArrayObject&amp;&gt;(*m_boundVertexArrayObject));
2280     case GraphicsContextGL::DRAW_BUFFER0:
2281     case GraphicsContextGL::DRAW_BUFFER1:
2282     case GraphicsContextGL::DRAW_BUFFER2:
2283     case GraphicsContextGL::DRAW_BUFFER3:
2284     case GraphicsContextGL::DRAW_BUFFER4:
2285     case GraphicsContextGL::DRAW_BUFFER5:
2286     case GraphicsContextGL::DRAW_BUFFER6:
2287     case GraphicsContextGL::DRAW_BUFFER7:
2288     case GraphicsContextGL::DRAW_BUFFER8:
2289     case GraphicsContextGL::DRAW_BUFFER9:
2290     case GraphicsContextGL::DRAW_BUFFER10:
2291     case GraphicsContextGL::DRAW_BUFFER11:
2292     case GraphicsContextGL::DRAW_BUFFER12:
2293     case GraphicsContextGL::DRAW_BUFFER13:
2294     case GraphicsContextGL::DRAW_BUFFER14:
2295     case GraphicsContextGL::DRAW_BUFFER15:
2296         if (m_framebufferBinding)
2297             return m_framebufferBinding-&gt;getDrawBuffer(pname);
2298         return m_backDrawBuffer; // emulated backbuffer
2299     case GraphicsContextGL::READ_FRAMEBUFFER_BINDING:
2300         return m_readFramebufferBinding;
2301     case GraphicsContextGL::TRANSFORM_FEEDBACK_BINDING:
2302         return m_boundTransformFeedback;
2303     case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_BINDING:
2304         return m_boundTransformFeedbackBuffer;
2305     case GraphicsContextGL::SAMPLER_BINDING:
2306         return m_boundSamplers[m_activeTextureUnit];
2307     case GraphicsContextGL::COPY_READ_BUFFER:
2308     case GraphicsContextGL::COPY_WRITE_BUFFER:
2309     case GraphicsContextGL::PIXEL_PACK_BUFFER_BINDING:
2310     case GraphicsContextGL::PIXEL_UNPACK_BUFFER_BINDING:
2311     case GraphicsContextGL::READ_BUFFER:
2312     case GraphicsContextGL::TEXTURE_BINDING_2D_ARRAY:
2313     case GraphicsContextGL::TEXTURE_BINDING_3D:
2314     case GraphicsContextGL::UNIFORM_BUFFER_BINDING:
2315         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;parameter name not yet supported&quot;);
2316         return nullptr;
2317     default:
2318         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getParameter&quot;, &quot;invalid parameter name&quot;);
2319         return nullptr;
2320     }
2321 }
2322 
2323 bool WebGL2RenderingContext::validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired)
2324 {
2325     // Performs conservative validation by caching a maximum index of
2326     // the given type per element array buffer. If all of the bound
2327     // array buffers have enough elements to satisfy that maximum
2328     // index, skips the expensive per-draw-call iteration in
2329     // validateIndexArrayPrecise.
2330 
2331     RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
2332 
2333     if (!elementArrayBuffer)
2334         return false;
2335 
2336     GCGLsizeiptr numElements = elementArrayBuffer-&gt;byteLength();
2337     // The case count==0 is already dealt with in drawElements before validateIndexArrayConservative.
2338     if (!numElements)
2339         return false;
2340     auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
2341     ASSERT(buffer);
2342 
2343     Optional&lt;unsigned&gt; maxIndex = elementArrayBuffer-&gt;getCachedMaxIndex(type);
2344     if (!maxIndex) {
2345         // Compute the maximum index in the entire buffer for the given type of index.
2346         switch (type) {
2347         case GraphicsContextGL::UNSIGNED_BYTE:
2348             maxIndex = getMaxIndex&lt;GCGLubyte&gt;(buffer, 0, numElements);
2349             break;
2350         case GraphicsContextGL::UNSIGNED_SHORT:
2351             maxIndex = getMaxIndex&lt;GCGLushort&gt;(buffer, 0, numElements / sizeof(GCGLushort));
2352             break;
2353         case GraphicsContextGL::UNSIGNED_INT:
2354             maxIndex = getMaxIndex&lt;GCGLuint&gt;(buffer, 0, numElements / sizeof(GCGLuint));
2355             break;
2356         default:
2357             return false;
2358         }
2359         if (maxIndex)
2360             elementArrayBuffer-&gt;setCachedMaxIndex(type, maxIndex.value());
2361     }
2362 
2363     if (!maxIndex)
2364         return false;
2365 
2366     // The number of required elements is one more than the maximum
2367     // index that will be accessed.
2368     auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex.value(), 1, 1);
2369     if (!checkedNumElementsRequired)
2370         return false;
2371     numElementsRequired = checkedNumElementsRequired.value();
2372 
2373     return true;
2374 }
2375 
2376 bool WebGL2RenderingContext::validateBlendEquation(const char* functionName, GCGLenum mode)
2377 {
2378     switch (mode) {
2379     case GraphicsContextGL::FUNC_ADD:
2380     case GraphicsContextGL::FUNC_SUBTRACT:
2381     case GraphicsContextGL::FUNC_REVERSE_SUBTRACT:
2382     case GraphicsContextGL::MIN:
2383     case GraphicsContextGL::MAX:
2384         return true;
2385     default:
2386         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid mode&quot;);
2387         return false;
2388     }
2389 }
2390 
2391 bool WebGL2RenderingContext::validateCapability(const char* functionName, GCGLenum cap)
2392 {
2393     switch (cap) {
2394     case GraphicsContextGL::BLEND:
2395     case GraphicsContextGL::CULL_FACE:
2396     case GraphicsContextGL::DEPTH_TEST:
2397     case GraphicsContextGL::DITHER:
2398     case GraphicsContextGL::POLYGON_OFFSET_FILL:
2399     case GraphicsContextGL::SAMPLE_ALPHA_TO_COVERAGE:
2400     case GraphicsContextGL::SAMPLE_COVERAGE:
2401     case GraphicsContextGL::SCISSOR_TEST:
2402     case GraphicsContextGL::STENCIL_TEST:
2403     case GraphicsContextGL::RASTERIZER_DISCARD:
2404         return true;
2405     default:
2406         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid capability&quot;);
2407         return false;
2408     }
2409 }
2410 
2411 void WebGL2RenderingContext::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLint64 offset)
2412 {
2413     UNUSED_PARAM(target);
2414     UNUSED_PARAM(level);
2415     UNUSED_PARAM(internalformat);
2416     UNUSED_PARAM(width);
2417     UNUSED_PARAM(height);
2418     UNUSED_PARAM(border);
2419     UNUSED_PARAM(imageSize);
2420     UNUSED_PARAM(offset);
2421 
2422     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage2D(PIXEL_UNPACK_BUFFER)&quot;);
2423 }
2424 
2425 void WebGL2RenderingContext::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2426 {
2427     UNUSED_PARAM(target);
2428     UNUSED_PARAM(level);
2429     UNUSED_PARAM(internalformat);
2430     UNUSED_PARAM(width);
2431     UNUSED_PARAM(height);
2432     UNUSED_PARAM(border);
2433     UNUSED_PARAM(srcData);
2434     UNUSED_PARAM(srcOffset);
2435     UNUSED_PARAM(srcLengthOverride);
2436 
2437     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexImage2D(ArrayBufferView)&quot;);
2438 }
2439 
2440 void WebGL2RenderingContext::compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset)
2441 {
2442     UNUSED_PARAM(target);
2443     UNUSED_PARAM(level);
2444     UNUSED_PARAM(xoffset);
2445     UNUSED_PARAM(yoffset);
2446     UNUSED_PARAM(width);
2447     UNUSED_PARAM(height);
2448     UNUSED_PARAM(format);
2449     UNUSED_PARAM(imageSize);
2450     UNUSED_PARAM(offset);
2451 
2452     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage2D(PIXEL_UNPACK_BUFFER)&quot;);
2453 }
2454 
2455 void WebGL2RenderingContext::compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView&amp; srcData, GLuint srcOffset, GLuint srcLengthOverride)
2456 {
2457     UNUSED_PARAM(target);
2458     UNUSED_PARAM(level);
2459     UNUSED_PARAM(xoffset);
2460     UNUSED_PARAM(yoffset);
2461     UNUSED_PARAM(width);
2462     UNUSED_PARAM(height);
2463     UNUSED_PARAM(format);
2464     UNUSED_PARAM(srcData);
2465     UNUSED_PARAM(srcOffset);
2466     UNUSED_PARAM(srcLengthOverride);
2467 
2468     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] compressedTexSubImage2D(ArrayBufferView)&quot;);
2469 
2470 }
2471 
2472 void WebGL2RenderingContext::uniform1fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)
2473 {
2474     UNUSED_PARAM(location);
2475     UNUSED_PARAM(data);
2476     UNUSED_PARAM(srcOffset);
2477     UNUSED_PARAM(srcLength);
2478 
2479     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1fv()&quot;);
2480 }
2481 
2482 void WebGL2RenderingContext::uniform2fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)
2483 {
2484     UNUSED_PARAM(location);
2485     UNUSED_PARAM(data);
2486     UNUSED_PARAM(srcOffset);
2487     UNUSED_PARAM(srcLength);
2488 
2489     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2fv()&quot;);
2490 }
2491 
2492 void WebGL2RenderingContext::uniform3fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)
2493 {
2494     UNUSED_PARAM(location);
2495     UNUSED_PARAM(data);
2496     UNUSED_PARAM(srcOffset);
2497     UNUSED_PARAM(srcLength);
2498 
2499     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3fv()&quot;);
2500 }
2501 
2502 void WebGL2RenderingContext::uniform4fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength)
2503 {
2504     UNUSED_PARAM(location);
2505     UNUSED_PARAM(data);
2506     UNUSED_PARAM(srcOffset);
2507     UNUSED_PARAM(srcLength);
2508 
2509     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4fv()&quot;);
2510 }
2511 
2512 void WebGL2RenderingContext::uniform1iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)
2513 {
2514     UNUSED_PARAM(location);
2515     UNUSED_PARAM(data);
2516     UNUSED_PARAM(srcOffset);
2517     UNUSED_PARAM(srcLength);
2518 
2519     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform1iv()&quot;);
2520 }
2521 
2522 void WebGL2RenderingContext::uniform2iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)
2523 {
2524     UNUSED_PARAM(location);
2525     UNUSED_PARAM(data);
2526     UNUSED_PARAM(srcOffset);
2527     UNUSED_PARAM(srcLength);
2528 
2529     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform2iv()&quot;);
2530 }
2531 
2532 void WebGL2RenderingContext::uniform3iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)
2533 {
2534     UNUSED_PARAM(location);
2535     UNUSED_PARAM(data);
2536     UNUSED_PARAM(srcOffset);
2537     UNUSED_PARAM(srcLength);
2538 
2539     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform3iv()&quot;);
2540 }
2541 
2542 void WebGL2RenderingContext::uniform4iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength)
2543 {
2544     UNUSED_PARAM(location);
2545     UNUSED_PARAM(data);
2546     UNUSED_PARAM(srcOffset);
2547     UNUSED_PARAM(srcLength);
2548 
2549     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniform4iv()&quot;);
2550 }
2551 
2552 void WebGL2RenderingContext::uniformMatrix2fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength)
2553 {
2554     UNUSED_PARAM(location);
2555     UNUSED_PARAM(transpose);
2556     UNUSED_PARAM(data);
2557     UNUSED_PARAM(srcOffset);
2558     UNUSED_PARAM(srcLength);
2559 
2560     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix2fv()&quot;);
2561 }
2562 
2563 void WebGL2RenderingContext::uniformMatrix3fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength)
2564 {
2565     UNUSED_PARAM(location);
2566     UNUSED_PARAM(transpose);
2567     UNUSED_PARAM(data);
2568     UNUSED_PARAM(srcOffset);
2569     UNUSED_PARAM(srcLength);
2570 
2571     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix3fv()&quot;);
2572 }
2573 
2574 void WebGL2RenderingContext::uniformMatrix4fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength)
2575 {
2576     UNUSED_PARAM(location);
2577     UNUSED_PARAM(transpose);
2578     UNUSED_PARAM(data);
2579     UNUSED_PARAM(srcOffset);
2580     UNUSED_PARAM(srcLength);
2581 
2582     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] uniformMatrix4fv()&quot;);
2583 }
2584 
2585 void WebGL2RenderingContext::readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset)
2586 {
2587     UNUSED_PARAM(x);
2588     UNUSED_PARAM(y);
2589     UNUSED_PARAM(width);
2590     UNUSED_PARAM(height);
2591     UNUSED_PARAM(format);
2592     UNUSED_PARAM(type);
2593     UNUSED_PARAM(offset);
2594 
2595     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] readPixels()&quot;);
2596 }
2597 
2598 void WebGL2RenderingContext::readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView&amp; dstData, GLuint dstOffset)
2599 {
2600     UNUSED_PARAM(x);
2601     UNUSED_PARAM(y);
2602     UNUSED_PARAM(width);
2603     UNUSED_PARAM(height);
2604     UNUSED_PARAM(format);
2605     UNUSED_PARAM(type);
2606     UNUSED_PARAM(dstData);
2607     UNUSED_PARAM(dstOffset);
2608 
2609     LOG(WebGL, &quot;[[ NOT IMPLEMENTED ]] readPixels(ArrayBufferView)&quot;);
2610 }
2611 
2612 void WebGL2RenderingContext::uncacheDeletedBuffer(WebGLBuffer* buffer)
2613 {
2614     ASSERT(buffer);
2615 
2616     WebGLRenderingContextBase::uncacheDeletedBuffer(buffer);
2617 
2618     size_t index = m_boundTransformFeedbackBuffers.find(buffer);
2619     if (index &lt; m_boundTransformFeedbackBuffers.size())
2620         m_boundTransformFeedbackBuffers[index] = nullptr;
2621 }
2622 
2623 } // namespace WebCore
2624 
2625 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathTraversalState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2007 Eric Seidel &lt;eric@webkit.org&gt;
  3  * Copyright (C) 2015 Apple Inc.  All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;PathTraversalState.h&quot;
 23 
 24 #include &lt;wtf/MathExtras.h&gt;
 25 #include &lt;wtf/Vector.h&gt;
 26 
 27 namespace WebCore {
 28 
 29 static const float kPathSegmentLengthTolerance = 0.00001f;
 30 
 31 static inline FloatPoint midPoint(const FloatPoint&amp; first, const FloatPoint&amp; second)
 32 {
 33     return FloatPoint((first.x() + second.x()) / 2.0f, (first.y() + second.y()) / 2.0f);
 34 }
 35 
 36 static inline float distanceLine(const FloatPoint&amp; start, const FloatPoint&amp; end)
 37 {
 38     return std::hypot(end.x() - start.x(), end.y() - start.y());
 39 }
 40 
 41 struct QuadraticBezier {
 42     QuadraticBezier() { }
 43     QuadraticBezier(const FloatPoint&amp; s, const FloatPoint&amp; c, const FloatPoint&amp; e)
 44         : start(s)
 45         , control(c)
 46         , end(e)
 47     {
 48     }
 49 
 50     bool operator==(const QuadraticBezier&amp; rhs) const
 51     {
 52         return start == rhs.start
 53             &amp;&amp; control == rhs.control
 54             &amp;&amp; end == rhs.end;
 55     }
 56 
 57     float approximateDistance() const
 58     {
 59         return distanceLine(start, control) + distanceLine(control, end);
 60     }
 61 
 62     bool split(QuadraticBezier&amp; left, QuadraticBezier&amp; right) const
 63     {
 64         left.control = midPoint(start, control);
 65         right.control = midPoint(control, end);
 66 
 67         FloatPoint leftControlToRightControl = midPoint(left.control, right.control);
 68         left.end = leftControlToRightControl;
 69         right.start = leftControlToRightControl;
 70 
 71         left.start = start;
 72         right.end = end;
 73 
 74         return !(left == *this) &amp;&amp; !(right == *this);
 75     }
 76 
 77     FloatPoint start;
 78     FloatPoint control;
 79     FloatPoint end;
 80 };
 81 
 82 struct CubicBezier {
 83     CubicBezier() { }
 84     CubicBezier(const FloatPoint&amp; s, const FloatPoint&amp; c1, const FloatPoint&amp; c2, const FloatPoint&amp; e)
 85         : start(s)
 86         , control1(c1)
 87         , control2(c2)
 88         , end(e)
 89     {
 90     }
 91 
 92     bool operator==(const CubicBezier&amp; rhs) const
 93     {
 94         return start == rhs.start
 95             &amp;&amp; control1 == rhs.control1
 96             &amp;&amp; control2 == rhs.control2
 97             &amp;&amp; end == rhs.end;
 98     }
 99 
100     float approximateDistance() const
101     {
102         return distanceLine(start, control1) + distanceLine(control1, control2) + distanceLine(control2, end);
103     }
104 
105     bool split(CubicBezier&amp; left, CubicBezier&amp; right) const
106     {
107         FloatPoint startToControl1 = midPoint(control1, control2);
108 
109         left.start = start;
110         left.control1 = midPoint(start, control1);
111         left.control2 = midPoint(left.control1, startToControl1);
112 
113         right.control2 = midPoint(control2, end);
114         right.control1 = midPoint(right.control2, startToControl1);
115         right.end = end;
116 
117         FloatPoint leftControl2ToRightControl1 = midPoint(left.control2, right.control1);
118         left.end = leftControl2ToRightControl1;
119         right.start = leftControl2ToRightControl1;
120 
121         return !(left == *this) &amp;&amp; !(right == *this);
122     }
123 
124     FloatPoint start;
125     FloatPoint control1;
126     FloatPoint control2;
127     FloatPoint end;
128 };
129 
130 // FIXME: This function is possibly very slow due to the ifs required for proper path measuring
131 // A simple speed-up would be to use an additional boolean template parameter to control whether
132 // to use the &quot;fast&quot; version of this function with no PathTraversalState updating, vs. the slow
133 // version which does update the PathTraversalState.  We&#39;ll have to shark it to see if that&#39;s necessary.
134 // Another check which is possible up-front (to send us down the fast path) would be to check if
135 // approximateDistance() + current total distance &gt; desired distance
136 template&lt;class CurveType&gt;
137 static float curveLength(const PathTraversalState&amp; traversalState, const CurveType&amp; originalCurve, FloatPoint&amp; previous, FloatPoint&amp; current)
138 {
139     static const unsigned curveStackDepthLimit = 20;
140     CurveType curve = originalCurve;
141     Vector&lt;CurveType, curveStackDepthLimit&gt; curveStack;
142     float totalLength = 0;
143 
144     while (true) {
145         float length = curve.approximateDistance();
146 
147         CurveType leftCurve;
148         CurveType rightCurve;
149 
150         if ((length - distanceLine(curve.start, curve.end)) &gt; kPathSegmentLengthTolerance &amp;&amp; curveStack.size() &lt; curveStackDepthLimit &amp;&amp; curve.split(leftCurve, rightCurve)) {
151             curve = leftCurve;
152             curveStack.append(rightCurve);
153             continue;
154         }
155 
156         totalLength += length;
157         if (traversalState.action() == PathTraversalState::Action::VectorAtLength) {
158             previous = curve.start;
159             current = curve.end;
160             if (traversalState.totalLength() + totalLength &gt; traversalState.desiredLength())
161                 break;
162         }
163 
164         if (curveStack.isEmpty())
165             break;
166 
167         curve = curveStack.last();
168         curveStack.removeLast();
169     }
170 
171     if (traversalState.action() != PathTraversalState::Action::VectorAtLength) {
172         ASSERT(curve.end == originalCurve.end);
173         previous = curve.start;
174         current = curve.end;
175     }
176 
177     return totalLength;
178 }
179 
180 PathTraversalState::PathTraversalState(Action action, float desiredLength)
181     : m_action(action)
182     , m_desiredLength(desiredLength)
183 {
184     ASSERT(action != Action::TotalLength || !desiredLength);
185 }
186 
187 void PathTraversalState::closeSubpath()
188 {
189     m_totalLength += distanceLine(m_current, m_start);
190     m_current = m_start;
191 }
192 
193 void PathTraversalState::moveTo(const FloatPoint&amp; point)
194 {
195     m_previous = m_current = m_start = point;
196 }
197 
198 void PathTraversalState::lineTo(const FloatPoint&amp; point)
199 {
200     m_totalLength += distanceLine(m_current, point);
201     m_current = point;
202 }
203 
204 void PathTraversalState::quadraticBezierTo(const FloatPoint&amp; newControl, const FloatPoint&amp; newEnd)
205 {
206     m_totalLength += curveLength&lt;QuadraticBezier&gt;(*this, QuadraticBezier(m_current, newControl, newEnd), m_previous, m_current);
207 }
208 
209 void PathTraversalState::cubicBezierTo(const FloatPoint&amp; newControl1, const FloatPoint&amp; newControl2, const FloatPoint&amp; newEnd)
210 {
211     m_totalLength += curveLength&lt;CubicBezier&gt;(*this, CubicBezier(m_current, newControl1, newControl2, newEnd), m_previous, m_current);
212 }
213 
214 bool PathTraversalState::finalizeAppendPathElement()
215 {
216     if (m_action == Action::TotalLength)
217         return false;
218 
219     if (m_action == Action::SegmentAtLength) {
220         if (m_totalLength &gt;= m_desiredLength)
221             m_success = true;
222         return m_success;
223     }
224 
225     ASSERT(m_action == Action::VectorAtLength);
226 
227     if (m_totalLength &gt;= m_desiredLength) {
228         float slope = FloatPoint(m_current - m_previous).slopeAngleRadians();
229         float offset = m_desiredLength - m_totalLength;
230         m_current.move(offset * cosf(slope), offset * sinf(slope));
231 
232         if (!m_isZeroVector &amp;&amp; !m_desiredLength)
233             m_isZeroVector = true;
234         else {
235             m_success = true;
236             m_normalAngle = rad2deg(slope);
237         }
238     }
239 
240     m_previous = m_current;
241     return m_success;
242 }
243 
244 bool PathTraversalState::appendPathElement(PathElement::Type type, const FloatPoint* points)
245 {
246     switch (type) {
247     case PathElement::Type::MoveToPoint:
248         moveTo(points[0]);
249         break;
250     case PathElement::Type::AddLineToPoint:
251         lineTo(points[0]);
252         break;
253     case PathElement::Type::AddQuadCurveToPoint:
254         quadraticBezierTo(points[0], points[1]);
255         break;
256     case PathElement::Type::AddCurveToPoint:
257         cubicBezierTo(points[0], points[1], points[2]);
258         break;
259     case PathElement::Type::CloseSubpath:
260         closeSubpath();
261         break;
262     }
263 
264     return finalizeAppendPathElement();
265 }
266 
267 bool PathTraversalState::processPathElement(PathElement::Type type, const FloatPoint* points)
268 {
269     if (m_success)
270         return true;
271 
272     if (m_isZeroVector) {
273         PathTraversalState traversalState(*this);
274         m_success = traversalState.appendPathElement(type, points);
275         m_normalAngle = traversalState.m_normalAngle;
276         return m_success;
277     }
278 
279     return appendPathElement(type, points);
280 }
281 
282 }
283 
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCRtpTransceiverBackend.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCRtpTransceiverBackend.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCRtpTransceiverBackend.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCRtpTransceiverBackend.cpp
@@ -25,13 +25,15 @@
 #include "config.h"
 #include "LibWebRTCRtpTransceiverBackend.h"
 
 #if ENABLE(WEB_RTC) && USE(LIBWEBRTC)
 
+#include "JSDOMPromiseDeferred.h"
 #include "LibWebRTCRtpReceiverBackend.h"
 #include "LibWebRTCRtpSenderBackend.h"
 #include "LibWebRTCUtils.h"
+#include "RTCRtpCodecCapability.h"
 
 namespace WebCore {
 
 std::unique_ptr<LibWebRTCRtpReceiverBackend> LibWebRTCRtpTransceiverBackend::createReceiverBackend()
 {
@@ -76,8 +78,48 @@
 bool LibWebRTCRtpTransceiverBackend::stopped() const
 {
     return m_rtcTransceiver->stopped();
 }
 
+static inline ExceptionOr<webrtc::RtpCodecCapability> toRtpCodecCapability(const RTCRtpCodecCapability& codec)
+{
+    webrtc::RtpCodecCapability rtcCodec;
+    if (codec.mimeType.startsWith("video/"))
+        rtcCodec.kind = cricket::MEDIA_TYPE_VIDEO;
+    else if (codec.mimeType.startsWith("audio/"))
+        rtcCodec.kind = cricket::MEDIA_TYPE_AUDIO;
+    else
+        return Exception { InvalidModificationError, "RTCRtpCodecCapability bad mimeType" };
+
+    rtcCodec.name = codec.mimeType.substring(6).utf8().data();
+    rtcCodec.clock_rate = codec.clockRate;
+    if (codec.channels)
+        rtcCodec.num_channels = *codec.channels;
+
+    for (auto parameter : StringView(codec.sdpFmtpLine).split(';')) {
+        auto position = parameter.find('=');
+        if (position == notFound)
+            return Exception { InvalidModificationError, "RTCRtpCodecCapability sdpFmtLine badly formated" };
+        rtcCodec.parameters.emplace(parameter.substring(0, position).utf8().data(), parameter.substring(position + 1).utf8().data());
+    }
+
+    return rtcCodec;
+}
+
+ExceptionOr<void> LibWebRTCRtpTransceiverBackend::setCodecPreferences(const Vector<RTCRtpCodecCapability>& codecs)
+{
+    std::vector<webrtc::RtpCodecCapability> rtcCodecs;
+    for (auto& codec : codecs) {
+        auto result = toRtpCodecCapability(codec);
+        if (result.hasException())
+            return result.releaseException();
+        rtcCodecs.push_back(result.releaseReturnValue());
+    }
+    auto result = m_rtcTransceiver->SetCodecPreferences(rtcCodecs);
+    if (!result.ok())
+        return toException(result);
+    return { };
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(WEB_RTC) && USE(LIBWEBRTC)

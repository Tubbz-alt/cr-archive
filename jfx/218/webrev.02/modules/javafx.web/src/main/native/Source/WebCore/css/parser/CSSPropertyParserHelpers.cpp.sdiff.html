<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParserHelpers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPropertyParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParserHelpers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParserHelpers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  69 }
  70 
  71 CSSParserTokenRange consumeFunction(CSSParserTokenRange&amp; range)
  72 {
  73     ASSERT(range.peek().type() == FunctionToken);
  74     CSSParserTokenRange contents = range.consumeBlock();
  75     range.consumeWhitespace();
  76     contents.consumeWhitespace();
  77     return contents;
  78 }
  79 
  80 // FIXME: consider pulling in the parsing logic from CSSCalculationValue.cpp.
  81 class CalcParser {
  82 public:
  83     explicit CalcParser(CSSParserTokenRange&amp; range, CalculationCategory destinationCategory, ValueRange valueRange = ValueRangeAll)
  84         : m_sourceRange(range)
  85         , m_range(range)
  86     {
  87         const CSSParserToken&amp; token = range.peek();
  88         auto functionId = token.functionId();
<span class="line-modified">  89         if (functionId == CSSValueCalc || functionId == CSSValueWebkitCalc || functionId == CSSValueMin || functionId == CSSValueMax)</span>
  90             m_calcValue = CSSCalcValue::create(functionId, consumeFunction(m_range), destinationCategory, valueRange);
  91     }
  92 
  93     const CSSCalcValue* value() const { return m_calcValue.get(); }

  94     RefPtr&lt;CSSPrimitiveValue&gt; consumeValue()
  95     {
  96         if (!m_calcValue)
  97             return nullptr;
  98         m_sourceRange = m_range;
  99         return CSSValuePool::singleton().createValue(WTFMove(m_calcValue));
 100     }
<span class="line-modified"> 101     RefPtr&lt;CSSPrimitiveValue&gt; consumeNumber()</span>

 102     {
 103         if (!m_calcValue)
 104             return nullptr;
 105         m_sourceRange = m_range;
<span class="line-modified"> 106         return CSSValuePool::singleton().createValue(m_calcValue-&gt;doubleValue(), CSSPrimitiveValue::UnitType::CSS_NUMBER);</span>


 107     }
 108 
<span class="line-modified"> 109     bool consumeNumberRaw(double&amp; result)</span>
 110     {
<span class="line-modified"> 111         if (!m_calcValue || m_calcValue-&gt;category() != CalculationCategory::Number)</span>
<span class="line-modified"> 112             return false;</span>
 113         m_sourceRange = m_range;
<span class="line-modified"> 114         result = m_calcValue-&gt;doubleValue();</span>
<span class="line-removed"> 115         return true;</span>
 116     }
 117 
<span class="line-modified"> 118     bool consumePositiveIntegerRaw(int&amp; result)</span>
 119     {
<span class="line-modified"> 120         if (!m_calcValue || m_calcValue-&gt;category() != CalculationCategory::Number || !m_calcValue-&gt;isInt())</span>
<span class="line-removed"> 121             return false;</span>
<span class="line-removed"> 122         result = static_cast&lt;int&gt;(m_calcValue-&gt;doubleValue());</span>
<span class="line-removed"> 123         if (result &lt; 1)</span>
 124             return false;
 125         m_sourceRange = m_range;

 126         return true;
 127     }
 128 
 129 private:
 130     CSSParserTokenRange&amp; m_sourceRange;
 131     CSSParserTokenRange m_range;
 132     RefPtr&lt;CSSCalcValue&gt; m_calcValue;
 133 };
 134 
 135 RefPtr&lt;CSSPrimitiveValue&gt; consumeInteger(CSSParserTokenRange&amp; range, double minimumValue)
 136 {
 137     const CSSParserToken&amp; token = range.peek();
 138     if (token.type() == NumberToken) {
 139         if (token.numericValueType() == NumberValueType || token.numericValue() &lt; minimumValue)
 140             return nullptr;
<span class="line-modified"> 141         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_NUMBER);</span>
 142     }
 143 
 144     if (token.type() != FunctionToken)
 145         return nullptr;
 146 
 147     CalcParser calcParser(range, CalculationCategory::Number);
 148     if (const CSSCalcValue* calculation = calcParser.value()) {
<span class="line-modified"> 149         if (calculation-&gt;category() != CalculationCategory::Number || !calculation-&gt;isInt())</span>
 150             return nullptr;
<span class="line-modified"> 151         double value = calculation-&gt;doubleValue();</span>
<span class="line-removed"> 152         if (value &lt; minimumValue)</span>
<span class="line-removed"> 153             return nullptr;</span>
<span class="line-removed"> 154         return calcParser.consumeNumber();</span>
 155     }
 156 
 157     return nullptr;
 158 }
 159 
 160 RefPtr&lt;CSSPrimitiveValue&gt; consumePositiveInteger(CSSParserTokenRange&amp; range)
 161 {
 162     return consumeInteger(range, 1);
 163 }
 164 
<span class="line-removed"> 165 bool consumePositiveIntegerRaw(CSSParserTokenRange&amp; range, int&amp; result)</span>
<span class="line-removed"> 166 {</span>
<span class="line-removed"> 167     const CSSParserToken&amp; token = range.peek();</span>
<span class="line-removed"> 168     if (token.type() == NumberToken) {</span>
<span class="line-removed"> 169         if (token.numericValueType() == NumberValueType || token.numericValue() &lt; 1)</span>
<span class="line-removed"> 170             return false;</span>
<span class="line-removed"> 171         result = range.consumeIncludingWhitespace().numericValue();</span>
<span class="line-removed"> 172         return true;</span>
<span class="line-removed"> 173     }</span>
<span class="line-removed"> 174 </span>
<span class="line-removed"> 175     if (token.type() != FunctionToken)</span>
<span class="line-removed"> 176         return false;</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178     CalcParser calcParser(range, CalculationCategory::Number);</span>
<span class="line-removed"> 179     return calcParser.consumePositiveIntegerRaw(result);</span>
<span class="line-removed"> 180 }</span>
<span class="line-removed"> 181 </span>
 182 bool consumeNumberRaw(CSSParserTokenRange&amp; range, double&amp; result)
 183 {
 184     const CSSParserToken&amp; token = range.peek();
 185     if (token.type() == NumberToken) {
 186         result = range.consumeIncludingWhitespace().numericValue();
 187         return true;
 188     }
 189 
 190     if (token.type() != FunctionToken)
 191         return false;
 192 
 193     CalcParser calcParser(range, CalculationCategory::Number, ValueRangeAll);
 194     return calcParser.consumeNumberRaw(result);
 195 }
 196 
 197 // FIXME: Work out if this can just call consumeNumberRaw
 198 RefPtr&lt;CSSPrimitiveValue&gt; consumeNumber(CSSParserTokenRange&amp; range, ValueRange valueRange)
 199 {
 200     const CSSParserToken&amp; token = range.peek();
 201     if (token.type() == NumberToken) {
 202         if (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0)
 203             return nullptr;
 204         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 205     }
 206 
 207     if (token.type() != FunctionToken)
 208         return nullptr;
 209 
<span class="line-modified"> 210     CalcParser calcParser(range, CalculationCategory::Number, ValueRangeAll);</span>
<span class="line-modified"> 211     if (const CSSCalcValue* calculation = calcParser.value()) {</span>
<span class="line-modified"> 212         // FIXME: Calcs should not be subject to parse time range checks.</span>
<span class="line-removed"> 213         // spec: https://drafts.csswg.org/css-values-3/#calc-range</span>
<span class="line-removed"> 214         if (calculation-&gt;category() != CalculationCategory::Number || (valueRange == ValueRangeNonNegative &amp;&amp; calculation-&gt;isNegative()))</span>
 215             return nullptr;
<span class="line-modified"> 216         return calcParser.consumeNumber();</span>
 217     }
 218 
 219     return nullptr;
 220 }
 221 
 222 #if !ENABLE(VARIATION_FONTS)
 223 static inline bool divisibleBy100(double value)
 224 {
 225     return static_cast&lt;int&gt;(value / 100) * 100 == value;
 226 }
 227 #endif
 228 
 229 RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeightNumber(CSSParserTokenRange&amp; range)
 230 {
 231     // Values less than or equal to 0 or greater than or equal to 1000 are parse errors.
 232     auto&amp; token = range.peek();
 233     if (token.type() == NumberToken &amp;&amp; token.numericValue() &gt;= 1 &amp;&amp; token.numericValue() &lt;= 1000
 234 #if !ENABLE(VARIATION_FONTS)
 235         &amp;&amp; token.numericValueType() == IntegerValueType &amp;&amp; divisibleBy100(token.numericValue())
 236 #endif
 237     )
 238         return consumeNumber(range, ValueRangeAll);
 239 
 240     if (token.type() != FunctionToken)
 241         return nullptr;
 242 
 243     // &quot;[For calc()], the used value resulting from an expression must be clamped to the range allowed in the target context.&quot;
 244     CalcParser calcParser(range, CalculationCategory::Number, ValueRangeAll);
 245     double result;
 246     if (calcParser.consumeNumberRaw(result)
 247 #if !ENABLE(VARIATION_FONTS)
 248         &amp;&amp; result &gt; 0 &amp;&amp; result &lt; 1000 &amp;&amp; divisibleBy100(result)
 249 #endif
 250     ) {
 251         result = std::min(std::max(result, std::nextafter(0., 1.)), std::nextafter(1000., 0.));
<span class="line-modified"> 252         return CSSValuePool::singleton().createValue(result, CSSPrimitiveValue::UnitType::CSS_NUMBER);</span>
 253     }
 254 
 255     return nullptr;
 256 }
 257 
 258 inline bool shouldAcceptUnitlessValue(double value, CSSParserMode cssParserMode, UnitlessQuirk unitless)
 259 {
 260     // FIXME: Presentational HTML attributes shouldn&#39;t use the CSS parser for lengths
 261     return value == 0
 262         || isUnitLessValueParsingEnabledForMode(cssParserMode)
 263         || (cssParserMode == HTMLQuirksMode &amp;&amp; unitless == UnitlessQuirk::Allow);
 264 }
 265 
 266 RefPtr&lt;CSSPrimitiveValue&gt; consumeLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 267 {
 268     const CSSParserToken&amp; token = range.peek();
 269     if (token.type() == DimensionToken) {
 270         switch (token.unitType()) {
<span class="line-modified"> 271         case CSSPrimitiveValue::UnitType::CSS_QUIRKY_EMS:</span>
 272             if (cssParserMode != UASheetMode)
 273                 return nullptr;
 274             FALLTHROUGH;
<span class="line-modified"> 275         case CSSPrimitiveValue::UnitType::CSS_EMS:</span>
<span class="line-modified"> 276         case CSSPrimitiveValue::UnitType::CSS_REMS:</span>
<span class="line-modified"> 277         case CSSPrimitiveValue::UnitType::CSS_CHS:</span>
<span class="line-modified"> 278         case CSSPrimitiveValue::UnitType::CSS_EXS:</span>
<span class="line-modified"> 279         case CSSPrimitiveValue::UnitType::CSS_PX:</span>
<span class="line-modified"> 280         case CSSPrimitiveValue::UnitType::CSS_CM:</span>
<span class="line-modified"> 281         case CSSPrimitiveValue::UnitType::CSS_MM:</span>
<span class="line-modified"> 282         case CSSPrimitiveValue::UnitType::CSS_IN:</span>
<span class="line-modified"> 283         case CSSPrimitiveValue::UnitType::CSS_PT:</span>
<span class="line-modified"> 284         case CSSPrimitiveValue::UnitType::CSS_PC:</span>
<span class="line-modified"> 285         case CSSPrimitiveValue::UnitType::CSS_VW:</span>
<span class="line-modified"> 286         case CSSPrimitiveValue::UnitType::CSS_VH:</span>
<span class="line-modified"> 287         case CSSPrimitiveValue::UnitType::CSS_VMIN:</span>
<span class="line-modified"> 288         case CSSPrimitiveValue::UnitType::CSS_VMAX:</span>

 289             break;
 290         default:
 291             return nullptr;
 292         }
 293         if ((valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0) || std::isinf(token.numericValue()))
 294             return nullptr;
 295         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 296     }
 297     if (token.type() == NumberToken) {
 298         if (!shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless)
 299             || (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0))
 300             return nullptr;
 301         if (std::isinf(token.numericValue()))
 302             return nullptr;
<span class="line-modified"> 303         CSSPrimitiveValue::UnitType unitType = CSSPrimitiveValue::UnitType::CSS_PX;</span>
 304         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unitType);
 305     }
 306 
 307     if (token.type() != FunctionToken)
 308         return nullptr;
 309 
 310     CalcParser calcParser(range, CalculationCategory::Length, valueRange);
 311     if (calcParser.value() &amp;&amp; calcParser.value()-&gt;category() == CalculationCategory::Length)
 312         return calcParser.consumeValue();
 313 
 314     return nullptr;
 315 }
 316 
 317 RefPtr&lt;CSSPrimitiveValue&gt; consumePercent(CSSParserTokenRange&amp; range, ValueRange valueRange)
 318 {
 319     const CSSParserToken&amp; token = range.peek();
 320     if (token.type() == PercentageToken) {
 321         if ((valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0) || std::isinf(token.numericValue()))
 322             return nullptr;
<span class="line-modified"> 323         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
 324     }
 325 
 326     if (token.type() != FunctionToken)
 327         return nullptr;
 328 
 329     CalcParser calcParser(range, CalculationCategory::Percent, valueRange);
 330     if (const CSSCalcValue* calculation = calcParser.value()) {
 331         if (calculation-&gt;category() == CalculationCategory::Percent)
 332             return calcParser.consumeValue();
 333     }
 334     return nullptr;
 335 }
 336 
 337 static bool canConsumeCalcValue(CalculationCategory category, CSSParserMode cssParserMode)
 338 {
 339     if (category == CalculationCategory::Length || category == CalculationCategory::Percent || category == CalculationCategory::PercentLength)
 340         return true;
 341 
 342     if (cssParserMode != SVGAttributeMode)
 343         return false;
</pre>
<hr />
<pre>
 355         return consumeLength(range, cssParserMode, valueRange, unitless);
 356     if (token.type() == PercentageToken)
 357         return consumePercent(range, valueRange);
 358 
 359     if (token.type() != FunctionToken)
 360         return nullptr;
 361 
 362     CalcParser calcParser(range, CalculationCategory::Length, valueRange);
 363     if (const CSSCalcValue* calculation = calcParser.value()) {
 364         if (canConsumeCalcValue(calculation-&gt;category(), cssParserMode))
 365             return calcParser.consumeValue();
 366     }
 367     return nullptr;
 368 }
 369 
 370 RefPtr&lt;CSSPrimitiveValue&gt; consumeAngle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
 371 {
 372     const CSSParserToken&amp; token = range.peek();
 373     if (token.type() == DimensionToken) {
 374         switch (token.unitType()) {
<span class="line-modified"> 375         case CSSPrimitiveValue::UnitType::CSS_DEG:</span>
<span class="line-modified"> 376         case CSSPrimitiveValue::UnitType::CSS_RAD:</span>
<span class="line-modified"> 377         case CSSPrimitiveValue::UnitType::CSS_GRAD:</span>
<span class="line-modified"> 378         case CSSPrimitiveValue::UnitType::CSS_TURN:</span>
 379             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 380         default:
 381             return nullptr;
 382         }
 383     }
 384 
 385     if (token.type() == NumberToken &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless))
<span class="line-modified"> 386         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_DEG);</span>
 387 
 388     if (token.type() != FunctionToken)
 389         return nullptr;
 390 
 391     CalcParser calcParser(range, CalculationCategory::Angle, ValueRangeAll);
 392     if (const CSSCalcValue* calculation = calcParser.value()) {
 393         if (calculation-&gt;category() == CalculationCategory::Angle)
 394             return calcParser.consumeValue();
 395     }
 396     return nullptr;
 397 }
 398 
 399 static RefPtr&lt;CSSPrimitiveValue&gt; consumeAngleOrPercent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 400 {
 401     const CSSParserToken&amp; token = range.peek();
 402     if (token.type() == DimensionToken) {
 403         switch (token.unitType()) {
<span class="line-modified"> 404         case CSSPrimitiveValue::UnitType::CSS_DEG:</span>
<span class="line-modified"> 405         case CSSPrimitiveValue::UnitType::CSS_RAD:</span>
<span class="line-modified"> 406         case CSSPrimitiveValue::UnitType::CSS_GRAD:</span>
<span class="line-modified"> 407         case CSSPrimitiveValue::UnitType::CSS_TURN:</span>
 408             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 409         default:
 410             return nullptr;
 411         }
 412     }
 413     if (token.type() == NumberToken &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless))
<span class="line-modified"> 414         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_DEG);</span>
 415 
 416     if (token.type() == PercentageToken)
 417         return consumePercent(range, valueRange);
 418 
 419      if (token.type() != FunctionToken)
 420          return nullptr;
 421 
 422     CalcParser angleCalcParser(range, CalculationCategory::Angle, valueRange);
 423     if (const CSSCalcValue* calculation = angleCalcParser.value()) {
 424         if (calculation-&gt;category() == CalculationCategory::Angle)
 425             return angleCalcParser.consumeValue();
 426     }
 427 
 428     CalcParser percentCalcParser(range, CalculationCategory::Percent, valueRange);
 429     if (const CSSCalcValue* calculation = percentCalcParser.value()) {
 430         if (calculation-&gt;category() == CalculationCategory::Percent)
 431             return percentCalcParser.consumeValue();
 432     }
 433     return nullptr;
 434 }
 435 
 436 RefPtr&lt;CSSPrimitiveValue&gt; consumeTime(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 437 {
 438     const CSSParserToken&amp; token = range.peek();
<span class="line-modified"> 439     CSSPrimitiveValue::UnitType unit = token.unitType();</span>
<span class="line-modified"> 440     bool acceptUnitless = token.type() == NumberToken &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless);</span>
 441     if (acceptUnitless)
<span class="line-modified"> 442         unit = CSSPrimitiveValue::UnitType::CSS_MS;</span>
 443     if (token.type() == DimensionToken || acceptUnitless) {
 444         if (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0)
 445             return nullptr;
<span class="line-modified"> 446         if (unit == CSSPrimitiveValue::UnitType::CSS_MS || unit == CSSPrimitiveValue::UnitType::CSS_S)</span>
 447             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unit);
 448         return nullptr;
 449     }
 450 
 451     if (token.type() != FunctionToken)
 452         return nullptr;
 453 
 454     CalcParser calcParser(range, CalculationCategory::Time, valueRange);
 455     if (const CSSCalcValue* calculation = calcParser.value()) {
 456         if (calculation-&gt;category() == CalculationCategory::Time)
 457             return calcParser.consumeValue();
 458     }
 459     return nullptr;
 460 }
 461 
<span class="line-modified"> 462 RefPtr&lt;CSSPrimitiveValue&gt; consumeResolution(CSSParserTokenRange&amp; range)</span>
 463 {
 464     const CSSParserToken&amp; token = range.peek();
 465     // Unlike the other types, calc() does not work with &lt;resolution&gt;.
 466     if (token.type() != DimensionToken)
 467         return nullptr;
<span class="line-modified"> 468     CSSPrimitiveValue::UnitType unit = token.unitType();</span>
<span class="line-modified"> 469     if (unit == CSSPrimitiveValue::UnitType::CSS_DPPX || unit == CSSPrimitiveValue::UnitType::CSS_DPI || unit == CSSPrimitiveValue::UnitType::CSS_DPCM)</span>
 470         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unit);



 471     return nullptr;
 472 }
 473 
 474 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdent(CSSParserTokenRange&amp; range)
 475 {
 476     if (range.peek().type() != IdentToken)
 477         return nullptr;
 478     return CSSValuePool::singleton().createIdentifierValue(range.consumeIncludingWhitespace().id());
 479 }
 480 
 481 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdentRange(CSSParserTokenRange&amp; range, CSSValueID lower, CSSValueID upper)
 482 {
 483     if (range.peek().id() &lt; lower || range.peek().id() &gt; upper)
 484         return nullptr;
 485     return consumeIdent(range);
 486 }
 487 
 488 // FIXME-NEWPARSER: Eventually we&#39;d like this to use CSSCustomIdentValue, but we need
 489 // to do other plumbing work first (like changing Pair to CSSValuePair and make it not
 490 // use only primitive values).
 491 RefPtr&lt;CSSPrimitiveValue&gt; consumeCustomIdent(CSSParserTokenRange&amp; range)
 492 {
 493     if (range.peek().type() != IdentToken || isCSSWideKeyword(range.peek().id()))
 494         return nullptr;
<span class="line-modified"> 495     return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
 496 }
 497 
 498 RefPtr&lt;CSSPrimitiveValue&gt; consumeString(CSSParserTokenRange&amp; range)
 499 {
 500     if (range.peek().type() != StringToken)
 501         return nullptr;
<span class="line-modified"> 502     return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
 503 }
 504 
 505 StringView consumeUrlAsStringView(CSSParserTokenRange&amp; range)
 506 {
 507     const CSSParserToken&amp; token = range.peek();
 508     if (token.type() == UrlToken) {
 509         range.consumeIncludingWhitespace();
 510         return token.value();
 511     }
 512     if (token.functionId() == CSSValueUrl) {
 513         CSSParserTokenRange urlRange = range;
 514         CSSParserTokenRange urlArgs = urlRange.consumeBlock();
 515         const CSSParserToken&amp; next = urlArgs.consumeIncludingWhitespace();
 516         if (next.type() == BadStringToken || !urlArgs.atEnd())
 517             return StringView();
 518         ASSERT(next.type() == StringToken);
 519         range = urlRange;
 520         range.consumeWhitespace();
 521         return next.value();
 522     }
 523 
 524     return StringView();
 525 }
 526 
 527 RefPtr&lt;CSSPrimitiveValue&gt; consumeUrl(CSSParserTokenRange&amp; range)
 528 {
 529     StringView url = consumeUrlAsStringView(range);
 530     if (url.isNull())
 531         return nullptr;
<span class="line-modified"> 532     return CSSValuePool::singleton().createValue(url.toString(), CSSPrimitiveValue::UnitType::CSS_URI);</span>
 533 }
 534 
 535 static int clampRGBComponent(const CSSPrimitiveValue&amp; value)
 536 {
 537     double result = value.doubleValue();
 538     if (value.isPercentage())
 539         result = result / 100.0 * 255.0;
 540 
 541     return clampTo&lt;int&gt;(round(result), 0, 255);
 542 }
 543 
 544 static Color parseRGBParameters(CSSParserTokenRange&amp; range)
 545 {
 546     ASSERT(range.peek().functionId() == CSSValueRgb || range.peek().functionId() == CSSValueRgba);
 547     Color result;
 548     CSSParserTokenRange args = consumeFunction(range);
 549     RefPtr&lt;CSSPrimitiveValue&gt; colorParameter = consumeNumber(args, ValueRangeAll);
 550     if (!colorParameter)
 551         colorParameter = consumePercent(args, ValueRangeAll);
 552     if (!colorParameter)
</pre>
<hr />
<pre>
 582     }
 583 
 584     // Historically, alpha was only parsed for rgba(), but css-color-4 specifies that rgba() is a simple alias for rgb().
 585     auto consumeAlphaSeparator = [&amp;] {
 586         if (syntax == ColorSyntax::Commas)
 587             return consumeCommaIncludingWhitespace(args);
 588 
 589         return consumeSlashIncludingWhitespace(args);
 590     };
 591 
 592     int alphaComponent = 255;
 593     if (consumeAlphaSeparator()) {
 594         double alpha;
 595         if (!consumeNumberRaw(args, alpha)) {
 596             auto alphaPercent = consumePercent(args, ValueRangeAll);
 597             if (!alphaPercent)
 598                 return Color();
 599             alpha = alphaPercent-&gt;doubleValue() / 100.0;
 600         }
 601 
<span class="line-modified"> 602         // Convert the floating pointer number of alpha to an integer in the range [0, 256),</span>
<span class="line-modified"> 603         // with an equal distribution across all 256 values.</span>
<span class="line-removed"> 604         alphaComponent = static_cast&lt;int&gt;(clampTo&lt;double&gt;(alpha, 0.0, 1.0) * nextafter(256.0, 0.0));</span>
 605     };
 606 
 607     result = Color(makeRGBA(colorArray[0], colorArray[1], colorArray[2], alphaComponent));
 608 
 609     if (!args.atEnd())
 610         return Color();
 611 
 612     return result;
 613 }
 614 
 615 static Color parseHSLParameters(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 616 {
 617     ASSERT(range.peek().functionId() == CSSValueHsl || range.peek().functionId() == CSSValueHsla);
 618     CSSParserTokenRange args = consumeFunction(range);
 619     auto hslValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
 620     double angleInDegrees;
 621     if (!hslValue) {
 622         hslValue = consumeNumber(args, ValueRangeAll);
 623         if (!hslValue)
 624             return Color();
 625         angleInDegrees = hslValue-&gt;doubleValue();
 626     } else
 627         angleInDegrees = hslValue-&gt;computeDegrees();

 628     double colorArray[3];
<span class="line-modified"> 629     // The hue needs to be in the range [0.0, 6.0) for calcHue()</span>
<span class="line-removed"> 630     colorArray[0] = fmod(fmod(angleInDegrees, 360.0) + 360.0, 360.0) / 60.0;</span>
 631     bool requiresCommas = false;
 632     for (int i = 1; i &lt; 3; i++) {
 633         if (consumeCommaIncludingWhitespace(args)) {
 634             if (i != 1 &amp;&amp; !requiresCommas)
 635                 return Color();
 636             requiresCommas = true;
 637         } else if (requiresCommas || args.atEnd() || (&amp;args.peek() - 1)-&gt;type() != WhitespaceToken)
 638             return Color();
 639         hslValue = consumePercent(args, ValueRangeAll);
 640         if (!hslValue)
 641             return Color();
 642         double doubleValue = hslValue-&gt;doubleValue();
 643         colorArray[i] = clampTo&lt;double&gt;(doubleValue, 0.0, 100.0) / 100.0; // Needs to be value between 0 and 1.0.
 644     }
 645 
 646     double alpha = 1.0;
 647     bool commaConsumed = consumeCommaIncludingWhitespace(args);
 648     bool slashConsumed = consumeSlashIncludingWhitespace(args);
 649     if ((commaConsumed &amp;&amp; !requiresCommas) || (slashConsumed &amp;&amp; requiresCommas))
 650         return Color();
 651     if (commaConsumed || slashConsumed) {
 652         if (!consumeNumberRaw(args, alpha)) {
 653             auto alphaPercent = consumePercent(args, ValueRangeAll);
 654             if (!alphaPercent)
 655                 return Color();
 656             alpha = alphaPercent-&gt;doubleValue() / 100.0f;
 657         }
 658         alpha = clampTo&lt;double&gt;(alpha, 0.0, 1.0);
 659     }
 660 
 661     if (!args.atEnd())
 662         return Color();
 663 
<span class="line-modified"> 664     return Color(makeRGBAFromHSLA(colorArray[0], colorArray[1], colorArray[2], alpha));</span>
 665 }
 666 
 667 static Color parseColorFunctionParameters(CSSParserTokenRange&amp; range)
 668 {
 669     ASSERT(range.peek().functionId() == CSSValueColor);
 670     CSSParserTokenRange args = consumeFunction(range);
 671 
 672     ColorSpace colorSpace;
 673     switch (args.peek().id()) {
 674     case CSSValueSRGB:
<span class="line-modified"> 675         colorSpace = ColorSpaceSRGB;</span>
 676         break;
 677     case CSSValueDisplayP3:
<span class="line-modified"> 678         colorSpace = ColorSpaceDisplayP3;</span>
 679         break;
 680     default:
 681         return Color();
 682     }
 683     consumeIdent(args);
 684 
 685     double colorChannels[4] = { 0, 0, 0, 1 };
 686     for (int i = 0; i &lt; 3; ++i) {
 687         double value;
 688         if (consumeNumberRaw(args, value))
 689             colorChannels[i] = std::max(0.0, std::min(1.0, value));
 690         else
 691             break;
 692     }
 693 
 694     if (consumeSlashIncludingWhitespace(args)) {
 695         auto alphaParameter = consumePercent(args, ValueRangeAll);
 696         if (!alphaParameter)
 697             alphaParameter = consumeNumber(args, ValueRangeAll);
 698         if (!alphaParameter)
</pre>
<hr />
<pre>
 816     bool mustOrderAsXY = isHorizontalPositionKeywordOnly(value1) || isVerticalPositionKeywordOnly(value2)
 817         || !value1.isValueID() || !value2.isValueID();
 818     bool mustOrderAsYX = isVerticalPositionKeywordOnly(value1) || isHorizontalPositionKeywordOnly(value2);
 819     if (mustOrderAsXY &amp;&amp; mustOrderAsYX)
 820         return false;
 821     resultX = &amp;value1;
 822     resultY = &amp;value2;
 823     if (mustOrderAsYX)
 824         std::swap(resultX, resultY);
 825     return true;
 826 }
 827 
 828 namespace CSSPropertyParserHelpersInternal {
 829 template&lt;typename... Args&gt;
 830 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
 831 {
 832     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
 833 }
 834 }
 835 
<span class="line-modified"> 836 static bool positionFromThreeOrFourValues(CSSPrimitiveValue** values, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)</span>










 837 {
 838     CSSPrimitiveValue* center = nullptr;
 839     for (int i = 0; values[i]; i++) {
 840         CSSPrimitiveValue* currentValue = values[i];
 841         if (!currentValue-&gt;isValueID())
 842             return false;
<span class="line-removed"> 843         CSSValueID id = currentValue-&gt;valueID();</span>
 844 

 845         if (id == CSSValueCenter) {
 846             if (center)
 847                 return false;
 848             center = currentValue;
 849             continue;
 850         }
 851 
 852         RefPtr&lt;CSSPrimitiveValue&gt; result;
 853         if (values[i + 1] &amp;&amp; !values[i + 1]-&gt;isValueID())
 854             result = CSSPropertyParserHelpersInternal::createPrimitiveValuePair(currentValue, values[++i]);
 855         else
 856             result = currentValue;
 857 
 858         if (id == CSSValueLeft || id == CSSValueRight) {
 859             if (resultX)
 860                 return false;
 861             resultX = result;
 862         } else {
 863             ASSERT(id == CSSValueTop || id == CSSValueBottom);
 864             if (resultY)
 865                 return false;
 866             resultY = result;
 867         }
 868     }
 869 
 870     if (center) {
 871         ASSERT(resultX || resultY);
 872         if (resultX &amp;&amp; resultY)
 873             return false;
 874         if (!resultX)
 875             resultX = center;
 876         else
 877             resultY = center;
 878     }
 879 
 880     ASSERT(resultX &amp;&amp; resultY);
 881     return true;
 882 }
 883 











































 884 // FIXME: This may consume from the range upon failure. The background
 885 // shorthand works around it, but we should just fix it here.
<span class="line-modified"> 886 bool consumePosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)</span>
 887 {
 888     RefPtr&lt;CSSPrimitiveValue&gt; value1 = consumePositionComponent(range, cssParserMode, unitless);
 889     if (!value1)
 890         return false;
 891 
 892     RefPtr&lt;CSSPrimitiveValue&gt; value2 = consumePositionComponent(range, cssParserMode, unitless);
 893     if (!value2) {
 894         positionFromOneValue(*value1, resultX, resultY);
 895         return true;
 896     }
 897 
 898     RefPtr&lt;CSSPrimitiveValue&gt; value3 = consumePositionComponent(range, cssParserMode, unitless);
 899     if (!value3)
 900         return positionFromTwoValues(*value1, *value2, resultX, resultY);
 901 
 902     RefPtr&lt;CSSPrimitiveValue&gt; value4 = consumePositionComponent(range, cssParserMode, unitless);
<span class="line-modified"> 903     CSSPrimitiveValue* values[5];</span>

 904     values[0] = value1.get();
 905     values[1] = value2.get();
 906     values[2] = value3.get();
 907     values[3] = value4.get();
 908     values[4] = nullptr;
<span class="line-modified"> 909     return positionFromThreeOrFourValues(values, resultX, resultY);</span>







 910 }
 911 
<span class="line-modified"> 912 RefPtr&lt;CSSPrimitiveValue&gt; consumePosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)</span>
 913 {
 914     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 915     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
<span class="line-modified"> 916     if (consumePosition(range, cssParserMode, unitless, resultX, resultY))</span>
 917         return CSSPropertyParserHelpersInternal::createPrimitiveValuePair(resultX.releaseNonNull(), resultY.releaseNonNull());
 918     return nullptr;
 919 }
 920 
 921 bool consumeOneOrTwoValuedPosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 922 {
 923     RefPtr&lt;CSSPrimitiveValue&gt; value1 = consumePositionComponent(range, cssParserMode, unitless);
 924     if (!value1)
 925         return false;
 926     RefPtr&lt;CSSPrimitiveValue&gt; value2 = consumePositionComponent(range, cssParserMode, unitless);
 927     if (!value2) {
 928         positionFromOneValue(*value1, resultX, resultY);
 929         return true;
 930     }
 931     return positionFromTwoValues(*value1, *value2, resultX, resultY);
 932 }
 933 
 934 // This should go away once we drop support for -webkit-gradient
 935 static RefPtr&lt;CSSPrimitiveValue&gt; consumeDeprecatedGradientPoint(CSSParserTokenRange&amp; args, bool horizontal)
 936 {
 937     if (args.peek().type() == IdentToken) {
 938         if ((horizontal &amp;&amp; consumeIdent&lt;CSSValueLeft&gt;(args)) || (!horizontal &amp;&amp; consumeIdent&lt;CSSValueTop&gt;(args)))
<span class="line-modified"> 939             return CSSValuePool::singleton().createValue(0., CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
 940         if ((horizontal &amp;&amp; consumeIdent&lt;CSSValueRight&gt;(args)) || (!horizontal &amp;&amp; consumeIdent&lt;CSSValueBottom&gt;(args)))
<span class="line-modified"> 941             return CSSValuePool::singleton().createValue(100., CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
 942         if (consumeIdent&lt;CSSValueCenter&gt;(args))
<span class="line-modified"> 943             return CSSValuePool::singleton().createValue(50., CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
 944         return nullptr;
 945     }
 946     RefPtr&lt;CSSPrimitiveValue&gt; result = consumePercent(args, ValueRangeAll);
 947     if (!result)
 948         result = consumeNumber(args, ValueRangeAll);
 949     return result;
 950 }
 951 
 952 // Used to parse colors for -webkit-gradient(...).
 953 static RefPtr&lt;CSSPrimitiveValue&gt; consumeDeprecatedGradientStopColor(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
 954 {
 955     if (args.peek().id() == CSSValueCurrentcolor)
 956         return nullptr;
 957     return consumeColor(args, cssParserMode);
 958 }
 959 
 960 static bool consumeDeprecatedGradientColorStop(CSSParserTokenRange&amp; range, CSSGradientColorStop&amp; stop, CSSParserMode cssParserMode)
 961 {
 962     CSSValueID id = range.peek().functionId();
 963     if (id != CSSValueFrom &amp;&amp; id != CSSValueTo &amp;&amp; id != CSSValueColorStop)
 964         return false;
 965 
 966     CSSParserTokenRange args = consumeFunction(range);
 967     double position;
 968     if (id == CSSValueFrom || id == CSSValueTo) {
 969         position = (id == CSSValueFrom) ? 0 : 1;
 970     } else {
 971         ASSERT(id == CSSValueColorStop);
 972         if (auto percentValue = consumePercent(args, ValueRangeAll))
 973             position = percentValue-&gt;doubleValue() / 100.0;
 974         else if (!consumeNumberRaw(args, position))
 975             return false;
 976 
 977         if (!consumeCommaIncludingWhitespace(args))
 978             return false;
 979     }
 980 
<span class="line-modified"> 981     stop.m_position = CSSValuePool::singleton().createValue(position, CSSPrimitiveValue::UnitType::CSS_NUMBER);</span>
 982     stop.m_color = consumeDeprecatedGradientStopColor(args, cssParserMode);
 983     return stop.m_color &amp;&amp; args.atEnd();
 984 }
 985 
 986 static RefPtr&lt;CSSValue&gt; consumeDeprecatedGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
 987 {
 988     RefPtr&lt;CSSGradientValue&gt; result;
 989     CSSValueID id = args.consumeIncludingWhitespace().id();
 990     bool isDeprecatedRadialGradient = (id == CSSValueRadial);
 991     if (isDeprecatedRadialGradient)
 992         result = CSSRadialGradientValue::create(NonRepeating, CSSDeprecatedRadialGradient);
 993     else if (id == CSSValueLinear)
 994         result = CSSLinearGradientValue::create(NonRepeating, CSSDeprecatedLinearGradient);
 995     if (!result || !consumeCommaIncludingWhitespace(args))
 996         return nullptr;
 997 
<span class="line-modified"> 998     RefPtr&lt;CSSPrimitiveValue&gt; point = consumeDeprecatedGradientPoint(args, true);</span>
 999     if (!point)
1000         return nullptr;
1001     result-&gt;setFirstX(point.copyRef());
1002     point = consumeDeprecatedGradientPoint(args, false);
1003     if (!point)
1004         return nullptr;
1005     result-&gt;setFirstY(point.copyRef());
1006 
1007     if (!consumeCommaIncludingWhitespace(args))
1008         return nullptr;
1009 
1010     // For radial gradients only, we now expect a numeric radius.
1011     if (isDeprecatedRadialGradient) {
<span class="line-modified">1012         RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeNumber(args, ValueRangeAll);</span>
1013         if (!radius || !consumeCommaIncludingWhitespace(args))
1014             return nullptr;
1015         downcast&lt;CSSRadialGradientValue&gt;(result.get())-&gt;setFirstRadius(radius.copyRef());
1016     }
1017 
1018     point = consumeDeprecatedGradientPoint(args, true);
1019     if (!point)
1020         return nullptr;
1021     result-&gt;setSecondX(point.copyRef());
1022     point = consumeDeprecatedGradientPoint(args, false);
1023     if (!point)
1024         return nullptr;
1025     result-&gt;setSecondY(point.copyRef());
1026 
1027     // For radial gradients only, we now expect the second radius.
1028     if (isDeprecatedRadialGradient) {
1029         if (!consumeCommaIncludingWhitespace(args))
1030             return nullptr;
<span class="line-modified">1031         RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeNumber(args, ValueRangeAll);</span>
1032         if (!radius)
1033             return nullptr;
1034         downcast&lt;CSSRadialGradientValue&gt;(result.get())-&gt;setSecondRadius(radius.copyRef());
1035     }
1036 
1037     CSSGradientColorStop stop;
1038     while (consumeCommaIncludingWhitespace(args)) {
1039         if (!consumeDeprecatedGradientColorStop(args, stop, cssParserMode))
1040             return nullptr;
1041         result-&gt;addStop(stop);
1042     }
1043 
1044     result-&gt;doneAddingStops();
1045     return result;
1046 }
1047 
1048 static bool consumeGradientColorStops(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSGradientValue&amp; gradient)
1049 {
1050     bool supportsColorHints = gradient.gradientType() == CSSLinearGradient || gradient.gradientType() == CSSRadialGradient || gradient.gradientType() == CSSConicGradient;
1051 
</pre>
<hr />
<pre>
1055     bool previousStopWasColorHint = true;
1056     do {
1057         CSSGradientColorStop stop;
1058         stop.m_color = consumeColor(range, cssParserMode);
1059         // Two hints in a row are not allowed.
1060         if (!stop.m_color &amp;&amp; (!supportsColorHints || previousStopWasColorHint))
1061             return false;
1062 
1063         previousStopWasColorHint = !stop.m_color;
1064 
1065         // FIXME-NEWPARSER: This boolean could be removed. Null checking color would be sufficient.
1066         stop.isMidpoint = !stop.m_color;
1067 
1068         if (isConicGradient)
1069             stop.m_position = consumeAngleOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Forbid);
1070         else
1071             stop.m_position = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
1072 
1073         if (!stop.m_color &amp;&amp; !stop.m_position)
1074             return false;

1075         gradient.addStop(stop);
1076 
<span class="line-modified">1077         // See if there is a second color hint, which is optional.</span>


1078         CSSGradientColorStop secondStop;
1079         if (isConicGradient)
1080             secondStop.m_position = consumeAngleOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Forbid);
1081         else
1082             secondStop.m_position = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
1083 
<span class="line-modified">1084         if (secondStop.m_position) {</span>
<span class="line-removed">1085             secondStop.m_color = stop.m_color;</span>
1086             gradient.addStop(secondStop);
<span class="line-removed">1087         }</span>
1088 
1089     } while (consumeCommaIncludingWhitespace(range));
1090 
1091     gradient.doneAddingStops();
1092 
1093     // The last color stop cannot be a color hint.
1094     if (previousStopWasColorHint)
1095         return false;
1096 
1097     // Must have 2 or more stops to be valid.
1098     return gradient.stopCount() &gt;= 2;
1099 }
1100 
1101 static RefPtr&lt;CSSValue&gt; consumeDeprecatedRadialGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating)
1102 {
1103     RefPtr&lt;CSSRadialGradientValue&gt; result = CSSRadialGradientValue::create(repeating, CSSPrefixedRadialGradient);
1104     RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1105     RefPtr&lt;CSSPrimitiveValue&gt; centerY;
1106     consumeOneOrTwoValuedPosition(args, cssParserMode, UnitlessQuirk::Forbid, centerX, centerY);
1107     if ((centerX || centerY) &amp;&amp; !consumeCommaIncludingWhitespace(args))
1108         return nullptr;
1109 
1110     result-&gt;setFirstX(centerX.copyRef());
1111     result-&gt;setFirstY(centerY.copyRef());
1112     result-&gt;setSecondX(centerX.copyRef());
1113     result-&gt;setSecondY(centerY.copyRef());
1114 
<span class="line-modified">1115     RefPtr&lt;CSSPrimitiveValue&gt; shape = consumeIdent&lt;CSSValueCircle, CSSValueEllipse&gt;(args);</span>
<span class="line-modified">1116     RefPtr&lt;CSSPrimitiveValue&gt; sizeKeyword = consumeIdent&lt;CSSValueClosestSide, CSSValueClosestCorner, CSSValueFarthestSide, CSSValueFarthestCorner, CSSValueContain, CSSValueCover&gt;(args);</span>
1117     if (!shape)
1118         shape = consumeIdent&lt;CSSValueCircle, CSSValueEllipse&gt;(args);
1119     result-&gt;setShape(shape.copyRef());
1120     result-&gt;setSizingBehavior(sizeKeyword.copyRef());
1121 
1122     // Or, two lengths or percentages
1123     if (!shape &amp;&amp; !sizeKeyword) {
<span class="line-modified">1124         RefPtr&lt;CSSPrimitiveValue&gt; horizontalSize = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);</span>
1125         RefPtr&lt;CSSPrimitiveValue&gt; verticalSize;
1126         if (horizontalSize) {
<span class="line-modified">1127             verticalSize = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);</span>
1128             if (!verticalSize)
1129                 return nullptr;
1130             consumeCommaIncludingWhitespace(args);
1131             result-&gt;setEndHorizontalSize(horizontalSize.copyRef());
1132             result-&gt;setEndVerticalSize(verticalSize.copyRef());
1133         }
1134     } else {
1135         consumeCommaIncludingWhitespace(args);
1136     }
1137     if (!consumeGradientColorStops(args, cssParserMode, *result))
1138         return nullptr;
1139 
1140     return result;
1141 }
1142 
1143 static RefPtr&lt;CSSValue&gt; consumeRadialGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating)
1144 {
1145     RefPtr&lt;CSSRadialGradientValue&gt; result = CSSRadialGradientValue::create(repeating, CSSRadialGradient);
1146 
1147     RefPtr&lt;CSSPrimitiveValue&gt; shape;
</pre>
<hr />
<pre>
1151 
1152     // First part of grammar, the size/shape clause:
1153     // [ circle || &lt;length&gt; ] |
1154     // [ ellipse || [ &lt;length&gt; | &lt;percentage&gt; ]{2} ] |
1155     // [ [ circle | ellipse] || &lt;size-keyword&gt; ]
1156     for (int i = 0; i &lt; 3; ++i) {
1157         if (args.peek().type() == IdentToken) {
1158             CSSValueID id = args.peek().id();
1159             if (id == CSSValueCircle || id == CSSValueEllipse) {
1160                 if (shape)
1161                     return nullptr;
1162                 shape = consumeIdent(args);
1163             } else if (id == CSSValueClosestSide || id == CSSValueClosestCorner || id == CSSValueFarthestSide || id == CSSValueFarthestCorner) {
1164                 if (sizeKeyword)
1165                     return nullptr;
1166                 sizeKeyword = consumeIdent(args);
1167             } else {
1168                 break;
1169             }
1170         } else {
<span class="line-modified">1171             RefPtr&lt;CSSPrimitiveValue&gt; center = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);</span>
1172             if (!center)
1173                 break;
1174             if (horizontalSize)
1175                 return nullptr;
1176             horizontalSize = center;
<span class="line-modified">1177             center = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);</span>
1178             if (center) {
1179                 verticalSize = center;
1180                 ++i;
1181             }
1182         }
1183     }
1184 
1185     // You can specify size as a keyword or a length/percentage, not both.
1186     if (sizeKeyword &amp;&amp; horizontalSize)
1187         return nullptr;
1188     // Circles must have 0 or 1 lengths.
1189     if (shape &amp;&amp; shape-&gt;valueID() == CSSValueCircle &amp;&amp; verticalSize)
1190         return nullptr;
1191     // Ellipses must have 0 or 2 length/percentages.
1192     if (shape &amp;&amp; shape-&gt;valueID() == CSSValueEllipse &amp;&amp; horizontalSize &amp;&amp; !verticalSize)
1193         return nullptr;
1194     // If there&#39;s only one size, it must be a length.
1195     if (!verticalSize &amp;&amp; horizontalSize &amp;&amp; horizontalSize-&gt;isPercentage())
1196         return nullptr;
1197     if ((horizontalSize &amp;&amp; horizontalSize-&gt;isCalculatedPercentageWithLength())
1198         || (verticalSize &amp;&amp; verticalSize-&gt;isCalculatedPercentageWithLength()))
1199         return nullptr;
1200 
1201     result-&gt;setShape(shape.copyRef());
1202     result-&gt;setSizingBehavior(sizeKeyword.copyRef());
1203     result-&gt;setEndHorizontalSize(horizontalSize.copyRef());
1204     result-&gt;setEndVerticalSize(verticalSize.copyRef());
1205 
1206     RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1207     RefPtr&lt;CSSPrimitiveValue&gt; centerY;
1208     if (args.peek().id() == CSSValueAt) {
1209         args.consumeIncludingWhitespace();
<span class="line-modified">1210         consumePosition(args, cssParserMode, UnitlessQuirk::Forbid, centerX, centerY);</span>
1211         if (!(centerX &amp;&amp; centerY))
1212             return nullptr;
1213 
1214         result-&gt;setFirstX(centerX.copyRef());
1215         result-&gt;setFirstY(centerY.copyRef());
1216 
1217         // Right now, CSS radial gradients have the same start and end centers.
1218         result-&gt;setSecondX(centerX.copyRef());
1219         result-&gt;setSecondY(centerY.copyRef());
1220     }
1221 
1222     if ((shape || sizeKeyword || horizontalSize || centerX || centerY) &amp;&amp; !consumeCommaIncludingWhitespace(args))
1223         return nullptr;
1224     if (!consumeGradientColorStops(args, cssParserMode, *result))
1225         return nullptr;
1226     return result;
1227 }
1228 
1229 static RefPtr&lt;CSSValue&gt; consumeLinearGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating, CSSGradientType gradientType)
1230 {
</pre>
<hr />
<pre>
1260 }
1261 
1262 static RefPtr&lt;CSSValue&gt; consumeConicGradient(CSSParserTokenRange&amp; args, CSSParserContext context, CSSGradientRepeat repeating)
1263 {
1264 #if ENABLE(CSS_CONIC_GRADIENTS)
1265     RefPtr&lt;CSSConicGradientValue&gt; result = CSSConicGradientValue::create(repeating);
1266 
1267     bool expectComma = false;
1268     if (args.peek().type() == IdentToken) {
1269         if (consumeIdent&lt;CSSValueFrom&gt;(args)) {
1270             auto angle = consumeAngle(args, context.mode, UnitlessQuirk::Forbid);
1271             if (!angle)
1272                 return nullptr;
1273             result-&gt;setAngle(angle.releaseNonNull());
1274             expectComma = true;
1275         }
1276 
1277         if (consumeIdent&lt;CSSValueAt&gt;(args)) {
1278             RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1279             RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">1280             consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY);</span>
1281             if (!(centerX &amp;&amp; centerY))
1282                 return nullptr;
1283 
1284             result-&gt;setFirstX(centerX.copyRef());
1285             result-&gt;setFirstY(centerY.copyRef());
1286 
1287             // Right now, conic gradients have the same start and end centers.
1288             result-&gt;setSecondX(centerX.copyRef());
1289             result-&gt;setSecondY(centerY.copyRef());
1290 
1291             expectComma = true;
1292         }
1293     }
1294 
1295     if (expectComma &amp;&amp; !consumeCommaIncludingWhitespace(args))
1296         return nullptr;
1297     if (!consumeGradientColorStops(args, context.mode, *result))
1298         return nullptr;
1299     return result;
1300 #else
</pre>
<hr />
<pre>
1306 }
1307 
1308 RefPtr&lt;CSSValue&gt; consumeImageOrNone(CSSParserTokenRange&amp; range, CSSParserContext context)
1309 {
1310     if (range.peek().id() == CSSValueNone)
1311         return consumeIdent(range);
1312     return consumeImage(range, context);
1313 }
1314 
1315 static RefPtr&lt;CSSValue&gt; consumeCrossFade(CSSParserTokenRange&amp; args, CSSParserContext context, bool prefixed)
1316 {
1317     RefPtr&lt;CSSValue&gt; fromImageValue = consumeImageOrNone(args, context);
1318     if (!fromImageValue || !consumeCommaIncludingWhitespace(args))
1319         return nullptr;
1320     RefPtr&lt;CSSValue&gt; toImageValue = consumeImageOrNone(args, context);
1321     if (!toImageValue || !consumeCommaIncludingWhitespace(args))
1322         return nullptr;
1323 
1324     RefPtr&lt;CSSPrimitiveValue&gt; percentage;
1325     if (auto percentValue = consumePercent(args, ValueRangeAll))
<span class="line-modified">1326         percentage = CSSValuePool::singleton().createValue(clampTo&lt;double&gt;(percentValue-&gt;doubleValue() / 100.0, 0, 1), CSSPrimitiveValue::UnitType::CSS_NUMBER);</span>
1327     else if (auto numberValue = consumeNumber(args, ValueRangeAll))
<span class="line-modified">1328         percentage = CSSValuePool::singleton().createValue(clampTo&lt;double&gt;(numberValue-&gt;doubleValue(), 0, 1), CSSPrimitiveValue::UnitType::CSS_NUMBER);</span>
1329 
1330     if (!percentage)
1331         return nullptr;
1332     return CSSCrossfadeValue::create(fromImageValue.releaseNonNull(), toImageValue.releaseNonNull(), percentage.releaseNonNull(), prefixed);
1333 }
1334 
1335 static RefPtr&lt;CSSValue&gt; consumeWebkitCanvas(CSSParserTokenRange&amp; args)
1336 {
1337     if (args.peek().type() != IdentToken)
1338         return nullptr;
1339     auto canvasName = args.consumeIncludingWhitespace().value().toString();
1340     if (!args.atEnd())
1341         return nullptr;
1342     return CSSCanvasValue::create(canvasName);
1343 }
1344 
1345 static RefPtr&lt;CSSValue&gt; consumeWebkitNamedImage(CSSParserTokenRange&amp; args)
1346 {
1347     if (args.peek().type() != IdentToken)
1348         return nullptr;
</pre>
<hr />
<pre>
1421     else if (id == CSSValueRepeatingConicGradient)
1422         result = consumeConicGradient(args, context, Repeating);
1423     else if (id == CSSValueWebkitCrossFade || id == CSSValueCrossFade)
1424         result = consumeCrossFade(args, context, id == CSSValueWebkitCrossFade);
1425     else if (id == CSSValueWebkitCanvas)
1426         result = consumeWebkitCanvas(args);
1427     else if (id == CSSValueWebkitNamedImage)
1428         result = consumeWebkitNamedImage(args);
1429     else if (id == CSSValueWebkitFilter || id == CSSValueFilter)
1430         result = consumeFilterImage(args, context);
1431 #if ENABLE(CSS_PAINTING_API)
1432     else if (id == CSSValuePaint)
1433         result = consumeCustomPaint(args);
1434 #endif
1435     if (!result || !args.atEnd())
1436         return nullptr;
1437     range = rangeCopy;
1438     return result;
1439 }
1440 
<span class="line-modified">1441 static RefPtr&lt;CSSValue&gt; consumeImageSet(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
1442 {
1443     CSSParserTokenRange rangeCopy = range;
1444     CSSParserTokenRange args = consumeFunction(rangeCopy);
<span class="line-modified">1445     RefPtr&lt;CSSImageSetValue&gt; imageSet = CSSImageSetValue::create(context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);</span>
1446     do {
<span class="line-modified">1447         AtomString urlValue = consumeUrlAsStringView(args).toAtomString();</span>
<span class="line-modified">1448         if (urlValue.isNull())</span>
1449             return nullptr;
1450 
<span class="line-removed">1451         RefPtr&lt;CSSValue&gt; image = CSSImageValue::create(completeURL(context, urlValue), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);</span>
1452         imageSet-&gt;append(image.releaseNonNull());
1453 
<span class="line-modified">1454         const CSSParserToken&amp; token = args.consumeIncludingWhitespace();</span>
<span class="line-modified">1455         if (token.type() != DimensionToken)</span>
<span class="line-removed">1456             return nullptr;</span>
<span class="line-removed">1457         if (token.value() != &quot;x&quot;)</span>
1458             return nullptr;
<span class="line-modified">1459         ASSERT(token.unitType() == CSSPrimitiveValue::UnitType::CSS_UNKNOWN);</span>
<span class="line-modified">1460         double imageScaleFactor = token.numericValue();</span>
<span class="line-removed">1461         if (imageScaleFactor &lt;= 0)</span>
<span class="line-removed">1462             return nullptr;</span>
<span class="line-removed">1463         imageSet-&gt;append(CSSValuePool::singleton().createValue(imageScaleFactor, CSSPrimitiveValue::UnitType::CSS_NUMBER));</span>
1464     } while (consumeCommaIncludingWhitespace(args));
1465     if (!args.atEnd())
1466         return nullptr;
1467     range = rangeCopy;
1468     return imageSet;
1469 }
1470 
1471 static bool isGeneratedImage(CSSValueID id)
1472 {
1473     return id == CSSValueLinearGradient
1474         || id == CSSValueRadialGradient
1475         || id == CSSValueConicGradient
1476         || id == CSSValueRepeatingLinearGradient
1477         || id == CSSValueRepeatingRadialGradient
1478         || id == CSSValueRepeatingConicGradient
1479         || id == CSSValueWebkitLinearGradient
1480         || id == CSSValueWebkitRadialGradient
1481         || id == CSSValueWebkitRepeatingLinearGradient
1482         || id == CSSValueWebkitRepeatingRadialGradient
1483         || id == CSSValueWebkitGradient
</pre>
<hr />
<pre>
1567     RefPtr&lt;CSSValue&gt; parsedValue;
1568 
1569     if (filterType == CSSValueDropShadow)
1570         parsedValue = consumeSingleShadow(args, context.mode, false, false);
1571     else {
1572         if (args.atEnd())
1573             return filterValue;
1574 
1575         if (filterType == CSSValueHueRotate)
1576             parsedValue = consumeAngle(args, context.mode, UnitlessQuirk::Forbid);
1577         else if (filterType == CSSValueBlur)
1578             parsedValue = consumeLength(args, HTMLStandardMode, ValueRangeNonNegative);
1579         else {
1580             parsedValue = consumePercent(args, ValueRangeNonNegative);
1581             if (!parsedValue)
1582                 parsedValue = consumeNumber(args, ValueRangeNonNegative);
1583             if (parsedValue &amp;&amp; !allowsValuesGreaterThanOne(filterType)) {
1584                 bool isPercentage = downcast&lt;CSSPrimitiveValue&gt;(*parsedValue).isPercentage();
1585                 double maxAllowed = isPercentage ? 100.0 : 1.0;
1586                 if (downcast&lt;CSSPrimitiveValue&gt;(*parsedValue).doubleValue() &gt; maxAllowed)
<span class="line-modified">1587                     parsedValue = CSSPrimitiveValue::create(maxAllowed, isPercentage ? CSSPrimitiveValue::UnitType::CSS_PERCENTAGE : CSSPrimitiveValue::UnitType::CSS_NUMBER);</span>
1588             }
1589         }
1590     }
1591     if (!parsedValue || !args.atEnd())
1592         return nullptr;
1593     filterValue-&gt;append(parsedValue.releaseNonNull());
1594     return filterValue;
1595 }
1596 
1597 RefPtr&lt;CSSValue&gt; consumeFilter(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, AllowedFilterFunctions allowedFunctions)
1598 {
1599     if (range.peek().id() == CSSValueNone)
1600         return consumeIdent(range);
1601 
1602     bool referenceFiltersAllowed = allowedFunctions == AllowedFilterFunctions::PixelFilters;
1603     auto list = CSSValueList::createSpaceSeparated();
1604     do {
1605         RefPtr&lt;CSSValue&gt; filterValue = referenceFiltersAllowed ? consumeUrl(range) : nullptr;
1606         if (!filterValue) {
1607             filterValue = consumeFilterFunction(range, context, allowedFunctions);
</pre>
<hr />
<pre>
1619     RefPtr&lt;CSSPrimitiveValue&gt; style;
1620     RefPtr&lt;CSSPrimitiveValue&gt; color;
1621 
1622     if (range.atEnd())
1623         return nullptr;
1624     if (range.peek().id() == CSSValueInset) {
1625         if (!allowInset)
1626             return nullptr;
1627         style = consumeIdent(range);
1628     }
1629     color = consumeColor(range, cssParserMode);
1630 
1631     auto horizontalOffset = consumeLength(range, cssParserMode, ValueRangeAll);
1632     if (!horizontalOffset)
1633         return nullptr;
1634 
1635     auto verticalOffset = consumeLength(range, cssParserMode, ValueRangeAll);
1636     if (!verticalOffset)
1637         return nullptr;
1638 
<span class="line-modified">1639     auto blurRadius = consumeLength(range, cssParserMode, ValueRangeAll);</span>
1640     RefPtr&lt;CSSPrimitiveValue&gt; spreadDistance;
<span class="line-modified">1641     if (blurRadius) {</span>
<span class="line-modified">1642         // Blur radius must be non-negative.</span>
<span class="line-modified">1643         if (blurRadius-&gt;doubleValue() &lt; 0)</span>



1644             return nullptr;
<span class="line-removed">1645         if (allowSpread)</span>
<span class="line-removed">1646             spreadDistance = consumeLength(range, cssParserMode, ValueRangeAll);</span>
1647     }
1648 



1649     if (!range.atEnd()) {
1650         if (!color)
1651             color = consumeColor(range, cssParserMode);
1652         if (range.peek().id() == CSSValueInset) {
1653             if (!allowInset || style)
1654                 return nullptr;
1655             style = consumeIdent(range);
1656         }
1657     }
1658 
1659     return CSSShadowValue::create(WTFMove(horizontalOffset), WTFMove(verticalOffset), WTFMove(blurRadius), WTFMove(spreadDistance), WTFMove(style), WTFMove(color));
1660 }
1661 
<span class="line-modified">1662 RefPtr&lt;CSSValue&gt; consumeImage(CSSParserTokenRange&amp; range, CSSParserContext context, ConsumeGeneratedImage generatedImage)</span>
1663 {
<span class="line-modified">1664     AtomString uri = consumeUrlAsStringView(range).toAtomString();</span>
<span class="line-modified">1665     if (!uri.isNull())</span>
<span class="line-modified">1666         return CSSImageValue::create(completeURL(context, uri), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);</span>

1667 
1668     if (range.peek().type() == FunctionToken) {
<span class="line-modified">1669         CSSValueID id = range.peek().functionId();</span>
<span class="line-modified">1670         if (id == CSSValueWebkitImageSet || id == CSSValueImageSet)</span>
<span class="line-removed">1671             return consumeImageSet(range, context);</span>
<span class="line-removed">1672         if (generatedImage == ConsumeGeneratedImage::Allow &amp;&amp; isGeneratedImage(id))</span>
1673             return consumeGeneratedImage(range, context);







1674     }







1675     return nullptr;
1676 }
1677 
1678 } // namespace CSSPropertyParserHelpers
1679 
1680 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  69 }
  70 
  71 CSSParserTokenRange consumeFunction(CSSParserTokenRange&amp; range)
  72 {
  73     ASSERT(range.peek().type() == FunctionToken);
  74     CSSParserTokenRange contents = range.consumeBlock();
  75     range.consumeWhitespace();
  76     contents.consumeWhitespace();
  77     return contents;
  78 }
  79 
  80 // FIXME: consider pulling in the parsing logic from CSSCalculationValue.cpp.
  81 class CalcParser {
  82 public:
  83     explicit CalcParser(CSSParserTokenRange&amp; range, CalculationCategory destinationCategory, ValueRange valueRange = ValueRangeAll)
  84         : m_sourceRange(range)
  85         , m_range(range)
  86     {
  87         const CSSParserToken&amp; token = range.peek();
  88         auto functionId = token.functionId();
<span class="line-modified">  89         if (CSSCalcValue::isCalcFunction(functionId))</span>
  90             m_calcValue = CSSCalcValue::create(functionId, consumeFunction(m_range), destinationCategory, valueRange);
  91     }
  92 
  93     const CSSCalcValue* value() const { return m_calcValue.get(); }
<span class="line-added">  94 </span>
  95     RefPtr&lt;CSSPrimitiveValue&gt; consumeValue()
  96     {
  97         if (!m_calcValue)
  98             return nullptr;
  99         m_sourceRange = m_range;
 100         return CSSValuePool::singleton().createValue(WTFMove(m_calcValue));
 101     }
<span class="line-modified"> 102 </span>
<span class="line-added"> 103     RefPtr&lt;CSSPrimitiveValue&gt; consumeInteger(double minimumValue)</span>
 104     {
 105         if (!m_calcValue)
 106             return nullptr;
 107         m_sourceRange = m_range;
<span class="line-modified"> 108         double value = std::max(m_calcValue-&gt;doubleValue(), minimumValue);</span>
<span class="line-added"> 109         value = std::round(value);</span>
<span class="line-added"> 110         return CSSValuePool::singleton().createValue(value, CSSUnitType::CSS_NUMBER);</span>
 111     }
 112 
<span class="line-modified"> 113     RefPtr&lt;CSSPrimitiveValue&gt; consumeNumber()</span>
 114     {
<span class="line-modified"> 115         if (!m_calcValue)</span>
<span class="line-modified"> 116             return nullptr;</span>
 117         m_sourceRange = m_range;
<span class="line-modified"> 118         return CSSValuePool::singleton().createValue(m_calcValue-&gt;doubleValue(), CSSUnitType::CSS_NUMBER);</span>

 119     }
 120 
<span class="line-modified"> 121     bool consumeNumberRaw(double&amp; result)</span>
 122     {
<span class="line-modified"> 123         if (!m_calcValue || m_calcValue-&gt;category() != CalculationCategory::Number)</span>



 124             return false;
 125         m_sourceRange = m_range;
<span class="line-added"> 126         result = m_calcValue-&gt;doubleValue();</span>
 127         return true;
 128     }
 129 
 130 private:
 131     CSSParserTokenRange&amp; m_sourceRange;
 132     CSSParserTokenRange m_range;
 133     RefPtr&lt;CSSCalcValue&gt; m_calcValue;
 134 };
 135 
 136 RefPtr&lt;CSSPrimitiveValue&gt; consumeInteger(CSSParserTokenRange&amp; range, double minimumValue)
 137 {
 138     const CSSParserToken&amp; token = range.peek();
 139     if (token.type() == NumberToken) {
 140         if (token.numericValueType() == NumberValueType || token.numericValue() &lt; minimumValue)
 141             return nullptr;
<span class="line-modified"> 142         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_NUMBER);</span>
 143     }
 144 
 145     if (token.type() != FunctionToken)
 146         return nullptr;
 147 
 148     CalcParser calcParser(range, CalculationCategory::Number);
 149     if (const CSSCalcValue* calculation = calcParser.value()) {
<span class="line-modified"> 150         if (calculation-&gt;category() != CalculationCategory::Number)</span>
 151             return nullptr;
<span class="line-modified"> 152         return calcParser.consumeInteger(minimumValue);</span>



 153     }
 154 
 155     return nullptr;
 156 }
 157 
 158 RefPtr&lt;CSSPrimitiveValue&gt; consumePositiveInteger(CSSParserTokenRange&amp; range)
 159 {
 160     return consumeInteger(range, 1);
 161 }
 162 

















 163 bool consumeNumberRaw(CSSParserTokenRange&amp; range, double&amp; result)
 164 {
 165     const CSSParserToken&amp; token = range.peek();
 166     if (token.type() == NumberToken) {
 167         result = range.consumeIncludingWhitespace().numericValue();
 168         return true;
 169     }
 170 
 171     if (token.type() != FunctionToken)
 172         return false;
 173 
 174     CalcParser calcParser(range, CalculationCategory::Number, ValueRangeAll);
 175     return calcParser.consumeNumberRaw(result);
 176 }
 177 
 178 // FIXME: Work out if this can just call consumeNumberRaw
 179 RefPtr&lt;CSSPrimitiveValue&gt; consumeNumber(CSSParserTokenRange&amp; range, ValueRange valueRange)
 180 {
 181     const CSSParserToken&amp; token = range.peek();
 182     if (token.type() == NumberToken) {
 183         if (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0)
 184             return nullptr;
 185         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 186     }
 187 
 188     if (token.type() != FunctionToken)
 189         return nullptr;
 190 
<span class="line-modified"> 191     CalcParser calcParser(range, CalculationCategory::Number, valueRange);</span>
<span class="line-modified"> 192     if (const CSSCalcValue* calcValue = calcParser.value()) {</span>
<span class="line-modified"> 193         if (calcValue-&gt;category() != CalculationCategory::Number)</span>


 194             return nullptr;
<span class="line-modified"> 195         return calcParser.consumeValue();</span>
 196     }
 197 
 198     return nullptr;
 199 }
 200 
 201 #if !ENABLE(VARIATION_FONTS)
 202 static inline bool divisibleBy100(double value)
 203 {
 204     return static_cast&lt;int&gt;(value / 100) * 100 == value;
 205 }
 206 #endif
 207 
 208 RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeightNumber(CSSParserTokenRange&amp; range)
 209 {
 210     // Values less than or equal to 0 or greater than or equal to 1000 are parse errors.
 211     auto&amp; token = range.peek();
 212     if (token.type() == NumberToken &amp;&amp; token.numericValue() &gt;= 1 &amp;&amp; token.numericValue() &lt;= 1000
 213 #if !ENABLE(VARIATION_FONTS)
 214         &amp;&amp; token.numericValueType() == IntegerValueType &amp;&amp; divisibleBy100(token.numericValue())
 215 #endif
 216     )
 217         return consumeNumber(range, ValueRangeAll);
 218 
 219     if (token.type() != FunctionToken)
 220         return nullptr;
 221 
 222     // &quot;[For calc()], the used value resulting from an expression must be clamped to the range allowed in the target context.&quot;
 223     CalcParser calcParser(range, CalculationCategory::Number, ValueRangeAll);
 224     double result;
 225     if (calcParser.consumeNumberRaw(result)
 226 #if !ENABLE(VARIATION_FONTS)
 227         &amp;&amp; result &gt; 0 &amp;&amp; result &lt; 1000 &amp;&amp; divisibleBy100(result)
 228 #endif
 229     ) {
 230         result = std::min(std::max(result, std::nextafter(0., 1.)), std::nextafter(1000., 0.));
<span class="line-modified"> 231         return CSSValuePool::singleton().createValue(result, CSSUnitType::CSS_NUMBER);</span>
 232     }
 233 
 234     return nullptr;
 235 }
 236 
 237 inline bool shouldAcceptUnitlessValue(double value, CSSParserMode cssParserMode, UnitlessQuirk unitless)
 238 {
 239     // FIXME: Presentational HTML attributes shouldn&#39;t use the CSS parser for lengths
 240     return value == 0
 241         || isUnitLessValueParsingEnabledForMode(cssParserMode)
 242         || (cssParserMode == HTMLQuirksMode &amp;&amp; unitless == UnitlessQuirk::Allow);
 243 }
 244 
 245 RefPtr&lt;CSSPrimitiveValue&gt; consumeLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 246 {
 247     const CSSParserToken&amp; token = range.peek();
 248     if (token.type() == DimensionToken) {
 249         switch (token.unitType()) {
<span class="line-modified"> 250         case CSSUnitType::CSS_QUIRKY_EMS:</span>
 251             if (cssParserMode != UASheetMode)
 252                 return nullptr;
 253             FALLTHROUGH;
<span class="line-modified"> 254         case CSSUnitType::CSS_EMS:</span>
<span class="line-modified"> 255         case CSSUnitType::CSS_REMS:</span>
<span class="line-modified"> 256         case CSSUnitType::CSS_CHS:</span>
<span class="line-modified"> 257         case CSSUnitType::CSS_EXS:</span>
<span class="line-modified"> 258         case CSSUnitType::CSS_PX:</span>
<span class="line-modified"> 259         case CSSUnitType::CSS_CM:</span>
<span class="line-modified"> 260         case CSSUnitType::CSS_MM:</span>
<span class="line-modified"> 261         case CSSUnitType::CSS_IN:</span>
<span class="line-modified"> 262         case CSSUnitType::CSS_PT:</span>
<span class="line-modified"> 263         case CSSUnitType::CSS_PC:</span>
<span class="line-modified"> 264         case CSSUnitType::CSS_VW:</span>
<span class="line-modified"> 265         case CSSUnitType::CSS_VH:</span>
<span class="line-modified"> 266         case CSSUnitType::CSS_VMIN:</span>
<span class="line-modified"> 267         case CSSUnitType::CSS_VMAX:</span>
<span class="line-added"> 268         case CSSUnitType::CSS_Q:</span>
 269             break;
 270         default:
 271             return nullptr;
 272         }
 273         if ((valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0) || std::isinf(token.numericValue()))
 274             return nullptr;
 275         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 276     }
 277     if (token.type() == NumberToken) {
 278         if (!shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless)
 279             || (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0))
 280             return nullptr;
 281         if (std::isinf(token.numericValue()))
 282             return nullptr;
<span class="line-modified"> 283         CSSUnitType unitType = CSSUnitType::CSS_PX;</span>
 284         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unitType);
 285     }
 286 
 287     if (token.type() != FunctionToken)
 288         return nullptr;
 289 
 290     CalcParser calcParser(range, CalculationCategory::Length, valueRange);
 291     if (calcParser.value() &amp;&amp; calcParser.value()-&gt;category() == CalculationCategory::Length)
 292         return calcParser.consumeValue();
 293 
 294     return nullptr;
 295 }
 296 
 297 RefPtr&lt;CSSPrimitiveValue&gt; consumePercent(CSSParserTokenRange&amp; range, ValueRange valueRange)
 298 {
 299     const CSSParserToken&amp; token = range.peek();
 300     if (token.type() == PercentageToken) {
 301         if ((valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0) || std::isinf(token.numericValue()))
 302             return nullptr;
<span class="line-modified"> 303         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_PERCENTAGE);</span>
 304     }
 305 
 306     if (token.type() != FunctionToken)
 307         return nullptr;
 308 
 309     CalcParser calcParser(range, CalculationCategory::Percent, valueRange);
 310     if (const CSSCalcValue* calculation = calcParser.value()) {
 311         if (calculation-&gt;category() == CalculationCategory::Percent)
 312             return calcParser.consumeValue();
 313     }
 314     return nullptr;
 315 }
 316 
 317 static bool canConsumeCalcValue(CalculationCategory category, CSSParserMode cssParserMode)
 318 {
 319     if (category == CalculationCategory::Length || category == CalculationCategory::Percent || category == CalculationCategory::PercentLength)
 320         return true;
 321 
 322     if (cssParserMode != SVGAttributeMode)
 323         return false;
</pre>
<hr />
<pre>
 335         return consumeLength(range, cssParserMode, valueRange, unitless);
 336     if (token.type() == PercentageToken)
 337         return consumePercent(range, valueRange);
 338 
 339     if (token.type() != FunctionToken)
 340         return nullptr;
 341 
 342     CalcParser calcParser(range, CalculationCategory::Length, valueRange);
 343     if (const CSSCalcValue* calculation = calcParser.value()) {
 344         if (canConsumeCalcValue(calculation-&gt;category(), cssParserMode))
 345             return calcParser.consumeValue();
 346     }
 347     return nullptr;
 348 }
 349 
 350 RefPtr&lt;CSSPrimitiveValue&gt; consumeAngle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
 351 {
 352     const CSSParserToken&amp; token = range.peek();
 353     if (token.type() == DimensionToken) {
 354         switch (token.unitType()) {
<span class="line-modified"> 355         case CSSUnitType::CSS_DEG:</span>
<span class="line-modified"> 356         case CSSUnitType::CSS_RAD:</span>
<span class="line-modified"> 357         case CSSUnitType::CSS_GRAD:</span>
<span class="line-modified"> 358         case CSSUnitType::CSS_TURN:</span>
 359             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 360         default:
 361             return nullptr;
 362         }
 363     }
 364 
 365     if (token.type() == NumberToken &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless))
<span class="line-modified"> 366         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_DEG);</span>
 367 
 368     if (token.type() != FunctionToken)
 369         return nullptr;
 370 
 371     CalcParser calcParser(range, CalculationCategory::Angle, ValueRangeAll);
 372     if (const CSSCalcValue* calculation = calcParser.value()) {
 373         if (calculation-&gt;category() == CalculationCategory::Angle)
 374             return calcParser.consumeValue();
 375     }
 376     return nullptr;
 377 }
 378 
 379 static RefPtr&lt;CSSPrimitiveValue&gt; consumeAngleOrPercent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 380 {
 381     const CSSParserToken&amp; token = range.peek();
 382     if (token.type() == DimensionToken) {
 383         switch (token.unitType()) {
<span class="line-modified"> 384         case CSSUnitType::CSS_DEG:</span>
<span class="line-modified"> 385         case CSSUnitType::CSS_RAD:</span>
<span class="line-modified"> 386         case CSSUnitType::CSS_GRAD:</span>
<span class="line-modified"> 387         case CSSUnitType::CSS_TURN:</span>
 388             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 389         default:
 390             return nullptr;
 391         }
 392     }
 393     if (token.type() == NumberToken &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless))
<span class="line-modified"> 394         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_DEG);</span>
 395 
 396     if (token.type() == PercentageToken)
 397         return consumePercent(range, valueRange);
 398 
 399      if (token.type() != FunctionToken)
 400          return nullptr;
 401 
 402     CalcParser angleCalcParser(range, CalculationCategory::Angle, valueRange);
 403     if (const CSSCalcValue* calculation = angleCalcParser.value()) {
 404         if (calculation-&gt;category() == CalculationCategory::Angle)
 405             return angleCalcParser.consumeValue();
 406     }
 407 
 408     CalcParser percentCalcParser(range, CalculationCategory::Percent, valueRange);
 409     if (const CSSCalcValue* calculation = percentCalcParser.value()) {
 410         if (calculation-&gt;category() == CalculationCategory::Percent)
 411             return percentCalcParser.consumeValue();
 412     }
 413     return nullptr;
 414 }
 415 
 416 RefPtr&lt;CSSPrimitiveValue&gt; consumeTime(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 417 {
 418     const CSSParserToken&amp; token = range.peek();
<span class="line-modified"> 419     CSSUnitType unit = token.unitType();</span>
<span class="line-modified"> 420     bool acceptUnitless = token.type() == NumberToken &amp;&amp; unitless == UnitlessQuirk::Allow &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless);</span>
 421     if (acceptUnitless)
<span class="line-modified"> 422         unit = CSSUnitType::CSS_MS;</span>
 423     if (token.type() == DimensionToken || acceptUnitless) {
 424         if (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0)
 425             return nullptr;
<span class="line-modified"> 426         if (unit == CSSUnitType::CSS_MS || unit == CSSUnitType::CSS_S)</span>
 427             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unit);
 428         return nullptr;
 429     }
 430 
 431     if (token.type() != FunctionToken)
 432         return nullptr;
 433 
 434     CalcParser calcParser(range, CalculationCategory::Time, valueRange);
 435     if (const CSSCalcValue* calculation = calcParser.value()) {
 436         if (calculation-&gt;category() == CalculationCategory::Time)
 437             return calcParser.consumeValue();
 438     }
 439     return nullptr;
 440 }
 441 
<span class="line-modified"> 442 RefPtr&lt;CSSPrimitiveValue&gt; consumeResolution(CSSParserTokenRange&amp; range, AllowXResolutionUnit allowX)</span>
 443 {
 444     const CSSParserToken&amp; token = range.peek();
 445     // Unlike the other types, calc() does not work with &lt;resolution&gt;.
 446     if (token.type() != DimensionToken)
 447         return nullptr;
<span class="line-modified"> 448     CSSUnitType unit = token.unitType();</span>
<span class="line-modified"> 449     if (unit == CSSUnitType::CSS_DPPX || unit == CSSUnitType::CSS_DPI || unit == CSSUnitType::CSS_DPCM)</span>
 450         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unit);
<span class="line-added"> 451     if (allowX == AllowXResolutionUnit::Allow &amp;&amp; token.value() == &quot;x&quot;)</span>
<span class="line-added"> 452         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_DPPX);</span>
<span class="line-added"> 453 </span>
 454     return nullptr;
 455 }
 456 
 457 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdent(CSSParserTokenRange&amp; range)
 458 {
 459     if (range.peek().type() != IdentToken)
 460         return nullptr;
 461     return CSSValuePool::singleton().createIdentifierValue(range.consumeIncludingWhitespace().id());
 462 }
 463 
 464 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdentRange(CSSParserTokenRange&amp; range, CSSValueID lower, CSSValueID upper)
 465 {
 466     if (range.peek().id() &lt; lower || range.peek().id() &gt; upper)
 467         return nullptr;
 468     return consumeIdent(range);
 469 }
 470 
 471 // FIXME-NEWPARSER: Eventually we&#39;d like this to use CSSCustomIdentValue, but we need
 472 // to do other plumbing work first (like changing Pair to CSSValuePair and make it not
 473 // use only primitive values).
 474 RefPtr&lt;CSSPrimitiveValue&gt; consumeCustomIdent(CSSParserTokenRange&amp; range)
 475 {
 476     if (range.peek().type() != IdentToken || isCSSWideKeyword(range.peek().id()))
 477         return nullptr;
<span class="line-modified"> 478     return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().value().toString(), CSSUnitType::CSS_STRING);</span>
 479 }
 480 
 481 RefPtr&lt;CSSPrimitiveValue&gt; consumeString(CSSParserTokenRange&amp; range)
 482 {
 483     if (range.peek().type() != StringToken)
 484         return nullptr;
<span class="line-modified"> 485     return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().value().toString(), CSSUnitType::CSS_STRING);</span>
 486 }
 487 
 488 StringView consumeUrlAsStringView(CSSParserTokenRange&amp; range)
 489 {
 490     const CSSParserToken&amp; token = range.peek();
 491     if (token.type() == UrlToken) {
 492         range.consumeIncludingWhitespace();
 493         return token.value();
 494     }
 495     if (token.functionId() == CSSValueUrl) {
 496         CSSParserTokenRange urlRange = range;
 497         CSSParserTokenRange urlArgs = urlRange.consumeBlock();
 498         const CSSParserToken&amp; next = urlArgs.consumeIncludingWhitespace();
 499         if (next.type() == BadStringToken || !urlArgs.atEnd())
 500             return StringView();
 501         ASSERT(next.type() == StringToken);
 502         range = urlRange;
 503         range.consumeWhitespace();
 504         return next.value();
 505     }
 506 
 507     return StringView();
 508 }
 509 
 510 RefPtr&lt;CSSPrimitiveValue&gt; consumeUrl(CSSParserTokenRange&amp; range)
 511 {
 512     StringView url = consumeUrlAsStringView(range);
 513     if (url.isNull())
 514         return nullptr;
<span class="line-modified"> 515     return CSSValuePool::singleton().createValue(url.toString(), CSSUnitType::CSS_URI);</span>
 516 }
 517 
 518 static int clampRGBComponent(const CSSPrimitiveValue&amp; value)
 519 {
 520     double result = value.doubleValue();
 521     if (value.isPercentage())
 522         result = result / 100.0 * 255.0;
 523 
 524     return clampTo&lt;int&gt;(round(result), 0, 255);
 525 }
 526 
 527 static Color parseRGBParameters(CSSParserTokenRange&amp; range)
 528 {
 529     ASSERT(range.peek().functionId() == CSSValueRgb || range.peek().functionId() == CSSValueRgba);
 530     Color result;
 531     CSSParserTokenRange args = consumeFunction(range);
 532     RefPtr&lt;CSSPrimitiveValue&gt; colorParameter = consumeNumber(args, ValueRangeAll);
 533     if (!colorParameter)
 534         colorParameter = consumePercent(args, ValueRangeAll);
 535     if (!colorParameter)
</pre>
<hr />
<pre>
 565     }
 566 
 567     // Historically, alpha was only parsed for rgba(), but css-color-4 specifies that rgba() is a simple alias for rgb().
 568     auto consumeAlphaSeparator = [&amp;] {
 569         if (syntax == ColorSyntax::Commas)
 570             return consumeCommaIncludingWhitespace(args);
 571 
 572         return consumeSlashIncludingWhitespace(args);
 573     };
 574 
 575     int alphaComponent = 255;
 576     if (consumeAlphaSeparator()) {
 577         double alpha;
 578         if (!consumeNumberRaw(args, alpha)) {
 579             auto alphaPercent = consumePercent(args, ValueRangeAll);
 580             if (!alphaPercent)
 581                 return Color();
 582             alpha = alphaPercent-&gt;doubleValue() / 100.0;
 583         }
 584 
<span class="line-modified"> 585         // W3 standard stipulates a 2.55 alpha value multiplication factor.</span>
<span class="line-modified"> 586         alphaComponent = static_cast&lt;int&gt;(lroundf(clampTo&lt;double&gt;(alpha, 0.0, 1.0) * 255.0f));</span>

 587     };
 588 
 589     result = Color(makeRGBA(colorArray[0], colorArray[1], colorArray[2], alphaComponent));
 590 
 591     if (!args.atEnd())
 592         return Color();
 593 
 594     return result;
 595 }
 596 
 597 static Color parseHSLParameters(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 598 {
 599     ASSERT(range.peek().functionId() == CSSValueHsl || range.peek().functionId() == CSSValueHsla);
 600     CSSParserTokenRange args = consumeFunction(range);
 601     auto hslValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
 602     double angleInDegrees;
 603     if (!hslValue) {
 604         hslValue = consumeNumber(args, ValueRangeAll);
 605         if (!hslValue)
 606             return Color();
 607         angleInDegrees = hslValue-&gt;doubleValue();
 608     } else
 609         angleInDegrees = hslValue-&gt;computeDegrees();
<span class="line-added"> 610 </span>
 611     double colorArray[3];
<span class="line-modified"> 612     colorArray[0] = fmod(fmod(angleInDegrees, 360.0) + 360.0, 360.0) / 360.0;</span>

 613     bool requiresCommas = false;
 614     for (int i = 1; i &lt; 3; i++) {
 615         if (consumeCommaIncludingWhitespace(args)) {
 616             if (i != 1 &amp;&amp; !requiresCommas)
 617                 return Color();
 618             requiresCommas = true;
 619         } else if (requiresCommas || args.atEnd() || (&amp;args.peek() - 1)-&gt;type() != WhitespaceToken)
 620             return Color();
 621         hslValue = consumePercent(args, ValueRangeAll);
 622         if (!hslValue)
 623             return Color();
 624         double doubleValue = hslValue-&gt;doubleValue();
 625         colorArray[i] = clampTo&lt;double&gt;(doubleValue, 0.0, 100.0) / 100.0; // Needs to be value between 0 and 1.0.
 626     }
 627 
 628     double alpha = 1.0;
 629     bool commaConsumed = consumeCommaIncludingWhitespace(args);
 630     bool slashConsumed = consumeSlashIncludingWhitespace(args);
 631     if ((commaConsumed &amp;&amp; !requiresCommas) || (slashConsumed &amp;&amp; requiresCommas))
 632         return Color();
 633     if (commaConsumed || slashConsumed) {
 634         if (!consumeNumberRaw(args, alpha)) {
 635             auto alphaPercent = consumePercent(args, ValueRangeAll);
 636             if (!alphaPercent)
 637                 return Color();
 638             alpha = alphaPercent-&gt;doubleValue() / 100.0f;
 639         }
 640         alpha = clampTo&lt;double&gt;(alpha, 0.0, 1.0);
 641     }
 642 
 643     if (!args.atEnd())
 644         return Color();
 645 
<span class="line-modified"> 646     return Color(makeRGBAFromHSLA(static_cast&lt;float&gt;(colorArray[0]), static_cast&lt;float&gt;(colorArray[1]), static_cast&lt;float&gt;(colorArray[2]), static_cast&lt;float&gt;(alpha)));</span>
 647 }
 648 
 649 static Color parseColorFunctionParameters(CSSParserTokenRange&amp; range)
 650 {
 651     ASSERT(range.peek().functionId() == CSSValueColor);
 652     CSSParserTokenRange args = consumeFunction(range);
 653 
 654     ColorSpace colorSpace;
 655     switch (args.peek().id()) {
 656     case CSSValueSRGB:
<span class="line-modified"> 657         colorSpace = ColorSpace::SRGB;</span>
 658         break;
 659     case CSSValueDisplayP3:
<span class="line-modified"> 660         colorSpace = ColorSpace::DisplayP3;</span>
 661         break;
 662     default:
 663         return Color();
 664     }
 665     consumeIdent(args);
 666 
 667     double colorChannels[4] = { 0, 0, 0, 1 };
 668     for (int i = 0; i &lt; 3; ++i) {
 669         double value;
 670         if (consumeNumberRaw(args, value))
 671             colorChannels[i] = std::max(0.0, std::min(1.0, value));
 672         else
 673             break;
 674     }
 675 
 676     if (consumeSlashIncludingWhitespace(args)) {
 677         auto alphaParameter = consumePercent(args, ValueRangeAll);
 678         if (!alphaParameter)
 679             alphaParameter = consumeNumber(args, ValueRangeAll);
 680         if (!alphaParameter)
</pre>
<hr />
<pre>
 798     bool mustOrderAsXY = isHorizontalPositionKeywordOnly(value1) || isVerticalPositionKeywordOnly(value2)
 799         || !value1.isValueID() || !value2.isValueID();
 800     bool mustOrderAsYX = isVerticalPositionKeywordOnly(value1) || isHorizontalPositionKeywordOnly(value2);
 801     if (mustOrderAsXY &amp;&amp; mustOrderAsYX)
 802         return false;
 803     resultX = &amp;value1;
 804     resultY = &amp;value2;
 805     if (mustOrderAsYX)
 806         std::swap(resultX, resultY);
 807     return true;
 808 }
 809 
 810 namespace CSSPropertyParserHelpersInternal {
 811 template&lt;typename... Args&gt;
 812 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
 813 {
 814     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
 815 }
 816 }
 817 
<span class="line-modified"> 818 // https://drafts.csswg.org/css-backgrounds-3/#propdef-background-position</span>
<span class="line-added"> 819 // background-position has special parsing rules, allowing a 3-value syntax:</span>
<span class="line-added"> 820 // &lt;bg-position&gt; =  [ left | center | right | top | bottom | &lt;length-percentage&gt; ]</span>
<span class="line-added"> 821 // |</span>
<span class="line-added"> 822 //   [ left | center | right | &lt;length-percentage&gt; ]</span>
<span class="line-added"> 823 //   [ top | center | bottom | &lt;length-percentage&gt; ]</span>
<span class="line-added"> 824 // |</span>
<span class="line-added"> 825 //   [ center | [ left | right ] &lt;length-percentage&gt;? ] &amp;&amp;</span>
<span class="line-added"> 826 //   [ center | [ top | bottom ] &lt;length-percentage&gt;? ]</span>
<span class="line-added"> 827 //</span>
<span class="line-added"> 828 static bool backgroundPositionFromThreeValues(const std::array&lt;CSSPrimitiveValue*, 5&gt;&amp; values, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)</span>
 829 {
 830     CSSPrimitiveValue* center = nullptr;
 831     for (int i = 0; values[i]; i++) {
 832         CSSPrimitiveValue* currentValue = values[i];
 833         if (!currentValue-&gt;isValueID())
 834             return false;

 835 
<span class="line-added"> 836         CSSValueID id = currentValue-&gt;valueID();</span>
 837         if (id == CSSValueCenter) {
 838             if (center)
 839                 return false;
 840             center = currentValue;
 841             continue;
 842         }
 843 
 844         RefPtr&lt;CSSPrimitiveValue&gt; result;
 845         if (values[i + 1] &amp;&amp; !values[i + 1]-&gt;isValueID())
 846             result = CSSPropertyParserHelpersInternal::createPrimitiveValuePair(currentValue, values[++i]);
 847         else
 848             result = currentValue;
 849 
 850         if (id == CSSValueLeft || id == CSSValueRight) {
 851             if (resultX)
 852                 return false;
 853             resultX = result;
 854         } else {
 855             ASSERT(id == CSSValueTop || id == CSSValueBottom);
 856             if (resultY)
 857                 return false;
 858             resultY = result;
 859         }
 860     }
 861 
 862     if (center) {
 863         ASSERT(resultX || resultY);
 864         if (resultX &amp;&amp; resultY)
 865             return false;
 866         if (!resultX)
 867             resultX = center;
 868         else
 869             resultY = center;
 870     }
 871 
 872     ASSERT(resultX &amp;&amp; resultY);
 873     return true;
 874 }
 875 
<span class="line-added"> 876 // https://drafts.csswg.org/css-values-4/#typedef-position</span>
<span class="line-added"> 877 // &lt;position&gt; = [</span>
<span class="line-added"> 878 //   [ left | center | right ] || [ top | center | bottom ]</span>
<span class="line-added"> 879 // |</span>
<span class="line-added"> 880 //   [ left | center | right | &lt;length-percentage&gt; ]</span>
<span class="line-added"> 881 //   [ top | center | bottom | &lt;length-percentage&gt; ]?</span>
<span class="line-added"> 882 // |</span>
<span class="line-added"> 883 //   [ [ left | right ] &lt;length-percentage&gt; ] &amp;&amp;</span>
<span class="line-added"> 884 //   [ [ top | bottom ] &lt;length-percentage&gt; ]</span>
<span class="line-added"> 885 //</span>
<span class="line-added"> 886 static bool positionFromFourValues(const std::array&lt;CSSPrimitiveValue*, 5&gt;&amp; values, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)</span>
<span class="line-added"> 887 {</span>
<span class="line-added"> 888     for (int i = 0; values[i]; i++) {</span>
<span class="line-added"> 889         CSSPrimitiveValue* currentValue = values[i];</span>
<span class="line-added"> 890         if (!currentValue-&gt;isValueID())</span>
<span class="line-added"> 891             return false;</span>
<span class="line-added"> 892 </span>
<span class="line-added"> 893         CSSValueID id = currentValue-&gt;valueID();</span>
<span class="line-added"> 894         if (id == CSSValueCenter)</span>
<span class="line-added"> 895             return false;</span>
<span class="line-added"> 896 </span>
<span class="line-added"> 897         RefPtr&lt;CSSPrimitiveValue&gt; result;</span>
<span class="line-added"> 898         if (values[i + 1] &amp;&amp; !values[i + 1]-&gt;isValueID())</span>
<span class="line-added"> 899             result = CSSPropertyParserHelpersInternal::createPrimitiveValuePair(currentValue, values[++i]);</span>
<span class="line-added"> 900         else</span>
<span class="line-added"> 901             result = currentValue;</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903         if (id == CSSValueLeft || id == CSSValueRight) {</span>
<span class="line-added"> 904             if (resultX)</span>
<span class="line-added"> 905                 return false;</span>
<span class="line-added"> 906             resultX = result;</span>
<span class="line-added"> 907         } else {</span>
<span class="line-added"> 908             ASSERT(id == CSSValueTop || id == CSSValueBottom);</span>
<span class="line-added"> 909             if (resultY)</span>
<span class="line-added"> 910                 return false;</span>
<span class="line-added"> 911             resultY = result;</span>
<span class="line-added"> 912         }</span>
<span class="line-added"> 913     }</span>
<span class="line-added"> 914 </span>
<span class="line-added"> 915     ASSERT(resultX &amp;&amp; resultY);</span>
<span class="line-added"> 916     return true;</span>
<span class="line-added"> 917 }</span>
<span class="line-added"> 918 </span>
 919 // FIXME: This may consume from the range upon failure. The background
 920 // shorthand works around it, but we should just fix it here.
<span class="line-modified"> 921 bool consumePosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, PositionSyntax positionSyntax, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)</span>
 922 {
 923     RefPtr&lt;CSSPrimitiveValue&gt; value1 = consumePositionComponent(range, cssParserMode, unitless);
 924     if (!value1)
 925         return false;
 926 
 927     RefPtr&lt;CSSPrimitiveValue&gt; value2 = consumePositionComponent(range, cssParserMode, unitless);
 928     if (!value2) {
 929         positionFromOneValue(*value1, resultX, resultY);
 930         return true;
 931     }
 932 
 933     RefPtr&lt;CSSPrimitiveValue&gt; value3 = consumePositionComponent(range, cssParserMode, unitless);
 934     if (!value3)
 935         return positionFromTwoValues(*value1, *value2, resultX, resultY);
 936 
 937     RefPtr&lt;CSSPrimitiveValue&gt; value4 = consumePositionComponent(range, cssParserMode, unitless);
<span class="line-modified"> 938 </span>
<span class="line-added"> 939     std::array&lt;CSSPrimitiveValue*, 5&gt; values;</span>
 940     values[0] = value1.get();
 941     values[1] = value2.get();
 942     values[2] = value3.get();
 943     values[3] = value4.get();
 944     values[4] = nullptr;
<span class="line-modified"> 945 </span>
<span class="line-added"> 946     if (value4)</span>
<span class="line-added"> 947         return positionFromFourValues(values, resultX, resultY);</span>
<span class="line-added"> 948 </span>
<span class="line-added"> 949     if (positionSyntax != PositionSyntax::BackgroundPosition)</span>
<span class="line-added"> 950         return false;</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952     return backgroundPositionFromThreeValues(values, resultX, resultY);</span>
 953 }
 954 
<span class="line-modified"> 955 RefPtr&lt;CSSPrimitiveValue&gt; consumePosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, PositionSyntax positionSyntax)</span>
 956 {
 957     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 958     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
<span class="line-modified"> 959     if (consumePosition(range, cssParserMode, unitless, positionSyntax, resultX, resultY))</span>
 960         return CSSPropertyParserHelpersInternal::createPrimitiveValuePair(resultX.releaseNonNull(), resultY.releaseNonNull());
 961     return nullptr;
 962 }
 963 
 964 bool consumeOneOrTwoValuedPosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 965 {
 966     RefPtr&lt;CSSPrimitiveValue&gt; value1 = consumePositionComponent(range, cssParserMode, unitless);
 967     if (!value1)
 968         return false;
 969     RefPtr&lt;CSSPrimitiveValue&gt; value2 = consumePositionComponent(range, cssParserMode, unitless);
 970     if (!value2) {
 971         positionFromOneValue(*value1, resultX, resultY);
 972         return true;
 973     }
 974     return positionFromTwoValues(*value1, *value2, resultX, resultY);
 975 }
 976 
 977 // This should go away once we drop support for -webkit-gradient
 978 static RefPtr&lt;CSSPrimitiveValue&gt; consumeDeprecatedGradientPoint(CSSParserTokenRange&amp; args, bool horizontal)
 979 {
 980     if (args.peek().type() == IdentToken) {
 981         if ((horizontal &amp;&amp; consumeIdent&lt;CSSValueLeft&gt;(args)) || (!horizontal &amp;&amp; consumeIdent&lt;CSSValueTop&gt;(args)))
<span class="line-modified"> 982             return CSSValuePool::singleton().createValue(0., CSSUnitType::CSS_PERCENTAGE);</span>
 983         if ((horizontal &amp;&amp; consumeIdent&lt;CSSValueRight&gt;(args)) || (!horizontal &amp;&amp; consumeIdent&lt;CSSValueBottom&gt;(args)))
<span class="line-modified"> 984             return CSSValuePool::singleton().createValue(100., CSSUnitType::CSS_PERCENTAGE);</span>
 985         if (consumeIdent&lt;CSSValueCenter&gt;(args))
<span class="line-modified"> 986             return CSSValuePool::singleton().createValue(50., CSSUnitType::CSS_PERCENTAGE);</span>
 987         return nullptr;
 988     }
 989     RefPtr&lt;CSSPrimitiveValue&gt; result = consumePercent(args, ValueRangeAll);
 990     if (!result)
 991         result = consumeNumber(args, ValueRangeAll);
 992     return result;
 993 }
 994 
 995 // Used to parse colors for -webkit-gradient(...).
 996 static RefPtr&lt;CSSPrimitiveValue&gt; consumeDeprecatedGradientStopColor(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
 997 {
 998     if (args.peek().id() == CSSValueCurrentcolor)
 999         return nullptr;
1000     return consumeColor(args, cssParserMode);
1001 }
1002 
1003 static bool consumeDeprecatedGradientColorStop(CSSParserTokenRange&amp; range, CSSGradientColorStop&amp; stop, CSSParserMode cssParserMode)
1004 {
1005     CSSValueID id = range.peek().functionId();
1006     if (id != CSSValueFrom &amp;&amp; id != CSSValueTo &amp;&amp; id != CSSValueColorStop)
1007         return false;
1008 
1009     CSSParserTokenRange args = consumeFunction(range);
1010     double position;
1011     if (id == CSSValueFrom || id == CSSValueTo) {
1012         position = (id == CSSValueFrom) ? 0 : 1;
1013     } else {
1014         ASSERT(id == CSSValueColorStop);
1015         if (auto percentValue = consumePercent(args, ValueRangeAll))
1016             position = percentValue-&gt;doubleValue() / 100.0;
1017         else if (!consumeNumberRaw(args, position))
1018             return false;
1019 
1020         if (!consumeCommaIncludingWhitespace(args))
1021             return false;
1022     }
1023 
<span class="line-modified">1024     stop.m_position = CSSValuePool::singleton().createValue(position, CSSUnitType::CSS_NUMBER);</span>
1025     stop.m_color = consumeDeprecatedGradientStopColor(args, cssParserMode);
1026     return stop.m_color &amp;&amp; args.atEnd();
1027 }
1028 
1029 static RefPtr&lt;CSSValue&gt; consumeDeprecatedGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
1030 {
1031     RefPtr&lt;CSSGradientValue&gt; result;
1032     CSSValueID id = args.consumeIncludingWhitespace().id();
1033     bool isDeprecatedRadialGradient = (id == CSSValueRadial);
1034     if (isDeprecatedRadialGradient)
1035         result = CSSRadialGradientValue::create(NonRepeating, CSSDeprecatedRadialGradient);
1036     else if (id == CSSValueLinear)
1037         result = CSSLinearGradientValue::create(NonRepeating, CSSDeprecatedLinearGradient);
1038     if (!result || !consumeCommaIncludingWhitespace(args))
1039         return nullptr;
1040 
<span class="line-modified">1041     auto point = consumeDeprecatedGradientPoint(args, true);</span>
1042     if (!point)
1043         return nullptr;
1044     result-&gt;setFirstX(point.copyRef());
1045     point = consumeDeprecatedGradientPoint(args, false);
1046     if (!point)
1047         return nullptr;
1048     result-&gt;setFirstY(point.copyRef());
1049 
1050     if (!consumeCommaIncludingWhitespace(args))
1051         return nullptr;
1052 
1053     // For radial gradients only, we now expect a numeric radius.
1054     if (isDeprecatedRadialGradient) {
<span class="line-modified">1055         auto radius = consumeNumber(args, ValueRangeNonNegative);</span>
1056         if (!radius || !consumeCommaIncludingWhitespace(args))
1057             return nullptr;
1058         downcast&lt;CSSRadialGradientValue&gt;(result.get())-&gt;setFirstRadius(radius.copyRef());
1059     }
1060 
1061     point = consumeDeprecatedGradientPoint(args, true);
1062     if (!point)
1063         return nullptr;
1064     result-&gt;setSecondX(point.copyRef());
1065     point = consumeDeprecatedGradientPoint(args, false);
1066     if (!point)
1067         return nullptr;
1068     result-&gt;setSecondY(point.copyRef());
1069 
1070     // For radial gradients only, we now expect the second radius.
1071     if (isDeprecatedRadialGradient) {
1072         if (!consumeCommaIncludingWhitespace(args))
1073             return nullptr;
<span class="line-modified">1074         auto radius = consumeNumber(args, ValueRangeNonNegative);</span>
1075         if (!radius)
1076             return nullptr;
1077         downcast&lt;CSSRadialGradientValue&gt;(result.get())-&gt;setSecondRadius(radius.copyRef());
1078     }
1079 
1080     CSSGradientColorStop stop;
1081     while (consumeCommaIncludingWhitespace(args)) {
1082         if (!consumeDeprecatedGradientColorStop(args, stop, cssParserMode))
1083             return nullptr;
1084         result-&gt;addStop(stop);
1085     }
1086 
1087     result-&gt;doneAddingStops();
1088     return result;
1089 }
1090 
1091 static bool consumeGradientColorStops(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSGradientValue&amp; gradient)
1092 {
1093     bool supportsColorHints = gradient.gradientType() == CSSLinearGradient || gradient.gradientType() == CSSRadialGradient || gradient.gradientType() == CSSConicGradient;
1094 
</pre>
<hr />
<pre>
1098     bool previousStopWasColorHint = true;
1099     do {
1100         CSSGradientColorStop stop;
1101         stop.m_color = consumeColor(range, cssParserMode);
1102         // Two hints in a row are not allowed.
1103         if (!stop.m_color &amp;&amp; (!supportsColorHints || previousStopWasColorHint))
1104             return false;
1105 
1106         previousStopWasColorHint = !stop.m_color;
1107 
1108         // FIXME-NEWPARSER: This boolean could be removed. Null checking color would be sufficient.
1109         stop.isMidpoint = !stop.m_color;
1110 
1111         if (isConicGradient)
1112             stop.m_position = consumeAngleOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Forbid);
1113         else
1114             stop.m_position = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
1115 
1116         if (!stop.m_color &amp;&amp; !stop.m_position)
1117             return false;
<span class="line-added">1118 </span>
1119         gradient.addStop(stop);
1120 
<span class="line-modified">1121         if (!stop.m_color || !stop.m_position)</span>
<span class="line-added">1122             continue;</span>
<span class="line-added">1123 </span>
1124         CSSGradientColorStop secondStop;
1125         if (isConicGradient)
1126             secondStop.m_position = consumeAngleOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Forbid);
1127         else
1128             secondStop.m_position = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
1129 
<span class="line-modified">1130         if (secondStop.m_position)</span>

1131             gradient.addStop(secondStop);

1132 
1133     } while (consumeCommaIncludingWhitespace(range));
1134 
1135     gradient.doneAddingStops();
1136 
1137     // The last color stop cannot be a color hint.
1138     if (previousStopWasColorHint)
1139         return false;
1140 
1141     // Must have 2 or more stops to be valid.
1142     return gradient.stopCount() &gt;= 2;
1143 }
1144 
1145 static RefPtr&lt;CSSValue&gt; consumeDeprecatedRadialGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating)
1146 {
1147     RefPtr&lt;CSSRadialGradientValue&gt; result = CSSRadialGradientValue::create(repeating, CSSPrefixedRadialGradient);
1148     RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1149     RefPtr&lt;CSSPrimitiveValue&gt; centerY;
1150     consumeOneOrTwoValuedPosition(args, cssParserMode, UnitlessQuirk::Forbid, centerX, centerY);
1151     if ((centerX || centerY) &amp;&amp; !consumeCommaIncludingWhitespace(args))
1152         return nullptr;
1153 
1154     result-&gt;setFirstX(centerX.copyRef());
1155     result-&gt;setFirstY(centerY.copyRef());
1156     result-&gt;setSecondX(centerX.copyRef());
1157     result-&gt;setSecondY(centerY.copyRef());
1158 
<span class="line-modified">1159     auto shape = consumeIdent&lt;CSSValueCircle, CSSValueEllipse&gt;(args);</span>
<span class="line-modified">1160     auto sizeKeyword = consumeIdent&lt;CSSValueClosestSide, CSSValueClosestCorner, CSSValueFarthestSide, CSSValueFarthestCorner, CSSValueContain, CSSValueCover&gt;(args);</span>
1161     if (!shape)
1162         shape = consumeIdent&lt;CSSValueCircle, CSSValueEllipse&gt;(args);
1163     result-&gt;setShape(shape.copyRef());
1164     result-&gt;setSizingBehavior(sizeKeyword.copyRef());
1165 
1166     // Or, two lengths or percentages
1167     if (!shape &amp;&amp; !sizeKeyword) {
<span class="line-modified">1168         auto horizontalSize = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);</span>
1169         RefPtr&lt;CSSPrimitiveValue&gt; verticalSize;
1170         if (horizontalSize) {
<span class="line-modified">1171             verticalSize = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);</span>
1172             if (!verticalSize)
1173                 return nullptr;
1174             consumeCommaIncludingWhitespace(args);
1175             result-&gt;setEndHorizontalSize(horizontalSize.copyRef());
1176             result-&gt;setEndVerticalSize(verticalSize.copyRef());
1177         }
1178     } else {
1179         consumeCommaIncludingWhitespace(args);
1180     }
1181     if (!consumeGradientColorStops(args, cssParserMode, *result))
1182         return nullptr;
1183 
1184     return result;
1185 }
1186 
1187 static RefPtr&lt;CSSValue&gt; consumeRadialGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating)
1188 {
1189     RefPtr&lt;CSSRadialGradientValue&gt; result = CSSRadialGradientValue::create(repeating, CSSRadialGradient);
1190 
1191     RefPtr&lt;CSSPrimitiveValue&gt; shape;
</pre>
<hr />
<pre>
1195 
1196     // First part of grammar, the size/shape clause:
1197     // [ circle || &lt;length&gt; ] |
1198     // [ ellipse || [ &lt;length&gt; | &lt;percentage&gt; ]{2} ] |
1199     // [ [ circle | ellipse] || &lt;size-keyword&gt; ]
1200     for (int i = 0; i &lt; 3; ++i) {
1201         if (args.peek().type() == IdentToken) {
1202             CSSValueID id = args.peek().id();
1203             if (id == CSSValueCircle || id == CSSValueEllipse) {
1204                 if (shape)
1205                     return nullptr;
1206                 shape = consumeIdent(args);
1207             } else if (id == CSSValueClosestSide || id == CSSValueClosestCorner || id == CSSValueFarthestSide || id == CSSValueFarthestCorner) {
1208                 if (sizeKeyword)
1209                     return nullptr;
1210                 sizeKeyword = consumeIdent(args);
1211             } else {
1212                 break;
1213             }
1214         } else {
<span class="line-modified">1215             auto center = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);</span>
1216             if (!center)
1217                 break;
1218             if (horizontalSize)
1219                 return nullptr;
1220             horizontalSize = center;
<span class="line-modified">1221             center = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);</span>
1222             if (center) {
1223                 verticalSize = center;
1224                 ++i;
1225             }
1226         }
1227     }
1228 
1229     // You can specify size as a keyword or a length/percentage, not both.
1230     if (sizeKeyword &amp;&amp; horizontalSize)
1231         return nullptr;
1232     // Circles must have 0 or 1 lengths.
1233     if (shape &amp;&amp; shape-&gt;valueID() == CSSValueCircle &amp;&amp; verticalSize)
1234         return nullptr;
1235     // Ellipses must have 0 or 2 length/percentages.
1236     if (shape &amp;&amp; shape-&gt;valueID() == CSSValueEllipse &amp;&amp; horizontalSize &amp;&amp; !verticalSize)
1237         return nullptr;
1238     // If there&#39;s only one size, it must be a length.
1239     if (!verticalSize &amp;&amp; horizontalSize &amp;&amp; horizontalSize-&gt;isPercentage())
1240         return nullptr;
1241     if ((horizontalSize &amp;&amp; horizontalSize-&gt;isCalculatedPercentageWithLength())
1242         || (verticalSize &amp;&amp; verticalSize-&gt;isCalculatedPercentageWithLength()))
1243         return nullptr;
1244 
1245     result-&gt;setShape(shape.copyRef());
1246     result-&gt;setSizingBehavior(sizeKeyword.copyRef());
1247     result-&gt;setEndHorizontalSize(horizontalSize.copyRef());
1248     result-&gt;setEndVerticalSize(verticalSize.copyRef());
1249 
1250     RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1251     RefPtr&lt;CSSPrimitiveValue&gt; centerY;
1252     if (args.peek().id() == CSSValueAt) {
1253         args.consumeIncludingWhitespace();
<span class="line-modified">1254         consumePosition(args, cssParserMode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY);</span>
1255         if (!(centerX &amp;&amp; centerY))
1256             return nullptr;
1257 
1258         result-&gt;setFirstX(centerX.copyRef());
1259         result-&gt;setFirstY(centerY.copyRef());
1260 
1261         // Right now, CSS radial gradients have the same start and end centers.
1262         result-&gt;setSecondX(centerX.copyRef());
1263         result-&gt;setSecondY(centerY.copyRef());
1264     }
1265 
1266     if ((shape || sizeKeyword || horizontalSize || centerX || centerY) &amp;&amp; !consumeCommaIncludingWhitespace(args))
1267         return nullptr;
1268     if (!consumeGradientColorStops(args, cssParserMode, *result))
1269         return nullptr;
1270     return result;
1271 }
1272 
1273 static RefPtr&lt;CSSValue&gt; consumeLinearGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating, CSSGradientType gradientType)
1274 {
</pre>
<hr />
<pre>
1304 }
1305 
1306 static RefPtr&lt;CSSValue&gt; consumeConicGradient(CSSParserTokenRange&amp; args, CSSParserContext context, CSSGradientRepeat repeating)
1307 {
1308 #if ENABLE(CSS_CONIC_GRADIENTS)
1309     RefPtr&lt;CSSConicGradientValue&gt; result = CSSConicGradientValue::create(repeating);
1310 
1311     bool expectComma = false;
1312     if (args.peek().type() == IdentToken) {
1313         if (consumeIdent&lt;CSSValueFrom&gt;(args)) {
1314             auto angle = consumeAngle(args, context.mode, UnitlessQuirk::Forbid);
1315             if (!angle)
1316                 return nullptr;
1317             result-&gt;setAngle(angle.releaseNonNull());
1318             expectComma = true;
1319         }
1320 
1321         if (consumeIdent&lt;CSSValueAt&gt;(args)) {
1322             RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1323             RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">1324             consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY);</span>
1325             if (!(centerX &amp;&amp; centerY))
1326                 return nullptr;
1327 
1328             result-&gt;setFirstX(centerX.copyRef());
1329             result-&gt;setFirstY(centerY.copyRef());
1330 
1331             // Right now, conic gradients have the same start and end centers.
1332             result-&gt;setSecondX(centerX.copyRef());
1333             result-&gt;setSecondY(centerY.copyRef());
1334 
1335             expectComma = true;
1336         }
1337     }
1338 
1339     if (expectComma &amp;&amp; !consumeCommaIncludingWhitespace(args))
1340         return nullptr;
1341     if (!consumeGradientColorStops(args, context.mode, *result))
1342         return nullptr;
1343     return result;
1344 #else
</pre>
<hr />
<pre>
1350 }
1351 
1352 RefPtr&lt;CSSValue&gt; consumeImageOrNone(CSSParserTokenRange&amp; range, CSSParserContext context)
1353 {
1354     if (range.peek().id() == CSSValueNone)
1355         return consumeIdent(range);
1356     return consumeImage(range, context);
1357 }
1358 
1359 static RefPtr&lt;CSSValue&gt; consumeCrossFade(CSSParserTokenRange&amp; args, CSSParserContext context, bool prefixed)
1360 {
1361     RefPtr&lt;CSSValue&gt; fromImageValue = consumeImageOrNone(args, context);
1362     if (!fromImageValue || !consumeCommaIncludingWhitespace(args))
1363         return nullptr;
1364     RefPtr&lt;CSSValue&gt; toImageValue = consumeImageOrNone(args, context);
1365     if (!toImageValue || !consumeCommaIncludingWhitespace(args))
1366         return nullptr;
1367 
1368     RefPtr&lt;CSSPrimitiveValue&gt; percentage;
1369     if (auto percentValue = consumePercent(args, ValueRangeAll))
<span class="line-modified">1370         percentage = CSSValuePool::singleton().createValue(clampTo&lt;double&gt;(percentValue-&gt;doubleValue() / 100.0, 0, 1), CSSUnitType::CSS_NUMBER);</span>
1371     else if (auto numberValue = consumeNumber(args, ValueRangeAll))
<span class="line-modified">1372         percentage = CSSValuePool::singleton().createValue(clampTo&lt;double&gt;(numberValue-&gt;doubleValue(), 0, 1), CSSUnitType::CSS_NUMBER);</span>
1373 
1374     if (!percentage)
1375         return nullptr;
1376     return CSSCrossfadeValue::create(fromImageValue.releaseNonNull(), toImageValue.releaseNonNull(), percentage.releaseNonNull(), prefixed);
1377 }
1378 
1379 static RefPtr&lt;CSSValue&gt; consumeWebkitCanvas(CSSParserTokenRange&amp; args)
1380 {
1381     if (args.peek().type() != IdentToken)
1382         return nullptr;
1383     auto canvasName = args.consumeIncludingWhitespace().value().toString();
1384     if (!args.atEnd())
1385         return nullptr;
1386     return CSSCanvasValue::create(canvasName);
1387 }
1388 
1389 static RefPtr&lt;CSSValue&gt; consumeWebkitNamedImage(CSSParserTokenRange&amp; args)
1390 {
1391     if (args.peek().type() != IdentToken)
1392         return nullptr;
</pre>
<hr />
<pre>
1465     else if (id == CSSValueRepeatingConicGradient)
1466         result = consumeConicGradient(args, context, Repeating);
1467     else if (id == CSSValueWebkitCrossFade || id == CSSValueCrossFade)
1468         result = consumeCrossFade(args, context, id == CSSValueWebkitCrossFade);
1469     else if (id == CSSValueWebkitCanvas)
1470         result = consumeWebkitCanvas(args);
1471     else if (id == CSSValueWebkitNamedImage)
1472         result = consumeWebkitNamedImage(args);
1473     else if (id == CSSValueWebkitFilter || id == CSSValueFilter)
1474         result = consumeFilterImage(args, context);
1475 #if ENABLE(CSS_PAINTING_API)
1476     else if (id == CSSValuePaint)
1477         result = consumeCustomPaint(args);
1478 #endif
1479     if (!result || !args.atEnd())
1480         return nullptr;
1481     range = rangeCopy;
1482     return result;
1483 }
1484 
<span class="line-modified">1485 static RefPtr&lt;CSSValue&gt; consumeImageSet(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, OptionSet&lt;AllowedImageType&gt; allowedImageTypes)</span>
1486 {
1487     CSSParserTokenRange rangeCopy = range;
1488     CSSParserTokenRange args = consumeFunction(rangeCopy);
<span class="line-modified">1489     RefPtr&lt;CSSImageSetValue&gt; imageSet = CSSImageSetValue::create();</span>
1490     do {
<span class="line-modified">1491         auto image = consumeImage(args, context, allowedImageTypes);</span>
<span class="line-modified">1492         if (!image)</span>
1493             return nullptr;
1494 

1495         imageSet-&gt;append(image.releaseNonNull());
1496 
<span class="line-modified">1497         auto resolution = consumeResolution(args, AllowXResolutionUnit::Allow);</span>
<span class="line-modified">1498         if (!resolution || resolution-&gt;floatValue() &lt;= 0)</span>


1499             return nullptr;
<span class="line-modified">1500 </span>
<span class="line-modified">1501         imageSet-&gt;append(resolution.releaseNonNull());</span>



1502     } while (consumeCommaIncludingWhitespace(args));
1503     if (!args.atEnd())
1504         return nullptr;
1505     range = rangeCopy;
1506     return imageSet;
1507 }
1508 
1509 static bool isGeneratedImage(CSSValueID id)
1510 {
1511     return id == CSSValueLinearGradient
1512         || id == CSSValueRadialGradient
1513         || id == CSSValueConicGradient
1514         || id == CSSValueRepeatingLinearGradient
1515         || id == CSSValueRepeatingRadialGradient
1516         || id == CSSValueRepeatingConicGradient
1517         || id == CSSValueWebkitLinearGradient
1518         || id == CSSValueWebkitRadialGradient
1519         || id == CSSValueWebkitRepeatingLinearGradient
1520         || id == CSSValueWebkitRepeatingRadialGradient
1521         || id == CSSValueWebkitGradient
</pre>
<hr />
<pre>
1605     RefPtr&lt;CSSValue&gt; parsedValue;
1606 
1607     if (filterType == CSSValueDropShadow)
1608         parsedValue = consumeSingleShadow(args, context.mode, false, false);
1609     else {
1610         if (args.atEnd())
1611             return filterValue;
1612 
1613         if (filterType == CSSValueHueRotate)
1614             parsedValue = consumeAngle(args, context.mode, UnitlessQuirk::Forbid);
1615         else if (filterType == CSSValueBlur)
1616             parsedValue = consumeLength(args, HTMLStandardMode, ValueRangeNonNegative);
1617         else {
1618             parsedValue = consumePercent(args, ValueRangeNonNegative);
1619             if (!parsedValue)
1620                 parsedValue = consumeNumber(args, ValueRangeNonNegative);
1621             if (parsedValue &amp;&amp; !allowsValuesGreaterThanOne(filterType)) {
1622                 bool isPercentage = downcast&lt;CSSPrimitiveValue&gt;(*parsedValue).isPercentage();
1623                 double maxAllowed = isPercentage ? 100.0 : 1.0;
1624                 if (downcast&lt;CSSPrimitiveValue&gt;(*parsedValue).doubleValue() &gt; maxAllowed)
<span class="line-modified">1625                     parsedValue = CSSPrimitiveValue::create(maxAllowed, isPercentage ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);</span>
1626             }
1627         }
1628     }
1629     if (!parsedValue || !args.atEnd())
1630         return nullptr;
1631     filterValue-&gt;append(parsedValue.releaseNonNull());
1632     return filterValue;
1633 }
1634 
1635 RefPtr&lt;CSSValue&gt; consumeFilter(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, AllowedFilterFunctions allowedFunctions)
1636 {
1637     if (range.peek().id() == CSSValueNone)
1638         return consumeIdent(range);
1639 
1640     bool referenceFiltersAllowed = allowedFunctions == AllowedFilterFunctions::PixelFilters;
1641     auto list = CSSValueList::createSpaceSeparated();
1642     do {
1643         RefPtr&lt;CSSValue&gt; filterValue = referenceFiltersAllowed ? consumeUrl(range) : nullptr;
1644         if (!filterValue) {
1645             filterValue = consumeFilterFunction(range, context, allowedFunctions);
</pre>
<hr />
<pre>
1657     RefPtr&lt;CSSPrimitiveValue&gt; style;
1658     RefPtr&lt;CSSPrimitiveValue&gt; color;
1659 
1660     if (range.atEnd())
1661         return nullptr;
1662     if (range.peek().id() == CSSValueInset) {
1663         if (!allowInset)
1664             return nullptr;
1665         style = consumeIdent(range);
1666     }
1667     color = consumeColor(range, cssParserMode);
1668 
1669     auto horizontalOffset = consumeLength(range, cssParserMode, ValueRangeAll);
1670     if (!horizontalOffset)
1671         return nullptr;
1672 
1673     auto verticalOffset = consumeLength(range, cssParserMode, ValueRangeAll);
1674     if (!verticalOffset)
1675         return nullptr;
1676 
<span class="line-modified">1677     RefPtr&lt;CSSPrimitiveValue&gt; blurRadius;</span>
1678     RefPtr&lt;CSSPrimitiveValue&gt; spreadDistance;
<span class="line-modified">1679 </span>
<span class="line-modified">1680     const CSSParserToken&amp; token = range.peek();</span>
<span class="line-modified">1681     // The explicit check for calc() is unfortunate. This is ensuring that we only fail parsing if there is a length, but it fails the range check.</span>
<span class="line-added">1682     if (token.type() == DimensionToken || token.type() == NumberToken || (token.type() == FunctionToken &amp;&amp; CSSCalcValue::isCalcFunction(token.functionId()))) {</span>
<span class="line-added">1683         blurRadius = consumeLength(range, cssParserMode, ValueRangeNonNegative);</span>
<span class="line-added">1684         if (!blurRadius)</span>
1685             return nullptr;


1686     }
1687 
<span class="line-added">1688     if (blurRadius &amp;&amp; allowSpread)</span>
<span class="line-added">1689         spreadDistance = consumeLength(range, cssParserMode, ValueRangeAll);</span>
<span class="line-added">1690 </span>
1691     if (!range.atEnd()) {
1692         if (!color)
1693             color = consumeColor(range, cssParserMode);
1694         if (range.peek().id() == CSSValueInset) {
1695             if (!allowInset || style)
1696                 return nullptr;
1697             style = consumeIdent(range);
1698         }
1699     }
1700 
1701     return CSSShadowValue::create(WTFMove(horizontalOffset), WTFMove(verticalOffset), WTFMove(blurRadius), WTFMove(spreadDistance), WTFMove(style), WTFMove(color));
1702 }
1703 
<span class="line-modified">1704 RefPtr&lt;CSSValue&gt; consumeImage(CSSParserTokenRange&amp; range, CSSParserContext context, OptionSet&lt;AllowedImageType&gt; allowedImageTypes)</span>
1705 {
<span class="line-modified">1706     if ((range.peek().type() == StringToken) &amp;&amp; (allowedImageTypes.contains(AllowedImageType::RawStringAsURL))) {</span>
<span class="line-modified">1707         auto urlStringView = range.consumeIncludingWhitespace().value();</span>
<span class="line-modified">1708         return CSSImageValue::create(completeURL(context, urlStringView.toAtomString()), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);</span>
<span class="line-added">1709     }</span>
1710 
1711     if (range.peek().type() == FunctionToken) {
<span class="line-modified">1712         CSSValueID functionId = range.peek().functionId();</span>
<span class="line-modified">1713         if ((allowedImageTypes.contains(AllowedImageType::GeneratedImage)) &amp;&amp; isGeneratedImage(functionId))</span>


1714             return consumeGeneratedImage(range, context);
<span class="line-added">1715 </span>
<span class="line-added">1716         if (allowedImageTypes.contains(AllowedImageType::ImageSet)) {</span>
<span class="line-added">1717             if (functionId == CSSValueImageSet)</span>
<span class="line-added">1718                 return consumeImageSet(range, context, (allowedImageTypes | AllowedImageType::RawStringAsURL) - AllowedImageType::ImageSet);</span>
<span class="line-added">1719             if (functionId == CSSValueWebkitImageSet)</span>
<span class="line-added">1720                 return consumeImageSet(range, context, AllowedImageType::URLFunction);</span>
<span class="line-added">1721         }</span>
1722     }
<span class="line-added">1723 </span>
<span class="line-added">1724     if (allowedImageTypes.contains(AllowedImageType::URLFunction)) {</span>
<span class="line-added">1725         auto uri = consumeUrlAsStringView(range);</span>
<span class="line-added">1726         if (!uri.isNull())</span>
<span class="line-added">1727             return CSSImageValue::create(completeURL(context, uri.toAtomString()), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);</span>
<span class="line-added">1728     }</span>
<span class="line-added">1729 </span>
1730     return nullptr;
1731 }
1732 
1733 } // namespace CSSPropertyParserHelpers
1734 
1735 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CSSPropertyParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParserHelpers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  * Copyright (C) 2004-2016 Apple Inc. All rights reserved.
  5  * Copyright (C) 2010 Google Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;HTMLImageElement.h&quot;
 25 
 26 #include &quot;CSSPropertyNames.h&quot;
 27 #include &quot;CSSValueKeywords.h&quot;
 28 #include &quot;CachedImage.h&quot;
 29 #include &quot;Chrome.h&quot;
 30 #include &quot;ChromeClient.h&quot;
 31 #include &quot;EditableImageReference.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;ElementIterator.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLAttachmentElement.h&quot;
 38 #include &quot;HTMLDocument.h&quot;
 39 #include &quot;HTMLFormElement.h&quot;
 40 #include &quot;HTMLImageLoader.h&quot;
 41 #include &quot;HTMLParserIdioms.h&quot;
 42 #include &quot;HTMLPictureElement.h&quot;
 43 #include &quot;HTMLMapElement.h&quot;
 44 #include &quot;HTMLSourceElement.h&quot;
 45 #include &quot;HTMLSrcsetParser.h&quot;
 46 #include &quot;Logging.h&quot;
 47 #include &quot;MIMETypeRegistry.h&quot;
 48 #include &quot;MediaList.h&quot;
 49 #include &quot;MediaQueryEvaluator.h&quot;
 50 #include &quot;MouseEvent.h&quot;
 51 #include &quot;NodeTraversal.h&quot;
 52 #include &quot;PlatformMouseEvent.h&quot;
 53 #include &quot;RenderImage.h&quot;
 54 #include &quot;RenderView.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
 56 #include &quot;Settings.h&quot;
 57 #include &quot;ShadowRoot.h&quot;
 58 #include &quot;SizesAttributeParser.h&quot;
 59 #include &lt;wtf/IsoMallocInlines.h&gt;
 60 #include &lt;wtf/text/StringBuilder.h&gt;
 61 
 62 #if ENABLE(SERVICE_CONTROLS)
 63 #include &quot;ImageControlsRootElement.h&quot;
 64 #endif
 65 
 66 namespace WebCore {
 67 
 68 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLImageElement);
 69 
 70 using namespace HTMLNames;
 71 
 72 HTMLImageElement::HTMLImageElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 73     : HTMLElement(tagName, document)
 74     , m_imageLoader(WTF::makeUnique&lt;HTMLImageLoader&gt;(*this))
 75     , m_form(nullptr)
 76     , m_formSetByParser(makeWeakPtr(form))
 77     , m_compositeOperator(CompositeOperator::SourceOver)
 78     , m_imageDevicePixelRatio(1.0f)
 79     , m_experimentalImageMenuEnabled(false)
 80     , m_createdByParser(createdByParser)
 81 {
 82     ASSERT(hasTagName(imgTag));
 83     setHasCustomStyleResolveCallbacks();
 84 }
 85 
 86 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(Document&amp; document)
 87 {
 88     return adoptRef(*new HTMLImageElement(imgTag, document));
 89 }
 90 
 91 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)
 92 {
 93     return adoptRef(*new HTMLImageElement(tagName, document, form, createdByParser));
 94 }
 95 
 96 HTMLImageElement::~HTMLImageElement()
 97 {
 98     document().removeDynamicMediaQueryDependentImage(*this);
 99 
100     if (m_form)
101         m_form-&gt;removeImgElement(this);
102     setPictureElement(nullptr);
103 }
104 
105 Ref&lt;HTMLImageElement&gt; HTMLImageElement::createForJSConstructor(Document&amp; document, Optional&lt;unsigned&gt; width, Optional&lt;unsigned&gt; height)
106 {
107     auto image = adoptRef(*new HTMLImageElement(imgTag, document));
108     if (width)
109         image-&gt;setWidth(width.value());
110     if (height)
111         image-&gt;setHeight(height.value());
112     return image;
113 }
114 
115 bool HTMLImageElement::isPresentationAttribute(const QualifiedName&amp; name) const
116 {
117     if (name == widthAttr || name == heightAttr || name == borderAttr || name == vspaceAttr || name == hspaceAttr || name == valignAttr)
118         return true;
119     return HTMLElement::isPresentationAttribute(name);
120 }
121 
122 void HTMLImageElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
123 {
124     if (name == widthAttr)
125         addHTMLLengthToStyle(style, CSSPropertyWidth, value);
126     else if (name == heightAttr)
127         addHTMLLengthToStyle(style, CSSPropertyHeight, value);
128     else if (name == borderAttr)
129         applyBorderAttributeToStyle(value, style);
130     else if (name == vspaceAttr) {
131         addHTMLLengthToStyle(style, CSSPropertyMarginTop, value);
132         addHTMLLengthToStyle(style, CSSPropertyMarginBottom, value);
133     } else if (name == hspaceAttr) {
134         addHTMLLengthToStyle(style, CSSPropertyMarginLeft, value);
135         addHTMLLengthToStyle(style, CSSPropertyMarginRight, value);
136     } else if (name == alignAttr)
137         applyAlignmentAttributeToStyle(value, style);
138     else if (name == valignAttr)
139         addPropertyToPresentationAttributeStyle(style, CSSPropertyVerticalAlign, value);
140     else
141         HTMLElement::collectStyleForPresentationAttribute(name, value, style);
142 }
143 
144 const AtomString&amp; HTMLImageElement::imageSourceURL() const
145 {
146     return m_bestFitImageURL.isEmpty() ? attributeWithoutSynchronization(srcAttr) : m_bestFitImageURL;
147 }
148 
149 void HTMLImageElement::setBestFitURLAndDPRFromImageCandidate(const ImageCandidate&amp; candidate)
150 {
151     m_bestFitImageURL = candidate.string.toAtomString();
152     m_currentSrc = AtomString(document().completeURL(imageSourceURL()).string());
153     if (candidate.density &gt;= 0)
154         m_imageDevicePixelRatio = 1 / candidate.density;
155     if (is&lt;RenderImage&gt;(renderer()))
156         downcast&lt;RenderImage&gt;(*renderer()).setImageDevicePixelRatio(m_imageDevicePixelRatio);
157 }
158 
159 ImageCandidate HTMLImageElement::bestFitSourceFromPictureElement()
160 {
161     auto picture = makeRefPtr(pictureElement());
162     if (!picture)
163         return { };
164 
165     ImageCandidate candidate;
166 
167     for (RefPtr&lt;Node&gt; child = picture-&gt;firstChild(); child &amp;&amp; child != this; child = child-&gt;nextSibling()) {
168         if (!is&lt;HTMLSourceElement&gt;(*child))
169             continue;
170         auto&amp; source = downcast&lt;HTMLSourceElement&gt;(*child);
171 
172         auto&amp; srcset = source.attributeWithoutSynchronization(srcsetAttr);
173         if (srcset.isEmpty())
174             continue;
175 
176         auto&amp; typeAttribute = source.attributeWithoutSynchronization(typeAttr);
177         if (!typeAttribute.isNull()) {
178             String type = typeAttribute.string();
179             type.truncate(type.find(&#39;;&#39;));
180             type = stripLeadingAndTrailingHTMLSpaces(type);
181             if (!type.isEmpty() &amp;&amp; !MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(type))
182                 continue;
183         }
184 
185         auto documentElement = makeRefPtr(document().documentElement());
186         MediaQueryEvaluator evaluator { document().printing() ? &quot;print&quot; : &quot;screen&quot;, document(), documentElement ? documentElement-&gt;computedStyle() : nullptr };
187         auto* queries = source.parsedMediaAttribute(document());
188         LOG(MediaQueries, &quot;HTMLImageElement %p bestFitSourceFromPictureElement evaluating media queries&quot;, this);
189 
190         auto evaluation = !queries || evaluator.evaluate(*queries, &amp;m_mediaQueryDynamicResults);
191         if (!evaluation)
192             continue;
193 
194         SizesAttributeParser sizesParser(source.attributeWithoutSynchronization(sizesAttr).string(), document(), &amp;m_mediaQueryDynamicResults);
195         auto sourceSize = sizesParser.length();
196 
197         candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), nullAtom(), srcset, sourceSize);
198         if (!candidate.isEmpty())
199             break;
200     }
201 
202     return candidate;
203 }
204 
205 void HTMLImageElement::evaluateDynamicMediaQueryDependencies()
206 {
207     auto documentElement = makeRefPtr(document().documentElement());
208     MediaQueryEvaluator evaluator { document().printing() ? &quot;print&quot; : &quot;screen&quot;, document(), documentElement ? documentElement-&gt;computedStyle() : nullptr };
209 
210     if (!evaluator.evaluateForChanges(m_mediaQueryDynamicResults))
211         return;
212 
213     selectImageSource();
214 }
215 
216 void HTMLImageElement::selectImageSource()
217 {
218     m_mediaQueryDynamicResults = { };
219     document().removeDynamicMediaQueryDependentImage(*this);
220 
221     // First look for the best fit source from our &lt;picture&gt; parent if we have one.
222     ImageCandidate candidate = bestFitSourceFromPictureElement();
223     if (candidate.isEmpty()) {
224         // If we don&#39;t have a &lt;picture&gt; or didn&#39;t find a source, then we use our own attributes.
225         SizesAttributeParser sizesParser(attributeWithoutSynchronization(sizesAttr).string(), document(), &amp;m_mediaQueryDynamicResults);
226         auto sourceSize = sizesParser.length();
227         candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);
228     }
229     setBestFitURLAndDPRFromImageCandidate(candidate);
230     m_imageLoader-&gt;updateFromElementIgnoringPreviousError();
231 
232     if (!m_mediaQueryDynamicResults.isEmpty())
233         document().addDynamicMediaQueryDependentImage(*this);
234 }
235 
236 void HTMLImageElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
237 {
238     if (name == altAttr) {
239         if (is&lt;RenderImage&gt;(renderer()))
240             downcast&lt;RenderImage&gt;(*renderer()).updateAltText();
241     } else if (name == srcAttr || name == srcsetAttr || name == sizesAttr)
242         selectImageSource();
243     else if (name == usemapAttr) {
244         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
245             treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
246 
247         m_parsedUsemap = parseHTMLHashNameReference(value);
248 
249         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
250             treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
251     } else if (name == compositeAttr) {
252         // FIXME: images don&#39;t support blend modes in their compositing attribute.
253         BlendMode blendOp = BlendMode::Normal;
254         if (!parseCompositeAndBlendOperator(value, m_compositeOperator, blendOp))
255             m_compositeOperator = CompositeOperator::SourceOver;
256 #if ENABLE(SERVICE_CONTROLS)
257     } else if (name == webkitimagemenuAttr) {
258         m_experimentalImageMenuEnabled = !value.isNull();
259         updateImageControls();
260 #endif
261     } else if (name == x_apple_editable_imageAttr)
262         updateEditableImage();
263     else {
264         if (name == nameAttr) {
265             bool willHaveName = !value.isNull();
266             if (m_hadNameBeforeAttributeChanged != willHaveName &amp;&amp; isConnected() &amp;&amp; !isInShadowTree() &amp;&amp; is&lt;HTMLDocument&gt;(document())) {
267                 HTMLDocument&amp; document = downcast&lt;HTMLDocument&gt;(this-&gt;document());
268                 const AtomString&amp; id = getIdAttribute();
269                 if (!id.isEmpty() &amp;&amp; id != getNameAttribute()) {
270                     if (willHaveName)
271                         document.addDocumentNamedItem(*id.impl(), *this);
272                     else
273                         document.removeDocumentNamedItem(*id.impl(), *this);
274                 }
275             }
276             m_hadNameBeforeAttributeChanged = willHaveName;
277         }
278         HTMLElement::parseAttribute(name, value);
279     }
280 }
281 
282 const AtomString&amp; HTMLImageElement::altText() const
283 {
284     // lets figure out the alt text.. magic stuff
285     // http://www.w3.org/TR/1998/REC-html40-19980424/appendix/notes.html#altgen
286     // also heavily discussed by Hixie on bugzilla
287     const AtomString&amp; alt = attributeWithoutSynchronization(altAttr);
288     if (!alt.isNull())
289         return alt;
290     // fall back to title attribute
291     return attributeWithoutSynchronization(titleAttr);
292 }
293 
294 RenderPtr&lt;RenderElement&gt; HTMLImageElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
295 {
296     if (style.hasContent())
297         return RenderElement::createFor(*this, WTFMove(style));
298 
299     return createRenderer&lt;RenderImage&gt;(*this, WTFMove(style), nullptr, m_imageDevicePixelRatio);
300 }
301 
302 bool HTMLImageElement::canStartSelection() const
303 {
304     if (shadowRoot())
305         return HTMLElement::canStartSelection();
306 
307     return false;
308 }
309 
310 bool HTMLImageElement::supportsFocus() const
311 {
312     if (hasEditableImageAttribute())
313         return true;
314     return HTMLElement::supportsFocus();
315 }
316 
317 bool HTMLImageElement::isFocusable() const
318 {
319     if (hasEditableImageAttribute())
320         return true;
321     return HTMLElement::isFocusable();
322 }
323 
324 bool HTMLImageElement::isInteractiveContent() const
325 {
326     return hasAttributeWithoutSynchronization(usemapAttr);
327 }
328 
329 void HTMLImageElement::didAttachRenderers()
330 {
331     if (!is&lt;RenderImage&gt;(renderer()))
332         return;
333     if (m_imageLoader-&gt;hasPendingBeforeLoadEvent())
334         return;
335 
336 #if ENABLE(SERVICE_CONTROLS)
337     updateImageControls();
338 #endif
339 
340     auto&amp; renderImage = downcast&lt;RenderImage&gt;(*renderer());
341     RenderImageResource&amp; renderImageResource = renderImage.imageResource();
342     if (renderImageResource.cachedImage())
343         return;
344     renderImageResource.setCachedImage(m_imageLoader-&gt;image());
345 
346     // If we have no image at all because we have no src attribute, set
347     // image height and width for the alt text instead.
348     if (!m_imageLoader-&gt;image() &amp;&amp; !renderImageResource.cachedImage())
349         renderImage.setImageSizeForAltText();
350 }
351 
352 Node::InsertedIntoAncestorResult HTMLImageElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
353 {
354     if (m_formSetByParser) {
355         m_form = WTFMove(m_formSetByParser);
356         m_form-&gt;registerImgElement(this);
357     }
358 
359     if (m_form &amp;&amp; rootElement() != m_form-&gt;rootElement()) {
360         m_form-&gt;removeImgElement(this);
361         m_form = nullptr;
362     }
363 
364     if (!m_form) {
365         if (auto* newForm = HTMLFormElement::findClosestFormAncestor(*this)) {
366             m_form = makeWeakPtr(newForm);
367             newForm-&gt;registerImgElement(this);
368         }
369     }
370 
371     // Insert needs to complete first, before we start updating the loader. Loader dispatches events which could result
372     // in callbacks back to this node.
373     Node::InsertedIntoAncestorResult insertNotificationRequest = HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
374 
375     if (insertionType.connectedToDocument &amp;&amp; hasEditableImageAttribute())
376         insertNotificationRequest = InsertedIntoAncestorResult::NeedsPostInsertionCallback;
377 
378     if (insertionType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
379         treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
380 
381     if (is&lt;HTMLPictureElement&gt;(parentNode())) {
382         setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(*parentNode()));
383         selectImageSource();
384     }
385 
386     // If we have been inserted from a renderer-less document,
387     // our loader may have not fetched the image, so do it now.
388     if (insertionType.connectedToDocument &amp;&amp; !m_imageLoader-&gt;image())
389         m_imageLoader-&gt;updateFromElement();
390 
391     return insertNotificationRequest;
392 }
393 
394 void HTMLImageElement::didFinishInsertingNode()
395 {
396     if (hasEditableImageAttribute())
397         updateEditableImage();
398 }
399 
400 void HTMLImageElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
401 {
402     if (m_form)
403         m_form-&gt;removeImgElement(this);
404 
405     if (removalType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
406         oldParentOfRemovedTree.treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
407 
408     if (is&lt;HTMLPictureElement&gt;(parentNode()))
409         setPictureElement(nullptr);
410 
411     if (removalType.disconnectedFromDocument)
412         updateEditableImage();
413 
414     m_form = nullptr;
415     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
416 }
417 
418 bool HTMLImageElement::hasEditableImageAttribute() const
419 {
420     if (!document().settings().editableImagesEnabled())
421         return false;
422     return hasAttributeWithoutSynchronization(x_apple_editable_imageAttr);
423 }
424 
425 GraphicsLayer::EmbeddedViewID HTMLImageElement::editableImageViewID() const
426 {
427     if (!m_editableImage)
428         return 0;
429     return m_editableImage-&gt;embeddedViewID();
430 }
431 
432 void HTMLImageElement::updateEditableImage()
433 {
434     if (!document().settings().editableImagesEnabled())
435         return;
436 
437     auto* page = document().page();
438     if (!page)
439         return;
440 
441     bool hasEditableAttribute = hasEditableImageAttribute();
442     bool isCurrentlyEditable = !!m_editableImage;
443     bool shouldBeEditable = isConnected() &amp;&amp; hasEditableAttribute;
444 
445 #if ENABLE(ATTACHMENT_ELEMENT)
446     // Create the inner attachment for editable images, or non-editable
447     // images that were cloned from editable image sources.
448     if (!attachmentElement() &amp;&amp; (shouldBeEditable || !m_pendingClonedAttachmentID.isEmpty())) {
449         auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, document());
450         if (!m_pendingClonedAttachmentID.isEmpty())
451             attachment-&gt;setUniqueIdentifier(WTFMove(m_pendingClonedAttachmentID));
452         else
453             attachment-&gt;ensureUniqueIdentifier();
454         setAttachmentElement(WTFMove(attachment));
455     }
456 #endif
457 
458     if (shouldBeEditable == isCurrentlyEditable)
459         return;
460 
461     if (!hasEditableAttribute) {
462         m_editableImage = nullptr;
463         return;
464     }
465 
466     if (!m_editableImage)
467         m_editableImage = EditableImageReference::create(document());
468 
469 #if ENABLE(ATTACHMENT_ELEMENT)
470     m_editableImage-&gt;associateWithAttachment(attachmentElement()-&gt;uniqueIdentifier());
471 #endif
472 }
473 
474 HTMLPictureElement* HTMLImageElement::pictureElement() const
475 {
476     return m_pictureElement.get();
477 }
478 
479 void HTMLImageElement::setPictureElement(HTMLPictureElement* pictureElement)
480 {
481     m_pictureElement = makeWeakPtr(pictureElement);
482 }
483 
484 unsigned HTMLImageElement::width(bool ignorePendingStylesheets)
485 {
486     if (!renderer()) {
487         // check the attribute first for an explicit pixel value
488         auto optionalWidth = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(widthAttr));
489         if (optionalWidth)
490             return optionalWidth.value();
491 
492         // if the image is available, use its width
493         if (m_imageLoader-&gt;image())
494             return m_imageLoader-&gt;image()-&gt;imageSizeForRenderer(renderer(), 1.0f).width().toUnsigned();
495     }
496 
497     if (ignorePendingStylesheets)
498         document().updateLayoutIgnorePendingStylesheets();
499     else
500         document().updateLayout();
501 
502     RenderBox* box = renderBox();
503     if (!box)
504         return 0;
505     LayoutRect contentRect = box-&gt;contentBoxRect();
506     return adjustForAbsoluteZoom(snappedIntRect(contentRect).width(), *box);
507 }
508 
509 unsigned HTMLImageElement::height(bool ignorePendingStylesheets)
510 {
511     if (!renderer()) {
512         // check the attribute first for an explicit pixel value
513         auto optionalHeight = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(heightAttr));
514         if (optionalHeight)
515             return optionalHeight.value();
516 
517         // if the image is available, use its height
518         if (m_imageLoader-&gt;image())
519             return m_imageLoader-&gt;image()-&gt;imageSizeForRenderer(renderer(), 1.0f).height().toUnsigned();
520     }
521 
522     if (ignorePendingStylesheets)
523         document().updateLayoutIgnorePendingStylesheets();
524     else
525         document().updateLayout();
526 
527     RenderBox* box = renderBox();
528     if (!box)
529         return 0;
530     LayoutRect contentRect = box-&gt;contentBoxRect();
531     return adjustForAbsoluteZoom(snappedIntRect(contentRect).height(), *box);
532 }
533 
534 float HTMLImageElement::effectiveImageDevicePixelRatio() const
535 {
536     if (!m_imageLoader-&gt;image())
537         return 1.0f;
538 
539     auto* image = m_imageLoader-&gt;image()-&gt;image();
540 
541     if (image &amp;&amp; image-&gt;isSVGImage())
542         return 1.0f;
543 
544     return m_imageDevicePixelRatio;
545 }
546 
547 int HTMLImageElement::naturalWidth() const
548 {
549     if (!m_imageLoader-&gt;image())
550         return 0;
551 
552     return m_imageLoader-&gt;image()-&gt;unclampedImageSizeForRenderer(renderer(), effectiveImageDevicePixelRatio()).width();
553 }
554 
555 int HTMLImageElement::naturalHeight() const
556 {
557     if (!m_imageLoader-&gt;image())
558         return 0;
559 
560     return m_imageLoader-&gt;image()-&gt;unclampedImageSizeForRenderer(renderer(), effectiveImageDevicePixelRatio()).height();
561 }
562 
563 bool HTMLImageElement::isURLAttribute(const Attribute&amp; attribute) const
564 {
565     return attribute.name() == srcAttr
566         || attribute.name() == lowsrcAttr
567         || attribute.name() == longdescAttr
568         || (attribute.name() == usemapAttr &amp;&amp; attribute.value().string()[0] != &#39;#&#39;)
569         || HTMLElement::isURLAttribute(attribute);
570 }
571 
572 bool HTMLImageElement::attributeContainsURL(const Attribute&amp; attribute) const
573 {
574     return attribute.name() == srcsetAttr
575         || HTMLElement::attributeContainsURL(attribute);
576 }
577 
578 String HTMLImageElement::completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp; attribute) const
579 {
580     if (attribute.name() == srcsetAttr) {
581         Vector&lt;ImageCandidate&gt; imageCandidates = parseImageCandidatesFromSrcsetAttribute(StringView(attribute.value()));
582         StringBuilder result;
583         for (const auto&amp; candidate : imageCandidates) {
584             if (&amp;candidate != &amp;imageCandidates[0])
585                 result.appendLiteral(&quot;, &quot;);
586             result.append(URL(base, candidate.string.toString()).string());
587             if (candidate.density != UninitializedDescriptor)
588                 result.append(&#39; &#39;, candidate.density, &#39;x&#39;);
589             if (candidate.resourceWidth != UninitializedDescriptor)
590                 result.append(&#39; &#39;, candidate.resourceWidth, &#39;w&#39;);
591         }
592         return result.toString();
593     }
594     return HTMLElement::completeURLsInAttributeValue(base, attribute);
595 }
596 
597 bool HTMLImageElement::matchesUsemap(const AtomStringImpl&amp; name) const
598 {
599     return m_parsedUsemap.impl() == &amp;name;
600 }
601 
602 HTMLMapElement* HTMLImageElement::associatedMapElement() const
603 {
604     return treeScope().getImageMap(m_parsedUsemap);
605 }
606 
607 const AtomString&amp; HTMLImageElement::alt() const
608 {
609     return attributeWithoutSynchronization(altAttr);
610 }
611 
612 bool HTMLImageElement::draggable() const
613 {
614     // Image elements are draggable by default.
615     return !equalLettersIgnoringASCIICase(attributeWithoutSynchronization(draggableAttr), &quot;false&quot;);
616 }
617 
618 void HTMLImageElement::setHeight(unsigned value)
619 {
620     setUnsignedIntegralAttribute(heightAttr, value);
621 }
622 
623 URL HTMLImageElement::src() const
624 {
625     return document().completeURL(attributeWithoutSynchronization(srcAttr));
626 }
627 
628 void HTMLImageElement::setSrc(const String&amp; value)
629 {
630     setAttributeWithoutSynchronization(srcAttr, value);
631 }
632 
633 void HTMLImageElement::setWidth(unsigned value)
634 {
635     setUnsignedIntegralAttribute(widthAttr, value);
636 }
637 
638 int HTMLImageElement::x() const
639 {
640     document().updateLayoutIgnorePendingStylesheets();
641     auto renderer = this-&gt;renderer();
642     if (!renderer)
643         return 0;
644 
645     // FIXME: This doesn&#39;t work correctly with transforms.
646     return renderer-&gt;localToAbsolute().x();
647 }
648 
649 int HTMLImageElement::y() const
650 {
651     document().updateLayoutIgnorePendingStylesheets();
652     auto renderer = this-&gt;renderer();
653     if (!renderer)
654         return 0;
655 
656     // FIXME: This doesn&#39;t work correctly with transforms.
657     return renderer-&gt;localToAbsolute().y();
658 }
659 
660 bool HTMLImageElement::complete() const
661 {
662     return m_imageLoader-&gt;imageComplete();
663 }
664 
665 DecodingMode HTMLImageElement::decodingMode() const
666 {
667     const AtomString&amp; decodingMode = attributeWithoutSynchronization(decodingAttr);
668     if (equalLettersIgnoringASCIICase(decodingMode, &quot;sync&quot;))
669         return DecodingMode::Synchronous;
670     if (equalLettersIgnoringASCIICase(decodingMode, &quot;async&quot;))
671         return DecodingMode::Asynchronous;
672     return DecodingMode::Auto;
673 }
674 
675 void HTMLImageElement::decode(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
676 {
677     return m_imageLoader-&gt;decode(WTFMove(promise));
678 }
679 
680 void HTMLImageElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
681 {
682     HTMLElement::addSubresourceAttributeURLs(urls);
683 
684     addSubresourceURL(urls, document().completeURL(imageSourceURL()));
685     // FIXME: What about when the usemap attribute begins with &quot;#&quot;?
686     addSubresourceURL(urls, document().completeURL(attributeWithoutSynchronization(usemapAttr)));
687 }
688 
689 void HTMLImageElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
690 {
691     oldDocument.removeDynamicMediaQueryDependentImage(*this);
692 
693     m_imageLoader-&gt;elementDidMoveToNewDocument();
694     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
695 }
696 
697 bool HTMLImageElement::isServerMap() const
698 {
699     if (!hasAttributeWithoutSynchronization(ismapAttr))
700         return false;
701 
702     const AtomString&amp; usemap = attributeWithoutSynchronization(usemapAttr);
703 
704     // If the usemap attribute starts with &#39;#&#39;, it refers to a map element in the document.
705     if (usemap.string()[0] == &#39;#&#39;)
706         return false;
707 
708     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(usemap)).isEmpty();
709 }
710 
711 void HTMLImageElement::setCrossOrigin(const AtomString&amp; value)
712 {
713     setAttributeWithoutSynchronization(crossoriginAttr, value);
714 }
715 
716 String HTMLImageElement::crossOrigin() const
717 {
718     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
719 }
720 
721 #if ENABLE(ATTACHMENT_ELEMENT)
722 
723 void HTMLImageElement::setAttachmentElement(Ref&lt;HTMLAttachmentElement&gt;&amp;&amp; attachment)
724 {
725     if (auto existingAttachment = attachmentElement())
726         existingAttachment-&gt;remove();
727 
728     attachment-&gt;setInlineStyleProperty(CSSPropertyDisplay, CSSValueNone, true);
729     ensureUserAgentShadowRoot().appendChild(WTFMove(attachment));
730 }
731 
732 RefPtr&lt;HTMLAttachmentElement&gt; HTMLImageElement::attachmentElement() const
733 {
734     if (auto shadowRoot = userAgentShadowRoot())
735         return childrenOfType&lt;HTMLAttachmentElement&gt;(*shadowRoot).first();
736 
737     return nullptr;
738 }
739 
740 const String&amp; HTMLImageElement::attachmentIdentifier() const
741 {
742     if (!m_pendingClonedAttachmentID.isEmpty())
743         return m_pendingClonedAttachmentID;
744 
745     if (auto attachment = attachmentElement())
746         return attachment-&gt;uniqueIdentifier();
747 
748     return nullAtom();
749 }
750 
751 #endif // ENABLE(ATTACHMENT_ELEMENT)
752 
753 #if ENABLE(SERVICE_CONTROLS)
754 void HTMLImageElement::updateImageControls()
755 {
756     // If this image element is inside a shadow tree then it is part of an image control.
757     if (isInShadowTree())
758         return;
759 
760     if (!document().settings().imageControlsEnabled())
761         return;
762 
763     bool hasControls = hasImageControls();
764     if (!m_experimentalImageMenuEnabled &amp;&amp; hasControls)
765         destroyImageControls();
766     else if (m_experimentalImageMenuEnabled &amp;&amp; !hasControls)
767         tryCreateImageControls();
768 }
769 
770 void HTMLImageElement::tryCreateImageControls()
771 {
772     ASSERT(m_experimentalImageMenuEnabled);
773     ASSERT(!hasImageControls());
774 
775     auto imageControls = ImageControlsRootElement::tryCreate(document());
776     if (!imageControls)
777         return;
778 
779     ensureUserAgentShadowRoot().appendChild(*imageControls);
780 
781     auto* renderObject = renderer();
782     if (!renderObject)
783         return;
784 
785     downcast&lt;RenderImage&gt;(*renderObject).setHasShadowControls(true);
786 }
787 
788 void HTMLImageElement::destroyImageControls()
789 {
790     auto shadowRoot = userAgentShadowRoot();
791     if (!shadowRoot)
792         return;
793 
794     if (RefPtr&lt;Node&gt; node = shadowRoot-&gt;firstChild()) {
795         ASSERT_WITH_SECURITY_IMPLICATION(node-&gt;isImageControlsRootElement());
796         shadowRoot-&gt;removeChild(*node);
797     }
798 
799     auto* renderObject = renderer();
800     if (!renderObject)
801         return;
802 
803     downcast&lt;RenderImage&gt;(*renderObject).setHasShadowControls(false);
804 }
805 
806 bool HTMLImageElement::hasImageControls() const
807 {
808     if (auto shadowRoot = userAgentShadowRoot()) {
809         RefPtr&lt;Node&gt; node = shadowRoot-&gt;firstChild();
810         ASSERT_WITH_SECURITY_IMPLICATION(!node || node-&gt;isImageControlsRootElement());
811         return node;
812     }
813 
814     return false;
815 }
816 
817 bool HTMLImageElement::childShouldCreateRenderer(const Node&amp; child) const
818 {
819     return hasShadowRootParent(child) &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
820 }
821 #endif // ENABLE(SERVICE_CONTROLS)
822 
823 #if PLATFORM(IOS_FAMILY)
824 // FIXME: We should find a better place for the touch callout logic. See rdar://problem/48937767.
825 bool HTMLImageElement::willRespondToMouseClickEvents()
826 {
827     auto renderer = this-&gt;renderer();
828     if (!renderer || renderer-&gt;style().touchCalloutEnabled())
829         return true;
830     return HTMLElement::willRespondToMouseClickEvents();
831 }
832 #endif
833 
834 #if USE(SYSTEM_PREVIEW)
835 bool HTMLImageElement::isSystemPreviewImage() const
836 {
837     if (!RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
838         return false;
839 
840     const auto* parent = parentElement();
841     if (is&lt;HTMLAnchorElement&gt;(parent))
842         return downcast&lt;HTMLAnchorElement&gt;(parent)-&gt;isSystemPreviewLink();
843     if (is&lt;HTMLPictureElement&gt;(parent))
844         return downcast&lt;HTMLPictureElement&gt;(parent)-&gt;isSystemPreviewImage();
845     return false;
846 }
847 #endif
848 
849 void HTMLImageElement::copyNonAttributePropertiesFromElement(const Element&amp; source)
850 {
851     auto&amp; sourceImage = static_cast&lt;const HTMLImageElement&amp;&gt;(source);
852 #if ENABLE(ATTACHMENT_ELEMENT)
853     m_pendingClonedAttachmentID = !sourceImage.m_pendingClonedAttachmentID.isEmpty() ? sourceImage.m_pendingClonedAttachmentID : sourceImage.attachmentIdentifier();
854 #endif
855     m_editableImage = sourceImage.m_editableImage;
856     Element::copyNonAttributePropertiesFromElement(source);
857 }
858 
859 void HTMLImageElement::defaultEventHandler(Event&amp; event)
860 {
861     if (hasEditableImageAttribute() &amp;&amp; event.type() == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
862         focus();
863         event.setDefaultHandled();
864         return;
865     }
866     HTMLElement::defaultEventHandler(event);
867 }
868 
869 CachedImage* HTMLImageElement::cachedImage() const
870 {
871     return m_imageLoader-&gt;image();
872 }
873 
874 void HTMLImageElement::setLoadManually(bool loadManually)
875 {
876     m_imageLoader-&gt;setLoadManually(loadManually);
877 }
878 
879 bool HTMLImageElement::hasPendingActivity() const
880 {
881     return m_imageLoader-&gt;hasPendingActivity();
882 }
883 
884 size_t HTMLImageElement::pendingDecodePromisesCountForTesting() const
885 {
886     return m_imageLoader-&gt;pendingDecodePromisesCountForTesting();
887 }
888 
889 }
    </pre>
  </body>
</html>
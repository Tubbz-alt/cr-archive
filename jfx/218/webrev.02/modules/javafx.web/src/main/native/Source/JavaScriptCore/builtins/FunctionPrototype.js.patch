diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/FunctionPrototype.js b/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/FunctionPrototype.js
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/FunctionPrototype.js
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/FunctionPrototype.js
@@ -25,13 +25,13 @@
 
 function call(thisArgument)
 {
     "use strict";
 
-    let argumentValues = [];
+    var argumentValues = [];
     // Start from 1 to ignore thisArgument
-    for (let i = 1; i < arguments.length; i++)
+    for (var i = 1; i < arguments.length; i++)
         @putByValDirect(argumentValues, i-1, arguments[i]);
 
     return this.@apply(thisArgument, argumentValues);
 }
 
@@ -51,45 +51,43 @@
         return false;
 
     if (@isBoundFunction(this))
         return @hasInstanceBoundFunction(this, value);
 
-    let target = this.prototype;
+    var target = this.prototype;
     return @instanceOf(value, target);
 }
 
 function bind(thisValue)
 {
     "use strict";
 
-    let target = this;
+    var target = this;
     if (typeof target !== "function")
         @throwTypeError("|this| is not a function inside Function.prototype.bind");
 
-    let argumentCount = arguments.length;
-    let boundArgs = null;
-    let numBoundArgs = 0;
+    var argumentCount = @argumentCount();
+    var boundArgs = null;
+    var numBoundArgs = 0;
     if (argumentCount > 1) {
         numBoundArgs = argumentCount - 1;
-        boundArgs = @newArrayWithSize(numBoundArgs);
-        for (let i = 0; i < numBoundArgs; i++)
-            @putByValDirect(boundArgs, i, arguments[i + 1]);
+        boundArgs = @createArgumentsButterfly();
     }
 
-    let length = 0;
+    var length = 0;
     if (@hasOwnLengthProperty(target)) {
-        let lengthValue = target.length;
+        var lengthValue = target.length;
         if (typeof lengthValue === "number") {
             lengthValue = lengthValue | 0;
             // Note that we only care about positive lengthValues, however, this comparision
             // against numBoundArgs suffices to prove we're not a negative number.
             if (lengthValue > numBoundArgs)
                 length = lengthValue - numBoundArgs;
         }
     }
 
-    let name = target.name;
+    var name = target.name;
     if (typeof name !== "string")
         name = "";
 
-    return @makeBoundFunction(target, arguments[0], boundArgs, length, name);
+    return @makeBoundFunction(target, thisValue, boundArgs, length, name);
 }

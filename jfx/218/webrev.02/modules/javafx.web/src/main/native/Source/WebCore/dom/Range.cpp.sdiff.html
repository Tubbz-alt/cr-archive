<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RadioButtonGroups.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Range.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 459 
 460 bool Range::boundaryPointsValid() const
 461 {
 462     auto result = compareBoundaryPoints(m_start, m_end);
 463     return !result.hasException() &amp;&amp; result.releaseReturnValue() &lt;= 0;
 464 }
 465 
 466 ExceptionOr&lt;void&gt; Range::deleteContents()
 467 {
 468     auto result = processContents(Delete);
 469     if (result.hasException())
 470         return result.releaseException();
 471     return { };
 472 }
 473 
 474 ExceptionOr&lt;bool&gt; Range::intersectsNode(Node&amp; refNode) const
 475 {
 476     if (!refNode.isConnected() || &amp;refNode.document() != &amp;ownerDocument())
 477         return false;
 478 
<span class="line-modified"> 479     ContainerNode* parentNode = refNode.parentNode();</span>
 480     if (!parentNode)
 481         return true;
 482 
 483     unsigned nodeIndex = refNode.computeNodeIndex();
 484 
<span class="line-modified"> 485     // If (parent, offset) is before end and (parent, offset + 1) is after start, return true.</span>
 486     // Otherwise, return false.
<span class="line-modified"> 487     auto result = comparePoint(*parentNode, nodeIndex);</span>
<span class="line-modified"> 488     if (result.hasException())</span>
<span class="line-modified"> 489         return result.releaseException();</span>
<span class="line-modified"> 490     auto compareFirst = result.releaseReturnValue();</span>
<span class="line-modified"> 491     result = comparePoint(*parentNode, nodeIndex + 1);</span>
<span class="line-modified"> 492     if (result.hasException())</span>
<span class="line-modified"> 493         return result.releaseException();</span>
<span class="line-removed"> 494     auto compareSecond = result.releaseReturnValue();</span>
<span class="line-removed"> 495 </span>
<span class="line-removed"> 496     bool isFirstBeforeEnd = m_start == m_end ? compareFirst &lt; 0 : compareFirst &lt;= 0;</span>
<span class="line-removed"> 497     bool isSecondAfterStart = m_start == m_end ? compareSecond &gt; 0 : compareSecond &gt;= 0;</span>
<span class="line-removed"> 498 </span>
<span class="line-removed"> 499     return isFirstBeforeEnd &amp;&amp; isSecondAfterStart;</span>
 500 }
 501 
 502 static inline Node* highestAncestorUnderCommonRoot(Node* node, Node* commonRoot)
 503 {
 504     if (node == commonRoot)
 505         return 0;
 506 
 507     ASSERT(commonRoot-&gt;contains(node));
 508 
 509     while (node-&gt;parentNode() != commonRoot)
 510         node = node-&gt;parentNode();
 511 
 512     return node;
 513 }
 514 
 515 static inline Node* childOfCommonRootBeforeOffset(Node* container, unsigned offset, Node* commonRoot)
 516 {
 517     ASSERT(container);
 518     ASSERT(commonRoot);
 519 
</pre>
<hr />
<pre>
 925         ++newOffset;
 926 
 927     auto insertResult = parent-&gt;insertBefore(node, referenceNode.get());
 928     if (insertResult.hasException())
 929         return insertResult.releaseException();
 930 
 931     if (collapsed())
 932         return setEnd(WTFMove(parent), newOffset);
 933 
 934     return { };
 935 }
 936 
 937 String Range::toString() const
 938 {
 939     StringBuilder builder;
 940 
 941     Node* pastLast = pastLastNode();
 942     for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
 943         auto type = node-&gt;nodeType();
 944         if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
<span class="line-modified"> 945             auto&amp; data = downcast&lt;CharacterData&gt;(*node).data();</span>
<span class="line-modified"> 946             unsigned length = data.length();</span>
<span class="line-modified"> 947             unsigned start = node == &amp;startContainer() ? std::min(m_start.offset(), length) : 0U;</span>
<span class="line-removed"> 948             unsigned end = node == &amp;endContainer() ? std::min(std::max(start, m_end.offset()), length) : length;</span>
<span class="line-removed"> 949             builder.appendSubstring(data, start, end - start);</span>
 950         }
 951     }
 952 
 953     return builder.toString();
 954 }
 955 
 956 String Range::text() const
 957 {
 958     // We need to update layout, since plainText uses line boxes in the render tree.
 959     // FIXME: As with innerText, we&#39;d like this to work even if there are no render objects.
 960     startContainer().document().updateLayout();
 961 
 962     return plainText(this);
 963 }
 964 
 965 // https://w3c.github.io/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment
 966 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::createContextualFragment(const String&amp; markup)
 967 {
 968     Node&amp; node = startContainer();
 969     RefPtr&lt;Element&gt; element;
</pre>
<hr />
<pre>
1134         return child;
1135     if (!m_start.offset())
1136         return &amp;startContainer();
1137     return NodeTraversal::nextSkippingChildren(startContainer());
1138 }
1139 
1140 ShadowRoot* Range::shadowRoot() const
1141 {
1142     return startContainer().containingShadowRoot();
1143 }
1144 
1145 Node* Range::pastLastNode() const
1146 {
1147     if (endContainer().isCharacterDataNode())
1148         return NodeTraversal::nextSkippingChildren(endContainer());
1149     if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
1150         return child;
1151     return NodeTraversal::nextSkippingChildren(endContainer());
1152 }
1153 
<span class="line-modified">1154 IntRect Range::absoluteBoundingBox() const</span>
1155 {
1156     IntRect result;
1157     Vector&lt;IntRect&gt; rects;
<span class="line-modified">1158     absoluteTextRects(rects);</span>


1159     for (auto&amp; rect : rects)
1160         result.unite(rect);
1161     return result;
1162 }
1163 
1164 Vector&lt;FloatRect&gt; Range::absoluteRectsForRangeInText(Node* node, RenderText&amp; renderText, bool useSelectionHeight, bool&amp; isFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1165 {
1166     unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1167     unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
1168 
<span class="line-modified">1169     auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &amp;isFixed);</span>
1170 
1171     if (rectOptions.contains(BoundingRectBehavior::RespectClipping)) {
1172         Vector&lt;FloatRect&gt; clippedRects;
1173         clippedRects.reserveInitialCapacity(textQuads.size());
1174 
1175         auto absoluteClippedOverflowRect = renderText.absoluteClippedOverflowRect();
1176 
1177         for (auto&amp; quad : textQuads) {
1178             auto clippedRect = intersection(quad.boundingBox(), absoluteClippedOverflowRect);
1179             if (!clippedRect.isEmpty())
1180                 clippedRects.uncheckedAppend(clippedRect);
1181         }
1182 
1183         return clippedRects;
1184     }
1185 
1186     Vector&lt;FloatRect&gt; floatRects;
1187     floatRects.reserveInitialCapacity(textQuads.size());
1188     for (auto&amp; quad : textQuads)
1189         floatRects.uncheckedAppend(quad.boundingBox());
</pre>
<hr />
<pre>
1218     if (inFixed)
1219         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1220 }
1221 
1222 void Range::absoluteTextQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool useSelectionHeight, RangeInFixedPosition* inFixed) const
1223 {
1224     bool allFixed = true;
1225     bool someFixed = false;
1226 
1227     Node* stopNode = pastLastNode();
1228     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1229         RenderObject* renderer = node-&gt;renderer();
1230         if (!renderer)
1231             continue;
1232         bool isFixed = false;
1233         if (renderer-&gt;isBR())
1234             renderer-&gt;absoluteQuads(quads, &amp;isFixed);
1235         else if (is&lt;RenderText&gt;(*renderer)) {
1236             unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1237             unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
<span class="line-modified">1238             quads.appendVector(downcast&lt;RenderText&gt;(*renderer).absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &amp;isFixed));</span>
1239         } else
1240             continue;
1241         allFixed &amp;= isFixed;
1242         someFixed |= isFixed;
1243     }
1244 
1245     if (inFixed)
1246         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1247 }
1248 
1249 #if PLATFORM(IOS_FAMILY)
1250 static bool intervalsSufficientlyOverlap(int startA, int endA, int startB, int endB)
1251 {
1252     if (endA &lt;= startA || endB &lt;= startB)
1253         return false;
1254 
1255     const float sufficientOverlap = .75;
1256 
1257     int lengthA = endA - startA;
1258     int lengthB = endB - startB;
</pre>
<hr />
<pre>
1556     return contains(*positionRange);
1557 }
1558 
1559 bool areRangesEqual(const Range* a, const Range* b)
1560 {
1561     if (a == b)
1562         return true;
1563     if (!a || !b)
1564         return false;
1565     return a-&gt;startPosition() == b-&gt;startPosition() &amp;&amp; a-&gt;endPosition() == b-&gt;endPosition();
1566 }
1567 
1568 bool rangesOverlap(const Range* a, const Range* b)
1569 {
1570     if (!a || !b)
1571         return false;
1572 
1573     if (a == b)
1574         return true;
1575 
<span class="line-modified">1576     if (a-&gt;commonAncestorContainer()-&gt;ownerDocument() != b-&gt;commonAncestorContainer()-&gt;ownerDocument())</span>
1577         return false;
1578 
1579     short startToStart = a-&gt;compareBoundaryPoints(Range::START_TO_START, *b).releaseReturnValue();
1580     short endToEnd = a-&gt;compareBoundaryPoints(Range::END_TO_END, *b).releaseReturnValue();
1581 
1582     // First range contains the second range.
1583     if (startToStart &lt;= 0 &amp;&amp; endToEnd &gt;= 0)
1584         return true;
1585 
1586     // End of first range is inside second range.
1587     if (a-&gt;compareBoundaryPoints(Range::START_TO_END, *b).releaseReturnValue() &gt;= 0 &amp;&amp; endToEnd &lt;= 0)
1588         return true;
1589 
1590     // Start of first range is inside second range.
1591     if (startToStart &gt;= 0 &amp;&amp; a-&gt;compareBoundaryPoints(Range::END_TO_START, *b).releaseReturnValue() &lt;= 0)
1592         return true;
1593 
1594     return false;
1595 }
1596 
</pre>
</td>
<td>
<hr />
<pre>
 459 
 460 bool Range::boundaryPointsValid() const
 461 {
 462     auto result = compareBoundaryPoints(m_start, m_end);
 463     return !result.hasException() &amp;&amp; result.releaseReturnValue() &lt;= 0;
 464 }
 465 
 466 ExceptionOr&lt;void&gt; Range::deleteContents()
 467 {
 468     auto result = processContents(Delete);
 469     if (result.hasException())
 470         return result.releaseException();
 471     return { };
 472 }
 473 
 474 ExceptionOr&lt;bool&gt; Range::intersectsNode(Node&amp; refNode) const
 475 {
 476     if (!refNode.isConnected() || &amp;refNode.document() != &amp;ownerDocument())
 477         return false;
 478 
<span class="line-modified"> 479     auto* parentNode = refNode.parentNode();</span>
 480     if (!parentNode)
 481         return true;
 482 
 483     unsigned nodeIndex = refNode.computeNodeIndex();
 484 
<span class="line-modified"> 485     // If (parentNode, nodeIndex) is before end and (parentNode, nodeIndex + 1) is after start, return true.</span>
 486     // Otherwise, return false.
<span class="line-modified"> 487     auto compareEndResult = compareBoundaryPoints(parentNode, nodeIndex, m_end.container(), m_end.offset());</span>
<span class="line-modified"> 488     if (compareEndResult.hasException())</span>
<span class="line-modified"> 489         return compareEndResult.releaseException();</span>
<span class="line-modified"> 490     auto compareStartResult = compareBoundaryPoints(parentNode, nodeIndex + 1, m_start.container(), m_start.offset());</span>
<span class="line-modified"> 491     if (compareStartResult.hasException())</span>
<span class="line-modified"> 492         return compareStartResult.releaseException();</span>
<span class="line-modified"> 493     return compareEndResult.returnValue() == -1 &amp;&amp; compareStartResult.returnValue() == 1;</span>






 494 }
 495 
 496 static inline Node* highestAncestorUnderCommonRoot(Node* node, Node* commonRoot)
 497 {
 498     if (node == commonRoot)
 499         return 0;
 500 
 501     ASSERT(commonRoot-&gt;contains(node));
 502 
 503     while (node-&gt;parentNode() != commonRoot)
 504         node = node-&gt;parentNode();
 505 
 506     return node;
 507 }
 508 
 509 static inline Node* childOfCommonRootBeforeOffset(Node* container, unsigned offset, Node* commonRoot)
 510 {
 511     ASSERT(container);
 512     ASSERT(commonRoot);
 513 
</pre>
<hr />
<pre>
 919         ++newOffset;
 920 
 921     auto insertResult = parent-&gt;insertBefore(node, referenceNode.get());
 922     if (insertResult.hasException())
 923         return insertResult.releaseException();
 924 
 925     if (collapsed())
 926         return setEnd(WTFMove(parent), newOffset);
 927 
 928     return { };
 929 }
 930 
 931 String Range::toString() const
 932 {
 933     StringBuilder builder;
 934 
 935     Node* pastLast = pastLastNode();
 936     for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
 937         auto type = node-&gt;nodeType();
 938         if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
<span class="line-modified"> 939             unsigned start = node == &amp;startContainer() ? m_start.offset() : 0U;</span>
<span class="line-modified"> 940             unsigned end = node == &amp;endContainer() ? std::max(start, m_end.offset()) : std::numeric_limits&lt;unsigned&gt;::max();</span>
<span class="line-modified"> 941             builder.appendSubstring(downcast&lt;CharacterData&gt;(*node).data(), start, end - start);</span>


 942         }
 943     }
 944 
 945     return builder.toString();
 946 }
 947 
 948 String Range::text() const
 949 {
 950     // We need to update layout, since plainText uses line boxes in the render tree.
 951     // FIXME: As with innerText, we&#39;d like this to work even if there are no render objects.
 952     startContainer().document().updateLayout();
 953 
 954     return plainText(this);
 955 }
 956 
 957 // https://w3c.github.io/DOM-Parsing/#widl-Range-createContextualFragment-DocumentFragment-DOMString-fragment
 958 ExceptionOr&lt;Ref&lt;DocumentFragment&gt;&gt; Range::createContextualFragment(const String&amp; markup)
 959 {
 960     Node&amp; node = startContainer();
 961     RefPtr&lt;Element&gt; element;
</pre>
<hr />
<pre>
1126         return child;
1127     if (!m_start.offset())
1128         return &amp;startContainer();
1129     return NodeTraversal::nextSkippingChildren(startContainer());
1130 }
1131 
1132 ShadowRoot* Range::shadowRoot() const
1133 {
1134     return startContainer().containingShadowRoot();
1135 }
1136 
1137 Node* Range::pastLastNode() const
1138 {
1139     if (endContainer().isCharacterDataNode())
1140         return NodeTraversal::nextSkippingChildren(endContainer());
1141     if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
1142         return child;
1143     return NodeTraversal::nextSkippingChildren(endContainer());
1144 }
1145 
<span class="line-modified">1146 IntRect Range::absoluteBoundingBox(OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const</span>
1147 {
1148     IntRect result;
1149     Vector&lt;IntRect&gt; rects;
<span class="line-modified">1150     bool useSelectionHeight = false;</span>
<span class="line-added">1151     RangeInFixedPosition* inFixed = nullptr;</span>
<span class="line-added">1152     absoluteTextRects(rects, useSelectionHeight, inFixed, rectOptions);</span>
1153     for (auto&amp; rect : rects)
1154         result.unite(rect);
1155     return result;
1156 }
1157 
1158 Vector&lt;FloatRect&gt; Range::absoluteRectsForRangeInText(Node* node, RenderText&amp; renderText, bool useSelectionHeight, bool&amp; isFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
1159 {
1160     unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1161     unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
1162 
<span class="line-modified">1163     auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, rectOptions.contains(BoundingRectBehavior::IgnoreEmptyTextSelections), &amp;isFixed);</span>
1164 
1165     if (rectOptions.contains(BoundingRectBehavior::RespectClipping)) {
1166         Vector&lt;FloatRect&gt; clippedRects;
1167         clippedRects.reserveInitialCapacity(textQuads.size());
1168 
1169         auto absoluteClippedOverflowRect = renderText.absoluteClippedOverflowRect();
1170 
1171         for (auto&amp; quad : textQuads) {
1172             auto clippedRect = intersection(quad.boundingBox(), absoluteClippedOverflowRect);
1173             if (!clippedRect.isEmpty())
1174                 clippedRects.uncheckedAppend(clippedRect);
1175         }
1176 
1177         return clippedRects;
1178     }
1179 
1180     Vector&lt;FloatRect&gt; floatRects;
1181     floatRects.reserveInitialCapacity(textQuads.size());
1182     for (auto&amp; quad : textQuads)
1183         floatRects.uncheckedAppend(quad.boundingBox());
</pre>
<hr />
<pre>
1212     if (inFixed)
1213         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1214 }
1215 
1216 void Range::absoluteTextQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool useSelectionHeight, RangeInFixedPosition* inFixed) const
1217 {
1218     bool allFixed = true;
1219     bool someFixed = false;
1220 
1221     Node* stopNode = pastLastNode();
1222     for (Node* node = firstNode(); node != stopNode; node = NodeTraversal::next(*node)) {
1223         RenderObject* renderer = node-&gt;renderer();
1224         if (!renderer)
1225             continue;
1226         bool isFixed = false;
1227         if (renderer-&gt;isBR())
1228             renderer-&gt;absoluteQuads(quads, &amp;isFixed);
1229         else if (is&lt;RenderText&gt;(*renderer)) {
1230             unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
1231             unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
<span class="line-modified">1232             quads.appendVector(downcast&lt;RenderText&gt;(*renderer).absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, false /* ignoreEmptyTextSelections */, &amp;isFixed));</span>
1233         } else
1234             continue;
1235         allFixed &amp;= isFixed;
1236         someFixed |= isFixed;
1237     }
1238 
1239     if (inFixed)
1240         *inFixed = allFixed ? EntirelyFixedPosition : (someFixed ? PartiallyFixedPosition : NotFixedPosition);
1241 }
1242 
1243 #if PLATFORM(IOS_FAMILY)
1244 static bool intervalsSufficientlyOverlap(int startA, int endA, int startB, int endB)
1245 {
1246     if (endA &lt;= startA || endB &lt;= startB)
1247         return false;
1248 
1249     const float sufficientOverlap = .75;
1250 
1251     int lengthA = endA - startA;
1252     int lengthB = endB - startB;
</pre>
<hr />
<pre>
1550     return contains(*positionRange);
1551 }
1552 
1553 bool areRangesEqual(const Range* a, const Range* b)
1554 {
1555     if (a == b)
1556         return true;
1557     if (!a || !b)
1558         return false;
1559     return a-&gt;startPosition() == b-&gt;startPosition() &amp;&amp; a-&gt;endPosition() == b-&gt;endPosition();
1560 }
1561 
1562 bool rangesOverlap(const Range* a, const Range* b)
1563 {
1564     if (!a || !b)
1565         return false;
1566 
1567     if (a == b)
1568         return true;
1569 
<span class="line-modified">1570     if (!areNodesConnectedInSameTreeScope(a-&gt;commonAncestorContainer(), b-&gt;commonAncestorContainer()))</span>
1571         return false;
1572 
1573     short startToStart = a-&gt;compareBoundaryPoints(Range::START_TO_START, *b).releaseReturnValue();
1574     short endToEnd = a-&gt;compareBoundaryPoints(Range::END_TO_END, *b).releaseReturnValue();
1575 
1576     // First range contains the second range.
1577     if (startToStart &lt;= 0 &amp;&amp; endToEnd &gt;= 0)
1578         return true;
1579 
1580     // End of first range is inside second range.
1581     if (a-&gt;compareBoundaryPoints(Range::START_TO_END, *b).releaseReturnValue() &gt;= 0 &amp;&amp; endToEnd &lt;= 0)
1582         return true;
1583 
1584     // Start of first range is inside second range.
1585     if (startToStart &gt;= 0 &amp;&amp; a-&gt;compareBoundaryPoints(Range::END_TO_START, *b).releaseReturnValue() &lt;= 0)
1586         return true;
1587 
1588     return false;
1589 }
1590 
</pre>
</td>
</tr>
</table>
<center><a href="RadioButtonGroups.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Range.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
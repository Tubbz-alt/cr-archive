<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/SampleMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SampleMap.h&quot;
 28 
 29 #include &quot;MediaSample.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 template &lt;typename M&gt;
 34 class SampleIsLessThanMediaTimeComparator {
 35 public:
 36     typedef typename M::value_type value_type;
 37     bool operator()(const value_type&amp; value, const MediaTime&amp; time)
 38     {
 39         MediaTime presentationEndTime = value.second-&gt;presentationTime() + value.second-&gt;duration();
 40         return presentationEndTime &lt;= time;
 41     }
 42     bool operator()(const MediaTime&amp; time, const value_type&amp; value)
 43     {
 44         MediaTime presentationStartTime = value.second-&gt;presentationTime();
 45         return time &lt; presentationStartTime;
 46     }
 47 };
 48 
 49 template &lt;typename M&gt;
 50 class SampleIsGreaterThanMediaTimeComparator {
 51 public:
 52     typedef typename M::value_type value_type;
 53     bool operator()(const value_type&amp; value, const MediaTime&amp; time)
 54     {
 55         MediaTime presentationStartTime = value.second-&gt;presentationTime();
 56         return presentationStartTime &gt; time;
 57     }
 58     bool operator()(const MediaTime&amp; time, const value_type&amp; value)
 59     {
 60         MediaTime presentationEndTime = value.second-&gt;presentationTime() + value.second-&gt;duration();
 61         return time &gt;= presentationEndTime;
 62     }
 63 };
 64 
 65 class SampleIsRandomAccess {
 66 public:
 67     bool operator()(DecodeOrderSampleMap::MapType::value_type&amp; value)
 68     {
 69         return value.second-&gt;flags() == MediaSample::IsSync;
 70     }
 71 };
 72 
 73 // SamplePresentationTimeIsInsideRangeComparator matches (range.first, range.second]
 74 struct SamplePresentationTimeIsInsideRangeComparator {
 75     bool operator()(std::pair&lt;MediaTime, MediaTime&gt; range, const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value)
 76     {
 77         return range.second &lt; value.first;
 78     }
 79     bool operator()(const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value, std::pair&lt;MediaTime, MediaTime&gt; range)
 80     {
 81         return value.first &lt;= range.first;
 82     }
 83 };
 84 
 85 // SamplePresentationTimeIsWithinRangeComparator matches [range.first, range.second)
 86 struct SamplePresentationTimeIsWithinRangeComparator {
 87     bool operator()(std::pair&lt;MediaTime, MediaTime&gt; range, const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value)
 88     {
 89         return range.second &lt;= value.first;
 90     }
 91     bool operator()(const std::pair&lt;MediaTime, RefPtr&lt;MediaSample&gt;&gt;&amp; value, std::pair&lt;MediaTime, MediaTime&gt; range)
 92     {
 93         return value.first &lt; range.first;
 94     }
 95 };
 96 
 97 bool SampleMap::empty() const
 98 {
 99     return presentationOrder().m_samples.empty();
100 }
101 
102 void SampleMap::clear()
103 {
104     presentationOrder().m_samples.clear();
105     decodeOrder().m_samples.clear();
106     m_totalSize = 0;
107 }
108 
109 void SampleMap::addSample(MediaSample&amp; sample)
110 {
111     MediaTime presentationTime = sample.presentationTime();
112 
113     presentationOrder().m_samples.insert(PresentationOrderSampleMap::MapType::value_type(presentationTime, &amp;sample));
114 
115     auto decodeKey = DecodeOrderSampleMap::KeyType(sample.decodeTime(), presentationTime);
116     decodeOrder().m_samples.insert(DecodeOrderSampleMap::MapType::value_type(decodeKey, &amp;sample));
117 
118     m_totalSize += sample.sizeInBytes();
119 }
120 
121 void SampleMap::removeSample(MediaSample* sample)
122 {
123     ASSERT(sample);
124     MediaTime presentationTime = sample-&gt;presentationTime();
125 
126     m_totalSize -= sample-&gt;sizeInBytes();
127 
128     auto decodeKey = DecodeOrderSampleMap::KeyType(sample-&gt;decodeTime(), presentationTime);
129     presentationOrder().m_samples.erase(presentationTime);
130     decodeOrder().m_samples.erase(decodeKey);
131 }
132 
133 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleWithPresentationTime(const MediaTime&amp; time)
134 {
135     auto range = m_samples.equal_range(time);
136     if (range.first == range.second)
137         return end();
138     return range.first;
139 }
140 
141 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleContainingPresentationTime(const MediaTime&amp; time)
142 {
143     // upper_bound will return the first sample whose presentation start time is greater than the search time.
144     // If this is the first sample, that means no sample in the map contains the requested time.
145     auto iter = m_samples.upper_bound(time);
146     if (iter == begin())
147         return end();
148 
149     // Look at the previous sample; does it contain the requested time?
150     --iter;
151     MediaSample&amp; sample = *iter-&gt;second;
152     if (sample.presentationTime() + sample.duration() &gt; time)
153         return iter;
154     return end();
155 }
156 
157 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleContainingOrAfterPresentationTime(const MediaTime&amp; time)
158 {
159     if (m_samples.empty())
160         return end();
161 
162     // upper_bound will return the first sample whose presentation start time is greater than the search time.
163     // If this is the first sample, that means no sample in the map contains the requested time.
164     auto iter = m_samples.upper_bound(time);
165     if (iter == begin())
166         return iter;
167 
168     // Look at the previous sample; does it contain the requested time?
169     --iter;
170     MediaSample&amp; sample = *iter-&gt;second;
171     if (sample.presentationTime() + sample.duration() &gt; time)
172         return iter;
173     return ++iter;
174 }
175 
176 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleStartingOnOrAfterPresentationTime(const MediaTime&amp; time)
177 {
178     return m_samples.lower_bound(time);
179 }
180 
181 PresentationOrderSampleMap::iterator PresentationOrderSampleMap::findSampleStartingAfterPresentationTime(const MediaTime&amp; time)
182 {
183     return m_samples.upper_bound(time);
184 }
185 
186 DecodeOrderSampleMap::iterator DecodeOrderSampleMap::findSampleWithDecodeKey(const KeyType&amp; key)
187 {
188     return m_samples.find(key);
189 }
190 
191 DecodeOrderSampleMap::iterator DecodeOrderSampleMap::findSampleAfterDecodeKey(const KeyType&amp; key)
192 {
193     return m_samples.upper_bound(key);
194 }
195 
196 PresentationOrderSampleMap::reverse_iterator PresentationOrderSampleMap::reverseFindSampleContainingPresentationTime(const MediaTime&amp; time)
197 {
198     auto range = std::equal_range(rbegin(), rend(), time, SampleIsGreaterThanMediaTimeComparator&lt;MapType&gt;());
199     if (range.first == range.second)
200         return rend();
201     return range.first;
202 }
203 
204 PresentationOrderSampleMap::reverse_iterator PresentationOrderSampleMap::reverseFindSampleBeforePresentationTime(const MediaTime&amp; time)
205 {
206     if (m_samples.empty())
207         return rend();
208 
209     // upper_bound will return the first sample whose presentation start time is greater than the search time.
210     auto found = m_samples.upper_bound(time);
211 
212     // If no sample was found with a time greater than the search time, return the last sample.
213     if (found == end())
214         return rbegin();
215 
216     // If the first sample has a time grater than the search time, no samples will have a presentation time before the search time.
217     if (found == begin())
218         return rend();
219 
220     // Otherwise, return the sample immediately previous to the one found.
221     return --reverse_iterator(--found);
222 }
223 
224 DecodeOrderSampleMap::reverse_iterator DecodeOrderSampleMap::reverseFindSampleWithDecodeKey(const KeyType&amp; key)
225 {
226     DecodeOrderSampleMap::iterator found = findSampleWithDecodeKey(key);
227     if (found == end())
228         return rend();
229     return --reverse_iterator(found);
230 }
231 
232 DecodeOrderSampleMap::reverse_iterator DecodeOrderSampleMap::findSyncSamplePriorToPresentationTime(const MediaTime&amp; time, const MediaTime&amp; threshold)
233 {
234     PresentationOrderSampleMap::reverse_iterator reverseCurrentSamplePTS = m_presentationOrder.reverseFindSampleBeforePresentationTime(time);
235     if (reverseCurrentSamplePTS == m_presentationOrder.rend())
236         return rend();
237 
238     const RefPtr&lt;MediaSample&gt;&amp; sample = reverseCurrentSamplePTS-&gt;second;
239     reverse_iterator reverseCurrentSampleDTS = reverseFindSampleWithDecodeKey(KeyType(sample-&gt;decodeTime(), sample-&gt;presentationTime()));
240 
241     reverse_iterator foundSample = findSyncSamplePriorToDecodeIterator(reverseCurrentSampleDTS);
242     if (foundSample == rend())
243         return rend();
244     if (foundSample-&gt;second-&gt;presentationTime() &lt; time - threshold)
245         return rend();
246     return foundSample;
247 }
248 
249 DecodeOrderSampleMap::reverse_iterator DecodeOrderSampleMap::findSyncSamplePriorToDecodeIterator(reverse_iterator iterator)
250 {
251     return std::find_if(iterator, rend(), SampleIsRandomAccess());
252 }
253 
254 DecodeOrderSampleMap::iterator DecodeOrderSampleMap::findSyncSampleAfterPresentationTime(const MediaTime&amp; time, const MediaTime&amp; threshold)
255 {
256     PresentationOrderSampleMap::iterator currentSamplePTS = m_presentationOrder.findSampleStartingOnOrAfterPresentationTime(time);
257     if (currentSamplePTS == m_presentationOrder.end())
258         return end();
259 
260     const RefPtr&lt;MediaSample&gt;&amp; sample = currentSamplePTS-&gt;second;
261     iterator currentSampleDTS = findSampleWithDecodeKey(KeyType(sample-&gt;decodeTime(), sample-&gt;presentationTime()));
262 
263     MediaTime upperBound = time + threshold;
264     iterator foundSample = std::find_if(currentSampleDTS, end(), SampleIsRandomAccess());
265     if (foundSample == end())
266         return end();
267     if (foundSample-&gt;second-&gt;presentationTime() &gt; upperBound)
268         return end();
269     return foundSample;
270 }
271 
272 DecodeOrderSampleMap::iterator DecodeOrderSampleMap::findSyncSampleAfterDecodeIterator(iterator currentSampleDTS)
273 {
274     if (currentSampleDTS == end())
275         return end();
276     return std::find_if(++currentSampleDTS, end(), SampleIsRandomAccess());
277 }
278 
279 PresentationOrderSampleMap::iterator_range PresentationOrderSampleMap::findSamplesBetweenPresentationTimes(const MediaTime&amp; beginTime, const MediaTime&amp; endTime)
280 {
281     // startTime is inclusive, so use lower_bound to include samples wich start exactly at startTime.
282     // endTime is not inclusive, so use lower_bound to exclude samples which start exactly at endTime.
283     auto lower_bound = m_samples.lower_bound(beginTime);
284     auto upper_bound = m_samples.lower_bound(endTime);
285     if (lower_bound == upper_bound)
286         return { end(), end() };
287     return { lower_bound, upper_bound };
288 }
289 
290 PresentationOrderSampleMap::iterator_range PresentationOrderSampleMap::findSamplesBetweenPresentationTimesFromEnd(const MediaTime&amp; beginTime, const MediaTime&amp; endTime)
291 {
292     reverse_iterator rangeEnd = std::find_if(rbegin(), rend(), [&amp;endTime](auto&amp; value) {
293         return value.first &lt; endTime;
294     });
295 
296     reverse_iterator rangeStart = std::find_if(rangeEnd, rend(), [&amp;beginTime](auto&amp; value) {
297         return value.first &lt; beginTime;
298     });
299 
300     if (rangeStart == rangeEnd)
301         return { end(), end() };
302 
303     // ( rangeStart, rangeEnd ] == [ rangeStart.base(), rangeEnd.base() )
304     return { rangeStart.base(), rangeEnd.base() };
305 }
306 
307 DecodeOrderSampleMap::reverse_iterator_range DecodeOrderSampleMap::findDependentSamples(MediaSample* sample)
308 {
309     ASSERT(sample);
310     reverse_iterator currentDecodeIter = reverseFindSampleWithDecodeKey(KeyType(sample-&gt;decodeTime(), sample-&gt;presentationTime()));
311     reverse_iterator nextSyncSample = findSyncSamplePriorToDecodeIterator(currentDecodeIter);
312     return reverse_iterator_range(currentDecodeIter, nextSyncSample);
313 }
314 
315 DecodeOrderSampleMap::iterator_range DecodeOrderSampleMap::findSamplesBetweenDecodeKeys(const KeyType&amp; beginKey, const KeyType&amp; endKey)
316 {
317     if (beginKey &gt; endKey)
318         return { end(), end() };
319 
320     // beginKey is inclusive, so use lower_bound to include samples wich start exactly at beginKey.
321     // endKey is not inclusive, so use lower_bound to exclude samples which start exactly at endKey.
322     auto lower_bound = m_samples.lower_bound(beginKey);
323     auto upper_bound = m_samples.lower_bound(endKey);
324     if (lower_bound == upper_bound)
325         return { end(), end() };
326     return { lower_bound, upper_bound };
327 }
328 
329 }
    </pre>
  </body>
</html>
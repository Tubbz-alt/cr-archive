<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@nypop.com&gt;.
   3  * Copyright (C) 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
   4  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   5  * Copyright (C) 2009 Jeff Schiller &lt;codedread@gmail.com&gt;
   6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
   7  *
   8  * Redistribution and use in source and binary forms, with or without
   9  * modification, are permitted provided that the following conditions
  10  * are met:
  11  *
  12  * 1. Redistributions of source code must retain the above copyright
  13  *    notice, this list of conditions and the following disclaimer.
  14  * 2. Redistributions in binary form must reproduce the above copyright
  15  *    notice, this list of conditions and the following disclaimer in the
  16  *    documentation and/or other materials provided with the distribution.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR
  19  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  20  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  21  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
  22  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  23  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  24  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  25  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #pragma once
  31 
  32 #include &quot;CSSCalculationValue.h&quot;
  33 #include &quot;CSSFontFamily.h&quot;
  34 #include &quot;CSSPrimitiveValue.h&quot;
  35 #include &quot;CSSToLengthConversionData.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;GraphicsTypes.h&quot;
  38 #include &quot;Length.h&quot;
  39 #include &quot;LineClampValue.h&quot;
  40 #include &quot;RenderStyleConstants.h&quot;
  41 #include &quot;SVGRenderStyleDefs.h&quot;
  42 #include &quot;TextFlags.h&quot;
  43 #include &quot;ThemeTypes.h&quot;
  44 #include &quot;TouchAction.h&quot;
  45 #include &quot;UnicodeBidi.h&quot;
  46 #include &quot;WritingMode.h&quot;
  47 #include &lt;wtf/MathExtras.h&gt;
  48 #include &lt;wtf/OptionSet.h&gt;
  49 
  50 namespace WebCore {
  51 
  52 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(short i)
  53     : CSSValue(PrimitiveClass)
  54 {
  55     setPrimitiveUnitType(CSSUnitType::CSS_NUMBER);
  56     m_value.num = static_cast&lt;double&gt;(i);
  57 }
  58 
  59 template&lt;&gt; inline CSSPrimitiveValue::operator short() const
  60 {
  61     if (primitiveUnitType() == CSSUnitType::CSS_NUMBER)
  62         return clampTo&lt;short&gt;(m_value.num);
  63 
  64     ASSERT_NOT_REACHED();
  65     return 0;
  66 }
  67 
  68 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(unsigned short i)
  69     : CSSValue(PrimitiveClass)
  70 {
  71     setPrimitiveUnitType(CSSUnitType::CSS_NUMBER);
  72     m_value.num = static_cast&lt;double&gt;(i);
  73 }
  74 
  75 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned short() const
  76 {
  77     if (primitiveType() == CSSUnitType::CSS_NUMBER)
  78         return value&lt;unsigned short&gt;();
  79 
  80     ASSERT_NOT_REACHED();
  81     return 0;
  82 }
  83 
  84 template&lt;&gt; inline CSSPrimitiveValue::operator int() const
  85 {
  86     if (primitiveType() == CSSUnitType::CSS_NUMBER)
  87         return value&lt;int&gt;();
  88 
  89     ASSERT_NOT_REACHED();
  90     return 0;
  91 }
  92 
  93 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned() const
  94 {
  95     if (primitiveType() == CSSUnitType::CSS_NUMBER)
  96         return value&lt;unsigned&gt;();
  97 
  98     ASSERT_NOT_REACHED();
  99     return 0;
 100 }
 101 
 102 
 103 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(float i)
 104     : CSSValue(PrimitiveClass)
 105 {
 106     setPrimitiveUnitType(CSSUnitType::CSS_NUMBER);
 107     m_value.num = static_cast&lt;double&gt;(i);
 108 }
 109 
 110 template&lt;&gt; inline CSSPrimitiveValue::operator float() const
 111 {
 112     if (primitiveType() == CSSUnitType::CSS_NUMBER)
 113         return value&lt;float&gt;();
 114 
 115     ASSERT_NOT_REACHED();
 116     return 0.0f;
 117 }
 118 
 119 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineClampValue i)
 120     : CSSValue(PrimitiveClass)
 121 {
 122     setPrimitiveUnitType(i.isPercentage() ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);
 123     m_value.num = static_cast&lt;double&gt;(i.value());
 124 }
 125 
 126 template&lt;&gt; inline CSSPrimitiveValue::operator LineClampValue() const
 127 {
 128     if (primitiveType() == CSSUnitType::CSS_NUMBER)
 129         return LineClampValue(value&lt;int&gt;(), LineClamp::LineCount);
 130 
 131     if (primitiveType() == CSSUnitType::CSS_PERCENTAGE)
 132         return LineClampValue(value&lt;int&gt;(), LineClamp::Percentage);
 133 
 134     ASSERT_NOT_REACHED();
 135     return LineClampValue();
 136 }
 137 
 138 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ReflectionDirection direction)
 139     : CSSValue(PrimitiveClass)
 140 {
 141     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 142     switch (direction) {
 143     case ReflectionDirection::Above:
 144         m_value.valueID = CSSValueAbove;
 145         break;
 146     case ReflectionDirection::Below:
 147         m_value.valueID = CSSValueBelow;
 148         break;
 149     case ReflectionDirection::Left:
 150         m_value.valueID = CSSValueLeft;
 151         break;
 152     case ReflectionDirection::Right:
 153         m_value.valueID = CSSValueRight;
 154     }
 155 }
 156 
 157 template&lt;&gt; inline CSSPrimitiveValue::operator ReflectionDirection() const
 158 {
 159     ASSERT(isValueID());
 160 
 161     switch (m_value.valueID) {
 162     case CSSValueAbove:
 163         return ReflectionDirection::Above;
 164     case CSSValueBelow:
 165         return ReflectionDirection::Below;
 166     case CSSValueLeft:
 167         return ReflectionDirection::Left;
 168     case CSSValueRight:
 169         return ReflectionDirection::Right;
 170     default:
 171         break;
 172     }
 173 
 174     ASSERT_NOT_REACHED();
 175     return ReflectionDirection::Below;
 176 }
 177 
 178 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnFill columnFill)
 179     : CSSValue(PrimitiveClass)
 180 {
 181     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 182     switch (columnFill) {
 183     case ColumnFill::Auto:
 184         m_value.valueID = CSSValueAuto;
 185         break;
 186     case ColumnFill::Balance:
 187         m_value.valueID = CSSValueBalance;
 188         break;
 189     }
 190 }
 191 
 192 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnFill() const
 193 {
 194     if (primitiveUnitType() == CSSUnitType::CSS_VALUE_ID) {
 195         if (m_value.valueID == CSSValueBalance)
 196             return ColumnFill::Balance;
 197         if (m_value.valueID == CSSValueAuto)
 198             return ColumnFill::Auto;
 199     }
 200     ASSERT_NOT_REACHED();
 201     return ColumnFill::Balance;
 202 }
 203 
 204 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnSpan columnSpan)
 205     : CSSValue(PrimitiveClass)
 206 {
 207     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 208     switch (columnSpan) {
 209     case ColumnSpan::All:
 210         m_value.valueID = CSSValueAll;
 211         break;
 212     case ColumnSpan::None:
 213         m_value.valueID = CSSValueNone;
 214         break;
 215     }
 216 }
 217 
 218 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnSpan() const
 219 {
 220     // Map 1 to none for compatibility reasons.
 221     if (primitiveUnitType() == CSSUnitType::CSS_NUMBER &amp;&amp; m_value.num == 1)
 222         return ColumnSpan::None;
 223 
 224     ASSERT(isValueID());
 225 
 226     switch (m_value.valueID) {
 227     case CSSValueAll:
 228         return ColumnSpan::All;
 229     case CSSValueNone:
 230         return ColumnSpan::None;
 231     default:
 232         break;
 233     }
 234 
 235     ASSERT_NOT_REACHED();
 236     return ColumnSpan::None;
 237 }
 238 
 239 
 240 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PrintColorAdjust value)
 241     : CSSValue(PrimitiveClass)
 242 {
 243     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 244     switch (value) {
 245     case PrintColorAdjust::Exact:
 246         m_value.valueID = CSSValueExact;
 247         break;
 248     case PrintColorAdjust::Economy:
 249         m_value.valueID = CSSValueEconomy;
 250         break;
 251     }
 252 }
 253 
 254 template&lt;&gt; inline CSSPrimitiveValue::operator PrintColorAdjust() const
 255 {
 256     ASSERT(isValueID());
 257 
 258     switch (m_value.valueID) {
 259     case CSSValueEconomy:
 260         return PrintColorAdjust::Economy;
 261     case CSSValueExact:
 262         return PrintColorAdjust::Exact;
 263     default:
 264         break;
 265     }
 266 
 267     ASSERT_NOT_REACHED();
 268     return PrintColorAdjust::Economy;
 269 }
 270 
 271 
 272 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderStyle e)
 273     : CSSValue(PrimitiveClass)
 274 {
 275     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 276     switch (e) {
 277     case BorderStyle::None:
 278         m_value.valueID = CSSValueNone;
 279         break;
 280     case BorderStyle::Hidden:
 281         m_value.valueID = CSSValueHidden;
 282         break;
 283     case BorderStyle::Inset:
 284         m_value.valueID = CSSValueInset;
 285         break;
 286     case BorderStyle::Groove:
 287         m_value.valueID = CSSValueGroove;
 288         break;
 289     case BorderStyle::Ridge:
 290         m_value.valueID = CSSValueRidge;
 291         break;
 292     case BorderStyle::Outset:
 293         m_value.valueID = CSSValueOutset;
 294         break;
 295     case BorderStyle::Dotted:
 296         m_value.valueID = CSSValueDotted;
 297         break;
 298     case BorderStyle::Dashed:
 299         m_value.valueID = CSSValueDashed;
 300         break;
 301     case BorderStyle::Solid:
 302         m_value.valueID = CSSValueSolid;
 303         break;
 304     case BorderStyle::Double:
 305         m_value.valueID = CSSValueDouble;
 306         break;
 307     }
 308 }
 309 
 310 template&lt;&gt; inline CSSPrimitiveValue::operator BorderStyle() const
 311 {
 312     ASSERT(isValueID());
 313 
 314     if (m_value.valueID == CSSValueAuto) // Valid for CSS outline-style
 315         return BorderStyle::Dotted;
 316     return static_cast&lt;BorderStyle&gt;(m_value.valueID - CSSValueNone);
 317 }
 318 
 319 template&lt;&gt; inline CSSPrimitiveValue::operator OutlineIsAuto() const
 320 {
 321     ASSERT(isValueID());
 322 
 323     if (m_value.valueID == CSSValueAuto)
 324         return OutlineIsAuto::On;
 325     return OutlineIsAuto::Off;
 326 }
 327 
 328 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CompositeOperator e)
 329     : CSSValue(PrimitiveClass)
 330 {
 331     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 332     switch (e) {
 333     case CompositeOperator::Clear:
 334         m_value.valueID = CSSValueClear;
 335         break;
 336     case CompositeOperator::Copy:
 337         m_value.valueID = CSSValueCopy;
 338         break;
 339     case CompositeOperator::SourceOver:
 340         m_value.valueID = CSSValueSourceOver;
 341         break;
 342     case CompositeOperator::SourceIn:
 343         m_value.valueID = CSSValueSourceIn;
 344         break;
 345     case CompositeOperator::SourceOut:
 346         m_value.valueID = CSSValueSourceOut;
 347         break;
 348     case CompositeOperator::SourceAtop:
 349         m_value.valueID = CSSValueSourceAtop;
 350         break;
 351     case CompositeOperator::DestinationOver:
 352         m_value.valueID = CSSValueDestinationOver;
 353         break;
 354     case CompositeOperator::DestinationIn:
 355         m_value.valueID = CSSValueDestinationIn;
 356         break;
 357     case CompositeOperator::DestinationOut:
 358         m_value.valueID = CSSValueDestinationOut;
 359         break;
 360     case CompositeOperator::DestinationAtop:
 361         m_value.valueID = CSSValueDestinationAtop;
 362         break;
 363     case CompositeOperator::XOR:
 364         m_value.valueID = CSSValueXor;
 365         break;
 366     case CompositeOperator::PlusDarker:
 367         m_value.valueID = CSSValuePlusDarker;
 368         break;
 369     case CompositeOperator::PlusLighter:
 370         m_value.valueID = CSSValuePlusLighter;
 371         break;
 372     case CompositeOperator::Difference:
 373         ASSERT_NOT_REACHED();
 374         break;
 375     }
 376 }
 377 
 378 template&lt;&gt; inline CSSPrimitiveValue::operator CompositeOperator() const
 379 {
 380     ASSERT(isValueID());
 381 
 382     switch (m_value.valueID) {
 383     case CSSValueClear:
 384         return CompositeOperator::Clear;
 385     case CSSValueCopy:
 386         return CompositeOperator::Copy;
 387     case CSSValueSourceOver:
 388         return CompositeOperator::SourceOver;
 389     case CSSValueSourceIn:
 390         return CompositeOperator::SourceIn;
 391     case CSSValueSourceOut:
 392         return CompositeOperator::SourceOut;
 393     case CSSValueSourceAtop:
 394         return CompositeOperator::SourceAtop;
 395     case CSSValueDestinationOver:
 396         return CompositeOperator::DestinationOver;
 397     case CSSValueDestinationIn:
 398         return CompositeOperator::DestinationIn;
 399     case CSSValueDestinationOut:
 400         return CompositeOperator::DestinationOut;
 401     case CSSValueDestinationAtop:
 402         return CompositeOperator::DestinationAtop;
 403     case CSSValueXor:
 404         return CompositeOperator::XOR;
 405     case CSSValuePlusDarker:
 406         return CompositeOperator::PlusDarker;
 407     case CSSValuePlusLighter:
 408         return CompositeOperator::PlusLighter;
 409     default:
 410         break;
 411     }
 412 
 413     ASSERT_NOT_REACHED();
 414     return CompositeOperator::Clear;
 415 }
 416 
 417 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ControlPart e)
 418     : CSSValue(PrimitiveClass)
 419 {
 420     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 421     switch (e) {
 422     case NoControlPart:
 423         m_value.valueID = CSSValueNone;
 424         break;
 425     case CheckboxPart:
 426         m_value.valueID = CSSValueCheckbox;
 427         break;
 428     case RadioPart:
 429         m_value.valueID = CSSValueRadio;
 430         break;
 431     case PushButtonPart:
 432         m_value.valueID = CSSValuePushButton;
 433         break;
 434     case SquareButtonPart:
 435         m_value.valueID = CSSValueSquareButton;
 436         break;
 437     case ButtonPart:
 438         m_value.valueID = CSSValueButton;
 439         break;
 440     case ButtonBevelPart:
 441         m_value.valueID = CSSValueButtonBevel;
 442         break;
 443     case DefaultButtonPart:
 444         m_value.valueID = CSSValueDefaultButton;
 445         break;
 446     case InnerSpinButtonPart:
 447         m_value.valueID = CSSValueInnerSpinButton;
 448         break;
 449     case ListboxPart:
 450         m_value.valueID = CSSValueListbox;
 451         break;
 452     case ListItemPart:
 453         m_value.valueID = CSSValueListitem;
 454         break;
 455     case MediaEnterFullscreenButtonPart:
 456         m_value.valueID = CSSValueMediaEnterFullscreenButton;
 457         break;
 458     case MediaExitFullscreenButtonPart:
 459         m_value.valueID = CSSValueMediaExitFullscreenButton;
 460         break;
 461     case MediaPlayButtonPart:
 462         m_value.valueID = CSSValueMediaPlayButton;
 463         break;
 464     case MediaOverlayPlayButtonPart:
 465         m_value.valueID = CSSValueMediaOverlayPlayButton;
 466         break;
 467     case MediaMuteButtonPart:
 468         m_value.valueID = CSSValueMediaMuteButton;
 469         break;
 470     case MediaSeekBackButtonPart:
 471         m_value.valueID = CSSValueMediaSeekBackButton;
 472         break;
 473     case MediaSeekForwardButtonPart:
 474         m_value.valueID = CSSValueMediaSeekForwardButton;
 475         break;
 476     case MediaRewindButtonPart:
 477         m_value.valueID = CSSValueMediaRewindButton;
 478         break;
 479     case MediaReturnToRealtimeButtonPart:
 480         m_value.valueID = CSSValueMediaReturnToRealtimeButton;
 481         break;
 482     case MediaToggleClosedCaptionsButtonPart:
 483         m_value.valueID = CSSValueMediaToggleClosedCaptionsButton;
 484         break;
 485     case MediaSliderPart:
 486         m_value.valueID = CSSValueMediaSlider;
 487         break;
 488     case MediaSliderThumbPart:
 489         m_value.valueID = CSSValueMediaSliderthumb;
 490         break;
 491     case MediaVolumeSliderContainerPart:
 492         m_value.valueID = CSSValueMediaVolumeSliderContainer;
 493         break;
 494     case MediaVolumeSliderPart:
 495         m_value.valueID = CSSValueMediaVolumeSlider;
 496         break;
 497     case MediaVolumeSliderMuteButtonPart:
 498         m_value.valueID = CSSValueMediaVolumeSliderMuteButton;
 499         break;
 500     case MediaVolumeSliderThumbPart:
 501         m_value.valueID = CSSValueMediaVolumeSliderthumb;
 502         break;
 503     case MediaControlsBackgroundPart:
 504         m_value.valueID = CSSValueMediaControlsBackground;
 505         break;
 506     case MediaControlsFullscreenBackgroundPart:
 507         m_value.valueID = CSSValueMediaControlsFullscreenBackground;
 508         break;
 509     case MediaFullScreenVolumeSliderPart:
 510         m_value.valueID = CSSValueMediaFullscreenVolumeSlider;
 511         break;
 512     case MediaFullScreenVolumeSliderThumbPart:
 513         m_value.valueID = CSSValueMediaFullscreenVolumeSliderThumb;
 514         break;
 515     case MediaCurrentTimePart:
 516         m_value.valueID = CSSValueMediaCurrentTimeDisplay;
 517         break;
 518     case MediaTimeRemainingPart:
 519         m_value.valueID = CSSValueMediaTimeRemainingDisplay;
 520         break;
 521     case MediaControlsLightBarBackgroundPart:
 522         m_value.valueID = CSSValueMediaControlsLightBarBackground;
 523         break;
 524     case MediaControlsDarkBarBackgroundPart:
 525         m_value.valueID = CSSValueMediaControlsDarkBarBackground;
 526         break;
 527     case MenulistPart:
 528         m_value.valueID = CSSValueMenulist;
 529         break;
 530     case MenulistButtonPart:
 531         m_value.valueID = CSSValueMenulistButton;
 532         break;
 533     case MenulistTextPart:
 534         m_value.valueID = CSSValueMenulistText;
 535         break;
 536     case MenulistTextFieldPart:
 537         m_value.valueID = CSSValueMenulistTextfield;
 538         break;
 539     case MeterPart:
 540         m_value.valueID = CSSValueMeter;
 541         break;
 542     case RelevancyLevelIndicatorPart:
 543         m_value.valueID = CSSValueRelevancyLevelIndicator;
 544         break;
 545     case ContinuousCapacityLevelIndicatorPart:
 546         m_value.valueID = CSSValueContinuousCapacityLevelIndicator;
 547         break;
 548     case DiscreteCapacityLevelIndicatorPart:
 549         m_value.valueID = CSSValueDiscreteCapacityLevelIndicator;
 550         break;
 551     case RatingLevelIndicatorPart:
 552         m_value.valueID = CSSValueRatingLevelIndicator;
 553         break;
 554     case ProgressBarPart:
 555         m_value.valueID = CSSValueProgressBar;
 556         break;
 557     case ProgressBarValuePart:
 558         m_value.valueID = CSSValueProgressBarValue;
 559         break;
 560     case SliderHorizontalPart:
 561         m_value.valueID = CSSValueSliderHorizontal;
 562         break;
 563     case SliderVerticalPart:
 564         m_value.valueID = CSSValueSliderVertical;
 565         break;
 566     case SliderThumbHorizontalPart:
 567         m_value.valueID = CSSValueSliderthumbHorizontal;
 568         break;
 569     case SliderThumbVerticalPart:
 570         m_value.valueID = CSSValueSliderthumbVertical;
 571         break;
 572     case CaretPart:
 573         m_value.valueID = CSSValueCaret;
 574         break;
 575     case SearchFieldPart:
 576         m_value.valueID = CSSValueSearchfield;
 577         break;
 578     case SearchFieldDecorationPart:
 579         m_value.valueID = CSSValueSearchfieldDecoration;
 580         break;
 581     case SearchFieldResultsDecorationPart:
 582         m_value.valueID = CSSValueSearchfieldResultsDecoration;
 583         break;
 584     case SearchFieldResultsButtonPart:
 585         m_value.valueID = CSSValueSearchfieldResultsButton;
 586         break;
 587     case SearchFieldCancelButtonPart:
 588         m_value.valueID = CSSValueSearchfieldCancelButton;
 589         break;
 590     case SnapshottedPluginOverlayPart:
 591         m_value.valueID = CSSValueSnapshottedPluginOverlay;
 592         break;
 593     case TextFieldPart:
 594         m_value.valueID = CSSValueTextfield;
 595         break;
 596     case TextAreaPart:
 597         m_value.valueID = CSSValueTextarea;
 598         break;
 599     case CapsLockIndicatorPart:
 600         m_value.valueID = CSSValueCapsLockIndicator;
 601         break;
 602 #if ENABLE(ATTACHMENT_ELEMENT)
 603     case AttachmentPart:
 604         m_value.valueID = CSSValueAttachment;
 605         break;
 606     case BorderlessAttachmentPart:
 607         m_value.valueID = CSSValueBorderlessAttachment;
 608         break;
 609 #endif
 610 #if ENABLE(SERVICE_CONTROLS)
 611     case ImageControlsButtonPart:
 612         m_value.valueID = CSSValueImageControlsButton;
 613         break;
 614 #endif
 615 #if ENABLE(APPLE_PAY)
 616     case ApplePayButtonPart:
 617         m_value.valueID = CSSValueApplePayButton;
 618         break;
 619 #endif
 620 #if ENABLE(INPUT_TYPE_COLOR)
 621     case ColorWellPart:
 622         m_value.valueID = CSSValueColorWell;
 623         break;
 624 #endif
 625 #if ENABLE(DATALIST_ELEMENT)
 626     case ListButtonPart:
 627         m_value.valueID = CSSValueListButton;
 628         break;
 629 #endif
 630     }
 631 }
 632 
 633 template&lt;&gt; inline CSSPrimitiveValue::operator ControlPart() const
 634 {
 635     ASSERT(isValueID());
 636 
 637     if (m_value.valueID == CSSValueNone)
 638         return NoControlPart;
 639     return ControlPart(m_value.valueID - CSSValueCheckbox + 1);
 640 }
 641 
 642 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BackfaceVisibility e)
 643     : CSSValue(PrimitiveClass)
 644 {
 645     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 646     switch (e) {
 647     case BackfaceVisibility::Visible:
 648         m_value.valueID = CSSValueVisible;
 649         break;
 650     case BackfaceVisibility::Hidden:
 651         m_value.valueID = CSSValueHidden;
 652         break;
 653     }
 654 }
 655 
 656 template&lt;&gt; inline CSSPrimitiveValue::operator BackfaceVisibility() const
 657 {
 658     ASSERT(isValueID());
 659 
 660     switch (m_value.valueID) {
 661     case CSSValueVisible:
 662         return BackfaceVisibility::Visible;
 663     case CSSValueHidden:
 664         return BackfaceVisibility::Hidden;
 665     default:
 666         break;
 667     }
 668 
 669     ASSERT_NOT_REACHED();
 670     return BackfaceVisibility::Hidden;
 671 }
 672 
 673 
 674 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillAttachment e)
 675     : CSSValue(PrimitiveClass)
 676 {
 677     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 678     switch (e) {
 679     case FillAttachment::ScrollBackground:
 680         m_value.valueID = CSSValueScroll;
 681         break;
 682     case FillAttachment::LocalBackground:
 683         m_value.valueID = CSSValueLocal;
 684         break;
 685     case FillAttachment::FixedBackground:
 686         m_value.valueID = CSSValueFixed;
 687         break;
 688     }
 689 }
 690 
 691 template&lt;&gt; inline CSSPrimitiveValue::operator FillAttachment() const
 692 {
 693     ASSERT(isValueID());
 694 
 695     switch (m_value.valueID) {
 696     case CSSValueScroll:
 697         return FillAttachment::ScrollBackground;
 698     case CSSValueLocal:
 699         return FillAttachment::LocalBackground;
 700     case CSSValueFixed:
 701         return FillAttachment::FixedBackground;
 702     default:
 703         break;
 704     }
 705 
 706     ASSERT_NOT_REACHED();
 707     return FillAttachment::ScrollBackground;
 708 }
 709 
 710 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillBox e)
 711     : CSSValue(PrimitiveClass)
 712 {
 713     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 714     switch (e) {
 715     case FillBox::Border:
 716         m_value.valueID = CSSValueBorderBox;
 717         break;
 718     case FillBox::Padding:
 719         m_value.valueID = CSSValuePaddingBox;
 720         break;
 721     case FillBox::Content:
 722         m_value.valueID = CSSValueContentBox;
 723         break;
 724     case FillBox::Text:
 725         m_value.valueID = CSSValueText;
 726         break;
 727     }
 728 }
 729 
 730 template&lt;&gt; inline CSSPrimitiveValue::operator FillBox() const
 731 {
 732     ASSERT(isValueID());
 733 
 734     switch (m_value.valueID) {
 735     case CSSValueBorder:
 736     case CSSValueBorderBox:
 737         return FillBox::Border;
 738     case CSSValuePadding:
 739     case CSSValuePaddingBox:
 740         return FillBox::Padding;
 741     case CSSValueContent:
 742     case CSSValueContentBox:
 743         return FillBox::Content;
 744     case CSSValueText:
 745     case CSSValueWebkitText:
 746         return FillBox::Text;
 747     default:
 748         break;
 749     }
 750 
 751     ASSERT_NOT_REACHED();
 752     return FillBox::Border;
 753 }
 754 
 755 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillRepeat e)
 756     : CSSValue(PrimitiveClass)
 757 {
 758     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 759     switch (e) {
 760     case FillRepeat::Repeat:
 761         m_value.valueID = CSSValueRepeat;
 762         break;
 763     case FillRepeat::NoRepeat:
 764         m_value.valueID = CSSValueNoRepeat;
 765         break;
 766     case FillRepeat::Round:
 767         m_value.valueID = CSSValueRound;
 768         break;
 769     case FillRepeat::Space:
 770         m_value.valueID = CSSValueSpace;
 771         break;
 772     }
 773 }
 774 
 775 template&lt;&gt; inline CSSPrimitiveValue::operator FillRepeat() const
 776 {
 777     ASSERT(isValueID());
 778 
 779     switch (m_value.valueID) {
 780     case CSSValueRepeat:
 781         return FillRepeat::Repeat;
 782     case CSSValueNoRepeat:
 783         return FillRepeat::NoRepeat;
 784     case CSSValueRound:
 785         return FillRepeat::Round;
 786     case CSSValueSpace:
 787         return FillRepeat::Space;
 788     default:
 789         break;
 790     }
 791 
 792     ASSERT_NOT_REACHED();
 793     return FillRepeat::Repeat;
 794 }
 795 
 796 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxPack e)
 797     : CSSValue(PrimitiveClass)
 798 {
 799     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 800     switch (e) {
 801     case BoxPack::Start:
 802         m_value.valueID = CSSValueStart;
 803         break;
 804     case BoxPack::Center:
 805         m_value.valueID = CSSValueCenter;
 806         break;
 807     case BoxPack::End:
 808         m_value.valueID = CSSValueEnd;
 809         break;
 810     case BoxPack::Justify:
 811         m_value.valueID = CSSValueJustify;
 812         break;
 813     }
 814 }
 815 
 816 template&lt;&gt; inline CSSPrimitiveValue::operator BoxPack() const
 817 {
 818     ASSERT(isValueID());
 819 
 820     switch (m_value.valueID) {
 821     case CSSValueStart:
 822         return BoxPack::Start;
 823     case CSSValueEnd:
 824         return BoxPack::End;
 825     case CSSValueCenter:
 826         return BoxPack::Center;
 827     case CSSValueJustify:
 828         return BoxPack::Justify;
 829     default:
 830         break;
 831     }
 832 
 833     ASSERT_NOT_REACHED();
 834     return BoxPack::Justify;
 835 }
 836 
 837 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxAlignment e)
 838     : CSSValue(PrimitiveClass)
 839 {
 840     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 841     switch (e) {
 842     case BoxAlignment::Stretch:
 843         m_value.valueID = CSSValueStretch;
 844         break;
 845     case BoxAlignment::Start:
 846         m_value.valueID = CSSValueStart;
 847         break;
 848     case BoxAlignment::Center:
 849         m_value.valueID = CSSValueCenter;
 850         break;
 851     case BoxAlignment::End:
 852         m_value.valueID = CSSValueEnd;
 853         break;
 854     case BoxAlignment::Baseline:
 855         m_value.valueID = CSSValueBaseline;
 856         break;
 857     }
 858 }
 859 
 860 template&lt;&gt; inline CSSPrimitiveValue::operator BoxAlignment() const
 861 {
 862     ASSERT(isValueID());
 863 
 864     switch (m_value.valueID) {
 865     case CSSValueStretch:
 866         return BoxAlignment::Stretch;
 867     case CSSValueStart:
 868         return BoxAlignment::Start;
 869     case CSSValueEnd:
 870         return BoxAlignment::End;
 871     case CSSValueCenter:
 872         return BoxAlignment::Center;
 873     case CSSValueBaseline:
 874         return BoxAlignment::Baseline;
 875     default:
 876         break;
 877     }
 878 
 879     ASSERT_NOT_REACHED();
 880     return BoxAlignment::Stretch;
 881 }
 882 
 883 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 884 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDecorationBreak e)
 885     : CSSValue(PrimitiveClass)
 886 {
 887     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 888     switch (e) {
 889     case BoxDecorationBreak::Slice:
 890         m_value.valueID = CSSValueSlice;
 891         break;
 892     case BoxDecorationBreak::Clone:
 893         m_value.valueID = CSSValueClone;
 894         break;
 895     }
 896 }
 897 
 898 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDecorationBreak() const
 899 {
 900     ASSERT(isValueID());
 901 
 902     switch (m_value.valueID) {
 903     case CSSValueSlice:
 904         return BoxDecorationBreak::Slice;
 905     case CSSValueClone:
 906         return BoxDecorationBreak::Clone;
 907     default:
 908         break;
 909     }
 910 
 911     ASSERT_NOT_REACHED();
 912     return BoxDecorationBreak::Slice;
 913 }
 914 #endif
 915 
 916 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Edge e)
 917     : CSSValue(PrimitiveClass)
 918 {
 919     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 920     switch (e) {
 921     case Edge::Top:
 922         m_value.valueID = CSSValueTop;
 923         break;
 924     case Edge::Right:
 925         m_value.valueID = CSSValueRight;
 926         break;
 927     case Edge::Bottom:
 928         m_value.valueID = CSSValueBottom;
 929         break;
 930     case Edge::Left:
 931         m_value.valueID = CSSValueLeft;
 932         break;
 933     }
 934 }
 935 
 936 template&lt;&gt; inline CSSPrimitiveValue::operator Edge() const
 937 {
 938     ASSERT(isValueID());
 939 
 940     switch (m_value.valueID) {
 941     case CSSValueTop:
 942         return Edge::Top;
 943     case CSSValueRight:
 944         return Edge::Right;
 945     case CSSValueBottom:
 946         return Edge::Bottom;
 947     case CSSValueLeft:
 948         return Edge::Left;
 949     default:
 950         break;
 951     }
 952 
 953     ASSERT_NOT_REACHED();
 954     return Edge::Top;
 955 }
 956 
 957 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxSizing e)
 958     : CSSValue(PrimitiveClass)
 959 {
 960     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 961     switch (e) {
 962     case BoxSizing::BorderBox:
 963         m_value.valueID = CSSValueBorderBox;
 964         break;
 965     case BoxSizing::ContentBox:
 966         m_value.valueID = CSSValueContentBox;
 967         break;
 968     }
 969 }
 970 
 971 template&lt;&gt; inline CSSPrimitiveValue::operator BoxSizing() const
 972 {
 973     ASSERT(isValueID());
 974 
 975     switch (m_value.valueID) {
 976     case CSSValueBorderBox:
 977         return BoxSizing::BorderBox;
 978     case CSSValueContentBox:
 979         return BoxSizing::ContentBox;
 980     default:
 981         break;
 982     }
 983 
 984     ASSERT_NOT_REACHED();
 985     return BoxSizing::BorderBox;
 986 }
 987 
 988 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDirection e)
 989     : CSSValue(PrimitiveClass)
 990 {
 991     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
 992     switch (e) {
 993     case BoxDirection::Normal:
 994         m_value.valueID = CSSValueNormal;
 995         break;
 996     case BoxDirection::Reverse:
 997         m_value.valueID = CSSValueReverse;
 998         break;
 999     }
1000 }
1001 
1002 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDirection() const
1003 {
1004     ASSERT(isValueID());
1005 
1006     switch (m_value.valueID) {
1007     case CSSValueNormal:
1008         return BoxDirection::Normal;
1009     case CSSValueReverse:
1010         return BoxDirection::Reverse;
1011     default:
1012         break;
1013     }
1014 
1015     ASSERT_NOT_REACHED();
1016     return BoxDirection::Normal;
1017 }
1018 
1019 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxLines e)
1020     : CSSValue(PrimitiveClass)
1021 {
1022     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1023     switch (e) {
1024     case BoxLines::Single:
1025         m_value.valueID = CSSValueSingle;
1026         break;
1027     case BoxLines::Multiple:
1028         m_value.valueID = CSSValueMultiple;
1029         break;
1030     }
1031 }
1032 
1033 template&lt;&gt; inline CSSPrimitiveValue::operator BoxLines() const
1034 {
1035     ASSERT(isValueID());
1036 
1037     switch (m_value.valueID) {
1038     case CSSValueSingle:
1039         return BoxLines::Single;
1040     case CSSValueMultiple:
1041         return BoxLines::Multiple;
1042     default:
1043         break;
1044     }
1045 
1046     ASSERT_NOT_REACHED();
1047     return BoxLines::Single;
1048 }
1049 
1050 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxOrient e)
1051     : CSSValue(PrimitiveClass)
1052 {
1053     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1054     switch (e) {
1055     case BoxOrient::Horizontal:
1056         m_value.valueID = CSSValueHorizontal;
1057         break;
1058     case BoxOrient::Vertical:
1059         m_value.valueID = CSSValueVertical;
1060         break;
1061     }
1062 }
1063 
1064 template&lt;&gt; inline CSSPrimitiveValue::operator BoxOrient() const
1065 {
1066     ASSERT(isValueID());
1067 
1068     switch (m_value.valueID) {
1069     case CSSValueHorizontal:
1070     case CSSValueInlineAxis:
1071         return BoxOrient::Horizontal;
1072     case CSSValueVertical:
1073     case CSSValueBlockAxis:
1074         return BoxOrient::Vertical;
1075     default:
1076         break;
1077     }
1078 
1079     ASSERT_NOT_REACHED();
1080     return BoxOrient::Horizontal;
1081 }
1082 
1083 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CaptionSide e)
1084     : CSSValue(PrimitiveClass)
1085 {
1086     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1087     switch (e) {
1088     case CaptionSide::Left:
1089         m_value.valueID = CSSValueLeft;
1090         break;
1091     case CaptionSide::Right:
1092         m_value.valueID = CSSValueRight;
1093         break;
1094     case CaptionSide::Top:
1095         m_value.valueID = CSSValueTop;
1096         break;
1097     case CaptionSide::Bottom:
1098         m_value.valueID = CSSValueBottom;
1099         break;
1100     }
1101 }
1102 
1103 template&lt;&gt; inline CSSPrimitiveValue::operator CaptionSide() const
1104 {
1105     ASSERT(isValueID());
1106 
1107     switch (m_value.valueID) {
1108     case CSSValueLeft:
1109         return CaptionSide::Left;
1110     case CSSValueRight:
1111         return CaptionSide::Right;
1112     case CSSValueTop:
1113         return CaptionSide::Top;
1114     case CSSValueBottom:
1115         return CaptionSide::Bottom;
1116     default:
1117         break;
1118     }
1119 
1120     ASSERT_NOT_REACHED();
1121     return CaptionSide::Top;
1122 }
1123 
1124 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Clear e)
1125     : CSSValue(PrimitiveClass)
1126 {
1127     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1128     switch (e) {
1129     case Clear::None:
1130         m_value.valueID = CSSValueNone;
1131         break;
1132     case Clear::Left:
1133         m_value.valueID = CSSValueLeft;
1134         break;
1135     case Clear::Right:
1136         m_value.valueID = CSSValueRight;
1137         break;
1138     case Clear::Both:
1139         m_value.valueID = CSSValueBoth;
1140         break;
1141     }
1142 }
1143 
1144 template&lt;&gt; inline CSSPrimitiveValue::operator Clear() const
1145 {
1146     ASSERT(isValueID());
1147 
1148     switch (m_value.valueID) {
1149     case CSSValueNone:
1150         return Clear::None;
1151     case CSSValueLeft:
1152         return Clear::Left;
1153     case CSSValueRight:
1154         return Clear::Right;
1155     case CSSValueBoth:
1156         return Clear::Both;
1157     default:
1158         break;
1159     }
1160 
1161     ASSERT_NOT_REACHED();
1162     return Clear::None;
1163 }
1164 
1165 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorType e)
1166     : CSSValue(PrimitiveClass)
1167 {
1168     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1169     switch (e) {
1170     case CursorType::Auto:
1171         m_value.valueID = CSSValueAuto;
1172         break;
1173     case CursorType::Default:
1174         m_value.valueID = CSSValueDefault;
1175         break;
1176     case CursorType::None:
1177         m_value.valueID = CSSValueNone;
1178         break;
1179     case CursorType::ContextMenu:
1180         m_value.valueID = CSSValueContextMenu;
1181         break;
1182     case CursorType::Help:
1183         m_value.valueID = CSSValueHelp;
1184         break;
1185     case CursorType::Pointer:
1186         m_value.valueID = CSSValuePointer;
1187         break;
1188     case CursorType::Progress:
1189         m_value.valueID = CSSValueProgress;
1190         break;
1191     case CursorType::Wait:
1192         m_value.valueID = CSSValueWait;
1193         break;
1194     case CursorType::Cell:
1195         m_value.valueID = CSSValueCell;
1196         break;
1197     case CursorType::Crosshair:
1198         m_value.valueID = CSSValueCrosshair;
1199         break;
1200     case CursorType::Text:
1201         m_value.valueID = CSSValueText;
1202         break;
1203     case CursorType::VerticalText:
1204         m_value.valueID = CSSValueVerticalText;
1205         break;
1206     case CursorType::Alias:
1207         m_value.valueID = CSSValueAlias;
1208         break;
1209     case CursorType::Copy:
1210         m_value.valueID = CSSValueCopy;
1211         break;
1212     case CursorType::Move:
1213         m_value.valueID = CSSValueMove;
1214         break;
1215     case CursorType::NoDrop:
1216         m_value.valueID = CSSValueNoDrop;
1217         break;
1218     case CursorType::NotAllowed:
1219         m_value.valueID = CSSValueNotAllowed;
1220         break;
1221     case CursorType::Grab:
1222         m_value.valueID = CSSValueGrab;
1223         break;
1224     case CursorType::Grabbing:
1225         m_value.valueID = CSSValueGrabbing;
1226         break;
1227     case CursorType::EResize:
1228         m_value.valueID = CSSValueEResize;
1229         break;
1230     case CursorType::NResize:
1231         m_value.valueID = CSSValueNResize;
1232         break;
1233     case CursorType::NEResize:
1234         m_value.valueID = CSSValueNeResize;
1235         break;
1236     case CursorType::NWResize:
1237         m_value.valueID = CSSValueNwResize;
1238         break;
1239     case CursorType::SResize:
1240         m_value.valueID = CSSValueSResize;
1241         break;
1242     case CursorType::SEResize:
1243         m_value.valueID = CSSValueSeResize;
1244         break;
1245     case CursorType::SWResize:
1246         m_value.valueID = CSSValueSwResize;
1247         break;
1248     case CursorType::WResize:
1249         m_value.valueID = CSSValueWResize;
1250         break;
1251     case CursorType::EWResize:
1252         m_value.valueID = CSSValueEwResize;
1253         break;
1254     case CursorType::NSResize:
1255         m_value.valueID = CSSValueNsResize;
1256         break;
1257     case CursorType::NESWResize:
1258         m_value.valueID = CSSValueNeswResize;
1259         break;
1260     case CursorType::NWSEResize:
1261         m_value.valueID = CSSValueNwseResize;
1262         break;
1263     case CursorType::ColumnResize:
1264         m_value.valueID = CSSValueColResize;
1265         break;
1266     case CursorType::RowResize:
1267         m_value.valueID = CSSValueRowResize;
1268         break;
1269     case CursorType::AllScroll:
1270         m_value.valueID = CSSValueAllScroll;
1271         break;
1272     case CursorType::ZoomIn:
1273         m_value.valueID = CSSValueZoomIn;
1274         break;
1275     case CursorType::ZoomOut:
1276         m_value.valueID = CSSValueZoomOut;
1277         break;
1278     }
1279 }
1280 
1281 template&lt;&gt; inline CSSPrimitiveValue::operator CursorType() const
1282 {
1283     ASSERT(isValueID());
1284     switch (m_value.valueID) {
1285     case CSSValueCopy:
1286         return CursorType::Copy;
1287     case CSSValueWebkitGrab:
1288         return CursorType::Grab;
1289     case CSSValueWebkitGrabbing:
1290         return CursorType::Grabbing;
1291     case CSSValueWebkitZoomIn:
1292         return CursorType::ZoomIn;
1293     case CSSValueWebkitZoomOut:
1294         return CursorType::ZoomOut;
1295     case CSSValueNone:
1296         return CursorType::None;
1297     default:
1298         return static_cast&lt;CursorType&gt;(m_value.valueID - CSSValueAuto);
1299     }
1300 }
1301 
1302 #if ENABLE(CURSOR_VISIBILITY)
1303 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorVisibility e)
1304     : CSSValue(PrimitiveClass)
1305 {
1306     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1307     switch (e) {
1308     case CursorVisibility::Auto:
1309         m_value.valueID = CSSValueAuto;
1310         break;
1311     case CursorVisibility::AutoHide:
1312         m_value.valueID = CSSValueAutoHide;
1313         break;
1314     }
1315 }
1316 
1317 template&lt;&gt; inline CSSPrimitiveValue::operator CursorVisibility() const
1318 {
1319     ASSERT(isValueID());
1320 
1321     if (m_value.valueID == CSSValueAuto)
1322         return CursorVisibility::Auto;
1323     if (m_value.valueID == CSSValueAutoHide)
1324         return CursorVisibility::AutoHide;
1325 
1326     ASSERT_NOT_REACHED();
1327     return CursorVisibility::Auto;
1328 }
1329 #endif
1330 
1331 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DisplayType e)
1332     : CSSValue(PrimitiveClass)
1333 {
1334     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1335     switch (e) {
1336     case DisplayType::Inline:
1337         m_value.valueID = CSSValueInline;
1338         break;
1339     case DisplayType::Block:
1340         m_value.valueID = CSSValueBlock;
1341         break;
1342     case DisplayType::ListItem:
1343         m_value.valueID = CSSValueListItem;
1344         break;
1345     case DisplayType::InlineBlock:
1346         m_value.valueID = CSSValueInlineBlock;
1347         break;
1348     case DisplayType::Table:
1349         m_value.valueID = CSSValueTable;
1350         break;
1351     case DisplayType::InlineTable:
1352         m_value.valueID = CSSValueInlineTable;
1353         break;
1354     case DisplayType::TableRowGroup:
1355         m_value.valueID = CSSValueTableRowGroup;
1356         break;
1357     case DisplayType::TableHeaderGroup:
1358         m_value.valueID = CSSValueTableHeaderGroup;
1359         break;
1360     case DisplayType::TableFooterGroup:
1361         m_value.valueID = CSSValueTableFooterGroup;
1362         break;
1363     case DisplayType::TableRow:
1364         m_value.valueID = CSSValueTableRow;
1365         break;
1366     case DisplayType::TableColumnGroup:
1367         m_value.valueID = CSSValueTableColumnGroup;
1368         break;
1369     case DisplayType::TableColumn:
1370         m_value.valueID = CSSValueTableColumn;
1371         break;
1372     case DisplayType::TableCell:
1373         m_value.valueID = CSSValueTableCell;
1374         break;
1375     case DisplayType::TableCaption:
1376         m_value.valueID = CSSValueTableCaption;
1377         break;
1378     case DisplayType::Box:
1379         m_value.valueID = CSSValueWebkitBox;
1380         break;
1381     case DisplayType::InlineBox:
1382         m_value.valueID = CSSValueWebkitInlineBox;
1383         break;
1384     case DisplayType::Flex:
1385     case DisplayType::WebKitFlex:
1386         m_value.valueID = CSSValueFlex;
1387         break;
1388     case DisplayType::InlineFlex:
1389     case DisplayType::WebKitInlineFlex:
1390         m_value.valueID = CSSValueInlineFlex;
1391         break;
1392     case DisplayType::Grid:
1393         m_value.valueID = CSSValueGrid;
1394         break;
1395     case DisplayType::InlineGrid:
1396         m_value.valueID = CSSValueInlineGrid;
1397         break;
1398     case DisplayType::None:
1399         m_value.valueID = CSSValueNone;
1400         break;
1401     case DisplayType::Contents:
1402         m_value.valueID = CSSValueContents;
1403         break;
1404     case DisplayType::FlowRoot:
1405         m_value.valueID = CSSValueFlowRoot;
1406         break;
1407     }
1408 }
1409 
1410 template&lt;&gt; inline CSSPrimitiveValue::operator DisplayType() const
1411 {
1412     ASSERT(isValueID());
1413 
1414     if (m_value.valueID == CSSValueNone)
1415         return DisplayType::None;
1416 
1417     DisplayType display = static_cast&lt;DisplayType&gt;(m_value.valueID - CSSValueInline);
1418     ASSERT(display &gt;= DisplayType::Inline &amp;&amp; display &lt;= DisplayType::None);
1419     if (display == DisplayType::WebKitFlex)
1420         return DisplayType::Flex;
1421     if (display == DisplayType::WebKitInlineFlex)
1422         return DisplayType::InlineFlex;
1423     return display;
1424 }
1425 
1426 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EmptyCell e)
1427     : CSSValue(PrimitiveClass)
1428 {
1429     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1430     switch (e) {
1431     case EmptyCell::Show:
1432         m_value.valueID = CSSValueShow;
1433         break;
1434     case EmptyCell::Hide:
1435         m_value.valueID = CSSValueHide;
1436         break;
1437     }
1438 }
1439 
1440 template&lt;&gt; inline CSSPrimitiveValue::operator EmptyCell() const
1441 {
1442     ASSERT(isValueID());
1443 
1444     switch (m_value.valueID) {
1445     case CSSValueShow:
1446         return EmptyCell::Show;
1447     case CSSValueHide:
1448         return EmptyCell::Hide;
1449     default:
1450         break;
1451     }
1452 
1453     ASSERT_NOT_REACHED();
1454     return EmptyCell::Show;
1455 }
1456 
1457 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexDirection e)
1458     : CSSValue(PrimitiveClass)
1459 {
1460     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1461     switch (e) {
1462     case FlexDirection::Row:
1463         m_value.valueID = CSSValueRow;
1464         break;
1465     case FlexDirection::RowReverse:
1466         m_value.valueID = CSSValueRowReverse;
1467         break;
1468     case FlexDirection::Column:
1469         m_value.valueID = CSSValueColumn;
1470         break;
1471     case FlexDirection::ColumnReverse:
1472         m_value.valueID = CSSValueColumnReverse;
1473         break;
1474     }
1475 }
1476 
1477 template&lt;&gt; inline CSSPrimitiveValue::operator FlexDirection() const
1478 {
1479     ASSERT(isValueID());
1480 
1481     switch (m_value.valueID) {
1482     case CSSValueRow:
1483         return FlexDirection::Row;
1484     case CSSValueRowReverse:
1485         return FlexDirection::RowReverse;
1486     case CSSValueColumn:
1487         return FlexDirection::Column;
1488     case CSSValueColumnReverse:
1489         return FlexDirection::ColumnReverse;
1490     default:
1491         break;
1492     }
1493 
1494     ASSERT_NOT_REACHED();
1495     return FlexDirection::Row;
1496 }
1497 
1498 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignContent e)
1499     : CSSValue(PrimitiveClass)
1500 {
1501     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1502     switch (e) {
1503     case AlignContent::FlexStart:
1504         m_value.valueID = CSSValueFlexStart;
1505         break;
1506     case AlignContent::FlexEnd:
1507         m_value.valueID = CSSValueFlexEnd;
1508         break;
1509     case AlignContent::Center:
1510         m_value.valueID = CSSValueCenter;
1511         break;
1512     case AlignContent::SpaceBetween:
1513         m_value.valueID = CSSValueSpaceBetween;
1514         break;
1515     case AlignContent::SpaceAround:
1516         m_value.valueID = CSSValueSpaceAround;
1517         break;
1518     case AlignContent::Stretch:
1519         m_value.valueID = CSSValueStretch;
1520         break;
1521     }
1522 }
1523 
1524 template&lt;&gt; inline CSSPrimitiveValue::operator AlignContent() const
1525 {
1526     ASSERT(isValueID());
1527 
1528     switch (m_value.valueID) {
1529     case CSSValueFlexStart:
1530         return AlignContent::FlexStart;
1531     case CSSValueFlexEnd:
1532         return AlignContent::FlexEnd;
1533     case CSSValueCenter:
1534         return AlignContent::Center;
1535     case CSSValueSpaceBetween:
1536         return AlignContent::SpaceBetween;
1537     case CSSValueSpaceAround:
1538         return AlignContent::SpaceAround;
1539     case CSSValueStretch:
1540         return AlignContent::Stretch;
1541     default:
1542         break;
1543     }
1544 
1545     ASSERT_NOT_REACHED();
1546     return AlignContent::Stretch;
1547 }
1548 
1549 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexWrap e)
1550     : CSSValue(PrimitiveClass)
1551 {
1552     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1553     switch (e) {
1554     case FlexWrap::NoWrap:
1555         m_value.valueID = CSSValueNowrap;
1556         break;
1557     case FlexWrap::Wrap:
1558         m_value.valueID = CSSValueWrap;
1559         break;
1560     case FlexWrap::Reverse:
1561         m_value.valueID = CSSValueWrapReverse;
1562         break;
1563     }
1564 }
1565 
1566 template&lt;&gt; inline CSSPrimitiveValue::operator FlexWrap() const
1567 {
1568     ASSERT(isValueID());
1569 
1570     switch (m_value.valueID) {
1571     case CSSValueNowrap:
1572         return FlexWrap::NoWrap;
1573     case CSSValueWrap:
1574         return FlexWrap::Wrap;
1575     case CSSValueWrapReverse:
1576         return FlexWrap::Reverse;
1577     default:
1578         break;
1579     }
1580 
1581     ASSERT_NOT_REACHED();
1582     return FlexWrap::NoWrap;
1583 }
1584 
1585 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Float e)
1586     : CSSValue(PrimitiveClass)
1587 {
1588     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1589     switch (e) {
1590     case Float::No:
1591         m_value.valueID = CSSValueNone;
1592         break;
1593     case Float::Left:
1594         m_value.valueID = CSSValueLeft;
1595         break;
1596     case Float::Right:
1597         m_value.valueID = CSSValueRight;
1598         break;
1599     }
1600 }
1601 
1602 template&lt;&gt; inline CSSPrimitiveValue::operator Float() const
1603 {
1604     ASSERT(isValueID());
1605 
1606     switch (m_value.valueID) {
1607     case CSSValueLeft:
1608         return Float::Left;
1609     case CSSValueRight:
1610         return Float::Right;
1611     case CSSValueNone:
1612     case CSSValueCenter: // Non-standard CSS value.
1613         return Float::No;
1614     default:
1615         break;
1616     }
1617 
1618     ASSERT_NOT_REACHED();
1619     return Float::No;
1620 }
1621 
1622 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineBreak e)
1623     : CSSValue(PrimitiveClass)
1624 {
1625     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1626     switch (e) {
1627     case LineBreak::Auto:
1628         m_value.valueID = CSSValueAuto;
1629         break;
1630     case LineBreak::Loose:
1631         m_value.valueID = CSSValueLoose;
1632         break;
1633     case LineBreak::Normal:
1634         m_value.valueID = CSSValueNormal;
1635         break;
1636     case LineBreak::Strict:
1637         m_value.valueID = CSSValueStrict;
1638         break;
1639     case LineBreak::AfterWhiteSpace:
1640         m_value.valueID = CSSValueAfterWhiteSpace;
1641         break;
1642     case LineBreak::Anywhere:
1643         m_value.valueID = CSSValueAnywhere;
1644         break;
1645     }
1646 }
1647 
1648 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;HangingPunctuation&gt;() const
1649 {
1650     ASSERT(isValueID());
1651 
1652     switch (m_value.valueID) {
1653     case CSSValueNone:
1654         return OptionSet&lt;HangingPunctuation&gt; { };
1655     case CSSValueFirst:
1656         return HangingPunctuation::First;
1657     case CSSValueLast:
1658         return HangingPunctuation::Last;
1659     case CSSValueAllowEnd:
1660         return HangingPunctuation::AllowEnd;
1661     case CSSValueForceEnd:
1662         return HangingPunctuation::ForceEnd;
1663     default:
1664         break;
1665     }
1666 
1667     ASSERT_NOT_REACHED();
1668     return OptionSet&lt;HangingPunctuation&gt; { };
1669 }
1670 
1671 template&lt;&gt; inline CSSPrimitiveValue::operator LineBreak() const
1672 {
1673     ASSERT(isValueID());
1674 
1675     switch (m_value.valueID) {
1676     case CSSValueAuto:
1677         return LineBreak::Auto;
1678     case CSSValueLoose:
1679         return LineBreak::Loose;
1680     case CSSValueNormal:
1681         return LineBreak::Normal;
1682     case CSSValueStrict:
1683         return LineBreak::Strict;
1684     case CSSValueAfterWhiteSpace:
1685         return LineBreak::AfterWhiteSpace;
1686     case CSSValueAnywhere:
1687         return LineBreak::Anywhere;
1688     default:
1689         break;
1690     }
1691 
1692     ASSERT_NOT_REACHED();
1693     return LineBreak::Auto;
1694 }
1695 
1696 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStylePosition e)
1697     : CSSValue(PrimitiveClass)
1698 {
1699     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1700     switch (e) {
1701     case ListStylePosition::Outside:
1702         m_value.valueID = CSSValueOutside;
1703         break;
1704     case ListStylePosition::Inside:
1705         m_value.valueID = CSSValueInside;
1706         break;
1707     }
1708 }
1709 
1710 template&lt;&gt; inline CSSPrimitiveValue::operator ListStylePosition() const
1711 {
1712     ASSERT(isValueID());
1713 
1714     switch (m_value.valueID) {
1715     case CSSValueOutside:
1716         return ListStylePosition::Outside;
1717     case CSSValueInside:
1718         return ListStylePosition::Inside;
1719     default:
1720         break;
1721     }
1722 
1723     ASSERT_NOT_REACHED();
1724     return ListStylePosition::Outside;
1725 }
1726 
1727 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStyleType e)
1728     : CSSValue(PrimitiveClass)
1729 {
1730     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1731     switch (e) {
1732     case ListStyleType::Afar:
1733         m_value.valueID = CSSValueAfar;
1734         break;
1735     case ListStyleType::Amharic:
1736         m_value.valueID = CSSValueAmharic;
1737         break;
1738     case ListStyleType::AmharicAbegede:
1739         m_value.valueID = CSSValueAmharicAbegede;
1740         break;
1741     case ListStyleType::ArabicIndic:
1742         m_value.valueID = CSSValueArabicIndic;
1743         break;
1744     case ListStyleType::Armenian:
1745         m_value.valueID = CSSValueArmenian;
1746         break;
1747     case ListStyleType::Asterisks:
1748         m_value.valueID = CSSValueAsterisks;
1749         break;
1750     case ListStyleType::Binary:
1751         m_value.valueID = CSSValueBinary;
1752         break;
1753     case ListStyleType::Bengali:
1754         m_value.valueID = CSSValueBengali;
1755         break;
1756     case ListStyleType::Cambodian:
1757         m_value.valueID = CSSValueCambodian;
1758         break;
1759     case ListStyleType::Circle:
1760         m_value.valueID = CSSValueCircle;
1761         break;
1762     case ListStyleType::CjkEarthlyBranch:
1763         m_value.valueID = CSSValueCjkEarthlyBranch;
1764         break;
1765     case ListStyleType::CjkHeavenlyStem:
1766         m_value.valueID = CSSValueCjkHeavenlyStem;
1767         break;
1768     case ListStyleType::CJKIdeographic:
1769         m_value.valueID = CSSValueCjkIdeographic;
1770         break;
1771     case ListStyleType::DecimalLeadingZero:
1772         m_value.valueID = CSSValueDecimalLeadingZero;
1773         break;
1774     case ListStyleType::Decimal:
1775         m_value.valueID = CSSValueDecimal;
1776         break;
1777     case ListStyleType::Devanagari:
1778         m_value.valueID = CSSValueDevanagari;
1779         break;
1780     case ListStyleType::Disc:
1781         m_value.valueID = CSSValueDisc;
1782         break;
1783     case ListStyleType::Ethiopic:
1784         m_value.valueID = CSSValueEthiopic;
1785         break;
1786     case ListStyleType::EthiopicAbegede:
1787         m_value.valueID = CSSValueEthiopicAbegede;
1788         break;
1789     case ListStyleType::EthiopicAbegedeAmEt:
1790         m_value.valueID = CSSValueEthiopicAbegedeAmEt;
1791         break;
1792     case ListStyleType::EthiopicAbegedeGez:
1793         m_value.valueID = CSSValueEthiopicAbegedeGez;
1794         break;
1795     case ListStyleType::EthiopicAbegedeTiEr:
1796         m_value.valueID = CSSValueEthiopicAbegedeTiEr;
1797         break;
1798     case ListStyleType::EthiopicAbegedeTiEt:
1799         m_value.valueID = CSSValueEthiopicAbegedeTiEt;
1800         break;
1801     case ListStyleType::EthiopicHalehameAaEr:
1802         m_value.valueID = CSSValueEthiopicHalehameAaEr;
1803         break;
1804     case ListStyleType::EthiopicHalehameAaEt:
1805         m_value.valueID = CSSValueEthiopicHalehameAaEt;
1806         break;
1807     case ListStyleType::EthiopicHalehameAmEt:
1808         m_value.valueID = CSSValueEthiopicHalehameAmEt;
1809         break;
1810     case ListStyleType::EthiopicHalehameGez:
1811         m_value.valueID = CSSValueEthiopicHalehameGez;
1812         break;
1813     case ListStyleType::EthiopicHalehameOmEt:
1814         m_value.valueID = CSSValueEthiopicHalehameOmEt;
1815         break;
1816     case ListStyleType::EthiopicHalehameSidEt:
1817         m_value.valueID = CSSValueEthiopicHalehameSidEt;
1818         break;
1819     case ListStyleType::EthiopicHalehameSoEt:
1820         m_value.valueID = CSSValueEthiopicHalehameSoEt;
1821         break;
1822     case ListStyleType::EthiopicHalehameTiEr:
1823         m_value.valueID = CSSValueEthiopicHalehameTiEr;
1824         break;
1825     case ListStyleType::EthiopicHalehameTiEt:
1826         m_value.valueID = CSSValueEthiopicHalehameTiEt;
1827         break;
1828     case ListStyleType::EthiopicHalehameTig:
1829         m_value.valueID = CSSValueEthiopicHalehameTig;
1830         break;
1831     case ListStyleType::Footnotes:
1832         m_value.valueID = CSSValueFootnotes;
1833         break;
1834     case ListStyleType::Georgian:
1835         m_value.valueID = CSSValueGeorgian;
1836         break;
1837     case ListStyleType::Gujarati:
1838         m_value.valueID = CSSValueGujarati;
1839         break;
1840     case ListStyleType::Gurmukhi:
1841         m_value.valueID = CSSValueGurmukhi;
1842         break;
1843     case ListStyleType::Hangul:
1844         m_value.valueID = CSSValueHangul;
1845         break;
1846     case ListStyleType::HangulConsonant:
1847         m_value.valueID = CSSValueHangulConsonant;
1848         break;
1849     case ListStyleType::Hebrew:
1850         m_value.valueID = CSSValueHebrew;
1851         break;
1852     case ListStyleType::Hiragana:
1853         m_value.valueID = CSSValueHiragana;
1854         break;
1855     case ListStyleType::HiraganaIroha:
1856         m_value.valueID = CSSValueHiraganaIroha;
1857         break;
1858     case ListStyleType::Kannada:
1859         m_value.valueID = CSSValueKannada;
1860         break;
1861     case ListStyleType::Katakana:
1862         m_value.valueID = CSSValueKatakana;
1863         break;
1864     case ListStyleType::KatakanaIroha:
1865         m_value.valueID = CSSValueKatakanaIroha;
1866         break;
1867     case ListStyleType::Khmer:
1868         m_value.valueID = CSSValueKhmer;
1869         break;
1870     case ListStyleType::Lao:
1871         m_value.valueID = CSSValueLao;
1872         break;
1873     case ListStyleType::LowerAlpha:
1874         m_value.valueID = CSSValueLowerAlpha;
1875         break;
1876     case ListStyleType::LowerArmenian:
1877         m_value.valueID = CSSValueLowerArmenian;
1878         break;
1879     case ListStyleType::LowerGreek:
1880         m_value.valueID = CSSValueLowerGreek;
1881         break;
1882     case ListStyleType::LowerHexadecimal:
1883         m_value.valueID = CSSValueLowerHexadecimal;
1884         break;
1885     case ListStyleType::LowerLatin:
1886         m_value.valueID = CSSValueLowerLatin;
1887         break;
1888     case ListStyleType::LowerNorwegian:
1889         m_value.valueID = CSSValueLowerNorwegian;
1890         break;
1891     case ListStyleType::LowerRoman:
1892         m_value.valueID = CSSValueLowerRoman;
1893         break;
1894     case ListStyleType::Malayalam:
1895         m_value.valueID = CSSValueMalayalam;
1896         break;
1897     case ListStyleType::Mongolian:
1898         m_value.valueID = CSSValueMongolian;
1899         break;
1900     case ListStyleType::Myanmar:
1901         m_value.valueID = CSSValueMyanmar;
1902         break;
1903     case ListStyleType::None:
1904         m_value.valueID = CSSValueNone;
1905         break;
1906     case ListStyleType::Octal:
1907         m_value.valueID = CSSValueOctal;
1908         break;
1909     case ListStyleType::Oriya:
1910         m_value.valueID = CSSValueOriya;
1911         break;
1912     case ListStyleType::Oromo:
1913         m_value.valueID = CSSValueOromo;
1914         break;
1915     case ListStyleType::Persian:
1916         m_value.valueID = CSSValuePersian;
1917         break;
1918     case ListStyleType::Sidama:
1919         m_value.valueID = CSSValueSidama;
1920         break;
1921     case ListStyleType::Somali:
1922         m_value.valueID = CSSValueSomali;
1923         break;
1924     case ListStyleType::Square:
1925         m_value.valueID = CSSValueSquare;
1926         break;
1927     case ListStyleType::Telugu:
1928         m_value.valueID = CSSValueTelugu;
1929         break;
1930     case ListStyleType::Thai:
1931         m_value.valueID = CSSValueThai;
1932         break;
1933     case ListStyleType::Tibetan:
1934         m_value.valueID = CSSValueTibetan;
1935         break;
1936     case ListStyleType::Tigre:
1937         m_value.valueID = CSSValueTigre;
1938         break;
1939     case ListStyleType::TigrinyaEr:
1940         m_value.valueID = CSSValueTigrinyaEr;
1941         break;
1942     case ListStyleType::TigrinyaErAbegede:
1943         m_value.valueID = CSSValueTigrinyaErAbegede;
1944         break;
1945     case ListStyleType::TigrinyaEt:
1946         m_value.valueID = CSSValueTigrinyaEt;
1947         break;
1948     case ListStyleType::TigrinyaEtAbegede:
1949         m_value.valueID = CSSValueTigrinyaEtAbegede;
1950         break;
1951     case ListStyleType::UpperAlpha:
1952         m_value.valueID = CSSValueUpperAlpha;
1953         break;
1954     case ListStyleType::UpperArmenian:
1955         m_value.valueID = CSSValueUpperArmenian;
1956         break;
1957     case ListStyleType::UpperGreek:
1958         m_value.valueID = CSSValueUpperGreek;
1959         break;
1960     case ListStyleType::UpperHexadecimal:
1961         m_value.valueID = CSSValueUpperHexadecimal;
1962         break;
1963     case ListStyleType::UpperLatin:
1964         m_value.valueID = CSSValueUpperLatin;
1965         break;
1966     case ListStyleType::UpperNorwegian:
1967         m_value.valueID = CSSValueUpperNorwegian;
1968         break;
1969     case ListStyleType::UpperRoman:
1970         m_value.valueID = CSSValueUpperRoman;
1971         break;
1972     case ListStyleType::Urdu:
1973         m_value.valueID = CSSValueUrdu;
1974         break;
1975     }
1976 }
1977 
1978 template&lt;&gt; inline CSSPrimitiveValue::operator ListStyleType() const
1979 {
1980     ASSERT(isValueID());
1981 
1982     switch (m_value.valueID) {
1983     case CSSValueNone:
1984         return ListStyleType::None;
1985     default:
1986         return static_cast&lt;ListStyleType&gt;(m_value.valueID - CSSValueDisc);
1987     }
1988 }
1989 
1990 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarginCollapse e)
1991     : CSSValue(PrimitiveClass)
1992 {
1993     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
1994     switch (e) {
1995     case MarginCollapse::Collapse:
1996         m_value.valueID = CSSValueCollapse;
1997         break;
1998     case MarginCollapse::Separate:
1999         m_value.valueID = CSSValueSeparate;
2000         break;
2001     case MarginCollapse::Discard:
2002         m_value.valueID = CSSValueDiscard;
2003         break;
2004     }
2005 }
2006 
2007 template&lt;&gt; inline CSSPrimitiveValue::operator MarginCollapse() const
2008 {
2009     ASSERT(isValueID());
2010 
2011     switch (m_value.valueID) {
2012     case CSSValueCollapse:
2013         return MarginCollapse::Collapse;
2014     case CSSValueSeparate:
2015         return MarginCollapse::Separate;
2016     case CSSValueDiscard:
2017         return MarginCollapse::Discard;
2018     default:
2019         break;
2020     }
2021 
2022     ASSERT_NOT_REACHED();
2023     return MarginCollapse::Collapse;
2024 }
2025 
2026 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeBehavior e)
2027     : CSSValue(PrimitiveClass)
2028 {
2029     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2030     switch (e) {
2031     case MarqueeBehavior::None:
2032         m_value.valueID = CSSValueNone;
2033         break;
2034     case MarqueeBehavior::Scroll:
2035         m_value.valueID = CSSValueScroll;
2036         break;
2037     case MarqueeBehavior::Slide:
2038         m_value.valueID = CSSValueSlide;
2039         break;
2040     case MarqueeBehavior::Alternate:
2041         m_value.valueID = CSSValueAlternate;
2042         break;
2043     }
2044 }
2045 
2046 template&lt;&gt; inline CSSPrimitiveValue::operator MarqueeBehavior() const
2047 {
2048     ASSERT(isValueID());
2049 
2050     switch (m_value.valueID) {
2051     case CSSValueNone:
2052         return MarqueeBehavior::None;
2053     case CSSValueScroll:
2054         return MarqueeBehavior::Scroll;
2055     case CSSValueSlide:
2056         return MarqueeBehavior::Slide;
2057     case CSSValueAlternate:
2058         return MarqueeBehavior::Alternate;
2059     default:
2060         break;
2061     }
2062 
2063     ASSERT_NOT_REACHED();
2064     return MarqueeBehavior::None;
2065 }
2066 
2067 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeDirection direction)
2068     : CSSValue(PrimitiveClass)
2069 {
2070     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2071     switch (direction) {
2072     case MarqueeDirection::Forward:
2073         m_value.valueID = CSSValueForwards;
2074         break;
2075     case MarqueeDirection::Backward:
2076         m_value.valueID = CSSValueBackwards;
2077         break;
2078     case MarqueeDirection::Auto:
2079         m_value.valueID = CSSValueAuto;
2080         break;
2081     case MarqueeDirection::Up:
2082         m_value.valueID = CSSValueUp;
2083         break;
2084     case MarqueeDirection::Down:
2085         m_value.valueID = CSSValueDown;
2086         break;
2087     case MarqueeDirection::Left:
2088         m_value.valueID = CSSValueLeft;
2089         break;
2090     case MarqueeDirection::Right:
2091         m_value.valueID = CSSValueRight;
2092         break;
2093     }
2094 }
2095 
2096 template&lt;&gt; inline CSSPrimitiveValue::operator MarqueeDirection() const
2097 {
2098     ASSERT(isValueID());
2099 
2100     switch (m_value.valueID) {
2101     case CSSValueForwards:
2102         return MarqueeDirection::Forward;
2103     case CSSValueBackwards:
2104         return MarqueeDirection::Backward;
2105     case CSSValueAuto:
2106         return MarqueeDirection::Auto;
2107     case CSSValueAhead:
2108     case CSSValueUp: // We don&#39;t support vertical languages, so AHEAD just maps to UP.
2109         return MarqueeDirection::Up;
2110     case CSSValueReverse:
2111     case CSSValueDown: // REVERSE just maps to DOWN, since we don&#39;t do vertical text.
2112         return MarqueeDirection::Down;
2113     case CSSValueLeft:
2114         return MarqueeDirection::Left;
2115     case CSSValueRight:
2116         return MarqueeDirection::Right;
2117     default:
2118         break;
2119     }
2120 
2121     ASSERT_NOT_REACHED();
2122     return MarqueeDirection::Auto;
2123 }
2124 
2125 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(NBSPMode e)
2126     : CSSValue(PrimitiveClass)
2127 {
2128     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2129     switch (e) {
2130     case NBSPMode::Normal:
2131         m_value.valueID = CSSValueNormal;
2132         break;
2133     case NBSPMode::Space:
2134         m_value.valueID = CSSValueSpace;
2135         break;
2136     }
2137 }
2138 
2139 template&lt;&gt; inline CSSPrimitiveValue::operator NBSPMode() const
2140 {
2141     ASSERT(isValueID());
2142 
2143     switch (m_value.valueID) {
2144     case CSSValueSpace:
2145         return NBSPMode::Space;
2146     case CSSValueNormal:
2147         return NBSPMode::Normal;
2148     default:
2149         break;
2150     }
2151 
2152     ASSERT_NOT_REACHED();
2153     return NBSPMode::Normal;
2154 }
2155 
2156 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Overflow e)
2157     : CSSValue(PrimitiveClass)
2158 {
2159     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2160     switch (e) {
2161     case Overflow::Visible:
2162         m_value.valueID = CSSValueVisible;
2163         break;
2164     case Overflow::Hidden:
2165         m_value.valueID = CSSValueHidden;
2166         break;
2167     case Overflow::Scroll:
2168         m_value.valueID = CSSValueScroll;
2169         break;
2170     case Overflow::Auto:
2171         m_value.valueID = CSSValueAuto;
2172         break;
2173     case Overflow::PagedX:
2174         m_value.valueID = CSSValueWebkitPagedX;
2175         break;
2176     case Overflow::PagedY:
2177         m_value.valueID = CSSValueWebkitPagedY;
2178         break;
2179     }
2180 }
2181 
2182 template&lt;&gt; inline CSSPrimitiveValue::operator Overflow() const
2183 {
2184     ASSERT(isValueID());
2185 
2186     switch (m_value.valueID) {
2187     case CSSValueVisible:
2188         return Overflow::Visible;
2189     case CSSValueHidden:
2190         return Overflow::Hidden;
2191     case CSSValueScroll:
2192         return Overflow::Scroll;
2193     case CSSValueOverlay:
2194     case CSSValueAuto:
2195         return Overflow::Auto;
2196     case CSSValueWebkitPagedX:
2197         return Overflow::PagedX;
2198     case CSSValueWebkitPagedY:
2199         return Overflow::PagedY;
2200     default:
2201         break;
2202     }
2203 
2204     ASSERT_NOT_REACHED();
2205     return Overflow::Visible;
2206 }
2207 
2208 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakBetween e)
2209     : CSSValue(PrimitiveClass)
2210 {
2211     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2212     switch (e) {
2213     case BreakBetween::Auto:
2214         m_value.valueID = CSSValueAuto;
2215         break;
2216     case BreakBetween::Avoid:
2217         m_value.valueID = CSSValueAvoid;
2218         break;
2219     case BreakBetween::AvoidColumn:
2220         m_value.valueID = CSSValueAvoidColumn;
2221         break;
2222     case BreakBetween::AvoidPage:
2223         m_value.valueID = CSSValueAvoidPage;
2224         break;
2225     case BreakBetween::Column:
2226         m_value.valueID = CSSValueColumn;
2227         break;
2228     case BreakBetween::Page:
2229         m_value.valueID = CSSValuePage;
2230         break;
2231     case BreakBetween::LeftPage:
2232         m_value.valueID = CSSValueLeft;
2233         break;
2234     case BreakBetween::RightPage:
2235         m_value.valueID = CSSValueRight;
2236         break;
2237     case BreakBetween::RectoPage:
2238         m_value.valueID = CSSValueRecto;
2239         break;
2240     case BreakBetween::VersoPage:
2241         m_value.valueID = CSSValueVerso;
2242         break;
2243     }
2244 }
2245 
2246 template&lt;&gt; inline CSSPrimitiveValue::operator BreakBetween() const
2247 {
2248     ASSERT(isValueID());
2249 
2250     switch (m_value.valueID) {
2251     case CSSValueAuto:
2252         return BreakBetween::Auto;
2253     case CSSValueAvoid:
2254         return BreakBetween::Avoid;
2255     case CSSValueAvoidColumn:
2256         return BreakBetween::AvoidColumn;
2257     case CSSValueAvoidPage:
2258         return BreakBetween::AvoidPage;
2259     case CSSValueColumn:
2260         return BreakBetween::Column;
2261     case CSSValuePage:
2262         return BreakBetween::Page;
2263     case CSSValueLeft:
2264         return BreakBetween::LeftPage;
2265     case CSSValueRight:
2266         return BreakBetween::RightPage;
2267     case CSSValueRecto:
2268         return BreakBetween::RectoPage;
2269     case CSSValueVerso:
2270         return BreakBetween::VersoPage;
2271     default:
2272         break;
2273     }
2274 
2275     ASSERT_NOT_REACHED();
2276     return BreakBetween::Auto;
2277 }
2278 
2279 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakInside e)
2280     : CSSValue(PrimitiveClass)
2281 {
2282     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2283     switch (e) {
2284     case BreakInside::Auto:
2285         m_value.valueID = CSSValueAuto;
2286         break;
2287     case BreakInside::Avoid:
2288         m_value.valueID = CSSValueAvoid;
2289         break;
2290     case BreakInside::AvoidColumn:
2291         m_value.valueID = CSSValueAvoidColumn;
2292         break;
2293     case BreakInside::AvoidPage:
2294         m_value.valueID = CSSValueAvoidPage;
2295         break;
2296     }
2297 }
2298 
2299 template&lt;&gt; inline CSSPrimitiveValue::operator BreakInside() const
2300 {
2301     ASSERT(isValueID());
2302 
2303     switch (m_value.valueID) {
2304     case CSSValueAuto:
2305         return BreakInside::Auto;
2306     case CSSValueAvoid:
2307         return BreakInside::Avoid;
2308     case CSSValueAvoidColumn:
2309         return BreakInside::AvoidColumn;
2310     case CSSValueAvoidPage:
2311         return BreakInside::AvoidPage;
2312     default:
2313         break;
2314     }
2315 
2316     ASSERT_NOT_REACHED();
2317     return BreakInside::Auto;
2318 }
2319 
2320 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PositionType e)
2321     : CSSValue(PrimitiveClass)
2322 {
2323     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2324     switch (e) {
2325     case PositionType::Static:
2326         m_value.valueID = CSSValueStatic;
2327         break;
2328     case PositionType::Relative:
2329         m_value.valueID = CSSValueRelative;
2330         break;
2331     case PositionType::Absolute:
2332         m_value.valueID = CSSValueAbsolute;
2333         break;
2334     case PositionType::Fixed:
2335         m_value.valueID = CSSValueFixed;
2336         break;
2337     case PositionType::Sticky:
2338         m_value.valueID = CSSValueSticky;
2339         break;
2340     }
2341 }
2342 
2343 template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
2344 {
2345     ASSERT(isValueID());
2346 
2347     switch (m_value.valueID) {
2348     case CSSValueStatic:
2349         return PositionType::Static;
2350     case CSSValueRelative:
2351         return PositionType::Relative;
2352     case CSSValueAbsolute:
2353         return PositionType::Absolute;
2354     case CSSValueFixed:
2355         return PositionType::Fixed;
2356     case CSSValueSticky:
2357     case CSSValueWebkitSticky:
2358         return PositionType::Sticky;
2359     default:
2360         break;
2361     }
2362 
2363     ASSERT_NOT_REACHED();
2364     return PositionType::Static;
2365 }
2366 
2367 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Resize e)
2368     : CSSValue(PrimitiveClass)
2369 {
2370     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2371     switch (e) {
2372     case Resize::Both:
2373         m_value.valueID = CSSValueBoth;
2374         break;
2375     case Resize::Horizontal:
2376         m_value.valueID = CSSValueHorizontal;
2377         break;
2378     case Resize::Vertical:
2379         m_value.valueID = CSSValueVertical;
2380         break;
2381     case Resize::None:
2382         m_value.valueID = CSSValueNone;
2383         break;
2384     }
2385 }
2386 
2387 template&lt;&gt; inline CSSPrimitiveValue::operator Resize() const
2388 {
2389     ASSERT(isValueID());
2390 
2391     switch (m_value.valueID) {
2392     case CSSValueBoth:
2393         return Resize::Both;
2394     case CSSValueHorizontal:
2395         return Resize::Horizontal;
2396     case CSSValueVertical:
2397         return Resize::Vertical;
2398     case CSSValueAuto:
2399         ASSERT_NOT_REACHED(); // Depends on settings, thus should be handled by the caller.
2400         return Resize::None;
2401     case CSSValueNone:
2402         return Resize::None;
2403     default:
2404         break;
2405     }
2406 
2407     ASSERT_NOT_REACHED();
2408     return Resize::None;
2409 }
2410 
2411 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TableLayoutType e)
2412     : CSSValue(PrimitiveClass)
2413 {
2414     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2415     switch (e) {
2416     case TableLayoutType::Auto:
2417         m_value.valueID = CSSValueAuto;
2418         break;
2419     case TableLayoutType::Fixed:
2420         m_value.valueID = CSSValueFixed;
2421         break;
2422     }
2423 }
2424 
2425 template&lt;&gt; inline CSSPrimitiveValue::operator TableLayoutType() const
2426 {
2427     ASSERT(isValueID());
2428 
2429     switch (m_value.valueID) {
2430     case CSSValueFixed:
2431         return TableLayoutType::Fixed;
2432     case CSSValueAuto:
2433         return TableLayoutType::Auto;
2434     default:
2435         break;
2436     }
2437 
2438     ASSERT_NOT_REACHED();
2439     return TableLayoutType::Auto;
2440 }
2441 
2442 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignMode e)
2443     : CSSValue(PrimitiveClass)
2444 {
2445     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2446     switch (e) {
2447     case TextAlignMode::Start:
2448         m_value.valueID = CSSValueStart;
2449         break;
2450     case TextAlignMode::End:
2451         m_value.valueID = CSSValueEnd;
2452         break;
2453     case TextAlignMode::Left:
2454         m_value.valueID = CSSValueLeft;
2455         break;
2456     case TextAlignMode::Right:
2457         m_value.valueID = CSSValueRight;
2458         break;
2459     case TextAlignMode::Center:
2460         m_value.valueID = CSSValueCenter;
2461         break;
2462     case TextAlignMode::Justify:
2463         m_value.valueID = CSSValueJustify;
2464         break;
2465     case TextAlignMode::WebKitLeft:
2466         m_value.valueID = CSSValueWebkitLeft;
2467         break;
2468     case TextAlignMode::WebKitRight:
2469         m_value.valueID = CSSValueWebkitRight;
2470         break;
2471     case TextAlignMode::WebKitCenter:
2472         m_value.valueID = CSSValueWebkitCenter;
2473         break;
2474     }
2475 }
2476 
2477 template&lt;&gt; inline CSSPrimitiveValue::operator TextAlignMode() const
2478 {
2479     ASSERT(isValueID());
2480 
2481     switch (m_value.valueID) {
2482     case CSSValueWebkitAuto: // Legacy -webkit-auto. Eqiuvalent to start.
2483     case CSSValueStart:
2484         return TextAlignMode::Start;
2485     case CSSValueEnd:
2486         return TextAlignMode::End;
2487     default:
2488         return static_cast&lt;TextAlignMode&gt;(m_value.valueID - CSSValueLeft);
2489     }
2490 }
2491 
2492 #if ENABLE(CSS3_TEXT)
2493 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignLast e)
2494     : CSSValue(PrimitiveClass)
2495 {
2496     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2497     switch (e) {
2498     case TextAlignLast::Start:
2499         m_value.valueID = CSSValueStart;
2500         break;
2501     case TextAlignLast::End:
2502         m_value.valueID = CSSValueEnd;
2503         break;
2504     case TextAlignLast::Left:
2505         m_value.valueID = CSSValueLeft;
2506         break;
2507     case TextAlignLast::Right:
2508         m_value.valueID = CSSValueRight;
2509         break;
2510     case TextAlignLast::Center:
2511         m_value.valueID = CSSValueCenter;
2512         break;
2513     case TextAlignLast::Justify:
2514         m_value.valueID = CSSValueJustify;
2515         break;
2516     case TextAlignLast::Auto:
2517         m_value.valueID = CSSValueAuto;
2518         break;
2519     }
2520 }
2521 
2522 template&lt;&gt; inline CSSPrimitiveValue::operator TextAlignLast() const
2523 {
2524     ASSERT(isValueID());
2525 
2526     switch (m_value.valueID) {
2527     case CSSValueAuto:
2528         return TextAlignLast::Auto;
2529     case CSSValueStart:
2530         return TextAlignLast::Start;
2531     case CSSValueEnd:
2532         return TextAlignLast::End;
2533     case CSSValueLeft:
2534         return TextAlignLast::Left;
2535     case CSSValueRight:
2536         return TextAlignLast::Right;
2537     case CSSValueCenter:
2538         return TextAlignLast::Center;
2539     case CSSValueJustify:
2540         return TextAlignLast::Justify;
2541     default:
2542         break;
2543     }
2544 
2545     ASSERT_NOT_REACHED();
2546     return TextAlignLast::Auto;
2547 }
2548 
2549 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextJustify e)
2550     : CSSValue(PrimitiveClass)
2551 {
2552     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2553     switch (e) {
2554     case TextJustify::Auto:
2555         m_value.valueID = CSSValueAuto;
2556         break;
2557     case TextJustify::None:
2558         m_value.valueID = CSSValueNone;
2559         break;
2560     case TextJustify::InterWord:
2561         m_value.valueID = CSSValueInterWord;
2562         break;
2563     case TextJustify::Distribute:
2564         m_value.valueID = CSSValueDistribute;
2565         break;
2566     }
2567 }
2568 
2569 template&lt;&gt; inline CSSPrimitiveValue::operator TextJustify() const
2570 {
2571     ASSERT(isValueID());
2572 
2573     switch (m_value.valueID) {
2574     case CSSValueAuto:
2575         return TextJustify::Auto;
2576     case CSSValueNone:
2577         return TextJustify::None;
2578     case CSSValueInterWord:
2579         return TextJustify::InterWord;
2580     case CSSValueDistribute:
2581         return TextJustify::Distribute;
2582     default:
2583         break;
2584     }
2585 
2586     ASSERT_NOT_REACHED();
2587     return TextJustify::Auto;
2588 }
2589 #endif // CSS3_TEXT
2590 
2591 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;TextDecoration&gt;() const
2592 {
2593     ASSERT(isValueID());
2594 
2595     switch (m_value.valueID) {
2596     case CSSValueNone:
2597         return OptionSet&lt;TextDecoration&gt; { };
2598     case CSSValueUnderline:
2599         return TextDecoration::Underline;
2600     case CSSValueOverline:
2601         return TextDecoration::Overline;
2602     case CSSValueLineThrough:
2603         return TextDecoration::LineThrough;
2604     case CSSValueBlink:
2605         return TextDecoration::Blink;
2606 #if ENABLE(LETTERPRESS)
2607     case CSSValueWebkitLetterpress:
2608         return TextDecoration::Letterpress;
2609 #endif
2610     default:
2611         break;
2612     }
2613 
2614     ASSERT_NOT_REACHED();
2615     return OptionSet&lt;TextDecoration&gt; { };
2616 }
2617 
2618 template&lt;&gt; inline CSSPrimitiveValue::operator TextDecorationStyle() const
2619 {
2620     ASSERT(isValueID());
2621 
2622     switch (m_value.valueID) {
2623     case CSSValueSolid:
2624         return TextDecorationStyle::Solid;
2625     case CSSValueDouble:
2626         return TextDecorationStyle::Double;
2627     case CSSValueDotted:
2628         return TextDecorationStyle::Dotted;
2629     case CSSValueDashed:
2630         return TextDecorationStyle::Dashed;
2631     case CSSValueWavy:
2632         return TextDecorationStyle::Wavy;
2633     default:
2634         break;
2635     }
2636 
2637     ASSERT_NOT_REACHED();
2638     return TextDecorationStyle::Solid;
2639 }
2640 
2641 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextUnderlinePosition position)
2642     : CSSValue(PrimitiveClass)
2643 {
2644     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2645     switch (position) {
2646     case TextUnderlinePosition::Auto:
2647         m_value.valueID = CSSValueAuto;
2648         break;
2649     case TextUnderlinePosition::Under:
2650         m_value.valueID = CSSValueUnder;
2651         break;
2652     case TextUnderlinePosition::FromFont:
2653         m_value.valueID = CSSValueFromFont;
2654         break;
2655     }
2656 
2657     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2658 }
2659 
2660 template&lt;&gt; inline CSSPrimitiveValue::operator TextUnderlinePosition() const
2661 {
2662     ASSERT(isValueID());
2663 
2664     switch (m_value.valueID) {
2665     case CSSValueAuto:
2666         return TextUnderlinePosition::Auto;
2667     case CSSValueUnder:
2668         return TextUnderlinePosition::Under;
2669     case CSSValueFromFont:
2670         return TextUnderlinePosition::FromFont;
2671     default:
2672         break;
2673     }
2674 
2675     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2676     ASSERT_NOT_REACHED();
2677     return TextUnderlinePosition::Auto;
2678 }
2679 
2680 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextSecurity e)
2681     : CSSValue(PrimitiveClass)
2682 {
2683     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2684     switch (e) {
2685     case TextSecurity::None:
2686         m_value.valueID = CSSValueNone;
2687         break;
2688     case TextSecurity::Disc:
2689         m_value.valueID = CSSValueDisc;
2690         break;
2691     case TextSecurity::Circle:
2692         m_value.valueID = CSSValueCircle;
2693         break;
2694     case TextSecurity::Square:
2695         m_value.valueID = CSSValueSquare;
2696         break;
2697     }
2698 }
2699 
2700 template&lt;&gt; inline CSSPrimitiveValue::operator TextSecurity() const
2701 {
2702     ASSERT(isValueID());
2703 
2704     switch (m_value.valueID) {
2705     case CSSValueNone:
2706         return TextSecurity::None;
2707     case CSSValueDisc:
2708         return TextSecurity::Disc;
2709     case CSSValueCircle:
2710         return TextSecurity::Circle;
2711     case CSSValueSquare:
2712         return TextSecurity::Square;
2713     default:
2714         break;
2715     }
2716 
2717     ASSERT_NOT_REACHED();
2718     return TextSecurity::None;
2719 }
2720 
2721 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextTransform e)
2722     : CSSValue(PrimitiveClass)
2723 {
2724     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2725     switch (e) {
2726     case TextTransform::Capitalize:
2727         m_value.valueID = CSSValueCapitalize;
2728         break;
2729     case TextTransform::Uppercase:
2730         m_value.valueID = CSSValueUppercase;
2731         break;
2732     case TextTransform::Lowercase:
2733         m_value.valueID = CSSValueLowercase;
2734         break;
2735     case TextTransform::None:
2736         m_value.valueID = CSSValueNone;
2737         break;
2738     }
2739 }
2740 
2741 template&lt;&gt; inline CSSPrimitiveValue::operator TextTransform() const
2742 {
2743     ASSERT(isValueID());
2744 
2745     switch (m_value.valueID) {
2746     case CSSValueCapitalize:
2747         return TextTransform::Capitalize;
2748     case CSSValueUppercase:
2749         return TextTransform::Uppercase;
2750     case CSSValueLowercase:
2751         return TextTransform::Lowercase;
2752     case CSSValueNone:
2753         return TextTransform::None;
2754     default:
2755         break;
2756     }
2757 
2758     ASSERT_NOT_REACHED();
2759     return TextTransform::None;
2760 }
2761 
2762 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EUnicodeBidi e)
2763     : CSSValue(PrimitiveClass)
2764 {
2765     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2766     switch (e) {
2767     case UBNormal:
2768         m_value.valueID = CSSValueNormal;
2769         break;
2770     case Embed:
2771         m_value.valueID = CSSValueEmbed;
2772         break;
2773     case Override:
2774         m_value.valueID = CSSValueBidiOverride;
2775         break;
2776     case Isolate:
2777         m_value.valueID = CSSValueIsolate;
2778         break;
2779     case IsolateOverride:
2780         m_value.valueID = CSSValueIsolateOverride;
2781         break;
2782     case Plaintext:
2783         m_value.valueID = CSSValuePlaintext;
2784         break;
2785     }
2786 }
2787 
2788 template&lt;&gt; inline CSSPrimitiveValue::operator EUnicodeBidi() const
2789 {
2790     ASSERT(isValueID());
2791 
2792     switch (m_value.valueID) {
2793     case CSSValueNormal:
2794         return UBNormal;
2795     case CSSValueEmbed:
2796         return Embed;
2797     case CSSValueBidiOverride:
2798         return Override;
2799     case CSSValueIsolate:
2800     case CSSValueWebkitIsolate:
2801         return Isolate;
2802     case CSSValueIsolateOverride:
2803     case CSSValueWebkitIsolateOverride:
2804         return IsolateOverride;
2805     case CSSValuePlaintext:
2806     case CSSValueWebkitPlaintext:
2807         return Plaintext;
2808     default:
2809         break;
2810     }
2811 
2812     ASSERT_NOT_REACHED();
2813     return UBNormal;
2814 }
2815 
2816 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserDrag e)
2817     : CSSValue(PrimitiveClass)
2818 {
2819     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2820     switch (e) {
2821     case UserDrag::Auto:
2822         m_value.valueID = CSSValueAuto;
2823         break;
2824     case UserDrag::None:
2825         m_value.valueID = CSSValueNone;
2826         break;
2827     case UserDrag::Element:
2828         m_value.valueID = CSSValueElement;
2829         break;
2830     default:
2831         break;
2832     }
2833 }
2834 
2835 template&lt;&gt; inline CSSPrimitiveValue::operator UserDrag() const
2836 {
2837     ASSERT(isValueID());
2838 
2839     switch (m_value.valueID) {
2840     case CSSValueAuto:
2841         return UserDrag::Auto;
2842     case CSSValueNone:
2843         return UserDrag::None;
2844     case CSSValueElement:
2845         return UserDrag::Element;
2846     default:
2847         break;
2848     }
2849 
2850     ASSERT_NOT_REACHED();
2851     return UserDrag::Auto;
2852 }
2853 
2854 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserModify e)
2855     : CSSValue(PrimitiveClass)
2856 {
2857     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2858     switch (e) {
2859     case UserModify::ReadOnly:
2860         m_value.valueID = CSSValueReadOnly;
2861         break;
2862     case UserModify::ReadWrite:
2863         m_value.valueID = CSSValueReadWrite;
2864         break;
2865     case UserModify::ReadWritePlaintextOnly:
2866         m_value.valueID = CSSValueReadWritePlaintextOnly;
2867         break;
2868     }
2869 }
2870 
2871 template&lt;&gt; inline CSSPrimitiveValue::operator UserModify() const
2872 {
2873     ASSERT(isValueID());
2874 
2875     switch (m_value.valueID) {
2876     case CSSValueReadOnly:
2877         return UserModify::ReadOnly;
2878     case CSSValueReadWrite:
2879         return UserModify::ReadWrite;
2880     case CSSValueReadWritePlaintextOnly:
2881         return UserModify::ReadWritePlaintextOnly;
2882     default:
2883         break;
2884     }
2885 
2886     ASSERT_NOT_REACHED();
2887     return UserModify::ReadOnly;
2888 }
2889 
2890 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserSelect e)
2891     : CSSValue(PrimitiveClass)
2892 {
2893     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2894     switch (e) {
2895     case UserSelect::None:
2896         m_value.valueID = CSSValueNone;
2897         break;
2898     case UserSelect::Text:
2899         m_value.valueID = CSSValueText;
2900         break;
2901     case UserSelect::All:
2902         m_value.valueID = CSSValueAll;
2903         break;
2904     }
2905 }
2906 
2907 template&lt;&gt; inline CSSPrimitiveValue::operator UserSelect() const
2908 {
2909     ASSERT(isValueID());
2910 
2911     switch (m_value.valueID) {
2912     case CSSValueAuto:
2913         return UserSelect::Text;
2914     case CSSValueNone:
2915         return UserSelect::None;
2916     case CSSValueText:
2917         return UserSelect::Text;
2918     case CSSValueAll:
2919         return UserSelect::All;
2920     default:
2921         break;
2922     }
2923 
2924     ASSERT_NOT_REACHED();
2925     return UserSelect::Text;
2926 }
2927 
2928 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VerticalAlign a)
2929     : CSSValue(PrimitiveClass)
2930 {
2931     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
2932     switch (a) {
2933     case VerticalAlign::Top:
2934         m_value.valueID = CSSValueTop;
2935         break;
2936     case VerticalAlign::Bottom:
2937         m_value.valueID = CSSValueBottom;
2938         break;
2939     case VerticalAlign::Middle:
2940         m_value.valueID = CSSValueMiddle;
2941         break;
2942     case VerticalAlign::Baseline:
2943         m_value.valueID = CSSValueBaseline;
2944         break;
2945     case VerticalAlign::TextBottom:
2946         m_value.valueID = CSSValueTextBottom;
2947         break;
2948     case VerticalAlign::TextTop:
2949         m_value.valueID = CSSValueTextTop;
2950         break;
2951     case VerticalAlign::Sub:
2952         m_value.valueID = CSSValueSub;
2953         break;
2954     case VerticalAlign::Super:
2955         m_value.valueID = CSSValueSuper;
2956         break;
2957     case VerticalAlign::BaselineMiddle:
2958         m_value.valueID = CSSValueWebkitBaselineMiddle;
2959         break;
2960     case VerticalAlign::Length:
2961         m_value.valueID = CSSValueInvalid;
2962     }
2963 }
2964 
2965 template&lt;&gt; inline CSSPrimitiveValue::operator VerticalAlign() const
2966 {
2967     ASSERT(isValueID());
2968 
2969     switch (m_value.valueID) {
2970     case CSSValueTop:
2971         return VerticalAlign::Top;
2972     case CSSValueBottom:
2973         return VerticalAlign::Bottom;
2974     case CSSValueMiddle:
2975         return VerticalAlign::Middle;
2976     case CSSValueBaseline:
2977         return VerticalAlign::Baseline;
2978     case CSSValueTextBottom:
2979         return VerticalAlign::TextBottom;
2980     case CSSValueTextTop:
2981         return VerticalAlign::TextTop;
2982     case CSSValueSub:
2983         return VerticalAlign::Sub;
2984     case CSSValueSuper:
2985         return VerticalAlign::Super;
2986     case CSSValueWebkitBaselineMiddle:
2987         return VerticalAlign::BaselineMiddle;
2988     default:
2989         break;
2990     }
2991 
2992     ASSERT_NOT_REACHED();
2993     return VerticalAlign::Top;
2994 }
2995 
2996 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Visibility e)
2997     : CSSValue(PrimitiveClass)
2998 {
2999     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3000     switch (e) {
3001     case Visibility::Visible:
3002         m_value.valueID = CSSValueVisible;
3003         break;
3004     case Visibility::Hidden:
3005         m_value.valueID = CSSValueHidden;
3006         break;
3007     case Visibility::Collapse:
3008         m_value.valueID = CSSValueCollapse;
3009         break;
3010     }
3011 }
3012 
3013 template&lt;&gt; inline CSSPrimitiveValue::operator Visibility() const
3014 {
3015     ASSERT(isValueID());
3016 
3017     switch (m_value.valueID) {
3018     case CSSValueHidden:
3019         return Visibility::Hidden;
3020     case CSSValueVisible:
3021         return Visibility::Visible;
3022     case CSSValueCollapse:
3023         return Visibility::Collapse;
3024     default:
3025         break;
3026     }
3027 
3028     ASSERT_NOT_REACHED();
3029     return Visibility::Visible;
3030 }
3031 
3032 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WhiteSpace e)
3033     : CSSValue(PrimitiveClass)
3034 {
3035     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3036     switch (e) {
3037     case WhiteSpace::Normal:
3038         m_value.valueID = CSSValueNormal;
3039         break;
3040     case WhiteSpace::Pre:
3041         m_value.valueID = CSSValuePre;
3042         break;
3043     case WhiteSpace::PreWrap:
3044         m_value.valueID = CSSValuePreWrap;
3045         break;
3046     case WhiteSpace::PreLine:
3047         m_value.valueID = CSSValuePreLine;
3048         break;
3049     case WhiteSpace::NoWrap:
3050         m_value.valueID = CSSValueNowrap;
3051         break;
3052     case WhiteSpace::KHTMLNoWrap:
3053         m_value.valueID = CSSValueWebkitNowrap;
3054         break;
3055     case WhiteSpace::BreakSpaces:
3056         m_value.valueID = CSSValueBreakSpaces;
3057         break;
3058     }
3059 }
3060 
3061 template&lt;&gt; inline CSSPrimitiveValue::operator WhiteSpace() const
3062 {
3063     ASSERT(isValueID());
3064 
3065     switch (m_value.valueID) {
3066     case CSSValueWebkitNowrap:
3067         return WhiteSpace::KHTMLNoWrap;
3068     case CSSValueNowrap:
3069         return WhiteSpace::NoWrap;
3070     case CSSValuePre:
3071         return WhiteSpace::Pre;
3072     case CSSValuePreWrap:
3073         return WhiteSpace::PreWrap;
3074     case CSSValuePreLine:
3075         return WhiteSpace::PreLine;
3076     case CSSValueNormal:
3077         return WhiteSpace::Normal;
3078     case CSSValueBreakSpaces:
3079         return WhiteSpace::BreakSpaces;
3080     default:
3081         break;
3082     }
3083 
3084     ASSERT_NOT_REACHED();
3085     return WhiteSpace::Normal;
3086 }
3087 
3088 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WordBreak e)
3089     : CSSValue(PrimitiveClass)
3090 {
3091     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3092     switch (e) {
3093     case WordBreak::Normal:
3094         m_value.valueID = CSSValueNormal;
3095         break;
3096     case WordBreak::BreakAll:
3097         m_value.valueID = CSSValueBreakAll;
3098         break;
3099     case WordBreak::KeepAll:
3100         m_value.valueID = CSSValueKeepAll;
3101         break;
3102     case WordBreak::BreakWord:
3103         m_value.valueID = CSSValueBreakWord;
3104         break;
3105     }
3106 }
3107 
3108 template&lt;&gt; inline CSSPrimitiveValue::operator WordBreak() const
3109 {
3110     ASSERT(isValueID());
3111 
3112     switch (m_value.valueID) {
3113     case CSSValueBreakAll:
3114         return WordBreak::BreakAll;
3115     case CSSValueKeepAll:
3116         return WordBreak::KeepAll;
3117     case CSSValueBreakWord:
3118         return WordBreak::BreakWord;
3119     case CSSValueNormal:
3120         return WordBreak::Normal;
3121     default:
3122         break;
3123     }
3124 
3125     ASSERT_NOT_REACHED();
3126     return WordBreak::Normal;
3127 }
3128 
3129 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowWrap e)
3130     : CSSValue(PrimitiveClass)
3131 {
3132     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3133     switch (e) {
3134     case OverflowWrap::Normal:
3135         m_value.valueID = CSSValueNormal;
3136         break;
3137     case OverflowWrap::Break:
3138         m_value.valueID = CSSValueBreakWord;
3139         break;
3140     }
3141 }
3142 
3143 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowWrap() const
3144 {
3145     ASSERT(isValueID());
3146 
3147     switch (m_value.valueID) {
3148     case CSSValueBreakWord:
3149         return OverflowWrap::Break;
3150     case CSSValueNormal:
3151         return OverflowWrap::Normal;
3152     default:
3153         break;
3154     }
3155 
3156     ASSERT_NOT_REACHED();
3157     return OverflowWrap::Normal;
3158 }
3159 
3160 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextDirection e)
3161     : CSSValue(PrimitiveClass)
3162 {
3163     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3164     switch (e) {
3165     case TextDirection::LTR:
3166         m_value.valueID = CSSValueLtr;
3167         break;
3168     case TextDirection::RTL:
3169         m_value.valueID = CSSValueRtl;
3170         break;
3171     }
3172 }
3173 
3174 template&lt;&gt; inline CSSPrimitiveValue::operator TextDirection() const
3175 {
3176     ASSERT(isValueID());
3177 
3178     switch (m_value.valueID) {
3179     case CSSValueLtr:
3180         return TextDirection::LTR;
3181     case CSSValueRtl:
3182         return TextDirection::RTL;
3183     default:
3184         break;
3185     }
3186 
3187     ASSERT_NOT_REACHED();
3188     return TextDirection::LTR;
3189 }
3190 
3191 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WritingMode e)
3192     : CSSValue(PrimitiveClass)
3193 {
3194     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3195     switch (e) {
3196     case TopToBottomWritingMode:
3197         m_value.valueID = CSSValueHorizontalTb;
3198         break;
3199     case RightToLeftWritingMode:
3200         m_value.valueID = CSSValueVerticalRl;
3201         break;
3202     case LeftToRightWritingMode:
3203         m_value.valueID = CSSValueVerticalLr;
3204         break;
3205     case BottomToTopWritingMode:
3206         m_value.valueID = CSSValueHorizontalBt;
3207         break;
3208     }
3209 }
3210 
3211 template&lt;&gt; inline CSSPrimitiveValue::operator WritingMode() const
3212 {
3213     ASSERT(isValueID());
3214 
3215     switch (m_value.valueID) {
3216     case CSSValueHorizontalTb:
3217     case CSSValueLr:
3218     case CSSValueLrTb:
3219     case CSSValueRl:
3220     case CSSValueRlTb:
3221         return TopToBottomWritingMode;
3222     case CSSValueVerticalRl:
3223     case CSSValueTb:
3224     case CSSValueTbRl:
3225         return RightToLeftWritingMode;
3226     case CSSValueVerticalLr:
3227         return LeftToRightWritingMode;
3228     case CSSValueHorizontalBt:
3229         return BottomToTopWritingMode;
3230     default:
3231         break;
3232     }
3233 
3234     ASSERT_NOT_REACHED();
3235     return TopToBottomWritingMode;
3236 }
3237 
3238 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextCombine e)
3239     : CSSValue(PrimitiveClass)
3240 {
3241     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3242     switch (e) {
3243     case TextCombine::None:
3244         m_value.valueID = CSSValueNone;
3245         break;
3246     case TextCombine::Horizontal:
3247         m_value.valueID = CSSValueHorizontal;
3248         break;
3249     }
3250 }
3251 
3252 template&lt;&gt; inline CSSPrimitiveValue::operator TextCombine() const
3253 {
3254     ASSERT(isValueID());
3255 
3256     switch (m_value.valueID) {
3257     case CSSValueNone:
3258         return TextCombine::None;
3259     case CSSValueHorizontal:
3260         return TextCombine::Horizontal;
3261     default:
3262         break;
3263     }
3264 
3265     ASSERT_NOT_REACHED();
3266     return TextCombine::None;
3267 }
3268 
3269 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(RubyPosition position)
3270     : CSSValue(PrimitiveClass)
3271 {
3272     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3273     switch (position) {
3274     case RubyPosition::Before:
3275         m_value.valueID = CSSValueBefore;
3276         break;
3277     case RubyPosition::After:
3278         m_value.valueID = CSSValueAfter;
3279         break;
3280     case RubyPosition::InterCharacter:
3281         m_value.valueID = CSSValueInterCharacter;
3282         break;
3283     }
3284 }
3285 
3286 template&lt;&gt; inline CSSPrimitiveValue::operator RubyPosition() const
3287 {
3288     ASSERT(isValueID());
3289 
3290     switch (m_value.valueID) {
3291     case CSSValueBefore:
3292         return RubyPosition::Before;
3293     case CSSValueAfter:
3294         return RubyPosition::After;
3295     case CSSValueInterCharacter:
3296         return RubyPosition::InterCharacter;
3297     default:
3298         break;
3299     }
3300 
3301     ASSERT_NOT_REACHED();
3302     return RubyPosition::Before;
3303 }
3304 
3305 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOverflow overflow)
3306     : CSSValue(PrimitiveClass)
3307 {
3308     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3309     switch (overflow) {
3310     case TextOverflow::Clip:
3311         m_value.valueID = CSSValueClip;
3312         break;
3313     case TextOverflow::Ellipsis:
3314         m_value.valueID = CSSValueEllipsis;
3315         break;
3316     }
3317 }
3318 
3319 template&lt;&gt; inline CSSPrimitiveValue::operator TextOverflow() const
3320 {
3321     ASSERT(isValueID());
3322 
3323     switch (m_value.valueID) {
3324     case CSSValueClip:
3325         return TextOverflow::Clip;
3326     case CSSValueEllipsis:
3327         return TextOverflow::Ellipsis;
3328     default:
3329         break;
3330     }
3331 
3332     ASSERT_NOT_REACHED();
3333     return TextOverflow::Clip;
3334 }
3335 
3336 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisFill fill)
3337     : CSSValue(PrimitiveClass)
3338 {
3339     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3340     switch (fill) {
3341     case TextEmphasisFill::Filled:
3342         m_value.valueID = CSSValueFilled;
3343         break;
3344     case TextEmphasisFill::Open:
3345         m_value.valueID = CSSValueOpen;
3346         break;
3347     }
3348 }
3349 
3350 template&lt;&gt; inline CSSPrimitiveValue::operator TextEmphasisFill() const
3351 {
3352     ASSERT(isValueID());
3353 
3354     switch (m_value.valueID) {
3355     case CSSValueFilled:
3356         return TextEmphasisFill::Filled;
3357     case CSSValueOpen:
3358         return TextEmphasisFill::Open;
3359     default:
3360         break;
3361     }
3362 
3363     ASSERT_NOT_REACHED();
3364     return TextEmphasisFill::Filled;
3365 }
3366 
3367 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisMark mark)
3368     : CSSValue(PrimitiveClass)
3369 {
3370     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3371     switch (mark) {
3372     case TextEmphasisMark::Dot:
3373         m_value.valueID = CSSValueDot;
3374         break;
3375     case TextEmphasisMark::Circle:
3376         m_value.valueID = CSSValueCircle;
3377         break;
3378     case TextEmphasisMark::DoubleCircle:
3379         m_value.valueID = CSSValueDoubleCircle;
3380         break;
3381     case TextEmphasisMark::Triangle:
3382         m_value.valueID = CSSValueTriangle;
3383         break;
3384     case TextEmphasisMark::Sesame:
3385         m_value.valueID = CSSValueSesame;
3386         break;
3387     case TextEmphasisMark::None:
3388     case TextEmphasisMark::Auto:
3389     case TextEmphasisMark::Custom:
3390         ASSERT_NOT_REACHED();
3391         m_value.valueID = CSSValueNone;
3392         break;
3393     }
3394 }
3395 
3396 template&lt;&gt; inline CSSPrimitiveValue::operator TextEmphasisMark() const
3397 {
3398     ASSERT(isValueID());
3399 
3400     switch (m_value.valueID) {
3401     case CSSValueNone:
3402         return TextEmphasisMark::None;
3403     case CSSValueDot:
3404         return TextEmphasisMark::Dot;
3405     case CSSValueCircle:
3406         return TextEmphasisMark::Circle;
3407     case CSSValueDoubleCircle:
3408         return TextEmphasisMark::DoubleCircle;
3409     case CSSValueTriangle:
3410         return TextEmphasisMark::Triangle;
3411     case CSSValueSesame:
3412         return TextEmphasisMark::Sesame;
3413     default:
3414         break;
3415     }
3416 
3417     ASSERT_NOT_REACHED();
3418     return TextEmphasisMark::None;
3419 }
3420 
3421 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOrientation e)
3422     : CSSValue(PrimitiveClass)
3423 {
3424     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3425     switch (e) {
3426     case TextOrientation::Sideways:
3427         m_value.valueID = CSSValueSideways;
3428         break;
3429     case TextOrientation::Mixed:
3430         m_value.valueID = CSSValueMixed;
3431         break;
3432     case TextOrientation::Upright:
3433         m_value.valueID = CSSValueUpright;
3434         break;
3435     }
3436 }
3437 
3438 template&lt;&gt; inline CSSPrimitiveValue::operator TextOrientation() const
3439 {
3440     ASSERT(isValueID());
3441 
3442     switch (m_value.valueID) {
3443     case CSSValueSideways:
3444         return TextOrientation::Sideways;
3445     case CSSValueSidewaysRight:
3446         return TextOrientation::Sideways;
3447     case CSSValueVerticalRight:
3448         return TextOrientation::Mixed;
3449     case CSSValueMixed:
3450         return TextOrientation::Mixed;
3451     case CSSValueUpright:
3452         return TextOrientation::Upright;
3453     default:
3454         break;
3455     }
3456 
3457     ASSERT_NOT_REACHED();
3458     return TextOrientation::Mixed;
3459 }
3460 
3461 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PointerEvents e)
3462     : CSSValue(PrimitiveClass)
3463 {
3464     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3465     switch (e) {
3466     case PointerEvents::None:
3467         m_value.valueID = CSSValueNone;
3468         break;
3469     case PointerEvents::Stroke:
3470         m_value.valueID = CSSValueStroke;
3471         break;
3472     case PointerEvents::Fill:
3473         m_value.valueID = CSSValueFill;
3474         break;
3475     case PointerEvents::Painted:
3476         m_value.valueID = CSSValuePainted;
3477         break;
3478     case PointerEvents::Visible:
3479         m_value.valueID = CSSValueVisible;
3480         break;
3481     case PointerEvents::VisibleStroke:
3482         m_value.valueID = CSSValueVisibleStroke;
3483         break;
3484     case PointerEvents::VisibleFill:
3485         m_value.valueID = CSSValueVisibleFill;
3486         break;
3487     case PointerEvents::VisiblePainted:
3488         m_value.valueID = CSSValueVisiblePainted;
3489         break;
3490     case PointerEvents::BoundingBox:
3491         m_value.valueID = CSSValueBoundingBox;
3492         break;
3493     case PointerEvents::Auto:
3494         m_value.valueID = CSSValueAuto;
3495         break;
3496     case PointerEvents::All:
3497         m_value.valueID = CSSValueAll;
3498         break;
3499     }
3500 }
3501 
3502 template&lt;&gt; inline CSSPrimitiveValue::operator PointerEvents() const
3503 {
3504     ASSERT(isValueID());
3505 
3506     switch (m_value.valueID) {
3507     case CSSValueAll:
3508         return PointerEvents::All;
3509     case CSSValueAuto:
3510         return PointerEvents::Auto;
3511     case CSSValueNone:
3512         return PointerEvents::None;
3513     case CSSValueVisiblePainted:
3514         return PointerEvents::VisiblePainted;
3515     case CSSValueVisibleFill:
3516         return PointerEvents::VisibleFill;
3517     case CSSValueVisibleStroke:
3518         return PointerEvents::VisibleStroke;
3519     case CSSValueVisible:
3520         return PointerEvents::Visible;
3521     case CSSValuePainted:
3522         return PointerEvents::Painted;
3523     case CSSValueFill:
3524         return PointerEvents::Fill;
3525     case CSSValueStroke:
3526         return PointerEvents::Stroke;
3527     case CSSValueBoundingBox:
3528         return PointerEvents::BoundingBox;
3529     default:
3530         break;
3531     }
3532 
3533     ASSERT_NOT_REACHED();
3534     return PointerEvents::All;
3535 }
3536 
3537 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Kerning kerning)
3538     : CSSValue(PrimitiveClass)
3539 {
3540     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3541     switch (kerning) {
3542     case Kerning::Auto:
3543         m_value.valueID = CSSValueAuto;
3544         return;
3545     case Kerning::Normal:
3546         m_value.valueID = CSSValueNormal;
3547         return;
3548     case Kerning::NoShift:
3549         m_value.valueID = CSSValueNone;
3550         return;
3551     }
3552 
3553     ASSERT_NOT_REACHED();
3554     m_value.valueID = CSSValueAuto;
3555 }
3556 
3557 template&lt;&gt; inline CSSPrimitiveValue::operator Kerning() const
3558 {
3559     ASSERT(isValueID());
3560 
3561     switch (m_value.valueID) {
3562     case CSSValueAuto:
3563         return Kerning::Auto;
3564     case CSSValueNormal:
3565         return Kerning::Normal;
3566     case CSSValueNone:
3567         return Kerning::NoShift;
3568     default:
3569         break;
3570     }
3571 
3572     ASSERT_NOT_REACHED();
3573     return Kerning::Auto;
3574 }
3575 
3576 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ObjectFit fit)
3577     : CSSValue(PrimitiveClass)
3578 {
3579     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3580     switch (fit) {
3581     case ObjectFit::Fill:
3582         m_value.valueID = CSSValueFill;
3583         break;
3584     case ObjectFit::Contain:
3585         m_value.valueID = CSSValueContain;
3586         break;
3587     case ObjectFit::Cover:
3588         m_value.valueID = CSSValueCover;
3589         break;
3590     case ObjectFit::None:
3591         m_value.valueID = CSSValueNone;
3592         break;
3593     case ObjectFit::ScaleDown:
3594         m_value.valueID = CSSValueScaleDown;
3595         break;
3596     }
3597 }
3598 
3599 template&lt;&gt; inline CSSPrimitiveValue::operator ObjectFit() const
3600 {
3601     ASSERT(isValueID());
3602 
3603     switch (m_value.valueID) {
3604     case CSSValueFill:
3605         return ObjectFit::Fill;
3606     case CSSValueContain:
3607         return ObjectFit::Contain;
3608     case CSSValueCover:
3609         return ObjectFit::Cover;
3610     case CSSValueNone:
3611         return ObjectFit::None;
3612     case CSSValueScaleDown:
3613         return ObjectFit::ScaleDown;
3614     default:
3615         ASSERT_NOT_REACHED();
3616         return ObjectFit::Fill;
3617     }
3618 }
3619 
3620 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmoothingMode smoothing)
3621     : CSSValue(PrimitiveClass)
3622 {
3623     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3624     switch (smoothing) {
3625     case FontSmoothingMode::AutoSmoothing:
3626         m_value.valueID = CSSValueAuto;
3627         return;
3628     case FontSmoothingMode::NoSmoothing:
3629         m_value.valueID = CSSValueNone;
3630         return;
3631     case FontSmoothingMode::Antialiased:
3632         m_value.valueID = CSSValueAntialiased;
3633         return;
3634     case FontSmoothingMode::SubpixelAntialiased:
3635         m_value.valueID = CSSValueSubpixelAntialiased;
3636         return;
3637     }
3638 
3639     ASSERT_NOT_REACHED();
3640     m_value.valueID = CSSValueAuto;
3641 }
3642 
3643 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmoothingMode() const
3644 {
3645     ASSERT(isValueID());
3646 
3647     switch (m_value.valueID) {
3648     case CSSValueAuto:
3649         return FontSmoothingMode::AutoSmoothing;
3650     case CSSValueNone:
3651         return FontSmoothingMode::NoSmoothing;
3652     case CSSValueAntialiased:
3653         return FontSmoothingMode::Antialiased;
3654     case CSSValueSubpixelAntialiased:
3655         return FontSmoothingMode::SubpixelAntialiased;
3656     default:
3657         break;
3658     }
3659 
3660     ASSERT_NOT_REACHED();
3661     return FontSmoothingMode::AutoSmoothing;
3662 }
3663 
3664 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmallCaps smallCaps)
3665     : CSSValue(PrimitiveClass)
3666 {
3667     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3668     switch (smallCaps) {
3669     case FontSmallCaps::Off:
3670         m_value.valueID = CSSValueNormal;
3671         return;
3672     case FontSmallCaps::On:
3673         m_value.valueID = CSSValueSmallCaps;
3674         return;
3675     }
3676 
3677     ASSERT_NOT_REACHED();
3678     m_value.valueID = CSSValueNormal;
3679 }
3680 
3681 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmallCaps() const
3682 {
3683     ASSERT(isValueID());
3684 
3685     switch (m_value.valueID) {
3686     case CSSValueSmallCaps:
3687         return FontSmallCaps::On;
3688     case CSSValueNormal:
3689         return FontSmallCaps::Off;
3690     default:
3691         break;
3692     }
3693     ASSERT_NOT_REACHED();
3694     return FontSmallCaps::Off;
3695 }
3696 
3697 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextRenderingMode e)
3698     : CSSValue(PrimitiveClass)
3699 {
3700     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3701     switch (e) {
3702     case TextRenderingMode::AutoTextRendering:
3703         m_value.valueID = CSSValueAuto;
3704         break;
3705     case TextRenderingMode::OptimizeSpeed:
3706         m_value.valueID = CSSValueOptimizeSpeed;
3707         break;
3708     case TextRenderingMode::OptimizeLegibility:
3709         m_value.valueID = CSSValueOptimizeLegibility;
3710         break;
3711     case TextRenderingMode::GeometricPrecision:
3712         m_value.valueID = CSSValueGeometricPrecision;
3713         break;
3714     }
3715 }
3716 
3717 template&lt;&gt; inline CSSPrimitiveValue::operator TextRenderingMode() const
3718 {
3719     ASSERT(isValueID());
3720 
3721     switch (m_value.valueID) {
3722     case CSSValueAuto:
3723         return TextRenderingMode::AutoTextRendering;
3724     case CSSValueOptimizeSpeed:
3725         return TextRenderingMode::OptimizeSpeed;
3726     case CSSValueOptimizeLegibility:
3727         return TextRenderingMode::OptimizeLegibility;
3728     case CSSValueGeometricPrecision:
3729         return TextRenderingMode::GeometricPrecision;
3730     default:
3731         break;
3732     }
3733 
3734     ASSERT_NOT_REACHED();
3735     return TextRenderingMode::AutoTextRendering;
3736 }
3737 
3738 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Hyphens hyphens)
3739     : CSSValue(PrimitiveClass)
3740 {
3741     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3742     switch (hyphens) {
3743     case Hyphens::None:
3744         m_value.valueID = CSSValueNone;
3745         break;
3746     case Hyphens::Manual:
3747         m_value.valueID = CSSValueManual;
3748         break;
3749     case Hyphens::Auto:
3750         m_value.valueID = CSSValueAuto;
3751         break;
3752     }
3753 }
3754 
3755 template&lt;&gt; inline CSSPrimitiveValue::operator Hyphens() const
3756 {
3757     ASSERT(isValueID());
3758 
3759     switch (m_value.valueID) {
3760     case CSSValueNone:
3761         return Hyphens::None;
3762     case CSSValueManual:
3763         return Hyphens::Manual;
3764     case CSSValueAuto:
3765         return Hyphens::Auto;
3766     default:
3767         break;
3768     }
3769 
3770     ASSERT_NOT_REACHED();
3771     return Hyphens::Auto;
3772 }
3773 
3774 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineSnap gridSnap)
3775     : CSSValue(PrimitiveClass)
3776 {
3777     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3778     switch (gridSnap) {
3779     case LineSnap::None:
3780         m_value.valueID = CSSValueNone;
3781         break;
3782     case LineSnap::Baseline:
3783         m_value.valueID = CSSValueBaseline;
3784         break;
3785     case LineSnap::Contain:
3786         m_value.valueID = CSSValueContain;
3787         break;
3788     }
3789 }
3790 
3791 template&lt;&gt; inline CSSPrimitiveValue::operator LineSnap() const
3792 {
3793     ASSERT(isValueID());
3794 
3795     switch (m_value.valueID) {
3796     case CSSValueNone:
3797         return LineSnap::None;
3798     case CSSValueBaseline:
3799         return LineSnap::Baseline;
3800     case CSSValueContain:
3801         return LineSnap::Contain;
3802     default:
3803         break;
3804     }
3805 
3806     ASSERT_NOT_REACHED();
3807     return LineSnap::None;
3808 }
3809 
3810 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineAlign lineAlign)
3811     : CSSValue(PrimitiveClass)
3812 {
3813     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3814     switch (lineAlign) {
3815     case LineAlign::None:
3816         m_value.valueID = CSSValueNone;
3817         break;
3818     case LineAlign::Edges:
3819         m_value.valueID = CSSValueEdges;
3820         break;
3821     }
3822 }
3823 
3824 template&lt;&gt; inline CSSPrimitiveValue::operator LineAlign() const
3825 {
3826     ASSERT(isValueID());
3827 
3828     switch (m_value.valueID) {
3829     case CSSValueNone:
3830         return LineAlign::None;
3831     case CSSValueEdges:
3832         return LineAlign::Edges;
3833     default:
3834         break;
3835     }
3836 
3837     ASSERT_NOT_REACHED();
3838     return LineAlign::None;
3839 }
3840 
3841 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(SpeakAs e)
3842     : CSSValue(PrimitiveClass)
3843 {
3844     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3845     switch (e) {
3846     case SpeakAs::Normal:
3847         m_value.valueID = CSSValueNormal;
3848         break;
3849     case SpeakAs::SpellOut:
3850         m_value.valueID = CSSValueSpellOut;
3851         break;
3852     case SpeakAs::Digits:
3853         m_value.valueID = CSSValueDigits;
3854         break;
3855     case SpeakAs::LiteralPunctuation:
3856         m_value.valueID = CSSValueLiteralPunctuation;
3857         break;
3858     case SpeakAs::NoPunctuation:
3859         m_value.valueID = CSSValueNoPunctuation;
3860         break;
3861     }
3862 }
3863 
3864 template&lt;&gt; inline CSSPrimitiveValue::operator Order() const
3865 {
3866     ASSERT(isValueID());
3867 
3868     switch (m_value.valueID) {
3869     case CSSValueLogical:
3870         return Order::Logical;
3871     case CSSValueVisual:
3872         return Order::Visual;
3873     default:
3874         break;
3875     }
3876 
3877     ASSERT_NOT_REACHED();
3878     return Order::Logical;
3879 }
3880 
3881 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Order e)
3882     : CSSValue(PrimitiveClass)
3883 {
3884     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3885     switch (e) {
3886     case Order::Logical:
3887         m_value.valueID = CSSValueLogical;
3888         break;
3889     case Order::Visual:
3890         m_value.valueID = CSSValueVisual;
3891         break;
3892     }
3893 }
3894 
3895 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;SpeakAs&gt;() const
3896 {
3897     ASSERT(isValueID());
3898 
3899     switch (m_value.valueID) {
3900     case CSSValueNormal:
3901         return OptionSet&lt;SpeakAs&gt; { };
3902     case CSSValueSpellOut:
3903         return SpeakAs::SpellOut;
3904     case CSSValueDigits:
3905         return SpeakAs::Digits;
3906     case CSSValueLiteralPunctuation:
3907         return SpeakAs::LiteralPunctuation;
3908     case CSSValueNoPunctuation:
3909         return SpeakAs::NoPunctuation;
3910     default:
3911         break;
3912     }
3913 
3914     ASSERT_NOT_REACHED();
3915     return OptionSet&lt;SpeakAs&gt; { };
3916 }
3917 
3918 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BlendMode blendMode)
3919     : CSSValue(PrimitiveClass)
3920 {
3921     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
3922     switch (blendMode) {
3923     case BlendMode::Normal:
3924         m_value.valueID = CSSValueNormal;
3925         break;
3926     case BlendMode::Multiply:
3927         m_value.valueID = CSSValueMultiply;
3928         break;
3929     case BlendMode::Screen:
3930         m_value.valueID = CSSValueScreen;
3931         break;
3932     case BlendMode::Overlay:
3933         m_value.valueID = CSSValueOverlay;
3934         break;
3935     case BlendMode::Darken:
3936         m_value.valueID = CSSValueDarken;
3937         break;
3938     case BlendMode::Lighten:
3939         m_value.valueID = CSSValueLighten;
3940         break;
3941     case BlendMode::ColorDodge:
3942         m_value.valueID = CSSValueColorDodge;
3943         break;
3944     case BlendMode::ColorBurn:
3945         m_value.valueID = CSSValueColorBurn;
3946         break;
3947     case BlendMode::HardLight:
3948         m_value.valueID = CSSValueHardLight;
3949         break;
3950     case BlendMode::SoftLight:
3951         m_value.valueID = CSSValueSoftLight;
3952         break;
3953     case BlendMode::Difference:
3954         m_value.valueID = CSSValueDifference;
3955         break;
3956     case BlendMode::Exclusion:
3957         m_value.valueID = CSSValueExclusion;
3958         break;
3959     case BlendMode::Hue:
3960         m_value.valueID = CSSValueHue;
3961         break;
3962     case BlendMode::Saturation:
3963         m_value.valueID = CSSValueSaturation;
3964         break;
3965     case BlendMode::Color:
3966         m_value.valueID = CSSValueColor;
3967         break;
3968     case BlendMode::Luminosity:
3969         m_value.valueID = CSSValueLuminosity;
3970         break;
3971     case BlendMode::PlusDarker:
3972         m_value.valueID = CSSValuePlusDarker;
3973         break;
3974     case BlendMode::PlusLighter:
3975         m_value.valueID = CSSValuePlusLighter;
3976         break;
3977     }
3978 }
3979 
3980 template&lt;&gt; inline CSSPrimitiveValue::operator BlendMode() const
3981 {
3982     ASSERT(isValueID());
3983 
3984     switch (m_value.valueID) {
3985     case CSSValueNormal:
3986         return BlendMode::Normal;
3987     case CSSValueMultiply:
3988         return BlendMode::Multiply;
3989     case CSSValueScreen:
3990         return BlendMode::Screen;
3991     case CSSValueOverlay:
3992         return BlendMode::Overlay;
3993     case CSSValueDarken:
3994         return BlendMode::Darken;
3995     case CSSValueLighten:
3996         return BlendMode::Lighten;
3997     case CSSValueColorDodge:
3998         return BlendMode::ColorDodge;
3999     case CSSValueColorBurn:
4000         return BlendMode::ColorBurn;
4001     case CSSValueHardLight:
4002         return BlendMode::HardLight;
4003     case CSSValueSoftLight:
4004         return BlendMode::SoftLight;
4005     case CSSValueDifference:
4006         return BlendMode::Difference;
4007     case CSSValueExclusion:
4008         return BlendMode::Exclusion;
4009     case CSSValueHue:
4010         return BlendMode::Hue;
4011     case CSSValueSaturation:
4012         return BlendMode::Saturation;
4013     case CSSValueColor:
4014         return BlendMode::Color;
4015     case CSSValueLuminosity:
4016         return BlendMode::Luminosity;
4017     case CSSValuePlusDarker:
4018         return BlendMode::PlusDarker;
4019     case CSSValuePlusLighter:
4020         return BlendMode::PlusLighter;
4021     default:
4022         break;
4023     }
4024 
4025     ASSERT_NOT_REACHED();
4026     return BlendMode::Normal;
4027 }
4028 
4029 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Isolation isolation)
4030     : CSSValue(PrimitiveClass)
4031 {
4032     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4033     switch (isolation) {
4034     case Isolation::Auto:
4035         m_value.valueID = CSSValueAuto;
4036         break;
4037     case Isolation::Isolate:
4038         m_value.valueID = CSSValueIsolate;
4039         break;
4040     default:
4041         ASSERT_NOT_REACHED();
4042     }
4043 }
4044 
4045 template&lt;&gt; inline CSSPrimitiveValue::operator Isolation() const
4046 {
4047     ASSERT(isValueID());
4048     switch (m_value.valueID) {
4049     case CSSValueAuto:
4050         return Isolation::Auto;
4051     case CSSValueIsolate:
4052         return Isolation::Isolate;
4053     default:
4054         break;
4055     }
4056 
4057     ASSERT_NOT_REACHED();
4058     return Isolation::Auto;
4059 }
4060 
4061 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineCap e)
4062     : CSSValue(PrimitiveClass)
4063 {
4064     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4065     switch (e) {
4066     case ButtCap:
4067         m_value.valueID = CSSValueButt;
4068         break;
4069     case RoundCap:
4070         m_value.valueID = CSSValueRound;
4071         break;
4072     case SquareCap:
4073         m_value.valueID = CSSValueSquare;
4074         break;
4075     }
4076 }
4077 
4078 template&lt;&gt; inline CSSPrimitiveValue::operator LineCap() const
4079 {
4080     ASSERT(isValueID());
4081 
4082     switch (m_value.valueID) {
4083     case CSSValueButt:
4084         return ButtCap;
4085     case CSSValueRound:
4086         return RoundCap;
4087     case CSSValueSquare:
4088         return SquareCap;
4089     default:
4090         break;
4091     }
4092 
4093     ASSERT_NOT_REACHED();
4094     return ButtCap;
4095 }
4096 
4097 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineJoin e)
4098     : CSSValue(PrimitiveClass)
4099 {
4100     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4101     switch (e) {
4102     case MiterJoin:
4103         m_value.valueID = CSSValueMiter;
4104         break;
4105     case RoundJoin:
4106         m_value.valueID = CSSValueRound;
4107         break;
4108     case BevelJoin:
4109         m_value.valueID = CSSValueBevel;
4110         break;
4111     }
4112 }
4113 
4114 template&lt;&gt; inline CSSPrimitiveValue::operator LineJoin() const
4115 {
4116     ASSERT(isValueID());
4117 
4118     switch (m_value.valueID) {
4119     case CSSValueMiter:
4120         return MiterJoin;
4121     case CSSValueRound:
4122         return RoundJoin;
4123     case CSSValueBevel:
4124         return BevelJoin;
4125     default:
4126         break;
4127     }
4128 
4129     ASSERT_NOT_REACHED();
4130     return MiterJoin;
4131 }
4132 
4133 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WindRule e)
4134     : CSSValue(PrimitiveClass)
4135 {
4136     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4137     switch (e) {
4138     case WindRule::NonZero:
4139         m_value.valueID = CSSValueNonzero;
4140         break;
4141     case WindRule::EvenOdd:
4142         m_value.valueID = CSSValueEvenodd;
4143         break;
4144     }
4145 }
4146 
4147 template&lt;&gt; inline CSSPrimitiveValue::operator WindRule() const
4148 {
4149     ASSERT(isValueID());
4150 
4151     switch (m_value.valueID) {
4152     case CSSValueNonzero:
4153         return WindRule::NonZero;
4154     case CSSValueEvenodd:
4155         return WindRule::EvenOdd;
4156     default:
4157         break;
4158     }
4159 
4160     ASSERT_NOT_REACHED();
4161     return WindRule::NonZero;
4162 }
4163 
4164 
4165 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignmentBaseline e)
4166     : CSSValue(PrimitiveClass)
4167 {
4168     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4169     switch (e) {
4170     case AlignmentBaseline::Auto:
4171         m_value.valueID = CSSValueAuto;
4172         break;
4173     case AlignmentBaseline::Baseline:
4174         m_value.valueID = CSSValueBaseline;
4175         break;
4176     case AlignmentBaseline::BeforeEdge:
4177         m_value.valueID = CSSValueBeforeEdge;
4178         break;
4179     case AlignmentBaseline::TextBeforeEdge:
4180         m_value.valueID = CSSValueTextBeforeEdge;
4181         break;
4182     case AlignmentBaseline::Middle:
4183         m_value.valueID = CSSValueMiddle;
4184         break;
4185     case AlignmentBaseline::Central:
4186         m_value.valueID = CSSValueCentral;
4187         break;
4188     case AlignmentBaseline::AfterEdge:
4189         m_value.valueID = CSSValueAfterEdge;
4190         break;
4191     case AlignmentBaseline::TextAfterEdge:
4192         m_value.valueID = CSSValueTextAfterEdge;
4193         break;
4194     case AlignmentBaseline::Ideographic:
4195         m_value.valueID = CSSValueIdeographic;
4196         break;
4197     case AlignmentBaseline::Alphabetic:
4198         m_value.valueID = CSSValueAlphabetic;
4199         break;
4200     case AlignmentBaseline::Hanging:
4201         m_value.valueID = CSSValueHanging;
4202         break;
4203     case AlignmentBaseline::Mathematical:
4204         m_value.valueID = CSSValueMathematical;
4205         break;
4206     }
4207 }
4208 
4209 template&lt;&gt; inline CSSPrimitiveValue::operator AlignmentBaseline() const
4210 {
4211     ASSERT(isValueID());
4212 
4213     switch (m_value.valueID) {
4214     case CSSValueAuto:
4215         return AlignmentBaseline::Auto;
4216     case CSSValueBaseline:
4217         return AlignmentBaseline::Baseline;
4218     case CSSValueBeforeEdge:
4219         return AlignmentBaseline::BeforeEdge;
4220     case CSSValueTextBeforeEdge:
4221         return AlignmentBaseline::TextBeforeEdge;
4222     case CSSValueMiddle:
4223         return AlignmentBaseline::Middle;
4224     case CSSValueCentral:
4225         return AlignmentBaseline::Central;
4226     case CSSValueAfterEdge:
4227         return AlignmentBaseline::AfterEdge;
4228     case CSSValueTextAfterEdge:
4229         return AlignmentBaseline::TextAfterEdge;
4230     case CSSValueIdeographic:
4231         return AlignmentBaseline::Ideographic;
4232     case CSSValueAlphabetic:
4233         return AlignmentBaseline::Alphabetic;
4234     case CSSValueHanging:
4235         return AlignmentBaseline::Hanging;
4236     case CSSValueMathematical:
4237         return AlignmentBaseline::Mathematical;
4238     default:
4239         break;
4240     }
4241 
4242     ASSERT_NOT_REACHED();
4243     return AlignmentBaseline::Auto;
4244 }
4245 
4246 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderCollapse e)
4247     : CSSValue(PrimitiveClass)
4248 {
4249     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4250     switch (e) {
4251     case BorderCollapse::Separate:
4252         m_value.valueID = CSSValueSeparate;
4253         break;
4254     case BorderCollapse::Collapse:
4255         m_value.valueID = CSSValueCollapse;
4256         break;
4257     }
4258 }
4259 
4260 template&lt;&gt; inline CSSPrimitiveValue::operator BorderCollapse() const
4261 {
4262     ASSERT(isValueID());
4263 
4264     switch (m_value.valueID) {
4265     case CSSValueSeparate:
4266         return BorderCollapse::Separate;
4267     case CSSValueCollapse:
4268         return BorderCollapse::Collapse;
4269     default:
4270         break;
4271     }
4272 
4273     ASSERT_NOT_REACHED();
4274     return BorderCollapse::Separate;
4275 }
4276 
4277 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderFit e)
4278     : CSSValue(PrimitiveClass)
4279 {
4280     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4281     switch (e) {
4282     case BorderFit::Border:
4283         m_value.valueID = CSSValueBorder;
4284         break;
4285     case BorderFit::Lines:
4286         m_value.valueID = CSSValueLines;
4287         break;
4288     }
4289 }
4290 
4291 template&lt;&gt; inline CSSPrimitiveValue::operator BorderFit() const
4292 {
4293     ASSERT(isValueID());
4294 
4295     switch (m_value.valueID) {
4296     case CSSValueBorder:
4297         return BorderFit::Border;
4298     case CSSValueLines:
4299         return BorderFit::Lines;
4300     default:
4301         break;
4302     }
4303 
4304     ASSERT_NOT_REACHED();
4305     return BorderFit::Lines;
4306 }
4307 
4308 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageRendering imageRendering)
4309     : CSSValue(PrimitiveClass)
4310 {
4311     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4312     switch (imageRendering) {
4313     case ImageRendering::Auto:
4314         m_value.valueID = CSSValueAuto;
4315         break;
4316     case ImageRendering::CrispEdges:
4317         m_value.valueID = CSSValueCrispEdges;
4318         break;
4319     case ImageRendering::Pixelated:
4320         m_value.valueID = CSSValuePixelated;
4321         break;
4322     case ImageRendering::OptimizeSpeed:
4323         m_value.valueID = CSSValueOptimizeSpeed;
4324         break;
4325     case ImageRendering::OptimizeQuality:
4326         m_value.valueID = CSSValueOptimizeQuality;
4327         break;
4328     }
4329 }
4330 
4331 template&lt;&gt; inline CSSPrimitiveValue::operator ImageRendering() const
4332 {
4333     ASSERT(isValueID());
4334 
4335     switch (m_value.valueID) {
4336     case CSSValueAuto:
4337         return ImageRendering::Auto;
4338     case CSSValueWebkitOptimizeContrast:
4339     case CSSValueCrispEdges:
4340     case CSSValueWebkitCrispEdges:
4341         return ImageRendering::CrispEdges;
4342     case CSSValuePixelated:
4343         return ImageRendering::Pixelated;
4344     case CSSValueOptimizeSpeed:
4345         return ImageRendering::OptimizeSpeed;
4346     case CSSValueOptimizeQuality:
4347         return ImageRendering::OptimizeQuality;
4348     default:
4349         break;
4350     }
4351 
4352     ASSERT_NOT_REACHED();
4353     return ImageRendering::Auto;
4354 }
4355 
4356 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformStyle3D e)
4357     : CSSValue(PrimitiveClass)
4358 {
4359     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4360     switch (e) {
4361     case TransformStyle3D::Flat:
4362         m_value.valueID = CSSValueFlat;
4363         break;
4364     case TransformStyle3D::Preserve3D:
4365         m_value.valueID = CSSValuePreserve3d;
4366         break;
4367     }
4368 }
4369 
4370 template&lt;&gt; inline CSSPrimitiveValue::operator TransformStyle3D() const
4371 {
4372     ASSERT(isValueID());
4373 
4374     switch (m_value.valueID) {
4375     case CSSValueFlat:
4376         return TransformStyle3D::Flat;
4377     case CSSValuePreserve3d:
4378         return TransformStyle3D::Preserve3D;
4379     default:
4380         break;
4381     }
4382 
4383     ASSERT_NOT_REACHED();
4384     return TransformStyle3D::Flat;
4385 }
4386 
4387 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformBox box)
4388     : CSSValue(PrimitiveClass)
4389 {
4390     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4391     switch (box) {
4392     case TransformBox::StrokeBox:
4393         m_value.valueID = CSSValueStrokeBox;
4394         break;
4395     case TransformBox::ContentBox:
4396         m_value.valueID = CSSValueContentBox;
4397         break;
4398     case TransformBox::BorderBox:
4399         m_value.valueID = CSSValueBorderBox;
4400         break;
4401     case TransformBox::FillBox:
4402         m_value.valueID = CSSValueFillBox;
4403         break;
4404     case TransformBox::ViewBox:
4405         m_value.valueID = CSSValueViewBox;
4406         break;
4407     }
4408 }
4409 
4410 template&lt;&gt; inline CSSPrimitiveValue::operator TransformBox() const
4411 {
4412     ASSERT(isValueID());
4413 
4414     switch (m_value.valueID) {
4415     case CSSValueStrokeBox:
4416         return TransformBox::StrokeBox;
4417     case CSSValueContentBox:
4418         return TransformBox::ContentBox;
4419     case CSSValueBorderBox:
4420         return TransformBox::BorderBox;
4421     case CSSValueFillBox:
4422         return TransformBox::FillBox;
4423     case CSSValueViewBox:
4424         return TransformBox::ViewBox;
4425     default:
4426         break;
4427     }
4428 
4429     ASSERT_NOT_REACHED();
4430     return TransformBox::BorderBox;
4431 }
4432 
4433 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnAxis e)
4434     : CSSValue(PrimitiveClass)
4435 {
4436     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4437     switch (e) {
4438     case ColumnAxis::Horizontal:
4439         m_value.valueID = CSSValueHorizontal;
4440         break;
4441     case ColumnAxis::Vertical:
4442         m_value.valueID = CSSValueVertical;
4443         break;
4444     case ColumnAxis::Auto:
4445         m_value.valueID = CSSValueAuto;
4446         break;
4447     }
4448 }
4449 
4450 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnAxis() const
4451 {
4452     ASSERT(isValueID());
4453 
4454     switch (m_value.valueID) {
4455     case CSSValueHorizontal:
4456         return ColumnAxis::Horizontal;
4457     case CSSValueVertical:
4458         return ColumnAxis::Vertical;
4459     case CSSValueAuto:
4460         return ColumnAxis::Auto;
4461     default:
4462         break;
4463     }
4464 
4465     ASSERT_NOT_REACHED();
4466     return ColumnAxis::Auto;
4467 }
4468 
4469 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnProgression e)
4470     : CSSValue(PrimitiveClass)
4471 {
4472     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4473     switch (e) {
4474     case ColumnProgression::Normal:
4475         m_value.valueID = CSSValueNormal;
4476         break;
4477     case ColumnProgression::Reverse:
4478         m_value.valueID = CSSValueReverse;
4479         break;
4480     }
4481 }
4482 
4483 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnProgression() const
4484 {
4485     ASSERT(isValueID());
4486 
4487     switch (m_value.valueID) {
4488     case CSSValueNormal:
4489         return ColumnProgression::Normal;
4490     case CSSValueReverse:
4491         return ColumnProgression::Reverse;
4492     default:
4493         break;
4494     }
4495 
4496     ASSERT_NOT_REACHED();
4497     return ColumnProgression::Normal;
4498 }
4499 
4500 enum LengthConversion {
4501     AnyConversion = ~0,
4502     FixedIntegerConversion = 1 &lt;&lt; 0,
4503     FixedFloatConversion = 1 &lt;&lt; 1,
4504     AutoConversion = 1 &lt;&lt; 2,
4505     PercentConversion = 1 &lt;&lt; 3,
4506     CalculatedConversion = 1 &lt;&lt; 4
4507 };
4508 
4509 inline bool CSSPrimitiveValue::convertingToLengthRequiresNonNullStyle(int lengthConversion) const
4510 {
4511     ASSERT(isFontRelativeLength());
4512     // This matches the implementation in CSSPrimitiveValue::computeLengthDouble().
4513     switch (primitiveUnitType()) {
4514     case CSSUnitType::CSS_EMS:
4515     case CSSUnitType::CSS_EXS:
4516     case CSSUnitType::CSS_CHS:
4517         return lengthConversion &amp; (FixedIntegerConversion | FixedFloatConversion);
4518     default:
4519         return false;
4520     }
4521 }
4522 
4523 template&lt;int supported&gt; Length CSSPrimitiveValue::convertToLength(const CSSToLengthConversionData&amp; conversionData) const
4524 {
4525     if (isFontRelativeLength() &amp;&amp; convertingToLengthRequiresNonNullStyle(supported) &amp;&amp; !conversionData.style())
4526         return Length(Undefined);
4527     if ((supported &amp; FixedIntegerConversion) &amp;&amp; isLength())
4528         return computeLength&lt;Length&gt;(conversionData);
4529     if ((supported &amp; FixedFloatConversion) &amp;&amp; isLength())
4530         return Length(computeLength&lt;double&gt;(conversionData), Fixed);
4531     if ((supported &amp; PercentConversion) &amp;&amp; isPercentage())
4532         return Length(doubleValue(), Percent);
4533     if ((supported &amp; AutoConversion) &amp;&amp; valueID() == CSSValueAuto)
4534         return Length(Auto);
4535     if ((supported &amp; CalculatedConversion) &amp;&amp; isCalculated())
4536         return Length(cssCalcValue()-&gt;createCalculationValue(conversionData));
4537     return Length(Undefined);
4538 }
4539 
4540 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BufferedRendering e)
4541     : CSSValue(PrimitiveClass)
4542 {
4543     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4544     switch (e) {
4545     case BufferedRendering::Auto:
4546         m_value.valueID = CSSValueAuto;
4547         break;
4548     case BufferedRendering::Dynamic:
4549         m_value.valueID = CSSValueDynamic;
4550         break;
4551     case BufferedRendering::Static:
4552         m_value.valueID = CSSValueStatic;
4553         break;
4554     }
4555 }
4556 
4557 template&lt;&gt; inline CSSPrimitiveValue::operator BufferedRendering() const
4558 {
4559     ASSERT(isValueID());
4560 
4561     switch (m_value.valueID) {
4562     case CSSValueAuto:
4563         return BufferedRendering::Auto;
4564     case CSSValueDynamic:
4565         return BufferedRendering::Dynamic;
4566     case CSSValueStatic:
4567         return BufferedRendering::Static;
4568     default:
4569         break;
4570     }
4571 
4572     ASSERT_NOT_REACHED();
4573     return BufferedRendering::Auto;
4574 }
4575 
4576 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorInterpolation e)
4577     : CSSValue(PrimitiveClass)
4578 {
4579     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4580     switch (e) {
4581     case ColorInterpolation::Auto:
4582         m_value.valueID = CSSValueAuto;
4583         break;
4584     case ColorInterpolation::SRGB:
4585         m_value.valueID = CSSValueSRGB;
4586         break;
4587     case ColorInterpolation::LinearRGB:
4588         m_value.valueID = CSSValueLinearRGB;
4589         break;
4590     }
4591 }
4592 
4593 template&lt;&gt; inline CSSPrimitiveValue::operator ColorInterpolation() const
4594 {
4595     ASSERT(isValueID());
4596 
4597     switch (m_value.valueID) {
4598     case CSSValueSRGB:
4599         return ColorInterpolation::SRGB;
4600     case CSSValueLinearRGB:
4601         return ColorInterpolation::LinearRGB;
4602     case CSSValueAuto:
4603         return ColorInterpolation::Auto;
4604     default:
4605         break;
4606     }
4607 
4608     ASSERT_NOT_REACHED();
4609     return ColorInterpolation::Auto;
4610 }
4611 
4612 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorRendering e)
4613     : CSSValue(PrimitiveClass)
4614 {
4615     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4616     switch (e) {
4617     case ColorRendering::Auto:
4618         m_value.valueID = CSSValueAuto;
4619         break;
4620     case ColorRendering::OptimizeSpeed:
4621         m_value.valueID = CSSValueOptimizeSpeed;
4622         break;
4623     case ColorRendering::OptimizeQuality:
4624         m_value.valueID = CSSValueOptimizeQuality;
4625         break;
4626     }
4627 }
4628 
4629 template&lt;&gt; inline CSSPrimitiveValue::operator ColorRendering() const
4630 {
4631     ASSERT(isValueID());
4632 
4633     switch (m_value.valueID) {
4634     case CSSValueOptimizeSpeed:
4635         return ColorRendering::OptimizeSpeed;
4636     case CSSValueOptimizeQuality:
4637         return ColorRendering::OptimizeQuality;
4638     case CSSValueAuto:
4639         return ColorRendering::Auto;
4640     default:
4641         break;
4642     }
4643 
4644     ASSERT_NOT_REACHED();
4645     return ColorRendering::Auto;
4646 }
4647 
4648 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DominantBaseline e)
4649     : CSSValue(PrimitiveClass)
4650 {
4651     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4652     switch (e) {
4653     case DominantBaseline::Auto:
4654         m_value.valueID = CSSValueAuto;
4655         break;
4656     case DominantBaseline::UseScript:
4657         m_value.valueID = CSSValueUseScript;
4658         break;
4659     case DominantBaseline::NoChange:
4660         m_value.valueID = CSSValueNoChange;
4661         break;
4662     case DominantBaseline::ResetSize:
4663         m_value.valueID = CSSValueResetSize;
4664         break;
4665     case DominantBaseline::Central:
4666         m_value.valueID = CSSValueCentral;
4667         break;
4668     case DominantBaseline::Middle:
4669         m_value.valueID = CSSValueMiddle;
4670         break;
4671     case DominantBaseline::TextBeforeEdge:
4672         m_value.valueID = CSSValueTextBeforeEdge;
4673         break;
4674     case DominantBaseline::TextAfterEdge:
4675         m_value.valueID = CSSValueTextAfterEdge;
4676         break;
4677     case DominantBaseline::Ideographic:
4678         m_value.valueID = CSSValueIdeographic;
4679         break;
4680     case DominantBaseline::Alphabetic:
4681         m_value.valueID = CSSValueAlphabetic;
4682         break;
4683     case DominantBaseline::Hanging:
4684         m_value.valueID = CSSValueHanging;
4685         break;
4686     case DominantBaseline::Mathematical:
4687         m_value.valueID = CSSValueMathematical;
4688         break;
4689     }
4690 }
4691 
4692 template&lt;&gt; inline CSSPrimitiveValue::operator DominantBaseline() const
4693 {
4694     ASSERT(isValueID());
4695 
4696     switch (m_value.valueID) {
4697     case CSSValueAuto:
4698         return DominantBaseline::Auto;
4699     case CSSValueUseScript:
4700         return DominantBaseline::UseScript;
4701     case CSSValueNoChange:
4702         return DominantBaseline::NoChange;
4703     case CSSValueResetSize:
4704         return DominantBaseline::ResetSize;
4705     case CSSValueIdeographic:
4706         return DominantBaseline::Ideographic;
4707     case CSSValueAlphabetic:
4708         return DominantBaseline::Alphabetic;
4709     case CSSValueHanging:
4710         return DominantBaseline::Hanging;
4711     case CSSValueMathematical:
4712         return DominantBaseline::Mathematical;
4713     case CSSValueCentral:
4714         return DominantBaseline::Central;
4715     case CSSValueMiddle:
4716         return DominantBaseline::Middle;
4717     case CSSValueTextAfterEdge:
4718         return DominantBaseline::TextAfterEdge;
4719     case CSSValueTextBeforeEdge:
4720         return DominantBaseline::TextBeforeEdge;
4721     default:
4722         break;
4723     }
4724 
4725     ASSERT_NOT_REACHED();
4726     return DominantBaseline::Auto;
4727 }
4728 
4729 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ShapeRendering e)
4730     : CSSValue(PrimitiveClass)
4731 {
4732     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4733     switch (e) {
4734     case ShapeRendering::Auto:
4735         m_value.valueID = CSSValueAuto;
4736         break;
4737     case ShapeRendering::OptimizeSpeed:
4738         m_value.valueID = CSSValueOptimizeSpeed;
4739         break;
4740     case ShapeRendering::CrispEdges:
4741         m_value.valueID = CSSValueCrispedges;
4742         break;
4743     case ShapeRendering::GeometricPrecision:
4744         m_value.valueID = CSSValueGeometricPrecision;
4745         break;
4746     }
4747 }
4748 
4749 template&lt;&gt; inline CSSPrimitiveValue::operator ShapeRendering() const
4750 {
4751     ASSERT(isValueID());
4752 
4753     switch (m_value.valueID) {
4754     case CSSValueAuto:
4755         return ShapeRendering::Auto;
4756     case CSSValueOptimizeSpeed:
4757         return ShapeRendering::OptimizeSpeed;
4758     case CSSValueCrispedges:
4759         return ShapeRendering::CrispEdges;
4760     case CSSValueGeometricPrecision:
4761         return ShapeRendering::GeometricPrecision;
4762     default:
4763         break;
4764     }
4765 
4766     ASSERT_NOT_REACHED();
4767     return ShapeRendering::Auto;
4768 }
4769 
4770 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAnchor e)
4771     : CSSValue(PrimitiveClass)
4772 {
4773     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4774     switch (e) {
4775     case TextAnchor::Start:
4776         m_value.valueID = CSSValueStart;
4777         break;
4778     case TextAnchor::Middle:
4779         m_value.valueID = CSSValueMiddle;
4780         break;
4781     case TextAnchor::End:
4782         m_value.valueID = CSSValueEnd;
4783         break;
4784     }
4785 }
4786 
4787 template&lt;&gt; inline CSSPrimitiveValue::operator TextAnchor() const
4788 {
4789     ASSERT(isValueID());
4790 
4791     switch (m_value.valueID) {
4792     case CSSValueStart:
4793         return TextAnchor::Start;
4794     case CSSValueMiddle:
4795         return TextAnchor::Middle;
4796     case CSSValueEnd:
4797         return TextAnchor::End;
4798     default:
4799         break;
4800     }
4801 
4802     ASSERT_NOT_REACHED();
4803     return TextAnchor::Start;
4804 }
4805 
4806 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(const Color&amp; color)
4807     : CSSValue(PrimitiveClass)
4808 {
4809     setPrimitiveUnitType(CSSUnitType::CSS_RGBCOLOR);
4810     m_value.color = new Color(color);
4811 }
4812 
4813 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSFontFamily fontFamily)
4814     : CSSValue(PrimitiveClass)
4815 {
4816     setPrimitiveUnitType(CSSUnitType::CSS_FONT_FAMILY);
4817     m_value.fontFamily = new CSSFontFamily(WTFMove(fontFamily));
4818 }
4819 
4820 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VectorEffect e)
4821     : CSSValue(PrimitiveClass)
4822 {
4823     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4824     switch (e) {
4825     case VectorEffect::None:
4826         m_value.valueID = CSSValueNone;
4827         break;
4828     case VectorEffect::NonScalingStroke:
4829         m_value.valueID = CSSValueNonScalingStroke;
4830         break;
4831     }
4832 }
4833 
4834 template&lt;&gt; inline CSSPrimitiveValue::operator VectorEffect() const
4835 {
4836     ASSERT(isValueID());
4837 
4838     switch (m_value.valueID) {
4839     case CSSValueNone:
4840         return VectorEffect::None;
4841     case CSSValueNonScalingStroke:
4842         return VectorEffect::NonScalingStroke;
4843     default:
4844         break;
4845     }
4846 
4847     ASSERT_NOT_REACHED();
4848     return VectorEffect::None;
4849 }
4850 
4851 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MaskType e)
4852     : CSSValue(PrimitiveClass)
4853 {
4854     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4855     switch (e) {
4856     case MaskType::Luminance:
4857         m_value.valueID = CSSValueLuminance;
4858         break;
4859     case MaskType::Alpha:
4860         m_value.valueID = CSSValueAlpha;
4861         break;
4862     }
4863 }
4864 
4865 template&lt;&gt; inline CSSPrimitiveValue::operator MaskType() const
4866 {
4867     ASSERT(isValueID());
4868 
4869     switch (m_value.valueID) {
4870     case CSSValueLuminance:
4871         return MaskType::Luminance;
4872     case CSSValueAlpha:
4873         return MaskType::Alpha;
4874     default:
4875         break;
4876     }
4877 
4878     ASSERT_NOT_REACHED();
4879     return MaskType::Luminance;
4880 }
4881 
4882 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
4883     : CSSValue(PrimitiveClass)
4884 {
4885     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4886     switch (cssBox) {
4887     case CSSBoxType::MarginBox:
4888         m_value.valueID = CSSValueMarginBox;
4889         break;
4890     case CSSBoxType::BorderBox:
4891         m_value.valueID = CSSValueBorderBox;
4892         break;
4893     case CSSBoxType::PaddingBox:
4894         m_value.valueID = CSSValuePaddingBox;
4895         break;
4896     case CSSBoxType::ContentBox:
4897         m_value.valueID = CSSValueContentBox;
4898         break;
4899     case CSSBoxType::FillBox:
4900         m_value.valueID = CSSValueFillBox;
4901         break;
4902     case CSSBoxType::StrokeBox:
4903         m_value.valueID = CSSValueStrokeBox;
4904         break;
4905     case CSSBoxType::ViewBox:
4906         m_value.valueID = CSSValueViewBox;
4907         break;
4908     case CSSBoxType::BoxMissing:
4909         ASSERT_NOT_REACHED();
4910         m_value.valueID = CSSValueNone;
4911         break;
4912     }
4913 }
4914 
4915 template&lt;&gt; inline CSSPrimitiveValue::operator CSSBoxType() const
4916 {
4917     switch (valueID()) {
4918     case CSSValueMarginBox:
4919         return CSSBoxType::MarginBox;
4920     case CSSValueBorderBox:
4921         return CSSBoxType::BorderBox;
4922     case CSSValuePaddingBox:
4923         return CSSBoxType::PaddingBox;
4924     case CSSValueContentBox:
4925         return CSSBoxType::ContentBox;
4926     // The following are used in an SVG context.
4927     case CSSValueFillBox:
4928         return CSSBoxType::FillBox;
4929     case CSSValueStrokeBox:
4930         return CSSBoxType::StrokeBox;
4931     case CSSValueViewBox:
4932         return CSSBoxType::ViewBox;
4933     default:
4934         break;
4935     }
4936     ASSERT_NOT_REACHED();
4937     return CSSBoxType::BoxMissing;
4938 }
4939 
4940 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ItemPosition itemPosition)
4941     : CSSValue(PrimitiveClass)
4942 {
4943     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
4944     switch (itemPosition) {
4945     case ItemPosition::Legacy:
4946         m_value.valueID = CSSValueLegacy;
4947         break;
4948     case ItemPosition::Auto:
4949         m_value.valueID = CSSValueAuto;
4950         break;
4951     case ItemPosition::Normal:
4952         m_value.valueID = CSSValueNormal;
4953         break;
4954     case ItemPosition::Stretch:
4955         m_value.valueID = CSSValueStretch;
4956         break;
4957     case ItemPosition::Baseline:
4958         m_value.valueID = CSSValueBaseline;
4959         break;
4960     case ItemPosition::LastBaseline:
4961         m_value.valueID = CSSValueLastBaseline;
4962         break;
4963     case ItemPosition::Center:
4964         m_value.valueID = CSSValueCenter;
4965         break;
4966     case ItemPosition::Start:
4967         m_value.valueID = CSSValueStart;
4968         break;
4969     case ItemPosition::End:
4970         m_value.valueID = CSSValueEnd;
4971         break;
4972     case ItemPosition::SelfStart:
4973         m_value.valueID = CSSValueSelfStart;
4974         break;
4975     case ItemPosition::SelfEnd:
4976         m_value.valueID = CSSValueSelfEnd;
4977         break;
4978     case ItemPosition::FlexStart:
4979         m_value.valueID = CSSValueFlexStart;
4980         break;
4981     case ItemPosition::FlexEnd:
4982         m_value.valueID = CSSValueFlexEnd;
4983         break;
4984     case ItemPosition::Left:
4985         m_value.valueID = CSSValueLeft;
4986         break;
4987     case ItemPosition::Right:
4988         m_value.valueID = CSSValueRight;
4989         break;
4990     }
4991 }
4992 
4993 template&lt;&gt; inline CSSPrimitiveValue::operator ItemPosition() const
4994 {
4995     switch (m_value.valueID) {
4996     case CSSValueLegacy:
4997         return ItemPosition::Legacy;
4998     case CSSValueAuto:
4999         return ItemPosition::Auto;
5000     case CSSValueNormal:
5001         return ItemPosition::Normal;
5002     case CSSValueStretch:
5003         return ItemPosition::Stretch;
5004     case CSSValueBaseline:
5005         return ItemPosition::Baseline;
5006     case CSSValueFirstBaseline:
5007         return ItemPosition::Baseline;
5008     case CSSValueLastBaseline:
5009         return ItemPosition::LastBaseline;
5010     case CSSValueCenter:
5011         return ItemPosition::Center;
5012     case CSSValueStart:
5013         return ItemPosition::Start;
5014     case CSSValueEnd:
5015         return ItemPosition::End;
5016     case CSSValueSelfStart:
5017         return ItemPosition::SelfStart;
5018     case CSSValueSelfEnd:
5019         return ItemPosition::SelfEnd;
5020     case CSSValueFlexStart:
5021         return ItemPosition::FlexStart;
5022     case CSSValueFlexEnd:
5023         return ItemPosition::FlexEnd;
5024     case CSSValueLeft:
5025         return ItemPosition::Left;
5026     case CSSValueRight:
5027         return ItemPosition::Right;
5028     default:
5029         break;
5030     }
5031     ASSERT_NOT_REACHED();
5032     return ItemPosition::Auto;
5033 }
5034 
5035 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowAlignment overflowAlignment)
5036     : CSSValue(PrimitiveClass)
5037 {
5038     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5039     switch (overflowAlignment) {
5040     case OverflowAlignment::Default:
5041         m_value.valueID = CSSValueDefault;
5042         break;
5043     case OverflowAlignment::Unsafe:
5044         m_value.valueID = CSSValueUnsafe;
5045         break;
5046     case OverflowAlignment::Safe:
5047         m_value.valueID = CSSValueSafe;
5048         break;
5049     }
5050 }
5051 
5052 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowAlignment() const
5053 {
5054     switch (m_value.valueID) {
5055     case CSSValueUnsafe:
5056         return OverflowAlignment::Unsafe;
5057     case CSSValueSafe:
5058         return OverflowAlignment::Safe;
5059     default:
5060         break;
5061     }
5062     ASSERT_NOT_REACHED();
5063     return OverflowAlignment::Unsafe;
5064 }
5065 
5066 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentPosition contentPosition)
5067     : CSSValue(PrimitiveClass)
5068 {
5069     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5070     switch (contentPosition) {
5071     case ContentPosition::Normal:
5072         m_value.valueID = CSSValueNormal;
5073         break;
5074     case ContentPosition::Baseline:
5075         m_value.valueID = CSSValueBaseline;
5076         break;
5077     case ContentPosition::LastBaseline:
5078         m_value.valueID = CSSValueLastBaseline;
5079         break;
5080     case ContentPosition::Center:
5081         m_value.valueID = CSSValueCenter;
5082         break;
5083     case ContentPosition::Start:
5084         m_value.valueID = CSSValueStart;
5085         break;
5086     case ContentPosition::End:
5087         m_value.valueID = CSSValueEnd;
5088         break;
5089     case ContentPosition::FlexStart:
5090         m_value.valueID = CSSValueFlexStart;
5091         break;
5092     case ContentPosition::FlexEnd:
5093         m_value.valueID = CSSValueFlexEnd;
5094         break;
5095     case ContentPosition::Left:
5096         m_value.valueID = CSSValueLeft;
5097         break;
5098     case ContentPosition::Right:
5099         m_value.valueID = CSSValueRight;
5100         break;
5101     }
5102 }
5103 
5104 template&lt;&gt; inline CSSPrimitiveValue::operator ContentPosition() const
5105 {
5106     switch (m_value.valueID) {
5107     case CSSValueNormal:
5108         return ContentPosition::Normal;
5109     case CSSValueBaseline:
5110         return ContentPosition::Baseline;
5111     case CSSValueFirstBaseline:
5112         return ContentPosition::Baseline;
5113     case CSSValueLastBaseline:
5114         return ContentPosition::LastBaseline;
5115     case CSSValueCenter:
5116         return ContentPosition::Center;
5117     case CSSValueStart:
5118         return ContentPosition::Start;
5119     case CSSValueEnd:
5120         return ContentPosition::End;
5121     case CSSValueFlexStart:
5122         return ContentPosition::FlexStart;
5123     case CSSValueFlexEnd:
5124         return ContentPosition::FlexEnd;
5125     case CSSValueLeft:
5126         return ContentPosition::Left;
5127     case CSSValueRight:
5128         return ContentPosition::Right;
5129     default:
5130         break;
5131     }
5132     ASSERT_NOT_REACHED();
5133     return ContentPosition::Normal;
5134 }
5135 
5136 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentDistribution contentDistribution)
5137     : CSSValue(PrimitiveClass)
5138 {
5139     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5140     switch (contentDistribution) {
5141     case ContentDistribution::Default:
5142         m_value.valueID = CSSValueDefault;
5143         break;
5144     case ContentDistribution::SpaceBetween:
5145         m_value.valueID = CSSValueSpaceBetween;
5146         break;
5147     case ContentDistribution::SpaceAround:
5148         m_value.valueID = CSSValueSpaceAround;
5149         break;
5150     case ContentDistribution::SpaceEvenly:
5151         m_value.valueID = CSSValueSpaceEvenly;
5152         break;
5153     case ContentDistribution::Stretch:
5154         m_value.valueID = CSSValueStretch;
5155         break;
5156     }
5157 }
5158 
5159 template&lt;&gt; inline CSSPrimitiveValue::operator ContentDistribution() const
5160 {
5161     switch (m_value.valueID) {
5162     case CSSValueSpaceBetween:
5163         return ContentDistribution::SpaceBetween;
5164     case CSSValueSpaceAround:
5165         return ContentDistribution::SpaceAround;
5166     case CSSValueSpaceEvenly:
5167         return ContentDistribution::SpaceEvenly;
5168     case CSSValueStretch:
5169         return ContentDistribution::Stretch;
5170     default:
5171         break;
5172     }
5173     ASSERT_NOT_REACHED();
5174     return ContentDistribution::Stretch;
5175 }
5176 
5177 template&lt;&gt; inline CSSPrimitiveValue::operator TextZoom() const
5178 {
5179     ASSERT(isValueID());
5180 
5181     switch (m_value.valueID) {
5182     case CSSValueNormal:
5183         return TextZoom::Normal;
5184     case CSSValueReset:
5185         return TextZoom::Reset;
5186     default:
5187         break;
5188     }
5189 
5190     ASSERT_NOT_REACHED();
5191     return TextZoom::Normal;
5192 }
5193 
5194 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextZoom textZoom)
5195     : CSSValue(PrimitiveClass)
5196 {
5197     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5198     switch (textZoom) {
5199     case TextZoom::Normal:
5200         m_value.valueID = CSSValueNormal;
5201         return;
5202     case TextZoom::Reset:
5203         m_value.valueID = CSSValueReset;
5204         return;
5205     }
5206 
5207     ASSERT_NOT_REACHED();
5208     m_value.valueID = CSSValueNormal;
5209 }
5210 
5211 #if ENABLE(POINTER_EVENTS)
5212 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TouchAction touchAction)
5213     : CSSValue(PrimitiveClass)
5214 {
5215     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5216     switch (touchAction) {
5217     case TouchAction::Auto:
5218         m_value.valueID = CSSValueAuto;
5219         break;
5220     case TouchAction::Manipulation:
5221         m_value.valueID = CSSValueManipulation;
5222         break;
5223     case TouchAction::None:
5224         m_value.valueID = CSSValueNone;
5225         break;
5226     case TouchAction::PanX:
5227         m_value.valueID = CSSValuePanX;
5228         break;
5229     case TouchAction::PanY:
5230         m_value.valueID = CSSValuePanY;
5231         break;
5232     case TouchAction::PinchZoom:
5233         m_value.valueID = CSSValuePinchZoom;
5234         break;
5235     }
5236 }
5237 
5238 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;TouchAction&gt;() const
5239 {
5240     ASSERT(isValueID());
5241     switch (m_value.valueID) {
5242     case CSSValueAuto:
5243         return TouchAction::Auto;
5244     case CSSValueManipulation:
5245         return TouchAction::Manipulation;
5246     case CSSValueNone:
5247         return TouchAction::None;
5248     case CSSValuePanX:
5249         return TouchAction::PanX;
5250     case CSSValuePanY:
5251         return TouchAction::PanY;
5252     case CSSValuePinchZoom:
5253         return TouchAction::PinchZoom;
5254     default:
5255         break;
5256     }
5257     ASSERT_NOT_REACHED();
5258     return TouchAction::Auto;
5259 }
5260 #endif
5261 
5262 #if ENABLE(CSS_SCROLL_SNAP)
5263 
5264 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapStrictness strictness)
5265     : CSSValue(PrimitiveClass)
5266 {
5267     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5268     switch (strictness) {
5269     case ScrollSnapStrictness::None:
5270         m_value.valueID = CSSValueNone;
5271         break;
5272     case ScrollSnapStrictness::Proximity:
5273         m_value.valueID = CSSValueProximity;
5274         break;
5275     case ScrollSnapStrictness::Mandatory:
5276         m_value.valueID = CSSValueMandatory;
5277         break;
5278     }
5279 }
5280 
5281 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapStrictness() const
5282 {
5283     ASSERT(isValueID());
5284     switch (m_value.valueID) {
5285     case CSSValueNone:
5286         return ScrollSnapStrictness::None;
5287     case CSSValueProximity:
5288         return ScrollSnapStrictness::Proximity;
5289     case CSSValueMandatory:
5290         return ScrollSnapStrictness::Mandatory;
5291     default:
5292         ASSERT_NOT_REACHED();
5293         return ScrollSnapStrictness::None;
5294     }
5295 }
5296 
5297 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxis axis)
5298     : CSSValue(PrimitiveClass)
5299 {
5300     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5301     switch (axis) {
5302     case ScrollSnapAxis::XAxis:
5303         m_value.valueID = CSSValueX;
5304         break;
5305     case ScrollSnapAxis::YAxis:
5306         m_value.valueID = CSSValueY;
5307         break;
5308     case ScrollSnapAxis::Block:
5309         m_value.valueID = CSSValueBlock;
5310         break;
5311     case ScrollSnapAxis::Inline:
5312         m_value.valueID = CSSValueInline;
5313         break;
5314     case ScrollSnapAxis::Both:
5315         m_value.valueID = CSSValueBoth;
5316         break;
5317     }
5318 }
5319 
5320 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxis() const
5321 {
5322     ASSERT(isValueID());
5323     switch (m_value.valueID) {
5324     case CSSValueX:
5325         return ScrollSnapAxis::XAxis;
5326     case CSSValueY:
5327         return ScrollSnapAxis::YAxis;
5328     case CSSValueBlock:
5329         return ScrollSnapAxis::Block;
5330     case CSSValueInline:
5331         return ScrollSnapAxis::Inline;
5332     case CSSValueBoth:
5333         return ScrollSnapAxis::Both;
5334     default:
5335         ASSERT_NOT_REACHED();
5336         return ScrollSnapAxis::Both;
5337     }
5338 }
5339 
5340 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxisAlignType type)
5341     : CSSValue(PrimitiveClass)
5342 {
5343     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5344     switch (type) {
5345     case ScrollSnapAxisAlignType::None:
5346         m_value.valueID = CSSValueNone;
5347         break;
5348     case ScrollSnapAxisAlignType::Start:
5349         m_value.valueID = CSSValueStart;
5350         break;
5351     case ScrollSnapAxisAlignType::Center:
5352         m_value.valueID = CSSValueCenter;
5353         break;
5354     case ScrollSnapAxisAlignType::End:
5355         m_value.valueID = CSSValueEnd;
5356         break;
5357     }
5358 }
5359 
5360 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxisAlignType() const
5361 {
5362     ASSERT(isValueID());
5363     switch (m_value.valueID) {
5364     case CSSValueNone:
5365         return ScrollSnapAxisAlignType::None;
5366     case CSSValueStart:
5367         return ScrollSnapAxisAlignType::Start;
5368     case CSSValueCenter:
5369         return ScrollSnapAxisAlignType::Center;
5370     case CSSValueEnd:
5371         return ScrollSnapAxisAlignType::End;
5372     default:
5373         ASSERT_NOT_REACHED();
5374         return ScrollSnapAxisAlignType::None;
5375     }
5376 }
5377 
5378 #endif
5379 
5380 #if ENABLE(CSS_TRAILING_WORD)
5381 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TrailingWord e)
5382     : CSSValue(PrimitiveClass)
5383 {
5384     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5385     switch (e) {
5386     case TrailingWord::Auto:
5387         m_value.valueID = CSSValueAuto;
5388         break;
5389     case TrailingWord::PartiallyBalanced:
5390         m_value.valueID = CSSValueWebkitPartiallyBalanced;
5391         break;
5392     default:
5393         ASSERT_NOT_REACHED();
5394         break;
5395     }
5396 }
5397 
5398 template&lt;&gt; inline CSSPrimitiveValue::operator TrailingWord() const
5399 {
5400     ASSERT(isValueID());
5401     switch (m_value.valueID) {
5402     case CSSValueAuto:
5403         return TrailingWord::Auto;
5404     case CSSValueWebkitPartiallyBalanced:
5405         return TrailingWord::PartiallyBalanced;
5406     default:
5407         break;
5408     }
5409     ASSERT_NOT_REACHED();
5410     return TrailingWord::Auto;
5411 }
5412 #endif
5413 
5414 #if ENABLE(APPLE_PAY)
5415 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonStyle e)
5416     : CSSValue(PrimitiveClass)
5417 {
5418     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5419     switch (e) {
5420     case ApplePayButtonStyle::White:
5421         m_value.valueID = CSSValueWhite;
5422         break;
5423     case ApplePayButtonStyle::WhiteOutline:
5424         m_value.valueID = CSSValueWhiteOutline;
5425         break;
5426     case ApplePayButtonStyle::Black:
5427         m_value.valueID = CSSValueBlack;
5428         break;
5429     default:
5430         ASSERT_NOT_REACHED();
5431         break;
5432     }
5433 }
5434 
5435 template&lt;&gt; inline CSSPrimitiveValue::operator ApplePayButtonStyle() const
5436 {
5437     ASSERT(isValueID());
5438     switch (m_value.valueID) {
5439     case CSSValueWhite:
5440         return ApplePayButtonStyle::White;
5441     case CSSValueWhiteOutline:
5442         return ApplePayButtonStyle::WhiteOutline;
5443     case CSSValueBlack:
5444         return ApplePayButtonStyle::Black;
5445     default:
5446         break;
5447     }
5448     ASSERT_NOT_REACHED();
5449     return ApplePayButtonStyle::Black;
5450 }
5451 
5452 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonType e)
5453     : CSSValue(PrimitiveClass)
5454 {
5455     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5456     switch (e) {
5457     case ApplePayButtonType::Plain:
5458         m_value.valueID = CSSValuePlain;
5459         break;
5460     case ApplePayButtonType::Buy:
5461         m_value.valueID = CSSValueBuy;
5462         break;
5463     case ApplePayButtonType::SetUp:
5464         m_value.valueID = CSSValueSetUp;
5465         break;
5466     case ApplePayButtonType::Donate:
5467         m_value.valueID = CSSValueDonate;
5468         break;
5469 #if ENABLE(APPLE_PAY_SESSION_V4)
5470     case ApplePayButtonType::CheckOut:
5471         m_value.valueID = CSSValueCheckOut;
5472         break;
5473     case ApplePayButtonType::Book:
5474         m_value.valueID = CSSValueBook;
5475         break;
5476     case ApplePayButtonType::Subscribe:
5477         m_value.valueID = CSSValueSubscribe;
5478         break;
5479 #endif
5480 
5481     default:
5482         ASSERT_NOT_REACHED();
5483         break;
5484     }
5485 }
5486 
5487 template&lt;&gt; inline CSSPrimitiveValue::operator ApplePayButtonType() const
5488 {
5489     ASSERT(isValueID());
5490     switch (m_value.valueID) {
5491     case CSSValuePlain:
5492         return ApplePayButtonType::Plain;
5493     case CSSValueBuy:
5494         return ApplePayButtonType::Buy;
5495     case CSSValueSetUp:
5496         return ApplePayButtonType::SetUp;
5497     case CSSValueDonate:
5498         return ApplePayButtonType::Donate;
5499 #if ENABLE(APPLE_PAY_SESSION_V4)
5500     case CSSValueCheckOut:
5501         return ApplePayButtonType::CheckOut;
5502     case CSSValueBook:
5503         return ApplePayButtonType::Book;
5504     case CSSValueSubscribe:
5505         return ApplePayButtonType::Subscribe;
5506 #endif
5507     default:
5508         break;
5509     }
5510     ASSERT_NOT_REACHED();
5511     return ApplePayButtonType::Plain;
5512 }
5513 #endif
5514 
5515 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantPosition position)
5516     : CSSValue(PrimitiveClass)
5517 {
5518     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5519     switch (position) {
5520     case FontVariantPosition::Normal:
5521         m_value.valueID = CSSValueNormal;
5522         break;
5523     case FontVariantPosition::Subscript:
5524         m_value.valueID = CSSValueSub;
5525         break;
5526     case FontVariantPosition::Superscript:
5527         m_value.valueID = CSSValueSuper;
5528         break;
5529     default:
5530         ASSERT_NOT_REACHED();
5531         break;
5532     }
5533 }
5534 
5535 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantPosition() const
5536 {
5537     ASSERT(isValueID());
5538     switch (m_value.valueID) {
5539     case CSSValueNormal:
5540         return FontVariantPosition::Normal;
5541     case CSSValueSub:
5542         return FontVariantPosition::Subscript;
5543     case CSSValueSuper:
5544         return FontVariantPosition::Superscript;
5545     default:
5546         break;
5547     }
5548     ASSERT_NOT_REACHED();
5549     return FontVariantPosition::Normal;
5550 }
5551 
5552 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantCaps caps)
5553     : CSSValue(PrimitiveClass)
5554 {
5555     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5556     switch (caps) {
5557     case FontVariantCaps::Normal:
5558         m_value.valueID = CSSValueNormal;
5559         break;
5560     case FontVariantCaps::Small:
5561         m_value.valueID = CSSValueSmallCaps;
5562         break;
5563     case FontVariantCaps::AllSmall:
5564         m_value.valueID = CSSValueAllSmallCaps;
5565         break;
5566     case FontVariantCaps::Petite:
5567         m_value.valueID = CSSValuePetiteCaps;
5568         break;
5569     case FontVariantCaps::AllPetite:
5570         m_value.valueID = CSSValueAllPetiteCaps;
5571         break;
5572     case FontVariantCaps::Unicase:
5573         m_value.valueID = CSSValueUnicase;
5574         break;
5575     case FontVariantCaps::Titling:
5576         m_value.valueID = CSSValueTitlingCaps;
5577         break;
5578     default:
5579         ASSERT_NOT_REACHED();
5580         break;
5581     }
5582 }
5583 
5584 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantCaps() const
5585 {
5586     ASSERT(isValueID());
5587     switch (m_value.valueID) {
5588     case CSSValueNormal:
5589         return FontVariantCaps::Normal;
5590     case CSSValueSmallCaps:
5591         return FontVariantCaps::Small;
5592     case CSSValueAllSmallCaps:
5593         return FontVariantCaps::AllSmall;
5594     case CSSValuePetiteCaps:
5595         return FontVariantCaps::Petite;
5596     case CSSValueAllPetiteCaps:
5597         return FontVariantCaps::AllPetite;
5598     case CSSValueUnicase:
5599         return FontVariantCaps::Unicase;
5600     case CSSValueTitlingCaps:
5601         return FontVariantCaps::Titling;
5602     default:
5603         break;
5604     }
5605     ASSERT_NOT_REACHED();
5606     return FontVariantCaps::Normal;
5607 }
5608 
5609 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantAlternates alternates)
5610     : CSSValue(PrimitiveClass)
5611 {
5612     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5613     switch (alternates) {
5614     case FontVariantAlternates::Normal:
5615         m_value.valueID = CSSValueNormal;
5616         break;
5617     case FontVariantAlternates::HistoricalForms:
5618         m_value.valueID = CSSValueHistoricalForms;
5619         break;
5620     default:
5621         ASSERT_NOT_REACHED();
5622         break;
5623     }
5624 }
5625 
5626 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantAlternates() const
5627 {
5628     ASSERT(isValueID());
5629     switch (m_value.valueID) {
5630     case CSSValueNormal:
5631         return FontVariantAlternates::Normal;
5632     case CSSValueHistoricalForms:
5633         return FontVariantAlternates::HistoricalForms;
5634     default:
5635         break;
5636     }
5637     ASSERT_NOT_REACHED();
5638     return FontVariantAlternates::Normal;
5639 }
5640 
5641 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontOpticalSizing sizing)
5642     : CSSValue(PrimitiveClass)
5643 {
5644     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5645     switch (sizing) {
5646     case FontOpticalSizing::Enabled:
5647         m_value.valueID = CSSValueAuto;
5648         break;
5649     case FontOpticalSizing::Disabled:
5650         m_value.valueID = CSSValueNone;
5651         break;
5652     default:
5653         ASSERT_NOT_REACHED();
5654         break;
5655     }
5656 }
5657 
5658 template&lt;&gt; inline CSSPrimitiveValue::operator FontOpticalSizing() const
5659 {
5660     ASSERT(isValueID());
5661     switch (m_value.valueID) {
5662     case CSSValueAuto:
5663         return FontOpticalSizing::Enabled;
5664     case CSSValueNone:
5665         return FontOpticalSizing::Disabled;
5666     default:
5667         break;
5668     }
5669     ASSERT_NOT_REACHED();
5670     return FontOpticalSizing::Enabled;
5671 }
5672 
5673 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontLoadingBehavior behavior)
5674     : CSSValue(PrimitiveClass)
5675 {
5676     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);
5677     switch (behavior) {
5678     case FontLoadingBehavior::Auto:
5679         m_value.valueID = CSSValueAuto;
5680         break;
5681     case FontLoadingBehavior::Block:
5682         m_value.valueID = CSSValueBlock;
5683         break;
5684     case FontLoadingBehavior::Swap:
5685         m_value.valueID = CSSValueSwap;
5686         break;
5687     case FontLoadingBehavior::Fallback:
5688         m_value.valueID = CSSValueFallback;
5689         break;
5690     case FontLoadingBehavior::Optional:
5691         m_value.valueID = CSSValueOptional;
5692         break;
5693     default:
5694         ASSERT_NOT_REACHED();
5695         break;
5696     }
5697 }
5698 
5699 template&lt;&gt; inline CSSPrimitiveValue::operator FontLoadingBehavior() const
5700 {
5701     ASSERT(isValueID());
5702     switch (m_value.valueID) {
5703     case CSSValueAuto:
5704         return FontLoadingBehavior::Auto;
5705     case CSSValueBlock:
5706         return FontLoadingBehavior::Block;
5707     case CSSValueSwap:
5708         return FontLoadingBehavior::Swap;
5709     case CSSValueFallback:
5710         return FontLoadingBehavior::Fallback;
5711     case CSSValueOptional:
5712         return FontLoadingBehavior::Optional;
5713     default:
5714         break;
5715     }
5716     ASSERT_NOT_REACHED();
5717     return FontLoadingBehavior::Auto;
5718 }
5719 
5720 }
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WorkerScriptController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WorkerScriptController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WorkerScriptController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WorkerScriptController.cpp
@@ -40,11 +40,11 @@
 #include <JavaScriptCore/Exception.h>
 #include <JavaScriptCore/ExceptionHelpers.h>
 #include <JavaScriptCore/GCActivityCallback.h>
 #include <JavaScriptCore/JSCInlines.h>
 #include <JavaScriptCore/JSLock.h>
-#include <JavaScriptCore/PromiseDeferredTimer.h>
+#include <JavaScriptCore/PromiseTimer.h>
 #include <JavaScriptCore/StrongInlines.h>
 
 namespace WebCore {
 using namespace JSC;
 
@@ -132,26 +132,26 @@
 
     NakedPtr<JSC::Exception> exception;
     evaluate(sourceCode, exception, returnedExceptionMessage);
     if (exception) {
         JSLockHolder lock(vm());
-        reportException(m_workerGlobalScopeWrapper->globalExec(), exception);
+        reportException(m_workerGlobalScopeWrapper.get(), exception);
     }
 }
 
 void WorkerScriptController::evaluate(const ScriptSourceCode& sourceCode, NakedPtr<JSC::Exception>& returnedException, String* returnedExceptionMessage)
 {
     if (isExecutionForbidden())
         return;
 
     initScriptIfNeeded();
 
-    auto& state = *m_workerGlobalScopeWrapper->globalExec();
-    VM& vm = state.vm();
+    auto& globalObject = *m_workerGlobalScopeWrapper.get();
+    VM& vm = globalObject.vm();
     JSLockHolder lock { vm };
 
-    JSExecState::profiledEvaluate(&state, JSC::ProfilingReason::Other, sourceCode.jsSourceCode(), m_workerGlobalScopeWrapper->globalThis(), returnedException);
+    JSExecState::profiledEvaluate(&globalObject, JSC::ProfilingReason::Other, sourceCode.jsSourceCode(), m_workerGlobalScopeWrapper->globalThis(), returnedException);
 
     if ((returnedException && isTerminatedExecutionException(vm, returnedException)) || isTerminatingExecution()) {
         forbidExecution();
         return;
     }
@@ -159,38 +159,38 @@
     if (returnedException) {
         if (m_workerGlobalScope->canIncludeErrorDetails(sourceCode.cachedScript(), sourceCode.url().string())) {
             // FIXME: It's not great that this can run arbitrary code to string-ify the value of the exception.
             // Do we need to do anything to handle that properly, if it, say, raises another exception?
             if (returnedExceptionMessage)
-                *returnedExceptionMessage = returnedException->value().toWTFString(&state);
+                *returnedExceptionMessage = returnedException->value().toWTFString(&globalObject);
         } else {
             // Overwrite the detailed error with a generic error.
             String genericErrorMessage { "Script error."_s };
             if (returnedExceptionMessage)
                 *returnedExceptionMessage = genericErrorMessage;
-            returnedException = JSC::Exception::create(vm, createError(&state, genericErrorMessage));
+            returnedException = JSC::Exception::create(vm, createError(&globalObject, genericErrorMessage));
         }
     }
 }
 
 void WorkerScriptController::setException(JSC::Exception* exception)
 {
-    JSC::ExecState* exec = m_workerGlobalScopeWrapper->globalExec();
-    VM& vm = exec->vm();
+    JSC::JSGlobalObject* lexicalGlobalObject = m_workerGlobalScopeWrapper.get();
+    VM& vm = lexicalGlobalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    throwException(exec, scope, exception);
+    throwException(lexicalGlobalObject, scope, exception);
 }
 
 void WorkerScriptController::scheduleExecutionTermination()
 {
     if (m_isTerminatingExecution)
         return;
 
     {
         // The mutex provides a memory barrier to ensure that once
         // termination is scheduled, isTerminatingExecution() will
-        // accurately reflect that state when called from another thread.
+        // accurately reflect that lexicalGlobalObject when called from another thread.
         LockHolder locker(m_scheduledTerminationMutex);
         m_isTerminatingExecution = true;
     }
     m_vm->notifyNeedTermination();
 }
@@ -248,11 +248,11 @@
         timer->addTimerSetNotification(callback);
     };
 
     processTimer(m_vm->heap.fullActivityCallback());
     processTimer(m_vm->heap.edenActivityCallback());
-    processTimer(m_vm->promiseDeferredTimer.ptr());
+    processTimer(m_vm->promiseTimer.ptr());
 }
 
 void WorkerScriptController::removeTimerSetNotification(JSC::JSRunLoopTimer::TimerNotificationCallback callback)
 {
     auto processTimer = [&] (JSRunLoopTimer* timer) {
@@ -261,20 +261,20 @@
         timer->removeTimerSetNotification(callback);
     };
 
     processTimer(m_vm->heap.fullActivityCallback());
     processTimer(m_vm->heap.edenActivityCallback());
-    processTimer(m_vm->promiseDeferredTimer.ptr());
+    processTimer(m_vm->promiseTimer.ptr());
 }
 
 void WorkerScriptController::attachDebugger(JSC::Debugger* debugger)
 {
     initScriptIfNeeded();
-    debugger->attach(m_workerGlobalScopeWrapper->globalObject());
+    debugger->attach(m_workerGlobalScopeWrapper.get());
 }
 
 void WorkerScriptController::detachDebugger(JSC::Debugger* debugger)
 {
-    debugger->detach(m_workerGlobalScopeWrapper->globalObject(), JSC::Debugger::TerminatingDebuggingSession);
+    debugger->detach(m_workerGlobalScopeWrapper.get(), JSC::Debugger::TerminatingDebuggingSession);
 }
 
 } // namespace WebCore

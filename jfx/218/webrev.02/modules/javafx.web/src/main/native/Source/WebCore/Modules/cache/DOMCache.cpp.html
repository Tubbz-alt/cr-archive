<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/cache/DOMCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DOMCache.h&quot;
 28 
 29 #include &quot;CacheQueryOptions.h&quot;
 30 #include &quot;EventLoop.h&quot;
 31 #include &quot;FetchResponse.h&quot;
 32 #include &quot;HTTPParsers.h&quot;
 33 #include &quot;JSFetchRequest.h&quot;
 34 #include &quot;JSFetchResponse.h&quot;
 35 #include &quot;ReadableStreamChunk.h&quot;
 36 #include &quot;ScriptExecutionContext.h&quot;
 37 #include &lt;wtf/CompletionHandler.h&gt;
 38 #include &lt;wtf/URL.h&gt;
 39 
 40 namespace WebCore {
 41 using namespace WebCore::DOMCacheEngine;
 42 
 43 DOMCache::DOMCache(ScriptExecutionContext&amp; context, String&amp;&amp; name, uint64_t identifier, Ref&lt;CacheStorageConnection&gt;&amp;&amp; connection)
 44     : ActiveDOMObject(&amp;context)
 45     , m_name(WTFMove(name))
 46     , m_identifier(identifier)
 47     , m_connection(WTFMove(connection))
 48 {
 49     suspendIfNeeded();
 50     m_connection-&gt;reference(m_identifier);
 51 }
 52 
 53 DOMCache::~DOMCache()
 54 {
 55     if (!m_isStopped)
 56         m_connection-&gt;dereference(m_identifier);
 57 }
 58 
 59 void DOMCache::match(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 60 {
 61     doMatch(WTFMove(info), WTFMove(options), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;RefPtr&lt;FetchResponse&gt;&gt;&amp;&amp; result) mutable {
 62         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {
 63             if (result.hasException()) {
 64                 promise-&gt;reject(result.releaseException());
 65                 return;
 66             }
 67             if (!result.returnValue()) {
 68                 promise-&gt;resolve();
 69                 return;
 70             }
 71             promise-&gt;resolve&lt;IDLInterface&lt;FetchResponse&gt;&gt;(*result.returnValue());
 72         });
 73     });
 74 }
 75 
 76 void DOMCache::doMatch(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, MatchCallback&amp;&amp; callback)
 77 {
 78     if (UNLIKELY(!scriptExecutionContext()))
 79         return;
 80 
 81     auto requestOrException = requestFromInfo(WTFMove(info), options.ignoreMethod);
 82     if (requestOrException.hasException()) {
 83         callback(nullptr);
 84         return;
 85     }
 86     auto request = requestOrException.releaseReturnValue();
 87 
 88     queryCache(request.get(), WTFMove(options), [this, callback = WTFMove(callback)](ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp; result) mutable {
 89         if (result.hasException()) {
 90             callback(result.releaseException());
 91             return;
 92         }
 93         if (result.returnValue().isEmpty()) {
 94             callback(nullptr);
 95             return;
 96         }
 97         callback(RefPtr&lt;FetchResponse&gt;(result.returnValue()[0].response-&gt;clone(*scriptExecutionContext()).releaseReturnValue()));
 98     });
 99 }
100 
101 Vector&lt;Ref&lt;FetchResponse&gt;&gt; DOMCache::cloneResponses(const Vector&lt;CacheStorageRecord&gt;&amp; records)
102 {
103     auto&amp; context = *scriptExecutionContext();
104     return WTF::map(records, [&amp;context] (const auto&amp; record) {
105         return record.response-&gt;clone(context).releaseReturnValue();
106     });
107 }
108 
109 void DOMCache::matchAll(Optional&lt;RequestInfo&gt;&amp;&amp; info, CacheQueryOptions&amp;&amp; options, MatchAllPromise&amp;&amp; promise)
110 {
111     if (UNLIKELY(!scriptExecutionContext()))
112         return;
113 
114     RefPtr&lt;FetchRequest&gt; request;
115     if (info) {
116         auto requestOrException = requestFromInfo(WTFMove(info.value()), options.ignoreMethod);
117         if (requestOrException.hasException()) {
118             promise.resolve({ });
119             return;
120         }
121         request = requestOrException.releaseReturnValue();
122     }
123 
124     if (!request) {
125         retrieveRecords(URL { }, [this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
126             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), exception = WTFMove(exception)]() mutable {
127                 if (exception) {
128                     promise.reject(WTFMove(exception.value()));
129                     return;
130                 }
131                 promise.resolve(cloneResponses(m_records));
132             });
133         });
134         return;
135     }
136     queryCache(request.releaseNonNull(), WTFMove(options), [this, promise = WTFMove(promise)](ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp; result) mutable {
137         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), result = WTFMove(result)]() mutable {
138             if (result.hasException()) {
139                 promise.reject(result.releaseException());
140                 return;
141             }
142             promise.resolve(cloneResponses(result.releaseReturnValue()));
143         });
144     });
145 }
146 
147 void DOMCache::add(RequestInfo&amp;&amp; info, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
148 {
149     addAll(Vector&lt;RequestInfo&gt; { WTFMove(info) }, WTFMove(promise));
150 }
151 
152 static inline bool hasResponseVaryStarHeaderValue(const FetchResponse&amp; response)
153 {
154     auto varyValue = response.headers().internalHeaders().get(WebCore::HTTPHeaderName::Vary);
155     bool hasStar = false;
156     varyValue.split(&#39;,&#39;, [&amp;](StringView view) {
157         if (!hasStar &amp;&amp; stripLeadingAndTrailingHTTPSpaces(view) == &quot;*&quot;)
158             hasStar = true;
159     });
160     return hasStar;
161 }
162 
163 class FetchTasksHandler : public RefCounted&lt;FetchTasksHandler&gt; {
164 public:
165     static Ref&lt;FetchTasksHandler&gt; create(Ref&lt;DOMCache&gt;&amp;&amp; domCache, CompletionHandler&lt;void(ExceptionOr&lt;Vector&lt;Record&gt;&gt;&amp;&amp;)&gt;&amp;&amp; callback) { return adoptRef(*new FetchTasksHandler(WTFMove(domCache), WTFMove(callback))); }
166 
167     ~FetchTasksHandler()
168     {
169         if (m_callback)
170             m_callback(WTFMove(m_records));
171     }
172 
173     const Vector&lt;Record&gt;&amp; records() const { return m_records; }
174 
175     size_t addRecord(Record&amp;&amp; record)
176     {
177         ASSERT(!isDone());
178         m_records.append(WTFMove(record));
179         return m_records.size() - 1;
180     }
181 
182     void addResponseBody(size_t position, FetchResponse&amp; response, DOMCacheEngine::ResponseBody&amp;&amp; data)
183     {
184         ASSERT(!isDone());
185         auto&amp; record = m_records[position];
186         record.responseBodySize = m_domCache-&gt;connection().computeRecordBodySize(response, data);
187         record.responseBody = WTFMove(data);
188     }
189 
190     bool isDone() const { return !m_callback; }
191 
192     void error(Exception&amp;&amp; exception)
193     {
194         if (auto callback = WTFMove(m_callback))
195             callback(WTFMove(exception));
196     }
197 
198 private:
199     FetchTasksHandler(Ref&lt;DOMCache&gt;&amp;&amp; domCache, CompletionHandler&lt;void(ExceptionOr&lt;Vector&lt;Record&gt;&gt;&amp;&amp;)&gt;&amp;&amp; callback)
200         : m_domCache(WTFMove(domCache))
201         , m_callback(WTFMove(callback))
202     {
203     }
204 
205     Ref&lt;DOMCache&gt; m_domCache;
206     Vector&lt;Record&gt; m_records;
207     CompletionHandler&lt;void(ExceptionOr&lt;Vector&lt;Record&gt;&gt;&amp;&amp;)&gt; m_callback;
208 };
209 
210 ExceptionOr&lt;Ref&lt;FetchRequest&gt;&gt; DOMCache::requestFromInfo(RequestInfo&amp;&amp; info, bool ignoreMethod)
211 {
212     RefPtr&lt;FetchRequest&gt; request;
213     if (WTF::holds_alternative&lt;RefPtr&lt;FetchRequest&gt;&gt;(info)) {
214         request = WTF::get&lt;RefPtr&lt;FetchRequest&gt;&gt;(info).releaseNonNull();
215         if (request-&gt;method() != &quot;GET&quot; &amp;&amp; !ignoreMethod)
216             return Exception { TypeError, &quot;Request method is not GET&quot;_s };
217     } else
218         request = FetchRequest::create(*scriptExecutionContext(), WTFMove(info), { }).releaseReturnValue();
219 
220     if (!protocolIsInHTTPFamily(request-&gt;url()))
221         return Exception { TypeError, &quot;Request url is not HTTP/HTTPS&quot;_s };
222 
223     return request.releaseNonNull();
224 }
225 
226 void DOMCache::addAll(Vector&lt;RequestInfo&gt;&amp;&amp; infos, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
227 {
228     if (UNLIKELY(!scriptExecutionContext()))
229         return;
230 
231     Vector&lt;Ref&lt;FetchRequest&gt;&gt; requests;
232     requests.reserveInitialCapacity(infos.size());
233     for (auto&amp; info : infos) {
234         bool ignoreMethod = false;
235         auto requestOrException = requestFromInfo(WTFMove(info), ignoreMethod);
236         if (requestOrException.hasException()) {
237             promise.reject(requestOrException.releaseException());
238             return;
239         }
240         requests.uncheckedAppend(requestOrException.releaseReturnValue());
241     }
242 
243     auto taskHandler = FetchTasksHandler::create(*this, [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;Vector&lt;Record&gt;&gt;&amp;&amp; result) mutable {
244         if (result.hasException()) {
245             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception = result.releaseException()]() mutable {
246                 promise.reject(WTFMove(exception));
247             });
248             return;
249         }
250         batchPutOperation(result.releaseReturnValue(), [this, protectedThis = WTFMove(protectedThis), promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {
251             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {
252                 promise.settle(WTFMove(result));
253             });
254         });
255     });
256 
257     for (auto&amp; request : requests) {
258         auto&amp; requestReference = request.get();
259         FetchResponse::fetch(*scriptExecutionContext(), requestReference, [this, request = WTFMove(request), taskHandler = taskHandler.copyRef()](ExceptionOr&lt;FetchResponse&amp;&gt;&amp;&amp; result) mutable {
260 
261             if (taskHandler-&gt;isDone())
262                 return;
263 
264             if (result.hasException()) {
265                 taskHandler-&gt;error(result.releaseException());
266                 return;
267             }
268 
269             auto&amp; response = result.releaseReturnValue();
270 
271             if (!response.ok()) {
272                 taskHandler-&gt;error(Exception { TypeError, &quot;Response is not OK&quot;_s });
273                 return;
274             }
275 
276             if (hasResponseVaryStarHeaderValue(response)) {
277                 taskHandler-&gt;error(Exception { TypeError, &quot;Response has a &#39;*&#39; Vary header value&quot;_s });
278                 return;
279             }
280 
281             if (response.status() == 206) {
282                 taskHandler-&gt;error(Exception { TypeError, &quot;Response is a 206 partial&quot;_s });
283                 return;
284             }
285 
286             CacheQueryOptions options;
287             for (const auto&amp; record : taskHandler-&gt;records()) {
288                 if (DOMCacheEngine::queryCacheMatch(request-&gt;resourceRequest(), record.request, record.response, options)) {
289                     taskHandler-&gt;error(Exception { InvalidStateError, &quot;addAll cannot store several matching requests&quot;_s});
290                     return;
291                 }
292             }
293             size_t recordPosition = taskHandler-&gt;addRecord(toConnectionRecord(request.get(), response, nullptr));
294 
295             response.consumeBodyReceivedByChunk([taskHandler = WTFMove(taskHandler), recordPosition, data = SharedBuffer::create(), response = makeRef(response)] (ExceptionOr&lt;ReadableStreamChunk*&gt;&amp;&amp; result) mutable {
296                 if (taskHandler-&gt;isDone())
297                     return;
298 
299                 if (result.hasException()) {
300                     taskHandler-&gt;error(result.releaseException());
301                     return;
302                 }
303 
304                 if (auto chunk = result.returnValue())
305                     data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
306                 else
307                     taskHandler-&gt;addResponseBody(recordPosition, response, WTFMove(data));
308             });
309         });
310     }
311 }
312 
313 void DOMCache::putWithResponseData(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise, Ref&lt;FetchRequest&gt;&amp;&amp; request, Ref&lt;FetchResponse&gt;&amp;&amp; response, ExceptionOr&lt;RefPtr&lt;SharedBuffer&gt;&gt;&amp;&amp; responseBody)
314 {
315     if (responseBody.hasException()) {
316         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), exception = responseBody.releaseException()]() mutable {
317             promise.reject(WTFMove(exception));
318         });
319         return;
320     }
321 
322     DOMCacheEngine::ResponseBody body;
323     if (auto buffer = responseBody.releaseReturnValue())
324         body = buffer.releaseNonNull();
325     batchPutOperation(request.get(), response.get(), WTFMove(body), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {
326         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {
327             promise.settle(WTFMove(result));
328         });
329     });
330 }
331 
332 void DOMCache::put(RequestInfo&amp;&amp; info, Ref&lt;FetchResponse&gt;&amp;&amp; response, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
333 {
334     if (UNLIKELY(!scriptExecutionContext()))
335         return;
336 
337     bool ignoreMethod = false;
338     auto requestOrException = requestFromInfo(WTFMove(info), ignoreMethod);
339     if (requestOrException.hasException()) {
340         promise.reject(requestOrException.releaseException());
341         return;
342     }
343     auto request = requestOrException.releaseReturnValue();
344 
345     if (auto exception = response-&gt;loadingException()) {
346         promise.reject(*exception);
347         return;
348     }
349 
350     if (hasResponseVaryStarHeaderValue(response.get())) {
351         promise.reject(Exception { TypeError, &quot;Response has a &#39;*&#39; Vary header value&quot;_s });
352         return;
353     }
354 
355     if (response-&gt;status() == 206) {
356         promise.reject(Exception { TypeError, &quot;Response is a 206 partial&quot;_s });
357         return;
358     }
359 
360     if (response-&gt;isDisturbedOrLocked()) {
361         promise.reject(Exception { TypeError, &quot;Response is disturbed or locked&quot;_s });
362         return;
363     }
364 
365     if (response-&gt;isBlobFormData()) {
366         promise.reject(Exception { NotSupportedError, &quot;Not implemented&quot;_s });
367         return;
368     }
369 
370     // FIXME: for efficiency, we should load blobs directly instead of going through the readableStream path.
371     if (response-&gt;isBlobBody())
372         response-&gt;readableStream(*scriptExecutionContext()-&gt;execState());
373 
374     if (response-&gt;isBodyReceivedByChunk()) {
375         auto&amp; responseRef = response.get();
376         responseRef.consumeBodyReceivedByChunk([promise = WTFMove(promise), request = WTFMove(request), response = WTFMove(response), data = SharedBuffer::create(), pendingActivity = makePendingActivity(*this), this](auto&amp;&amp; result) mutable {
377 
378             if (result.hasException()) {
379                 this-&gt;putWithResponseData(WTFMove(promise), WTFMove(request), WTFMove(response), result.releaseException().isolatedCopy());
380                 return;
381             }
382 
383             if (auto chunk = result.returnValue())
384                 data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
385             else
386                 this-&gt;putWithResponseData(WTFMove(promise), WTFMove(request), WTFMove(response), RefPtr&lt;SharedBuffer&gt; { WTFMove(data) });
387         });
388         return;
389     }
390 
391     batchPutOperation(request.get(), response.get(), response-&gt;consumeBody(), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;void&gt;&amp;&amp; result) mutable {
392         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {
393             promise.settle(WTFMove(result));
394         });
395     });
396 }
397 
398 void DOMCache::remove(RequestInfo&amp;&amp; info, CacheQueryOptions&amp;&amp; options, DOMPromiseDeferred&lt;IDLBoolean&gt;&amp;&amp; promise)
399 {
400     if (UNLIKELY(!scriptExecutionContext()))
401         return;
402 
403     auto requestOrException = requestFromInfo(WTFMove(info), options.ignoreMethod);
404     if (requestOrException.hasException()) {
405         promise.resolve(false);
406         return;
407     }
408 
409     batchDeleteOperation(requestOrException.releaseReturnValue(), WTFMove(options), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](ExceptionOr&lt;bool&gt;&amp;&amp; result) mutable {
410         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {
411             promise.settle(WTFMove(result));
412         });
413     });
414 }
415 
416 static inline Ref&lt;FetchRequest&gt; copyRequestRef(const CacheStorageRecord&amp; record)
417 {
418     return record.request.copyRef();
419 }
420 
421 void DOMCache::keys(Optional&lt;RequestInfo&gt;&amp;&amp; info, CacheQueryOptions&amp;&amp; options, KeysPromise&amp;&amp; promise)
422 {
423     if (UNLIKELY(!scriptExecutionContext()))
424         return;
425 
426     RefPtr&lt;FetchRequest&gt; request;
427     if (info) {
428         auto requestOrException = requestFromInfo(WTFMove(info.value()), options.ignoreMethod);
429         if (requestOrException.hasException()) {
430             promise.resolve(Vector&lt;Ref&lt;FetchRequest&gt;&gt; { });
431             return;
432         }
433         request = requestOrException.releaseReturnValue();
434     }
435 
436     if (!request) {
437         retrieveRecords(URL { }, [this, promise = WTFMove(promise)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
438             queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [this, promise = WTFMove(promise), exception = WTFMove(exception)]() mutable {
439                 if (exception) {
440                     promise.reject(WTFMove(exception.value()));
441                     return;
442                 }
443                 promise.resolve(WTF::map(m_records, copyRequestRef));
444             });
445         });
446         return;
447     }
448 
449     queryCache(request.releaseNonNull(), WTFMove(options), [this, protectedThis = makeRef(*this), promise = WTFMove(promise)](auto&amp;&amp; result) mutable {
450         queueTaskKeepingObjectAlive(*this, TaskSource::DOMManipulation, [promise = WTFMove(promise), result = WTFMove(result)]() mutable {
451             if (result.hasException()) {
452                 promise.reject(result.releaseException());
453                 return;
454             }
455 
456             promise.resolve(WTF::map(result.releaseReturnValue(), copyRequestRef));
457         });
458     });
459 }
460 
461 void DOMCache::retrieveRecords(const URL&amp; url, WTF::Function&lt;void(Optional&lt;Exception&gt;&amp;&amp;)&gt;&amp;&amp; callback)
462 {
463     URL retrieveURL = url;
464     retrieveURL.removeQueryAndFragmentIdentifier();
465 
466     m_connection-&gt;retrieveRecords(m_identifier, retrieveURL, [this, pendingActivity = makePendingActivity(*this), callback = WTFMove(callback)](RecordsOrError&amp;&amp; result) {
467         if (m_isStopped)
468             return;
469 
470         if (!result.has_value()) {
471             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
472             return;
473         }
474 
475         updateRecords(WTFMove(result.value()));
476         callback(WTF::nullopt);
477     });
478 }
479 
480 void DOMCache::queryCache(Ref&lt;FetchRequest&gt;&amp;&amp; request, CacheQueryOptions&amp;&amp; options, WTF::Function&lt;void(ExceptionOr&lt;Vector&lt;CacheStorageRecord&gt;&gt;&amp;&amp;)&gt;&amp;&amp; callback)
481 {
482     auto url = request-&gt;url();
483     retrieveRecords(url, [this, request = WTFMove(request), options = WTFMove(options), callback = WTFMove(callback)](Optional&lt;Exception&gt;&amp;&amp; exception) mutable {
484         if (exception) {
485             callback(WTFMove(exception.value()));
486             return;
487         }
488         callback(queryCacheWithTargetStorage(request.get(), options, m_records));
489     });
490 }
491 
492 static inline bool queryCacheMatch(const FetchRequest&amp; request, const FetchRequest&amp; cachedRequest, const ResourceResponse&amp; cachedResponse, const CacheQueryOptions&amp; options)
493 {
494     // We need to pass the resource request with all correct headers hence why we call resourceRequest().
495     return DOMCacheEngine::queryCacheMatch(request.resourceRequest(), cachedRequest.resourceRequest(), cachedResponse, options);
496 }
497 
498 Vector&lt;CacheStorageRecord&gt; DOMCache::queryCacheWithTargetStorage(const FetchRequest&amp; request, const CacheQueryOptions&amp; options, const Vector&lt;CacheStorageRecord&gt;&amp; targetStorage)
499 {
500     if (!options.ignoreMethod &amp;&amp; request.method() != &quot;GET&quot;)
501         return { };
502 
503     Vector&lt;CacheStorageRecord&gt; records;
504     for (auto&amp; record : targetStorage) {
505         if (queryCacheMatch(request, record.request.get(), record.response-&gt;resourceResponse(), options))
506             records.append({ record.identifier, record.updateResponseCounter, record.request.copyRef(), record.response.copyRef() });
507     }
508     return records;
509 }
510 
511 void DOMCache::batchDeleteOperation(const FetchRequest&amp; request, CacheQueryOptions&amp;&amp; options, WTF::Function&lt;void(ExceptionOr&lt;bool&gt;&amp;&amp;)&gt;&amp;&amp; callback)
512 {
513     m_connection-&gt;batchDeleteOperation(m_identifier, request.internalRequest(), WTFMove(options), [this, pendingActivity = makePendingActivity(*this), callback = WTFMove(callback)](RecordIdentifiersOrError&amp;&amp; result) {
514         if (m_isStopped)
515             return;
516 
517         if (!result.has_value()) {
518             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
519             return;
520         }
521         callback(!result.value().isEmpty());
522     });
523 }
524 
525 Record DOMCache::toConnectionRecord(const FetchRequest&amp; request, FetchResponse&amp; response, DOMCacheEngine::ResponseBody&amp;&amp; responseBody)
526 {
527     auto cachedResponse = response.resourceResponse();
528     ResourceRequest cachedRequest = request.internalRequest();
529     cachedRequest.setHTTPHeaderFields(request.headers().internalHeaders());
530 
531     ASSERT(!cachedRequest.isNull());
532     ASSERT(!cachedResponse.isNull());
533 
534     auto sizeWithPadding = response.bodySizeWithPadding();
535     if (!sizeWithPadding) {
536         sizeWithPadding = m_connection-&gt;computeRecordBodySize(response, responseBody);
537         response.setBodySizeWithPadding(sizeWithPadding);
538     }
539 
540     return { 0, 0,
541         request.headers().guard(), WTFMove(cachedRequest), request.fetchOptions(), request.internalRequestReferrer(),
542         response.headers().guard(), WTFMove(cachedResponse), WTFMove(responseBody), sizeWithPadding
543     };
544 }
545 
546 void DOMCache::batchPutOperation(const FetchRequest&amp; request, FetchResponse&amp; response, DOMCacheEngine::ResponseBody&amp;&amp; responseBody, WTF::Function&lt;void(ExceptionOr&lt;void&gt;&amp;&amp;)&gt;&amp;&amp; callback)
547 {
548     Vector&lt;Record&gt; records;
549     records.append(toConnectionRecord(request, response, WTFMove(responseBody)));
550 
551     batchPutOperation(WTFMove(records), WTFMove(callback));
552 }
553 
554 void DOMCache::batchPutOperation(Vector&lt;Record&gt;&amp;&amp; records, WTF::Function&lt;void(ExceptionOr&lt;void&gt;&amp;&amp;)&gt;&amp;&amp; callback)
555 {
556     m_connection-&gt;batchPutOperation(m_identifier, WTFMove(records), [this, pendingActivity = makePendingActivity(*this), callback = WTFMove(callback)](RecordIdentifiersOrError&amp;&amp; result) {
557         if (m_isStopped)
558             return;
559         if (!result.has_value()) {
560             callback(DOMCacheEngine::convertToExceptionAndLog(scriptExecutionContext(), result.error()));
561             return;
562         }
563         callback({ });
564     });
565 }
566 
567 void DOMCache::updateRecords(Vector&lt;Record&gt;&amp;&amp; records)
568 {
569     ASSERT(scriptExecutionContext());
570     Vector&lt;CacheStorageRecord&gt; newRecords;
571 
572     for (auto&amp; record : records) {
573         size_t index = m_records.findMatching([&amp;](const auto&amp; item) { return item.identifier == record.identifier; });
574         if (index != notFound) {
575             auto&amp; current = m_records[index];
576             if (current.updateResponseCounter != record.updateResponseCounter) {
577                 record.response.setSource(ResourceResponse::Source::DOMCache);
578                 auto response = FetchResponse::create(*scriptExecutionContext(), WTF::nullopt, record.responseHeadersGuard, WTFMove(record.response));
579                 response-&gt;setBodyData(WTFMove(record.responseBody), record.responseBodySize);
580 
581                 current.response = WTFMove(response);
582                 current.updateResponseCounter = record.updateResponseCounter;
583             }
584             newRecords.append(WTFMove(current));
585         } else {
586             auto requestHeaders = FetchHeaders::create(record.requestHeadersGuard, HTTPHeaderMap { record.request.httpHeaderFields() });
587             auto request = FetchRequest::create(*scriptExecutionContext(), WTF::nullopt, WTFMove(requestHeaders),  WTFMove(record.request), WTFMove(record.options), WTFMove(record.referrer));
588 
589             record.response.setSource(ResourceResponse::Source::DOMCache);
590             auto response = FetchResponse::create(*scriptExecutionContext(), WTF::nullopt, record.responseHeadersGuard, WTFMove(record.response));
591             response-&gt;setBodyData(WTFMove(record.responseBody), record.responseBodySize);
592 
593             newRecords.append(CacheStorageRecord { record.identifier, record.updateResponseCounter, WTFMove(request), WTFMove(response) });
594         }
595     }
596     m_records = WTFMove(newRecords);
597 }
598 
599 void DOMCache::stop()
600 {
601     if (m_isStopped)
602         return;
603     m_isStopped = true;
604     m_connection-&gt;dereference(m_identifier);
605 }
606 
607 const char* DOMCache::activeDOMObjectName() const
608 {
609     return &quot;Cache&quot;;
610 }
611 
612 } // namespace WebCore
    </pre>
  </body>
</html>
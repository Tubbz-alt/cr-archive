<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGVariableEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableEventStream.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2012-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,20 ***</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;DFGJITCode.h&quot;
  #include &quot;DFGValueSource.h&quot;
  #include &quot;InlineCallFrame.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/HashMap.h&gt;
  
  namespace JSC { namespace DFG {
  
  void VariableEventStream::logEvent(const VariableEvent&amp; event)
  {
      dataLogF(&quot;seq#%u:&quot;, static_cast&lt;unsigned&gt;(size()));
      event.dump(WTF::dataFile());
<span class="line-modified">!     dataLogF(&quot; &quot;);</span>
  }
  
  namespace {
  
  struct MinifiedGenerationInfo {
<span class="line-new-header">--- 31,21 ---</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;DFGJITCode.h&quot;
  #include &quot;DFGValueSource.h&quot;
  #include &quot;InlineCallFrame.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="line-added">+ #include &quot;OperandsInlines.h&quot;</span>
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/HashMap.h&gt;
  
  namespace JSC { namespace DFG {
  
  void VariableEventStream::logEvent(const VariableEvent&amp; event)
  {
      dataLogF(&quot;seq#%u:&quot;, static_cast&lt;unsigned&gt;(size()));
      event.dump(WTF::dataFile());
<span class="line-modified">!     dataLogLn(&quot; &quot;);</span>
  }
  
  namespace {
  
  struct MinifiedGenerationInfo {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,68 ***</span>
  template&lt;VariableEventStream::ReconstructionStyle style&gt;
  unsigned VariableEventStream::reconstruct(
      CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
      unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries, Vector&lt;UndefinedOperandSpan&gt;* undefinedOperandSpans) const
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
      CodeBlock* baselineCodeBlock = codeBlock-&gt;baselineVersion();
  
      unsigned numVariables;
<span class="line-modified">!     static const unsigned invalidIndex = std::numeric_limits&lt;unsigned&gt;::max();</span>
      unsigned firstUndefined = invalidIndex;
      bool firstUndefinedIsArgument = false;
  
      auto flushUndefinedOperandSpan = [&amp;] (unsigned i) {
          if (firstUndefined == invalidIndex)
              return;
<span class="line-modified">!         int firstOffset = valueRecoveries.virtualRegisterForIndex(firstUndefined).offset();</span>
<span class="line-modified">!         int lastOffset = valueRecoveries.virtualRegisterForIndex(i - 1).offset();</span>
          int minOffset = std::min(firstOffset, lastOffset);
          undefinedOperandSpans-&gt;append({ firstUndefined, minOffset, i - firstUndefined });
          firstUndefined = invalidIndex;
      };
      auto recordUndefinedOperand = [&amp;] (unsigned i) {
          // We want to separate the span of arguments from the span of locals even if they have adjacent operands indexes.
<span class="line-modified">!         if (firstUndefined != invalidIndex &amp;&amp; firstUndefinedIsArgument != valueRecoveries.isArgument(i))</span>
              flushUndefinedOperandSpan(i);
  
          if (firstUndefined == invalidIndex) {
              firstUndefined = i;
<span class="line-modified">!             firstUndefinedIsArgument = valueRecoveries.isArgument(i);</span>
          }
      };
  
      auto* inlineCallFrame = codeOrigin.inlineCallFrame();
<span class="line-modified">!     if (inlineCallFrame)</span>
<span class="line-modified">!         numVariables = baselineCodeBlockForInlineCallFrame(inlineCallFrame)-&gt;numCalleeLocals() + VirtualRegister(inlineCallFrame-&gt;stackOffset).toLocal() + 1;</span>
<span class="line-modified">!     else</span>
          numVariables = baselineCodeBlock-&gt;numCalleeLocals();
  
      // Crazy special case: if we&#39;re at index == 0 then this must be an argument check
      // failure, in which case all variables are already set up. The recoveries should
      // reflect this.
      if (!index) {
<span class="line-modified">!         valueRecoveries = Operands&lt;ValueRecovery&gt;(codeBlock-&gt;numParameters(), numVariables);</span>
          for (size_t i = 0; i &lt; valueRecoveries.size(); ++i) {
              valueRecoveries[i] = ValueRecovery::displacedInJSStack(
<span class="line-modified">!                 VirtualRegister(valueRecoveries.operandForIndex(i)), DataFormatJS);</span>
          }
          return numVariables;
      }
  
      // Step 1: Find the last checkpoint, and figure out the number of virtual registers as we go.
      unsigned startIndex = index - 1;
      while (at(startIndex).kind() != Reset)
          startIndex--;
  
      // Step 2: Create a mock-up of the DFG&#39;s state and execute the events.
<span class="line-modified">!     Operands&lt;ValueSource&gt; operandSources(codeBlock-&gt;numParameters(), numVariables);</span>
      for (unsigned i = operandSources.size(); i--;)
          operandSources[i] = ValueSource(SourceIsDead);
      HashMap&lt;MinifiedID, MinifiedGenerationInfo&gt; generationInfos;
      for (unsigned i = startIndex; i &lt; index; ++i) {
          const VariableEvent&amp; event = at(i);
          switch (event.kind()) {
          case Reset:
              // nothing to do.
              break;
          case BirthToFill:
<span class="line-new-header">--- 118,76 ---</span>
  template&lt;VariableEventStream::ReconstructionStyle style&gt;
  unsigned VariableEventStream::reconstruct(
      CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph&amp; graph,
      unsigned index, Operands&lt;ValueRecovery&gt;&amp; valueRecoveries, Vector&lt;UndefinedOperandSpan&gt;* undefinedOperandSpans) const
  {
<span class="line-added">+     constexpr bool verbose = false;</span>
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
      CodeBlock* baselineCodeBlock = codeBlock-&gt;baselineVersion();
  
      unsigned numVariables;
<span class="line-modified">!     unsigned numTmps;</span>
<span class="line-added">+     static constexpr unsigned invalidIndex = std::numeric_limits&lt;unsigned&gt;::max();</span>
      unsigned firstUndefined = invalidIndex;
      bool firstUndefinedIsArgument = false;
  
      auto flushUndefinedOperandSpan = [&amp;] (unsigned i) {
          if (firstUndefined == invalidIndex)
              return;
<span class="line-modified">!         int firstOffset = valueRecoveries.operandForIndex(firstUndefined).virtualRegister().offset();</span>
<span class="line-modified">!         int lastOffset = valueRecoveries.operandForIndex(i - 1).virtualRegister().offset();</span>
          int minOffset = std::min(firstOffset, lastOffset);
          undefinedOperandSpans-&gt;append({ firstUndefined, minOffset, i - firstUndefined });
          firstUndefined = invalidIndex;
      };
      auto recordUndefinedOperand = [&amp;] (unsigned i) {
          // We want to separate the span of arguments from the span of locals even if they have adjacent operands indexes.
<span class="line-modified">!         if (firstUndefined != invalidIndex &amp;&amp; firstUndefinedIsArgument != valueRecoveries.operandForIndex(i).isArgument())</span>
              flushUndefinedOperandSpan(i);
  
          if (firstUndefined == invalidIndex) {
              firstUndefined = i;
<span class="line-modified">!             firstUndefinedIsArgument = valueRecoveries.operandForIndex(i).isArgument();</span>
          }
      };
  
      auto* inlineCallFrame = codeOrigin.inlineCallFrame();
<span class="line-modified">!     if (inlineCallFrame) {</span>
<span class="line-modified">!         CodeBlock* codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);</span>
<span class="line-modified">!         numVariables = codeBlock-&gt;numCalleeLocals() + VirtualRegister(inlineCallFrame-&gt;stackOffset).toLocal() + 1;</span>
<span class="line-added">+         numTmps = codeBlock-&gt;numTmps() + inlineCallFrame-&gt;tmpOffset;</span>
<span class="line-added">+     } else {</span>
          numVariables = baselineCodeBlock-&gt;numCalleeLocals();
<span class="line-added">+         numTmps = baselineCodeBlock-&gt;numTmps();</span>
<span class="line-added">+     }</span>
  
      // Crazy special case: if we&#39;re at index == 0 then this must be an argument check
      // failure, in which case all variables are already set up. The recoveries should
      // reflect this.
      if (!index) {
<span class="line-modified">!         // We don&#39;t include tmps here because they can&#39;t be used yet.</span>
<span class="line-added">+         valueRecoveries = Operands&lt;ValueRecovery&gt;(codeBlock-&gt;numParameters(), numVariables, 0);</span>
          for (size_t i = 0; i &lt; valueRecoveries.size(); ++i) {
              valueRecoveries[i] = ValueRecovery::displacedInJSStack(
<span class="line-modified">!                 valueRecoveries.operandForIndex(i).virtualRegister(), DataFormatJS);</span>
          }
          return numVariables;
      }
  
      // Step 1: Find the last checkpoint, and figure out the number of virtual registers as we go.
      unsigned startIndex = index - 1;
      while (at(startIndex).kind() != Reset)
          startIndex--;
  
      // Step 2: Create a mock-up of the DFG&#39;s state and execute the events.
<span class="line-modified">!     Operands&lt;ValueSource&gt; operandSources(codeBlock-&gt;numParameters(), numVariables, numTmps);</span>
      for (unsigned i = operandSources.size(); i--;)
          operandSources[i] = ValueSource(SourceIsDead);
      HashMap&lt;MinifiedID, MinifiedGenerationInfo&gt; generationInfos;
      for (unsigned i = startIndex; i &lt; index; ++i) {
          const VariableEvent&amp; event = at(i);
<span class="line-added">+         dataLogLnIf(verbose, &quot;Processing event &quot;, event);</span>
          switch (event.kind()) {
          case Reset:
              // nothing to do.
              break;
          case BirthToFill:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 196,25 ***</span>
              ASSERT(iter != generationInfos.end());
              iter-&gt;value.update(event);
              break;
          }
          case MovHintEvent:
<span class="line-modified">!             if (operandSources.hasOperand(event.bytecodeRegister()))</span>
<span class="line-modified">!                 operandSources.setOperand(event.bytecodeRegister(), ValueSource(event.id()));</span>
              break;
          case SetLocalEvent:
<span class="line-modified">!             if (operandSources.hasOperand(event.bytecodeRegister()))</span>
<span class="line-modified">!                 operandSources.setOperand(event.bytecodeRegister(), ValueSource::forDataFormat(event.machineRegister(), event.dataFormat()));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
      }
  
      // Step 3: Compute value recoveries!
<span class="line-modified">!     valueRecoveries = Operands&lt;ValueRecovery&gt;(codeBlock-&gt;numParameters(), numVariables);</span>
      for (unsigned i = 0; i &lt; operandSources.size(); ++i) {
          ValueSource&amp; source = operandSources[i];
          if (source.isTriviallyRecoverable()) {
              valueRecoveries[i] = source.valueRecovery();
              if (style == ReconstructionStyle::Separated) {
<span class="line-new-header">--- 205,27 ---</span>
              ASSERT(iter != generationInfos.end());
              iter-&gt;value.update(event);
              break;
          }
          case MovHintEvent:
<span class="line-modified">!             if (operandSources.hasOperand(event.operand()))</span>
<span class="line-modified">!                 operandSources.setOperand(event.operand(), ValueSource(event.id()));</span>
              break;
          case SetLocalEvent:
<span class="line-modified">!             if (operandSources.hasOperand(event.operand()))</span>
<span class="line-modified">!                 operandSources.setOperand(event.operand(), ValueSource::forDataFormat(event.machineRegister(), event.dataFormat()));</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
      }
  
<span class="line-added">+     dataLogLnIf(verbose, &quot;Operand sources: &quot;, operandSources);</span>
<span class="line-added">+ </span>
      // Step 3: Compute value recoveries!
<span class="line-modified">!     valueRecoveries = Operands&lt;ValueRecovery&gt;(OperandsLike, operandSources);</span>
      for (unsigned i = 0; i &lt; operandSources.size(); ++i) {
          ValueSource&amp; source = operandSources[i];
          if (source.isTriviallyRecoverable()) {
              valueRecoveries[i] = source.valueRecovery();
              if (style == ReconstructionStyle::Separated) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,17 ***</span>
<span class="line-new-header">--- 239,19 ---</span>
  
          ASSERT(source.kind() == HaveNode);
          MinifiedNode* node = graph.at(source.id());
          MinifiedGenerationInfo info = generationInfos.get(source.id());
          if (!info.alive) {
<span class="line-added">+             dataLogLnIf(verbose, &quot;Operand &quot;, valueRecoveries.operandForIndex(i), &quot; is dead.&quot;);</span>
              valueRecoveries[i] = ValueRecovery::constant(jsUndefined());
              if (style == ReconstructionStyle::Separated)
                  recordUndefinedOperand(i);
              continue;
          }
  
          if (tryToSetConstantRecovery(valueRecoveries[i], node)) {
<span class="line-added">+             dataLogLnIf(verbose, &quot;Operand &quot;, valueRecoveries.operandForIndex(i), &quot; is constant.&quot;);</span>
              if (style == ReconstructionStyle::Separated) {
                  if (node-&gt;hasConstant() &amp;&amp; node-&gt;constant() == jsUndefined())
                      recordUndefinedOperand(i);
                  else
                      flushUndefinedOperandSpan(i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,11 ***</span>
              valueRecoveries[i] = ValueRecovery::inGPR(info.u.gpr, info.format);
              continue;
          }
  
          valueRecoveries[i] =
<span class="line-modified">!             ValueRecovery::displacedInJSStack(static_cast&lt;VirtualRegister&gt;(info.u.virtualReg), info.format);</span>
      }
      if (style == ReconstructionStyle::Separated)
          flushUndefinedOperandSpan(operandSources.size());
  
      return numVariables;
<span class="line-new-header">--- 277,11 ---</span>
              valueRecoveries[i] = ValueRecovery::inGPR(info.u.gpr, info.format);
              continue;
          }
  
          valueRecoveries[i] =
<span class="line-modified">!             ValueRecovery::displacedInJSStack(info.u.operand.virtualRegister(), info.format);</span>
      }
      if (style == ReconstructionStyle::Separated)
          flushUndefinedOperandSpan(operandSources.size());
  
      return numVariables;
</pre>
<center><a href="DFGVariableEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableEventStream.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  3 
  4  This library is free software; you can redistribute it and/or
  5  modify it under the terms of the GNU Library General Public
  6  License as published by the Free Software Foundation; either
  7  version 2 of the License, or (at your option) any later version.
  8 
  9  This library is distributed in the hope that it will be useful,
 10  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  Library General Public License for more details.
 13 
 14  You should have received a copy of the GNU Library General Public License
 15  along with this library; see the file COPYING.LIB.  If not, write to
 16  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #ifndef TextureMapperLayer_h
 21 #define TextureMapperLayer_h
 22 
 23 #include &quot;FilterOperations.h&quot;
 24 #include &quot;FloatRect.h&quot;
 25 #include &quot;NicosiaAnimation.h&quot;
 26 #include &quot;TextureMapper.h&quot;
 27 #include &quot;TextureMapperBackingStore.h&quot;
 28 #include &lt;wtf/WeakPtr.h&gt;
 29 
 30 #if USE(COORDINATED_GRAPHICS)
 31 #include &quot;NicosiaAnimatedBackingStoreClient.h&quot;
 32 #endif
 33 
 34 namespace WebCore {
 35 
 36 class GraphicsLayer;
 37 class Region;
 38 class TextureMapperPaintOptions;
 39 class TextureMapperPlatformLayer;
 40 
 41 class WEBCORE_EXPORT TextureMapperLayer : public CanMakeWeakPtr&lt;TextureMapperLayer&gt; {
 42     WTF_MAKE_NONCOPYABLE(TextureMapperLayer);
 43     WTF_MAKE_FAST_ALLOCATED;
 44 public:
 45     TextureMapperLayer();
 46     virtual ~TextureMapperLayer();
 47 
 48     void setID(uint32_t id) { m_id = id; }
 49     uint32_t id() { return m_id; }
 50 
 51     const Vector&lt;TextureMapperLayer*&gt;&amp; children() const { return m_children; }
 52 
 53     TextureMapper* textureMapper() const { return rootLayer().m_textureMapper; }
 54     void setTextureMapper(TextureMapper* texmap) { m_textureMapper = texmap; }
 55 
 56 #if !USE(COORDINATED_GRAPHICS)
 57     void setChildren(const Vector&lt;GraphicsLayer*&gt;&amp;);
 58 #endif
 59     void setChildren(const Vector&lt;TextureMapperLayer*&gt;&amp;);
 60     void setMaskLayer(TextureMapperLayer*);
 61     void setReplicaLayer(TextureMapperLayer*);
 62     void setPosition(const FloatPoint&amp;);
 63     void setBoundsOrigin(const FloatPoint&amp;);
 64     void setSize(const FloatSize&amp;);
 65     void setAnchorPoint(const FloatPoint3D&amp;);
 66     void setPreserves3D(bool);
 67     void setTransform(const TransformationMatrix&amp;);
 68     void setChildrenTransform(const TransformationMatrix&amp;);
 69     void setContentsRect(const FloatRect&amp;);
 70     void setMasksToBounds(bool);
 71     void setDrawsContent(bool);
 72     bool drawsContent() const { return m_state.drawsContent; }
 73     bool contentsAreVisible() const { return m_state.contentsVisible; }
 74     FloatSize size() const { return m_state.size; }
 75     float opacity() const { return m_state.opacity; }
 76     TransformationMatrix transform() const { return m_state.transform; }
 77     void setContentsVisible(bool);
 78     void setContentsOpaque(bool);
 79     void setBackfaceVisibility(bool);
 80     void setOpacity(float);
 81     void setSolidColor(const Color&amp;);
 82     void setContentsTileSize(const FloatSize&amp;);
 83     void setContentsTilePhase(const FloatSize&amp;);
 84     void setFilters(const FilterOperations&amp;);
 85 
 86     bool hasFilters() const
 87     {
 88         return !m_currentFilters.isEmpty();
 89     }
 90 
 91     void setDebugVisuals(bool showDebugBorders, const Color&amp; debugBorderColor, float debugBorderWidth);
 92     void setRepaintCounter(bool showRepaintCounter, int repaintCount);
 93     void setContentsLayer(TextureMapperPlatformLayer*);
 94     void setAnimations(const Nicosia::Animations&amp;);
 95     void setBackingStore(TextureMapperBackingStore*);
 96 #if USE(COORDINATED_GRAPHICS)
 97     void setAnimatedBackingStoreClient(Nicosia::AnimatedBackingStoreClient*);
 98 #endif
 99 
100     bool applyAnimationsRecursively(MonotonicTime);
101     bool syncAnimations(MonotonicTime);
102     bool descendantsOrSelfHaveRunningAnimations() const;
103 
104     void paint();
105 
106     void addChild(TextureMapperLayer*);
107 
108 private:
109     const TextureMapperLayer&amp; rootLayer() const
110     {
111         if (m_effectTarget)
112             return m_effectTarget-&gt;rootLayer();
113         if (m_parent)
114             return m_parent-&gt;rootLayer();
115         return *this;
116     }
117     void computeTransformsRecursive();
118 
119     static void sortByZOrder(Vector&lt;TextureMapperLayer* &gt;&amp; array);
120 
121     TransformationMatrix replicaTransform();
122     void removeFromParent();
123     void removeAllChildren();
124 
125     enum ResolveSelfOverlapMode {
126         ResolveSelfOverlapAlways = 0,
127         ResolveSelfOverlapIfNeeded
128     };
129     void computeOverlapRegions(Region&amp; overlapRegion, Region&amp; nonOverlapRegion, ResolveSelfOverlapMode);
130 
131     void paintRecursive(const TextureMapperPaintOptions&amp;);
132     void paintUsingOverlapRegions(const TextureMapperPaintOptions&amp;);
133     RefPtr&lt;BitmapTexture&gt; paintIntoSurface(const TextureMapperPaintOptions&amp;, const IntSize&amp;);
134     void paintWithIntermediateSurface(const TextureMapperPaintOptions&amp;, const IntRect&amp;);
135     void paintSelf(const TextureMapperPaintOptions&amp;);
136     void paintSelfAndChildren(const TextureMapperPaintOptions&amp;);
137     void paintSelfAndChildrenWithReplica(const TextureMapperPaintOptions&amp;);
138     void applyMask(const TextureMapperPaintOptions&amp;);
139 
140     bool isVisible() const;
141 
142     bool shouldBlend() const;
143 
144     inline FloatRect layerRect() const
145     {
146         return FloatRect(FloatPoint::zero(), m_state.size);
147     }
148 
149     Vector&lt;TextureMapperLayer*&gt; m_children;
150     TextureMapperLayer* m_parent { nullptr };
151     WeakPtr&lt;TextureMapperLayer&gt; m_effectTarget;
152     TextureMapperBackingStore* m_backingStore { nullptr };
153     TextureMapperPlatformLayer* m_contentsLayer { nullptr };
154     float m_currentOpacity { 1.0 };
155     FilterOperations m_currentFilters;
156     float m_centerZ { 0 };
157 
158     struct State {
159         FloatPoint pos;
160         FloatPoint3D anchorPoint;
161         FloatPoint boundsOrigin;
162         FloatSize size;
163         TransformationMatrix transform;
164         TransformationMatrix childrenTransform;
165         float opacity;
166         FloatRect contentsRect;
167         FloatSize contentsTileSize;
168         FloatSize contentsTilePhase;
169         WeakPtr&lt;TextureMapperLayer&gt; maskLayer;
170         WeakPtr&lt;TextureMapperLayer&gt; replicaLayer;
171         Color solidColor;
172         FilterOperations filters;
173         Color debugBorderColor;
174         float debugBorderWidth;
175         int repaintCount;
176 
177         bool preserves3D : 1;
178         bool masksToBounds : 1;
179         bool drawsContent : 1;
180         bool contentsVisible : 1;
181         bool contentsOpaque : 1;
182         bool backfaceVisibility : 1;
183         bool visible : 1;
184         bool showDebugBorders : 1;
185         bool showRepaintCounter : 1;
186 
187         State()
188             : anchorPoint(0.5, 0.5, 0)
189             , opacity(1)
190             , debugBorderWidth(0)
191             , repaintCount(0)
192             , preserves3D(false)
193             , masksToBounds(false)
194             , drawsContent(false)
195             , contentsVisible(true)
196             , contentsOpaque(false)
197             , backfaceVisibility(true)
198             , visible(true)
199             , showDebugBorders(false)
200             , showRepaintCounter(false)
201         {
202         }
203     };
204 
205     State m_state;
206     TextureMapper* m_textureMapper { nullptr };
207     Nicosia::Animations m_animations;
208     uint32_t m_id { 0 };
209 #if USE(COORDINATED_GRAPHICS)
210     RefPtr&lt;Nicosia::AnimatedBackingStoreClient&gt; m_animatedBackingStoreClient;
211 #endif
212 
213     struct {
214         TransformationMatrix localTransform;
215         TransformationMatrix combined;
216         TransformationMatrix combinedForChildren;
217 #if USE(COORDINATED_GRAPHICS)
218         TransformationMatrix futureLocalTransform;
219         TransformationMatrix futureCombined;
220         TransformationMatrix futureCombinedForChildren;
221 #endif
222     } m_layerTransforms;
223 };
224 
225 }
226 
227 #endif // TextureMapperLayer_h
    </pre>
  </body>
</html>
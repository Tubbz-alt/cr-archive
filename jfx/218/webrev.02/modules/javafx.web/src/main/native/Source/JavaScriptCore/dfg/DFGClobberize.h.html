<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;DFGAbstractHeap.h&quot;
  31 #include &quot;DFGGraph.h&quot;
  32 #include &quot;DFGHeapLocation.h&quot;
  33 #include &quot;DFGLazyNode.h&quot;
  34 #include &quot;DFGPureValue.h&quot;
  35 #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
  36 #include &quot;DOMJITSignature.h&quot;
  37 #include &quot;InlineCallFrame.h&quot;
  38 #include &quot;JSImmutableButterfly.h&quot;
  39 
  40 namespace JSC { namespace DFG {
  41 
  42 template&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;
  43 void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFunctor&amp; write, const DefFunctor&amp; def)
  44 {
  45     // Some notes:
  46     //
  47     // - The canonical way of clobbering the world is to read world and write
  48     //   heap. This is because World subsumes Heap and Stack, and Stack can be
  49     //   read by anyone but only written to by explicit stack writing operations.
  50     //   Of course, claiming to also write World is not wrong; it&#39;ll just
  51     //   pessimise some important optimizations.
  52     //
  53     // - We cannot hoist, or sink, anything that has effects. This means that the
  54     //   easiest way of indicating that something cannot be hoisted is to claim
  55     //   that it side-effects some miscellaneous thing.
  56     //
  57     // - We cannot hoist forward-exiting nodes without some additional effort. I
  58     //   believe that what it comes down to is that forward-exiting generally have
  59     //   their NodeExitsForward cleared upon hoist, except for forward-exiting
  60     //   nodes that take bogus state as their input. Those are substantially
  61     //   harder. We disable it for now. In the future we could enable it by having
  62     //   versions of those nodes that backward-exit instead, but I&#39;m not convinced
  63     //   of the soundness.
  64     //
  65     // - Some nodes lie, and claim that they do not read the JSCell_structureID,
  66     //   JSCell_typeInfoFlags, etc. These are nodes that use the structure in a way
  67     //   that does not depend on things that change under structure transitions.
  68     //
  69     // - It&#39;s implicitly understood that OSR exits read the world. This is why we
  70     //   generally don&#39;t move or eliminate stores. Every node can exit, so the
  71     //   read set does not reflect things that would be read if we exited.
  72     //   Instead, the read set reflects what the node will have to read if it
  73     //   *doesn&#39;t* exit.
  74     //
  75     // - Broadly, we don&#39;t say that we&#39;re reading something if that something is
  76     //   immutable.
  77     //
  78     // - This must be sound even prior to type inference. We use this as early as
  79     //   bytecode parsing to determine at which points in the program it&#39;s legal to
  80     //   OSR exit.
  81     //
  82     // - If you do read(Stack) or read(World), then make sure that readTop() in
  83     //   PreciseLocalClobberize is correct.
  84 
  85     // While read() and write() are fairly self-explanatory - they track what sorts of things the
  86     // node may read or write - the def() functor is more tricky. It tells you the heap locations
  87     // (not just abstract heaps) that are defined by a node. A heap location comprises an abstract
  88     // heap, some nodes, and a LocationKind. Briefly, a location defined by a node is a location
  89     // whose value can be deduced from looking at the node itself. The locations returned must obey
  90     // the following properties:
  91     //
  92     // - If someone wants to CSE a load from the heap, then a HeapLocation object should be
  93     //   sufficient to find a single matching node.
  94     //
  95     // - The abstract heap is the only abstract heap that could be clobbered to invalidate any such
  96     //   CSE attempt. I.e. if clobberize() reports that on every path between some node and a node
  97     //   that defines a HeapLocation that it wanted, there were no writes to any abstract heap that
  98     //   overlap the location&#39;s heap, then we have a sound match. Effectively, the semantics of
  99     //   write() and def() are intertwined such that for them to be sound they must agree on what
 100     //   is CSEable.
 101     //
 102     // read(), write(), and def() for heap locations is enough to do GCSE on effectful things. To
 103     // keep things simple, this code will also def() pure things. def() must be overloaded to also
 104     // accept PureValue. This way, a client of clobberize() can implement GCSE entirely using the
 105     // information that clobberize() passes to write() and def(). Other clients of clobberize() can
 106     // just ignore def() by using a NoOpClobberize functor.
 107 
 108     // We allow the runtime to perform a stack scan at any time. We don&#39;t model which nodes get implemented
 109     // by calls into the runtime. For debugging we might replace the implementation of any node with a call
 110     // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
 111     // scan would read. That&#39;s what this does.
 112     for (InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
 113         if (inlineCallFrame-&gt;isClosureCall)
 114             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee)));
 115         if (inlineCallFrame-&gt;isVarargs())
 116             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis)));
 117     }
 118 
 119     // We don&#39;t want to specifically account which nodes can read from the scope
 120     // when the debugger is enabled. It&#39;s helpful to just claim all nodes do.
 121     // Specifically, if a node allocates, this may call into the debugger&#39;s machinery.
 122     // The debugger&#39;s machinery is free to take a stack trace and try to read from
 123     // a scope which is expected to be flushed to the stack.
 124     if (graph.hasDebuggerEnabled()) {
 125         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
 126         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
 127     }
 128 
 129     switch (node-&gt;op()) {
 130     case JSConstant:
 131     case DoubleConstant:
 132     case Int52Constant:
 133         def(PureValue(node, node-&gt;constant()));
 134         return;
 135 
 136     case Identity:
 137     case IdentityWithProfile:
 138     case Phantom:
 139     case Check:
 140     case CheckVarargs:
 141     case ExtractOSREntryLocal:
 142     case CheckStructureImmediate:
 143         return;
 144 
 145     case ExtractCatchLocal:
 146         read(AbstractHeap(CatchLocals, node-&gt;catchOSREntryIndex()));
 147         return;
 148 
 149     case ClearCatchLocals:
 150         write(CatchLocals);
 151         return;
 152 
 153     case LazyJSConstant:
 154         // We should enable CSE of LazyJSConstant. It&#39;s a little annoying since LazyJSValue has
 155         // more bits than we currently have in PureValue.
 156         return;
 157 
 158     case CompareEqPtr:
 159         def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));
 160         return;
 161 
 162     case ArithIMul:
 163     case ArithMin:
 164     case ArithMax:
 165     case ArithPow:
 166     case GetScope:
 167     case SkipScope:
 168     case GetGlobalObject:
 169     case StringCharCodeAt:
 170     case StringCodePointAt:
 171     case CompareStrictEq:
 172     case SameValue:
 173     case IsEmpty:
 174     case IsUndefined:
 175     case IsUndefinedOrNull:
 176     case IsBoolean:
 177     case IsNumber:
 178     case NumberIsInteger:
 179     case IsObject:
 180     case IsTypedArrayView:
 181     case LogicalNot:
 182     case CheckInBounds:
 183     case DoubleRep:
 184     case ValueRep:
 185     case Int52Rep:
 186     case BooleanToNumber:
 187     case FiatInt52:
 188     case MakeRope:
 189     case StrCat:
 190     case ValueToInt32:
 191     case GetExecutable:
 192     case BottomValue:
 193     case TypeOf:
 194         def(PureValue(node));
 195         return;
 196 
 197     case GetGlobalThis:
 198         read(World);
 199         return;
 200 
 201     case AtomicsIsLockFree:
 202         if (node-&gt;child1().useKind() == Int32Use)
 203             def(PureValue(node));
 204         else {
 205             read(World);
 206             write(Heap);
 207         }
 208         return;
 209 
 210     case ArithUnary:
 211         if (node-&gt;child1().useKind() == DoubleRepUse)
 212             def(PureValue(node, static_cast&lt;std::underlying_type&lt;Arith::UnaryType&gt;::type&gt;(node-&gt;arithUnaryType())));
 213         else {
 214             read(World);
 215             write(Heap);
 216         }
 217         return;
 218 
 219     case ArithFRound:
 220     case ArithSqrt:
 221         if (node-&gt;child1().useKind() == DoubleRepUse)
 222             def(PureValue(node));
 223         else {
 224             read(World);
 225             write(Heap);
 226         }
 227         return;
 228 
 229     case ArithAbs:
 230         if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == DoubleRepUse)
 231             def(PureValue(node));
 232         else {
 233             read(World);
 234             write(Heap);
 235         }
 236         return;
 237 
 238     case ArithClz32:
 239         if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == KnownInt32Use)
 240             def(PureValue(node));
 241         else {
 242             read(World);
 243             write(Heap);
 244         }
 245         return;
 246 
 247     case ArithNegate:
 248         if (node-&gt;child1().useKind() == Int32Use
 249             || node-&gt;child1().useKind() == DoubleRepUse
 250             || node-&gt;child1().useKind() == Int52RepUse)
 251             def(PureValue(node));
 252         else {
 253             read(World);
 254             write(Heap);
 255         }
 256         return;
 257 
 258     case IsCellWithType:
 259         def(PureValue(node, node-&gt;queriedType()));
 260         return;
 261 
 262     case ValueBitNot:
 263         if (node-&gt;child1().useKind() == BigIntUse) {
 264             def(PureValue(node));
 265             return;
 266         }
 267         read(World);
 268         write(Heap);
 269         return;
 270 
 271     case ArithBitNot:
 272         if (node-&gt;child1().useKind() == UntypedUse) {
 273             read(World);
 274             write(Heap);
 275             return;
 276         }
 277         def(PureValue(node));
 278         return;
 279 
 280     case ArithBitAnd:
 281     case ArithBitOr:
 282     case ArithBitXor:
 283     case ArithBitLShift:
 284     case ArithBitRShift:
 285     case BitURShift:
 286         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 287             read(World);
 288             write(Heap);
 289             return;
 290         }
 291         def(PureValue(node));
 292         return;
 293 
 294     case ArithRandom:
 295         read(MathDotRandomState);
 296         write(MathDotRandomState);
 297         return;
 298 
 299     case GetEnumerableLength: {
 300         read(Heap);
 301         write(SideState);
 302         return;
 303     }
 304 
 305     case ToIndexString:
 306     case GetEnumeratorStructurePname:
 307     case GetEnumeratorGenericPname: {
 308         def(PureValue(node));
 309         return;
 310     }
 311 
 312     case HasIndexedProperty: {
 313         read(JSObject_butterfly);
 314         ArrayMode mode = node-&gt;arrayMode();
 315         switch (mode.type()) {
 316         case Array::ForceExit: {
 317             write(SideState);
 318             return;
 319         }
 320         case Array::Int32: {
 321             if (mode.isInBounds()) {
 322                 read(Butterfly_publicLength);
 323                 read(IndexedInt32Properties);
 324                 def(HeapLocation(HasIndexedPropertyLoc, IndexedInt32Properties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 325                 return;
 326             }
 327             read(Heap);
 328             return;
 329         }
 330 
 331         case Array::Double: {
 332             if (mode.isInBounds()) {
 333                 read(Butterfly_publicLength);
 334                 read(IndexedDoubleProperties);
 335                 def(HeapLocation(HasIndexedPropertyLoc, IndexedDoubleProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 336                 return;
 337             }
 338             read(Heap);
 339             return;
 340         }
 341 
 342         case Array::Contiguous: {
 343             if (mode.isInBounds()) {
 344                 read(Butterfly_publicLength);
 345                 read(IndexedContiguousProperties);
 346                 def(HeapLocation(HasIndexedPropertyLoc, IndexedContiguousProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 347                 return;
 348             }
 349             read(Heap);
 350             return;
 351         }
 352 
 353         case Array::ArrayStorage: {
 354             if (mode.isInBounds()) {
 355                 read(Butterfly_vectorLength);
 356                 read(IndexedArrayStorageProperties);
 357                 return;
 358             }
 359             read(Heap);
 360             return;
 361         }
 362 
 363         default: {
 364             read(World);
 365             write(Heap);
 366             return;
 367         }
 368         }
 369         RELEASE_ASSERT_NOT_REACHED();
 370         return;
 371     }
 372 
 373     case StringFromCharCode:
 374         switch (node-&gt;child1().useKind()) {
 375         case Int32Use:
 376             def(PureValue(node));
 377             return;
 378         case UntypedUse:
 379             read(World);
 380             write(Heap);
 381             return;
 382         default:
 383             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
 384         }
 385         return;
 386 
 387     case ArithAdd:
 388     case ArithMod:
 389     case DoubleAsInt32:
 390     case UInt32ToNumber:
 391         def(PureValue(node, node-&gt;arithMode()));
 392         return;
 393 
 394     case ArithDiv:
 395     case ArithMul:
 396     case ArithSub:
 397         switch (node-&gt;binaryUseKind()) {
 398         case Int32Use:
 399         case Int52RepUse:
 400         case DoubleRepUse:
 401             def(PureValue(node, node-&gt;arithMode()));
 402             return;
 403         case UntypedUse:
 404             read(World);
 405             write(Heap);
 406             return;
 407         default:
 408             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
 409         }
 410 
 411     case ArithRound:
 412     case ArithFloor:
 413     case ArithCeil:
 414     case ArithTrunc:
 415         if (node-&gt;child1().useKind() == DoubleRepUse)
 416             def(PureValue(node, static_cast&lt;uintptr_t&gt;(node-&gt;arithRoundingMode())));
 417         else {
 418             read(World);
 419             write(Heap);
 420         }
 421         return;
 422 
 423     case CheckCell:
 424         def(PureValue(CheckCell, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;cellOperand()));
 425         return;
 426 
 427     case CheckNotEmpty:
 428         def(PureValue(CheckNotEmpty, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1())));
 429         return;
 430 
 431     case AssertNotEmpty:
 432         write(SideState);
 433         return;
 434 
 435     case CheckIdent:
 436         def(PureValue(CheckIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));
 437         return;
 438 
 439     case ConstantStoragePointer:
 440         def(PureValue(node, node-&gt;storagePointer()));
 441         return;
 442 
 443     case KillStack:
 444         write(AbstractHeap(Stack, node-&gt;unlinkedOperand()));
 445         return;
 446 
 447     case MovHint:
 448     case ZombieHint:
 449     case ExitOK:
 450     case Upsilon:
 451     case Phi:
 452     case PhantomLocal:
 453     case SetArgumentDefinitely:
 454     case SetArgumentMaybe:
 455     case Jump:
 456     case Branch:
 457     case Switch:
 458     case EntrySwitch:
 459     case ForceOSRExit:
 460     case CPUIntrinsic:
 461     case CheckBadCell:
 462     case Return:
 463     case Unreachable:
 464     case CheckTierUpInLoop:
 465     case CheckTierUpAtReturn:
 466     case CheckTierUpAndOSREnter:
 467     case LoopHint:
 468     case ProfileType:
 469     case ProfileControlFlow:
 470     case PutHint:
 471     case InitializeEntrypointArguments:
 472     case FilterCallLinkStatus:
 473     case FilterGetByStatus:
 474     case FilterPutByIdStatus:
 475     case FilterInByIdStatus:
 476         write(SideState);
 477         return;
 478 
 479     case StoreBarrier:
 480         read(JSCell_cellState);
 481         write(JSCell_cellState);
 482         return;
 483 
 484     case FencedStoreBarrier:
 485         read(Heap);
 486         write(JSCell_cellState);
 487         return;
 488 
 489     case CheckTraps:
 490         read(InternalState);
 491         write(InternalState);
 492         return;
 493 
 494     case InvalidationPoint:
 495         write(SideState);
 496         def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
 497         return;
 498 
 499     case Flush:
 500         read(AbstractHeap(Stack, node-&gt;operand()));
 501         write(SideState);
 502         return;
 503 
 504     case NotifyWrite:
 505         write(Watchpoint_fire);
 506         write(SideState);
 507         return;
 508 
 509     case PushWithScope: {
 510         read(World);
 511         write(HeapObjectCount);
 512         return;
 513     }
 514 
 515     case CreateActivation: {
 516         SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 517         if (table-&gt;singleton().isStillValid())
 518             write(Watchpoint_fire);
 519         read(HeapObjectCount);
 520         write(HeapObjectCount);
 521         return;
 522     }
 523 
 524     case CreateDirectArguments:
 525     case CreateScopedArguments:
 526     case CreateClonedArguments:
 527     case CreateArgumentsButterfly:
 528         read(Stack);
 529         read(HeapObjectCount);
 530         write(HeapObjectCount);
 531         return;
 532 
 533     case PhantomDirectArguments:
 534     case PhantomClonedArguments:
 535         // DFG backend requires that the locals that this reads are flushed. FTL backend can handle those
 536         // locals being promoted.
 537         if (!graph.m_plan.isFTL())
 538             read(Stack);
 539 
 540         // Even though it&#39;s phantom, it still has the property that one can&#39;t be replaced with another.
 541         read(HeapObjectCount);
 542         write(HeapObjectCount);
 543         return;
 544 
 545     case PhantomSpread:
 546     case PhantomNewArrayWithSpread:
 547     case PhantomNewArrayBuffer:
 548     case PhantomCreateRest:
 549         // Even though it&#39;s phantom, it still has the property that one can&#39;t be replaced with another.
 550         read(HeapObjectCount);
 551         write(HeapObjectCount);
 552         return;
 553 
 554     case CallObjectConstructor:
 555         read(HeapObjectCount);
 556         write(HeapObjectCount);
 557         return;
 558 
 559     case ToThis:
 560         read(MiscFields);
 561         read(HeapObjectCount);
 562         write(HeapObjectCount);
 563         return;
 564 
 565     case IsObjectOrNull:
 566         read(MiscFields);
 567         def(HeapLocation(IsObjectOrNullLoc, MiscFields, node-&gt;child1()), LazyNode(node));
 568         return;
 569 
 570     case IsFunction:
 571         read(MiscFields);
 572         def(HeapLocation(IsFunctionLoc, MiscFields, node-&gt;child1()), LazyNode(node));
 573         return;
 574 
 575     case MatchStructure:
 576         read(JSCell_structureID);
 577         return;
 578 
 579     case ArraySlice:
 580         read(MiscFields);
 581         read(JSCell_indexingType);
 582         read(JSCell_structureID);
 583         read(JSObject_butterfly);
 584         read(Butterfly_publicLength);
 585         read(IndexedDoubleProperties);
 586         read(IndexedInt32Properties);
 587         read(IndexedContiguousProperties);
 588         read(HeapObjectCount);
 589         write(HeapObjectCount);
 590         return;
 591 
 592     case ArrayIndexOf: {
 593         // FIXME: Should support a CSE rule.
 594         // https://bugs.webkit.org/show_bug.cgi?id=173173
 595         read(MiscFields);
 596         read(JSCell_indexingType);
 597         read(JSCell_structureID);
 598         read(JSObject_butterfly);
 599         read(Butterfly_publicLength);
 600         switch (node-&gt;arrayMode().type()) {
 601         case Array::Double:
 602             read(IndexedDoubleProperties);
 603             return;
 604         case Array::Int32:
 605             read(IndexedInt32Properties);
 606             return;
 607         case Array::Contiguous:
 608             read(IndexedContiguousProperties);
 609             return;
 610         default:
 611             RELEASE_ASSERT_NOT_REACHED();
 612             return;
 613         }
 614         return;
 615     }
 616 
 617     case GetById:
 618     case GetByIdFlush:
 619     case GetByIdWithThis:
 620     case GetByIdDirect:
 621     case GetByIdDirectFlush:
 622     case GetByValWithThis:
 623     case PutById:
 624     case PutByIdWithThis:
 625     case PutByValWithThis:
 626     case PutByIdFlush:
 627     case PutByIdDirect:
 628     case PutGetterById:
 629     case PutSetterById:
 630     case PutGetterSetterById:
 631     case PutGetterByVal:
 632     case PutSetterByVal:
 633     case DefineDataProperty:
 634     case DefineAccessorProperty:
 635     case DeleteById:
 636     case DeleteByVal:
 637     case ArrayPush:
 638     case ArrayPop:
 639     case Call:
 640     case DirectCall:
 641     case TailCallInlinedCaller:
 642     case DirectTailCallInlinedCaller:
 643     case Construct:
 644     case DirectConstruct:
 645     case CallVarargs:
 646     case CallForwardVarargs:
 647     case TailCallVarargsInlinedCaller:
 648     case TailCallForwardVarargsInlinedCaller:
 649     case ConstructVarargs:
 650     case ConstructForwardVarargs:
 651     case ToPrimitive:
 652     case ToPropertyKey:
 653     case InByVal:
 654     case InById:
 655     case HasOwnProperty:
 656     case ValueNegate:
 657     case SetFunctionName:
 658     case GetDynamicVar:
 659     case PutDynamicVar:
 660     case ResolveScopeForHoistingFuncDeclInEval:
 661     case ResolveScope:
 662     case ToObject:
 663     case HasGenericProperty:
 664     case HasStructureProperty:
 665     case GetPropertyEnumerator:
 666     case GetDirectPname:
 667     case InstanceOfCustom:
 668     case ToNumber:
 669     case ToNumeric:
 670     case NumberToStringWithRadix:
 671     case CreateThis:
 672     case CreatePromise:
 673     case CreateGenerator:
 674     case CreateAsyncGenerator:
 675     case InstanceOf:
 676     case StringValueOf:
 677     case ObjectKeys:
 678         read(World);
 679         write(Heap);
 680         return;
 681 
 682     case Inc:
 683     case Dec:
 684         switch (node-&gt;child1().useKind()) {
 685         case Int32Use:
 686         case Int52RepUse:
 687         case DoubleRepUse:
 688         case BigIntUse:
 689             def(PureValue(node));
 690             return;
 691         case UntypedUse:
 692             read(World);
 693             write(Heap);
 694             return;
 695         default:
 696             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
 697         }
 698 
 699     case ValueBitAnd:
 700     case ValueBitXor:
 701     case ValueBitOr:
 702     case ValueAdd:
 703     case ValueSub:
 704     case ValueMul:
 705     case ValueDiv:
 706     case ValueMod:
 707     case ValuePow:
 708     case ValueBitLShift:
 709     case ValueBitRShift:
 710         if (node-&gt;isBinaryUseKind(BigIntUse)) {
 711             def(PureValue(node));
 712             return;
 713         }
 714         read(World);
 715         write(Heap);
 716         return;
 717 
 718     case AtomicsAdd:
 719     case AtomicsAnd:
 720     case AtomicsCompareExchange:
 721     case AtomicsExchange:
 722     case AtomicsLoad:
 723     case AtomicsOr:
 724     case AtomicsStore:
 725     case AtomicsSub:
 726     case AtomicsXor: {
 727         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
 728         Edge storageEdge = graph.child(node, 2 + numExtraArgs);
 729         if (!storageEdge) {
 730             read(World);
 731             write(Heap);
 732             return;
 733         }
 734         read(TypedArrayProperties);
 735         read(MiscFields);
 736         write(TypedArrayProperties);
 737         return;
 738     }
 739 
 740     case CallEval:
 741         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
 742         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
 743         read(AbstractHeap(Stack, virtualRegisterForArgumentIncludingThis(0)));
 744         read(World);
 745         write(Heap);
 746         return;
 747 
 748     case Throw:
 749     case ThrowStaticError:
 750     case TailCall:
 751     case DirectTailCall:
 752     case TailCallVarargs:
 753     case TailCallForwardVarargs:
 754         read(World);
 755         write(SideState);
 756         return;
 757 
 758     case GetGetter:
 759         read(GetterSetter_getter);
 760         def(HeapLocation(GetterLoc, GetterSetter_getter, node-&gt;child1()), LazyNode(node));
 761         return;
 762 
 763     case GetSetter:
 764         read(GetterSetter_setter);
 765         def(HeapLocation(SetterLoc, GetterSetter_setter, node-&gt;child1()), LazyNode(node));
 766         return;
 767 
 768     case GetCallee:
 769         read(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));
 770         def(HeapLocation(StackLoc, AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee))), LazyNode(node));
 771         return;
 772 
 773     case SetCallee:
 774         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));
 775         return;
 776 
 777     case GetArgumentCountIncludingThis: {
 778         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));
 779         read(heap);
 780         def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
 781         return;
 782     }
 783 
 784     case SetArgumentCountIncludingThis:
 785         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));
 786         return;
 787 
 788     case GetRestLength:
 789         read(Stack);
 790         return;
 791 
 792     case GetLocal:
 793         read(AbstractHeap(Stack, node-&gt;operand()));
 794         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node));
 795         return;
 796 
 797     case SetLocal:
 798         write(AbstractHeap(Stack, node-&gt;operand()));
 799         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node-&gt;child1().node()));
 800         return;
 801 
 802     case GetStack: {
 803         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);
 804         read(heap);
 805         def(HeapLocation(StackLoc, heap), LazyNode(node));
 806         return;
 807     }
 808 
 809     case PutStack: {
 810         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);
 811         write(heap);
 812         def(HeapLocation(StackLoc, heap), LazyNode(node-&gt;child1().node()));
 813         return;
 814     }
 815 
 816     case VarargsLength: {
 817         read(World);
 818         write(Heap);
 819         return;
 820     }
 821 
 822     case LoadVarargs: {
 823         read(World);
 824         write(Heap);
 825         LoadVarargsData* data = node-&gt;loadVarargsData();
 826         write(AbstractHeap(Stack, data-&gt;count));
 827         for (unsigned i = data-&gt;limit; i--;)
 828             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));
 829         return;
 830     }
 831 
 832     case ForwardVarargs: {
 833         // We could be way more precise here.
 834         read(Stack);
 835 
 836         LoadVarargsData* data = node-&gt;loadVarargsData();
 837         write(AbstractHeap(Stack, data-&gt;count));
 838         for (unsigned i = data-&gt;limit; i--;)
 839             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));
 840         return;
 841     }
 842 
 843     case GetByVal: {
 844         ArrayMode mode = node-&gt;arrayMode();
 845         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
 846         switch (mode.type()) {
 847         case Array::SelectUsingPredictions:
 848         case Array::Unprofiled:
 849         case Array::SelectUsingArguments:
 850             // Assume the worst since we don&#39;t have profiling yet.
 851             read(World);
 852             write(Heap);
 853             return;
 854 
 855         case Array::ForceExit:
 856             write(SideState);
 857             return;
 858 
 859         case Array::Generic:
 860             read(World);
 861             write(Heap);
 862             return;
 863 
 864         case Array::String:
 865             if (mode.isOutOfBounds()) {
 866                 read(World);
 867                 write(Heap);
 868                 return;
 869             }
 870             // This appears to read nothing because it&#39;s only reading immutable data.
 871             def(PureValue(graph, node, mode.asWord()));
 872             return;
 873 
 874         case Array::DirectArguments:
 875             if (mode.isInBounds()) {
 876                 read(DirectArgumentsProperties);
 877                 def(HeapLocation(indexedPropertyLoc, DirectArgumentsProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 878                 return;
 879             }
 880             read(World);
 881             write(Heap);
 882             return;
 883 
 884         case Array::ScopedArguments:
 885             read(ScopeProperties);
 886             def(HeapLocation(indexedPropertyLoc, ScopeProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 887             return;
 888 
 889         case Array::Int32:
 890             if (mode.isInBounds()) {
 891                 read(Butterfly_publicLength);
 892                 read(IndexedInt32Properties);
 893                 def(HeapLocation(indexedPropertyLoc, IndexedInt32Properties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 894                 return;
 895             }
 896             read(World);
 897             write(Heap);
 898             return;
 899 
 900         case Array::Double:
 901             if (mode.isInBounds()) {
 902                 read(Butterfly_publicLength);
 903                 read(IndexedDoubleProperties);
 904                 LocationKind kind = mode.isSaneChain() ? IndexedPropertyDoubleSaneChainLoc : IndexedPropertyDoubleLoc;
 905                 def(HeapLocation(kind, IndexedDoubleProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 906                 return;
 907             }
 908             read(World);
 909             write(Heap);
 910             return;
 911 
 912         case Array::Contiguous:
 913             if (mode.isInBounds()) {
 914                 read(Butterfly_publicLength);
 915                 read(IndexedContiguousProperties);
 916                 def(HeapLocation(indexedPropertyLoc, IndexedContiguousProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 917                 return;
 918             }
 919             read(World);
 920             write(Heap);
 921             return;
 922 
 923         case Array::Undecided:
 924             def(PureValue(graph, node));
 925             return;
 926 
 927         case Array::ArrayStorage:
 928         case Array::SlowPutArrayStorage:
 929             if (mode.isInBounds()) {
 930                 read(Butterfly_vectorLength);
 931                 read(IndexedArrayStorageProperties);
 932                 return;
 933             }
 934             read(World);
 935             write(Heap);
 936             return;
 937 
 938         case Array::Int8Array:
 939         case Array::Int16Array:
 940         case Array::Int32Array:
 941         case Array::Uint8Array:
 942         case Array::Uint8ClampedArray:
 943         case Array::Uint16Array:
 944         case Array::Uint32Array:
 945         case Array::Float32Array:
 946         case Array::Float64Array:
 947             read(TypedArrayProperties);
 948             read(MiscFields);
 949             def(HeapLocation(indexedPropertyLoc, TypedArrayProperties, graph.varArgChild(node, 0), graph.varArgChild(node, 1)), LazyNode(node));
 950             return;
 951         // We should not get an AnyTypedArray in a GetByVal as AnyTypedArray is only created from intrinsics, which
 952         // are only added from Inline Caching a GetById.
 953         case Array::AnyTypedArray:
 954             DFG_CRASH(graph, node, &quot;impossible array mode for get&quot;);
 955             return;
 956         }
 957         RELEASE_ASSERT_NOT_REACHED();
 958         return;
 959     }
 960 
 961     case GetMyArgumentByVal:
 962     case GetMyArgumentByValOutOfBounds: {
 963         read(Stack);
 964         // FIXME: It would be trivial to have a def here.
 965         // https://bugs.webkit.org/show_bug.cgi?id=143077
 966         return;
 967     }
 968 
 969     case PutByValDirect:
 970     case PutByVal:
 971     case PutByValAlias: {
 972         ArrayMode mode = node-&gt;arrayMode();
 973         Node* base = graph.varArgChild(node, 0).node();
 974         Node* index = graph.varArgChild(node, 1).node();
 975         Node* value = graph.varArgChild(node, 2).node();
 976         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
 977 
 978         switch (mode.modeForPut().type()) {
 979         case Array::SelectUsingPredictions:
 980         case Array::SelectUsingArguments:
 981         case Array::Unprofiled:
 982         case Array::Undecided:
 983             // Assume the worst since we don&#39;t have profiling yet.
 984             read(World);
 985             write(Heap);
 986             return;
 987 
 988         case Array::ForceExit:
 989             write(SideState);
 990             return;
 991 
 992         case Array::Generic:
 993             read(World);
 994             write(Heap);
 995             return;
 996 
 997         case Array::Int32:
 998             if (node-&gt;arrayMode().isOutOfBounds()) {
 999                 read(World);
1000                 write(Heap);
1001                 return;
1002             }
1003             read(Butterfly_publicLength);
1004             read(Butterfly_vectorLength);
1005             read(IndexedInt32Properties);
1006             write(IndexedInt32Properties);
1007             if (node-&gt;arrayMode().mayStoreToHole())
1008                 write(Butterfly_publicLength);
1009             def(HeapLocation(indexedPropertyLoc, IndexedInt32Properties, base, index), LazyNode(value));
1010             return;
1011 
1012         case Array::Double:
1013             if (node-&gt;arrayMode().isOutOfBounds()) {
1014                 read(World);
1015                 write(Heap);
1016                 return;
1017             }
1018             read(Butterfly_publicLength);
1019             read(Butterfly_vectorLength);
1020             read(IndexedDoubleProperties);
1021             write(IndexedDoubleProperties);
1022             if (node-&gt;arrayMode().mayStoreToHole())
1023                 write(Butterfly_publicLength);
1024             def(HeapLocation(IndexedPropertyDoubleLoc, IndexedDoubleProperties, base, index), LazyNode(value));
1025             def(HeapLocation(IndexedPropertyDoubleSaneChainLoc, IndexedDoubleProperties, base, index), LazyNode(value));
1026             return;
1027 
1028         case Array::Contiguous:
1029             if (node-&gt;arrayMode().isOutOfBounds()) {
1030                 read(World);
1031                 write(Heap);
1032                 return;
1033             }
1034             read(Butterfly_publicLength);
1035             read(Butterfly_vectorLength);
1036             read(IndexedContiguousProperties);
1037             write(IndexedContiguousProperties);
1038             if (node-&gt;arrayMode().mayStoreToHole())
1039                 write(Butterfly_publicLength);
1040             def(HeapLocation(indexedPropertyLoc, IndexedContiguousProperties, base, index), LazyNode(value));
1041             return;
1042 
1043         case Array::ArrayStorage:
1044             if (node-&gt;arrayMode().isOutOfBounds()) {
1045                 read(World);
1046                 write(Heap);
1047                 return;
1048             }
1049             read(Butterfly_publicLength);
1050             read(Butterfly_vectorLength);
1051             read(IndexedArrayStorageProperties);
1052             write(IndexedArrayStorageProperties);
1053             if (node-&gt;arrayMode().mayStoreToHole())
1054                 write(Butterfly_publicLength);
1055             return;
1056 
1057         case Array::SlowPutArrayStorage:
1058             if (node-&gt;arrayMode().mayStoreToHole()) {
1059                 read(World);
1060                 write(Heap);
1061                 return;
1062             }
1063             read(Butterfly_publicLength);
1064             read(Butterfly_vectorLength);
1065             read(IndexedArrayStorageProperties);
1066             write(IndexedArrayStorageProperties);
1067             return;
1068 
1069         case Array::Int8Array:
1070         case Array::Int16Array:
1071         case Array::Int32Array:
1072         case Array::Uint8Array:
1073         case Array::Uint8ClampedArray:
1074         case Array::Uint16Array:
1075         case Array::Uint32Array:
1076         case Array::Float32Array:
1077         case Array::Float64Array:
1078             read(MiscFields);
1079             write(TypedArrayProperties);
1080             // FIXME: We can&#39;t def() anything here because these operations truncate their inputs.
1081             // https://bugs.webkit.org/show_bug.cgi?id=134737
1082             return;
1083         case Array::AnyTypedArray:
1084         case Array::String:
1085         case Array::DirectArguments:
1086         case Array::ScopedArguments:
1087             DFG_CRASH(graph, node, &quot;impossible array mode for put&quot;);
1088             return;
1089         }
1090         RELEASE_ASSERT_NOT_REACHED();
1091         return;
1092     }
1093 
1094     case CheckStructureOrEmpty:
1095     case CheckStructure:
1096         read(JSCell_structureID);
1097         return;
1098 
1099     case CheckArrayOrEmpty:
1100     case CheckArray:
1101         read(JSCell_indexingType);
1102         read(JSCell_structureID);
1103         return;
1104 
1105     case CheckNeutered:
1106         read(MiscFields);
1107         return;
1108 
1109     case CheckTypeInfoFlags:
1110         read(JSCell_typeInfoFlags);
1111         def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1112         return;
1113 
1114     case ParseInt:
1115         // Note: We would have eliminated a ParseInt that has just a single child as an Int32Use inside fixup.
1116         if (node-&gt;child1().useKind() == StringUse &amp;&amp; (!node-&gt;child2() || node-&gt;child2().useKind() == Int32Use)) {
1117             def(PureValue(node));
1118             return;
1119         }
1120 
1121         read(World);
1122         write(Heap);
1123         return;
1124 
1125     case OverridesHasInstance:
1126         read(JSCell_typeInfoFlags);
1127         def(HeapLocation(OverridesHasInstanceLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1128         return;
1129 
1130     case PutStructure:
1131         read(JSObject_butterfly);
1132         write(JSCell_structureID);
1133         write(JSCell_typeInfoFlags);
1134         write(JSCell_indexingType);
1135         return;
1136 
1137     case AllocatePropertyStorage:
1138     case ReallocatePropertyStorage:
1139         read(HeapObjectCount);
1140         write(HeapObjectCount);
1141         return;
1142 
1143     case NukeStructureAndSetButterfly:
1144         write(JSObject_butterfly);
1145         write(JSCell_structureID);
1146         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1147         return;
1148 
1149     case GetButterfly:
1150         read(JSObject_butterfly);
1151         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node));
1152         return;
1153 
1154     case CheckSubClass:
1155         def(PureValue(node, node-&gt;classInfo()));
1156         return;
1157 
1158     case CallDOMGetter: {
1159         DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
1160         if (!snippet) {
1161             read(World);
1162             write(Heap);
1163             return;
1164         }
1165         DOMJIT::Effect effect = snippet-&gt;effect;
1166         if (effect.reads) {
1167             if (effect.reads == DOMJIT::HeapRange::top())
1168                 read(World);
1169             else
1170                 read(AbstractHeap(DOMState, effect.reads.rawRepresentation()));
1171         }
1172         if (effect.writes) {
1173             if (effect.writes == DOMJIT::HeapRange::top())
1174                 write(Heap);
1175             else
1176                 write(AbstractHeap(DOMState, effect.writes.rawRepresentation()));
1177         }
1178         if (effect.def != DOMJIT::HeapRange::top()) {
1179             DOMJIT::HeapRange range = effect.def;
1180             if (range == DOMJIT::HeapRange::none())
1181                 def(PureValue(node, bitwise_cast&lt;uintptr_t&gt;(node-&gt;callDOMGetterData()-&gt;customAccessorGetter)));
1182             else {
1183                 // Def with heap location. We do not include &quot;GlobalObject&quot; for that since this information is included in the base node.
1184                 // We only see the DOMJIT getter here. So just including &quot;base&quot; is ok.
1185                 def(HeapLocation(DOMStateLoc, AbstractHeap(DOMState, range.rawRepresentation()), node-&gt;child1()), LazyNode(node));
1186             }
1187         }
1188         return;
1189     }
1190 
1191     case CallDOM: {
1192         const DOMJIT::Signature* signature = node-&gt;signature();
1193         DOMJIT::Effect effect = signature-&gt;effect;
1194         if (effect.reads) {
1195             if (effect.reads == DOMJIT::HeapRange::top())
1196                 read(World);
1197             else
1198                 read(AbstractHeap(DOMState, effect.reads.rawRepresentation()));
1199         }
1200         if (effect.writes) {
1201             if (effect.writes == DOMJIT::HeapRange::top())
1202                 write(Heap);
1203             else
1204                 write(AbstractHeap(DOMState, effect.writes.rawRepresentation()));
1205         }
1206         ASSERT_WITH_MESSAGE(effect.def == DOMJIT::HeapRange::top(), &quot;Currently, we do not accept any def for CallDOM.&quot;);
1207         return;
1208     }
1209 
1210     case Arrayify:
1211     case ArrayifyToStructure:
1212         read(JSCell_structureID);
1213         read(JSCell_indexingType);
1214         read(JSObject_butterfly);
1215         write(JSCell_structureID);
1216         write(JSCell_indexingType);
1217         write(JSObject_butterfly);
1218         write(Watchpoint_fire);
1219         return;
1220 
1221     case GetIndexedPropertyStorage:
1222         if (node-&gt;arrayMode().type() == Array::String) {
1223             def(PureValue(node, node-&gt;arrayMode().asWord()));
1224             return;
1225         }
1226         read(MiscFields);
1227         def(HeapLocation(IndexedPropertyStorageLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1228         return;
1229 
1230     case GetTypedArrayByteOffset:
1231         read(MiscFields);
1232         def(HeapLocation(TypedArrayByteOffsetLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1233         return;
1234 
1235     case GetPrototypeOf: {
1236         switch (node-&gt;child1().useKind()) {
1237         case ArrayUse:
1238         case FunctionUse:
1239         case FinalObjectUse:
1240             read(JSCell_structureID);
1241             read(JSObject_butterfly);
1242             read(NamedProperties); // Poly proto could load prototype from its slot.
1243             def(HeapLocation(PrototypeLoc, NamedProperties, node-&gt;child1()), LazyNode(node));
1244             return;
1245         default:
1246             read(World);
1247             write(Heap);
1248             return;
1249         }
1250     }
1251 
1252     case GetByOffset:
1253     case GetGetterSetterByOffset: {
1254         unsigned identifierNumber = node-&gt;storageAccessData().identifierNumber;
1255         AbstractHeap heap(NamedProperties, identifierNumber);
1256         read(heap);
1257         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child2()), LazyNode(node));
1258         return;
1259     }
1260 
1261     case TryGetById: {
1262         read(Heap);
1263         return;
1264     }
1265 
1266     case MultiGetByOffset: {
1267         read(JSCell_structureID);
1268         read(JSObject_butterfly);
1269         AbstractHeap heap(NamedProperties, node-&gt;multiGetByOffsetData().identifierNumber);
1270         read(heap);
1271         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child1()), LazyNode(node));
1272         return;
1273     }
1274 
1275     case MultiPutByOffset: {
1276         read(JSCell_structureID);
1277         read(JSObject_butterfly);
1278         AbstractHeap heap(NamedProperties, node-&gt;multiPutByOffsetData().identifierNumber);
1279         write(heap);
1280         if (node-&gt;multiPutByOffsetData().writesStructures())
1281             write(JSCell_structureID);
1282         if (node-&gt;multiPutByOffsetData().reallocatesStorage())
1283             write(JSObject_butterfly);
1284         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1285         return;
1286     }
1287 
1288     case PutByOffset: {
1289         unsigned identifierNumber = node-&gt;storageAccessData().identifierNumber;
1290         AbstractHeap heap(NamedProperties, identifierNumber);
1291         write(heap);
1292         def(HeapLocation(NamedPropertyLoc, heap, node-&gt;child2()), LazyNode(node-&gt;child3().node()));
1293         return;
1294     }
1295 
1296     case GetArrayLength: {
1297         ArrayMode mode = node-&gt;arrayMode();
1298         switch (mode.type()) {
1299         case Array::Undecided:
1300         case Array::Int32:
1301         case Array::Double:
1302         case Array::Contiguous:
1303         case Array::ArrayStorage:
1304         case Array::SlowPutArrayStorage:
1305             read(Butterfly_publicLength);
1306             def(HeapLocation(ArrayLengthLoc, Butterfly_publicLength, node-&gt;child1()), LazyNode(node));
1307             return;
1308 
1309         case Array::String:
1310             def(PureValue(node, mode.asWord()));
1311             return;
1312 
1313         case Array::DirectArguments:
1314         case Array::ScopedArguments:
1315             read(MiscFields);
1316             def(HeapLocation(ArrayLengthLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1317             return;
1318 
1319         default:
1320             ASSERT(mode.isSomeTypedArrayView());
1321             read(MiscFields);
1322             def(HeapLocation(ArrayLengthLoc, MiscFields, node-&gt;child1()), LazyNode(node));
1323             return;
1324         }
1325     }
1326 
1327     case GetVectorLength: {
1328         ArrayMode mode = node-&gt;arrayMode();
1329         switch (mode.type()) {
1330         case Array::ArrayStorage:
1331         case Array::SlowPutArrayStorage:
1332             read(Butterfly_vectorLength);
1333             def(HeapLocation(VectorLengthLoc, Butterfly_vectorLength, node-&gt;child1()), LazyNode(node));
1334             return;
1335 
1336         default:
1337             RELEASE_ASSERT_NOT_REACHED();
1338             return;
1339         }
1340     }
1341 
1342     case GetClosureVar:
1343         read(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1344         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node));
1345         return;
1346 
1347     case PutClosureVar:
1348         write(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1349         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1350         return;
1351 
1352     case GetInternalField: {
1353         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());
1354         read(heap);
1355         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node));
1356         return;
1357     }
1358 
1359     case PutInternalField: {
1360         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());
1361         write(heap);
1362         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1363         return;
1364     }
1365 
1366     case GetRegExpObjectLastIndex:
1367         read(RegExpObject_lastIndex);
1368         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node));
1369         return;
1370 
1371     case SetRegExpObjectLastIndex:
1372         write(RegExpObject_lastIndex);
1373         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1374         return;
1375 
1376     case RecordRegExpCachedResult:
1377         write(RegExpState);
1378         return;
1379 
1380     case GetFromArguments: {
1381         AbstractHeap heap(DirectArgumentsProperties, node-&gt;capturedArgumentsOffset().offset());
1382         read(heap);
1383         def(HeapLocation(DirectArgumentsLoc, heap, node-&gt;child1()), LazyNode(node));
1384         return;
1385     }
1386 
1387     case PutToArguments: {
1388         AbstractHeap heap(DirectArgumentsProperties, node-&gt;capturedArgumentsOffset().offset());
1389         write(heap);
1390         def(HeapLocation(DirectArgumentsLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1391         return;
1392     }
1393 
1394     case GetArgument: {
1395         read(Stack);
1396         // FIXME: It would be trivial to have a def here.
1397         // https://bugs.webkit.org/show_bug.cgi?id=143077
1398         return;
1399     }
1400 
1401     case GetGlobalVar:
1402     case GetGlobalLexicalVariable:
1403         read(AbstractHeap(Absolute, node-&gt;variablePointer()));
1404         def(HeapLocation(GlobalVariableLoc, AbstractHeap(Absolute, node-&gt;variablePointer())), LazyNode(node));
1405         return;
1406 
1407     case PutGlobalVariable:
1408         write(AbstractHeap(Absolute, node-&gt;variablePointer()));
1409         def(HeapLocation(GlobalVariableLoc, AbstractHeap(Absolute, node-&gt;variablePointer())), LazyNode(node-&gt;child2().node()));
1410         return;
1411 
1412     case NewArrayWithSize:
1413         read(HeapObjectCount);
1414         write(HeapObjectCount);
1415         return;
1416 
1417     case NewTypedArray:
1418         switch (node-&gt;child1().useKind()) {
1419         case Int32Use:
1420             read(HeapObjectCount);
1421             write(HeapObjectCount);
1422             return;
1423         case UntypedUse:
1424             read(World);
1425             write(Heap);
1426             return;
1427         default:
1428             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
1429         }
1430         break;
1431 
1432     case NewArrayWithSpread: {
1433         read(HeapObjectCount);
1434         // This appears to read nothing because it&#39;s only reading immutable butterfly data.
1435         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
1436             Node* child = graph.varArgChild(node, i).node();
1437             if (child-&gt;op() == PhantomSpread) {
1438                 read(Stack);
1439                 break;
1440             }
1441         }
1442         write(HeapObjectCount);
1443         return;
1444     }
1445 
1446     case Spread: {
1447         if (node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
1448             read(MiscFields);
1449             return;
1450         }
1451 
1452         if (node-&gt;child1()-&gt;op() == PhantomCreateRest) {
1453             read(Stack);
1454             write(HeapObjectCount);
1455             return;
1456         }
1457 
1458         read(World);
1459         write(Heap);
1460         return;
1461     }
1462 
1463     case NewArray: {
1464         read(HeapObjectCount);
1465         write(HeapObjectCount);
1466 
1467         unsigned numElements = node-&gt;numChildren();
1468 
1469         def(HeapLocation(ArrayLengthLoc, Butterfly_publicLength, node),
1470             LazyNode(graph.freeze(jsNumber(numElements))));
1471 
1472         if (!numElements)
1473             return;
1474 
1475         AbstractHeap heap;
1476         LocationKind indexedPropertyLoc;
1477         switch (node-&gt;indexingType()) {
1478         case ALL_DOUBLE_INDEXING_TYPES:
1479             heap = IndexedDoubleProperties;
1480             indexedPropertyLoc = IndexedPropertyDoubleLoc;
1481             break;
1482 
1483         case ALL_INT32_INDEXING_TYPES:
1484             heap = IndexedInt32Properties;
1485             indexedPropertyLoc = IndexedPropertyJSLoc;
1486             break;
1487 
1488         case ALL_CONTIGUOUS_INDEXING_TYPES:
1489             heap = IndexedContiguousProperties;
1490             indexedPropertyLoc = IndexedPropertyJSLoc;
1491             break;
1492 
1493         default:
1494             return;
1495         }
1496 
1497         if (numElements &lt; graph.m_uint32ValuesInUse.size()) {
1498             for (unsigned operandIdx = 0; operandIdx &lt; numElements; ++operandIdx) {
1499                 Edge use = graph.m_varArgChildren[node-&gt;firstChild() + operandIdx];
1500                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(operandIdx)))),
1501                     LazyNode(use.node()));
1502             }
1503         } else {
1504             for (uint32_t operandIdx : graph.m_uint32ValuesInUse) {
1505                 if (operandIdx &gt;= numElements)
1506                     continue;
1507                 Edge use = graph.m_varArgChildren[node-&gt;firstChild() + operandIdx];
1508                 // operandIdx comes from graph.m_uint32ValuesInUse and thus is guaranteed to be already frozen
1509                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(operandIdx)))),
1510                     LazyNode(use.node()));
1511             }
1512         }
1513         return;
1514     }
1515 
1516     case NewArrayBuffer: {
1517         read(HeapObjectCount);
1518         write(HeapObjectCount);
1519 
1520         auto* array = node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1521         unsigned numElements = array-&gt;length();
1522         def(HeapLocation(ArrayLengthLoc, Butterfly_publicLength, node),
1523             LazyNode(graph.freeze(jsNumber(numElements))));
1524 
1525         AbstractHeap heap;
1526         LocationKind indexedPropertyLoc;
1527         NodeType op = JSConstant;
1528         switch (node-&gt;indexingType()) {
1529         case ALL_DOUBLE_INDEXING_TYPES:
1530             heap = IndexedDoubleProperties;
1531             indexedPropertyLoc = IndexedPropertyDoubleLoc;
1532             op = DoubleConstant;
1533             break;
1534 
1535         case ALL_INT32_INDEXING_TYPES:
1536             heap = IndexedInt32Properties;
1537             indexedPropertyLoc = IndexedPropertyJSLoc;
1538             break;
1539 
1540         case ALL_CONTIGUOUS_INDEXING_TYPES:
1541             heap = IndexedContiguousProperties;
1542             indexedPropertyLoc = IndexedPropertyJSLoc;
1543             break;
1544 
1545         default:
1546             return;
1547         }
1548 
1549         if (numElements &lt; graph.m_uint32ValuesInUse.size()) {
1550             for (unsigned index = 0; index &lt; numElements; ++index) {
1551                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(index)))),
1552                     LazyNode(graph.freeze(array-&gt;get(index)), op));
1553             }
1554         } else {
1555             Vector&lt;uint32_t&gt; possibleIndices;
1556             for (uint32_t index : graph.m_uint32ValuesInUse) {
1557                 if (index &gt;= numElements)
1558                     continue;
1559                 possibleIndices.append(index);
1560             }
1561             for (uint32_t index : possibleIndices) {
1562                 def(HeapLocation(indexedPropertyLoc, heap, node, LazyNode(graph.freeze(jsNumber(index)))),
1563                     LazyNode(graph.freeze(array-&gt;get(index)), op));
1564             }
1565         }
1566         return;
1567     }
1568 
1569     case CreateRest: {
1570         if (!graph.isWatchingHavingABadTimeWatchpoint(node)) {
1571             // This means we&#39;re already having a bad time.
1572             read(World);
1573             write(Heap);
1574             return;
1575         }
1576         read(Stack);
1577         read(HeapObjectCount);
1578         write(HeapObjectCount);
1579         return;
1580     }
1581 
1582     case ObjectCreate: {
1583         switch (node-&gt;child1().useKind()) {
1584         case ObjectUse:
1585             read(HeapObjectCount);
1586             write(HeapObjectCount);
1587             return;
1588         case UntypedUse:
1589             read(World);
1590             write(Heap);
1591             return;
1592         default:
1593             RELEASE_ASSERT_NOT_REACHED();
1594             return;
1595         }
1596     }
1597 
1598     case NewObject:
1599     case NewPromise:
1600     case NewGenerator:
1601     case NewAsyncGenerator:
1602     case NewArrayIterator:
1603     case NewRegexp:
1604     case NewSymbol:
1605     case NewStringObject:
1606     case PhantomNewObject:
1607     case MaterializeNewObject:
1608     case PhantomNewFunction:
1609     case PhantomNewGeneratorFunction:
1610     case PhantomNewAsyncFunction:
1611     case PhantomNewAsyncGeneratorFunction:
1612     case PhantomNewArrayIterator:
1613     case MaterializeNewInternalFieldObject:
1614     case PhantomCreateActivation:
1615     case MaterializeCreateActivation:
1616     case PhantomNewRegexp:
1617         read(HeapObjectCount);
1618         write(HeapObjectCount);
1619         return;
1620 
1621     case NewFunction:
1622     case NewGeneratorFunction:
1623     case NewAsyncGeneratorFunction:
1624     case NewAsyncFunction:
1625         if (node-&gt;castOperand&lt;FunctionExecutable*&gt;()-&gt;singleton().isStillValid())
1626             write(Watchpoint_fire);
1627         read(HeapObjectCount);
1628         write(HeapObjectCount);
1629         return;
1630 
1631     case RegExpExec:
1632     case RegExpTest:
1633         // Even if we&#39;ve proven known input types as RegExpObject and String,
1634         // accessing lastIndex is effectful if it&#39;s a global regexp.
1635         read(World);
1636         write(Heap);
1637         return;
1638 
1639     case RegExpMatchFast:
1640         read(RegExpState);
1641         read(RegExpObject_lastIndex);
1642         write(RegExpState);
1643         write(RegExpObject_lastIndex);
1644         return;
1645 
1646     case RegExpExecNonGlobalOrSticky:
1647     case RegExpMatchFastGlobal:
1648         read(RegExpState);
1649         write(RegExpState);
1650         return;
1651 
1652     case StringReplace:
1653     case StringReplaceRegExp:
1654         if (node-&gt;child1().useKind() == StringUse
1655             &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
1656             &amp;&amp; node-&gt;child3().useKind() == StringUse) {
1657             read(RegExpState);
1658             read(RegExpObject_lastIndex);
1659             write(RegExpState);
1660             write(RegExpObject_lastIndex);
1661             return;
1662         }
1663         read(World);
1664         write(Heap);
1665         return;
1666 
1667     case StringCharAt:
1668         if (node-&gt;arrayMode().isOutOfBounds()) {
1669             read(World);
1670             write(Heap);
1671             return;
1672         }
1673         def(PureValue(node));
1674         return;
1675 
1676     case CompareBelow:
1677     case CompareBelowEq:
1678         def(PureValue(node));
1679         return;
1680 
1681     case CompareEq:
1682     case CompareLess:
1683     case CompareLessEq:
1684     case CompareGreater:
1685     case CompareGreaterEq:
1686         if (node-&gt;isBinaryUseKind(StringUse)) {
1687             read(HeapObjectCount);
1688             write(HeapObjectCount);
1689             return;
1690         }
1691 
1692         if (node-&gt;isBinaryUseKind(UntypedUse)) {
1693             read(World);
1694             write(Heap);
1695             return;
1696         }
1697 
1698         def(PureValue(node));
1699         return;
1700 
1701     case ToString:
1702     case CallStringConstructor:
1703         switch (node-&gt;child1().useKind()) {
1704         case CellUse:
1705         case UntypedUse:
1706             read(World);
1707             write(Heap);
1708             return;
1709 
1710         case StringObjectUse:
1711         case StringOrStringObjectUse:
1712             // These two StringObjectUse&#39;s are pure because if we emit this node with either
1713             // of these UseKinds, we&#39;ll first emit a StructureCheck ensuring that we&#39;re the
1714             // original String or StringObject structure. Therefore, we don&#39;t have an overridden
1715             // valueOf, etc.
1716 
1717         case Int32Use:
1718         case Int52RepUse:
1719         case DoubleRepUse:
1720         case NotCellUse:
1721             def(PureValue(node));
1722             return;
1723 
1724         default:
1725             RELEASE_ASSERT_NOT_REACHED();
1726             return;
1727         }
1728 
1729     case CountExecution:
1730     case SuperSamplerBegin:
1731     case SuperSamplerEnd:
1732         read(InternalState);
1733         write(InternalState);
1734         return;
1735 
1736     case LogShadowChickenPrologue:
1737     case LogShadowChickenTail:
1738         write(SideState);
1739         return;
1740 
1741     case MapHash:
1742         def(PureValue(node));
1743         return;
1744 
1745     case NormalizeMapKey:
1746         def(PureValue(node));
1747         return;
1748 
1749     case GetMapBucket: {
1750         Edge&amp; mapEdge = node-&gt;child1();
1751         Edge&amp; keyEdge = node-&gt;child2();
1752         AbstractHeapKind heap = (mapEdge.useKind() == MapObjectUse) ? JSMapFields : JSSetFields;
1753         read(heap);
1754         def(HeapLocation(MapBucketLoc, heap, mapEdge, keyEdge), LazyNode(node));
1755         return;
1756     }
1757 
1758     case GetMapBucketHead: {
1759         Edge&amp; mapEdge = node-&gt;child1();
1760         AbstractHeapKind heap = (mapEdge.useKind() == MapObjectUse) ? JSMapFields : JSSetFields;
1761         read(heap);
1762         def(HeapLocation(MapBucketHeadLoc, heap, mapEdge), LazyNode(node));
1763         return;
1764     }
1765 
1766     case GetMapBucketNext: {
1767         AbstractHeapKind heap = (node-&gt;bucketOwnerType() == BucketOwnerType::Map) ? JSMapFields : JSSetFields;
1768         read(heap);
1769         Edge&amp; bucketEdge = node-&gt;child1();
1770         def(HeapLocation(MapBucketNextLoc, heap, bucketEdge), LazyNode(node));
1771         return;
1772     }
1773 
1774     case LoadKeyFromMapBucket: {
1775         AbstractHeapKind heap = (node-&gt;bucketOwnerType() == BucketOwnerType::Map) ? JSMapFields : JSSetFields;
1776         read(heap);
1777         Edge&amp; bucketEdge = node-&gt;child1();
1778         def(HeapLocation(MapBucketKeyLoc, heap, bucketEdge), LazyNode(node));
1779         return;
1780     }
1781 
1782     case LoadValueFromMapBucket: {
1783         AbstractHeapKind heap = (node-&gt;bucketOwnerType() == BucketOwnerType::Map) ? JSMapFields : JSSetFields;
1784         read(heap);
1785         Edge&amp; bucketEdge = node-&gt;child1();
1786         def(HeapLocation(MapBucketValueLoc, heap, bucketEdge), LazyNode(node));
1787         return;
1788     }
1789 
1790     case WeakMapGet: {
1791         Edge&amp; mapEdge = node-&gt;child1();
1792         Edge&amp; keyEdge = node-&gt;child2();
1793         AbstractHeapKind heap = (mapEdge.useKind() == WeakMapObjectUse) ? JSWeakMapFields : JSWeakSetFields;
1794         read(heap);
1795         def(HeapLocation(WeakMapGetLoc, heap, mapEdge, keyEdge), LazyNode(node));
1796         return;
1797     }
1798 
1799     case SetAdd: {
1800         Edge&amp; mapEdge = node-&gt;child1();
1801         Edge&amp; keyEdge = node-&gt;child2();
1802         write(JSSetFields);
1803         def(HeapLocation(MapBucketLoc, JSSetFields, mapEdge, keyEdge), LazyNode(node));
1804         return;
1805     }
1806 
1807     case MapSet: {
1808         Edge&amp; mapEdge = graph.varArgChild(node, 0);
1809         Edge&amp; keyEdge = graph.varArgChild(node, 1);
1810         write(JSMapFields);
1811         def(HeapLocation(MapBucketLoc, JSMapFields, mapEdge, keyEdge), LazyNode(node));
1812         return;
1813     }
1814 
1815     case WeakSetAdd: {
1816         Edge&amp; mapEdge = node-&gt;child1();
1817         Edge&amp; keyEdge = node-&gt;child2();
1818         write(JSWeakSetFields);
1819         def(HeapLocation(WeakMapGetLoc, JSWeakSetFields, mapEdge, keyEdge), LazyNode(keyEdge.node()));
1820         return;
1821     }
1822 
1823     case WeakMapSet: {
1824         Edge&amp; mapEdge = graph.varArgChild(node, 0);
1825         Edge&amp; keyEdge = graph.varArgChild(node, 1);
1826         Edge&amp; valueEdge = graph.varArgChild(node, 2);
1827         write(JSWeakMapFields);
1828         def(HeapLocation(WeakMapGetLoc, JSWeakMapFields, mapEdge, keyEdge), LazyNode(valueEdge.node()));
1829         return;
1830     }
1831 
1832     case ExtractValueFromWeakMapGet:
1833         def(PureValue(node));
1834         return;
1835 
1836     case StringSlice:
1837         def(PureValue(node));
1838         return;
1839 
1840     case ToLowerCase:
1841         def(PureValue(node));
1842         return;
1843 
1844     case NumberToStringWithValidRadixConstant:
1845         def(PureValue(node, node-&gt;validRadixConstant()));
1846         return;
1847 
1848     case DateGetTime:
1849     case DateGetInt32OrNaN: {
1850         read(JSDateFields);
1851         def(HeapLocation(DateFieldLoc, AbstractHeap(JSDateFields, static_cast&lt;uint64_t&gt;(node-&gt;intrinsic())), node-&gt;child1()), LazyNode(node));
1852         return;
1853     }
1854 
1855     case DataViewGetFloat:
1856     case DataViewGetInt: {
1857         read(MiscFields);
1858         read(TypedArrayProperties);
1859         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
1860         def(HeapLocation(indexedPropertyLoc, AbstractHeap(TypedArrayProperties, node-&gt;dataViewData().asQuadWord),
1861             node-&gt;child1(), node-&gt;child2(), node-&gt;child3()), LazyNode(node));
1862         return;
1863     }
1864 
1865     case DataViewSet: {
1866         read(MiscFields);
1867         read(TypedArrayProperties);
1868         write(TypedArrayProperties);
1869         return;
1870     }
1871 
1872     case LastNodeType:
1873         RELEASE_ASSERT_NOT_REACHED();
1874         return;
1875     }
1876 
1877     DFG_CRASH(graph, node, toCString(&quot;Unrecognized node type: &quot;, Graph::opName(node-&gt;op())).data());
1878 }
1879 
1880 class NoOpClobberize {
1881 public:
1882     NoOpClobberize() { }
1883     template&lt;typename... T&gt;
1884     void operator()(T...) const { }
1885 };
1886 
1887 class CheckClobberize {
1888 public:
1889     CheckClobberize()
1890         : m_result(false)
1891     {
1892     }
1893 
1894     template&lt;typename... T&gt;
1895     void operator()(T...) const { m_result = true; }
1896 
1897     bool result() const { return m_result; }
1898 
1899 private:
1900     mutable bool m_result;
1901 };
1902 
1903 bool doesWrites(Graph&amp;, Node*);
1904 
1905 class AbstractHeapOverlaps {
1906 public:
1907     AbstractHeapOverlaps(AbstractHeap heap)
1908         : m_heap(heap)
1909         , m_result(false)
1910     {
1911     }
1912 
1913     void operator()(AbstractHeap otherHeap) const
1914     {
1915         if (m_result)
1916             return;
1917         m_result = m_heap.overlaps(otherHeap);
1918     }
1919 
1920     bool result() const { return m_result; }
1921 
1922 private:
1923     AbstractHeap m_heap;
1924     mutable bool m_result;
1925 };
1926 
1927 bool accessesOverlap(Graph&amp;, Node*, AbstractHeap);
1928 bool writesOverlap(Graph&amp;, Node*, AbstractHeap);
1929 
1930 bool clobbersHeap(Graph&amp;, Node*);
1931 
1932 // We would have used bind() for these, but because of the overlaoding that we are doing,
1933 // it&#39;s quite a bit of clearer to just write this out the traditional way.
1934 
1935 template&lt;typename T&gt;
1936 class ReadMethodClobberize {
1937 public:
1938     ReadMethodClobberize(T&amp; value)
1939         : m_value(value)
1940     {
1941     }
1942 
1943     void operator()(AbstractHeap heap) const
1944     {
1945         m_value.read(heap);
1946     }
1947 private:
1948     T&amp; m_value;
1949 };
1950 
1951 template&lt;typename T&gt;
1952 class WriteMethodClobberize {
1953 public:
1954     WriteMethodClobberize(T&amp; value)
1955         : m_value(value)
1956     {
1957     }
1958 
1959     void operator()(AbstractHeap heap) const
1960     {
1961         m_value.write(heap);
1962     }
1963 private:
1964     T&amp; m_value;
1965 };
1966 
1967 template&lt;typename T&gt;
1968 class DefMethodClobberize {
1969 public:
1970     DefMethodClobberize(T&amp; value)
1971         : m_value(value)
1972     {
1973     }
1974 
1975     void operator()(PureValue value) const
1976     {
1977         m_value.def(value);
1978     }
1979 
1980     void operator()(HeapLocation location, LazyNode node) const
1981     {
1982         m_value.def(location, node);
1983     }
1984 
1985 private:
1986     T&amp; m_value;
1987 };
1988 
1989 template&lt;typename Adaptor&gt;
1990 void clobberize(Graph&amp; graph, Node* node, Adaptor&amp; adaptor)
1991 {
1992     ReadMethodClobberize&lt;Adaptor&gt; read(adaptor);
1993     WriteMethodClobberize&lt;Adaptor&gt; write(adaptor);
1994     DefMethodClobberize&lt;Adaptor&gt; def(adaptor);
1995     clobberize(graph, node, read, write, def);
1996 }
1997 
1998 } } // namespace JSC::DFG
1999 
2000 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
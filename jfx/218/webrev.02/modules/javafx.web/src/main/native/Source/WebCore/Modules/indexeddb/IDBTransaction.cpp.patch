diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp
@@ -76,18 +76,16 @@
 
 IDBTransaction::IDBTransaction(IDBDatabase& database, const IDBTransactionInfo& info, IDBOpenDBRequest* request)
     : IDBActiveDOMObject(database.scriptExecutionContext())
     , m_database(database)
     , m_info(info)
-    , m_pendingOperationTimer(*this, &IDBTransaction::pendingOperationTimerFired)
-    , m_completedOperationTimer(*this, &IDBTransaction::completedOperationTimerFired)
     , m_openDBRequest(request)
     , m_currentlyCompletingRequest(request)
 
 {
     LOG(IndexedDB, "IDBTransaction::IDBTransaction - %s", m_info.loggingString().utf8().data());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ++numberOfIDBTransactions;
 
     if (m_info.mode() == IDBTransactionMode::Versionchange) {
         ASSERT(m_openDBRequest);
@@ -111,21 +109,21 @@
 }
 
 IDBTransaction::~IDBTransaction()
 {
     --numberOfIDBTransactions;
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 }
 
 IDBClient::IDBConnectionProxy& IDBTransaction::connectionProxy()
 {
     return m_database->connectionProxy();
 }
 
 Ref<DOMStringList> IDBTransaction::objectStoreNames() const
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     const Vector<String> names = isVersionChange() ? m_database->info().objectStoreNames() : m_info.objectStores();
 
     Ref<DOMStringList> objectStoreNames = DOMStringList::create();
     for (auto& name : names)
@@ -135,24 +133,24 @@
     return objectStoreNames;
 }
 
 IDBDatabase* IDBTransaction::db()
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     return m_database.ptr();
 }
 
 DOMException* IDBTransaction::error() const
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     return m_domError.get();
 }
 
 ExceptionOr<Ref<IDBObjectStore>> IDBTransaction::objectStore(const String& objectStoreName)
 {
     LOG(IndexedDB, "IDBTransaction::objectStore");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (!scriptExecutionContext())
         return Exception { InvalidStateError };
 
     if (isFinishedOrFinishing())
@@ -188,32 +186,32 @@
 
 
 void IDBTransaction::abortDueToFailedRequest(DOMException& error)
 {
     LOG(IndexedDB, "IDBTransaction::abortDueToFailedRequest");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (isFinishedOrFinishing())
         return;
 
     m_domError = &error;
     internalAbort();
 }
 
 void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT(!isFinishedOrFinishing());
     m_state = state;
     ASSERT(isFinishedOrFinishing());
 }
 
 ExceptionOr<void> IDBTransaction::abort()
 {
     LOG(IndexedDB, "IDBTransaction::abort");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (isFinishedOrFinishing())
         return Exception { InvalidStateError, "Failed to execute 'abort' on 'IDBTransaction': The transaction is inactive or finished."_s };
 
     internalAbort();
@@ -222,11 +220,11 @@
 }
 
 void IDBTransaction::internalAbort()
 {
     LOG(IndexedDB, "IDBTransaction::internalAbort");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(!isFinishedOrFinishing());
 
     m_database->willAbortTransaction(*this);
 
     if (isVersionChange()) {
@@ -272,27 +270,20 @@
         m_transactionOperationsInProgressQueue.append(operation.get());
         m_currentlyCompletingRequest = nullptr;
         operation->doComplete(IDBResultData::error(operation->identifier(), error));
     }
 
-    Vector<RefPtr<IDBClient::TransactionOperation>> completedOnServerAbortVector;
-    completedOnServerAbortVector.reserveInitialCapacity(m_completedOnServerQueue.size());
-    while (!m_completedOnServerQueue.isEmpty())
-        completedOnServerAbortVector.uncheckedAppend(m_completedOnServerQueue.takeFirst().first);
-
-    for (auto& operation : completedOnServerAbortVector) {
-        m_currentlyCompletingRequest = nullptr;
-        operation->doComplete(IDBResultData::error(operation->identifier(), error));
-    }
+    m_transactionOperationResultMap.clear();
 
+    m_currentlyCompletingRequest = nullptr;
     connectionProxy().forgetActiveOperations(inProgressAbortVector);
 }
 
 void IDBTransaction::abortOnServerAndCancelRequests(IDBClient::TransactionOperation& operation)
 {
     LOG(IndexedDB, "IDBTransaction::abortOnServerAndCancelRequests");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 
     m_database->connectionProxy().abortTransaction(*this);
 
     ASSERT(m_transactionOperationMap.contains(operation.identifier()));
@@ -311,36 +302,31 @@
         operation->doComplete(IDBResultData::error(operation->identifier(), error));
         m_currentlyCompletingRequest = nullptr;
     }
 
     m_abortQueue.clear();
+    m_openRequests.clear();
     // Since we're aborting, it should be impossible to have queued any further operations.
     ASSERT(m_pendingTransactionOperationQueue.isEmpty());
 }
 
 const char* IDBTransaction::activeDOMObjectName() const
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     return "IDBTransaction";
 }
 
-bool IDBTransaction::canSuspendForDocumentSuspension() const
-{
-    ASSERT(&m_database->originThread() == &Thread::current());
-    return false;
-}
-
 bool IDBTransaction::hasPendingActivity() const
 {
-    ASSERT(&m_database->originThread() == &Thread::current() || Thread::mayBeGCThread());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()) || Thread::mayBeGCThread());
     return !m_contextStopped && m_state != IndexedDB::TransactionState::Finished;
 }
 
 void IDBTransaction::stop()
 {
     LOG(IndexedDB, "IDBTransaction::stop - %s", m_info.loggingString().utf8().data());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
     // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
     if (m_contextStopped)
         return;
@@ -358,122 +344,81 @@
     internalAbort();
 }
 
 bool IDBTransaction::isActive() const
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     return m_state == IndexedDB::TransactionState::Active;
 }
 
 bool IDBTransaction::isFinishedOrFinishing() const
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     return m_state == IndexedDB::TransactionState::Committing
         || m_state == IndexedDB::TransactionState::Aborting
         || m_state == IndexedDB::TransactionState::Finished;
 }
 
 void IDBTransaction::addRequest(IDBRequest& request)
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     m_openRequests.add(&request);
 }
 
 void IDBTransaction::removeRequest(IDBRequest& request)
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
+    if (m_currentlyCompletingRequest == &request)
+        return;
+
     m_openRequests.remove(&request);
+
+    autoCommit();
 }
 
-void IDBTransaction::scheduleOperation(Ref<IDBClient::TransactionOperation>&& operation)
+void IDBTransaction::scheduleOperation(Ref<IDBClient::TransactionOperation>&& operation, IsWriteOperation isWriteOperation)
 {
     ASSERT(!m_transactionOperationMap.contains(operation->identifier()));
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
+
+    if (isWriteOperation == IsWriteOperation::Yes)
+        m_lastWriteOperationID = operation->operationID();
 
     auto identifier = operation->identifier();
     m_pendingTransactionOperationQueue.append(operation.copyRef());
     m_transactionOperationMap.set(identifier, WTFMove(operation));
 
-    schedulePendingOperationTimer();
+    handlePendingOperations();
 }
 
-void IDBTransaction::schedulePendingOperationTimer()
-{
-    ASSERT(&m_database->originThread() == &Thread::current());
-
-    if (!m_pendingOperationTimer.isActive())
-        m_pendingOperationTimer.startOneShot(0_s);
-}
-
-void IDBTransaction::pendingOperationTimerFired()
+void IDBTransaction::operationCompletedOnServer(const IDBResultData& data, IDBClient::TransactionOperation& operation)
 {
-    LOG(IndexedDB, "IDBTransaction::pendingOperationTimerFired (%p)", this);
-    ASSERT(&m_database->originThread() == &Thread::current());
-
-    if (!m_startedOnServer)
-        return;
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
+    ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));
 
-    // If the last in-progress operation we've sent to the server is not an IDBRequest operation,
-    // then we have to wait until it completes before sending any more.
-    if (!m_transactionOperationsInProgressQueue.isEmpty() && !m_transactionOperationsInProgressQueue.last()->nextRequestCanGoToServer())
+    if (!m_transactionOperationMap.contains(operation.identifier()))
         return;
 
-    // We want to batch operations together without spinning the runloop for performance,
-    // but don't want to affect responsiveness of the main thread.
-    // This number is a good compromise in ad-hoc testing.
-    static const size_t operationBatchLimit = 128;
-
-    for (size_t iterations = 0; !m_pendingTransactionOperationQueue.isEmpty() && iterations < operationBatchLimit; ++iterations) {
-        auto operation = m_pendingTransactionOperationQueue.takeFirst();
-        m_transactionOperationsInProgressQueue.append(operation.get());
-        operation->perform();
-
-        if (!operation->nextRequestCanGoToServer())
-            break;
-
-    }
-
-    if (!m_transactionOperationMap.isEmpty() || !m_openRequests.isEmpty())
-        return;
-
-    if (!isFinishedOrFinishing())
-        commit();
-}
-
-void IDBTransaction::operationCompletedOnServer(const IDBResultData& data, IDBClient::TransactionOperation& operation)
-{
-    ASSERT(&m_database->originThread() == &Thread::current());
-    ASSERT(&operation.originThread() == &Thread::current());
-
-    m_completedOnServerQueue.append({ &operation, data });
+    m_transactionOperationResultMap.set(&operation, IDBResultData(data));
 
     if (!m_currentlyCompletingRequest)
-        scheduleCompletedOperationTimer();
-}
-
-void IDBTransaction::scheduleCompletedOperationTimer()
-{
-    ASSERT(&m_database->originThread() == &Thread::current());
-
-    if (!m_completedOperationTimer.isActive())
-        m_completedOperationTimer.startOneShot(0_s);
+        handleOperationsCompletedOnServer();
 }
 
-void IDBTransaction::completedOperationTimerFired()
+void IDBTransaction::handleOperationsCompletedOnServer()
 {
-    LOG(IndexedDB, "IDBTransaction::completedOperationTimerFired (%p)", this);
-    ASSERT(&m_database->originThread() == &Thread::current());
-
-    if (m_completedOnServerQueue.isEmpty() || m_currentlyCompletingRequest)
-        return;
+    LOG(IndexedDB, "IDBTransaction::handleOperationsCompletedOnServer");
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
-    auto iterator = m_completedOnServerQueue.takeFirst();
-    iterator.first->doComplete(iterator.second);
+    while (!m_transactionOperationsInProgressQueue.isEmpty() && !m_currentlyCompletingRequest) {
+        RefPtr<IDBClient::TransactionOperation> currentOperation = m_transactionOperationsInProgressQueue.first();
+        if (!m_transactionOperationResultMap.contains(currentOperation))
+            return;
 
-    if (!m_completedOnServerQueue.isEmpty() && !m_currentlyCompletingRequest)
-        scheduleCompletedOperationTimer();
+        currentOperation->doComplete(m_transactionOperationResultMap.take(currentOperation));
+    }
 }
 
 void IDBTransaction::completeNoncursorRequest(IDBRequest& request, const IDBResultData& result)
 {
     ASSERT(!m_currentlyCompletingRequest);
@@ -492,23 +437,23 @@
     m_currentlyCompletingRequest = &request;
 }
 
 void IDBTransaction::finishedDispatchEventForRequest(IDBRequest& request)
 {
-    if (isFinishedOrFinishing())
+    if (isFinished())
         return;
 
     ASSERT_UNUSED(request, !m_currentlyCompletingRequest || m_currentlyCompletingRequest == &request);
 
     m_currentlyCompletingRequest = nullptr;
-    scheduleCompletedOperationTimer();
+    handleOperationsCompletedOnServer();
 }
 
 void IDBTransaction::commit()
 {
     LOG(IndexedDB, "IDBTransaction::commit");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(!isFinishedOrFinishing());
 
     transitionedToFinishing(IndexedDB::TransactionState::Committing);
     m_database->willCommitTransaction(*this);
 
@@ -519,11 +464,11 @@
 }
 
 void IDBTransaction::commitOnServer(IDBClient::TransactionOperation& operation)
 {
     LOG(IndexedDB, "IDBTransaction::commitOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().commitTransaction(*this);
 
     ASSERT(!m_transactionOperationsInProgressQueue.isEmpty());
     ASSERT(m_transactionOperationsInProgressQueue.last() == &operation);
@@ -534,19 +479,19 @@
 }
 
 void IDBTransaction::finishAbortOrCommit()
 {
     ASSERT(m_state != IndexedDB::TransactionState::Finished);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_state = IndexedDB::TransactionState::Finished;
 }
 
 void IDBTransaction::didStart(const IDBError& error)
 {
     LOG(IndexedDB, "IDBTransaction::didStart");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->didStartTransaction(*this);
 
     m_startedOnServer = true;
 
@@ -555,16 +500,21 @@
     if (!error.isNull()) {
         didAbort(error);
         return;
     }
 
-    schedulePendingOperationTimer();
+    handlePendingOperations();
+
+    // It's possible transaction does not create requests (or creates but finishes them early
+    // because of error) during intialization. In this case, since the transaction will
+    // not be active any more, we can end it.
+    autoCommit();
 }
 
 void IDBTransaction::notifyDidAbort(const IDBError& error)
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->didAbortTransaction(*this);
     m_idbError = error;
     fireOnAbort();
 
@@ -575,11 +525,11 @@
 }
 
 void IDBTransaction::didAbort(const IDBError& error)
 {
     LOG(IndexedDB, "IDBTransaction::didAbort");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (m_state == IndexedDB::TransactionState::Finished)
         return;
 
     notifyDidAbort(error);
@@ -588,11 +538,11 @@
 }
 
 void IDBTransaction::didCommit(const IDBError& error)
 {
     LOG(IndexedDB, "IDBTransaction::didCommit");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(m_state == IndexedDB::TransactionState::Committing);
 
     if (error.isNull()) {
         m_database->didCommitTransaction(*this);
         fireOnComplete();
@@ -605,41 +555,39 @@
 }
 
 void IDBTransaction::fireOnComplete()
 {
     LOG(IndexedDB, "IDBTransaction::fireOnComplete");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     enqueueEvent(Event::create(eventNames().completeEvent, Event::CanBubble::No, Event::IsCancelable::No));
 }
 
 void IDBTransaction::fireOnAbort()
 {
     LOG(IndexedDB, "IDBTransaction::fireOnAbort");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     enqueueEvent(Event::create(eventNames().abortEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
 }
 
 void IDBTransaction::enqueueEvent(Ref<Event>&& event)
 {
     ASSERT(m_state != IndexedDB::TransactionState::Finished);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (!scriptExecutionContext() || m_contextStopped)
         return;
 
-    event->setTarget(this);
-    scriptExecutionContext()->eventQueue().enqueueEvent(WTFMove(event));
+    queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));
 }
 
 void IDBTransaction::dispatchEvent(Event& event)
 {
     LOG(IndexedDB, "IDBTransaction::dispatchEvent");
 
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(scriptExecutionContext());
     ASSERT(!m_contextStopped);
-    ASSERT(event.target() == this);
     ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
 
     auto protectedThis = makeRef(*this);
 
     EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
@@ -663,11 +611,11 @@
 Ref<IDBObjectStore> IDBTransaction::createObjectStore(const IDBObjectStoreInfo& info)
 {
     LOG(IndexedDB, "IDBTransaction::createObjectStore");
     ASSERT(isVersionChange());
     ASSERT(scriptExecutionContext());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     Locker<Lock> locker(m_referencedObjectStoreLock);
 
     auto objectStore = makeUnique<IDBObjectStore>(*scriptExecutionContext(), info, *this);
     auto* rawObjectStore = objectStore.get();
@@ -676,28 +624,28 @@
     LOG(IndexedDBOperations, "IDB create object store operation: %s", info.condensedLoggingString().utf8().data());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto& result) {
         protectedThis->didCreateObjectStoreOnServer(result);
     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto& operation) {
         protectedThis->createObjectStoreOnServer(operation, info);
-    }));
+    }), IsWriteOperation::Yes);
 
     return *rawObjectStore;
 }
 
 void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation& operation, const IDBObjectStoreInfo& info)
 {
     LOG(IndexedDB, "IDBTransaction::createObjectStoreOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(isVersionChange());
 
     m_database->connectionProxy().createObjectStore(operation, info);
 }
 
 void IDBTransaction::didCreateObjectStoreOnServer(const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didCreateObjectStoreOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::CreateObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 }
 
 void IDBTransaction::renameObjectStore(IDBObjectStore& objectStore, const String& newName)
 {
@@ -705,11 +653,11 @@
 
     Locker<Lock> locker(m_referencedObjectStoreLock);
 
     ASSERT(isVersionChange());
     ASSERT(scriptExecutionContext());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT(m_referencedObjectStores.contains(objectStore.info().name()));
     ASSERT(!m_referencedObjectStores.contains(newName));
     ASSERT(m_referencedObjectStores.get(objectStore.info().name()) == &objectStore);
 
@@ -718,63 +666,63 @@
     LOG(IndexedDBOperations, "IDB rename object store operation: %s to %s", objectStore.info().condensedLoggingString().utf8().data(), newName.utf8().data());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto& result) {
         protectedThis->didRenameObjectStoreOnServer(result);
     }, [protectedThis = makeRef(*this), objectStoreIdentifier, newName = newName.isolatedCopy()] (auto& operation) {
         protectedThis->renameObjectStoreOnServer(operation, objectStoreIdentifier, newName);
-    }));
+    }), IsWriteOperation::Yes);
 
     m_referencedObjectStores.set(newName, m_referencedObjectStores.take(objectStore.info().name()));
 }
 
 void IDBTransaction::renameObjectStoreOnServer(IDBClient::TransactionOperation& operation, const uint64_t& objectStoreIdentifier, const String& newName)
 {
     LOG(IndexedDB, "IDBTransaction::renameObjectStoreOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(isVersionChange());
 
     m_database->connectionProxy().renameObjectStore(operation, objectStoreIdentifier, newName);
 }
 
 void IDBTransaction::didRenameObjectStoreOnServer(const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didRenameObjectStoreOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 }
 
 std::unique_ptr<IDBIndex> IDBTransaction::createIndex(IDBObjectStore& objectStore, const IDBIndexInfo& info)
 {
     LOG(IndexedDB, "IDBTransaction::createIndex");
     ASSERT(isVersionChange());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (!scriptExecutionContext())
         return nullptr;
 
     LOG(IndexedDBOperations, "IDB create index operation: %s under object store %s", info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto& result) {
         protectedThis->didCreateIndexOnServer(result);
     }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto& operation) {
         protectedThis->createIndexOnServer(operation, info);
-    }));
+    }), IsWriteOperation::Yes);
 
     return makeUnique<IDBIndex>(*scriptExecutionContext(), info, objectStore);
 }
 
 void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation& operation, const IDBIndexInfo& info)
 {
     LOG(IndexedDB, "IDBTransaction::createIndexOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(isVersionChange());
 
     m_database->connectionProxy().createIndex(operation, info);
 }
 
 void IDBTransaction::didCreateIndexOnServer(const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didCreateIndexOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (resultData.type() == IDBResultType::CreateIndexSuccess)
         return;
 
     ASSERT(resultData.type() == IDBResultType::Error);
@@ -792,11 +740,11 @@
     LOG(IndexedDB, "IDBTransaction::renameIndex");
     Locker<Lock> locker(m_referencedObjectStoreLock);
 
     ASSERT(isVersionChange());
     ASSERT(scriptExecutionContext());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT(m_referencedObjectStores.contains(index.objectStore().info().name()));
     ASSERT(m_referencedObjectStores.get(index.objectStore().info().name()) == &index.objectStore());
 
     index.objectStore().renameReferencedIndex(index, newName);
@@ -807,55 +755,55 @@
     LOG(IndexedDBOperations, "IDB rename index operation: %s to %s under object store %" PRIu64, index.info().condensedLoggingString().utf8().data(), newName.utf8().data(), index.info().objectStoreIdentifier());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto& result) {
         protectedThis->didRenameIndexOnServer(result);
     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] (auto& operation) {
         protectedThis->renameIndexOnServer(operation, objectStoreIdentifier, indexIdentifier, newName);
-    }));
+    }), IsWriteOperation::Yes);
 }
 
 void IDBTransaction::renameIndexOnServer(IDBClient::TransactionOperation& operation, const uint64_t& objectStoreIdentifier, const uint64_t& indexIdentifier, const String& newName)
 {
     LOG(IndexedDB, "IDBTransaction::renameIndexOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(isVersionChange());
 
     m_database->connectionProxy().renameIndex(operation, objectStoreIdentifier, indexIdentifier, newName);
 }
 
 void IDBTransaction::didRenameIndexOnServer(const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didRenameIndexOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameIndexSuccess || resultData.type() == IDBResultType::Error);
 }
 
-Ref<IDBRequest> IDBTransaction::requestOpenCursor(ExecState& state, IDBObjectStore& objectStore, const IDBCursorInfo& info)
+Ref<IDBRequest> IDBTransaction::requestOpenCursor(JSGlobalObject& state, IDBObjectStore& objectStore, const IDBCursorInfo& info)
 {
     LOG(IndexedDB, "IDBTransaction::requestOpenCursor");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
         return doRequestOpenCursor(state, IDBCursor::create(objectStore, info));
 
     return doRequestOpenCursor(state, IDBCursorWithValue::create(objectStore, info));
 }
 
-Ref<IDBRequest> IDBTransaction::requestOpenCursor(ExecState& state, IDBIndex& index, const IDBCursorInfo& info)
+Ref<IDBRequest> IDBTransaction::requestOpenCursor(JSGlobalObject& state, IDBIndex& index, const IDBCursorInfo& info)
 {
     LOG(IndexedDB, "IDBTransaction::requestOpenCursor");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
         return doRequestOpenCursor(state, IDBCursor::create(index, info));
 
     return doRequestOpenCursor(state, IDBCursorWithValue::create(index, info));
 }
 
-Ref<IDBRequest> IDBTransaction::doRequestOpenCursor(ExecState& state, Ref<IDBCursor>&& cursor)
+Ref<IDBRequest> IDBTransaction::doRequestOpenCursor(JSGlobalObject& state, Ref<IDBCursor>&& cursor)
 {
     ASSERT(isActive());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), cursor.get(), *this);
     addRequest(request.get());
@@ -871,29 +819,29 @@
 }
 
 void IDBTransaction::openCursorOnServer(IDBClient::TransactionOperation& operation, const IDBCursorInfo& info)
 {
     LOG(IndexedDB, "IDBTransaction::openCursorOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().openCursor(operation, info);
 }
 
 void IDBTransaction::didOpenCursorOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didOpenCursorOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     completeCursorRequest(request, resultData);
 }
 
 void IDBTransaction::iterateCursor(IDBCursor& cursor, const IDBIterateCursorData& data)
 {
     LOG(IndexedDB, "IDBTransaction::iterateCursor");
     ASSERT(isActive());
     ASSERT(cursor.request());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     addRequest(*cursor.request());
 
     LOG(IndexedDBOperations, "IDB iterate cursor operation: %s %s", cursor.info().loggingString().utf8().data(), data.loggingString().utf8().data());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, *cursor.request(), [protectedThis = makeRef(*this), request = makeRef(*cursor.request())] (const auto& result) {
@@ -905,28 +853,44 @@
 
 // FIXME: changes here
 void IDBTransaction::iterateCursorOnServer(IDBClient::TransactionOperation& operation, const IDBIterateCursorData& data)
 {
     LOG(IndexedDB, "IDBTransaction::iterateCursorOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
+    ASSERT(operation.idbRequest());
+
+    auto* cursor = operation.idbRequest()->pendingCursor();
+    ASSERT(cursor);
 
+    if (data.keyData.isNull() && data.primaryKeyData.isNull()) {
+        if (auto getResult = cursor->iterateWithPrefetchedRecords(data.count, m_lastWriteOperationID)) {
+            auto result = IDBResultData::iterateCursorSuccess(operation.identifier(), getResult.value());
+            m_database->connectionProxy().iterateCursor(operation, { data.keyData, data.primaryKeyData, data.count, IndexedDB::CursorIterateOption::DoNotReply });
+            operationCompletedOnServer(result, operation);
+            return;
+        }
+    }
+
+    cursor->clearPrefetchedRecords();
+
+    ASSERT(data.option == IndexedDB::CursorIterateOption::Reply);
     m_database->connectionProxy().iterateCursor(operation, data);
 }
 
 void IDBTransaction::didIterateCursorOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didIterateCursorOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     completeCursorRequest(request, resultData);
 }
 
-Ref<IDBRequest> IDBTransaction::requestGetAllObjectStoreRecords(JSC::ExecState& state, IDBObjectStore& objectStore, const IDBKeyRangeData& keyRangeData, IndexedDB::GetAllType getAllType, Optional<uint32_t> count)
+Ref<IDBRequest> IDBTransaction::requestGetAllObjectStoreRecords(JSC::JSGlobalObject& state, IDBObjectStore& objectStore, const IDBKeyRangeData& keyRangeData, IndexedDB::GetAllType getAllType, Optional<uint32_t> count)
 {
     LOG(IndexedDB, "IDBTransaction::requestGetAllObjectStoreRecords");
     ASSERT(isActive());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
     addRequest(request.get());
@@ -941,15 +905,15 @@
     }));
 
     return request;
 }
 
-Ref<IDBRequest> IDBTransaction::requestGetAllIndexRecords(JSC::ExecState& state, IDBIndex& index, const IDBKeyRangeData& keyRangeData, IndexedDB::GetAllType getAllType, Optional<uint32_t> count)
+Ref<IDBRequest> IDBTransaction::requestGetAllIndexRecords(JSC::JSGlobalObject& state, IDBIndex& index, const IDBKeyRangeData& keyRangeData, IndexedDB::GetAllType getAllType, Optional<uint32_t> count)
 {
     LOG(IndexedDB, "IDBTransaction::requestGetAllIndexRecords");
     ASSERT(isActive());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
     addRequest(request.get());
@@ -967,19 +931,19 @@
 }
 
 void IDBTransaction::getAllRecordsOnServer(IDBClient::TransactionOperation& operation, const IDBGetAllRecordsData& getAllRecordsData)
 {
     LOG(IndexedDB, "IDBTransaction::getAllRecordsOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().getAllRecords(operation, getAllRecordsData);
 }
 
 void IDBTransaction::didGetAllRecordsOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didGetAllRecordsOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (resultData.type() == IDBResultType::Error) {
         completeNoncursorRequest(request, resultData);
         return;
     }
@@ -997,16 +961,16 @@
     }
 
     completeNoncursorRequest(request, resultData);
 }
 
-Ref<IDBRequest> IDBTransaction::requestGetRecord(ExecState& state, IDBObjectStore& objectStore, const IDBGetRecordData& getRecordData)
+Ref<IDBRequest> IDBTransaction::requestGetRecord(JSGlobalObject& state, IDBObjectStore& objectStore, const IDBGetRecordData& getRecordData)
 {
     LOG(IndexedDB, "IDBTransaction::requestGetRecord");
     ASSERT(isActive());
     ASSERT(!getRecordData.keyRangeData.isNull);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
 
@@ -1021,32 +985,32 @@
     }));
 
     return request;
 }
 
-Ref<IDBRequest> IDBTransaction::requestGetValue(ExecState& state, IDBIndex& index, const IDBKeyRangeData& range)
+Ref<IDBRequest> IDBTransaction::requestGetValue(JSGlobalObject& state, IDBIndex& index, const IDBKeyRangeData& range)
 {
     LOG(IndexedDB, "IDBTransaction::requestGetValue");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Value, range);
 }
 
-Ref<IDBRequest> IDBTransaction::requestGetKey(ExecState& state, IDBIndex& index, const IDBKeyRangeData& range)
+Ref<IDBRequest> IDBTransaction::requestGetKey(JSGlobalObject& state, IDBIndex& index, const IDBKeyRangeData& range)
 {
     LOG(IndexedDB, "IDBTransaction::requestGetValue");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Key, range);
 }
 
-Ref<IDBRequest> IDBTransaction::requestIndexRecord(ExecState& state, IDBIndex& index, IndexedDB::IndexRecordType type, const IDBKeyRangeData& range)
+Ref<IDBRequest> IDBTransaction::requestIndexRecord(JSGlobalObject& state, IDBIndex& index, IndexedDB::IndexRecordType type, const IDBKeyRangeData& range)
 {
     LOG(IndexedDB, "IDBTransaction::requestGetValue");
     ASSERT(isActive());
     ASSERT(!range.isNull);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::createIndexGet(*scriptExecutionContext(), index, type, *this);
     addRequest(request.get());
@@ -1064,19 +1028,19 @@
 }
 
 void IDBTransaction::getRecordOnServer(IDBClient::TransactionOperation& operation, const IDBGetRecordData& getRecordData)
 {
     LOG(IndexedDB, "IDBTransaction::getRecordOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().getRecord(operation, getRecordData);
 }
 
 void IDBTransaction::didGetRecordOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didGetRecordOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (resultData.type() == IDBResultType::Error) {
         completeNoncursorRequest(request, resultData);
         return;
     }
@@ -1102,16 +1066,16 @@
     }
 
     completeNoncursorRequest(request, resultData);
 }
 
-Ref<IDBRequest> IDBTransaction::requestCount(ExecState& state, IDBObjectStore& objectStore, const IDBKeyRangeData& range)
+Ref<IDBRequest> IDBTransaction::requestCount(JSGlobalObject& state, IDBObjectStore& objectStore, const IDBKeyRangeData& range)
 {
     LOG(IndexedDB, "IDBTransaction::requestCount (IDBObjectStore)");
     ASSERT(isActive());
     ASSERT(!range.isNull);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
     addRequest(request.get());
@@ -1124,16 +1088,16 @@
     }));
 
     return request;
 }
 
-Ref<IDBRequest> IDBTransaction::requestCount(ExecState& state, IDBIndex& index, const IDBKeyRangeData& range)
+Ref<IDBRequest> IDBTransaction::requestCount(JSGlobalObject& state, IDBIndex& index, const IDBKeyRangeData& range)
 {
     LOG(IndexedDB, "IDBTransaction::requestCount (IDBIndex)");
     ASSERT(isActive());
     ASSERT(!range.isNull);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
     addRequest(request.get());
@@ -1149,30 +1113,30 @@
 }
 
 void IDBTransaction::getCountOnServer(IDBClient::TransactionOperation& operation, const IDBKeyRangeData& keyRange)
 {
     LOG(IndexedDB, "IDBTransaction::getCountOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().getCount(operation, keyRange);
 }
 
 void IDBTransaction::didGetCountOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didGetCountOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     request.setResult(resultData.resultInteger());
     completeNoncursorRequest(request, resultData);
 }
 
-Ref<IDBRequest> IDBTransaction::requestDeleteRecord(ExecState& state, IDBObjectStore& objectStore, const IDBKeyRangeData& range)
+Ref<IDBRequest> IDBTransaction::requestDeleteRecord(JSGlobalObject& state, IDBObjectStore& objectStore, const IDBKeyRangeData& range)
 {
     LOG(IndexedDB, "IDBTransaction::requestDeleteRecord");
     ASSERT(isActive());
     ASSERT(!range.isNull);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
     addRequest(request.get());
@@ -1180,36 +1144,36 @@
     LOG(IndexedDBOperations, "IDB delete record operation: %s, range %s", objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto& result) {
         protectedThis->didDeleteRecordOnServer(request.get(), result);
     }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto& operation) {
         protectedThis->deleteRecordOnServer(operation, range);
-    }));
+    }), IsWriteOperation::Yes);
     return request;
 }
 
 void IDBTransaction::deleteRecordOnServer(IDBClient::TransactionOperation& operation, const IDBKeyRangeData& keyRange)
 {
     LOG(IndexedDB, "IDBTransaction::deleteRecordOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().deleteRecord(operation, keyRange);
 }
 
 void IDBTransaction::didDeleteRecordOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didDeleteRecordOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     request.setResultToUndefined();
     completeNoncursorRequest(request, resultData);
 }
 
-Ref<IDBRequest> IDBTransaction::requestClearObjectStore(ExecState& state, IDBObjectStore& objectStore)
+Ref<IDBRequest> IDBTransaction::requestClearObjectStore(JSGlobalObject& state, IDBObjectStore& objectStore)
 {
     LOG(IndexedDB, "IDBTransaction::requestClearObjectStore");
     ASSERT(isActive());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
     addRequest(request.get());
@@ -1219,39 +1183,39 @@
     LOG(IndexedDBOperations, "IDB clear object store operation: %s", objectStore.info().condensedLoggingString().utf8().data());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto& result) {
         protectedThis->didClearObjectStoreOnServer(request.get(), result);
     }, [protectedThis = makeRef(*this), objectStoreIdentifier] (auto& operation) {
         protectedThis->clearObjectStoreOnServer(operation, objectStoreIdentifier);
-    }));
+    }), IsWriteOperation::Yes);
 
     return request;
 }
 
 void IDBTransaction::clearObjectStoreOnServer(IDBClient::TransactionOperation& operation, const uint64_t& objectStoreIdentifier)
 {
     LOG(IndexedDB, "IDBTransaction::clearObjectStoreOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().clearObjectStore(operation, objectStoreIdentifier);
 }
 
 void IDBTransaction::didClearObjectStoreOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didClearObjectStoreOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     request.setResultToUndefined();
     completeNoncursorRequest(request, resultData);
 }
 
-Ref<IDBRequest> IDBTransaction::requestPutOrAdd(ExecState& state, IDBObjectStore& objectStore, RefPtr<IDBKey>&& key, SerializedScriptValue& value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
+Ref<IDBRequest> IDBTransaction::requestPutOrAdd(JSGlobalObject& state, IDBObjectStore& objectStore, RefPtr<IDBKey>&& key, SerializedScriptValue& value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
 {
     LOG(IndexedDB, "IDBTransaction::requestPutOrAdd");
     ASSERT(isActive());
     ASSERT(!isReadOnly());
     ASSERT(objectStore.info().autoIncrement() || key);
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&state));
 
     auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
     addRequest(request.get());
@@ -1259,19 +1223,19 @@
     LOG(IndexedDBOperations, "IDB putOrAdd operation: %s key: %s", objectStore.info().condensedLoggingString().utf8().data(), key ? key->loggingString().utf8().data() : "<null key>");
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto& result) {
         protectedThis->didPutOrAddOnServer(request.get(), result);
     }, [protectedThis = makeRef(*this), key, value = makeRef(value), overwriteMode] (auto& operation) {
         protectedThis->putOrAddOnServer(operation, key.get(), value.ptr(), overwriteMode);
-    }));
+    }), IsWriteOperation::Yes);
 
     return request;
 }
 
 void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation& operation, RefPtr<IDBKey> key, RefPtr<SerializedScriptValue> value, const IndexedDB::ObjectStoreOverwriteMode& overwriteMode)
 {
     LOG(IndexedDB, "IDBTransaction::putOrAddOnServer");
-    ASSERT(&originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
     ASSERT(!isReadOnly());
     ASSERT(value);
 
     if (!value->hasBlobURLs()) {
         m_database->connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
@@ -1280,11 +1244,11 @@
 
     // Due to current limitations on our ability to post tasks back to a worker thread,
     // workers currently write blobs to disk synchronously.
     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
     if (!isMainThread()) {
-        auto idbValue = value->writeBlobsToDiskForIndexedDBSynchronously(scriptExecutionContext()->sessionID());
+        auto idbValue = value->writeBlobsToDiskForIndexedDBSynchronously();
         if (idbValue.data().data())
             m_database->connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
         else {
             // If the IDBValue doesn't have any data, then something went wrong writing the blobs to disk.
             // In that case, we cannot successfully store this record, so we callback with an error.
@@ -1299,12 +1263,12 @@
 
     // Since this request won't actually go to the server until the blob writes are complete,
     // stop future requests from going to the server ahead of it.
     operation.setNextRequestCanGoToServer(false);
 
-    value->writeBlobsToDiskForIndexedDB(scriptExecutionContext()->sessionID(), [protectedThis = makeRef(*this), this, protectedOperation = Ref<IDBClient::TransactionOperation>(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&& idbValue) mutable {
-        ASSERT(&originThread() == &Thread::current());
+    value->writeBlobsToDiskForIndexedDB([protectedThis = makeRef(*this), this, protectedOperation = Ref<IDBClient::TransactionOperation>(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&& idbValue) mutable {
+        ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
         ASSERT(isMainThread());
         if (idbValue.data().data()) {
             m_database->connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
             return;
         }
@@ -1319,11 +1283,11 @@
 }
 
 void IDBTransaction::didPutOrAddOnServer(IDBRequest& request, const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didPutOrAddOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (auto* result = resultData.resultKey())
         request.setResult(*result);
     else
         request.setResultToUndefined();
@@ -1331,11 +1295,11 @@
 }
 
 void IDBTransaction::deleteObjectStore(const String& objectStoreName)
 {
     LOG(IndexedDB, "IDBTransaction::deleteObjectStore");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(isVersionChange());
 
     Locker<Lock> locker(m_referencedObjectStoreLock);
 
     if (auto objectStore = m_referencedObjectStores.take(objectStoreName)) {
@@ -1347,124 +1311,133 @@
     LOG(IndexedDBOperations, "IDB delete object store operation: %s", objectStoreName.utf8().data());
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto& result) {
         protectedThis->didDeleteObjectStoreOnServer(result);
     }, [protectedThis = makeRef(*this), objectStoreName = objectStoreName.isolatedCopy()] (auto& operation) {
         protectedThis->deleteObjectStoreOnServer(operation, objectStoreName);
-    }));
+    }), IsWriteOperation::Yes);
 }
 
 void IDBTransaction::deleteObjectStoreOnServer(IDBClient::TransactionOperation& operation, const String& objectStoreName)
 {
     LOG(IndexedDB, "IDBTransaction::deleteObjectStoreOnServer");
     ASSERT(isVersionChange());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().deleteObjectStore(operation, objectStoreName);
 }
 
 void IDBTransaction::didDeleteObjectStoreOnServer(const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didDeleteObjectStoreOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteObjectStoreSuccess || resultData.type() == IDBResultType::Error);
 }
 
 void IDBTransaction::deleteIndex(uint64_t objectStoreIdentifier, const String& indexName)
 {
     LOG(IndexedDB, "IDBTransaction::deleteIndex");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT(isVersionChange());
 
     LOG(IndexedDBOperations, "IDB delete index operation: %s (%" PRIu64 ")", indexName.utf8().data(), objectStoreIdentifier);
     scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto& result) {
         protectedThis->didDeleteIndexOnServer(result);
     }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexName = indexName.isolatedCopy()] (auto& operation) {
         protectedThis->deleteIndexOnServer(operation, objectStoreIdentifier, indexName);
-    }));
+    }), IsWriteOperation::Yes);
 }
 
 void IDBTransaction::deleteIndexOnServer(IDBClient::TransactionOperation& operation, const uint64_t& objectStoreIdentifier, const String& indexName)
 {
     LOG(IndexedDB, "IDBTransaction::deleteIndexOnServer");
     ASSERT(isVersionChange());
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().deleteIndex(operation, objectStoreIdentifier, indexName);
 }
 
 void IDBTransaction::didDeleteIndexOnServer(const IDBResultData& resultData)
 {
     LOG(IndexedDB, "IDBTransaction::didDeleteIndexOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
     ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteIndexSuccess || resultData.type() == IDBResultType::Error);
 }
 
 void IDBTransaction::operationCompletedOnClient(IDBClient::TransactionOperation& operation)
 {
     LOG(IndexedDB, "IDBTransaction::operationCompletedOnClient");
 
-    ASSERT(&m_database->originThread() == &Thread::current());
-    ASSERT(&operation.originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
+    ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));
     ASSERT(m_transactionOperationMap.get(operation.identifier()) == &operation);
     ASSERT(m_transactionOperationsInProgressQueue.first() == &operation);
 
     m_transactionOperationMap.remove(operation.identifier());
     m_transactionOperationsInProgressQueue.removeFirst();
 
-    schedulePendingOperationTimer();
+    if (m_transactionOperationsInProgressQueue.isEmpty())
+        handlePendingOperations();
+
+    autoCommit();
 }
 
 void IDBTransaction::establishOnServer()
 {
     LOG(IndexedDB, "IDBTransaction::establishOnServer");
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     m_database->connectionProxy().establishTransaction(*this);
 }
 
 void IDBTransaction::activate()
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (isFinishedOrFinishing())
         return;
 
     m_state = IndexedDB::TransactionState::Active;
 }
 
 void IDBTransaction::deactivate()
 {
-    ASSERT(&m_database->originThread() == &Thread::current());
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
 
     if (m_state == IndexedDB::TransactionState::Active)
         m_state = IndexedDB::TransactionState::Inactive;
 
-    schedulePendingOperationTimer();
+    autoCommit();
 }
 
 void IDBTransaction::connectionClosedFromServer(const IDBError& error)
 {
     LOG(IndexedDB, "IDBTransaction::connectionClosedFromServer - %s", error.message().utf8().data());
 
     m_database->willAbortTransaction(*this);
     m_state = IndexedDB::TransactionState::Aborting;
 
+    // Move operations out of m_pendingTransactionOperationQueue, otherwise we may start handling
+    // them after we forcibly complete in-progress transactions.
+    Deque<RefPtr<IDBClient::TransactionOperation>> pendingTransactionOperationQueue;
+    pendingTransactionOperationQueue.swap(m_pendingTransactionOperationQueue);
+
     abortInProgressOperations(error);
 
     auto operations = copyToVector(m_transactionOperationMap.values());
     for (auto& operation : operations) {
         m_currentlyCompletingRequest = nullptr;
         m_transactionOperationsInProgressQueue.append(operation.get());
         ASSERT(m_transactionOperationsInProgressQueue.first() == operation.get());
         operation->doComplete(IDBResultData::error(operation->identifier(), error));
     }
     m_currentlyCompletingRequest = nullptr;
+    m_openRequests.clear();
+    pendingTransactionOperationQueue.clear();
 
     connectionProxy().forgetActiveOperations(operations);
     connectionProxy().forgetTransaction(*this);
 
-    m_pendingTransactionOperationQueue.clear();
     m_abortQueue.clear();
     m_transactionOperationMap.clear();
 
     m_idbError = error;
     m_domError = error.toDOMException();
@@ -1479,8 +1452,54 @@
         visitor.addOpaqueRoot(objectStore.get());
     for (auto& objectStore : m_deletedObjectStores.values())
         visitor.addOpaqueRoot(objectStore.get());
 }
 
+void IDBTransaction::handlePendingOperations()
+{
+    ASSERT(canCurrentThreadAccessThreadLocalData(m_database->originThread()));
+
+    if (!m_startedOnServer)
+        return;
+
+    if (!m_transactionOperationsInProgressQueue.isEmpty() && !m_transactionOperationsInProgressQueue.last()->nextRequestCanGoToServer())
+        return;
+
+    while (!m_pendingTransactionOperationQueue.isEmpty()) {
+        auto operation = m_pendingTransactionOperationQueue.takeFirst();
+        m_transactionOperationsInProgressQueue.append(operation.get());
+        operation->perform();
+
+        if (!operation->nextRequestCanGoToServer())
+            break;
+    }
+}
+
+void IDBTransaction::autoCommit()
+{
+    // If transaction is not inactive, it's active, finished or finishing.
+    // If it's active, it may create new requests, so we cannot commit it.
+    if (m_state != IndexedDB::TransactionState::Inactive)
+        return;
+
+    if (!m_startedOnServer)
+        return;
+
+    if (!m_transactionOperationMap.isEmpty())
+        return;
+
+    if (!m_openRequests.isEmpty())
+        return;
+    ASSERT(!m_currentlyCompletingRequest);
+
+    commit();
+}
+
+uint64_t IDBTransaction::generateOperationID()
+{
+    static std::atomic<uint64_t> currentOperationID(1);
+    return currentOperationID += 1;
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(INDEXED_DATABASE)

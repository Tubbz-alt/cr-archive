<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DebuggerPrimitives.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerScope.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 75,22 ***</span>
          return String();
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
      return thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm);
  }
  
<span class="line-modified">! String DebuggerScope::toStringName(const JSObject* object, ExecState* exec)</span>
  {
      const DebuggerScope* scope = jsCast&lt;const DebuggerScope*&gt;(object);
      // We cannot assert that scope-&gt;isValid() because the TypeProfiler may encounter an invalidated
      // DebuggerScope in its log entries. We just need to handle it appropriately as below.
      if (!scope-&gt;isValid())
          return String();
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;toStringName(thisObject, exec);</span>
  }
  
<span class="line-modified">! bool DebuggerScope::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-new-header">--- 75,22 ---</span>
          return String();
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
      return thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm);
  }
  
<span class="line-modified">! String DebuggerScope::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
  {
      const DebuggerScope* scope = jsCast&lt;const DebuggerScope*&gt;(object);
      // We cannot assert that scope-&gt;isValid() because the TypeProfiler may encounter an invalidated
      // DebuggerScope in its log entries. We just need to handle it appropriately as below.
      if (!scope-&gt;isValid())
          return String();
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;toStringName(thisObject, globalObject);</span>
  }
  
<span class="line-modified">! bool DebuggerScope::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,12 ***</span>
      // Instead, we&#39;ll treat all properties in the wrapped scope and its prototype chain as
      // the own properties of the DebuggerScope. This is fine because the WebInspector
      // does not presently need to distinguish between what&#39;s owned at each level in the
      // prototype chain. Hence, we&#39;ll invoke getPropertySlot() on the wrapped scope here
      // instead of getOwnPropertySlot().
<span class="line-modified">!     bool result = thisObject-&gt;getPropertySlot(exec, propertyName, slot);</span>
<span class="line-modified">!     if (result &amp;&amp; slot.isValue() &amp;&amp; slot.getValue(exec, propertyName) == jsTDZValue()) {</span>
          // FIXME:
          // We hit a scope property that has the TDZ empty value.
          // Currently, we just lie to the inspector and claim that this property is undefined.
          // This is not ideal and we should fix it.
          // https://bugs.webkit.org/show_bug.cgi?id=144977
<span class="line-new-header">--- 103,12 ---</span>
      // Instead, we&#39;ll treat all properties in the wrapped scope and its prototype chain as
      // the own properties of the DebuggerScope. This is fine because the WebInspector
      // does not presently need to distinguish between what&#39;s owned at each level in the
      // prototype chain. Hence, we&#39;ll invoke getPropertySlot() on the wrapped scope here
      // instead of getOwnPropertySlot().
<span class="line-modified">!     bool result = thisObject-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
<span class="line-modified">!     if (result &amp;&amp; slot.isValue() &amp;&amp; slot.getValue(globalObject, propertyName) == jsTDZValue()) {</span>
          // FIXME:
          // We hit a scope property that has the TDZ empty value.
          // Currently, we just lie to the inspector and claim that this property is undefined.
          // This is not ideal and we should fix it.
          // https://bugs.webkit.org/show_bug.cgi?id=144977
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,49 ***</span>
          return true;
      }
      return result;
  }
  
<span class="line-modified">! bool DebuggerScope::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
      slot.setThisValue(JSValue(thisObject));
<span class="line-modified">!     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;put(thisObject, exec, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! bool DebuggerScope::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;deleteProperty(thisObject, exec, propertyName);</span>
  }
  
<span class="line-modified">! void DebuggerScope::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     thisObject-&gt;methodTable(exec-&gt;vm())-&gt;getPropertyNames(thisObject, exec, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool DebuggerScope::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     return thisObject-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
  }
  
  DebuggerScope* DebuggerScope::next()
  {
      ASSERT(isValid());
<span class="line-new-header">--- 116,49 ---</span>
          return true;
      }
      return result;
  }
  
<span class="line-modified">! bool DebuggerScope::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
      slot.setThisValue(JSValue(thisObject));
<span class="line-modified">!     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;put(thisObject, globalObject, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! bool DebuggerScope::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(cell);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;deleteProperty(thisObject, globalObject, propertyName);</span>
  }
  
<span class="line-modified">! void DebuggerScope::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;getPropertyNames(thisObject, globalObject, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool DebuggerScope::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      DebuggerScope* scope = jsCast&lt;DebuggerScope*&gt;(object);
      ASSERT(scope-&gt;isValid());
      if (!scope-&gt;isValid())
          return false;
      JSObject* thisObject = JSScope::objectAtScope(scope-&gt;jsScope());
<span class="line-modified">!     return thisObject-&gt;methodTable(globalObject-&gt;vm())-&gt;defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);</span>
  }
  
  DebuggerScope* DebuggerScope::next()
  {
      ASSERT(isValid());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,19 ***</span>
  
      ScriptExecutable* executable = codeBlock-&gt;ownerExecutable();
      return DebuggerLocation(executable);
  }
  
<span class="line-modified">! JSValue DebuggerScope::caughtValue(ExecState* exec) const</span>
  {
      ASSERT(isCatchScope());
      JSLexicalEnvironment* catchEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(m_scope.get());
      SymbolTable* catchSymbolTable = catchEnvironment-&gt;symbolTable();
      RELEASE_ASSERT(catchSymbolTable-&gt;size() == 1);
      PropertyName errorName(catchSymbolTable-&gt;begin(catchSymbolTable-&gt;m_lock)-&gt;key.get());
      PropertySlot slot(m_scope.get(), PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     bool success = catchEnvironment-&gt;getOwnPropertySlot(catchEnvironment, exec, errorName, slot);</span>
      RELEASE_ASSERT(success &amp;&amp; slot.isValue());
<span class="line-modified">!     return slot.getValue(exec, errorName);</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 247,19 ---</span>
  
      ScriptExecutable* executable = codeBlock-&gt;ownerExecutable();
      return DebuggerLocation(executable);
  }
  
<span class="line-modified">! JSValue DebuggerScope::caughtValue(JSGlobalObject* globalObject) const</span>
  {
      ASSERT(isCatchScope());
      JSLexicalEnvironment* catchEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(m_scope.get());
      SymbolTable* catchSymbolTable = catchEnvironment-&gt;symbolTable();
      RELEASE_ASSERT(catchSymbolTable-&gt;size() == 1);
      PropertyName errorName(catchSymbolTable-&gt;begin(catchSymbolTable-&gt;m_lock)-&gt;key.get());
      PropertySlot slot(m_scope.get(), PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     bool success = catchEnvironment-&gt;getOwnPropertySlot(catchEnvironment, globalObject, errorName, slot);</span>
      RELEASE_ASSERT(success &amp;&amp; slot.isValue());
<span class="line-modified">!     return slot.getValue(globalObject, errorName);</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="DebuggerPrimitives.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DebuggerScope.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArrayMode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGArithMode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArrayMode.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArrayMode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
286                 return typedArrayResult(withSpeculation(Array::OutOfBounds));
287         }
288         return typedArrayResult(withSpeculation(Array::InBounds));
289     case Array::Unprofiled:
290     case Array::SelectUsingPredictions: {
291         base &amp;= ~SpecOther;
292 
293         if (isStringSpeculation(base))
294             return withType(Array::String);
295 
296         if (isDirectArgumentsSpeculation(base) || isScopedArgumentsSpeculation(base)) {
297             // Handle out-of-bounds accesses as generic accesses.
298             Array::Type type = isDirectArgumentsSpeculation(base) ? Array::DirectArguments : Array::ScopedArguments;
299             if (graph.hasExitSite(node-&gt;origin.semantic, OutOfBounds) || !isInBounds()) {
300                 // FIXME: Support OOB access for ScopedArguments.
301                 // https://bugs.webkit.org/show_bug.cgi?id=179596
302                 if (type == Array::DirectArguments)
303                     return ArrayMode(type, Array::NonArray, Array::OutOfBounds, Array::AsIs, action());
304                 return ArrayMode(Array::Generic, action());
305             }
<span class="line-removed">306             if (isX86() &amp;&amp; is32Bit() &amp;&amp; isScopedArgumentsSpeculation(base))</span>
<span class="line-removed">307                 return ArrayMode(Array::Generic, action());</span>
308             return withType(type);
309         }
310 
311         ArrayMode result;
312         switch (node-&gt;op()) {
313         case PutByVal:
314             if (graph.hasExitSite(node-&gt;origin.semantic, OutOfBounds) || !isInBounds())
315                 result = withSpeculation(Array::OutOfBounds);
316             else
317                 result = withSpeculation(Array::InBounds);
318             break;
319 
320         default:
321             result = withSpeculation(Array::InBounds);
322             break;
323         }
324 
325         if (isInt8ArraySpeculation(base))
326             return typedArrayResult(result.withType(Array::Int8Array));
327 
</pre>
<hr />
<pre>
402     case Array::OriginalNonArray: {
403         TypedArrayType type = typedArrayType();
404         if (type == NotTypedArray)
405             return nullptr;
406 
407         return globalObject-&gt;typedArrayStructureConcurrently(type);
408     }
409 
410     default:
411         return nullptr;
412     }
413 }
414 
415 Structure* ArrayMode::originalArrayStructure(Graph&amp; graph, Node* node) const
416 {
417     return originalArrayStructure(graph, node-&gt;origin.semantic);
418 }
419 
420 bool ArrayMode::alreadyChecked(Graph&amp; graph, Node* node, const AbstractValue&amp; value, IndexingType shape) const
421 {






422     switch (arrayClass()) {
<span class="line-modified">423     case Array::OriginalArray: {</span>
<span class="line-modified">424         if (value.m_structure.isTop())</span>


425             return false;
426         for (unsigned i = value.m_structure.size(); i--;) {
427             RegisteredStructure structure = value.m_structure[i];
<span class="line-modified">428             if ((structure-&gt;indexingType() &amp; IndexingShapeMask) != shape)</span>
<span class="line-removed">429                 return false;</span>
<span class="line-removed">430             if (isCopyOnWrite(structure-&gt;indexingMode()) &amp;&amp; action() == Array::Write)</span>
<span class="line-removed">431                 return false;</span>
<span class="line-removed">432             if (!(structure-&gt;indexingType() &amp; IsArray))</span>
<span class="line-removed">433                 return false;</span>
<span class="line-removed">434             if (!graph.globalObjectFor(node-&gt;origin.semantic)-&gt;isOriginalArrayStructure(structure.get()))</span>
435                 return false;
436         }
437         return true;
438     }
439 
<span class="line-modified">440     case Array::Array: {</span>
<span class="line-modified">441         if (arrayModesAlreadyChecked(value.m_arrayModes, asArrayModesIgnoringTypedArrays(shape | IsArray)))</span>



442             return true;
<span class="line-modified">443         if (value.m_structure.isTop())</span>
444             return false;
445         for (unsigned i = value.m_structure.size(); i--;) {
446             RegisteredStructure structure = value.m_structure[i];
<span class="line-modified">447             if ((structure-&gt;indexingMode() &amp; IndexingShapeMask) != shape)</span>
<span class="line-removed">448                 return false;</span>
<span class="line-removed">449             if (isCopyOnWrite(structure-&gt;indexingMode()) &amp;&amp; action() == Array::Write)</span>
<span class="line-removed">450                 return false;</span>
<span class="line-removed">451             if (!(structure-&gt;indexingType() &amp; IsArray))</span>
452                 return false;
453         }
454         return true;
455     }
456 
<span class="line-modified">457     default: {</span>
458         if (arrayModesAlreadyChecked(value.m_arrayModes, asArrayModesIgnoringTypedArrays(shape) | asArrayModesIgnoringTypedArrays(shape | IsArray)))
459             return true;
<span class="line-modified">460         if (value.m_structure.isTop())</span>
461             return false;
462         for (unsigned i = value.m_structure.size(); i--;) {
463             RegisteredStructure structure = value.m_structure[i];
<span class="line-modified">464             if ((structure-&gt;indexingMode() &amp; IndexingShapeMask) != shape)</span>
<span class="line-removed">465                 return false;</span>
<span class="line-removed">466             if (isCopyOnWrite(structure-&gt;indexingMode()) &amp;&amp; action() == Array::Write)</span>
467                 return false;
468         }
469         return true;
<span class="line-modified">470     } }</span>














471 }
472 
473 bool ArrayMode::alreadyChecked(Graph&amp; graph, Node* node, const AbstractValue&amp; value) const
474 {
475     switch (type()) {
476     case Array::Generic:
477         return true;
478 
479     case Array::ForceExit:
480         return false;
481 
482     case Array::String:
483         return speculationChecked(value.m_type, SpecString);
484 
485     case Array::Int32:
486         return alreadyChecked(graph, node, value, Int32Shape);
487 
488     case Array::Double:
489         return alreadyChecked(graph, node, value, DoubleShape);
490 
</pre>
</td>
<td>
<hr />
<pre>
286                 return typedArrayResult(withSpeculation(Array::OutOfBounds));
287         }
288         return typedArrayResult(withSpeculation(Array::InBounds));
289     case Array::Unprofiled:
290     case Array::SelectUsingPredictions: {
291         base &amp;= ~SpecOther;
292 
293         if (isStringSpeculation(base))
294             return withType(Array::String);
295 
296         if (isDirectArgumentsSpeculation(base) || isScopedArgumentsSpeculation(base)) {
297             // Handle out-of-bounds accesses as generic accesses.
298             Array::Type type = isDirectArgumentsSpeculation(base) ? Array::DirectArguments : Array::ScopedArguments;
299             if (graph.hasExitSite(node-&gt;origin.semantic, OutOfBounds) || !isInBounds()) {
300                 // FIXME: Support OOB access for ScopedArguments.
301                 // https://bugs.webkit.org/show_bug.cgi?id=179596
302                 if (type == Array::DirectArguments)
303                     return ArrayMode(type, Array::NonArray, Array::OutOfBounds, Array::AsIs, action());
304                 return ArrayMode(Array::Generic, action());
305             }


306             return withType(type);
307         }
308 
309         ArrayMode result;
310         switch (node-&gt;op()) {
311         case PutByVal:
312             if (graph.hasExitSite(node-&gt;origin.semantic, OutOfBounds) || !isInBounds())
313                 result = withSpeculation(Array::OutOfBounds);
314             else
315                 result = withSpeculation(Array::InBounds);
316             break;
317 
318         default:
319             result = withSpeculation(Array::InBounds);
320             break;
321         }
322 
323         if (isInt8ArraySpeculation(base))
324             return typedArrayResult(result.withType(Array::Int8Array));
325 
</pre>
<hr />
<pre>
400     case Array::OriginalNonArray: {
401         TypedArrayType type = typedArrayType();
402         if (type == NotTypedArray)
403             return nullptr;
404 
405         return globalObject-&gt;typedArrayStructureConcurrently(type);
406     }
407 
408     default:
409         return nullptr;
410     }
411 }
412 
413 Structure* ArrayMode::originalArrayStructure(Graph&amp; graph, Node* node) const
414 {
415     return originalArrayStructure(graph, node-&gt;origin.semantic);
416 }
417 
418 bool ArrayMode::alreadyChecked(Graph&amp; graph, Node* node, const AbstractValue&amp; value, IndexingType shape) const
419 {
<span class="line-added">420     ASSERT(isSpecific());</span>
<span class="line-added">421 </span>
<span class="line-added">422     IndexingType indexingModeMask = IsArray | IndexingShapeMask;</span>
<span class="line-added">423     if (action() == Array::Write)</span>
<span class="line-added">424         indexingModeMask |= CopyOnWrite;</span>
<span class="line-added">425 </span>
426     switch (arrayClass()) {
<span class="line-modified">427     case Array::Array: {</span>
<span class="line-modified">428         if (arrayModesAlreadyChecked(value.m_arrayModes, asArrayModesIgnoringTypedArrays(shape | IsArray)))</span>
<span class="line-added">429             return true;</span>
<span class="line-added">430         if (!value.m_structure.isFinite())</span>
431             return false;
432         for (unsigned i = value.m_structure.size(); i--;) {
433             RegisteredStructure structure = value.m_structure[i];
<span class="line-modified">434             if ((structure-&gt;indexingMode() &amp; indexingModeMask) != (shape | IsArray))</span>






435                 return false;
436         }
437         return true;
438     }
439 
<span class="line-modified">440     // Array::OriginalNonArray can be shown when the value is a TypedArray with original structure.</span>
<span class="line-modified">441     // But here, we already filtered TypedArrays. So, just handle it like a NonArray.</span>
<span class="line-added">442     case Array::OriginalNonArray:</span>
<span class="line-added">443     case Array::NonArray: {</span>
<span class="line-added">444         if (arrayModesAlreadyChecked(value.m_arrayModes, asArrayModesIgnoringTypedArrays(shape)))</span>
445             return true;
<span class="line-modified">446         if (!value.m_structure.isFinite())</span>
447             return false;
448         for (unsigned i = value.m_structure.size(); i--;) {
449             RegisteredStructure structure = value.m_structure[i];
<span class="line-modified">450             if ((structure-&gt;indexingMode() &amp; indexingModeMask) != shape)</span>




451                 return false;
452         }
453         return true;
454     }
455 
<span class="line-modified">456     case Array::PossiblyArray: {</span>
457         if (arrayModesAlreadyChecked(value.m_arrayModes, asArrayModesIgnoringTypedArrays(shape) | asArrayModesIgnoringTypedArrays(shape | IsArray)))
458             return true;
<span class="line-modified">459         if (!value.m_structure.isFinite())</span>
460             return false;
461         for (unsigned i = value.m_structure.size(); i--;) {
462             RegisteredStructure structure = value.m_structure[i];
<span class="line-modified">463             if ((structure-&gt;indexingMode() &amp; (indexingModeMask &amp; ~IsArray)) != shape)</span>


464                 return false;
465         }
466         return true;
<span class="line-modified">467     }</span>
<span class="line-added">468 </span>
<span class="line-added">469     // If ArrayMode is Array::OriginalCopyOnWriteArray or Array::OriginalArray, CheckArray is never emitted. Instead, we always emit CheckStructure.</span>
<span class="line-added">470     // So, we should perform the same check to the CheckStructure here.</span>
<span class="line-added">471     case Array::OriginalArray:</span>
<span class="line-added">472     case Array::OriginalCopyOnWriteArray: {</span>
<span class="line-added">473         if (!value.m_structure.isFinite())</span>
<span class="line-added">474             return false;</span>
<span class="line-added">475         Structure* originalStructure = originalArrayStructure(graph, node);</span>
<span class="line-added">476         if (value.m_structure.size() != 1)</span>
<span class="line-added">477             return false;</span>
<span class="line-added">478         return value.m_structure.onlyStructure().get() == originalStructure;</span>
<span class="line-added">479     }</span>
<span class="line-added">480     }</span>
<span class="line-added">481     return false;</span>
482 }
483 
484 bool ArrayMode::alreadyChecked(Graph&amp; graph, Node* node, const AbstractValue&amp; value) const
485 {
486     switch (type()) {
487     case Array::Generic:
488         return true;
489 
490     case Array::ForceExit:
491         return false;
492 
493     case Array::String:
494         return speculationChecked(value.m_type, SpecString);
495 
496     case Array::Int32:
497         return alreadyChecked(graph, node, value, Int32Shape);
498 
499     case Array::Double:
500         return alreadyChecked(graph, node, value, DoubleShape);
501 
</pre>
</td>
</tr>
</table>
<center><a href="DFGArithMode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArrayMode.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
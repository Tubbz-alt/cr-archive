<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/RuleFeature.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2012, 2014 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012 Google Inc. All rights reserved.
 12  *
 13  * This library is free software; you can redistribute it and/or
 14  * modify it under the terms of the GNU Library General Public
 15  * License as published by the Free Software Foundation; either
 16  * version 2 of the License, or (at your option) any later version.
 17  *
 18  * This library is distributed in the hope that it will be useful,
 19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 21  * Library General Public License for more details.
 22  *
 23  * You should have received a copy of the GNU Library General Public License
 24  * along with this library; see the file COPYING.LIB.  If not, write to
 25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 26  * Boston, MA 02110-1301, USA.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;RuleFeature.h&quot;
 31 
 32 #include &quot;CSSSelector.h&quot;
 33 #include &quot;CSSSelectorList.h&quot;
 34 #include &quot;RuleSet.h&quot;
 35 
 36 namespace WebCore {
 37 namespace Style {
 38 
 39 static bool isSiblingOrSubject(MatchElement matchElement)
 40 {
 41     switch (matchElement) {
 42     case MatchElement::Subject:
 43     case MatchElement::IndirectSibling:
 44     case MatchElement::DirectSibling:
 45     case MatchElement::AnySibling:
 46     case MatchElement::Host:
 47         return true;
 48     case MatchElement::Parent:
 49     case MatchElement::Ancestor:
 50     case MatchElement::ParentSibling:
 51     case MatchElement::AncestorSibling:
 52         return false;
 53     }
 54     ASSERT_NOT_REACHED();
 55     return false;
 56 }
 57 
 58 RuleFeature::RuleFeature(const RuleData&amp; ruleData, Optional&lt;MatchElement&gt; matchElement)
 59     : styleRule(&amp;ruleData.styleRule())
 60     , selectorIndex(ruleData.selectorIndex())
 61     , selectorListIndex(ruleData.selectorListIndex())
 62     , matchElement(matchElement)
 63 {
 64     ASSERT(selectorIndex == ruleData.selectorIndex());
 65     ASSERT(selectorListIndex == ruleData.selectorListIndex());
 66 }
 67 
 68 MatchElement RuleFeatureSet::computeNextMatchElement(MatchElement matchElement, CSSSelector::RelationType relation)
 69 {
 70     if (isSiblingOrSubject(matchElement)) {
 71         switch (relation) {
 72         case CSSSelector::Subselector:
 73             return matchElement;
 74         case CSSSelector::DescendantSpace:
 75             return MatchElement::Ancestor;
 76         case CSSSelector::Child:
 77             return MatchElement::Parent;
 78         case CSSSelector::IndirectAdjacent:
 79             if (matchElement == MatchElement::AnySibling)
 80                 return MatchElement::AnySibling;
 81             return MatchElement::IndirectSibling;
 82         case CSSSelector::DirectAdjacent:
 83             if (matchElement == MatchElement::AnySibling)
 84                 return MatchElement::AnySibling;
 85             return matchElement == MatchElement::Subject ? MatchElement::DirectSibling : MatchElement::IndirectSibling;
 86         case CSSSelector::ShadowDescendant:
 87             return MatchElement::Host;
 88         };
 89     }
 90     switch (relation) {
 91     case CSSSelector::Subselector:
 92         return matchElement;
 93     case CSSSelector::DescendantSpace:
 94     case CSSSelector::Child:
 95         return MatchElement::Ancestor;
 96     case CSSSelector::IndirectAdjacent:
 97     case CSSSelector::DirectAdjacent:
 98         return matchElement == MatchElement::Parent ? MatchElement::ParentSibling : MatchElement::AncestorSibling;
 99     case CSSSelector::ShadowDescendant:
100         return MatchElement::Host;
101     };
102     ASSERT_NOT_REACHED();
103     return matchElement;
104 };
105 
106 MatchElement RuleFeatureSet::computeSubSelectorMatchElement(MatchElement matchElement, const CSSSelector&amp; selector)
107 {
108     ASSERT(selector.selectorList());
109 
110     if (selector.match() == CSSSelector::PseudoClass) {
111         auto type = selector.pseudoClassType();
112         // For :nth-child(n of .some-subselector) where an element change may affect other elements similar to sibling combinators.
113         if (type == CSSSelector::PseudoClassNthChild || type == CSSSelector::PseudoClassNthLastChild)
114             return MatchElement::AnySibling;
115 
116         // Similarly for :host().
117         if (type == CSSSelector::PseudoClassHost)
118             return MatchElement::Host;
119     }
120     if (selector.match() == CSSSelector::PseudoElement) {
121         // Similarly for ::slotted().
122         if (selector.pseudoElementType() == CSSSelector::PseudoElementSlotted)
123             return MatchElement::Host;
124     }
125 
126     return matchElement;
127 };
128 
129 void RuleFeatureSet::recursivelyCollectFeaturesFromSelector(SelectorFeatures&amp; selectorFeatures, const CSSSelector&amp; firstSelector, MatchElement matchElement)
130 {
131     const CSSSelector* selector = &amp;firstSelector;
132     do {
133         if (selector-&gt;match() == CSSSelector::Id) {
134             idsInRules.add(selector-&gt;value());
135             if (matchElement == MatchElement::Parent || matchElement == MatchElement::Ancestor)
136                 idsMatchingAncestorsInRules.add(selector-&gt;value());
137         } else if (selector-&gt;match() == CSSSelector::Class)
138             selectorFeatures.classes.append(std::make_pair(selector-&gt;value(), matchElement));
139         else if (selector-&gt;isAttributeSelector()) {
140             auto&amp; canonicalLocalName = selector-&gt;attributeCanonicalLocalName();
141             auto&amp; localName = selector-&gt;attribute().localName();
142             attributeCanonicalLocalNamesInRules.add(canonicalLocalName);
143             attributeLocalNamesInRules.add(localName);
144             selectorFeatures.attributes.append(std::make_pair(selector, matchElement));
145         } else if (selector-&gt;match() == CSSSelector::PseudoElement) {
146             switch (selector-&gt;pseudoElementType()) {
147             case CSSSelector::PseudoElementFirstLine:
148                 usesFirstLineRules = true;
149                 break;
150             case CSSSelector::PseudoElementFirstLetter:
151                 usesFirstLetterRules = true;
152                 break;
153             default:
154                 break;
155             }
156         }
157 
158         if (!selectorFeatures.hasSiblingSelector &amp;&amp; selector-&gt;isSiblingSelector())
159             selectorFeatures.hasSiblingSelector = true;
160 
161         if (const CSSSelectorList* selectorList = selector-&gt;selectorList()) {
162             auto subSelectorMatchElement = computeSubSelectorMatchElement(matchElement, *selector);
163 
164             for (const CSSSelector* subSelector = selectorList-&gt;first(); subSelector; subSelector = CSSSelectorList::next(subSelector)) {
165                 if (!selectorFeatures.hasSiblingSelector &amp;&amp; selector-&gt;isSiblingSelector())
166                     selectorFeatures.hasSiblingSelector = true;
167                 recursivelyCollectFeaturesFromSelector(selectorFeatures, *subSelector, subSelectorMatchElement);
168             }
169         }
170 
171         matchElement = computeNextMatchElement(matchElement, selector-&gt;relation());
172 
173         selector = selector-&gt;tagHistory();
174     } while (selector);
175 }
176 
177 void RuleFeatureSet::collectFeatures(const RuleData&amp; ruleData)
178 {
179     SelectorFeatures selectorFeatures;
180     recursivelyCollectFeaturesFromSelector(selectorFeatures, *ruleData.selector());
181     if (selectorFeatures.hasSiblingSelector)
182         siblingRules.append({ ruleData });
183     if (ruleData.containsUncommonAttributeSelector())
184         uncommonAttributeRules.append({ ruleData });
185 
186     for (auto&amp; nameAndMatch : selectorFeatures.classes) {
187         classRules.ensure(nameAndMatch.first, [] {
188             return makeUnique&lt;Vector&lt;RuleFeature&gt;&gt;();
189         }).iterator-&gt;value-&gt;append({ ruleData, nameAndMatch.second });
190         if (nameAndMatch.second == MatchElement::Host)
191             classesAffectingHost.add(nameAndMatch.first);
192     }
193     for (auto&amp; selectorAndMatch : selectorFeatures.attributes) {
194         auto* selector = selectorAndMatch.first;
195         auto matchElement = selectorAndMatch.second;
196         attributeRules.ensure(selector-&gt;attribute().localName().convertToASCIILowercase(), [] {
197             return makeUnique&lt;Vector&lt;RuleFeatureWithInvalidationSelector&gt;&gt;();
198         }).iterator-&gt;value-&gt;append({ ruleData, matchElement, selector });
199         if (matchElement == MatchElement::Host)
200             attributesAffectingHost.add(selector-&gt;attribute().localName().convertToASCIILowercase());
201     }
202 }
203 
204 void RuleFeatureSet::add(const RuleFeatureSet&amp; other)
205 {
206     idsInRules.add(other.idsInRules.begin(), other.idsInRules.end());
207     idsMatchingAncestorsInRules.add(other.idsMatchingAncestorsInRules.begin(), other.idsMatchingAncestorsInRules.end());
208     attributeCanonicalLocalNamesInRules.add(other.attributeCanonicalLocalNamesInRules.begin(), other.attributeCanonicalLocalNamesInRules.end());
209     attributeLocalNamesInRules.add(other.attributeLocalNamesInRules.begin(), other.attributeLocalNamesInRules.end());
210     contentAttributeNamesInRules.add(other.contentAttributeNamesInRules.begin(), other.contentAttributeNamesInRules.end());
211     siblingRules.appendVector(other.siblingRules);
212     uncommonAttributeRules.appendVector(other.uncommonAttributeRules);
213     for (auto&amp; keyValuePair : other.classRules) {
214         classRules.ensure(keyValuePair.key, [] {
215             return makeUnique&lt;Vector&lt;RuleFeature&gt;&gt;();
216         }).iterator-&gt;value-&gt;appendVector(*keyValuePair.value);
217     }
218     classesAffectingHost.add(other.classesAffectingHost.begin(), other.classesAffectingHost.end());
219 
220     for (auto&amp; keyValuePair : other.attributeRules) {
221         attributeRules.ensure(keyValuePair.key, [] {
222             return makeUnique&lt;Vector&lt;RuleFeatureWithInvalidationSelector&gt;&gt;();
223         }).iterator-&gt;value-&gt;appendVector(*keyValuePair.value);
224     }
225     attributesAffectingHost.add(other.attributesAffectingHost.begin(), other.attributesAffectingHost.end());
226 
227     usesFirstLineRules = usesFirstLineRules || other.usesFirstLineRules;
228     usesFirstLetterRules = usesFirstLetterRules || other.usesFirstLetterRules;
229 }
230 
231 void RuleFeatureSet::registerContentAttribute(const AtomString&amp; attributeName)
232 {
233     contentAttributeNamesInRules.add(attributeName.convertToASCIILowercase());
234     attributeCanonicalLocalNamesInRules.add(attributeName);
235     attributeLocalNamesInRules.add(attributeName);
236 }
237 
238 void RuleFeatureSet::clear()
239 {
240     idsInRules.clear();
241     idsMatchingAncestorsInRules.clear();
242     attributeCanonicalLocalNamesInRules.clear();
243     attributeLocalNamesInRules.clear();
244     contentAttributeNamesInRules.clear();
245     siblingRules.clear();
246     uncommonAttributeRules.clear();
247     classRules.clear();
248     classesAffectingHost.clear();
249     attributeRules.clear();
250     attributesAffectingHost.clear();
251     usesFirstLineRules = false;
252     usesFirstLetterRules = false;
253 }
254 
255 void RuleFeatureSet::shrinkToFit()
256 {
257     siblingRules.shrinkToFit();
258     uncommonAttributeRules.shrinkToFit();
259     for (auto&amp; rules : classRules.values())
260         rules-&gt;shrinkToFit();
261     for (auto&amp; rules : attributeRules.values())
262         rules-&gt;shrinkToFit();
263 }
264 
265 } // namespace Style
266 } // namespace WebCore
    </pre>
  </body>
</html>
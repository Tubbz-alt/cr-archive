<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/URL.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2011, 2012, 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Forward.h&gt;
 29 #include &lt;wtf/RetainPtr.h&gt;
 30 #include &lt;wtf/text/WTFString.h&gt;
 31 
 32 #if USE(CF)
 33 typedef const struct __CFURL* CFURLRef;
 34 #endif
 35 
 36 #if USE(FOUNDATION)
 37 OBJC_CLASS NSURL;
 38 #endif
 39 
 40 #if PLATFORM(JAVA)
 41 #include &lt;wtf/java/JavaEnv.h&gt;
 42 #endif
 43 
 44 namespace WTF {
 45 class TextStream;
 46 
 47 class URLTextEncoding {
 48 public:
 49     virtual Vector&lt;uint8_t&gt; encodeForURLParsing(StringView) const = 0;
 50     virtual ~URLTextEncoding() { };
 51 };
 52 
 53 struct URLHash;
 54 
 55 class WTF_EXPORT_PRIVATE URL {
 56     WTF_MAKE_FAST_ALLOCATED;
 57 public:
 58     // Generates a URL which contains a null string.
 59     URL() { invalidate(); }
 60 
 61     explicit URL(WTF::HashTableDeletedValueType) : m_string(WTF::HashTableDeletedValue) { }
 62     bool isHashTableDeletedValue() const { return string().isHashTableDeletedValue(); }
 63 
 64     // Resolves the relative URL with the given base URL. If provided, the
 65     // URLTextEncoding is used to encode non-ASCII characers. The base URL can be
 66     // null or empty, in which case the relative URL will be interpreted as
 67     // absolute.
 68     // FIXME: If the base URL is invalid, this always creates an invalid
 69     // URL. Instead I think it would be better to treat all invalid base URLs
 70     // the same way we treate null and empty base URLs.
 71     URL(const URL&amp; base, const String&amp; relative, const URLTextEncoding* = nullptr);
 72 
 73     static URL fakeURLWithRelativePart(const String&amp;);
 74     static URL fileURLWithFileSystemPath(const String&amp;);
 75 
 76     String strippedForUseAsReferrer() const;
 77 
 78     // FIXME: The above functions should be harmonized so that passing a
 79     // base of null or the empty string gives the same result as the
 80     // standard String constructor.
 81 
 82     // Makes a deep copy. Helpful only if you need to use a URL on another
 83     // thread. Since the underlying StringImpl objects are immutable, there&#39;s
 84     // no other reason to ever prefer isolatedCopy() over plain old assignment.
 85     URL isolatedCopy() const;
 86 
 87     bool isNull() const;
 88     bool isEmpty() const;
 89     bool isValid() const;
 90 
 91     // Returns true if you can set the host and port for the URL.
 92     // Non-hierarchical URLs don&#39;t have a host and port.
 93     bool canSetHostOrPort() const { return isHierarchical(); }
 94 
 95     bool canSetPathname() const { return isHierarchical(); }
 96     bool isHierarchical() const;
 97 
 98     const String&amp; string() const { return m_string; }
 99 
100     String stringCenterEllipsizedToLength(unsigned length = 1024) const;
101 
102     StringView protocol() const;
103     StringView host() const;
104     Optional&lt;uint16_t&gt; port() const;
105     String hostAndPort() const;
106     String protocolHostAndPort() const;
107     String user() const;
108     String pass() const;
109     String path() const;
110     String lastPathComponent() const;
111     String query() const;
112     String fragmentIdentifier() const;
113     bool hasFragmentIdentifier() const;
114 
115     bool hasUsername() const;
116     bool hasPassword() const;
117     bool hasQuery() const;
118     bool hasFragment() const;
119     bool hasPath() const;
120 
121     // Unlike user() and pass(), these functions don&#39;t decode escape sequences.
122     // This is necessary for accurate round-tripping, because encoding doesn&#39;t encode &#39;%&#39; characters.
123     String encodedUser() const;
124     String encodedPass() const;
125 
126     String baseAsString() const;
127 
128     String fileSystemPath() const;
129 
130     // Returns true if the current URL&#39;s protocol is the same as the null-
131     // terminated ASCII argument. The argument must be lower-case.
132     bool protocolIs(const char*) const;
133     bool protocolIs(StringView) const;
134     bool protocolIsBlob() const { return protocolIs(&quot;blob&quot;); }
135     bool protocolIsData() const { return protocolIs(&quot;data&quot;); }
136     bool protocolIsAbout() const;
137     bool protocolIsInHTTPFamily() const;
138     bool isLocalFile() const;
139     bool isBlankURL() const;
140     bool cannotBeABaseURL() const { return m_cannotBeABaseURL; }
141 
142     bool isMatchingDomain(const String&amp;) const;
143 
144     bool setProtocol(const String&amp;);
145     void setHost(const String&amp;);
146 
147     void removePort();
148     void setPort(unsigned short);
149 
150     // Input is like &quot;foo.com&quot; or &quot;foo.com:8000&quot;.
151     void setHostAndPort(const String&amp;);
152     void removeHostAndPort();
153 
154     void setUser(const String&amp;);
155     void setPass(const String&amp;);
156 
157     // If you pass an empty path for HTTP or HTTPS URLs, the resulting path
158     // will be &quot;/&quot;.
159     void setPath(const String&amp;);
160 
161     // The query may begin with a question mark, or, if not, one will be added
162     // for you. Setting the query to the empty string will leave a &quot;?&quot; in the
163     // URL (with nothing after it). To clear the query, pass a null string.
164     void setQuery(const String&amp;);
165 
166     void setFragmentIdentifier(StringView);
167     void removeFragmentIdentifier();
168 
169     void removeQueryAndFragmentIdentifier();
170 
171     static bool hostIsIPAddress(StringView);
172 
173     unsigned pathStart() const;
174     unsigned pathEnd() const;
175     unsigned pathAfterLastSlash() const;
176 
177     operator const String&amp;() const { return string(); }
178 
179 #if USE(CF)
180     URL(CFURLRef);
181     RetainPtr&lt;CFURLRef&gt; createCFURL() const;
182 #endif
183 
184 #if USE(FOUNDATION)
185     URL(NSURL*);
186     operator NSURL*() const;
187 #endif
188 #ifdef __OBJC__
189     operator NSString*() const { return string(); }
190 #endif
191 
192 #if PLATFORM(JAVA)
193     URL(JNIEnv* env, jstring url) : URL(URL(), String(env, url)) {}
194 #endif
195 
196 #ifndef NDEBUG
197     void print() const;
198 #endif
199 
200     template &lt;class Encoder&gt; void encode(Encoder&amp;) const;
201     template &lt;class Decoder&gt; static bool decode(Decoder&amp;, URL&amp;);
202     template &lt;class Decoder&gt; static Optional&lt;URL&gt; decode(Decoder&amp;);
203 
204 private:
205     friend class URLParser;
206     void invalidate();
207     static bool protocolIs(const String&amp;, const char*);
208     void copyToBuffer(Vector&lt;char, 512&gt;&amp; buffer) const;
209     unsigned hostStart() const;
210 
211     friend WTF_EXPORT_PRIVATE bool equalIgnoringFragmentIdentifier(const URL&amp;, const URL&amp;);
212     friend WTF_EXPORT_PRIVATE bool protocolHostAndPortAreEqual(const URL&amp;, const URL&amp;);
213     friend WTF_EXPORT_PRIVATE bool hostsAreEqual(const URL&amp;, const URL&amp;);
214 
215     String m_string;
216 
217     unsigned m_isValid : 1;
218     unsigned m_protocolIsInHTTPFamily : 1;
219     unsigned m_cannotBeABaseURL : 1;
220 
221     // This is out of order to align the bits better. The port is after the host.
222     unsigned m_portLength : 3;
223     static constexpr unsigned maxPortLength = (1 &lt;&lt; 3) - 1;
224 
225     static constexpr unsigned maxSchemeLength = (1 &lt;&lt; 26) - 1;
226     unsigned m_schemeEnd : 26;
227     unsigned m_userStart;
228     unsigned m_userEnd;
229     unsigned m_passwordEnd;
230     unsigned m_hostEnd;
231     unsigned m_pathAfterLastSlash;
232     unsigned m_pathEnd;
233     unsigned m_queryEnd;
234 };
235 
236 static_assert(sizeof(URL) == sizeof(String) + 8 * sizeof(unsigned), &quot;URL should stay small&quot;);
237 
238 template &lt;class Encoder&gt;
239 void URL::encode(Encoder&amp; encoder) const
240 {
241     encoder &lt;&lt; m_string;
242 }
243 
244 template &lt;class Decoder&gt;
245 bool URL::decode(Decoder&amp; decoder, URL&amp; url)
246 {
247     auto optionalURL = URL::decode(decoder);
248     if (!optionalURL)
249         return false;
250     url = WTFMove(*optionalURL);
251     return true;
252 }
253 
254 template &lt;class Decoder&gt;
255 Optional&lt;URL&gt; URL::decode(Decoder&amp; decoder)
256 {
257     String string;
258     if (!decoder.decode(string))
259         return WTF::nullopt;
260     return URL(URL(), string);
261 }
262 
263 WTF_EXPORT_PRIVATE bool equalIgnoringFragmentIdentifier(const URL&amp;, const URL&amp;);
264 WTF_EXPORT_PRIVATE bool equalIgnoringQueryAndFragment(const URL&amp;, const URL&amp;);
265 WTF_EXPORT_PRIVATE bool protocolHostAndPortAreEqual(const URL&amp;, const URL&amp;);
266 WTF_EXPORT_PRIVATE bool hostsAreEqual(const URL&amp;, const URL&amp;);
267 
268 WTF_EXPORT_PRIVATE const URL&amp; blankURL();
269 
270 // Functions to do URL operations on strings.
271 // These are operations that aren&#39;t faster on a parsed URL.
272 // These are also different from the URL functions in that they don&#39;t require the string to be a valid and parsable URL.
273 // This is especially important because valid javascript URLs are not necessarily considered valid by URL.
274 
275 WTF_EXPORT_PRIVATE bool protocolIs(const String&amp; url, const char* protocol);
276 WTF_EXPORT_PRIVATE bool protocolIsJavaScript(const String&amp; url);
277 WTF_EXPORT_PRIVATE bool protocolIsJavaScript(StringView url);
278 WTF_EXPORT_PRIVATE bool protocolIsInHTTPFamily(const String&amp; url);
279 
280 WTF_EXPORT_PRIVATE Optional&lt;uint16_t&gt; defaultPortForProtocol(StringView protocol);
281 WTF_EXPORT_PRIVATE bool isDefaultPortForProtocol(uint16_t port, StringView protocol);
282 WTF_EXPORT_PRIVATE bool portAllowed(const URL&amp;); // Blacklist ports that should never be used for Web resources.
283 
284 WTF_EXPORT_PRIVATE void registerDefaultPortForProtocolForTesting(uint16_t port, const String&amp; protocol);
285 WTF_EXPORT_PRIVATE void clearDefaultPortForProtocolMapForTesting();
286 
287 WTF_EXPORT_PRIVATE bool isValidProtocol(const String&amp;);
288 
289 WTF_EXPORT_PRIVATE String mimeTypeFromDataURL(const String&amp; url);
290 
291 // FIXME: This is a wrong concept to expose, different parts of a URL need different escaping per the URL Standard.
292 WTF_EXPORT_PRIVATE String encodeWithURLEscapeSequences(const String&amp;);
293 
294 // Inlines.
295 
296 inline bool operator==(const URL&amp; a, const URL&amp; b)
297 {
298     return a.string() == b.string();
299 }
300 
301 inline bool operator==(const URL&amp; a, const String&amp; b)
302 {
303     return a.string() == b;
304 }
305 
306 inline bool operator==(const String&amp; a, const URL&amp; b)
307 {
308     return a == b.string();
309 }
310 
311 inline bool operator!=(const URL&amp; a, const URL&amp; b)
312 {
313     return a.string() != b.string();
314 }
315 
316 inline bool operator!=(const URL&amp; a, const String&amp; b)
317 {
318     return a.string() != b;
319 }
320 
321 inline bool operator!=(const String&amp; a, const URL&amp; b)
322 {
323     return a != b.string();
324 }
325 
326 // Inline versions of some non-GoogleURL functions so we can get inlining
327 // without having to have a lot of ugly ifdefs in the class definition.
328 
329 inline bool URL::isNull() const
330 {
331     return m_string.isNull();
332 }
333 
334 inline bool URL::isEmpty() const
335 {
336     return m_string.isEmpty();
337 }
338 
339 inline bool URL::isValid() const
340 {
341     return m_isValid;
342 }
343 
344 inline bool URL::hasPath() const
345 {
346     return m_pathEnd != m_hostEnd + m_portLength;
347 }
348 
349 inline bool URL::hasUsername() const
350 {
351     return m_userEnd &gt; m_userStart;
352 }
353 
354 inline bool URL::hasPassword() const
355 {
356     return m_passwordEnd &gt; (m_userEnd + 1);
357 }
358 
359 inline bool URL::hasQuery() const
360 {
361     return m_queryEnd &gt; m_pathEnd;
362 }
363 
364 inline bool URL::hasFragment() const
365 {
366     return m_isValid &amp;&amp; m_string.length() &gt; m_queryEnd;
367 }
368 
369 inline bool URL::protocolIsInHTTPFamily() const
370 {
371     return m_protocolIsInHTTPFamily;
372 }
373 
374 inline unsigned URL::pathStart() const
375 {
376     return m_hostEnd + m_portLength;
377 }
378 
379 inline unsigned URL::pathEnd() const
380 {
381     return m_pathEnd;
382 }
383 
384 inline unsigned URL::pathAfterLastSlash() const
385 {
386     return m_pathAfterLastSlash;
387 }
388 
389 WTF_EXPORT_PRIVATE WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const URL&amp;);
390 
391 template&lt;&gt; struct DefaultHash&lt;URL&gt;;
392 template&lt;&gt; struct HashTraits&lt;URL&gt;;
393 
394 } // namespace WTF
    </pre>
  </body>
</html>
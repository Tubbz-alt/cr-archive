<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (C) 2005-2020 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2009 Google Inc. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &lt;limits.h&gt;
  26 #include &lt;unicode/ustring.h&gt;
  27 #include &lt;wtf/ASCIICType.h&gt;
  28 #include &lt;wtf/CheckedArithmetic.h&gt;
<a name="2" id="anc2"></a><span class="line-added">  29 #include &lt;wtf/DebugHeap.h&gt;</span>
  30 #include &lt;wtf/Expected.h&gt;
  31 #include &lt;wtf/MathExtras.h&gt;
<a name="3" id="anc3"></a><span class="line-added">  32 #include &lt;wtf/Packed.h&gt;</span>
  33 #include &lt;wtf/StdLibExtras.h&gt;
  34 #include &lt;wtf/Vector.h&gt;
  35 #include &lt;wtf/text/ASCIIFastPath.h&gt;
  36 #include &lt;wtf/text/ConversionMode.h&gt;
  37 #include &lt;wtf/text/StringCommon.h&gt;
  38 #include &lt;wtf/text/StringHasher.h&gt;
  39 #include &lt;wtf/text/UTF8ConversionError.h&gt;
  40 
  41 #if USE(CF)
  42 typedef const struct __CFString * CFStringRef;
  43 #endif
  44 
  45 #ifdef __OBJC__
  46 @class NSString;
  47 #endif
  48 
  49 namespace JSC {
  50 namespace LLInt { class Data; }
  51 class LLIntOffsetsExtractor;
  52 }
  53 
  54 namespace WTF {
  55 
  56 class SymbolImpl;
  57 class SymbolRegistry;
  58 
  59 struct CStringTranslator;
  60 struct HashAndUTF8CharactersTranslator;
  61 struct LCharBufferTranslator;
  62 struct StringHash;
  63 struct SubstringTranslator;
  64 struct UCharBufferTranslator;
  65 
  66 template&lt;typename&gt; class RetainPtr;
  67 
  68 template&lt;typename&gt; struct BufferFromStaticDataTranslator;
  69 template&lt;typename&gt; struct HashAndCharactersTranslator;
  70 
  71 // Define STRING_STATS to 1 turn on runtime statistics of string sizes and memory usage.
  72 #define STRING_STATS 0
  73 
  74 template&lt;bool isSpecialCharacter(UChar), typename CharacterType&gt; bool isAllSpecialCharacters(const CharacterType*, size_t length);
  75 
  76 #if STRING_STATS
  77 
  78 struct StringStats {
  79     WTF_MAKE_STRUCT_FAST_ALLOCATED;
  80     void add8BitString(unsigned length, bool isSubString = false)
  81     {
  82         ++m_totalNumberStrings;
  83         ++m_number8BitStrings;
  84         if (!isSubString)
  85             m_total8BitData += length;
  86     }
  87 
  88     void add16BitString(unsigned length, bool isSubString = false)
  89     {
  90         ++m_totalNumberStrings;
  91         ++m_number16BitStrings;
  92         if (!isSubString)
  93             m_total16BitData += length;
  94     }
  95 
  96     void removeString(StringImpl&amp;);
  97     void printStats();
  98 
<a name="4" id="anc4"></a><span class="line-modified">  99     static constexpr unsigned s_printStringStatsFrequency = 5000;</span>
 100     static std::atomic&lt;unsigned&gt; s_stringRemovesTillPrintStats;
 101 
 102     std::atomic&lt;unsigned&gt; m_refCalls;
 103     std::atomic&lt;unsigned&gt; m_derefCalls;
 104 
 105     std::atomic&lt;unsigned&gt; m_totalNumberStrings;
 106     std::atomic&lt;unsigned&gt; m_number8BitStrings;
 107     std::atomic&lt;unsigned&gt; m_number16BitStrings;
 108     std::atomic&lt;unsigned long long&gt; m_total8BitData;
 109     std::atomic&lt;unsigned long long&gt; m_total16BitData;
 110 };
 111 
 112 #define STRING_STATS_ADD_8BIT_STRING(length) StringImpl::stringStats().add8BitString(length)
 113 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) StringImpl::stringStats().add8BitString(length, isSubString)
 114 #define STRING_STATS_ADD_16BIT_STRING(length) StringImpl::stringStats().add16BitString(length)
 115 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) StringImpl::stringStats().add16BitString(length, isSubString)
 116 #define STRING_STATS_REMOVE_STRING(string) StringImpl::stringStats().removeString(string)
 117 #define STRING_STATS_REF_STRING(string) ++StringImpl::stringStats().m_refCalls;
 118 #define STRING_STATS_DEREF_STRING(string) ++StringImpl::stringStats().m_derefCalls;
 119 
 120 #else
 121 
 122 #define STRING_STATS_ADD_8BIT_STRING(length) ((void)0)
 123 #define STRING_STATS_ADD_8BIT_STRING2(length, isSubString) ((void)0)
 124 #define STRING_STATS_ADD_16BIT_STRING(length) ((void)0)
 125 #define STRING_STATS_ADD_16BIT_STRING2(length, isSubString) ((void)0)
 126 #define STRING_STATS_ADD_UPCONVERTED_STRING(length) ((void)0)
 127 #define STRING_STATS_REMOVE_STRING(string) ((void)0)
 128 #define STRING_STATS_REF_STRING(string) ((void)0)
 129 #define STRING_STATS_DEREF_STRING(string) ((void)0)
 130 
 131 #endif
 132 
 133 class StringImplShape {
 134     WTF_MAKE_NONCOPYABLE(StringImplShape);
 135 public:
 136     static constexpr unsigned MaxLength = std::numeric_limits&lt;int32_t&gt;::max();
 137 
 138 protected:
 139     StringImplShape(unsigned refCount, unsigned length, const LChar*, unsigned hashAndFlags);
 140     StringImplShape(unsigned refCount, unsigned length, const UChar*, unsigned hashAndFlags);
 141 
 142     enum ConstructWithConstExprTag { ConstructWithConstExpr };
 143     template&lt;unsigned characterCount&gt; constexpr StringImplShape(unsigned refCount, unsigned length, const char (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag);
 144     template&lt;unsigned characterCount&gt; constexpr StringImplShape(unsigned refCount, unsigned length, const char16_t (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag);
 145 
 146     unsigned m_refCount;
 147     unsigned m_length;
 148     union {
 149         const LChar* m_data8;
 150         const UChar* m_data16;
 151         // It seems that reinterpret_cast prevents constexpr&#39;s compile time initialization in VC++.
 152         // These are needed to avoid reinterpret_cast.
 153         const char* m_data8Char;
 154         const char16_t* m_data16Char;
 155     };
 156     mutable unsigned m_hashAndFlags;
 157 };
 158 
 159 // FIXME: Use of StringImpl and const is rather confused.
 160 // The actual string inside a StringImpl is immutable, so you can&#39;t modify a string using a StringImpl&amp;.
 161 // We could mark every member function const and always use &quot;const StringImpl&amp;&quot; and &quot;const StringImpl*&quot;.
 162 // Or we could say that &quot;const&quot; doesn&#39;t make sense at all and use &quot;StringImpl&amp;&quot; and &quot;StringImpl*&quot; everywhere.
 163 // Right now we use a mix of both, which makes code more confusing and has no benefit.
 164 
<a name="5" id="anc5"></a><span class="line-added"> 165 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringImpl);</span>
 166 class StringImpl : private StringImplShape {
<a name="6" id="anc6"></a><span class="line-modified"> 167     WTF_MAKE_NONCOPYABLE(StringImpl);</span>
<span class="line-added"> 168     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StringImpl);</span>
 169 
 170     friend class AtomStringImpl;
 171     friend class JSC::LLInt::Data;
 172     friend class JSC::LLIntOffsetsExtractor;
 173     friend class PrivateSymbolImpl;
 174     friend class RegisteredSymbolImpl;
 175     friend class SymbolImpl;
 176     friend class ExternalStringImpl;
 177 
 178     friend struct WTF::CStringTranslator;
 179     friend struct WTF::HashAndUTF8CharactersTranslator;
 180     friend struct WTF::LCharBufferTranslator;
 181     friend struct WTF::SubstringTranslator;
 182     friend struct WTF::UCharBufferTranslator;
 183 
 184     template&lt;typename&gt; friend struct WTF::BufferFromStaticDataTranslator;
 185     template&lt;typename&gt; friend struct WTF::HashAndCharactersTranslator;
 186 
 187 public:
 188     enum BufferOwnership { BufferInternal, BufferOwned, BufferSubstring, BufferExternal };
 189 
 190     static constexpr unsigned MaxLength = StringImplShape::MaxLength;
 191 
 192     // The bottom 6 bits in the hash are flags.
 193     static constexpr const unsigned s_flagCount = 6;
<a name="7" id="anc7"></a><span class="line-added"> 194 </span>
 195 private:
 196     static constexpr const unsigned s_flagMask = (1u &lt;&lt; s_flagCount) - 1;
 197     static_assert(s_flagCount &lt;= StringHasher::flagCount, &quot;StringHasher reserves enough bits for StringImpl flags&quot;);
 198     static constexpr const unsigned s_flagStringKindCount = 4;
 199 
 200     static constexpr const unsigned s_hashFlagStringKindIsAtom = 1u &lt;&lt; (s_flagStringKindCount);
 201     static constexpr const unsigned s_hashFlagStringKindIsSymbol = 1u &lt;&lt; (s_flagStringKindCount + 1);
 202     static constexpr const unsigned s_hashMaskStringKind = s_hashFlagStringKindIsAtom | s_hashFlagStringKindIsSymbol;
 203     static constexpr const unsigned s_hashFlagDidReportCost = 1u &lt;&lt; 3;
 204     static constexpr const unsigned s_hashFlag8BitBuffer = 1u &lt;&lt; 2;
 205     static constexpr const unsigned s_hashMaskBufferOwnership = (1u &lt;&lt; 0) | (1u &lt;&lt; 1);
 206 
 207     enum StringKind {
 208         StringNormal = 0u, // non-symbol, non-atomic
 209         StringAtom = s_hashFlagStringKindIsAtom, // non-symbol, atomic
 210         StringSymbol = s_hashFlagStringKindIsSymbol, // symbol, non-atomic
 211     };
 212 
 213     // Create a normal 8-bit string with internal storage (BufferInternal).
 214     enum Force8Bit { Force8BitConstructor };
 215     StringImpl(unsigned length, Force8Bit);
 216 
 217     // Create a normal 16-bit string with internal storage (BufferInternal).
 218     explicit StringImpl(unsigned length);
 219 
 220     // Create a StringImpl adopting ownership of the provided buffer (BufferOwned).
<a name="8" id="anc8"></a><span class="line-modified"> 221     template&lt;typename Malloc&gt; StringImpl(MallocPtr&lt;LChar, Malloc&gt;, unsigned length);</span>
<span class="line-modified"> 222     template&lt;typename Malloc&gt; StringImpl(MallocPtr&lt;UChar, Malloc&gt;, unsigned length);</span>
 223     enum ConstructWithoutCopyingTag { ConstructWithoutCopying };
 224     StringImpl(const UChar*, unsigned length, ConstructWithoutCopyingTag);
 225     StringImpl(const LChar*, unsigned length, ConstructWithoutCopyingTag);
 226 
 227     // Used to create new strings that are a substring of an existing StringImpl (BufferSubstring).
 228     StringImpl(const LChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 229     StringImpl(const UChar*, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp;);
 230 
 231 public:
 232     WTF_EXPORT_PRIVATE static void destroy(StringImpl*);
 233 
 234     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const UChar*, unsigned length);
 235     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const LChar*, unsigned length);
 236     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create8BitIfPossible(const UChar*, unsigned length);
 237     template&lt;size_t inlineCapacity&gt; static Ref&lt;StringImpl&gt; create8BitIfPossible(const Vector&lt;UChar, inlineCapacity&gt;&amp;);
 238     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create8BitIfPossible(const UChar*);
 239 
 240     ALWAYS_INLINE static Ref&lt;StringImpl&gt; create(const char* characters, unsigned length) { return create(reinterpret_cast&lt;const LChar*&gt;(characters), length); }
 241     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; create(const LChar*);
 242     ALWAYS_INLINE static Ref&lt;StringImpl&gt; create(const char* string) { return create(reinterpret_cast&lt;const LChar*&gt;(string)); }
 243 
 244     static Ref&lt;StringImpl&gt; createSubstringSharingImpl(StringImpl&amp;, unsigned offset, unsigned length);
 245 
 246     template&lt;unsigned characterCount&gt; static Ref&lt;StringImpl&gt; createFromLiteral(const char (&amp;)[characterCount]);
 247 
 248     // FIXME: Replace calls to these overloads of createFromLiteral to createWithoutCopying instead.
 249     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*, unsigned length);
 250     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createFromLiteral(const char*);
 251 
 252     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const UChar*, unsigned length);
 253     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const LChar*, unsigned length);
 254     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, LChar*&amp;);
 255     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, UChar*&amp;);
 256     template&lt;typename CharacterType&gt; static RefPtr&lt;StringImpl&gt; tryCreateUninitialized(unsigned length, CharacterType*&amp;);
 257 
<a name="9" id="anc9"></a><span class="line-added"> 258     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createStaticStringImpl(const char*, unsigned length);</span>
<span class="line-added"> 259 </span>
 260     // Reallocate the StringImpl. The originalString must be only owned by the Ref,
 261     // and the buffer ownership must be BufferInternal. Just like the input pointer of realloc(),
 262     // the originalString can&#39;t be used after this function.
 263     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 264     static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 265     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
 266     static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; tryReallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
 267 
 268     static unsigned flagsOffset() { return OBJECT_OFFSETOF(StringImpl, m_hashAndFlags); }
 269     static constexpr unsigned flagIs8Bit() { return s_hashFlag8BitBuffer; }
 270     static constexpr unsigned flagIsAtom() { return s_hashFlagStringKindIsAtom; }
 271     static constexpr unsigned flagIsSymbol() { return s_hashFlagStringKindIsSymbol; }
 272     static constexpr unsigned maskStringKind() { return s_hashMaskStringKind; }
 273     static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }
 274 
<a name="10" id="anc10"></a><span class="line-modified"> 275     template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified"> 276     static Ref&lt;StringImpl&gt; adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp;);</span>
 277 
 278     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;UChar&gt;&amp;&amp;);
 279     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;LChar&gt;&amp;&amp;);
 280 
 281     unsigned length() const { return m_length; }
 282     static ptrdiff_t lengthMemoryOffset() { return OBJECT_OFFSETOF(StringImpl, m_length); }
 283     bool isEmpty() const { return !m_length; }
 284 
 285     bool is8Bit() const { return m_hashAndFlags &amp; s_hashFlag8BitBuffer; }
 286     ALWAYS_INLINE const LChar* characters8() const { ASSERT(is8Bit()); return m_data8; }
 287     ALWAYS_INLINE const UChar* characters16() const { ASSERT(!is8Bit()); return m_data16; }
 288 
 289     template&lt;typename CharacterType&gt; const CharacterType* characters() const;
 290 
 291     size_t cost() const;
 292     size_t costDuringGC();
 293 
 294     WTF_EXPORT_PRIVATE size_t sizeInBytes() const;
 295 
 296     bool isSymbol() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsSymbol; }
 297     bool isAtom() const { return m_hashAndFlags &amp; s_hashFlagStringKindIsAtom; }
 298     void setIsAtom(bool);
 299 
 300     bool isExternal() const { return bufferOwnership() == BufferExternal; }
 301 
 302     bool isSubString() const { return bufferOwnership() == BufferSubstring; }
 303 
 304     static WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; utf8ForCharacters(const LChar* characters, unsigned length);
 305     static WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; utf8ForCharacters(const UChar* characters, unsigned length, ConversionMode = LenientConversion);
 306 
 307     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8ForRange(unsigned offset, unsigned length, ConversionMode = LenientConversion) const;
 308     WTF_EXPORT_PRIVATE Expected&lt;CString, UTF8ConversionError&gt; tryGetUtf8(ConversionMode = LenientConversion) const;
 309     WTF_EXPORT_PRIVATE CString utf8(ConversionMode = LenientConversion) const;
 310 
 311 private:
 312     static WTF_EXPORT_PRIVATE UTF8ConversionError utf8Impl(const UChar* characters, unsigned length, char*&amp; buffer, size_t bufferSize, ConversionMode);
 313 
 314     // The high bits of &#39;hash&#39; are always empty, but we prefer to store our flags
 315     // in the low bits because it makes them slightly more efficient to access.
 316     // So, we shift left and right when setting and getting our hash code.
 317     void setHash(unsigned) const;
 318 
 319     unsigned rawHash() const { return m_hashAndFlags &gt;&gt; s_flagCount; }
 320 
 321 public:
 322     bool hasHash() const { return !!rawHash(); }
 323 
 324     unsigned existingHash() const { ASSERT(hasHash()); return rawHash(); }
 325     unsigned hash() const { return hasHash() ? rawHash() : hashSlowCase(); }
 326 
 327     WTF_EXPORT_PRIVATE unsigned concurrentHash() const;
 328 
 329     unsigned symbolAwareHash() const;
 330     unsigned existingSymbolAwareHash() const;
 331 
 332     bool isStatic() const { return m_refCount &amp; s_refCountFlagIsStaticString; }
 333 
 334     size_t refCount() const { return m_refCount / s_refCountIncrement; }
 335     bool hasOneRef() const { return m_refCount == s_refCountIncrement; }
 336     bool hasAtLeastOneRef() const { return m_refCount; } // For assertions.
 337 
 338     void ref();
 339     void deref();
 340 
 341     class StaticStringImpl : private StringImplShape {
 342         WTF_MAKE_NONCOPYABLE(StaticStringImpl);
 343     public:
 344         // Used to construct static strings, which have an special refCount that can never hit zero.
 345         // This means that the static string will never be destroyed, which is important because
 346         // static strings will be shared across threads &amp; ref-counted in a non-threadsafe manner.
 347         //
 348         // In order to make StaticStringImpl thread safe, we also need to ensure that the rest of
 349         // the fields are never mutated by threads. We have this guarantee because:
 350         //
 351         // 1. m_length is only set on construction and never mutated thereafter.
 352         //
 353         // 2. m_data8 and m_data16 are only set on construction and never mutated thereafter.
 354         //    We also know that a StringImpl never changes from 8 bit to 16 bit because there
 355         //    is no way to set/clear the s_hashFlag8BitBuffer flag other than at construction.
 356         //
 357         // 3. m_hashAndFlags will not be mutated by different threads because:
 358         //
 359         //    a. StaticStringImpl&#39;s constructor sets the s_hashFlagDidReportCost flag to ensure
 360         //       that StringImpl::cost() returns early.
 361         //       This means StaticStringImpl costs are not counted. But since there should only
 362         //       be a finite set of StaticStringImpls, their cost can be aggregated into a single
 363         //       system cost if needed.
 364         //    b. setIsAtom() is never called on a StaticStringImpl.
 365         //       setIsAtom() asserts !isStatic().
 366         //    c. setHash() is never called on a StaticStringImpl.
 367         //       StaticStringImpl&#39;s constructor sets the hash on construction.
 368         //       StringImpl::hash() only sets a new hash iff !hasHash().
 369         //       Additionally, StringImpl::setHash() asserts hasHash() and !isStatic().
 370 
 371         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char (&amp;characters)[characterCount], StringKind = StringNormal);
 372         template&lt;unsigned characterCount&gt; constexpr StaticStringImpl(const char16_t (&amp;characters)[characterCount], StringKind = StringNormal);
 373         operator StringImpl&amp;();
 374     };
 375 
 376     WTF_EXPORT_PRIVATE static StaticStringImpl s_emptyAtomString;
 377     ALWAYS_INLINE static StringImpl* empty() { return reinterpret_cast&lt;StringImpl*&gt;(&amp;s_emptyAtomString); }
 378 
 379     // FIXME: Does this really belong in StringImpl?
<a name="11" id="anc11"></a><span class="line-modified"> 380     template&lt;typename SourceCharacterType, typename DestinationCharacterType&gt; static void copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters);</span>

 381 
 382     // Some string features, like reference counting and the atomicity flag, are not
 383     // thread-safe. We achieve thread safety by isolation, giving each thread
 384     // its own copy of the string.
 385     Ref&lt;StringImpl&gt; isolatedCopy() const;
 386 
 387     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; substring(unsigned position, unsigned length = MaxLength);
 388 
 389     UChar at(unsigned) const;
 390     UChar operator[](unsigned i) const { return at(i); }
 391     WTF_EXPORT_PRIVATE UChar32 characterStartingAt(unsigned);
 392 
 393     int toIntStrict(bool* ok = 0, int base = 10);
 394     unsigned toUIntStrict(bool* ok = 0, int base = 10);
 395     int64_t toInt64Strict(bool* ok = 0, int base = 10);
 396     uint64_t toUInt64Strict(bool* ok = 0, int base = 10);
 397     intptr_t toIntPtrStrict(bool* ok = 0, int base = 10);
 398 
 399     WTF_EXPORT_PRIVATE int toInt(bool* ok = 0); // ignores trailing garbage
 400     unsigned toUInt(bool* ok = 0); // ignores trailing garbage
 401     int64_t toInt64(bool* ok = 0); // ignores trailing garbage
 402     uint64_t toUInt64(bool* ok = 0); // ignores trailing garbage
 403     intptr_t toIntPtr(bool* ok = 0); // ignores trailing garbage
 404 
 405     // FIXME: Like the strict functions above, these give false for &quot;ok&quot; when there is trailing garbage.
 406     // Like the non-strict functions above, these return the value when there is trailing garbage.
 407     // It would be better if these were more consistent with the above functions instead.
 408     double toDouble(bool* ok = 0);
 409     float toFloat(bool* ok = 0);
 410 
 411     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToASCIILowercase();
 412     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToASCIIUppercase();
 413     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithoutLocale();
 414     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned);
 415     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToUppercaseWithoutLocale();
 416     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToLowercaseWithLocale(const AtomString&amp; localeIdentifier);
 417     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; convertToUppercaseWithLocale(const AtomString&amp; localeIdentifier);
 418 
 419     Ref&lt;StringImpl&gt; foldCase();
 420 
 421     Ref&lt;StringImpl&gt; stripWhiteSpace();
 422     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; simplifyWhiteSpace();
 423     Ref&lt;StringImpl&gt; simplifyWhiteSpace(CodeUnitMatchFunction);
 424 
 425     Ref&lt;StringImpl&gt; stripLeadingAndTrailingCharacters(CodeUnitMatchFunction);
 426     Ref&lt;StringImpl&gt; removeCharacters(CodeUnitMatchFunction);
 427 
 428     bool isAllASCII() const;
 429     bool isAllLatin1() const;
 430     template&lt;bool isSpecialCharacter(UChar)&gt; bool isAllSpecialCharacters() const;
 431 
 432     size_t find(LChar character, unsigned start = 0);
 433     size_t find(char character, unsigned start = 0);
 434     size_t find(UChar character, unsigned start = 0);
 435     WTF_EXPORT_PRIVATE size_t find(CodeUnitMatchFunction, unsigned index = 0);
 436     size_t find(const LChar*, unsigned index = 0);
 437     ALWAYS_INLINE size_t find(const char* string, unsigned index = 0) { return find(reinterpret_cast&lt;const LChar*&gt;(string), index); }
 438     WTF_EXPORT_PRIVATE size_t find(StringImpl*);
 439     WTF_EXPORT_PRIVATE size_t find(StringImpl*, unsigned index);
 440     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringImpl&amp;) const;
 441     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringImpl&amp;, unsigned startOffset) const;
 442     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringImpl*) const;
 443     WTF_EXPORT_PRIVATE size_t findIgnoringASCIICase(const StringImpl*, unsigned startOffset) const;
 444 
 445     WTF_EXPORT_PRIVATE size_t reverseFind(UChar, unsigned index = MaxLength);
 446     WTF_EXPORT_PRIVATE size_t reverseFind(StringImpl*, unsigned index = MaxLength);
 447 
 448     WTF_EXPORT_PRIVATE bool startsWith(const StringImpl*) const;
 449     WTF_EXPORT_PRIVATE bool startsWith(const StringImpl&amp;) const;
 450     WTF_EXPORT_PRIVATE bool startsWithIgnoringASCIICase(const StringImpl*) const;
 451     WTF_EXPORT_PRIVATE bool startsWithIgnoringASCIICase(const StringImpl&amp;) const;
 452     WTF_EXPORT_PRIVATE bool startsWith(UChar) const;
 453     WTF_EXPORT_PRIVATE bool startsWith(const char*, unsigned matchLength) const;
 454     template&lt;unsigned matchLength&gt; bool startsWith(const char (&amp;prefix)[matchLength]) const { return startsWith(prefix, matchLength - 1); }
 455     WTF_EXPORT_PRIVATE bool hasInfixStartingAt(const StringImpl&amp;, unsigned startOffset) const;
 456 
 457     WTF_EXPORT_PRIVATE bool endsWith(StringImpl*);
 458     WTF_EXPORT_PRIVATE bool endsWith(StringImpl&amp;);
 459     WTF_EXPORT_PRIVATE bool endsWithIgnoringASCIICase(const StringImpl*) const;
 460     WTF_EXPORT_PRIVATE bool endsWithIgnoringASCIICase(const StringImpl&amp;) const;
 461     WTF_EXPORT_PRIVATE bool endsWith(UChar) const;
 462     WTF_EXPORT_PRIVATE bool endsWith(const char*, unsigned matchLength) const;
 463     template&lt;unsigned matchLength&gt; bool endsWith(const char (&amp;prefix)[matchLength]) const { return endsWith(prefix, matchLength - 1); }
 464     WTF_EXPORT_PRIVATE bool hasInfixEndingAt(const StringImpl&amp;, unsigned endOffset) const;
 465 
 466     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; replace(UChar, UChar);
 467     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; replace(UChar, StringImpl*);
 468     ALWAYS_INLINE Ref&lt;StringImpl&gt; replace(UChar pattern, const char* replacement, unsigned replacementLength) { return replace(pattern, reinterpret_cast&lt;const LChar*&gt;(replacement), replacementLength); }
 469     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; replace(UChar, const LChar*, unsigned replacementLength);
 470     Ref&lt;StringImpl&gt; replace(UChar, const UChar*, unsigned replacementLength);
 471     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; replace(StringImpl*, StringImpl*);
 472     WTF_EXPORT_PRIVATE Ref&lt;StringImpl&gt; replace(unsigned index, unsigned length, StringImpl*);
 473 
 474     WTF_EXPORT_PRIVATE UCharDirection defaultWritingDirection(bool* hasStrongDirectionality = nullptr);
 475 
 476 #if USE(CF)
 477     RetainPtr&lt;CFStringRef&gt; createCFString();
 478 #endif
 479 
 480 #ifdef __OBJC__
 481     WTF_EXPORT_PRIVATE operator NSString *();
 482 #endif
 483 
 484 #if STRING_STATS
 485     ALWAYS_INLINE static StringStats&amp; stringStats() { return m_stringStats; }
 486 #endif
 487 
 488     BufferOwnership bufferOwnership() const { return static_cast&lt;BufferOwnership&gt;(m_hashAndFlags &amp; s_hashMaskBufferOwnership); }
 489 
 490     template&lt;typename T&gt; static size_t headerSize() { return tailOffset&lt;T&gt;(); }
 491 
 492 protected:
 493     ~StringImpl();
 494 
 495     // Used to create new symbol string that holds an existing [[Description]] string as a substring buffer (BufferSubstring).
 496     enum CreateSymbolTag { CreateSymbol };
 497     StringImpl(CreateSymbolTag, const LChar*, unsigned length);
 498     StringImpl(CreateSymbolTag, const UChar*, unsigned length);
 499 
 500     // Null symbol.
 501     explicit StringImpl(CreateSymbolTag);
 502 
 503 private:
 504     template&lt;typename&gt; static size_t allocationSize(Checked&lt;size_t&gt; tailElementCount);
 505     template&lt;typename&gt; static size_t maxInternalLength();
 506     template&lt;typename&gt; static size_t tailOffset();
 507 
 508     bool requiresCopy() const;
 509     template&lt;typename T&gt; const T* tailPointer() const;
 510     template&lt;typename T&gt; T* tailPointer();
 511     StringImpl* const&amp; substringBuffer() const;
 512     StringImpl*&amp; substringBuffer();
 513 
 514     enum class CaseConvertType { Upper, Lower };
 515     template&lt;CaseConvertType, typename CharacterType&gt; static Ref&lt;StringImpl&gt; convertASCIICase(StringImpl&amp;, const CharacterType*, unsigned);
 516 
 517     template&lt;class CodeUnitPredicate&gt; Ref&lt;StringImpl&gt; stripMatchedCharacters(CodeUnitPredicate);
 518     template&lt;typename CharacterType&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; removeCharacters(const CharacterType* characters, CodeUnitMatchFunction);
 519     template&lt;typename CharacterType, class CodeUnitPredicate&gt; Ref&lt;StringImpl&gt; simplifyMatchedCharactersToSpace(CodeUnitPredicate);
 520     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; constructInternal(StringImpl&amp;, unsigned);
 521     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createUninitializedInternal(unsigned, CharacterType*&amp;);
 522     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createUninitializedInternalNonEmpty(unsigned, CharacterType*&amp;);
 523     template&lt;typename CharacterType&gt; static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; reallocateInternal(Ref&lt;StringImpl&gt;&amp;&amp;, unsigned, CharacterType*&amp;);
 524     template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createInternal(const CharacterType*, unsigned);
 525     WTF_EXPORT_PRIVATE NEVER_INLINE unsigned hashSlowCase() const;
 526 
 527     // The bottom bit in the ref count indicates a static (immortal) string.
<a name="12" id="anc12"></a><span class="line-modified"> 528     static constexpr unsigned s_refCountFlagIsStaticString = 0x1;</span>
<span class="line-modified"> 529     static constexpr unsigned s_refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static string flag.</span>
 530 
 531 #if STRING_STATS
 532     WTF_EXPORT_PRIVATE static StringStats m_stringStats;
 533 #endif
 534 
 535 public:
 536     void assertHashIsCorrect() const;
 537 };
 538 
 539 using StaticStringImpl = StringImpl::StaticStringImpl;
 540 
 541 static_assert(sizeof(StringImpl) == sizeof(StaticStringImpl), &quot;&quot;);
 542 
<a name="13" id="anc13"></a><span class="line-modified"> 543 #if ASSERT_ENABLED</span>
 544 
 545 // StringImpls created from StaticStringImpl will ASSERT in the generic ValueCheck&lt;T&gt;::checkConsistency
 546 // as they are not allocated by fastMalloc. We don&#39;t currently have any way to detect that case
 547 // so we ignore the consistency check for all StringImpl*.
 548 template&lt;&gt; struct ValueCheck&lt;StringImpl*&gt; {
 549     static void checkConsistency(const StringImpl*) { }
 550 };
 551 
<a name="14" id="anc14"></a><span class="line-modified"> 552 #endif // ASSERT_ENABLED</span>
 553 
 554 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const StringImpl*);
 555 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*);
 556 inline bool equal(const StringImpl* a, const char* b) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b)); }
 557 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*, unsigned);
 558 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const UChar*, unsigned);
 559 inline bool equal(const StringImpl* a, const char* b, unsigned length) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b), length); }
 560 inline bool equal(const LChar* a, StringImpl* b) { return equal(b, a); }
 561 inline bool equal(const char* a, StringImpl* b) { return equal(b, reinterpret_cast&lt;const LChar*&gt;(a)); }
 562 WTF_EXPORT_PRIVATE bool equal(const StringImpl&amp; a, const StringImpl&amp; b);
 563 
 564 WTF_EXPORT_PRIVATE bool equalIgnoringNullity(StringImpl*, StringImpl*);
 565 WTF_EXPORT_PRIVATE bool equalIgnoringNullity(const UChar*, size_t length, StringImpl*);
 566 
 567 bool equalIgnoringASCIICase(const StringImpl&amp;, const StringImpl&amp;);
 568 WTF_EXPORT_PRIVATE bool equalIgnoringASCIICase(const StringImpl*, const StringImpl*);
 569 bool equalIgnoringASCIICase(const StringImpl&amp;, const char*);
 570 bool equalIgnoringASCIICase(const StringImpl*, const char*);
 571 
 572 WTF_EXPORT_PRIVATE bool equalIgnoringASCIICaseNonNull(const StringImpl*, const StringImpl*);
 573 
 574 template&lt;unsigned length&gt; bool equalLettersIgnoringASCIICase(const StringImpl&amp;, const char (&amp;lowercaseLetters)[length]);
 575 template&lt;unsigned length&gt; bool equalLettersIgnoringASCIICase(const StringImpl*, const char (&amp;lowercaseLetters)[length]);
 576 
 577 size_t find(const LChar*, unsigned length, CodeUnitMatchFunction, unsigned index = 0);
 578 size_t find(const UChar*, unsigned length, CodeUnitMatchFunction, unsigned index = 0);
 579 
 580 template&lt;typename CharacterType&gt; size_t reverseFindLineTerminator(const CharacterType*, unsigned length, unsigned index = StringImpl::MaxLength);
 581 template&lt;typename CharacterType&gt; size_t reverseFind(const CharacterType*, unsigned length, CharacterType matchCharacter, unsigned index = StringImpl::MaxLength);
 582 size_t reverseFind(const UChar*, unsigned length, LChar matchCharacter, unsigned index = StringImpl::MaxLength);
 583 size_t reverseFind(const LChar*, unsigned length, UChar matchCharacter, unsigned index = StringImpl::MaxLength);
 584 
 585 template&lt;size_t inlineCapacity&gt; bool equalIgnoringNullity(const Vector&lt;UChar, inlineCapacity&gt;&amp;, StringImpl*);
 586 
 587 template&lt;typename CharacterType1, typename CharacterType2&gt; int codePointCompare(const CharacterType1*, unsigned length1, const CharacterType2*, unsigned length2);
 588 int codePointCompare(const StringImpl*, const StringImpl*);
 589 
 590 // FIXME: Should rename this to make clear it uses the Unicode definition of whitespace.
 591 // Most WebKit callers don&#39;t want that would use isASCIISpace or isHTMLSpace instead.
 592 bool isSpaceOrNewline(UChar32);
 593 
 594 template&lt;typename CharacterType&gt; unsigned lengthOfNullTerminatedString(const CharacterType*);
 595 
 596 // StringHash is the default hash for StringImpl* and RefPtr&lt;StringImpl&gt;
 597 template&lt;typename T&gt; struct DefaultHash;
 598 template&lt;&gt; struct DefaultHash&lt;StringImpl*&gt; {
 599     typedef StringHash Hash;
 600 };
 601 template&lt;&gt; struct DefaultHash&lt;RefPtr&lt;StringImpl&gt;&gt; {
 602     typedef StringHash Hash;
 603 };
<a name="15" id="anc15"></a><span class="line-added"> 604 template&lt;&gt; struct DefaultHash&lt;PackedPtr&lt;StringImpl&gt;&gt; {</span>
<span class="line-added"> 605     using Hash = StringHash;</span>
<span class="line-added"> 606 };</span>
 607 
 608 #define MAKE_STATIC_STRING_IMPL(characters) ([] { \
 609         static StaticStringImpl impl(characters); \
 610         return &amp;impl; \
 611     }())
 612 
 613 template&lt;&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::constructInternal&lt;LChar&gt;(StringImpl&amp; string, unsigned length)
 614 {
 615     return adoptRef(*new (NotNull, &amp;string) StringImpl { length, Force8BitConstructor });
 616 }
 617 
 618 template&lt;&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::constructInternal&lt;UChar&gt;(StringImpl&amp; string, unsigned length)
 619 {
 620     return adoptRef(*new (NotNull, &amp;string) StringImpl { length });
 621 }
 622 
 623 template&lt;&gt; ALWAYS_INLINE const LChar* StringImpl::characters&lt;LChar&gt;() const
 624 {
 625     return characters8();
 626 }
 627 
 628 template&lt;&gt; ALWAYS_INLINE const UChar* StringImpl::characters&lt;UChar&gt;() const
 629 {
 630     return characters16();
 631 }
 632 
 633 inline size_t find(const LChar* characters, unsigned length, CodeUnitMatchFunction matchFunction, unsigned index)
 634 {
 635     while (index &lt; length) {
 636         if (matchFunction(characters[index]))
 637             return index;
 638         ++index;
 639     }
 640     return notFound;
 641 }
 642 
 643 inline size_t find(const UChar* characters, unsigned length, CodeUnitMatchFunction matchFunction, unsigned index)
 644 {
 645     while (index &lt; length) {
 646         if (matchFunction(characters[index]))
 647             return index;
 648         ++index;
 649     }
 650     return notFound;
 651 }
 652 
 653 template&lt;typename CharacterType&gt; inline size_t reverseFindLineTerminator(const CharacterType* characters, unsigned length, unsigned index)
 654 {
 655     if (!length)
 656         return notFound;
 657     if (index &gt;= length)
 658         index = length - 1;
 659     auto character = characters[index];
 660     while (character != &#39;\n&#39; &amp;&amp; character != &#39;\r&#39;) {
 661         if (!index--)
 662             return notFound;
 663         character = characters[index];
 664     }
 665     return index;
 666 }
 667 
 668 template&lt;typename CharacterType&gt; inline size_t reverseFind(const CharacterType* characters, unsigned length, CharacterType matchCharacter, unsigned index)
 669 {
 670     if (!length)
 671         return notFound;
 672     if (index &gt;= length)
 673         index = length - 1;
 674     while (characters[index] != matchCharacter) {
 675         if (!index--)
 676             return notFound;
 677     }
 678     return index;
 679 }
 680 
 681 ALWAYS_INLINE size_t reverseFind(const UChar* characters, unsigned length, LChar matchCharacter, unsigned index)
 682 {
 683     return reverseFind(characters, length, static_cast&lt;UChar&gt;(matchCharacter), index);
 684 }
 685 
 686 inline size_t reverseFind(const LChar* characters, unsigned length, UChar matchCharacter, unsigned index)
 687 {
 688     if (!isLatin1(matchCharacter))
 689         return notFound;
 690     return reverseFind(characters, length, static_cast&lt;LChar&gt;(matchCharacter), index);
 691 }
 692 
 693 inline size_t StringImpl::find(LChar character, unsigned start)
 694 {
 695     if (is8Bit())
 696         return WTF::find(characters8(), m_length, character, start);
 697     return WTF::find(characters16(), m_length, character, start);
 698 }
 699 
 700 ALWAYS_INLINE size_t StringImpl::find(char character, unsigned start)
 701 {
 702     return find(static_cast&lt;LChar&gt;(character), start);
 703 }
 704 
 705 inline size_t StringImpl::find(UChar character, unsigned start)
 706 {
 707     if (is8Bit())
 708         return WTF::find(characters8(), m_length, character, start);
 709     return WTF::find(characters16(), m_length, character, start);
 710 }
 711 
 712 template&lt;size_t inlineCapacity&gt; inline bool equalIgnoringNullity(const Vector&lt;UChar, inlineCapacity&gt;&amp; a, StringImpl* b)
 713 {
 714     return equalIgnoringNullity(a.data(), a.size(), b);
 715 }
 716 
 717 template&lt;typename CharacterType1, typename CharacterType2&gt; inline int codePointCompare(const CharacterType1* characters1, unsigned length1, const CharacterType2* characters2, unsigned length2)
 718 {
 719     unsigned commonLength = std::min(length1, length2);
 720 
 721     unsigned position = 0;
 722     while (position &lt; commonLength &amp;&amp; *characters1 == *characters2) {
 723         ++characters1;
 724         ++characters2;
 725         ++position;
 726     }
 727 
 728     if (position &lt; commonLength)
 729         return (characters1[0] &gt; characters2[0]) ? 1 : -1;
 730 
 731     if (length1 == length2)
 732         return 0;
 733     return (length1 &gt; length2) ? 1 : -1;
 734 }
 735 
 736 inline int codePointCompare(const StringImpl* string1, const StringImpl* string2)
 737 {
 738     // FIXME: Should null strings compare as less than empty strings rather than equal to them?
 739     if (!string1)
 740         return (string2 &amp;&amp; string2-&gt;length()) ? -1 : 0;
 741     if (!string2)
 742         return string1-&gt;length() ? 1 : 0;
 743 
 744     bool string1Is8Bit = string1-&gt;is8Bit();
 745     bool string2Is8Bit = string2-&gt;is8Bit();
 746     if (string1Is8Bit) {
 747         if (string2Is8Bit)
 748             return codePointCompare(string1-&gt;characters8(), string1-&gt;length(), string2-&gt;characters8(), string2-&gt;length());
 749         return codePointCompare(string1-&gt;characters8(), string1-&gt;length(), string2-&gt;characters16(), string2-&gt;length());
 750     }
 751     if (string2Is8Bit)
 752         return codePointCompare(string1-&gt;characters16(), string1-&gt;length(), string2-&gt;characters8(), string2-&gt;length());
 753     return codePointCompare(string1-&gt;characters16(), string1-&gt;length(), string2-&gt;characters16(), string2-&gt;length());
 754 }
 755 
 756 inline bool isSpaceOrNewline(UChar32 character)
 757 {
 758     // Use isASCIISpace() for all Latin-1 characters. This will include newlines, which aren&#39;t included in Unicode DirWS.
 759     return isLatin1(character) ? isASCIISpace(character) : u_charDirection(character) == U_WHITE_SPACE_NEUTRAL;
 760 }
 761 
 762 template&lt;typename CharacterType&gt; inline unsigned lengthOfNullTerminatedString(const CharacterType* string)
 763 {
 764     ASSERT(string);
 765     size_t length = 0;
 766     while (string[length])
 767         ++length;
 768 
 769     RELEASE_ASSERT(length &lt; StringImpl::MaxLength);
 770     return static_cast&lt;unsigned&gt;(length);
 771 }
 772 
 773 inline StringImplShape::StringImplShape(unsigned refCount, unsigned length, const LChar* data8, unsigned hashAndFlags)
 774     : m_refCount(refCount)
 775     , m_length(length)
 776     , m_data8(data8)
 777     , m_hashAndFlags(hashAndFlags)
 778 {
 779 }
 780 
 781 inline StringImplShape::StringImplShape(unsigned refCount, unsigned length, const UChar* data16, unsigned hashAndFlags)
 782     : m_refCount(refCount)
 783     , m_length(length)
 784     , m_data16(data16)
 785     , m_hashAndFlags(hashAndFlags)
 786 {
 787 }
 788 
 789 template&lt;unsigned characterCount&gt; constexpr StringImplShape::StringImplShape(unsigned refCount, unsigned length, const char (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag)
 790     : m_refCount(refCount)
 791     , m_length(length)
 792     , m_data8Char(characters)
 793     , m_hashAndFlags(hashAndFlags)
 794 {
 795 }
 796 
 797 template&lt;unsigned characterCount&gt; constexpr StringImplShape::StringImplShape(unsigned refCount, unsigned length, const char16_t (&amp;characters)[characterCount], unsigned hashAndFlags, ConstructWithConstExprTag)
 798     : m_refCount(refCount)
 799     , m_length(length)
 800     , m_data16Char(characters)
 801     , m_hashAndFlags(hashAndFlags)
 802 {
 803 }
 804 
 805 inline Ref&lt;StringImpl&gt; StringImpl::isolatedCopy() const
 806 {
 807     if (!requiresCopy()) {
 808         if (is8Bit())
 809             return StringImpl::createWithoutCopying(m_data8, m_length);
 810         return StringImpl::createWithoutCopying(m_data16, m_length);
 811     }
 812 
 813     if (is8Bit())
 814         return create(m_data8, m_length);
 815     return create(m_data16, m_length);
 816 }
 817 
 818 inline bool StringImpl::isAllASCII() const
 819 {
 820     if (is8Bit())
 821         return charactersAreAllASCII(characters8(), length());
 822     return charactersAreAllASCII(characters16(), length());
 823 }
 824 
 825 inline bool StringImpl::isAllLatin1() const
 826 {
 827     if (is8Bit())
 828         return true;
 829     auto* characters = characters16();
 830     UChar ored = 0;
 831     for (size_t i = 0; i &lt; length(); ++i)
 832         ored |= characters[i];
 833     return !(ored &amp; 0xFF00);
 834 }
 835 
 836 template&lt;bool isSpecialCharacter(UChar), typename CharacterType&gt; inline bool isAllSpecialCharacters(const CharacterType* characters, size_t length)
 837 {
 838     for (size_t i = 0; i &lt; length; ++i) {
 839         if (!isSpecialCharacter(characters[i]))
 840             return false;
 841     }
 842     return true;
 843 }
 844 
 845 template&lt;bool isSpecialCharacter(UChar)&gt; inline bool StringImpl::isAllSpecialCharacters() const
 846 {
 847     if (is8Bit())
 848         return WTF::isAllSpecialCharacters&lt;isSpecialCharacter&gt;(characters8(), length());
 849     return WTF::isAllSpecialCharacters&lt;isSpecialCharacter&gt;(characters16(), length());
 850 }
 851 
 852 inline StringImpl::StringImpl(unsigned length, Force8Bit)
 853     : StringImplShape(s_refCountIncrement, length, tailPointer&lt;LChar&gt;(), s_hashFlag8BitBuffer | StringNormal | BufferInternal)
 854 {
 855     ASSERT(m_data8);
 856     ASSERT(m_length);
 857 
 858     STRING_STATS_ADD_8BIT_STRING(m_length);
 859 }
 860 
 861 inline StringImpl::StringImpl(unsigned length)
 862     : StringImplShape(s_refCountIncrement, length, tailPointer&lt;UChar&gt;(), StringNormal | BufferInternal)
 863 {
 864     ASSERT(m_data16);
 865     ASSERT(m_length);
 866 
 867     STRING_STATS_ADD_16BIT_STRING(m_length);
 868 }
 869 
<a name="16" id="anc16"></a><span class="line-modified"> 870 template&lt;typename Malloc&gt;</span>
<span class="line-modified"> 871 inline StringImpl::StringImpl(MallocPtr&lt;LChar, Malloc&gt; characters, unsigned length)</span>
<span class="line-added"> 872     : StringImplShape(s_refCountIncrement, length, static_cast&lt;const LChar*&gt;(nullptr), s_hashFlag8BitBuffer | StringNormal | BufferOwned)</span>
 873 {
<a name="17" id="anc17"></a><span class="line-added"> 874     if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="line-added"> 875         m_data8 = characters.leakPtr();</span>
<span class="line-added"> 876     else {</span>
<span class="line-added"> 877         m_data8 = static_cast&lt;const LChar*&gt;(StringImplMalloc::malloc(length));</span>
<span class="line-added"> 878         memcpy((void*)m_data8, characters.get(), length);</span>
<span class="line-added"> 879     }</span>
<span class="line-added"> 880 </span>
 881     ASSERT(m_data8);
 882     ASSERT(m_length);
 883 
 884     STRING_STATS_ADD_8BIT_STRING(m_length);
 885 }
 886 
 887 inline StringImpl::StringImpl(const UChar* characters, unsigned length, ConstructWithoutCopyingTag)
 888     : StringImplShape(s_refCountIncrement, length, characters, StringNormal | BufferInternal)
 889 {
 890     ASSERT(m_data16);
 891     ASSERT(m_length);
 892 
 893     STRING_STATS_ADD_16BIT_STRING(m_length);
 894 }
 895 
 896 inline StringImpl::StringImpl(const LChar* characters, unsigned length, ConstructWithoutCopyingTag)
 897     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringNormal | BufferInternal)
 898 {
 899     ASSERT(m_data8);
 900     ASSERT(m_length);
 901 
 902     STRING_STATS_ADD_8BIT_STRING(m_length);
 903 }
 904 
<a name="18" id="anc18"></a><span class="line-modified"> 905 template&lt;typename Malloc&gt;</span>
<span class="line-modified"> 906 inline StringImpl::StringImpl(MallocPtr&lt;UChar, Malloc&gt; characters, unsigned length)</span>
<span class="line-added"> 907     : StringImplShape(s_refCountIncrement, length, static_cast&lt;const UChar*&gt;(nullptr), StringNormal | BufferOwned)</span>
 908 {
<a name="19" id="anc19"></a><span class="line-added"> 909     if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="line-added"> 910         m_data16 = characters.leakPtr();</span>
<span class="line-added"> 911     else {</span>
<span class="line-added"> 912         m_data16 = static_cast&lt;const UChar*&gt;(StringImplMalloc::malloc(length * sizeof(UChar)));</span>
<span class="line-added"> 913         memcpy((void*)m_data16, characters.get(), length * sizeof(UChar));</span>
<span class="line-added"> 914     }</span>
<span class="line-added"> 915 </span>
 916     ASSERT(m_data16);
 917     ASSERT(m_length);
 918 
 919     STRING_STATS_ADD_16BIT_STRING(m_length);
 920 }
 921 
 922 inline StringImpl::StringImpl(const LChar* characters, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp; base)
 923     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringNormal | BufferSubstring)
 924 {
 925     ASSERT(is8Bit());
 926     ASSERT(m_data8);
 927     ASSERT(m_length);
 928     ASSERT(base-&gt;bufferOwnership() != BufferSubstring);
 929 
 930     substringBuffer() = &amp;base.leakRef();
 931 
 932     STRING_STATS_ADD_8BIT_STRING2(m_length, true);
 933 }
 934 
 935 inline StringImpl::StringImpl(const UChar* characters, unsigned length, Ref&lt;StringImpl&gt;&amp;&amp; base)
 936     : StringImplShape(s_refCountIncrement, length, characters, StringNormal | BufferSubstring)
 937 {
 938     ASSERT(!is8Bit());
 939     ASSERT(m_data16);
 940     ASSERT(m_length);
 941     ASSERT(base-&gt;bufferOwnership() != BufferSubstring);
 942 
 943     substringBuffer() = &amp;base.leakRef();
 944 
 945     STRING_STATS_ADD_16BIT_STRING2(m_length, true);
 946 }
 947 
 948 template&lt;size_t inlineCapacity&gt; inline Ref&lt;StringImpl&gt; StringImpl::create8BitIfPossible(const Vector&lt;UChar, inlineCapacity&gt;&amp; vector)
 949 {
 950     return create8BitIfPossible(vector.data(), vector.size());
 951 }
 952 
 953 ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::createSubstringSharingImpl(StringImpl&amp; rep, unsigned offset, unsigned length)
 954 {
 955     ASSERT(length &lt;= rep.length());
 956 
 957     if (!length)
 958         return *empty();
 959 
 960     // Coyping the thing would save more memory sometimes, largely due to the size of pointer.
 961     size_t substringSize = allocationSize&lt;StringImpl*&gt;(1);
 962     if (rep.is8Bit()) {
 963         if (substringSize &gt;= allocationSize&lt;LChar&gt;(length))
 964             return create(rep.m_data8 + offset, length);
 965     } else {
 966         if (substringSize &gt;= allocationSize&lt;UChar&gt;(length))
 967             return create(rep.m_data16 + offset, length);
 968     }
 969 
 970     auto* ownerRep = ((rep.bufferOwnership() == BufferSubstring) ? rep.substringBuffer() : &amp;rep);
 971 
 972     // We allocate a buffer that contains both the StringImpl struct as well as the pointer to the owner string.
<a name="20" id="anc20"></a><span class="line-modified"> 973     auto* stringImpl = static_cast&lt;StringImpl*&gt;(StringImplMalloc::malloc(substringSize));</span>
 974     if (rep.is8Bit())
 975         return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data8 + offset, length, *ownerRep));
 976     return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data16 + offset, length, *ownerRep));
 977 }
 978 
 979 template&lt;unsigned characterCount&gt; ALWAYS_INLINE Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char (&amp;characters)[characterCount])
 980 {
 981     COMPILE_ASSERT(characterCount &gt; 1, StringImplFromLiteralNotEmpty);
 982     COMPILE_ASSERT((characterCount - 1 &lt;= ((unsigned(~0) - sizeof(StringImpl)) / sizeof(LChar))), StringImplFromLiteralCannotOverflow);
 983 
 984     return createWithoutCopying(reinterpret_cast&lt;const LChar*&gt;(characters), characterCount - 1);
 985 }
 986 
 987 template&lt;typename CharacterType&gt; ALWAYS_INLINE RefPtr&lt;StringImpl&gt; StringImpl::tryCreateUninitialized(unsigned length, CharacterType*&amp; output)
 988 {
 989     if (!length) {
 990         output = nullptr;
 991         return empty();
 992     }
 993 
 994     if (length &gt; maxInternalLength&lt;CharacterType&gt;()) {
 995         output = nullptr;
 996         return nullptr;
 997     }
 998     StringImpl* result;
<a name="21" id="anc21"></a><span class="line-modified"> 999 </span>
<span class="line-added">1000     result = (StringImpl*)StringImplMalloc::tryMalloc(allocationSize&lt;CharacterType&gt;(length));</span>
<span class="line-added">1001     if (!result) {</span>
1002         output = nullptr;
1003         return nullptr;
1004     }
1005     output = result-&gt;tailPointer&lt;CharacterType&gt;();
1006 
1007     return constructInternal&lt;CharacterType&gt;(*result, length);
1008 }
1009 
<a name="22" id="anc22"></a><span class="line-modified">1010 template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">1011 inline Ref&lt;StringImpl&gt; StringImpl::adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; vector)</span>
1012 {
1013     if (size_t size = vector.size()) {
1014         ASSERT(vector.data());
1015         if (size &gt; MaxLength)
1016             CRASH();
<a name="23" id="anc23"></a><span class="line-modified">1017 </span>
<span class="line-added">1018         if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="line-added">1019             return adoptRef(*new StringImpl(vector.releaseBuffer(), size));</span>
<span class="line-added">1020         else {</span>
<span class="line-added">1021             // We have to copy between malloc zones.</span>
<span class="line-added">1022             auto vectorBuffer = vector.releaseBuffer();</span>
<span class="line-added">1023             auto stringImplBuffer = MallocPtr&lt;CharacterType, StringImplMalloc&gt;::malloc(size);</span>
<span class="line-added">1024             memcpy(stringImplBuffer.get(), vectorBuffer.get(), size);</span>
<span class="line-added">1025             return adoptRef(*new StringImpl(WTFMove(stringImplBuffer), size));</span>
<span class="line-added">1026         }</span>
1027     }
1028     return *empty();
1029 }
1030 
1031 inline size_t StringImpl::cost() const
1032 {
1033     // For substrings, return the cost of the base string.
1034     if (bufferOwnership() == BufferSubstring)
1035         return substringBuffer()-&gt;cost();
1036 
1037     // Note: we must not alter the m_hashAndFlags field in instances of StaticStringImpl.
1038     // We ensure this by pre-setting the s_hashFlagDidReportCost bit in all instances of
1039     // StaticStringImpl. As a result, StaticStringImpl instances will always return a cost of
1040     // 0 here and avoid modifying m_hashAndFlags.
1041     if (m_hashAndFlags &amp; s_hashFlagDidReportCost)
1042         return 0;
1043 
1044     m_hashAndFlags |= s_hashFlagDidReportCost;
1045     size_t result = m_length;
1046     if (!is8Bit())
1047         result &lt;&lt;= 1;
1048     return result;
1049 }
1050 
1051 inline size_t StringImpl::costDuringGC()
1052 {
1053     if (isStatic())
1054         return 0;
1055 
1056     if (bufferOwnership() == BufferSubstring)
1057         return divideRoundedUp(substringBuffer()-&gt;costDuringGC(), refCount());
1058 
1059     size_t result = m_length;
1060     if (!is8Bit())
1061         result &lt;&lt;= 1;
1062     return divideRoundedUp(result, refCount());
1063 }
1064 
1065 inline void StringImpl::setIsAtom(bool isAtom)
1066 {
1067     ASSERT(!isStatic());
1068     ASSERT(!isSymbol());
1069     if (isAtom)
1070         m_hashAndFlags |= s_hashFlagStringKindIsAtom;
1071     else
1072         m_hashAndFlags &amp;= ~s_hashFlagStringKindIsAtom;
1073 }
1074 
1075 inline void StringImpl::setHash(unsigned hash) const
1076 {
1077     // The high bits of &#39;hash&#39; are always empty, but we prefer to store our flags
1078     // in the low bits because it makes them slightly more efficient to access.
1079     // So, we shift left and right when setting and getting our hash code.
1080 
1081     ASSERT(!hasHash());
1082     ASSERT(!isStatic());
1083     // Multiple clients assume that StringHasher is the canonical string hash function.
1084     ASSERT(hash == (is8Bit() ? StringHasher::computeHashAndMaskTop8Bits(m_data8, m_length) : StringHasher::computeHashAndMaskTop8Bits(m_data16, m_length)));
1085     ASSERT(!(hash &amp; (s_flagMask &lt;&lt; (8 * sizeof(hash) - s_flagCount)))); // Verify that enough high bits are empty.
1086 
1087     hash &lt;&lt;= s_flagCount;
1088     ASSERT(!(hash &amp; m_hashAndFlags)); // Verify that enough low bits are empty after shift.
1089     ASSERT(hash); // Verify that 0 is a valid sentinel hash value.
1090 
1091     m_hashAndFlags |= hash; // Store hash with flags in low bits.
1092 }
1093 
1094 inline void StringImpl::ref()
1095 {
1096     STRING_STATS_REF_STRING(*this);
1097 
1098     m_refCount += s_refCountIncrement;
1099 }
1100 
1101 inline void StringImpl::deref()
1102 {
1103     STRING_STATS_DEREF_STRING(*this);
1104 
1105     unsigned tempRefCount = m_refCount - s_refCountIncrement;
1106     if (!tempRefCount) {
1107         StringImpl::destroy(this);
1108         return;
1109     }
1110     m_refCount = tempRefCount;
1111 }
1112 
<a name="24" id="anc24"></a><span class="line-modified">1113 template&lt;typename SourceCharacterType, typename DestinationCharacterType&gt;</span>
<span class="line-added">1114 inline void StringImpl::copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters)</span>
1115 {
<a name="25" id="anc25"></a><span class="line-modified">1116     static_assert(std::is_same&lt;SourceCharacterType, LChar&gt;::value || std::is_same&lt;SourceCharacterType, UChar&gt;::value);</span>
<span class="line-modified">1117     static_assert(std::is_same&lt;DestinationCharacterType, LChar&gt;::value || std::is_same&lt;DestinationCharacterType, UChar&gt;::value);</span>
<span class="line-modified">1118     if constexpr (std::is_same&lt;SourceCharacterType, DestinationCharacterType&gt;::value) {</span>
<span class="line-added">1119         if (numCharacters == 1) {</span>
<span class="line-added">1120             *destination = *source;</span>
<span class="line-added">1121             return;</span>
<span class="line-added">1122         }</span>
<span class="line-added">1123         memcpy(destination, source, numCharacters * sizeof(DestinationCharacterType));</span>
<span class="line-added">1124     } else {</span>
<span class="line-added">1125         // FIXME: We should ensure that UChar -&gt; LChar copying happens when UChar only contains Latin-1.</span>
<span class="line-added">1126         // https://bugs.webkit.org/show_bug.cgi?id=205355</span>
<span class="line-added">1127         for (unsigned i = 0; i &lt; numCharacters; ++i)</span>
<span class="line-added">1128             destination[i] = source[i];</span>
1129     }
<a name="26" id="anc26"></a>






1130 }
1131 
1132 inline UChar StringImpl::at(unsigned i) const
1133 {
1134     ASSERT_WITH_SECURITY_IMPLICATION(i &lt; m_length);
1135     return is8Bit() ? m_data8[i] : m_data16[i];
1136 }
1137 
1138 inline StringImpl::StringImpl(CreateSymbolTag, const LChar* characters, unsigned length)
1139     : StringImplShape(s_refCountIncrement, length, characters, s_hashFlag8BitBuffer | StringSymbol | BufferSubstring)
1140 {
1141     ASSERT(is8Bit());
1142     ASSERT(m_data8);
1143     STRING_STATS_ADD_8BIT_STRING2(m_length, true);
1144 }
1145 
1146 inline StringImpl::StringImpl(CreateSymbolTag, const UChar* characters, unsigned length)
1147     : StringImplShape(s_refCountIncrement, length, characters, StringSymbol | BufferSubstring)
1148 {
1149     ASSERT(!is8Bit());
1150     ASSERT(m_data16);
1151     STRING_STATS_ADD_16BIT_STRING2(m_length, true);
1152 }
1153 
1154 inline StringImpl::StringImpl(CreateSymbolTag)
1155     : StringImplShape(s_refCountIncrement, 0, empty()-&gt;characters8(), s_hashFlag8BitBuffer | StringSymbol | BufferSubstring)
1156 {
1157     ASSERT(is8Bit());
1158     ASSERT(m_data8);
1159     STRING_STATS_ADD_8BIT_STRING2(m_length, true);
1160 }
1161 
1162 template&lt;typename T&gt; inline size_t StringImpl::allocationSize(Checked&lt;size_t&gt; tailElementCount)
1163 {
1164     return (tailOffset&lt;T&gt;() + tailElementCount * sizeof(T)).unsafeGet();
1165 }
1166 
1167 template&lt;typename CharacterType&gt;
1168 inline size_t StringImpl::maxInternalLength()
1169 {
1170     // In order to not overflow the unsigned length, the check for (std::numeric_limits&lt;unsigned&gt;::max() - sizeof(StringImpl)) is needed when sizeof(CharacterType) == 2.
1171     return std::min(static_cast&lt;size_t&gt;(MaxLength), (std::numeric_limits&lt;unsigned&gt;::max() - sizeof(StringImpl)) / sizeof(CharacterType));
1172 }
1173 
1174 template&lt;typename T&gt; inline size_t StringImpl::tailOffset()
1175 {
1176 #if COMPILER(MSVC)
1177     // MSVC doesn&#39;t support alignof yet.
1178     return roundUpToMultipleOf&lt;sizeof(T)&gt;(sizeof(StringImpl));
1179 #else
1180     return roundUpToMultipleOf&lt;alignof(T)&gt;(offsetof(StringImpl, m_hashAndFlags) + sizeof(StringImpl::m_hashAndFlags));
1181 #endif
1182 }
1183 
1184 inline bool StringImpl::requiresCopy() const
1185 {
1186     if (bufferOwnership() != BufferInternal)
1187         return true;
1188 
1189     if (is8Bit())
1190         return m_data8 == tailPointer&lt;LChar&gt;();
1191     return m_data16 == tailPointer&lt;UChar&gt;();
1192 }
1193 
1194 template&lt;typename T&gt; inline const T* StringImpl::tailPointer() const
1195 {
1196     return reinterpret_cast_ptr&lt;const T*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(this) + tailOffset&lt;T&gt;());
1197 }
1198 
1199 template&lt;typename T&gt; inline T* StringImpl::tailPointer()
1200 {
1201     return reinterpret_cast_ptr&lt;T*&gt;(reinterpret_cast&lt;uint8_t*&gt;(this) + tailOffset&lt;T&gt;());
1202 }
1203 
1204 inline StringImpl* const&amp; StringImpl::substringBuffer() const
1205 {
1206     ASSERT(bufferOwnership() == BufferSubstring);
1207 
1208     return *tailPointer&lt;StringImpl*&gt;();
1209 }
1210 
1211 inline StringImpl*&amp; StringImpl::substringBuffer()
1212 {
1213     ASSERT(bufferOwnership() == BufferSubstring);
1214 
1215     return *tailPointer&lt;StringImpl*&gt;();
1216 }
1217 
1218 inline void StringImpl::assertHashIsCorrect() const
1219 {
1220     ASSERT(existingHash() == StringHasher::computeHashAndMaskTop8Bits(characters8(), length()));
1221 }
1222 
1223 template&lt;unsigned characterCount&gt; constexpr StringImpl::StaticStringImpl::StaticStringImpl(const char (&amp;characters)[characterCount], StringKind stringKind)
1224     : StringImplShape(s_refCountFlagIsStaticString, characterCount - 1, characters,
1225         s_hashFlag8BitBuffer | s_hashFlagDidReportCost | stringKind | BufferInternal | (StringHasher::computeLiteralHashAndMaskTop8Bits(characters) &lt;&lt; s_flagCount), ConstructWithConstExpr)
1226 {
1227 }
1228 
1229 template&lt;unsigned characterCount&gt; constexpr StringImpl::StaticStringImpl::StaticStringImpl(const char16_t (&amp;characters)[characterCount], StringKind stringKind)
1230     : StringImplShape(s_refCountFlagIsStaticString, characterCount - 1, characters,
1231         s_hashFlagDidReportCost | stringKind | BufferInternal | (StringHasher::computeLiteralHashAndMaskTop8Bits(characters) &lt;&lt; s_flagCount), ConstructWithConstExpr)
1232 {
1233 }
1234 
1235 inline StringImpl::StaticStringImpl::operator StringImpl&amp;()
1236 {
1237     return *reinterpret_cast&lt;StringImpl*&gt;(this);
1238 }
1239 
1240 inline bool equalIgnoringASCIICase(const StringImpl&amp; a, const StringImpl&amp; b)
1241 {
1242     return equalIgnoringASCIICaseCommon(a, b);
1243 }
1244 
1245 inline bool equalIgnoringASCIICase(const StringImpl&amp; a, const char* b)
1246 {
1247     return equalIgnoringASCIICaseCommon(a, b);
1248 }
1249 
1250 inline bool equalIgnoringASCIICase(const StringImpl* a, const char* b)
1251 {
1252     return a &amp;&amp; equalIgnoringASCIICase(*a, b);
1253 }
1254 
1255 template&lt;unsigned length&gt; inline bool startsWithLettersIgnoringASCIICase(const StringImpl&amp; string, const char (&amp;lowercaseLetters)[length])
1256 {
1257     return startsWithLettersIgnoringASCIICaseCommon(string, lowercaseLetters);
1258 }
1259 
1260 template&lt;unsigned length&gt; inline bool startsWithLettersIgnoringASCIICase(const StringImpl* string, const char (&amp;lowercaseLetters)[length])
1261 {
1262     return string &amp;&amp; startsWithLettersIgnoringASCIICase(*string, lowercaseLetters);
1263 }
1264 
1265 template&lt;unsigned length&gt; inline bool equalLettersIgnoringASCIICase(const StringImpl&amp; string, const char (&amp;lowercaseLetters)[length])
1266 {
1267     return equalLettersIgnoringASCIICaseCommon(string, lowercaseLetters);
1268 }
1269 
1270 template&lt;unsigned length&gt; inline bool equalLettersIgnoringASCIICase(const StringImpl* string, const char (&amp;lowercaseLetters)[length])
1271 {
1272     return string &amp;&amp; equalLettersIgnoringASCIICase(*string, lowercaseLetters);
1273 }
1274 
1275 } // namespace WTF
1276 
1277 using WTF::StaticStringImpl;
1278 using WTF::StringImpl;
1279 using WTF::equal;
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
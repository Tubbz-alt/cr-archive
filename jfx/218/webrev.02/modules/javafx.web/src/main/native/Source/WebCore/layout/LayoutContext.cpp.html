<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/LayoutContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;BlockFormattingContext.h&quot;
 32 #include &quot;BlockFormattingState.h&quot;
 33 #include &quot;DisplayBox.h&quot;
 34 #include &quot;DisplayPainter.h&quot;
 35 #include &quot;InlineFormattingContext.h&quot;
 36 #include &quot;InlineFormattingState.h&quot;
 37 #include &quot;InvalidationContext.h&quot;
 38 #include &quot;InvalidationState.h&quot;
 39 #include &quot;LayoutBox.h&quot;
 40 #include &quot;LayoutContainer.h&quot;
 41 #include &quot;LayoutPhase.h&quot;
 42 #include &quot;LayoutTreeBuilder.h&quot;
 43 #include &quot;RenderStyleConstants.h&quot;
 44 #include &quot;RenderView.h&quot;
 45 #include &quot;RuntimeEnabledFeatures.h&quot;
 46 #include &quot;TableFormattingContext.h&quot;
 47 #include &quot;TableFormattingState.h&quot;
 48 #include &lt;wtf/IsoMallocInlines.h&gt;
 49 
 50 namespace WebCore {
 51 namespace Layout {
 52 
 53 WTF_MAKE_ISO_ALLOCATED_IMPL(LayoutContext);
 54 
 55 LayoutContext::LayoutContext(LayoutState&amp; layoutState)
 56     : m_layoutState(layoutState)
 57 {
 58 }
 59 
 60 void LayoutContext::layout(const LayoutSize&amp; rootContentBoxSize, InvalidationState&amp; invalidationState)
 61 {
 62     // Set the geometry on the root.
 63     // Note that we never layout the root box. It has to have an already computed geometry (in case of ICB, it&#39;s the view geometry).
 64     // ICB establishes the initial BFC, but it does not live in a formatting context and while a non-ICB root(subtree layout) has to have a formatting context,
 65     // we could not lay it out even if we wanted to since it&#39;s outside of this LayoutContext.
 66     auto&amp; displayBox = layoutState().displayBoxForRootLayoutBox();
 67     displayBox.setHorizontalMargin({ });
 68     displayBox.setHorizontalComputedMargin({ });
 69     displayBox.setVerticalMargin({ });
 70     displayBox.setBorder({ });
 71     displayBox.setPadding({ });
 72     displayBox.setTopLeft({ });
 73     displayBox.setContentBoxHeight(rootContentBoxSize.height());
 74     displayBox.setContentBoxWidth(rootContentBoxSize.width());
 75 
 76     layoutWithPreparedRootGeometry(invalidationState);
 77 }
 78 
 79 void LayoutContext::layoutWithPreparedRootGeometry(InvalidationState&amp; invalidationState)
 80 {
 81     PhaseScope scope(Phase::Type::Layout);
 82 
 83     auto&amp; formattingContextRootsForLayout = invalidationState.formattingContextRoots();
 84     // When invalidation is empty, we assume constraint mutation and start running layout on the context root. Layout logic should be able to figure out the damage.
 85     if (formattingContextRootsForLayout.computesEmpty())
 86         return layoutFormattingContextSubtree(m_layoutState.root(), invalidationState);
 87 
 88     for (auto&amp; formattingContextRoot : formattingContextRootsForLayout)
 89         layoutFormattingContextSubtree(formattingContextRoot, invalidationState);
 90 }
 91 
 92 void LayoutContext::layoutFormattingContextSubtree(const Container&amp; formattingContextRoot, InvalidationState&amp; invalidationState)
 93 {
 94     RELEASE_ASSERT(formattingContextRoot.establishesFormattingContext());
 95     auto formattingContext = createFormattingContext(formattingContextRoot, layoutState());
 96     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(formattingContextRoot);
 97 
 98     auto horizontalConstraints = HorizontalConstraints { displayBox.contentBoxLeft(), displayBox.contentBoxWidth() };
 99     auto verticalConstraints = VerticalConstraints { displayBox.contentBoxTop(), { } };
100     formattingContext-&gt;layoutInFlowContent(invalidationState, horizontalConstraints, verticalConstraints);
101 
102     // FIXME: layoutFormattingContextSubtree() does not perform layout on the root, rather it lays out the root&#39;s content.
103     // It constructs an FC for descendant boxes and runs layout on them. The formattingContextRoot is laid out in the FC in which it lives (parent formatting context).
104     // It also means that the formattingContextRoot has to have a valid/clean geometry at this point.
105     {
106         auto horizontalConstraints = HorizontalConstraints { displayBox.paddingBoxLeft(), displayBox.paddingBoxWidth() };
107         auto verticalConstraints = VerticalConstraints { displayBox.paddingBoxTop(), displayBox.paddingBoxHeight() };
108         formattingContext-&gt;layoutOutOfFlowContent(invalidationState, horizontalConstraints, verticalConstraints);
109     }
110 }
111 
112 std::unique_ptr&lt;FormattingContext&gt; LayoutContext::createFormattingContext(const Container&amp; formattingContextRoot, LayoutState&amp; layoutState)
113 {
114     ASSERT(formattingContextRoot.establishesFormattingContext());
115     if (formattingContextRoot.establishesInlineFormattingContext()) {
116         auto&amp; inlineFormattingState = layoutState.ensureInlineFormattingState(formattingContextRoot);
117         return makeUnique&lt;InlineFormattingContext&gt;(formattingContextRoot, inlineFormattingState);
118     }
119 
120     if (formattingContextRoot.establishesBlockFormattingContext()) {
121         ASSERT(!formattingContextRoot.establishesInlineFormattingContext());
122         auto&amp; blockFormattingState = layoutState.ensureBlockFormattingState(formattingContextRoot);
123         return makeUnique&lt;BlockFormattingContext&gt;(formattingContextRoot, blockFormattingState);
124     }
125 
126     if (formattingContextRoot.establishesTableFormattingContext()) {
127         auto&amp; tableFormattingState = layoutState.ensureTableFormattingState(formattingContextRoot);
128         return makeUnique&lt;TableFormattingContext&gt;(formattingContextRoot, tableFormattingState);
129     }
130 
131     CRASH();
132 }
133 
134 void LayoutContext::paint(const LayoutState&amp; layoutState, GraphicsContext&amp; context, const IntRect&amp; dirtyRect)
135 {
136     Display::Painter::paint(layoutState, context, dirtyRect);
137 }
138 
139 }
140 }
141 
142 #endif
    </pre>
  </body>
</html>
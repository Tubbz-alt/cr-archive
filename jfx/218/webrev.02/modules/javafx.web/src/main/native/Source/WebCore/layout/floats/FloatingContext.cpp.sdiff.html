<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FloatingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;FloatAvoider.h&quot;
 33 #include &quot;FloatBox.h&quot;
 34 #include &quot;FormattingContext.h&quot;
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;
<span class="line-removed"> 37 #include &quot;LayoutState.h&quot;</span>
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 
 40 namespace WebCore {
 41 namespace Layout {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(FloatingContext);
 44 
 45 // Finding the top/left position for a new floating(F)
 46 //  ____  ____  _____               _______
 47 // |    || L2 ||     | &lt;-----1----&gt;|       |
 48 // |    ||____||  L3 |             |   R1  |
 49 // | L1 |      |_____|             |       |
 50 // |____| &lt;-------------2---------&gt;|       |
 51 //                                 |       |
 52 //                                 |_______|
 53 //
 54 // 1. Compute the initial vertical position for (F) -&gt; (1)
 55 // 2. Find the corresponding floating pair (L3-R1)
 56 // 3. Align (F) horizontally with (L3-R1) depending whether (F) is left/right positioned
 57 // 4. Intersect (F) with (L3-R1)
</pre>
<hr />
<pre>
101     bool operator!=(const Iterator&amp;) const;
102 
103 private:
104     void set(PositionInContextRoot verticalPosition);
105 
106     const FloatingState::FloatList&amp; m_floats;
107     FloatPair m_current;
108 };
109 
110 static Iterator begin(const FloatingState::FloatList&amp; floats, PositionInContextRoot initialVerticalPosition)
111 {
112     // Start with the inner-most floating pair for the initial vertical position.
113     return Iterator(floats, initialVerticalPosition);
114 }
115 
116 static Iterator end(const FloatingState::FloatList&amp; floats)
117 {
118     return Iterator(floats, { });
119 }
120 
<span class="line-modified">121 #ifndef NDEBUG</span>
122 static bool areFloatsHorizontallySorted(const FloatingState&amp; floatingState)
123 {
124     auto&amp; floats = floatingState.floats();
125     auto rightEdgeOfLeftFloats = LayoutUnit::min();
126     auto leftEdgeOfRightFloats = LayoutUnit::max();
127     WTF::Optional&lt;LayoutUnit&gt; leftBottom;
128     WTF::Optional&lt;LayoutUnit&gt; rightBottom;
129 
130     for (auto&amp; floatItem : floats) {
131         if (floatItem.isLeftPositioned()) {
132             auto rightEdge = floatItem.rectWithMargin().right();
133             if (rightEdge &lt; rightEdgeOfLeftFloats) {
134                 if (leftBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *leftBottom)
135                     return false;
136             }
137             leftBottom = floatItem.rectWithMargin().bottom();
138             rightEdgeOfLeftFloats = rightEdge;
139         } else {
140             auto leftEdge = floatItem.rectWithMargin().left();
141             if (leftEdge &gt; leftEdgeOfRightFloats) {
142                 if (rightBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *rightBottom)
143                     return false;
144             }
145             rightBottom = floatItem.rectWithMargin().bottom();
146             leftEdgeOfRightFloats = leftEdge;
147         }
148     }
149     return true;
150 }
151 #endif
152 
<span class="line-modified">153 FloatingContext::FloatingContext(FloatingState&amp; floatingState)</span>
<span class="line-modified">154     : m_floatingState(floatingState)</span>








155 {
156 }
157 
158 Point FloatingContext::positionForFloat(const Box&amp; layoutBox) const
159 {
160     ASSERT(layoutBox.isFloatingPositioned());
161     ASSERT(areFloatsHorizontallySorted(m_floatingState));
162 
<span class="line-modified">163     if (m_floatingState.isEmpty()) {</span>
<span class="line-modified">164         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
165 
166         auto alignWithContainingBlock = [&amp;]() -&gt; Position {
167             // If there is no floating to align with, push the box to the left/right edge of its containing block&#39;s content box.
<span class="line-modified">168             auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(*layoutBox.containingBlock());</span>
169 
170             if (layoutBox.isLeftFloatingPositioned())
<span class="line-modified">171                 return Position { containingBlockDisplayBox.contentBoxLeft() + displayBox.marginStart() };</span>
172 
<span class="line-modified">173             return Position { containingBlockDisplayBox.contentBoxRight() - displayBox.marginEnd() - displayBox.width() };</span>
174         };
175 
176         // No float box on the context yet -&gt; align it with the containing block&#39;s left/right edge.
<span class="line-modified">177         return { alignWithContainingBlock(), displayBox.top() };</span>
178     }
179 
180     // Find the top most position where the float box fits.
<span class="line-modified">181     FloatBox floatBox = { layoutBox, m_floatingState, layoutState() };</span>





182     findPositionForFloatBox(floatBox);
183     return floatBox.rectInContainingBlock().topLeft();
184 }
185 
186 Optional&lt;Point&gt; FloatingContext::positionForFormattingContextRoot(const Box&amp; layoutBox) const
187 {
188     ASSERT(layoutBox.establishesBlockFormattingContext());
189     ASSERT(!layoutBox.isFloatingPositioned());
190     ASSERT(!layoutBox.hasFloatClear());
191     ASSERT(areFloatsHorizontallySorted(m_floatingState));
192 
<span class="line-modified">193     if (m_floatingState.isEmpty())</span>
194         return { };
195 
<span class="line-modified">196     FloatAvoider floatAvoider = { layoutBox, m_floatingState, layoutState() };</span>

197     findPositionForFormattingContextRoot(floatAvoider);
198     return { floatAvoider.rectInContainingBlock().topLeft() };
199 }
200 
201 FloatingContext::ClearancePosition FloatingContext::verticalPositionWithClearance(const Box&amp; layoutBox) const
202 {
203     ASSERT(layoutBox.hasFloatClear());
204     ASSERT(layoutBox.isBlockLevelBox());
205     ASSERT(areFloatsHorizontallySorted(m_floatingState));
206 
<span class="line-modified">207     if (m_floatingState.isEmpty())</span>
208         return { };
209 
210     auto bottom = [&amp;](Optional&lt;PositionInContextRoot&gt; floatBottom) -&gt; ClearancePosition {
211         // &#39;bottom&#39; is in the formatting root&#39;s coordinate system.
212         if (!floatBottom)
213             return { };
214 
215         // 9.5.2 Controlling flow next to floats: the &#39;clear&#39; property
216         // Then the amount of clearance is set to the greater of:
217         //
218         // 1. The amount necessary to place the border edge of the block even with the bottom outer edge of the lowest float that is to be cleared.
219         // 2. The amount necessary to place the top border edge of the block at its hypothetical position.
<span class="line-modified">220         auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">221         auto rootRelativeTop = FormattingContext::mapTopToAncestor(layoutState, layoutBox, downcast&lt;Container&gt;(m_floatingState.root()));</span>
222         auto clearance = *floatBottom - rootRelativeTop;
223         if (clearance &lt;= 0)
224             return { };
225 
226         // Clearance inhibits margin collapsing.
227         if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
228             // Does this box with clearance actually collapse its margin before with the previous inflow box&#39;s margin after?
<span class="line-modified">229             auto verticalMargin = layoutState.displayBoxForLayoutBox(layoutBox).verticalMargin();</span>
230             if (verticalMargin.hasCollapsedValues() &amp;&amp; verticalMargin.collapsedValues().before) {
<span class="line-modified">231                 auto previousVerticalMargin = layoutState.displayBoxForLayoutBox(*previousInFlowSibling).verticalMargin();</span>
232                 auto collapsedMargin = *verticalMargin.collapsedValues().before;
233                 auto nonCollapsedMargin = previousVerticalMargin.after() + verticalMargin.before();
234                 auto marginDifference = nonCollapsedMargin - collapsedMargin;
235                 // Move the box to the position where it would be with non-collapsed margins.
236                 rootRelativeTop += marginDifference;
237                 // Having negative clearance is also normal. It just means that the box with the non-collapsed margins is now lower than it needs to be.
238                 clearance -= marginDifference;
239             }
240         }
241         // Now adjust the box&#39;s position with the clearance.
242         rootRelativeTop += clearance;
243         ASSERT(*floatBottom == rootRelativeTop);
244 
245         // The return vertical position is in the containing block&#39;s coordinate system. Convert it to the formatting root&#39;s coordinate system if needed.
246         if (layoutBox.containingBlock() == &amp;m_floatingState.root())
247             return { Position { rootRelativeTop }, clearance };
248 
<span class="line-modified">249         auto containingBlockRootRelativeTop = FormattingContext::mapTopToAncestor(layoutState, *layoutBox.containingBlock(), downcast&lt;Container&gt;(m_floatingState.root()));</span>
250         return { Position { rootRelativeTop - containingBlockRootRelativeTop }, clearance };
251     };
252 
253     auto clear = layoutBox.style().clear();
<span class="line-removed">254     auto&amp; formattingContextRoot = layoutBox.formattingContextRoot();</span>
<span class="line-removed">255 </span>
256     if (clear == Clear::Left)
<span class="line-modified">257         return bottom(m_floatingState.leftBottom(formattingContextRoot));</span>
258 
259     if (clear == Clear::Right)
<span class="line-modified">260         return bottom(m_floatingState.rightBottom(formattingContextRoot));</span>
261 
262     if (clear == Clear::Both)
<span class="line-modified">263         return bottom(m_floatingState.bottom(formattingContextRoot));</span>
264 
265     ASSERT_NOT_REACHED();
266     return { };
267 }
268 

























































269 static FloatPair::LeftRightIndex findAvailablePosition(FloatAvoider&amp; floatAvoider, const FloatingState::FloatList&amp; floats)
270 {
271     Optional&lt;PositionInContextRoot&gt; bottomMost;
272     Optional&lt;FloatPair::LeftRightIndex&gt; innerMostLeftAndRight;
273     auto end = Layout::end(floats);
274     for (auto iterator = begin(floats, { floatAvoider.rect().top() }); iterator != end; ++iterator) {
275         ASSERT(!(*iterator).isEmpty());
276         auto leftRightFloatPair = *iterator;
277         innerMostLeftAndRight = innerMostLeftAndRight.valueOr(*leftRightFloatPair);
278 
279         // Move the box horizontally so that it either
280         // 1. aligns with the current floating pair
281         // 2. or with the containing block&#39;s content box if there&#39;s no float to align with at this vertical position.
282         floatAvoider.setHorizontalConstraints(leftRightFloatPair.horizontalConstraints());
283         floatAvoider.setVerticalConstraint(leftRightFloatPair.verticalConstraint());
284 
285         // Ensure that the float avoider
286         // 1. does not &quot;overflow&quot; its containing block with the current horiztonal constraints. It simply means that the float avoider&#39;s
287         // containing block could push the candidate position beyond the current float horizontally (too far to the left/right)
288         // 2. avoids floats on both sides.
</pre>
<hr />
<pre>
331         if (innerMostLeftAndRight.isEmpty())
332             return;
333 
334         auto overlappingFloatBox = [&amp;floats](auto startFloatIndex, auto floatAvoiderRect) -&gt; const FloatingState::FloatItem* {
335             for (auto i = startFloatIndex; i &lt; floats.size(); ++i) {
336                 auto&amp; floatBox = floats[i];
337                 if (floatBox.rectWithMargin().intersects(floatAvoiderRect))
338                     return &amp;floatBox;
339             }
340             return nullptr;
341         };
342 
343         auto startIndex = std::max(innerMostLeftAndRight.left.valueOr(0), innerMostLeftAndRight.right.valueOr(0)) + 1;
344         auto* intersectedFloatBox = overlappingFloatBox(startIndex, floatAvoider.rect());
345         if (!intersectedFloatBox)
346             return;
347         floatAvoider.setVerticalConstraint({ intersectedFloatBox-&gt;rectWithMargin().top() });
348     }
349 }
350 
















































351 FloatPair::FloatPair(const FloatingState::FloatList&amp; floats)
352     : m_floats(floats)
353 {
354 }
355 
356 const FloatingState::FloatItem* FloatPair::left() const
357 {
358     if (!m_floatPair.left)
359         return nullptr;
360 
361     ASSERT(m_floats[*m_floatPair.left].isLeftPositioned());
362     return &amp;m_floats[*m_floatPair.left];
363 }
364 
365 const FloatingState::FloatItem* FloatPair::right() const
366 {
367     if (!m_floatPair.right)
368         return nullptr;
369 
370     ASSERT(!m_floats[*m_floatPair.right].isLeftPositioned());
</pre>
</td>
<td>
<hr />
<pre>
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FloatingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;FloatAvoider.h&quot;
 33 #include &quot;FloatBox.h&quot;
 34 #include &quot;FormattingContext.h&quot;
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;

 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 
 39 namespace WebCore {
 40 namespace Layout {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(FloatingContext);
 43 
 44 // Finding the top/left position for a new floating(F)
 45 //  ____  ____  _____               _______
 46 // |    || L2 ||     | &lt;-----1----&gt;|       |
 47 // |    ||____||  L3 |             |   R1  |
 48 // | L1 |      |_____|             |       |
 49 // |____| &lt;-------------2---------&gt;|       |
 50 //                                 |       |
 51 //                                 |_______|
 52 //
 53 // 1. Compute the initial vertical position for (F) -&gt; (1)
 54 // 2. Find the corresponding floating pair (L3-R1)
 55 // 3. Align (F) horizontally with (L3-R1) depending whether (F) is left/right positioned
 56 // 4. Intersect (F) with (L3-R1)
</pre>
<hr />
<pre>
100     bool operator!=(const Iterator&amp;) const;
101 
102 private:
103     void set(PositionInContextRoot verticalPosition);
104 
105     const FloatingState::FloatList&amp; m_floats;
106     FloatPair m_current;
107 };
108 
109 static Iterator begin(const FloatingState::FloatList&amp; floats, PositionInContextRoot initialVerticalPosition)
110 {
111     // Start with the inner-most floating pair for the initial vertical position.
112     return Iterator(floats, initialVerticalPosition);
113 }
114 
115 static Iterator end(const FloatingState::FloatList&amp; floats)
116 {
117     return Iterator(floats, { });
118 }
119 
<span class="line-modified">120 #if ASSERT_ENABLED</span>
121 static bool areFloatsHorizontallySorted(const FloatingState&amp; floatingState)
122 {
123     auto&amp; floats = floatingState.floats();
124     auto rightEdgeOfLeftFloats = LayoutUnit::min();
125     auto leftEdgeOfRightFloats = LayoutUnit::max();
126     WTF::Optional&lt;LayoutUnit&gt; leftBottom;
127     WTF::Optional&lt;LayoutUnit&gt; rightBottom;
128 
129     for (auto&amp; floatItem : floats) {
130         if (floatItem.isLeftPositioned()) {
131             auto rightEdge = floatItem.rectWithMargin().right();
132             if (rightEdge &lt; rightEdgeOfLeftFloats) {
133                 if (leftBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *leftBottom)
134                     return false;
135             }
136             leftBottom = floatItem.rectWithMargin().bottom();
137             rightEdgeOfLeftFloats = rightEdge;
138         } else {
139             auto leftEdge = floatItem.rectWithMargin().left();
140             if (leftEdge &gt; leftEdgeOfRightFloats) {
141                 if (rightBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *rightBottom)
142                     return false;
143             }
144             rightBottom = floatItem.rectWithMargin().bottom();
145             leftEdgeOfRightFloats = leftEdge;
146         }
147     }
148     return true;
149 }
150 #endif
151 
<span class="line-modified">152 struct FloatingContext::AbsoluteCoordinateValuesForFloatAvoider {</span>
<span class="line-modified">153     Display::Box displayBox;</span>
<span class="line-added">154     LayoutPoint containingBlockTopLeft;</span>
<span class="line-added">155     HorizontalEdges containingBlockContentBox;</span>
<span class="line-added">156 };</span>
<span class="line-added">157 </span>
<span class="line-added">158 FloatingContext::FloatingContext(const Container&amp; floatingContextRoot, const FormattingContext&amp; formattingContext, FloatingState&amp; floatingState)</span>
<span class="line-added">159     : m_root(makeWeakPtr(floatingContextRoot))</span>
<span class="line-added">160     , m_formattingContext(formattingContext)</span>
<span class="line-added">161     , m_floatingState(floatingState)</span>
162 {
163 }
164 
165 Point FloatingContext::positionForFloat(const Box&amp; layoutBox) const
166 {
167     ASSERT(layoutBox.isFloatingPositioned());
168     ASSERT(areFloatsHorizontallySorted(m_floatingState));
169 
<span class="line-modified">170     if (isEmpty()) {</span>
<span class="line-modified">171         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
172 
173         auto alignWithContainingBlock = [&amp;]() -&gt; Position {
174             // If there is no floating to align with, push the box to the left/right edge of its containing block&#39;s content box.
<span class="line-modified">175             auto&amp; containingBlockGeometry = formattingContext().geometryForBox(*layoutBox.containingBlock());</span>
176 
177             if (layoutBox.isLeftFloatingPositioned())
<span class="line-modified">178                 return Position { containingBlockGeometry.contentBoxLeft() + boxGeometry.marginStart() };</span>
179 
<span class="line-modified">180             return Position { containingBlockGeometry.contentBoxRight() - boxGeometry.marginEnd() - boxGeometry.width() };</span>
181         };
182 
183         // No float box on the context yet -&gt; align it with the containing block&#39;s left/right edge.
<span class="line-modified">184         return { alignWithContainingBlock(), boxGeometry.top() };</span>
185     }
186 
187     // Find the top most position where the float box fits.
<span class="line-modified">188     auto absoluteDisplayBoxCoordinates = this-&gt;absoluteDisplayBoxCoordinates(layoutBox);</span>
<span class="line-added">189 </span>
<span class="line-added">190     Optional&lt;LayoutUnit&gt; previousFloatAbsoluteTop;</span>
<span class="line-added">191     if (!isEmpty())</span>
<span class="line-added">192         previousFloatAbsoluteTop = floatingState().floats().last().rectWithMargin().top();</span>
<span class="line-added">193     auto floatBox = FloatBox { layoutBox, absoluteDisplayBoxCoordinates.displayBox, absoluteDisplayBoxCoordinates.containingBlockTopLeft, absoluteDisplayBoxCoordinates.containingBlockContentBox, previousFloatAbsoluteTop };</span>
194     findPositionForFloatBox(floatBox);
195     return floatBox.rectInContainingBlock().topLeft();
196 }
197 
198 Optional&lt;Point&gt; FloatingContext::positionForFormattingContextRoot(const Box&amp; layoutBox) const
199 {
200     ASSERT(layoutBox.establishesBlockFormattingContext());
201     ASSERT(!layoutBox.isFloatingPositioned());
202     ASSERT(!layoutBox.hasFloatClear());
203     ASSERT(areFloatsHorizontallySorted(m_floatingState));
204 
<span class="line-modified">205     if (isEmpty())</span>
206         return { };
207 
<span class="line-modified">208     auto absoluteDisplayBoxCoordinates = this-&gt;absoluteDisplayBoxCoordinates(layoutBox);</span>
<span class="line-added">209     auto floatAvoider = FloatAvoider { layoutBox, absoluteDisplayBoxCoordinates.displayBox, absoluteDisplayBoxCoordinates.containingBlockTopLeft, absoluteDisplayBoxCoordinates.containingBlockContentBox };</span>
210     findPositionForFormattingContextRoot(floatAvoider);
211     return { floatAvoider.rectInContainingBlock().topLeft() };
212 }
213 
214 FloatingContext::ClearancePosition FloatingContext::verticalPositionWithClearance(const Box&amp; layoutBox) const
215 {
216     ASSERT(layoutBox.hasFloatClear());
217     ASSERT(layoutBox.isBlockLevelBox());
218     ASSERT(areFloatsHorizontallySorted(m_floatingState));
219 
<span class="line-modified">220     if (isEmpty())</span>
221         return { };
222 
223     auto bottom = [&amp;](Optional&lt;PositionInContextRoot&gt; floatBottom) -&gt; ClearancePosition {
224         // &#39;bottom&#39; is in the formatting root&#39;s coordinate system.
225         if (!floatBottom)
226             return { };
227 
228         // 9.5.2 Controlling flow next to floats: the &#39;clear&#39; property
229         // Then the amount of clearance is set to the greater of:
230         //
231         // 1. The amount necessary to place the border edge of the block even with the bottom outer edge of the lowest float that is to be cleared.
232         // 2. The amount necessary to place the top border edge of the block at its hypothetical position.
<span class="line-modified">233         auto rootRelativeTop = mapTopToFloatingStateRoot(layoutBox);</span>

234         auto clearance = *floatBottom - rootRelativeTop;
235         if (clearance &lt;= 0)
236             return { };
237 
238         // Clearance inhibits margin collapsing.
239         if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
240             // Does this box with clearance actually collapse its margin before with the previous inflow box&#39;s margin after?
<span class="line-modified">241             auto verticalMargin = formattingContext().geometryForBox(layoutBox).verticalMargin();</span>
242             if (verticalMargin.hasCollapsedValues() &amp;&amp; verticalMargin.collapsedValues().before) {
<span class="line-modified">243                 auto previousVerticalMargin = formattingContext().geometryForBox(*previousInFlowSibling).verticalMargin();</span>
244                 auto collapsedMargin = *verticalMargin.collapsedValues().before;
245                 auto nonCollapsedMargin = previousVerticalMargin.after() + verticalMargin.before();
246                 auto marginDifference = nonCollapsedMargin - collapsedMargin;
247                 // Move the box to the position where it would be with non-collapsed margins.
248                 rootRelativeTop += marginDifference;
249                 // Having negative clearance is also normal. It just means that the box with the non-collapsed margins is now lower than it needs to be.
250                 clearance -= marginDifference;
251             }
252         }
253         // Now adjust the box&#39;s position with the clearance.
254         rootRelativeTop += clearance;
255         ASSERT(*floatBottom == rootRelativeTop);
256 
257         // The return vertical position is in the containing block&#39;s coordinate system. Convert it to the formatting root&#39;s coordinate system if needed.
258         if (layoutBox.containingBlock() == &amp;m_floatingState.root())
259             return { Position { rootRelativeTop }, clearance };
260 
<span class="line-modified">261         auto containingBlockRootRelativeTop = mapTopToFloatingStateRoot(*layoutBox.containingBlock());</span>
262         return { Position { rootRelativeTop - containingBlockRootRelativeTop }, clearance };
263     };
264 
265     auto clear = layoutBox.style().clear();


266     if (clear == Clear::Left)
<span class="line-modified">267         return bottom(m_floatingState.leftBottom(root()));</span>
268 
269     if (clear == Clear::Right)
<span class="line-modified">270         return bottom(m_floatingState.rightBottom(root()));</span>
271 
272     if (clear == Clear::Both)
<span class="line-modified">273         return bottom(m_floatingState.bottom(root()));</span>
274 
275     ASSERT_NOT_REACHED();
276     return { };
277 }
278 
<span class="line-added">279 FloatingContext::Constraints FloatingContext::constraints(LayoutUnit logicalTop, LayoutUnit logicalBottom) const</span>
<span class="line-added">280 {</span>
<span class="line-added">281     if (isEmpty())</span>
<span class="line-added">282         return { };</span>
<span class="line-added">283 </span>
<span class="line-added">284     // 1. Convert vertical position if this floating context is inherited.</span>
<span class="line-added">285     // 2. Find the inner left/right floats at logicalTop/logicalBottom.</span>
<span class="line-added">286     // 3. Convert left/right positions back to formattingContextRoot&#39;s cooridnate system.</span>
<span class="line-added">287     auto coordinateMappingIsRequired = &amp;floatingState().root() != &amp;root();</span>
<span class="line-added">288     auto adjustedLogicalTop = logicalTop;</span>
<span class="line-added">289     LayoutSize adjustingDelta;</span>
<span class="line-added">290     if (coordinateMappingIsRequired) {</span>
<span class="line-added">291         auto adjustedPosition = mapPointFromFormattingContextRootToFloatingStateRoot({ 0, logicalTop });</span>
<span class="line-added">292         adjustedLogicalTop = adjustedPosition.y;</span>
<span class="line-added">293         adjustingDelta = { adjustedPosition.x, adjustedLogicalTop - logicalTop };</span>
<span class="line-added">294     }</span>
<span class="line-added">295     auto adjustedLogicalBottom = adjustedLogicalTop + (logicalBottom - logicalTop);</span>
<span class="line-added">296 </span>
<span class="line-added">297     Constraints constraints;</span>
<span class="line-added">298     auto&amp; floats = floatingState().floats();</span>
<span class="line-added">299     for (auto index = floats.size(); index--;) {</span>
<span class="line-added">300         auto&amp; floatItem = floats[index];</span>
<span class="line-added">301 </span>
<span class="line-added">302         if (constraints.left &amp;&amp; floatItem.isLeftPositioned())</span>
<span class="line-added">303             continue;</span>
<span class="line-added">304 </span>
<span class="line-added">305         if (constraints.right &amp;&amp; !floatItem.isLeftPositioned())</span>
<span class="line-added">306             continue;</span>
<span class="line-added">307 </span>
<span class="line-added">308         auto rect = floatItem.rectWithMargin();</span>
<span class="line-added">309         if (rect.top() &gt;= adjustedLogicalBottom || rect.bottom() &lt;= adjustedLogicalTop)</span>
<span class="line-added">310             continue;</span>
<span class="line-added">311 </span>
<span class="line-added">312         if (floatItem.isLeftPositioned())</span>
<span class="line-added">313             constraints.left = PointInContextRoot { rect.right(), rect.bottom() };</span>
<span class="line-added">314         else</span>
<span class="line-added">315             constraints.right = PointInContextRoot { rect.left(), rect.bottom() };</span>
<span class="line-added">316 </span>
<span class="line-added">317         if (constraints.left &amp;&amp; constraints.right)</span>
<span class="line-added">318             break;</span>
<span class="line-added">319     }</span>
<span class="line-added">320 </span>
<span class="line-added">321     if (coordinateMappingIsRequired) {</span>
<span class="line-added">322         if (constraints.left)</span>
<span class="line-added">323             constraints.left-&gt;move(-adjustingDelta);</span>
<span class="line-added">324 </span>
<span class="line-added">325         if (constraints.right)</span>
<span class="line-added">326             constraints.right-&gt;move(-adjustingDelta);</span>
<span class="line-added">327     }</span>
<span class="line-added">328     return constraints;</span>
<span class="line-added">329 }</span>
<span class="line-added">330 </span>
<span class="line-added">331 void FloatingContext::append(const Box&amp; floatBox)</span>
<span class="line-added">332 {</span>
<span class="line-added">333     floatingState().append(FloatingState::FloatItem { floatBox, mapToFloatingStateRoot(floatBox) });</span>
<span class="line-added">334 }</span>
<span class="line-added">335 </span>
336 static FloatPair::LeftRightIndex findAvailablePosition(FloatAvoider&amp; floatAvoider, const FloatingState::FloatList&amp; floats)
337 {
338     Optional&lt;PositionInContextRoot&gt; bottomMost;
339     Optional&lt;FloatPair::LeftRightIndex&gt; innerMostLeftAndRight;
340     auto end = Layout::end(floats);
341     for (auto iterator = begin(floats, { floatAvoider.rect().top() }); iterator != end; ++iterator) {
342         ASSERT(!(*iterator).isEmpty());
343         auto leftRightFloatPair = *iterator;
344         innerMostLeftAndRight = innerMostLeftAndRight.valueOr(*leftRightFloatPair);
345 
346         // Move the box horizontally so that it either
347         // 1. aligns with the current floating pair
348         // 2. or with the containing block&#39;s content box if there&#39;s no float to align with at this vertical position.
349         floatAvoider.setHorizontalConstraints(leftRightFloatPair.horizontalConstraints());
350         floatAvoider.setVerticalConstraint(leftRightFloatPair.verticalConstraint());
351 
352         // Ensure that the float avoider
353         // 1. does not &quot;overflow&quot; its containing block with the current horiztonal constraints. It simply means that the float avoider&#39;s
354         // containing block could push the candidate position beyond the current float horizontally (too far to the left/right)
355         // 2. avoids floats on both sides.
</pre>
<hr />
<pre>
398         if (innerMostLeftAndRight.isEmpty())
399             return;
400 
401         auto overlappingFloatBox = [&amp;floats](auto startFloatIndex, auto floatAvoiderRect) -&gt; const FloatingState::FloatItem* {
402             for (auto i = startFloatIndex; i &lt; floats.size(); ++i) {
403                 auto&amp; floatBox = floats[i];
404                 if (floatBox.rectWithMargin().intersects(floatAvoiderRect))
405                     return &amp;floatBox;
406             }
407             return nullptr;
408         };
409 
410         auto startIndex = std::max(innerMostLeftAndRight.left.valueOr(0), innerMostLeftAndRight.right.valueOr(0)) + 1;
411         auto* intersectedFloatBox = overlappingFloatBox(startIndex, floatAvoider.rect());
412         if (!intersectedFloatBox)
413             return;
414         floatAvoider.setVerticalConstraint({ intersectedFloatBox-&gt;rectWithMargin().top() });
415     }
416 }
417 
<span class="line-added">418 FloatingContext::AbsoluteCoordinateValuesForFloatAvoider FloatingContext::absoluteDisplayBoxCoordinates(const Box&amp; floatAvoider) const</span>
<span class="line-added">419 {</span>
<span class="line-added">420     auto&amp; containingBlock = *floatAvoider.containingBlock();</span>
<span class="line-added">421     auto displayBox = mapToFloatingStateRoot(floatAvoider);</span>
<span class="line-added">422 </span>
<span class="line-added">423     if (&amp;containingBlock == &amp;floatingState().root()) {</span>
<span class="line-added">424         auto containingBlockGeometry = formattingContext().geometryForBox(containingBlock, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates);</span>
<span class="line-added">425         return { displayBox, { }, {  containingBlockGeometry.contentBoxLeft(), containingBlockGeometry.contentBoxRight() } };</span>
<span class="line-added">426     }</span>
<span class="line-added">427     auto containingBlockAbsoluteDisplayBox = mapToFloatingStateRoot(containingBlock);</span>
<span class="line-added">428     auto containingBlockLeft = containingBlockAbsoluteDisplayBox.left();</span>
<span class="line-added">429     return { displayBox, containingBlockAbsoluteDisplayBox.topLeft(), { containingBlockLeft + containingBlockAbsoluteDisplayBox.contentBoxLeft(), containingBlockLeft + containingBlockAbsoluteDisplayBox.contentBoxRight() } };</span>
<span class="line-added">430 }</span>
<span class="line-added">431 </span>
<span class="line-added">432 Display::Box FloatingContext::mapToFloatingStateRoot(const Box&amp; floatBox) const</span>
<span class="line-added">433 {</span>
<span class="line-added">434     auto&amp; floatingStateRoot = floatingState().root();</span>
<span class="line-added">435     auto&amp; boxGeometry = formattingContext().geometryForBox(floatBox, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates);</span>
<span class="line-added">436     auto topLeft = boxGeometry.topLeft();</span>
<span class="line-added">437     for (auto* containingBlock = floatBox.containingBlock(); containingBlock &amp;&amp; containingBlock != &amp;floatingStateRoot; containingBlock = containingBlock-&gt;containingBlock())</span>
<span class="line-added">438         topLeft.moveBy(formattingContext().geometryForBox(*containingBlock, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).topLeft());</span>
<span class="line-added">439 </span>
<span class="line-added">440     auto mappedDisplayBox = Display::Box(boxGeometry);</span>
<span class="line-added">441     mappedDisplayBox.setTopLeft(topLeft);</span>
<span class="line-added">442     return mappedDisplayBox;</span>
<span class="line-added">443 }</span>
<span class="line-added">444 </span>
<span class="line-added">445 LayoutUnit FloatingContext::mapTopToFloatingStateRoot(const Box&amp; floatBox) const</span>
<span class="line-added">446 {</span>
<span class="line-added">447     auto&amp; floatingStateRoot = floatingState().root();</span>
<span class="line-added">448     auto top = formattingContext().geometryForBox(floatBox, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).top();</span>
<span class="line-added">449     for (auto* container = floatBox.containingBlock(); container &amp;&amp; container != &amp;floatingStateRoot; container = container-&gt;containingBlock())</span>
<span class="line-added">450         top += formattingContext().geometryForBox(*container, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).top();</span>
<span class="line-added">451     return top;</span>
<span class="line-added">452 }</span>
<span class="line-added">453 </span>
<span class="line-added">454 Point FloatingContext::mapPointFromFormattingContextRootToFloatingStateRoot(Point position) const</span>
<span class="line-added">455 {</span>
<span class="line-added">456     auto&amp; from = root();</span>
<span class="line-added">457     auto&amp; to = floatingState().root();</span>
<span class="line-added">458     if (&amp;from == &amp;to)</span>
<span class="line-added">459         return position;</span>
<span class="line-added">460     auto mappedPosition = position;</span>
<span class="line-added">461     for (auto* container = &amp;from; container &amp;&amp; container != &amp;to; container = container-&gt;containingBlock())</span>
<span class="line-added">462         mappedPosition.moveBy(formattingContext().geometryForBox(*container, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).topLeft());</span>
<span class="line-added">463     return mappedPosition;</span>
<span class="line-added">464 }</span>
<span class="line-added">465 </span>
466 FloatPair::FloatPair(const FloatingState::FloatList&amp; floats)
467     : m_floats(floats)
468 {
469 }
470 
471 const FloatingState::FloatItem* FloatPair::left() const
472 {
473     if (!m_floatPair.left)
474         return nullptr;
475 
476     ASSERT(m_floats[*m_floatPair.left].isLeftPositioned());
477     return &amp;m_floats[*m_floatPair.left];
478 }
479 
480 const FloatingState::FloatItem* FloatPair::right() const
481 {
482     if (!m_floatPair.right)
483         return nullptr;
484 
485     ASSERT(!m_floats[*m_floatPair.right].isLeftPositioned());
</pre>
</td>
</tr>
</table>
<center><a href="FloatBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
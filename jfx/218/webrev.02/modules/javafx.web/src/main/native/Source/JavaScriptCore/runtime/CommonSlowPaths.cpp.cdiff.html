<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommonIdentifiers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CommonSlowPaths.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 44,16 ***</span>
  #include &quot;ICStats.h&quot;
  #include &quot;Interpreter.h&quot;
  #include &quot;IteratorOperations.h&quot;
  #include &quot;JIT.h&quot;
  #include &quot;JSArrayInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCJSValue.h&quot;
<span class="line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSGlobalObjectFunctions.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSPropertyNameEnumerator.h&quot;
  #include &quot;JSString.h&quot;
  #include &quot;JSWithScope.h&quot;
  #include &quot;LLIntCommon.h&quot;
  #include &quot;LLIntExceptions.h&quot;
<span class="line-new-header">--- 44,19 ---</span>
  #include &quot;ICStats.h&quot;
  #include &quot;Interpreter.h&quot;
  #include &quot;IteratorOperations.h&quot;
  #include &quot;JIT.h&quot;
  #include &quot;JSArrayInlines.h&quot;
<span class="line-added">+ #include &quot;JSAsyncGenerator.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCJSValue.h&quot;
  #include &quot;JSGlobalObjectFunctions.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">+ #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">+ #include &quot;JSInternalPromiseConstructor.h&quot;</span>
  #include &quot;JSLexicalEnvironment.h&quot;
<span class="line-added">+ #include &quot;JSPromiseConstructor.h&quot;</span>
  #include &quot;JSPropertyNameEnumerator.h&quot;
  #include &quot;JSString.h&quot;
  #include &quot;JSWithScope.h&quot;
  #include &quot;LLIntCommon.h&quot;
  #include &quot;LLIntExceptions.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,51 ***</span>
  #include &lt;wtf/Variant.h&gt;
  
  namespace JSC {
  
  #define BEGIN_NO_SET_PC() \
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();      \</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec); \</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm); \
      UNUSED_PARAM(throwScope)
  
  #ifndef NDEBUG
  #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">!         exec-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #else
  #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         exec-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #endif
  
<span class="line-modified">! #define RETURN_TO_THROW(exec, pc)   pc = LLInt::returnToThrow(exec)</span>
  
  #define BEGIN()                           \
      BEGIN_NO_SET_PC();                    \
      SET_PC_FOR_STUBS()
  
<span class="line-modified">! #define GET(operand) (exec-&gt;uncheckedR(operand.offset()))</span>
<span class="line-modified">! #define GET_C(operand) (exec-&gt;r(operand.offset()))</span>
  
  #define RETURN_TWO(first, second) do {       \
          return encodeResult(first, second);        \
      } while (false)
  
<span class="line-modified">! #define END_IMPL() RETURN_TWO(pc, exec)</span>
  
  #define THROW(exceptionToThrow) do {                        \
<span class="line-modified">!         throwException(exec, throwScope, exceptionToThrow); \</span>
<span class="line-modified">!         RETURN_TO_THROW(exec, pc);                          \</span>
          END_IMPL();                                         \
      } while (false)
  
  #define CHECK_EXCEPTION() do {                    \
<span class="line-modified">!         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;CommonSlowPaths&quot;, pc);   \</span>
          if (UNLIKELY(throwScope.exception())) {   \
<span class="line-modified">!             RETURN_TO_THROW(exec, pc);            \</span>
              END_IMPL();                           \
          }                                         \
      } while (false)
  
  #define END() do {                        \
<span class="line-new-header">--- 72,53 ---</span>
  #include &lt;wtf/Variant.h&gt;
  
  namespace JSC {
  
  #define BEGIN_NO_SET_PC() \
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock(); \</span>
<span class="line-modified">!     JSGlobalObject* globalObject = codeBlock-&gt;globalObject(); \</span>
<span class="line-added">+     VM&amp; vm = codeBlock-&gt;vm(); \</span>
<span class="line-added">+     SlowPathFrameTracer tracer(vm, callFrame); \</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm); \
      UNUSED_PARAM(throwScope)
  
  #ifndef NDEBUG
  #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         codeBlock-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">!         callFrame-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #else
  #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         callFrame-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #endif
  
<span class="line-modified">! #define RETURN_TO_THROW(pc)   pc = LLInt::returnToThrow(vm)</span>
  
  #define BEGIN()                           \
      BEGIN_NO_SET_PC();                    \
      SET_PC_FOR_STUBS()
  
<span class="line-modified">! #define GET(operand) (callFrame-&gt;uncheckedR(operand))</span>
<span class="line-modified">! #define GET_C(operand) (callFrame-&gt;r(operand))</span>
  
  #define RETURN_TWO(first, second) do {       \
          return encodeResult(first, second);        \
      } while (false)
  
<span class="line-modified">! #define END_IMPL() RETURN_TWO(pc, callFrame)</span>
  
  #define THROW(exceptionToThrow) do {                        \
<span class="line-modified">!         throwException(globalObject, throwScope, exceptionToThrow); \</span>
<span class="line-modified">!         RETURN_TO_THROW(pc);                          \</span>
          END_IMPL();                                         \
      } while (false)
  
  #define CHECK_EXCEPTION() do {                    \
<span class="line-modified">!         doExceptionFuzzingIfEnabled(globalObject, throwScope, &quot;CommonSlowPaths&quot;, pc);   \</span>
          if (UNLIKELY(throwScope.exception())) {   \
<span class="line-modified">!             RETURN_TO_THROW(pc);            \</span>
              END_IMPL();                           \
          }                                         \
      } while (false)
  
  #define END() do {                        \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,11 ***</span>
          bool bCondition = (condition);                         \
          CHECK_EXCEPTION();                                  \
          if (bCondition)                                        \
              pc = bytecode.m_targetLabel \
                  ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
<span class="line-modified">!                 : exec-&gt;codeBlock()-&gt;outOfLineJumpTarget(pc);                              \</span>
          else                                                      \
              pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
          END_IMPL();                                         \
      } while (false)
  
<span class="line-new-header">--- 130,11 ---</span>
          bool bCondition = (condition);                         \
          CHECK_EXCEPTION();                                  \
          if (bCondition)                                        \
              pc = bytecode.m_targetLabel \
                  ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
<span class="line-modified">!                 : codeBlock-&gt;outOfLineJumpTarget(pc);                              \</span>
          else                                                      \
              pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
          END_IMPL();                                         \
      } while (false)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,139 ***</span>
  
  #define RETURN_PROFILED(value__) \
      RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
  
  #define PROFILE_VALUE(value) do { \
<span class="line-modified">!         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
      } while (false)
  
<span class="line-modified">! #define CALL_END_IMPL(exec, callTarget, callTargetTag) \</span>
<span class="line-removed">-     RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define CALL_CHECK_EXCEPTION(exec, pc) do {                          \</span>
<span class="line-removed">-         ExecState* cceExec = (exec);                                 \</span>
<span class="line-removed">-         Instruction* ccePC = (pc);                                   \</span>
<span class="line-removed">-         if (UNLIKELY(throwScope.exception()))                        \</span>
<span class="line-removed">-             CALL_END_IMPL(cceExec, LLInt::callToThrow(cceExec), ExceptionHandlerPtrTag); \</span>
<span class="line-removed">-     } while (false)</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void throwArityCheckStackOverflowError(ExecState* exec, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     JSObject* error = createStackOverflowError(exec);</span>
<span class="line-modified">!     throwException(exec, scope, error);</span>
  #if LLINT_TRACING
      if (UNLIKELY(Options::traceLLIntSlowPath()))
          dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
  #endif
  }
  
  SLOW_PATH_DECL(slow_path_call_arityCheck)
  {
      BEGIN();
<span class="line-modified">!     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);</span>
      if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified">!         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);</span>
<span class="line-modified">!         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified">!         NativeCallFrameTracer tracer(vm, exec);</span>
          ErrorHandlingScope errorScope(vm);
          throwScope.release();
<span class="line-modified">!         throwArityCheckStackOverflowError(exec, throwScope);</span>
<span class="line-modified">!         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);</span>
      }
      RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
  }
  
  SLOW_PATH_DECL(slow_path_construct_arityCheck)
  {
      BEGIN();
<span class="line-modified">!     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);</span>
      if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified">!         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);</span>
<span class="line-modified">!         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified">!         NativeCallFrameTracer tracer(vm, exec);</span>
          ErrorHandlingScope errorScope(vm);
<span class="line-modified">!         throwArityCheckStackOverflowError(exec, throwScope);</span>
<span class="line-modified">!         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);</span>
      }
      RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
  }
  
  SLOW_PATH_DECL(slow_path_create_direct_arguments)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
<span class="line-modified">!     RETURN(DirectArguments::createByCopying(exec));</span>
  }
  
  SLOW_PATH_DECL(slow_path_create_scoped_arguments)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
      JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
      ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
<span class="line-modified">!     RETURN(ScopedArguments::createByCopying(exec, table, scope));</span>
  }
  
  SLOW_PATH_DECL(slow_path_create_cloned_arguments)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
<span class="line-modified">!     RETURN(ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned));</span>
  }
  
  SLOW_PATH_DECL(slow_path_create_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
      JSObject* result;
      JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
<span class="line-modified">!     if (constructorAsObject-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructorAsObject)-&gt;canUseAllocationProfile()) {</span>
<span class="line-modified">!         JSFunction* constructor = jsCast&lt;JSFunction*&gt;(constructorAsObject);</span>
<span class="line-modified">!         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(exec).m_cachedCallee;</span>
          if (!cachedCallee)
<span class="line-modified">!             cachedCallee.set(vm, exec-&gt;codeBlock(), constructor);</span>
          else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
              cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
  
          size_t inlineCapacity = bytecode.m_inlineCapacity;
<span class="line-modified">!         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity)-&gt;objectAllocationProfile();</span>
          throwScope.releaseAssertNoException();
          Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified">!         result = constructEmptyObject(exec, structure);</span>
          if (structure-&gt;hasPolyProto()) {
              JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified">!             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, exec));</span>
              result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
              prototype-&gt;didBecomePrototype();
              ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
          }
      } else {
          // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
<span class="line-modified">!         JSValue proto = constructorAsObject-&gt;get(exec, vm.propertyNames-&gt;prototype);</span>
          CHECK_EXCEPTION();
          if (proto.isObject())
<span class="line-modified">!             result = constructEmptyObject(exec, asObject(proto));</span>
          else
<span class="line-modified">!             result = constructEmptyObject(exec);</span>
      }
      RETURN(result);
  }
  
  SLOW_PATH_DECL(slow_path_to_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
      JSValue v1 = GET(bytecode.m_srcDst).jsValue();
      if (v1.isCell()) {
          StructureID myStructureID = v1.asCell()-&gt;structureID();
          StructureID otherStructureID = metadata.m_cachedStructureID;
          if (myStructureID != otherStructureID) {
              if (otherStructureID)
                  metadata.m_toThisStatus = ToThisConflicted;
              metadata.m_cachedStructureID = myStructureID;
<span class="line-modified">!             vm.heap.writeBarrier(exec-&gt;codeBlock(), vm.getStructure(myStructureID));</span>
          }
      } else {
          metadata.m_toThisStatus = ToThisConflicted;
          metadata.m_cachedStructureID = 0;
      }
<span class="line-new-header">--- 153,224 ---</span>
  
  #define RETURN_PROFILED(value__) \
      RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
  
  #define PROFILE_VALUE(value) do { \
<span class="line-modified">!         bytecode.metadata(codeBlock).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
      } while (false)
  
<span class="line-modified">! static void throwArityCheckStackOverflowError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     JSObject* error = createStackOverflowError(globalObject);</span>
<span class="line-modified">!     throwException(globalObject, scope, error);</span>
  #if LLINT_TRACING
      if (UNLIKELY(Options::traceLLIntSlowPath()))
          dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
  #endif
  }
  
  SLOW_PATH_DECL(slow_path_call_arityCheck)
  {
      BEGIN();
<span class="line-modified">!     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForCall);</span>
      if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified">!         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForCall);</span>
<span class="line-modified">!         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified">!         SlowPathFrameTracer tracer(vm, callFrame);</span>
          ErrorHandlingScope errorScope(vm);
          throwScope.release();
<span class="line-modified">!         throwArityCheckStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified">!         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);</span>
      }
      RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
  }
  
  SLOW_PATH_DECL(slow_path_construct_arityCheck)
  {
      BEGIN();
<span class="line-modified">!     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForConstruct);</span>
      if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified">!         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForConstruct);</span>
<span class="line-modified">!         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified">!         SlowPathFrameTracer tracer(vm, callFrame);</span>
          ErrorHandlingScope errorScope(vm);
<span class="line-modified">!         throwArityCheckStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified">!         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);</span>
      }
      RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
  }
  
  SLOW_PATH_DECL(slow_path_create_direct_arguments)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
<span class="line-modified">!     RETURN(DirectArguments::createByCopying(globalObject, callFrame));</span>
  }
  
  SLOW_PATH_DECL(slow_path_create_scoped_arguments)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
      JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
      ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
<span class="line-modified">!     RETURN(ScopedArguments::createByCopying(globalObject, callFrame, table, scope));</span>
  }
  
  SLOW_PATH_DECL(slow_path_create_cloned_arguments)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
<span class="line-modified">!     RETURN(ClonedArguments::createWithMachineFrame(globalObject, callFrame, ArgumentsMode::Cloned));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_create_arguments_butterfly)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpCreateArgumentsButterfly&gt;();</span>
<span class="line-added">+     int32_t argumentCount = callFrame-&gt;argumentCount();</span>
<span class="line-added">+     JSImmutableButterfly* butterfly = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), argumentCount);</span>
<span class="line-added">+     if (!butterfly)</span>
<span class="line-added">+         THROW(createOutOfMemoryError(globalObject));</span>
<span class="line-added">+     for (int32_t index = 0; index &lt; argumentCount; ++index)</span>
<span class="line-added">+         butterfly-&gt;setIndex(vm, index, callFrame-&gt;uncheckedArgument(index));</span>
<span class="line-added">+     RETURN(butterfly);</span>
  }
  
  SLOW_PATH_DECL(slow_path_create_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
      JSObject* result;
      JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
<span class="line-modified">!     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-modified">!     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-modified">!         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
          if (!cachedCallee)
<span class="line-modified">!             cachedCallee.set(vm, codeBlock, constructor);</span>
          else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
              cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
  
          size_t inlineCapacity = bytecode.m_inlineCapacity;
<span class="line-modified">!         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity)-&gt;objectAllocationProfile();</span>
          throwScope.releaseAssertNoException();
          Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified">!         result = constructEmptyObject(vm, structure);</span>
          if (structure-&gt;hasPolyProto()) {
              JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified">!             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, globalObject));</span>
              result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
              prototype-&gt;didBecomePrototype();
              ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
          }
      } else {
          // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
<span class="line-modified">!         JSValue proto = constructorAsObject-&gt;get(globalObject, vm.propertyNames-&gt;prototype);</span>
          CHECK_EXCEPTION();
          if (proto.isObject())
<span class="line-modified">!             result = constructEmptyObject(globalObject, asObject(proto));</span>
          else
<span class="line-modified">!             result = constructEmptyObject(globalObject);</span>
      }
      RETURN(result);
  }
  
<span class="line-added">+ SLOW_PATH_DECL(slow_path_create_promise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpCreatePromise&gt;();</span>
<span class="line-added">+     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSPromise* result = nullptr;</span>
<span class="line-added">+     if (bytecode.m_isInternalPromise) {</span>
<span class="line-added">+         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;internalPromiseConstructor(), constructorAsObject, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added">+         CHECK_EXCEPTION();</span>
<span class="line-added">+         result = JSInternalPromise::create(vm, structure);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;promiseConstructor(), constructorAsObject, globalObject-&gt;promiseStructure());</span>
<span class="line-added">+         CHECK_EXCEPTION();</span>
<span class="line-added">+         result = JSPromise::create(vm, structure);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-added">+     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-added">+         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
<span class="line-added">+         if (!cachedCallee)</span>
<span class="line-added">+             cachedCallee.set(vm, codeBlock, constructor);</span>
<span class="line-added">+         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)</span>
<span class="line-added">+             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     RETURN(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_new_promise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpNewPromise&gt;();</span>
<span class="line-added">+     JSPromise* result = nullptr;</span>
<span class="line-added">+     if (bytecode.m_isInternalPromise)</span>
<span class="line-added">+         result = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added">+     else</span>
<span class="line-added">+         result = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
<span class="line-added">+     RETURN(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename JSClass, typename Bytecode&gt;</span>
<span class="line-added">+ static JSClass* createInternalFieldObject(JSGlobalObject* globalObject, VM&amp; vm, CodeBlock* codeBlock, const Bytecode&amp; bytecode, JSObject* constructorAsObject, Structure* baseStructure)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructorAsObject, baseStructure);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added">+     JSClass* result = JSClass::create(vm, structure);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-added">+     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-added">+         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
<span class="line-added">+         if (!cachedCallee)</span>
<span class="line-added">+             cachedCallee.set(vm, codeBlock, constructor);</span>
<span class="line-added">+         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)</span>
<span class="line-added">+             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     RELEASE_AND_RETURN(scope, result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_create_generator)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpCreateGenerator&gt;();</span>
<span class="line-added">+     RETURN(createInternalFieldObject&lt;JSGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;generatorStructure()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_create_async_generator)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpCreateAsyncGenerator&gt;();</span>
<span class="line-added">+     RETURN(createInternalFieldObject&lt;JSAsyncGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;asyncGeneratorStructure()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_new_generator)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpNewGenerator&gt;();</span>
<span class="line-added">+     JSGenerator* result = JSGenerator::create(vm, globalObject-&gt;generatorStructure());</span>
<span class="line-added">+     RETURN(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  SLOW_PATH_DECL(slow_path_to_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
      JSValue v1 = GET(bytecode.m_srcDst).jsValue();
      if (v1.isCell()) {
          StructureID myStructureID = v1.asCell()-&gt;structureID();
          StructureID otherStructureID = metadata.m_cachedStructureID;
          if (myStructureID != otherStructureID) {
              if (otherStructureID)
                  metadata.m_toThisStatus = ToThisConflicted;
              metadata.m_cachedStructureID = myStructureID;
<span class="line-modified">!             vm.heap.writeBarrier(codeBlock, vm.getStructure(myStructureID));</span>
          }
      } else {
          metadata.m_toThisStatus = ToThisConflicted;
          metadata.m_cachedStructureID = 0;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,121 ***</span>
      // just returns the input to to_this if the structure check succeeds. If the structure
      // check succeeds, doing value profiling here is equivalent to doing it with a potentially
      // different object that still has the same structure on the fast path since it&#39;ll produce
      // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
      // fast path.
<span class="line-modified">!     auto value = v1.toThis(exec, exec-&gt;codeBlock()-&gt;isStrictMode() ? StrictMode : NotStrictMode);</span>
      RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
  }
  
  SLOW_PATH_DECL(slow_path_throw_tdz_error)
  {
      BEGIN();
<span class="line-modified">!     THROW(createTDZError(exec));</span>
  }
  
  SLOW_PATH_DECL(slow_path_check_tdz)
  {
      BEGIN();
<span class="line-modified">!     THROW(createTDZError(exec));</span>
  }
  
  SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
  {
      BEGIN();
<span class="line-modified">!     THROW(createTypeError(exec, ReadonlyPropertyWriteError));</span>
  }
  
  SLOW_PATH_DECL(slow_path_not)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNot&gt;();
<span class="line-modified">!     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(exec)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_eq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_neq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(!JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_stricteq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_nstricteq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(!JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_less)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpLess&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLess&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_lesseq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLessEq&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_greater)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLess&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_greatereq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLessEq&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_inc)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpInc&gt;();
<span class="line-modified">!     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) + 1), { });</span>
  }
  
  SLOW_PATH_DECL(slow_path_dec)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDec&gt;();
<span class="line-modified">!     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) - 1), { });</span>
  }
  
  SLOW_PATH_DECL(slow_path_to_string)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToString&gt;();
<span class="line-modified">!     RETURN(GET_C(bytecode.m_operand).jsValue().toString(exec));</span>
  }
  
  #if ENABLE(JIT)
  static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
  {
<span class="line-modified">!     ArithProfile&amp; profile = metadata.m_arithProfile;</span>
<span class="line-modified">!     profile.observeLHS(operand);</span>
      ASSERT(result.isNumber() || result.isBigInt());
      if (result.isNumber()) {
          if (!result.isInt32()) {
              if (operand.isInt32())
                  profile.setObservedInt32Overflow();
<span class="line-new-header">--- 378,137 ---</span>
      // just returns the input to to_this if the structure check succeeds. If the structure
      // check succeeds, doing value profiling here is equivalent to doing it with a potentially
      // different object that still has the same structure on the fast path since it&#39;ll produce
      // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
      // fast path.
<span class="line-modified">!     auto value = v1.toThis(globalObject, codeBlock-&gt;isStrictMode() ? StrictMode : NotStrictMode);</span>
      RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
  }
  
  SLOW_PATH_DECL(slow_path_throw_tdz_error)
  {
      BEGIN();
<span class="line-modified">!     THROW(createTDZError(globalObject));</span>
  }
  
  SLOW_PATH_DECL(slow_path_check_tdz)
  {
      BEGIN();
<span class="line-modified">!     THROW(createTDZError(globalObject));</span>
  }
  
  SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
  {
      BEGIN();
<span class="line-modified">!     THROW(createTypeError(globalObject, ReadonlyPropertyWriteError));</span>
  }
  
  SLOW_PATH_DECL(slow_path_not)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNot&gt;();
<span class="line-modified">!     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(globalObject)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_eq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_neq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(!JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_stricteq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_nstricteq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(!JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_less)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpLess&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLess&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_lesseq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLessEq&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_greater)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLess&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_greatereq)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsLessEq&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_inc)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpInc&gt;();
<span class="line-modified">!     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();</span>
<span class="line-added">+     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added">+     CHECK_EXCEPTION();</span>
<span class="line-added">+     JSValue result;</span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added">+         result = JSBigInt::inc(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));</span>
<span class="line-added">+     else</span>
<span class="line-added">+         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) + 1);</span>
<span class="line-added">+     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });</span>
  }
  
  SLOW_PATH_DECL(slow_path_dec)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDec&gt;();
<span class="line-modified">!     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();</span>
<span class="line-added">+     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added">+     CHECK_EXCEPTION();</span>
<span class="line-added">+     JSValue result;</span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added">+         result = JSBigInt::dec(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));</span>
<span class="line-added">+     else</span>
<span class="line-added">+         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) - 1);</span>
<span class="line-added">+     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });</span>
  }
  
  SLOW_PATH_DECL(slow_path_to_string)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToString&gt;();
<span class="line-modified">!     RETURN(GET_C(bytecode.m_operand).jsValue().toString(globalObject));</span>
  }
  
  #if ENABLE(JIT)
  static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
  {
<span class="line-modified">!     UnaryArithProfile&amp; profile = metadata.m_arithProfile;</span>
<span class="line-modified">!     profile.observeArg(operand);</span>
      ASSERT(result.isNumber() || result.isBigInt());
      if (result.isNumber()) {
          if (!result.isInt32()) {
              if (operand.isInt32())
                  profile.setObservedInt32Overflow();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,34 ***</span>
  
  SLOW_PATH_DECL(slow_path_negate)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
      JSValue operand = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified">!     JSValue primValue = operand.toPrimitive(exec, PreferNumber);</span>
      CHECK_EXCEPTION();
  
      if (primValue.isBigInt()) {
          JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
          RETURN_WITH_PROFILING(result, {
              updateArithProfileForUnaryArithOp(metadata, result, operand);
          });
      }
  
<span class="line-modified">!     JSValue result = jsNumber(-primValue.toNumber(exec));</span>
      CHECK_EXCEPTION();
      RETURN_WITH_PROFILING(result, {
          updateArithProfileForUnaryArithOp(metadata, result, operand);
      });
  }
  
  #if ENABLE(DFG_JIT)
<span class="line-modified">! static void updateArithProfileForBinaryArithOp(ExecState* exec, const Instruction* pc, JSValue result, JSValue left, JSValue right)</span>
  {
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     ArithProfile&amp; profile = *codeBlock-&gt;arithProfileForPC(pc);</span>
  
      if (result.isNumber()) {
          if (!result.isInt32()) {
              if (left.isInt32() &amp;&amp; right.isInt32())
                  profile.setObservedInt32Overflow();
<span class="line-new-header">--- 539,33 ---</span>
  
  SLOW_PATH_DECL(slow_path_negate)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
      JSValue operand = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified">!     JSValue primValue = operand.toPrimitive(globalObject, PreferNumber);</span>
      CHECK_EXCEPTION();
  
      if (primValue.isBigInt()) {
          JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
          RETURN_WITH_PROFILING(result, {
              updateArithProfileForUnaryArithOp(metadata, result, operand);
          });
      }
  
<span class="line-modified">!     JSValue result = jsNumber(-primValue.toNumber(globalObject));</span>
      CHECK_EXCEPTION();
      RETURN_WITH_PROFILING(result, {
          updateArithProfileForUnaryArithOp(metadata, result, operand);
      });
  }
  
  #if ENABLE(DFG_JIT)
<span class="line-modified">! static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock* codeBlock, const Instruction* pc, JSValue result, JSValue left, JSValue right)</span>
  {
<span class="line-modified">!     BinaryArithProfile&amp; profile = *codeBlock-&gt;binaryArithProfileForPC(pc);</span>
  
      if (result.isNumber()) {
          if (!result.isInt32()) {
              if (left.isInt32() &amp;&amp; right.isInt32())
                  profile.setObservedInt32Overflow();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 484,149 ***</span>
          profile.setObservedBigInt();
      else
          profile.setObservedNonNumeric();
  }
  #else
<span class="line-modified">! static void updateArithProfileForBinaryArithOp(ExecState*, const Instruction*, JSValue, JSValue, JSValue) { }</span>
  #endif
  
  SLOW_PATH_DECL(slow_path_to_number)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
      JSValue argument = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified">!     JSValue result = jsNumber(argument.toNumber(exec));</span>
      RETURN_PROFILED(result);
  }
  
  SLOW_PATH_DECL(slow_path_to_object)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
      JSValue argument = GET_C(bytecode.m_operand).jsValue();
      if (UNLIKELY(argument.isUndefinedOrNull())) {
<span class="line-modified">!         const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_message);</span>
          if (!ident.isEmpty())
<span class="line-modified">!             THROW(createTypeError(exec, ident.impl()));</span>
      }
<span class="line-modified">!     JSObject* result = argument.toObject(exec);</span>
      RETURN_PROFILED(result);
  }
  
  SLOW_PATH_DECL(slow_path_add)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
      JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
      JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
  
<span class="line-modified">!     ArithProfile&amp; arithProfile = *exec-&gt;codeBlock()-&gt;arithProfileForPC(pc);</span>
      arithProfile.observeLHSAndRHS(v1, v2);
  
<span class="line-modified">!     JSValue result = jsAdd(exec, v1, v2);</span>
  
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(exec, pc, result, v1, v2);</span>
      });
  }
  
  // The following arithmetic and bitwise operations need to be sure to run
  // toNumber() on their operands in order.  (A call to toNumber() is idempotent
<span class="line-modified">! // if an exception is already set on the ExecState.)</span>
  
  SLOW_PATH_DECL(slow_path_mul)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpMul&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     JSValue result = jsMul(exec, left, right);</span>
      CHECK_EXCEPTION();
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
      });
  }
  
  SLOW_PATH_DECL(slow_path_sub)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSub&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(exec);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::sub(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_WITH_PROFILING(result, {
<span class="line-modified">!                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
              });
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));</span>
      }
  
      JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
      });
  }
  
  SLOW_PATH_DECL(slow_path_div)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(exec);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::divide(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_WITH_PROFILING(result, {
<span class="line-modified">!                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
              });
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in division.&quot;));</span>
      }
  
      double a = WTF::get&lt;double&gt;(leftNumeric);
      double b = WTF::get&lt;double&gt;(rightNumeric);
      JSValue result = jsNumber(a / b);
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
      });
  }
  
  SLOW_PATH_DECL(slow_path_mod)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpMod&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(exec);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::remainder(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));</span>
      }
  
      double a = WTF::get&lt;double&gt;(leftNumeric);
      double b = WTF::get&lt;double&gt;(rightNumeric);
      RETURN(jsNumber(jsMod(a, b)));
<span class="line-new-header">--- 589,164 ---</span>
          profile.setObservedBigInt();
      else
          profile.setObservedNonNumeric();
  }
  #else
<span class="line-modified">! static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock*, const Instruction*, JSValue, JSValue, JSValue) { }</span>
  #endif
  
  SLOW_PATH_DECL(slow_path_to_number)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
      JSValue argument = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified">!     JSValue result = jsNumber(argument.toNumber(globalObject));</span>
<span class="line-added">+     RETURN_PROFILED(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_to_numeric)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpToNumeric&gt;();</span>
<span class="line-added">+     JSValue argument = GET_C(bytecode.m_operand).jsValue();</span>
<span class="line-added">+     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added">+     CHECK_EXCEPTION();</span>
<span class="line-added">+     JSValue result;</span>
<span class="line-added">+     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added">+         result = WTF::get&lt;JSBigInt*&gt;(resultVariant);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         result = jsNumber(WTF::get&lt;double&gt;(resultVariant));</span>
      RETURN_PROFILED(result);
  }
  
  SLOW_PATH_DECL(slow_path_to_object)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
      JSValue argument = GET_C(bytecode.m_operand).jsValue();
      if (UNLIKELY(argument.isUndefinedOrNull())) {
<span class="line-modified">!         const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_message);</span>
          if (!ident.isEmpty())
<span class="line-modified">!             THROW(createTypeError(globalObject, ident.impl()));</span>
      }
<span class="line-modified">!     JSObject* result = argument.toObject(globalObject);</span>
      RETURN_PROFILED(result);
  }
  
  SLOW_PATH_DECL(slow_path_add)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
      JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
      JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
  
<span class="line-modified">!     BinaryArithProfile&amp; arithProfile = *codeBlock-&gt;binaryArithProfileForPC(pc);</span>
      arithProfile.observeLHSAndRHS(v1, v2);
  
<span class="line-modified">!     JSValue result = jsAdd(globalObject, v1, v2);</span>
  
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, v1, v2);</span>
      });
  }
  
  // The following arithmetic and bitwise operations need to be sure to run
  // toNumber() on their operands in order.  (A call to toNumber() is idempotent
<span class="line-modified">! // if an exception is already set on the CallFrame.)</span>
  
  SLOW_PATH_DECL(slow_path_mul)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpMul&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     JSValue result = jsMul(globalObject, left, right);</span>
      CHECK_EXCEPTION();
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
      });
  }
  
  SLOW_PATH_DECL(slow_path_sub)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSub&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::sub(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_WITH_PROFILING(result, {
<span class="line-modified">!                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
              });
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));</span>
      }
  
      JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
      });
  }
  
  SLOW_PATH_DECL(slow_path_div)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::divide(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_WITH_PROFILING(result, {
<span class="line-modified">!                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
              });
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in division.&quot;));</span>
      }
  
      double a = WTF::get&lt;double&gt;(leftNumeric);
      double b = WTF::get&lt;double&gt;(rightNumeric);
      JSValue result = jsNumber(a / b);
      RETURN_WITH_PROFILING(result, {
<span class="line-modified">!         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
      });
  }
  
  SLOW_PATH_DECL(slow_path_mod)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpMod&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::remainder(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));</span>
      }
  
      double a = WTF::get&lt;double&gt;(leftNumeric);
      double b = WTF::get&lt;double&gt;(rightNumeric);
      RETURN(jsNumber(jsMod(a, b)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 636,23 ***</span>
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPow&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(exec);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::exponentiate(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));</span>
      }
  
      double a = WTF::get&lt;double&gt;(leftNumeric);
      double b = WTF::get&lt;double&gt;(rightNumeric);
  
<span class="line-new-header">--- 756,23 ---</span>
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPow&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toNumeric(globalObject);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::exponentiate(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));</span>
      }
  
      double a = WTF::get&lt;double&gt;(leftNumeric);
      double b = WTF::get&lt;double&gt;(rightNumeric);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 663,23 ***</span>
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::leftShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
  }
  
<span class="line-new-header">--- 783,23 ---</span>
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::leftShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,56 ***</span>
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::signedRightShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
<span class="line-modified">!             RETURN(result);</span>
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;));</span>
      }
  
<span class="line-modified">!     RETURN(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_urshift)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
<span class="line-modified">!     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(exec);</span>
      if (UNLIKELY(throwScope.exception()))
          RETURN(JSValue());
<span class="line-modified">!     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(exec);</span>
      RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
  }
  
  SLOW_PATH_DECL(slow_path_unsigned)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">!     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(exec);</span>
      RETURN(jsNumber(a));
  }
  
  SLOW_PATH_DECL(slow_path_bitnot)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified">!     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
<span class="line-modified">!         JSBigInt* result = JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric));</span>
          CHECK_EXCEPTION();
          RETURN_PROFILED(result);
      }
  
      RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
<span class="line-new-header">--- 807,56 ---</span>
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
      JSValue left = GET_C(bytecode.m_lhs).jsValue();
      JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified">!     auto leftNumeric = left.toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = right.toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::signedRightShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
<span class="line-modified">!             RETURN_PROFILED(result);</span>
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;_s));</span>
      }
  
<span class="line-modified">!     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_urshift)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
<span class="line-modified">!     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(globalObject);</span>
      if (UNLIKELY(throwScope.exception()))
          RETURN(JSValue());
<span class="line-modified">!     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(globalObject);</span>
      RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
  }
  
  SLOW_PATH_DECL(slow_path_unsigned)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">!     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(globalObject);</span>
      RETURN(jsNumber(a));
  }
  
  SLOW_PATH_DECL(slow_path_bitnot)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified">!     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
  
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
<span class="line-modified">!         JSBigInt* result = JSBigInt::bitwiseNot(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric));</span>
          CHECK_EXCEPTION();
          RETURN_PROFILED(result);
      }
  
      RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 744,81 ***</span>
  
  SLOW_PATH_DECL(slow_path_bitand)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
<span class="line-modified">!     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
  }
  
  SLOW_PATH_DECL(slow_path_bitor)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
<span class="line-modified">!     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::bitwiseOr(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
  }
  
  SLOW_PATH_DECL(slow_path_bitxor)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
<span class="line-modified">!     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
      CHECK_EXCEPTION();
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::bitwiseXor(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
  }
  
  SLOW_PATH_DECL(slow_path_typeof)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified">!     RETURN(jsTypeStringForValue(exec, GET_C(bytecode.m_value).jsValue()));</span>
  }
  
  SLOW_PATH_DECL(slow_path_is_object_or_null)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsIsObjectTypeOrNull(exec, GET_C(bytecode.m_operand).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_is_function)
  {
      BEGIN();
<span class="line-new-header">--- 864,81 ---</span>
  
  SLOW_PATH_DECL(slow_path_bitand)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
<span class="line-modified">!     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::bitwiseAnd(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
  }
  
  SLOW_PATH_DECL(slow_path_bitor)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
<span class="line-modified">!     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::bitwiseOr(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
  }
  
  SLOW_PATH_DECL(slow_path_bitxor)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
<span class="line-modified">!     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
      CHECK_EXCEPTION();
      if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
          if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified">!             JSBigInt* result = JSBigInt::bitwiseXor(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
              CHECK_EXCEPTION();
              RETURN_PROFILED(result);
          }
  
<span class="line-modified">!         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));</span>
      }
  
      RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
  }
  
  SLOW_PATH_DECL(slow_path_typeof)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified">!     RETURN(jsTypeStringForValue(globalObject, GET_C(bytecode.m_value).jsValue()));</span>
  }
  
  SLOW_PATH_DECL(slow_path_is_object_or_null)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
<span class="line-modified">!     RETURN(jsBoolean(jsIsObjectTypeOrNull(globalObject, GET_C(bytecode.m_operand).jsValue())));</span>
  }
  
  SLOW_PATH_DECL(slow_path_is_function)
  {
      BEGIN();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,66 ***</span>
  
  SLOW_PATH_DECL(slow_path_in_by_val)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     RETURN(jsBoolean(CommonSlowPaths::opInByVal(exec, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_in_by_id)
  {
      BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpInById&gt;();
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      if (!baseValue.isObject())
<span class="line-modified">!         THROW(createInvalidInParameterError(exec, baseValue));</span>
  
<span class="line-modified">!     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property))));</span>
  }
  
  SLOW_PATH_DECL(slow_path_del_by_val)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
<span class="line-modified">!     JSObject* baseObject = baseValue.toObject(exec);</span>
      CHECK_EXCEPTION();
  
      JSValue subscript = GET_C(bytecode.m_property).jsValue();
  
      bool couldDelete;
  
      uint32_t i;
      if (subscript.getUInt32(i))
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);</span>
      else {
          CHECK_EXCEPTION();
<span class="line-modified">!         auto property = subscript.toPropertyKey(exec);</span>
          CHECK_EXCEPTION();
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);</span>
      }
  
<span class="line-modified">!     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified">!         THROW(createTypeError(exec, UnableToDeletePropertyError));</span>
  
      RETURN(jsBoolean(couldDelete));
  }
  
  SLOW_PATH_DECL(slow_path_strcat)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified">!     RETURN(jsStringFromRegisterArray(exec, &amp;GET(bytecode.m_src), bytecode.m_count));</span>
  }
  
  SLOW_PATH_DECL(slow_path_to_primitive)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(exec));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_enumerable_length)
  {
      BEGIN();
<span class="line-new-header">--- 948,81 ---</span>
  
  SLOW_PATH_DECL(slow_path_in_by_val)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     RETURN(jsBoolean(CommonSlowPaths::opInByVal(globalObject, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_in_by_id)
  {
      BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpInById&gt;();
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      if (!baseValue.isObject())
<span class="line-modified">!         THROW(createInvalidInParameterError(globalObject, baseValue));</span>
  
<span class="line-modified">!     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(globalObject, codeBlock-&gt;identifier(bytecode.m_property))));</span>
  }
  
  SLOW_PATH_DECL(slow_path_del_by_val)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
<span class="line-modified">!     JSObject* baseObject = baseValue.toObject(globalObject);</span>
      CHECK_EXCEPTION();
  
      JSValue subscript = GET_C(bytecode.m_property).jsValue();
  
      bool couldDelete;
  
      uint32_t i;
      if (subscript.getUInt32(i))
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, globalObject, i);</span>
      else {
          CHECK_EXCEPTION();
<span class="line-modified">!         auto property = subscript.toPropertyKey(globalObject);</span>
          CHECK_EXCEPTION();
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, property);</span>
      }
<span class="line-added">+     CHECK_EXCEPTION();</span>
  
<span class="line-modified">!     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())</span>
<span class="line-modified">!         THROW(createTypeError(globalObject, UnableToDeletePropertyError));</span>
  
      RETURN(jsBoolean(couldDelete));
  }
  
  SLOW_PATH_DECL(slow_path_strcat)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified">!     RETURN(jsStringFromRegisterArray(globalObject, &amp;GET(bytecode.m_src), bytecode.m_count));</span>
  }
  
  SLOW_PATH_DECL(slow_path_to_primitive)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(globalObject));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_enter)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     Heap::heap(codeBlock)-&gt;writeBarrier(codeBlock);</span>
<span class="line-added">+     END();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SLOW_PATH_DECL(slow_path_to_property_key)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     BEGIN();</span>
<span class="line-added">+     auto bytecode = pc-&gt;as&lt;OpToPropertyKey&gt;();</span>
<span class="line-added">+     RETURN(GET_C(bytecode.m_src).jsValue().toPropertyKeyValue(globalObject));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_enumerable_length)
  {
      BEGIN();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 903,75 ***</span>
  
  SLOW_PATH_DECL(slow_path_has_indexed_property)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
      CHECK_EXCEPTION();
      JSValue property = GET(bytecode.m_property).jsValue();
      metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
      ASSERT(property.isUInt32AsAnyInt());
<span class="line-modified">!     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_has_structure_property)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified">!     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
      CHECK_EXCEPTION();
      JSValue property = GET(bytecode.m_property).jsValue();
      ASSERT(property.isString());
      JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
      if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
          RETURN(jsBoolean(true));
      JSString* string = asString(property);
<span class="line-modified">!     auto propertyName = string-&gt;toIdentifier(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_has_generic_property)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
<span class="line-modified">!     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
      CHECK_EXCEPTION();
      JSValue property = GET(bytecode.m_property).jsValue();
      ASSERT(property.isString());
      JSString* string = asString(property);
<span class="line-modified">!     auto propertyName = string-&gt;toIdentifier(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_direct_pname)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue property = GET(bytecode.m_property).jsValue();
      ASSERT(property.isString());
      JSString* string = asString(property);
<span class="line-modified">!     auto propertyName = string-&gt;toIdentifier(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN(baseValue.get(exec, propertyName));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_property_enumerator)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
      JSValue baseValue = GET(bytecode.m_base).jsValue();
      if (baseValue.isUndefinedOrNull())
          RETURN(vm.emptyPropertyNameEnumerator());
  
<span class="line-modified">!     JSObject* base = baseValue.toObject(exec);</span>
      CHECK_EXCEPTION();
  
<span class="line-modified">!     RETURN(propertyNameEnumerator(exec, base));</span>
  }
  
  SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
  {
      BEGIN();
<span class="line-new-header">--- 1038,75 ---</span>
  
  SLOW_PATH_DECL(slow_path_has_indexed_property)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
      CHECK_EXCEPTION();
      JSValue property = GET(bytecode.m_property).jsValue();
      metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
      ASSERT(property.isUInt32AsAnyInt());
<span class="line-modified">!     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_has_structure_property)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified">!     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
      CHECK_EXCEPTION();
      JSValue property = GET(bytecode.m_property).jsValue();
      ASSERT(property.isString());
      JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
      if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
          RETURN(jsBoolean(true));
      JSString* string = asString(property);
<span class="line-modified">!     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_has_generic_property)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
<span class="line-modified">!     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
      CHECK_EXCEPTION();
      JSValue property = GET(bytecode.m_property).jsValue();
      ASSERT(property.isString());
      JSString* string = asString(property);
<span class="line-modified">!     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_direct_pname)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue property = GET(bytecode.m_property).jsValue();
      ASSERT(property.isString());
      JSString* string = asString(property);
<span class="line-modified">!     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN(baseValue.get(globalObject, propertyName));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_property_enumerator)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
      JSValue baseValue = GET(bytecode.m_base).jsValue();
      if (baseValue.isUndefinedOrNull())
          RETURN(vm.emptyPropertyNameEnumerator());
  
<span class="line-modified">!     JSObject* base = baseValue.toObject(globalObject);</span>
      CHECK_EXCEPTION();
  
<span class="line-modified">!     RETURN(propertyNameEnumerator(globalObject, base));</span>
  }
  
  SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
  {
      BEGIN();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,53 ***</span>
  
  SLOW_PATH_DECL(slow_path_create_lexical_environment)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
<span class="line-modified">!     int scopeReg = bytecode.m_scope.offset();</span>
<span class="line-removed">-     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();</span>
      SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
      JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
      ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<span class="line-modified">!     JSScope* newScope = JSLexicalEnvironment::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, symbolTable, initialValue);</span>
      RETURN(newScope);
  }
  
  SLOW_PATH_DECL(slow_path_push_with_scope)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
<span class="line-modified">!     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(exec);</span>
      CHECK_EXCEPTION();
  
<span class="line-modified">!     int scopeReg = bytecode.m_currentScope.offset();</span>
<span class="line-modified">!     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();</span>
<span class="line-removed">-     RETURN(JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, newScope));</span>
  }
  
  SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
<span class="line-modified">!     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);</span>
<span class="line-modified">!     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();</span>
<span class="line-modified">!     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, ident);</span>
  
      CHECK_EXCEPTION();
  
      RETURN(resolvedScope);
  }
  
  SLOW_PATH_DECL(slow_path_resolve_scope)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">!     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();</span>
<span class="line-modified">!     JSObject* resolvedScope = JSScope::resolve(exec, scope, ident);</span>
      // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
      CHECK_EXCEPTION();
  
      ResolveType resolveType = metadata.m_resolveType;
  
<span class="line-new-header">--- 1158,50 ---</span>
  
  SLOW_PATH_DECL(slow_path_create_lexical_environment)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
<span class="line-modified">!     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
      JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
      ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<span class="line-modified">!     JSScope* newScope = JSLexicalEnvironment::create(vm, globalObject, currentScope, symbolTable, initialValue);</span>
      RETURN(newScope);
  }
  
  SLOW_PATH_DECL(slow_path_push_with_scope)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
<span class="line-modified">!     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(globalObject);</span>
      CHECK_EXCEPTION();
  
<span class="line-modified">!     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_currentScope).Register::scope();</span>
<span class="line-modified">!     RETURN(JSWithScope::create(vm, globalObject, currentScope, newScope));</span>
  }
  
  SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
<span class="line-modified">!     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);</span>
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-modified">!     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);</span>
  
      CHECK_EXCEPTION();
  
      RETURN(resolvedScope);
  }
  
  SLOW_PATH_DECL(slow_path_resolve_scope)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-modified">!     JSObject* resolvedScope = JSScope::resolve(globalObject, scope, ident);</span>
      // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
      CHECK_EXCEPTION();
  
      ResolveType resolveType = metadata.m_resolveType;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1081,11 ***</span>
      case GlobalPropertyWithVarInjectionChecks:
      case UnresolvedProperty:
      case UnresolvedPropertyWithVarInjectionChecks: {
          if (resolvedScope-&gt;isGlobalObject()) {
              JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
<span class="line-modified">!             bool hasProperty = globalObject-&gt;hasProperty(exec, ident);</span>
              CHECK_EXCEPTION();
              if (hasProperty) {
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
                  metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
                  metadata.m_globalObject.set(vm, codeBlock, globalObject);
<span class="line-new-header">--- 1213,11 ---</span>
      case GlobalPropertyWithVarInjectionChecks:
      case UnresolvedProperty:
      case UnresolvedPropertyWithVarInjectionChecks: {
          if (resolvedScope-&gt;isGlobalObject()) {
              JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
<span class="line-modified">!             bool hasProperty = globalObject-&gt;hasProperty(globalObject, ident);</span>
              CHECK_EXCEPTION();
              if (hasProperty) {
                  ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
                  metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
                  metadata.m_globalObject.set(vm, codeBlock, globalObject);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1109,26 ***</span>
  SLOW_PATH_DECL(slow_path_create_rest)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
      unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      Structure* structure = globalObject-&gt;restParameterStructure();
      unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<span class="line-modified">!     JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numParamsToSkip;</span>
<span class="line-modified">!     RETURN(constructArray(exec, structure, argumentsToCopyRegion, arraySize));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_by_id_with_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);</span>
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
      PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     JSValue result = baseValue.get(exec, ident, slot);</span>
      RETURN_PROFILED(result);
  }
  
  SLOW_PATH_DECL(slow_path_get_by_val_with_this)
  {
<span class="line-new-header">--- 1241,25 ---</span>
  SLOW_PATH_DECL(slow_path_create_rest)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
      unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
      Structure* structure = globalObject-&gt;restParameterStructure();
      unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<span class="line-modified">!     JSValue* argumentsToCopyRegion = callFrame-&gt;addressOfArgumentsStart() + numParamsToSkip;</span>
<span class="line-modified">!     RETURN(constructArray(globalObject, structure, argumentsToCopyRegion, arraySize));</span>
  }
  
  SLOW_PATH_DECL(slow_path_get_by_id_with_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);</span>
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
      PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     JSValue result = baseValue.get(globalObject, ident, slot);</span>
      RETURN_PROFILED(result);
  }
  
  SLOW_PATH_DECL(slow_path_get_by_val_with_this)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1140,11 ***</span>
      JSValue subscript = GET_C(bytecode.m_property).jsValue();
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
              CHECK_EXCEPTION();
              if (existingAtomString) {
                  if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      RETURN_PROFILED(result);
              }
<span class="line-new-header">--- 1271,11 ---</span>
      JSValue subscript = GET_C(bytecode.m_property).jsValue();
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
              CHECK_EXCEPTION();
              if (existingAtomString) {
                  if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      RETURN_PROFILED(result);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1153,33 ***</span>
  
      PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
      if (subscript.isUInt32()) {
          uint32_t i = subscript.asUInt32();
          if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">!             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(exec, i));</span>
  
<span class="line-modified">!         RETURN_PROFILED(baseValue.get(exec, i, slot));</span>
      }
  
<span class="line-modified">!     baseValue.requireObjectCoercible(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN_PROFILED(baseValue.get(exec, property, slot));</span>
  }
  
  SLOW_PATH_DECL(slow_path_put_by_id_with_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
      JSValue putValue = GET_C(bytecode.m_value).jsValue();
      PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<span class="line-modified">!     baseValue.putInline(exec, ident, putValue, slot);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_put_by_val_with_this)
  {
<span class="line-new-header">--- 1284,32 ---</span>
  
      PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
      if (subscript.isUInt32()) {
          uint32_t i = subscript.asUInt32();
          if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">!             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(globalObject, i));</span>
  
<span class="line-modified">!         RETURN_PROFILED(baseValue.get(globalObject, i, slot));</span>
      }
  
<span class="line-modified">!     baseValue.requireObjectCoercible(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     RETURN_PROFILED(baseValue.get(globalObject, property, slot));</span>
  }
  
  SLOW_PATH_DECL(slow_path_put_by_id_with_this)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
      JSValue putValue = GET_C(bytecode.m_value).jsValue();
      PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<span class="line-modified">!     baseValue.putInline(globalObject, ident, putValue, slot);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_put_by_val_with_this)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1188,14 ***</span>
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
      JSValue subscript = GET_C(bytecode.m_property).jsValue();
      JSValue value = GET_C(bytecode.m_value).jsValue();
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     PutPropertySlot slot(thisValue, exec-&gt;codeBlock()-&gt;isStrictMode());</span>
<span class="line-modified">!     baseValue.put(exec, property, value, slot);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_define_data_property)
  {
<span class="line-new-header">--- 1318,14 ---</span>
      JSValue baseValue = GET_C(bytecode.m_base).jsValue();
      JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
      JSValue subscript = GET_C(bytecode.m_property).jsValue();
      JSValue value = GET_C(bytecode.m_value).jsValue();
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      CHECK_EXCEPTION();
<span class="line-modified">!     PutPropertySlot slot(thisValue, codeBlock-&gt;isStrictMode());</span>
<span class="line-modified">!     baseValue.put(globalObject, property, value, slot);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_define_data_property)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1205,15 ***</span>
      JSValue property = GET_C(bytecode.m_property).jsValue();
      JSValue value = GET_C(bytecode.m_value).jsValue();
      JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
      ASSERT(attributes.isInt32());
  
<span class="line-modified">!     auto propertyName = property.toPropertyKey(exec);</span>
      CHECK_EXCEPTION();
      PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">!     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_define_accessor_property)
  {
<span class="line-new-header">--- 1335,15 ---</span>
      JSValue property = GET_C(bytecode.m_property).jsValue();
      JSValue value = GET_C(bytecode.m_value).jsValue();
      JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
      ASSERT(attributes.isInt32());
  
<span class="line-modified">!     auto propertyName = property.toPropertyKey(globalObject);</span>
      CHECK_EXCEPTION();
      PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">!     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_define_accessor_property)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1224,78 ***</span>
      JSValue getter = GET_C(bytecode.m_getter).jsValue();
      JSValue setter = GET_C(bytecode.m_setter).jsValue();
      JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
      ASSERT(attributes.isInt32());
  
<span class="line-modified">!     auto propertyName = property.toPropertyKey(exec);</span>
      CHECK_EXCEPTION();
      PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">!     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_throw_static_error)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
      JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
      RELEASE_ASSERT(errorMessageValue.isString());
<span class="line-modified">!     String errorMessage = asString(errorMessageValue)-&gt;value(exec);</span>
      ErrorType errorType = bytecode.m_errorType;
<span class="line-modified">!     THROW(createError(exec, errorType, errorMessage));</span>
  }
  
  SLOW_PATH_DECL(slow_path_new_array_with_spread)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
      int numItems = bytecode.m_argc;
      ASSERT(numItems &gt;= 0);
<span class="line-modified">!     const BitVector&amp; bitVector = exec-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);</span>
  
      JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
  
      Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
      for (int i = 0; i &lt; numItems; i++) {
          if (bitVector.get(i)) {
              JSValue value = values[-i];
<span class="line-modified">!             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);</span>
<span class="line-modified">!             checkedArraySize += array-&gt;size();</span>
          } else
              checkedArraySize += 1;
      }
      if (UNLIKELY(checkedArraySize.hasOverflowed()))
<span class="line-modified">!         THROW(createOutOfMemoryError(exec));</span>
  
      unsigned arraySize = checkedArraySize.unsafeGet();
      if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
<span class="line-modified">!         THROW(createOutOfMemoryError(exec));</span>
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
  
      JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
      if (UNLIKELY(!result))
<span class="line-modified">!         THROW(createOutOfMemoryError(exec));</span>
      CHECK_EXCEPTION();
  
      unsigned index = 0;
      for (int i = 0; i &lt; numItems; i++) {
          JSValue value = values[-i];
          if (bitVector.get(i)) {
              // We are spreading.
<span class="line-modified">!             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);</span>
<span class="line-modified">!             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {</span>
                  RELEASE_ASSERT(array-&gt;get(i));
<span class="line-modified">!                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));</span>
                  CHECK_EXCEPTION();
                  ++index;
              }
          } else {
              // We are not spreading.
<span class="line-modified">!             result-&gt;putDirectIndex(exec, index, value);</span>
              CHECK_EXCEPTION();
              ++index;
          }
      }
  
<span class="line-new-header">--- 1354,85 ---</span>
      JSValue getter = GET_C(bytecode.m_getter).jsValue();
      JSValue setter = GET_C(bytecode.m_setter).jsValue();
      JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
      ASSERT(attributes.isInt32());
  
<span class="line-modified">!     auto propertyName = property.toPropertyKey(globalObject);</span>
      CHECK_EXCEPTION();
      PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">!     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
      END();
  }
  
  SLOW_PATH_DECL(slow_path_throw_static_error)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
      JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
      RELEASE_ASSERT(errorMessageValue.isString());
<span class="line-modified">!     String errorMessage = asString(errorMessageValue)-&gt;value(globalObject);</span>
      ErrorType errorType = bytecode.m_errorType;
<span class="line-modified">!     THROW(createError(globalObject, errorType, errorMessage));</span>
  }
  
  SLOW_PATH_DECL(slow_path_new_array_with_spread)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
      int numItems = bytecode.m_argc;
      ASSERT(numItems &gt;= 0);
<span class="line-modified">!     const BitVector&amp; bitVector = codeBlock-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);</span>
  
      JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
  
<span class="line-added">+     if (numItems == 1 &amp;&amp; bitVector.get(0)) {</span>
<span class="line-added">+         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous);</span>
<span class="line-added">+         if (isCopyOnWrite(structure-&gt;indexingMode())) {</span>
<span class="line-added">+             JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, jsCast&lt;JSImmutableButterfly*&gt;(values[0]));</span>
<span class="line-added">+             RETURN(result);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
      for (int i = 0; i &lt; numItems; i++) {
          if (bitVector.get(i)) {
              JSValue value = values[-i];
<span class="line-modified">!             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);</span>
<span class="line-modified">!             checkedArraySize += array-&gt;publicLength();</span>
          } else
              checkedArraySize += 1;
      }
      if (UNLIKELY(checkedArraySize.hasOverflowed()))
<span class="line-modified">!         THROW(createOutOfMemoryError(globalObject));</span>
  
      unsigned arraySize = checkedArraySize.unsafeGet();
      if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
<span class="line-modified">!         THROW(createOutOfMemoryError(globalObject));</span>
  
      Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
  
      JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
      if (UNLIKELY(!result))
<span class="line-modified">!         THROW(createOutOfMemoryError(globalObject));</span>
      CHECK_EXCEPTION();
  
      unsigned index = 0;
      for (int i = 0; i &lt; numItems; i++) {
          JSValue value = values[-i];
          if (bitVector.get(i)) {
              // We are spreading.
<span class="line-modified">!             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);</span>
<span class="line-modified">!             for (unsigned i = 0; i &lt; array-&gt;publicLength(); i++) {</span>
                  RELEASE_ASSERT(array-&gt;get(i));
<span class="line-modified">!                 result-&gt;putDirectIndex(globalObject, index, array-&gt;get(i));</span>
                  CHECK_EXCEPTION();
                  ++index;
              }
          } else {
              // We are not spreading.
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, index, value);</span>
              CHECK_EXCEPTION();
              ++index;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1304,36 ***</span>
  
  SLOW_PATH_DECL(slow_path_new_array_buffer)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
<span class="line-modified">!     ASSERT(exec-&gt;codeBlock()-&gt;isConstantRegisterIndex(bytecode.m_immutableButterfly.offset()));</span>
      JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
<span class="line-modified">!     auto&amp; profile = bytecode.metadata(exec).m_arrayAllocationProfile;</span>
  
      IndexingType indexingMode = profile.selectIndexingType();
<span class="line-modified">!     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
      ASSERT(isCopyOnWrite(indexingMode));
      ASSERT(!structure-&gt;outOfLineCapacity());
  
      if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
          auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
          for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
              newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
          immutableButterfly = newButterfly;
<span class="line-removed">-         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
          // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
          // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
          // a compilation thread.
          WTF::storeStoreFence();
<span class="line-modified">!         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly.offset()).set(vm, codeBlock, immutableButterfly);</span>
          WTF::storeStoreFence();
      }
  
      JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
<span class="line-modified">!     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || exec-&gt;lexicalGlobalObject()-&gt;isHavingABadTime());</span>
      ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
      RETURN(result);
  }
  
  SLOW_PATH_DECL(slow_path_spread)
<span class="line-new-header">--- 1441,35 ---</span>
  
  SLOW_PATH_DECL(slow_path_new_array_buffer)
  {
      BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
<span class="line-modified">!     ASSERT(bytecode.m_immutableButterfly.isConstant());</span>
      JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
<span class="line-modified">!     auto&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;</span>
  
      IndexingType indexingMode = profile.selectIndexingType();
<span class="line-modified">!     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
      ASSERT(isCopyOnWrite(indexingMode));
      ASSERT(!structure-&gt;outOfLineCapacity());
  
      if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
          auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
          for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
              newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
          immutableButterfly = newButterfly;
  
          // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
          // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
          // a compilation thread.
          WTF::storeStoreFence();
<span class="line-modified">!         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly).set(vm, codeBlock, immutableButterfly);</span>
          WTF::storeStoreFence();
      }
  
      JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
<span class="line-modified">!     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || globalObject-&gt;isHavingABadTime());</span>
      ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
      RETURN(result);
  }
  
  SLOW_PATH_DECL(slow_path_spread)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1344,33 ***</span>
      JSValue iterable = GET_C(bytecode.m_argument).jsValue();
  
      if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
          JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
          if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
<span class="line-modified">!             // JSFixedArray::createFromArray does not consult the prototype chain,</span>
              // so we must be sure that not consulting the prototype chain would
              // produce the same value during iteration.
<span class="line-modified">!             RETURN(JSFixedArray::createFromArray(exec, vm, array));</span>
          }
      }
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">- </span>
      JSArray* array;
      {
          JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
          CallData callData;
          CallType callType = JSC::getCallData(vm, iterationFunction, callData);
          ASSERT(callType != CallType::None);
  
          MarkedArgumentBuffer arguments;
          arguments.append(iterable);
          ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);</span>
          CHECK_EXCEPTION();
          array = jsCast&lt;JSArray*&gt;(arrayResult);
      }
  
<span class="line-modified">!     RETURN(JSFixedArray::createFromArray(exec, vm, array));</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 1480,31 ---</span>
      JSValue iterable = GET_C(bytecode.m_argument).jsValue();
  
      if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
          JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
          if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
<span class="line-modified">!             // JSImmutableButterfly::createFromArray does not consult the prototype chain,</span>
              // so we must be sure that not consulting the prototype chain would
              // produce the same value during iteration.
<span class="line-modified">!             RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
          }
      }
  
      JSArray* array;
      {
          JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
          CallData callData;
          CallType callType = JSC::getCallData(vm, iterationFunction, callData);
          ASSERT(callType != CallType::None);
  
          MarkedArgumentBuffer arguments;
          arguments.append(iterable);
          ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!         JSValue arrayResult = call(globalObject, iterationFunction, callType, callData, jsNull(), arguments);</span>
          CHECK_EXCEPTION();
          array = jsCast&lt;JSArray*&gt;(arrayResult);
      }
  
<span class="line-modified">!     RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="CommonIdentifiers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CommonSlowPaths.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
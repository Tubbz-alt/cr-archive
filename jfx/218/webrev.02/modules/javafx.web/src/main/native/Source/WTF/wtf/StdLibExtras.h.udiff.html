<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StackTrace.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SystemTracing.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/StdLibExtras.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2008-2019 Apple Inc. All Rights Reserved.</span>
   * Copyright (C) 2013 Patrick Gansterer &lt;paroga@paroga.com&gt;
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111,13 +111,13 @@</span>
  
  namespace WTF {
  
  enum CheckMoveParameterTag { CheckMoveParameter };
  
<span class="udiff-line-modified-removed">- static const size_t KB = 1024;</span>
<span class="udiff-line-modified-removed">- static const size_t MB = 1024 * 1024;</span>
<span class="udiff-line-modified-removed">- static const size_t GB = 1024 * 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t KB = 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t MB = 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t GB = 1024 * 1024 * 1024;</span>
  
  inline bool isPointerAligned(void* p)
  {
      return !((intptr_t)(p) &amp; (sizeof(char*) - 1));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -457,51 +457,11 @@</span>
  {
      ASSERT(location);
      return location;
  }
  
<span class="udiff-line-removed">- // This adds various C++14 features for versions of the STL that may not yet have them.</span>
  namespace std {
<span class="udiff-line-removed">- #if COMPILER(CLANG) &amp;&amp; __cplusplus &lt; 201400L</span>
<span class="udiff-line-removed">- template&lt;class T&gt; struct _Unique_if {</span>
<span class="udiff-line-removed">-     typedef unique_ptr&lt;T&gt; _Single_object;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class T&gt; struct _Unique_if&lt;T[]&gt; {</span>
<span class="udiff-line-removed">-     typedef unique_ptr&lt;T[]&gt; _Unknown_bound;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class T, size_t N&gt; struct _Unique_if&lt;T[N]&gt; {</span>
<span class="udiff-line-removed">-     typedef void _Known_bound;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class T, class... Args&gt; inline typename _Unique_if&lt;T&gt;::_Single_object</span>
<span class="udiff-line-removed">- make_unique(Args&amp;&amp;... args)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     return unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class T&gt; inline typename _Unique_if&lt;T&gt;::_Unknown_bound</span>
<span class="udiff-line-removed">- make_unique(size_t n)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     typedef typename remove_extent&lt;T&gt;::type U;</span>
<span class="udiff-line-removed">-     return unique_ptr&lt;T&gt;(new U[n]());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template&lt;class T, class... Args&gt; typename _Unique_if&lt;T&gt;::_Known_bound</span>
<span class="udiff-line-removed">- make_unique(Args&amp;&amp;...) = delete;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // std::exchange</span>
<span class="udiff-line-removed">- template&lt;class T, class U = T&gt;</span>
<span class="udiff-line-removed">- T exchange(T&amp; t, U&amp;&amp; newValue)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     T oldValue = std::move(t);</span>
<span class="udiff-line-removed">-     t = std::forward&lt;U&gt;(newValue);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return oldValue;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #endif</span>
  
  template&lt;WTF::CheckMoveParameterTag, typename T&gt;
  ALWAYS_INLINE constexpr typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; value)
  {
      static_assert(is_lvalue_reference&lt;T&gt;::value, &quot;T is not an lvalue reference; move() is unnecessary.&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -510,61 +470,10 @@</span>
      static_assert(!is_const&lt;NonRefQualifiedType&gt;::value, &quot;T is const qualified.&quot;);
  
      return move(forward&lt;T&gt;(value));
  }
  
<span class="udiff-line-removed">- #if __cplusplus &lt; 201703L &amp;&amp; (!defined(_MSC_FULL_VER) || _MSC_FULL_VER &lt; 190023918) &amp;&amp; !defined(__cpp_lib_logical_traits)</span>
<span class="udiff-line-removed">- template&lt;class...&gt; struct wtf_conjunction_impl;</span>
<span class="udiff-line-removed">- template&lt;&gt; struct wtf_conjunction_impl&lt;&gt; : true_type { };</span>
<span class="udiff-line-removed">- template&lt;class B0&gt; struct wtf_conjunction_impl&lt;B0&gt; : B0 { };</span>
<span class="udiff-line-removed">- template&lt;class B0, class B1&gt; struct wtf_conjunction_impl&lt;B0, B1&gt; : conditional&lt;B0::value, B1, B0&gt;::type { };</span>
<span class="udiff-line-removed">- template&lt;class B0, class B1, class B2, class... Bn&gt; struct wtf_conjunction_impl&lt;B0, B1, B2, Bn...&gt; : conditional&lt;B0::value, wtf_conjunction_impl&lt;B1, B2, Bn...&gt;, B0&gt;::type { };</span>
<span class="udiff-line-removed">- template&lt;class... _Args&gt; struct conjunction : wtf_conjunction_impl&lt;_Args...&gt; { };</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Provide in_place_t when not building with -std=c++17, or when building with libstdc++ 6</span>
<span class="udiff-line-removed">- // (which doesn&#39;t define the _GLIBCXX_RELEASE macro that&#39;s been introduced in libstdc++ 7).</span>
<span class="udiff-line-removed">- #if ((defined(__GLIBCXX__) &amp;&amp; !defined(_GLIBCXX_RELEASE))) &amp;&amp; (!defined(_MSVC_LANG) || _MSVC_LANG &lt; 201703L)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // These are inline variable for C++17 and later.</span>
<span class="udiff-line-removed">- #define __IN_PLACE_INLINE_VARIABLE static const</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- struct in_place_t {</span>
<span class="udiff-line-removed">-     explicit in_place_t() = default;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- __IN_PLACE_INLINE_VARIABLE constexpr in_place_t in_place { };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template &lt;class T&gt; struct in_place_type_t {</span>
<span class="udiff-line-removed">-     explicit in_place_type_t() = default;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- template &lt;class T&gt;</span>
<span class="udiff-line-removed">- __IN_PLACE_INLINE_VARIABLE constexpr in_place_type_t&lt;T&gt; in_place_type { };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- template &lt;size_t I&gt; struct in_place_index_t {</span>
<span class="udiff-line-removed">-     explicit in_place_index_t() = default;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- template &lt;size_t I&gt;</span>
<span class="udiff-line-removed">- __IN_PLACE_INLINE_VARIABLE constexpr in_place_index_t&lt;I&gt; in_place_index { };</span>
<span class="udiff-line-removed">- #endif // __cplusplus &lt; 201703L</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- enum class ZeroStatus {</span>
<span class="udiff-line-removed">-     MayBeZero,</span>
<span class="udiff-line-removed">-     NonZero</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- constexpr size_t clz(uint32_t value, ZeroStatus mightBeZero = ZeroStatus::MayBeZero)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (mightBeZero == ZeroStatus::MayBeZero &amp;&amp; value) {</span>
<span class="udiff-line-removed">- #if COMPILER(MSVC)</span>
<span class="udiff-line-removed">-         return __lzcnt(value);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-         return __builtin_clz(value);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return 32;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  } // namespace std
  
  namespace WTF {
  
  template&lt;class T, class... Args&gt;
</pre>
<center><a href="StackTrace.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SystemTracing.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
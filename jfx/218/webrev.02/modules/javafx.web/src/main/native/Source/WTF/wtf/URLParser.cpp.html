<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &lt;wtf/URLParser.h&gt;
  28 
  29 #include &lt;array&gt;
  30 #include &lt;mutex&gt;
  31 #include &lt;unicode/uidna.h&gt;
  32 #include &lt;unicode/utf8.h&gt;
  33 #include &lt;unicode/utypes.h&gt;
  34 
  35 namespace WTF {
  36 
  37 #define URL_PARSER_DEBUGGING 0
  38 
  39 #if URL_PARSER_DEBUGGING
  40 #define URL_PARSER_LOG(...) WTFLogAlways(__VA_ARGS__)
  41 #else
  42 #define URL_PARSER_LOG(...)
  43 #endif
  44 
  45 template&lt;typename CharacterType&gt;
  46 class CodePointIterator {
  47     WTF_MAKE_FAST_ALLOCATED;
  48 public:
  49     ALWAYS_INLINE CodePointIterator() { }
  50     ALWAYS_INLINE CodePointIterator(const CharacterType* begin, const CharacterType* end)
  51         : m_begin(begin)
  52         , m_end(end)
  53     {
  54     }
  55 
  56     ALWAYS_INLINE CodePointIterator(const CodePointIterator&amp; begin, const CodePointIterator&amp; end)
  57         : CodePointIterator(begin.m_begin, end.m_begin)
  58     {
  59         ASSERT(end.m_begin &gt;= begin.m_begin);
  60     }
  61 
  62     ALWAYS_INLINE UChar32 operator*() const;
  63     ALWAYS_INLINE CodePointIterator&amp; operator++();
  64 
  65     ALWAYS_INLINE bool operator==(const CodePointIterator&amp; other) const
  66     {
  67         return m_begin == other.m_begin
  68             &amp;&amp; m_end == other.m_end;
  69     }
  70     ALWAYS_INLINE bool operator!=(const CodePointIterator&amp; other) const { return !(*this == other); }
  71 
  72     ALWAYS_INLINE bool atEnd() const
  73     {
  74         ASSERT(m_begin &lt;= m_end);
  75         return m_begin &gt;= m_end;
  76     }
  77 
  78     ALWAYS_INLINE size_t codeUnitsSince(const CharacterType* reference) const
  79     {
  80         ASSERT(m_begin &gt;= reference);
  81         return m_begin - reference;
  82     }
  83 
  84     ALWAYS_INLINE size_t codeUnitsSince(const CodePointIterator&amp; other) const
  85     {
  86         return codeUnitsSince(other.m_begin);
  87     }
  88 
  89 private:
  90     const CharacterType* m_begin { nullptr };
  91     const CharacterType* m_end { nullptr };
  92 };
  93 
  94 template&lt;&gt;
  95 ALWAYS_INLINE UChar32 CodePointIterator&lt;LChar&gt;::operator*() const
  96 {
  97     ASSERT(!atEnd());
  98     return *m_begin;
  99 }
 100 
 101 template&lt;&gt;
 102 ALWAYS_INLINE auto CodePointIterator&lt;LChar&gt;::operator++() -&gt; CodePointIterator&amp;
 103 {
 104     m_begin++;
 105     return *this;
 106 }
 107 
 108 template&lt;&gt;
 109 ALWAYS_INLINE UChar32 CodePointIterator&lt;UChar&gt;::operator*() const
 110 {
 111     ASSERT(!atEnd());
 112     UChar32 c;
 113     U16_GET(m_begin, 0, 0, m_end - m_begin, c);
 114     return c;
 115 }
 116 
 117 template&lt;&gt;
 118 ALWAYS_INLINE auto CodePointIterator&lt;UChar&gt;::operator++() -&gt; CodePointIterator&amp;
 119 {
 120     unsigned i = 0;
 121     size_t length = m_end - m_begin;
 122     U16_FWD_1(m_begin, i, length);
 123     m_begin += i;
 124     return *this;
 125 }
 126 
 127 ALWAYS_INLINE static void appendCodePoint(Vector&lt;UChar&gt;&amp; destination, UChar32 codePoint)
 128 {
 129     if (U_IS_BMP(codePoint)) {
 130         destination.append(static_cast&lt;UChar&gt;(codePoint));
 131         return;
 132     }
 133     destination.reserveCapacity(destination.size() + 2);
 134     destination.uncheckedAppend(U16_LEAD(codePoint));
 135     destination.uncheckedAppend(U16_TRAIL(codePoint));
 136 }
 137 
 138 enum URLCharacterClass {
 139     UserInfo = 0x1,
 140     Default = 0x2,
 141     ForbiddenHost = 0x4,
 142     QueryPercent = 0x8,
 143     SlashQuestionOrHash = 0x10,
 144     ValidScheme = 0x20,
 145 };
 146 
 147 static const uint8_t characterClassTable[256] = {
 148     UserInfo | Default | QueryPercent | ForbiddenHost, // 0x0
 149     UserInfo | Default | QueryPercent, // 0x1
 150     UserInfo | Default | QueryPercent, // 0x2
 151     UserInfo | Default | QueryPercent, // 0x3
 152     UserInfo | Default | QueryPercent, // 0x4
 153     UserInfo | Default | QueryPercent, // 0x5
 154     UserInfo | Default | QueryPercent, // 0x6
 155     UserInfo | Default | QueryPercent, // 0x7
 156     UserInfo | Default | QueryPercent, // 0x8
 157     UserInfo | Default | QueryPercent | ForbiddenHost, // 0x9
 158     UserInfo | Default | QueryPercent | ForbiddenHost, // 0xA
 159     UserInfo | Default | QueryPercent, // 0xB
 160     UserInfo | Default | QueryPercent, // 0xC
 161     UserInfo | Default | QueryPercent | ForbiddenHost, // 0xD
 162     UserInfo | Default | QueryPercent, // 0xE
 163     UserInfo | Default | QueryPercent, // 0xF
 164     UserInfo | Default | QueryPercent, // 0x10
 165     UserInfo | Default | QueryPercent, // 0x11
 166     UserInfo | Default | QueryPercent, // 0x12
 167     UserInfo | Default | QueryPercent, // 0x13
 168     UserInfo | Default | QueryPercent, // 0x14
 169     UserInfo | Default | QueryPercent, // 0x15
 170     UserInfo | Default | QueryPercent, // 0x16
 171     UserInfo | Default | QueryPercent, // 0x17
 172     UserInfo | Default | QueryPercent, // 0x18
 173     UserInfo | Default | QueryPercent, // 0x19
 174     UserInfo | Default | QueryPercent, // 0x1A
 175     UserInfo | Default | QueryPercent, // 0x1B
 176     UserInfo | Default | QueryPercent, // 0x1C
 177     UserInfo | Default | QueryPercent, // 0x1D
 178     UserInfo | Default | QueryPercent, // 0x1E
 179     UserInfo | Default | QueryPercent, // 0x1F
 180     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39; &#39;
 181     0, // &#39;!&#39;
 182     UserInfo | Default | QueryPercent, // &#39;&quot;&#39;
 183     UserInfo | Default | QueryPercent | SlashQuestionOrHash | ForbiddenHost, // &#39;#&#39;
 184     0, // &#39;$&#39;
 185     ForbiddenHost, // &#39;%&#39;
 186     0, // &#39;&amp;&#39;
 187     0, // &#39;\&#39;&#39;
 188     0, // &#39;(&#39;
 189     0, // &#39;)&#39;
 190     0, // &#39;*&#39;
 191     ValidScheme, // &#39;+&#39;
 192     0, // &#39;,&#39;
 193     ValidScheme, // &#39;-&#39;
 194     ValidScheme, // &#39;.&#39;
 195     UserInfo | SlashQuestionOrHash | ForbiddenHost, // &#39;/&#39;
 196     ValidScheme, // &#39;0&#39;
 197     ValidScheme, // &#39;1&#39;
 198     ValidScheme, // &#39;2&#39;
 199     ValidScheme, // &#39;3&#39;
 200     ValidScheme, // &#39;4&#39;
 201     ValidScheme, // &#39;5&#39;
 202     ValidScheme, // &#39;6&#39;
 203     ValidScheme, // &#39;7&#39;
 204     ValidScheme, // &#39;8&#39;
 205     ValidScheme, // &#39;9&#39;
 206     UserInfo | ForbiddenHost, // &#39;:&#39;
 207     UserInfo, // &#39;;&#39;
 208     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39;&lt;&#39;
 209     UserInfo, // &#39;=&#39;
 210     UserInfo | Default | QueryPercent | ForbiddenHost, // &#39;&gt;&#39;
 211     UserInfo | Default | SlashQuestionOrHash | ForbiddenHost, // &#39;?&#39;
 212     UserInfo | ForbiddenHost, // &#39;@&#39;
 213     ValidScheme, // &#39;A&#39;
 214     ValidScheme, // &#39;B&#39;
 215     ValidScheme, // &#39;C&#39;
 216     ValidScheme, // &#39;D&#39;
 217     ValidScheme, // &#39;E&#39;
 218     ValidScheme, // &#39;F&#39;
 219     ValidScheme, // &#39;G&#39;
 220     ValidScheme, // &#39;H&#39;
 221     ValidScheme, // &#39;I&#39;
 222     ValidScheme, // &#39;J&#39;
 223     ValidScheme, // &#39;K&#39;
 224     ValidScheme, // &#39;L&#39;
 225     ValidScheme, // &#39;M&#39;
 226     ValidScheme, // &#39;N&#39;
 227     ValidScheme, // &#39;O&#39;
 228     ValidScheme, // &#39;P&#39;
 229     ValidScheme, // &#39;Q&#39;
 230     ValidScheme, // &#39;R&#39;
 231     ValidScheme, // &#39;S&#39;
 232     ValidScheme, // &#39;T&#39;
 233     ValidScheme, // &#39;U&#39;
 234     ValidScheme, // &#39;V&#39;
 235     ValidScheme, // &#39;W&#39;
 236     ValidScheme, // &#39;X&#39;
 237     ValidScheme, // &#39;Y&#39;
 238     ValidScheme, // &#39;Z&#39;
 239     UserInfo | ForbiddenHost, // &#39;[&#39;
 240     UserInfo | SlashQuestionOrHash | ForbiddenHost, // &#39;\\&#39;
 241     UserInfo | ForbiddenHost, // &#39;]&#39;
 242     UserInfo, // &#39;^&#39;
 243     0, // &#39;_&#39;
 244     UserInfo | Default, // &#39;`&#39;
 245     ValidScheme, // &#39;a&#39;
 246     ValidScheme, // &#39;b&#39;
 247     ValidScheme, // &#39;c&#39;
 248     ValidScheme, // &#39;d&#39;
 249     ValidScheme, // &#39;e&#39;
 250     ValidScheme, // &#39;f&#39;
 251     ValidScheme, // &#39;g&#39;
 252     ValidScheme, // &#39;h&#39;
 253     ValidScheme, // &#39;i&#39;
 254     ValidScheme, // &#39;j&#39;
 255     ValidScheme, // &#39;k&#39;
 256     ValidScheme, // &#39;l&#39;
 257     ValidScheme, // &#39;m&#39;
 258     ValidScheme, // &#39;n&#39;
 259     ValidScheme, // &#39;o&#39;
 260     ValidScheme, // &#39;p&#39;
 261     ValidScheme, // &#39;q&#39;
 262     ValidScheme, // &#39;r&#39;
 263     ValidScheme, // &#39;s&#39;
 264     ValidScheme, // &#39;t&#39;
 265     ValidScheme, // &#39;u&#39;
 266     ValidScheme, // &#39;v&#39;
 267     ValidScheme, // &#39;w&#39;
 268     ValidScheme, // &#39;x&#39;
 269     ValidScheme, // &#39;y&#39;
 270     ValidScheme, // &#39;z&#39;
 271     UserInfo | Default, // &#39;{&#39;
 272     UserInfo, // &#39;|&#39;
 273     UserInfo | Default, // &#39;}&#39;
 274     0, // &#39;~&#39;
 275     QueryPercent, // 0x7F
 276     QueryPercent, // 0x80
 277     QueryPercent, // 0x81
 278     QueryPercent, // 0x82
 279     QueryPercent, // 0x83
 280     QueryPercent, // 0x84
 281     QueryPercent, // 0x85
 282     QueryPercent, // 0x86
 283     QueryPercent, // 0x87
 284     QueryPercent, // 0x88
 285     QueryPercent, // 0x89
 286     QueryPercent, // 0x8A
 287     QueryPercent, // 0x8B
 288     QueryPercent, // 0x8C
 289     QueryPercent, // 0x8D
 290     QueryPercent, // 0x8E
 291     QueryPercent, // 0x8F
 292     QueryPercent, // 0x90
 293     QueryPercent, // 0x91
 294     QueryPercent, // 0x92
 295     QueryPercent, // 0x93
 296     QueryPercent, // 0x94
 297     QueryPercent, // 0x95
 298     QueryPercent, // 0x96
 299     QueryPercent, // 0x97
 300     QueryPercent, // 0x98
 301     QueryPercent, // 0x99
 302     QueryPercent, // 0x9A
 303     QueryPercent, // 0x9B
 304     QueryPercent, // 0x9C
 305     QueryPercent, // 0x9D
 306     QueryPercent, // 0x9E
 307     QueryPercent, // 0x9F
 308     QueryPercent, // 0xA0
 309     QueryPercent, // 0xA1
 310     QueryPercent, // 0xA2
 311     QueryPercent, // 0xA3
 312     QueryPercent, // 0xA4
 313     QueryPercent, // 0xA5
 314     QueryPercent, // 0xA6
 315     QueryPercent, // 0xA7
 316     QueryPercent, // 0xA8
 317     QueryPercent, // 0xA9
 318     QueryPercent, // 0xAA
 319     QueryPercent, // 0xAB
 320     QueryPercent, // 0xAC
 321     QueryPercent, // 0xAD
 322     QueryPercent, // 0xAE
 323     QueryPercent, // 0xAF
 324     QueryPercent, // 0xB0
 325     QueryPercent, // 0xB1
 326     QueryPercent, // 0xB2
 327     QueryPercent, // 0xB3
 328     QueryPercent, // 0xB4
 329     QueryPercent, // 0xB5
 330     QueryPercent, // 0xB6
 331     QueryPercent, // 0xB7
 332     QueryPercent, // 0xB8
 333     QueryPercent, // 0xB9
 334     QueryPercent, // 0xBA
 335     QueryPercent, // 0xBB
 336     QueryPercent, // 0xBC
 337     QueryPercent, // 0xBD
 338     QueryPercent, // 0xBE
 339     QueryPercent, // 0xBF
 340     QueryPercent, // 0xC0
 341     QueryPercent, // 0xC1
 342     QueryPercent, // 0xC2
 343     QueryPercent, // 0xC3
 344     QueryPercent, // 0xC4
 345     QueryPercent, // 0xC5
 346     QueryPercent, // 0xC6
 347     QueryPercent, // 0xC7
 348     QueryPercent, // 0xC8
 349     QueryPercent, // 0xC9
 350     QueryPercent, // 0xCA
 351     QueryPercent, // 0xCB
 352     QueryPercent, // 0xCC
 353     QueryPercent, // 0xCD
 354     QueryPercent, // 0xCE
 355     QueryPercent, // 0xCF
 356     QueryPercent, // 0xD0
 357     QueryPercent, // 0xD1
 358     QueryPercent, // 0xD2
 359     QueryPercent, // 0xD3
 360     QueryPercent, // 0xD4
 361     QueryPercent, // 0xD5
 362     QueryPercent, // 0xD6
 363     QueryPercent, // 0xD7
 364     QueryPercent, // 0xD8
 365     QueryPercent, // 0xD9
 366     QueryPercent, // 0xDA
 367     QueryPercent, // 0xDB
 368     QueryPercent, // 0xDC
 369     QueryPercent, // 0xDD
 370     QueryPercent, // 0xDE
 371     QueryPercent, // 0xDF
 372     QueryPercent, // 0xE0
 373     QueryPercent, // 0xE1
 374     QueryPercent, // 0xE2
 375     QueryPercent, // 0xE3
 376     QueryPercent, // 0xE4
 377     QueryPercent, // 0xE5
 378     QueryPercent, // 0xE6
 379     QueryPercent, // 0xE7
 380     QueryPercent, // 0xE8
 381     QueryPercent, // 0xE9
 382     QueryPercent, // 0xEA
 383     QueryPercent, // 0xEB
 384     QueryPercent, // 0xEC
 385     QueryPercent, // 0xED
 386     QueryPercent, // 0xEE
 387     QueryPercent, // 0xEF
 388     QueryPercent, // 0xF0
 389     QueryPercent, // 0xF1
 390     QueryPercent, // 0xF2
 391     QueryPercent, // 0xF3
 392     QueryPercent, // 0xF4
 393     QueryPercent, // 0xF5
 394     QueryPercent, // 0xF6
 395     QueryPercent, // 0xF7
 396     QueryPercent, // 0xF8
 397     QueryPercent, // 0xF9
 398     QueryPercent, // 0xFA
 399     QueryPercent, // 0xFB
 400     QueryPercent, // 0xFC
 401     QueryPercent, // 0xFD
 402     QueryPercent, // 0xFE
 403     QueryPercent, // 0xFF
 404 };
 405 
 406 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isC0Control(CharacterType character) { return character &lt;= 0x1F; }
 407 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isC0ControlOrSpace(CharacterType character) { return character &lt;= 0x20; }
 408 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isTabOrNewline(CharacterType character) { return character &lt;= 0xD &amp;&amp; character &gt;= 0x9 &amp;&amp; character != 0xB &amp;&amp; character != 0xC; }
 409 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInSimpleEncodeSet(CharacterType character) { return character &gt; 0x7E || isC0Control(character); }
 410 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInDefaultEncodeSet(CharacterType character) { return character &gt; 0x7E || characterClassTable[character] &amp; Default; }
 411 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isInUserInfoEncodeSet(CharacterType character) { return character &gt; 0x7E || characterClassTable[character] &amp; UserInfo; }
 412 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isPercentOrNonASCII(CharacterType character) { return !isASCII(character) || character == &#39;%&#39;; }
 413 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isSlashQuestionOrHash(CharacterType character) { return character &lt;= &#39;\\&#39; &amp;&amp; characterClassTable[character] &amp; SlashQuestionOrHash; }
 414 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isValidSchemeCharacter(CharacterType character) { return character &lt;= &#39;z&#39; &amp;&amp; characterClassTable[character] &amp; ValidScheme; }
 415 template&lt;typename CharacterType&gt; ALWAYS_INLINE static bool isForbiddenHostCodePoint(CharacterType character) { return character &lt;= &#39;]&#39; &amp;&amp; characterClassTable[character] &amp; ForbiddenHost; }
 416 ALWAYS_INLINE static bool shouldPercentEncodeQueryByte(uint8_t byte, const bool&amp; urlIsSpecial)
 417 {
 418     if (characterClassTable[byte] &amp; QueryPercent)
 419         return true;
 420     if (byte == &#39;\&#39;&#39; &amp;&amp; urlIsSpecial)
 421         return true;
 422     return false;
 423 }
 424 
 425 bool URLParser::isInUserInfoEncodeSet(UChar c)
 426 {
 427     return WTF::isInUserInfoEncodeSet(c);
 428 }
 429 
 430 template&lt;typename CharacterType, URLParser::ReportSyntaxViolation reportSyntaxViolation&gt;
 431 ALWAYS_INLINE void URLParser::advance(CodePointIterator&lt;CharacterType&gt;&amp; iterator, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
 432 {
 433     ++iterator;
 434     while (UNLIKELY(!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))) {
 435         if (reportSyntaxViolation == ReportSyntaxViolation::Yes)
 436             syntaxViolation(iteratorForSyntaxViolationPosition);
 437         ++iterator;
 438     }
 439 }
 440 
 441 template&lt;typename CharacterType&gt;
 442 bool URLParser::takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt; iterator)
 443 {
 444     if (iterator.atEnd())
 445         return false;
 446     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 447     if (iterator.atEnd())
 448         return false;
 449     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 450     return iterator.atEnd();
 451 }
 452 
 453 template&lt;typename CharacterType&gt;
 454 ALWAYS_INLINE bool URLParser::isWindowsDriveLetter(CodePointIterator&lt;CharacterType&gt; iterator)
 455 {
 456     if (iterator.atEnd() || !isASCIIAlpha(*iterator))
 457         return false;
 458     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
 459     if (iterator.atEnd())
 460         return false;
 461     if (*iterator == &#39;:&#39;)
 462         return true;
 463     if (UNLIKELY(*iterator == &#39;|&#39;))
 464         return true;
 465     return false;
 466 }
 467 
 468 ALWAYS_INLINE void URLParser::appendToASCIIBuffer(UChar32 codePoint)
 469 {
 470     ASSERT(isASCII(codePoint));
 471     if (UNLIKELY(m_didSeeSyntaxViolation))
 472         m_asciiBuffer.append(codePoint);
 473 }
 474 
 475 ALWAYS_INLINE void URLParser::appendToASCIIBuffer(const char* characters, size_t length)
 476 {
 477     if (UNLIKELY(m_didSeeSyntaxViolation))
 478         m_asciiBuffer.append(characters, length);
 479 }
 480 
 481 template&lt;typename CharacterType&gt;
 482 void URLParser::appendWindowsDriveLetter(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 483 {
 484     ASSERT(isWindowsDriveLetter(iterator));
 485     appendToASCIIBuffer(*iterator);
 486     advance(iterator);
 487     ASSERT(!iterator.atEnd());
 488     ASSERT(*iterator == &#39;:&#39; || *iterator == &#39;|&#39;);
 489     if (*iterator == &#39;|&#39;)
 490         syntaxViolation(iterator);
 491     appendToASCIIBuffer(&#39;:&#39;);
 492     advance(iterator);
 493 }
 494 
 495 bool URLParser::copyBaseWindowsDriveLetter(const URL&amp; base)
 496 {
 497     if (base.protocolIs(&quot;file&quot;)) {
 498         RELEASE_ASSERT(base.m_hostEnd + base.m_portLength &lt; base.m_string.length());
 499         if (base.m_string.is8Bit()) {
 500             const LChar* begin = base.m_string.characters8();
 501             CodePointIterator&lt;LChar&gt; c(begin + base.m_hostEnd + base.m_portLength + 1, begin + base.m_string.length());
 502             if (isWindowsDriveLetter(c)) {
 503                 appendWindowsDriveLetter(c);
 504                 return true;
 505             }
 506         } else {
 507             const UChar* begin = base.m_string.characters16();
 508             CodePointIterator&lt;UChar&gt; c(begin + base.m_hostEnd + base.m_portLength + 1, begin + base.m_string.length());
 509             if (isWindowsDriveLetter(c)) {
 510                 appendWindowsDriveLetter(c);
 511                 return true;
 512             }
 513         }
 514     }
 515     return false;
 516 }
 517 
 518 template&lt;typename CharacterType&gt;
 519 bool URLParser::shouldCopyFileURL(CodePointIterator&lt;CharacterType&gt; iterator)
 520 {
 521     if (!isWindowsDriveLetter(iterator))
 522         return true;
 523     if (iterator.atEnd())
 524         return false;
 525     advance(iterator);
 526     if (iterator.atEnd())
 527         return true;
 528     advance(iterator);
 529     if (iterator.atEnd())
 530         return true;
 531     return !isSlashQuestionOrHash(*iterator);
 532 }
 533 
 534 static void percentEncodeByte(uint8_t byte, Vector&lt;LChar&gt;&amp; buffer)
 535 {
 536     buffer.append(&#39;%&#39;);
 537     buffer.append(upperNibbleToASCIIHexDigit(byte));
 538     buffer.append(lowerNibbleToASCIIHexDigit(byte));
 539 }
 540 
 541 void URLParser::percentEncodeByte(uint8_t byte)
 542 {
 543     ASSERT(m_didSeeSyntaxViolation);
 544     appendToASCIIBuffer(&#39;%&#39;);
 545     appendToASCIIBuffer(upperNibbleToASCIIHexDigit(byte));
 546     appendToASCIIBuffer(lowerNibbleToASCIIHexDigit(byte));
 547 }
 548 
 549 const char replacementCharacterUTF8PercentEncoded[10] = &quot;%EF%BF%BD&quot;;
 550 const size_t replacementCharacterUTF8PercentEncodedLength = sizeof(replacementCharacterUTF8PercentEncoded) - 1;
 551 
 552 template&lt;bool(*isInCodeSet)(UChar32), typename CharacterType&gt;
 553 ALWAYS_INLINE void URLParser::utf8PercentEncode(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 554 {
 555     ASSERT(!iterator.atEnd());
 556     UChar32 codePoint = *iterator;
 557     if (LIKELY(isASCII(codePoint))) {
 558         if (UNLIKELY(isInCodeSet(codePoint))) {
 559             syntaxViolation(iterator);
 560             percentEncodeByte(codePoint);
 561         } else
 562             appendToASCIIBuffer(codePoint);
 563         return;
 564     }
 565     ASSERT_WITH_MESSAGE(isInCodeSet(codePoint), &quot;isInCodeSet should always return true for non-ASCII characters&quot;);
 566     syntaxViolation(iterator);
 567 
 568     if (!U_IS_UNICODE_CHAR(codePoint)) {
 569         appendToASCIIBuffer(replacementCharacterUTF8PercentEncoded, replacementCharacterUTF8PercentEncodedLength);
 570         return;
 571     }
 572 
 573     uint8_t buffer[U8_MAX_LENGTH];
 574     int32_t offset = 0;
 575     U8_APPEND_UNSAFE(buffer, offset, codePoint);
 576     for (int32_t i = 0; i &lt; offset; ++i)
 577         percentEncodeByte(buffer[i]);
 578 }
 579 
 580 template&lt;typename CharacterType&gt;
 581 ALWAYS_INLINE void URLParser::utf8QueryEncode(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
 582 {
 583     ASSERT(!iterator.atEnd());
 584     UChar32 codePoint = *iterator;
 585     if (LIKELY(isASCII(codePoint))) {
 586         if (UNLIKELY(shouldPercentEncodeQueryByte(codePoint, m_urlIsSpecial))) {
 587             syntaxViolation(iterator);
 588             percentEncodeByte(codePoint);
 589         } else
 590             appendToASCIIBuffer(codePoint);
 591         return;
 592     }
 593 
 594     syntaxViolation(iterator);
 595 
 596     if (!U_IS_UNICODE_CHAR(codePoint)) {
 597         appendToASCIIBuffer(replacementCharacterUTF8PercentEncoded, replacementCharacterUTF8PercentEncodedLength);
 598         return;
 599     }
 600 
 601     uint8_t buffer[U8_MAX_LENGTH];
 602     int32_t offset = 0;
 603     U8_APPEND_UNSAFE(buffer, offset, codePoint);
 604     for (int32_t i = 0; i &lt; offset; ++i) {
 605         auto byte = buffer[i];
 606         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 607             percentEncodeByte(byte);
 608         else
 609             appendToASCIIBuffer(byte);
 610     }
 611 }
 612 
 613 template&lt;typename CharacterType&gt;
 614 void URLParser::encodeNonUTF8Query(const Vector&lt;UChar&gt;&amp; source, const URLTextEncoding&amp; encoding, CodePointIterator&lt;CharacterType&gt; iterator)
 615 {
 616     auto encoded = encoding.encodeForURLParsing(StringView(source.data(), source.size()));
 617     auto* data = encoded.data();
 618     size_t length = encoded.size();
 619 
 620     if (!length == !iterator.atEnd()) {
 621         syntaxViolation(iterator);
 622         return;
 623     }
 624 
 625     size_t i = 0;
 626     for (; i &lt; length; ++i) {
 627         ASSERT(!iterator.atEnd());
 628         uint8_t byte = data[i];
 629         if (UNLIKELY(byte != *iterator)) {
 630             syntaxViolation(iterator);
 631             break;
 632         }
 633         if (UNLIKELY(shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))) {
 634             syntaxViolation(iterator);
 635             break;
 636         }
 637         appendToASCIIBuffer(byte);
 638         ++iterator;
 639     }
 640     while (!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))
 641         ++iterator;
 642     ASSERT((i == length) == iterator.atEnd());
 643     for (; i &lt; length; ++i) {
 644         ASSERT(m_didSeeSyntaxViolation);
 645         uint8_t byte = data[i];
 646         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 647             percentEncodeByte(byte);
 648         else
 649             appendToASCIIBuffer(byte);
 650     }
 651 }
 652 
 653 Optional&lt;uint16_t&gt; URLParser::defaultPortForProtocol(StringView scheme)
 654 {
 655     static constexpr uint16_t ftpPort = 21;
 656     static constexpr uint16_t httpPort = 80;
 657     static constexpr uint16_t httpsPort = 443;
 658     static constexpr uint16_t wsPort = 80;
 659     static constexpr uint16_t wssPort = 443;
 660 
 661     auto length = scheme.length();
 662     if (!length)
 663         return WTF::nullopt;
 664     switch (scheme[0]) {
 665     case &#39;w&#39;:
 666         switch (length) {
 667         case 2:
 668             if (scheme[1] == &#39;s&#39;)
 669                 return wsPort;
 670             return WTF::nullopt;
 671         case 3:
 672             if (scheme[1] == &#39;s&#39;
 673                 &amp;&amp; scheme[2] == &#39;s&#39;)
 674                 return wssPort;
 675             return WTF::nullopt;
 676         default:
 677             return false;
 678         }
 679     case &#39;h&#39;:
 680         switch (length) {
 681         case 4:
 682             if (scheme[1] == &#39;t&#39;
 683                 &amp;&amp; scheme[2] == &#39;t&#39;
 684                 &amp;&amp; scheme[3] == &#39;p&#39;)
 685                 return httpPort;
 686             return WTF::nullopt;
 687         case 5:
 688             if (scheme[1] == &#39;t&#39;
 689                 &amp;&amp; scheme[2] == &#39;t&#39;
 690                 &amp;&amp; scheme[3] == &#39;p&#39;
 691                 &amp;&amp; scheme[4] == &#39;s&#39;)
 692                 return httpsPort;
 693             return WTF::nullopt;
 694         default:
 695             return WTF::nullopt;
 696         }
 697     case &#39;f&#39;:
 698         if (length == 3
 699             &amp;&amp; scheme[1] == &#39;t&#39;
 700             &amp;&amp; scheme[2] == &#39;p&#39;)
 701             return ftpPort;
 702         return WTF::nullopt;
 703     default:
 704         return WTF::nullopt;
 705     }
 706 }
 707 
 708 enum class Scheme {
 709 #if PLATFORM(JAVA)
 710     JAR,
 711 #endif
 712     WS,
 713     WSS,
 714     File,
 715     FTP,
 716     HTTP,
 717     HTTPS,
 718     NonSpecial
 719 };
 720 
 721 ALWAYS_INLINE static Scheme scheme(StringView scheme)
 722 {
 723     auto length = scheme.length();
 724     if (!length)
 725         return Scheme::NonSpecial;
 726     switch (scheme[0]) {
 727     case &#39;f&#39;:
 728         switch (length) {
 729         case 3:
 730             if (scheme[1] == &#39;t&#39;
 731                 &amp;&amp; scheme[2] == &#39;p&#39;)
 732                 return Scheme::FTP;
 733             return Scheme::NonSpecial;
 734         case 4:
 735             if (scheme[1] == &#39;i&#39;
 736                 &amp;&amp; scheme[2] == &#39;l&#39;
 737                 &amp;&amp; scheme[3] == &#39;e&#39;)
 738                 return Scheme::File;
 739             return Scheme::NonSpecial;
 740         default:
 741             return Scheme::NonSpecial;
 742         }
 743     case &#39;h&#39;:
 744         switch (length) {
 745         case 4:
 746             if (scheme[1] == &#39;t&#39;
 747                 &amp;&amp; scheme[2] == &#39;t&#39;
 748                 &amp;&amp; scheme[3] == &#39;p&#39;)
 749                 return Scheme::HTTP;
 750             return Scheme::NonSpecial;
 751         case 5:
 752             if (scheme[1] == &#39;t&#39;
 753                 &amp;&amp; scheme[2] == &#39;t&#39;
 754                 &amp;&amp; scheme[3] == &#39;p&#39;
 755                 &amp;&amp; scheme[4] == &#39;s&#39;)
 756                 return Scheme::HTTPS;
 757             return Scheme::NonSpecial;
 758         default:
 759             return Scheme::NonSpecial;
 760         }
 761     case &#39;w&#39;:
 762         switch (length) {
 763         case 2:
 764             if (scheme[1] == &#39;s&#39;)
 765                 return Scheme::WS;
 766             return Scheme::NonSpecial;
 767         case 3:
 768             if (scheme[1] == &#39;s&#39;
 769                 &amp;&amp; scheme[2] == &#39;s&#39;)
 770                 return Scheme::WSS;
 771             return Scheme::NonSpecial;
 772         default:
 773             return Scheme::NonSpecial;
 774         }
 775 #if PLATFORM(JAVA)
 776      case &#39;j&#39;:
 777         if (length == 3 &amp;&amp; scheme[1] == &#39;a&#39; &amp;&amp; scheme[2] == &#39;r&#39;)
 778             return Scheme::JAR;
 779         return Scheme::NonSpecial;
 780 #endif
 781     default:
 782         return Scheme::NonSpecial;
 783     }
 784 }
 785 
 786 Optional&lt;String&gt; URLParser::maybeCanonicalizeScheme(const String&amp; scheme)
 787 {
 788     if (scheme.isEmpty())
 789         return WTF::nullopt;
 790 
 791     if (!isASCIIAlpha(scheme[0]))
 792         return WTF::nullopt;
 793 
 794     for (size_t i = 1; i &lt; scheme.length(); ++i) {
 795         if (isASCIIAlphanumeric(scheme[i]) || scheme[i] == &#39;+&#39; || scheme[i] == &#39;-&#39; || scheme[i] == &#39;.&#39;)
 796             continue;
 797         return WTF::nullopt;
 798     }
 799 
 800     return scheme.convertToASCIILowercase();
 801 }
 802 
 803 bool URLParser::isSpecialScheme(const String&amp; schemeArg)
 804 {
 805     return scheme(schemeArg) != Scheme::NonSpecial;
 806 }
 807 
 808 enum class URLParser::URLPart {
 809     SchemeEnd,
 810     UserStart,
 811     UserEnd,
 812     PasswordEnd,
 813     HostEnd,
 814     PortEnd,
 815     PathAfterLastSlash,
 816     PathEnd,
 817     QueryEnd,
 818 };
 819 
 820 size_t URLParser::urlLengthUntilPart(const URL&amp; url, URLPart part)
 821 {
 822     switch (part) {
 823     case URLPart::QueryEnd:
 824         return url.m_queryEnd;
 825     case URLPart::PathEnd:
 826         return url.m_pathEnd;
 827     case URLPart::PathAfterLastSlash:
 828         return url.m_pathAfterLastSlash;
 829     case URLPart::PortEnd:
 830         return url.m_hostEnd + url.m_portLength;
 831     case URLPart::HostEnd:
 832         return url.m_hostEnd;
 833     case URLPart::PasswordEnd:
 834         return url.m_passwordEnd;
 835     case URLPart::UserEnd:
 836         return url.m_userEnd;
 837     case URLPart::UserStart:
 838         return url.m_userStart;
 839     case URLPart::SchemeEnd:
 840         return url.m_schemeEnd;
 841     }
 842     ASSERT_NOT_REACHED();
 843     return 0;
 844 }
 845 
 846 void URLParser::copyASCIIStringUntil(const String&amp; string, size_t length)
 847 {
 848     RELEASE_ASSERT(length &lt;= string.length());
 849     if (string.isNull())
 850         return;
 851     ASSERT(m_asciiBuffer.isEmpty());
 852     if (string.is8Bit())
 853         appendToASCIIBuffer(string.characters8(), length);
 854     else {
 855         const UChar* characters = string.characters16();
 856         for (size_t i = 0; i &lt; length; ++i) {
 857             UChar c = characters[i];
 858             ASSERT_WITH_SECURITY_IMPLICATION(isASCII(c));
 859             appendToASCIIBuffer(c);
 860         }
 861     }
 862 }
 863 
 864 template&lt;typename CharacterType&gt;
 865 void URLParser::copyURLPartsUntil(const URL&amp; base, URLPart part, const CodePointIterator&lt;CharacterType&gt;&amp; iterator, const URLTextEncoding*&amp; nonUTF8QueryEncoding)
 866 {
 867     syntaxViolation(iterator);
 868 
 869     m_asciiBuffer.clear();
 870     copyASCIIStringUntil(base.m_string, urlLengthUntilPart(base, part));
 871     switch (part) {
 872     case URLPart::QueryEnd:
 873         m_url.m_queryEnd = base.m_queryEnd;
 874         FALLTHROUGH;
 875     case URLPart::PathEnd:
 876         m_url.m_pathEnd = base.m_pathEnd;
 877         FALLTHROUGH;
 878     case URLPart::PathAfterLastSlash:
 879         m_url.m_pathAfterLastSlash = base.m_pathAfterLastSlash;
 880         FALLTHROUGH;
 881     case URLPart::PortEnd:
 882         m_url.m_portLength = base.m_portLength;
 883         FALLTHROUGH;
 884     case URLPart::HostEnd:
 885         m_url.m_hostEnd = base.m_hostEnd;
 886         FALLTHROUGH;
 887     case URLPart::PasswordEnd:
 888         m_url.m_passwordEnd = base.m_passwordEnd;
 889         FALLTHROUGH;
 890     case URLPart::UserEnd:
 891         m_url.m_userEnd = base.m_userEnd;
 892         FALLTHROUGH;
 893     case URLPart::UserStart:
 894         m_url.m_userStart = base.m_userStart;
 895         FALLTHROUGH;
 896     case URLPart::SchemeEnd:
 897         m_url.m_isValid = base.m_isValid;
 898         m_url.m_protocolIsInHTTPFamily = base.m_protocolIsInHTTPFamily;
 899         m_url.m_schemeEnd = base.m_schemeEnd;
 900     }
 901     switch (scheme(StringView(m_asciiBuffer.data(), m_url.m_schemeEnd))) {
 902 #if PLATFORM(JAVA)
 903     case Scheme::JAR:
 904         break;
 905 #endif
 906     case Scheme::WS:
 907     case Scheme::WSS:
 908         nonUTF8QueryEncoding = nullptr;
 909         m_urlIsSpecial = true;
 910         return;
 911     case Scheme::File:
 912         m_urlIsFile = true;
 913         FALLTHROUGH;
 914     case Scheme::FTP:
 915     case Scheme::HTTP:
 916     case Scheme::HTTPS:
 917         m_urlIsSpecial = true;
 918         return;
 919     case Scheme::NonSpecial:
 920         m_urlIsSpecial = false;
 921         nonUTF8QueryEncoding = nullptr;
 922         return;
 923     }
 924     ASSERT_NOT_REACHED();
 925 }
 926 
 927 static const char dotASCIICode[2] = {&#39;2&#39;, &#39;e&#39;};
 928 
 929 template&lt;typename CharacterType&gt;
 930 ALWAYS_INLINE bool URLParser::isSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 931 {
 932     if (c.atEnd())
 933         return false;
 934     if (*c == &#39;.&#39;) {
 935         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 936         return c.atEnd() || isSlashQuestionOrHash(*c);
 937     }
 938     if (*c != &#39;%&#39;)
 939         return false;
 940     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 941     if (c.atEnd() || *c != dotASCIICode[0])
 942         return false;
 943     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 944     if (c.atEnd())
 945         return false;
 946     if (toASCIILower(*c) == dotASCIICode[1]) {
 947         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 948         return c.atEnd() || isSlashQuestionOrHash(*c);
 949     }
 950     return false;
 951 }
 952 
 953 template&lt;typename CharacterType&gt;
 954 ALWAYS_INLINE bool URLParser::isDoubleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 955 {
 956     if (c.atEnd())
 957         return false;
 958     if (*c == &#39;.&#39;) {
 959         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 960         return isSingleDotPathSegment(c);
 961     }
 962     if (*c != &#39;%&#39;)
 963         return false;
 964     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 965     if (c.atEnd() || *c != dotASCIICode[0])
 966         return false;
 967     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 968     if (c.atEnd())
 969         return false;
 970     if (toASCIILower(*c) == dotASCIICode[1]) {
 971         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(c);
 972         return isSingleDotPathSegment(c);
 973     }
 974     return false;
 975 }
 976 
 977 template&lt;typename CharacterType&gt;
 978 void URLParser::consumeSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt;&amp; c)
 979 {
 980     ASSERT(isSingleDotPathSegment(c));
 981     if (*c == &#39;.&#39;) {
 982         advance(c);
 983         if (!c.atEnd()) {
 984             if (*c == &#39;/&#39; || *c == &#39;\\&#39;)
 985                 advance(c);
 986             else
 987                 ASSERT(*c == &#39;?&#39; || *c == &#39;#&#39;);
 988         }
 989     } else {
 990         ASSERT(*c == &#39;%&#39;);
 991         advance(c);
 992         ASSERT(*c == dotASCIICode[0]);
 993         advance(c);
 994         ASSERT(toASCIILower(*c) == dotASCIICode[1]);
 995         advance(c);
 996         if (!c.atEnd()) {
 997             if (*c == &#39;/&#39; || *c == &#39;\\&#39;)
 998                 advance(c);
 999             else
1000                 ASSERT(*c == &#39;?&#39; || *c == &#39;#&#39;);
1001         }
1002     }
1003 }
1004 
1005 template&lt;typename CharacterType&gt;
1006 void URLParser::consumeDoubleDotPathSegment(CodePointIterator&lt;CharacterType&gt;&amp; c)
1007 {
1008     ASSERT(isDoubleDotPathSegment(c));
1009     if (*c == &#39;.&#39;)
1010         advance(c);
1011     else {
1012         ASSERT(*c == &#39;%&#39;);
1013         advance(c);
1014         ASSERT(*c == dotASCIICode[0]);
1015         advance(c);
1016         ASSERT(toASCIILower(*c) == dotASCIICode[1]);
1017         advance(c);
1018     }
1019     consumeSingleDotPathSegment(c);
1020 }
1021 
1022 bool URLParser::shouldPopPath(unsigned newPathAfterLastSlash)
1023 {
1024     ASSERT(m_didSeeSyntaxViolation);
1025     if (!m_urlIsFile)
1026         return true;
1027 
1028     ASSERT(m_url.m_pathAfterLastSlash &lt;= m_asciiBuffer.size());
1029     CodePointIterator&lt;LChar&gt; componentToPop(&amp;m_asciiBuffer[newPathAfterLastSlash], &amp;m_asciiBuffer[0] + m_url.m_pathAfterLastSlash);
1030     if (newPathAfterLastSlash == m_url.m_hostEnd + m_url.m_portLength + 1 &amp;&amp; isWindowsDriveLetter(componentToPop))
1031         return false;
1032     return true;
1033 }
1034 
1035 void URLParser::popPath()
1036 {
1037     ASSERT(m_didSeeSyntaxViolation);
1038     if (m_url.m_pathAfterLastSlash &gt; m_url.m_hostEnd + m_url.m_portLength + 1) {
1039         auto newPathAfterLastSlash = m_url.m_pathAfterLastSlash - 1;
1040         if (m_asciiBuffer[newPathAfterLastSlash] == &#39;/&#39;)
1041             newPathAfterLastSlash--;
1042         while (newPathAfterLastSlash &gt; m_url.m_hostEnd + m_url.m_portLength &amp;&amp; m_asciiBuffer[newPathAfterLastSlash] != &#39;/&#39;)
1043             newPathAfterLastSlash--;
1044         newPathAfterLastSlash++;
1045         if (shouldPopPath(newPathAfterLastSlash))
1046             m_url.m_pathAfterLastSlash = newPathAfterLastSlash;
1047     }
1048     m_asciiBuffer.resize(m_url.m_pathAfterLastSlash);
1049 }
1050 
1051 template&lt;typename CharacterType&gt;
1052 void URLParser::syntaxViolation(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
1053 {
1054     if (m_didSeeSyntaxViolation)
1055         return;
1056     m_didSeeSyntaxViolation = true;
1057 
1058     ASSERT(m_asciiBuffer.isEmpty());
1059     size_t codeUnitsToCopy = iterator.codeUnitsSince(reinterpret_cast&lt;const CharacterType*&gt;(m_inputBegin));
1060     RELEASE_ASSERT(codeUnitsToCopy &lt;= m_inputString.length());
1061     m_asciiBuffer.reserveCapacity(m_inputString.length());
1062     for (size_t i = 0; i &lt; codeUnitsToCopy; ++i) {
1063         ASSERT(isASCII(m_inputString[i]));
1064         m_asciiBuffer.uncheckedAppend(m_inputString[i]);
1065     }
1066 }
1067 
1068 void URLParser::failure()
1069 {
1070     m_url.invalidate();
1071     m_url.m_string = m_inputString;
1072 }
1073 
1074 template&lt;typename CharacterType&gt;
1075 bool URLParser::checkLocalhostCodePoint(CodePointIterator&lt;CharacterType&gt;&amp; iterator, UChar32 codePoint)
1076 {
1077     if (iterator.atEnd() || toASCIILower(*iterator) != codePoint)
1078         return false;
1079     advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
1080     return true;
1081 }
1082 
1083 template&lt;typename CharacterType&gt;
1084 bool URLParser::isAtLocalhost(CodePointIterator&lt;CharacterType&gt; iterator)
1085 {
1086     if (!checkLocalhostCodePoint(iterator, &#39;l&#39;))
1087         return false;
1088     if (!checkLocalhostCodePoint(iterator, &#39;o&#39;))
1089         return false;
1090     if (!checkLocalhostCodePoint(iterator, &#39;c&#39;))
1091         return false;
1092     if (!checkLocalhostCodePoint(iterator, &#39;a&#39;))
1093         return false;
1094     if (!checkLocalhostCodePoint(iterator, &#39;l&#39;))
1095         return false;
1096     if (!checkLocalhostCodePoint(iterator, &#39;h&#39;))
1097         return false;
1098     if (!checkLocalhostCodePoint(iterator, &#39;o&#39;))
1099         return false;
1100     if (!checkLocalhostCodePoint(iterator, &#39;s&#39;))
1101         return false;
1102     if (!checkLocalhostCodePoint(iterator, &#39;t&#39;))
1103         return false;
1104     return iterator.atEnd();
1105 }
1106 
1107 bool URLParser::isLocalhost(StringView view)
1108 {
1109     if (view.is8Bit())
1110         return isAtLocalhost(CodePointIterator&lt;LChar&gt;(view.characters8(), view.characters8() + view.length()));
1111     return isAtLocalhost(CodePointIterator&lt;UChar&gt;(view.characters16(), view.characters16() + view.length()));
1112 }
1113 
1114 ALWAYS_INLINE StringView URLParser::parsedDataView(size_t start, size_t length)
1115 {
1116     if (UNLIKELY(m_didSeeSyntaxViolation)) {
1117         ASSERT(start + length &lt;= m_asciiBuffer.size());
1118         return StringView(m_asciiBuffer.data() + start, length);
1119     }
1120     ASSERT(start + length &lt;= m_inputString.length());
1121     return StringView(m_inputString).substring(start, length);
1122 }
1123 
1124 ALWAYS_INLINE UChar URLParser::parsedDataView(size_t position)
1125 {
1126     if (UNLIKELY(m_didSeeSyntaxViolation))
1127         return m_asciiBuffer[position];
1128     return m_inputString[position];
1129 }
1130 
1131 template&lt;typename CharacterType&gt;
1132 ALWAYS_INLINE size_t URLParser::currentPosition(const CodePointIterator&lt;CharacterType&gt;&amp; iterator)
1133 {
1134     if (UNLIKELY(m_didSeeSyntaxViolation))
1135         return m_asciiBuffer.size();
1136 
1137     return iterator.codeUnitsSince(reinterpret_cast&lt;const CharacterType*&gt;(m_inputBegin));
1138 }
1139 
1140 URLParser::URLParser(const String&amp; input, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1141     : m_inputString(input)
1142 {
1143     if (input.isNull()) {
1144         if (base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1145             m_url = base;
1146             m_url.removeFragmentIdentifier();
1147         }
1148         return;
1149     }
1150 
1151     if (input.is8Bit()) {
1152         m_inputBegin = input.characters8();
1153         parse(input.characters8(), input.length(), base, nonUTF8QueryEncoding);
1154     } else {
1155         m_inputBegin = input.characters16();
1156         parse(input.characters16(), input.length(), base, nonUTF8QueryEncoding);
1157     }
1158 
1159     ASSERT(!m_url.m_isValid
1160         || m_didSeeSyntaxViolation == (m_url.string() != input)
1161         || (input.isAllSpecialCharacters&lt;isC0ControlOrSpace&gt;()
1162             &amp;&amp; m_url.m_string == base.m_string.left(base.m_queryEnd)));
1163     ASSERT(internalValuesConsistent(m_url));
1164 #if ASSERT_ENABLED
1165     if (!m_didSeeSyntaxViolation) {
1166         // Force a syntax violation at the beginning to make sure we get the same result.
1167         URLParser parser(makeString(&quot; &quot;, input), base, nonUTF8QueryEncoding);
1168         URL parsed = parser.result();
1169         if (parsed.isValid())
1170             ASSERT(allValuesEqual(parser.result(), m_url));
1171     }
1172 #endif // ASSERT_ENABLED
1173 }
1174 
1175 template&lt;typename CharacterType&gt;
1176 void URLParser::parse(const CharacterType* input, const unsigned length, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1177 {
1178     URL_PARSER_LOG(&quot;Parsing URL &lt;%s&gt; base &lt;%s&gt;&quot;, String(input, length).utf8().data(), base.string().utf8().data());
1179     m_url = { };
1180     ASSERT(m_asciiBuffer.isEmpty());
1181 
1182     Vector&lt;UChar&gt; queryBuffer;
1183 
1184     unsigned endIndex = length;
1185     while (UNLIKELY(endIndex &amp;&amp; isC0ControlOrSpace(input[endIndex - 1]))) {
1186         syntaxViolation(CodePointIterator&lt;CharacterType&gt;(input, input));
1187         endIndex--;
1188     }
1189     CodePointIterator&lt;CharacterType&gt; c(input, input + endIndex);
1190     CodePointIterator&lt;CharacterType&gt; authorityOrHostBegin;
1191     CodePointIterator&lt;CharacterType&gt; queryBegin;
1192     while (UNLIKELY(!c.atEnd() &amp;&amp; isC0ControlOrSpace(*c))) {
1193         syntaxViolation(c);
1194         ++c;
1195     }
1196     auto beginAfterControlAndSpace = c;
1197 
1198     enum class State : uint8_t {
1199         SchemeStart,
1200         Scheme,
1201         NoScheme,
1202         SpecialRelativeOrAuthority,
1203         PathOrAuthority,
1204         Relative,
1205         RelativeSlash,
1206         SpecialAuthoritySlashes,
1207         SpecialAuthorityIgnoreSlashes,
1208         AuthorityOrHost,
1209         Host,
1210         File,
1211         FileSlash,
1212         FileHost,
1213         PathStart,
1214         Path,
1215         CannotBeABaseURLPath,
1216         UTF8Query,
1217         NonUTF8Query,
1218         Fragment,
1219     };
1220 
1221 #define LOG_STATE(x) URL_PARSER_LOG(&quot;State %s, code point %c, parsed data &lt;%s&gt; size %zu&quot;, x, *c, parsedDataView(0, currentPosition(c)).utf8().data(), currentPosition(c))
1222 #define LOG_FINAL_STATE(x) URL_PARSER_LOG(&quot;Final State: %s&quot;, x)
1223 
1224     State state = State::SchemeStart;
1225     while (!c.atEnd()) {
1226         if (UNLIKELY(isTabOrNewline(*c))) {
1227             syntaxViolation(c);
1228             ++c;
1229             continue;
1230         }
1231 
1232         switch (state) {
1233         case State::SchemeStart:
1234             LOG_STATE(&quot;SchemeStart&quot;);
1235             if (isASCIIAlpha(*c)) {
1236                 if (UNLIKELY(isASCIIUpper(*c)))
1237                     syntaxViolation(c);
1238                 appendToASCIIBuffer(toASCIILower(*c));
1239                 advance(c);
1240                 if (c.atEnd()) {
1241                     m_asciiBuffer.clear();
1242                     state = State::NoScheme;
1243                     c = beginAfterControlAndSpace;
1244                     break;
1245                 }
1246                 state = State::Scheme;
1247             } else
1248                 state = State::NoScheme;
1249             break;
1250         case State::Scheme:
1251             LOG_STATE(&quot;Scheme&quot;);
1252             if (isValidSchemeCharacter(*c)) {
1253                 if (UNLIKELY(isASCIIUpper(*c)))
1254                     syntaxViolation(c);
1255                 appendToASCIIBuffer(toASCIILower(*c));
1256             } else if (*c == &#39;:&#39;) {
1257                 unsigned schemeEnd = currentPosition(c);
1258                 if (schemeEnd &gt; URL::maxSchemeLength) {
1259                     failure();
1260                     return;
1261                 }
1262                 m_url.m_schemeEnd = schemeEnd;
1263                 StringView urlScheme = parsedDataView(0, m_url.m_schemeEnd);
1264                 appendToASCIIBuffer(&#39;:&#39;);
1265                 switch (scheme(urlScheme)) {
1266 #if PLATFORM(JAVA)
1267                 // JAR can have complex protocols like &quot;jar:file&quot; or &quot;jar:http://&quot;
1268                 // Just skip the jar: part, rest will be parsed like other
1269                 // scheme.
1270                 case Scheme::JAR:
1271                     ++c;
1272                     break;
1273 #endif
1274                 case Scheme::File:
1275                     m_urlIsSpecial = true;
1276                     m_urlIsFile = true;
1277                     state = State::File;
1278                     ++c;
1279                     break;
1280                 case Scheme::WS:
1281                 case Scheme::WSS:
1282                     nonUTF8QueryEncoding = nullptr;
1283                     m_urlIsSpecial = true;
1284                     if (base.protocolIs(urlScheme))
1285                         state = State::SpecialRelativeOrAuthority;
1286                     else
1287                         state = State::SpecialAuthoritySlashes;
1288                     ++c;
1289                     break;
1290                 case Scheme::HTTP:
1291                 case Scheme::HTTPS:
1292                     m_url.m_protocolIsInHTTPFamily = true;
1293                     FALLTHROUGH;
1294                 case Scheme::FTP:
1295                     m_urlIsSpecial = true;
1296                     if (base.protocolIs(urlScheme))
1297                         state = State::SpecialRelativeOrAuthority;
1298                     else
1299                         state = State::SpecialAuthoritySlashes;
1300                     ++c;
1301                     break;
1302                 case Scheme::NonSpecial:
1303                     nonUTF8QueryEncoding = nullptr;
1304                     auto maybeSlash = c;
1305                     advance(maybeSlash);
1306                     if (!maybeSlash.atEnd() &amp;&amp; *maybeSlash == &#39;/&#39;) {
1307                         appendToASCIIBuffer(&#39;/&#39;);
1308                         c = maybeSlash;
1309                         state = State::PathOrAuthority;
1310                         ASSERT(*c == &#39;/&#39;);
1311                         ++c;
1312                         m_url.m_userStart = currentPosition(c);
1313                     } else {
1314                         ++c;
1315                         m_url.m_userStart = currentPosition(c);
1316                         m_url.m_userEnd = m_url.m_userStart;
1317                         m_url.m_passwordEnd = m_url.m_userStart;
1318                         m_url.m_hostEnd = m_url.m_userStart;
1319                         m_url.m_portLength = 0;
1320                         m_url.m_pathAfterLastSlash = m_url.m_userStart;
1321                         m_url.m_cannotBeABaseURL = true;
1322                         state = State::CannotBeABaseURLPath;
1323                     }
1324                     break;
1325                 }
1326                 break;
1327             } else {
1328                 m_asciiBuffer.clear();
1329                 state = State::NoScheme;
1330                 c = beginAfterControlAndSpace;
1331                 break;
1332             }
1333             advance(c);
1334             if (c.atEnd()) {
1335                 m_asciiBuffer.clear();
1336                 state = State::NoScheme;
1337                 c = beginAfterControlAndSpace;
1338             }
1339             break;
1340         case State::NoScheme:
1341             LOG_STATE(&quot;NoScheme&quot;);
1342             if (!base.isValid() || (base.m_cannotBeABaseURL &amp;&amp; *c != &#39;#&#39;)) {
1343                 failure();
1344                 return;
1345             }
1346             if (base.m_cannotBeABaseURL &amp;&amp; *c == &#39;#&#39;) {
1347                 copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1348                 state = State::Fragment;
1349                 appendToASCIIBuffer(&#39;#&#39;);
1350                 ++c;
1351                 break;
1352             }
1353             if (!base.protocolIs(&quot;file&quot;)) {
1354                 state = State::Relative;
1355                 break;
1356             }
1357             copyURLPartsUntil(base, URLPart::SchemeEnd, c, nonUTF8QueryEncoding);
1358             appendToASCIIBuffer(&#39;:&#39;);
1359             state = State::File;
1360             break;
1361         case State::SpecialRelativeOrAuthority:
1362             LOG_STATE(&quot;SpecialRelativeOrAuthority&quot;);
1363             if (*c == &#39;/&#39;) {
1364                 appendToASCIIBuffer(&#39;/&#39;);
1365                 advance(c);
1366                 if (c.atEnd()) {
1367                     failure();
1368                     return;
1369                 }
1370                 if (*c == &#39;/&#39;) {
1371                     appendToASCIIBuffer(&#39;/&#39;);
1372                     state = State::SpecialAuthorityIgnoreSlashes;
1373                     ++c;
1374                 } else
1375                     state = State::RelativeSlash;
1376             } else
1377                 state = State::Relative;
1378             break;
1379         case State::PathOrAuthority:
1380             LOG_STATE(&quot;PathOrAuthority&quot;);
1381             if (*c == &#39;/&#39;) {
1382                 appendToASCIIBuffer(&#39;/&#39;);
1383                 state = State::AuthorityOrHost;
1384                 advance(c);
1385                 m_url.m_userStart = currentPosition(c);
1386                 authorityOrHostBegin = c;
1387             } else {
1388                 ASSERT(parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1389                 m_url.m_userStart = currentPosition(c) - 1;
1390                 m_url.m_userEnd = m_url.m_userStart;
1391                 m_url.m_passwordEnd = m_url.m_userStart;
1392                 m_url.m_hostEnd = m_url.m_userStart;
1393                 m_url.m_portLength = 0;
1394                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1395                 state = State::Path;
1396             }
1397             break;
1398         case State::Relative:
1399             LOG_STATE(&quot;Relative&quot;);
1400             switch (*c) {
1401             case &#39;/&#39;:
1402             case &#39;\\&#39;:
1403                 state = State::RelativeSlash;
1404                 ++c;
1405                 break;
1406             case &#39;?&#39;:
1407                 copyURLPartsUntil(base, URLPart::PathEnd, c, nonUTF8QueryEncoding);
1408                 appendToASCIIBuffer(&#39;?&#39;);
1409                 ++c;
1410                 if (nonUTF8QueryEncoding) {
1411                     queryBegin = c;
1412                     state = State::NonUTF8Query;
1413                 } else
1414                     state = State::UTF8Query;
1415                 break;
1416             case &#39;#&#39;:
1417                 copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1418                 appendToASCIIBuffer(&#39;#&#39;);
1419                 state = State::Fragment;
1420                 ++c;
1421                 break;
1422             default:
1423                 copyURLPartsUntil(base, URLPart::PathAfterLastSlash, c, nonUTF8QueryEncoding);
1424                 if (currentPosition(c) &amp;&amp; parsedDataView(currentPosition(c) - 1) != &#39;/&#39;) {
1425                     appendToASCIIBuffer(&#39;/&#39;);
1426                     m_url.m_pathAfterLastSlash = currentPosition(c);
1427                 }
1428                 state = State::Path;
1429                 break;
1430             }
1431             break;
1432         case State::RelativeSlash:
1433             LOG_STATE(&quot;RelativeSlash&quot;);
1434             if (*c == &#39;/&#39; || *c == &#39;\\&#39;) {
1435                 ++c;
1436                 copyURLPartsUntil(base, URLPart::SchemeEnd, c, nonUTF8QueryEncoding);
1437                 appendToASCIIBuffer(&quot;://&quot;, 3);
1438                 if (m_urlIsSpecial)
1439                     state = State::SpecialAuthorityIgnoreSlashes;
1440                 else {
1441                     m_url.m_userStart = currentPosition(c);
1442                     state = State::AuthorityOrHost;
1443                     authorityOrHostBegin = c;
1444                 }
1445             } else {
1446                 copyURLPartsUntil(base, URLPart::PortEnd, c, nonUTF8QueryEncoding);
1447                 appendToASCIIBuffer(&#39;/&#39;);
1448                 m_url.m_pathAfterLastSlash = base.m_hostEnd + base.m_portLength + 1;
1449                 state = State::Path;
1450             }
1451             break;
1452         case State::SpecialAuthoritySlashes:
1453             LOG_STATE(&quot;SpecialAuthoritySlashes&quot;);
1454             if (LIKELY(*c == &#39;/&#39; || *c == &#39;\\&#39;)) {
1455                 if (UNLIKELY(*c == &#39;\\&#39;))
1456                     syntaxViolation(c);
1457                 appendToASCIIBuffer(&#39;/&#39;);
1458                 advance(c);
1459                 if (LIKELY(!c.atEnd() &amp;&amp; (*c == &#39;/&#39; || *c == &#39;\\&#39;))) {
1460                     if (UNLIKELY(*c == &#39;\\&#39;))
1461                         syntaxViolation(c);
1462                     ++c;
1463                     appendToASCIIBuffer(&#39;/&#39;);
1464                 } else {
1465                     syntaxViolation(c);
1466                     appendToASCIIBuffer(&#39;/&#39;);
1467                 }
1468             } else {
1469                 syntaxViolation(c);
1470                 appendToASCIIBuffer(&quot;//&quot;, 2);
1471             }
1472             state = State::SpecialAuthorityIgnoreSlashes;
1473             break;
1474         case State::SpecialAuthorityIgnoreSlashes:
1475             LOG_STATE(&quot;SpecialAuthorityIgnoreSlashes&quot;);
1476             if (*c == &#39;/&#39; || *c == &#39;\\&#39;) {
1477                 syntaxViolation(c);
1478                 ++c;
1479             } else {
1480                 m_url.m_userStart = currentPosition(c);
1481                 state = State::AuthorityOrHost;
1482                 authorityOrHostBegin = c;
1483             }
1484             break;
1485         case State::AuthorityOrHost:
1486             do {
1487                 LOG_STATE(&quot;AuthorityOrHost&quot;);
1488                 if (*c == &#39;@&#39;) {
1489                     auto lastAt = c;
1490                     auto findLastAt = c;
1491                     while (!findLastAt.atEnd()) {
1492                         URL_PARSER_LOG(&quot;Finding last @: %c&quot;, *findLastAt);
1493                         if (*findLastAt == &#39;@&#39;)
1494                             lastAt = findLastAt;
1495                         bool isSlash = *findLastAt == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *findLastAt == &#39;\\&#39;);
1496                         if (isSlash || *findLastAt == &#39;?&#39; || *findLastAt == &#39;#&#39;)
1497                             break;
1498                         ++findLastAt;
1499                     }
1500                     parseAuthority(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, lastAt));
1501                     c = lastAt;
1502                     advance(c);
1503                     authorityOrHostBegin = c;
1504                     state = State::Host;
1505                     m_hostHasPercentOrNonASCII = false;
1506                     break;
1507                 }
1508                 bool isSlash = *c == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;);
1509                 if (isSlash || *c == &#39;?&#39; || *c == &#39;#&#39;) {
1510                     auto iterator = CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c);
1511                     if (iterator.atEnd()) {
1512                         if (m_urlIsSpecial)
1513                             return failure();
1514                         m_url.m_userEnd = currentPosition(c);
1515                         m_url.m_passwordEnd = m_url.m_userEnd;
1516                         m_url.m_hostEnd = m_url.m_userEnd;
1517                         m_url.m_portLength = 0;
1518                         m_url.m_pathAfterLastSlash = m_url.m_userEnd;
1519                     } else {
1520                         m_url.m_userEnd = currentPosition(authorityOrHostBegin);
1521                         m_url.m_passwordEnd = m_url.m_userEnd;
1522                         if (!parseHostAndPort(iterator)) {
1523                             failure();
1524                             return;
1525                         }
1526                         if (UNLIKELY(!isSlash)) {
1527                             if (m_urlIsSpecial) {
1528                                 syntaxViolation(c);
1529                                 appendToASCIIBuffer(&#39;/&#39;);
1530                             }
1531                             m_url.m_pathAfterLastSlash = currentPosition(c);
1532                         }
1533                     }
1534                     state = State::Path;
1535                     break;
1536                 }
1537                 if (isPercentOrNonASCII(*c))
1538                     m_hostHasPercentOrNonASCII = true;
1539                 ++c;
1540             } while (!c.atEnd());
1541             break;
1542         case State::Host:
1543             do {
1544                 LOG_STATE(&quot;Host&quot;);
1545                 if (*c == &#39;/&#39; || *c == &#39;?&#39; || *c == &#39;#&#39;) {
1546                     if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
1547                         failure();
1548                         return;
1549                     }
1550                     if (*c == &#39;?&#39; || *c == &#39;#&#39;) {
1551                         syntaxViolation(c);
1552                         appendToASCIIBuffer(&#39;/&#39;);
1553                         m_url.m_pathAfterLastSlash = currentPosition(c);
1554                     }
1555                     state = State::Path;
1556                     break;
1557                 }
1558                 if (isPercentOrNonASCII(*c))
1559                     m_hostHasPercentOrNonASCII = true;
1560                 ++c;
1561             } while (!c.atEnd());
1562             break;
1563         case State::File:
1564             LOG_STATE(&quot;File&quot;);
1565             switch (*c) {
1566             case &#39;\\&#39;:
1567                 syntaxViolation(c);
1568                 FALLTHROUGH;
1569             case &#39;/&#39;:
1570                 appendToASCIIBuffer(&#39;/&#39;);
1571                 state = State::FileSlash;
1572                 ++c;
1573                 break;
1574             case &#39;?&#39;:
1575                 syntaxViolation(c);
1576                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1577                     copyURLPartsUntil(base, URLPart::PathEnd, c, nonUTF8QueryEncoding);
1578                     appendToASCIIBuffer(&#39;?&#39;);
1579                     ++c;
1580                 } else {
1581                     appendToASCIIBuffer(&quot;///?&quot;, 4);
1582                     ++c;
1583                     m_url.m_userStart = currentPosition(c) - 2;
1584                     m_url.m_userEnd = m_url.m_userStart;
1585                     m_url.m_passwordEnd = m_url.m_userStart;
1586                     m_url.m_hostEnd = m_url.m_userStart;
1587                     m_url.m_portLength = 0;
1588                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1589                     m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1590                 }
1591                 if (nonUTF8QueryEncoding) {
1592                     queryBegin = c;
1593                     state = State::NonUTF8Query;
1594                 } else
1595                     state = State::UTF8Query;
1596                 break;
1597             case &#39;#&#39;:
1598                 syntaxViolation(c);
1599                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1600                     copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1601                     appendToASCIIBuffer(&#39;#&#39;);
1602                 } else {
1603                     appendToASCIIBuffer(&quot;///#&quot;, 4);
1604                     m_url.m_userStart = currentPosition(c) - 2;
1605                     m_url.m_userEnd = m_url.m_userStart;
1606                     m_url.m_passwordEnd = m_url.m_userStart;
1607                     m_url.m_hostEnd = m_url.m_userStart;
1608                     m_url.m_portLength = 0;
1609                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1610                     m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1611                     m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1612                 }
1613                 state = State::Fragment;
1614                 ++c;
1615                 break;
1616             default:
1617                 syntaxViolation(c);
1618                 if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;) &amp;&amp; shouldCopyFileURL(c))
1619                     copyURLPartsUntil(base, URLPart::PathAfterLastSlash, c, nonUTF8QueryEncoding);
1620                 else {
1621                     appendToASCIIBuffer(&quot;///&quot;, 3);
1622                     m_url.m_userStart = currentPosition(c) - 1;
1623                     m_url.m_userEnd = m_url.m_userStart;
1624                     m_url.m_passwordEnd = m_url.m_userStart;
1625                     m_url.m_hostEnd = m_url.m_userStart;
1626                     m_url.m_portLength = 0;
1627                     m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1628                     if (isWindowsDriveLetter(c))
1629                         appendWindowsDriveLetter(c);
1630                 }
1631                 state = State::Path;
1632                 break;
1633             }
1634             break;
1635         case State::FileSlash:
1636             LOG_STATE(&quot;FileSlash&quot;);
1637             if (LIKELY(*c == &#39;/&#39; || *c == &#39;\\&#39;)) {
1638                 if (UNLIKELY(*c == &#39;\\&#39;))
1639                     syntaxViolation(c);
1640                 appendToASCIIBuffer(&#39;/&#39;);
1641                 advance(c);
1642                 m_url.m_userStart = currentPosition(c);
1643                 m_url.m_userEnd = m_url.m_userStart;
1644                 m_url.m_passwordEnd = m_url.m_userStart;
1645                 m_url.m_hostEnd = m_url.m_userStart;
1646                 m_url.m_portLength = 0;
1647                 authorityOrHostBegin = c;
1648                 state = State::FileHost;
1649                 break;
1650             }
1651             syntaxViolation(c);
1652             appendToASCIIBuffer(&quot;//&quot;, 2);
1653             m_url.m_userStart = currentPosition(c) - 1;
1654             m_url.m_userEnd = m_url.m_userStart;
1655             m_url.m_passwordEnd = m_url.m_userStart;
1656             m_url.m_hostEnd = m_url.m_userStart;
1657             m_url.m_portLength = 0;
1658             if (isWindowsDriveLetter(c)) {
1659                 appendWindowsDriveLetter(c);
1660                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1661             } else if (copyBaseWindowsDriveLetter(base)) {
1662                 appendToASCIIBuffer(&#39;/&#39;);
1663                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 4;
1664             } else
1665                 m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1666             state = State::Path;
1667             break;
1668         case State::FileHost:
1669             do {
1670                 LOG_STATE(&quot;FileHost&quot;);
1671                 if (isSlashQuestionOrHash(*c)) {
1672                     bool windowsQuirk = takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))
1673                         &amp;&amp; isWindowsDriveLetter(authorityOrHostBegin);
1674                     if (windowsQuirk) {
1675                         syntaxViolation(authorityOrHostBegin);
1676                         appendToASCIIBuffer(&#39;/&#39;);
1677                         appendWindowsDriveLetter(authorityOrHostBegin);
1678                     }
1679                     if (windowsQuirk || authorityOrHostBegin == c) {
1680                         ASSERT(windowsQuirk || parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1681                         if (UNLIKELY(*c == &#39;?&#39;)) {
1682                             syntaxViolation(c);
1683                             appendToASCIIBuffer(&quot;/?&quot;, 2);
1684                             ++c;
1685                             if (nonUTF8QueryEncoding) {
1686                                 queryBegin = c;
1687                                 state = State::NonUTF8Query;
1688                             } else
1689                                 state = State::UTF8Query;
1690                             m_url.m_pathAfterLastSlash = currentPosition(c) - 1;
1691                             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1692                             break;
1693                         }
1694                         if (UNLIKELY(*c == &#39;#&#39;)) {
1695                             syntaxViolation(c);
1696                             appendToASCIIBuffer(&quot;/#&quot;, 2);
1697                             ++c;
1698                             m_url.m_pathAfterLastSlash = currentPosition(c) - 1;
1699                             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1700                             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1701                             state = State::Fragment;
1702                             break;
1703                         }
1704                         state = State::Path;
1705                         break;
1706                     }
1707                     if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
1708                         failure();
1709                         return;
1710                     }
1711                     if (UNLIKELY(isLocalhost(parsedDataView(m_url.m_passwordEnd, currentPosition(c) - m_url.m_passwordEnd)))) {
1712                         syntaxViolation(c);
1713                         m_asciiBuffer.shrink(m_url.m_passwordEnd);
1714                         m_url.m_hostEnd = currentPosition(c);
1715                         m_url.m_portLength = 0;
1716                     }
1717 
1718                     state = State::PathStart;
1719                     break;
1720                 }
1721                 if (isPercentOrNonASCII(*c))
1722                     m_hostHasPercentOrNonASCII = true;
1723                 ++c;
1724             } while (!c.atEnd());
1725             break;
1726         case State::PathStart:
1727             LOG_STATE(&quot;PathStart&quot;);
1728             if (*c != &#39;/&#39; &amp;&amp; *c != &#39;\\&#39;) {
1729                 syntaxViolation(c);
1730                 appendToASCIIBuffer(&#39;/&#39;);
1731             }
1732             m_url.m_pathAfterLastSlash = currentPosition(c);
1733             state = State::Path;
1734             break;
1735         case State::Path:
1736             LOG_STATE(&quot;Path&quot;);
1737             if (*c == &#39;/&#39; || (m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;)) {
1738                 if (UNLIKELY(m_urlIsSpecial &amp;&amp; *c == &#39;\\&#39;))
1739                     syntaxViolation(c);
1740                 appendToASCIIBuffer(&#39;/&#39;);
1741                 ++c;
1742                 m_url.m_pathAfterLastSlash = currentPosition(c);
1743                 break;
1744             }
1745             if (UNLIKELY(currentPosition(c) &amp;&amp; parsedDataView(currentPosition(c) - 1) == &#39;/&#39;)) {
1746                 if (UNLIKELY(isDoubleDotPathSegment(c))) {
1747                     syntaxViolation(c);
1748                     consumeDoubleDotPathSegment(c);
1749                     popPath();
1750                     break;
1751                 }
1752                 if (UNLIKELY(isSingleDotPathSegment(c))) {
1753                     syntaxViolation(c);
1754                     consumeSingleDotPathSegment(c);
1755                     break;
1756                 }
1757             }
1758             if (*c == &#39;?&#39;) {
1759                 m_url.m_pathEnd = currentPosition(c);
1760                 appendToASCIIBuffer(&#39;?&#39;);
1761                 ++c;
1762                 if (nonUTF8QueryEncoding) {
1763                     queryBegin = c;
1764                     state = State::NonUTF8Query;
1765                 } else
1766                     state = State::UTF8Query;
1767                 break;
1768             }
1769             if (*c == &#39;#&#39;) {
1770                 m_url.m_pathEnd = currentPosition(c);
1771                 m_url.m_queryEnd = m_url.m_pathEnd;
1772                 state = State::Fragment;
1773                 break;
1774             }
1775             utf8PercentEncode&lt;isInDefaultEncodeSet&gt;(c);
1776             ++c;
1777             break;
1778         case State::CannotBeABaseURLPath:
1779             LOG_STATE(&quot;CannotBeABaseURLPath&quot;);
1780             if (*c == &#39;?&#39;) {
1781                 m_url.m_pathEnd = currentPosition(c);
1782                 appendToASCIIBuffer(&#39;?&#39;);
1783                 ++c;
1784                 if (nonUTF8QueryEncoding) {
1785                     queryBegin = c;
1786                     state = State::NonUTF8Query;
1787                 } else
1788                     state = State::UTF8Query;
1789             } else if (*c == &#39;#&#39;) {
1790                 m_url.m_pathEnd = currentPosition(c);
1791                 m_url.m_queryEnd = m_url.m_pathEnd;
1792                 state = State::Fragment;
1793             } else if (*c == &#39;/&#39;) {
1794                 appendToASCIIBuffer(&#39;/&#39;);
1795                 ++c;
1796                 m_url.m_pathAfterLastSlash = currentPosition(c);
1797             } else {
1798                 utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(c);
1799                 ++c;
1800             }
1801             break;
1802         case State::UTF8Query:
1803             LOG_STATE(&quot;UTF8Query&quot;);
1804             ASSERT(queryBegin == CodePointIterator&lt;CharacterType&gt;());
1805             if (*c == &#39;#&#39;) {
1806                 m_url.m_queryEnd = currentPosition(c);
1807                 state = State::Fragment;
1808                 break;
1809             }
1810             ASSERT(!nonUTF8QueryEncoding);
1811             utf8QueryEncode(c);
1812             ++c;
1813             break;
1814         case State::NonUTF8Query:
1815             do {
1816                 LOG_STATE(&quot;NonUTF8Query&quot;);
1817                 ASSERT(queryBegin != CodePointIterator&lt;CharacterType&gt;());
1818                 if (*c == &#39;#&#39;) {
1819                     encodeNonUTF8Query(queryBuffer, *nonUTF8QueryEncoding, CodePointIterator&lt;CharacterType&gt;(queryBegin, c));
1820                     m_url.m_queryEnd = currentPosition(c);
1821                     state = State::Fragment;
1822                     break;
1823                 }
1824                 appendCodePoint(queryBuffer, *c);
1825                 advance(c, queryBegin);
1826             } while (!c.atEnd());
1827             break;
1828         case State::Fragment:
1829             URL_PARSER_LOG(&quot;State Fragment&quot;);
1830             utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(c);
1831             ++c;
1832             break;
1833         }
1834     }
1835 
1836     switch (state) {
1837     case State::SchemeStart:
1838         LOG_FINAL_STATE(&quot;SchemeStart&quot;);
1839         if (!currentPosition(c) &amp;&amp; base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1840             m_url = base;
1841             m_url.removeFragmentIdentifier();
1842             return;
1843         }
1844         failure();
1845         return;
1846     case State::Scheme:
1847         LOG_FINAL_STATE(&quot;Scheme&quot;);
1848         failure();
1849         return;
1850     case State::NoScheme:
1851         LOG_FINAL_STATE(&quot;NoScheme&quot;);
1852         RELEASE_ASSERT_NOT_REACHED();
1853     case State::SpecialRelativeOrAuthority:
1854         LOG_FINAL_STATE(&quot;SpecialRelativeOrAuthority&quot;);
1855         copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1856         break;
1857     case State::PathOrAuthority:
1858         LOG_FINAL_STATE(&quot;PathOrAuthority&quot;);
1859         ASSERT(m_url.m_userStart);
1860         ASSERT(m_url.m_userStart == currentPosition(c));
1861         ASSERT(parsedDataView(currentPosition(c) - 1) == &#39;/&#39;);
1862         m_url.m_userStart--;
1863         m_url.m_userEnd = m_url.m_userStart;
1864         m_url.m_passwordEnd = m_url.m_userStart;
1865         m_url.m_hostEnd = m_url.m_userStart;
1866         m_url.m_portLength = 0;
1867         m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1868         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1869         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1870         break;
1871     case State::Relative:
1872         LOG_FINAL_STATE(&quot;Relative&quot;);
1873         RELEASE_ASSERT_NOT_REACHED();
1874     case State::RelativeSlash:
1875         LOG_FINAL_STATE(&quot;RelativeSlash&quot;);
1876         copyURLPartsUntil(base, URLPart::PortEnd, c, nonUTF8QueryEncoding);
1877         appendToASCIIBuffer(&#39;/&#39;);
1878         m_url.m_pathAfterLastSlash = m_url.m_hostEnd + m_url.m_portLength + 1;
1879         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1880         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1881         break;
1882     case State::SpecialAuthoritySlashes:
1883         LOG_FINAL_STATE(&quot;SpecialAuthoritySlashes&quot;);
1884         m_url.m_userStart = currentPosition(c);
1885         m_url.m_userEnd = m_url.m_userStart;
1886         m_url.m_passwordEnd = m_url.m_userStart;
1887         m_url.m_hostEnd = m_url.m_userStart;
1888         m_url.m_portLength = 0;
1889         m_url.m_pathAfterLastSlash = m_url.m_userStart;
1890         m_url.m_pathEnd = m_url.m_userStart;
1891         m_url.m_queryEnd = m_url.m_userStart;
1892         break;
1893     case State::SpecialAuthorityIgnoreSlashes:
1894         LOG_FINAL_STATE(&quot;SpecialAuthorityIgnoreSlashes&quot;);
1895         failure();
1896         return;
1897     case State::AuthorityOrHost:
1898         LOG_FINAL_STATE(&quot;AuthorityOrHost&quot;);
1899         m_url.m_userEnd = currentPosition(authorityOrHostBegin);
1900         m_url.m_passwordEnd = m_url.m_userEnd;
1901         if (authorityOrHostBegin.atEnd()) {
1902             m_url.m_userEnd = m_url.m_userStart;
1903             m_url.m_passwordEnd = m_url.m_userStart;
1904             m_url.m_hostEnd = m_url.m_userStart;
1905             m_url.m_portLength = 0;
1906             m_url.m_pathEnd = m_url.m_userStart;
1907         } else if (!parseHostAndPort(authorityOrHostBegin)) {
1908             failure();
1909             return;
1910         } else {
1911             if (m_urlIsSpecial) {
1912                 syntaxViolation(c);
1913                 appendToASCIIBuffer(&#39;/&#39;);
1914                 m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength + 1;
1915             } else
1916                 m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength;
1917         }
1918         m_url.m_pathAfterLastSlash = m_url.m_pathEnd;
1919         m_url.m_queryEnd = m_url.m_pathEnd;
1920         break;
1921     case State::Host:
1922         LOG_FINAL_STATE(&quot;Host&quot;);
1923         if (!parseHostAndPort(authorityOrHostBegin)) {
1924             failure();
1925             return;
1926         }
1927         if (m_urlIsSpecial) {
1928             syntaxViolation(c);
1929             appendToASCIIBuffer(&#39;/&#39;);
1930             m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength + 1;
1931         } else
1932             m_url.m_pathEnd = m_url.m_hostEnd + m_url.m_portLength;
1933         m_url.m_pathAfterLastSlash = m_url.m_pathEnd;
1934         m_url.m_queryEnd = m_url.m_pathEnd;
1935         break;
1936     case State::File:
1937         LOG_FINAL_STATE(&quot;File&quot;);
1938         if (base.isValid() &amp;&amp; base.protocolIs(&quot;file&quot;)) {
1939             copyURLPartsUntil(base, URLPart::QueryEnd, c, nonUTF8QueryEncoding);
1940             break;
1941         }
1942         syntaxViolation(c);
1943         appendToASCIIBuffer(&quot;///&quot;, 3);
1944         m_url.m_userStart = currentPosition(c) - 1;
1945         m_url.m_userEnd = m_url.m_userStart;
1946         m_url.m_passwordEnd = m_url.m_userStart;
1947         m_url.m_hostEnd = m_url.m_userStart;
1948         m_url.m_portLength = 0;
1949         m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1950         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1951         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1952         break;
1953     case State::FileSlash:
1954         LOG_FINAL_STATE(&quot;FileSlash&quot;);
1955         syntaxViolation(c);
1956         m_url.m_userStart = currentPosition(c) + 1;
1957         appendToASCIIBuffer(&quot;//&quot;, 2);
1958         m_url.m_userEnd = m_url.m_userStart;
1959         m_url.m_passwordEnd = m_url.m_userStart;
1960         m_url.m_hostEnd = m_url.m_userStart;
1961         m_url.m_portLength = 0;
1962         if (copyBaseWindowsDriveLetter(base)) {
1963             appendToASCIIBuffer(&#39;/&#39;);
1964             m_url.m_pathAfterLastSlash = m_url.m_userStart + 4;
1965         } else
1966             m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1967         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1968         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1969         break;
1970     case State::FileHost:
1971         LOG_FINAL_STATE(&quot;FileHost&quot;);
1972         if (takesTwoAdvancesUntilEnd(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))
1973             &amp;&amp; isWindowsDriveLetter(authorityOrHostBegin)) {
1974             syntaxViolation(authorityOrHostBegin);
1975             appendToASCIIBuffer(&#39;/&#39;);
1976             appendWindowsDriveLetter(authorityOrHostBegin);
1977             m_url.m_pathAfterLastSlash = currentPosition(c);
1978             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1979             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1980             break;
1981         }
1982 
1983         if (authorityOrHostBegin == c) {
1984             syntaxViolation(c);
1985             appendToASCIIBuffer(&#39;/&#39;);
1986             m_url.m_userStart = currentPosition(c) - 1;
1987             m_url.m_userEnd = m_url.m_userStart;
1988             m_url.m_passwordEnd = m_url.m_userStart;
1989             m_url.m_hostEnd = m_url.m_userStart;
1990             m_url.m_portLength = 0;
1991             m_url.m_pathAfterLastSlash = m_url.m_userStart + 1;
1992             m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
1993             m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
1994             break;
1995         }
1996 
1997         if (!parseHostAndPort(CodePointIterator&lt;CharacterType&gt;(authorityOrHostBegin, c))) {
1998             failure();
1999             return;
2000         }
2001 
2002         syntaxViolation(c);
2003         if (isLocalhost(parsedDataView(m_url.m_passwordEnd, currentPosition(c) - m_url.m_passwordEnd))) {
2004             m_asciiBuffer.shrink(m_url.m_passwordEnd);
2005             m_url.m_hostEnd = currentPosition(c);
2006             m_url.m_portLength = 0;
2007         }
2008         appendToASCIIBuffer(&#39;/&#39;);
2009         m_url.m_pathAfterLastSlash = m_url.m_hostEnd + m_url.m_portLength + 1;
2010         m_url.m_pathEnd = m_url.m_pathAfterLastSlash;
2011         m_url.m_queryEnd = m_url.m_pathAfterLastSlash;
2012         break;
2013     case State::PathStart:
2014         LOG_FINAL_STATE(&quot;PathStart&quot;);
2015         RELEASE_ASSERT_NOT_REACHED();
2016     case State::Path:
2017         LOG_FINAL_STATE(&quot;Path&quot;);
2018         m_url.m_pathEnd = currentPosition(c);
2019         m_url.m_queryEnd = m_url.m_pathEnd;
2020         break;
2021     case State::CannotBeABaseURLPath:
2022         LOG_FINAL_STATE(&quot;CannotBeABaseURLPath&quot;);
2023         m_url.m_pathEnd = currentPosition(c);
2024         m_url.m_queryEnd = m_url.m_pathEnd;
2025         break;
2026     case State::UTF8Query:
2027         LOG_FINAL_STATE(&quot;UTF8Query&quot;);
2028         ASSERT(queryBegin == CodePointIterator&lt;CharacterType&gt;());
2029         m_url.m_queryEnd = currentPosition(c);
2030         break;
2031     case State::NonUTF8Query:
2032         LOG_FINAL_STATE(&quot;NonUTF8Query&quot;);
2033         ASSERT(queryBegin != CodePointIterator&lt;CharacterType&gt;());
2034         encodeNonUTF8Query(queryBuffer, *nonUTF8QueryEncoding, CodePointIterator&lt;CharacterType&gt;(queryBegin, c));
2035         m_url.m_queryEnd = currentPosition(c);
2036         break;
2037     case State::Fragment:
2038         LOG_FINAL_STATE(&quot;Fragment&quot;);
2039         break;
2040     }
2041 
2042     if (LIKELY(!m_didSeeSyntaxViolation)) {
2043         m_url.m_string = m_inputString;
2044         ASSERT(m_asciiBuffer.isEmpty());
2045     } else
2046         m_url.m_string = String::adopt(WTFMove(m_asciiBuffer));
2047     m_url.m_isValid = true;
2048     URL_PARSER_LOG(&quot;Parsed URL &lt;%s&gt;&quot;, m_url.m_string.utf8().data());
2049 }
2050 
2051 template&lt;typename CharacterType&gt;
2052 void URLParser::parseAuthority(CodePointIterator&lt;CharacterType&gt; iterator)
2053 {
2054     if (UNLIKELY(iterator.atEnd())) {
2055         syntaxViolation(iterator);
2056         m_url.m_userEnd = currentPosition(iterator);
2057         m_url.m_passwordEnd = m_url.m_userEnd;
2058         return;
2059     }
2060     for (; !iterator.atEnd(); advance(iterator)) {
2061         if (*iterator == &#39;:&#39;) {
2062             m_url.m_userEnd = currentPosition(iterator);
2063             auto iteratorAtColon = iterator;
2064             ++iterator;
2065             bool tabOrNewlineAfterColon = false;
2066             while (UNLIKELY(!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))) {
2067                 tabOrNewlineAfterColon = true;
2068                 ++iterator;
2069             }
2070             if (UNLIKELY(iterator.atEnd())) {
2071                 syntaxViolation(iteratorAtColon);
2072                 m_url.m_passwordEnd = m_url.m_userEnd;
2073                 if (m_url.m_userEnd &gt; m_url.m_userStart)
2074                     appendToASCIIBuffer(&#39;@&#39;);
2075                 return;
2076             }
2077             if (tabOrNewlineAfterColon)
2078                 syntaxViolation(iteratorAtColon);
2079             appendToASCIIBuffer(&#39;:&#39;);
2080             break;
2081         }
2082         utf8PercentEncode&lt;WTF::isInUserInfoEncodeSet&gt;(iterator);
2083     }
2084     for (; !iterator.atEnd(); advance(iterator))
2085         utf8PercentEncode&lt;WTF::isInUserInfoEncodeSet&gt;(iterator);
2086     m_url.m_passwordEnd = currentPosition(iterator);
2087     if (!m_url.m_userEnd)
2088         m_url.m_userEnd = m_url.m_passwordEnd;
2089     appendToASCIIBuffer(&#39;@&#39;);
2090 }
2091 
2092 template&lt;typename UnsignedIntegerType&gt;
2093 void URLParser::appendNumberToASCIIBuffer(UnsignedIntegerType number)
2094 {
2095     LChar buf[sizeof(UnsignedIntegerType) * 3 + 1];
2096     LChar* end = std::end(buf);
2097     LChar* p = end;
2098     do {
2099         *--p = (number % 10) + &#39;0&#39;;
2100         number /= 10;
2101     } while (number);
2102     appendToASCIIBuffer(p, end - p);
2103 }
2104 
2105 void URLParser::serializeIPv4(IPv4Address address)
2106 {
2107     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 24);
2108     appendToASCIIBuffer(&#39;.&#39;);
2109     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 16);
2110     appendToASCIIBuffer(&#39;.&#39;);
2111     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address &gt;&gt; 8);
2112     appendToASCIIBuffer(&#39;.&#39;);
2113     appendNumberToASCIIBuffer&lt;uint8_t&gt;(address);
2114 }
2115 
2116 static size_t zeroSequenceLength(const std::array&lt;uint16_t, 8&gt;&amp; address, size_t begin)
2117 {
2118     size_t end = begin;
2119     for (; end &lt; 8; end++) {
2120         if (address[end])
2121             break;
2122     }
2123     return end - begin;
2124 }
2125 
2126 static Optional&lt;size_t&gt; findLongestZeroSequence(const std::array&lt;uint16_t, 8&gt;&amp; address)
2127 {
2128     Optional&lt;size_t&gt; longest;
2129     size_t longestLength = 0;
2130     for (size_t i = 0; i &lt; 8; i++) {
2131         size_t length = zeroSequenceLength(address, i);
2132         if (length) {
2133             if (length &gt; 1 &amp;&amp; (!longest || longestLength &lt; length)) {
2134                 longest = i;
2135                 longestLength = length;
2136             }
2137             i += length;
2138         }
2139     }
2140     return longest;
2141 }
2142 
2143 void URLParser::serializeIPv6Piece(uint16_t piece)
2144 {
2145     bool printed = false;
2146     if (auto nibble0 = piece &gt;&gt; 12) {
2147         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble0));
2148         printed = true;
2149     }
2150     auto nibble1 = piece &gt;&gt; 8 &amp; 0xF;
2151     if (printed || nibble1) {
2152         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble1));
2153         printed = true;
2154     }
2155     auto nibble2 = piece &gt;&gt; 4 &amp; 0xF;
2156     if (printed || nibble2)
2157         appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(nibble2));
2158     appendToASCIIBuffer(lowerNibbleToLowercaseASCIIHexDigit(piece &amp; 0xF));
2159 }
2160 
2161 void URLParser::serializeIPv6(URLParser::IPv6Address address)
2162 {
2163     appendToASCIIBuffer(&#39;[&#39;);
2164     auto compressPointer = findLongestZeroSequence(address);
2165     for (size_t piece = 0; piece &lt; 8; piece++) {
2166         if (compressPointer &amp;&amp; compressPointer.value() == piece) {
2167             ASSERT(!address[piece]);
2168             if (piece)
2169                 appendToASCIIBuffer(&#39;:&#39;);
2170             else
2171                 appendToASCIIBuffer(&quot;::&quot;, 2);
2172             while (piece &lt; 8 &amp;&amp; !address[piece])
2173                 piece++;
2174             if (piece == 8)
2175                 break;
2176         }
2177         serializeIPv6Piece(address[piece]);
2178         if (piece &lt; 7)
2179             appendToASCIIBuffer(&#39;:&#39;);
2180     }
2181     appendToASCIIBuffer(&#39;]&#39;);
2182 }
2183 
2184 enum class URLParser::IPv4PieceParsingError {
2185     Failure,
2186     Overflow,
2187 };
2188 
2189 template&lt;typename CharacterType&gt;
2190 Expected&lt;uint32_t, URLParser::IPv4PieceParsingError&gt; URLParser::parseIPv4Piece(CodePointIterator&lt;CharacterType&gt;&amp; iterator, bool&amp; didSeeSyntaxViolation)
2191 {
2192     enum class State : uint8_t {
2193         UnknownBase,
2194         Decimal,
2195         OctalOrHex,
2196         Octal,
2197         Hex,
2198     };
2199     State state = State::UnknownBase;
2200     Checked&lt;uint32_t, RecordOverflow&gt; value = 0;
2201     if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;)
2202         return makeUnexpected(IPv4PieceParsingError::Failure);
2203     while (!iterator.atEnd()) {
2204         if (isTabOrNewline(*iterator)) {
2205             didSeeSyntaxViolation = true;
2206             ++iterator;
2207             continue;
2208         }
2209         if (*iterator == &#39;.&#39;) {
2210             ASSERT(!value.hasOverflowed());
2211             return value.unsafeGet();
2212         }
2213         switch (state) {
2214         case State::UnknownBase:
2215             if (UNLIKELY(*iterator == &#39;0&#39;)) {
2216                 ++iterator;
2217                 state = State::OctalOrHex;
2218                 break;
2219             }
2220             state = State::Decimal;
2221             break;
2222         case State::OctalOrHex:
2223             didSeeSyntaxViolation = true;
2224             if (*iterator == &#39;x&#39; || *iterator == &#39;X&#39;) {
2225                 ++iterator;
2226                 state = State::Hex;
2227                 break;
2228             }
2229             state = State::Octal;
2230             break;
2231         case State::Decimal:
2232             if (!isASCIIDigit(*iterator))
2233                 return makeUnexpected(IPv4PieceParsingError::Failure);
2234             value *= 10;
2235             value += *iterator - &#39;0&#39;;
2236             if (UNLIKELY(value.hasOverflowed()))
2237                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2238             ++iterator;
2239             break;
2240         case State::Octal:
2241             ASSERT(didSeeSyntaxViolation);
2242             if (*iterator &lt; &#39;0&#39; || *iterator &gt; &#39;7&#39;)
2243                 return makeUnexpected(IPv4PieceParsingError::Failure);
2244             value *= 8;
2245             value += *iterator - &#39;0&#39;;
2246             if (UNLIKELY(value.hasOverflowed()))
2247                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2248             ++iterator;
2249             break;
2250         case State::Hex:
2251             ASSERT(didSeeSyntaxViolation);
2252             if (!isASCIIHexDigit(*iterator))
2253                 return makeUnexpected(IPv4PieceParsingError::Failure);
2254             value *= 16;
2255             value += toASCIIHexValue(*iterator);
2256             if (UNLIKELY(value.hasOverflowed()))
2257                 return makeUnexpected(IPv4PieceParsingError::Overflow);
2258             ++iterator;
2259             break;
2260         }
2261     }
2262     ASSERT(!value.hasOverflowed());
2263     return value.unsafeGet();
2264 }
2265 
2266 ALWAYS_INLINE static uint64_t pow256(size_t exponent)
2267 {
2268     RELEASE_ASSERT(exponent &lt;= 4);
2269     uint64_t values[5] = {1, 256, 256 * 256, 256 * 256 * 256, 256ull * 256 * 256 * 256 };
2270     return values[exponent];
2271 }
2272 
2273 enum class URLParser::IPv4ParsingError {
2274     Failure,
2275     NotIPv4,
2276 };
2277 
2278 template&lt;typename CharacterTypeForSyntaxViolation, typename CharacterType&gt;
2279 Expected&lt;URLParser::IPv4Address, URLParser::IPv4ParsingError&gt; URLParser::parseIPv4Host(const CodePointIterator&lt;CharacterTypeForSyntaxViolation&gt;&amp; iteratorForSyntaxViolationPosition, CodePointIterator&lt;CharacterType&gt; iterator)
2280 {
2281     Vector&lt;Expected&lt;uint32_t, URLParser::IPv4PieceParsingError&gt;, 4&gt; items;
2282     bool didSeeSyntaxViolation = false;
2283     if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;)
2284         return makeUnexpected(IPv4ParsingError::NotIPv4);
2285     while (!iterator.atEnd()) {
2286         if (isTabOrNewline(*iterator)) {
2287             didSeeSyntaxViolation = true;
2288             ++iterator;
2289             continue;
2290         }
2291         if (items.size() &gt;= 4)
2292             return makeUnexpected(IPv4ParsingError::NotIPv4);
2293         items.append(parseIPv4Piece(iterator, didSeeSyntaxViolation));
2294         if (!iterator.atEnd() &amp;&amp; *iterator == &#39;.&#39;) {
2295             ++iterator;
2296             if (iterator.atEnd())
2297                 didSeeSyntaxViolation = true;
2298             else if (*iterator == &#39;.&#39;)
2299                 return makeUnexpected(IPv4ParsingError::NotIPv4);
2300         }
2301     }
2302     if (!iterator.atEnd() || !items.size() || items.size() &gt; 4)
2303         return makeUnexpected(IPv4ParsingError::NotIPv4);
2304     for (const auto&amp; item : items) {
2305         if (!item.has_value() &amp;&amp; item.error() == IPv4PieceParsingError::Failure)
2306             return makeUnexpected(IPv4ParsingError::NotIPv4);
2307     }
2308     for (const auto&amp; item : items) {
2309         if (!item.has_value() &amp;&amp; item.error() == IPv4PieceParsingError::Overflow)
2310             return makeUnexpected(IPv4ParsingError::Failure);
2311     }
2312     if (items.size() &gt; 1) {
2313         for (size_t i = 0; i &lt; items.size() - 1; i++) {
2314             if (items[i].value() &gt; 255)
2315                 return makeUnexpected(IPv4ParsingError::Failure);
2316         }
2317     }
2318     if (items[items.size() - 1].value() &gt;= pow256(5 - items.size()))
2319         return makeUnexpected(IPv4ParsingError::Failure);
2320 
2321     if (didSeeSyntaxViolation)
2322         syntaxViolation(iteratorForSyntaxViolationPosition);
2323     for (const auto&amp; item : items) {
2324         if (item.value() &gt; 255)
2325             syntaxViolation(iteratorForSyntaxViolationPosition);
2326     }
2327 
2328     if (UNLIKELY(items.size() != 4))
2329         syntaxViolation(iteratorForSyntaxViolationPosition);
2330 
2331     IPv4Address ipv4 = items.takeLast().value();
2332     for (size_t counter = 0; counter &lt; items.size(); ++counter)
2333         ipv4 += items[counter].value() * pow256(3 - counter);
2334     return ipv4;
2335 }
2336 
2337 template&lt;typename CharacterType&gt;
2338 Optional&lt;uint32_t&gt; URLParser::parseIPv4PieceInsideIPv6(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2339 {
2340     if (iterator.atEnd())
2341         return WTF::nullopt;
2342     uint32_t piece = 0;
2343     bool leadingZeros = false;
2344     size_t digitCount = 0;
2345     while (!iterator.atEnd()) {
2346         if (!isASCIIDigit(*iterator))
2347             return WTF::nullopt;
2348         ++digitCount;
2349         if (!piece &amp;&amp; *iterator == &#39;0&#39;) {
2350             if (leadingZeros)
2351                 return WTF::nullopt;
2352             leadingZeros = true;
2353         }
2354         if (!piece &amp;&amp; *iterator == &#39;0&#39;)
2355             leadingZeros = true;
2356         piece = piece * 10 + *iterator - &#39;0&#39;;
2357         if (piece &gt; 255)
2358             return WTF::nullopt;
2359         advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
2360         if (iterator.atEnd())
2361             break;
2362         if (*iterator == &#39;.&#39;)
2363             break;
2364     }
2365     if (piece &amp;&amp; leadingZeros)
2366         return WTF::nullopt;
2367     return piece;
2368 }
2369 
2370 template&lt;typename CharacterType&gt;
2371 Optional&lt;URLParser::IPv4Address&gt; URLParser::parseIPv4AddressInsideIPv6(CodePointIterator&lt;CharacterType&gt; iterator)
2372 {
2373     IPv4Address address = 0;
2374     for (size_t i = 0; i &lt; 4; ++i) {
2375         if (Optional&lt;uint32_t&gt; piece = parseIPv4PieceInsideIPv6(iterator))
2376             address = (address &lt;&lt; 8) + piece.value();
2377         else
2378             return WTF::nullopt;
2379         if (i &lt; 3) {
2380             if (iterator.atEnd())
2381                 return WTF::nullopt;
2382             if (*iterator != &#39;.&#39;)
2383                 return WTF::nullopt;
2384             advance&lt;CharacterType, ReportSyntaxViolation::No&gt;(iterator);
2385         } else if (!iterator.atEnd())
2386             return WTF::nullopt;
2387     }
2388     ASSERT(iterator.atEnd());
2389     return address;
2390 }
2391 
2392 template&lt;typename CharacterType&gt;
2393 Optional&lt;URLParser::IPv6Address&gt; URLParser::parseIPv6Host(CodePointIterator&lt;CharacterType&gt; c)
2394 {
2395     ASSERT(*c == &#39;[&#39;);
2396     const auto hostBegin = c;
2397     advance(c, hostBegin);
2398     if (c.atEnd())
2399         return WTF::nullopt;
2400 
2401     IPv6Address address = {{0, 0, 0, 0, 0, 0, 0, 0}};
2402     size_t piecePointer = 0;
2403     Optional&lt;size_t&gt; compressPointer;
2404     bool previousValueWasZero = false;
2405     bool immediatelyAfterCompress = false;
2406 
2407     if (*c == &#39;:&#39;) {
2408         advance(c, hostBegin);
2409         if (c.atEnd())
2410             return WTF::nullopt;
2411         if (*c != &#39;:&#39;)
2412             return WTF::nullopt;
2413         advance(c, hostBegin);
2414         ++piecePointer;
2415         compressPointer = piecePointer;
2416         immediatelyAfterCompress = true;
2417     }
2418 
2419     while (!c.atEnd()) {
2420         if (piecePointer == 8)
2421             return WTF::nullopt;
2422         if (*c == &#39;:&#39;) {
2423             if (compressPointer)
2424                 return WTF::nullopt;
2425             advance(c, hostBegin);
2426             ++piecePointer;
2427             compressPointer = piecePointer;
2428             immediatelyAfterCompress = true;
2429             if (previousValueWasZero)
2430                 syntaxViolation(hostBegin);
2431             continue;
2432         }
2433         if (piecePointer == 6 || (compressPointer &amp;&amp; piecePointer &lt; 6)) {
2434             if (Optional&lt;IPv4Address&gt; ipv4Address = parseIPv4AddressInsideIPv6(c)) {
2435                 if (compressPointer &amp;&amp; piecePointer == 5)
2436                     return WTF::nullopt;
2437                 syntaxViolation(hostBegin);
2438                 address[piecePointer++] = ipv4Address.value() &gt;&gt; 16;
2439                 address[piecePointer++] = ipv4Address.value() &amp; 0xFFFF;
2440                 c = { };
2441                 break;
2442             }
2443         }
2444         uint16_t value = 0;
2445         size_t length = 0;
2446         bool leadingZeros = false;
2447         for (; length &lt; 4; length++) {
2448             if (c.atEnd())
2449                 break;
2450             if (!isASCIIHexDigit(*c))
2451                 break;
2452             if (isASCIIUpper(*c))
2453                 syntaxViolation(hostBegin);
2454             if (*c == &#39;0&#39; &amp;&amp; !length)
2455                 leadingZeros = true;
2456             value = value * 0x10 + toASCIIHexValue(*c);
2457             advance(c, hostBegin);
2458         }
2459 
2460         previousValueWasZero = !value;
2461         if (UNLIKELY((value &amp;&amp; leadingZeros) || (previousValueWasZero &amp;&amp; (length &gt; 1 || immediatelyAfterCompress))))
2462             syntaxViolation(hostBegin);
2463 
2464         address[piecePointer++] = value;
2465         if (c.atEnd())
2466             break;
2467         if (piecePointer == 8 || *c != &#39;:&#39;)
2468             return WTF::nullopt;
2469         advance(c, hostBegin);
2470         if (c.atEnd())
2471             syntaxViolation(hostBegin);
2472 
2473         immediatelyAfterCompress = false;
2474     }
2475 
2476     if (!c.atEnd())
2477         return WTF::nullopt;
2478 
2479     if (compressPointer) {
2480         size_t swaps = piecePointer - compressPointer.value();
2481         piecePointer = 7;
2482         while (swaps)
2483             std::swap(address[piecePointer--], address[compressPointer.value() + swaps-- - 1]);
2484     } else if (piecePointer != 8)
2485         return WTF::nullopt;
2486 
2487     Optional&lt;size_t&gt; possibleCompressPointer = findLongestZeroSequence(address);
2488     if (possibleCompressPointer)
2489         possibleCompressPointer.value()++;
2490     if (UNLIKELY(compressPointer != possibleCompressPointer))
2491         syntaxViolation(hostBegin);
2492 
2493     return address;
2494 }
2495 
2496 template&lt;typename CharacterType&gt;
2497 URLParser::LCharBuffer URLParser::percentDecode(const LChar* input, size_t length, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
2498 {
2499     LCharBuffer output;
2500     output.reserveInitialCapacity(length);
2501 
2502     for (size_t i = 0; i &lt; length; ++i) {
2503         uint8_t byte = input[i];
2504         if (byte != &#39;%&#39;)
2505             output.uncheckedAppend(byte);
2506         else if (length &gt; 2 &amp;&amp; i &lt; length - 2) {
2507             if (isASCIIHexDigit(input[i + 1]) &amp;&amp; isASCIIHexDigit(input[i + 2])) {
2508                 syntaxViolation(iteratorForSyntaxViolationPosition);
2509                 output.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
2510                 i += 2;
2511             } else
2512                 output.uncheckedAppend(byte);
2513         } else
2514             output.uncheckedAppend(byte);
2515     }
2516     return output;
2517 }
2518 
2519 URLParser::LCharBuffer URLParser::percentDecode(const LChar* input, size_t length)
2520 {
2521     LCharBuffer output;
2522     output.reserveInitialCapacity(length);
2523 
2524     for (size_t i = 0; i &lt; length; ++i) {
2525         uint8_t byte = input[i];
2526         if (byte != &#39;%&#39;)
2527             output.uncheckedAppend(byte);
2528         else if (length &gt; 2 &amp;&amp; i &lt; length - 2) {
2529             if (isASCIIHexDigit(input[i + 1]) &amp;&amp; isASCIIHexDigit(input[i + 2])) {
2530                 output.uncheckedAppend(toASCIIHexValue(input[i + 1], input[i + 2]));
2531                 i += 2;
2532             } else
2533                 output.uncheckedAppend(byte);
2534         } else
2535             output.uncheckedAppend(byte);
2536     }
2537     return output;
2538 }
2539 
2540 template&lt;typename CharacterType&gt; Optional&lt;URLParser::LCharBuffer&gt; URLParser::domainToASCII(StringImpl&amp; domain, const CodePointIterator&lt;CharacterType&gt;&amp; iteratorForSyntaxViolationPosition)
2541 {
2542     LCharBuffer ascii;
2543     if (domain.isAllASCII()) {
2544         size_t length = domain.length();
2545         if (domain.is8Bit()) {
2546             const LChar* characters = domain.characters8();
2547             ascii.reserveInitialCapacity(length);
2548             for (size_t i = 0; i &lt; length; ++i) {
2549                 if (UNLIKELY(isASCIIUpper(characters[i])))
2550                     syntaxViolation(iteratorForSyntaxViolationPosition);
2551                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2552             }
2553         } else {
2554             const UChar* characters = domain.characters16();
2555             ascii.reserveInitialCapacity(length);
2556             for (size_t i = 0; i &lt; length; ++i) {
2557                 if (UNLIKELY(isASCIIUpper(characters[i])))
2558                     syntaxViolation(iteratorForSyntaxViolationPosition);
2559                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2560             }
2561         }
2562         return ascii;
2563     }
2564 
2565     const size_t maxDomainLength = 64;
2566     UChar hostnameBuffer[maxDomainLength];
2567     UErrorCode error = U_ZERO_ERROR;
2568     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
2569     int32_t numCharactersConverted = uidna_nameToASCII(&amp;internationalDomainNameTranscoder(), StringView(domain).upconvertedCharacters(), domain.length(), hostnameBuffer, maxDomainLength, &amp;processingDetails, &amp;error);
2570 
2571     if (U_SUCCESS(error) &amp;&amp; !processingDetails.errors) {
2572 #if ASSERT_ENABLED
2573         for (int32_t i = 0; i &lt; numCharactersConverted; ++i) {
2574             ASSERT(isASCII(hostnameBuffer[i]));
2575             ASSERT(!isASCIIUpper(hostnameBuffer[i]));
2576         }
2577 #else
2578         UNUSED_PARAM(numCharactersConverted);
2579 #endif // ASSERT_ENABLED
2580         ascii.append(hostnameBuffer, numCharactersConverted);
2581         if (domain != StringView(ascii.data(), ascii.size()))
2582             syntaxViolation(iteratorForSyntaxViolationPosition);
2583         return ascii;
2584     }
2585     return WTF::nullopt;
2586 }
2587 
2588 bool URLParser::hasForbiddenHostCodePoint(const URLParser::LCharBuffer&amp; asciiDomain)
2589 {
2590     for (size_t i = 0; i &lt; asciiDomain.size(); ++i) {
2591         if (isForbiddenHostCodePoint(asciiDomain[i]))
2592             return true;
2593     }
2594     return false;
2595 }
2596 
2597 template&lt;typename CharacterType&gt;
2598 bool URLParser::parsePort(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2599 {
2600     ASSERT(*iterator == &#39;:&#39;);
2601     auto colonIterator = iterator;
2602     advance(iterator, colonIterator);
2603     uint32_t port = 0;
2604     if (UNLIKELY(iterator.atEnd())) {
2605         unsigned portLength = currentPosition(colonIterator) - m_url.m_hostEnd;
2606         RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2607         m_url.m_portLength = portLength;
2608         syntaxViolation(colonIterator);
2609         return true;
2610     }
2611     size_t digitCount = 0;
2612     bool leadingZeros = false;
2613     for (; !iterator.atEnd(); ++iterator) {
2614         if (UNLIKELY(isTabOrNewline(*iterator))) {
2615             syntaxViolation(colonIterator);
2616             continue;
2617         }
2618         if (isASCIIDigit(*iterator)) {
2619             if (*iterator == &#39;0&#39; &amp;&amp; !digitCount)
2620                 leadingZeros = true;
2621             ++digitCount;
2622             port = port * 10 + *iterator - &#39;0&#39;;
2623             if (port &gt; std::numeric_limits&lt;uint16_t&gt;::max())
2624                 return false;
2625         } else
2626             return false;
2627     }
2628 
2629     if (port &amp;&amp; leadingZeros)
2630         syntaxViolation(colonIterator);
2631 
2632     if (!port &amp;&amp; digitCount &gt; 1)
2633         syntaxViolation(colonIterator);
2634 
2635     ASSERT(port == static_cast&lt;uint16_t&gt;(port));
2636     if (UNLIKELY(defaultPortForProtocol(parsedDataView(0, m_url.m_schemeEnd)) == static_cast&lt;uint16_t&gt;(port)))
2637         syntaxViolation(colonIterator);
2638     else {
2639         appendToASCIIBuffer(&#39;:&#39;);
2640         ASSERT(port &lt;= std::numeric_limits&lt;uint16_t&gt;::max());
2641         appendNumberToASCIIBuffer&lt;uint16_t&gt;(static_cast&lt;uint16_t&gt;(port));
2642     }
2643 
2644     unsigned portLength = currentPosition(iterator) - m_url.m_hostEnd;
2645     RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2646     m_url.m_portLength = portLength;
2647     return true;
2648 }
2649 
2650 template&lt;typename CharacterType&gt;
2651 bool URLParser::parseHostAndPort(CodePointIterator&lt;CharacterType&gt; iterator)
2652 {
2653     if (iterator.atEnd())
2654         return false;
2655     if (*iterator == &#39;:&#39;)
2656         return false;
2657     if (*iterator == &#39;[&#39;) {
2658         auto ipv6End = iterator;
2659         while (!ipv6End.atEnd() &amp;&amp; *ipv6End != &#39;]&#39;)
2660             ++ipv6End;
2661         if (ipv6End.atEnd())
2662             return false;
2663         if (auto address = parseIPv6Host(CodePointIterator&lt;CharacterType&gt;(iterator, ipv6End))) {
2664             serializeIPv6(address.value());
2665             if (!ipv6End.atEnd()) {
2666                 advance(ipv6End);
2667                 m_url.m_hostEnd = currentPosition(ipv6End);
2668                 if (!ipv6End.atEnd() &amp;&amp; *ipv6End == &#39;:&#39;)
2669                     return parsePort(ipv6End);
2670                 m_url.m_portLength = 0;
2671                 return ipv6End.atEnd();
2672             }
2673             m_url.m_hostEnd = currentPosition(ipv6End);
2674             return true;
2675         }
2676         return false;
2677     }
2678 
2679     if (!m_urlIsSpecial) {
2680         for (; !iterator.atEnd(); ++iterator) {
2681             if (UNLIKELY(isTabOrNewline(*iterator))) {
2682                 syntaxViolation(iterator);
2683                 continue;
2684             }
2685             if (*iterator == &#39;:&#39;)
2686                 break;
2687             if (UNLIKELY(isForbiddenHostCodePoint(*iterator) &amp;&amp; *iterator != &#39;%&#39;))
2688                 return false;
2689             utf8PercentEncode&lt;isInSimpleEncodeSet&gt;(iterator);
2690         }
2691         m_url.m_hostEnd = currentPosition(iterator);
2692         if (iterator.atEnd()) {
2693             m_url.m_portLength = 0;
2694             return true;
2695         }
2696         return parsePort(iterator);
2697     }
2698 
2699     if (LIKELY(!m_hostHasPercentOrNonASCII)) {
2700         auto hostIterator = iterator;
2701         for (; !iterator.atEnd(); ++iterator) {
2702             if (isTabOrNewline(*iterator))
2703                 continue;
2704             if (*iterator == &#39;:&#39;)
2705                 break;
2706             if (isForbiddenHostCodePoint(*iterator))
2707                 return false;
2708         }
2709         auto address = parseIPv4Host(hostIterator, CodePointIterator&lt;CharacterType&gt;(hostIterator, iterator));
2710         if (address) {
2711             serializeIPv4(address.value());
2712             m_url.m_hostEnd = currentPosition(iterator);
2713             if (iterator.atEnd()) {
2714                 m_url.m_portLength = 0;
2715                 return true;
2716             }
2717             return parsePort(iterator);
2718         }
2719         if (address.error() == IPv4ParsingError::Failure)
2720             return false;
2721         for (; hostIterator != iterator; ++hostIterator) {
2722             if (UNLIKELY(isTabOrNewline(*hostIterator))) {
2723                 syntaxViolation(hostIterator);
2724                 continue;
2725             }
2726             if (UNLIKELY(isASCIIUpper(*hostIterator)))
2727                 syntaxViolation(hostIterator);
2728             appendToASCIIBuffer(toASCIILower(*hostIterator));
2729         }
2730         m_url.m_hostEnd = currentPosition(iterator);
2731         if (!hostIterator.atEnd())
2732             return parsePort(hostIterator);
2733         unsigned portLength = currentPosition(iterator) - m_url.m_hostEnd;
2734         RELEASE_ASSERT(portLength &lt;= URL::maxPortLength);
2735         m_url.m_portLength = portLength;
2736         return true;
2737     }
2738 
2739     const auto hostBegin = iterator;
2740 
2741     LCharBuffer utf8Encoded;
2742     for (; !iterator.atEnd(); ++iterator) {
2743         if (UNLIKELY(isTabOrNewline(*iterator))) {
2744             syntaxViolation(hostBegin);
2745             continue;
2746         }
2747         if (*iterator == &#39;:&#39;)
2748             break;
2749         if (UNLIKELY(!isASCII(*iterator)))
2750             syntaxViolation(hostBegin);
2751 
2752         if (!U_IS_UNICODE_CHAR(*iterator))
2753             return false;
2754         uint8_t buffer[U8_MAX_LENGTH];
2755         int32_t offset = 0;
2756         U8_APPEND_UNSAFE(buffer, offset, *iterator);
2757         utf8Encoded.append(buffer, offset);
2758     }
2759     LCharBuffer percentDecoded = percentDecode(utf8Encoded.data(), utf8Encoded.size(), hostBegin);
2760     String domain = String::fromUTF8(percentDecoded.data(), percentDecoded.size());
2761     if (domain.isNull())
2762         return false;
2763     if (domain != StringView(percentDecoded.data(), percentDecoded.size()))
2764         syntaxViolation(hostBegin);
2765     auto asciiDomain = domainToASCII(*domain.impl(), hostBegin);
2766     if (!asciiDomain || hasForbiddenHostCodePoint(asciiDomain.value()))
2767         return false;
2768     LCharBuffer&amp; asciiDomainValue = asciiDomain.value();
2769     const LChar* asciiDomainCharacters = asciiDomainValue.data();
2770 
2771     auto address = parseIPv4Host(hostBegin, CodePointIterator&lt;LChar&gt;(asciiDomainValue.begin(), asciiDomainValue.end()));
2772     if (address) {
2773         serializeIPv4(address.value());
2774         m_url.m_hostEnd = currentPosition(iterator);
2775         if (iterator.atEnd()) {
2776             m_url.m_portLength = 0;
2777             return true;
2778         }
2779         return parsePort(iterator);
2780     }
2781     if (address.error() == IPv4ParsingError::Failure)
2782         return false;
2783 
2784     appendToASCIIBuffer(asciiDomainCharacters, asciiDomainValue.size());
2785     m_url.m_hostEnd = currentPosition(iterator);
2786     if (!iterator.atEnd())
2787         return parsePort(iterator);
2788     m_url.m_portLength = 0;
2789     return true;
2790 }
2791 
2792 Optional&lt;String&gt; URLParser::formURLDecode(StringView input)
2793 {
2794     auto utf8 = input.utf8(StrictConversion);
2795     if (utf8.isNull())
2796         return WTF::nullopt;
2797     auto percentDecoded = percentDecode(reinterpret_cast&lt;const LChar*&gt;(utf8.data()), utf8.length());
2798     return String::fromUTF8(percentDecoded.data(), percentDecoded.size());
2799 }
2800 
2801 // https://url.spec.whatwg.org/#concept-urlencoded-parser
2802 auto URLParser::parseURLEncodedForm(StringView input) -&gt; URLEncodedForm
2803 {
2804     URLEncodedForm output;
2805     for (StringView bytes : input.split(&#39;&amp;&#39;)) {
2806         auto equalIndex = bytes.find(&#39;=&#39;);
2807         if (equalIndex == notFound) {
2808             auto name = formURLDecode(bytes.toString().replace(&#39;+&#39;, 0x20));
2809             if (name)
2810                 output.append({ name.value(), emptyString() });
2811         } else {
2812             auto name = formURLDecode(bytes.substring(0, equalIndex).toString().replace(&#39;+&#39;, 0x20));
2813             auto value = formURLDecode(bytes.substring(equalIndex + 1).toString().replace(&#39;+&#39;, 0x20));
2814             if (name &amp;&amp; value)
2815                 output.append({ name.value(), value.value() });
2816         }
2817     }
2818     return output;
2819 }
2820 
2821 static void serializeURLEncodedForm(const String&amp; input, Vector&lt;LChar&gt;&amp; output)
2822 {
2823     auto utf8 = input.utf8(StrictConversion);
2824     const char* data = utf8.data();
2825     for (size_t i = 0; i &lt; utf8.length(); ++i) {
2826         const char byte = data[i];
2827         if (byte == 0x20)
2828             output.append(0x2B);
2829         else if (byte == 0x2A
2830             || byte == 0x2D
2831             || byte == 0x2E
2832             || (byte &gt;= 0x30 &amp;&amp; byte &lt;= 0x39)
2833             || (byte &gt;= 0x41 &amp;&amp; byte &lt;= 0x5A)
2834             || byte == 0x5F
2835             || (byte &gt;= 0x61 &amp;&amp; byte &lt;= 0x7A)) // FIXME: Put these in the characterClassTable to avoid branches.
2836             output.append(byte);
2837         else
2838             percentEncodeByte(byte, output);
2839     }
2840 }
2841 
2842 String URLParser::serialize(const URLEncodedForm&amp; tuples)
2843 {
2844     if (tuples.isEmpty())
2845         return { };
2846 
2847     Vector&lt;LChar&gt; output;
2848     for (auto&amp; tuple : tuples) {
2849         if (!output.isEmpty())
2850             output.append(&#39;&amp;&#39;);
2851         serializeURLEncodedForm(tuple.key, output);
2852         output.append(&#39;=&#39;);
2853         serializeURLEncodedForm(tuple.value, output);
2854     }
2855     return String::adopt(WTFMove(output));
2856 }
2857 
2858 const UIDNA&amp; URLParser::internationalDomainNameTranscoder()
2859 {
2860     static UIDNA* encoder;
2861     static std::once_flag onceFlag;
2862     std::call_once(onceFlag, [] {
2863         UErrorCode error = U_ZERO_ERROR;
2864         encoder = uidna_openUTS46(UIDNA_CHECK_BIDI | UIDNA_CHECK_CONTEXTJ | UIDNA_NONTRANSITIONAL_TO_UNICODE | UIDNA_NONTRANSITIONAL_TO_ASCII, &amp;error);
2865         RELEASE_ASSERT(U_SUCCESS(error));
2866         RELEASE_ASSERT(encoder);
2867     });
2868     return *encoder;
2869 }
2870 
2871 bool URLParser::allValuesEqual(const URL&amp; a, const URL&amp; b)
2872 {
2873     URL_PARSER_LOG(&quot;%d %d %d %d %d %d %d %d %d %d %d %d %s\n%d %d %d %d %d %d %d %d %d %d %d %d %s&quot;,
2874         a.m_isValid,
2875         a.m_cannotBeABaseURL,
2876         a.m_protocolIsInHTTPFamily,
2877         a.m_schemeEnd,
2878         a.m_userStart,
2879         a.m_userEnd,
2880         a.m_passwordEnd,
2881         a.m_hostEnd,
2882         a.m_hostEnd + a.m_portLength,
2883         a.m_pathAfterLastSlash,
2884         a.m_pathEnd,
2885         a.m_queryEnd,
2886         a.m_string.utf8().data(),
2887         b.m_isValid,
2888         b.m_cannotBeABaseURL,
2889         b.m_protocolIsInHTTPFamily,
2890         b.m_schemeEnd,
2891         b.m_userStart,
2892         b.m_userEnd,
2893         b.m_passwordEnd,
2894         b.m_hostEnd,
2895         b.m_hostEnd + b.m_portLength,
2896         b.m_pathAfterLastSlash,
2897         b.m_pathEnd,
2898         b.m_queryEnd,
2899         b.m_string.utf8().data());
2900 
2901     return a.m_string == b.m_string
2902         &amp;&amp; a.m_isValid == b.m_isValid
2903         &amp;&amp; a.m_cannotBeABaseURL == b.m_cannotBeABaseURL
2904         &amp;&amp; a.m_protocolIsInHTTPFamily == b.m_protocolIsInHTTPFamily
2905         &amp;&amp; a.m_schemeEnd == b.m_schemeEnd
2906         &amp;&amp; a.m_userStart == b.m_userStart
2907         &amp;&amp; a.m_userEnd == b.m_userEnd
2908         &amp;&amp; a.m_passwordEnd == b.m_passwordEnd
2909         &amp;&amp; a.m_hostEnd == b.m_hostEnd
2910         &amp;&amp; a.m_portLength == b.m_portLength
2911         &amp;&amp; a.m_pathAfterLastSlash == b.m_pathAfterLastSlash
2912         &amp;&amp; a.m_pathEnd == b.m_pathEnd
2913         &amp;&amp; a.m_queryEnd == b.m_queryEnd;
2914 }
2915 
2916 bool URLParser::internalValuesConsistent(const URL&amp; url)
2917 {
2918     return url.m_schemeEnd &lt;= url.m_userStart
2919         &amp;&amp; url.m_userStart &lt;= url.m_userEnd
2920         &amp;&amp; url.m_userEnd &lt;= url.m_passwordEnd
2921         &amp;&amp; url.m_passwordEnd &lt;= url.m_hostEnd
2922         &amp;&amp; url.m_hostEnd + url.m_portLength &lt;= url.m_pathAfterLastSlash
2923         &amp;&amp; url.m_pathAfterLastSlash &lt;= url.m_pathEnd
2924         &amp;&amp; url.m_pathEnd &lt;= url.m_queryEnd
2925         &amp;&amp; url.m_queryEnd &lt;= url.m_string.length();
2926 }
2927 
2928 } // namespace WTF
    </pre>
  </body>
</html>
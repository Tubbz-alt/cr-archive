<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditingBehavior.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EditingStyle.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1155,14 ***</span>
          break;
      }
      return copyEditingProperties(style, AllEditingProperties);
  }
  
<span class="line-modified">! void EditingStyle::mergeInlineAndImplicitStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude)</span>
  {
      auto styleFromRules = EditingStyle::create();
<span class="line-modified">!     styleFromRules-&gt;mergeStyleFromRulesForSerialization(element);</span>
  
      if (element.inlineStyle())
          styleFromRules-&gt;m_mutableStyle-&gt;mergeAndOverrideOnConflict(*element.inlineStyle());
  
      styleFromRules-&gt;m_mutableStyle = extractEditingProperties(styleFromRules-&gt;m_mutableStyle.get(), propertiesToInclude);
<span class="line-new-header">--- 1155,14 ---</span>
          break;
      }
      return copyEditingProperties(style, AllEditingProperties);
  }
  
<span class="line-modified">! void EditingStyle::mergeInlineAndImplicitStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude, StandardFontFamilySerializationMode standardFontFamilySerializationMode)</span>
  {
      auto styleFromRules = EditingStyle::create();
<span class="line-modified">!     styleFromRules-&gt;mergeStyleFromRulesForSerialization(element, standardFontFamilySerializationMode);</span>
  
      if (element.inlineStyle())
          styleFromRules-&gt;m_mutableStyle-&gt;mergeAndOverrideOnConflict(*element.inlineStyle());
  
      styleFromRules-&gt;m_mutableStyle = extractEditingProperties(styleFromRules-&gt;m_mutableStyle.get(), propertiesToInclude);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1179,11 ***</span>
          if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
              equivalent-&gt;addToStyle(&amp;element, this);
      }
  }
  
<span class="line-modified">! Ref&lt;EditingStyle&gt; EditingStyle::wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate)</span>
  {
      if (shouldAnnotate) {
          auto wrappingStyle = EditingStyle::create(&amp;context, EditingStyle::EditingPropertiesInEffect);
  
          // Styles that Mail blockquotes contribute should only be placed on the Mail blockquote,
<span class="line-new-header">--- 1179,11 ---</span>
          if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
              equivalent-&gt;addToStyle(&amp;element, this);
      }
  }
  
<span class="line-modified">! Ref&lt;EditingStyle&gt; EditingStyle::wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate, StandardFontFamilySerializationMode standardFontFamilySerializationMode)</span>
  {
      if (shouldAnnotate) {
          auto wrappingStyle = EditingStyle::create(&amp;context, EditingStyle::EditingPropertiesInEffect);
  
          // Styles that Mail blockquotes contribute should only be placed on the Mail blockquote,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1200,11 ***</span>
      auto wrappingStyle = EditingStyle::create();
  
      // When not annotating for interchange, we only preserve inline style declarations.
      for (Node* node = &amp;context; node &amp;&amp; !node-&gt;isDocumentNode(); node = node-&gt;parentNode()) {
          if (is&lt;StyledElement&gt;(*node) &amp;&amp; !isMailBlockquote(node))
<span class="line-modified">!             wrappingStyle-&gt;mergeInlineAndImplicitStyleOfElement(downcast&lt;StyledElement&gt;(*node), EditingStyle::DoNotOverrideValues, EditingStyle::EditingPropertiesInEffect);</span>
      }
  
      return wrappingStyle;
  }
  
<span class="line-new-header">--- 1200,11 ---</span>
      auto wrappingStyle = EditingStyle::create();
  
      // When not annotating for interchange, we only preserve inline style declarations.
      for (Node* node = &amp;context; node &amp;&amp; !node-&gt;isDocumentNode(); node = node-&gt;parentNode()) {
          if (is&lt;StyledElement&gt;(*node) &amp;&amp; !isMailBlockquote(node))
<span class="line-modified">!             wrappingStyle-&gt;mergeInlineAndImplicitStyleOfElement(downcast&lt;StyledElement&gt;(*node), DoNotOverrideValues, EditingPropertiesInEffect, standardFontFamilySerializationMode);</span>
      }
  
      return wrappingStyle;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1259,47 ***</span>
  }
  
  static Ref&lt;MutableStyleProperties&gt; styleFromMatchedRulesForElement(Element&amp; element, unsigned rulesToInclude)
  {
      auto style = MutableStyleProperties::create();
<span class="line-modified">!     for (auto&amp; matchedRule : element.styleResolver().styleRulesForElement(&amp;element, rulesToInclude)) {</span>
<span class="line-modified">!         if (matchedRule-&gt;isStyleRule())</span>
<span class="line-removed">-             style-&gt;mergeAndOverrideOnConflict(static_pointer_cast&lt;StyleRule&gt;(matchedRule)-&gt;properties());</span>
<span class="line-removed">-     }</span>
  
      return style;
  }
  
  void EditingStyle::mergeStyleFromRules(StyledElement&amp; element)
  {
      RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element,
<span class="line-modified">!         StyleResolver::AuthorCSSRules);</span>
      // Styles from the inline style declaration, held in the variable &quot;style&quot;, take precedence
      // over those from matched rules.
      if (m_mutableStyle)
          styleFromMatchedRules-&gt;mergeAndOverrideOnConflict(*m_mutableStyle);
  
      clear();
      m_mutableStyle = styleFromMatchedRules;
  }
  
<span class="line-modified">! static bool usesForbiddenSystemFontAsOnlyFontFamilyName(CSSValue&amp; value)</span>
  {
      if (!is&lt;CSSValueList&gt;(value) || downcast&lt;CSSValueList&gt;(value).length() != 1)
<span class="line-modified">!         return false;</span>
  
      auto&amp; item = *downcast&lt;CSSValueList&gt;(value).item(0);
      if (!is&lt;CSSPrimitiveValue&gt;(item))
<span class="line-modified">!         return false;</span>
  
<span class="line-modified">!     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item);</span>
<span class="line-removed">-     if (!primitiveValue.isFontFamily())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     return FontCache::isSystemFontForbiddenForEditing(primitiveValue.fontFamily().familyName);</span>
  }
  
<span class="line-modified">! void EditingStyle::mergeStyleFromRulesForSerialization(StyledElement&amp; element)</span>
  {
      mergeStyleFromRules(element);
  
      // The property value, if it&#39;s a percentage, may not reflect the actual computed value.
      // For example: style=&quot;height: 1%; overflow: visible;&quot; in quirksmode
<span class="line-new-header">--- 1259,52 ---</span>
  }
  
  static Ref&lt;MutableStyleProperties&gt; styleFromMatchedRulesForElement(Element&amp; element, unsigned rulesToInclude)
  {
      auto style = MutableStyleProperties::create();
<span class="line-modified">!     for (auto&amp; matchedRule : element.styleResolver().styleRulesForElement(&amp;element, rulesToInclude))</span>
<span class="line-modified">!         style-&gt;mergeAndOverrideOnConflict(matchedRule-&gt;properties());</span>
  
      return style;
  }
  
  void EditingStyle::mergeStyleFromRules(StyledElement&amp; element)
  {
      RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element,
<span class="line-modified">!         Style::Resolver::AuthorCSSRules);</span>
      // Styles from the inline style declaration, held in the variable &quot;style&quot;, take precedence
      // over those from matched rules.
      if (m_mutableStyle)
          styleFromMatchedRules-&gt;mergeAndOverrideOnConflict(*m_mutableStyle);
  
      clear();
      m_mutableStyle = styleFromMatchedRules;
  }
  
<span class="line-modified">! static String familyNameFromCSSPrimitiveValue(const CSSPrimitiveValue&amp; primitiveValue)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!primitiveValue.isFontFamily())</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+     return primitiveValue.fontFamily().familyName;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static String loneFontFamilyName(const CSSValue&amp; value)</span>
  {
<span class="line-added">+     if (is&lt;CSSPrimitiveValue&gt;(value))</span>
<span class="line-added">+         return familyNameFromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));</span>
<span class="line-added">+ </span>
      if (!is&lt;CSSValueList&gt;(value) || downcast&lt;CSSValueList&gt;(value).length() != 1)
<span class="line-modified">!         return { };</span>
  
      auto&amp; item = *downcast&lt;CSSValueList&gt;(value).item(0);
      if (!is&lt;CSSPrimitiveValue&gt;(item))
<span class="line-modified">!         return { };</span>
  
<span class="line-modified">!     return familyNameFromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(item));</span>
  }
  
<span class="line-modified">! void EditingStyle::mergeStyleFromRulesForSerialization(StyledElement&amp; element, StandardFontFamilySerializationMode standardFontFamilySerializationMode)</span>
  {
      mergeStyleFromRules(element);
  
      // The property value, if it&#39;s a percentage, may not reflect the actual computed value.
      // For example: style=&quot;height: 1%; overflow: visible;&quot; in quirksmode
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1311,12 ***</span>
      {
          unsigned propertyCount = m_mutableStyle-&gt;propertyCount();
          for (unsigned i = 0; i &lt; propertyCount; ++i) {
              StyleProperties::PropertyReference property = m_mutableStyle-&gt;propertyAt(i);
              CSSValue&amp; value = *property.value();
<span class="line-modified">!             if (property.id() == CSSPropertyFontFamily &amp;&amp; usesForbiddenSystemFontAsOnlyFontFamilyName(value)) {</span>
<span class="line-modified">!                 shouldRemoveFontFamily = true;</span>
                  continue;
              }
              if (!is&lt;CSSPrimitiveValue&gt;(value))
                  continue;
              if (downcast&lt;CSSPrimitiveValue&gt;(value).isPercentage()) {
<span class="line-new-header">--- 1316,15 ---</span>
      {
          unsigned propertyCount = m_mutableStyle-&gt;propertyCount();
          for (unsigned i = 0; i &lt; propertyCount; ++i) {
              StyleProperties::PropertyReference property = m_mutableStyle-&gt;propertyAt(i);
              CSSValue&amp; value = *property.value();
<span class="line-modified">!             if (property.id() == CSSPropertyFontFamily) {</span>
<span class="line-modified">!                 auto familyName = loneFontFamilyName(value);</span>
<span class="line-added">+                 if (FontCache::isSystemFontForbiddenForEditing(familyName)</span>
<span class="line-added">+                     || (standardFontFamilySerializationMode == StandardFontFamilySerializationMode::Strip &amp;&amp; familyName == standardFamily))</span>
<span class="line-added">+                     shouldRemoveFontFamily = true;</span>
                  continue;
              }
              if (!is&lt;CSSPrimitiveValue&gt;(value))
                  continue;
              if (downcast&lt;CSSPrimitiveValue&gt;(value).isPercentage()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1346,11 ***</span>
  {
      if (!m_mutableStyle)
          return;
  
      // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
<span class="line-modified">!     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element, StyleResolver::AllButEmptyCSSRules);</span>
      if (styleFromMatchedRules &amp;&amp; !styleFromMatchedRules-&gt;isEmpty())
          m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *styleFromMatchedRules);
  
      // 2. Remove style present in context and not overridden by matched rules.
      auto computedStyle = EditingStyle::create(context, EditingPropertiesInEffect);
<span class="line-new-header">--- 1354,11 ---</span>
  {
      if (!m_mutableStyle)
          return;
  
      // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
<span class="line-modified">!     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element, Style::Resolver::AllButEmptyCSSRules);</span>
      if (styleFromMatchedRules &amp;&amp; !styleFromMatchedRules-&gt;isEmpty())
          m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *styleFromMatchedRules);
  
      // 2. Remove style present in context and not overridden by matched rules.
      auto computedStyle = EditingStyle::create(context, EditingPropertiesInEffect);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1375,11 ***</span>
  void EditingStyle::removePropertiesInElementDefaultStyle(Element&amp; element)
  {
      if (!m_mutableStyle || m_mutableStyle-&gt;isEmpty())
          return;
  
<span class="line-modified">!     RefPtr&lt;MutableStyleProperties&gt; defaultStyle = styleFromMatchedRulesForElement(element, StyleResolver::UAAndUserCSSRules);</span>
  
      removePropertiesInStyle(m_mutableStyle.get(), defaultStyle.get());
  }
  
  template&lt;typename T&gt;
<span class="line-new-header">--- 1383,11 ---</span>
  void EditingStyle::removePropertiesInElementDefaultStyle(Element&amp; element)
  {
      if (!m_mutableStyle || m_mutableStyle-&gt;isEmpty())
          return;
  
<span class="line-modified">!     RefPtr&lt;MutableStyleProperties&gt; defaultStyle = styleFromMatchedRulesForElement(element, Style::Resolver::UAAndUserCSSRules);</span>
  
      removePropertiesInStyle(m_mutableStyle.get(), defaultStyle.get());
  }
  
  template&lt;typename T&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1578,12 ***</span>
      auto* renderer = element.renderer();
      if (!m_mutableStyle || !renderer || !renderer-&gt;style().hasAppleColorFilter())
          return *this;
  
      bool hasColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyColor);
      bool hasBackgroundColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor);
<span class="line-modified">!     if (!hasColor &amp;&amp; !hasBackgroundColor)</span>
          return *this;
  
      auto styleWithInvertedColors = copy();
      ASSERT(styleWithInvertedColors-&gt;m_mutableStyle);
  
<span class="line-new-header">--- 1586,13 ---</span>
      auto* renderer = element.renderer();
      if (!m_mutableStyle || !renderer || !renderer-&gt;style().hasAppleColorFilter())
          return *this;
  
      bool hasColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyColor);
<span class="line-added">+     bool hasCaretColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyCaretColor);</span>
      bool hasBackgroundColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor);
<span class="line-modified">!     if (!hasColor &amp;&amp; !hasCaretColor &amp;&amp; !hasBackgroundColor)</span>
          return *this;
  
      auto styleWithInvertedColors = copy();
      ASSERT(styleWithInvertedColors-&gt;m_mutableStyle);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1595,10 ***</span>
<span class="line-new-header">--- 1604,13 ---</span>
      };
  
      if (hasColor)
          invertedColor(CSSPropertyColor);
  
<span class="line-added">+     if (hasCaretColor)</span>
<span class="line-added">+         invertedColor(CSSPropertyCaretColor);</span>
<span class="line-added">+ </span>
      if (hasBackgroundColor)
          invertedColor(CSSPropertyBackgroundColor);
  
      return styleWithInvertedColors;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1868,11 ***</span>
  }
  
  int legacyFontSizeFromCSSValue(Document&amp; document, CSSPrimitiveValue* value, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode mode)
  {
      if (isCSSValueLength(value)) {
<span class="line-modified">!         int pixelFontSize = value-&gt;intValue(CSSPrimitiveValue::CSS_PX);</span>
          int legacyFontSize = Style::legacyFontSizeForPixelSize(pixelFontSize, shouldUseFixedFontDefaultSize, document);
          // Use legacy font size only if pixel value matches exactly to that of legacy font size.
          int cssPrimitiveEquivalent = legacyFontSize - 1 + CSSValueXSmall;
          if (mode == AlwaysUseLegacyFontSize || Style::fontSizeForKeyword(cssPrimitiveEquivalent, shouldUseFixedFontDefaultSize, document) == pixelFontSize)
              return legacyFontSize;
<span class="line-new-header">--- 1880,11 ---</span>
  }
  
  int legacyFontSizeFromCSSValue(Document&amp; document, CSSPrimitiveValue* value, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode mode)
  {
      if (isCSSValueLength(value)) {
<span class="line-modified">!         int pixelFontSize = value-&gt;intValue(CSSUnitType::CSS_PX);</span>
          int legacyFontSize = Style::legacyFontSizeForPixelSize(pixelFontSize, shouldUseFixedFontDefaultSize, document);
          // Use legacy font size only if pixel value matches exactly to that of legacy font size.
          int cssPrimitiveEquivalent = legacyFontSize - 1 + CSSValueXSmall;
          if (mode == AlwaysUseLegacyFontSize || Style::fontSizeForKeyword(cssPrimitiveEquivalent, shouldUseFixedFontDefaultSize, document) == pixelFontSize)
              return legacyFontSize;
</pre>
<center><a href="EditingBehavior.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EditingStyle.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
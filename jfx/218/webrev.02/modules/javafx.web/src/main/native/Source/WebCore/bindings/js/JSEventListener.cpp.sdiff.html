<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSEventCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSEventListener.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
113     JSObject* jsFunction = this-&gt;jsFunction(scriptExecutionContext);
114     if (!jsFunction)
115         return;
116 
117     JSDOMGlobalObject* globalObject = toJSDOMGlobalObject(scriptExecutionContext, m_isolatedWorld);
118     if (!globalObject)
119         return;
120 
121     if (scriptExecutionContext.isDocument()) {
122         JSDOMWindow* window = jsCast&lt;JSDOMWindow*&gt;(globalObject);
123         if (!window-&gt;wrapped().isCurrentlyDisplayedInFrame())
124             return;
125         if (wasCreatedFromMarkup() &amp;&amp; !scriptExecutionContext.contentSecurityPolicy()-&gt;allowInlineEventHandlers(sourceURL(), sourcePosition().m_line))
126             return;
127         // FIXME: Is this check needed for other contexts?
128         ScriptController&amp; script = window-&gt;wrapped().frame()-&gt;script();
129         if (!script.canExecuteScripts(AboutToExecuteScript) || script.isPaused())
130             return;
131     }
132 
<span class="line-modified">133     ExecState* exec = globalObject-&gt;globalExec();</span>
134 
135     JSValue handleEventFunction = jsFunction;
136 
137     CallData callData;
138     CallType callType = getCallData(vm, handleEventFunction, callData);
139 
<span class="line-modified">140     // If jsFunction is not actually a function, see if it implements the EventListener interface and use that</span>
141     if (callType == CallType::None) {
<span class="line-modified">142         handleEventFunction = jsFunction-&gt;get(exec, Identifier::fromString(vm, &quot;handleEvent&quot;));</span>



143         if (UNLIKELY(scope.exception())) {
144             auto* exception = scope.exception();
145             scope.clearException();
146             event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">147             reportException(exec, exception);</span>
148             return;
149         }
150         callType = getCallData(vm, handleEventFunction, callData);





151     }
152 
<span class="line-removed">153     if (callType == CallType::None)</span>
<span class="line-removed">154         return;</span>
<span class="line-removed">155 </span>
156     Ref&lt;JSEventListener&gt; protectedThis(*this);
157 
158     MarkedArgumentBuffer args;
<span class="line-modified">159     args.append(toJS(exec, globalObject, &amp;event));</span>
160     ASSERT(!args.hasOverflowed());
161 
162     Event* savedEvent = globalObject-&gt;currentEvent();
163 
164     // window.event should not be set when the target is inside a shadow tree, as per the DOM specification.
165     bool isTargetInsideShadowTree = is&lt;Node&gt;(event.currentTarget()) &amp;&amp; downcast&lt;Node&gt;(*event.currentTarget()).isInShadowTree();
166     if (!isTargetInsideShadowTree)
167         globalObject-&gt;setCurrentEvent(&amp;event);
168 
169     VMEntryScope entryScope(vm, vm.entryScope ? vm.entryScope-&gt;globalObject() : globalObject);
170 
<span class="line-modified">171     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionCall(&amp;scriptExecutionContext, callType, callData);</span>
172 
<span class="line-modified">173     JSValue thisValue = handleEventFunction == jsFunction ? toJS(exec, globalObject, event.currentTarget()) : jsFunction;</span>
174     NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">175     JSValue retval = JSExecState::profiledCall(exec, JSC::ProfilingReason::Other, handleEventFunction, callType, callData, thisValue, args, exception);</span>
176 
<span class="line-modified">177     InspectorInstrumentation::didCallFunction(cookie, &amp;scriptExecutionContext);</span>
178 
179     globalObject-&gt;setCurrentEvent(savedEvent);
180 
181     if (is&lt;WorkerGlobalScope&gt;(scriptExecutionContext)) {
182         auto&amp; scriptController = *downcast&lt;WorkerGlobalScope&gt;(scriptExecutionContext).script();
183         bool terminatorCausedException = (scope.exception() &amp;&amp; isTerminatedExecutionException(vm, scope.exception()));
184         if (terminatorCausedException || scriptController.isTerminatingExecution())
185             scriptController.forbidExecution();
186     }
187 
188     if (exception) {
189         event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">190         reportException(exec, exception);</span>
191         return;
192     }
193 
194     if (!m_isAttribute) {
195         // This is an EventListener and there is therefore no need for any return value handling.
196         return;
197     }
198 
199     // Do return value handling for event handlers (https://html.spec.whatwg.org/#the-event-handler-processing-algorithm).
200 
201     if (event.type() == eventNames().beforeunloadEvent) {
202         // This is a OnBeforeUnloadEventHandler, and therefore the return value must be coerced into a String.
203         if (is&lt;BeforeUnloadEvent&gt;(event))
<span class="line-modified">204             handleBeforeUnloadEventReturnValue(downcast&lt;BeforeUnloadEvent&gt;(event), convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*exec, retval));</span>
205         return;
206     }
207 
208     if (retval.isFalse())
209         event.preventDefault();
210 }
211 
212 bool JSEventListener::operator==(const EventListener&amp; listener) const
213 {
214     if (!is&lt;JSEventListener&gt;(listener))
215         return false;
216     auto&amp; other = downcast&lt;JSEventListener&gt;(listener);
217     return m_jsFunction == other.m_jsFunction &amp;&amp; m_isAttribute == other.m_isAttribute;
218 }
219 















220 static inline JSC::JSValue eventHandlerAttribute(EventListener* abstractListener, ScriptExecutionContext&amp; context)
221 {
222     if (!is&lt;JSEventListener&gt;(abstractListener))
223         return jsNull();
224 
225     auto* function = downcast&lt;JSEventListener&gt;(*abstractListener).jsFunction(context);
226     if (!function)
227         return jsNull();
228 
229     return function;
230 }
231 
<span class="line-modified">232 static inline RefPtr&lt;JSEventListener&gt; createEventListenerForEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSValue listener, JSC::JSObject&amp; wrapper)</span>
233 {
234     if (!listener.isObject())
235         return nullptr;
<span class="line-modified">236     return JSEventListener::create(asObject(listener), &amp;wrapper, true, currentWorld(state));</span>
237 }
238 
239 JSC::JSValue eventHandlerAttribute(EventTarget&amp; target, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
240 {
241     return eventHandlerAttribute(target.attributeEventListener(eventType, isolatedWorld), *target.scriptExecutionContext());
242 }
243 
<span class="line-modified">244 void setEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, EventTarget&amp; target, const AtomString&amp; eventType, JSC::JSValue value)</span>
245 {
<span class="line-modified">246     target.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, wrapper), currentWorld(state));</span>
247 }
248 
249 JSC::JSValue windowEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
250 {
251     auto&amp; document = element.document();
252     return eventHandlerAttribute(document.getWindowAttributeEventListener(eventType, isolatedWorld), document);
253 }
254 
<span class="line-modified">255 void setWindowEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
256 {
257     ASSERT(wrapper.globalObject());
<span class="line-modified">258     element.document().setWindowAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, *wrapper.globalObject()), currentWorld(state));</span>
259 }
260 
261 JSC::JSValue windowEventHandlerAttribute(DOMWindow&amp; window, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
262 {
263     return eventHandlerAttribute(window, eventType, isolatedWorld);
264 }
265 
<span class="line-modified">266 void setWindowEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, DOMWindow&amp; window, const AtomString&amp; eventType, JSC::JSValue value)</span>
267 {
<span class="line-modified">268     setEventHandlerAttribute(state, wrapper, window, eventType, value);</span>
269 }
270 
271 JSC::JSValue documentEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
272 {
273     auto&amp; document = element.document();
274     return eventHandlerAttribute(document.attributeEventListener(eventType, isolatedWorld), document);
275 }
276 
<span class="line-modified">277 void setDocumentEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
278 {
279     ASSERT(wrapper.globalObject());
280     auto&amp; document = element.document();
<span class="line-modified">281     auto* documentWrapper = JSC::jsCast&lt;JSDocument*&gt;(toJS(&amp;state, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(wrapper.globalObject()), document));</span>
282     ASSERT(documentWrapper);
<span class="line-modified">283     document.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, *documentWrapper), currentWorld(state));</span>
284 }
285 
286 JSC::JSValue documentEventHandlerAttribute(Document&amp; document, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
287 {
288     return eventHandlerAttribute(document, eventType, isolatedWorld);
289 }
290 
<span class="line-modified">291 void setDocumentEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, Document&amp; document, const AtomString&amp; eventType, JSC::JSValue value)</span>
292 {
<span class="line-modified">293     setEventHandlerAttribute(state, wrapper, document, eventType, value);</span>
294 }
295 
296 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
113     JSObject* jsFunction = this-&gt;jsFunction(scriptExecutionContext);
114     if (!jsFunction)
115         return;
116 
117     JSDOMGlobalObject* globalObject = toJSDOMGlobalObject(scriptExecutionContext, m_isolatedWorld);
118     if (!globalObject)
119         return;
120 
121     if (scriptExecutionContext.isDocument()) {
122         JSDOMWindow* window = jsCast&lt;JSDOMWindow*&gt;(globalObject);
123         if (!window-&gt;wrapped().isCurrentlyDisplayedInFrame())
124             return;
125         if (wasCreatedFromMarkup() &amp;&amp; !scriptExecutionContext.contentSecurityPolicy()-&gt;allowInlineEventHandlers(sourceURL(), sourcePosition().m_line))
126             return;
127         // FIXME: Is this check needed for other contexts?
128         ScriptController&amp; script = window-&gt;wrapped().frame()-&gt;script();
129         if (!script.canExecuteScripts(AboutToExecuteScript) || script.isPaused())
130             return;
131     }
132 
<span class="line-modified">133     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
134 
135     JSValue handleEventFunction = jsFunction;
136 
137     CallData callData;
138     CallType callType = getCallData(vm, handleEventFunction, callData);
139 
<span class="line-modified">140     // If jsFunction is not actually a function and this is an EventListener, see if it implements callback interface.</span>
141     if (callType == CallType::None) {
<span class="line-modified">142         if (m_isAttribute)</span>
<span class="line-added">143             return;</span>
<span class="line-added">144 </span>
<span class="line-added">145         handleEventFunction = jsFunction-&gt;get(lexicalGlobalObject, Identifier::fromString(vm, &quot;handleEvent&quot;));</span>
146         if (UNLIKELY(scope.exception())) {
147             auto* exception = scope.exception();
148             scope.clearException();
149             event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">150             reportException(lexicalGlobalObject, exception);</span>
151             return;
152         }
153         callType = getCallData(vm, handleEventFunction, callData);
<span class="line-added">154         if (callType == CallType::None) {</span>
<span class="line-added">155             event.target()-&gt;uncaughtExceptionInEventHandler();</span>
<span class="line-added">156             reportException(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;&#39;handleEvent&#39; property of event listener should be callable&quot;_s));</span>
<span class="line-added">157             return;</span>
<span class="line-added">158         }</span>
159     }
160 



161     Ref&lt;JSEventListener&gt; protectedThis(*this);
162 
163     MarkedArgumentBuffer args;
<span class="line-modified">164     args.append(toJS(lexicalGlobalObject, globalObject, &amp;event));</span>
165     ASSERT(!args.hasOverflowed());
166 
167     Event* savedEvent = globalObject-&gt;currentEvent();
168 
169     // window.event should not be set when the target is inside a shadow tree, as per the DOM specification.
170     bool isTargetInsideShadowTree = is&lt;Node&gt;(event.currentTarget()) &amp;&amp; downcast&lt;Node&gt;(*event.currentTarget()).isInShadowTree();
171     if (!isTargetInsideShadowTree)
172         globalObject-&gt;setCurrentEvent(&amp;event);
173 
174     VMEntryScope entryScope(vm, vm.entryScope ? vm.entryScope-&gt;globalObject() : globalObject);
175 
<span class="line-modified">176     JSExecState::instrumentFunctionCall(&amp;scriptExecutionContext, callType, callData);</span>
177 
<span class="line-modified">178     JSValue thisValue = handleEventFunction == jsFunction ? toJS(lexicalGlobalObject, globalObject, event.currentTarget()) : jsFunction;</span>
179     NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">180     JSValue retval = JSExecState::profiledCall(lexicalGlobalObject, JSC::ProfilingReason::Other, handleEventFunction, callType, callData, thisValue, args, exception);</span>
181 
<span class="line-modified">182     InspectorInstrumentation::didCallFunction(&amp;scriptExecutionContext);</span>
183 
184     globalObject-&gt;setCurrentEvent(savedEvent);
185 
186     if (is&lt;WorkerGlobalScope&gt;(scriptExecutionContext)) {
187         auto&amp; scriptController = *downcast&lt;WorkerGlobalScope&gt;(scriptExecutionContext).script();
188         bool terminatorCausedException = (scope.exception() &amp;&amp; isTerminatedExecutionException(vm, scope.exception()));
189         if (terminatorCausedException || scriptController.isTerminatingExecution())
190             scriptController.forbidExecution();
191     }
192 
193     if (exception) {
194         event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">195         reportException(lexicalGlobalObject, exception);</span>
196         return;
197     }
198 
199     if (!m_isAttribute) {
200         // This is an EventListener and there is therefore no need for any return value handling.
201         return;
202     }
203 
204     // Do return value handling for event handlers (https://html.spec.whatwg.org/#the-event-handler-processing-algorithm).
205 
206     if (event.type() == eventNames().beforeunloadEvent) {
207         // This is a OnBeforeUnloadEventHandler, and therefore the return value must be coerced into a String.
208         if (is&lt;BeforeUnloadEvent&gt;(event))
<span class="line-modified">209             handleBeforeUnloadEventReturnValue(downcast&lt;BeforeUnloadEvent&gt;(event), convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, retval));</span>
210         return;
211     }
212 
213     if (retval.isFalse())
214         event.preventDefault();
215 }
216 
217 bool JSEventListener::operator==(const EventListener&amp; listener) const
218 {
219     if (!is&lt;JSEventListener&gt;(listener))
220         return false;
221     auto&amp; other = downcast&lt;JSEventListener&gt;(listener);
222     return m_jsFunction == other.m_jsFunction &amp;&amp; m_isAttribute == other.m_isAttribute;
223 }
224 
<span class="line-added">225 String JSEventListener::functionName() const</span>
<span class="line-added">226 {</span>
<span class="line-added">227     if (!m_wrapper || !m_jsFunction)</span>
<span class="line-added">228         return { };</span>
<span class="line-added">229 </span>
<span class="line-added">230     auto&amp; vm = isolatedWorld().vm();</span>
<span class="line-added">231     JSC::JSLockHolder lock(vm);</span>
<span class="line-added">232 </span>
<span class="line-added">233     auto* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, m_jsFunction.get());</span>
<span class="line-added">234     if (!handlerFunction)</span>
<span class="line-added">235         return { };</span>
<span class="line-added">236 </span>
<span class="line-added">237     return handlerFunction-&gt;name(vm);</span>
<span class="line-added">238 }</span>
<span class="line-added">239 </span>
240 static inline JSC::JSValue eventHandlerAttribute(EventListener* abstractListener, ScriptExecutionContext&amp; context)
241 {
242     if (!is&lt;JSEventListener&gt;(abstractListener))
243         return jsNull();
244 
245     auto* function = downcast&lt;JSEventListener&gt;(*abstractListener).jsFunction(context);
246     if (!function)
247         return jsNull();
248 
249     return function;
250 }
251 
<span class="line-modified">252 static inline RefPtr&lt;JSEventListener&gt; createEventListenerForEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue listener, JSC::JSObject&amp; wrapper)</span>
253 {
254     if (!listener.isObject())
255         return nullptr;
<span class="line-modified">256     return JSEventListener::create(asObject(listener), &amp;wrapper, true, currentWorld(lexicalGlobalObject));</span>
257 }
258 
259 JSC::JSValue eventHandlerAttribute(EventTarget&amp; target, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
260 {
261     return eventHandlerAttribute(target.attributeEventListener(eventType, isolatedWorld), *target.scriptExecutionContext());
262 }
263 
<span class="line-modified">264 void setEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, EventTarget&amp; target, const AtomString&amp; eventType, JSC::JSValue value)</span>
265 {
<span class="line-modified">266     target.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, wrapper), currentWorld(lexicalGlobalObject));</span>
267 }
268 
269 JSC::JSValue windowEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
270 {
271     auto&amp; document = element.document();
272     return eventHandlerAttribute(document.getWindowAttributeEventListener(eventType, isolatedWorld), document);
273 }
274 
<span class="line-modified">275 void setWindowEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
276 {
277     ASSERT(wrapper.globalObject());
<span class="line-modified">278     element.document().setWindowAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *wrapper.globalObject()), currentWorld(lexicalGlobalObject));</span>
279 }
280 
281 JSC::JSValue windowEventHandlerAttribute(DOMWindow&amp; window, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
282 {
283     return eventHandlerAttribute(window, eventType, isolatedWorld);
284 }
285 
<span class="line-modified">286 void setWindowEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, DOMWindow&amp; window, const AtomString&amp; eventType, JSC::JSValue value)</span>
287 {
<span class="line-modified">288     setEventHandlerAttribute(lexicalGlobalObject, wrapper, window, eventType, value);</span>
289 }
290 
291 JSC::JSValue documentEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
292 {
293     auto&amp; document = element.document();
294     return eventHandlerAttribute(document.attributeEventListener(eventType, isolatedWorld), document);
295 }
296 
<span class="line-modified">297 void setDocumentEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
298 {
299     ASSERT(wrapper.globalObject());
300     auto&amp; document = element.document();
<span class="line-modified">301     auto* documentWrapper = JSC::jsCast&lt;JSDocument*&gt;(toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(wrapper.globalObject()), document));</span>
302     ASSERT(documentWrapper);
<span class="line-modified">303     document.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *documentWrapper), currentWorld(lexicalGlobalObject));</span>
304 }
305 
306 JSC::JSValue documentEventHandlerAttribute(Document&amp; document, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
307 {
308     return eventHandlerAttribute(document, eventType, isolatedWorld);
309 }
310 
<span class="line-modified">311 void setDocumentEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, Document&amp; document, const AtomString&amp; eventType, JSC::JSValue value)</span>
312 {
<span class="line-modified">313     setEventHandlerAttribute(lexicalGlobalObject, wrapper, document, eventType, value);</span>
314 }
315 
316 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSEventCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSEventListener.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
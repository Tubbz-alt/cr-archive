diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -48,11 +48,11 @@
 public:
     template<typename CellType, SubspaceAccess>
     static CompleteSubspace* subspaceFor(VM& vm)
     {
         static_assert(!CellType::needsDestruction, "");
-        return &vm.jsValueGigacageCellSpace;
+        return &vm.variableSizedCellSpace;
     }
 
     // Creates an arguments object but leaves it uninitialized. This is dangerous if we GC right
     // after allocation.
     static DirectArguments* createUninitialized(VM&, Structure*, unsigned length, unsigned capacity);
@@ -60,28 +60,28 @@
     // Creates an arguments object and initializes everything to the empty value. Use this if you
     // cannot guarantee that you'll immediately initialize all of the elements.
     static DirectArguments* create(VM&, Structure*, unsigned length, unsigned capacity);
 
     // Creates an arguments object by copying the argumnets from the stack.
-    static DirectArguments* createByCopying(ExecState*);
+    static DirectArguments* createByCopying(JSGlobalObject*, CallFrame*);
 
     static size_t estimatedSize(JSCell*, VM&);
     static void visitChildren(JSCell*, SlotVisitor&);
 
     uint32_t internalLength() const
     {
         return m_length;
     }
 
-    uint32_t length(ExecState* exec) const
+    uint32_t length(JSGlobalObject* globalObject) const
     {
         if (UNLIKELY(m_mappedArguments)) {
-            VM& vm = exec->vm();
+            VM& vm = getVM(globalObject);
             auto scope = DECLARE_THROW_SCOPE(vm);
-            JSValue value = get(exec, vm.propertyNames->length);
+            JSValue value = get(globalObject, vm.propertyNames->length);
             RETURN_IF_EXCEPTION(scope, 0);
-            RELEASE_AND_RETURN(scope, value.toUInt32(exec));
+            RELEASE_AND_RETURN(scope, value.toUInt32(globalObject));
         }
         return m_length;
     }
 
     bool isMappedArgument(uint32_t i) const
@@ -123,30 +123,30 @@
         return storage()[offset.offset()];
     }
 
     // Methods intended for use by the GenericArguments mixin.
     bool overrodeThings() const { return !!m_mappedArguments; }
-    void overrideThings(VM&);
-    void overrideThingsIfNecessary(VM&);
-    void unmapArgument(VM&, unsigned index);
+    void overrideThings(JSGlobalObject*);
+    void overrideThingsIfNecessary(JSGlobalObject*);
+    void unmapArgument(JSGlobalObject*, unsigned index);
 
-    void initModifiedArgumentsDescriptorIfNecessary(VM& vm)
+    void initModifiedArgumentsDescriptorIfNecessary(JSGlobalObject* globalObject)
     {
-        GenericArguments<DirectArguments>::initModifiedArgumentsDescriptorIfNecessary(vm, m_length);
+        GenericArguments<DirectArguments>::initModifiedArgumentsDescriptorIfNecessary(globalObject, m_length);
     }
 
-    void setModifiedArgumentDescriptor(VM& vm, unsigned index)
+    void setModifiedArgumentDescriptor(JSGlobalObject* globalObject, unsigned index)
     {
-        GenericArguments<DirectArguments>::setModifiedArgumentDescriptor(vm, index, m_length);
+        GenericArguments<DirectArguments>::setModifiedArgumentDescriptor(globalObject, index, m_length);
     }
 
     bool isModifiedArgumentDescriptor(unsigned index)
     {
         return GenericArguments<DirectArguments>::isModifiedArgumentDescriptor(index, m_length);
     }
 
-    void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);
+    void copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length);
 
     DECLARE_INFO;
 
     static Structure* createStructure(VM&, JSGlobalObject*, JSValue prototype);
 
@@ -182,8 +182,10 @@
     WriteBarrier<JSFunction> m_callee;
     uint32_t m_length; // Always the actual length of captured arguments and never what was stored into the length property.
     uint32_t m_minCapacity; // The max of this and length determines the capacity of this object. It may be the actual capacity, or maybe something smaller. We arrange it this way to be kind to the JITs.
     using MappedArguments = CagedBarrierPtr<Gigacage::Primitive, bool>;
     MappedArguments m_mappedArguments; // If non-null, it means that length, callee, and caller are fully materialized properties.
+
+    friend size_t cellSize(VM&, JSCell*);
 };
 
 } // namespace JSC

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2008, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2009 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;CacheValidation.h&quot;
 30 #include &quot;CertificateInfo.h&quot;
 31 #include &quot;HTTPHeaderMap.h&quot;
 32 #include &quot;NetworkLoadMetrics.h&quot;
 33 #include &quot;ParsedContentRange.h&quot;
 34 #include &lt;wtf/Markable.h&gt;
 35 #include &lt;wtf/URL.h&gt;
 36 #include &lt;wtf/WallTime.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 class ResourceResponse;
 41 
 42 bool isScriptAllowedByNosniff(const ResourceResponse&amp;);
 43 
 44 enum class UsedLegacyTLS : bool { No, Yes };
 45 
 46 // Do not use this class directly, use the class ResourceResponse instead
 47 class ResourceResponseBase {
 48     WTF_MAKE_FAST_ALLOCATED;
 49 public:
 50     enum class Type : uint8_t { Basic, Cors, Default, Error, Opaque, Opaqueredirect };
 51     static constexpr unsigned bitWidthOfType = 3;
 52     enum class Tainting : uint8_t { Basic, Cors, Opaque, Opaqueredirect };
 53     static constexpr unsigned bitWidthOfTainting = 2;
 54 
 55     static bool isRedirectionStatusCode(int code) { return code == 301 || code == 302 || code == 303 || code == 307 || code == 308; }
 56 
 57     struct CrossThreadData {
 58         CrossThreadData(const CrossThreadData&amp;) = delete;
 59         CrossThreadData&amp; operator=(const CrossThreadData&amp;) = delete;
 60         CrossThreadData() = default;
 61         CrossThreadData(CrossThreadData&amp;&amp;) = default;
 62 
 63         URL url;
 64         String mimeType;
 65         long long expectedContentLength;
 66         String textEncodingName;
 67         int httpStatusCode;
 68         String httpStatusText;
 69         String httpVersion;
 70         HTTPHeaderMap httpHeaderFields;
 71         NetworkLoadMetrics networkLoadMetrics;
 72         Type type;
 73         Tainting tainting;
 74         bool isRedirected;
 75         bool isRangeRequested;
 76     };
 77 
 78     CrossThreadData crossThreadData() const;
 79     static ResourceResponse fromCrossThreadData(CrossThreadData&amp;&amp;);
 80 
 81     bool isNull() const { return m_isNull; }
 82     WEBCORE_EXPORT bool isHTTP() const;
 83     WEBCORE_EXPORT bool isSuccessful() const;
 84 
 85     WEBCORE_EXPORT const URL&amp; url() const;
 86     WEBCORE_EXPORT void setURL(const URL&amp;);
 87 
 88     WEBCORE_EXPORT const String&amp; mimeType() const;
 89     WEBCORE_EXPORT void setMimeType(const String&amp; mimeType);
 90 
 91     WEBCORE_EXPORT long long expectedContentLength() const;
 92     WEBCORE_EXPORT void setExpectedContentLength(long long expectedContentLength);
 93 
 94     WEBCORE_EXPORT const String&amp; textEncodingName() const;
 95     WEBCORE_EXPORT void setTextEncodingName(const String&amp; name);
 96 
 97     WEBCORE_EXPORT int httpStatusCode() const;
 98     WEBCORE_EXPORT void setHTTPStatusCode(int);
 99     WEBCORE_EXPORT bool isRedirection() const;
100 
101     WEBCORE_EXPORT const String&amp; httpStatusText() const;
102     WEBCORE_EXPORT void setHTTPStatusText(const String&amp;);
103 
104     WEBCORE_EXPORT const String&amp; httpVersion() const;
105     WEBCORE_EXPORT void setHTTPVersion(const String&amp;);
106     WEBCORE_EXPORT bool isHTTP09() const;
107 
108     WEBCORE_EXPORT const HTTPHeaderMap&amp; httpHeaderFields() const;
109     void setHTTPHeaderFields(HTTPHeaderMap&amp;&amp;);
110 
111     enum class SanitizationType { Redirection, RemoveCookies, CrossOriginSafe };
112     WEBCORE_EXPORT void sanitizeHTTPHeaderFields(SanitizationType);
113 
114     String httpHeaderField(const String&amp; name) const;
115     WEBCORE_EXPORT String httpHeaderField(HTTPHeaderName) const;
116     WEBCORE_EXPORT void setHTTPHeaderField(const String&amp; name, const String&amp; value);
117     WEBCORE_EXPORT void setHTTPHeaderField(HTTPHeaderName, const String&amp; value);
118 
119     WEBCORE_EXPORT void addHTTPHeaderField(HTTPHeaderName, const String&amp; value);
120     WEBCORE_EXPORT void addHTTPHeaderField(const String&amp; name, const String&amp; value);
121 
122     // Instead of passing a string literal to any of these functions, just use a HTTPHeaderName instead.
123     template&lt;size_t length&gt; String httpHeaderField(const char (&amp;)[length]) const = delete;
124     template&lt;size_t length&gt; void setHTTPHeaderField(const char (&amp;)[length], const String&amp;) = delete;
125     template&lt;size_t length&gt; void addHTTPHeaderField(const char (&amp;)[length], const String&amp;) = delete;
126 
127     bool isMultipart() const { return mimeType() == &quot;multipart/x-mixed-replace&quot;; }
128 
129     WEBCORE_EXPORT bool isAttachment() const;
130     WEBCORE_EXPORT bool isAttachmentWithFilename() const;
131     WEBCORE_EXPORT String suggestedFilename() const;
132     WEBCORE_EXPORT static String sanitizeSuggestedFilename(const String&amp;);
133 
134     WEBCORE_EXPORT void includeCertificateInfo(UsedLegacyTLS = UsedLegacyTLS::No) const;
135     const Optional&lt;CertificateInfo&gt;&amp; certificateInfo() const { return m_certificateInfo; };
136     bool usedLegacyTLS() const { return m_usedLegacyTLS == UsedLegacyTLS::Yes; }
137 
138     // These functions return parsed values of the corresponding response headers.
139     WEBCORE_EXPORT bool cacheControlContainsNoCache() const;
140     WEBCORE_EXPORT bool cacheControlContainsNoStore() const;
141     WEBCORE_EXPORT bool cacheControlContainsMustRevalidate() const;
142     WEBCORE_EXPORT bool cacheControlContainsImmutable() const;
143     WEBCORE_EXPORT bool hasCacheValidatorFields() const;
144     WEBCORE_EXPORT Optional&lt;Seconds&gt; cacheControlMaxAge() const;
145     WEBCORE_EXPORT Optional&lt;Seconds&gt; cacheControlStaleWhileRevalidate() const;
146     WEBCORE_EXPORT Optional&lt;WallTime&gt; date() const;
147     WEBCORE_EXPORT Optional&lt;Seconds&gt; age() const;
148     WEBCORE_EXPORT Optional&lt;WallTime&gt; expires() const;
149     WEBCORE_EXPORT Optional&lt;WallTime&gt; lastModified() const;
150     const ParsedContentRange&amp; contentRange() const;
151 
152     enum class Source : uint8_t { Unknown, Network, DiskCache, DiskCacheAfterValidation, MemoryCache, MemoryCacheAfterValidation, ServiceWorker, ApplicationCache, DOMCache, InspectorOverride };
153     WEBCORE_EXPORT Source source() const;
154     void setSource(Source source)
155     {
156         ASSERT(source != Source::Unknown);
157         m_source = source;
158     }
159 
160     // FIXME: This should be eliminated from ResourceResponse.
161     // Network loading metrics should be delivered via didFinishLoad
162     // and should not be part of the ResourceResponse.
163     NetworkLoadMetrics&amp; deprecatedNetworkLoadMetrics() const { return m_networkLoadMetrics; }
164 
165     // The ResourceResponse subclass may &quot;shadow&quot; this method to provide platform-specific memory usage information
166     unsigned memoryUsage() const
167     {
168         // average size, mostly due to URL and Header Map strings
169         return 1280;
170     }
171 
172     WEBCORE_EXPORT void setType(Type);
173     Type type() const { return m_type; }
174 
175     void setRedirected(bool isRedirected) { m_isRedirected = isRedirected; }
176     bool isRedirected() const { return m_isRedirected; }
177 
178     void setTainting(Tainting tainting) { m_tainting = tainting; }
179     Tainting tainting() const { return m_tainting; }
180 
181     static ResourceResponse filter(const ResourceResponse&amp;);
182 
183     WEBCORE_EXPORT static ResourceResponse syntheticRedirectResponse(const URL&amp; fromURL, const URL&amp; toURL);
184 
185     static bool compare(const ResourceResponse&amp;, const ResourceResponse&amp;);
186 
187     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
188     template&lt;class Decoder&gt; static bool decode(Decoder&amp;, ResourceResponseBase&amp;);
189 
190     bool isRangeRequested() const { return m_isRangeRequested; }
191     void setAsRangeRequested() { m_isRangeRequested = true; }
192 
193 protected:
194     enum InitLevel {
195         Uninitialized,
196         CommonFieldsOnly,
197         AllFields
198     };
199 
200     WEBCORE_EXPORT ResourceResponseBase();
201     WEBCORE_EXPORT ResourceResponseBase(const URL&amp;, const String&amp; mimeType, long long expectedLength, const String&amp; textEncodingName);
202 
203     WEBCORE_EXPORT void lazyInit(InitLevel) const;
204 
205     // The ResourceResponse subclass should shadow these functions to lazily initialize platform specific fields
206     void platformLazyInit(InitLevel) { }
207     CertificateInfo platformCertificateInfo() const { return CertificateInfo(); };
208     String platformSuggestedFileName() const { return String(); }
209 
210     static bool platformCompare(const ResourceResponse&amp;, const ResourceResponse&amp;) { return true; }
211 
212 private:
213     void parseCacheControlDirectives() const;
214     void updateHeaderParsedState(HTTPHeaderName);
215     void sanitizeHTTPHeaderFieldsAccordingToTainting();
216 
217 protected:
218     URL m_url;
219     AtomString m_mimeType;
220     long long m_expectedContentLength { 0 };
221     AtomString m_textEncodingName;
222     AtomString m_httpStatusText;
223     AtomString m_httpVersion;
224     HTTPHeaderMap m_httpHeaderFields;
225     mutable NetworkLoadMetrics m_networkLoadMetrics;
226 
227     mutable Optional&lt;CertificateInfo&gt; m_certificateInfo;
228 
229 private:
230     mutable Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_age;
231     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_date;
232     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_expires;
233     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_lastModified;
234     mutable ParsedContentRange m_contentRange;
235     mutable CacheControlDirectives m_cacheControlDirectives;
236 
237     mutable bool m_haveParsedCacheControlHeader : 1;
238     mutable bool m_haveParsedAgeHeader : 1;
239     mutable bool m_haveParsedDateHeader : 1;
240     mutable bool m_haveParsedExpiresHeader : 1;
241     mutable bool m_haveParsedLastModifiedHeader : 1;
242     mutable bool m_haveParsedContentRangeHeader : 1;
243     bool m_isRedirected : 1;
244 protected:
245     bool m_isNull : 1;
246 
247 private:
248     Source m_source { Source::Unknown };
249     Type m_type { Type::Default };
250     Tainting m_tainting { Tainting::Basic };
251     bool m_isRangeRequested { false };
252 
253 protected:
254     short m_httpStatusCode { 0 };
255     mutable UsedLegacyTLS m_usedLegacyTLS { UsedLegacyTLS::No };
256 };
257 
258 inline bool operator==(const ResourceResponse&amp; a, const ResourceResponse&amp; b) { return ResourceResponseBase::compare(a, b); }
259 inline bool operator!=(const ResourceResponse&amp; a, const ResourceResponse&amp; b) { return !(a == b); }
260 
261 template&lt;class Encoder&gt;
262 void ResourceResponseBase::encode(Encoder&amp; encoder) const
263 {
264     encoder &lt;&lt; m_isNull;
265     if (m_isNull)
266         return;
267     lazyInit(AllFields);
268 
269     encoder &lt;&lt; m_url;
270     encoder &lt;&lt; m_mimeType;
271     encoder &lt;&lt; static_cast&lt;int64_t&gt;(m_expectedContentLength);
272     encoder &lt;&lt; m_textEncodingName;
273     encoder &lt;&lt; m_httpStatusText;
274     encoder &lt;&lt; m_httpVersion;
275     encoder &lt;&lt; m_httpHeaderFields;
276 
277     // We don&#39;t want to put the networkLoadMetrics info
278     // into the disk cache, because we will never use the old info.
279     if (Encoder::isIPCEncoder)
280         encoder &lt;&lt; m_networkLoadMetrics;
281 
282     encoder &lt;&lt; m_httpStatusCode;
283     encoder &lt;&lt; m_certificateInfo;
284     encoder.encodeEnum(m_source);
285     encoder.encodeEnum(m_type);
286     encoder.encodeEnum(m_tainting);
287     encoder &lt;&lt; m_isRedirected;
288     encoder &lt;&lt; m_usedLegacyTLS;
289     encoder &lt;&lt; m_isRangeRequested;
290 }
291 
292 template&lt;class Decoder&gt;
293 bool ResourceResponseBase::decode(Decoder&amp; decoder, ResourceResponseBase&amp; response)
294 {
295     ASSERT(response.m_isNull);
296     bool responseIsNull;
297     if (!decoder.decode(responseIsNull))
298         return false;
299     if (responseIsNull)
300         return true;
301 
302     response.m_isNull = false;
303 
304     if (!decoder.decode(response.m_url))
305         return false;
306     if (!decoder.decode(response.m_mimeType))
307         return false;
308     int64_t expectedContentLength;
309     if (!decoder.decode(expectedContentLength))
310         return false;
311     response.m_expectedContentLength = expectedContentLength;
312     if (!decoder.decode(response.m_textEncodingName))
313         return false;
314     if (!decoder.decode(response.m_httpStatusText))
315         return false;
316     if (!decoder.decode(response.m_httpVersion))
317         return false;
318     if (!decoder.decode(response.m_httpHeaderFields))
319         return false;
320     // The networkLoadMetrics info is only send over IPC and not stored in disk cache.
321     if (Decoder::isIPCDecoder &amp;&amp; !decoder.decode(response.m_networkLoadMetrics))
322         return false;
323     if (!decoder.decode(response.m_httpStatusCode))
324         return false;
325     if (!decoder.decode(response.m_certificateInfo))
326         return false;
327     if (!decoder.decodeEnum(response.m_source))
328         return false;
329     if (!decoder.decodeEnum(response.m_type))
330         return false;
331     if (!decoder.decodeEnum(response.m_tainting))
332         return false;
333     bool isRedirected = false;
334     if (!decoder.decode(isRedirected))
335         return false;
336     response.m_isRedirected = isRedirected;
337     if (!decoder.decode(response.m_usedLegacyTLS))
338         return false;
339     bool isRangeRequested = false;
340     if (!decoder.decode(isRangeRequested))
341         return false;
342     response.m_isRangeRequested = isRangeRequested;
343 
344     return true;
345 }
346 
347 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGEpoch.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGForAllKills.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGFixupPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGGraph.h&quot;
  33 #include &quot;DFGInsertionSet.h&quot;
  34 #include &quot;DFGPhase.h&quot;
  35 #include &quot;DFGPredictionPropagationPhase.h&quot;
  36 #include &quot;DFGVariableAccessDataDump.h&quot;

  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;TypeLocation.h&quot;
  39 
  40 namespace JSC { namespace DFG {
  41 
  42 class FixupPhase : public Phase {
  43 public:
  44     FixupPhase(Graph&amp; graph)
  45         : Phase(graph, &quot;fixup&quot;)
  46         , m_insertionSet(graph)
  47     {
  48     }
  49 
  50     bool run()
  51     {
  52         ASSERT(m_graph.m_fixpointState == BeforeFixpoint);
  53         ASSERT(m_graph.m_form == ThreadedCPS);
  54 
  55         m_profitabilityChanged = false;
  56         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
</pre>
<hr />
<pre>
 167             return;
 168         ASSERT(block-&gt;isReachable);
 169         m_block = block;
 170         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
 171             m_currentNode = block-&gt;at(m_indexInBlock);
 172             fixupNode(m_currentNode);
 173         }
 174         m_insertionSet.execute(block);
 175     }
 176 
 177     void fixupNode(Node* node)
 178     {
 179         NodeType op = node-&gt;op();
 180 
 181         switch (op) {
 182         case SetLocal: {
 183             // This gets handled by fixupGetAndSetLocalsInBlock().
 184             return;
 185         }
 186 













































 187         case ValueSub: {
 188             Edge&amp; child1 = node-&gt;child1();
 189             Edge&amp; child2 = node-&gt;child2();
 190 
 191             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 192                 fixEdge&lt;BigIntUse&gt;(child1);
 193                 fixEdge&lt;BigIntUse&gt;(child2);
 194                 break;
 195             }
 196 
 197             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {
 198                 fixEdge&lt;UntypedUse&gt;(child1);
 199                 fixEdge&lt;UntypedUse&gt;(child2);
 200                 break;
 201             }
 202 
 203             if (attemptToMakeIntegerAdd(node)) {
 204                 // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 205                 // https://bugs.webkit.org/show_bug.cgi?id=190607
 206                 node-&gt;setOp(ArithSub);
 207                 break;
 208             }
 209 
 210             fixDoubleOrBooleanEdge(node-&gt;child1());
 211             fixDoubleOrBooleanEdge(node-&gt;child2());
 212             node-&gt;setOp(ArithSub);
 213             node-&gt;setResult(NodeResultDouble);
 214 
 215             break;
 216         }
 217 
 218         case ValueBitLShift:

 219         case ValueBitXor:
 220         case ValueBitOr:
 221         case ValueBitAnd: {
 222             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 223                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 224                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 225                 node-&gt;clearFlags(NodeMustGenerate);
 226                 break;
 227             }
 228 
 229             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 230                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 231                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 232                 break;
 233             }
 234 
 235             switch (op) {
 236             case ValueBitXor:
 237                 node-&gt;setOp(ArithBitXor);
 238                 break;
 239             case ValueBitOr:
 240                 node-&gt;setOp(ArithBitOr);
 241                 break;
 242             case ValueBitAnd:
 243                 node-&gt;setOp(ArithBitAnd);
 244                 break;
 245             case ValueBitLShift:
 246                 node-&gt;setOp(ArithBitLShift);
 247                 break;



 248             default:
 249                 DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
 250                 break;
 251             }
 252 
 253             node-&gt;clearFlags(NodeMustGenerate);
 254             node-&gt;setResult(NodeResultInt32);
 255             fixIntConvertingEdge(node-&gt;child1());
 256             fixIntConvertingEdge(node-&gt;child2());
 257             break;
 258         }
 259 
 260         case ValueBitNot: {
 261             Edge&amp; operandEdge = node-&gt;child1();
 262 
 263             if (operandEdge.node()-&gt;shouldSpeculateBigInt()) {
 264                 node-&gt;clearFlags(NodeMustGenerate);
 265                 fixEdge&lt;BigIntUse&gt;(operandEdge);
 266             } else if (operandEdge.node()-&gt;shouldSpeculateUntypedForBitOps())
 267                 fixEdge&lt;UntypedUse&gt;(operandEdge);
 268             else {
 269                 node-&gt;setOp(ArithBitNot);
 270                 node-&gt;setResult(NodeResultInt32);
 271                 node-&gt;clearFlags(NodeMustGenerate);
 272                 fixIntConvertingEdge(operandEdge);
 273             }
 274             break;
 275         }
 276 
 277         case ArithBitNot: {
 278             Edge&amp; operandEdge = node-&gt;child1();
 279 
 280             fixIntConvertingEdge(operandEdge);
 281             break;
 282         }
 283 

 284         case ArithBitLShift:
 285         case ArithBitXor:
 286         case ArithBitOr:
 287         case ArithBitAnd: {
 288             fixIntConvertingEdge(node-&gt;child1());
 289             fixIntConvertingEdge(node-&gt;child2());
 290             break;
 291         }
 292 
<span class="line-removed"> 293         case BitRShift:</span>
 294         case BitURShift: {
 295             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 296                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 297                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 298                 break;
 299             }
 300             fixIntConvertingEdge(node-&gt;child1());
 301             fixIntConvertingEdge(node-&gt;child2());
 302             break;
 303         }
 304 
 305         case ArithIMul: {
 306             fixIntConvertingEdge(node-&gt;child1());
 307             fixIntConvertingEdge(node-&gt;child2());
 308             node-&gt;setOp(ArithMul);
 309             node-&gt;setArithMode(Arith::Unchecked);
 310             node-&gt;child1().setUseKind(Int32Use);
 311             node-&gt;child2().setUseKind(Int32Use);
 312             break;
 313         }
</pre>
<hr />
<pre>
 818             }
 819 
 820             break;
 821         }
 822 
 823         case CompareStrictEq:
 824         case SameValue: {
 825             fixupCompareStrictEqAndSameValue(node);
 826             break;
 827         }
 828 
 829         case StringFromCharCode:
 830             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 831                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
 832                 node-&gt;clearFlags(NodeMustGenerate);
 833             } else
 834                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 835             break;
 836 
 837         case StringCharAt:
<span class="line-modified"> 838         case StringCharCodeAt: {</span>

 839             // Currently we have no good way of refining these.
 840             ASSERT(node-&gt;arrayMode() == ArrayMode(Array::String, Array::Read));
 841             blessArrayOperation(node-&gt;child1(), node-&gt;child2(), node-&gt;child3());
 842             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
 843             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
 844             break;
 845         }
 846 
 847         case GetByVal: {
 848             if (!node-&gt;prediction()) {
 849                 m_insertionSet.insertNode(
 850                     m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
 851             }
 852 
 853             node-&gt;setArrayMode(
 854                 node-&gt;arrayMode().refine(
 855                     m_graph, node,
 856                     m_graph.varArgChild(node, 0)-&gt;prediction(),
 857                     m_graph.varArgChild(node, 1)-&gt;prediction(),
 858                     SpecNone));
</pre>
<hr />
<pre>
1323                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent())
1324                     fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
1325                 else if (node-&gt;child1()-&gt;shouldSpeculateString())
1326                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1327                 break;
1328             case SwitchCell:
1329                 if (node-&gt;child1()-&gt;shouldSpeculateCell())
1330                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
1331                 // else it&#39;s fine for this to have UntypedUse; we will handle this by just making
1332                 // non-cells take the default case.
1333                 break;
1334             }
1335             break;
1336         }
1337 
1338         case ToPrimitive: {
1339             fixupToPrimitive(node);
1340             break;
1341         }
1342 
































1343         case ToNumber: {
1344             fixupToNumber(node);
1345             break;
1346         }
1347 





1348         case ToString:
1349         case CallStringConstructor: {
1350             fixupToStringOrCallStringConstructor(node);
1351             break;
1352         }
1353 
1354         case NewStringObject: {
1355             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1356             break;
1357         }
1358 
1359         case NewSymbol: {
1360             if (node-&gt;child1())
1361                 fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1362             break;
1363         }
1364 
1365         case NewArrayWithSpread: {
1366             watchHavingABadTime(node);
1367 
</pre>
<hr />
<pre>
1466             fixupToObject(node);
1467             break;
1468         }
1469 
1470         case CallObjectConstructor: {
1471             fixupCallObjectConstructor(node);
1472             break;
1473         }
1474 
1475         case ToThis: {
1476             fixupToThis(node);
1477             break;
1478         }
1479 
1480         case PutStructure: {
1481             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1482             break;
1483         }
1484 
1485         case GetClosureVar:
<span class="line-modified">1486         case GetFromArguments: {</span>

1487             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1488             break;
1489         }
1490 
1491         case PutClosureVar:
<span class="line-modified">1492         case PutToArguments: {</span>

1493             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1494             speculateForBarrier(node-&gt;child2());
1495             break;
1496         }
1497 
1498         case SkipScope:
1499         case GetScope:
1500         case GetGetter:
1501         case GetSetter:
1502         case GetGlobalObject: {
1503             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1504             break;
1505         }
1506 
1507         case AllocatePropertyStorage:
1508         case ReallocatePropertyStorage: {
1509             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1510             break;
1511         }
1512 
</pre>
<hr />
<pre>
1626             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1627             break;
1628         }
1629 
1630         case PutGetterByVal:
1631         case PutSetterByVal: {
1632             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1633             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1634             break;
1635         }
1636 
1637         case GetExecutable: {
1638             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
1639             break;
1640         }
1641 
1642         case OverridesHasInstance:
1643         case CheckStructure:
1644         case CheckCell:
1645         case CreateThis:



1646         case GetButterfly: {
1647             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1648             break;
1649         }
1650 
1651         case ObjectCreate: {
1652             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1653                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1654                 node-&gt;clearFlags(NodeMustGenerate);
1655                 break;
1656             }
1657             break;
1658         }
1659 
1660         case ObjectKeys: {
1661             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1662                 watchHavingABadTime(node);
1663                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1664             }
1665             break;
1666         }
1667 
<span class="line-modified">1668         case CheckStringIdent: {</span>
<span class="line-modified">1669             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());</span>



1670             break;
1671         }
1672 
1673         case Arrayify:
1674         case ArrayifyToStructure: {
1675             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1676             if (node-&gt;child2())
1677                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1678             break;
1679         }
1680 
1681         case GetByOffset:
1682         case GetGetterSetterByOffset: {
1683             if (!node-&gt;child1()-&gt;hasStorageResult())
1684                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1685             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1686             break;
1687         }
1688 
1689         case MultiGetByOffset: {
</pre>
<hr />
<pre>
1726             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1727             break;
1728 
1729         case InById: {
1730             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1731             break;
1732         }
1733 
1734         case InByVal: {
1735             if (node-&gt;child2()-&gt;shouldSpeculateInt32()) {
1736                 convertToHasIndexedProperty(node);
1737                 break;
1738             }
1739 
1740             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1741             break;
1742         }
1743 
1744         case HasOwnProperty: {
1745             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
<span class="line-removed">1746 #if CPU(X86)</span>
<span class="line-removed">1747             // We don&#39;t have enough registers to do anything interesting on x86 and mips.</span>
<span class="line-removed">1748             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());</span>
<span class="line-removed">1749 #else</span>
1750             if (node-&gt;child2()-&gt;shouldSpeculateString())
1751                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1752             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
1753                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
1754             else
1755                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
<span class="line-removed">1756 #endif</span>
1757             break;
1758         }
1759 
1760         case CheckVarargs:
1761         case Check: {
1762             m_graph.doToChildren(
1763                 node,
1764                 [&amp;] (Edge&amp; edge) {
1765                     switch (edge.useKind()) {
1766                     case NumberUse:
1767                         if (edge-&gt;shouldSpeculateInt32ForArithmetic())
1768                             edge.setUseKind(Int32Use);
1769                         break;
1770                     default:
1771                         break;
1772                     }
1773                     observeUseKindOnEdge(edge);
1774                 });
1775             break;
1776         }
</pre>
<hr />
<pre>
1793             break;
1794         }
1795 
1796         case GetTypedArrayByteOffset: {
1797             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1798             break;
1799         }
1800 
1801         case CompareBelow:
1802         case CompareBelowEq: {
1803             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1804             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1805             break;
1806         }
1807 
1808         case GetPrototypeOf: {
1809             fixupGetPrototypeOf(node);
1810             break;
1811         }
1812 






1813         case Phi:
1814         case Upsilon:
1815         case EntrySwitch:
1816         case GetIndexedPropertyStorage:
1817         case LastNodeType:
1818         case CheckTierUpInLoop:
1819         case CheckTierUpAtReturn:
1820         case CheckTierUpAndOSREnter:
<span class="line-removed">1821         case CheckArray:</span>
1822         case CheckInBounds:
1823         case ConstantStoragePointer:
1824         case DoubleAsInt32:
1825         case ValueToInt32:
1826         case DoubleRep:
1827         case ValueRep:
1828         case Int52Rep:
1829         case Int52Constant:
1830         case Identity: // This should have been cleaned up.
1831         case BooleanToNumber:
1832         case PhantomNewObject:
1833         case PhantomNewFunction:
1834         case PhantomNewGeneratorFunction:
1835         case PhantomNewAsyncGeneratorFunction:
1836         case PhantomNewAsyncFunction:

1837         case PhantomCreateActivation:
1838         case PhantomDirectArguments:
1839         case PhantomCreateRest:
1840         case PhantomSpread:
1841         case PhantomNewArrayWithSpread:
1842         case PhantomNewArrayBuffer:
1843         case PhantomClonedArguments:
1844         case PhantomNewRegexp:
1845         case GetMyArgumentByVal:
1846         case GetMyArgumentByValOutOfBounds:
1847         case GetVectorLength:
1848         case PutHint:
1849         case CheckStructureImmediate:
1850         case CheckStructureOrEmpty:

1851         case MaterializeNewObject:
1852         case MaterializeCreateActivation:

1853         case PutStack:
1854         case KillStack:
1855         case GetStack:
1856         case StoreBarrier:
1857         case FencedStoreBarrier:
1858         case GetRegExpObjectLastIndex:
1859         case SetRegExpObjectLastIndex:
1860         case RecordRegExpCachedResult:
1861         case RegExpExecNonGlobalOrSticky:
1862         case RegExpMatchFastGlobal:
1863             // These are just nodes that we don&#39;t currently expect to see during fixup.
1864             // If we ever wanted to insert them prior to fixup, then we just have to create
1865             // fixup rules for them.
1866             DFG_CRASH(m_graph, node, &quot;Unexpected node during fixup&quot;);
1867             break;
1868 
1869         case PutGlobalVariable: {
1870             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1871             speculateForBarrier(node-&gt;child2());
1872             break;
</pre>
<hr />
<pre>
2297         }
2298 
2299         case ThrowStaticError:
2300             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2301             break;
2302 
2303         case NumberIsInteger:
2304             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2305                 m_insertionSet.insertNode(
2306                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2307                     Edge(node-&gt;child1().node(), Int32Use));
2308                 m_graph.convertToConstant(node, jsBoolean(true));
2309                 break;
2310             }
2311             break;
2312 
2313         case SetCallee:
2314             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2315             break;
2316 





2317         case DataViewGetInt:
2318         case DataViewGetFloat: {
2319             fixEdge&lt;DataViewObjectUse&gt;(node-&gt;child1());
2320             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2321             if (node-&gt;child3())
2322                 fixEdge&lt;BooleanUse&gt;(node-&gt;child3());
2323 
2324             if (node-&gt;op() == DataViewGetInt) {
2325                 DataViewData data = node-&gt;dataViewData();
2326                 switch (data.byteSize) {
2327                 case 1:
2328                 case 2:
2329                     node-&gt;setResult(NodeResultInt32);
2330                     break;
2331                 case 4:
2332                     if (data.isSigned)
2333                         node-&gt;setResult(NodeResultInt32);
2334                     else
2335                         node-&gt;setResult(NodeResultInt52);
2336                     break;
</pre>
<hr />
<pre>
2351             Edge&amp; valueToStore = m_graph.varArgChild(node, 2);
2352             if (data.isFloatingPoint)
2353                 fixEdge&lt;DoubleRepUse&gt;(valueToStore);
2354             else {
2355                 switch (data.byteSize) {
2356                 case 1:
2357                 case 2:
2358                     fixEdge&lt;Int32Use&gt;(valueToStore);
2359                     break;
2360                 case 4:
2361                     if (data.isSigned)
2362                         fixEdge&lt;Int32Use&gt;(valueToStore);
2363                     else
2364                         fixEdge&lt;Int52RepUse&gt;(valueToStore);
2365                     break;
2366                 }
2367             }
2368             break;
2369         }
2370 
<span class="line-modified">2371 #if !ASSERT_DISABLED</span>






2372         // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
2373         case SetArgumentDefinitely:
2374         case SetArgumentMaybe:
2375         case JSConstant:
2376         case LazyJSConstant:
2377         case DoubleConstant:
2378         case GetLocal:
2379         case GetCallee:
2380         case GetArgumentCountIncludingThis:
2381         case SetArgumentCountIncludingThis:
2382         case GetRestLength:
2383         case GetArgument:
2384         case Flush:
2385         case PhantomLocal:
2386         case GetGlobalVar:
2387         case GetGlobalLexicalVariable:
2388         case NotifyWrite:
2389         case DirectCall:
2390         case CheckTypeInfoFlags:
2391         case TailCallInlinedCaller:
2392         case DirectTailCallInlinedCaller:
2393         case Construct:
2394         case DirectConstruct:
2395         case CallVarargs:
2396         case CallEval:
2397         case TailCallVarargsInlinedCaller:
2398         case ConstructVarargs:
2399         case CallForwardVarargs:
2400         case ConstructForwardVarargs:
2401         case TailCallForwardVarargs:
2402         case TailCallForwardVarargsInlinedCaller:
<span class="line-modified">2403         case LoadVarargs:</span>
<span class="line-removed">2404         case ForwardVarargs:</span>
2405         case ProfileControlFlow:
2406         case NewObject:




2407         case NewRegexp:
2408         case DeleteById:
2409         case DeleteByVal:
2410         case IsTypedArrayView:
2411         case IsEmpty:
2412         case IsUndefined:
2413         case IsUndefinedOrNull:
2414         case IsBoolean:
2415         case IsNumber:
2416         case IsObjectOrNull:
2417         case IsFunction:
2418         case CreateDirectArguments:
2419         case Jump:
2420         case Return:
2421         case TailCall:
2422         case DirectTailCall:
2423         case TailCallVarargs:
2424         case Throw:
2425         case CountExecution:
2426         case SuperSamplerBegin:
</pre>
<hr />
<pre>
2433         case Unreachable:
2434         case ExtractOSREntryLocal:
2435         case ExtractCatchLocal:
2436         case ClearCatchLocals:
2437         case LoopHint:
2438         case MovHint:
2439         case InitializeEntrypointArguments:
2440         case ZombieHint:
2441         case ExitOK:
2442         case BottomValue:
2443         case TypeOf:
2444         case PutByIdWithThis:
2445         case PutByValWithThis:
2446         case GetByValWithThis:
2447         case CompareEqPtr:
2448         case NumberToStringWithValidRadixConstant:
2449         case GetGlobalThis:
2450         case ExtractValueFromWeakMapGet:
2451         case CPUIntrinsic:
2452         case FilterCallLinkStatus:
<span class="line-modified">2453         case FilterGetByIdStatus:</span>
2454         case FilterPutByIdStatus:
2455         case FilterInByIdStatus:
2456         case InvalidationPoint:

2457             break;
<span class="line-modified">2458 #else</span>
2459         default:
2460             break;
<span class="line-modified">2461 #endif</span>
2462         }
2463     }
2464 
2465     void watchHavingABadTime(Node* node)
2466     {
2467         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2468 
2469         // If this global object is not having a bad time, watch it. We go down this path anytime the code
2470         // does an array allocation. The types of array allocations may change if we start to have a bad
2471         // time. It&#39;s easier to reason about this if we know that whenever the types change after we start
2472         // optimizing, the code just gets thrown out. Doing this at FixupPhase is just early enough, since
2473         // prior to this point nobody should have been doing optimizations based on the indexing type of
2474         // the allocation.
2475         if (!globalObject-&gt;isHavingABadTime()) {
2476             m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2477             m_graph.freeze(globalObject);
2478         }
2479     }
2480 
2481     template&lt;UseKind useKind&gt;
</pre>
<hr />
<pre>
2557             if (!string)
2558                 continue;
2559             if (string-&gt;length())
2560                 continue;
2561 
2562             // Don&#39;t allow the MakeRope to have zero children.
2563             if (!i &amp;&amp; !node-&gt;child2())
2564                 break;
2565 
2566             node-&gt;children.removeEdge(i--);
2567         }
2568 
2569         if (!node-&gt;child2()) {
2570             ASSERT(!node-&gt;child3());
2571             node-&gt;convertToIdentity();
2572         }
2573     }
2574 
2575     void fixupIsCellWithType(Node* node)
2576     {
<span class="line-modified">2577         switch (node-&gt;speculatedTypeForQuery()) {</span>
<span class="line-modified">2578         case SpecString:</span>
<span class="line-modified">2579             if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="line-modified">2580                 m_insertionSet.insertNode(</span>
<span class="line-modified">2581                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2582                     Edge(node-&gt;child1().node(), StringUse));</span>
<span class="line-modified">2583                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2584                 observeUseKindOnNode&lt;StringUse&gt;(node);</span>
<span class="line-modified">2585                 return;</span>
<span class="line-modified">2586             }</span>
<span class="line-modified">2587             break;</span>


2588 
<span class="line-modified">2589         case SpecProxyObject:</span>
<span class="line-modified">2590             if (node-&gt;child1()-&gt;shouldSpeculateProxyObject()) {</span>
<span class="line-modified">2591                 m_insertionSet.insertNode(</span>
<span class="line-modified">2592                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2593                     Edge(node-&gt;child1().node(), ProxyObjectUse));</span>
<span class="line-modified">2594                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2595                 observeUseKindOnNode&lt;ProxyObjectUse&gt;(node);</span>
<span class="line-modified">2596                 return;</span>
<span class="line-modified">2597             }</span>
<span class="line-modified">2598             break;</span>
2599 
<span class="line-modified">2600         case SpecRegExpObject:</span>
<span class="line-modified">2601             if (node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {</span>
<span class="line-modified">2602                 m_insertionSet.insertNode(</span>
<span class="line-modified">2603                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2604                     Edge(node-&gt;child1().node(), RegExpObjectUse));</span>
<span class="line-modified">2605                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2606                 observeUseKindOnNode&lt;RegExpObjectUse&gt;(node);</span>
<span class="line-modified">2607                 return;</span>
<span class="line-modified">2608             }</span>
<span class="line-modified">2609             break;</span>
2610 
<span class="line-modified">2611         case SpecArray:</span>
<span class="line-modified">2612             if (node-&gt;child1()-&gt;shouldSpeculateArray()) {</span>
<span class="line-modified">2613                 m_insertionSet.insertNode(</span>
<span class="line-modified">2614                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2615                     Edge(node-&gt;child1().node(), ArrayUse));</span>
<span class="line-modified">2616                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2617                 observeUseKindOnNode&lt;ArrayUse&gt;(node);</span>
<span class="line-modified">2618                 return;</span>
<span class="line-modified">2619             }</span>
<span class="line-modified">2620             break;</span>
2621 
<span class="line-modified">2622         case SpecDerivedArray:</span>
<span class="line-modified">2623             if (node-&gt;child1()-&gt;shouldSpeculateDerivedArray()) {</span>
<span class="line-modified">2624                 m_insertionSet.insertNode(</span>
<span class="line-modified">2625                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2626                     Edge(node-&gt;child1().node(), DerivedArrayUse));</span>
<span class="line-modified">2627                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2628                 observeUseKindOnNode&lt;DerivedArrayUse&gt;(node);</span>
<span class="line-modified">2629                 return;</span>


2630             }
<span class="line-removed">2631             break;</span>
2632         }
2633 
2634         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2635             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2636             return;
2637         }
2638 
2639         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2640             m_insertionSet.insertNode(
2641                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2642                 Edge(node-&gt;child1().node(), NotCellUse));
2643             m_graph.convertToConstant(node, jsBoolean(false));
2644             observeUseKindOnNode&lt;NotCellUse&gt;(node);
2645             return;
2646         }
2647     }
2648 
2649     void fixupGetPrototypeOf(Node* node)
2650     {
2651         // Reflect.getPrototypeOf only accepts Objects. For Reflect.getPrototypeOf, ByteCodeParser attaches ObjectUse edge filter before fixup phase.
</pre>
<hr />
<pre>
2801             return;
2802         }
2803 
2804         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2805             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2806             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2807             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2808             node-&gt;convertToToString();
2809             return;
2810         }
2811 
2812         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2813             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2814             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2815             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2816             node-&gt;convertToToString();
2817             return;
2818         }
2819     }
2820 












2821     void fixupToNumber(Node* node)
2822     {
2823         // At first, attempt to fold Boolean or Int32 to Int32.
2824         if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()) {
2825             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2826                 fixIntOrBooleanEdge(node-&gt;child1());
2827                 node-&gt;convertToIdentity();
2828                 return;
2829             }
2830         }
2831 
2832         // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
2833         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2834             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2835                 // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
2836                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2837                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2838                     node-&gt;convertToIdentity();
2839                     return;
2840                 }
</pre>
</td>
<td>
<hr />
<pre>
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGFixupPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGGraph.h&quot;
  33 #include &quot;DFGInsertionSet.h&quot;
  34 #include &quot;DFGPhase.h&quot;
  35 #include &quot;DFGPredictionPropagationPhase.h&quot;
  36 #include &quot;DFGVariableAccessDataDump.h&quot;
<span class="line-added">  37 #include &quot;GetterSetter.h&quot;</span>
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;TypeLocation.h&quot;
  40 
  41 namespace JSC { namespace DFG {
  42 
  43 class FixupPhase : public Phase {
  44 public:
  45     FixupPhase(Graph&amp; graph)
  46         : Phase(graph, &quot;fixup&quot;)
  47         , m_insertionSet(graph)
  48     {
  49     }
  50 
  51     bool run()
  52     {
  53         ASSERT(m_graph.m_fixpointState == BeforeFixpoint);
  54         ASSERT(m_graph.m_form == ThreadedCPS);
  55 
  56         m_profitabilityChanged = false;
  57         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
</pre>
<hr />
<pre>
 168             return;
 169         ASSERT(block-&gt;isReachable);
 170         m_block = block;
 171         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
 172             m_currentNode = block-&gt;at(m_indexInBlock);
 173             fixupNode(m_currentNode);
 174         }
 175         m_insertionSet.execute(block);
 176     }
 177 
 178     void fixupNode(Node* node)
 179     {
 180         NodeType op = node-&gt;op();
 181 
 182         switch (op) {
 183         case SetLocal: {
 184             // This gets handled by fixupGetAndSetLocalsInBlock().
 185             return;
 186         }
 187 
<span class="line-added"> 188         case Inc:</span>
<span class="line-added"> 189         case Dec: {</span>
<span class="line-added"> 190             if (node-&gt;child1()-&gt;shouldSpeculateUntypedForArithmetic()) {</span>
<span class="line-added"> 191                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 192                 break;</span>
<span class="line-added"> 193             }</span>
<span class="line-added"> 194 </span>
<span class="line-added"> 195             Node* nodeConstantOne;</span>
<span class="line-added"> 196             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {</span>
<span class="line-added"> 197                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="line-added"> 198                 node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="line-added"> 199                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecInt32Only, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="line-added"> 200                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 201                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());</span>
<span class="line-added"> 202                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());</span>
<span class="line-added"> 203                 node-&gt;setResult(NodeResultInt32);</span>
<span class="line-added"> 204             } else if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {</span>
<span class="line-added"> 205                 // FIXME: the freezing does not appear useful (since the JSCell is kept alive by vm), but it refuses to compile otherwise.</span>
<span class="line-added"> 206                 node-&gt;setOp(op == Inc ? ValueAdd : ValueSub);</span>
<span class="line-added"> 207                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecBigInt, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(vm().bigIntConstantOne.get())));</span>
<span class="line-added"> 208                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 209                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 210                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 211                 // BigInts are currently cells, so the default of NodeResultJS is good here</span>
<span class="line-added"> 212             } else if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
<span class="line-added"> 213                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="line-added"> 214                 node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="line-added"> 215                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecInt32AsInt52, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="line-added"> 216                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 217                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 218                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 219                 node-&gt;setResult(NodeResultInt52);</span>
<span class="line-added"> 220             } else {</span>
<span class="line-added"> 221                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="line-added"> 222                 node-&gt;setArithMode(Arith::Unchecked);</span>
<span class="line-added"> 223                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="line-added"> 224                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 225                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 226                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 227                 node-&gt;setResult(NodeResultDouble);</span>
<span class="line-added"> 228             }</span>
<span class="line-added"> 229             node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="line-added"> 230             break;</span>
<span class="line-added"> 231         }</span>
<span class="line-added"> 232 </span>
 233         case ValueSub: {
 234             Edge&amp; child1 = node-&gt;child1();
 235             Edge&amp; child2 = node-&gt;child2();
 236 
 237             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 238                 fixEdge&lt;BigIntUse&gt;(child1);
 239                 fixEdge&lt;BigIntUse&gt;(child2);
 240                 break;
 241             }
 242 
 243             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {
 244                 fixEdge&lt;UntypedUse&gt;(child1);
 245                 fixEdge&lt;UntypedUse&gt;(child2);
 246                 break;
 247             }
 248 
 249             if (attemptToMakeIntegerAdd(node)) {
 250                 // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 251                 // https://bugs.webkit.org/show_bug.cgi?id=190607
 252                 node-&gt;setOp(ArithSub);
 253                 break;
 254             }
 255 
 256             fixDoubleOrBooleanEdge(node-&gt;child1());
 257             fixDoubleOrBooleanEdge(node-&gt;child2());
 258             node-&gt;setOp(ArithSub);
 259             node-&gt;setResult(NodeResultDouble);
 260 
 261             break;
 262         }
 263 
 264         case ValueBitLShift:
<span class="line-added"> 265         case ValueBitRShift:</span>
 266         case ValueBitXor:
 267         case ValueBitOr:
 268         case ValueBitAnd: {
 269             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 270                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 271                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 272                 node-&gt;clearFlags(NodeMustGenerate);
 273                 break;
 274             }
 275 
 276             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 277                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 278                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 279                 break;
 280             }
 281 
 282             switch (op) {
 283             case ValueBitXor:
 284                 node-&gt;setOp(ArithBitXor);
 285                 break;
 286             case ValueBitOr:
 287                 node-&gt;setOp(ArithBitOr);
 288                 break;
 289             case ValueBitAnd:
 290                 node-&gt;setOp(ArithBitAnd);
 291                 break;
 292             case ValueBitLShift:
 293                 node-&gt;setOp(ArithBitLShift);
 294                 break;
<span class="line-added"> 295             case ValueBitRShift:</span>
<span class="line-added"> 296                 node-&gt;setOp(ArithBitRShift);</span>
<span class="line-added"> 297                 break;</span>
 298             default:
 299                 DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
 300                 break;
 301             }
 302 
 303             node-&gt;clearFlags(NodeMustGenerate);
 304             node-&gt;setResult(NodeResultInt32);
 305             fixIntConvertingEdge(node-&gt;child1());
 306             fixIntConvertingEdge(node-&gt;child2());
 307             break;
 308         }
 309 
 310         case ValueBitNot: {
 311             Edge&amp; operandEdge = node-&gt;child1();
 312 
 313             if (operandEdge.node()-&gt;shouldSpeculateBigInt()) {
 314                 node-&gt;clearFlags(NodeMustGenerate);
 315                 fixEdge&lt;BigIntUse&gt;(operandEdge);
 316             } else if (operandEdge.node()-&gt;shouldSpeculateUntypedForBitOps())
 317                 fixEdge&lt;UntypedUse&gt;(operandEdge);
 318             else {
 319                 node-&gt;setOp(ArithBitNot);
 320                 node-&gt;setResult(NodeResultInt32);
 321                 node-&gt;clearFlags(NodeMustGenerate);
 322                 fixIntConvertingEdge(operandEdge);
 323             }
 324             break;
 325         }
 326 
 327         case ArithBitNot: {
 328             Edge&amp; operandEdge = node-&gt;child1();
 329 
 330             fixIntConvertingEdge(operandEdge);
 331             break;
 332         }
 333 
<span class="line-added"> 334         case ArithBitRShift:</span>
 335         case ArithBitLShift:
 336         case ArithBitXor:
 337         case ArithBitOr:
 338         case ArithBitAnd: {
 339             fixIntConvertingEdge(node-&gt;child1());
 340             fixIntConvertingEdge(node-&gt;child2());
 341             break;
 342         }
 343 

 344         case BitURShift: {
 345             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 346                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 347                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 348                 break;
 349             }
 350             fixIntConvertingEdge(node-&gt;child1());
 351             fixIntConvertingEdge(node-&gt;child2());
 352             break;
 353         }
 354 
 355         case ArithIMul: {
 356             fixIntConvertingEdge(node-&gt;child1());
 357             fixIntConvertingEdge(node-&gt;child2());
 358             node-&gt;setOp(ArithMul);
 359             node-&gt;setArithMode(Arith::Unchecked);
 360             node-&gt;child1().setUseKind(Int32Use);
 361             node-&gt;child2().setUseKind(Int32Use);
 362             break;
 363         }
</pre>
<hr />
<pre>
 868             }
 869 
 870             break;
 871         }
 872 
 873         case CompareStrictEq:
 874         case SameValue: {
 875             fixupCompareStrictEqAndSameValue(node);
 876             break;
 877         }
 878 
 879         case StringFromCharCode:
 880             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 881                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
 882                 node-&gt;clearFlags(NodeMustGenerate);
 883             } else
 884                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 885             break;
 886 
 887         case StringCharAt:
<span class="line-modified"> 888         case StringCharCodeAt:</span>
<span class="line-added"> 889         case StringCodePointAt: {</span>
 890             // Currently we have no good way of refining these.
 891             ASSERT(node-&gt;arrayMode() == ArrayMode(Array::String, Array::Read));
 892             blessArrayOperation(node-&gt;child1(), node-&gt;child2(), node-&gt;child3());
 893             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
 894             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
 895             break;
 896         }
 897 
 898         case GetByVal: {
 899             if (!node-&gt;prediction()) {
 900                 m_insertionSet.insertNode(
 901                     m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
 902             }
 903 
 904             node-&gt;setArrayMode(
 905                 node-&gt;arrayMode().refine(
 906                     m_graph, node,
 907                     m_graph.varArgChild(node, 0)-&gt;prediction(),
 908                     m_graph.varArgChild(node, 1)-&gt;prediction(),
 909                     SpecNone));
</pre>
<hr />
<pre>
1374                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent())
1375                     fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
1376                 else if (node-&gt;child1()-&gt;shouldSpeculateString())
1377                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1378                 break;
1379             case SwitchCell:
1380                 if (node-&gt;child1()-&gt;shouldSpeculateCell())
1381                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
1382                 // else it&#39;s fine for this to have UntypedUse; we will handle this by just making
1383                 // non-cells take the default case.
1384                 break;
1385             }
1386             break;
1387         }
1388 
1389         case ToPrimitive: {
1390             fixupToPrimitive(node);
1391             break;
1392         }
1393 
<span class="line-added">1394         case ToPropertyKey: {</span>
<span class="line-added">1395             if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="line-added">1396                 fixEdge&lt;StringUse&gt;(node-&gt;child1());</span>
<span class="line-added">1397                 node-&gt;convertToIdentity();</span>
<span class="line-added">1398 </span>
<span class="line-added">1399                 return;</span>
<span class="line-added">1400             }</span>
<span class="line-added">1401 </span>
<span class="line-added">1402             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {</span>
<span class="line-added">1403                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());</span>
<span class="line-added">1404                 node-&gt;convertToIdentity();</span>
<span class="line-added">1405                 return;</span>
<span class="line-added">1406             }</span>
<span class="line-added">1407 </span>
<span class="line-added">1408             if (node-&gt;child1()-&gt;shouldSpeculateStringObject()</span>
<span class="line-added">1409                 &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {</span>
<span class="line-added">1410                 addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());</span>
<span class="line-added">1411                 fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());</span>
<span class="line-added">1412                 node-&gt;convertToToString();</span>
<span class="line-added">1413                 return;</span>
<span class="line-added">1414             }</span>
<span class="line-added">1415 </span>
<span class="line-added">1416             if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()</span>
<span class="line-added">1417                 &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {</span>
<span class="line-added">1418                 addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());</span>
<span class="line-added">1419                 fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());</span>
<span class="line-added">1420                 node-&gt;convertToToString();</span>
<span class="line-added">1421                 return;</span>
<span class="line-added">1422             }</span>
<span class="line-added">1423             break;</span>
<span class="line-added">1424         }</span>
<span class="line-added">1425 </span>
1426         case ToNumber: {
1427             fixupToNumber(node);
1428             break;
1429         }
1430 
<span class="line-added">1431         case ToNumeric: {</span>
<span class="line-added">1432             fixupToNumeric(node);</span>
<span class="line-added">1433             break;</span>
<span class="line-added">1434         }</span>
<span class="line-added">1435 </span>
1436         case ToString:
1437         case CallStringConstructor: {
1438             fixupToStringOrCallStringConstructor(node);
1439             break;
1440         }
1441 
1442         case NewStringObject: {
1443             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1444             break;
1445         }
1446 
1447         case NewSymbol: {
1448             if (node-&gt;child1())
1449                 fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1450             break;
1451         }
1452 
1453         case NewArrayWithSpread: {
1454             watchHavingABadTime(node);
1455 
</pre>
<hr />
<pre>
1554             fixupToObject(node);
1555             break;
1556         }
1557 
1558         case CallObjectConstructor: {
1559             fixupCallObjectConstructor(node);
1560             break;
1561         }
1562 
1563         case ToThis: {
1564             fixupToThis(node);
1565             break;
1566         }
1567 
1568         case PutStructure: {
1569             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1570             break;
1571         }
1572 
1573         case GetClosureVar:
<span class="line-modified">1574         case GetFromArguments:</span>
<span class="line-added">1575         case GetInternalField: {</span>
1576             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1577             break;
1578         }
1579 
1580         case PutClosureVar:
<span class="line-modified">1581         case PutToArguments:</span>
<span class="line-added">1582         case PutInternalField: {</span>
1583             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1584             speculateForBarrier(node-&gt;child2());
1585             break;
1586         }
1587 
1588         case SkipScope:
1589         case GetScope:
1590         case GetGetter:
1591         case GetSetter:
1592         case GetGlobalObject: {
1593             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1594             break;
1595         }
1596 
1597         case AllocatePropertyStorage:
1598         case ReallocatePropertyStorage: {
1599             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1600             break;
1601         }
1602 
</pre>
<hr />
<pre>
1716             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1717             break;
1718         }
1719 
1720         case PutGetterByVal:
1721         case PutSetterByVal: {
1722             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1723             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1724             break;
1725         }
1726 
1727         case GetExecutable: {
1728             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
1729             break;
1730         }
1731 
1732         case OverridesHasInstance:
1733         case CheckStructure:
1734         case CheckCell:
1735         case CreateThis:
<span class="line-added">1736         case CreatePromise:</span>
<span class="line-added">1737         case CreateGenerator:</span>
<span class="line-added">1738         case CreateAsyncGenerator:</span>
1739         case GetButterfly: {
1740             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1741             break;
1742         }
1743 
1744         case ObjectCreate: {
1745             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1746                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1747                 node-&gt;clearFlags(NodeMustGenerate);
1748                 break;
1749             }
1750             break;
1751         }
1752 
1753         case ObjectKeys: {
1754             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1755                 watchHavingABadTime(node);
1756                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1757             }
1758             break;
1759         }
1760 
<span class="line-modified">1761         case CheckIdent: {</span>
<span class="line-modified">1762             if (node-&gt;uidOperand()-&gt;isSymbol())</span>
<span class="line-added">1763                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());</span>
<span class="line-added">1764             else</span>
<span class="line-added">1765                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());</span>
1766             break;
1767         }
1768 
1769         case Arrayify:
1770         case ArrayifyToStructure: {
1771             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1772             if (node-&gt;child2())
1773                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1774             break;
1775         }
1776 
1777         case GetByOffset:
1778         case GetGetterSetterByOffset: {
1779             if (!node-&gt;child1()-&gt;hasStorageResult())
1780                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1781             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1782             break;
1783         }
1784 
1785         case MultiGetByOffset: {
</pre>
<hr />
<pre>
1822             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1823             break;
1824 
1825         case InById: {
1826             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1827             break;
1828         }
1829 
1830         case InByVal: {
1831             if (node-&gt;child2()-&gt;shouldSpeculateInt32()) {
1832                 convertToHasIndexedProperty(node);
1833                 break;
1834             }
1835 
1836             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1837             break;
1838         }
1839 
1840         case HasOwnProperty: {
1841             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());




1842             if (node-&gt;child2()-&gt;shouldSpeculateString())
1843                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1844             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
1845                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
1846             else
1847                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());

1848             break;
1849         }
1850 
1851         case CheckVarargs:
1852         case Check: {
1853             m_graph.doToChildren(
1854                 node,
1855                 [&amp;] (Edge&amp; edge) {
1856                     switch (edge.useKind()) {
1857                     case NumberUse:
1858                         if (edge-&gt;shouldSpeculateInt32ForArithmetic())
1859                             edge.setUseKind(Int32Use);
1860                         break;
1861                     default:
1862                         break;
1863                     }
1864                     observeUseKindOnEdge(edge);
1865                 });
1866             break;
1867         }
</pre>
<hr />
<pre>
1884             break;
1885         }
1886 
1887         case GetTypedArrayByteOffset: {
1888             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1889             break;
1890         }
1891 
1892         case CompareBelow:
1893         case CompareBelowEq: {
1894             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1895             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1896             break;
1897         }
1898 
1899         case GetPrototypeOf: {
1900             fixupGetPrototypeOf(node);
1901             break;
1902         }
1903 
<span class="line-added">1904         case CheckNeutered:</span>
<span class="line-added">1905         case CheckArray: {</span>
<span class="line-added">1906             fixEdge&lt;CellUse&gt;(node-&gt;child1());</span>
<span class="line-added">1907             break;</span>
<span class="line-added">1908         }</span>
<span class="line-added">1909 </span>
1910         case Phi:
1911         case Upsilon:
1912         case EntrySwitch:
1913         case GetIndexedPropertyStorage:
1914         case LastNodeType:
1915         case CheckTierUpInLoop:
1916         case CheckTierUpAtReturn:
1917         case CheckTierUpAndOSREnter:

1918         case CheckInBounds:
1919         case ConstantStoragePointer:
1920         case DoubleAsInt32:
1921         case ValueToInt32:
1922         case DoubleRep:
1923         case ValueRep:
1924         case Int52Rep:
1925         case Int52Constant:
1926         case Identity: // This should have been cleaned up.
1927         case BooleanToNumber:
1928         case PhantomNewObject:
1929         case PhantomNewFunction:
1930         case PhantomNewGeneratorFunction:
1931         case PhantomNewAsyncGeneratorFunction:
1932         case PhantomNewAsyncFunction:
<span class="line-added">1933         case PhantomNewArrayIterator:</span>
1934         case PhantomCreateActivation:
1935         case PhantomDirectArguments:
1936         case PhantomCreateRest:
1937         case PhantomSpread:
1938         case PhantomNewArrayWithSpread:
1939         case PhantomNewArrayBuffer:
1940         case PhantomClonedArguments:
1941         case PhantomNewRegexp:
1942         case GetMyArgumentByVal:
1943         case GetMyArgumentByValOutOfBounds:
1944         case GetVectorLength:
1945         case PutHint:
1946         case CheckStructureImmediate:
1947         case CheckStructureOrEmpty:
<span class="line-added">1948         case CheckArrayOrEmpty:</span>
1949         case MaterializeNewObject:
1950         case MaterializeCreateActivation:
<span class="line-added">1951         case MaterializeNewInternalFieldObject:</span>
1952         case PutStack:
1953         case KillStack:
1954         case GetStack:
1955         case StoreBarrier:
1956         case FencedStoreBarrier:
1957         case GetRegExpObjectLastIndex:
1958         case SetRegExpObjectLastIndex:
1959         case RecordRegExpCachedResult:
1960         case RegExpExecNonGlobalOrSticky:
1961         case RegExpMatchFastGlobal:
1962             // These are just nodes that we don&#39;t currently expect to see during fixup.
1963             // If we ever wanted to insert them prior to fixup, then we just have to create
1964             // fixup rules for them.
1965             DFG_CRASH(m_graph, node, &quot;Unexpected node during fixup&quot;);
1966             break;
1967 
1968         case PutGlobalVariable: {
1969             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1970             speculateForBarrier(node-&gt;child2());
1971             break;
</pre>
<hr />
<pre>
2396         }
2397 
2398         case ThrowStaticError:
2399             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2400             break;
2401 
2402         case NumberIsInteger:
2403             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2404                 m_insertionSet.insertNode(
2405                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2406                     Edge(node-&gt;child1().node(), Int32Use));
2407                 m_graph.convertToConstant(node, jsBoolean(true));
2408                 break;
2409             }
2410             break;
2411 
2412         case SetCallee:
2413             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2414             break;
2415 
<span class="line-added">2416         case DateGetInt32OrNaN:</span>
<span class="line-added">2417         case DateGetTime:</span>
<span class="line-added">2418             fixEdge&lt;DateObjectUse&gt;(node-&gt;child1());</span>
<span class="line-added">2419             break;</span>
<span class="line-added">2420 </span>
2421         case DataViewGetInt:
2422         case DataViewGetFloat: {
2423             fixEdge&lt;DataViewObjectUse&gt;(node-&gt;child1());
2424             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2425             if (node-&gt;child3())
2426                 fixEdge&lt;BooleanUse&gt;(node-&gt;child3());
2427 
2428             if (node-&gt;op() == DataViewGetInt) {
2429                 DataViewData data = node-&gt;dataViewData();
2430                 switch (data.byteSize) {
2431                 case 1:
2432                 case 2:
2433                     node-&gt;setResult(NodeResultInt32);
2434                     break;
2435                 case 4:
2436                     if (data.isSigned)
2437                         node-&gt;setResult(NodeResultInt32);
2438                     else
2439                         node-&gt;setResult(NodeResultInt52);
2440                     break;
</pre>
<hr />
<pre>
2455             Edge&amp; valueToStore = m_graph.varArgChild(node, 2);
2456             if (data.isFloatingPoint)
2457                 fixEdge&lt;DoubleRepUse&gt;(valueToStore);
2458             else {
2459                 switch (data.byteSize) {
2460                 case 1:
2461                 case 2:
2462                     fixEdge&lt;Int32Use&gt;(valueToStore);
2463                     break;
2464                 case 4:
2465                     if (data.isSigned)
2466                         fixEdge&lt;Int32Use&gt;(valueToStore);
2467                     else
2468                         fixEdge&lt;Int52RepUse&gt;(valueToStore);
2469                     break;
2470                 }
2471             }
2472             break;
2473         }
2474 
<span class="line-modified">2475         case ForwardVarargs:</span>
<span class="line-added">2476         case LoadVarargs: {</span>
<span class="line-added">2477             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());</span>
<span class="line-added">2478             break;</span>
<span class="line-added">2479         }</span>
<span class="line-added">2480 </span>
<span class="line-added">2481 #if ASSERT_ENABLED</span>
2482         // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
2483         case SetArgumentDefinitely:
2484         case SetArgumentMaybe:
2485         case JSConstant:
2486         case LazyJSConstant:
2487         case DoubleConstant:
2488         case GetLocal:
2489         case GetCallee:
2490         case GetArgumentCountIncludingThis:
2491         case SetArgumentCountIncludingThis:
2492         case GetRestLength:
2493         case GetArgument:
2494         case Flush:
2495         case PhantomLocal:
2496         case GetGlobalVar:
2497         case GetGlobalLexicalVariable:
2498         case NotifyWrite:
2499         case DirectCall:
2500         case CheckTypeInfoFlags:
2501         case TailCallInlinedCaller:
2502         case DirectTailCallInlinedCaller:
2503         case Construct:
2504         case DirectConstruct:
2505         case CallVarargs:
2506         case CallEval:
2507         case TailCallVarargsInlinedCaller:
2508         case ConstructVarargs:
2509         case CallForwardVarargs:
2510         case ConstructForwardVarargs:
2511         case TailCallForwardVarargs:
2512         case TailCallForwardVarargsInlinedCaller:
<span class="line-modified">2513         case VarargsLength:</span>

2514         case ProfileControlFlow:
2515         case NewObject:
<span class="line-added">2516         case NewPromise:</span>
<span class="line-added">2517         case NewGenerator:</span>
<span class="line-added">2518         case NewAsyncGenerator:</span>
<span class="line-added">2519         case NewArrayIterator:</span>
2520         case NewRegexp:
2521         case DeleteById:
2522         case DeleteByVal:
2523         case IsTypedArrayView:
2524         case IsEmpty:
2525         case IsUndefined:
2526         case IsUndefinedOrNull:
2527         case IsBoolean:
2528         case IsNumber:
2529         case IsObjectOrNull:
2530         case IsFunction:
2531         case CreateDirectArguments:
2532         case Jump:
2533         case Return:
2534         case TailCall:
2535         case DirectTailCall:
2536         case TailCallVarargs:
2537         case Throw:
2538         case CountExecution:
2539         case SuperSamplerBegin:
</pre>
<hr />
<pre>
2546         case Unreachable:
2547         case ExtractOSREntryLocal:
2548         case ExtractCatchLocal:
2549         case ClearCatchLocals:
2550         case LoopHint:
2551         case MovHint:
2552         case InitializeEntrypointArguments:
2553         case ZombieHint:
2554         case ExitOK:
2555         case BottomValue:
2556         case TypeOf:
2557         case PutByIdWithThis:
2558         case PutByValWithThis:
2559         case GetByValWithThis:
2560         case CompareEqPtr:
2561         case NumberToStringWithValidRadixConstant:
2562         case GetGlobalThis:
2563         case ExtractValueFromWeakMapGet:
2564         case CPUIntrinsic:
2565         case FilterCallLinkStatus:
<span class="line-modified">2566         case FilterGetByStatus:</span>
2567         case FilterPutByIdStatus:
2568         case FilterInByIdStatus:
2569         case InvalidationPoint:
<span class="line-added">2570         case CreateArgumentsButterfly:</span>
2571             break;
<span class="line-modified">2572 #else // not ASSERT_ENABLED</span>
2573         default:
2574             break;
<span class="line-modified">2575 #endif // not ASSERT_ENABLED</span>
2576         }
2577     }
2578 
2579     void watchHavingABadTime(Node* node)
2580     {
2581         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2582 
2583         // If this global object is not having a bad time, watch it. We go down this path anytime the code
2584         // does an array allocation. The types of array allocations may change if we start to have a bad
2585         // time. It&#39;s easier to reason about this if we know that whenever the types change after we start
2586         // optimizing, the code just gets thrown out. Doing this at FixupPhase is just early enough, since
2587         // prior to this point nobody should have been doing optimizations based on the indexing type of
2588         // the allocation.
2589         if (!globalObject-&gt;isHavingABadTime()) {
2590             m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2591             m_graph.freeze(globalObject);
2592         }
2593     }
2594 
2595     template&lt;UseKind useKind&gt;
</pre>
<hr />
<pre>
2671             if (!string)
2672                 continue;
2673             if (string-&gt;length())
2674                 continue;
2675 
2676             // Don&#39;t allow the MakeRope to have zero children.
2677             if (!i &amp;&amp; !node-&gt;child2())
2678                 break;
2679 
2680             node-&gt;children.removeEdge(i--);
2681         }
2682 
2683         if (!node-&gt;child2()) {
2684             ASSERT(!node-&gt;child3());
2685             node-&gt;convertToIdentity();
2686         }
2687     }
2688 
2689     void fixupIsCellWithType(Node* node)
2690     {
<span class="line-modified">2691         Optional&lt;SpeculatedType&gt; filter = node-&gt;speculatedTypeForQuery();</span>
<span class="line-modified">2692         if (filter) {</span>
<span class="line-modified">2693             switch (filter.value()) {</span>
<span class="line-modified">2694             case SpecString:</span>
<span class="line-modified">2695                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="line-modified">2696                     m_insertionSet.insertNode(</span>
<span class="line-modified">2697                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2698                         Edge(node-&gt;child1().node(), StringUse));</span>
<span class="line-modified">2699                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2700                     observeUseKindOnNode&lt;StringUse&gt;(node);</span>
<span class="line-modified">2701                     return;</span>
<span class="line-added">2702                 }</span>
<span class="line-added">2703                 break;</span>
2704 
<span class="line-modified">2705             case SpecProxyObject:</span>
<span class="line-modified">2706                 if (node-&gt;child1()-&gt;shouldSpeculateProxyObject()) {</span>
<span class="line-modified">2707                     m_insertionSet.insertNode(</span>
<span class="line-modified">2708                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2709                         Edge(node-&gt;child1().node(), ProxyObjectUse));</span>
<span class="line-modified">2710                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2711                     observeUseKindOnNode&lt;ProxyObjectUse&gt;(node);</span>
<span class="line-modified">2712                     return;</span>
<span class="line-modified">2713                 }</span>
<span class="line-modified">2714                 break;</span>
2715 
<span class="line-modified">2716             case SpecRegExpObject:</span>
<span class="line-modified">2717                 if (node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {</span>
<span class="line-modified">2718                     m_insertionSet.insertNode(</span>
<span class="line-modified">2719                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2720                         Edge(node-&gt;child1().node(), RegExpObjectUse));</span>
<span class="line-modified">2721                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2722                     observeUseKindOnNode&lt;RegExpObjectUse&gt;(node);</span>
<span class="line-modified">2723                     return;</span>
<span class="line-modified">2724                 }</span>
<span class="line-modified">2725                 break;</span>
2726 
<span class="line-modified">2727             case SpecArray:</span>
<span class="line-modified">2728                 if (node-&gt;child1()-&gt;shouldSpeculateArray()) {</span>
<span class="line-modified">2729                     m_insertionSet.insertNode(</span>
<span class="line-modified">2730                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2731                         Edge(node-&gt;child1().node(), ArrayUse));</span>
<span class="line-modified">2732                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2733                     observeUseKindOnNode&lt;ArrayUse&gt;(node);</span>
<span class="line-modified">2734                     return;</span>
<span class="line-modified">2735                 }</span>
<span class="line-modified">2736                 break;</span>
2737 
<span class="line-modified">2738             case SpecDerivedArray:</span>
<span class="line-modified">2739                 if (node-&gt;child1()-&gt;shouldSpeculateDerivedArray()) {</span>
<span class="line-modified">2740                     m_insertionSet.insertNode(</span>
<span class="line-modified">2741                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2742                         Edge(node-&gt;child1().node(), DerivedArrayUse));</span>
<span class="line-modified">2743                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2744                     observeUseKindOnNode&lt;DerivedArrayUse&gt;(node);</span>
<span class="line-modified">2745                     return;</span>
<span class="line-added">2746                 }</span>
<span class="line-added">2747                 break;</span>
2748             }

2749         }
2750 
2751         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2752             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2753             return;
2754         }
2755 
2756         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2757             m_insertionSet.insertNode(
2758                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2759                 Edge(node-&gt;child1().node(), NotCellUse));
2760             m_graph.convertToConstant(node, jsBoolean(false));
2761             observeUseKindOnNode&lt;NotCellUse&gt;(node);
2762             return;
2763         }
2764     }
2765 
2766     void fixupGetPrototypeOf(Node* node)
2767     {
2768         // Reflect.getPrototypeOf only accepts Objects. For Reflect.getPrototypeOf, ByteCodeParser attaches ObjectUse edge filter before fixup phase.
</pre>
<hr />
<pre>
2918             return;
2919         }
2920 
2921         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2922             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2923             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2924             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2925             node-&gt;convertToToString();
2926             return;
2927         }
2928 
2929         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2930             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2931             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2932             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2933             node-&gt;convertToToString();
2934             return;
2935         }
2936     }
2937 
<span class="line-added">2938     void fixupToNumeric(Node* node)</span>
<span class="line-added">2939     {</span>
<span class="line-added">2940         // If the prediction of the child is BigInt, we attempt to convert ToNumeric to Identity, since it can only return a BigInt when fed a BigInt.</span>
<span class="line-added">2941         if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {</span>
<span class="line-added">2942             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="line-added">2943             node-&gt;convertToIdentity();</span>
<span class="line-added">2944             return;</span>
<span class="line-added">2945         }</span>
<span class="line-added">2946 </span>
<span class="line-added">2947         fixupToNumber(node);</span>
<span class="line-added">2948     }</span>
<span class="line-added">2949 </span>
2950     void fixupToNumber(Node* node)
2951     {
2952         // At first, attempt to fold Boolean or Int32 to Int32.
2953         if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()) {
2954             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2955                 fixIntOrBooleanEdge(node-&gt;child1());
2956                 node-&gt;convertToIdentity();
2957                 return;
2958             }
2959         }
2960 
2961         // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
2962         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2963             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2964                 // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
2965                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2966                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2967                     node-&gt;convertToIdentity();
2968                     return;
2969                 }
</pre>
</td>
</tr>
</table>
<center><a href="DFGEpoch.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGForAllKills.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
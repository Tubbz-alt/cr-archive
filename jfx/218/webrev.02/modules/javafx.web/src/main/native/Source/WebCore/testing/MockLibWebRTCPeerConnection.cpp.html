<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/testing/MockLibWebRTCPeerConnection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;MockLibWebRTCPeerConnection.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;LibWebRTCProvider.h&quot;
 31 #include &lt;sstream&gt;
 32 #include &lt;webrtc/pc/media_stream.h&gt;
 33 #include &lt;wtf/Function.h&gt;
 34 #include &lt;wtf/MainThread.h&gt;
 35 #include &lt;wtf/NeverDestroyed.h&gt;
 36 #include &lt;wtf/Threading.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 static inline rtc::scoped_refptr&lt;webrtc::PeerConnectionFactoryInterface&gt;&amp; getRealPeerConnectionFactory()
 41 {
 42     static NeverDestroyed&lt;rtc::scoped_refptr&lt;webrtc::PeerConnectionFactoryInterface&gt;&gt; realPeerConnectionFactory;
 43     return realPeerConnectionFactory;
 44 }
 45 
 46 static inline webrtc::PeerConnectionFactoryInterface* realPeerConnectionFactory()
 47 {
 48     return getRealPeerConnectionFactory().get();
 49 }
 50 
 51 void useRealRTCPeerConnectionFactory(LibWebRTCProvider&amp; provider)
 52 {
 53     auto&amp; factory = getRealPeerConnectionFactory();
 54     if (!factory)
 55         return;
 56     provider.setPeerConnectionFactory(factory.get());
 57     factory = nullptr;
 58 }
 59 
 60 void useMockRTCPeerConnectionFactory(LibWebRTCProvider* provider, const String&amp; testCase)
 61 {
 62     if (!provider)
 63         return;
 64 
 65     if (!realPeerConnectionFactory()) {
 66         auto&amp; factory = getRealPeerConnectionFactory();
 67         factory = provider-&gt;factory();
 68     }
 69     provider-&gt;setPeerConnectionFactory(MockLibWebRTCPeerConnectionFactory::create(testCase));
 70 }
 71 
 72 MockLibWebRTCPeerConnection::~MockLibWebRTCPeerConnection()
 73 {
 74     // Free senders and receivers in a different thread like an actual peer connection would probably do.
 75     Thread::create(&quot;MockLibWebRTCPeerConnection thread&quot;, [transceivers = WTFMove(m_transceivers)] { });
 76 }
 77 
 78 std::vector&lt;rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&gt; MockLibWebRTCPeerConnection::GetTransceivers() const
 79 {
 80     std::vector&lt;rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&gt; transceivers;
 81     transceivers.reserve(m_transceivers.size());
 82     for (const auto&amp; transceiver : m_transceivers)
 83         transceivers.push_back(transceiver);
 84     return transceivers;
 85 }
 86 
 87 class MockLibWebRTCPeerConnectionForIceCandidates : public MockLibWebRTCPeerConnection {
 88 public:
 89     explicit MockLibWebRTCPeerConnectionForIceCandidates(webrtc::PeerConnectionObserver&amp; observer) : MockLibWebRTCPeerConnection(observer) { }
 90     virtual ~MockLibWebRTCPeerConnectionForIceCandidates() = default;
 91 private:
 92     void gotLocalDescription() final;
 93 };
 94 
 95 void MockLibWebRTCPeerConnectionForIceCandidates::gotLocalDescription()
 96 {
 97     // Let&#39;s gather candidates
 98     LibWebRTCProvider::callOnWebRTCSignalingThread([this]() {
 99         MockLibWebRTCIceCandidate candidate(&quot;2013266431 1 udp 2013266432 192.168.0.100 38838 typ host generation 0&quot;, &quot;1&quot;);
100         m_observer.OnIceCandidate(&amp;candidate);
101     });
102     LibWebRTCProvider::callOnWebRTCSignalingThread([this]() {
103         MockLibWebRTCIceCandidate candidate(&quot;1019216383 1 tcp 1019216384 192.168.0.100 9 typ host tcptype passive generation 0&quot;, &quot;1&quot;);
104         m_observer.OnIceCandidate(&amp;candidate);
105     });
106     LibWebRTCProvider::callOnWebRTCSignalingThread([this]() {
107         MockLibWebRTCIceCandidate candidate(&quot;1677722111 1 tcp 1677722112 172.18.0.1 47989 typ srflx raddr 192.168.0.100 rport 47989 generation 0&quot;, &quot;1&quot;);
108         m_observer.OnIceCandidate(&amp;candidate);
109     });
110     LibWebRTCProvider::callOnWebRTCSignalingThread([this]() {
111         m_observer.OnIceGatheringChange(webrtc::PeerConnectionInterface::kIceGatheringComplete);
112     });
113 }
114 
115 class MockLibWebRTCPeerConnectionForIceConnectionState : public MockLibWebRTCPeerConnection {
116 public:
117     explicit MockLibWebRTCPeerConnectionForIceConnectionState(webrtc::PeerConnectionObserver&amp; observer) : MockLibWebRTCPeerConnection(observer) { }
118     virtual ~MockLibWebRTCPeerConnectionForIceConnectionState() = default;
119 
120 private:
121     void gotLocalDescription() final;
122 };
123 
124 void MockLibWebRTCPeerConnectionForIceConnectionState::gotLocalDescription()
125 {
126     m_observer.OnIceConnectionChange(kIceConnectionChecking);
127     m_observer.OnIceConnectionChange(kIceConnectionConnected);
128     m_observer.OnIceConnectionChange(kIceConnectionCompleted);
129     m_observer.OnIceConnectionChange(kIceConnectionFailed);
130     m_observer.OnIceConnectionChange(kIceConnectionDisconnected);
131     m_observer.OnIceConnectionChange(kIceConnectionNew);
132 }
133 
134 template&lt;typename U&gt; static inline void releaseInNetworkThread(MockLibWebRTCPeerConnection&amp; mock, U&amp; observer)
135 {
136     mock.AddRef();
137     observer.AddRef();
138     callOnMainThread([&amp;mock, &amp;observer] {
139         LibWebRTCProvider::callOnWebRTCNetworkThread([&amp;mock, &amp;observer]() {
140             observer.Release();
141             mock.Release();
142         });
143     });
144 }
145 
146 class MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileCreatingOffer : public MockLibWebRTCPeerConnection {
147 public:
148     explicit MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileCreatingOffer(webrtc::PeerConnectionObserver&amp; observer) : MockLibWebRTCPeerConnection(observer) { }
149     virtual ~MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileCreatingOffer() = default;
150 
151 private:
152     void CreateOffer(webrtc::CreateSessionDescriptionObserver* observer, const webrtc::PeerConnectionInterface::RTCOfferAnswerOptions&amp;) final { releaseInNetworkThread(*this, *observer); }
153 };
154 
155 class MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileGettingStats : public MockLibWebRTCPeerConnection {
156 public:
157     explicit MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileGettingStats(webrtc::PeerConnectionObserver&amp; observer) : MockLibWebRTCPeerConnection(observer) { }
158     virtual ~MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileGettingStats() = default;
159 
160 private:
161     bool GetStats(webrtc::StatsObserver*, webrtc::MediaStreamTrackInterface*, StatsOutputLevel) final;
162 };
163 
164 bool MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileGettingStats::GetStats(webrtc::StatsObserver* observer, webrtc::MediaStreamTrackInterface*, StatsOutputLevel)
165 {
166     releaseInNetworkThread(*this, *observer);
167     return true;
168 }
169 
170 class MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileSettingDescription : public MockLibWebRTCPeerConnection {
171 public:
172     explicit MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileSettingDescription(webrtc::PeerConnectionObserver&amp; observer) : MockLibWebRTCPeerConnection(observer) { }
173     virtual ~MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileSettingDescription() = default;
174 
175 private:
176     void SetLocalDescription(webrtc::SetSessionDescriptionObserver* observer, webrtc::SessionDescriptionInterface* sessionDescription) final
177     {
178         std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; toBeFreed(sessionDescription);
179         releaseInNetworkThread(*this, *observer);
180     }
181 };
182 
183 MockLibWebRTCPeerConnectionFactory::MockLibWebRTCPeerConnectionFactory(const String&amp; testCase)
184     : m_testCase(testCase.isolatedCopy())
185 {
186 }
187 
188 rtc::scoped_refptr&lt;webrtc::PeerConnectionInterface&gt; MockLibWebRTCPeerConnectionFactory::CreatePeerConnection(const webrtc::PeerConnectionInterface::RTCConfiguration&amp;, webrtc::PeerConnectionDependencies dependencies)
189 {
190     if (m_testCase == &quot;ICECandidates&quot;)
191         return new rtc::RefCountedObject&lt;MockLibWebRTCPeerConnectionForIceCandidates&gt;(*dependencies.observer);
192 
193     if (m_testCase == &quot;ICEConnectionState&quot;)
194         return new rtc::RefCountedObject&lt;MockLibWebRTCPeerConnectionForIceConnectionState&gt;(*dependencies.observer);
195 
196     if (m_testCase == &quot;LibWebRTCReleasingWhileCreatingOffer&quot;)
197         return new rtc::RefCountedObject&lt;MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileCreatingOffer&gt;(*dependencies.observer);
198 
199     if (m_testCase == &quot;LibWebRTCReleasingWhileGettingStats&quot;)
200         return new rtc::RefCountedObject&lt;MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileGettingStats&gt;(*dependencies.observer);
201 
202     if (m_testCase == &quot;LibWebRTCReleasingWhileSettingDescription&quot;)
203         return new rtc::RefCountedObject&lt;MockLibWebRTCPeerConnectionReleasedInNetworkThreadWhileSettingDescription&gt;(*dependencies.observer);
204 
205     return new rtc::RefCountedObject&lt;MockLibWebRTCPeerConnection&gt;(*dependencies.observer);
206 }
207 
208 rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; MockLibWebRTCPeerConnectionFactory::CreateVideoTrack(const std::string&amp; id, webrtc::VideoTrackSourceInterface* source)
209 {
210     return new rtc::RefCountedObject&lt;MockLibWebRTCVideoTrack&gt;(id, source);
211 }
212 
213 rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; MockLibWebRTCPeerConnectionFactory::CreateAudioTrack(const std::string&amp; id, webrtc::AudioSourceInterface* source)
214 {
215     return new rtc::RefCountedObject&lt;MockLibWebRTCAudioTrack&gt;(id, source);
216 }
217 
218 rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; MockLibWebRTCPeerConnectionFactory::CreateLocalMediaStream(const std::string&amp; label)
219 {
220     return new rtc::RefCountedObject&lt;webrtc::MediaStream&gt;(label);
221 }
222 
223 void MockLibWebRTCPeerConnection::SetLocalDescription(webrtc::SetSessionDescriptionObserver* observer, webrtc::SessionDescriptionInterface* sessionDescription)
224 {
225     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; toBeFreed(sessionDescription);
226     LibWebRTCProvider::callOnWebRTCSignalingThread([this, observer] {
227         observer-&gt;OnSuccess();
228         gotLocalDescription();
229     });
230 }
231 
232 void MockLibWebRTCPeerConnection::SetRemoteDescription(webrtc::SetSessionDescriptionObserver* observer, webrtc::SessionDescriptionInterface* sessionDescription)
233 {
234     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; toBeFreed(sessionDescription);
235     LibWebRTCProvider::callOnWebRTCSignalingThread([observer] {
236         observer-&gt;OnSuccess();
237     });
238     ASSERT(sessionDescription);
239     if (sessionDescription-&gt;type() == &quot;offer&quot;) {
240         std::string sdp;
241         sessionDescription-&gt;ToString(&amp;sdp);
242 
243         m_isInitiator = false;
244         m_isReceivingAudio = sdp.find(&quot;m=audio&quot;) != std::string::npos;
245         m_isReceivingVideo = sdp.find(&quot;m=video&quot;) != std::string::npos;
246     }
247 }
248 
249 rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; MockLibWebRTCPeerConnection::CreateDataChannel(const std::string&amp; label, const webrtc::DataChannelInit* init)
250 {
251     webrtc::DataChannelInit parameters;
252     if (init)
253         parameters = *init;
254     return new rtc::RefCountedObject&lt;MockLibWebRTCDataChannel&gt;(std::string(label), parameters.ordered, parameters.reliable, parameters.id);
255 }
256 
257 webrtc::RTCErrorOr&lt;rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;&gt; MockLibWebRTCPeerConnection::AddTrack(rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; track, const std::vector&lt;std::string&gt;&amp; streamIds)
258 {
259     LibWebRTCProvider::callOnWebRTCSignalingThread([observer = &amp;m_observer] {
260         observer-&gt;OnRenegotiationNeeded();
261     });
262 
263     if (!streamIds.empty())
264         m_streamLabel = streamIds.front();
265 
266     rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt; sender = new rtc::RefCountedObject&lt;MockRtpSender&gt;(WTFMove(track));
267     rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver = new rtc::RefCountedObject&lt;MockRtpReceiver&gt;();
268     rtc::scoped_refptr&lt;MockRtpTransceiver&gt; transceiver = new rtc::RefCountedObject&lt;MockRtpTransceiver&gt;(WTFMove(sender), WTFMove(receiver));
269 
270     m_transceivers.append(WTFMove(transceiver));
271     return rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(m_transceivers.last()-&gt;sender());
272 }
273 
274 bool MockLibWebRTCPeerConnection::RemoveTrack(webrtc::RtpSenderInterface* sender)
275 {
276     LibWebRTCProvider::callOnWebRTCSignalingThread([observer = &amp;m_observer] {
277         observer-&gt;OnRenegotiationNeeded();
278     });
279     bool isRemoved = false;
280     return m_transceivers.removeFirstMatching([&amp;](auto&amp; transceiver) {
281         if (transceiver-&gt;sender().get() != sender)
282             return false;
283         isRemoved = true;
284         return true;
285     });
286 }
287 
288 void MockLibWebRTCPeerConnection::CreateOffer(webrtc::CreateSessionDescriptionObserver* observer, const webrtc::PeerConnectionInterface::RTCOfferAnswerOptions&amp;)
289 {
290     LibWebRTCProvider::callOnWebRTCSignalingThread([this, observer] {
291         std::ostringstream sdp;
292         sdp &lt;&lt;
293             &quot;v=0\r\n&quot;
294             &quot;o=- 5667094644266930845 &quot; &lt;&lt; m_counter++ &lt;&lt; &quot; IN IP4 127.0.0.1\r\n&quot;
295             &quot;s=-\r\n&quot;
296             &quot;t=0 0\r\n&quot;;
297         if (m_transceivers.size()) {
298             unsigned partCounter = 1;
299             sdp &lt;&lt; &quot;a=msid-semantic:WMS &quot; &lt;&lt; m_streamLabel &lt;&lt; &quot;\r\n&quot;;
300             for (auto&amp; transceiver : m_transceivers) {
301                 auto track = transceiver-&gt;sender()-&gt;track();
302                 if (track-&gt;kind() != &quot;audio&quot;)
303                     continue;
304                 sdp &lt;&lt;
305                     &quot;m=audio 9 UDP/TLS/RTP/SAVPF 111 8 0\r\n&quot;
306                     &quot;c=IN IP4 0.0.0.0\r\n&quot;
307                     &quot;a=rtcp-mux\r\n&quot;
308                     &quot;a=sendrecv\r\n&quot;
309                     &quot;a=mid:part&quot; &lt;&lt; partCounter++ &lt;&lt; &quot;\r\n&quot;
310                     &quot;a=rtpmap:111 OPUS/48000/2\r\n&quot;
311                     &quot;a=rtpmap:8 PCMA/8000\r\n&quot;
312                     &quot;a=rtpmap:0 PCMU/8000\r\n&quot;
313                     &quot;a=ssrc:3409173717 cname:/chKzCS9K6KOgL0n\r\n&quot;
314                     &quot;a=msid:&quot; &lt;&lt; m_streamLabel &lt;&lt; &quot; &quot; &lt;&lt; track-&gt;id() &lt;&lt; &quot;\r\n&quot;
315                     &quot;a=ice-ufrag:e/B1\r\n&quot;
316                     &quot;a=ice-pwd:Yotk3Im3mnyi+1Q38p51MDub\r\n&quot;
317                     &quot;a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B\r\n&quot;
318                     &quot;a=setup:actpass\r\n&quot;;
319             }
320             for (auto&amp; transceiver : m_transceivers) {
321                 auto track = transceiver-&gt;sender()-&gt;track();
322                 if (track-&gt;kind() != &quot;video&quot;)
323                     continue;
324                 sdp &lt;&lt;
325                     &quot;m=video 9 UDP/TLS/RTP/SAVPF 103 100 120\r\n&quot;
326                     &quot;c=IN IP4 0.0.0.0\r\n&quot;
327                     &quot;a=rtcp-mux\r\n&quot;
328                     &quot;a=sendrecv\r\n&quot;
329                     &quot;a=mid:part&quot; &lt;&lt; partCounter++ &lt;&lt; &quot;\r\n&quot;
330                     &quot;a=rtpmap:103 H264/90000\r\n&quot;
331                     &quot;a=rtpmap:100 VP8/90000\r\n&quot;
332                     &quot;a=rtpmap:120 RTX/90000\r\n&quot;
333                     &quot;a=fmtp:103 packetization-mode=1\r\n&quot;
334                     &quot;a=fmtp:120 apt=100;rtx-time=200\r\n&quot;
335                     &quot;a=rtcp-fb:100 nack\r\n&quot;
336                     &quot;a=rtcp-fb:103 nack pli\r\n&quot;
337                     &quot;a=rtcp-fb:100 nack pli\r\n&quot;
338                     &quot;a=rtcp-fb:103 ccm fir\r\n&quot;
339                     &quot;a=rtcp-fb:100 ccm fir\r\n&quot;
340                     &quot;a=ssrc:3409173718 cname:/chKzCS9K6KOgL0n\r\n&quot;
341                     &quot;a=msid:&quot; &lt;&lt; m_streamLabel &lt;&lt; &quot; &quot; &lt;&lt; track-&gt;id() &lt;&lt; &quot;\r\n&quot;
342                     &quot;a=ice-ufrag:e/B1\r\n&quot;
343                     &quot;a=ice-pwd:Yotk3Im3mnyi+1Q38p51MDub\r\n&quot;
344                     &quot;a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B\r\n&quot;
345                     &quot;a=setup:actpass\r\n&quot;;
346             }
347         }
348         observer-&gt;OnSuccess(new MockLibWebRTCSessionDescription(sdp.str()));
349     });
350 }
351 
352     void MockLibWebRTCPeerConnection::CreateAnswer(webrtc::CreateSessionDescriptionObserver* observer, const webrtc::PeerConnectionInterface::RTCOfferAnswerOptions&amp;)
353 {
354     LibWebRTCProvider::callOnWebRTCSignalingThread([this, observer] {
355         std::ostringstream sdp;
356         sdp &lt;&lt;
357             &quot;v=0\r\n&quot;
358             &quot;o=- 5667094644266930846 &quot; &lt;&lt; m_counter++ &lt;&lt; &quot; IN IP4 127.0.0.1\r\n&quot;
359             &quot;s=-\r\n&quot;
360             &quot;t=0 0\r\n&quot;;
361         if (m_transceivers.size()) {
362             for (auto&amp; transceiver : m_transceivers) {
363                 auto track = transceiver-&gt;sender()-&gt;track();
364                 if (track-&gt;kind() != &quot;audio&quot;)
365                     continue;
366                 sdp &lt;&lt;
367                     &quot;m=audio 9 UDP/TLS/RTP/SAVPF 111 8 0\r\n&quot;
368                     &quot;c=IN IP4 0.0.0.0\r\n&quot;
369                     &quot;a=rtcp-mux\r\n&quot;
370                     &quot;a=recvonly\r\n&quot;
371                     &quot;a=mid:part1\r\n&quot;
372                     &quot;a=rtpmap:111 OPUS/48000/2\r\n&quot;
373                     &quot;a=rtpmap:8 PCMA/8000\r\n&quot;
374                     &quot;a=rtpmap:0 PCMU/8000\r\n&quot;
375                     &quot;a=ssrc:3409173717 cname:/chKzCS9K6KOgL0m\r\n&quot;
376                     &quot;a=ice-ufrag:e/B1\r\n&quot;
377                     &quot;a=ice-pwd:Yotk3Im3mnyi+1Q38p51MDub\r\n&quot;
378                     &quot;a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B\r\n&quot;
379                     &quot;a=setup:active\r\n&quot;;
380             }
381             for (auto&amp; transceiver : m_transceivers) {
382                 auto track = transceiver-&gt;sender()-&gt;track();
383                 if (track-&gt;kind() != &quot;video&quot;)
384                     continue;
385                 sdp &lt;&lt;
386                     &quot;m=video 9 UDP/TLS/RTP/SAVPF 103 100 120\r\n&quot;
387                     &quot;c=IN IP4 0.0.0.0\r\n&quot;
388                     &quot;a=rtcp-mux\r\n&quot;
389                     &quot;a=recvonly\r\n&quot;
390                     &quot;a=mid:part2\r\n&quot;
391                     &quot;a=rtpmap:103 H264/90000\r\n&quot;
392                     &quot;a=rtpmap:100 VP8/90000\r\n&quot;
393                     &quot;a=rtpmap:120 RTX/90000\r\n&quot;
394                     &quot;a=fmtp:103 packetization-mode=1\r\n&quot;
395                     &quot;a=fmtp:120 apt=100;rtx-time=200\r\n&quot;
396                     &quot;a=rtcp-fb:100 nack\r\n&quot;
397                     &quot;a=rtcp-fb:103 nack pli\r\n&quot;
398                     &quot;a=rtcp-fb:100 nack pli\r\n&quot;
399                     &quot;a=rtcp-fb:103 ccm fir\r\n&quot;
400                     &quot;a=rtcp-fb:100 ccm fir\r\n&quot;
401                     &quot;a=ssrc:3409173718 cname:/chKzCS9K6KOgL0n\r\n&quot;
402                     &quot;a=ice-ufrag:e/B1\r\n&quot;
403                     &quot;a=ice-pwd:Yotk3Im3mnyi+1Q38p51MDub\r\n&quot;
404                     &quot;a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B\r\n&quot;
405                     &quot;a=setup:active\r\n&quot;;
406             }
407         } else if (!m_isInitiator) {
408             if (m_isReceivingAudio) {
409                 sdp &lt;&lt;
410                     &quot;m=audio 9 UDP/TLS/RTP/SAVPF 111 8 0\r\n&quot;
411                     &quot;c=IN IP4 0.0.0.0\r\n&quot;
412                     &quot;a=rtcp-mux\r\n&quot;
413                     &quot;a=recvonly\r\n&quot;
414                     &quot;a=mid:part1\r\n&quot;
415                     &quot;a=rtpmap:111 OPUS/48000/2\r\n&quot;
416                     &quot;a=rtpmap:8 PCMA/8000\r\n&quot;
417                     &quot;a=rtpmap:0 PCMU/8000\r\n&quot;
418                     &quot;a=ssrc:3409173717 cname:/chKzCS9K6KOgL0m\r\n&quot;
419                     &quot;a=ice-ufrag:e/B1\r\n&quot;
420                     &quot;a=ice-pwd:Yotk3Im3mnyi+1Q38p51MDub\r\n&quot;
421                     &quot;a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B\r\n&quot;
422                     &quot;a=setup:active\r\n&quot;;
423             }
424             if (m_isReceivingVideo) {
425                 sdp &lt;&lt;
426                     &quot;m=video 9 UDP/TLS/RTP/SAVPF 103 100 120\r\n&quot;
427                     &quot;c=IN IP4 0.0.0.0\r\n&quot;
428                     &quot;a=rtcp-mux\r\n&quot;
429                     &quot;a=recvonly\r\n&quot;
430                     &quot;a=mid:part2\r\n&quot;
431                     &quot;a=rtpmap:103 H264/90000\r\n&quot;
432                     &quot;a=rtpmap:100 VP8/90000\r\n&quot;
433                     &quot;a=rtpmap:120 RTX/90000\r\n&quot;
434                     &quot;a=fmtp:103 packetization-mode=1\r\n&quot;
435                     &quot;a=fmtp:120 apt=100;rtx-time=200\r\n&quot;
436                     &quot;a=rtcp-fb:100 nack\r\n&quot;
437                     &quot;a=rtcp-fb:103 nack pli\r\n&quot;
438                     &quot;a=rtcp-fb:100 nack pli\r\n&quot;
439                     &quot;a=rtcp-fb:103 ccm fir\r\n&quot;
440                     &quot;a=rtcp-fb:100 ccm fir\r\n&quot;
441                     &quot;a=ssrc:3409173718 cname:/chKzCS9K6KOgL0n\r\n&quot;
442                     &quot;a=ice-ufrag:e/B1\r\n&quot;
443                     &quot;a=ice-pwd:Yotk3Im3mnyi+1Q38p51MDub\r\n&quot;
444                     &quot;a=fingerprint:sha-256 8B:87:09:8A:5D:C2:F3:33:EF:C5:B1:F6:84:3A:3D:D6:A3:E2:9C:17:4C:E7:46:3B:1B:CE:84:98:DD:8E:AF:7B\r\n&quot;
445                     &quot;a=setup:active\r\n&quot;;
446             }
447         }
448         observer-&gt;OnSuccess(new MockLibWebRTCSessionDescription(sdp.str()));
449     });
450 }
451 
452 } // namespace WebCore
453 
454 #endif // USE(LIBWEBRTC)
    </pre>
  </body>
</html>
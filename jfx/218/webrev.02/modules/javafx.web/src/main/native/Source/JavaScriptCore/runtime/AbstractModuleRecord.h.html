<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Identifier.h&quot;
 29 #include &quot;JSDestructibleObject.h&quot;
 30 #include &lt;wtf/ListHashSet.h&gt;
 31 
 32 namespace JSC {
 33 
 34 class JSModuleEnvironment;
 35 class JSModuleNamespaceObject;
 36 class JSMap;
 37 
 38 // Based on the Source Text Module Record
 39 // http://www.ecma-international.org/ecma-262/6.0/#sec-source-text-module-records
 40 class AbstractModuleRecord : public JSNonFinalObject {
 41     friend class LLIntOffsetsExtractor;
 42 public:
 43     using Base = JSNonFinalObject;
 44 
 45     static constexpr bool needsDestruction = true;
 46 
 47     template&lt;typename CellType, SubspaceAccess&gt;
 48     static void subspaceFor(VM&amp;)
 49     {
 50         RELEASE_ASSERT_NOT_REACHED();
 51     }
 52 
 53     // https://tc39.github.io/ecma262/#sec-source-text-module-records
 54     struct ExportEntry {
 55         enum class Type {
 56             Local,
 57             Indirect
 58         };
 59 
 60         static ExportEntry createLocal(const Identifier&amp; exportName, const Identifier&amp; localName);
 61         static ExportEntry createIndirect(const Identifier&amp; exportName, const Identifier&amp; importName, const Identifier&amp; moduleName);
 62 
 63         Type type;
 64         Identifier exportName;
 65         Identifier moduleName;
 66         Identifier importName;
 67         Identifier localName;
 68     };
 69 
 70     enum class ImportEntryType { Single, Namespace };
 71     struct ImportEntry {
 72         ImportEntryType type;
 73         Identifier moduleRequest;
 74         Identifier importName;
 75         Identifier localName;
 76     };
 77 
 78     typedef WTF::ListHashSet&lt;RefPtr&lt;UniquedStringImpl&gt;, IdentifierRepHash&gt; OrderedIdentifierSet;
 79     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, ImportEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;&gt; ImportEntries;
 80     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, ExportEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;&gt; ExportEntries;
 81 
 82     DECLARE_EXPORT_INFO;
 83 
 84     void appendRequestedModule(const Identifier&amp;);
 85     void addStarExportEntry(const Identifier&amp;);
 86     void addImportEntry(const ImportEntry&amp;);
 87     void addExportEntry(const ExportEntry&amp;);
 88 
 89     Optional&lt;ImportEntry&gt; tryGetImportEntry(UniquedStringImpl* localName);
 90     Optional&lt;ExportEntry&gt; tryGetExportEntry(UniquedStringImpl* exportName);
 91 
 92     const Identifier&amp; moduleKey() const { return m_moduleKey; }
 93     const OrderedIdentifierSet&amp; requestedModules() const { return m_requestedModules; }
 94     const ExportEntries&amp; exportEntries() const { return m_exportEntries; }
 95     const ImportEntries&amp; importEntries() const { return m_importEntries; }
 96     const OrderedIdentifierSet&amp; starExportEntries() const { return m_starExportEntries; }
 97 
 98     void dump();
 99 
100     struct Resolution {
101         enum class Type { Resolved, NotFound, Ambiguous, Error };
102 
103         static Resolution notFound();
104         static Resolution error();
105         static Resolution ambiguous();
106 
107         Type type;
108         AbstractModuleRecord* moduleRecord;
109         Identifier localName;
110     };
111 
112     Resolution resolveExport(JSGlobalObject*, const Identifier&amp; exportName);
113     Resolution resolveImport(JSGlobalObject*, const Identifier&amp; localName);
114 
115     AbstractModuleRecord* hostResolveImportedModule(JSGlobalObject*, const Identifier&amp; moduleName);
116 
117     JSModuleNamespaceObject* getModuleNamespace(JSGlobalObject*);
118 
119     JSModuleEnvironment* moduleEnvironment()
120     {
121         ASSERT(m_moduleEnvironment);
122         return m_moduleEnvironment.get();
123     }
124 
125     JSModuleEnvironment* moduleEnvironmentMayBeNull()
126     {
127         return m_moduleEnvironment.get();
128     }
129 
130     void link(JSGlobalObject*, JSValue scriptFetcher);
131     JS_EXPORT_PRIVATE JSValue evaluate(JSGlobalObject*);
132 
133 protected:
134     AbstractModuleRecord(VM&amp;, Structure*, const Identifier&amp;);
135     void finishCreation(JSGlobalObject*, VM&amp;);
136 
137     static void visitChildren(JSCell*, SlotVisitor&amp;);
138 
139     WriteBarrier&lt;JSModuleEnvironment&gt; m_moduleEnvironment;
140 
141 private:
142     struct ResolveQuery;
143     static Resolution resolveExportImpl(JSGlobalObject*, const ResolveQuery&amp;);
144     Optional&lt;Resolution&gt; tryGetCachedResolution(UniquedStringImpl* exportName);
145     void cacheResolution(UniquedStringImpl* exportName, const Resolution&amp;);
146 
147     // The loader resolves the given module name to the module key. The module key is the unique value to represent this module.
148     Identifier m_moduleKey;
149 
150     // Currently, we don&#39;t keep the occurrence order of the import / export entries.
151     // So, we does not guarantee the order of the errors.
152     // e.g. The import declaration that occurr later than the another import declaration may
153     //      throw the error even if the former import declaration also has the invalid content.
154     //
155     //      import ... // (1) this has some invalid content.
156     //      import ... // (2) this also has some invalid content.
157     //
158     //      In the above case, (2) may throw the error earlier than (1)
159     //
160     // But, in all the cases, we will throw the syntax error. So except for the content of the syntax error,
161     // there are no difference.
162 
163     // Map localName -&gt; ImportEntry.
164     ImportEntries m_importEntries;
165 
166     // Map exportName -&gt; ExportEntry.
167     ExportEntries m_exportEntries;
168 
169     // Save the occurrence order since resolveExport requires it.
170     OrderedIdentifierSet m_starExportEntries;
171 
172     // Save the occurrence order since the module loader loads and runs the modules in this order.
173     // http://www.ecma-international.org/ecma-262/6.0/#sec-moduleevaluation
174     OrderedIdentifierSet m_requestedModules;
175 
176     WriteBarrier&lt;JSMap&gt; m_dependenciesMap;
177 
178     WriteBarrier&lt;JSModuleNamespaceObject&gt; m_moduleNamespaceObject;
179 
180     // We assume that all the AbstractModuleRecord are retained by JSModuleLoader&#39;s registry.
181     // So here, we don&#39;t visit each object for GC. The resolution cache map caches the once
182     // looked up correctly resolved resolution, since (1) we rarely looked up the non-resolved one,
183     // and (2) if we cache all the attempts the size of the map becomes infinitely large.
184     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, Resolution, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;&gt; Resolutions;
185     Resolutions m_resolutionCache;
186 };
187 
188 } // namespace JSC
    </pre>
  </body>
</html>
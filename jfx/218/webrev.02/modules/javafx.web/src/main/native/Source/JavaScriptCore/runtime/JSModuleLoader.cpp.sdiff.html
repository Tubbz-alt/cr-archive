<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSModuleEnvironment.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;JSModuleLoader.h&quot;
 29 
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;CatchScope.h&quot;
 32 #include &quot;CodeProfiling.h&quot;
 33 #include &quot;Error.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;JSGlobalObjectFunctions.h&quot;
 37 #include &quot;JSInternalPromise.h&quot;
<span class="line-removed"> 38 #include &quot;JSInternalPromiseDeferred.h&quot;</span>
 39 #include &quot;JSMap.h&quot;
 40 #include &quot;JSModuleEnvironment.h&quot;
 41 #include &quot;JSModuleNamespaceObject.h&quot;
 42 #include &quot;JSModuleRecord.h&quot;
 43 #include &quot;JSSourceCode.h&quot;
 44 #include &quot;JSWebAssembly.h&quot;
 45 #include &quot;ModuleAnalyzer.h&quot;
 46 #include &quot;Nodes.h&quot;
 47 #include &quot;ObjectConstructor.h&quot;
 48 #include &quot;Parser.h&quot;
 49 #include &quot;ParserError.h&quot;
 50 
 51 namespace JSC {
 52 
<span class="line-modified"> 53 static EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(ExecState*);</span>
<span class="line-modified"> 54 static EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(ExecState*);</span>
<span class="line-modified"> 55 static EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(ExecState*);</span>
<span class="line-modified"> 56 static EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(ExecState*);</span>
<span class="line-modified"> 57 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(ExecState*);</span>
<span class="line-modified"> 58 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(ExecState*);</span>
<span class="line-modified"> 59 static EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(ExecState*);</span>
<span class="line-modified"> 60 static EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(ExecState*);</span>
 61 
 62 }
 63 
 64 #include &quot;JSModuleLoader.lut.h&quot;
 65 
 66 namespace JSC {
 67 
 68 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSModuleLoader);
 69 
 70 const ClassInfo JSModuleLoader::s_info = { &quot;ModuleLoader&quot;, &amp;Base::s_info, &amp;moduleLoaderTable, nullptr, CREATE_METHOD_TABLE(JSModuleLoader) };
 71 
 72 /* Source for JSModuleLoader.lut.h
 73 @begin moduleLoaderTable
 74     ensureRegistered               JSBuiltin                                  DontEnum|Function 1
 75     forceFulfillPromise            JSBuiltin                                  DontEnum|Function 2
 76     fulfillFetch                   JSBuiltin                                  DontEnum|Function 2
 77     requestFetch                   JSBuiltin                                  DontEnum|Function 3
 78     requestInstantiate             JSBuiltin                                  DontEnum|Function 3
 79     requestSatisfy                 JSBuiltin                                  DontEnum|Function 3
 80     link                           JSBuiltin                                  DontEnum|Function 2
</pre>
<hr />
<pre>
 84     provideFetch                   JSBuiltin                                  DontEnum|Function 2
 85     loadAndEvaluateModule          JSBuiltin                                  DontEnum|Function 3
 86     loadModule                     JSBuiltin                                  DontEnum|Function 3
 87     linkAndEvaluateModule          JSBuiltin                                  DontEnum|Function 2
 88     requestImportModule            JSBuiltin                                  DontEnum|Function 3
 89     dependencyKeysIfEvaluated      JSBuiltin                                  DontEnum|Function 1
 90     getModuleNamespaceObject       moduleLoaderGetModuleNamespaceObject       DontEnum|Function 1
 91     parseModule                    moduleLoaderParseModule                    DontEnum|Function 2
 92     requestedModules               moduleLoaderRequestedModules               DontEnum|Function 1
 93     resolve                        moduleLoaderResolve                        DontEnum|Function 2
 94     resolveSync                    moduleLoaderResolveSync                    DontEnum|Function 2
 95     fetch                          moduleLoaderFetch                          DontEnum|Function 3
 96 @end
 97 */
 98 
 99 JSModuleLoader::JSModuleLoader(VM&amp; vm, Structure* structure)
100     : JSNonFinalObject(vm, structure)
101 {
102 }
103 
<span class="line-modified">104 void JSModuleLoader::finishCreation(ExecState* exec, VM&amp; vm, JSGlobalObject* globalObject)</span>
105 {
106     auto scope = DECLARE_CATCH_SCOPE(vm);
107 
108     Base::finishCreation(vm);
109     ASSERT(inherits(vm, info()));
<span class="line-modified">110     JSMap* map = JSMap::create(exec, vm, globalObject-&gt;mapStructure());</span>
111     scope.releaseAssertNoException();
112     putDirect(vm, Identifier::fromString(vm, &quot;registry&quot;), map);
113 }
114 
115 // ------------------------------ Functions --------------------------------
116 
<span class="line-modified">117 static String printableModuleKey(ExecState* exec, JSValue key)</span>
118 {
<span class="line-modified">119     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">120     auto scope = DECLARE_THROW_SCOPE(vm);</span>
121     if (key.isString() || key.isSymbol()) {
<span class="line-modified">122         auto propertyName = key.toPropertyKey(exec);</span>
123         scope.assertNoException(); // This is OK since this function is just for debugging purpose.
124         return propertyName.impl();
125     }
126     return vm.propertyNames-&gt;emptyIdentifier.impl();
127 }
128 
<span class="line-modified">129 JSArray* JSModuleLoader::dependencyKeysIfEvaluated(ExecState* exec, JSValue key)</span>
130 {
<span class="line-modified">131     VM&amp; vm = exec-&gt;vm();</span>
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
<span class="line-modified">134     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().dependencyKeysIfEvaluatedPublicName()));</span>
135     RETURN_IF_EXCEPTION(scope, nullptr);
136     CallData callData;
137     CallType callType = JSC::getCallData(vm, function, callData);
138     ASSERT(callType != CallType::None);
139 
140     MarkedArgumentBuffer arguments;
141     arguments.append(key);
142 
<span class="line-modified">143     JSValue result = call(exec, function, callType, callData, this, arguments);</span>
144     RETURN_IF_EXCEPTION(scope, nullptr);
145 
146     return jsDynamicCast&lt;JSArray*&gt;(vm, result);
147 }
148 
<span class="line-modified">149 JSValue JSModuleLoader::provideFetch(ExecState* exec, JSValue key, const SourceCode&amp; sourceCode)</span>
150 {
<span class="line-modified">151     VM&amp; vm = exec-&gt;vm();</span>
152     auto scope = DECLARE_THROW_SCOPE(vm);
153 
<span class="line-modified">154     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().provideFetchPublicName()));</span>
155     RETURN_IF_EXCEPTION(scope, { });
156     CallData callData;
157     CallType callType = JSC::getCallData(vm, function, callData);
158     ASSERT(callType != CallType::None);
159 
160     SourceCode source { sourceCode };
161     MarkedArgumentBuffer arguments;
162     arguments.append(key);
163     arguments.append(JSSourceCode::create(vm, WTFMove(source)));
164     ASSERT(!arguments.hasOverflowed());
165 
<span class="line-modified">166     RELEASE_AND_RETURN(scope, call(exec, function, callType, callData, this, arguments));</span>
167 }
168 
<span class="line-modified">169 JSInternalPromise* JSModuleLoader::loadAndEvaluateModule(ExecState* exec, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
170 {
<span class="line-modified">171     VM&amp; vm = exec-&gt;vm();</span>
172     auto scope = DECLARE_THROW_SCOPE(vm);
173 
<span class="line-modified">174     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().loadAndEvaluateModulePublicName()));</span>
175     RETURN_IF_EXCEPTION(scope, nullptr);
176     CallData callData;
177     CallType callType = JSC::getCallData(vm, function, callData);
178     ASSERT(callType != CallType::None);
179 
180     MarkedArgumentBuffer arguments;
181     arguments.append(moduleName);
182     arguments.append(parameters);
183     arguments.append(scriptFetcher);
184     ASSERT(!arguments.hasOverflowed());
185 
<span class="line-modified">186     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
187     RETURN_IF_EXCEPTION(scope, nullptr);
188     return jsCast&lt;JSInternalPromise*&gt;(promise);
189 }
190 
<span class="line-modified">191 JSInternalPromise* JSModuleLoader::loadModule(ExecState* exec, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
192 {
<span class="line-modified">193     VM&amp; vm = exec-&gt;vm();</span>
194     auto scope = DECLARE_THROW_SCOPE(vm);
195 
<span class="line-modified">196     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().loadModulePublicName()));</span>
197     RETURN_IF_EXCEPTION(scope, nullptr);
198     CallData callData;
199     CallType callType = JSC::getCallData(vm, function, callData);
200     ASSERT(callType != CallType::None);
201 
202     MarkedArgumentBuffer arguments;
203     arguments.append(moduleName);
204     arguments.append(parameters);
205     arguments.append(scriptFetcher);
206     ASSERT(!arguments.hasOverflowed());
207 
<span class="line-modified">208     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
209     RETURN_IF_EXCEPTION(scope, nullptr);
210     return jsCast&lt;JSInternalPromise*&gt;(promise);
211 }
212 
<span class="line-modified">213 JSValue JSModuleLoader::linkAndEvaluateModule(ExecState* exec, JSValue moduleKey, JSValue scriptFetcher)</span>
214 {
<span class="line-modified">215     VM&amp; vm = exec-&gt;vm();</span>
216     auto scope = DECLARE_THROW_SCOPE(vm);
217 
<span class="line-modified">218     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().linkAndEvaluateModulePublicName()));</span>
219     RETURN_IF_EXCEPTION(scope, { });
220     CallData callData;
221     CallType callType = JSC::getCallData(vm, function, callData);
222     ASSERT(callType != CallType::None);
223 
224     MarkedArgumentBuffer arguments;
225     arguments.append(moduleKey);
226     arguments.append(scriptFetcher);
227     ASSERT(!arguments.hasOverflowed());
228 
<span class="line-modified">229     RELEASE_AND_RETURN(scope, call(exec, function, callType, callData, this, arguments));</span>
230 }
231 
<span class="line-modified">232 JSInternalPromise* JSModuleLoader::requestImportModule(ExecState* exec, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)</span>
233 {
<span class="line-modified">234     VM&amp; vm = exec-&gt;vm();</span>
235     auto scope = DECLARE_THROW_SCOPE(vm);
236 
<span class="line-modified">237     auto* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().requestImportModulePublicName()));</span>
238     RETURN_IF_EXCEPTION(scope, nullptr);
239     CallData callData;
240     auto callType = JSC::getCallData(vm, function, callData);
241     ASSERT(callType != CallType::None);
242 
243     MarkedArgumentBuffer arguments;
244     arguments.append(jsString(vm, moduleKey.impl()));
245     arguments.append(parameters);
246     arguments.append(scriptFetcher);
247     ASSERT(!arguments.hasOverflowed());
248 
<span class="line-modified">249     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
250     RETURN_IF_EXCEPTION(scope, nullptr);
251     return jsCast&lt;JSInternalPromise*&gt;(promise);
252 }
253 
<span class="line-modified">254 JSInternalPromise* JSModuleLoader::importModule(ExecState* exec, JSString* moduleName, JSValue parameters, const SourceOrigin&amp; referrer)</span>
255 {
<span class="line-modified">256     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">257         dataLog(&quot;Loader [import] &quot;, printableModuleKey(exec, moduleName), &quot;\n&quot;);</span>
258 
<span class="line-removed">259     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
260     VM&amp; vm = globalObject-&gt;vm();
261     auto throwScope = DECLARE_THROW_SCOPE(vm);
262 
263     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule)
<span class="line-modified">264         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule(globalObject, exec, this, moduleName, parameters, referrer));</span>
265 
<span class="line-modified">266     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">267     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
268 
269     auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">270     auto moduleNameString = moduleName-&gt;value(exec);</span>
271     if (UNLIKELY(catchScope.exception())) {
272         JSValue exception = catchScope.exception()-&gt;value();
273         catchScope.clearException();
<span class="line-modified">274         deferred-&gt;reject(exec, exception);</span>
275         catchScope.clearException();
<span class="line-modified">276         return deferred-&gt;promise();</span>
277     }
<span class="line-modified">278     deferred-&gt;reject(exec, createError(exec, makeString(&quot;Could not import the module &#39;&quot;, moduleNameString, &quot;&#39;.&quot;)));</span>
279     catchScope.clearException();
<span class="line-modified">280     return deferred-&gt;promise();</span>
281 }
282 
<span class="line-modified">283 Identifier JSModuleLoader::resolveSync(ExecState* exec, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
284 {
<span class="line-modified">285     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">286         dataLog(&quot;Loader [resolve] &quot;, printableModuleKey(exec, name), &quot;\n&quot;);</span>
287 
<span class="line-removed">288     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
289     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve)
<span class="line-modified">290         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve(globalObject, exec, this, name, referrer, scriptFetcher);</span>
<span class="line-modified">291     return name.toPropertyKey(exec);</span>
292 }
293 
<span class="line-modified">294 JSInternalPromise* JSModuleLoader::resolve(ExecState* exec, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
295 {
<span class="line-modified">296     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">297     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
298 
<span class="line-modified">299     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed">300     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
301 
302     auto catchScope = DECLARE_CATCH_SCOPE(vm);
303 
<span class="line-modified">304     const Identifier moduleKey = resolveSync(exec, name, referrer, scriptFetcher);</span>
305     if (UNLIKELY(catchScope.exception())) {
306         JSValue exception = catchScope.exception();
307         catchScope.clearException();
<span class="line-modified">308         auto result = deferred-&gt;reject(exec, exception);</span>
309         catchScope.clearException();
<span class="line-modified">310         return result;</span>
311     }
<span class="line-modified">312     auto result = deferred-&gt;resolve(exec, identifierToJSValue(vm, moduleKey));</span>
313     catchScope.clearException();
<span class="line-modified">314     return result;</span>
315 }
316 
<span class="line-modified">317 JSInternalPromise* JSModuleLoader::fetch(ExecState* exec, JSValue key, JSValue parameters, JSValue scriptFetcher)</span>
318 {
<span class="line-modified">319     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">320         dataLog(&quot;Loader [fetch] &quot;, printableModuleKey(exec, key), &quot;\n&quot;);</span>
321 
<span class="line-removed">322     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
323     VM&amp; vm = globalObject-&gt;vm();
324     auto throwScope = DECLARE_THROW_SCOPE(vm);
325 
326     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch)
<span class="line-modified">327         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch(globalObject, exec, this, key, parameters, scriptFetcher));</span>
328 
<span class="line-modified">329     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">330     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
331 
332     auto catchScope = DECLARE_CATCH_SCOPE(vm);
333 
<span class="line-modified">334     String moduleKey = key.toWTFString(exec);</span>
335     if (UNLIKELY(catchScope.exception())) {
336         JSValue exception = catchScope.exception()-&gt;value();
337         catchScope.clearException();
<span class="line-modified">338         deferred-&gt;reject(exec, exception);</span>
339         catchScope.clearException();
<span class="line-modified">340         return deferred-&gt;promise();</span>
341     }
<span class="line-modified">342     deferred-&gt;reject(exec, createError(exec, makeString(&quot;Could not open the module &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
343     catchScope.clearException();
<span class="line-modified">344     return deferred-&gt;promise();</span>
345 }
346 
<span class="line-modified">347 JSObject* JSModuleLoader::createImportMetaProperties(ExecState* exec, JSValue key, JSModuleRecord* moduleRecord, JSValue scriptFetcher)</span>
348 {
<span class="line-removed">349     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
350     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties)
<span class="line-modified">351         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties(globalObject, exec, this, key, moduleRecord, scriptFetcher);</span>
<span class="line-modified">352     return constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
353 }
354 
<span class="line-modified">355 JSValue JSModuleLoader::evaluate(ExecState* exec, JSValue key, JSValue moduleRecordValue, JSValue scriptFetcher)</span>
356 {
<span class="line-modified">357     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">358         dataLog(&quot;Loader [evaluate] &quot;, printableModuleKey(exec, key), &quot;\n&quot;);</span>
359 
<span class="line-removed">360     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
361     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate)
<span class="line-modified">362         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate(globalObject, exec, this, key, moduleRecordValue, scriptFetcher);</span>
363 
<span class="line-modified">364     return evaluateNonVirtual(exec, key, moduleRecordValue, scriptFetcher);</span>
365 }
366 
<span class="line-modified">367 JSValue JSModuleLoader::evaluateNonVirtual(ExecState* exec, JSValue, JSValue moduleRecordValue, JSValue)</span>
368 {
<span class="line-modified">369     if (auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(exec-&gt;vm(), moduleRecordValue))</span>
<span class="line-modified">370         return moduleRecord-&gt;evaluate(exec);</span>
371     return jsUndefined();
372 }
373 
<span class="line-modified">374 JSModuleNamespaceObject* JSModuleLoader::getModuleNamespaceObject(ExecState* exec, JSValue moduleRecordValue)</span>
375 {
<span class="line-modified">376     VM&amp; vm = exec-&gt;vm();</span>
377     auto scope = DECLARE_THROW_SCOPE(vm);
378 
379     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, moduleRecordValue);
380     if (!moduleRecord) {
<span class="line-modified">381         throwTypeError(exec, scope);</span>
382         return nullptr;
383     }
384 
<span class="line-modified">385     RELEASE_AND_RETURN(scope, moduleRecord-&gt;getModuleNamespace(exec));</span>
386 }
387 
388 // ------------------------------ Functions --------------------------------
389 
<span class="line-modified">390 EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(ExecState* exec)</span>
391 {
<span class="line-modified">392     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">393     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
394 
<span class="line-modified">395     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed">396     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
397 
398     auto catchScope = DECLARE_CATCH_SCOPE(vm);
399     auto reject = [&amp;] (JSValue rejectionReason) {
400         catchScope.clearException();
<span class="line-modified">401         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
402         catchScope.clearException();
<span class="line-modified">403         return JSValue::encode(result);</span>
404     };
405 
<span class="line-modified">406     const Identifier moduleKey = exec-&gt;argument(0).toPropertyKey(exec);</span>
407     if (UNLIKELY(catchScope.exception()))
408         return reject(catchScope.exception());
409 
<span class="line-modified">410     JSValue source = exec-&gt;argument(1);</span>
411     auto* jsSourceCode = jsCast&lt;JSSourceCode*&gt;(source);
412     SourceCode sourceCode = jsSourceCode-&gt;sourceCode();
413 
414 #if ENABLE(WEBASSEMBLY)
415     if (sourceCode.provider()-&gt;sourceType() == SourceProviderSourceType::WebAssembly)
<span class="line-modified">416         return JSValue::encode(JSWebAssembly::instantiate(exec, deferred, moduleKey, jsSourceCode));</span>
417 #endif
418 
419     CodeProfiling profile(sourceCode);
420 
421     ParserError error;
422     std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
423         vm, sourceCode, Identifier(), JSParserBuiltinMode::NotBuiltin,
424         JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
425     if (error.isValid())
<span class="line-modified">426         return reject(error.toErrorObject(exec-&gt;lexicalGlobalObject(), sourceCode));</span>
427     ASSERT(moduleProgramNode);
428 
<span class="line-modified">429     ModuleAnalyzer moduleAnalyzer(exec, moduleKey, sourceCode, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());</span>
430     if (UNLIKELY(catchScope.exception()))
431         return reject(catchScope.exception());
432 
<span class="line-modified">433     auto result = deferred-&gt;resolve(exec, moduleAnalyzer.analyze(*moduleProgramNode));</span>
434     catchScope.clearException();
<span class="line-modified">435     return JSValue::encode(result);</span>
436 }
437 
<span class="line-modified">438 EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(ExecState* exec)</span>
439 {
<span class="line-modified">440     VM&amp; vm = exec-&gt;vm();</span>
441     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">442     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, exec-&gt;argument(0));</span>
443     if (!moduleRecord)
<span class="line-modified">444         RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(exec, nullptr)));</span>
445 
<span class="line-modified">446     JSArray* result = constructEmptyArray(exec, nullptr, moduleRecord-&gt;requestedModules().size());</span>
447     RETURN_IF_EXCEPTION(scope, encodedJSValue());
448     size_t i = 0;
449     for (auto&amp; key : moduleRecord-&gt;requestedModules()) {
<span class="line-modified">450         result-&gt;putDirectIndex(exec, i++, jsString(vm, key.get()));</span>
451         RETURN_IF_EXCEPTION(scope, encodedJSValue());
452     }
453     return JSValue::encode(result);
454 }
455 
<span class="line-modified">456 EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(ExecState* exec)</span>
457 {
<span class="line-modified">458     VM&amp; vm = exec-&gt;vm();</span>
459     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">460     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, exec-&gt;argument(0));</span>
461     if (!moduleRecord)
462         return JSValue::encode(jsUndefined());
463 
<span class="line-modified">464     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">465         dataLog(&quot;Loader [link] &quot;, moduleRecord-&gt;moduleKey(), &quot;\n&quot;);</span>
466 
<span class="line-modified">467     moduleRecord-&gt;link(exec, exec-&gt;argument(1));</span>
468     RETURN_IF_EXCEPTION(scope, encodedJSValue());
469 
470     return JSValue::encode(jsUndefined());
471 }
472 
473 // ------------------------------ Hook Functions ---------------------------
474 
<span class="line-modified">475 EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(ExecState* exec)</span>
476 {
<span class="line-modified">477     VM&amp; vm = exec-&gt;vm();</span>
478     // Hook point, Loader.resolve.
479     // https://whatwg.github.io/loader/#browser-resolve
480     // Take the name and resolve it to the unique identifier for the resource location.
481     // For example, take the &quot;jquery&quot; and return the URL for the resource.
<span class="line-modified">482     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
483     if (!loader)
484         return JSValue::encode(jsUndefined());
<span class="line-modified">485     return JSValue::encode(loader-&gt;resolve(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
486 }
487 
<span class="line-modified">488 EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(ExecState* exec)</span>
489 {
<span class="line-modified">490     VM&amp; vm = exec-&gt;vm();</span>
491     auto scope = DECLARE_THROW_SCOPE(vm);
492 
<span class="line-modified">493     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
494     if (!loader)
495         return JSValue::encode(jsUndefined());
<span class="line-modified">496     auto result = loader-&gt;resolveSync(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2));</span>
497     RETURN_IF_EXCEPTION(scope, encodedJSValue());
498     return JSValue::encode(identifierToJSValue(vm, result));
499 }
500 
<span class="line-modified">501 EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(ExecState* exec)</span>
502 {
<span class="line-modified">503     VM&amp; vm = exec-&gt;vm();</span>
504     // Hook point, Loader.fetch
505     // https://whatwg.github.io/loader/#browser-fetch
506     // Take the key and fetch the resource actually.
507     // For example, JavaScriptCore shell can provide the hook fetching the resource
508     // from the local file system.
<span class="line-modified">509     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
510     if (!loader)
511         return JSValue::encode(jsUndefined());
<span class="line-modified">512     return JSValue::encode(loader-&gt;fetch(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
513 }
514 
<span class="line-modified">515 EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(ExecState* exec)</span>
516 {
<span class="line-modified">517     VM&amp; vm = exec-&gt;vm();</span>
518     auto scope = DECLARE_THROW_SCOPE(vm);
519 
<span class="line-modified">520     auto* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
521     if (!loader)
522         return JSValue::encode(jsUndefined());
<span class="line-modified">523     auto* moduleNamespaceObject = loader-&gt;getModuleNamespaceObject(exec, exec-&gt;argument(0));</span>
524     RETURN_IF_EXCEPTION(scope, encodedJSValue());
525     return JSValue::encode(moduleNamespaceObject);
526 }
527 
528 // ------------------- Additional Hook Functions ---------------------------
529 
<span class="line-modified">530 EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(ExecState* exec)</span>
531 {
532     // To instrument and retrieve the errors raised from the module execution,
533     // we inserted the hook point here.
534 
<span class="line-modified">535     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">536     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
537     if (!loader)
538         return JSValue::encode(jsUndefined());
<span class="line-modified">539     return JSValue::encode(loader-&gt;evaluate(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
540 }
541 
542 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;JSModuleLoader.h&quot;
 29 
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;CatchScope.h&quot;
 32 #include &quot;CodeProfiling.h&quot;
 33 #include &quot;Error.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;JSGlobalObjectFunctions.h&quot;
 37 #include &quot;JSInternalPromise.h&quot;

 38 #include &quot;JSMap.h&quot;
 39 #include &quot;JSModuleEnvironment.h&quot;
 40 #include &quot;JSModuleNamespaceObject.h&quot;
 41 #include &quot;JSModuleRecord.h&quot;
 42 #include &quot;JSSourceCode.h&quot;
 43 #include &quot;JSWebAssembly.h&quot;
 44 #include &quot;ModuleAnalyzer.h&quot;
 45 #include &quot;Nodes.h&quot;
 46 #include &quot;ObjectConstructor.h&quot;
 47 #include &quot;Parser.h&quot;
 48 #include &quot;ParserError.h&quot;
 49 
 50 namespace JSC {
 51 
<span class="line-modified"> 52 static EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 53 static EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 54 static EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 55 static EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 56 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 57 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 58 static EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 59 static EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(JSGlobalObject*, CallFrame*);</span>
 60 
 61 }
 62 
 63 #include &quot;JSModuleLoader.lut.h&quot;
 64 
 65 namespace JSC {
 66 
 67 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSModuleLoader);
 68 
 69 const ClassInfo JSModuleLoader::s_info = { &quot;ModuleLoader&quot;, &amp;Base::s_info, &amp;moduleLoaderTable, nullptr, CREATE_METHOD_TABLE(JSModuleLoader) };
 70 
 71 /* Source for JSModuleLoader.lut.h
 72 @begin moduleLoaderTable
 73     ensureRegistered               JSBuiltin                                  DontEnum|Function 1
 74     forceFulfillPromise            JSBuiltin                                  DontEnum|Function 2
 75     fulfillFetch                   JSBuiltin                                  DontEnum|Function 2
 76     requestFetch                   JSBuiltin                                  DontEnum|Function 3
 77     requestInstantiate             JSBuiltin                                  DontEnum|Function 3
 78     requestSatisfy                 JSBuiltin                                  DontEnum|Function 3
 79     link                           JSBuiltin                                  DontEnum|Function 2
</pre>
<hr />
<pre>
 83     provideFetch                   JSBuiltin                                  DontEnum|Function 2
 84     loadAndEvaluateModule          JSBuiltin                                  DontEnum|Function 3
 85     loadModule                     JSBuiltin                                  DontEnum|Function 3
 86     linkAndEvaluateModule          JSBuiltin                                  DontEnum|Function 2
 87     requestImportModule            JSBuiltin                                  DontEnum|Function 3
 88     dependencyKeysIfEvaluated      JSBuiltin                                  DontEnum|Function 1
 89     getModuleNamespaceObject       moduleLoaderGetModuleNamespaceObject       DontEnum|Function 1
 90     parseModule                    moduleLoaderParseModule                    DontEnum|Function 2
 91     requestedModules               moduleLoaderRequestedModules               DontEnum|Function 1
 92     resolve                        moduleLoaderResolve                        DontEnum|Function 2
 93     resolveSync                    moduleLoaderResolveSync                    DontEnum|Function 2
 94     fetch                          moduleLoaderFetch                          DontEnum|Function 3
 95 @end
 96 */
 97 
 98 JSModuleLoader::JSModuleLoader(VM&amp; vm, Structure* structure)
 99     : JSNonFinalObject(vm, structure)
100 {
101 }
102 
<span class="line-modified">103 void JSModuleLoader::finishCreation(JSGlobalObject* globalObject, VM&amp; vm)</span>
104 {
105     auto scope = DECLARE_CATCH_SCOPE(vm);
106 
107     Base::finishCreation(vm);
108     ASSERT(inherits(vm, info()));
<span class="line-modified">109     JSMap* map = JSMap::create(globalObject, vm, globalObject-&gt;mapStructure());</span>
110     scope.releaseAssertNoException();
111     putDirect(vm, Identifier::fromString(vm, &quot;registry&quot;), map);
112 }
113 
114 // ------------------------------ Functions --------------------------------
115 
<span class="line-modified">116 static String printableModuleKey(JSGlobalObject* globalObject, JSValue key)</span>
117 {
<span class="line-modified">118     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">119     auto scope = DECLARE_CATCH_SCOPE(vm);</span>
120     if (key.isString() || key.isSymbol()) {
<span class="line-modified">121         auto propertyName = key.toPropertyKey(globalObject);</span>
122         scope.assertNoException(); // This is OK since this function is just for debugging purpose.
123         return propertyName.impl();
124     }
125     return vm.propertyNames-&gt;emptyIdentifier.impl();
126 }
127 
<span class="line-modified">128 JSArray* JSModuleLoader::dependencyKeysIfEvaluated(JSGlobalObject* globalObject, JSValue key)</span>
129 {
<span class="line-modified">130     VM&amp; vm = globalObject-&gt;vm();</span>
131     auto scope = DECLARE_THROW_SCOPE(vm);
132 
<span class="line-modified">133     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().dependencyKeysIfEvaluatedPublicName()));</span>
134     RETURN_IF_EXCEPTION(scope, nullptr);
135     CallData callData;
136     CallType callType = JSC::getCallData(vm, function, callData);
137     ASSERT(callType != CallType::None);
138 
139     MarkedArgumentBuffer arguments;
140     arguments.append(key);
141 
<span class="line-modified">142     JSValue result = call(globalObject, function, callType, callData, this, arguments);</span>
143     RETURN_IF_EXCEPTION(scope, nullptr);
144 
145     return jsDynamicCast&lt;JSArray*&gt;(vm, result);
146 }
147 
<span class="line-modified">148 JSValue JSModuleLoader::provideFetch(JSGlobalObject* globalObject, JSValue key, const SourceCode&amp; sourceCode)</span>
149 {
<span class="line-modified">150     VM&amp; vm = globalObject-&gt;vm();</span>
151     auto scope = DECLARE_THROW_SCOPE(vm);
152 
<span class="line-modified">153     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().provideFetchPublicName()));</span>
154     RETURN_IF_EXCEPTION(scope, { });
155     CallData callData;
156     CallType callType = JSC::getCallData(vm, function, callData);
157     ASSERT(callType != CallType::None);
158 
159     SourceCode source { sourceCode };
160     MarkedArgumentBuffer arguments;
161     arguments.append(key);
162     arguments.append(JSSourceCode::create(vm, WTFMove(source)));
163     ASSERT(!arguments.hasOverflowed());
164 
<span class="line-modified">165     RELEASE_AND_RETURN(scope, call(globalObject, function, callType, callData, this, arguments));</span>
166 }
167 
<span class="line-modified">168 JSInternalPromise* JSModuleLoader::loadAndEvaluateModule(JSGlobalObject* globalObject, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
169 {
<span class="line-modified">170     VM&amp; vm = globalObject-&gt;vm();</span>
171     auto scope = DECLARE_THROW_SCOPE(vm);
172 
<span class="line-modified">173     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().loadAndEvaluateModulePublicName()));</span>
174     RETURN_IF_EXCEPTION(scope, nullptr);
175     CallData callData;
176     CallType callType = JSC::getCallData(vm, function, callData);
177     ASSERT(callType != CallType::None);
178 
179     MarkedArgumentBuffer arguments;
180     arguments.append(moduleName);
181     arguments.append(parameters);
182     arguments.append(scriptFetcher);
183     ASSERT(!arguments.hasOverflowed());
184 
<span class="line-modified">185     JSValue promise = call(globalObject, function, callType, callData, this, arguments);</span>
186     RETURN_IF_EXCEPTION(scope, nullptr);
187     return jsCast&lt;JSInternalPromise*&gt;(promise);
188 }
189 
<span class="line-modified">190 JSInternalPromise* JSModuleLoader::loadModule(JSGlobalObject* globalObject, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
191 {
<span class="line-modified">192     VM&amp; vm = globalObject-&gt;vm();</span>
193     auto scope = DECLARE_THROW_SCOPE(vm);
194 
<span class="line-modified">195     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().loadModulePublicName()));</span>
196     RETURN_IF_EXCEPTION(scope, nullptr);
197     CallData callData;
198     CallType callType = JSC::getCallData(vm, function, callData);
199     ASSERT(callType != CallType::None);
200 
201     MarkedArgumentBuffer arguments;
202     arguments.append(moduleName);
203     arguments.append(parameters);
204     arguments.append(scriptFetcher);
205     ASSERT(!arguments.hasOverflowed());
206 
<span class="line-modified">207     JSValue promise = call(globalObject, function, callType, callData, this, arguments);</span>
208     RETURN_IF_EXCEPTION(scope, nullptr);
209     return jsCast&lt;JSInternalPromise*&gt;(promise);
210 }
211 
<span class="line-modified">212 JSValue JSModuleLoader::linkAndEvaluateModule(JSGlobalObject* globalObject, JSValue moduleKey, JSValue scriptFetcher)</span>
213 {
<span class="line-modified">214     VM&amp; vm = globalObject-&gt;vm();</span>
215     auto scope = DECLARE_THROW_SCOPE(vm);
216 
<span class="line-modified">217     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().linkAndEvaluateModulePublicName()));</span>
218     RETURN_IF_EXCEPTION(scope, { });
219     CallData callData;
220     CallType callType = JSC::getCallData(vm, function, callData);
221     ASSERT(callType != CallType::None);
222 
223     MarkedArgumentBuffer arguments;
224     arguments.append(moduleKey);
225     arguments.append(scriptFetcher);
226     ASSERT(!arguments.hasOverflowed());
227 
<span class="line-modified">228     RELEASE_AND_RETURN(scope, call(globalObject, function, callType, callData, this, arguments));</span>
229 }
230 
<span class="line-modified">231 JSInternalPromise* JSModuleLoader::requestImportModule(JSGlobalObject* globalObject, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)</span>
232 {
<span class="line-modified">233     VM&amp; vm = globalObject-&gt;vm();</span>
234     auto scope = DECLARE_THROW_SCOPE(vm);
235 
<span class="line-modified">236     auto* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().requestImportModulePublicName()));</span>
237     RETURN_IF_EXCEPTION(scope, nullptr);
238     CallData callData;
239     auto callType = JSC::getCallData(vm, function, callData);
240     ASSERT(callType != CallType::None);
241 
242     MarkedArgumentBuffer arguments;
243     arguments.append(jsString(vm, moduleKey.impl()));
244     arguments.append(parameters);
245     arguments.append(scriptFetcher);
246     ASSERT(!arguments.hasOverflowed());
247 
<span class="line-modified">248     JSValue promise = call(globalObject, function, callType, callData, this, arguments);</span>
249     RETURN_IF_EXCEPTION(scope, nullptr);
250     return jsCast&lt;JSInternalPromise*&gt;(promise);
251 }
252 
<span class="line-modified">253 JSInternalPromise* JSModuleLoader::importModule(JSGlobalObject* globalObject, JSString* moduleName, JSValue parameters, const SourceOrigin&amp; referrer)</span>
254 {
<span class="line-modified">255     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [import] &quot;, printableModuleKey(globalObject, moduleName));</span>

256 

257     VM&amp; vm = globalObject-&gt;vm();
258     auto throwScope = DECLARE_THROW_SCOPE(vm);
259 
260     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule)
<span class="line-modified">261         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule(globalObject, this, moduleName, parameters, referrer));</span>
262 
<span class="line-modified">263     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>

264 
265     auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">266     auto moduleNameString = moduleName-&gt;value(globalObject);</span>
267     if (UNLIKELY(catchScope.exception())) {
268         JSValue exception = catchScope.exception()-&gt;value();
269         catchScope.clearException();
<span class="line-modified">270         promise-&gt;reject(globalObject, exception);</span>
271         catchScope.clearException();
<span class="line-modified">272         return promise;</span>
273     }
<span class="line-modified">274     promise-&gt;reject(globalObject, createError(globalObject, makeString(&quot;Could not import the module &#39;&quot;, moduleNameString, &quot;&#39;.&quot;)));</span>
275     catchScope.clearException();
<span class="line-modified">276     return promise;</span>
277 }
278 
<span class="line-modified">279 Identifier JSModuleLoader::resolveSync(JSGlobalObject* globalObject, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
280 {
<span class="line-modified">281     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [resolve] &quot;, printableModuleKey(globalObject, name));</span>

282 

283     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve)
<span class="line-modified">284         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve(globalObject, this, name, referrer, scriptFetcher);</span>
<span class="line-modified">285     return name.toPropertyKey(globalObject);</span>
286 }
287 
<span class="line-modified">288 JSInternalPromise* JSModuleLoader::resolve(JSGlobalObject* globalObject, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
289 {
<span class="line-modified">290     VM&amp; vm = globalObject-&gt;vm();</span>

291 
<span class="line-modified">292     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>

293 
294     auto catchScope = DECLARE_CATCH_SCOPE(vm);
295 
<span class="line-modified">296     const Identifier moduleKey = resolveSync(globalObject, name, referrer, scriptFetcher);</span>
297     if (UNLIKELY(catchScope.exception())) {
298         JSValue exception = catchScope.exception();
299         catchScope.clearException();
<span class="line-modified">300         promise-&gt;reject(globalObject, exception);</span>
301         catchScope.clearException();
<span class="line-modified">302         return promise;</span>
303     }
<span class="line-modified">304     promise-&gt;resolve(globalObject, identifierToJSValue(vm, moduleKey));</span>
305     catchScope.clearException();
<span class="line-modified">306     return promise;</span>
307 }
308 
<span class="line-modified">309 JSInternalPromise* JSModuleLoader::fetch(JSGlobalObject* globalObject, JSValue key, JSValue parameters, JSValue scriptFetcher)</span>
310 {
<span class="line-modified">311     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [fetch] &quot;, printableModuleKey(globalObject, key));</span>

312 

313     VM&amp; vm = globalObject-&gt;vm();
314     auto throwScope = DECLARE_THROW_SCOPE(vm);
315 
316     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch)
<span class="line-modified">317         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch(globalObject, this, key, parameters, scriptFetcher));</span>
318 
<span class="line-modified">319     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>

320 
321     auto catchScope = DECLARE_CATCH_SCOPE(vm);
322 
<span class="line-modified">323     String moduleKey = key.toWTFString(globalObject);</span>
324     if (UNLIKELY(catchScope.exception())) {
325         JSValue exception = catchScope.exception()-&gt;value();
326         catchScope.clearException();
<span class="line-modified">327         promise-&gt;reject(globalObject, exception);</span>
328         catchScope.clearException();
<span class="line-modified">329         return promise;</span>
330     }
<span class="line-modified">331     promise-&gt;reject(globalObject, createError(globalObject, makeString(&quot;Could not open the module &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
332     catchScope.clearException();
<span class="line-modified">333     return promise;</span>
334 }
335 
<span class="line-modified">336 JSObject* JSModuleLoader::createImportMetaProperties(JSGlobalObject* globalObject, JSValue key, JSModuleRecord* moduleRecord, JSValue scriptFetcher)</span>
337 {

338     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties)
<span class="line-modified">339         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties(globalObject, this, key, moduleRecord, scriptFetcher);</span>
<span class="line-modified">340     return constructEmptyObject(globalObject-&gt;vm(), globalObject-&gt;nullPrototypeObjectStructure());</span>
341 }
342 
<span class="line-modified">343 JSValue JSModuleLoader::evaluate(JSGlobalObject* globalObject, JSValue key, JSValue moduleRecordValue, JSValue scriptFetcher)</span>
344 {
<span class="line-modified">345     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [evaluate] &quot;, printableModuleKey(globalObject, key));</span>

346 

347     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate)
<span class="line-modified">348         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate(globalObject, this, key, moduleRecordValue, scriptFetcher);</span>
349 
<span class="line-modified">350     return evaluateNonVirtual(globalObject, key, moduleRecordValue, scriptFetcher);</span>
351 }
352 
<span class="line-modified">353 JSValue JSModuleLoader::evaluateNonVirtual(JSGlobalObject* globalObject, JSValue, JSValue moduleRecordValue, JSValue)</span>
354 {
<span class="line-modified">355     if (auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(globalObject-&gt;vm(), moduleRecordValue))</span>
<span class="line-modified">356         return moduleRecord-&gt;evaluate(globalObject);</span>
357     return jsUndefined();
358 }
359 
<span class="line-modified">360 JSModuleNamespaceObject* JSModuleLoader::getModuleNamespaceObject(JSGlobalObject* globalObject, JSValue moduleRecordValue)</span>
361 {
<span class="line-modified">362     VM&amp; vm = globalObject-&gt;vm();</span>
363     auto scope = DECLARE_THROW_SCOPE(vm);
364 
365     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, moduleRecordValue);
366     if (!moduleRecord) {
<span class="line-modified">367         throwTypeError(globalObject, scope);</span>
368         return nullptr;
369     }
370 
<span class="line-modified">371     RELEASE_AND_RETURN(scope, moduleRecord-&gt;getModuleNamespace(globalObject));</span>
372 }
373 
374 // ------------------------------ Functions --------------------------------
375 
<span class="line-modified">376 EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
377 {
<span class="line-modified">378     VM&amp; vm = globalObject-&gt;vm();</span>

379 
<span class="line-modified">380     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>

381 
382     auto catchScope = DECLARE_CATCH_SCOPE(vm);
383     auto reject = [&amp;] (JSValue rejectionReason) {
384         catchScope.clearException();
<span class="line-modified">385         promise-&gt;reject(globalObject, rejectionReason);</span>
386         catchScope.clearException();
<span class="line-modified">387         return JSValue::encode(promise);</span>
388     };
389 
<span class="line-modified">390     const Identifier moduleKey = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
391     if (UNLIKELY(catchScope.exception()))
392         return reject(catchScope.exception());
393 
<span class="line-modified">394     JSValue source = callFrame-&gt;argument(1);</span>
395     auto* jsSourceCode = jsCast&lt;JSSourceCode*&gt;(source);
396     SourceCode sourceCode = jsSourceCode-&gt;sourceCode();
397 
398 #if ENABLE(WEBASSEMBLY)
399     if (sourceCode.provider()-&gt;sourceType() == SourceProviderSourceType::WebAssembly)
<span class="line-modified">400         return JSValue::encode(JSWebAssembly::instantiate(globalObject, promise, moduleKey, jsSourceCode));</span>
401 #endif
402 
403     CodeProfiling profile(sourceCode);
404 
405     ParserError error;
406     std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
407         vm, sourceCode, Identifier(), JSParserBuiltinMode::NotBuiltin,
408         JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
409     if (error.isValid())
<span class="line-modified">410         return reject(error.toErrorObject(globalObject, sourceCode));</span>
411     ASSERT(moduleProgramNode);
412 
<span class="line-modified">413     ModuleAnalyzer moduleAnalyzer(globalObject, moduleKey, sourceCode, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());</span>
414     if (UNLIKELY(catchScope.exception()))
415         return reject(catchScope.exception());
416 
<span class="line-modified">417     promise-&gt;resolve(globalObject, moduleAnalyzer.analyze(*moduleProgramNode));</span>
418     catchScope.clearException();
<span class="line-modified">419     return JSValue::encode(promise);</span>
420 }
421 
<span class="line-modified">422 EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
423 {
<span class="line-modified">424     VM&amp; vm = globalObject-&gt;vm();</span>
425     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">426     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, callFrame-&gt;argument(0));</span>
427     if (!moduleRecord)
<span class="line-modified">428         RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(globalObject, nullptr)));</span>
429 
<span class="line-modified">430     JSArray* result = constructEmptyArray(globalObject, nullptr, moduleRecord-&gt;requestedModules().size());</span>
431     RETURN_IF_EXCEPTION(scope, encodedJSValue());
432     size_t i = 0;
433     for (auto&amp; key : moduleRecord-&gt;requestedModules()) {
<span class="line-modified">434         result-&gt;putDirectIndex(globalObject, i++, jsString(vm, key.get()));</span>
435         RETURN_IF_EXCEPTION(scope, encodedJSValue());
436     }
437     return JSValue::encode(result);
438 }
439 
<span class="line-modified">440 EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
441 {
<span class="line-modified">442     VM&amp; vm = globalObject-&gt;vm();</span>
443     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">444     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, callFrame-&gt;argument(0));</span>
445     if (!moduleRecord)
446         return JSValue::encode(jsUndefined());
447 
<span class="line-modified">448     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [link] &quot;, moduleRecord-&gt;moduleKey());</span>

449 
<span class="line-modified">450     moduleRecord-&gt;link(globalObject, callFrame-&gt;argument(1));</span>
451     RETURN_IF_EXCEPTION(scope, encodedJSValue());
452 
453     return JSValue::encode(jsUndefined());
454 }
455 
456 // ------------------------------ Hook Functions ---------------------------
457 
<span class="line-modified">458 EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
459 {
<span class="line-modified">460     VM&amp; vm = globalObject-&gt;vm();</span>
461     // Hook point, Loader.resolve.
462     // https://whatwg.github.io/loader/#browser-resolve
463     // Take the name and resolve it to the unique identifier for the resource location.
464     // For example, take the &quot;jquery&quot; and return the URL for the resource.
<span class="line-modified">465     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
466     if (!loader)
467         return JSValue::encode(jsUndefined());
<span class="line-modified">468     return JSValue::encode(loader-&gt;resolve(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));</span>
469 }
470 
<span class="line-modified">471 EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
472 {
<span class="line-modified">473     VM&amp; vm = globalObject-&gt;vm();</span>
474     auto scope = DECLARE_THROW_SCOPE(vm);
475 
<span class="line-modified">476     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
477     if (!loader)
478         return JSValue::encode(jsUndefined());
<span class="line-modified">479     auto result = loader-&gt;resolveSync(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2));</span>
480     RETURN_IF_EXCEPTION(scope, encodedJSValue());
481     return JSValue::encode(identifierToJSValue(vm, result));
482 }
483 
<span class="line-modified">484 EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
485 {
<span class="line-modified">486     VM&amp; vm = globalObject-&gt;vm();</span>
487     // Hook point, Loader.fetch
488     // https://whatwg.github.io/loader/#browser-fetch
489     // Take the key and fetch the resource actually.
490     // For example, JavaScriptCore shell can provide the hook fetching the resource
491     // from the local file system.
<span class="line-modified">492     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
493     if (!loader)
494         return JSValue::encode(jsUndefined());
<span class="line-modified">495     return JSValue::encode(loader-&gt;fetch(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));</span>
496 }
497 
<span class="line-modified">498 EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
499 {
<span class="line-modified">500     VM&amp; vm = globalObject-&gt;vm();</span>
501     auto scope = DECLARE_THROW_SCOPE(vm);
502 
<span class="line-modified">503     auto* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
504     if (!loader)
505         return JSValue::encode(jsUndefined());
<span class="line-modified">506     auto* moduleNamespaceObject = loader-&gt;getModuleNamespaceObject(globalObject, callFrame-&gt;argument(0));</span>
507     RETURN_IF_EXCEPTION(scope, encodedJSValue());
508     return JSValue::encode(moduleNamespaceObject);
509 }
510 
511 // ------------------- Additional Hook Functions ---------------------------
512 
<span class="line-modified">513 EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
514 {
515     // To instrument and retrieve the errors raised from the module execution,
516     // we inserted the hook point here.
517 
<span class="line-modified">518     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">519     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
520     if (!loader)
521         return JSValue::encode(jsUndefined());
<span class="line-modified">522     return JSValue::encode(loader-&gt;evaluate(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));</span>
523 }
524 
525 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSModuleEnvironment.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
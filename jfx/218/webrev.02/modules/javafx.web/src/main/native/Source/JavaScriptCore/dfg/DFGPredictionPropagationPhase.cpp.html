<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGPredictionPropagationPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;DFGGraph.h&quot;
  32 #include &quot;DFGPhase.h&quot;
  33 #include &quot;JSCInlines.h&quot;
  34 
  35 namespace JSC { namespace DFG {
  36 
  37 namespace {
  38 
  39 bool verboseFixPointLoops = false;
  40 
  41 class PredictionPropagationPhase : public Phase {
  42 public:
  43     PredictionPropagationPhase(Graph&amp; graph)
  44         : Phase(graph, &quot;prediction propagation&quot;)
  45     {
  46     }
  47 
  48     bool run()
  49     {
  50         ASSERT(m_graph.m_form == ThreadedCPS);
  51         ASSERT(m_graph.m_unificationState == GloballyUnified);
  52 
  53         m_pass = PrimaryPass;
  54 
  55         propagateThroughArgumentPositions();
  56 
  57         processInvariants();
  58 
  59         propagateToFixpoint();
  60 
  61         m_pass = RareCasePass;
  62         propagateToFixpoint();
  63 
  64         m_pass = DoubleVotingPass;
  65         unsigned counter = 0;
  66         do {
  67             if (verboseFixPointLoops)
  68                 ++counter;
  69 
  70             m_changed = false;
  71             doRoundOfDoubleVoting();
  72             if (!m_changed)
  73                 break;
  74             m_changed = false;
  75             propagateForward();
  76         } while (m_changed);
  77 
  78         if (verboseFixPointLoops)
  79             dataLog(&quot;Iterated &quot;, counter, &quot; times in double voting fixpoint.\n&quot;);
  80 
  81         return true;
  82     }
  83 
  84 private:
  85     void propagateToFixpoint()
  86     {
  87         unsigned counter = 0;
  88         do {
  89             if (verboseFixPointLoops)
  90                 ++counter;
  91 
  92             m_changed = false;
  93 
  94             // Forward propagation is near-optimal for both topologically-sorted and
  95             // DFS-sorted code.
  96             propagateForward();
  97             if (!m_changed)
  98                 break;
  99 
 100             // Backward propagation reduces the likelihood that pathological code will
 101             // cause slowness. Loops (especially nested ones) resemble backward flow.
 102             // This pass captures two cases: (1) it detects if the forward fixpoint
 103             // found a sound solution and (2) short-circuits backward flow.
 104             m_changed = false;
 105             propagateBackward();
 106         } while (m_changed);
 107 
 108         if (verboseFixPointLoops)
 109             dataLog(&quot;Iterated &quot;, counter, &quot; times in propagateToFixpoint.\n&quot;);
 110     }
 111 
 112     bool setPrediction(SpeculatedType prediction)
 113     {
 114         ASSERT(m_currentNode-&gt;hasResult());
 115 
 116         // setPrediction() is used when we know that there is no way that we can change
 117         // our minds about what the prediction is going to be. There is no semantic
 118         // difference between setPrediction() and mergeSpeculation() other than the
 119         // increased checking to validate this property.
 120         ASSERT(m_currentNode-&gt;prediction() == SpecNone || m_currentNode-&gt;prediction() == prediction);
 121 
 122         return m_currentNode-&gt;predict(prediction);
 123     }
 124 
 125     bool mergePrediction(SpeculatedType prediction)
 126     {
 127         ASSERT(m_currentNode-&gt;hasResult());
 128 
 129         return m_currentNode-&gt;predict(prediction);
 130     }
 131 
 132     SpeculatedType speculatedDoubleTypeForPrediction(SpeculatedType value)
 133     {
 134         SpeculatedType result = SpecDoubleReal;
 135         if (value &amp; SpecDoubleImpureNaN)
 136             result |= SpecDoubleImpureNaN;
 137         if (value &amp; SpecDoublePureNaN)
 138             result |= SpecDoublePureNaN;
 139         if (!isFullNumberOrBooleanSpeculation(value))
 140             result |= SpecDoublePureNaN;
 141         return result;
 142     }
 143 
 144     SpeculatedType speculatedDoubleTypeForPredictions(SpeculatedType left, SpeculatedType right)
 145     {
 146         return speculatedDoubleTypeForPrediction(mergeSpeculations(left, right));
 147     }
 148 
 149     void propagate(Node* node)
 150     {
 151         NodeType op = node-&gt;op();
 152 
 153         bool changed = false;
 154 
 155         switch (op) {
 156         case GetLocal: {
 157             VariableAccessData* variable = node-&gt;variableAccessData();
 158             SpeculatedType prediction = variable-&gt;prediction();
 159             if (!variable-&gt;couldRepresentInt52() &amp;&amp; (prediction &amp; SpecNonInt32AsInt52))
 160                 prediction = (prediction | SpecAnyIntAsDouble) &amp; ~SpecNonInt32AsInt52;
 161             if (prediction)
 162                 changed |= mergePrediction(prediction);
 163             break;
 164         }
 165 
 166         case SetLocal: {
 167             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 168             changed |= variableAccessData-&gt;predict(node-&gt;child1()-&gt;prediction());
 169             break;
 170         }
 171 
 172         case UInt32ToNumber: {
 173             if (node-&gt;canSpeculateInt32(m_pass))
 174                 changed |= mergePrediction(SpecInt32Only);
 175             else if (enableInt52())
 176                 changed |= mergePrediction(SpecInt52Any);
 177             else
 178                 changed |= mergePrediction(SpecBytecodeNumber);
 179             break;
 180         }
 181 
 182         case ValueBitRShift:
 183         case ValueBitLShift: {
 184             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 185             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 186 
 187             if (left &amp;&amp; right) {
 188                 if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 189                     changed |= mergePrediction(SpecBigInt);
 190                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left) &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))
 191                     changed |= mergePrediction(SpecInt32Only);
 192                 else
 193                     changed |= mergePrediction(node-&gt;getHeapPrediction());
 194             }
 195 
 196             break;
 197         }
 198 
 199         case ValueAdd: {
 200             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 201             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 202 
 203             if (left &amp;&amp; right) {
 204                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 205                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 206                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 207                         changed |= mergePrediction(SpecInt32Only);
 208                     else if (m_graph.addShouldSpeculateInt52(node))
 209                         changed |= mergePrediction(SpecInt52Any);
 210                     else
 211                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 212                 } else if (isStringOrStringObjectSpeculation(left) || isStringOrStringObjectSpeculation(right)) {
 213                     // left or right is definitely something other than a number.
 214                     changed |= mergePrediction(SpecString);
 215                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 216                     changed |= mergePrediction(SpecBigInt);
 217                 else {
 218                     changed |= mergePrediction(SpecInt32Only);
 219                     if (node-&gt;mayHaveDoubleResult())
 220                         changed |= mergePrediction(SpecBytecodeDouble);
 221                     if (node-&gt;mayHaveBigIntResult())
 222                         changed |= mergePrediction(SpecBigInt);
 223                     if (node-&gt;mayHaveNonNumericResult())
 224                         changed |= mergePrediction(SpecString);
 225                 }
 226             }
 227             break;
 228         }
 229 
 230         case ArithAdd: {
 231             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 232             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 233 
 234             if (left &amp;&amp; right) {
 235                 if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 236                     changed |= mergePrediction(SpecInt32Only);
 237                 else if (m_graph.addShouldSpeculateInt52(node))
 238                     changed |= mergePrediction(SpecInt52Any);
 239                 else if (isFullNumberOrBooleanSpeculation(left) &amp;&amp; isFullNumberOrBooleanSpeculation(right))
 240                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 241                 else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 242                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 243                 else
 244                     changed |= mergePrediction(SpecInt32Only);
 245             }
 246             break;
 247         }
 248 
 249         case ArithSub: {
 250             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 251             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 252 
 253             if (left &amp;&amp; right) {
 254                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 255                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 256                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 257                         changed |= mergePrediction(SpecInt32Only);
 258                     else if (m_graph.addShouldSpeculateInt52(node))
 259                         changed |= mergePrediction(SpecInt52Any);
 260                     else
 261                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 262                 } else if (node-&gt;mayHaveNonIntResult() || (left &amp; SpecBytecodeDouble) || (right &amp; SpecBytecodeDouble))
 263                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 264                 else
 265                     changed |= mergePrediction(SpecInt32Only);
 266             }
 267             break;
 268         }
 269 
 270         case ValueSub: {
 271             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 272             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 273 
 274             if (left &amp;&amp; right) {
 275                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 276                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 277                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 278                         changed |= mergePrediction(SpecInt32Only);
 279                     else if (m_graph.addShouldSpeculateInt52(node))
 280                         changed |= mergePrediction(SpecInt52Any);
 281                     else
 282                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 283                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 284                     changed |= mergePrediction(SpecBigInt);
 285                 else {
 286                     changed |= mergePrediction(SpecInt32Only);
 287                     if (node-&gt;mayHaveDoubleResult())
 288                         changed |= mergePrediction(SpecBytecodeDouble);
 289                     if (node-&gt;mayHaveBigIntResult())
 290                         changed |= mergePrediction(SpecBigInt);
 291                 }
 292             }
 293 
 294             break;
 295         }
 296 
 297         case Inc:
 298         case Dec: {
 299             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 300 
 301             if (prediction) {
 302                 if (isFullNumberOrBooleanSpeculationExpectingDefined(prediction)) {
 303                     if (m_graph.unaryArithShouldSpeculateInt32(node, m_pass))
 304                         changed |= mergePrediction(SpecInt32Only);
 305                     else if (m_graph.unaryArithShouldSpeculateInt52(node, m_pass))
 306                         changed |= mergePrediction(SpecInt52Any);
 307                     else
 308                         changed |= mergePrediction(speculatedDoubleTypeForPrediction(prediction));
 309                 } else if (isBigIntSpeculation(prediction))
 310                     changed |= mergePrediction(SpecBigInt);
 311                 else {
 312                     changed |= mergePrediction(SpecInt32Only);
 313                     if (node-&gt;mayHaveDoubleResult())
 314                         changed |= mergePrediction(SpecBytecodeDouble);
 315                     if (node-&gt;mayHaveBigIntResult())
 316                         changed |= mergePrediction(SpecBigInt);
 317                 }
 318             }
 319             break;
 320         }
 321 
 322         case ValuePow: {
 323             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 324             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 325 
 326             if (left &amp;&amp; right) {
 327                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateBigInt())
 328                     changed |= mergePrediction(SpecBigInt);
 329                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 330                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))
 331                     changed |= mergePrediction(SpecBytecodeDouble);
 332                 else
 333                     changed |= mergePrediction(SpecBytecodeDouble | SpecBigInt);
 334             }
 335             break;
 336         }
 337 
 338         case ValueNegate:
 339         case ArithNegate: {
 340             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 341             if (prediction) {
 342                 if (isInt32OrBooleanSpeculation(prediction) &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 343                     changed |= mergePrediction(SpecInt32Only);
 344                 else if (m_graph.unaryArithShouldSpeculateInt52(node, m_pass))
 345                     changed |= mergePrediction(SpecInt52Any);
 346                 else if (isBytecodeNumberSpeculation(prediction))
 347                     changed |= mergePrediction(speculatedDoubleTypeForPrediction(node-&gt;child1()-&gt;prediction()));
 348                 else {
 349                     changed |= mergePrediction(SpecInt32Only);
 350                     if (node-&gt;op() == ValueNegate &amp;&amp; node-&gt;mayHaveBigIntResult())
 351                         changed |= mergePrediction(SpecBigInt);
 352                     if (node-&gt;mayHaveDoubleResult())
 353                         changed |= mergePrediction(SpecBytecodeDouble);
 354                 }
 355             }
 356             break;
 357         }
 358         case ArithMin:
 359         case ArithMax: {
 360             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 361             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 362 
 363             if (left &amp;&amp; right) {
 364                 if (Node::shouldSpeculateInt32OrBooleanForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())
 365                     &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 366                     changed |= mergePrediction(SpecInt32Only);
 367                 else
 368                     changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 369             }
 370             break;
 371         }
 372 
 373         case ValueMul:
 374         case ArithMul: {
 375             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 376             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 377 
 378             if (left &amp;&amp; right) {
 379                 // FIXME: We&#39;re currently relying on prediction propagation and backwards propagation
 380                 // whenever we can, and only falling back on result flags if that fails. And the result
 381                 // flags logic doesn&#39;t know how to use backwards propagation. We should get rid of the
 382                 // prediction propagation logic and rely solely on the result type.
 383                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 384                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 385                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 386                         changed |= mergePrediction(SpecInt32Only);
 387                     else if (m_graph.binaryArithShouldSpeculateInt52(node, m_pass))
 388                         changed |= mergePrediction(SpecInt52Any);
 389                     else
 390                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 391                 } else if (op == ValueMul &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 392                     changed |= mergePrediction(SpecBigInt);
 393                 else {
 394                     changed |= mergePrediction(SpecInt32Only);
 395                     if (node-&gt;mayHaveDoubleResult()
 396                         || (left &amp; SpecBytecodeDouble)
 397                         || (right &amp; SpecBytecodeDouble))
 398                         changed |= mergePrediction(SpecBytecodeDouble);
 399                     if ((op == ValueMul &amp;&amp; node-&gt;mayHaveBigIntResult())
 400                         || (left &amp; SpecBigInt)
 401                         || (right &amp; SpecBigInt))
 402                         changed |= mergePrediction(SpecBigInt);
 403                 }
 404             }
 405             break;
 406         }
 407 
 408         case ValueDiv:
 409         case ValueMod:
 410         case ArithDiv:
 411         case ArithMod: {
 412             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 413             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 414 
 415             if (left &amp;&amp; right) {
 416                 if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 417                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right)) {
 418                     if (m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 419                         changed |= mergePrediction(SpecInt32Only);
 420                     else
 421                         changed |= mergePrediction(SpecBytecodeDouble);
 422                 } else if ((op == ValueDiv || op == ValueMod) &amp;&amp; isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 423                     changed |= mergePrediction(SpecBigInt);
 424                 else {
 425                     changed |= mergePrediction(SpecInt32Only | SpecBytecodeDouble);
 426                     if ((op == ValueDiv || op == ValueMod) &amp;&amp; (node-&gt;mayHaveBigIntResult()
 427                         || (left &amp; SpecBigInt)
 428                         || (right &amp; SpecBigInt)))
 429                         changed |= mergePrediction(SpecBigInt);
 430                 }
 431             }
 432             break;
 433         }
 434 
 435         case ArithAbs: {
 436             SpeculatedType childPrediction = node-&gt;child1()-&gt;prediction();
 437             if (isInt32OrBooleanSpeculation(childPrediction)
 438                 &amp;&amp; node-&gt;canSpeculateInt32(m_pass))
 439                 changed |= mergePrediction(SpecInt32Only);
 440             else
 441                 changed |= mergePrediction(SpecBytecodeDouble);
 442             break;
 443         }
 444 
 445         case GetByVal:
 446         case AtomicsAdd:
 447         case AtomicsAnd:
 448         case AtomicsCompareExchange:
 449         case AtomicsExchange:
 450         case AtomicsLoad:
 451         case AtomicsOr:
 452         case AtomicsStore:
 453         case AtomicsSub:
 454         case AtomicsXor: {
 455             Edge child1 = m_graph.child(node, 0);
 456             if (!child1-&gt;prediction())
 457                 break;
 458 
 459             Edge child2 = m_graph.child(node, 1);
 460             ArrayMode arrayMode = node-&gt;arrayMode().refine(
 461                 m_graph, node,
 462                 child1-&gt;prediction(),
 463                 child2-&gt;prediction(),
 464                 SpecNone);
 465 
 466             switch (arrayMode.type()) {
 467             case Array::Int32:
 468                 if (arrayMode.isOutOfBounds())
 469                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecInt32Only);
 470                 else
 471                     changed |= mergePrediction(SpecInt32Only);
 472                 break;
 473             case Array::Double:
 474                 if (arrayMode.isOutOfBounds())
 475                     changed |= mergePrediction(node-&gt;getHeapPrediction() | SpecDoubleReal);
 476                 else if (node-&gt;getHeapPrediction() &amp; SpecNonIntAsDouble)
 477                     changed |= mergePrediction(SpecDoubleReal);
 478                 else
 479                     changed |= mergePrediction(SpecAnyIntAsDouble);
 480                 break;
 481             case Array::Float32Array:
 482             case Array::Float64Array:
 483                 changed |= mergePrediction(SpecFullDouble);
 484                 break;
 485             case Array::Uint32Array:
 486                 if (isInt32SpeculationForArithmetic(node-&gt;getHeapPrediction()) &amp;&amp; node-&gt;op() == GetByVal)
 487                     changed |= mergePrediction(SpecInt32Only);
 488                 else if (enableInt52())
 489                     changed |= mergePrediction(SpecInt52Any);
 490                 else
 491                     changed |= mergePrediction(SpecInt32Only | SpecAnyIntAsDouble);
 492                 break;
 493             case Array::Int8Array:
 494             case Array::Uint8Array:
 495             case Array::Int16Array:
 496             case Array::Uint16Array:
 497             case Array::Int32Array:
 498                 changed |= mergePrediction(SpecInt32Only);
 499                 break;
 500             default:
 501                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 502                 break;
 503             }
 504             break;
 505         }
 506 
 507         case ToThis: {
 508             // ToThis in methods for primitive types should speculate primitive types in strict mode.
 509             bool isStrictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
 510             if (isStrictMode) {
 511                 if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
 512                     changed |= mergePrediction(SpecBoolean);
 513                     break;
 514                 }
 515 
 516                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 517                     changed |= mergePrediction(SpecInt32Only);
 518                     break;
 519                 }
 520 
 521                 if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
 522                     changed |= mergePrediction(SpecInt52Any);
 523                     break;
 524                 }
 525 
 526                 if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
 527                     changed |= mergePrediction(SpecBytecodeNumber);
 528                     break;
 529                 }
 530 
 531                 if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
 532                     changed |= mergePrediction(SpecSymbol);
 533                     break;
 534                 }
 535 
 536                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
 537                     changed |= mergePrediction(SpecBigInt);
 538                     break;
 539                 }
 540 
 541                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
 542                     changed |= mergePrediction(SpecStringIdent);
 543                     break;
 544                 }
 545 
 546                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 547                     changed |= mergePrediction(SpecString);
 548                     break;
 549                 }
 550             } else {
 551                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {
 552                     changed |= mergePrediction(SpecStringObject);
 553                     break;
 554                 }
 555             }
 556 
 557             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 558             if (isStrictMode)
 559                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 560             else if (prediction) {
 561                 if (prediction &amp; ~SpecObject) {
 562                     // Wrapper objects are created only in sloppy mode.
 563                     prediction &amp;= SpecObject;
 564                     prediction = mergeSpeculations(prediction, SpecObjectOther);
 565                 }
 566                 changed |= mergePrediction(prediction);
 567             }
 568             break;
 569         }
 570 
 571         case ToPrimitive: {
 572             SpeculatedType child = node-&gt;child1()-&gt;prediction();
 573             if (child)
 574                 changed |= mergePrediction(resultOfToPrimitive(child));
 575             break;
 576         }
 577 
 578         case ToPropertyKey: {
 579             SpeculatedType child = node-&gt;child1()-&gt;prediction();
 580             if (child)
 581                 changed |= mergePrediction(resultOfToPropertyKey(child));
 582             break;
 583         }
 584 
 585         case NormalizeMapKey: {
 586             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 587             if (prediction)
 588                 changed |= mergePrediction(prediction);
 589             break;
 590         }
 591 
 592         default:
 593             break;
 594         }
 595 
 596         m_changed |= changed;
 597     }
 598 
 599     void propagateForward()
 600     {
 601         for (Node* node : m_dependentNodes) {
 602             m_currentNode = node;
 603             propagate(m_currentNode);
 604         }
 605     }
 606 
 607     void propagateBackward()
 608     {
 609         for (unsigned i = m_dependentNodes.size(); i--;) {
 610             m_currentNode = m_dependentNodes[i];
 611             propagate(m_currentNode);
 612         }
 613     }
 614 
 615     void doDoubleVoting(Node* node, float weight)
 616     {
 617         // Loop pre-headers created by OSR entrypoint creation may have NaN weight to indicate
 618         // that we actually don&#39;t know they weight. Assume that they execute once. This turns
 619         // out to be an OK assumption since the pre-header doesn&#39;t have any meaningful code.
 620         if (weight != weight)
 621             weight = 1;
 622 
 623         switch (node-&gt;op()) {
 624         case ValueAdd:
 625         case ValueSub:
 626         case ArithAdd:
 627         case ArithSub: {
 628             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 629             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 630 
 631             DoubleBallot ballot;
 632 
 633             if (isFullNumberSpeculation(left)
 634                 &amp;&amp; isFullNumberSpeculation(right)
 635                 &amp;&amp; !m_graph.addShouldSpeculateInt32(node, m_pass)
 636                 &amp;&amp; !m_graph.addShouldSpeculateInt52(node))
 637                 ballot = VoteDouble;
 638             else
 639                 ballot = VoteValue;
 640 
 641             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 642             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 643             break;
 644         }
 645 
 646         case ValueMul:
 647         case ArithMul: {
 648             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 649             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 650 
 651             DoubleBallot ballot;
 652 
 653             if (isFullNumberSpeculation(left)
 654                 &amp;&amp; isFullNumberSpeculation(right)
 655                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass)
 656                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt52(node, m_pass))
 657                 ballot = VoteDouble;
 658             else
 659                 ballot = VoteValue;
 660 
 661             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 662             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 663             break;
 664         }
 665 
 666         case ArithMin:
 667         case ArithMax:
 668         case ArithMod:
 669         case ValueDiv:
 670         case ValueMod:
 671         case ArithDiv: {
 672             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 673             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 674 
 675             DoubleBallot ballot;
 676 
 677             if (isFullNumberSpeculation(left)
 678                 &amp;&amp; isFullNumberSpeculation(right)
 679                 &amp;&amp; !m_graph.binaryArithShouldSpeculateInt32(node, m_pass))
 680                 ballot = VoteDouble;
 681             else
 682                 ballot = VoteValue;
 683 
 684             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 685             m_graph.voteNode(node-&gt;child2(), ballot, weight);
 686             break;
 687         }
 688 
 689         case ArithAbs:
 690             DoubleBallot ballot;
 691             if (node-&gt;child1()-&gt;shouldSpeculateNumber()
 692                 &amp;&amp; !m_graph.unaryArithShouldSpeculateInt32(node, m_pass))
 693                 ballot = VoteDouble;
 694             else
 695                 ballot = VoteValue;
 696 
 697             m_graph.voteNode(node-&gt;child1(), ballot, weight);
 698             break;
 699 
 700         case ArithSqrt:
 701         case ArithUnary:
 702             if (node-&gt;child1()-&gt;shouldSpeculateNumber())
 703                 m_graph.voteNode(node-&gt;child1(), VoteDouble, weight);
 704             else
 705                 m_graph.voteNode(node-&gt;child1(), VoteValue, weight);
 706             break;
 707 
 708         case SetLocal: {
 709             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 710             if (isDoubleSpeculation(prediction))
 711                 node-&gt;variableAccessData()-&gt;vote(VoteDouble, weight);
 712             else if (!isFullNumberSpeculation(prediction) || isInt32OrInt52Speculation(prediction))
 713                 node-&gt;variableAccessData()-&gt;vote(VoteValue, weight);
 714             break;
 715         }
 716 
 717         case PutByValDirect:
 718         case PutByVal:
 719         case PutByValAlias: {
 720             Edge child1 = m_graph.varArgChild(node, 0);
 721             Edge child2 = m_graph.varArgChild(node, 1);
 722             Edge child3 = m_graph.varArgChild(node, 2);
 723             m_graph.voteNode(child1, VoteValue, weight);
 724             m_graph.voteNode(child2, VoteValue, weight);
 725             switch (node-&gt;arrayMode().type()) {
 726             case Array::Double:
 727                 m_graph.voteNode(child3, VoteDouble, weight);
 728                 break;
 729             default:
 730                 m_graph.voteNode(child3, VoteValue, weight);
 731                 break;
 732             }
 733             break;
 734         }
 735 
 736         case DataViewSet: {
 737             DataViewData data = node-&gt;dataViewData();
 738             if (data.isFloatingPoint)
 739                 m_graph.voteNode(m_graph.varArgChild(node, 2), VoteValue, weight);
 740             break;
 741         }
 742 
 743         case MovHint:
 744             // Ignore these since they have no effect on in-DFG execution.
 745             break;
 746 
 747         default:
 748             m_graph.voteChildren(node, VoteValue, weight);
 749             break;
 750         }
 751     }
 752 
 753     void doRoundOfDoubleVoting()
 754     {
 755         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i)
 756             m_graph.m_variableAccessData[i].find()-&gt;clearVotes();
 757         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 758             BasicBlock* block = m_graph.block(blockIndex);
 759             if (!block)
 760                 continue;
 761             ASSERT(block-&gt;isReachable);
 762             for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
 763                 m_currentNode = block-&gt;at(i);
 764                 doDoubleVoting(m_currentNode, block-&gt;executionCount);
 765             }
 766         }
 767         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i) {
 768             VariableAccessData* variableAccessData = &amp;m_graph.m_variableAccessData[i];
 769             if (!variableAccessData-&gt;isRoot())
 770                 continue;
 771             m_changed |= variableAccessData-&gt;tallyVotesForShouldUseDoubleFormat();
 772         }
 773         propagateThroughArgumentPositions();
 774         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i) {
 775             VariableAccessData* variableAccessData = &amp;m_graph.m_variableAccessData[i];
 776             if (!variableAccessData-&gt;isRoot())
 777                 continue;
 778             m_changed |= variableAccessData-&gt;makePredictionForDoubleFormat();
 779         }
 780     }
 781 
 782     void propagateThroughArgumentPositions()
 783     {
 784         for (unsigned i = 0; i &lt; m_graph.m_argumentPositions.size(); ++i)
 785             m_changed |= m_graph.m_argumentPositions[i].mergeArgumentPredictionAwareness();
 786     }
 787 
 788     // Sets any predictions that do not depends on other nodes.
 789     void processInvariants()
 790     {
 791         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 792             for (Node* node : *block) {
 793                 m_currentNode = node;
 794                 processInvariantsForNode();
 795             }
 796         }
 797     }
 798 
 799     void processInvariantsForNode()
 800     {
 801         switch (m_currentNode-&gt;op()) {
 802         case JSConstant: {
 803             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 804             if (type == SpecAnyIntAsDouble &amp;&amp; enableInt52())
 805                 type = int52AwareSpeculationFromValue(m_currentNode-&gt;asJSValue());
 806             setPrediction(type);
 807             break;
 808         }
 809         case DoubleConstant: {
 810             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 811             setPrediction(type);
 812             break;
 813         }
 814 
 815         case ArithBitNot:
 816         case ArithBitAnd:
 817         case ArithBitOr:
 818         case ArithBitXor:
 819         case ArithBitRShift:
 820         case ArithBitLShift:
 821         case BitURShift:
 822         case ArithIMul:
 823         case ArithClz32: {
 824             setPrediction(SpecInt32Only);
 825             break;
 826         }
 827 
 828         case ArrayPop:
 829         case ArrayPush:
 830         case RegExpExec:
 831         case RegExpExecNonGlobalOrSticky:
 832         case RegExpTest:
 833         case RegExpMatchFast:
 834         case RegExpMatchFastGlobal:
 835         case StringReplace:
 836         case StringReplaceRegExp:
 837         case GetById:
 838         case GetByIdFlush:
 839         case GetByIdWithThis:
 840         case GetByIdDirect:
 841         case GetByIdDirectFlush:
 842         case TryGetById:
 843         case GetByValWithThis:
 844         case GetByOffset:
 845         case MultiGetByOffset:
 846         case GetDirectPname:
 847         case Call:
 848         case DirectCall:
 849         case TailCallInlinedCaller:
 850         case DirectTailCallInlinedCaller:
 851         case Construct:
 852         case DirectConstruct:
 853         case CallVarargs:
 854         case CallEval:
 855         case TailCallVarargsInlinedCaller:
 856         case ConstructVarargs:
 857         case CallForwardVarargs:
 858         case ConstructForwardVarargs:
 859         case TailCallForwardVarargsInlinedCaller:
 860         case GetGlobalVar:
 861         case GetGlobalLexicalVariable:
 862         case GetClosureVar:
 863         case GetInternalField:
 864         case GetFromArguments:
 865         case LoadKeyFromMapBucket:
 866         case LoadValueFromMapBucket:
 867         case ToNumber:
 868         case ToNumeric:
 869         case ToObject:
 870         case ValueBitAnd:
 871         case ValueBitXor:
 872         case ValueBitOr:
 873         case ValueBitNot:
 874         case CallObjectConstructor:
 875         case GetArgument:
 876         case CallDOMGetter:
 877         case GetDynamicVar:
 878         case GetPrototypeOf:
 879         case ExtractValueFromWeakMapGet:
 880         case DataViewGetInt:
 881         case DataViewGetFloat:
 882         case DateGetInt32OrNaN: {
 883             setPrediction(m_currentNode-&gt;getHeapPrediction());
 884             break;
 885         }
 886 
 887         case DateGetTime: {
 888             setPrediction(SpecFullNumber);
 889             break;
 890         }
 891 
 892         case WeakMapGet:
 893         case ResolveScopeForHoistingFuncDeclInEval: {
 894             setPrediction(SpecBytecodeTop);
 895             break;
 896         }
 897 
 898         case GetGetterSetterByOffset:
 899         case GetExecutable: {
 900             setPrediction(SpecCellOther);
 901             break;
 902         }
 903 
 904         case GetGetter:
 905         case GetSetter:
 906         case GetCallee:
 907         case NewFunction:
 908         case NewGeneratorFunction:
 909         case NewAsyncGeneratorFunction:
 910         case NewAsyncFunction: {
 911             setPrediction(SpecFunction);
 912             break;
 913         }
 914 
 915         case GetArgumentCountIncludingThis: {
 916             setPrediction(SpecInt32Only);
 917             break;
 918         }
 919 
 920         case SetCallee:
 921         case SetArgumentCountIncludingThis:
 922             break;
 923 
 924         case MapHash:
 925             setPrediction(SpecInt32Only);
 926             break;
 927 
 928         case GetMapBucket:
 929         case GetMapBucketHead:
 930         case GetMapBucketNext:
 931         case SetAdd:
 932         case MapSet:
 933             setPrediction(SpecCellOther);
 934             break;
 935 
 936         case GetRestLength:
 937         case ArrayIndexOf: {
 938             setPrediction(SpecInt32Only);
 939             break;
 940         }
 941 
 942         case GetTypedArrayByteOffset:
 943         case GetArrayLength:
 944         case GetVectorLength: {
 945             setPrediction(SpecInt32Only);
 946             break;
 947         }
 948 
 949         case StringCharCodeAt:
 950         case StringCodePointAt: {
 951             setPrediction(SpecInt32Only);
 952             break;
 953         }
 954 
 955         case StringValueOf:
 956         case StringSlice:
 957         case ToLowerCase:
 958             setPrediction(SpecString);
 959             break;
 960 
 961         case ArithPow:
 962         case ArithSqrt:
 963         case ArithFRound:
 964         case ArithUnary: {
 965             setPrediction(SpecBytecodeDouble);
 966             break;
 967         }
 968 
 969         case ArithRound:
 970         case ArithFloor:
 971         case ArithCeil:
 972         case ArithTrunc: {
 973             if (isInt32OrBooleanSpeculation(m_currentNode-&gt;getHeapPrediction())
 974                 &amp;&amp; m_graph.roundShouldSpeculateInt32(m_currentNode, m_pass))
 975                 setPrediction(SpecInt32Only);
 976             else
 977                 setPrediction(SpecBytecodeDouble);
 978             break;
 979         }
 980 
 981         case ArithRandom: {
 982             setPrediction(SpecDoubleReal);
 983             break;
 984         }
 985         case DeleteByVal:
 986         case DeleteById:
 987         case LogicalNot:
 988         case CompareLess:
 989         case CompareLessEq:
 990         case CompareGreater:
 991         case CompareGreaterEq:
 992         case CompareBelow:
 993         case CompareBelowEq:
 994         case CompareEq:
 995         case CompareStrictEq:
 996         case CompareEqPtr:
 997         case SameValue:
 998         case OverridesHasInstance:
 999         case InstanceOf:
1000         case InstanceOfCustom:
1001         case IsEmpty:
1002         case IsUndefined:
1003         case IsUndefinedOrNull:
1004         case IsBoolean:
1005         case IsNumber:
1006         case NumberIsInteger:
1007         case IsObject:
1008         case IsObjectOrNull:
1009         case IsFunction:
1010         case IsCellWithType:
1011         case IsTypedArrayView:
1012         case MatchStructure: {
1013             setPrediction(SpecBoolean);
1014             break;
1015         }
1016 
1017         case TypeOf: {
1018             setPrediction(SpecStringIdent);
1019             break;
1020         }
1021         case GetButterfly:
1022         case GetIndexedPropertyStorage:
1023         case AllocatePropertyStorage:
1024         case ReallocatePropertyStorage: {
1025             setPrediction(SpecOther);
1026             break;
1027         }
1028 
1029         case CheckSubClass:
1030             break;
1031 
1032         case SkipScope:
1033         case GetGlobalObject: {
1034             setPrediction(SpecObjectOther);
1035             break;
1036         }
1037 
1038         case GetGlobalThis:
1039             setPrediction(SpecObject);
1040             break;
1041 
1042         case ResolveScope: {
1043             setPrediction(SpecObjectOther);
1044             break;
1045         }
1046 
1047         case ObjectCreate:
1048         case CreateThis:
1049         case NewObject: {
1050             setPrediction(SpecFinalObject);
1051             break;
1052         }
1053 
1054         case CreatePromise:
1055         case NewPromise:
1056             setPrediction(SpecPromiseObject);
1057             break;
1058 
1059         case CreateGenerator:
1060         case NewGenerator:
1061         case CreateAsyncGenerator:
1062         case NewAsyncGenerator:
1063         case NewArrayIterator:
1064             setPrediction(SpecObjectOther);
1065             break;
1066 
1067         case ArraySlice:
1068         case NewArrayWithSpread:
1069         case NewArray:
1070         case NewArrayWithSize:
1071         case CreateRest:
1072         case NewArrayBuffer:
1073         case ObjectKeys: {
1074             setPrediction(SpecArray);
1075             break;
1076         }
1077 
1078         case Spread:
1079             setPrediction(SpecCellOther);
1080             break;
1081 
1082         case NewTypedArray: {
1083             setPrediction(speculationFromTypedArrayType(m_currentNode-&gt;typedArrayType()));
1084             break;
1085         }
1086 
1087         case NewRegexp: {
1088             setPrediction(SpecRegExpObject);
1089             break;
1090         }
1091 
1092         case PushWithScope:
1093         case CreateActivation: {
1094             setPrediction(SpecObjectOther);
1095             break;
1096         }
1097 
1098         case StringFromCharCode: {
1099             setPrediction(SpecString);
1100             m_currentNode-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsInt);
1101             break;
1102         }
1103         case StringCharAt:
1104         case CallStringConstructor:
1105         case ToString:
1106         case NumberToStringWithRadix:
1107         case NumberToStringWithValidRadixConstant:
1108         case MakeRope:
1109         case StrCat: {
1110             setPrediction(SpecString);
1111             break;
1112         }
1113         case NewStringObject: {
1114             setPrediction(SpecStringObject);
1115             break;
1116         }
1117         case NewSymbol: {
1118             setPrediction(SpecSymbol);
1119             break;
1120         }
1121 
1122         case CreateDirectArguments: {
1123             setPrediction(SpecDirectArguments);
1124             break;
1125         }
1126 
1127         case CreateScopedArguments: {
1128             setPrediction(SpecScopedArguments);
1129             break;
1130         }
1131 
1132         case CreateClonedArguments: {
1133             setPrediction(SpecObjectOther);
1134             break;
1135         }
1136 
1137         case CreateArgumentsButterfly: {
1138             setPrediction(SpecCellOther);
1139             break;
1140         }
1141 
1142         case FiatInt52: {
1143             RELEASE_ASSERT(enableInt52());
1144             setPrediction(SpecInt52Any);
1145             break;
1146         }
1147 
1148         case GetScope:
1149             setPrediction(SpecObjectOther);
1150             break;
1151 
1152         case InByVal:
1153         case InById:
1154             setPrediction(SpecBoolean);
1155             break;
1156 
1157         case HasOwnProperty:
1158             setPrediction(SpecBoolean);
1159             break;
1160 
1161         case GetEnumerableLength: {
1162             setPrediction(SpecInt32Only);
1163             break;
1164         }
1165         case HasGenericProperty:
1166         case HasStructureProperty:
1167         case HasIndexedProperty: {
1168             setPrediction(SpecBoolean);
1169             break;
1170         }
1171         case GetPropertyEnumerator: {
1172             setPrediction(SpecCell);
1173             break;
1174         }
1175         case GetEnumeratorStructurePname: {
1176             setPrediction(SpecCell | SpecOther);
1177             break;
1178         }
1179         case GetEnumeratorGenericPname: {
1180             setPrediction(SpecCell | SpecOther);
1181             break;
1182         }
1183         case ToIndexString: {
1184             setPrediction(SpecString);
1185             break;
1186         }
1187         case ParseInt: {
1188             // We expect this node to almost always produce an int32. However,
1189             // it&#39;s possible it produces NaN or integers out of int32 range. We
1190             // rely on the heap prediction since the parseInt() call profiled
1191             // its result.
1192             setPrediction(m_currentNode-&gt;getHeapPrediction());
1193             break;
1194         }
1195 
1196         case IdentityWithProfile: {
1197             setPrediction(m_currentNode-&gt;getForcedPrediction());
1198             break;
1199         }
1200 
1201         case ExtractCatchLocal: {
1202             setPrediction(m_currentNode-&gt;catchLocalPrediction());
1203             break;
1204         }
1205 
1206         case GetLocal:
1207         case SetLocal:
1208         case UInt32ToNumber:
1209         case ValueNegate:
1210         case ValueAdd:
1211         case ValueSub:
1212         case ValueMul:
1213         case ValueDiv:
1214         case ValueMod:
1215         case ValuePow:
1216         case ValueBitLShift:
1217         case ValueBitRShift:
1218         case Inc:
1219         case Dec:
1220         case ArithAdd:
1221         case ArithSub:
1222         case ArithNegate:
1223         case ArithMin:
1224         case ArithMax:
1225         case ArithMul:
1226         case ArithDiv:
1227         case ArithMod:
1228         case ArithAbs:
1229         case GetByVal:
1230         case ToThis:
1231         case ToPrimitive:
1232         case ToPropertyKey:
1233         case NormalizeMapKey:
1234         case AtomicsAdd:
1235         case AtomicsAnd:
1236         case AtomicsCompareExchange:
1237         case AtomicsExchange:
1238         case AtomicsLoad:
1239         case AtomicsOr:
1240         case AtomicsStore:
1241         case AtomicsSub:
1242         case AtomicsXor: {
1243             m_dependentNodes.append(m_currentNode);
1244             break;
1245         }
1246 
1247         case AtomicsIsLockFree: {
1248             setPrediction(SpecBoolean);
1249             break;
1250         }
1251 
1252         case CPUIntrinsic: {
1253             if (m_currentNode-&gt;intrinsic() == CPURdtscIntrinsic)
1254                 setPrediction(SpecInt32Only);
1255             else
1256                 setPrediction(SpecOther);
1257             break;
1258         }
1259 
1260         case PutByValAlias:
1261         case DoubleAsInt32:
1262         case CheckTypeInfoFlags:
1263         case Arrayify:
1264         case ArrayifyToStructure:
1265         case CheckTierUpInLoop:
1266         case CheckTierUpAtReturn:
1267         case CheckTierUpAndOSREnter:
1268         case CheckInBounds:
1269         case ValueToInt32:
1270         case DoubleRep:
1271         case ValueRep:
1272         case Int52Rep:
1273         case Int52Constant:
1274         case Identity:
1275         case BooleanToNumber:
1276         case PhantomNewObject:
1277         case PhantomNewFunction:
1278         case PhantomNewGeneratorFunction:
1279         case PhantomNewAsyncGeneratorFunction:
1280         case PhantomNewAsyncFunction:
1281         case PhantomCreateActivation:
1282         case PhantomDirectArguments:
1283         case PhantomCreateRest:
1284         case PhantomSpread:
1285         case PhantomNewArrayWithSpread:
1286         case PhantomNewArrayBuffer:
1287         case PhantomNewArrayIterator:
1288         case PhantomClonedArguments:
1289         case PhantomNewRegexp:
1290         case GetMyArgumentByVal:
1291         case GetMyArgumentByValOutOfBounds:
1292         case PutHint:
1293         case CheckStructureImmediate:
1294         case CheckStructureOrEmpty:
1295         case CheckArrayOrEmpty:
1296         case MaterializeNewObject:
1297         case MaterializeCreateActivation:
1298         case MaterializeNewInternalFieldObject:
1299         case PutStack:
1300         case KillStack:
1301         case StoreBarrier:
1302         case FencedStoreBarrier:
1303         case GetStack:
1304         case GetRegExpObjectLastIndex:
1305         case SetRegExpObjectLastIndex:
1306         case RecordRegExpCachedResult:
1307         case LazyJSConstant:
1308         case CallDOM: {
1309             // This node should never be visible at this stage of compilation.
1310             DFG_CRASH(m_graph, m_currentNode, &quot;Unexpected node during prediction propagation&quot;);
1311             break;
1312         }
1313 
1314         case Phi:
1315             // Phis should not be visible here since we&#39;re iterating the all-but-Phi&#39;s
1316             // part of basic blocks.
1317             RELEASE_ASSERT_NOT_REACHED();
1318             break;
1319 
1320         case EntrySwitch:
1321         case Upsilon:
1322             // These don&#39;t get inserted until we go into SSA.
1323             RELEASE_ASSERT_NOT_REACHED();
1324             break;
1325 
1326 #ifndef NDEBUG
1327         // These get ignored because they don&#39;t return anything.
1328         case PutByValDirect:
1329         case PutByValWithThis:
1330         case PutByIdWithThis:
1331         case PutByVal:
1332         case PutClosureVar:
1333         case PutInternalField:
1334         case PutToArguments:
1335         case Return:
1336         case Throw:
1337         case ThrowStaticError:
1338         case TailCall:
1339         case DirectTailCall:
1340         case TailCallVarargs:
1341         case TailCallForwardVarargs:
1342         case PutById:
1343         case PutByIdFlush:
1344         case PutByIdDirect:
1345         case PutByOffset:
1346         case MultiPutByOffset:
1347         case PutGetterById:
1348         case PutSetterById:
1349         case PutGetterSetterById:
1350         case PutGetterByVal:
1351         case PutSetterByVal:
1352         case DefineDataProperty:
1353         case DefineAccessorProperty:
1354         case DFG::Jump:
1355         case Branch:
1356         case Switch:
1357         case ProfileType:
1358         case ProfileControlFlow:
1359         case ForceOSRExit:
1360         case SetArgumentDefinitely:
1361         case SetArgumentMaybe:
1362         case SetFunctionName:
1363         case CheckStructure:
1364         case CheckCell:
1365         case CheckNotEmpty:
1366         case AssertNotEmpty:
1367         case CheckIdent:
1368         case CheckBadCell:
1369         case PutStructure:
1370         case Phantom:
1371         case Check:
1372         case CheckArray:
1373         case CheckNeutered:
1374         case CheckVarargs:
1375         case PutGlobalVariable:
1376         case CheckTraps:
1377         case LogShadowChickenPrologue:
1378         case LogShadowChickenTail:
1379         case Unreachable:
1380         case LoopHint:
1381         case NotifyWrite:
1382         case ConstantStoragePointer:
1383         case MovHint:
1384         case ZombieHint:
1385         case ExitOK:
1386         case VarargsLength:
1387         case LoadVarargs:
1388         case ForwardVarargs:
1389         case PutDynamicVar:
1390         case NukeStructureAndSetButterfly:
1391         case InitializeEntrypointArguments:
1392         case WeakSetAdd:
1393         case WeakMapSet:
1394         case FilterCallLinkStatus:
1395         case FilterGetByStatus:
1396         case FilterPutByIdStatus:
1397         case FilterInByIdStatus:
1398         case ClearCatchLocals:
1399         case DataViewSet:
1400         case InvalidationPoint:
1401             break;
1402 
1403         // This gets ignored because it only pretends to produce a value.
1404         case BottomValue:
1405             break;
1406 
1407         // This gets ignored because it already has a prediction.
1408         case ExtractOSREntryLocal:
1409             break;
1410 
1411         // These gets ignored because it doesn&#39;t do anything.
1412         case CountExecution:
1413         case SuperSamplerBegin:
1414         case SuperSamplerEnd:
1415         case PhantomLocal:
1416         case Flush:
1417             break;
1418 
1419         case LastNodeType:
1420             RELEASE_ASSERT_NOT_REACHED();
1421             break;
1422 #else
1423         default:
1424             break;
1425 #endif
1426         }
1427     }
1428 
1429     SpeculatedType resultOfToPrimitive(SpeculatedType type)
1430     {
1431         if (type &amp; SpecObject) {
1432             // We try to be optimistic here about StringObjects since it&#39;s unlikely that
1433             // someone overrides the valueOf or toString methods.
1434             if (type &amp; SpecStringObject &amp;&amp; m_graph.canOptimizeStringObjectAccess(m_currentNode-&gt;origin.semantic))
1435                 return mergeSpeculations(type &amp; ~SpecObject, SpecString);
1436 
1437             return mergeSpeculations(type &amp; ~SpecObject, SpecPrimitive);
1438         }
1439 
1440         return type;
1441     }
1442 
1443     SpeculatedType resultOfToPropertyKey(SpeculatedType type)
1444     {
1445         // Propagate the prediction of the source directly if already proven to be a property key.
1446         if (type &amp;&amp; !(type &amp; ~(SpecString | SpecSymbol)))
1447             return type;
1448 
1449         if (type &amp; SpecStringObject &amp;&amp; m_graph.canOptimizeStringObjectAccess(m_currentNode-&gt;origin.semantic))
1450             return mergeSpeculations(type &amp; SpecSymbol, SpecString);
1451 
1452         return SpecString | SpecSymbol;
1453     }
1454 
1455     Vector&lt;Node*&gt; m_dependentNodes;
1456     Node* m_currentNode;
1457     bool m_changed { false };
1458     PredictionPass m_pass { PrimaryPass }; // We use different logic for considering predictions depending on how far along we are in propagation.
1459 };
1460 
1461 } // Anonymous namespace.
1462 
1463 bool performPredictionPropagation(Graph&amp; graph)
1464 {
1465     return runPhase&lt;PredictionPropagationPhase&gt;(graph);
1466 }
1467 
1468 } } // namespace JSC::DFG
1469 
1470 #endif // ENABLE(DFG_JIT)
1471 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmCallingConvention.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmCodeBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;AirCode.h&quot;
 31 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
 32 #include &quot;B3ArgumentRegValue.h&quot;
 33 #include &quot;B3BasicBlock.h&quot;
 34 #include &quot;B3Const64Value.h&quot;
 35 #include &quot;B3ConstrainedValue.h&quot;
 36 #include &quot;B3MemoryValue.h&quot;
 37 #include &quot;B3PatchpointValue.h&quot;
 38 #include &quot;B3Procedure.h&quot;
 39 #include &quot;B3StackmapGenerationParams.h&quot;
 40 #include &quot;CallFrame.h&quot;
 41 #include &quot;LinkBuffer.h&quot;

 42 #include &quot;RegisterSet.h&quot;
 43 #include &quot;WasmFormat.h&quot;
 44 #include &quot;WasmSignature.h&quot;
 45 
 46 namespace JSC { namespace Wasm {
 47 
<span class="line-modified"> 48 typedef unsigned (*NextOffset)(unsigned currentOffset);</span>
 49 
<span class="line-modified"> 50 template&lt;unsigned headerSize, NextOffset updateOffset&gt;</span>
<span class="line-modified"> 51 class CallingConvention {</span>
<span class="line-modified"> 52 public:</span>
<span class="line-modified"> 53     CallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprArgs, Vector&lt;Reg&gt;&amp;&amp; fprArgs, RegisterSet&amp;&amp; calleeSaveRegisters)</span>
<span class="line-modified"> 54         : m_gprArgs(WTFMove(gprArgs))</span>
<span class="line-modified"> 55         , m_fprArgs(WTFMove(fprArgs))</span>
<span class="line-modified"> 56         , m_calleeSaveRegisters(WTFMove(calleeSaveRegisters))</span>







 57     {








 58     }
 59 






















 60 private:
<span class="line-modified"> 61     B3::ValueRep marshallArgumentImpl(const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>
 62     {
 63         if (count &lt; regArgs.size())
<span class="line-modified"> 64             return B3::ValueRep::reg(regArgs[count++]);</span>
 65 
 66         count++;
<span class="line-modified"> 67         B3::ValueRep result = B3::ValueRep::stackArgument(stackOffset);</span>
<span class="line-modified"> 68         stackOffset = updateOffset(stackOffset);</span>
 69         return result;
 70     }
 71 
<span class="line-modified"> 72     B3::ValueRep marshallArgument(B3::Type type, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>
 73     {
<span class="line-modified"> 74         switch (type.kind()) {</span>
<span class="line-modified"> 75         case B3::Int32:</span>
<span class="line-modified"> 76         case B3::Int64:</span>
<span class="line-modified"> 77             return marshallArgumentImpl(m_gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified"> 78         case B3::Float:</span>
<span class="line-modified"> 79         case B3::Double:</span>
<span class="line-modified"> 80             return marshallArgumentImpl(m_fprArgs, fpArgumentCount, stackOffset);</span>
<span class="line-modified"> 81         case B3::Void:</span>
<span class="line-modified"> 82         case B3::Tuple:</span>


 83             break;
<span class="line-removed"> 84 </span>
 85         }
 86         RELEASE_ASSERT_NOT_REACHED();
 87     }
 88 
 89 public:
<span class="line-modified"> 90     static unsigned headerSizeInBytes() { return headerSize; }</span>
<span class="line-removed"> 91     void setupFrameInPrologue(CodeLocationDataLabelPtr&lt;WasmEntryPtrTag&gt;* calleeMoveLocation, B3::Procedure&amp; proc, B3::Origin origin, B3::BasicBlock* block) const</span>
<span class="line-removed"> 92     {</span>
<span class="line-removed"> 93         static_assert(CallFrameSlot::callee * sizeof(Register) &lt; headerSize, &quot;We rely on this here for now.&quot;);</span>
<span class="line-removed"> 94         static_assert(CallFrameSlot::codeBlock * sizeof(Register) &lt; headerSize, &quot;We rely on this here for now.&quot;);</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96         B3::PatchpointValue* getCalleePatchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, B3::Int64, origin);</span>
<span class="line-removed"> 97         getCalleePatchpoint-&gt;resultConstraints = { B3::ValueRep::SomeRegister };</span>
<span class="line-removed"> 98         getCalleePatchpoint-&gt;effects = B3::Effects::none();</span>
<span class="line-removed"> 99         getCalleePatchpoint-&gt;setGenerator(</span>
<span class="line-removed">100             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
<span class="line-removed">101                 GPRReg result = params[0].gpr();</span>
<span class="line-removed">102                 MacroAssembler::DataLabelPtr moveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), result);</span>
<span class="line-removed">103                 jit.addLinkTask([calleeMoveLocation, moveLocation] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-removed">104                     *calleeMoveLocation = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(moveLocation);</span>
<span class="line-removed">105                 });</span>
<span class="line-removed">106             });</span>
<span class="line-removed">107 </span>
<span class="line-removed">108         B3::Value* framePointer = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::FramePointer, origin);</span>
<span class="line-removed">109         B3::Value* offsetOfCallee = block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, CallFrameSlot::callee * sizeof(Register));</span>
<span class="line-removed">110         block-&gt;appendNew&lt;B3::MemoryValue&gt;(proc, B3::Store, origin,</span>
<span class="line-removed">111             getCalleePatchpoint,</span>
<span class="line-removed">112             block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Add, origin, framePointer, offsetOfCallee));</span>
<span class="line-removed">113 </span>
<span class="line-removed">114         // FIXME: We shouldn&#39;t have to store zero into the CodeBlock* spot in the call frame,</span>
<span class="line-removed">115         // but there are places that interpret non-null CodeBlock slot to mean a valid CodeBlock.</span>
<span class="line-removed">116         // When doing unwinding, we&#39;ll need to verify that the entire runtime is OK with a non-null</span>
<span class="line-removed">117         // CodeBlock not implying that the CodeBlock is valid.</span>
<span class="line-removed">118         // https://bugs.webkit.org/show_bug.cgi?id=165321</span>
<span class="line-removed">119         B3::Value* offsetOfCodeBlock = block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, CallFrameSlot::codeBlock * sizeof(Register));</span>
<span class="line-removed">120         block-&gt;appendNew&lt;B3::MemoryValue&gt;(proc, B3::Store, origin,</span>
<span class="line-removed">121             block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, 0),</span>
<span class="line-removed">122             block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Add, origin, framePointer, offsetOfCodeBlock));</span>
<span class="line-removed">123     }</span>
<span class="line-removed">124 </span>
<span class="line-removed">125     template&lt;typename Functor&gt;</span>
<span class="line-removed">126     void loadArguments(const Signature&amp; signature, B3::Procedure&amp; proc, B3::BasicBlock* block, B3::Origin origin, const Functor&amp; functor) const</span>
127     {
<span class="line-modified">128         B3::Value* framePointer = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::FramePointer, origin);</span>
<span class="line-modified">129 </span>
130         size_t gpArgumentCount = 0;
131         size_t fpArgumentCount = 0;
<span class="line-modified">132         size_t stackOffset = headerSize;</span>


133 

134         for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {
<span class="line-modified">135             B3::Type type = toB3Type(signature.argument(i));</span>
<span class="line-modified">136             B3::Value* argument;</span>
<span class="line-removed">137             B3::ValueRep rep = marshallArgument(type, gpArgumentCount, fpArgumentCount, stackOffset);</span>
<span class="line-removed">138             if (rep.isReg()) {</span>
<span class="line-removed">139                 argument = block-&gt;appendNew&lt;B3::ArgumentRegValue&gt;(proc, origin, rep.reg());</span>
<span class="line-removed">140                 if (type == B3::Int32 || type == B3::Float)</span>
<span class="line-removed">141                     argument = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Trunc, origin, argument);</span>
<span class="line-removed">142             } else {</span>
<span class="line-removed">143                 ASSERT(rep.isStackArgument());</span>
<span class="line-removed">144                 B3::Value* address = block-&gt;appendNew&lt;B3::Value&gt;(proc, B3::Add, origin, framePointer,</span>
<span class="line-removed">145                     block-&gt;appendNew&lt;B3::Const64Value&gt;(proc, origin, rep.offsetFromSP()));</span>
<span class="line-removed">146                 argument = block-&gt;appendNew&lt;B3::MemoryValue&gt;(proc, B3::Load, type, origin, address);</span>
<span class="line-removed">147             }</span>
<span class="line-removed">148             functor(argument, i);</span>
149         }
<span class="line-modified">150     }</span>
<span class="line-modified">151 </span>
<span class="line-modified">152     // It&#39;s expected that the pachpointFunctor sets the generator for the call operation.</span>
<span class="line-modified">153     template&lt;typename Functor&gt;</span>
<span class="line-modified">154     B3::Value* setupCall(B3::Procedure&amp; proc, B3::BasicBlock* block, B3::Origin origin, const Vector&lt;B3::Value*&gt;&amp; arguments, B3::Type returnType, const Functor&amp; patchpointFunctor) const</span>
<span class="line-modified">155     {</span>
<span class="line-modified">156         size_t gpArgumentCount = 0;</span>
<span class="line-modified">157         size_t fpArgumentCount = 0;</span>
<span class="line-modified">158         size_t stackOffset = headerSize - sizeof(CallerFrameAndPC);</span>
<span class="line-modified">159 </span>
<span class="line-removed">160         Vector&lt;B3::ConstrainedValue&gt; constrainedArguments;</span>
<span class="line-removed">161         for (B3::Value* argument : arguments) {</span>
<span class="line-removed">162             B3::ValueRep rep = marshallArgument(argument-&gt;type(), gpArgumentCount, fpArgumentCount, stackOffset);</span>
<span class="line-removed">163             constrainedArguments.append(B3::ConstrainedValue(argument, rep));</span>
164         }
165 
<span class="line-modified">166         proc.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), stackOffset));</span>
<span class="line-modified">167 </span>
<span class="line-modified">168         B3::PatchpointValue* patchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(proc, returnType, origin);</span>
<span class="line-modified">169         patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());</span>
<span class="line-removed">170         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());</span>
<span class="line-removed">171         patchpointFunctor(patchpoint);</span>
<span class="line-removed">172         patchpoint-&gt;appendVector(constrainedArguments);</span>
<span class="line-removed">173 </span>
<span class="line-removed">174         switch (returnType.kind()) {</span>
<span class="line-removed">175         case B3::Void:</span>
<span class="line-removed">176             return nullptr;</span>
<span class="line-removed">177         case B3::Float:</span>
<span class="line-removed">178         case B3::Double:</span>
<span class="line-removed">179             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(FPRInfo::returnValueFPR) };</span>
<span class="line-removed">180             break;</span>
<span class="line-removed">181         case B3::Int32:</span>
<span class="line-removed">182         case B3::Int64:</span>
<span class="line-removed">183             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(GPRInfo::returnValueGPR) };</span>
<span class="line-removed">184             break;</span>
<span class="line-removed">185         case B3::Tuple:</span>
<span class="line-removed">186             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">187             break;</span>
<span class="line-removed">188         }</span>
<span class="line-removed">189         return patchpoint;</span>
190     }
191 
<span class="line-modified">192     const Vector&lt;Reg&gt; m_gprArgs;</span>
<span class="line-modified">193     const Vector&lt;Reg&gt; m_fprArgs;</span>
<span class="line-modified">194     const RegisterSet m_calleeSaveRegisters;</span>
<span class="line-modified">195     const RegisterSet m_callerSaveRegisters;</span>

196 };
197 
<span class="line-modified">198 // FIXME: Share more code with CallingConvention above:</span>
<span class="line-removed">199 // https://bugs.webkit.org/show_bug.cgi?id=194065</span>
<span class="line-removed">200 template&lt;unsigned headerSize, NextOffset updateOffset&gt;</span>
<span class="line-removed">201 class CallingConventionAir {</span>
202 public:
<span class="line-modified">203     CallingConventionAir(Vector&lt;Reg&gt;&amp;&amp; gprArgs, Vector&lt;Reg&gt;&amp;&amp; fprArgs, RegisterSet&amp;&amp; calleeSaveRegisters)</span>
<span class="line-modified">204         : m_gprArgs(WTFMove(gprArgs))</span>
<span class="line-modified">205         , m_fprArgs(WTFMove(fprArgs))</span>
<span class="line-modified">206         , m_calleeSaveRegisters(WTFMove(calleeSaveRegisters))</span>
<span class="line-modified">207     {</span>
<span class="line-modified">208         RegisterSet scratch = RegisterSet::allGPRs();</span>
<span class="line-removed">209         scratch.exclude(RegisterSet::macroScratchRegisters());</span>
<span class="line-removed">210         scratch.exclude(RegisterSet::reservedHardwareRegisters());</span>
<span class="line-removed">211         scratch.exclude(RegisterSet::stackRegisters());</span>
<span class="line-removed">212         for (Reg reg : m_gprArgs)</span>
<span class="line-removed">213             scratch.clear(reg);</span>
<span class="line-removed">214         for (Reg reg : m_calleeSaveRegisters)</span>
<span class="line-removed">215             scratch.clear(reg);</span>
<span class="line-removed">216         for (Reg reg : scratch)</span>
<span class="line-removed">217             m_scratchGPRs.append(reg);</span>
<span class="line-removed">218         RELEASE_ASSERT(m_scratchGPRs.size() &gt;= 2);</span>
<span class="line-removed">219     }</span>
220 
<span class="line-modified">221     GPRReg prologueScratch(size_t i) const { return m_scratchGPRs[i].gpr(); }</span>





222 

223 private:
<span class="line-modified">224     template &lt;typename RegFunc, typename StackFunc&gt;</span>
<span class="line-removed">225     void marshallArgumentImpl(const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset, const RegFunc&amp; regFunc, const StackFunc&amp; stackFunc) const</span>
226     {
<span class="line-modified">227         if (count &lt; regArgs.size()) {</span>
<span class="line-modified">228             regFunc(regArgs[count++]);</span>
<span class="line-removed">229             return;</span>
<span class="line-removed">230         }</span>
231 
232         count++;
<span class="line-modified">233         stackFunc(stackOffset);</span>
<span class="line-modified">234         stackOffset = updateOffset(stackOffset);</span>

235     }
236 
<span class="line-modified">237     template &lt;typename RegFunc, typename StackFunc&gt;</span>
<span class="line-removed">238     void marshallArgument(Type type, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset, const RegFunc&amp; regFunc, const StackFunc&amp; stackFunc) const</span>
239     {
<span class="line-modified">240         switch (type) {</span>
<span class="line-modified">241         case Type::I32:</span>
<span class="line-modified">242         case Type::I64:</span>
<span class="line-modified">243         case Type::Anyref:</span>
<span class="line-modified">244         case Wasm::Funcref:</span>
<span class="line-modified">245             marshallArgumentImpl(m_gprArgs, gpArgumentCount, stackOffset, regFunc, stackFunc);</span>
<span class="line-modified">246             break;</span>
<span class="line-modified">247         case Type::F32:</span>
<span class="line-modified">248         case Type::F64:</span>
<span class="line-modified">249             marshallArgumentImpl(m_fprArgs, fpArgumentCount, stackOffset, regFunc, stackFunc);</span>
<span class="line-removed">250             break;</span>
251         default:
<span class="line-modified">252             RELEASE_ASSERT_NOT_REACHED();</span>
253         }

254     }
255 
256 public:
<span class="line-modified">257     static unsigned headerSizeInBytes() { return headerSize; }</span>
<span class="line-removed">258 </span>
<span class="line-removed">259     template&lt;typename Functor&gt;</span>
<span class="line-removed">260     void loadArguments(const Signature&amp; signature, const Functor&amp; functor) const</span>
<span class="line-removed">261     {</span>
<span class="line-removed">262         size_t gpArgumentCount = 0;</span>
<span class="line-removed">263         size_t fpArgumentCount = 0;</span>
<span class="line-removed">264         size_t stackOffset = headerSize;</span>
<span class="line-removed">265 </span>
<span class="line-removed">266         for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {</span>
<span class="line-removed">267             marshallArgument(signature.argument(i), gpArgumentCount, fpArgumentCount, stackOffset,</span>
<span class="line-removed">268                 [&amp;] (Reg reg) {</span>
<span class="line-removed">269                     functor(B3::Air::Tmp(reg), i);</span>
<span class="line-removed">270                 },</span>
<span class="line-removed">271                 [&amp;] (size_t stackOffset) {</span>
<span class="line-removed">272                     functor(B3::Air::Arg::addr(B3::Air::Tmp(GPRInfo::callFrameRegister), stackOffset), i);</span>
<span class="line-removed">273                 });</span>
<span class="line-removed">274         }</span>
<span class="line-removed">275     }</span>
<span class="line-removed">276 </span>
<span class="line-removed">277     // It&#39;s expected that the pachpointFunctor sets the generator for the call operation.</span>
<span class="line-removed">278     template&lt;typename Functor&gt;</span>
<span class="line-removed">279     void setupCall(B3::Air::Code&amp; code, Type returnType, B3::PatchpointValue* patchpoint, const Vector&lt;B3::Air::Tmp&gt;&amp; args, const Functor&amp; functor) const</span>
280     {
281         size_t gpArgumentCount = 0;
282         size_t fpArgumentCount = 0;
<span class="line-modified">283         size_t stackOffset = headerSize - sizeof(CallerFrameAndPC);</span>
<span class="line-modified">284 </span>
<span class="line-modified">285         for (auto tmp : args) {</span>
<span class="line-removed">286             marshallArgument(tmp.isGP() ? Type::I64 : Type::F64, gpArgumentCount, fpArgumentCount, stackOffset,</span>
<span class="line-removed">287                 [&amp;] (Reg reg) {</span>
<span class="line-removed">288                     functor(tmp, B3::ValueRep::reg(reg));</span>
<span class="line-removed">289                 },</span>
<span class="line-removed">290                 [&amp;] (size_t stackOffset) {</span>
<span class="line-removed">291                     functor(tmp, B3::ValueRep::stackArgument(stackOffset));</span>
<span class="line-removed">292                 });</span>
<span class="line-removed">293         }</span>
294 
<span class="line-modified">295         code.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), stackOffset));</span>


296 
<span class="line-modified">297         patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());</span>
<span class="line-modified">298         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());</span>
<span class="line-removed">299 </span>
<span class="line-removed">300         switch (returnType) {</span>
<span class="line-removed">301         case Type::Void:</span>
<span class="line-removed">302             break;</span>
<span class="line-removed">303         case Type::F32:</span>
<span class="line-removed">304         case Type::F64:</span>
<span class="line-removed">305             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(FPRInfo::returnValueFPR) };</span>
<span class="line-removed">306             break;</span>
<span class="line-removed">307         case Type::I32:</span>
<span class="line-removed">308         case Type::I64:</span>
<span class="line-removed">309         case Type::Anyref:</span>
<span class="line-removed">310         case Wasm::Funcref:</span>
<span class="line-removed">311             patchpoint-&gt;resultConstraints = { B3::ValueRep::reg(GPRInfo::returnValueGPR) };</span>
<span class="line-removed">312             break;</span>
<span class="line-removed">313         default:</span>
<span class="line-removed">314             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">315         }</span>
316     }
317 
<span class="line-modified">318     const Vector&lt;Reg&gt; m_gprArgs;</span>
<span class="line-modified">319     const Vector&lt;Reg&gt; m_fprArgs;</span>
<span class="line-modified">320     Vector&lt;Reg&gt; m_scratchGPRs;</span>
<span class="line-modified">321     const RegisterSet m_calleeSaveRegisters;</span>
<span class="line-removed">322     const RegisterSet m_callerSaveRegisters;</span>
323 };
324 
<span class="line-modified">325 inline unsigned nextJSCOffset(unsigned currentOffset)</span>
<span class="line-removed">326 {</span>
<span class="line-removed">327     return currentOffset + sizeof(Register);</span>
<span class="line-removed">328 }</span>
<span class="line-removed">329 </span>
<span class="line-removed">330 constexpr unsigned jscHeaderSize = ExecState::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-removed">331 </span>
<span class="line-removed">332 using JSCCallingConvention = CallingConvention&lt;jscHeaderSize, nextJSCOffset&gt;;</span>
<span class="line-removed">333 using WasmCallingConvention = JSCCallingConvention;</span>
<span class="line-removed">334 const JSCCallingConvention&amp; jscCallingConvention();</span>
335 const WasmCallingConvention&amp; wasmCallingConvention();
336 
<span class="line-removed">337 using JSCCallingConventionAir = CallingConventionAir&lt;jscHeaderSize, nextJSCOffset&gt;;</span>
<span class="line-removed">338 using WasmCallingConventionAir = JSCCallingConventionAir;</span>
<span class="line-removed">339 const JSCCallingConventionAir&amp; jscCallingConventionAir();</span>
<span class="line-removed">340 const WasmCallingConventionAir&amp; wasmCallingConventionAir();</span>
<span class="line-removed">341 </span>
342 } } // namespace JSC::Wasm
343 
344 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;AirCode.h&quot;
 31 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
 32 #include &quot;B3ArgumentRegValue.h&quot;
 33 #include &quot;B3BasicBlock.h&quot;
 34 #include &quot;B3Const64Value.h&quot;
 35 #include &quot;B3ConstrainedValue.h&quot;
 36 #include &quot;B3MemoryValue.h&quot;
 37 #include &quot;B3PatchpointValue.h&quot;
 38 #include &quot;B3Procedure.h&quot;
 39 #include &quot;B3StackmapGenerationParams.h&quot;
 40 #include &quot;CallFrame.h&quot;
 41 #include &quot;LinkBuffer.h&quot;
<span class="line-added"> 42 #include &quot;RegisterAtOffsetList.h&quot;</span>
 43 #include &quot;RegisterSet.h&quot;
 44 #include &quot;WasmFormat.h&quot;
 45 #include &quot;WasmSignature.h&quot;
 46 
 47 namespace JSC { namespace Wasm {
 48 
<span class="line-modified"> 49 constexpr unsigned numberOfLLIntCalleeSaveRegisters = 2;</span>
 50 
<span class="line-modified"> 51 using ArgumentLocation = B3::ValueRep;</span>
<span class="line-modified"> 52 enum class CallRole : uint8_t {</span>
<span class="line-modified"> 53     Caller,</span>
<span class="line-modified"> 54     Callee,</span>
<span class="line-modified"> 55 };</span>
<span class="line-modified"> 56 </span>
<span class="line-modified"> 57 struct CallInformation {</span>
<span class="line-added"> 58     CallInformation(Vector&lt;ArgumentLocation&gt;&amp;&amp; parameters, Vector&lt;ArgumentLocation, 1&gt;&amp;&amp; returnValues, size_t stackOffset)</span>
<span class="line-added"> 59         : params(WTFMove(parameters))</span>
<span class="line-added"> 60         , results(WTFMove(returnValues))</span>
<span class="line-added"> 61         , headerAndArgumentStackSizeInBytes(stackOffset)</span>
<span class="line-added"> 62     { }</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64     RegisterAtOffsetList computeResultsOffsetList()</span>
 65     {
<span class="line-added"> 66         RegisterSet usedResultRegisters;</span>
<span class="line-added"> 67         for (B3::ValueRep rep : results) {</span>
<span class="line-added"> 68             if (rep.isReg())</span>
<span class="line-added"> 69                 usedResultRegisters.set(rep.reg());</span>
<span class="line-added"> 70         }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72         RegisterAtOffsetList savedRegs(usedResultRegisters, RegisterAtOffsetList::ZeroBased);</span>
<span class="line-added"> 73         return savedRegs;</span>
 74     }
 75 
<span class="line-added"> 76     bool argumentsIncludeI64 { false };</span>
<span class="line-added"> 77     bool resultsIncludeI64 { false };</span>
<span class="line-added"> 78     Vector&lt;ArgumentLocation&gt; params;</span>
<span class="line-added"> 79     Vector&lt;ArgumentLocation, 1&gt; results;</span>
<span class="line-added"> 80     // As a callee this includes CallerFrameAndPC as a caller it does not.</span>
<span class="line-added"> 81     size_t headerAndArgumentStackSizeInBytes;</span>
<span class="line-added"> 82 };</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 class WasmCallingConvention {</span>
<span class="line-added"> 85 public:</span>
<span class="line-added"> 86     static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88     WasmCallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprs, Vector&lt;Reg&gt;&amp;&amp; fprs, Vector&lt;GPRReg&gt;&amp;&amp; scratches, RegisterSet&amp;&amp; calleeSaves, RegisterSet&amp;&amp; callerSaves)</span>
<span class="line-added"> 89         : gprArgs(WTFMove(gprs))</span>
<span class="line-added"> 90         , fprArgs(WTFMove(fprs))</span>
<span class="line-added"> 91         , prologueScratchGPRs(WTFMove(scratches))</span>
<span class="line-added"> 92         , calleeSaveRegisters(WTFMove(calleeSaves))</span>
<span class="line-added"> 93         , callerSaveRegisters(WTFMove(callerSaves))</span>
<span class="line-added"> 94     { }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96     WTF_MAKE_NONCOPYABLE(WasmCallingConvention);</span>
<span class="line-added"> 97 </span>
 98 private:
<span class="line-modified"> 99     ArgumentLocation marshallLocationImpl(CallRole role, const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>
100     {
101         if (count &lt; regArgs.size())
<span class="line-modified">102             return ArgumentLocation::reg(regArgs[count++]);</span>
103 
104         count++;
<span class="line-modified">105         ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);</span>
<span class="line-modified">106         stackOffset += sizeof(Register);</span>
107         return result;
108     }
109 
<span class="line-modified">110     ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>
111     {
<span class="line-modified">112         ASSERT(isValueType(valueType));</span>
<span class="line-modified">113         switch (valueType) {</span>
<span class="line-modified">114         case I32:</span>
<span class="line-modified">115         case I64:</span>
<span class="line-modified">116         case Funcref:</span>
<span class="line-modified">117         case Anyref:</span>
<span class="line-modified">118             return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified">119         case F32:</span>
<span class="line-modified">120         case F64:</span>
<span class="line-added">121             return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);</span>
<span class="line-added">122         default:</span>
123             break;

124         }
125         RELEASE_ASSERT_NOT_REACHED();
126     }
127 
128 public:
<span class="line-modified">129     CallInformation callInformationFor(const Signature&amp; signature, CallRole role = CallRole::Caller) const</span>




































130     {
<span class="line-modified">131         bool argumentsIncludeI64 = false;</span>
<span class="line-modified">132         bool resultsIncludeI64 = false;</span>
133         size_t gpArgumentCount = 0;
134         size_t fpArgumentCount = 0;
<span class="line-modified">135         size_t argStackOffset = headerSizeInBytes;</span>
<span class="line-added">136         if (role == CallRole::Caller)</span>
<span class="line-added">137             argStackOffset -= sizeof(CallerFrameAndPC);</span>
138 
<span class="line-added">139         Vector&lt;ArgumentLocation&gt; params(signature.argumentCount());</span>
140         for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {
<span class="line-modified">141             argumentsIncludeI64 |= signature.argument(i) == I64;</span>
<span class="line-modified">142             params[i] = marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, argStackOffset);</span>












143         }
<span class="line-modified">144         gpArgumentCount = 0;</span>
<span class="line-modified">145         fpArgumentCount = 0;</span>
<span class="line-modified">146         size_t resultStackOffset = headerSizeInBytes;</span>
<span class="line-modified">147         if (role == CallRole::Caller)</span>
<span class="line-modified">148             resultStackOffset -= sizeof(CallerFrameAndPC);</span>
<span class="line-modified">149 </span>
<span class="line-modified">150         Vector&lt;ArgumentLocation, 1&gt; results(signature.returnCount());</span>
<span class="line-modified">151         for (size_t i = 0; i &lt; signature.returnCount(); ++i) {</span>
<span class="line-modified">152             resultsIncludeI64 |= signature.returnType(i) == I64;</span>
<span class="line-modified">153             results[i] = marshallLocation(role, signature.returnType(i), gpArgumentCount, fpArgumentCount, resultStackOffset);</span>




154         }
155 
<span class="line-modified">156         CallInformation result(WTFMove(params), WTFMove(results), std::max(argStackOffset, resultStackOffset));</span>
<span class="line-modified">157         result.argumentsIncludeI64 = argumentsIncludeI64;</span>
<span class="line-modified">158         result.resultsIncludeI64 = resultsIncludeI64;</span>
<span class="line-modified">159         return result;</span>




















160     }
161 
<span class="line-modified">162     const Vector&lt;Reg&gt; gprArgs;</span>
<span class="line-modified">163     const Vector&lt;Reg&gt; fprArgs;</span>
<span class="line-modified">164     const Vector&lt;GPRReg&gt; prologueScratchGPRs;</span>
<span class="line-modified">165     const RegisterSet calleeSaveRegisters;</span>
<span class="line-added">166     const RegisterSet callerSaveRegisters;</span>
167 };
168 
<span class="line-modified">169 class JSCallingConvention {</span>



170 public:
<span class="line-modified">171     static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-modified">172 </span>
<span class="line-modified">173     // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s</span>
<span class="line-modified">174     // instance as the first JS argument when we&#39;re not using fast TLS to hold the</span>
<span class="line-modified">175     // Wasm::Context*&#39;s instance.</span>
<span class="line-modified">176     static constexpr ptrdiff_t instanceStackOffset = CallFrameSlot::thisArgument * sizeof(EncodedJSValue);</span>











177 
<span class="line-modified">178     JSCallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprs, Vector&lt;Reg&gt;&amp;&amp; fprs, RegisterSet&amp;&amp; calleeSaves, RegisterSet&amp;&amp; callerSaves)</span>
<span class="line-added">179         : gprArgs(WTFMove(gprs))</span>
<span class="line-added">180         , fprArgs(WTFMove(fprs))</span>
<span class="line-added">181         , calleeSaveRegisters(WTFMove(calleeSaves))</span>
<span class="line-added">182         , callerSaveRegisters(WTFMove(callerSaves))</span>
<span class="line-added">183     { }</span>
184 
<span class="line-added">185     WTF_MAKE_NONCOPYABLE(JSCallingConvention);</span>
186 private:
<span class="line-modified">187     ArgumentLocation marshallLocationImpl(CallRole role, const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>

188     {
<span class="line-modified">189         if (count &lt; regArgs.size())</span>
<span class="line-modified">190             return ArgumentLocation::reg(regArgs[count++]);</span>


191 
192         count++;
<span class="line-modified">193         ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);</span>
<span class="line-modified">194         stackOffset += sizeof(Register);</span>
<span class="line-added">195         return result;</span>
196     }
197 
<span class="line-modified">198     ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>

199     {
<span class="line-modified">200         ASSERT(isValueType(valueType));</span>
<span class="line-modified">201         switch (valueType) {</span>
<span class="line-modified">202         case I32:</span>
<span class="line-modified">203         case I64:</span>
<span class="line-modified">204         case Funcref:</span>
<span class="line-modified">205         case Anyref:</span>
<span class="line-modified">206             return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified">207         case F32:</span>
<span class="line-modified">208         case F64:</span>
<span class="line-modified">209             return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);</span>

210         default:
<span class="line-modified">211             break;</span>
212         }
<span class="line-added">213         RELEASE_ASSERT_NOT_REACHED();</span>
214     }
215 
216 public:
<span class="line-modified">217     CallInformation callInformationFor(const Signature&amp; signature, CallRole role = CallRole::Callee) const</span>






















218     {
219         size_t gpArgumentCount = 0;
220         size_t fpArgumentCount = 0;
<span class="line-modified">221         size_t stackOffset = headerSizeInBytes + sizeof(Register); // Skip the this value since wasm doesn&#39;t use it and we sometimes put the context there.</span>
<span class="line-modified">222         if (role == CallRole::Caller)</span>
<span class="line-modified">223             stackOffset -= sizeof(CallerFrameAndPC);</span>








224 
<span class="line-modified">225         Vector&lt;ArgumentLocation&gt; params;</span>
<span class="line-added">226         for (size_t i = 0; i &lt; signature.argumentCount(); ++i)</span>
<span class="line-added">227             params.append(marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, stackOffset));</span>
228 
<span class="line-modified">229         Vector&lt;ArgumentLocation, 1&gt; results { ArgumentLocation::reg(GPRInfo::returnValueGPR) };</span>
<span class="line-modified">230         return CallInformation(WTFMove(params), WTFMove(results), stackOffset);</span>

















231     }
232 
<span class="line-modified">233     const Vector&lt;Reg&gt; gprArgs;</span>
<span class="line-modified">234     const Vector&lt;Reg&gt; fprArgs;</span>
<span class="line-modified">235     const RegisterSet calleeSaveRegisters;</span>
<span class="line-modified">236     const RegisterSet callerSaveRegisters;</span>

237 };
238 
<span class="line-modified">239 const JSCallingConvention&amp; jsCallingConvention();</span>









240 const WasmCallingConvention&amp; wasmCallingConvention();
241 





242 } } // namespace JSC::Wasm
243 
244 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmCallingConvention.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmCodeBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPhantomInsertionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPlan.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPlan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
117 Profiler::CompilationKind profilerCompilationKindForMode(CompilationMode mode)
118 {
119     switch (mode) {
120     case InvalidCompilationMode:
121         RELEASE_ASSERT_NOT_REACHED();
122         return Profiler::DFG;
123     case DFGMode:
124         return Profiler::DFG;
125     case FTLMode:
126         return Profiler::FTL;
127     case FTLForOSREntryMode:
128         return Profiler::FTLForOSREntry;
129     }
130     RELEASE_ASSERT_NOT_REACHED();
131     return Profiler::DFG;
132 }
133 
134 } // anonymous namespace
135 
136 Plan::Plan(CodeBlock* passedCodeBlock, CodeBlock* profiledDFGCodeBlock,
<span class="line-modified">137     CompilationMode mode, unsigned osrEntryBytecodeIndex,</span>
138     const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues)
139     : m_mode(mode)
140     , m_vm(&amp;passedCodeBlock-&gt;vm())
141     , m_codeBlock(passedCodeBlock)
142     , m_profiledDFGCodeBlock(profiledDFGCodeBlock)
143     , m_mustHandleValues(mustHandleValues)
144     , m_osrEntryBytecodeIndex(osrEntryBytecodeIndex)
145     , m_compilation(UNLIKELY(m_vm-&gt;m_perBytecodeProfiler) ? adoptRef(new Profiler::Compilation(m_vm-&gt;m_perBytecodeProfiler-&gt;ensureBytecodesFor(m_codeBlock), profilerCompilationKindForMode(mode))) : nullptr)
146     , m_inlineCallFrames(adoptRef(new InlineCallFrameSet()))
147     , m_identifiers(m_codeBlock)
148     , m_weakReferences(m_codeBlock)
149     , m_stage(Preparing)
150 {
151     RELEASE_ASSERT(m_codeBlock-&gt;alternative()-&gt;jitCode());
152     m_inlineCallFrames-&gt;disableThreadingChecks();
153 }
154 
155 Plan::~Plan()
156 {
157 }
</pre>
<hr />
<pre>
221     default:
222         RELEASE_ASSERT_NOT_REACHED();
223         break;
224     }
225     if (m_codeBlock) { // m_codeBlock will be null if the compilation was cancelled.
226         if (path == FTLPath)
227             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;ftlCompile&quot;, (&quot;took &quot;, (after - before).milliseconds(), &quot; ms (DFG: &quot;, (m_timeBeforeFTL - before).milliseconds(), &quot;, B3: &quot;, (after - m_timeBeforeFTL).milliseconds(), &quot;) with &quot;, pathName));
228         else
229             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgCompile&quot;, (&quot;took &quot;, (after - before).milliseconds(), &quot; ms with &quot;, pathName));
230     }
231     if (UNLIKELY(reportCompileTimes())) {
232         dataLog(&quot;Optimized &quot;, codeBlockName, &quot; using &quot;, m_mode, &quot; with &quot;, pathName, &quot; into &quot;, m_finalizer ? m_finalizer-&gt;codeSize() : 0, &quot; bytes in &quot;, (after - before).milliseconds(), &quot; ms&quot;);
233         if (path == FTLPath)
234             dataLog(&quot; (DFG: &quot;, (m_timeBeforeFTL - before).milliseconds(), &quot;, B3: &quot;, (after - m_timeBeforeFTL).milliseconds(), &quot;)&quot;);
235         dataLog(&quot;.\n&quot;);
236     }
237 }
238 
239 Plan::CompilationPath Plan::compileInThreadImpl()
240 {
<span class="line-modified">241     cleanMustHandleValuesIfNecessary();</span>



242 
<span class="line-modified">243     if (verboseCompilationEnabled(m_mode) &amp;&amp; m_osrEntryBytecodeIndex != UINT_MAX) {</span>
244         dataLog(&quot;\n&quot;);
<span class="line-modified">245         dataLog(&quot;Compiler must handle OSR entry from bc#&quot;, m_osrEntryBytecodeIndex, &quot; with values: &quot;, m_mustHandleValues, &quot;\n&quot;);</span>
246         dataLog(&quot;\n&quot;);
247     }
248 
249     Graph dfg(*m_vm, *this);
<span class="line-modified">250     parse(dfg);</span>




251 
252     m_codeBlock-&gt;setCalleeSaveRegisters(RegisterSet::dfgCalleeSaveRegisters());
253 
254     bool changed = false;
255 
256 #define RUN_PHASE(phase)                                         \
257     do {                                                         \
258         if (Options::safepointBeforeEachPhase()) {               \
259             Safepoint::Result safepointResult;                   \
260             {                                                    \
261                 GraphSafepoint safepoint(dfg, safepointResult);  \
262             }                                                    \
263             if (safepointResult.didGetCancelled())               \
264                 return CancelPath;                               \
265         }                                                        \
266         dfg.nextPhase();                                         \
267         changed |= phase(dfg);                                   \
268     } while (false);                                             \
269 
270 
271     // By this point the DFG bytecode parser will have potentially mutated various tables
272     // in the CodeBlock. This is a good time to perform an early shrink, which is more
273     // powerful than a late one. It&#39;s safe to do so because we haven&#39;t generated any code
274     // that references any of the tables directly, yet.
<span class="line-modified">275     m_codeBlock-&gt;shrinkToFit(CodeBlock::EarlyShrink);</span>



276 
277     if (validationEnabled())
278         validate(dfg);
279 
280     if (Options::dumpGraphAfterParsing()) {
281         dataLog(&quot;Graph after parsing:\n&quot;);
282         dfg.dump();
283     }
284 
285     RUN_PHASE(performLiveCatchVariablePreservationPhase);
286 
287     RUN_PHASE(performCPSRethreading);
288     RUN_PHASE(performUnification);
289     RUN_PHASE(performPredictionInjection);
290 
291     RUN_PHASE(performStaticExecutionCountEstimation);
292 
293     if (m_mode == FTLForOSREntryMode) {
294         bool result = performOSREntrypointCreation(dfg);
295         if (!result) {
</pre>
<hr />
<pre>
364         dfg.ensureCPSNaturalLoops();
365     }
366 
367     switch (m_mode) {
368     case DFGMode: {
369         dfg.m_fixpointState = FixpointConverged;
370 
371         RUN_PHASE(performTierUpCheckInjection);
372 
373         RUN_PHASE(performFastStoreBarrierInsertion);
374         RUN_PHASE(performStoreBarrierClustering);
375         RUN_PHASE(performCleanUp);
376         RUN_PHASE(performCPSRethreading);
377         RUN_PHASE(performDCE);
378         RUN_PHASE(performPhantomInsertion);
379         RUN_PHASE(performStackLayout);
380         RUN_PHASE(performVirtualRegisterAllocation);
381         RUN_PHASE(performWatchpointCollection);
382         dumpAndVerifyGraph(dfg, &quot;Graph after optimization:&quot;);
383 
<span class="line-modified">384         JITCompiler dataFlowJIT(dfg);</span>
<span class="line-modified">385         if (m_codeBlock-&gt;codeType() == FunctionCode)</span>
<span class="line-modified">386             dataFlowJIT.compileFunction();</span>
<span class="line-modified">387         else</span>
<span class="line-modified">388             dataFlowJIT.compile();</span>




389 
390         return DFGPath;
391     }
392 
393     case FTLMode:
394     case FTLForOSREntryMode: {
395 #if ENABLE(FTL_JIT)
396         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
397             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);
398             return FailPath;
399         }
400 
401         RUN_PHASE(performCleanUp); // Reduce the graph size a bit.
402         RUN_PHASE(performCriticalEdgeBreaking);
403         if (Options::createPreHeaders())
404             RUN_PHASE(performLoopPreHeaderCreation);
405         RUN_PHASE(performCPSRethreading);
406         RUN_PHASE(performSSAConversion);
407         RUN_PHASE(performSSALowering);
408 
</pre>
<hr />
<pre>
479         }
480 
481         dfg.nextPhase();
482         dumpAndVerifyGraph(dfg, &quot;Graph just before FTL lowering:&quot;, shouldDumpDisassembly(m_mode));
483 
484         // Flash a safepoint in case the GC wants some action.
485         Safepoint::Result safepointResult;
486         {
487             GraphSafepoint safepoint(dfg, safepointResult);
488         }
489         if (safepointResult.didGetCancelled())
490             return CancelPath;
491 
492         dfg.nextPhase();
493         FTL::State state(dfg);
494         FTL::lowerDFGToB3(state);
495 
496         if (UNLIKELY(computeCompileTimes()))
497             m_timeBeforeFTL = MonotonicTime::now();
498 
<span class="line-modified">499         if (Options::b3AlwaysFailsBeforeCompile()) {</span>
500             FTL::fail(state);
501             return FTLPath;
502         }
503 
504         FTL::compile(state, safepointResult);
505         if (safepointResult.didGetCancelled())
506             return CancelPath;
507 
<span class="line-modified">508         if (Options::b3AlwaysFailsBeforeLink()) {</span>
509             FTL::fail(state);
510             return FTLPath;
511         }
512 
513         if (state.allocationFailed) {
514             FTL::fail(state);
515             return FTLPath;
516         }
517 
518         FTL::link(state);
519 
520         if (state.allocationFailed) {
521             FTL::fail(state);
522             return FTLPath;
523         }
524 
525         return FTLPath;
526 #else
527         RELEASE_ASSERT_NOT_REACHED();
528         return FailPath;
</pre>
<hr />
<pre>
586     ASSERT(m_vm-&gt;heap.isDeferred());
587 
588     CompilationResult result = [&amp;] {
589         if (!isStillValidOnMainThread() || !isStillValid()) {
590             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;invalidated&quot;));
591             return CompilationInvalidated;
592         }
593 
594         bool result;
595         if (m_codeBlock-&gt;codeType() == FunctionCode)
596             result = m_finalizer-&gt;finalizeFunction();
597         else
598             result = m_finalizer-&gt;finalize();
599 
600         if (!result) {
601             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;failed&quot;));
602             return CompilationFailed;
603         }
604 
605         reallyAdd(m_codeBlock-&gt;jitCode()-&gt;dfgCommon());





606 
607         if (validationEnabled()) {
608             TrackedReferences trackedReferences;
609 
610             for (WriteBarrier&lt;JSCell&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakReferences)
611                 trackedReferences.add(reference.get());
<span class="line-modified">612             for (WriteBarrier&lt;Structure&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakStructureReferences)</span>
<span class="line-modified">613                 trackedReferences.add(reference.get());</span>
614             for (WriteBarrier&lt;Unknown&gt;&amp; constant : m_codeBlock-&gt;constants())
615                 trackedReferences.add(constant.get());
616 
617             for (auto* inlineCallFrame : *m_inlineCallFrames) {
618                 ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
619                 trackedReferences.add(inlineCallFrame-&gt;baselineCodeBlock.get());
620             }
621 
622             // Check that any other references that we have anywhere in the JITCode are also
623             // tracked either strongly or weakly.
624             m_codeBlock-&gt;jitCode()-&gt;validateReferences(trackedReferences);
625         }
626 
627         CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;succeeded&quot;));
628         return CompilationSuccessful;
629     }();
630 
631     // We will establish new references from the code block to things. So, we need a barrier.
632     m_vm-&gt;heap.writeBarrier(m_codeBlock);
633     return result;
</pre>
<hr />
<pre>
638     m_callback-&gt;compilationDidComplete(m_codeBlock, m_profiledDFGCodeBlock, finalizeWithoutNotifyingCallback());
639 }
640 
641 CompilationKey Plan::key()
642 {
643     return CompilationKey(m_codeBlock-&gt;alternative(), m_mode);
644 }
645 
646 void Plan::checkLivenessAndVisitChildren(SlotVisitor&amp; visitor)
647 {
648     if (!isKnownToBeLiveDuringGC())
649         return;
650 
651     cleanMustHandleValuesIfNecessary();
652     for (unsigned i = m_mustHandleValues.size(); i--;) {
653         Optional&lt;JSValue&gt; value = m_mustHandleValues[i];
654         if (value)
655             visitor.appendUnbarriered(value.value());
656     }
657 

658     m_recordedStatuses.markIfCheap(visitor);
659 
660     visitor.appendUnbarriered(m_codeBlock);
661     visitor.appendUnbarriered(m_codeBlock-&gt;alternative());
662     visitor.appendUnbarriered(m_profiledDFGCodeBlock);
663 
664     if (m_inlineCallFrames) {
665         for (auto* inlineCallFrame : *m_inlineCallFrames) {
666             ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
667             visitor.appendUnbarriered(inlineCallFrame-&gt;baselineCodeBlock.get());
668         }
669     }
670 
671     m_weakReferences.visitChildren(visitor);
672     m_transitions.visitChildren(visitor);
673 }
674 
675 void Plan::finalizeInGC()
676 {
677     ASSERT(m_vm);
678     m_recordedStatuses.finalizeWithoutDeleting(*m_vm);
679 }
680 
681 bool Plan::isKnownToBeLiveDuringGC()
682 {
683     if (m_stage == Cancelled)
684         return false;
685     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;ownerExecutable()))
686         return false;
687     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;alternative()))
688         return false;
689     if (!!m_profiledDFGCodeBlock &amp;&amp; !m_vm-&gt;heap.isMarked(m_profiledDFGCodeBlock))
690         return false;
691     return true;
692 }
693 
694 void Plan::cancel()
695 {


696     m_vm = nullptr;

697     m_codeBlock = nullptr;
698     m_profiledDFGCodeBlock = nullptr;
699     m_mustHandleValues.clear();
700     m_compilation = nullptr;
701     m_finalizer = nullptr;
702     m_inlineCallFrames = nullptr;
703     m_watchpoints = DesiredWatchpoints();
704     m_identifiers = DesiredIdentifiers();
705     m_globalProperties = DesiredGlobalProperties();
706     m_weakReferences = DesiredWeakReferences();
707     m_transitions = DesiredTransitions();
708     m_callback = nullptr;
709     m_stage = Cancelled;
710 }
711 
712 void Plan::cleanMustHandleValuesIfNecessary()
713 {
714     LockHolder locker(m_mustHandleValueCleaningLock);
715 
716     if (!m_mustHandleValuesMayIncludeGarbage)
717         return;
718 
719     m_mustHandleValuesMayIncludeGarbage = false;
720 
721     if (!m_codeBlock)
722         return;
723 
724     if (!m_mustHandleValues.numberOfLocals())
725         return;
726 
727     CodeBlock* alternative = m_codeBlock-&gt;alternative();
<span class="line-modified">728     FastBitVector liveness = alternative-&gt;livenessAnalysis().getLivenessInfoAtBytecodeOffset(alternative, m_osrEntryBytecodeIndex);</span>
729 
730     for (unsigned local = m_mustHandleValues.numberOfLocals(); local--;) {
731         if (!liveness[local])
732             m_mustHandleValues.local(local) = WTF::nullopt;
733     }
734 }
735 
736 } } // namespace JSC::DFG
737 
738 #endif // ENABLE(DFG_JIT)
739 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
117 Profiler::CompilationKind profilerCompilationKindForMode(CompilationMode mode)
118 {
119     switch (mode) {
120     case InvalidCompilationMode:
121         RELEASE_ASSERT_NOT_REACHED();
122         return Profiler::DFG;
123     case DFGMode:
124         return Profiler::DFG;
125     case FTLMode:
126         return Profiler::FTL;
127     case FTLForOSREntryMode:
128         return Profiler::FTLForOSREntry;
129     }
130     RELEASE_ASSERT_NOT_REACHED();
131     return Profiler::DFG;
132 }
133 
134 } // anonymous namespace
135 
136 Plan::Plan(CodeBlock* passedCodeBlock, CodeBlock* profiledDFGCodeBlock,
<span class="line-modified">137     CompilationMode mode, BytecodeIndex osrEntryBytecodeIndex,</span>
138     const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues)
139     : m_mode(mode)
140     , m_vm(&amp;passedCodeBlock-&gt;vm())
141     , m_codeBlock(passedCodeBlock)
142     , m_profiledDFGCodeBlock(profiledDFGCodeBlock)
143     , m_mustHandleValues(mustHandleValues)
144     , m_osrEntryBytecodeIndex(osrEntryBytecodeIndex)
145     , m_compilation(UNLIKELY(m_vm-&gt;m_perBytecodeProfiler) ? adoptRef(new Profiler::Compilation(m_vm-&gt;m_perBytecodeProfiler-&gt;ensureBytecodesFor(m_codeBlock), profilerCompilationKindForMode(mode))) : nullptr)
146     , m_inlineCallFrames(adoptRef(new InlineCallFrameSet()))
147     , m_identifiers(m_codeBlock)
148     , m_weakReferences(m_codeBlock)
149     , m_stage(Preparing)
150 {
151     RELEASE_ASSERT(m_codeBlock-&gt;alternative()-&gt;jitCode());
152     m_inlineCallFrames-&gt;disableThreadingChecks();
153 }
154 
155 Plan::~Plan()
156 {
157 }
</pre>
<hr />
<pre>
221     default:
222         RELEASE_ASSERT_NOT_REACHED();
223         break;
224     }
225     if (m_codeBlock) { // m_codeBlock will be null if the compilation was cancelled.
226         if (path == FTLPath)
227             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;ftlCompile&quot;, (&quot;took &quot;, (after - before).milliseconds(), &quot; ms (DFG: &quot;, (m_timeBeforeFTL - before).milliseconds(), &quot;, B3: &quot;, (after - m_timeBeforeFTL).milliseconds(), &quot;) with &quot;, pathName));
228         else
229             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgCompile&quot;, (&quot;took &quot;, (after - before).milliseconds(), &quot; ms with &quot;, pathName));
230     }
231     if (UNLIKELY(reportCompileTimes())) {
232         dataLog(&quot;Optimized &quot;, codeBlockName, &quot; using &quot;, m_mode, &quot; with &quot;, pathName, &quot; into &quot;, m_finalizer ? m_finalizer-&gt;codeSize() : 0, &quot; bytes in &quot;, (after - before).milliseconds(), &quot; ms&quot;);
233         if (path == FTLPath)
234             dataLog(&quot; (DFG: &quot;, (m_timeBeforeFTL - before).milliseconds(), &quot;, B3: &quot;, (after - m_timeBeforeFTL).milliseconds(), &quot;)&quot;);
235         dataLog(&quot;.\n&quot;);
236     }
237 }
238 
239 Plan::CompilationPath Plan::compileInThreadImpl()
240 {
<span class="line-modified">241     {</span>
<span class="line-added">242         CompilerTimingScope timingScope(&quot;DFG&quot;, &quot;clean must handle values&quot;);</span>
<span class="line-added">243         cleanMustHandleValuesIfNecessary();</span>
<span class="line-added">244     }</span>
245 
<span class="line-modified">246     if (verboseCompilationEnabled(m_mode) &amp;&amp; m_osrEntryBytecodeIndex) {</span>
247         dataLog(&quot;\n&quot;);
<span class="line-modified">248         dataLog(&quot;Compiler must handle OSR entry from &quot;, m_osrEntryBytecodeIndex, &quot; with values: &quot;, m_mustHandleValues, &quot;\n&quot;);</span>
249         dataLog(&quot;\n&quot;);
250     }
251 
252     Graph dfg(*m_vm, *this);
<span class="line-modified">253 </span>
<span class="line-added">254     {</span>
<span class="line-added">255         CompilerTimingScope timingScope(&quot;DFG&quot;, &quot;bytecode parser&quot;);</span>
<span class="line-added">256         parse(dfg);</span>
<span class="line-added">257     }</span>
258 
259     m_codeBlock-&gt;setCalleeSaveRegisters(RegisterSet::dfgCalleeSaveRegisters());
260 
261     bool changed = false;
262 
263 #define RUN_PHASE(phase)                                         \
264     do {                                                         \
265         if (Options::safepointBeforeEachPhase()) {               \
266             Safepoint::Result safepointResult;                   \
267             {                                                    \
268                 GraphSafepoint safepoint(dfg, safepointResult);  \
269             }                                                    \
270             if (safepointResult.didGetCancelled())               \
271                 return CancelPath;                               \
272         }                                                        \
273         dfg.nextPhase();                                         \
274         changed |= phase(dfg);                                   \
275     } while (false);                                             \
276 
277 
278     // By this point the DFG bytecode parser will have potentially mutated various tables
279     // in the CodeBlock. This is a good time to perform an early shrink, which is more
280     // powerful than a late one. It&#39;s safe to do so because we haven&#39;t generated any code
281     // that references any of the tables directly, yet.
<span class="line-modified">282     {</span>
<span class="line-added">283         ConcurrentJSLocker locker(m_codeBlock-&gt;m_lock);</span>
<span class="line-added">284         m_codeBlock-&gt;shrinkToFit(locker, CodeBlock::ShrinkMode::EarlyShrink);</span>
<span class="line-added">285     }</span>
286 
287     if (validationEnabled())
288         validate(dfg);
289 
290     if (Options::dumpGraphAfterParsing()) {
291         dataLog(&quot;Graph after parsing:\n&quot;);
292         dfg.dump();
293     }
294 
295     RUN_PHASE(performLiveCatchVariablePreservationPhase);
296 
297     RUN_PHASE(performCPSRethreading);
298     RUN_PHASE(performUnification);
299     RUN_PHASE(performPredictionInjection);
300 
301     RUN_PHASE(performStaticExecutionCountEstimation);
302 
303     if (m_mode == FTLForOSREntryMode) {
304         bool result = performOSREntrypointCreation(dfg);
305         if (!result) {
</pre>
<hr />
<pre>
374         dfg.ensureCPSNaturalLoops();
375     }
376 
377     switch (m_mode) {
378     case DFGMode: {
379         dfg.m_fixpointState = FixpointConverged;
380 
381         RUN_PHASE(performTierUpCheckInjection);
382 
383         RUN_PHASE(performFastStoreBarrierInsertion);
384         RUN_PHASE(performStoreBarrierClustering);
385         RUN_PHASE(performCleanUp);
386         RUN_PHASE(performCPSRethreading);
387         RUN_PHASE(performDCE);
388         RUN_PHASE(performPhantomInsertion);
389         RUN_PHASE(performStackLayout);
390         RUN_PHASE(performVirtualRegisterAllocation);
391         RUN_PHASE(performWatchpointCollection);
392         dumpAndVerifyGraph(dfg, &quot;Graph after optimization:&quot;);
393 
<span class="line-modified">394         {</span>
<span class="line-modified">395             CompilerTimingScope timingScope(&quot;DFG&quot;, &quot;machine code generation&quot;);</span>
<span class="line-modified">396 </span>
<span class="line-modified">397             JITCompiler dataFlowJIT(dfg);</span>
<span class="line-modified">398             if (m_codeBlock-&gt;codeType() == FunctionCode)</span>
<span class="line-added">399                 dataFlowJIT.compileFunction();</span>
<span class="line-added">400             else</span>
<span class="line-added">401                 dataFlowJIT.compile();</span>
<span class="line-added">402         }</span>
403 
404         return DFGPath;
405     }
406 
407     case FTLMode:
408     case FTLForOSREntryMode: {
409 #if ENABLE(FTL_JIT)
410         if (FTL::canCompile(dfg) == FTL::CannotCompile) {
411             m_finalizer = makeUnique&lt;FailedFinalizer&gt;(*this);
412             return FailPath;
413         }
414 
415         RUN_PHASE(performCleanUp); // Reduce the graph size a bit.
416         RUN_PHASE(performCriticalEdgeBreaking);
417         if (Options::createPreHeaders())
418             RUN_PHASE(performLoopPreHeaderCreation);
419         RUN_PHASE(performCPSRethreading);
420         RUN_PHASE(performSSAConversion);
421         RUN_PHASE(performSSALowering);
422 
</pre>
<hr />
<pre>
493         }
494 
495         dfg.nextPhase();
496         dumpAndVerifyGraph(dfg, &quot;Graph just before FTL lowering:&quot;, shouldDumpDisassembly(m_mode));
497 
498         // Flash a safepoint in case the GC wants some action.
499         Safepoint::Result safepointResult;
500         {
501             GraphSafepoint safepoint(dfg, safepointResult);
502         }
503         if (safepointResult.didGetCancelled())
504             return CancelPath;
505 
506         dfg.nextPhase();
507         FTL::State state(dfg);
508         FTL::lowerDFGToB3(state);
509 
510         if (UNLIKELY(computeCompileTimes()))
511             m_timeBeforeFTL = MonotonicTime::now();
512 
<span class="line-modified">513         if (UNLIKELY(Options::b3AlwaysFailsBeforeCompile())) {</span>
514             FTL::fail(state);
515             return FTLPath;
516         }
517 
518         FTL::compile(state, safepointResult);
519         if (safepointResult.didGetCancelled())
520             return CancelPath;
521 
<span class="line-modified">522         if (UNLIKELY(Options::b3AlwaysFailsBeforeLink())) {</span>
523             FTL::fail(state);
524             return FTLPath;
525         }
526 
527         if (state.allocationFailed) {
528             FTL::fail(state);
529             return FTLPath;
530         }
531 
532         FTL::link(state);
533 
534         if (state.allocationFailed) {
535             FTL::fail(state);
536             return FTLPath;
537         }
538 
539         return FTLPath;
540 #else
541         RELEASE_ASSERT_NOT_REACHED();
542         return FailPath;
</pre>
<hr />
<pre>
600     ASSERT(m_vm-&gt;heap.isDeferred());
601 
602     CompilationResult result = [&amp;] {
603         if (!isStillValidOnMainThread() || !isStillValid()) {
604             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;invalidated&quot;));
605             return CompilationInvalidated;
606         }
607 
608         bool result;
609         if (m_codeBlock-&gt;codeType() == FunctionCode)
610             result = m_finalizer-&gt;finalizeFunction();
611         else
612             result = m_finalizer-&gt;finalize();
613 
614         if (!result) {
615             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;failed&quot;));
616             return CompilationFailed;
617         }
618 
619         reallyAdd(m_codeBlock-&gt;jitCode()-&gt;dfgCommon());
<span class="line-added">620         {</span>
<span class="line-added">621             ConcurrentJSLocker locker(m_codeBlock-&gt;m_lock);</span>
<span class="line-added">622             m_codeBlock-&gt;jitCode()-&gt;shrinkToFit(locker);</span>
<span class="line-added">623             m_codeBlock-&gt;shrinkToFit(locker, CodeBlock::ShrinkMode::LateShrink);</span>
<span class="line-added">624         }</span>
625 
626         if (validationEnabled()) {
627             TrackedReferences trackedReferences;
628 
629             for (WriteBarrier&lt;JSCell&gt;&amp; reference : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakReferences)
630                 trackedReferences.add(reference.get());
<span class="line-modified">631             for (StructureID structureID : m_codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;weakStructureReferences)</span>
<span class="line-modified">632                 trackedReferences.add(m_vm-&gt;getStructure(structureID));</span>
633             for (WriteBarrier&lt;Unknown&gt;&amp; constant : m_codeBlock-&gt;constants())
634                 trackedReferences.add(constant.get());
635 
636             for (auto* inlineCallFrame : *m_inlineCallFrames) {
637                 ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
638                 trackedReferences.add(inlineCallFrame-&gt;baselineCodeBlock.get());
639             }
640 
641             // Check that any other references that we have anywhere in the JITCode are also
642             // tracked either strongly or weakly.
643             m_codeBlock-&gt;jitCode()-&gt;validateReferences(trackedReferences);
644         }
645 
646         CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;dfgFinalize&quot;, (&quot;succeeded&quot;));
647         return CompilationSuccessful;
648     }();
649 
650     // We will establish new references from the code block to things. So, we need a barrier.
651     m_vm-&gt;heap.writeBarrier(m_codeBlock);
652     return result;
</pre>
<hr />
<pre>
657     m_callback-&gt;compilationDidComplete(m_codeBlock, m_profiledDFGCodeBlock, finalizeWithoutNotifyingCallback());
658 }
659 
660 CompilationKey Plan::key()
661 {
662     return CompilationKey(m_codeBlock-&gt;alternative(), m_mode);
663 }
664 
665 void Plan::checkLivenessAndVisitChildren(SlotVisitor&amp; visitor)
666 {
667     if (!isKnownToBeLiveDuringGC())
668         return;
669 
670     cleanMustHandleValuesIfNecessary();
671     for (unsigned i = m_mustHandleValues.size(); i--;) {
672         Optional&lt;JSValue&gt; value = m_mustHandleValues[i];
673         if (value)
674             visitor.appendUnbarriered(value.value());
675     }
676 
<span class="line-added">677     m_recordedStatuses.visitAggregate(visitor);</span>
678     m_recordedStatuses.markIfCheap(visitor);
679 
680     visitor.appendUnbarriered(m_codeBlock);
681     visitor.appendUnbarriered(m_codeBlock-&gt;alternative());
682     visitor.appendUnbarriered(m_profiledDFGCodeBlock);
683 
684     if (m_inlineCallFrames) {
685         for (auto* inlineCallFrame : *m_inlineCallFrames) {
686             ASSERT(inlineCallFrame-&gt;baselineCodeBlock.get());
687             visitor.appendUnbarriered(inlineCallFrame-&gt;baselineCodeBlock.get());
688         }
689     }
690 
691     m_weakReferences.visitChildren(visitor);
692     m_transitions.visitChildren(visitor);
693 }
694 
695 void Plan::finalizeInGC()
696 {
697     ASSERT(m_vm);
698     m_recordedStatuses.finalizeWithoutDeleting(*m_vm);
699 }
700 
701 bool Plan::isKnownToBeLiveDuringGC()
702 {
703     if (m_stage == Cancelled)
704         return false;
705     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;ownerExecutable()))
706         return false;
707     if (!m_vm-&gt;heap.isMarked(m_codeBlock-&gt;alternative()))
708         return false;
709     if (!!m_profiledDFGCodeBlock &amp;&amp; !m_vm-&gt;heap.isMarked(m_profiledDFGCodeBlock))
710         return false;
711     return true;
712 }
713 
714 void Plan::cancel()
715 {
<span class="line-added">716     RELEASE_ASSERT(m_stage != Cancelled);</span>
<span class="line-added">717     ASSERT(m_vm);</span>
718     m_vm = nullptr;
<span class="line-added">719 </span>
720     m_codeBlock = nullptr;
721     m_profiledDFGCodeBlock = nullptr;
722     m_mustHandleValues.clear();
723     m_compilation = nullptr;
724     m_finalizer = nullptr;
725     m_inlineCallFrames = nullptr;
726     m_watchpoints = DesiredWatchpoints();
727     m_identifiers = DesiredIdentifiers();
728     m_globalProperties = DesiredGlobalProperties();
729     m_weakReferences = DesiredWeakReferences();
730     m_transitions = DesiredTransitions();
731     m_callback = nullptr;
732     m_stage = Cancelled;
733 }
734 
735 void Plan::cleanMustHandleValuesIfNecessary()
736 {
737     LockHolder locker(m_mustHandleValueCleaningLock);
738 
739     if (!m_mustHandleValuesMayIncludeGarbage)
740         return;
741 
742     m_mustHandleValuesMayIncludeGarbage = false;
743 
744     if (!m_codeBlock)
745         return;
746 
747     if (!m_mustHandleValues.numberOfLocals())
748         return;
749 
750     CodeBlock* alternative = m_codeBlock-&gt;alternative();
<span class="line-modified">751     FastBitVector liveness = alternative-&gt;livenessAnalysis().getLivenessInfoAtBytecodeIndex(alternative, m_osrEntryBytecodeIndex);</span>
752 
753     for (unsigned local = m_mustHandleValues.numberOfLocals(); local--;) {
754         if (!liveness[local])
755             m_mustHandleValues.local(local) = WTF::nullopt;
756     }
757 }
758 
759 } } // namespace JSC::DFG
760 
761 #endif // ENABLE(DFG_JIT)
762 
</pre>
</td>
</tr>
</table>
<center><a href="DFGPhantomInsertionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPlan.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
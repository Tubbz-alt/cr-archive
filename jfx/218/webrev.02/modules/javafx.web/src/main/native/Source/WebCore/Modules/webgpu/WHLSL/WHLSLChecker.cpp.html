<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WHLSLChecker.h&quot;
  28 
  29 #if ENABLE(WEBGPU)
  30 
  31 #include &quot;WHLSLArrayReferenceType.h&quot;
  32 #include &quot;WHLSLArrayType.h&quot;
  33 #include &quot;WHLSLAssignmentExpression.h&quot;
  34 #include &quot;WHLSLCallExpression.h&quot;
  35 #include &quot;WHLSLCommaExpression.h&quot;
  36 #include &quot;WHLSLDereferenceExpression.h&quot;
  37 #include &quot;WHLSLDoWhileLoop.h&quot;
  38 #include &quot;WHLSLDotExpression.h&quot;
  39 #include &quot;WHLSLEntryPointType.h&quot;
  40 #include &quot;WHLSLForLoop.h&quot;
  41 #include &quot;WHLSLGatherEntryPointItems.h&quot;
  42 #include &quot;WHLSLIfStatement.h&quot;
  43 #include &quot;WHLSLIndexExpression.h&quot;
  44 #include &quot;WHLSLInferTypes.h&quot;
  45 #include &quot;WHLSLLogicalExpression.h&quot;
  46 #include &quot;WHLSLLogicalNotExpression.h&quot;
  47 #include &quot;WHLSLMakeArrayReferenceExpression.h&quot;
  48 #include &quot;WHLSLMakePointerExpression.h&quot;
  49 #include &quot;WHLSLNameContext.h&quot;
  50 #include &quot;WHLSLPointerType.h&quot;
  51 #include &quot;WHLSLProgram.h&quot;
  52 #include &quot;WHLSLReadModifyWriteExpression.h&quot;
  53 #include &quot;WHLSLResolvableType.h&quot;
  54 #include &quot;WHLSLResolveOverloadImpl.h&quot;
  55 #include &quot;WHLSLResolvingType.h&quot;
  56 #include &quot;WHLSLReturn.h&quot;
  57 #include &quot;WHLSLSwitchStatement.h&quot;
  58 #include &quot;WHLSLTernaryExpression.h&quot;
  59 #include &quot;WHLSLVisitor.h&quot;
  60 #include &quot;WHLSLWhileLoop.h&quot;
  61 #include &lt;wtf/HashMap.h&gt;
  62 #include &lt;wtf/HashSet.h&gt;
  63 #include &lt;wtf/Ref.h&gt;
  64 #include &lt;wtf/Vector.h&gt;
  65 #include &lt;wtf/text/WTFString.h&gt;
  66 
  67 namespace WebCore {
  68 
  69 namespace WHLSL {
  70 
  71 class PODChecker : public Visitor {
  72 public:
  73     PODChecker() = default;
  74 
  75     virtual ~PODChecker() = default;
  76 
  77     void visit(AST::EnumerationDefinition&amp; enumerationDefinition) override
  78     {
  79         Visitor::visit(enumerationDefinition);
  80     }
  81 
  82     void visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration) override
  83     {
  84         if (!nativeTypeDeclaration.isNumber()
  85             &amp;&amp; !nativeTypeDeclaration.isVector()
  86             &amp;&amp; !nativeTypeDeclaration.isMatrix())
  87             setError(Error(&quot;Use of native type is not a POD in entrypoint semantic.&quot;, nativeTypeDeclaration.codeLocation()));
  88     }
  89 
  90     void visit(AST::StructureDefinition&amp; structureDefinition) override
  91     {
  92         Visitor::visit(structureDefinition);
  93     }
  94 
  95     void visit(AST::TypeDefinition&amp; typeDefinition) override
  96     {
  97         Visitor::visit(typeDefinition);
  98     }
  99 
 100     void visit(AST::ArrayType&amp; arrayType) override
 101     {
 102         Visitor::visit(arrayType);
 103     }
 104 
 105     void visit(AST::PointerType&amp; pointerType) override
 106     {
 107         setError(Error(&quot;Illegal use of pointer in entrypoint semantic.&quot;, pointerType.codeLocation()));
 108     }
 109 
 110     void visit(AST::ArrayReferenceType&amp; arrayReferenceType) override
 111     {
 112         setError(Error(&quot;Illegal use of array reference in entrypoint semantic.&quot;, arrayReferenceType.codeLocation()));
 113     }
 114 
 115     void visit(AST::TypeReference&amp; typeReference) override
 116     {
 117         checkErrorAndVisit(typeReference.resolvedType());
 118     }
 119 };
 120 
 121 class FunctionKey {
 122 public:
 123     FunctionKey() = default;
 124     FunctionKey(WTF::HashTableDeletedValueType)
 125     {
 126         m_castReturnType = bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));
 127     }
 128 
 129     FunctionKey(String name, Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types, AST::NamedType* castReturnType = nullptr)
 130         : m_name(WTFMove(name))
 131         , m_types(WTFMove(types))
 132         , m_castReturnType(castReturnType)
 133     { }
 134 
 135     bool isEmptyValue() const { return m_name.isNull(); }
 136     bool isHashTableDeletedValue() const { return m_castReturnType == bitwise_cast&lt;AST::NamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }
 137 
 138     unsigned hash() const
 139     {
 140         unsigned hash = IntHash&lt;size_t&gt;::hash(m_types.size());
 141         hash ^= m_name.hash();
 142         for (size_t i = 0; i &lt; m_types.size(); ++i)
 143             hash ^= m_types[i].get().hash() + i;
 144 
 145         if (m_castReturnType)
 146             hash ^= WTF::PtrHash&lt;AST::Type*&gt;::hash(&amp;m_castReturnType-&gt;unifyNode());
 147 
 148         return hash;
 149     }
 150 
 151     bool operator==(const FunctionKey&amp; other) const
 152     {
 153         if (m_types.size() != other.m_types.size())
 154             return false;
 155 
 156         if (m_name != other.m_name)
 157             return false;
 158 
 159         for (size_t i = 0; i &lt; m_types.size(); ++i) {
 160             if (!matches(m_types[i].get(), other.m_types[i].get()))
 161                 return false;
 162         }
 163 
 164         if (static_cast&lt;bool&gt;(m_castReturnType) != static_cast&lt;bool&gt;(other.m_castReturnType))
 165             return false;
 166 
 167         if (!m_castReturnType)
 168             return true;
 169 
 170         if (&amp;m_castReturnType-&gt;unifyNode() == &amp;other.m_castReturnType-&gt;unifyNode())
 171             return true;
 172 
 173         return false;
 174     }
 175 
 176     struct Hash {
 177         static unsigned hash(const FunctionKey&amp; key)
 178         {
 179             return key.hash();
 180         }
 181 
 182         static bool equal(const FunctionKey&amp; a, const FunctionKey&amp; b)
 183         {
 184             return a == b;
 185         }
 186 
 187         static const bool safeToCompareToEmptyOrDeleted = false;
 188         static const bool emptyValueIsZero = false;
 189     };
 190 
 191     struct Traits : public WTF::SimpleClassHashTraits&lt;FunctionKey&gt; {
 192         static const bool hasIsEmptyValueFunction = true;
 193         static bool isEmptyValue(const FunctionKey&amp; key) { return key.isEmptyValue(); }
 194     };
 195 
 196 private:
 197     String m_name;
 198     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;
 199     AST::NamedType* m_castReturnType;
 200 };
 201 
 202 static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)
 203 {
 204     const bool isOperator = true;
 205     auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());
 206     auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 207         return unnamedType.copyRef();
 208     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 209         return secondArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
 210             return unnamedType.copyRef();
 211         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Ref&lt;AST::UnnamedType&gt; {
 212             // We encountered &quot;null == null&quot;.
 213             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198162 This can probably be generalized, using the &quot;preferred type&quot; infrastructure used by generic literals
 214             ASSERT_NOT_REACHED();
 215             return AST::TypeReference::wrap(location, intrinsics.intType());
 216         }));
 217     }));
 218     AST::VariableDeclarations parameters;
 219     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), argumentType.copyRef(), String(), nullptr, nullptr));
 220     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), WTFMove(argumentType), String(), nullptr, nullptr));
 221     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
 222 }
 223 
 224 enum class Acceptability {
 225     Yes,
 226     No
 227 };
 228 
 229 static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)
 230 {
 231     if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {
 232         auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {
 233             return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {
 234                 auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 235                 return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;
 236             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Acceptability {
 237                 return Acceptability::No;
 238             }));
 239         };
 240         auto leftAcceptability = acceptability(types[0].get());
 241         auto rightAcceptability = acceptability(types[1].get());
 242         bool success = false;
 243         if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {
 244             auto&amp; unnamedType1 = *types[0].get().getUnnamedType();
 245             auto&amp; unnamedType2 = *types[1].get().getUnnamedType();
 246             success = matches(unnamedType1, unnamedType2);
 247         }
 248         if (success)
 249             return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);
 250     }
 251     return WTF::nullopt;
 252 }
 253 
 254 static bool checkSemantics(Vector&lt;EntryPointItem&gt;&amp; inputItems, Vector&lt;EntryPointItem&gt;&amp; outputItems, const Optional&lt;AST::EntryPointType&gt;&amp; entryPointType, const Intrinsics&amp; intrinsics)
 255 {
 256     {
 257         auto checkDuplicateSemantics = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 258             for (size_t i = 0; i &lt; items.size(); ++i) {
 259                 for (size_t j = i + 1; j &lt; items.size(); ++j) {
 260                     if (items[i].semantic == items[j].semantic)
 261                         return false;
 262                 }
 263             }
 264             return true;
 265         };
 266         if (!checkDuplicateSemantics(inputItems))
 267             return false;
 268         if (!checkDuplicateSemantics(outputItems))
 269             return false;
 270     }
 271 
 272     {
 273         auto checkSemanticTypes = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 274             for (auto&amp; item : items) {
 275                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 276                     return semantic.isAcceptableType(*item.unnamedType, intrinsics);
 277                 }), *item.semantic);
 278                 if (!acceptable)
 279                     return false;
 280             }
 281             return true;
 282         };
 283         if (!checkSemanticTypes(inputItems))
 284             return false;
 285         if (!checkSemanticTypes(outputItems))
 286             return false;
 287     }
 288 
 289     {
 290         auto checkSemanticForShaderType = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items, AST::BaseSemantic::ShaderItemDirection direction) -&gt; bool {
 291             for (auto&amp; item : items) {
 292                 auto acceptable = WTF::visit(WTF::makeVisitor([&amp;](const AST::BaseSemantic&amp; semantic) -&gt; bool {
 293                     return semantic.isAcceptableForShaderItemDirection(direction, entryPointType);
 294                 }), *item.semantic);
 295                 if (!acceptable)
 296                     return false;
 297             }
 298             return true;
 299         };
 300         if (!checkSemanticForShaderType(inputItems, AST::BaseSemantic::ShaderItemDirection::Input))
 301             return false;
 302         if (!checkSemanticForShaderType(outputItems, AST::BaseSemantic::ShaderItemDirection::Output))
 303             return false;
 304     }
 305 
 306     {
 307         auto checkPODData = [&amp;](const Vector&lt;EntryPointItem&gt;&amp; items) -&gt; bool {
 308             for (auto&amp; item : items) {
 309                 PODChecker podChecker;
 310                 if (is&lt;AST::PointerType&gt;(item.unnamedType))
 311                     podChecker.checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(*item.unnamedType).elementType());
 312                 else if (is&lt;AST::ArrayReferenceType&gt;(item.unnamedType))
 313                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(*item.unnamedType).elementType());
 314                 else if (is&lt;AST::ArrayType&gt;(item.unnamedType))
 315                     podChecker.checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(*item.unnamedType).type());
 316                 else
 317                     continue;
 318                 if (podChecker.hasError())
 319                     return false;
 320             }
 321             return true;
 322         };
 323         if (!checkPODData(inputItems))
 324             return false;
 325         if (!checkPODData(outputItems))
 326             return false;
 327     }
 328 
 329     return true;
 330 }
 331 
 332 static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition)
 333 {
 334     enum class CheckKind {
 335         Index,
 336         Dot
 337     };
 338 
 339     if (!functionDefinition.isOperator())
 340         return true;
 341     if (functionDefinition.isCast())
 342         return true;
 343     if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
 344         return functionDefinition.parameters().size() == 1
 345             &amp;&amp; matches(*functionDefinition.parameters()[0]-&gt;type(), functionDefinition.type());
 346     }
 347     if (functionDefinition.name() == &quot;operator+&quot; || functionDefinition.name() == &quot;operator-&quot;)
 348         return functionDefinition.parameters().size() == 1 || functionDefinition.parameters().size() == 2;
 349     if (functionDefinition.name() == &quot;operator*&quot;
 350         || functionDefinition.name() == &quot;operator/&quot;
 351         || functionDefinition.name() == &quot;operator%&quot;
 352         || functionDefinition.name() == &quot;operator&amp;&quot;
 353         || functionDefinition.name() == &quot;operator|&quot;
 354         || functionDefinition.name() == &quot;operator^&quot;
 355         || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
 356         || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)
 357         return functionDefinition.parameters().size() == 2;
 358     if (functionDefinition.name() == &quot;operator~&quot;)
 359         return functionDefinition.parameters().size() == 1;
 360     return false;
 361 }
 362 
 363 class Checker : public Visitor {
 364 public:
 365     Checker(const Intrinsics&amp; intrinsics, Program&amp; program)
 366         : m_intrinsics(intrinsics)
 367         , m_program(program)
 368     {
 369         auto addFunction = [&amp;] (AST::FunctionDeclaration&amp; function) {
 370             AST::NamedType* castReturnType = nullptr;
 371             if (function.isCast() &amp;&amp; is&lt;AST::NamedType&gt;(function.type().unifyNode()))
 372                 castReturnType = &amp;downcast&lt;AST::NamedType&gt;(function.type().unifyNode());
 373 
 374             Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; types;
 375             types.reserveInitialCapacity(function.parameters().size());
 376 
 377             for (auto&amp; param : function.parameters())
 378                 types.uncheckedAppend(normalizedTypeForFunctionKey(*param-&gt;type()));
 379 
 380             auto addResult = m_functions.add(FunctionKey { function.name(), WTFMove(types), castReturnType }, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;());
 381             addResult.iterator-&gt;value.append(function);
 382         };
 383 
 384         for (auto&amp; function : m_program.functionDefinitions())
 385             addFunction(function.get());
 386         for (auto&amp; function : m_program.nativeFunctionDeclarations())
 387             addFunction(function.get());
 388     }
 389 
 390     virtual ~Checker() = default;
 391 
 392     void visit(Program&amp;) override;
 393 
 394     Expected&lt;void, Error&gt; assignTypes();
 395 
 396 private:
 397     bool checkShaderType(const AST::FunctionDefinition&amp;);
 398     bool isBoolType(ResolvingType&amp;);
 399     struct RecurseInfo {
 400         ResolvingType&amp; resolvingType;
 401         const AST::TypeAnnotation typeAnnotation;
 402     };
 403     Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 404     Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);
 405     RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);
 406     bool recurseAndRequireBoolType(AST::Expression&amp;);
 407     void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);
 408     void assignConcreteType(AST::Expression&amp;, AST::NamedType&amp;, AST::TypeAnnotation);
 409     void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);
 410     void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);
 411 
 412     void visit(AST::FunctionDefinition&amp;) override;
 413     void visit(AST::FunctionDeclaration&amp;) override;
 414     void visit(AST::EnumerationDefinition&amp;) override;
 415     void visit(AST::TypeReference&amp;) override;
 416     void visit(AST::VariableDeclaration&amp;) override;
 417     void visit(AST::AssignmentExpression&amp;) override;
 418     void visit(AST::ReadModifyWriteExpression&amp;) override;
 419     void visit(AST::DereferenceExpression&amp;) override;
 420     void visit(AST::MakePointerExpression&amp;) override;
 421     void visit(AST::MakeArrayReferenceExpression&amp;) override;
 422     void visit(AST::DotExpression&amp;) override;
 423     void visit(AST::IndexExpression&amp;) override;
 424     void visit(AST::VariableReference&amp;) override;
 425     void visit(AST::Return&amp;) override;
 426     void visit(AST::PointerType&amp;) override;
 427     void visit(AST::ArrayReferenceType&amp;) override;
 428     void visit(AST::IntegerLiteral&amp;) override;
 429     void visit(AST::UnsignedIntegerLiteral&amp;) override;
 430     void visit(AST::FloatLiteral&amp;) override;
 431     void visit(AST::BooleanLiteral&amp;) override;
 432     void visit(AST::EnumerationMemberLiteral&amp;) override;
 433     void visit(AST::LogicalNotExpression&amp;) override;
 434     void visit(AST::LogicalExpression&amp;) override;
 435     void visit(AST::IfStatement&amp;) override;
 436     void visit(AST::WhileLoop&amp;) override;
 437     void visit(AST::DoWhileLoop&amp;) override;
 438     void visit(AST::ForLoop&amp;) override;
 439     void visit(AST::SwitchStatement&amp;) override;
 440     void visit(AST::CommaExpression&amp;) override;
 441     void visit(AST::TernaryExpression&amp;) override;
 442     void visit(AST::CallExpression&amp;) override;
 443 
 444     AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);
 445 
 446     AST::UnnamedType&amp; wrappedFloatType()
 447     {
 448         if (!m_wrappedFloatType)
 449             m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());
 450         return *m_wrappedFloatType;
 451     }
 452 
 453     AST::UnnamedType&amp; wrappedUintType()
 454     {
 455         if (!m_wrappedUintType)
 456             m_wrappedUintType = AST::TypeReference::wrap({ }, m_intrinsics.uintType());
 457         return *m_wrappedUintType;
 458     }
 459 
 460     AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)
 461     {
 462         auto* unifyNode = &amp;type.unifyNode();
 463         if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())
 464             return wrappedFloatType();
 465 
 466         return type;
 467     }
 468 
 469     RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;
 470     RefPtr&lt;AST::TypeReference&gt; m_wrappedUintType;
 471     HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;
 472     HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];
 473     HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];
 474     HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];
 475     const Intrinsics&amp; m_intrinsics;
 476     Program&amp; m_program;
 477     AST::FunctionDefinition* m_currentFunction { nullptr };
 478     HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;
 479     AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };
 480     bool m_isVisitingParameters { false };
 481 };
 482 
 483 void Checker::visit(Program&amp; program)
 484 {
 485     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 486     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 487         checkErrorAndVisit(program.typeDefinitions()[i]);
 488     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 489         checkErrorAndVisit(program.structureDefinitions()[i]);
 490     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 491         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 492     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 493         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 494 
 495     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 496         checkErrorAndVisit(program.functionDefinitions()[i]);
 497     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 498         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 499 }
 500 
 501 Expected&lt;void, Error&gt; Checker::assignTypes()
 502 {
 503     for (auto&amp; keyValuePair : m_typeMap) {
 504         auto success = keyValuePair.value-&gt;visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {
 505             keyValuePair.key-&gt;setType(unnamedType.copyRef());
 506             return true;
 507         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {
 508             if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType()) {
 509                 if (!static_cast&lt;bool&gt;(commit(resolvableTypeReference-&gt;resolvableType())))
 510                     return false;
 511             }
 512             keyValuePair.key-&gt;setType(resolvableTypeReference-&gt;resolvableType().resolvedType());
 513             return true;
 514         }));
 515         if (!success)
 516             return makeUnexpected(Error(&quot;Could not resolve the type of a constant.&quot;));
 517     }
 518 
 519     return { };
 520 }
 521 
 522 bool Checker::checkShaderType(const AST::FunctionDefinition&amp; functionDefinition)
 523 {
 524     auto index = static_cast&lt;unsigned&gt;(m_currentNameSpace);
 525     switch (*functionDefinition.entryPointType()) {
 526     case AST::EntryPointType::Vertex:
 527         return static_cast&lt;bool&gt;(m_vertexEntryPoints[index].add(functionDefinition.name()));
 528     case AST::EntryPointType::Fragment:
 529         return static_cast&lt;bool&gt;(m_fragmentEntryPoints[index].add(functionDefinition.name()));
 530     case AST::EntryPointType::Compute:
 531         return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));
 532     }
 533 }
 534 
 535 void Checker::visit(AST::FunctionDeclaration&amp; functionDeclaration)
 536 {
 537     m_isVisitingParameters = true;
 538     Visitor::visit(functionDeclaration);
 539     m_isVisitingParameters = false;
 540 }
 541 
 542 void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
 543 {
 544     m_currentNameSpace = functionDefinition.nameSpace();
 545     m_currentFunction = &amp;functionDefinition;
 546     if (functionDefinition.entryPointType()) {
 547         if (!checkShaderType(functionDefinition)) {
 548             setError(Error(&quot;Duplicate entrypoint function.&quot;, functionDefinition.codeLocation()));
 549             return;
 550         }
 551         auto entryPointItems = gatherEntryPointItems(m_intrinsics, functionDefinition);
 552         if (!entryPointItems) {
 553             setError(entryPointItems.error());
 554             return;
 555         }
 556         if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
 557             setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));
 558             return;
 559         }
 560     }
 561     if (!checkOperatorOverload(functionDefinition)) {
 562         setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));
 563         return;
 564     }
 565 
 566     Visitor::visit(functionDefinition);
 567 }
 568 
 569 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; left, ResolvingType&amp; right)
 570 {
 571     return left.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 572         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 573             if (matches(left, right))
 574                 return left.copyRef();
 575             return nullptr;
 576         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 577             return matchAndCommit(left, right-&gt;resolvableType());
 578         }));
 579     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 580         return right.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 581             return matchAndCommit(right, left-&gt;resolvableType());
 582         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; right) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 583             return matchAndCommit(left-&gt;resolvableType(), right-&gt;resolvableType());
 584         }));
 585     }));
 586 }
 587 
 588 static RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(ResolvingType&amp; resolvingType, AST::UnnamedType&amp; unnamedType)
 589 {
 590     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 591         if (matches(unnamedType, resolvingType))
 592             return &amp;unnamedType;
 593         return nullptr;
 594     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 595         return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
 596     }));
 597 }
 598 
 599 static bool matchAndCommit(ResolvingType&amp; resolvingType, AST::NamedType&amp; namedType)
 600 {
 601     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) {
 602         if (matches(resolvingType, namedType))
 603             return true;
 604         return false;
 605     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; bool {
 606         return matchAndCommit(namedType, resolvingType-&gt;resolvableType());
 607     }));
 608 }
 609 
 610 static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)
 611 {
 612     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 613         return unnamedType.copyRef();
 614     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
 615         if (!resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 616             return commit(resolvableTypeReference-&gt;resolvableType());
 617         return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 618     }));
 619 }
 620 
 621 AST::FunctionDeclaration* Checker::resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation location, AST::NamedType* castReturnType)
 622 {
 623     Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; unnamedTypes;
 624     unnamedTypes.reserveInitialCapacity(types.size());
 625 
 626     for (auto resolvingType : types) {
 627         AST::UnnamedType* type = resolvingType.get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {
 628             return unnamedType.ptr();
 629         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; AST::UnnamedType* {
 630             if (resolvableTypeReference-&gt;resolvableType().maybeResolvedType())
 631                 return &amp;resolvableTypeReference-&gt;resolvableType().resolvedType();
 632 
 633             if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()
 634                 || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()
 635                 || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())
 636                 return &amp;wrappedFloatType();
 637 
 638             return commit(resolvableTypeReference-&gt;resolvableType()).get();
 639         }));
 640 
 641         if (!type) {
 642             setError(Error(&quot;Could not resolve the type of a constant.&quot;));
 643             return nullptr;
 644         }
 645 
 646         unnamedTypes.uncheckedAppend(normalizedTypeForFunctionKey(*type));
 647     }
 648 
 649     {
 650         auto iter = m_functions.find(FunctionKey { name, WTFMove(unnamedTypes), castReturnType });
 651         if (iter != m_functions.end()) {
 652             if (AST::FunctionDeclaration* function = resolveFunctionOverload(iter-&gt;value, types, castReturnType, m_currentNameSpace))
 653                 return function;
 654         }
 655     }
 656 
 657     if (auto newFunction = resolveByInstantiation(name, location, types, m_intrinsics)) {
 658         m_program.append(WTFMove(*newFunction));
 659         return &amp;m_program.nativeFunctionDeclarations().last();
 660     }
 661 
 662     return nullptr;
 663 }
 664 
 665 void Checker::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 666 {
 667     bool isSigned;
 668     auto* baseType = ([&amp;]() -&gt; AST::NativeTypeDeclaration* {
 669         checkErrorAndVisit(enumerationDefinition.type());
 670         auto&amp; baseType = enumerationDefinition.type().unifyNode();
 671         if (!is&lt;AST::NamedType&gt;(baseType))
 672             return nullptr;
 673         auto&amp; namedType = downcast&lt;AST::NamedType&gt;(baseType);
 674         if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))
 675             return nullptr;
 676         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);
 677         if (!nativeTypeDeclaration.isInt())
 678             return nullptr;
 679         isSigned = nativeTypeDeclaration.isSigned();
 680         return &amp;nativeTypeDeclaration;
 681     })();
 682     if (!baseType) {
 683         setError(Error(&quot;Invalid base type for enum.&quot;, enumerationDefinition.codeLocation()));
 684         return;
 685     }
 686 
 687     auto enumerationMembers = enumerationDefinition.enumerationMembers();
 688 
 689     for (auto&amp; member : enumerationMembers) {
 690         int64_t value = member.get().value();
 691         if (isSigned) {
 692             if (static_cast&lt;int64_t&gt;(static_cast&lt;int32_t&gt;(value)) != value) {
 693                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));
 694                 return;
 695             }
 696         } else {
 697             if (static_cast&lt;int64_t&gt;(static_cast&lt;uint32_t&gt;(value)) != value) {
 698                 setError(Error(&quot;Invalid enumeration value.&quot;, member.get().codeLocation()));
 699                 return;
 700             }
 701         }
 702     }
 703 
 704     for (size_t i = 0; i &lt; enumerationMembers.size(); ++i) {
 705         auto value = enumerationMembers[i].get().value();
 706         for (size_t j = i + 1; j &lt; enumerationMembers.size(); ++j) {
 707             auto otherValue = enumerationMembers[j].get().value();
 708             if (value == otherValue) {
 709                 setError(Error(&quot;Cannot declare duplicate enumeration values.&quot;, enumerationMembers[j].get().codeLocation()));
 710                 return;
 711             }
 712         }
 713     }
 714 
 715     bool foundZero = false;
 716     for (auto&amp; member : enumerationMembers) {
 717         if (!member.get().value()) {
 718             foundZero = true;
 719             break;
 720         }
 721     }
 722     if (!foundZero) {
 723         setError(Error(&quot;enum definition must contain a zero value.&quot;, enumerationDefinition.codeLocation()));
 724         return;
 725     }
 726 }
 727 
 728 void Checker::visit(AST::TypeReference&amp; typeReference)
 729 {
 730     ASSERT(typeReference.maybeResolvedType());
 731 
 732     for (auto&amp; typeArgument : typeReference.typeArguments())
 733         checkErrorAndVisit(typeArgument);
 734 }
 735 
 736 auto Checker::recurseAndGetInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;
 737 {
 738     Visitor::visit(expression);
 739     if (hasError())
 740         return WTF::nullopt;
 741     return getInfo(expression, requiresLeftValue);
 742 }
 743 
 744 auto Checker::getInfo(AST::Expression&amp; expression, bool requiresLeftValue) -&gt; Optional&lt;RecurseInfo&gt;
 745 {
 746     auto typeIterator = m_typeMap.find(&amp;expression);
 747     ASSERT(typeIterator != m_typeMap.end());
 748 
 749     const auto&amp; typeAnnotation = expression.typeAnnotation();
 750     if (requiresLeftValue &amp;&amp; typeAnnotation.isRightValue()) {
 751         setError(Error(&quot;Unexpected rvalue.&quot;, expression.codeLocation()));
 752         return WTF::nullopt;
 753     }
 754     return {{ *typeIterator-&gt;value, typeAnnotation }};
 755 }
 756 
 757 void Checker::visit(AST::VariableDeclaration&amp; variableDeclaration)
 758 {
 759     // ReadModifyWriteExpressions are the only place where anonymous variables exist,
 760     // and that doesn&#39;t recurse on the anonymous variables, so we can assume the variable has a type.
 761     checkErrorAndVisit(*variableDeclaration.type());
 762     if (matches(*variableDeclaration.type(), m_intrinsics.voidType())) {
 763         setError(Error(&quot;Variables can&#39;t have void type.&quot;, variableDeclaration.codeLocation()));
 764         return;
 765     }
 766     if (variableDeclaration.initializer()) {
 767         auto&amp; lhsType = *variableDeclaration.type();
 768         auto initializerInfo = recurseAndGetInfo(*variableDeclaration.initializer());
 769         if (!initializerInfo)
 770             return;
 771         if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
 772             setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));
 773             return;
 774         }
 775     } else if (!m_isVisitingParameters &amp;&amp; is&lt;AST::ReferenceType&gt;(variableDeclaration.type()-&gt;unifyNode())) {
 776         if (is&lt;AST::PointerType&gt;(variableDeclaration.type()-&gt;unifyNode()))
 777             setError(Error(&quot;Must assign to a pointer variable declaration in its initializer.&quot;, variableDeclaration.codeLocation()));
 778         else {
 779             ASSERT(is&lt;AST::ArrayReferenceType&gt;(variableDeclaration.type()-&gt;unifyNode()));
 780             setError(Error(&quot;Must assign to an array reference variable declaration in its initializer.&quot;, variableDeclaration.codeLocation()));
 781         }
 782         return;
 783     }
 784 }
 785 
 786 void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 787 {
 788     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));
 789     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 790     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 791 }
 792 
 793 void Checker::assignConcreteType(AST::Expression&amp; expression, AST::NamedType&amp; type, AST::TypeAnnotation annotation)
 794 {
 795     auto unnamedType = AST::TypeReference::wrap(type.codeLocation(), type);
 796     Visitor::visit(unnamedType);
 797     assignConcreteType(expression, WTFMove(unnamedType), annotation);
 798 }
 799 
 800 void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 801 {
 802     auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));
 803     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 804     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 805 }
 806 
 807 void Checker::forwardType(AST::Expression&amp; expression, ResolvingType&amp; resolvingType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
 808 {
 809     resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; result) {
 810         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 811         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 812     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; result) {
 813         auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(result.copyRef()));
 814         ASSERT_UNUSED(addResult, addResult.isNewEntry);
 815     }));
 816     expression.setTypeAnnotation(WTFMove(typeAnnotation));
 817 }
 818 
 819 void Checker::visit(AST::AssignmentExpression&amp; assignmentExpression)
 820 {
 821     auto leftInfo = recurseAndGetInfo(assignmentExpression.left(), true);
 822     if (!leftInfo)
 823         return;
 824 
 825     auto rightInfo = recurseAndGetInfo(assignmentExpression.right());
 826     if (!rightInfo)
 827         return;
 828 
 829     auto resultType = matchAndCommit(leftInfo-&gt;resolvingType, rightInfo-&gt;resolvingType);
 830     if (!resultType) {
 831         setError(Error(&quot;Left hand side of assignment does not match the type of the right hand side.&quot;, assignmentExpression.codeLocation()));
 832         return;
 833     }
 834 
 835     assignConcreteType(assignmentExpression, *resultType);
 836 }
 837 
 838 void Checker::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
 839 {
 840     auto leftValueInfo = recurseAndGetInfo(readModifyWriteExpression.leftValue(), true);
 841     if (!leftValueInfo)
 842         return;
 843 
 844     readModifyWriteExpression.oldValue().setType(*leftValueInfo-&gt;resolvingType.getUnnamedType());
 845 
 846     auto newValueInfo = recurseAndGetInfo(readModifyWriteExpression.newValueExpression());
 847     if (!newValueInfo)
 848         return;
 849 
 850     if (RefPtr&lt;AST::UnnamedType&gt; matchedType = matchAndCommit(leftValueInfo-&gt;resolvingType, newValueInfo-&gt;resolvingType))
 851         readModifyWriteExpression.newValue().setType(*matchedType);
 852     else {
 853         setError(Error(&quot;Base of the read-modify-write expression does not match the type of the new value.&quot;, readModifyWriteExpression.codeLocation()));
 854         return;
 855     }
 856 
 857     auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());
 858     if (!resultInfo)
 859         return;
 860 
 861     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType, AST::RightValue());
 862 }
 863 
 864 static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
 865 {
 866     return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {
 867         return type.ptr();
 868     }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; type) -&gt; AST::UnnamedType* {
 869         // FIXME: If the type isn&#39;t committed, should we just commit() it now?
 870         return type-&gt;resolvableType().maybeResolvedType();
 871     }));
 872 }
 873 
 874 void Checker::visit(AST::DereferenceExpression&amp; dereferenceExpression)
 875 {
 876     auto pointerInfo = recurseAndGetInfo(dereferenceExpression.pointer());
 877     if (!pointerInfo)
 878         return;
 879 
 880     auto* unnamedType = getUnnamedType(pointerInfo-&gt;resolvingType);
 881 
 882     auto* pointerType = ([&amp;](AST::UnnamedType* unnamedType) -&gt; AST::PointerType* {
 883         if (!unnamedType)
 884             return nullptr;
 885         auto&amp; unifyNode = unnamedType-&gt;unifyNode();
 886         if (!is&lt;AST::UnnamedType&gt;(unifyNode))
 887             return nullptr;
 888         auto&amp; unnamedUnifyType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 889         if (!is&lt;AST::PointerType&gt;(unnamedUnifyType))
 890             return nullptr;
 891         return &amp;downcast&lt;AST::PointerType&gt;(unnamedUnifyType);
 892     })(unnamedType);
 893     if (!pointerType) {
 894         setError(Error(&quot;Cannot dereference a non-pointer type.&quot;, dereferenceExpression.codeLocation()));
 895         return;
 896     }
 897 
 898     assignConcreteType(dereferenceExpression, pointerType-&gt;elementType(), AST::LeftValue { pointerType-&gt;addressSpace() });
 899 }
 900 
 901 void Checker::visit(AST::MakePointerExpression&amp; makePointerExpression)
 902 {
 903     auto leftValueInfo = recurseAndGetInfo(makePointerExpression.leftValue(), true);
 904     if (!leftValueInfo)
 905         return;
 906 
 907     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
 908     if (!leftAddressSpace) {
 909         setError(Error(&quot;Cannot take the address of a non lvalue.&quot;, makePointerExpression.codeLocation()));
 910         return;
 911     }
 912 
 913     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);
 914     if (!leftValueType) {
 915         setError(Error(&quot;Cannot take the address of a value without a type.&quot;, makePointerExpression.codeLocation()));
 916         return;
 917     }
 918 
 919     assignConcreteType(makePointerExpression, AST::PointerType::create(makePointerExpression.codeLocation(), *leftAddressSpace, *leftValueType));
 920 }
 921 
 922 void Checker::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
 923 {
 924     auto leftValueInfo = recurseAndGetInfo(makeArrayReferenceExpression.leftValue());
 925     if (!leftValueInfo)
 926         return;
 927 
 928     auto* leftValueType = getUnnamedType(leftValueInfo-&gt;resolvingType);
 929     if (!leftValueType) {
 930         setError(Error(&quot;Cannot make an array reference of a value without a type.&quot;, makeArrayReferenceExpression.codeLocation()));
 931         return;
 932     }
 933 
 934     auto&amp; unifyNode = leftValueType-&gt;unifyNode();
 935     if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
 936         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
 937         if (is&lt;AST::PointerType&gt;(unnamedType)) {
 938             auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
 939             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));
 940             return;
 941         }
 942 
 943         auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
 944         if (!leftAddressSpace) {
 945             setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
 946             return;
 947         }
 948 
 949         if (is&lt;AST::ArrayType&gt;(unnamedType)) {
 950             auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(unnamedType);
 951             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the number of elements.
 952             assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, arrayType.type()));
 953             return;
 954         }
 955     }
 956 
 957     auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
 958     if (!leftAddressSpace) {
 959         setError(Error(&quot;Cannot make an array reference from a non-left-value.&quot;, makeArrayReferenceExpression.codeLocation()));
 960         return;
 961     }
 962 
 963     assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));
 964 }
 965 
 966 void Checker::visit(AST::DotExpression&amp; dotExpression)
 967 {
 968     auto baseInfo = recurseAndGetInfo(dotExpression.base());
 969     if (!baseInfo)
 970         return;
 971 
 972     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);
 973     if (!baseUnnamedType) {
 974         setError(Error(&quot;Cannot resolve the type of the base of a dot expression.&quot;, dotExpression.codeLocation()));
 975         return;
 976     }
 977 
 978     auto&amp; type = baseUnnamedType-&gt;unifyNode();
 979     if (is&lt;AST::StructureDefinition&gt;(type)) {
 980         auto&amp; structure = downcast&lt;AST::StructureDefinition&gt;(type);
 981         if (AST::StructureElement* element = structure.find(dotExpression.fieldName()))
 982             assignConcreteType(dotExpression, element-&gt;type(), baseInfo-&gt;typeAnnotation);
 983         else {
 984             setError(Error(makeString(&quot;Field name: &#39;&quot;, dotExpression.fieldName(), &quot;&#39; does not exist on structure: &quot;, structure.name()), dotExpression.codeLocation()));
 985             return;
 986         }
 987     } else if (dotExpression.fieldName() == &quot;length&quot;) {
 988         if (is&lt;AST::ArrayReferenceType&gt;(type)
 989             || is&lt;AST::ArrayType&gt;(type)
 990             || (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector())) {
 991             assignConcreteType(dotExpression, wrappedUintType(), AST::RightValue());
 992         } else {
 993             setError(Error(&quot;.length field is only available on arrays, array references, or vectors.&quot;, dotExpression.codeLocation()));
 994             return;
 995         }
 996     } else if (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector()) {
 997         if (!m_program.isValidVectorProperty(dotExpression.fieldName())) {
 998             setError(Error(makeString(&quot;&#39;.&quot;, dotExpression.fieldName(), &quot;&#39; is not a valid property on a vector.&quot;), dotExpression.codeLocation()));
 999             return;
1000         }
1001 
1002         auto typeAnnotation = baseInfo-&gt;typeAnnotation.isRightValue() ? AST::TypeAnnotation { AST::RightValue() } : AST::TypeAnnotation { AST::AbstractLeftValue() };
1003 
1004         size_t fieldLength = dotExpression.fieldName().length();
1005         auto&amp; innerType = downcast&lt;AST::NativeTypeDeclaration&gt;(type).vectorTypeArgument();
1006         if (fieldLength == 1)
1007             assignConcreteType(dotExpression, innerType, typeAnnotation);
1008         else {
1009             if (matches(innerType, m_intrinsics.boolType()))
1010                 assignConcreteType(dotExpression, m_intrinsics.boolVectorTypeForSize(fieldLength), typeAnnotation);
1011             else if (matches(innerType, m_intrinsics.intType()))
1012                 assignConcreteType(dotExpression, m_intrinsics.intVectorTypeForSize(fieldLength), typeAnnotation);
1013             else if (matches(innerType, m_intrinsics.uintType()))
1014                 assignConcreteType(dotExpression, m_intrinsics.uintVectorTypeForSize(fieldLength), typeAnnotation);
1015             else if (matches(innerType, m_intrinsics.floatType()))
1016                 assignConcreteType(dotExpression, m_intrinsics.floatVectorTypeForSize(fieldLength), typeAnnotation);
1017             else
1018                 RELEASE_ASSERT_NOT_REACHED();
1019         }
1020     } else
1021         setError(Error(&quot;Base value of dot expression must be a structure, array, or vector.&quot;, dotExpression.codeLocation()));
1022 }
1023 
1024 void Checker::visit(AST::IndexExpression&amp; indexExpression)
1025 {
1026     {
1027         auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());
1028         if (!indexInfo)
1029             return;
1030 
1031         if (!matchAndCommit(indexInfo-&gt;resolvingType, m_intrinsics.uintType())) {
1032             setError(Error(&quot;Index in an index expression must be a uint.&quot;, indexExpression.codeLocation()));
1033             return;
1034         }
1035     }
1036 
1037     auto baseInfo = recurseAndGetInfo(indexExpression.base());
1038     if (!baseInfo)
1039         return;
1040 
1041     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);
1042     if (!baseUnnamedType) {
1043         setError(Error(&quot;Cannot resolve the type of the base of an index expression.&quot;, indexExpression.codeLocation()));
1044         return;
1045     }
1046 
1047     auto&amp; type = baseUnnamedType-&gt;unifyNode();
1048     if (is&lt;AST::ArrayReferenceType&gt;(type)) {
1049         auto&amp; arrayReferenceType = downcast&lt;AST::ArrayReferenceType&gt;(type);
1050         assignConcreteType(indexExpression, arrayReferenceType.elementType(), AST::LeftValue { arrayReferenceType.addressSpace() });
1051     } else if (is&lt;AST::ArrayType&gt;(type))
1052         assignConcreteType(indexExpression, downcast&lt;AST::ArrayType&gt;(type).type(), baseInfo-&gt;typeAnnotation);
1053     else if (is&lt;AST::NativeTypeDeclaration&gt;(type)) {
1054         auto&amp; nativeType = downcast&lt;AST::NativeTypeDeclaration&gt;(type);
1055         auto typeAnnotation = baseInfo-&gt;typeAnnotation.isRightValue() ? AST::TypeAnnotation { AST::RightValue() } : AST::TypeAnnotation { AST::AbstractLeftValue() };
1056         if (nativeType.isVector())
1057             assignConcreteType(indexExpression, nativeType.vectorTypeArgument(), typeAnnotation);
1058         else if (nativeType.isMatrix()) {
1059             auto&amp; innerType = nativeType.matrixTypeArgument();
1060             unsigned numRows = nativeType.numberOfMatrixRows();
1061             if (matches(innerType, m_intrinsics.boolType()))
1062                 assignConcreteType(indexExpression, m_intrinsics.boolVectorTypeForSize(numRows), typeAnnotation);
1063             else if (matches(innerType, m_intrinsics.floatType()))
1064                 assignConcreteType(indexExpression, m_intrinsics.floatVectorTypeForSize(numRows), typeAnnotation);
1065             else
1066                 RELEASE_ASSERT_NOT_REACHED();
1067         } else {
1068             setError(Error(&quot;Index expression on unknown type.&quot;, indexExpression.codeLocation()));
1069             return;
1070         }
1071     } else {
1072         setError(Error(&quot;Index expression on an unknown base type. Base type must be an array, array reference, vector, or matrix.&quot;, indexExpression.codeLocation()));
1073         return;
1074     }
1075 }
1076 
1077 void Checker::visit(AST::VariableReference&amp; variableReference)
1078 {
1079     ASSERT(variableReference.variable());
1080     ASSERT(variableReference.variable()-&gt;type());
1081 
1082     assignConcreteType(variableReference, *variableReference.variable()-&gt;type(), AST::LeftValue { AST::AddressSpace::Thread });
1083 }
1084 
1085 void Checker::visit(AST::Return&amp; returnStatement)
1086 {
1087     if (returnStatement.value()) {
1088         auto valueInfo = recurseAndGetInfo(*returnStatement.value());
1089         if (!valueInfo)
1090             return;
1091         if (!matchAndCommit(valueInfo-&gt;resolvingType, m_currentFunction-&gt;type()))
1092             setError(Error(&quot;Type of the return value must match the return type of the function.&quot;, returnStatement.codeLocation()));
1093         return;
1094     }
1095 
1096     if (!matches(m_currentFunction-&gt;type(), m_intrinsics.voidType()))
1097         setError(Error(&quot;Cannot return a value from a void function.&quot;, returnStatement.codeLocation()));
1098 }
1099 
1100 void Checker::visit(AST::PointerType&amp;)
1101 {
1102     // Following pointer types can cause infinite loops because of data structures
1103     // like linked lists.
1104     // FIXME: Make sure this function should be empty
1105 }
1106 
1107 void Checker::visit(AST::ArrayReferenceType&amp;)
1108 {
1109     // Following array reference types can cause infinite loops because of data
1110     // structures like linked lists.
1111     // FIXME: Make sure this function should be empty
1112 }
1113 
1114 void Checker::visit(AST::IntegerLiteral&amp; integerLiteral)
1115 {
1116     assignType(integerLiteral, adoptRef(*new ResolvableTypeReference(integerLiteral.type())));
1117 }
1118 
1119 void Checker::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
1120 {
1121     assignType(unsignedIntegerLiteral, adoptRef(*new ResolvableTypeReference(unsignedIntegerLiteral.type())));
1122 }
1123 
1124 void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
1125 {
1126     assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
1127 }
1128 
1129 void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
1130 {
1131     assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));
1132 }
1133 
1134 void Checker::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
1135 {
1136     ASSERT(enumerationMemberLiteral.enumerationDefinition());
1137     auto&amp; enumerationDefinition = *enumerationMemberLiteral.enumerationDefinition();
1138     assignConcreteType(enumerationMemberLiteral, AST::TypeReference::wrap(enumerationMemberLiteral.codeLocation(), enumerationDefinition));
1139 }
1140 
1141 bool Checker::isBoolType(ResolvingType&amp; resolvingType)
1142 {
1143     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; left) -&gt; bool {
1144         return matches(left, m_intrinsics.boolType());
1145     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; left) -&gt; bool {
1146         return static_cast&lt;bool&gt;(matchAndCommit(m_intrinsics.boolType(), left-&gt;resolvableType()));
1147     }));
1148 }
1149 
1150 bool Checker::recurseAndRequireBoolType(AST::Expression&amp; expression)
1151 {
1152     auto expressionInfo = recurseAndGetInfo(expression);
1153     if (!expressionInfo)
1154         return false;
1155     if (!isBoolType(expressionInfo-&gt;resolvingType)) {
1156         setError(Error(&quot;Expected bool type from expression.&quot;, expression.codeLocation()));
1157         return false;
1158     }
1159     return true;
1160 }
1161 
1162 void Checker::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
1163 {
1164     if (!recurseAndRequireBoolType(logicalNotExpression.operand()))
1165         return;
1166     assignConcreteType(logicalNotExpression, AST::TypeReference::wrap(logicalNotExpression.codeLocation(), m_intrinsics.boolType()));
1167 }
1168 
1169 void Checker::visit(AST::LogicalExpression&amp; logicalExpression)
1170 {
1171     if (!recurseAndRequireBoolType(logicalExpression.left()))
1172         return;
1173     if (!recurseAndRequireBoolType(logicalExpression.right()))
1174         return;
1175     assignConcreteType(logicalExpression, AST::TypeReference::wrap(logicalExpression.codeLocation(), m_intrinsics.boolType()));
1176 }
1177 
1178 void Checker::visit(AST::IfStatement&amp; ifStatement)
1179 {
1180     if (!recurseAndRequireBoolType(ifStatement.conditional()))
1181         return;
1182     checkErrorAndVisit(ifStatement.body());
1183     if (ifStatement.elseBody())
1184         checkErrorAndVisit(*ifStatement.elseBody());
1185 }
1186 
1187 void Checker::visit(AST::WhileLoop&amp; whileLoop)
1188 {
1189     if (!recurseAndRequireBoolType(whileLoop.conditional()))
1190         return;
1191     checkErrorAndVisit(whileLoop.body());
1192 }
1193 
1194 void Checker::visit(AST::DoWhileLoop&amp; doWhileLoop)
1195 {
1196     checkErrorAndVisit(doWhileLoop.body());
1197     recurseAndRequireBoolType(doWhileLoop.conditional());
1198 }
1199 
1200 void Checker::visit(AST::ForLoop&amp; forLoop)
1201 {
1202     checkErrorAndVisit(forLoop.initialization());
1203     if (hasError())
1204         return;
1205     if (forLoop.condition()) {
1206         if (!recurseAndRequireBoolType(*forLoop.condition()))
1207             return;
1208     }
1209     if (forLoop.increment())
1210         checkErrorAndVisit(*forLoop.increment());
1211     checkErrorAndVisit(forLoop.body());
1212 }
1213 
1214 void Checker::visit(AST::SwitchStatement&amp; switchStatement)
1215 {
1216     auto* valueType = ([&amp;]() -&gt; AST::NamedType* {
1217         auto valueInfo = recurseAndGetInfo(switchStatement.value());
1218         if (!valueInfo)
1219             return nullptr;
1220         auto* valueType = getUnnamedType(valueInfo-&gt;resolvingType);
1221         if (!valueType)
1222             return nullptr;
1223         auto&amp; valueUnifyNode = valueType-&gt;unifyNode();
1224         if (!is&lt;AST::NamedType&gt;(valueUnifyNode))
1225             return nullptr;
1226         auto&amp; valueNamedUnifyNode = downcast&lt;AST::NamedType&gt;(valueUnifyNode);
1227         if (!(is&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(valueNamedUnifyNode).isInt())
1228             &amp;&amp; !is&lt;AST::EnumerationDefinition&gt;(valueNamedUnifyNode))
1229             return nullptr;
1230         return &amp;valueNamedUnifyNode;
1231     })();
1232     if (!valueType) {
1233         setError(Error(&quot;Invalid type for the expression condition of the switch statement.&quot;, switchStatement.codeLocation()));
1234         return;
1235     }
1236 
1237     bool hasDefault = false;
1238     for (auto&amp; switchCase : switchStatement.switchCases()) {
1239         checkErrorAndVisit(switchCase.block());
1240         if (!switchCase.value()) {
1241             hasDefault = true;
1242             continue;
1243         }
1244         auto success = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; bool {
1245             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));
1246         }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {
1247             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
1248         }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {
1249             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));
1250         }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {
1251             return matches(*valueType, m_intrinsics.boolType());
1252         }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {
1253             ASSERT(enumerationMemberLiteral.enumerationDefinition());
1254             return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
1255         }));
1256         if (!success) {
1257             setError(Error(&quot;Invalid type for switch case.&quot;, switchCase.codeLocation()));
1258             return;
1259         }
1260     }
1261 
1262     for (size_t i = 0; i &lt; switchStatement.switchCases().size(); ++i) {
1263         auto&amp; firstCase = switchStatement.switchCases()[i];
1264         for (size_t j = i + 1; j &lt; switchStatement.switchCases().size(); ++j) {
1265             auto&amp; secondCase = switchStatement.switchCases()[j];
1266 
1267             if (static_cast&lt;bool&gt;(firstCase.value()) != static_cast&lt;bool&gt;(secondCase.value()))
1268                 continue;
1269 
1270             if (!static_cast&lt;bool&gt;(firstCase.value())) {
1271                 setError(Error(&quot;Cannot define multiple default cases in switch statement.&quot;, secondCase.codeLocation()));
1272                 return;
1273             }
1274 
1275             auto success = firstCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; firstIntegerLiteral) -&gt; bool {
1276                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {
1277                     return firstIntegerLiteral.value() != secondIntegerLiteral.value();
1278                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {
1279                     return static_cast&lt;int64_t&gt;(firstIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondUnsignedIntegerLiteral.value());
1280                 }, [](auto&amp;) -&gt; bool {
1281                     return true;
1282                 }));
1283             }, [&amp;](AST::UnsignedIntegerLiteral&amp; firstUnsignedIntegerLiteral) -&gt; bool {
1284                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; secondIntegerLiteral) -&gt; bool {
1285                     return static_cast&lt;int64_t&gt;(firstUnsignedIntegerLiteral.value()) != static_cast&lt;int64_t&gt;(secondIntegerLiteral.value());
1286                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; secondUnsignedIntegerLiteral) -&gt; bool {
1287                     return firstUnsignedIntegerLiteral.value() != secondUnsignedIntegerLiteral.value();
1288                 }, [](auto&amp;) -&gt; bool {
1289                     return true;
1290                 }));
1291             }, [&amp;](AST::EnumerationMemberLiteral&amp; firstEnumerationMemberLiteral) -&gt; bool {
1292                 return secondCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; secondEnumerationMemberLiteral) -&gt; bool {
1293                     ASSERT(firstEnumerationMemberLiteral.enumerationMember());
1294                     ASSERT(secondEnumerationMemberLiteral.enumerationMember());
1295                     return firstEnumerationMemberLiteral.enumerationMember() != secondEnumerationMemberLiteral.enumerationMember();
1296                 }, [](auto&amp;) -&gt; bool {
1297                     return true;
1298                 }));
1299             }, [](auto&amp;) -&gt; bool {
1300                 return true;
1301             }));
1302             if (!success) {
1303                 setError(Error(&quot;Cannot define duplicate case statements in a switch.&quot;, secondCase.codeLocation()));
1304                 return;
1305             }
1306         }
1307     }
1308 
1309     if (!hasDefault) {
1310         if (is&lt;AST::NativeTypeDeclaration&gt;(*valueType)) {
1311             HashSet&lt;int64_t&gt; values;
1312             bool zeroValueExists;
1313             for (auto&amp; switchCase : switchStatement.switchCases()) {
1314                 auto value = switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) -&gt; int64_t {
1315                     return integerLiteral.valueForSelectedType();
1316                 }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; int64_t {
1317                     return unsignedIntegerLiteral.valueForSelectedType();
1318                 }, [](auto&amp;) -&gt; int64_t {
1319                     ASSERT_NOT_REACHED();
1320                     return 0;
1321                 }));
1322                 if (!value)
1323                     zeroValueExists = true;
1324                 else
1325                     values.add(value);
1326             }
1327             bool success = true;
1328             downcast&lt;AST::NativeTypeDeclaration&gt;(*valueType).iterateAllValues([&amp;](int64_t value) -&gt; bool {
1329                 if (!value) {
1330                     if (!zeroValueExists) {
1331                         success = false;
1332                         return true;
1333                     }
1334                     return false;
1335                 }
1336                 if (!values.contains(value)) {
1337                     success = false;
1338                     return true;
1339                 }
1340                 return false;
1341             });
1342             if (!success) {
1343                 setError(Error(&quot;Switch cases must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));
1344                 return;
1345             }
1346         } else {
1347             HashSet&lt;AST::EnumerationMember*&gt; values;
1348             for (auto&amp; switchCase : switchStatement.switchCases()) {
1349                 switchCase.value()-&gt;visit(WTF::makeVisitor([&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
1350                     ASSERT(enumerationMemberLiteral.enumerationMember());
1351                     values.add(enumerationMemberLiteral.enumerationMember());
1352                 }, [](auto&amp;) {
1353                     ASSERT_NOT_REACHED();
1354                 }));
1355             }
1356             for (auto&amp; enumerationMember : downcast&lt;AST::EnumerationDefinition&gt;(*valueType).enumerationMembers()) {
1357                 if (!values.contains(&amp;enumerationMember.get())) {
1358                     setError(Error(&quot;Switch cases over an enum must be exhaustive or you must define a default case.&quot;, switchStatement.codeLocation()));
1359                     return;
1360                 }
1361             }
1362         }
1363     }
1364 }
1365 
1366 void Checker::visit(AST::CommaExpression&amp; commaExpression)
1367 {
1368     ASSERT(commaExpression.list().size() &gt; 0);
1369     Visitor::visit(commaExpression);
1370     if (hasError())
1371         return;
1372     auto lastInfo = getInfo(commaExpression.list().last());
1373     forwardType(commaExpression, lastInfo-&gt;resolvingType);
1374 }
1375 
1376 void Checker::visit(AST::TernaryExpression&amp; ternaryExpression)
1377 {
1378     auto predicateInfo = recurseAndRequireBoolType(ternaryExpression.predicate());
1379     if (!predicateInfo)
1380         return;
1381 
1382     auto bodyInfo = recurseAndGetInfo(ternaryExpression.bodyExpression());
1383     auto elseInfo = recurseAndGetInfo(ternaryExpression.elseExpression());
1384 
1385     auto resultType = matchAndCommit(bodyInfo-&gt;resolvingType, elseInfo-&gt;resolvingType);
1386     if (!resultType) {
1387         setError(Error(&quot;lhs and rhs of a ternary expression must match.&quot;, ternaryExpression.codeLocation()));
1388         return;
1389     }
1390 
1391     assignConcreteType(ternaryExpression, *resultType);
1392 }
1393 
1394 void Checker::visit(AST::CallExpression&amp; callExpression)
1395 {
1396     Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; types;
1397     types.reserveInitialCapacity(callExpression.arguments().size());
1398     for (auto&amp; argument : callExpression.arguments()) {
1399         auto argumentInfo = recurseAndGetInfo(argument);
1400         if (!argumentInfo)
1401             return;
1402         types.uncheckedAppend(argumentInfo-&gt;resolvingType);
1403     }
1404     // Don&#39;t recurse on the castReturnType, because it&#39;s guaranteed to be a NamedType, which will get visited later.
1405     // We don&#39;t want to recurse to the same node twice.
1406 
1407     auto* function = resolveFunction(types, callExpression.name(), callExpression.codeLocation());
1408     if (hasError())
1409         return;
1410 
1411     if (!function) {
1412         NameContext&amp; nameContext = m_program.nameContext();
1413         auto castTypes = nameContext.getTypes(callExpression.name(), m_currentNameSpace);
1414         if (castTypes.size() == 1) {
1415             AST::NamedType&amp; castType = castTypes[0].get();
1416             function = resolveFunction(types, &quot;operator cast&quot;_str, callExpression.codeLocation(), &amp;castType);
1417             if (hasError())
1418                 return;
1419             if (function)
1420                 callExpression.setCastData(castType);
1421         }
1422     }
1423 
1424     if (!function) {
1425         // FIXME: Add better error messages for why we can&#39;t resolve to one of the overrides.
1426         // https://bugs.webkit.org/show_bug.cgi?id=200133
1427         setError(Error(&quot;Cannot resolve function call to a concrete callee. Make sure you are using compatible types.&quot;, callExpression.codeLocation()));
1428         return;
1429     }
1430 
1431     for (size_t i = 0; i &lt; function-&gt;parameters().size(); ++i) {
1432         if (!matchAndCommit(types[i].get(), *function-&gt;parameters()[i]-&gt;type())) {
1433             setError(Error(makeString(&quot;Invalid type for parameter number &quot;, i + 1, &quot; in function call.&quot;), callExpression.codeLocation()));
1434             return;
1435         }
1436     }
1437 
1438     callExpression.setFunction(*function);
1439 
1440     assignConcreteType(callExpression, function-&gt;type());
1441 }
1442 
1443 Expected&lt;void, Error&gt; check(Program&amp; program)
1444 {
1445     Checker checker(program.intrinsics(), program);
1446     checker.checkErrorAndVisit(program);
1447     if (checker.hasError())
1448         return checker.result();
1449     return checker.assignTypes();
1450 }
1451 
1452 } // namespace WHLSL
1453 
1454 } // namespace WebCore
1455 
1456 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>
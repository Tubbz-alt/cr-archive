<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;ErrorInstance.h&quot;
 23 
 24 #include &quot;CodeBlock.h&quot;
 25 #include &quot;InlineCallFrame.h&quot;
 26 #include &quot;Interpreter.h&quot;
 27 #include &quot;JSScope.h&quot;
 28 #include &quot;JSCInlines.h&quot;
 29 #include &quot;ParseInt.h&quot;
 30 #include &quot;StackFrame.h&quot;
 31 #include &lt;wtf/text/StringBuilder.h&gt;
 32 
 33 namespace JSC {
 34 
 35 const ClassInfo ErrorInstance::s_info = { &quot;Error&quot;, &amp;JSNonFinalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ErrorInstance) };
 36 
 37 ErrorInstance::ErrorInstance(VM&amp; vm, Structure* structure)
 38     : Base(vm, structure)
 39 {
 40 }
 41 
<a name="1" id="anc1"></a><span class="line-modified"> 42 ErrorInstance* ErrorInstance::create(JSGlobalObject* globalObject, Structure* structure, JSValue message, SourceAppender appender, RuntimeType type, bool useCurrentFrame)</span>
 43 {
<a name="2" id="anc2"></a><span class="line-modified"> 44     VM&amp; vm = globalObject-&gt;vm();</span>
 45     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="3" id="anc3"></a><span class="line-modified"> 46     String messageString = message.isUndefined() ? String() : message.toWTFString(globalObject);</span>
 47     RETURN_IF_EXCEPTION(scope, nullptr);
<a name="4" id="anc4"></a><span class="line-modified"> 48     return create(globalObject, vm, structure, messageString, appender, type, useCurrentFrame);</span>
 49 }
 50 
<a name="5" id="anc5"></a><span class="line-modified"> 51 static void appendSourceToError(JSGlobalObject* globalObject, CallFrame* callFrame, ErrorInstance* exception, BytecodeIndex bytecodeIndex)</span>
 52 {
 53     ErrorInstance::SourceAppender appender = exception-&gt;sourceAppender();
 54     exception-&gt;clearSourceAppender();
 55     RuntimeType type = exception-&gt;runtimeTypeForCause();
 56     exception-&gt;clearRuntimeTypeForCause();
 57 
 58     if (!callFrame-&gt;codeBlock()-&gt;hasExpressionInfo())
 59         return;
 60 
 61     int startOffset = 0;
 62     int endOffset = 0;
 63     int divotPoint = 0;
 64     unsigned line = 0;
 65     unsigned column = 0;
 66 
 67     CodeBlock* codeBlock;
 68     CodeOrigin codeOrigin = callFrame-&gt;codeOrigin();
 69     if (codeOrigin &amp;&amp; codeOrigin.inlineCallFrame())
 70         codeBlock = baselineCodeBlockForInlineCallFrame(codeOrigin.inlineCallFrame());
 71     else
 72         codeBlock = callFrame-&gt;codeBlock();
 73 
<a name="6" id="anc6"></a><span class="line-modified"> 74     codeBlock-&gt;expressionRangeForBytecodeIndex(bytecodeIndex, divotPoint, startOffset, endOffset, line, column);</span>
 75 
 76     int expressionStart = divotPoint - startOffset;
 77     int expressionStop = divotPoint + endOffset;
 78 
 79     StringView sourceString = codeBlock-&gt;source().provider()-&gt;source();
 80     if (!expressionStop || expressionStart &gt; static_cast&lt;int&gt;(sourceString.length()))
 81         return;
 82 
<a name="7" id="anc7"></a><span class="line-modified"> 83     VM&amp; vm = globalObject-&gt;vm();</span>
 84     JSValue jsMessage = exception-&gt;getDirect(vm, vm.propertyNames-&gt;message);
 85     if (!jsMessage || !jsMessage.isString())
 86         return;
 87 
<a name="8" id="anc8"></a><span class="line-modified"> 88     String message = asString(jsMessage)-&gt;value(globalObject);</span>
 89     if (expressionStart &lt; expressionStop)
 90         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(expressionStart, expressionStop).toString(), type, ErrorInstance::FoundExactSource);
 91     else {
 92         // No range information, so give a few characters of context.
 93         int dataLength = sourceString.length();
 94         int start = expressionStart;
 95         int stop = expressionStart;
 96         // Get up to 20 characters of context to the left and right of the divot, clamping to the line.
 97         // Then strip whitespace.
 98         while (start &gt; 0 &amp;&amp; (expressionStart - start &lt; 20) &amp;&amp; sourceString[start - 1] != &#39;\n&#39;)
 99             start--;
100         while (start &lt; (expressionStart - 1) &amp;&amp; isStrWhiteSpace(sourceString[start]))
101             start++;
102         while (stop &lt; dataLength &amp;&amp; (stop - expressionStart &lt; 20) &amp;&amp; sourceString[stop] != &#39;\n&#39;)
103             stop++;
104         while (stop &gt; expressionStart &amp;&amp; isStrWhiteSpace(sourceString[stop - 1]))
105             stop--;
106         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(start, stop).toString(), type, ErrorInstance::FoundApproximateSource);
107     }
108     exception-&gt;putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message));
109 
110 }
111 
<a name="9" id="anc9"></a><span class="line-modified">112 void ErrorInstance::finishCreation(JSGlobalObject* globalObject, VM&amp; vm, const String&amp; message, bool useCurrentFrame)</span>
113 {
114     Base::finishCreation(vm);
115     ASSERT(inherits(vm, info()));
116     if (!message.isNull())
117         putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
118 
<a name="10" id="anc10"></a><span class="line-modified">119     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = getStackTrace(globalObject, vm, this, useCurrentFrame);</span>
120     {
121         auto locker = holdLock(cellLock());
122         m_stackTrace = WTFMove(stackTrace);
123     }
124     vm.heap.writeBarrier(this);
125 
126     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty() &amp;&amp; hasSourceAppender()) {
<a name="11" id="anc11"></a><span class="line-modified">127         BytecodeIndex bytecodeIndex;</span>
128         CallFrame* callFrame;
<a name="12" id="anc12"></a><span class="line-modified">129         getBytecodeIndex(vm, vm.topCallFrame, m_stackTrace.get(), callFrame, bytecodeIndex);</span>
<span class="line-modified">130         if (callFrame &amp;&amp; callFrame-&gt;codeBlock() &amp;&amp; !callFrame-&gt;callee().isWasm())</span>
<span class="line-modified">131             appendSourceToError(globalObject, callFrame, this, bytecodeIndex);</span>


132     }
133 }
134 
<a name="13" id="anc13"></a>




135 // Based on ErrorPrototype&#39;s errorProtoFuncToString(), but is modified to
136 // have no observable side effects to the user (i.e. does not call proxies,
137 // and getters).
<a name="14" id="anc14"></a><span class="line-modified">138 String ErrorInstance::sanitizedToString(JSGlobalObject* globalObject)</span>
139 {
<a name="15" id="anc15"></a><span class="line-modified">140     VM&amp; vm = globalObject-&gt;vm();</span>
141     auto scope = DECLARE_THROW_SCOPE(vm);
142 
143     JSValue nameValue;
144     auto namePropertName = vm.propertyNames-&gt;name;
145     PropertySlot nameSlot(this, PropertySlot::InternalMethodType::VMInquiry);
146 
147     JSValue currentObj = this;
148     unsigned prototypeDepth = 0;
149 
150     // We only check the current object and its prototype (2 levels) because normal
151     // Error objects may have a name property, and if not, its prototype should have
152     // a name property for the type of error e.g. &quot;SyntaxError&quot;.
153     while (currentObj.isCell() &amp;&amp; prototypeDepth++ &lt; 2) {
154         JSObject* obj = jsCast&lt;JSObject*&gt;(currentObj);
<a name="16" id="anc16"></a><span class="line-modified">155         if (JSObject::getOwnPropertySlot(obj, globalObject, namePropertName, nameSlot) &amp;&amp; nameSlot.isValue()) {</span>
<span class="line-modified">156             nameValue = nameSlot.getValue(globalObject, namePropertName);</span>
157             break;
158         }
159         currentObj = obj-&gt;getPrototypeDirect(vm);
160     }
161     scope.assertNoException();
162 
163     String nameString;
164     if (!nameValue)
165         nameString = &quot;Error&quot;_s;
166     else {
<a name="17" id="anc17"></a><span class="line-modified">167         nameString = nameValue.toWTFString(globalObject);</span>
168         RETURN_IF_EXCEPTION(scope, String());
169     }
170 
171     JSValue messageValue;
172     auto messagePropertName = vm.propertyNames-&gt;message;
173     PropertySlot messageSlot(this, PropertySlot::InternalMethodType::VMInquiry);
<a name="18" id="anc18"></a><span class="line-modified">174     if (JSObject::getOwnPropertySlot(this, globalObject, messagePropertName, messageSlot) &amp;&amp; messageSlot.isValue())</span>
<span class="line-modified">175         messageValue = messageSlot.getValue(globalObject, messagePropertName);</span>
176     scope.assertNoException();
177 
178     String messageString;
179     if (!messageValue)
180         messageString = String();
181     else {
<a name="19" id="anc19"></a><span class="line-modified">182         messageString = messageValue.toWTFString(globalObject);</span>
183         RETURN_IF_EXCEPTION(scope, String());
184     }
185 
186     if (!nameString.length())
187         return messageString;
188 
189     if (!messageString.length())
190         return nameString;
191 
192     StringBuilder builder;
193     builder.append(nameString);
194     builder.appendLiteral(&quot;: &quot;);
195     builder.append(messageString);
196     return builder.toString();
197 }
198 
199 void ErrorInstance::finalizeUnconditionally(VM&amp; vm)
200 {
201     if (!m_stackTrace)
202         return;
203 
204     // We don&#39;t want to keep our stack traces alive forever if the user doesn&#39;t access the stack trace.
205     // If we did, we might end up keeping functions (and their global objects) alive that happened to
206     // get caught in a trace.
207     for (const auto&amp; frame : *m_stackTrace.get()) {
208         if (!frame.isMarked(vm)) {
209             computeErrorInfo(vm);
210             return;
211         }
212     }
213 }
214 
215 void ErrorInstance::computeErrorInfo(VM&amp; vm)
216 {
217     ASSERT(!m_errorInfoMaterialized);
218 
219     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty()) {
220         getLineColumnAndSource(m_stackTrace.get(), m_line, m_column, m_sourceURL);
221         m_stackString = Interpreter::stackTraceAsString(vm, *m_stackTrace.get());
222         m_stackTrace = nullptr;
223     }
224 }
225 
226 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm)
227 {
228     if (m_errorInfoMaterialized)
229         return false;
230 
231     computeErrorInfo(vm);
232 
233     if (!m_stackString.isNull()) {
<a name="20" id="anc20"></a><span class="line-modified">234         auto attributes = static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum);</span>
<span class="line-modified">235 </span>
<span class="line-added">236         putDirect(vm, vm.propertyNames-&gt;line, jsNumber(m_line), attributes);</span>
<span class="line-added">237         putDirect(vm, vm.propertyNames-&gt;column, jsNumber(m_column), attributes);</span>
238         if (!m_sourceURL.isEmpty())
<a name="21" id="anc21"></a><span class="line-modified">239             putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, WTFMove(m_sourceURL)), attributes);</span>
240 
<a name="22" id="anc22"></a><span class="line-modified">241         putDirect(vm, vm.propertyNames-&gt;stack, jsString(vm, WTFMove(m_stackString)), attributes);</span>
242     }
243 
244     m_errorInfoMaterialized = true;
245     return true;
246 }
247 
248 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm, PropertyName propertyName)
249 {
250     if (propertyName == vm.propertyNames-&gt;line
251         || propertyName == vm.propertyNames-&gt;column
252         || propertyName == vm.propertyNames-&gt;sourceURL
253         || propertyName == vm.propertyNames-&gt;stack)
254         return materializeErrorInfoIfNeeded(vm);
255     return false;
256 }
257 
<a name="23" id="anc23"></a><span class="line-modified">258 bool ErrorInstance::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
259 {
<a name="24" id="anc24"></a><span class="line-modified">260     VM&amp; vm = globalObject-&gt;vm();</span>
261     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
262     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<a name="25" id="anc25"></a><span class="line-modified">263     return Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
264 }
265 
<a name="26" id="anc26"></a><span class="line-modified">266 void ErrorInstance::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
267 {
<a name="27" id="anc27"></a><span class="line-modified">268     VM&amp; vm = globalObject-&gt;vm();</span>
269     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
270     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<a name="28" id="anc28"></a><span class="line-modified">271     Base::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNameArray, enumerationMode);</span>
272 }
273 
<a name="29" id="anc29"></a><span class="line-modified">274 void ErrorInstance::getStructurePropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
275 {
<a name="30" id="anc30"></a><span class="line-modified">276     VM&amp; vm = globalObject-&gt;vm();</span>
277     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
278     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<a name="31" id="anc31"></a><span class="line-modified">279     Base::getStructurePropertyNames(thisObject, globalObject, propertyNameArray, enumerationMode);</span>
280 }
281 
<a name="32" id="anc32"></a><span class="line-modified">282 bool ErrorInstance::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
283 {
<a name="33" id="anc33"></a><span class="line-modified">284     VM&amp; vm = globalObject-&gt;vm();</span>
285     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
286     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<a name="34" id="anc34"></a><span class="line-modified">287     return Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);</span>
288 }
289 
<a name="35" id="anc35"></a><span class="line-modified">290 bool ErrorInstance::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
291 {
<a name="36" id="anc36"></a><span class="line-modified">292     VM&amp; vm = globalObject-&gt;vm();</span>
293     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
294     bool materializedProperties = thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
295     if (materializedProperties)
296         slot.disableCaching();
<a name="37" id="anc37"></a><span class="line-modified">297     return Base::put(thisObject, globalObject, propertyName, value, slot);</span>
298 }
299 
<a name="38" id="anc38"></a><span class="line-modified">300 bool ErrorInstance::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
301 {
<a name="39" id="anc39"></a><span class="line-modified">302     VM&amp; vm = globalObject-&gt;vm();</span>
303     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
304     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<a name="40" id="anc40"></a><span class="line-modified">305     return Base::deleteProperty(thisObject, globalObject, propertyName);</span>
306 }
307 
308 } // namespace JSC
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExp.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ReflectObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpCache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExp.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">  3  *  Copyright (C) 2007, 2008, 2009, 2016 Apple Inc. All rights reserved.</span>
  4  *  Copyright (C) 2009 Torch Mobile, Inc.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
</pre>
<hr />
<pre>
 25 #include &quot;MatchResult.h&quot;
 26 #include &quot;RegExpKey.h&quot;
 27 #include &quot;Structure.h&quot;
 28 #include &quot;Yarr.h&quot;
 29 #include &lt;wtf/Forward.h&gt;
 30 #include &lt;wtf/text/WTFString.h&gt;
 31 
 32 #if ENABLE(YARR_JIT)
 33 #include &quot;YarrJIT.h&quot;
 34 #endif
 35 
 36 namespace JSC {
 37 
 38 struct RegExpRepresentation;
 39 class VM;
 40 
 41 class RegExp final : public JSCell {
 42     friend class CachedRegExp;
 43 
 44 public:
<span class="line-modified"> 45     typedef JSCell Base;</span>
<span class="line-modified"> 46     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>







 47 
 48     JS_EXPORT_PRIVATE static RegExp* create(VM&amp;, const String&amp; pattern, OptionSet&lt;Yarr::Flags&gt;);
<span class="line-removed"> 49     static const bool needsDestruction = true;</span>
 50     static void destroy(JSCell*);
 51     static size_t estimatedSize(JSCell*, VM&amp;);
 52     JS_EXPORT_PRIVATE static void dumpToStream(const JSCell*, PrintStream&amp;);
 53 
 54     bool global() const { return m_flags.contains(Yarr::Flags::Global); }
 55     bool ignoreCase() const { return m_flags.contains(Yarr::Flags::IgnoreCase); }
 56     bool multiline() const { return m_flags.contains(Yarr::Flags::Multiline); }
 57     bool sticky() const { return m_flags.contains(Yarr::Flags::Sticky); }
 58     bool globalOrSticky() const { return global() || sticky(); }
 59     bool unicode() const { return m_flags.contains(Yarr::Flags::Unicode); }
 60     bool dotAll() const { return m_flags.contains(Yarr::Flags::DotAll); }
 61 
 62     const String&amp; pattern() const { return m_patternString; }
 63 
 64     bool isValid() const { return !Yarr::hasError(m_constructionErrorCode); }
 65     const char* errorMessage() const { return Yarr::errorMessage(m_constructionErrorCode); }
<span class="line-modified"> 66     JSObject* errorToThrow(ExecState* exec) { return Yarr::errorToThrow(exec, m_constructionErrorCode); }</span>
 67     void reset()
 68     {
 69         m_state = NotCompiled;
 70         m_constructionErrorCode = Yarr::ErrorCode::NoError;
 71     }
 72 
 73     JS_EXPORT_PRIVATE int match(VM&amp;, const String&amp;, unsigned startOffset, Vector&lt;int&gt;&amp; ovector);
 74 
 75     // Returns false if we couldn&#39;t run the regular expression for any reason.
 76     bool matchConcurrently(VM&amp;, const String&amp;, unsigned startOffset, int&amp; position, Vector&lt;int&gt;&amp; ovector);
 77 
 78     JS_EXPORT_PRIVATE MatchResult match(VM&amp;, const String&amp;, unsigned startOffset);
 79 
 80     bool matchConcurrently(VM&amp;, const String&amp;, unsigned startOffset, MatchResult&amp;);
 81 
 82     // Call these versions of the match functions if you&#39;re desperate for performance.
 83     template&lt;typename VectorType&gt;
 84     int matchInline(VM&amp;, const String&amp;, unsigned startOffset, VectorType&amp; ovector);
 85     MatchResult matchInline(VM&amp;, const String&amp;, unsigned startOffset);
 86 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">  3  *  Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
  4  *  Copyright (C) 2009 Torch Mobile, Inc.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
</pre>
<hr />
<pre>
 25 #include &quot;MatchResult.h&quot;
 26 #include &quot;RegExpKey.h&quot;
 27 #include &quot;Structure.h&quot;
 28 #include &quot;Yarr.h&quot;
 29 #include &lt;wtf/Forward.h&gt;
 30 #include &lt;wtf/text/WTFString.h&gt;
 31 
 32 #if ENABLE(YARR_JIT)
 33 #include &quot;YarrJIT.h&quot;
 34 #endif
 35 
 36 namespace JSC {
 37 
 38 struct RegExpRepresentation;
 39 class VM;
 40 
 41 class RegExp final : public JSCell {
 42     friend class CachedRegExp;
 43 
 44 public:
<span class="line-modified"> 45     using Base = JSCell;</span>
<span class="line-modified"> 46     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
<span class="line-added"> 47     static constexpr bool needsDestruction = true;</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added"> 50     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added"> 51     {</span>
<span class="line-added"> 52         return &amp;vm.regExpSpace;</span>
<span class="line-added"> 53     }</span>
 54 
 55     JS_EXPORT_PRIVATE static RegExp* create(VM&amp;, const String&amp; pattern, OptionSet&lt;Yarr::Flags&gt;);

 56     static void destroy(JSCell*);
 57     static size_t estimatedSize(JSCell*, VM&amp;);
 58     JS_EXPORT_PRIVATE static void dumpToStream(const JSCell*, PrintStream&amp;);
 59 
 60     bool global() const { return m_flags.contains(Yarr::Flags::Global); }
 61     bool ignoreCase() const { return m_flags.contains(Yarr::Flags::IgnoreCase); }
 62     bool multiline() const { return m_flags.contains(Yarr::Flags::Multiline); }
 63     bool sticky() const { return m_flags.contains(Yarr::Flags::Sticky); }
 64     bool globalOrSticky() const { return global() || sticky(); }
 65     bool unicode() const { return m_flags.contains(Yarr::Flags::Unicode); }
 66     bool dotAll() const { return m_flags.contains(Yarr::Flags::DotAll); }
 67 
 68     const String&amp; pattern() const { return m_patternString; }
 69 
 70     bool isValid() const { return !Yarr::hasError(m_constructionErrorCode); }
 71     const char* errorMessage() const { return Yarr::errorMessage(m_constructionErrorCode); }
<span class="line-modified"> 72     JSObject* errorToThrow(JSGlobalObject* globalObject) { return Yarr::errorToThrow(globalObject, m_constructionErrorCode); }</span>
 73     void reset()
 74     {
 75         m_state = NotCompiled;
 76         m_constructionErrorCode = Yarr::ErrorCode::NoError;
 77     }
 78 
 79     JS_EXPORT_PRIVATE int match(VM&amp;, const String&amp;, unsigned startOffset, Vector&lt;int&gt;&amp; ovector);
 80 
 81     // Returns false if we couldn&#39;t run the regular expression for any reason.
 82     bool matchConcurrently(VM&amp;, const String&amp;, unsigned startOffset, int&amp; position, Vector&lt;int&gt;&amp; ovector);
 83 
 84     JS_EXPORT_PRIVATE MatchResult match(VM&amp;, const String&amp;, unsigned startOffset);
 85 
 86     bool matchConcurrently(VM&amp;, const String&amp;, unsigned startOffset, MatchResult&amp;);
 87 
 88     // Call these versions of the match functions if you&#39;re desperate for performance.
 89     template&lt;typename VectorType&gt;
 90     int matchInline(VM&amp;, const String&amp;, unsigned startOffset, VectorType&amp; ovector);
 91     MatchResult matchInline(VM&amp;, const String&amp;, unsigned startOffset);
 92 
</pre>
</td>
</tr>
</table>
<center><a href="ReflectObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpCache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
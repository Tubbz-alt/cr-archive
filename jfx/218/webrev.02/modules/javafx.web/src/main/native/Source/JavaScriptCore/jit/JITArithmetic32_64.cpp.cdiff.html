<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITArithmetic.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITBitAndGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,12 ***</span>
  {
      JumpList notInt32Op1;
      JumpList notInt32Op2;
  
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
  
      // Character less.
      if (isOperandConstantChar(op1)) {
          emitLoad(op2, regT1, regT0);
<span class="line-new-header">--- 46,12 ---</span>
  {
      JumpList notInt32Op1;
      JumpList notInt32Op2;
  
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
  
      // Character less.
      if (isOperandConstantChar(op1)) {
          emitLoad(op2, regT1, regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,12 ***</span>
  
  template &lt;typename Op&gt;
  void JIT::emit_compareUnsignedAndJump(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
  
      if (isOperandConstantInt(op1)) {
          emitLoad(op2, regT3, regT2);
          addJump(branch32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32())), target);
<span class="line-new-header">--- 100,12 ---</span>
  
  template &lt;typename Op&gt;
  void JIT::emit_compareUnsignedAndJump(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
  
      if (isOperandConstantInt(op1)) {
          emitLoad(op2, regT3, regT2);
          addJump(branch32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32())), target);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 120,13 ***</span>
  
  template &lt;typename Op&gt;
  void JIT::emit_compareUnsigned(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
  
      if (isOperandConstantInt(op1)) {
          emitLoad(op2, regT3, regT2);
          compare32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32()), regT0);
      } else if (isOperandConstantInt(op2)) {
<span class="line-new-header">--- 120,13 ---</span>
  
  template &lt;typename Op&gt;
  void JIT::emit_compareUnsigned(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
      if (isOperandConstantInt(op1)) {
          emitLoad(op2, regT3, regT2);
          compare32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32()), regT0);
      } else if (isOperandConstantInt(op2)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,30 ***</span>
      }
      emitStoreBool(dst, regT0);
  }
  
  template &lt;typename Op&gt;
<span class="line-modified">! void JIT::emit_compareAndJumpSlow(const Instruction *instruction, DoubleCondition, size_t (JIT_OPERATION *operation)(ExecState*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
  
      linkAllSlowCases(iter);
  
      emitLoad(op1, regT1, regT0);
      emitLoad(op2, regT3, regT2);
<span class="line-modified">!     callOperation(operation, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
  }
  
  void JIT::emit_op_unsigned(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_operand.offset();</span>
  
      emitLoad(op1, regT1, regT0);
  
      addSlowCase(branchIfNotInt32(regT1));
      addSlowCase(branch32(LessThan, regT0, TrustedImm32(0)));
<span class="line-new-header">--- 138,30 ---</span>
      }
      emitStoreBool(dst, regT0);
  }
  
  template &lt;typename Op&gt;
<span class="line-modified">! void JIT::emit_compareAndJumpSlow(const Instruction *instruction, DoubleCondition, size_t (JIT_OPERATION *operation)(JSGlobalObject*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
  
      linkAllSlowCases(iter);
  
      emitLoad(op1, regT1, regT0);
      emitLoad(op2, regT3, regT2);
<span class="line-modified">!     callOperation(operation, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
  }
  
  void JIT::emit_op_unsigned(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_operand;</span>
  
      emitLoad(op1, regT1, regT0);
  
      addSlowCase(branchIfNotInt32(regT1));
      addSlowCase(branch32(LessThan, regT0, TrustedImm32(0)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,11 ***</span>
  }
  
  void JIT::emit_op_inc(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
<span class="line-modified">!     int srcDst = bytecode.m_srcDst.offset();</span>
  
      emitLoad(srcDst, regT1, regT0);
  
      addSlowCase(branchIfNotInt32(regT1));
      addSlowCase(branchAdd32(Overflow, TrustedImm32(1), regT0));
<span class="line-new-header">--- 169,11 ---</span>
  }
  
  void JIT::emit_op_inc(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
<span class="line-modified">!     VirtualRegister srcDst = bytecode.m_srcDst;</span>
  
      emitLoad(srcDst, regT1, regT0);
  
      addSlowCase(branchIfNotInt32(regT1));
      addSlowCase(branchAdd32(Overflow, TrustedImm32(1), regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,11 ***</span>
  }
  
  void JIT::emit_op_dec(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
<span class="line-modified">!     int srcDst = bytecode.m_srcDst.offset();</span>
  
      emitLoad(srcDst, regT1, regT0);
  
      addSlowCase(branchIfNotInt32(regT1));
      addSlowCase(branchSub32(Overflow, TrustedImm32(1), regT0));
<span class="line-new-header">--- 181,11 ---</span>
  }
  
  void JIT::emit_op_dec(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
<span class="line-modified">!     VirtualRegister srcDst = bytecode.m_srcDst;</span>
  
      emitLoad(srcDst, regT1, regT0);
  
      addSlowCase(branchIfNotInt32(regT1));
      addSlowCase(branchSub32(Overflow, TrustedImm32(1), regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,12 ***</span>
      JumpList end;
  
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
      int opcodeID = Op::opcodeID;
      int target = jumpTarget(instruction, bytecode.m_targetLabel);
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
  
      if (!notInt32Op1.empty()) {
          // Double case 1: Op1 is not int32; Op2 is unknown.
          notInt32Op1.link(this);
  
<span class="line-new-header">--- 198,12 ---</span>
      JumpList end;
  
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
      int opcodeID = Op::opcodeID;
      int target = jumpTarget(instruction, bytecode.m_targetLabel);
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
      if (!notInt32Op1.empty()) {
          // Double case 1: Op1 is not int32; Op2 is unknown.
          notInt32Op1.link(this);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,57 ***</span>
  
  /* ------------------------------ BEGIN: OP_MOD ------------------------------ */
  
  void JIT::emit_op_mod(const Instruction* currentInstruction)
  {
<span class="line-removed">- #if CPU(X86)</span>
<span class="line-removed">-     auto bytecode = instruction-&gt;as&lt;OpMod&gt;();</span>
<span class="line-removed">-     int dst = bytecode.m_dst.offset();</span>
<span class="line-removed">-     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-removed">-     int op2 = bytecode.m_rhs.offset();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Make sure registers are correct for x86 IDIV instructions.</span>
<span class="line-removed">-     ASSERT(regT0 == X86Registers::eax);</span>
<span class="line-removed">-     ASSERT(regT1 == X86Registers::edx);</span>
<span class="line-removed">-     ASSERT(regT2 == X86Registers::ecx);</span>
<span class="line-removed">-     ASSERT(regT3 == X86Registers::ebx);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitLoad2(op1, regT0, regT3, op2, regT1, regT2);</span>
<span class="line-removed">-     addSlowCase(branchIfNotInt32(regT1));</span>
<span class="line-removed">-     addSlowCase(branchIfNotInt32(regT0));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     move(regT3, regT0);</span>
<span class="line-removed">-     addSlowCase(branchTest32(Zero, regT2));</span>
<span class="line-removed">-     Jump denominatorNotNeg1 = branch32(NotEqual, regT2, TrustedImm32(-1));</span>
<span class="line-removed">-     addSlowCase(branch32(Equal, regT0, TrustedImm32(-2147483647-1)));</span>
<span class="line-removed">-     denominatorNotNeg1.link(this);</span>
<span class="line-removed">-     x86ConvertToDoubleWord32();</span>
<span class="line-removed">-     x86Div32(regT2);</span>
<span class="line-removed">-     Jump numeratorPositive = branch32(GreaterThanOrEqual, regT3, TrustedImm32(0));</span>
<span class="line-removed">-     addSlowCase(branchTest32(Zero, regT1));</span>
<span class="line-removed">-     numeratorPositive.link(this);</span>
<span class="line-removed">-     emitStoreInt32(dst, regT1, (op1 == dst || op2 == dst));</span>
<span class="line-removed">- #else</span>
      JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_mod);
      slowPathCall.call();
<span class="line-removed">- #endif</span>
  }
  
<span class="line-modified">! void JIT::emitSlow_op_mod(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
  {
<span class="line-removed">- #if CPU(X86)</span>
<span class="line-removed">-     linkAllSlowCases(iter);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_mod);</span>
<span class="line-removed">-     slowPathCall.call();</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     UNUSED_PARAM(currentInstruction);</span>
<span class="line-removed">-     UNUSED_PARAM(iter);</span>
      // We would have really useful assertions here if it wasn&#39;t for the compiler&#39;s
      // insistence on attribute noreturn.
      // RELEASE_ASSERT_NOT_REACHED();
<span class="line-removed">- #endif</span>
  }
  
  /* ------------------------------ END: OP_MOD ------------------------------ */
  
  } // namespace JSC
<span class="line-new-header">--- 332,19 ---</span>
  
  /* ------------------------------ BEGIN: OP_MOD ------------------------------ */
  
  void JIT::emit_op_mod(const Instruction* currentInstruction)
  {
      JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_mod);
      slowPathCall.call();
  }
  
<span class="line-modified">! void JIT::emitSlow_op_mod(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;)</span>
  {
      // We would have really useful assertions here if it wasn&#39;t for the compiler&#39;s
      // insistence on attribute noreturn.
      // RELEASE_ASSERT_NOT_REACHED();
  }
  
  /* ------------------------------ END: OP_MOD ------------------------------ */
  
  } // namespace JSC
</pre>
<center><a href="JITArithmetic.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITBitAndGenerator.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
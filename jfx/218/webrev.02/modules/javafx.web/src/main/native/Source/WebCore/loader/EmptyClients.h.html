<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyClients.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006 Eric Seidel (eric@webkit.org)
  3  * Copyright (C) 2008-2017 Apple Inc. All rights reserved.
  4  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
  5  * Copyright (C) 2012 Samsung Electronics. All rights reserved.
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  * 1. Redistributions of source code must retain the above copyright
 11  *    notice, this list of conditions and the following disclaimer.
 12  * 2. Redistributions in binary form must reproduce the above copyright
 13  *    notice, this list of conditions and the following disclaimer in the
 14  *    documentation and/or other materials provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #pragma once
 30 
 31 #include &quot;ChromeClient.h&quot;
 32 #include &lt;wtf/UniqueRef.h&gt;
 33 
 34 // Empty client classes for use by WebCore.
 35 //
 36 // First created for SVGImage as it had no way to access the current Page (nor should it, since Images are not tied to a page).
 37 // See http://bugs.webkit.org/show_bug.cgi?id=5971 for the original discussion about this file.
 38 
 39 namespace WebCore {
 40 
 41 class DiagnosticLoggingClient;
 42 class EditorClient;
 43 class HTMLImageElement;
 44 class PageConfiguration;
 45 
 46 class EmptyChromeClient : public ChromeClient {
 47     WTF_MAKE_FAST_ALLOCATED;
 48 
 49     void chromeDestroyed() override { }
 50 
 51     void setWindowRect(const FloatRect&amp;) final { }
 52     FloatRect windowRect() final { return FloatRect(); }
 53 
 54     FloatRect pageRect() final { return FloatRect(); }
 55 
 56     void focus() final { }
 57     void unfocus() final { }
 58 
 59     bool canTakeFocus(FocusDirection) final { return false; }
 60     void takeFocus(FocusDirection) final { }
 61 
 62     void focusedElementChanged(Element*) final { }
 63     void focusedFrameChanged(Frame*) final { }
 64 
 65     Page* createWindow(Frame&amp;, const FrameLoadRequest&amp;, const WindowFeatures&amp;, const NavigationAction&amp;) final { return nullptr; }
 66     void show() final { }
 67 
 68     bool canRunModal() final { return false; }
 69     void runModal() final { }
 70 
 71     void setToolbarsVisible(bool) final { }
 72     bool toolbarsVisible() final { return false; }
 73 
 74     void setStatusbarVisible(bool) final { }
 75     bool statusbarVisible() final { return false; }
 76 
 77     void setScrollbarsVisible(bool) final { }
 78     bool scrollbarsVisible() final { return false; }
 79 
 80     void setMenubarVisible(bool) final { }
 81     bool menubarVisible() final { return false; }
 82 
 83     void setResizable(bool) final { }
 84 
 85     void addMessageToConsole(MessageSource, MessageLevel, const String&amp;, unsigned, unsigned, const String&amp;) final { }
 86 
 87     bool canRunBeforeUnloadConfirmPanel() final { return false; }
 88     bool runBeforeUnloadConfirmPanel(const String&amp;, Frame&amp;) final { return true; }
 89 
 90     void closeWindowSoon() final { }
 91 
 92     void runJavaScriptAlert(Frame&amp;, const String&amp;) final { }
 93     bool runJavaScriptConfirm(Frame&amp;, const String&amp;) final { return false; }
 94     bool runJavaScriptPrompt(Frame&amp;, const String&amp;, const String&amp;, String&amp;) final { return false; }
 95 
 96     bool selectItemWritingDirectionIsNatural() final { return false; }
 97     bool selectItemAlignmentFollowsMenuWritingDirection() final { return false; }
 98     RefPtr&lt;PopupMenu&gt; createPopupMenu(PopupMenuClient&amp;) const final;
 99     RefPtr&lt;SearchPopupMenu&gt; createSearchPopupMenu(PopupMenuClient&amp;) const final;
100 
101     void setStatusbarText(const String&amp;) final { }
102 
103     KeyboardUIMode keyboardUIMode() final { return KeyboardAccessDefault; }
104 
105     void invalidateRootView(const IntRect&amp;) final { }
106     void invalidateContentsAndRootView(const IntRect&amp;) override { }
107     void invalidateContentsForSlowScroll(const IntRect&amp;) final { }
108     void scroll(const IntSize&amp;, const IntRect&amp;, const IntRect&amp;) final { }
109 
110     IntPoint screenToRootView(const IntPoint&amp; p) const final { return p; }
111     IntRect rootViewToScreen(const IntRect&amp; r) const final { return r; }
112     IntPoint accessibilityScreenToRootView(const IntPoint&amp; p) const final { return p; };
113     IntRect rootViewToAccessibilityScreen(const IntRect&amp; r) const final { return r; };
114 
115     void didFinishLoadingImageForElement(HTMLImageElement&amp;) final { }
116 
117     PlatformPageClient platformPageClient() const final { return 0; }
118     void contentsSizeChanged(Frame&amp;, const IntSize&amp;) const final { }
119     void intrinsicContentsSizeChanged(const IntSize&amp;) const final { }
120 
121     void mouseDidMoveOverElement(const HitTestResult&amp;, unsigned, const String&amp;, TextDirection) final { }
122 
123     void print(Frame&amp;) final { }
124 
125     void exceededDatabaseQuota(Frame&amp;, const String&amp;, DatabaseDetails) final { }
126 
127     void reachedMaxAppCacheSize(int64_t) final { }
128     void reachedApplicationCacheOriginQuota(SecurityOrigin&amp;, int64_t) final { }
129 
130 #if ENABLE(INPUT_TYPE_COLOR)
131     std::unique_ptr&lt;ColorChooser&gt; createColorChooser(ColorChooserClient&amp;, const Color&amp;) final;
132 #endif
133 
134 #if ENABLE(DATALIST_ELEMENT)
135     std::unique_ptr&lt;DataListSuggestionPicker&gt; createDataListSuggestionPicker(DataListSuggestionsClient&amp;) final;
136 #endif
137 
138     void runOpenPanel(Frame&amp;, FileChooser&amp;) final;
139     void showShareSheet(ShareDataWithParsedURL&amp;, CompletionHandler&lt;void(bool)&gt;&amp;&amp;) final;
140     void loadIconForFiles(const Vector&lt;String&gt;&amp;, FileIconLoader&amp;) final { }
141 
142     void elementDidFocus(Element&amp;) final { }
143     void elementDidBlur(Element&amp;) final { }
144 
145     void setCursor(const Cursor&amp;) final { }
146     void setCursorHiddenUntilMouseMoves(bool) final { }
147 
148     void scrollRectIntoView(const IntRect&amp;) const final { }
149 
150     void attachRootGraphicsLayer(Frame&amp;, GraphicsLayer*) final { }
151     void attachViewOverlayGraphicsLayer(GraphicsLayer*) final { }
152     void setNeedsOneShotDrawingSynchronization() final { }
153     void scheduleCompositingLayerFlush() final { }
154 
155 #if PLATFORM(WIN)
156     void setLastSetCursorToCurrentCursor() final { }
157     void AXStartFrameLoad() final { }
158     void AXFinishFrameLoad() final { }
159 #endif
160 
161 #if ENABLE(IOS_TOUCH_EVENTS)
162     void didPreventDefaultForEvent() final { }
163 #endif
164 
165 #if PLATFORM(IOS_FAMILY)
166     void didReceiveMobileDocType(bool) final { }
167     void setNeedsScrollNotifications(Frame&amp;, bool) final { }
168     void didFinishContentChangeObserving(Frame&amp;, WKContentChange) final { }
169     void notifyRevealedSelectionByScrollingFrame(Frame&amp;) final { }
170     void didLayout(LayoutType) final { }
171     void didStartOverflowScroll() final { }
172     void didEndOverflowScroll() final { }
173 
174     void suppressFormNotifications() final { }
175     void restoreFormNotifications() final { }
176 
177     void addOrUpdateScrollingLayer(Node*, PlatformLayer*, PlatformLayer*, const IntSize&amp;, bool, bool) final { }
178     void removeScrollingLayer(Node*, PlatformLayer*, PlatformLayer*) final { }
179 
180     void webAppOrientationsUpdated() final { };
181     void showPlaybackTargetPicker(bool, RouteSharingPolicy, const String&amp;) final { };
182 #endif // PLATFORM(IOS_FAMILY)
183 
184 #if ENABLE(ORIENTATION_EVENTS)
185     int deviceOrientation() const final { return 0; }
186 #endif
187 
188 #if PLATFORM(IOS_FAMILY)
189     bool isStopping() final { return false; }
190 #endif
191 
192     void wheelEventHandlersChanged(bool) final { }
193 
194     bool isEmptyChromeClient() const final { return true; }
195 
196     void didAssociateFormControls(const Vector&lt;RefPtr&lt;Element&gt;&gt;&amp;, Frame&amp;) final { }
197     bool shouldNotifyOnFormChanges() final { return false; }
198 
199     RefPtr&lt;Icon&gt; createIconForFiles(const Vector&lt;String&gt;&amp; /* filenames */) final { return nullptr; }
200 };
201 
202 DiagnosticLoggingClient&amp; emptyDiagnosticLoggingClient();
203 WEBCORE_EXPORT PageConfiguration pageConfigurationWithEmptyClients(PAL::SessionID);
204 
205 }
    </pre>
  </body>
</html>
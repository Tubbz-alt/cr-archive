<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentThreadableLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;CachedRawResourceClient.h&quot;
 33 #include &quot;CachedResourceHandle.h&quot;

 34 #include &quot;ContentSecurityPolicyClient.h&quot;
 35 #include &quot;DeviceOrientationOrMotionPermissionState.h&quot;
 36 #include &quot;DocumentIdentifier.h&quot;
 37 #include &quot;DocumentWriter.h&quot;
 38 #include &quot;FrameDestructionObserver.h&quot;
 39 #include &quot;LinkIcon.h&quot;
 40 #include &quot;LoadTiming.h&quot;
 41 #include &quot;NavigationAction.h&quot;
 42 #include &quot;ResourceError.h&quot;
 43 #include &quot;ResourceLoaderOptions.h&quot;
 44 #include &quot;ResourceRequest.h&quot;
 45 #include &quot;ResourceResponse.h&quot;
 46 #include &quot;SecurityPolicyViolationEvent.h&quot;
 47 #include &quot;ServiceWorkerRegistrationData.h&quot;
 48 #include &quot;StringWithDirection.h&quot;
 49 #include &quot;StyleSheetContents.h&quot;
 50 #include &quot;SubstituteData.h&quot;
 51 #include &quot;Timer.h&quot;
 52 #include &lt;wtf/HashSet.h&gt;
 53 #include &lt;wtf/OptionSet.h&gt;
</pre>
<hr />
<pre>
120 };
121 
122 enum class MediaSourcePolicy : uint8_t {
123     Default,
124     Disable,
125     Enable
126 };
127 
128 enum class SimulatedMouseEventsDispatchPolicy : uint8_t {
129     Default,
130     Allow,
131     Deny,
132 };
133 
134 enum class LegacyOverflowScrollingTouchPolicy : uint8_t {
135     Default,
136     Disable,
137     Enable,
138 };
139 

140 class DocumentLoader
141     : public RefCounted&lt;DocumentLoader&gt;
142     , public FrameDestructionObserver
143     , public ContentSecurityPolicyClient



144     , private CachedRawResourceClient {
<span class="line-modified">145     WTF_MAKE_FAST_ALLOCATED;</span>
146     friend class ContentFilter;
147 public:
148     static Ref&lt;DocumentLoader&gt; create(const ResourceRequest&amp; request, const SubstituteData&amp; data)
149     {
150         return adoptRef(*new DocumentLoader(request, data));
151     }



152     WEBCORE_EXPORT virtual ~DocumentLoader();
153 
154     void attachToFrame(Frame&amp;);
155 
156     WEBCORE_EXPORT virtual void detachFromFrame();
157 
158     WEBCORE_EXPORT FrameLoader* frameLoader() const;
159     WEBCORE_EXPORT SubresourceLoader* mainResourceLoader() const;
160     WEBCORE_EXPORT RefPtr&lt;SharedBuffer&gt; mainResourceData() const;
161 
162     DocumentWriter&amp; writer() const { return m_writer; }
163 
164     const ResourceRequest&amp; originalRequest() const;
165     const ResourceRequest&amp; originalRequestCopy() const;
166 
167     const ResourceRequest&amp; request() const;
168     ResourceRequest&amp; request();
169 
170     CachedResourceLoader&amp; cachedResourceLoader() { return m_cachedResourceLoader; }
171 
</pre>
<hr />
<pre>
216     RefPtr&lt;Archive&gt; popArchiveForSubframe(const String&amp; frameName, const URL&amp;);
217     WEBCORE_EXPORT SharedBuffer* parsedArchiveData() const;
218 
219     WEBCORE_EXPORT bool scheduleArchiveLoad(ResourceLoader&amp;, const ResourceRequest&amp;);
220 #endif
221 
222     void scheduleSubstituteResourceLoad(ResourceLoader&amp;, SubstituteResource&amp;);
223     void scheduleCannotShowURLError(ResourceLoader&amp;);
224 
225     // Return the ArchiveResource for the URL only when loading an Archive
226     WEBCORE_EXPORT ArchiveResource* archiveResourceForURL(const URL&amp;) const;
227 
228     WEBCORE_EXPORT RefPtr&lt;ArchiveResource&gt; mainResource() const;
229 
230     // Return an ArchiveResource for the URL, either creating from live data or
231     // pulling from the ArchiveResourceCollection.
232     WEBCORE_EXPORT RefPtr&lt;ArchiveResource&gt; subresource(const URL&amp;) const;
233 
234     WEBCORE_EXPORT Vector&lt;Ref&lt;ArchiveResource&gt;&gt; subresources() const;
235 
<span class="line-modified">236 #ifndef NDEBUG</span>
237     bool isSubstituteLoadPending(ResourceLoader*) const;
238 #endif
239     void cancelPendingSubstituteLoad(ResourceLoader*);
240 
241     void addResponse(const ResourceResponse&amp;);
242     const Vector&lt;ResourceResponse&gt;&amp; responses() const { return m_responses; }
243 
244     const NavigationAction&amp; triggeringAction() const { return m_triggeringAction; }
245     void setTriggeringAction(NavigationAction&amp;&amp;);
246     void setOverrideEncoding(const String&amp; encoding) { m_overrideEncoding = encoding; }
247     void setLastCheckedRequest(ResourceRequest&amp;&amp; request) { m_lastCheckedRequest = WTFMove(request); }
248     const ResourceRequest&amp; lastCheckedRequest()  { return m_lastCheckedRequest; }
249 
250     void stopRecordingResponses();
251     const StringWithDirection&amp; title() const { return m_pageTitle; }
252 
253     WEBCORE_EXPORT URL urlForHistory() const;
254     WEBCORE_EXPORT bool urlForHistoryReflectsFailure() const;
255 
256     // These accessors accommodate WebCore&#39;s somewhat fickle custom of creating history
257     // items for redirects, but only sometimes. For &quot;source&quot; and &quot;destination&quot;,
258     // these accessors return the URL that would have been used if a history
259     // item were created. This allows WebKit to link history items reflecting
260     // redirects into a chain from start to finish.
261     String clientRedirectSourceForHistory() const { return m_clientRedirectSourceForHistory; } // null if no client redirect occurred.
262     String clientRedirectDestinationForHistory() const { return urlForHistory(); }
263     void setClientRedirectSourceForHistory(const String&amp; clientRedirectSourceForHistory) { m_clientRedirectSourceForHistory = clientRedirectSourceForHistory; }
264 
265     String serverRedirectSourceForHistory() const { return (urlForHistory() == url() || url() == WTF::blankURL()) ? String() : urlForHistory().string(); } // null if no server redirect occurred.
266     String serverRedirectDestinationForHistory() const { return url(); }
267 
268     bool didCreateGlobalHistoryEntry() const { return m_didCreateGlobalHistoryEntry; }
269     void setDidCreateGlobalHistoryEntry(bool didCreateGlobalHistoryEntry) { m_didCreateGlobalHistoryEntry = didCreateGlobalHistoryEntry; }
270 
<span class="line-removed">271     bool subresourceLoadersArePageCacheAcceptable() const { return m_subresourceLoadersArePageCacheAcceptable; }</span>
<span class="line-removed">272 </span>
273     void setDefersLoading(bool);
274     void setMainResourceDataBufferingPolicy(DataBufferingPolicy);
275 
276     void startLoadingMainResource();
277     WEBCORE_EXPORT void cancelMainResourceLoad(const ResourceError&amp;);
278     void willContinueMainResourceLoadAfterRedirect(const ResourceRequest&amp;);
279 
280     bool isLoadingMainResource() const { return m_loadingMainResource; }
281     bool isLoadingMultipartContent() const { return m_isLoadingMultipartContent; }
282 
283     void stopLoadingPlugIns();
284     void stopLoadingSubresources();
285     WEBCORE_EXPORT void stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp;);
286 
287     bool userContentExtensionsEnabled() const { return m_userContentExtensionsEnabled; }
288     void setUserContentExtensionsEnabled(bool enabled) { m_userContentExtensionsEnabled = enabled; }
289 
290 #if ENABLE(DEVICE_ORIENTATION)
291     DeviceOrientationOrMotionPermissionState deviceOrientationAndMotionAccessState() const { return m_deviceOrientationAndMotionAccessState; }
292     void setDeviceOrientationAndMotionAccessState(DeviceOrientationOrMotionPermissionState state) { m_deviceOrientationAndMotionAccessState = state; }
293 #endif
294 
295     AutoplayPolicy autoplayPolicy() const { return m_autoplayPolicy; }
296     void setAutoplayPolicy(AutoplayPolicy policy) { m_autoplayPolicy = policy; }
297 
298     void setCustomUserAgent(const String&amp; customUserAgent) { m_customUserAgent = customUserAgent; }
299     const String&amp; customUserAgent() const { return m_customUserAgent; }
300 
<span class="line-modified">301     void setCustomJavaScriptUserAgentAsSiteSpecificQuirks(const String&amp; customUserAgent) { m_customJavaScriptUserAgentAsSiteSpecificQuirks = customUserAgent; }</span>
<span class="line-modified">302     const String&amp; customJavaScriptUserAgentAsSiteSpecificQuirks() const { return m_customJavaScriptUserAgentAsSiteSpecificQuirks; }</span>
303 
304     void setCustomNavigatorPlatform(const String&amp; customNavigatorPlatform) { m_customNavigatorPlatform = customNavigatorPlatform; }
305     const String&amp; customNavigatorPlatform() const { return m_customNavigatorPlatform; }
306 
307     OptionSet&lt;AutoplayQuirk&gt; allowedAutoplayQuirks() const { return m_allowedAutoplayQuirks; }
308     void setAllowedAutoplayQuirks(OptionSet&lt;AutoplayQuirk&gt; allowedQuirks) { m_allowedAutoplayQuirks = allowedQuirks; }
309 
310     PopUpPolicy popUpPolicy() const { return m_popUpPolicy; }
311     void setPopUpPolicy(PopUpPolicy popUpPolicy) { m_popUpPolicy = popUpPolicy; }
312 
313     MetaViewportPolicy metaViewportPolicy() const { return m_metaViewportPolicy; }
314     void setMetaViewportPolicy(MetaViewportPolicy policy) { m_metaViewportPolicy = policy; }
315 
316     MediaSourcePolicy mediaSourcePolicy() const { return m_mediaSourcePolicy; }
317     void setMediaSourcePolicy(MediaSourcePolicy policy) { m_mediaSourcePolicy = policy; }
318 
319     SimulatedMouseEventsDispatchPolicy simulatedMouseEventsDispatchPolicy() const { return m_simulatedMouseEventsDispatchPolicy; }
320     void setSimulatedMouseEventsDispatchPolicy(SimulatedMouseEventsDispatchPolicy policy) { m_simulatedMouseEventsDispatchPolicy = policy; }
321 
322     LegacyOverflowScrollingTouchPolicy legacyOverflowScrollingTouchPolicy() const { return m_legacyOverflowScrollingTouchPolicy; }
</pre>
<hr />
<pre>
334     void didTellClientAboutLoad(const String&amp; url);
335     bool haveToldClientAboutLoad(const String&amp; url) { return m_resourcesClientKnowsAbout.contains(url); }
336     void recordMemoryCacheLoadForFutureClientNotification(const ResourceRequest&amp;);
337     void takeMemoryCacheLoadsForClientNotification(Vector&lt;ResourceRequest&gt;&amp; loads);
338 
339     LoadTiming&amp; timing() { return m_loadTiming; }
340     void resetTiming() { m_loadTiming = LoadTiming(); }
341 
342     // The WebKit layer calls this function when it&#39;s ready for the data to actually be added to the document.
343     WEBCORE_EXPORT void commitData(const char* bytes, size_t length);
344 
345     ApplicationCacheHost&amp; applicationCacheHost() const;
346     ApplicationCacheHost* applicationCacheHostUnlessBeingDestroyed() const;
347 
348     void checkLoadComplete();
349 
350     // The URL of the document resulting from this DocumentLoader.
351     URL documentURL() const;
352 
353 #if USE(QUICK_LOOK)
<span class="line-modified">354     void setPreviewConverter(std::unique_ptr&lt;PreviewConverter&gt;&amp;&amp;);</span>
355     PreviewConverter* previewConverter() const;
356 #endif
357 
358 #if ENABLE(CONTENT_EXTENSIONS)
359     void addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp;);
360     void addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID);
361 #endif
362 
363     void setShouldOpenExternalURLsPolicy(ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy) { m_shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicy; }
364     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
365 
366 #if ENABLE(CONTENT_FILTERING)
<span class="line-modified">367     ContentFilter* contentFilter() const;</span>


368 #endif
369 
370     bool isAlwaysOnLoggingAllowed() const;
371 
372     void startIconLoading();
373     WEBCORE_EXPORT void didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID);
374     void finishedLoadingIcon(IconLoader&amp;, SharedBuffer*);
375 
376     const Vector&lt;LinkIcon&gt;&amp; linkIcons() const { return m_linkIcons; }
377 
378 #if ENABLE(APPLICATION_MANIFEST)
379     WEBCORE_EXPORT uint64_t loadApplicationManifest();
380     void finishedLoadingApplicationManifest(ApplicationManifestLoader&amp;);
381 #endif
382 
383     WEBCORE_EXPORT void setCustomHeaderFields(Vector&lt;CustomHeaderFields&gt;&amp;&amp;);
384     const Vector&lt;CustomHeaderFields&gt;&amp; customHeaderFields() const { return m_customHeaderFields; }
385 
386     void setAllowsWebArchiveForMainFrame(bool allowsWebArchiveForMainFrame) { m_allowsWebArchiveForMainFrame = allowsWebArchiveForMainFrame; }
387     bool allowsWebArchiveForMainFrame() const { return m_allowsWebArchiveForMainFrame; }
388 



389     void setDownloadAttribute(const String&amp; attribute) { m_downloadAttribute = attribute; }
390     const String&amp; downloadAttribute() const { return m_downloadAttribute; }
391 
392     WEBCORE_EXPORT void applyPoliciesToSettings();
393 
394     void setAllowContentChangeObserverQuirk(bool allow) { m_allowContentChangeObserverQuirk = allow; }
395     bool allowContentChangeObserverQuirk() const { return m_allowContentChangeObserverQuirk; }
396 




397 protected:
398     WEBCORE_EXPORT DocumentLoader(const ResourceRequest&amp;, const SubstituteData&amp;);
399 
400     WEBCORE_EXPORT virtual void attachToFrame();
401 
402     bool m_deferMainResourceDataLoad { true };
403 
404 private:
405     Document* document() const;
406 
407 #if ENABLE(SERVICE_WORKER)
408     void matchRegistration(const URL&amp;, CompletionHandler&lt;void(Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp;)&gt;&amp;&amp;);
409 #endif
<span class="line-removed">410     void registerTemporaryServiceWorkerClient(const URL&amp;);</span>
411     void unregisterTemporaryServiceWorkerClient();
412 
413     void loadMainResource(ResourceRequest&amp;&amp;);
414 
415     void setRequest(const ResourceRequest&amp;);
416 
417     void commitIfReady();
418     void setMainDocumentError(const ResourceError&amp;);
419     void commitLoad(const char*, int);
420     void clearMainResourceLoader();
421 
422     void setupForReplace();
423     void maybeFinishLoadingMultipartContent();
424 
425     bool maybeCreateArchive();
426 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
427     void clearArchiveResources();
428 #endif
429 
430     void willSendRequest(ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
431     void finishedLoading();
432     void mainReceivedError(const ResourceError&amp;);
433     WEBCORE_EXPORT void redirectReceived(CachedResource&amp;, ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;) override;
434     WEBCORE_EXPORT void responseReceived(CachedResource&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;) override;
435     WEBCORE_EXPORT void dataReceived(CachedResource&amp;, const char* data, int length) override;
436     WEBCORE_EXPORT void notifyFinished(CachedResource&amp;) override;



437 
438     void responseReceived(const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;);









439     void dataReceived(const char* data, int length);
440 
441     bool maybeLoadEmpty();
442 
443     bool isMultipartReplacingLoad() const;
444     bool isPostOrRedirectAfterPost(const ResourceRequest&amp;, const ResourceResponse&amp;);
445 
446     bool tryLoadingRequestFromApplicationCache();
447     bool tryLoadingSubstituteData();
448     bool tryLoadingRedirectRequestFromApplicationCache(const ResourceRequest&amp;);
<span class="line-removed">449 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-removed">450     void restartLoadingDueToServiceWorkerRegistrationChange(ResourceRequest&amp;&amp;, Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp;);</span>
<span class="line-removed">451 #endif</span>
452     void continueAfterContentPolicy(PolicyAction);
453 
454     void stopLoadingForPolicyChange();
455     ResourceError interruptedForPolicyChangeError() const;
456 
457 #if HAVE(RUNLOOP_TIMER)
458     typedef RunLoopTimer&lt;DocumentLoader&gt; DocumentLoaderTimer;
459 #else
460     typedef Timer DocumentLoaderTimer;
461 #endif
462     void handleSubstituteDataLoadNow();
463     void startDataLoadTimer();
464 
465     void deliverSubstituteResourcesAfterDelay();
466     void substituteResourceDeliveryTimerFired();
467 
468     void clearMainResource();
469 
470     void cancelPolicyCheckIfNeeded();
471     void becomeMainResourceClient();
472 
473     void notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer*);
474 
475 #if ENABLE(APPLICATION_MANIFEST)
476     void notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt;);
477 #endif
478 
479     // ContentSecurityPolicyClient
480     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp;, unsigned long requestIdentifier) final;
481     WEBCORE_EXPORT void sendCSPViolationReport(URL&amp;&amp;, Ref&lt;FormData&gt;&amp;&amp;) final;
482     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;) final;
483 
484     bool disallowWebArchive() const;

485 
486     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
487 
488     CachedResourceHandle&lt;CachedRawResource&gt; m_mainResource;
489     ResourceLoaderMap m_subresourceLoaders;
490     ResourceLoaderMap m_multipartSubresourceLoaders;
491     ResourceLoaderMap m_plugInStreamLoaders;
492 
493     mutable DocumentWriter m_writer;
494 
495     // A reference to actual request used to create the data source.
496     // This should only be used by the resourceLoadDelegate&#39;s
497     // identifierForInitialRequest:fromDatasource: method. It is
498     // not guaranteed to remain unchanged, as requests are mutable.
499     ResourceRequest m_originalRequest;
500 
501     SubstituteData m_substituteData;
502 
503     // A copy of the original request used to create the data source.
504     // We have to copy the request because requests are mutable.
</pre>
<hr />
<pre>
521     bool m_isLoadingMultipartContent { false };
522 
523     // FIXME: Document::m_processingLoadEvent and DocumentLoader::m_wasOnloadDispatched are roughly the same
524     // and should be merged.
525     bool m_wasOnloadDispatched { false };
526 
527     StringWithDirection m_pageTitle;
528 
529     String m_overrideEncoding;
530 
531     // The action that triggered loading - we keep this around for the
532     // benefit of the various policy handlers.
533     NavigationAction m_triggeringAction;
534 
535     // The last request that we checked click policy for - kept around
536     // so we can avoid asking again needlessly.
537     ResourceRequest m_lastCheckedRequest;
538 
539     // We retain all the received responses so we can play back the
540     // WebResourceLoadDelegate messages if the item is loaded from the
<span class="line-modified">541     // page cache.</span>
542     Vector&lt;ResourceResponse&gt; m_responses;
543     bool m_stopRecordingResponses { false };
544 
545     typedef HashMap&lt;RefPtr&lt;ResourceLoader&gt;, RefPtr&lt;SubstituteResource&gt;&gt; SubstituteResourceMap;
546     SubstituteResourceMap m_pendingSubstituteResources;
547     Timer m_substituteResourceDeliveryTimer;
548 
549     std::unique_ptr&lt;ArchiveResourceCollection&gt; m_archiveResourceCollection;
550 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
551     RefPtr&lt;Archive&gt; m_archive;
552     RefPtr&lt;SharedBuffer&gt; m_parsedArchiveData;
553 #endif
554 
555     HashSet&lt;String&gt; m_resourcesClientKnowsAbout;
556     Vector&lt;ResourceRequest&gt; m_resourcesLoadedFromMemoryCacheForClientNotification;
557 
558     String m_clientRedirectSourceForHistory;
559     bool m_didCreateGlobalHistoryEntry { false };
560 
561     bool m_loadingMainResource { false };
562     LoadTiming m_loadTiming;
563 
564     MonotonicTime m_timeOfLastDataReceived;
565     unsigned long m_identifierForLoadWithoutResourceLoader { 0 };
566 
567     DocumentLoaderTimer m_dataLoadTimer;
568     bool m_waitingForContentPolicy { false };
569     bool m_waitingForNavigationPolicy { false };
570 
571     HashMap&lt;uint64_t, LinkIcon&gt; m_iconsPendingLoadDecision;
572     HashMap&lt;std::unique_ptr&lt;IconLoader&gt;, uint64_t&gt; m_iconLoaders;
573     Vector&lt;LinkIcon&gt; m_linkIcons;
574 
575 #if ENABLE(APPLICATION_MANIFEST)
576     HashMap&lt;std::unique_ptr&lt;ApplicationManifestLoader&gt;, uint64_t&gt; m_applicationManifestLoaders;
577 #endif
578 
579     Vector&lt;CustomHeaderFields&gt; m_customHeaderFields;
580 
<span class="line-removed">581     bool m_subresourceLoadersArePageCacheAcceptable { false };</span>
582     ShouldOpenExternalURLsPolicy m_shouldOpenExternalURLsPolicy { ShouldOpenExternalURLsPolicy::ShouldNotAllow };
583 
584     std::unique_ptr&lt;ApplicationCacheHost&gt; m_applicationCacheHost;
585 
586 #if ENABLE(CONTENT_FILTERING)
587     std::unique_ptr&lt;ContentFilter&gt; m_contentFilter;
588 #endif
589 
590 #if USE(QUICK_LOOK)
<span class="line-modified">591     std::unique_ptr&lt;PreviewConverter&gt; m_previewConverter;</span>
592 #endif
593 
594 #if ENABLE(CONTENT_EXTENSIONS)
595     HashMap&lt;String, RefPtr&lt;StyleSheetContents&gt;&gt; m_pendingNamedContentExtensionStyleSheets;
596     HashMap&lt;String, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;&gt; m_pendingContentExtensionDisplayNoneSelectors;
597 #endif
598     String m_customUserAgent;
<span class="line-modified">599     String m_customJavaScriptUserAgentAsSiteSpecificQuirks;</span>
600     bool m_allowContentChangeObserverQuirk { false };
601     String m_customNavigatorPlatform;
602     bool m_userContentExtensionsEnabled { true };
603 #if ENABLE(DEVICE_ORIENTATION)
604     DeviceOrientationOrMotionPermissionState m_deviceOrientationAndMotionAccessState { DeviceOrientationOrMotionPermissionState::Prompt };
605 #endif
606     AutoplayPolicy m_autoplayPolicy { AutoplayPolicy::Default };
607     OptionSet&lt;AutoplayQuirk&gt; m_allowedAutoplayQuirks;
608     PopUpPolicy m_popUpPolicy { PopUpPolicy::Default };
609     MetaViewportPolicy m_metaViewportPolicy { MetaViewportPolicy::Default };
610     MediaSourcePolicy m_mediaSourcePolicy { MediaSourcePolicy::Default };
611     SimulatedMouseEventsDispatchPolicy m_simulatedMouseEventsDispatchPolicy { SimulatedMouseEventsDispatchPolicy::Default };
612     LegacyOverflowScrollingTouchPolicy m_legacyOverflowScrollingTouchPolicy { LegacyOverflowScrollingTouchPolicy::Default };
613 
614 #if ENABLE(SERVICE_WORKER)
615     Optional&lt;ServiceWorkerRegistrationData&gt; m_serviceWorkerRegistrationData;
<span class="line-modified">616     struct TemporaryServiceWorkerClient {</span>
<span class="line-removed">617         DocumentIdentifier documentIdentifier;</span>
<span class="line-removed">618         PAL::SessionID sessionID;</span>
<span class="line-removed">619     };</span>
<span class="line-removed">620     Optional&lt;TemporaryServiceWorkerClient&gt; m_temporaryServiceWorkerClient;</span>
621 #endif
622 
<span class="line-modified">623 #ifndef NDEBUG</span>
624     bool m_hasEverBeenAttached { false };
625 #endif
626 
627     bool m_allowsWebArchiveForMainFrame { false };

628     String m_downloadAttribute;
629 };
630 
631 inline void DocumentLoader::recordMemoryCacheLoadForFutureClientNotification(const ResourceRequest&amp; request)
632 {
633     m_resourcesLoadedFromMemoryCacheForClientNotification.append(request);
634 }
635 
636 inline void DocumentLoader::takeMemoryCacheLoadsForClientNotification(Vector&lt;ResourceRequest&gt;&amp; loadsSet)
637 {
638     loadsSet.swap(m_resourcesLoadedFromMemoryCacheForClientNotification);
639     m_resourcesLoadedFromMemoryCacheForClientNotification.clear();
640 }
641 
642 inline const ResourceRequest&amp; DocumentLoader::originalRequest() const
643 {
644     return m_originalRequest;
645 }
646 
647 inline const ResourceRequest&amp; DocumentLoader::originalRequestCopy() const
</pre>
<hr />
<pre>
685 }
686 
687 inline const URL&amp; DocumentLoader::unreachableURL() const
688 {
689     return m_substituteData.failingURL();
690 }
691 
692 inline ApplicationCacheHost&amp; DocumentLoader::applicationCacheHost() const
693 {
694     // For a short time while the document loader is being destroyed, m_applicationCacheHost is null.
695     // It&#39;s not acceptable to call this function during that time.
696     ASSERT(m_applicationCacheHost);
697     return *m_applicationCacheHost;
698 }
699 
700 inline ApplicationCacheHost* DocumentLoader::applicationCacheHostUnlessBeingDestroyed() const
701 {
702     return m_applicationCacheHost.get();
703 }
704 
<span class="line-removed">705 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-removed">706 </span>
<span class="line-removed">707 inline ContentFilter* DocumentLoader::contentFilter() const</span>
<span class="line-removed">708 {</span>
<span class="line-removed">709     return m_contentFilter.get();</span>
<span class="line-removed">710 }</span>
<span class="line-removed">711 </span>
<span class="line-removed">712 #endif</span>
<span class="line-removed">713 </span>
714 inline void DocumentLoader::didTellClientAboutLoad(const String&amp; url)
715 {
716 #if !PLATFORM(COCOA)
717     // Don&#39;t include data URLs here, as if a lot of data is loaded that way, we hold on to the (large) URL string for too long.
718     if (protocolIs(url, &quot;data&quot;))
719         return;
720 #endif
721     if (!url.isEmpty())
722         m_resourcesClientKnowsAbout.add(url);
723 }
724 
725 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;CachedRawResourceClient.h&quot;
 33 #include &quot;CachedResourceHandle.h&quot;
<span class="line-added"> 34 #include &quot;ContentFilterClient.h&quot;</span>
 35 #include &quot;ContentSecurityPolicyClient.h&quot;
 36 #include &quot;DeviceOrientationOrMotionPermissionState.h&quot;
 37 #include &quot;DocumentIdentifier.h&quot;
 38 #include &quot;DocumentWriter.h&quot;
 39 #include &quot;FrameDestructionObserver.h&quot;
 40 #include &quot;LinkIcon.h&quot;
 41 #include &quot;LoadTiming.h&quot;
 42 #include &quot;NavigationAction.h&quot;
 43 #include &quot;ResourceError.h&quot;
 44 #include &quot;ResourceLoaderOptions.h&quot;
 45 #include &quot;ResourceRequest.h&quot;
 46 #include &quot;ResourceResponse.h&quot;
 47 #include &quot;SecurityPolicyViolationEvent.h&quot;
 48 #include &quot;ServiceWorkerRegistrationData.h&quot;
 49 #include &quot;StringWithDirection.h&quot;
 50 #include &quot;StyleSheetContents.h&quot;
 51 #include &quot;SubstituteData.h&quot;
 52 #include &quot;Timer.h&quot;
 53 #include &lt;wtf/HashSet.h&gt;
 54 #include &lt;wtf/OptionSet.h&gt;
</pre>
<hr />
<pre>
121 };
122 
123 enum class MediaSourcePolicy : uint8_t {
124     Default,
125     Disable,
126     Enable
127 };
128 
129 enum class SimulatedMouseEventsDispatchPolicy : uint8_t {
130     Default,
131     Allow,
132     Deny,
133 };
134 
135 enum class LegacyOverflowScrollingTouchPolicy : uint8_t {
136     Default,
137     Disable,
138     Enable,
139 };
140 
<span class="line-added">141 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DocumentLoader);</span>
142 class DocumentLoader
143     : public RefCounted&lt;DocumentLoader&gt;
144     , public FrameDestructionObserver
145     , public ContentSecurityPolicyClient
<span class="line-added">146 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">147     , public ContentFilterClient</span>
<span class="line-added">148 #endif</span>
149     , private CachedRawResourceClient {
<span class="line-modified">150     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(DocumentLoader);</span>
151     friend class ContentFilter;
152 public:
153     static Ref&lt;DocumentLoader&gt; create(const ResourceRequest&amp; request, const SubstituteData&amp; data)
154     {
155         return adoptRef(*new DocumentLoader(request, data));
156     }
<span class="line-added">157 </span>
<span class="line-added">158     WEBCORE_EXPORT static DocumentLoader* fromTemporaryDocumentIdentifier(DocumentIdentifier);</span>
<span class="line-added">159 </span>
160     WEBCORE_EXPORT virtual ~DocumentLoader();
161 
162     void attachToFrame(Frame&amp;);
163 
164     WEBCORE_EXPORT virtual void detachFromFrame();
165 
166     WEBCORE_EXPORT FrameLoader* frameLoader() const;
167     WEBCORE_EXPORT SubresourceLoader* mainResourceLoader() const;
168     WEBCORE_EXPORT RefPtr&lt;SharedBuffer&gt; mainResourceData() const;
169 
170     DocumentWriter&amp; writer() const { return m_writer; }
171 
172     const ResourceRequest&amp; originalRequest() const;
173     const ResourceRequest&amp; originalRequestCopy() const;
174 
175     const ResourceRequest&amp; request() const;
176     ResourceRequest&amp; request();
177 
178     CachedResourceLoader&amp; cachedResourceLoader() { return m_cachedResourceLoader; }
179 
</pre>
<hr />
<pre>
224     RefPtr&lt;Archive&gt; popArchiveForSubframe(const String&amp; frameName, const URL&amp;);
225     WEBCORE_EXPORT SharedBuffer* parsedArchiveData() const;
226 
227     WEBCORE_EXPORT bool scheduleArchiveLoad(ResourceLoader&amp;, const ResourceRequest&amp;);
228 #endif
229 
230     void scheduleSubstituteResourceLoad(ResourceLoader&amp;, SubstituteResource&amp;);
231     void scheduleCannotShowURLError(ResourceLoader&amp;);
232 
233     // Return the ArchiveResource for the URL only when loading an Archive
234     WEBCORE_EXPORT ArchiveResource* archiveResourceForURL(const URL&amp;) const;
235 
236     WEBCORE_EXPORT RefPtr&lt;ArchiveResource&gt; mainResource() const;
237 
238     // Return an ArchiveResource for the URL, either creating from live data or
239     // pulling from the ArchiveResourceCollection.
240     WEBCORE_EXPORT RefPtr&lt;ArchiveResource&gt; subresource(const URL&amp;) const;
241 
242     WEBCORE_EXPORT Vector&lt;Ref&lt;ArchiveResource&gt;&gt; subresources() const;
243 
<span class="line-modified">244 #if ASSERT_ENABLED</span>
245     bool isSubstituteLoadPending(ResourceLoader*) const;
246 #endif
247     void cancelPendingSubstituteLoad(ResourceLoader*);
248 
249     void addResponse(const ResourceResponse&amp;);
250     const Vector&lt;ResourceResponse&gt;&amp; responses() const { return m_responses; }
251 
252     const NavigationAction&amp; triggeringAction() const { return m_triggeringAction; }
253     void setTriggeringAction(NavigationAction&amp;&amp;);
254     void setOverrideEncoding(const String&amp; encoding) { m_overrideEncoding = encoding; }
255     void setLastCheckedRequest(ResourceRequest&amp;&amp; request) { m_lastCheckedRequest = WTFMove(request); }
256     const ResourceRequest&amp; lastCheckedRequest()  { return m_lastCheckedRequest; }
257 
258     void stopRecordingResponses();
259     const StringWithDirection&amp; title() const { return m_pageTitle; }
260 
261     WEBCORE_EXPORT URL urlForHistory() const;
262     WEBCORE_EXPORT bool urlForHistoryReflectsFailure() const;
263 
264     // These accessors accommodate WebCore&#39;s somewhat fickle custom of creating history
265     // items for redirects, but only sometimes. For &quot;source&quot; and &quot;destination&quot;,
266     // these accessors return the URL that would have been used if a history
267     // item were created. This allows WebKit to link history items reflecting
268     // redirects into a chain from start to finish.
269     String clientRedirectSourceForHistory() const { return m_clientRedirectSourceForHistory; } // null if no client redirect occurred.
270     String clientRedirectDestinationForHistory() const { return urlForHistory(); }
271     void setClientRedirectSourceForHistory(const String&amp; clientRedirectSourceForHistory) { m_clientRedirectSourceForHistory = clientRedirectSourceForHistory; }
272 
273     String serverRedirectSourceForHistory() const { return (urlForHistory() == url() || url() == WTF::blankURL()) ? String() : urlForHistory().string(); } // null if no server redirect occurred.
274     String serverRedirectDestinationForHistory() const { return url(); }
275 
276     bool didCreateGlobalHistoryEntry() const { return m_didCreateGlobalHistoryEntry; }
277     void setDidCreateGlobalHistoryEntry(bool didCreateGlobalHistoryEntry) { m_didCreateGlobalHistoryEntry = didCreateGlobalHistoryEntry; }
278 


279     void setDefersLoading(bool);
280     void setMainResourceDataBufferingPolicy(DataBufferingPolicy);
281 
282     void startLoadingMainResource();
283     WEBCORE_EXPORT void cancelMainResourceLoad(const ResourceError&amp;);
284     void willContinueMainResourceLoadAfterRedirect(const ResourceRequest&amp;);
285 
286     bool isLoadingMainResource() const { return m_loadingMainResource; }
287     bool isLoadingMultipartContent() const { return m_isLoadingMultipartContent; }
288 
289     void stopLoadingPlugIns();
290     void stopLoadingSubresources();
291     WEBCORE_EXPORT void stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp;);
292 
293     bool userContentExtensionsEnabled() const { return m_userContentExtensionsEnabled; }
294     void setUserContentExtensionsEnabled(bool enabled) { m_userContentExtensionsEnabled = enabled; }
295 
296 #if ENABLE(DEVICE_ORIENTATION)
297     DeviceOrientationOrMotionPermissionState deviceOrientationAndMotionAccessState() const { return m_deviceOrientationAndMotionAccessState; }
298     void setDeviceOrientationAndMotionAccessState(DeviceOrientationOrMotionPermissionState state) { m_deviceOrientationAndMotionAccessState = state; }
299 #endif
300 
301     AutoplayPolicy autoplayPolicy() const { return m_autoplayPolicy; }
302     void setAutoplayPolicy(AutoplayPolicy policy) { m_autoplayPolicy = policy; }
303 
304     void setCustomUserAgent(const String&amp; customUserAgent) { m_customUserAgent = customUserAgent; }
305     const String&amp; customUserAgent() const { return m_customUserAgent; }
306 
<span class="line-modified">307     void setCustomUserAgentAsSiteSpecificQuirks(const String&amp; customUserAgent) { m_customUserAgentAsSiteSpecificQuirks = customUserAgent; }</span>
<span class="line-modified">308     const String&amp; customUserAgentAsSiteSpecificQuirks() const { return m_customUserAgentAsSiteSpecificQuirks; }</span>
309 
310     void setCustomNavigatorPlatform(const String&amp; customNavigatorPlatform) { m_customNavigatorPlatform = customNavigatorPlatform; }
311     const String&amp; customNavigatorPlatform() const { return m_customNavigatorPlatform; }
312 
313     OptionSet&lt;AutoplayQuirk&gt; allowedAutoplayQuirks() const { return m_allowedAutoplayQuirks; }
314     void setAllowedAutoplayQuirks(OptionSet&lt;AutoplayQuirk&gt; allowedQuirks) { m_allowedAutoplayQuirks = allowedQuirks; }
315 
316     PopUpPolicy popUpPolicy() const { return m_popUpPolicy; }
317     void setPopUpPolicy(PopUpPolicy popUpPolicy) { m_popUpPolicy = popUpPolicy; }
318 
319     MetaViewportPolicy metaViewportPolicy() const { return m_metaViewportPolicy; }
320     void setMetaViewportPolicy(MetaViewportPolicy policy) { m_metaViewportPolicy = policy; }
321 
322     MediaSourcePolicy mediaSourcePolicy() const { return m_mediaSourcePolicy; }
323     void setMediaSourcePolicy(MediaSourcePolicy policy) { m_mediaSourcePolicy = policy; }
324 
325     SimulatedMouseEventsDispatchPolicy simulatedMouseEventsDispatchPolicy() const { return m_simulatedMouseEventsDispatchPolicy; }
326     void setSimulatedMouseEventsDispatchPolicy(SimulatedMouseEventsDispatchPolicy policy) { m_simulatedMouseEventsDispatchPolicy = policy; }
327 
328     LegacyOverflowScrollingTouchPolicy legacyOverflowScrollingTouchPolicy() const { return m_legacyOverflowScrollingTouchPolicy; }
</pre>
<hr />
<pre>
340     void didTellClientAboutLoad(const String&amp; url);
341     bool haveToldClientAboutLoad(const String&amp; url) { return m_resourcesClientKnowsAbout.contains(url); }
342     void recordMemoryCacheLoadForFutureClientNotification(const ResourceRequest&amp;);
343     void takeMemoryCacheLoadsForClientNotification(Vector&lt;ResourceRequest&gt;&amp; loads);
344 
345     LoadTiming&amp; timing() { return m_loadTiming; }
346     void resetTiming() { m_loadTiming = LoadTiming(); }
347 
348     // The WebKit layer calls this function when it&#39;s ready for the data to actually be added to the document.
349     WEBCORE_EXPORT void commitData(const char* bytes, size_t length);
350 
351     ApplicationCacheHost&amp; applicationCacheHost() const;
352     ApplicationCacheHost* applicationCacheHostUnlessBeingDestroyed() const;
353 
354     void checkLoadComplete();
355 
356     // The URL of the document resulting from this DocumentLoader.
357     URL documentURL() const;
358 
359 #if USE(QUICK_LOOK)
<span class="line-modified">360     void setPreviewConverter(RefPtr&lt;PreviewConverter&gt;&amp;&amp;);</span>
361     PreviewConverter* previewConverter() const;
362 #endif
363 
364 #if ENABLE(CONTENT_EXTENSIONS)
365     void addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp;);
366     void addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID);
367 #endif
368 
369     void setShouldOpenExternalURLsPolicy(ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy) { m_shouldOpenExternalURLsPolicy = shouldOpenExternalURLsPolicy; }
370     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
371 
372 #if ENABLE(CONTENT_FILTERING)
<span class="line-modified">373     ContentFilter* contentFilter() const { return m_contentFilter.get(); }</span>
<span class="line-added">374     void ref() const final { RefCounted&lt;DocumentLoader&gt;::ref(); }</span>
<span class="line-added">375     void deref() const final { RefCounted&lt;DocumentLoader&gt;::deref(); }</span>
376 #endif
377 
378     bool isAlwaysOnLoggingAllowed() const;
379 
380     void startIconLoading();
381     WEBCORE_EXPORT void didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID);
382     void finishedLoadingIcon(IconLoader&amp;, SharedBuffer*);
383 
384     const Vector&lt;LinkIcon&gt;&amp; linkIcons() const { return m_linkIcons; }
385 
386 #if ENABLE(APPLICATION_MANIFEST)
387     WEBCORE_EXPORT uint64_t loadApplicationManifest();
388     void finishedLoadingApplicationManifest(ApplicationManifestLoader&amp;);
389 #endif
390 
391     WEBCORE_EXPORT void setCustomHeaderFields(Vector&lt;CustomHeaderFields&gt;&amp;&amp;);
392     const Vector&lt;CustomHeaderFields&gt;&amp; customHeaderFields() const { return m_customHeaderFields; }
393 
394     void setAllowsWebArchiveForMainFrame(bool allowsWebArchiveForMainFrame) { m_allowsWebArchiveForMainFrame = allowsWebArchiveForMainFrame; }
395     bool allowsWebArchiveForMainFrame() const { return m_allowsWebArchiveForMainFrame; }
396 
<span class="line-added">397     void setAllowsDataURLsForMainFrame(bool allowsDataURLsForMainFrame) { m_allowsDataURLsForMainFrame = allowsDataURLsForMainFrame; }</span>
<span class="line-added">398     bool allowsDataURLsForMainFrame() const { return m_allowsDataURLsForMainFrame; }</span>
<span class="line-added">399 </span>
400     void setDownloadAttribute(const String&amp; attribute) { m_downloadAttribute = attribute; }
401     const String&amp; downloadAttribute() const { return m_downloadAttribute; }
402 
403     WEBCORE_EXPORT void applyPoliciesToSettings();
404 
405     void setAllowContentChangeObserverQuirk(bool allow) { m_allowContentChangeObserverQuirk = allow; }
406     bool allowContentChangeObserverQuirk() const { return m_allowContentChangeObserverQuirk; }
407 
<span class="line-added">408 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">409     WEBCORE_EXPORT bool setControllingServiceWorkerRegistration(ServiceWorkerRegistrationData&amp;&amp;);</span>
<span class="line-added">410 #endif</span>
<span class="line-added">411 </span>
412 protected:
413     WEBCORE_EXPORT DocumentLoader(const ResourceRequest&amp;, const SubstituteData&amp;);
414 
415     WEBCORE_EXPORT virtual void attachToFrame();
416 
417     bool m_deferMainResourceDataLoad { true };
418 
419 private:
420     Document* document() const;
421 
422 #if ENABLE(SERVICE_WORKER)
423     void matchRegistration(const URL&amp;, CompletionHandler&lt;void(Optional&lt;ServiceWorkerRegistrationData&gt;&amp;&amp;)&gt;&amp;&amp;);
424 #endif

425     void unregisterTemporaryServiceWorkerClient();
426 
427     void loadMainResource(ResourceRequest&amp;&amp;);
428 
429     void setRequest(const ResourceRequest&amp;);
430 
431     void commitIfReady();
432     void setMainDocumentError(const ResourceError&amp;);
433     void commitLoad(const char*, int);
434     void clearMainResourceLoader();
435 
436     void setupForReplace();
437     void maybeFinishLoadingMultipartContent();
438 
439     bool maybeCreateArchive();
440 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
441     void clearArchiveResources();
442 #endif
443 
444     void willSendRequest(ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
445     void finishedLoading();
446     void mainReceivedError(const ResourceError&amp;);
447     WEBCORE_EXPORT void redirectReceived(CachedResource&amp;, ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;) override;
448     WEBCORE_EXPORT void responseReceived(CachedResource&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;) override;
449     WEBCORE_EXPORT void dataReceived(CachedResource&amp;, const char* data, int length) override;
450     WEBCORE_EXPORT void notifyFinished(CachedResource&amp;) override;
<span class="line-added">451 #if USE(QUICK_LOOK)</span>
<span class="line-added">452     WEBCORE_EXPORT void previewResponseReceived(CachedResource&amp;, const ResourceResponse&amp;) override;</span>
<span class="line-added">453 #endif</span>
454 
455     void responseReceived(const ResourceResponse&amp;, CompletionHandler&lt;void()&gt;&amp;&amp;);
<span class="line-added">456 </span>
<span class="line-added">457 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">458     // ContentFilterClient</span>
<span class="line-added">459     WEBCORE_EXPORT void dataReceivedThroughContentFilter(const char*, int) final;</span>
<span class="line-added">460     WEBCORE_EXPORT ResourceError contentFilterDidBlock(ContentFilterUnblockHandler, String&amp;&amp; unblockRequestDeniedScript) final;</span>
<span class="line-added">461     WEBCORE_EXPORT void cancelMainResourceLoadForContentFilter(const ResourceError&amp;) final;</span>
<span class="line-added">462     WEBCORE_EXPORT void handleProvisionalLoadFailureFromContentFilter(const URL&amp; blockedPageURL, SubstituteData&amp;) final;</span>
<span class="line-added">463 #endif</span>
<span class="line-added">464 </span>
465     void dataReceived(const char* data, int length);
466 
467     bool maybeLoadEmpty();
468 
469     bool isMultipartReplacingLoad() const;
470     bool isPostOrRedirectAfterPost(const ResourceRequest&amp;, const ResourceResponse&amp;);
471 
472     bool tryLoadingRequestFromApplicationCache();
473     bool tryLoadingSubstituteData();
474     bool tryLoadingRedirectRequestFromApplicationCache(const ResourceRequest&amp;);



475     void continueAfterContentPolicy(PolicyAction);
476 
477     void stopLoadingForPolicyChange();
478     ResourceError interruptedForPolicyChangeError() const;
479 
480 #if HAVE(RUNLOOP_TIMER)
481     typedef RunLoopTimer&lt;DocumentLoader&gt; DocumentLoaderTimer;
482 #else
483     typedef Timer DocumentLoaderTimer;
484 #endif
485     void handleSubstituteDataLoadNow();
486     void startDataLoadTimer();
487 
488     void deliverSubstituteResourcesAfterDelay();
489     void substituteResourceDeliveryTimerFired();
490 
491     void clearMainResource();
492 
493     void cancelPolicyCheckIfNeeded();
494     void becomeMainResourceClient();
495 
496     void notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer*);
497 
498 #if ENABLE(APPLICATION_MANIFEST)
499     void notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt;);
500 #endif
501 
502     // ContentSecurityPolicyClient
503     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp;, unsigned long requestIdentifier) final;
504     WEBCORE_EXPORT void sendCSPViolationReport(URL&amp;&amp;, Ref&lt;FormData&gt;&amp;&amp;) final;
505     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;) final;
506 
507     bool disallowWebArchive() const;
<span class="line-added">508     bool disallowDataRequest() const;</span>
509 
510     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
511 
512     CachedResourceHandle&lt;CachedRawResource&gt; m_mainResource;
513     ResourceLoaderMap m_subresourceLoaders;
514     ResourceLoaderMap m_multipartSubresourceLoaders;
515     ResourceLoaderMap m_plugInStreamLoaders;
516 
517     mutable DocumentWriter m_writer;
518 
519     // A reference to actual request used to create the data source.
520     // This should only be used by the resourceLoadDelegate&#39;s
521     // identifierForInitialRequest:fromDatasource: method. It is
522     // not guaranteed to remain unchanged, as requests are mutable.
523     ResourceRequest m_originalRequest;
524 
525     SubstituteData m_substituteData;
526 
527     // A copy of the original request used to create the data source.
528     // We have to copy the request because requests are mutable.
</pre>
<hr />
<pre>
545     bool m_isLoadingMultipartContent { false };
546 
547     // FIXME: Document::m_processingLoadEvent and DocumentLoader::m_wasOnloadDispatched are roughly the same
548     // and should be merged.
549     bool m_wasOnloadDispatched { false };
550 
551     StringWithDirection m_pageTitle;
552 
553     String m_overrideEncoding;
554 
555     // The action that triggered loading - we keep this around for the
556     // benefit of the various policy handlers.
557     NavigationAction m_triggeringAction;
558 
559     // The last request that we checked click policy for - kept around
560     // so we can avoid asking again needlessly.
561     ResourceRequest m_lastCheckedRequest;
562 
563     // We retain all the received responses so we can play back the
564     // WebResourceLoadDelegate messages if the item is loaded from the
<span class="line-modified">565     // back/forward cache.</span>
566     Vector&lt;ResourceResponse&gt; m_responses;
567     bool m_stopRecordingResponses { false };
568 
569     typedef HashMap&lt;RefPtr&lt;ResourceLoader&gt;, RefPtr&lt;SubstituteResource&gt;&gt; SubstituteResourceMap;
570     SubstituteResourceMap m_pendingSubstituteResources;
571     Timer m_substituteResourceDeliveryTimer;
572 
573     std::unique_ptr&lt;ArchiveResourceCollection&gt; m_archiveResourceCollection;
574 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
575     RefPtr&lt;Archive&gt; m_archive;
576     RefPtr&lt;SharedBuffer&gt; m_parsedArchiveData;
577 #endif
578 
579     HashSet&lt;String&gt; m_resourcesClientKnowsAbout;
580     Vector&lt;ResourceRequest&gt; m_resourcesLoadedFromMemoryCacheForClientNotification;
581 
582     String m_clientRedirectSourceForHistory;
583     bool m_didCreateGlobalHistoryEntry { false };
584 
585     bool m_loadingMainResource { false };
586     LoadTiming m_loadTiming;
587 
588     MonotonicTime m_timeOfLastDataReceived;
589     unsigned long m_identifierForLoadWithoutResourceLoader { 0 };
590 
591     DocumentLoaderTimer m_dataLoadTimer;
592     bool m_waitingForContentPolicy { false };
593     bool m_waitingForNavigationPolicy { false };
594 
595     HashMap&lt;uint64_t, LinkIcon&gt; m_iconsPendingLoadDecision;
596     HashMap&lt;std::unique_ptr&lt;IconLoader&gt;, uint64_t&gt; m_iconLoaders;
597     Vector&lt;LinkIcon&gt; m_linkIcons;
598 
599 #if ENABLE(APPLICATION_MANIFEST)
600     HashMap&lt;std::unique_ptr&lt;ApplicationManifestLoader&gt;, uint64_t&gt; m_applicationManifestLoaders;
601 #endif
602 
603     Vector&lt;CustomHeaderFields&gt; m_customHeaderFields;
604 

605     ShouldOpenExternalURLsPolicy m_shouldOpenExternalURLsPolicy { ShouldOpenExternalURLsPolicy::ShouldNotAllow };
606 
607     std::unique_ptr&lt;ApplicationCacheHost&gt; m_applicationCacheHost;
608 
609 #if ENABLE(CONTENT_FILTERING)
610     std::unique_ptr&lt;ContentFilter&gt; m_contentFilter;
611 #endif
612 
613 #if USE(QUICK_LOOK)
<span class="line-modified">614     RefPtr&lt;PreviewConverter&gt; m_previewConverter;</span>
615 #endif
616 
617 #if ENABLE(CONTENT_EXTENSIONS)
618     HashMap&lt;String, RefPtr&lt;StyleSheetContents&gt;&gt; m_pendingNamedContentExtensionStyleSheets;
619     HashMap&lt;String, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;&gt; m_pendingContentExtensionDisplayNoneSelectors;
620 #endif
621     String m_customUserAgent;
<span class="line-modified">622     String m_customUserAgentAsSiteSpecificQuirks;</span>
623     bool m_allowContentChangeObserverQuirk { false };
624     String m_customNavigatorPlatform;
625     bool m_userContentExtensionsEnabled { true };
626 #if ENABLE(DEVICE_ORIENTATION)
627     DeviceOrientationOrMotionPermissionState m_deviceOrientationAndMotionAccessState { DeviceOrientationOrMotionPermissionState::Prompt };
628 #endif
629     AutoplayPolicy m_autoplayPolicy { AutoplayPolicy::Default };
630     OptionSet&lt;AutoplayQuirk&gt; m_allowedAutoplayQuirks;
631     PopUpPolicy m_popUpPolicy { PopUpPolicy::Default };
632     MetaViewportPolicy m_metaViewportPolicy { MetaViewportPolicy::Default };
633     MediaSourcePolicy m_mediaSourcePolicy { MediaSourcePolicy::Default };
634     SimulatedMouseEventsDispatchPolicy m_simulatedMouseEventsDispatchPolicy { SimulatedMouseEventsDispatchPolicy::Default };
635     LegacyOverflowScrollingTouchPolicy m_legacyOverflowScrollingTouchPolicy { LegacyOverflowScrollingTouchPolicy::Default };
636 
637 #if ENABLE(SERVICE_WORKER)
638     Optional&lt;ServiceWorkerRegistrationData&gt; m_serviceWorkerRegistrationData;
<span class="line-modified">639     Optional&lt;DocumentIdentifier&gt; m_temporaryServiceWorkerClient;</span>




640 #endif
641 
<span class="line-modified">642 #if ASSERT_ENABLED</span>
643     bool m_hasEverBeenAttached { false };
644 #endif
645 
646     bool m_allowsWebArchiveForMainFrame { false };
<span class="line-added">647     bool m_allowsDataURLsForMainFrame { false };</span>
648     String m_downloadAttribute;
649 };
650 
651 inline void DocumentLoader::recordMemoryCacheLoadForFutureClientNotification(const ResourceRequest&amp; request)
652 {
653     m_resourcesLoadedFromMemoryCacheForClientNotification.append(request);
654 }
655 
656 inline void DocumentLoader::takeMemoryCacheLoadsForClientNotification(Vector&lt;ResourceRequest&gt;&amp; loadsSet)
657 {
658     loadsSet.swap(m_resourcesLoadedFromMemoryCacheForClientNotification);
659     m_resourcesLoadedFromMemoryCacheForClientNotification.clear();
660 }
661 
662 inline const ResourceRequest&amp; DocumentLoader::originalRequest() const
663 {
664     return m_originalRequest;
665 }
666 
667 inline const ResourceRequest&amp; DocumentLoader::originalRequestCopy() const
</pre>
<hr />
<pre>
705 }
706 
707 inline const URL&amp; DocumentLoader::unreachableURL() const
708 {
709     return m_substituteData.failingURL();
710 }
711 
712 inline ApplicationCacheHost&amp; DocumentLoader::applicationCacheHost() const
713 {
714     // For a short time while the document loader is being destroyed, m_applicationCacheHost is null.
715     // It&#39;s not acceptable to call this function during that time.
716     ASSERT(m_applicationCacheHost);
717     return *m_applicationCacheHost;
718 }
719 
720 inline ApplicationCacheHost* DocumentLoader::applicationCacheHostUnlessBeingDestroyed() const
721 {
722     return m_applicationCacheHost.get();
723 }
724 









725 inline void DocumentLoader::didTellClientAboutLoad(const String&amp; url)
726 {
727 #if !PLATFORM(COCOA)
728     // Don&#39;t include data URLs here, as if a lot of data is loaded that way, we hold on to the (large) URL string for too long.
729     if (protocolIs(url, &quot;data&quot;))
730         return;
731 #endif
732     if (!url.isEmpty())
733         m_resourcesClientKnowsAbout.add(url);
734 }
735 
736 }
</pre>
</td>
</tr>
</table>
<center><a href="DocumentLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentThreadableLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
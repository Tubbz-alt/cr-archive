<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaPlayer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayerEnums.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,12 ***</span>
  
  #if ENABLE(VIDEO)
  
  #include &quot;AudioTrackPrivate.h&quot;
  #include &quot;ContentType.h&quot;
<span class="line-modified">! #include &quot;GraphicsTypes3D.h&quot;</span>
<span class="line-removed">- #include &quot;InbandTextTrackPrivate.h&quot;</span>
  #include &quot;LayoutRect.h&quot;
  #include &quot;LegacyCDMSession.h&quot;
  #include &quot;MediaPlayerEnums.h&quot;
  #include &quot;NativeImage.h&quot;
  #include &quot;PlatformLayer.h&quot;
<span class="line-new-header">--- 27,11 ---</span>
  
  #if ENABLE(VIDEO)
  
  #include &quot;AudioTrackPrivate.h&quot;
  #include &quot;ContentType.h&quot;
<span class="line-modified">! #include &quot;GraphicsTypesGL.h&quot;</span>
  #include &quot;LayoutRect.h&quot;
  #include &quot;LegacyCDMSession.h&quot;
  #include &quot;MediaPlayerEnums.h&quot;
  #include &quot;NativeImage.h&quot;
  #include &quot;PlatformLayer.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,32 ***</span>
  namespace WebCore {
  
  class AudioSourceProvider;
  class CDMInstance;
  class CachedResourceLoader;
<span class="line-modified">! class GraphicsContext3D;</span>
  class GraphicsContext;
  class LegacyCDMSessionClient;
  class MediaPlaybackTarget;
  class MediaPlayer;
  class MediaPlayerPrivateInterface;
  class MediaPlayerRequestInstallMissingPluginsCallback;
  class MediaSourcePrivateClient;
  class MediaStreamPrivate;
  class PlatformTimeRanges;
  class TextTrackRepresentation;
  
  struct Cookie;
  struct GraphicsDeviceAdapter;
<span class="line-removed">- struct MediaPlayerFactory;</span>
  
  struct MediaEngineSupportParameters {
      ContentType type;
      URL url;
      bool isMediaSource { false };
      bool isMediaStream { false };
      Vector&lt;ContentType&gt; contentTypesRequiringHardwareSupport;
  };
  
  struct VideoPlaybackQualityMetrics {
      uint32_t totalVideoFrames { 0 };
      uint32_t droppedVideoFrames { 0 };
<span class="line-new-header">--- 59,74 ---</span>
  namespace WebCore {
  
  class AudioSourceProvider;
  class CDMInstance;
  class CachedResourceLoader;
<span class="line-modified">! class GraphicsContextGLOpenGL;</span>
  class GraphicsContext;
<span class="line-added">+ class InbandTextTrackPrivate;</span>
  class LegacyCDMSessionClient;
  class MediaPlaybackTarget;
  class MediaPlayer;
<span class="line-added">+ class MediaPlayerFactory;</span>
  class MediaPlayerPrivateInterface;
  class MediaPlayerRequestInstallMissingPluginsCallback;
  class MediaSourcePrivateClient;
  class MediaStreamPrivate;
  class PlatformTimeRanges;
  class TextTrackRepresentation;
  
  struct Cookie;
  struct GraphicsDeviceAdapter;
  
  struct MediaEngineSupportParameters {
      ContentType type;
      URL url;
      bool isMediaSource { false };
      bool isMediaStream { false };
      Vector&lt;ContentType&gt; contentTypesRequiringHardwareSupport;
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;class Encoder&gt;</span>
<span class="line-added">+     void encode(Encoder&amp; encoder) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         encoder &lt;&lt; type;</span>
<span class="line-added">+         encoder &lt;&lt; url;</span>
<span class="line-added">+         encoder &lt;&lt; isMediaSource;</span>
<span class="line-added">+         encoder &lt;&lt; isMediaStream;</span>
<span class="line-added">+         encoder &lt;&lt; contentTypesRequiringHardwareSupport;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template &lt;class Decoder&gt;</span>
<span class="line-added">+     static Optional&lt;MediaEngineSupportParameters&gt; decode(Decoder&amp; decoder)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         Optional&lt;ContentType&gt; type;</span>
<span class="line-added">+         decoder &gt;&gt; type;</span>
<span class="line-added">+         if (!type)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Optional&lt;URL&gt; url;</span>
<span class="line-added">+         decoder &gt;&gt; url;</span>
<span class="line-added">+         if (!url)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Optional&lt;bool&gt; isMediaSource;</span>
<span class="line-added">+         decoder &gt;&gt; isMediaSource;</span>
<span class="line-added">+         if (!isMediaSource)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Optional&lt;bool&gt; isMediaStream;</span>
<span class="line-added">+         decoder &gt;&gt; isMediaStream;</span>
<span class="line-added">+         if (!isMediaStream)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Optional&lt;Vector&lt;ContentType&gt;&gt; typesRequiringHardware;</span>
<span class="line-added">+         decoder &gt;&gt; typesRequiringHardware;</span>
<span class="line-added">+         if (!typesRequiringHardware)</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return {{ WTFMove(*type), WTFMove(*url), *isMediaSource, *isMediaStream, *typesRequiringHardware }};</span>
<span class="line-added">+     }</span>
  };
  
  struct VideoPlaybackQualityMetrics {
      uint32_t totalVideoFrames { 0 };
      uint32_t droppedVideoFrames { 0 };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,86 ***</span>
  class MediaPlayerClient {
  public:
      virtual ~MediaPlayerClient() = default;
  
      // the network state has changed
<span class="line-modified">!     virtual void mediaPlayerNetworkStateChanged(MediaPlayer*) { }</span>
  
      // the ready state has changed
<span class="line-modified">!     virtual void mediaPlayerReadyStateChanged(MediaPlayer*) { }</span>
  
      // the volume state has changed
<span class="line-modified">!     virtual void mediaPlayerVolumeChanged(MediaPlayer*) { }</span>
  
      // the mute state has changed
<span class="line-modified">!     virtual void mediaPlayerMuteChanged(MediaPlayer*) { }</span>
  
      // time has jumped, eg. not as a result of normal playback
<span class="line-modified">!     virtual void mediaPlayerTimeChanged(MediaPlayer*) { }</span>
  
      // the media file duration has changed, or is now known
<span class="line-modified">!     virtual void mediaPlayerDurationChanged(MediaPlayer*) { }</span>
  
      // the playback rate has changed
<span class="line-modified">!     virtual void mediaPlayerRateChanged(MediaPlayer*) { }</span>
  
      // the play/pause status changed
<span class="line-modified">!     virtual void mediaPlayerPlaybackStateChanged(MediaPlayer*) { }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The MediaPlayer has found potentially problematic media content.</span>
<span class="line-removed">-     // This is used internally to trigger swapping from a &lt;video&gt;</span>
<span class="line-removed">-     // element to an &lt;embed&gt; in standalone documents</span>
<span class="line-removed">-     virtual void mediaPlayerSawUnsupportedTracks(MediaPlayer*) { }</span>
  
      // The MediaPlayer could not discover an engine which supports the requested resource.
<span class="line-modified">!     virtual void mediaPlayerResourceNotSupported(MediaPlayer*) { }</span>
  
  // Presentation-related methods
      // a new frame of video is available
<span class="line-modified">!     virtual void mediaPlayerRepaint(MediaPlayer*) { }</span>
  
      // the movie size has changed
<span class="line-modified">!     virtual void mediaPlayerSizeChanged(MediaPlayer*) { }</span>
  
<span class="line-modified">!     virtual void mediaPlayerEngineUpdated(MediaPlayer*) { }</span>
  
      // The first frame of video is available to render. A media engine need only make this callback if the
      // first frame is not available immediately when prepareForRendering is called.
<span class="line-modified">!     virtual void mediaPlayerFirstVideoFrameAvailable(MediaPlayer*) { }</span>
  
      // A characteristic of the media file, eg. video, audio, closed captions, etc, has changed.
<span class="line-modified">!     virtual void mediaPlayerCharacteristicChanged(MediaPlayer*) { }</span>
  
      // whether the rendering system can accelerate the display of this MediaPlayer.
<span class="line-modified">!     virtual bool mediaPlayerRenderingCanBeAccelerated(MediaPlayer*) { return false; }</span>
  
      // called when the media player&#39;s rendering mode changed, which indicates a change in the
      // availability of the platformLayer().
<span class="line-modified">!     virtual void mediaPlayerRenderingModeChanged(MediaPlayer*) { }</span>
  
      // whether accelerated compositing is enabled for video rendering
      virtual bool mediaPlayerAcceleratedCompositingEnabled() { return false; }
  
<span class="line-modified">!     virtual void mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*) { }</span>
  
  #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified">!     virtual GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const { return nullptr; }</span>
  #endif
  
  #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
      virtual RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp;) const { return nullptr; }
<span class="line-modified">!     virtual bool mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array*) { return false; }</span>
      virtual String mediaPlayerMediaKeysStorageDirectory() const { return emptyString(); }
  #endif
  
  #if ENABLE(ENCRYPTED_MEDIA)
      virtual void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) { }
      virtual void mediaPlayerWaitingForKeyChanged() { }
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     virtual void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*) { };</span>
  #endif
  
      virtual String mediaPlayerReferrer() const { return String(); }
      virtual String mediaPlayerUserAgent() const { return String(); }
      virtual void mediaPlayerEnterFullscreen() { }
<span class="line-new-header">--- 138,81 ---</span>
  class MediaPlayerClient {
  public:
      virtual ~MediaPlayerClient() = default;
  
      // the network state has changed
<span class="line-modified">!     virtual void mediaPlayerNetworkStateChanged() { }</span>
  
      // the ready state has changed
<span class="line-modified">!     virtual void mediaPlayerReadyStateChanged() { }</span>
  
      // the volume state has changed
<span class="line-modified">!     virtual void mediaPlayerVolumeChanged() { }</span>
  
      // the mute state has changed
<span class="line-modified">!     virtual void mediaPlayerMuteChanged() { }</span>
  
      // time has jumped, eg. not as a result of normal playback
<span class="line-modified">!     virtual void mediaPlayerTimeChanged() { }</span>
  
      // the media file duration has changed, or is now known
<span class="line-modified">!     virtual void mediaPlayerDurationChanged() { }</span>
  
      // the playback rate has changed
<span class="line-modified">!     virtual void mediaPlayerRateChanged() { }</span>
  
      // the play/pause status changed
<span class="line-modified">!     virtual void mediaPlayerPlaybackStateChanged() { }</span>
  
      // The MediaPlayer could not discover an engine which supports the requested resource.
<span class="line-modified">!     virtual void mediaPlayerResourceNotSupported() { }</span>
  
  // Presentation-related methods
      // a new frame of video is available
<span class="line-modified">!     virtual void mediaPlayerRepaint() { }</span>
  
      // the movie size has changed
<span class="line-modified">!     virtual void mediaPlayerSizeChanged() { }</span>
  
<span class="line-modified">!     virtual void mediaPlayerEngineUpdated() { }</span>
  
      // The first frame of video is available to render. A media engine need only make this callback if the
      // first frame is not available immediately when prepareForRendering is called.
<span class="line-modified">!     virtual void mediaPlayerFirstVideoFrameAvailable() { }</span>
  
      // A characteristic of the media file, eg. video, audio, closed captions, etc, has changed.
<span class="line-modified">!     virtual void mediaPlayerCharacteristicChanged() { }</span>
  
      // whether the rendering system can accelerate the display of this MediaPlayer.
<span class="line-modified">!     virtual bool mediaPlayerRenderingCanBeAccelerated() { return false; }</span>
  
      // called when the media player&#39;s rendering mode changed, which indicates a change in the
      // availability of the platformLayer().
<span class="line-modified">!     virtual void mediaPlayerRenderingModeChanged() { }</span>
  
      // whether accelerated compositing is enabled for video rendering
      virtual bool mediaPlayerAcceleratedCompositingEnabled() { return false; }
  
<span class="line-modified">!     virtual void mediaPlayerActiveSourceBuffersChanged() { }</span>
  
  #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified">!     virtual GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter() const { return nullptr; }</span>
  #endif
  
  #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
      virtual RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp;) const { return nullptr; }
<span class="line-modified">!     virtual bool mediaPlayerKeyNeeded(Uint8Array*) { return false; }</span>
      virtual String mediaPlayerMediaKeysStorageDirectory() const { return emptyString(); }
  #endif
  
  #if ENABLE(ENCRYPTED_MEDIA)
      virtual void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) { }
      virtual void mediaPlayerWaitingForKeyChanged() { }
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     virtual void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool) { };</span>
  #endif
  
      virtual String mediaPlayerReferrer() const { return String(); }
      virtual String mediaPlayerUserAgent() const { return String(); }
      virtual void mediaPlayerEnterFullscreen() { }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,15 ***</span>
      virtual bool mediaPlayerIsFullscreen() const { return false; }
      virtual bool mediaPlayerIsFullscreenPermitted() const { return false; }
      virtual bool mediaPlayerIsVideo() const { return false; }
      virtual LayoutRect mediaPlayerContentBoxRect() const { return LayoutRect(); }
      virtual float mediaPlayerContentsScale() const { return 1; }
<span class="line-removed">-     virtual void mediaPlayerSetSize(const IntSize&amp;) { }</span>
      virtual void mediaPlayerPause() { }
      virtual void mediaPlayerPlay() { }
      virtual bool mediaPlayerPlatformVolumeConfigurationRequired() const { return false; }
<span class="line-removed">-     virtual bool mediaPlayerIsPaused() const { return true; }</span>
      virtual bool mediaPlayerIsLooping() const { return false; }
      virtual CachedResourceLoader* mediaPlayerCachedResourceLoader() { return nullptr; }
      virtual RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() { return nullptr; }
      virtual bool doesHaveAttribute(const AtomString&amp;, AtomString* = nullptr) const { return false; }
      virtual bool mediaPlayerShouldUsePersistentCache() const { return true; }
<span class="line-new-header">--- 220,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,15 ***</span>
  #if PLATFORM(IOS_FAMILY)
      virtual String mediaPlayerNetworkInterfaceName() const { return String(); }
      virtual bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const { return false; }
  #endif
  
<span class="line-removed">-     virtual void mediaPlayerHandlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType) { }</span>
<span class="line-removed">- </span>
      virtual String mediaPlayerSourceApplicationIdentifier() const { return emptyString(); }
  
<span class="line-removed">-     virtual bool mediaPlayerIsInMediaDocument() const { return false; }</span>
      virtual void mediaPlayerEngineFailedToLoad() const { }
  
      virtual double mediaPlayerRequestedPlaybackRate() const { return 0; }
      virtual MediaPlayerEnums::VideoFullscreenMode mediaPlayerFullscreenMode() const { return MediaPlayerEnums::VideoFullscreenModeNone; }
      virtual bool mediaPlayerIsVideoFullscreenStandby() const { return false; }
<span class="line-new-header">--- 250,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,29 ***</span>
  #if USE(GSTREAMER)
      virtual void requestInstallMissingPlugins(const String&amp;, const String&amp;, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { };
  #endif
  
      virtual bool mediaPlayerShouldDisableSleep() const { return false; }
<span class="line-modified">!     virtual const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const;</span>
      virtual bool mediaPlayerShouldCheckHardwareSupport() const { return false; }
  
  #if !RELEASE_LOG_DISABLED
      virtual const void* mediaPlayerLogIdentifier() { return nullptr; }
      virtual const Logger&amp; mediaPlayerLogger() = 0;
  #endif
  };
  
<span class="line-modified">! class MediaPlayer : public MediaPlayerEnums, public RefCounted&lt;MediaPlayer&gt; {</span>
      WTF_MAKE_NONCOPYABLE(MediaPlayer); WTF_MAKE_FAST_ALLOCATED;
  public:
      static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;);
      virtual ~MediaPlayer();
  
      void invalidate();
  
      // Media engine support.
      using MediaPlayerEnums::SupportsType;
      static SupportsType supportsType(const MediaEngineSupportParameters&amp;);
      static void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;);
      static bool isAvailable();
      static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp; path);
      static void clearMediaCache(const String&amp; path, WallTime modifiedSince);
<span class="line-new-header">--- 264,34 ---</span>
  #if USE(GSTREAMER)
      virtual void requestInstallMissingPlugins(const String&amp;, const String&amp;, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { };
  #endif
  
      virtual bool mediaPlayerShouldDisableSleep() const { return false; }
<span class="line-modified">!     virtual const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const = 0;</span>
      virtual bool mediaPlayerShouldCheckHardwareSupport() const { return false; }
  
<span class="line-added">+     virtual void mediaPlayerBufferedTimeRangesChanged() { }</span>
<span class="line-added">+     virtual void mediaPlayerSeekableTimeRangesChanged() { }</span>
<span class="line-added">+ </span>
  #if !RELEASE_LOG_DISABLED
      virtual const void* mediaPlayerLogIdentifier() { return nullptr; }
      virtual const Logger&amp; mediaPlayerLogger() = 0;
  #endif
  };
  
<span class="line-modified">! class WEBCORE_EXPORT MediaPlayer : public MediaPlayerEnums, public RefCounted&lt;MediaPlayer&gt; {</span>
      WTF_MAKE_NONCOPYABLE(MediaPlayer); WTF_MAKE_FAST_ALLOCATED;
  public:
      static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;);
<span class="line-added">+     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);</span>
      virtual ~MediaPlayer();
  
      void invalidate();
  
      // Media engine support.
      using MediaPlayerEnums::SupportsType;
<span class="line-added">+     static const MediaPlayerFactory* mediaEngine(MediaPlayerEnums::MediaEngineIdentifier);</span>
      static SupportsType supportsType(const MediaEngineSupportParameters&amp;);
      static void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;);
      static bool isAvailable();
      static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp; path);
      static void clearMediaCache(const String&amp; path, WallTime modifiedSince);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,12 ***</span>
  
      FloatSize naturalSize();
      bool hasVideo() const;
      bool hasAudio() const;
  
<span class="line-removed">-     bool inMediaDocument() const;</span>
<span class="line-removed">- </span>
      IntSize size() const { return m_size; }
      void setSize(const IntSize&amp; size);
  
      bool load(const URL&amp;, const ContentType&amp;, const String&amp; keySystem);
  #if ENABLE(MEDIA_SOURCE)
<span class="line-new-header">--- 326,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 353,10 ***</span>
<span class="line-new-header">--- 387,12 ---</span>
      bool preservesPitch() const;
      void setPreservesPitch(bool);
  
      std::unique_ptr&lt;PlatformTimeRanges&gt; buffered();
      std::unique_ptr&lt;PlatformTimeRanges&gt; seekable();
<span class="line-added">+     void bufferedTimeRangesChanged();</span>
<span class="line-added">+     void seekableTimeRangesChanged();</span>
      MediaTime minTimeSeekable();
      MediaTime maxTimeSeekable();
  
      double seekableTimeRangesLastModifiedTime();
      double liveUpdateInterval();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,11 ***</span>
  
      // In the GPU-GPU textures copy, the source texture(Video texture) should have valid target, internalFormat and size, etc.
      // The destination texture may need to be resized to to the dimensions of the source texture or re-defined to the required internalFormat.
      // The current restrictions require that format shoud be RGB or RGBA, type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
  
<span class="line-modified">!     bool copyVideoTextureToPlatformTexture(GraphicsContext3D*, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY);</span>
  
      NativeImagePtr nativeImageForCurrentTime();
  
      using MediaPlayerEnums::NetworkState;
      NetworkState networkState();
<span class="line-new-header">--- 419,11 ---</span>
  
      // In the GPU-GPU textures copy, the source texture(Video texture) should have valid target, internalFormat and size, etc.
      // The destination texture may need to be resized to to the dimensions of the source texture or re-defined to the required internalFormat.
      // The current restrictions require that format shoud be RGB or RGBA, type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
  
<span class="line-modified">!     bool copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL*, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY);</span>
  
      NativeImagePtr nativeImageForCurrentTime();
  
      using MediaPlayerEnums::NetworkState;
      NetworkState networkState();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,18 ***</span>
      void firstVideoFrameAvailable();
      void characteristicChanged();
  
      void repaint();
  
<span class="line-removed">-     MediaPlayerClient&amp; client() const { return *m_client; }</span>
<span class="line-removed">- </span>
      bool hasAvailableVideoFrame() const;
      void prepareForRendering();
  
<span class="line-removed">-     bool canLoadPoster() const;</span>
<span class="line-removed">-     void setPoster(const String&amp;);</span>
<span class="line-removed">- </span>
  #if USE(NATIVE_FULLSCREEN_VIDEO)
      void enterFullscreen();
      void exitFullscreen();
  #endif
  
<span class="line-new-header">--- 450,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,11 ***</span>
      String wirelessPlaybackTargetName() const;
  
      bool wirelessVideoPlaybackDisabled() const;
      void setWirelessVideoPlaybackDisabled(bool);
  
<span class="line-modified">!     void currentPlaybackTargetIsWirelessChanged();</span>
      void playbackTargetAvailabilityChanged();
  
      bool isCurrentPlaybackTargetWireless() const;
      bool canPlayToWirelessPlaybackTarget() const;
      void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
<span class="line-new-header">--- 467,11 ---</span>
      String wirelessPlaybackTargetName() const;
  
      bool wirelessVideoPlaybackDisabled() const;
      void setWirelessVideoPlaybackDisabled(bool);
  
<span class="line-modified">!     void currentPlaybackTargetIsWirelessChanged(bool);</span>
      void playbackTargetAvailabilityChanged();
  
      bool isCurrentPlaybackTargetWireless() const;
      bool canPlayToWirelessPlaybackTarget() const;
      void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 532,25 ***</span>
  #endif
  
      static void resetMediaEngines();
  
  #if USE(GSTREAMER)
<span class="line-modified">!     WEBCORE_EXPORT void simulateAudioInterruption();</span>
  #endif
  
<span class="line-modified">!     WEBCORE_EXPORT void beginSimulatedHDCPError();</span>
<span class="line-modified">!     WEBCORE_EXPORT void endSimulatedHDCPError();</span>
  
      String languageOfPrimaryAudioTrack() const;
  
      size_t extraMemoryCost() const;
  
      unsigned long long fileSize() const;
  
      Optional&lt;VideoPlaybackQualityMetrics&gt; videoPlaybackQualityMetrics();
  
<span class="line-removed">-     void handlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType);</span>
      String sourceApplicationIdentifier() const;
      Vector&lt;String&gt; preferredAudioCharacteristics() const;
  
      bool ended() const;
  
<span class="line-new-header">--- 563,24 ---</span>
  #endif
  
      static void resetMediaEngines();
  
  #if USE(GSTREAMER)
<span class="line-modified">!     void simulateAudioInterruption();</span>
  #endif
  
<span class="line-modified">!     void beginSimulatedHDCPError();</span>
<span class="line-modified">!     void endSimulatedHDCPError();</span>
  
      String languageOfPrimaryAudioTrack() const;
  
      size_t extraMemoryCost() const;
  
      unsigned long long fileSize() const;
  
      Optional&lt;VideoPlaybackQualityMetrics&gt; videoPlaybackQualityMetrics();
  
      String sourceApplicationIdentifier() const;
      Vector&lt;String&gt; preferredAudioCharacteristics() const;
  
      bool ended() const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,33 ***</span>
  
      void applicationWillResignActive();
      void applicationDidBecomeActive();
  
  #if USE(AVFOUNDATION)
<span class="line-modified">!     WEBCORE_EXPORT AVPlayer *objCAVFoundationAVPlayer() const;</span>
  #endif
  
      bool performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp;, MediaTime);
  
      bool shouldIgnoreIntrinsicSize();
  
  private:
      MediaPlayer(MediaPlayerClient&amp;);
  
<span class="line-modified">!     const MediaPlayerFactory* nextBestMediaEngine(const MediaPlayerFactory*) const;</span>
      void loadWithNextMediaEngine(const MediaPlayerFactory*);
      void reloadTimerFired();
  
      MediaPlayerClient* m_client;
      Timer m_reloadTimer;
      std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; m_private;
      const MediaPlayerFactory* m_currentMediaEngine { nullptr };
      URL m_url;
      ContentType m_contentType;
      String m_keySystem;
      IntSize m_size;
<span class="line-modified">!     Preload m_preload { Auto };</span>
      double m_volume { 1 };
      bool m_visible { false };
      bool m_muted { false };
      bool m_preservesPitch { true };
      bool m_privateBrowsing { false };
<span class="line-new-header">--- 601,57 ---</span>
  
      void applicationWillResignActive();
      void applicationDidBecomeActive();
  
  #if USE(AVFOUNDATION)
<span class="line-modified">!     AVPlayer *objCAVFoundationAVPlayer() const;</span>
  #endif
  
      bool performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp;, MediaTime);
  
      bool shouldIgnoreIntrinsicSize();
  
<span class="line-added">+     bool renderingCanBeAccelerated() const { return client().mediaPlayerRenderingCanBeAccelerated(); }</span>
<span class="line-added">+     void renderingModeChanged() const  { client().mediaPlayerRenderingModeChanged(); }</span>
<span class="line-added">+     bool acceleratedCompositingEnabled() { return client().mediaPlayerAcceleratedCompositingEnabled(); }</span>
<span class="line-added">+     void activeSourceBuffersChanged() { client().mediaPlayerActiveSourceBuffersChanged(); }</span>
<span class="line-added">+     LayoutRect playerContentBoxRect() const { return client().mediaPlayerContentBoxRect(); }</span>
<span class="line-added">+     float playerContentsScale() const { return client().mediaPlayerContentsScale(); }</span>
<span class="line-added">+     bool shouldUsePersistentCache() const { return client().mediaPlayerShouldUsePersistentCache(); }</span>
<span class="line-added">+     const String&amp; mediaCacheDirectory() const { return client().mediaPlayerMediaCacheDirectory(); }</span>
<span class="line-added">+     bool isVideoPlayer() const { return client().mediaPlayerIsVideo(); }</span>
<span class="line-added">+     void mediaEngineUpdated() { client().mediaPlayerEngineUpdated(); }</span>
<span class="line-added">+     void resourceNotSupported() { client().mediaPlayerResourceNotSupported(); }</span>
<span class="line-added">+     bool isLooping() const { return client().mediaPlayerIsLooping(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void remoteEngineFailedToLoad();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(GSTREAMER)</span>
<span class="line-added">+     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback) { client().requestInstallMissingPlugins(details, description, callback); }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  private:
      MediaPlayer(MediaPlayerClient&amp;);
<span class="line-added">+     MediaPlayer(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);</span>
  
<span class="line-modified">!     MediaPlayerClient&amp; client() const { return *m_client; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     const MediaPlayerFactory* nextBestMediaEngine(const MediaPlayerFactory*);</span>
      void loadWithNextMediaEngine(const MediaPlayerFactory*);
<span class="line-added">+     const MediaPlayerFactory* nextMediaEngine(const MediaPlayerFactory*);</span>
      void reloadTimerFired();
  
      MediaPlayerClient* m_client;
      Timer m_reloadTimer;
      std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; m_private;
      const MediaPlayerFactory* m_currentMediaEngine { nullptr };
      URL m_url;
      ContentType m_contentType;
      String m_keySystem;
<span class="line-added">+     Optional&lt;MediaPlayerEnums::MediaEngineIdentifier&gt; m_activeEngineIdentifier;</span>
      IntSize m_size;
<span class="line-modified">!     Preload m_preload { Preload::Auto };</span>
      double m_volume { 1 };
      bool m_visible { false };
      bool m_muted { false };
      bool m_preservesPitch { true };
      bool m_privateBrowsing { false };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,25 ***</span>
  #if ENABLE(MEDIA_STREAM)
      RefPtr&lt;MediaStreamPrivate&gt; m_mediaStream;
  #endif
  };
  
<span class="line-modified">! using CreateMediaEnginePlayer = WTF::Function&lt;std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; (MediaPlayer*)&gt;;</span>
<span class="line-modified">! typedef void (*MediaEngineSupportedTypes)(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types);</span>
<span class="line-modified">! typedef MediaPlayer::SupportsType (*MediaEngineSupportsType)(const MediaEngineSupportParameters&amp; parameters);</span>
<span class="line-modified">! typedef HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; (*MediaEngineOriginsInMediaCache)(const String&amp; path);</span>
<span class="line-modified">! typedef void (*MediaEngineClearMediaCache)(const String&amp; path, WallTime modifiedSince);</span>
<span class="line-modified">! typedef void (*MediaEngineClearMediaCacheForOrigins)(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);</span>
<span class="line-modified">! typedef bool (*MediaEngineSupportsKeySystem)(const String&amp; keySystem, const String&amp; mimeType);</span>
  
<span class="line-modified">! typedef void (*MediaEngineRegistrar)(CreateMediaEnginePlayer&amp;&amp;, MediaEngineSupportedTypes, MediaEngineSupportsType,</span>
<span class="line-modified">!     MediaEngineOriginsInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForOrigins, MediaEngineSupportsKeySystem);</span>
<span class="line-removed">- typedef void (*MediaEngineRegister)(MediaEngineRegistrar);</span>
  
  class MediaPlayerFactorySupport {
  public:
      WEBCORE_EXPORT static void callRegisterMediaEngine(MediaEngineRegister);
  };
  
  } // namespace WebCore
  
  #endif // ENABLE(VIDEO)
<span class="line-new-header">--- 665,40 ---</span>
  #if ENABLE(MEDIA_STREAM)
      RefPtr&lt;MediaStreamPrivate&gt; m_mediaStream;
  #endif
  };
  
<span class="line-modified">! class MediaPlayerFactory {</span>
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">! public:</span>
<span class="line-modified">!     MediaPlayerFactory() = default;</span>
<span class="line-modified">!     virtual ~MediaPlayerFactory() = default;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     virtual MediaPlayerEnums::MediaEngineIdentifier identifier() const  = 0;</span>
<span class="line-added">+     virtual std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; createMediaEnginePlayer(MediaPlayer*) const = 0;</span>
<span class="line-added">+     virtual void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;) const = 0;</span>
<span class="line-added">+     virtual MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters&amp;) const = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     virtual HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;) const { return { }; }</span>
<span class="line-added">+     virtual void clearMediaCache(const String&amp;, WallTime) const { }</span>
<span class="line-added">+     virtual void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;) const { }</span>
<span class="line-added">+     virtual bool supportsKeySystem(const String&amp; /* keySystem */, const String&amp; /* mimeType */) const { return false; }</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! using MediaEngineRegistrar = void(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp;);</span>
<span class="line-modified">! using MediaEngineRegister = void(MediaEngineRegistrar);</span>
  
  class MediaPlayerFactorySupport {
  public:
      WEBCORE_EXPORT static void callRegisterMediaEngine(MediaEngineRegister);
  };
  
<span class="line-added">+ class RemoteMediaPlayerSupport {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     using RegisterRemotePlayerCallback = WTF::Function&lt;void(MediaEngineRegistrar, MediaPlayerEnums::MediaEngineIdentifier)&gt;;</span>
<span class="line-added">+     WEBCORE_EXPORT static void setRegisterRemotePlayerCallback(RegisterRemotePlayerCallback&amp;&amp;);</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #endif // ENABLE(VIDEO)
</pre>
<center><a href="MediaPlayer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaPlayerEnums.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractInterpreter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,15 ***</span>
  #include &quot;ArrayPrototype.h&quot;
  #include &quot;DFGAbstractInterpreter.h&quot;
  #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  #include &quot;DOMJITGetterSetter.h&quot;
  #include &quot;DOMJITSignature.h&quot;
<span class="line-modified">! #include &quot;GetByIdStatus.h&quot;</span>
  #include &quot;GetterSetter.h&quot;
  #include &quot;HashMapImpl.h&quot;
  #include &quot;JITOperations.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;MathCommon.h&quot;
  #include &quot;NumberConstructor.h&quot;
  #include &quot;Operations.h&quot;
  #include &quot;PutByIdStatus.h&quot;
  #include &quot;StringObject.h&quot;
<span class="line-new-header">--- 31,20 ---</span>
  #include &quot;ArrayPrototype.h&quot;
  #include &quot;DFGAbstractInterpreter.h&quot;
  #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  #include &quot;DOMJITGetterSetter.h&quot;
  #include &quot;DOMJITSignature.h&quot;
<span class="line-modified">! #include &quot;GetByStatus.h&quot;</span>
  #include &quot;GetterSetter.h&quot;
  #include &quot;HashMapImpl.h&quot;
  #include &quot;JITOperations.h&quot;
<span class="line-added">+ #include &quot;JSAsyncGenerator.h&quot;</span>
<span class="line-added">+ #include &quot;JSGenerator.h&quot;</span>
  #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">+ #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">+ #include &quot;JSInternalPromiseConstructor.h&quot;</span>
<span class="line-added">+ #include &quot;JSPromiseConstructor.h&quot;</span>
  #include &quot;MathCommon.h&quot;
  #include &quot;NumberConstructor.h&quot;
  #include &quot;Operations.h&quot;
  #include &quot;PutByIdStatus.h&quot;
  #include &quot;StringObject.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 71,11 ***</span>
  AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
      Node* node, AbstractValue&amp; value)
  {
      JSValue childConst = value.value();
      if (childConst) {
<span class="line-modified">!         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;globalExec()))</span>
              return DefinitelyTrue;
          return DefinitelyFalse;
      }
  
      // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
<span class="line-new-header">--- 76,11 ---</span>
  AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
      Node* node, AbstractValue&amp; value)
  {
      JSValue childConst = value.value();
      if (childConst) {
<span class="line-modified">!         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)))</span>
              return DefinitelyTrue;
          return DefinitelyFalse;
      }
  
      // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,11 ***</span>
              break;
          case ValueBitXor:
          case ArithBitXor:
              setConstant(node, JSValue(a ^ b));
              break;
<span class="line-modified">!         case BitRShift:</span>
              setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
              break;
          case ValueBitLShift:
          case ArithBitLShift:
              setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
<span class="line-new-header">--- 260,12 ---</span>
              break;
          case ValueBitXor:
          case ArithBitXor:
              setConstant(node, JSValue(a ^ b));
              break;
<span class="line-modified">!         case ArithBitRShift:</span>
<span class="line-added">+         case ValueBitRShift:</span>
              setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
              break;
          case ValueBitLShift:
          case ArithBitLShift:
              setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,14 ***</span>
              }
          } else if (left.isNumber() &amp;&amp; right.isNumber()) {
              if (isClobbering)
                  didFoldClobberWorld();
  
<span class="line-modified">!             if (isDivOperation)</span>
<span class="line-modified">!                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
  
              return true;
          }
      }
  
<span class="line-new-header">--- 321,21 ---</span>
              }
          } else if (left.isNumber() &amp;&amp; right.isNumber()) {
              if (isClobbering)
                  didFoldClobberWorld();
  
<span class="line-modified">!             if (isDivOperation) {</span>
<span class="line-modified">!                 if (op == ValueDiv)</span>
<span class="line-modified">!                     setConstant(node, jsNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-modified">!                 else</span>
<span class="line-added">+                     setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 if (op == ValueMod)</span>
<span class="line-added">+                     setConstant(node, jsNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-added">+             }</span>
  
              return true;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
  
      case IdentityWithProfile:
      case Identity: {
          setForNode(node, forNode(node-&gt;child1()));
          if (forNode(node).value())
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          break;
      }
  
      case ExtractCatchLocal:
      case ExtractOSREntryLocal: {
<span class="line-new-header">--- 374,11 ---</span>
  
      case IdentityWithProfile:
      case Identity: {
          setForNode(node, forNode(node-&gt;child1()));
          if (forNode(node).value())
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          break;
      }
  
      case ExtractCatchLocal:
      case ExtractOSREntryLocal: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,37 ***</span>
          break;
      }
  
      case GetLocal: {
          VariableAccessData* variableAccessData = node-&gt;variableAccessData();
<span class="line-modified">!         AbstractValue value = m_state.operand(variableAccessData-&gt;local().offset());</span>
          // The value in the local should already be checked.
          DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData-&gt;flushFormat())));
          if (value.value())
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          setForNode(node, value);
          break;
      }
  
      case GetStack: {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         AbstractValue value = m_state.operand(data-&gt;local);</span>
          // The value in the local should already be checked.
          DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data-&gt;format)));
          if (value.value())
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          setForNode(node, value);
          break;
      }
  
      case SetLocal: {
<span class="line-modified">!         m_state.operand(node-&gt;local()) = forNode(node-&gt;child1());</span>
          break;
      }
  
      case PutStack: {
<span class="line-modified">!         m_state.operand(node-&gt;stackAccessData()-&gt;local) = forNode(node-&gt;child1());</span>
          break;
      }
  
      case MovHint: {
          // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
<span class="line-new-header">--- 386,37 ---</span>
          break;
      }
  
      case GetLocal: {
          VariableAccessData* variableAccessData = node-&gt;variableAccessData();
<span class="line-modified">!         AbstractValue value = m_state.operand(variableAccessData-&gt;operand());</span>
          // The value in the local should already be checked.
          DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData-&gt;flushFormat())));
          if (value.value())
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          setForNode(node, value);
          break;
      }
  
      case GetStack: {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         AbstractValue value = m_state.operand(data-&gt;operand);</span>
          // The value in the local should already be checked.
          DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data-&gt;format)));
          if (value.value())
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          setForNode(node, value);
          break;
      }
  
      case SetLocal: {
<span class="line-modified">!         m_state.operand(node-&gt;operand()) = forNode(node-&gt;child1());</span>
          break;
      }
  
      case PutStack: {
<span class="line-modified">!         m_state.operand(node-&gt;stackAccessData()-&gt;operand) = forNode(node-&gt;child1());</span>
          break;
      }
  
      case MovHint: {
          // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
</pre>
<hr />
<pre>
<span class="line-old-header">*** 421,11 ***</span>
      case SetArgumentDefinitely:
      case SetArgumentMaybe:
          // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means
          // that someone set the argument values out-of-band, and currently this always means setting to a
          // non-clear value.
<span class="line-modified">!         ASSERT(!m_state.operand(node-&gt;local()).isClear());</span>
          break;
  
      case InitializeEntrypointArguments: {
          unsigned entrypointIndex = node-&gt;entrypointIndex();
          const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
<span class="line-new-header">--- 434,11 ---</span>
      case SetArgumentDefinitely:
      case SetArgumentMaybe:
          // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means
          // that someone set the argument values out-of-band, and currently this always means setting to a
          // non-clear value.
<span class="line-modified">!         ASSERT(!m_state.operand(node-&gt;operand()).isClear());</span>
          break;
  
      case InitializeEntrypointArguments: {
          unsigned entrypointIndex = node-&gt;entrypointIndex();
          const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,10 ***</span>
<span class="line-new-header">--- 463,16 ---</span>
              }
          }
          break;
      }
  
<span class="line-added">+     case VarargsLength: {</span>
<span class="line-added">+         clobberWorld();</span>
<span class="line-added">+         setTypeForNode(node, SpecInt32Only);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case LoadVarargs:
      case ForwardVarargs: {
          // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
          // itself into a straight-line sequence of GetStack/PutStack.
          // https://bugs.webkit.org/show_bug.cgi?id=143071
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,11 ***</span>
              break;
          }
          LoadVarargsData* data = node-&gt;loadVarargsData();
          m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
          for (unsigned i = data-&gt;limit - 1; i--;)
<span class="line-modified">!             m_state.operand(data-&gt;start.offset() + i).makeHeapTop();</span>
          break;
      }
  
      case ValueBitNot: {
          JSValue operand = forNode(node-&gt;child1()).value();
<span class="line-new-header">--- 487,11 ---</span>
              break;
          }
          LoadVarargsData* data = node-&gt;loadVarargsData();
          m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
          for (unsigned i = data-&gt;limit - 1; i--;)
<span class="line-modified">!             m_state.operand(data-&gt;start + i).makeHeapTop();</span>
          break;
      }
  
      case ValueBitNot: {
          JSValue operand = forNode(node-&gt;child1()).value();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 506,10 ***</span>
<span class="line-new-header">--- 525,11 ---</span>
      }
  
      case ValueBitXor:
      case ValueBitAnd:
      case ValueBitOr:
<span class="line-added">+     case ValueBitRShift:</span>
      case ValueBitLShift: {
          if (handleConstantBinaryBitwiseOp(node))
              break;
  
          if (node-&gt;binaryUseKind() == BigIntUse)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,11 ***</span>
      }
  
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
<span class="line-modified">!     case BitRShift:</span>
      case ArithBitLShift:
      case BitURShift: {
          if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
              clobberWorld();
              setNonCellTypeForNode(node, SpecInt32Only);
<span class="line-new-header">--- 542,11 ---</span>
      }
  
      case ArithBitAnd:
      case ArithBitOr:
      case ArithBitXor:
<span class="line-modified">!     case ArithBitRShift:</span>
      case ArithBitLShift:
      case BitURShift: {
          if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
              clobberWorld();
              setNonCellTypeForNode(node, SpecInt32Only);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,11 ***</span>
              break;
          }
          AbstractValue&amp; value = forNode(node);
          value = forNode(node-&gt;child1());
          if (node-&gt;child1().useKind() == UntypedUse &amp;&amp; !(value.m_type &amp; ~SpecBoolean))
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          if (value.m_type &amp; SpecBoolean) {
              value.merge(SpecBoolInt32);
              value.filter(~SpecBoolean);
          }
          break;
<span class="line-new-header">--- 608,11 ---</span>
              break;
          }
          AbstractValue&amp; value = forNode(node);
          value = forNode(node-&gt;child1());
          if (node-&gt;child1().useKind() == UntypedUse &amp;&amp; !(value.m_type &amp; ~SpecBoolean))
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          if (value.m_type &amp; SpecBoolean) {
              value.merge(SpecBoolInt32);
              value.filter(~SpecBoolean);
          }
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 810,11 ***</span>
                  continue;
              ++numberOfRemovedChildren;
          }
  
          if (numberOfRemovedChildren)
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          setForNode(node, m_vm.stringStructure.get());
          break;
      }
  
      case ArithSub: {
<span class="line-new-header">--- 830,11 ---</span>
                  continue;
              ++numberOfRemovedChildren;
          }
  
          if (numberOfRemovedChildren)
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          setForNode(node, m_vm.stringStructure.get());
          break;
      }
  
      case ArithSub: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 922,19 ***</span>
              break;
          }
          break;
      }
  
      case ValuePow: {
          JSValue childX = forNode(node-&gt;child1()).value();
          JSValue childY = forNode(node-&gt;child2()).value();
          if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {
              // We need to call `didFoldClobberWorld` here because this path is only possible
              // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be
              // cleared by `AbstractInterpreter::executeEffects`.
              didFoldClobberWorld();
<span class="line-modified">!             setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));</span>
              break;
          }
  
          if (node-&gt;binaryUseKind() == BigIntUse)
              setTypeForNode(node, SpecBigInt);
<span class="line-new-header">--- 942,45 ---</span>
              break;
          }
          break;
      }
  
<span class="line-added">+     case Inc:</span>
<span class="line-added">+     case Dec: {</span>
<span class="line-added">+         // FIXME: support some form of constant folding here.</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=204258</span>
<span class="line-added">+         switch (node-&gt;child1().useKind()) {</span>
<span class="line-added">+         case Int32Use:</span>
<span class="line-added">+             setNonCellTypeForNode(node, SpecInt32Only);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case Int52RepUse:</span>
<span class="line-added">+             setNonCellTypeForNode(node, SpecInt52Any);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case DoubleRepUse:</span>
<span class="line-added">+             setNonCellTypeForNode(node, typeOfDoubleIncOrDec(forNode(node-&gt;child1()).m_type));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case BigIntUse:</span>
<span class="line-added">+             setTypeForNode(node, SpecBigInt);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);</span>
<span class="line-added">+             clobberWorld(); // Because of the call to ToNumeric()</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case ValuePow: {
          JSValue childX = forNode(node-&gt;child1()).value();
          JSValue childY = forNode(node-&gt;child2()).value();
          if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {
              // We need to call `didFoldClobberWorld` here because this path is only possible
              // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be
              // cleared by `AbstractInterpreter::executeEffects`.
              didFoldClobberWorld();
<span class="line-modified">!             // Our boxing scheme here matches what we do in operationValuePow.</span>
<span class="line-added">+             setConstant(node, jsNumber(operationMathPow(childX.asNumber(), childY.asNumber())));</span>
              break;
          }
  
          if (node-&gt;binaryUseKind() == BigIntUse)
              setTypeForNode(node, SpecBigInt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1261,11 ***</span>
              break;
          }
  
          SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
          if (!(forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)) {
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              forNode(node) = forNode(node-&gt;child1());
              break;
          }
  
          makeHeapTopForNode(node);
<span class="line-new-header">--- 1307,11 ---</span>
              break;
          }
  
          SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
          if (!(forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)) {
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              forNode(node) = forNode(node-&gt;child1());
              break;
          }
  
          makeHeapTopForNode(node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1410,10 ***</span>
<span class="line-new-header">--- 1456,41 ---</span>
              }
              if (constantWasSet)
                  break;
          }
  
<span class="line-added">+         if (!(child.m_type &amp; ~SpecCell)) {</span>
<span class="line-added">+             if (child.m_structure.isFinite()) {</span>
<span class="line-added">+                 bool constantWasSet = false;</span>
<span class="line-added">+                 switch (node-&gt;op()) {</span>
<span class="line-added">+                 case IsCellWithType: {</span>
<span class="line-added">+                     bool ok = true;</span>
<span class="line-added">+                     Optional&lt;bool&gt; result;</span>
<span class="line-added">+                     child.m_structure.forEach(</span>
<span class="line-added">+                         [&amp;] (RegisteredStructure structure) {</span>
<span class="line-added">+                             bool matched = structure-&gt;typeInfo().type() == node-&gt;queriedType();</span>
<span class="line-added">+                             if (!result)</span>
<span class="line-added">+                                 result = matched;</span>
<span class="line-added">+                             else {</span>
<span class="line-added">+                                 if (result.value() != matched)</span>
<span class="line-added">+                                     ok = false;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         });</span>
<span class="line-added">+                     if (ok &amp;&amp; result) {</span>
<span class="line-added">+                         setConstant(node, jsBoolean(result.value()));</span>
<span class="line-added">+                         constantWasSet = true;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (constantWasSet)</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // FIXME: This code should really use AbstractValue::isType() and
          // AbstractValue::couldBeType().
          // https://bugs.webkit.org/show_bug.cgi?id=146870
  
          bool constantWasSet = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1559,22 ***</span>
                  constantWasSet = true;
                  break;
              }
              break;
  
<span class="line-modified">!         case IsCellWithType:</span>
<span class="line-modified">!             if (!(child.m_type &amp; ~node-&gt;speculatedTypeForQuery())) {</span>
                  setConstant(node, jsBoolean(true));
                  constantWasSet = true;
                  break;
              }
<span class="line-modified">!             if (!(child.m_type &amp; node-&gt;speculatedTypeForQuery())) {</span>
                  setConstant(node, jsBoolean(false));
                  constantWasSet = true;
                  break;
              }
              break;
  
          case IsTypedArrayView:
              if (!(child.m_type &amp; ~SpecTypedArrayView)) {
                  setConstant(node, jsBoolean(true));
                  constantWasSet = true;
<span class="line-new-header">--- 1636,31 ---</span>
                  constantWasSet = true;
                  break;
              }
              break;
  
<span class="line-modified">!         case IsCellWithType: {</span>
<span class="line-modified">!             Optional&lt;SpeculatedType&gt; filter = node-&gt;speculatedTypeForQuery();</span>
<span class="line-added">+             if (!filter) {</span>
<span class="line-added">+                 if (!(child.m_type &amp; SpecCell)) {</span>
<span class="line-added">+                     setConstant(node, jsBoolean(false));</span>
<span class="line-added">+                     constantWasSet = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (!(child.m_type &amp; ~filter.value())) {</span>
                  setConstant(node, jsBoolean(true));
                  constantWasSet = true;
                  break;
              }
<span class="line-modified">!             if (!(child.m_type &amp; filter.value())) {</span>
                  setConstant(node, jsBoolean(false));
                  constantWasSet = true;
                  break;
              }
              break;
<span class="line-added">+         }</span>
  
          case IsTypedArrayView:
              if (!(child.m_type &amp; ~SpecTypedArrayView)) {
                  setConstant(node, jsBoolean(true));
                  constantWasSet = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1855,11 ***</span>
              auto isNonStringCellConstant = [] (JSValue value) {
                  return value &amp;&amp; value.isCell() &amp;&amp; !value.isString();
              };
  
              if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  setNonCellTypeForNode(node, SpecBoolean);
                  break;
              }
          }
  
<span class="line-new-header">--- 1941,11 ---</span>
              auto isNonStringCellConstant = [] (JSValue value) {
                  return value &amp;&amp; value.isCell() &amp;&amp; !value.isString();
              };
  
              if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  setNonCellTypeForNode(node, SpecBoolean);
                  break;
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1904,10 ***</span>
<span class="line-new-header">--- 1990,11 ---</span>
          setNonCellTypeForNode(node, SpecBoolean);
          break;
      }
  
      case StringCharCodeAt:
<span class="line-added">+     case StringCodePointAt:</span>
          setNonCellTypeForNode(node, SpecInt32Only);
          break;
  
      case StringFromCharCode:
          switch (node-&gt;child1().useKind()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2282,20 ***</span>
              Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
              argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
              unsigned argumentIndex;
              if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
                  if (inlineCallFrame) {
<span class="line-modified">!                     if (argumentIndex &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {</span>
                          setForNode(node, m_state.operand(
<span class="line-modified">!                             virtualRegisterForArgument(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));</span>
<span class="line-modified">!                         m_state.setFoundConstants(true);</span>
                          break;
                      }
                  } else {
                      if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
                          setForNode(node, m_state.argument(argumentIndex + 1));
<span class="line-modified">!                         m_state.setFoundConstants(true);</span>
                          break;
                      }
                  }
              }
          }
<span class="line-new-header">--- 2369,20 ---</span>
              Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
              argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
              unsigned argumentIndex;
              if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
                  if (inlineCallFrame) {
<span class="line-modified">!                     if (argumentIndex &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1)) {</span>
                          setForNode(node, m_state.operand(
<span class="line-modified">!                             virtualRegisterForArgumentIncludingThis(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));</span>
<span class="line-modified">!                         m_state.setShouldTryConstantFolding(true);</span>
                          break;
                      }
                  } else {
                      if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
                          setForNode(node, m_state.argument(argumentIndex + 1));
<span class="line-modified">!                         m_state.setShouldTryConstantFolding(true);</span>
                          break;
                      }
                  }
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2305,18 ***</span>
  
              AbstractValue result;
              for (unsigned i = 1 + node-&gt;numberOfArgumentsToSkip(); i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
                  result.merge(
                      m_state.operand(
<span class="line-modified">!                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset));</span>
              }
  
              if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
                  result.merge(SpecOther);
  
              if (result.value())
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
  
              setForNode(node, result);
              break;
          }
  
<span class="line-new-header">--- 2392,18 ---</span>
  
              AbstractValue result;
              for (unsigned i = 1 + node-&gt;numberOfArgumentsToSkip(); i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
                  result.merge(
                      m_state.operand(
<span class="line-modified">!                         virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset));</span>
              }
  
              if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
                  result.merge(SpecOther);
  
              if (result.value())
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
  
              setForNode(node, result);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2336,11 ***</span>
              if (JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(m_vm, globalObjectValue)) {
                  if (!globalObject-&gt;isHavingABadTime()) {
                      m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
                      RegisteredStructureSet structureSet;
                      structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayStructure()));
<span class="line-removed">-                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayWithGroupsStructure()));</span>
                      setForNode(node, structureSet);
                      forNode(node).merge(SpecOther);
                      break;
                  }
              }
<span class="line-new-header">--- 2423,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2431,11 ***</span>
          }
  
          ASSERT(node-&gt;child1().useKind() == UntypedUse);
  
          if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              didFoldClobberWorld();
              setForNode(node, forNode(node-&gt;child1()));
              break;
          }
  
<span class="line-new-header">--- 2517,11 ---</span>
          }
  
          ASSERT(node-&gt;child1().useKind() == UntypedUse);
  
          if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              didFoldClobberWorld();
              setForNode(node, forNode(node-&gt;child1()));
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2443,10 ***</span>
<span class="line-new-header">--- 2529,24 ---</span>
  
          setTypeForNode(node, SpecHeapTop &amp; ~SpecObject);
          break;
      }
  
<span class="line-added">+     case ToPropertyKey: {</span>
<span class="line-added">+         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecString | SpecSymbol))) {</span>
<span class="line-added">+             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+             didFoldClobberWorld();</span>
<span class="line-added">+             setForNode(node, forNode(node-&gt;child1()));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         clobberWorld();</span>
<span class="line-added">+ </span>
<span class="line-added">+         setTypeForNode(node, SpecString | SpecSymbol);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case ToNumber: {
          JSValue childConst = forNode(node-&gt;child1()).value();
          if (childConst &amp;&amp; childConst.isNumber()) {
              didFoldClobberWorld();
              setConstant(node, childConst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2454,21 ***</span>
          }
  
          ASSERT(node-&gt;child1().useKind() == UntypedUse);
  
          if (!(forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)) {
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              didFoldClobberWorld();
              setForNode(node, forNode(node-&gt;child1()));
              break;
          }
  
          clobberWorld();
          setNonCellTypeForNode(node, SpecBytecodeNumber);
          break;
      }
  
      case ToString:
      case CallStringConstructor: {
          switch (node-&gt;child1().useKind()) {
          case StringObjectUse:
          case StringOrStringObjectUse:
<span class="line-new-header">--- 2554,43 ---</span>
          }
  
          ASSERT(node-&gt;child1().useKind() == UntypedUse);
  
          if (!(forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)) {
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              didFoldClobberWorld();
              setForNode(node, forNode(node-&gt;child1()));
              break;
          }
  
          clobberWorld();
          setNonCellTypeForNode(node, SpecBytecodeNumber);
          break;
      }
  
<span class="line-added">+     case ToNumeric: {</span>
<span class="line-added">+         JSValue childConst = forNode(node-&gt;child1()).value();</span>
<span class="line-added">+         if (childConst &amp;&amp; (childConst.isNumber() || childConst.isBigInt())) {</span>
<span class="line-added">+             didFoldClobberWorld();</span>
<span class="line-added">+             setConstant(node, childConst);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         ASSERT(node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecBytecodeNumber | SpecBigInt))) {</span>
<span class="line-added">+             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+             didFoldClobberWorld();</span>
<span class="line-added">+             setForNode(node, forNode(node-&gt;child1()));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         clobberWorld();</span>
<span class="line-added">+         setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case ToString:
      case CallStringConstructor: {
          switch (node-&gt;child1().useKind()) {
          case StringObjectUse:
          case StringOrStringObjectUse:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2492,11 ***</span>
      case NumberToStringWithRadix: {
          JSValue radixValue = forNode(node-&gt;child2()).m_value;
          if (radixValue &amp;&amp; radixValue.isInt32()) {
              int32_t radix = radixValue.asInt32();
              if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  didFoldClobberWorld();
                  setForNode(node, m_graph.m_vm.stringStructure.get());
                  break;
              }
          }
<span class="line-new-header">--- 2614,11 ---</span>
      case NumberToStringWithRadix: {
          JSValue radixValue = forNode(node-&gt;child2()).m_value;
          if (radixValue &amp;&amp; radixValue.isInt32()) {
              int32_t radix = radixValue.asInt32();
              if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  didFoldClobberWorld();
                  setForNode(node, m_graph.m_vm.stringStructure.get());
                  break;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2530,12 ***</span>
      case NewArrayWithSpread:
          if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
              // We&#39;ve compiled assuming we&#39;re not having a bad time, so to be consistent
              // with StructureRegisterationPhase we must say we produce an original array
              // allocation structure.
<span class="line-modified">!             setForNode(node,</span>
<span class="line-modified">!                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));</span>
          } else {
              setForNode(node,
                  m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
          }
  
<span class="line-new-header">--- 2652,30 ---</span>
      case NewArrayWithSpread:
          if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
              // We&#39;ve compiled assuming we&#39;re not having a bad time, so to be consistent
              // with StructureRegisterationPhase we must say we produce an original array
              // allocation structure.
<span class="line-modified">! #if USE(JSVALUE64)</span>
<span class="line-modified">!             BitVector* bitVector = node-&gt;bitVector();</span>
<span class="line-added">+             if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added">+                 Edge use = m_graph.varArgChild(node, 0);</span>
<span class="line-added">+                 if (use-&gt;op() == PhantomSpread) {</span>
<span class="line-added">+                     if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="line-added">+                         auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added">+                         if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added">+                             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+                             setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));</span>
          } else {
              setForNode(node,
                  m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2552,12 ***</span>
              else
                  didFoldClobberWorld();
              break;
          }
  
<span class="line-modified">!         setForNode(node,</span>
<span class="line-removed">-             m_vm.fixedArrayStructure.get());</span>
          break;
  
      case NewArrayBuffer:
          setForNode(node,
              m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingMode()));
<span class="line-new-header">--- 2692,11 ---</span>
              else
                  didFoldClobberWorld();
              break;
          }
  
<span class="line-modified">!         setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());</span>
          break;
  
      case NewArrayBuffer:
          setForNode(node,
              m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingMode()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2593,18 ***</span>
          bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
  
          ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
          switch (result) {
          case ToThisResult::Identity:
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              destination = source;
              break;
          case ToThisResult::Undefined:
              setConstant(node, jsUndefined());
              break;
          case ToThisResult::GlobalThis:
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              destination.setType(m_graph, SpecObject);
              break;
          case ToThisResult::Dynamic:
              if (strictMode)
                  destination.makeHeapTop();
<span class="line-new-header">--- 2732,18 ---</span>
          bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
  
          ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
          switch (result) {
          case ToThisResult::Identity:
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              destination = source;
              break;
          case ToThisResult::Undefined:
              setConstant(node, jsUndefined());
              break;
          case ToThisResult::GlobalThis:
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              destination.setType(m_graph, SpecObject);
              break;
          case ToThisResult::Dynamic:
              if (strictMode)
                  destination.makeHeapTop();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2619,27 ***</span>
  
      case CreateThis: {
          if (JSValue base = forNode(node-&gt;child1()).m_value) {
              if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
                  if (FunctionRareData* rareData = function-&gt;rareData()) {
<span class="line-modified">!                     if (Structure* structure = rareData-&gt;objectAllocationStructure()) {</span>
<span class="line-modified">!                         m_graph.freeze(rareData);</span>
<span class="line-modified">!                         m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-modified">!                         m_state.setFoundConstants(true);</span>
<span class="line-modified">!                         didFoldClobberWorld();</span>
<span class="line-modified">!                         setForNode(node, structure);</span>
<span class="line-modified">!                         break;</span>
                      }
                  }
              }
          }
          clobberWorld();
          setTypeForNode(node, SpecFinalObject);
          break;
      }
  
      case NewObject:
          ASSERT(!!node-&gt;structure().get());
          setForNode(node, node-&gt;structure());
          break;
  
      case ObjectCreate: {
<span class="line-new-header">--- 2758,113 ---</span>
  
      case CreateThis: {
          if (JSValue base = forNode(node-&gt;child1()).m_value) {
              if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
                  if (FunctionRareData* rareData = function-&gt;rareData()) {
<span class="line-modified">!                     if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-modified">!                         if (Structure* structure = rareData-&gt;objectAllocationStructure()) {</span>
<span class="line-modified">!                             m_graph.freeze(rareData);</span>
<span class="line-modified">!                             m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-modified">!                             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-modified">!                             didFoldClobberWorld();</span>
<span class="line-modified">!                             setForNode(node, structure);</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         }</span>
                      }
                  }
              }
          }
          clobberWorld();
          setTypeForNode(node, SpecFinalObject);
          break;
      }
  
<span class="line-added">+     case CreatePromise: {</span>
<span class="line-added">+         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">+         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added">+             if (base == (node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {</span>
<span class="line-added">+                 m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+                 didFoldClobberWorld();</span>
<span class="line-added">+                 setForNode(node, node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure());</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added">+                 if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added">+                     if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                         Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">+                         if (structure</span>
<span class="line-added">+                             &amp;&amp; structure-&gt;classInfo() == (node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())</span>
<span class="line-added">+                             &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added">+                             &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                             m_graph.freeze(rareData);</span>
<span class="line-added">+                             m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added">+                             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+                             didFoldClobberWorld();</span>
<span class="line-added">+                             setForNode(node, structure);</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         clobberWorld();</span>
<span class="line-added">+         setTypeForNode(node, SpecPromiseObject);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case CreateGenerator:</span>
<span class="line-added">+     case CreateAsyncGenerator: {</span>
<span class="line-added">+         auto tryToFold = [&amp;] (const ClassInfo* classInfo) -&gt; bool {</span>
<span class="line-added">+             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">+             if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added">+                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added">+                     if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added">+                         if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                             Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">+                             if (structure</span>
<span class="line-added">+                                 &amp;&amp; structure-&gt;classInfo() == classInfo</span>
<span class="line-added">+                                 &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added">+                                 &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">+                                 m_graph.freeze(rareData);</span>
<span class="line-added">+                                 m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added">+                                 m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+                                 didFoldClobberWorld();</span>
<span class="line-added">+                                 setForNode(node, structure);</span>
<span class="line-added">+                                 return true;</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         bool found = false;</span>
<span class="line-added">+         switch (node-&gt;op()) {</span>
<span class="line-added">+         case CreateGenerator:</span>
<span class="line-added">+             found = tryToFold(JSGenerator::info());</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         case CreateAsyncGenerator:</span>
<span class="line-added">+             found = tryToFold(JSAsyncGenerator::info());</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (found)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         clobberWorld();</span>
<span class="line-added">+         setTypeForNode(node, SpecObjectOther);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case NewPromise:</span>
<span class="line-added">+     case NewGenerator:</span>
<span class="line-added">+     case NewAsyncGenerator:</span>
<span class="line-added">+     case NewArrayIterator:</span>
      case NewObject:
<span class="line-added">+     case MaterializeNewInternalFieldObject:</span>
          ASSERT(!!node-&gt;structure().get());
          setForNode(node, node-&gt;structure());
          break;
  
      case ObjectCreate: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2647,14 ***</span>
              JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
              Structure* structure = nullptr;
              if (base.isNull())
                  structure = globalObject-&gt;nullPrototypeObjectStructure();
              else if (base.isObject())
<span class="line-modified">!                 structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());</span>
  
              if (structure) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  if (node-&gt;child1().useKind() == UntypedUse)
                      didFoldClobberWorld();
                  setForNode(node, structure);
                  break;
              }
<span class="line-new-header">--- 2872,14 ---</span>
              JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
              Structure* structure = nullptr;
              if (base.isNull())
                  structure = globalObject-&gt;nullPrototypeObjectStructure();
              else if (base.isObject())
<span class="line-modified">!                 structure = m_vm.structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());</span>
  
              if (structure) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  if (node-&gt;child1().useKind() == UntypedUse)
                      didFoldClobberWorld();
                  setForNode(node, structure);
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2671,11 ***</span>
              if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
                  RegisteredStructure structure = structureSet.onlyStructure();
                  if (auto* rareData = structure-&gt;rareDataConcurrently()) {
                      if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
                          if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
<span class="line-modified">!                             m_state.setFoundConstants(true);</span>
                              didFoldClobberWorld();
                              setTypeForNode(node, SpecArray);
                              break;
                          }
                      }
<span class="line-new-header">--- 2896,11 ---</span>
              if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
                  RegisteredStructure structure = structureSet.onlyStructure();
                  if (auto* rareData = structure-&gt;rareDataConcurrently()) {
                      if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
                          if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
<span class="line-modified">!                             m_state.setShouldTryConstantFolding(true);</span>
                              didFoldClobberWorld();
                              setTypeForNode(node, SpecArray);
                              break;
                          }
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2692,11 ***</span>
      case CallObjectConstructor: {
          AbstractValue&amp; source = forNode(node-&gt;child1());
          AbstractValue&amp; destination = forNode(node);
  
          if (!(source.m_type &amp; ~SpecObject)) {
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              if (node-&gt;op() == ToObject)
                  didFoldClobberWorld();
              destination = source;
              break;
          }
<span class="line-new-header">--- 2917,11 ---</span>
      case CallObjectConstructor: {
          AbstractValue&amp; source = forNode(node-&gt;child1());
          AbstractValue&amp; destination = forNode(node);
  
          if (!(source.m_type &amp; ~SpecObject)) {
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              if (node-&gt;op() == ToObject)
                  didFoldClobberWorld();
              destination = source;
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2717,10 ***</span>
<span class="line-new-header">--- 2942,11 ---</span>
      case PhantomClonedArguments:
      case PhantomCreateRest:
      case PhantomSpread:
      case PhantomNewArrayWithSpread:
      case PhantomNewArrayBuffer:
<span class="line-added">+     case PhantomNewArrayIterator:</span>
      case PhantomNewRegexp:
      case BottomValue: {
          clearForNode(node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2758,10 ***</span>
<span class="line-new-header">--- 2984,14 ---</span>
              break;
          }
          setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure());
          break;
  
<span class="line-added">+     case CreateArgumentsButterfly:</span>
<span class="line-added">+         setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ </span>
      case NewGeneratorFunction:
          setForNode(node,
              m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;generatorFunctionStructure());
          break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2895,10 ***</span>
<span class="line-new-header">--- 3125,18 ---</span>
          break;
  
      case PutClosureVar:
          break;
  
<span class="line-added">+     case GetInternalField:</span>
<span class="line-added">+         makeBytecodeTopForNode(node);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     case PutInternalField:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      case GetRegExpObjectLastIndex:
          makeHeapTopForNode(node);
          break;
  
      case SetRegExpObjectLastIndex:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2928,11 ***</span>
      case GetByIdFlush: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (value.m_structure.isFinite()
              &amp;&amp; (node-&gt;child1().useKind() == CellUse || !(value.m_type &amp; ~SpecCell))) {
              UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
<span class="line-modified">!             GetByIdStatus status = GetByIdStatus::computeFor(value.m_structure.toStructureSet(), uid);</span>
              if (status.isSimple()) {
                  // Figure out what the result is going to be - is it TOP, a constant, or maybe
                  // something more subtle?
                  AbstractValue result;
                  for (unsigned i = status.numVariants(); i--;) {
<span class="line-new-header">--- 3166,11 ---</span>
      case GetByIdFlush: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (value.m_structure.isFinite()
              &amp;&amp; (node-&gt;child1().useKind() == CellUse || !(value.m_type &amp; ~SpecCell))) {
              UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
<span class="line-modified">!             GetByStatus status = GetByStatus::computeFor(value.m_structure.toStructureSet(), uid);</span>
              if (status.isSimple()) {
                  // Figure out what the result is going to be - is it TOP, a constant, or maybe
                  // something more subtle?
                  AbstractValue result;
                  for (unsigned i = status.numVariants(); i--;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2943,11 ***</span>
                      result.merge(
                          m_graph.inferredValueForProperty(
                              value, status[i].offset(), m_state.structureClobberState()));
                  }
  
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  didFoldClobberWorld();
                  forNode(node) = result;
                  break;
              }
          }
<span class="line-new-header">--- 3181,11 ---</span>
                      result.merge(
                          m_graph.inferredValueForProperty(
                              value, status[i].offset(), m_state.structureClobberState()));
                  }
  
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  didFoldClobberWorld();
                  forNode(node) = result;
                  break;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2996,11 ***</span>
          // It&#39;s interesting that we could have proven that the object has a larger structure set
          // that includes the set we&#39;re testing. In that case we could make the structure check
          // more efficient. We currently don&#39;t.
  
          if (value.m_structure.isSubsetOf(set))
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
  
          SpeculatedType admittedTypes = SpecNone;
          switch (node-&gt;child1().useKind()) {
          case CellUse:
          case KnownCellUse:
<span class="line-new-header">--- 3234,11 ---</span>
          // It&#39;s interesting that we could have proven that the object has a larger structure set
          // that includes the set we&#39;re testing. In that case we could make the structure check
          // more efficient. We currently don&#39;t.
  
          if (value.m_structure.isSubsetOf(set))
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
  
          SpeculatedType admittedTypes = SpecNone;
          switch (node-&gt;child1().useKind()) {
          case CellUse:
          case KnownCellUse:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3021,11 ***</span>
      case CheckStructureOrEmpty: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
  
          bool mayBeEmpty = value.m_type &amp; SpecEmpty;
          if (!mayBeEmpty)
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
  
          SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
          filter(value, node-&gt;structureSet(), admittedTypes);
          break;
      }
<span class="line-new-header">--- 3259,11 ---</span>
      case CheckStructureOrEmpty: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
  
          bool mayBeEmpty = value.m_type &amp; SpecEmpty;
          if (!mayBeEmpty)
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
  
          SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
          filter(value, node-&gt;structureSet(), admittedTypes);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3038,11 ***</span>
          const RegisteredStructureSet&amp; set = node-&gt;structureSet();
  
          if (value.value()) {
              if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_vm, value.value())) {
                  if (set.contains(m_graph.registerStructure(structure))) {
<span class="line-modified">!                     m_state.setFoundConstants(true);</span>
                      break;
                  }
              }
              m_state.setIsValid(false);
              break;
<span class="line-new-header">--- 3276,11 ---</span>
          const RegisteredStructureSet&amp; set = node-&gt;structureSet();
  
          if (value.value()) {
              if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_vm, value.value())) {
                  if (set.contains(m_graph.registerStructure(structure))) {
<span class="line-modified">!                     m_state.setShouldTryConstantFolding(true);</span>
                      break;
                  }
              }
              m_state.setIsValid(false);
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3058,11 ***</span>
                              return;
                      }
                      allGood = false;
                  });
              if (allGood) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  break;
              }
          }
  
          if (RegisteredStructure structure = set.onlyStructure()) {
<span class="line-new-header">--- 3296,11 ---</span>
                              return;
                      }
                      allGood = false;
                  });
              if (allGood) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  break;
              }
          }
  
          if (RegisteredStructure structure = set.onlyStructure()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3076,11 ***</span>
  
      case PutStructure:
          if (!forNode(node-&gt;child1()).m_structure.isClear()) {
              if (forNode(node-&gt;child1()).m_structure.onlyStructure() == node-&gt;transition()-&gt;next) {
                  didFoldClobberStructures();
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
              } else {
                  observeTransition(
                      clobberLimit, node-&gt;transition()-&gt;previous, node-&gt;transition()-&gt;next);
                  forNode(node-&gt;child1()).changeStructure(m_graph, node-&gt;transition()-&gt;next);
              }
<span class="line-new-header">--- 3314,11 ---</span>
  
      case PutStructure:
          if (!forNode(node-&gt;child1()).m_structure.isClear()) {
              if (forNode(node-&gt;child1()).m_structure.onlyStructure() == node-&gt;transition()-&gt;next) {
                  didFoldClobberStructures();
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
              } else {
                  observeTransition(
                      clobberLimit, node-&gt;transition()-&gt;previous, node-&gt;transition()-&gt;next);
                  forNode(node-&gt;child1()).changeStructure(m_graph, node-&gt;transition()-&gt;next);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3101,20 ***</span>
          break;
      case CheckSubClass: {
          JSValue constant = forNode(node-&gt;child1()).value();
          if (constant) {
              if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_vm, node-&gt;classInfo())) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  ASSERT(constant);
                  break;
              }
          }
  
          AbstractValue&amp; value = forNode(node-&gt;child1());
  
          if (value.m_structure.isSubClassOf(node-&gt;classInfo()))
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
  
          filterClassInfo(value, node-&gt;classInfo());
          break;
      }
      case CallDOMGetter: {
<span class="line-new-header">--- 3339,20 ---</span>
          break;
      case CheckSubClass: {
          JSValue constant = forNode(node-&gt;child1()).value();
          if (constant) {
              if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_vm, node-&gt;classInfo())) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  ASSERT(constant);
                  break;
              }
          }
  
          AbstractValue&amp; value = forNode(node-&gt;child1());
  
          if (value.m_structure.isSubClassOf(node-&gt;classInfo()))
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
  
          filterClassInfo(value, node-&gt;classInfo());
          break;
      }
      case CallDOMGetter: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3133,84 ***</span>
          if (signature-&gt;effect.writes)
              clobberWorld();
          setTypeForNode(node, signature-&gt;result);
          break;
      }
      case CheckArray: {
<span class="line-modified">!         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {</span>
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              break;
          }
          switch (node-&gt;arrayMode().type()) {
          case Array::String:
<span class="line-modified">!             filter(node-&gt;child1(), SpecString);</span>
              break;
          case Array::Int32:
          case Array::Double:
          case Array::Contiguous:
          case Array::Undecided:
          case Array::ArrayStorage:
          case Array::SlowPutArrayStorage:
              break;
          case Array::DirectArguments:
<span class="line-modified">!             filter(node-&gt;child1(), SpecDirectArguments);</span>
              break;
          case Array::ScopedArguments:
<span class="line-modified">!             filter(node-&gt;child1(), SpecScopedArguments);</span>
              break;
          case Array::Int8Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecInt8Array);</span>
              break;
          case Array::Int16Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecInt16Array);</span>
              break;
          case Array::Int32Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecInt32Array);</span>
              break;
          case Array::Uint8Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint8Array);</span>
              break;
          case Array::Uint8ClampedArray:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint8ClampedArray);</span>
              break;
          case Array::Uint16Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint16Array);</span>
              break;
          case Array::Uint32Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint32Array);</span>
              break;
          case Array::Float32Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecFloat32Array);</span>
              break;
          case Array::Float64Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecFloat64Array);</span>
              break;
          case Array::AnyTypedArray:
<span class="line-modified">!             filter(node-&gt;child1(), SpecTypedArrayView);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
<span class="line-modified">!         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());</span>
          break;
      }
      case Arrayify: {
          if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
              didFoldClobberStructures();
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              break;
          }
          ASSERT(node-&gt;arrayMode().conversion() == Array::Convert);
          clobberStructures();
          filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
          break;
      }
      case ArrayifyToStructure: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (value.m_structure.isSubsetOf(RegisteredStructureSet(node-&gt;structure())))
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          clobberStructures();
  
          // We have a bunch of options of how to express the abstract set at this point. Let set S
          // be the set of structures that the value had before clobbering and assume that all of
          // them are watchable. The new value should be the least expressible upper bound of the
<span class="line-new-header">--- 3371,99 ---</span>
          if (signature-&gt;effect.writes)
              clobberWorld();
          setTypeForNode(node, signature-&gt;result);
          break;
      }
<span class="line-added">+ </span>
<span class="line-added">+     case CheckArrayOrEmpty:</span>
      case CheckArray: {
<span class="line-modified">!         AbstractValue&amp; value = forNode(node-&gt;child1());</span>
<span class="line-modified">! </span>
<span class="line-added">+         SpeculatedType admittedTypes = SpecNone;</span>
<span class="line-added">+         if (node-&gt;op() == CheckArrayOrEmpty) {</span>
<span class="line-added">+             bool mayBeEmpty = value.m_type &amp; SpecEmpty;</span>
<span class="line-added">+             if (!mayBeEmpty)</span>
<span class="line-added">+                 m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 admittedTypes = SpecEmpty;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, value)) {</span>
<span class="line-added">+             m_state.setShouldTryConstantFolding(true);</span>
              break;
          }
<span class="line-added">+ </span>
          switch (node-&gt;arrayMode().type()) {
          case Array::String:
<span class="line-modified">!             filter(node-&gt;child1(), SpecString | admittedTypes);</span>
              break;
          case Array::Int32:
          case Array::Double:
          case Array::Contiguous:
          case Array::Undecided:
          case Array::ArrayStorage:
          case Array::SlowPutArrayStorage:
              break;
          case Array::DirectArguments:
<span class="line-modified">!             filter(node-&gt;child1(), SpecDirectArguments | admittedTypes);</span>
              break;
          case Array::ScopedArguments:
<span class="line-modified">!             filter(node-&gt;child1(), SpecScopedArguments | admittedTypes);</span>
              break;
          case Array::Int8Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecInt8Array | admittedTypes);</span>
              break;
          case Array::Int16Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecInt16Array | admittedTypes);</span>
              break;
          case Array::Int32Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecInt32Array | admittedTypes);</span>
              break;
          case Array::Uint8Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint8Array | admittedTypes);</span>
              break;
          case Array::Uint8ClampedArray:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint8ClampedArray | admittedTypes);</span>
              break;
          case Array::Uint16Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint16Array | admittedTypes);</span>
              break;
          case Array::Uint32Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecUint32Array | admittedTypes);</span>
              break;
          case Array::Float32Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecFloat32Array | admittedTypes);</span>
              break;
          case Array::Float64Array:
<span class="line-modified">!             filter(node-&gt;child1(), SpecFloat64Array | admittedTypes);</span>
              break;
          case Array::AnyTypedArray:
<span class="line-modified">!             filter(node-&gt;child1(), SpecTypedArrayView | admittedTypes);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
<span class="line-modified">!         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering(), admittedTypes);</span>
          break;
      }
<span class="line-added">+ </span>
      case Arrayify: {
          if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
              didFoldClobberStructures();
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              break;
          }
          ASSERT(node-&gt;arrayMode().conversion() == Array::Convert);
          clobberStructures();
          filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
          break;
      }
      case ArrayifyToStructure: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (value.m_structure.isSubsetOf(RegisteredStructureSet(node-&gt;structure())))
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          clobberStructures();
  
          // We have a bunch of options of how to express the abstract set at this point. Let set S
          // be the set of structures that the value had before clobbering and assume that all of
          // them are watchable. The new value should be the least expressible upper bound of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3243,11 ***</span>
      }
      case GetIndexedPropertyStorage: {
          JSArrayBufferView* view = m_graph.tryGetFoldableView(
              forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
          if (view)
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          clearForNode(node);
          break;
      }
      case ConstantStoragePointer: {
          clearForNode(node);
<span class="line-new-header">--- 3496,11 ---</span>
      }
      case GetIndexedPropertyStorage: {
          JSArrayBufferView* view = m_graph.tryGetFoldableView(
              forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
          if (view)
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          clearForNode(node);
          break;
      }
      case ConstantStoragePointer: {
          clearForNode(node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3255,12 ***</span>
      }
  
      case GetTypedArrayByteOffset: {
          JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node-&gt;child1()).m_value);
          if (view) {
<span class="line-modified">!             setConstant(node, jsNumber(view-&gt;byteOffset()));</span>
<span class="line-modified">!             break;</span>
          }
          setNonCellTypeForNode(node, SpecInt32Only);
          break;
      }
  
<span class="line-new-header">--- 3508,15 ---</span>
      }
  
      case GetTypedArrayByteOffset: {
          JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node-&gt;child1()).m_value);
          if (view) {
<span class="line-modified">!             Optional&lt;unsigned&gt; byteOffset = view-&gt;byteOffsetConcurrently();</span>
<span class="line-modified">!             if (byteOffset) {</span>
<span class="line-added">+                 setConstant(node, jsNumber(*byteOffset));</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
          }
          setNonCellTypeForNode(node, SpecInt32Only);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3331,11 ***</span>
          if (value.isClear())
              m_state.setIsValid(false);
  
          setForNode(node, value);
          if (value.m_value)
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          break;
      }
  
      case GetGetterSetterByOffset: {
          StorageAccessData&amp; data = node-&gt;storageAccessData();
<span class="line-new-header">--- 3587,11 ---</span>
          if (value.isClear())
              m_state.setIsValid(false);
  
          setForNode(node, value);
          if (value.m_value)
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          break;
      }
  
      case GetGetterSetterByOffset: {
          StorageAccessData&amp; data = node-&gt;storageAccessData();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3344,16 ***</span>
          if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
              setConstant(node, *m_graph.freeze(result));
              break;
          }
  
<span class="line-modified">!         if (base.value() &amp;&amp; base.value().isObject()) {</span>
<span class="line-removed">-             setForNode(node, asObject(base.value())-&gt;globalObject()-&gt;getterSetterStructure());</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         setTypeForNode(node, SpecObjectOther);</span>
          break;
      }
  
      case MultiGetByOffset: {
          // This code will filter the base value in a manner that is possibly different (either more
<span class="line-new-header">--- 3600,11 ---</span>
          if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
              setConstant(node, *m_graph.freeze(result));
              break;
          }
  
<span class="line-modified">!         setForNode(node, m_vm.getterSetterStructure.get());</span>
          break;
      }
  
      case MultiGetByOffset: {
          // This code will filter the base value in a manner that is possibly different (either more
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3363,13 ***</span>
          // one guy proving that code should never execute (due to a contradiction) and another guy
          // not finding that contradiction. If someone ever proved that there would be a
          // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
          // realize it. This is the case here.
  
<span class="line-modified">!         // Ordinarily you have to be careful with calling setFoundConstants()</span>
          // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">!         m_state.setFoundConstants(true);</span>
  
          AbstractValue base = forNode(node-&gt;child1());
          RegisteredStructureSet baseSet;
          AbstractValue result;
          for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
<span class="line-new-header">--- 3614,13 ---</span>
          // one guy proving that code should never execute (due to a contradiction) and another guy
          // not finding that contradiction. If someone ever proved that there would be a
          // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
          // realize it. This is the case here.
  
<span class="line-modified">!         // Ordinarily you have to be careful with calling setShouldTryConstantFolding()</span>
          // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">!         m_state.setShouldTryConstantFolding(true);</span>
  
          AbstractValue base = forNode(node-&gt;child1());
          RegisteredStructureSet baseSet;
          AbstractValue result;
          for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3409,13 ***</span>
  
      case MultiPutByOffset: {
          RegisteredStructureSet newSet;
          TransitionVector transitions;
  
<span class="line-modified">!         // Ordinarily you have to be careful with calling setFoundConstants()</span>
          // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">!         m_state.setFoundConstants(true);</span>
  
          AbstractValue base = forNode(node-&gt;child1());
          AbstractValue originalValue = forNode(node-&gt;child2());
          AbstractValue resultingValue;
  
<span class="line-new-header">--- 3660,13 ---</span>
  
      case MultiPutByOffset: {
          RegisteredStructureSet newSet;
          TransitionVector transitions;
  
<span class="line-modified">!         // Ordinarily you have to be careful with calling setShouldTryConstantFolding()</span>
          // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">!         m_state.setShouldTryConstantFolding(true);</span>
  
          AbstractValue base = forNode(node-&gt;child1());
          AbstractValue originalValue = forNode(node-&gt;child2());
          AbstractValue resultingValue;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3473,11 ***</span>
      }
  
      case CheckCell: {
          JSValue value = forNode(node-&gt;child1()).value();
          if (value == node-&gt;cellOperand()-&gt;value()) {
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              ASSERT(value);
              break;
          }
          filterByValue(node-&gt;child1(), *node-&gt;cellOperand());
          break;
<span class="line-new-header">--- 3724,11 ---</span>
      }
  
      case CheckCell: {
          JSValue value = forNode(node-&gt;child1()).value();
          if (value == node-&gt;cellOperand()-&gt;value()) {
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              ASSERT(value);
              break;
          }
          filterByValue(node-&gt;child1(), *node-&gt;cellOperand());
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3485,41 ***</span>
  
      case AssertNotEmpty:
      case CheckNotEmpty: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (!(value.m_type &amp; SpecEmpty)) {
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
              break;
          }
  
          filter(value, ~SpecEmpty);
          break;
      }
  
<span class="line-modified">!     case CheckStringIdent: {</span>
          AbstractValue&amp; value = forNode(node-&gt;child1());
          UniquedStringImpl* uid = node-&gt;uidOperand();
<span class="line-removed">-         ASSERT(!(value.m_type &amp; ~SpecStringIdent)); // Edge filtering should have already ensured this.</span>
  
          JSValue childConstant = value.value();
          if (childConstant) {
<span class="line-modified">!             ASSERT(childConstant.isString());</span>
<span class="line-modified">!             if (asString(childConstant)-&gt;tryGetValueImpl() == uid) {</span>
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
<span class="line-modified">!                 break;</span>
              }
          }
  
<span class="line-modified">!         filter(value, SpecStringIdent);</span>
          break;
      }
  
      case CheckInBounds: {
          JSValue left = forNode(node-&gt;child1()).value();
          JSValue right = forNode(node-&gt;child2()).value();
          if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32() &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32()))
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
  
          // We claim we result in Int32. It&#39;s not really important what our result is (though we
          // don&#39;t want to claim we may result in the empty value), other nodes with data flow edges
          // to us just do that to maintain the invariant that they can&#39;t be hoisted higher than us.
          // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
<span class="line-new-header">--- 3736,49 ---</span>
  
      case AssertNotEmpty:
      case CheckNotEmpty: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (!(value.m_type &amp; SpecEmpty)) {
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
              break;
          }
  
          filter(value, ~SpecEmpty);
          break;
      }
  
<span class="line-modified">!     case CheckIdent: {</span>
          AbstractValue&amp; value = forNode(node-&gt;child1());
          UniquedStringImpl* uid = node-&gt;uidOperand();
  
          JSValue childConstant = value.value();
          if (childConstant) {
<span class="line-modified">!             if (childConstant.isString()) {</span>
<span class="line-modified">!                 if (asString(childConstant)-&gt;tryGetValueImpl() == uid) {</span>
<span class="line-modified">!                     m_state.setShouldTryConstantFolding(true);</span>
<span class="line-modified">!                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else if (childConstant.isSymbol()) {</span>
<span class="line-added">+                 if (&amp;jsCast&lt;Symbol*&gt;(childConstant)-&gt;uid() == uid) {</span>
<span class="line-added">+                     m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
              }
          }
  
<span class="line-modified">!         if (node-&gt;child1().useKind() == StringIdentUse)</span>
<span class="line-added">+             filter(value, SpecStringIdent);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             filter(value, SpecSymbol);</span>
          break;
      }
  
      case CheckInBounds: {
          JSValue left = forNode(node-&gt;child1()).value();
          JSValue right = forNode(node-&gt;child2()).value();
          if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32() &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32()))
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
  
          // We claim we result in Int32. It&#39;s not really important what our result is (though we
          // don&#39;t want to claim we may result in the empty value), other nodes with data flow edges
          // to us just do that to maintain the invariant that they can&#39;t be hoisted higher than us.
          // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3538,16 ***</span>
                  m_graph.globalObjectFor(node-&gt;origin.semantic),
                  value.m_structure.toStructureSet(),
                  m_graph.identifiers()[node-&gt;identifierNumber()],
                  node-&gt;op() == PutByIdDirect);
  
              if (status.isSimple()) {
                  RegisteredStructureSet newSet;
                  TransitionVector transitions;
  
<span class="line-modified">!                 for (unsigned i = status.numVariants(); i--;) {</span>
<span class="line-modified">!                     const PutByIdVariant&amp; variant = status[i];</span>
                      if (variant.kind() == PutByIdVariant::Transition) {
                          RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
                          transitions.append(
                              Transition(
                                  m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
<span class="line-new-header">--- 3797,26 ---</span>
                  m_graph.globalObjectFor(node-&gt;origin.semantic),
                  value.m_structure.toStructureSet(),
                  m_graph.identifiers()[node-&gt;identifierNumber()],
                  node-&gt;op() == PutByIdDirect);
  
<span class="line-added">+             bool allGood = true;</span>
              if (status.isSimple()) {
                  RegisteredStructureSet newSet;
                  TransitionVector transitions;
  
<span class="line-modified">!                 for (const PutByIdVariant&amp; variant : status.variants()) {</span>
<span class="line-modified">!                     for (const ObjectPropertyCondition&amp; condition : variant.conditionSet()) {</span>
<span class="line-added">+                         if (!m_graph.watchCondition(condition)) {</span>
<span class="line-added">+                             allGood = false;</span>
<span class="line-added">+                             break;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (!allGood)</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+ </span>
                      if (variant.kind() == PutByIdVariant::Transition) {
                          RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
                          transitions.append(
                              Transition(
                                  m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3557,17 ***</span>
                          newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
                      }
                  }
  
                  if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
<span class="line-modified">!                     m_state.setFoundConstants(true);</span>
  
<span class="line-modified">!                 didFoldClobberWorld();</span>
<span class="line-modified">!                 observeTransitions(clobberLimit, transitions);</span>
<span class="line-modified">!                 if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)</span>
<span class="line-modified">!                     m_state.setIsValid(false);</span>
<span class="line-modified">!                 break;</span>
              }
          }
  
          clobberWorld();
          break;
<span class="line-new-header">--- 3826,19 ---</span>
                          newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
                      }
                  }
  
                  if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
<span class="line-modified">!                     m_state.setShouldTryConstantFolding(true);</span>
  
<span class="line-modified">!                 if (allGood) {</span>
<span class="line-modified">!                     didFoldClobberWorld();</span>
<span class="line-modified">!                     observeTransitions(clobberLimit, transitions);</span>
<span class="line-modified">!                     if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)</span>
<span class="line-modified">!                         m_state.setIsValid(false);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
              }
          }
  
          clobberWorld();
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3606,11 ***</span>
          if (JSValue constant = property.value()) {
              if (constant.isString()) {
                  JSString* string = asString(constant);
                  const StringImpl* impl = string-&gt;tryGetValueImpl();
                  if (impl &amp;&amp; impl-&gt;isAtom())
<span class="line-modified">!                     m_state.setFoundConstants(true);</span>
              }
          }
  
          // FIXME: We can determine when the property definitely exists based on abstract
          // value information.
<span class="line-new-header">--- 3877,11 ---</span>
          if (JSValue constant = property.value()) {
              if (constant.isString()) {
                  JSString* string = asString(constant);
                  const StringImpl* impl = string-&gt;tryGetValueImpl();
                  if (impl &amp;&amp; impl-&gt;isAtom())
<span class="line-modified">!                     m_state.setShouldTryConstantFolding(true);</span>
              }
          }
  
          // FIXME: We can determine when the property definitely exists based on abstract
          // value information.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3731,11 ***</span>
  
          BooleanLattice result = BooleanLattice::Bottom;
          for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants) {
              RegisteredStructure structure = variant.structure;
              if (!base.contains(structure)) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  continue;
              }
  
              baseSet.add(structure);
              result = leastUpperBoundOfBooleanLattices(
<span class="line-new-header">--- 4002,11 ---</span>
  
          BooleanLattice result = BooleanLattice::Bottom;
          for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants) {
              RegisteredStructure structure = variant.structure;
              if (!base.contains(structure)) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  continue;
              }
  
              baseSet.add(structure);
              result = leastUpperBoundOfBooleanLattices(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3763,11 ***</span>
          RELEASE_ASSERT(m_graph.m_form == SSA);
          setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
          // The state of this node would have already been decided, but it may have become a
          // constant, in which case we&#39;d like to know.
          if (forNode(node).m_value)
<span class="line-modified">!             m_state.setFoundConstants(true);</span>
          break;
  
      case Upsilon: {
          NodeFlowProjection shadow(node-&gt;phi(), NodeFlowProjection::Shadow);
          if (shadow.isStillValid()) {
<span class="line-new-header">--- 4034,11 ---</span>
          RELEASE_ASSERT(m_graph.m_form == SSA);
          setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
          // The state of this node would have already been decided, but it may have become a
          // constant, in which case we&#39;d like to know.
          if (forNode(node).m_value)
<span class="line-modified">!             m_state.setShouldTryConstantFolding(true);</span>
          break;
  
      case Upsilon: {
          NodeFlowProjection shadow(node-&gt;phi(), NodeFlowProjection::Shadow);
          if (shadow.isStillValid()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3822,18 ***</span>
      case ProfileControlFlow:
      case Phantom:
      case CountExecution:
      case CheckTierUpInLoop:
      case CheckTierUpAtReturn:
      case SuperSamplerBegin:
      case SuperSamplerEnd:
      case CheckTierUpAndOSREnter:
      case LoopHint:
      case ZombieHint:
      case ExitOK:
      case FilterCallLinkStatus:
<span class="line-modified">!     case FilterGetByIdStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
      case ClearCatchLocals:
          break;
  
<span class="line-new-header">--- 4093,19 ---</span>
      case ProfileControlFlow:
      case Phantom:
      case CountExecution:
      case CheckTierUpInLoop:
      case CheckTierUpAtReturn:
<span class="line-added">+     case CheckNeutered:</span>
      case SuperSamplerBegin:
      case SuperSamplerEnd:
      case CheckTierUpAndOSREnter:
      case LoopHint:
      case ZombieHint:
      case ExitOK:
      case FilterCallLinkStatus:
<span class="line-modified">!     case FilterGetByStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
      case ClearCatchLocals:
          break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3841,22 ***</span>
          const AbstractValue&amp; abstractValue = forNode(node-&gt;child1());
          unsigned bits = node-&gt;typeInfoOperand();
          ASSERT(bits);
          if (bits == ImplementsDefaultHasInstance) {
              if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  break;
              }
          }
  
          if (JSValue value = abstractValue.value()) {
              if (value.isCell()) {
                  // This works because if we see a cell here, we know it&#39;s fully constructed
                  // and we can read its inline type info flags. These flags don&#39;t change over the
                  // object&#39;s lifetime.
                  if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
<span class="line-modified">!                     m_state.setFoundConstants(true);</span>
                      break;
                  }
              }
          }
  
<span class="line-new-header">--- 4113,22 ---</span>
          const AbstractValue&amp; abstractValue = forNode(node-&gt;child1());
          unsigned bits = node-&gt;typeInfoOperand();
          ASSERT(bits);
          if (bits == ImplementsDefaultHasInstance) {
              if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  break;
              }
          }
  
          if (JSValue value = abstractValue.value()) {
              if (value.isCell()) {
                  // This works because if we see a cell here, we know it&#39;s fully constructed
                  // and we can read its inline type info flags. These flags don&#39;t change over the
                  // object&#39;s lifetime.
                  if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
<span class="line-modified">!                     m_state.setShouldTryConstantFolding(true);</span>
                      break;
                  }
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3864,11 ***</span>
              bool ok = true;
              abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
                  ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
              });
              if (ok) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  break;
              }
          }
  
          break;
<span class="line-new-header">--- 4136,11 ---</span>
              bool ok = true;
              abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
                  ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
              });
              if (ok) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  break;
              }
          }
  
          break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3883,11 ***</span>
              else
                  radix = forNode(node-&gt;child2()).m_value;
  
              if (radix.isNumber()
                  &amp;&amp; (radix.asNumber() == 0 || radix.asNumber() == 10)) {
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
                  if (node-&gt;child1().useKind() == UntypedUse)
                      didFoldClobberWorld();
                  setNonCellTypeForNode(node, SpecInt32Only);
                  break;
              }
<span class="line-new-header">--- 4155,11 ---</span>
              else
                  radix = forNode(node-&gt;child2()).m_value;
  
              if (radix.isNumber()
                  &amp;&amp; (radix.asNumber() == 0 || radix.asNumber() == 10)) {
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
                  if (node-&gt;child1().useKind() == UntypedUse)
                      didFoldClobberWorld();
                  setNonCellTypeForNode(node, SpecInt32Only);
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3915,11 ***</span>
          // Simplify out checks that don&#39;t actually do checking.
          m_graph.doToChildren(node, [&amp;] (Edge edge) {
              if (!edge)
                  return;
              if (edge.isProved() || edge.willNotHaveCheck())
<span class="line-modified">!                 m_state.setFoundConstants(true);</span>
          });
          break;
      }
  
      case SetFunctionName: {
<span class="line-new-header">--- 4187,11 ---</span>
          // Simplify out checks that don&#39;t actually do checking.
          m_graph.doToChildren(node, [&amp;] (Edge edge) {
              if (!edge)
                  return;
              if (edge.isProved() || edge.willNotHaveCheck())
<span class="line-modified">!                 m_state.setShouldTryConstantFolding(true);</span>
          });
          break;
      }
  
      case SetFunctionName: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3950,10 ***</span>
<span class="line-new-header">--- 4222,20 ---</span>
      case DataViewGetFloat: {
          setNonCellTypeForNode(node, SpecFullDouble);
          break;
      }
  
<span class="line-added">+     case DateGetInt32OrNaN: {</span>
<span class="line-added">+         setNonCellTypeForNode(node, SpecInt32Only | SpecDoublePureNaN);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     case DateGetTime: {</span>
<span class="line-added">+         setNonCellTypeForNode(node, SpecFullDouble);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case DataViewSet: {
          break;
      }
  
      case Unreachable:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3982,14 ***</span>
      case FilterCallLinkStatus:
          if (JSValue value = forNode(node-&gt;child1()).m_value)
              node-&gt;callLinkStatus()-&gt;filter(m_vm, value);
          break;
  
<span class="line-modified">!     case FilterGetByIdStatus: {</span>
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (value.m_structure.isFinite())
<span class="line-modified">!             node-&gt;getByIdStatus()-&gt;filter(value.m_structure.toStructureSet());</span>
          break;
      }
  
      case FilterInByIdStatus: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
<span class="line-new-header">--- 4264,14 ---</span>
      case FilterCallLinkStatus:
          if (JSValue value = forNode(node-&gt;child1()).m_value)
              node-&gt;callLinkStatus()-&gt;filter(m_vm, value);
          break;
  
<span class="line-modified">!     case FilterGetByStatus: {</span>
          AbstractValue&amp; value = forNode(node-&gt;child1());
          if (value.m_structure.isFinite())
<span class="line-modified">!             node-&gt;getByStatus()-&gt;filter(value.m_structure.toStructureSet());</span>
          break;
      }
  
      case FilterInByIdStatus: {
          AbstractValue&amp; value = forNode(node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4126,11 ***</span>
      }
  
      AbstractValue::TransitionsObserver transitionsObserver(vector);
      forAllValues(clobberLimit, transitionsObserver);
  
<span class="line-modified">!     if (!ASSERT_DISABLED) {</span>
          // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
          for (unsigned i = vector.size(); i--;)
              ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
      }
  
<span class="line-new-header">--- 4408,11 ---</span>
      }
  
      AbstractValue::TransitionsObserver transitionsObserver(vector);
      forAllValues(clobberLimit, transitionsObserver);
  
<span class="line-modified">!     if (ASSERT_ENABLED) {</span>
          // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
          for (unsigned i = vector.size(); i--;)
              ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4189,13 ***</span>
      return Contradiction;
  }
  
  template&lt;typename AbstractStateType&gt;
  FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterArrayModes(
<span class="line-modified">!     AbstractValue&amp; value, ArrayModes arrayModes)</span>
  {
<span class="line-modified">!     if (value.filterArrayModes(arrayModes) == FiltrationOK)</span>
          return FiltrationOK;
      m_state.setIsValid(false);
      return Contradiction;
  }
  
<span class="line-new-header">--- 4471,13 ---</span>
      return Contradiction;
  }
  
  template&lt;typename AbstractStateType&gt;
  FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterArrayModes(
<span class="line-modified">!     AbstractValue&amp; value, ArrayModes arrayModes, SpeculatedType admittedTypes)</span>
  {
<span class="line-modified">!     if (value.filterArrayModes(arrayModes, admittedTypes) == FiltrationOK)</span>
          return FiltrationOK;
      m_state.setIsValid(false);
      return Contradiction;
  }
  
</pre>
<center><a href="DFGAbstractInterpreter.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
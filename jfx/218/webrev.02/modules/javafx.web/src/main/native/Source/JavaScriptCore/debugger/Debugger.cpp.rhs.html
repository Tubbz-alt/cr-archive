<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  3  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  4  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;Debugger.h&quot;
 24 
 25 #include &quot;CodeBlock.h&quot;
 26 #include &quot;DebuggerCallFrame.h&quot;
 27 #include &quot;Error.h&quot;
 28 #include &quot;HeapIterationScope.h&quot;
 29 #include &quot;Interpreter.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;JSCJSValueInlines.h&quot;
 32 #include &quot;JSFunction.h&quot;
 33 #include &quot;JSGlobalObject.h&quot;
 34 #include &quot;MarkedSpaceInlines.h&quot;
 35 #include &quot;Parser.h&quot;
 36 #include &quot;Protect.h&quot;
 37 #include &quot;VMEntryScope.h&quot;
 38 
<a name="1" id="anc1"></a>








































 39 namespace JSC {
 40 
 41 class DebuggerPausedScope {
 42 public:
 43     DebuggerPausedScope(Debugger&amp; debugger)
 44         : m_debugger(debugger)
 45     {
 46         ASSERT(!m_debugger.m_currentDebuggerCallFrame);
 47     }
 48 
 49     ~DebuggerPausedScope()
 50     {
 51         if (m_debugger.m_currentDebuggerCallFrame) {
 52             m_debugger.m_currentDebuggerCallFrame-&gt;invalidate();
 53             m_debugger.m_currentDebuggerCallFrame = nullptr;
 54         }
 55     }
 56 
 57 private:
 58     Debugger&amp; m_debugger;
 59 };
 60 
 61 // This is very similar to SetForScope&lt;bool&gt;, but that cannot be used
 62 // as the m_isPaused field uses only one bit.
 63 class TemporaryPausedState {
 64 public:
 65     TemporaryPausedState(Debugger&amp; debugger)
 66         : m_debugger(debugger)
 67     {
 68         ASSERT(!m_debugger.m_isPaused);
 69         m_debugger.m_isPaused = true;
 70     }
 71 
 72     ~TemporaryPausedState()
 73     {
 74         m_debugger.m_isPaused = false;
 75     }
 76 
 77 private:
 78     Debugger&amp; m_debugger;
 79 };
 80 
 81 
 82 Debugger::ProfilingClient::~ProfilingClient()
 83 {
 84 }
 85 
 86 Debugger::Debugger(VM&amp; vm)
 87     : m_vm(vm)
 88     , m_pauseOnExceptionsState(DontPauseOnExceptions)
 89     , m_pauseAtNextOpportunity(false)
 90     , m_pastFirstExpressionInStatement(false)
 91     , m_isPaused(false)
 92     , m_breakpointsActivated(false)
 93     , m_hasHandlerForExceptionCallback(false)
 94     , m_suppressAllPauses(false)
 95     , m_steppingMode(SteppingModeDisabled)
 96     , m_reasonForPause(NotPaused)
 97     , m_lastExecutedLine(UINT_MAX)
 98     , m_lastExecutedSourceID(noSourceID)
 99     , m_topBreakpointID(noBreakpointID)
100     , m_pausingBreakpointID(noBreakpointID)
101 {
102 }
103 
104 Debugger::~Debugger()
105 {
106     HashSet&lt;JSGlobalObject*&gt;::iterator end = m_globalObjects.end();
107     for (HashSet&lt;JSGlobalObject*&gt;::iterator it = m_globalObjects.begin(); it != end; ++it)
108         (*it)-&gt;setDebugger(nullptr);
109 }
110 
111 void Debugger::attach(JSGlobalObject* globalObject)
112 {
113     ASSERT(!globalObject-&gt;debugger());
114     globalObject-&gt;setDebugger(this);
115     m_globalObjects.add(globalObject);
116 
117     m_vm.setShouldBuildPCToCodeOriginMapping();
118 
<a name="2" id="anc2"></a><span class="line-modified">119     // Call `sourceParsed` after iterating because it will execute JavaScript in Web Inspector.</span>
<span class="line-modified">120     HashSet&lt;RefPtr&lt;SourceProvider&gt;&gt; sourceProviders;</span>
121     {
122         HeapIterationScope iterationScope(m_vm.heap);
<a name="3" id="anc3"></a><span class="line-modified">123         m_vm.heap.objectSpace().forEachLiveCell(iterationScope, [&amp;] (HeapCell* heapCell, HeapCell::Kind kind) {</span>
<span class="line-added">124             if (isJSCellKind(kind)) {</span>
<span class="line-added">125                 auto* cell = static_cast&lt;JSCell*&gt;(heapCell);</span>
<span class="line-added">126                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(cell-&gt;vm(), cell)) {</span>
<span class="line-added">127                     if (function-&gt;scope()-&gt;globalObject() == globalObject &amp;&amp; function-&gt;executable()-&gt;isFunctionExecutable() &amp;&amp; !function-&gt;isHostOrBuiltinFunction())</span>
<span class="line-added">128                         sourceProviders.add(jsCast&lt;FunctionExecutable*&gt;(function-&gt;executable())-&gt;source().provider());</span>
<span class="line-added">129                 }</span>
<span class="line-added">130             }</span>
<span class="line-added">131             return IterationStatus::Continue;</span>
<span class="line-added">132         });</span>
133     }
<a name="4" id="anc4"></a><span class="line-modified">134     for (auto&amp; sourceProvider : sourceProviders)</span>
<span class="line-modified">135         sourceParsed(globalObject, sourceProvider.get(), -1, nullString());</span>
136 }
137 
138 void Debugger::detach(JSGlobalObject* globalObject, ReasonForDetach reason)
139 {
140     // If we&#39;re detaching from the currently executing global object, manually tear down our
141     // stack, since we won&#39;t get further debugger callbacks to do so. Also, resume execution,
142     // since there&#39;s no point in staying paused once a window closes.
143     // We know there is an entry scope, otherwise, m_currentCallFrame would be null.
144     VM&amp; vm = globalObject-&gt;vm();
<a name="5" id="anc5"></a><span class="line-added">145     JSLockHolder locker(vm);</span>
<span class="line-added">146 </span>
147     if (m_isPaused &amp;&amp; m_currentCallFrame &amp;&amp; vm.entryScope-&gt;globalObject() == globalObject) {
148         m_currentCallFrame = nullptr;
149         m_pauseOnCallFrame = nullptr;
150         continueProgram();
151     }
152 
153     ASSERT(m_globalObjects.contains(globalObject));
154     m_globalObjects.remove(globalObject);
155 
156     // If the globalObject is destructing, then its CodeBlocks will also be
157     // destructed. There is no need to do the debugger requests clean up, and
158     // it is not safe to access those CodeBlocks at this time anyway.
159     if (reason != GlobalObjectIsDestructing)
160         clearDebuggerRequests(globalObject);
161 
162     globalObject-&gt;setDebugger(nullptr);
163 
164     if (m_globalObjects.isEmpty())
165         clearParsedData();
166 }
167 
168 bool Debugger::isAttached(JSGlobalObject* globalObject)
169 {
170     return globalObject-&gt;debugger() == this;
171 }
172 
173 class Debugger::SetSteppingModeFunctor {
174 public:
175     SetSteppingModeFunctor(Debugger* debugger, SteppingMode mode)
176         : m_debugger(debugger)
177         , m_mode(mode)
178     {
179     }
180 
181     void operator()(CodeBlock* codeBlock) const
182     {
183         if (m_debugger == codeBlock-&gt;globalObject()-&gt;debugger()) {
184             if (m_mode == SteppingModeEnabled)
185                 codeBlock-&gt;setSteppingMode(CodeBlock::SteppingModeEnabled);
186             else
187                 codeBlock-&gt;setSteppingMode(CodeBlock::SteppingModeDisabled);
188         }
189     }
190 
191 private:
192     Debugger* m_debugger;
193     SteppingMode m_mode;
194 };
195 
196 void Debugger::setSteppingMode(SteppingMode mode)
197 {
198     if (mode == m_steppingMode)
199         return;
200 
201     m_vm.heap.completeAllJITPlans();
202 
203     m_steppingMode = mode;
204     SetSteppingModeFunctor functor(this, mode);
205     m_vm.heap.forEachCodeBlock(functor);
206 }
207 
208 void Debugger::registerCodeBlock(CodeBlock* codeBlock)
209 {
210     applyBreakpoints(codeBlock);
211     if (isStepping())
212         codeBlock-&gt;setSteppingMode(CodeBlock::SteppingModeEnabled);
213 }
214 
215 void Debugger::setProfilingClient(ProfilingClient* client)
216 {
217     ASSERT(!!m_profilingClient != !!client);
218     m_profilingClient = client;
219 }
220 
221 Seconds Debugger::willEvaluateScript()
222 {
223     return m_profilingClient-&gt;willEvaluateScript();
224 }
225 
226 void Debugger::didEvaluateScript(Seconds startTime, ProfilingReason reason)
227 {
228     m_profilingClient-&gt;didEvaluateScript(startTime, reason);
229 }
230 
231 void Debugger::toggleBreakpoint(CodeBlock* codeBlock, Breakpoint&amp; breakpoint, BreakpointState enabledOrNot)
232 {
233     ASSERT(breakpoint.resolved);
234 
235     ScriptExecutable* executable = codeBlock-&gt;ownerExecutable();
236 
237     SourceID sourceID = static_cast&lt;SourceID&gt;(executable-&gt;sourceID());
238     if (breakpoint.sourceID != sourceID)
239         return;
240 
<a name="6" id="anc6"></a>


241     unsigned startLine = executable-&gt;firstLine();
242     unsigned startColumn = executable-&gt;startColumn();
243     unsigned endLine = executable-&gt;lastLine();
244     unsigned endColumn = executable-&gt;endColumn();
245 
246     // Inspector breakpoint line and column values are zero-based but the executable
247     // and CodeBlock line and column values are one-based.
<a name="7" id="anc7"></a><span class="line-modified">248     unsigned line = breakpoint.line + 1;</span>
<span class="line-modified">249     Optional&lt;unsigned&gt; column;</span>
<span class="line-added">250     if (breakpoint.column)</span>
<span class="line-added">251         column = breakpoint.column + 1;</span>
252 
253     if (line &lt; startLine || line &gt; endLine)
254         return;
<a name="8" id="anc8"></a><span class="line-modified">255     if (column) {</span>
256         if (line == startLine &amp;&amp; column &lt; startColumn)
257             return;
258         if (line == endLine &amp;&amp; column &gt; endColumn)
259             return;
260     }
261 
262     if (!codeBlock-&gt;hasOpDebugForLineAndColumn(line, column))
263         return;
264 
265     if (enabledOrNot == BreakpointEnabled)
266         codeBlock-&gt;addBreakpoint(1);
267     else
268         codeBlock-&gt;removeBreakpoint(1);
269 }
270 
271 void Debugger::applyBreakpoints(CodeBlock* codeBlock)
272 {
273     BreakpointIDToBreakpointMap&amp; breakpoints = m_breakpointIDToBreakpoint;
274     for (auto* breakpoint : breakpoints.values())
275         toggleBreakpoint(codeBlock, *breakpoint, BreakpointEnabled);
276 }
277 
278 class Debugger::ToggleBreakpointFunctor {
279 public:
280     ToggleBreakpointFunctor(Debugger* debugger, Breakpoint&amp; breakpoint, BreakpointState enabledOrNot)
281         : m_debugger(debugger)
282         , m_breakpoint(breakpoint)
283         , m_enabledOrNot(enabledOrNot)
284     {
285     }
286 
287     void operator()(CodeBlock* codeBlock) const
288     {
289         if (m_debugger == codeBlock-&gt;globalObject()-&gt;debugger())
290             m_debugger-&gt;toggleBreakpoint(codeBlock, m_breakpoint, m_enabledOrNot);
291     }
292 
293 private:
294     Debugger* m_debugger;
295     Breakpoint&amp; m_breakpoint;
296     BreakpointState m_enabledOrNot;
297 };
298 
299 void Debugger::toggleBreakpoint(Breakpoint&amp; breakpoint, Debugger::BreakpointState enabledOrNot)
300 {
301     m_vm.heap.completeAllJITPlans();
302 
303     ToggleBreakpointFunctor functor(this, breakpoint, enabledOrNot);
304     m_vm.heap.forEachCodeBlock(functor);
305 }
306 
307 void Debugger::recompileAllJSFunctions()
308 {
309     m_vm.deleteAllCode(PreventCollectionAndDeleteAllCode);
310 }
311 
312 DebuggerParseData&amp; Debugger::debuggerParseData(SourceID sourceID, SourceProvider* provider)
313 {
314     auto iter = m_parseDataMap.find(sourceID);
315     if (iter != m_parseDataMap.end())
316         return iter-&gt;value;
317 
318     DebuggerParseData parseData;
319     gatherDebuggerParseDataForSource(m_vm, provider, parseData);
320     auto result = m_parseDataMap.add(sourceID, parseData);
321     return result.iterator-&gt;value;
322 }
323 
324 void Debugger::resolveBreakpoint(Breakpoint&amp; breakpoint, SourceProvider* sourceProvider)
325 {
326     RELEASE_ASSERT(!breakpoint.resolved);
327     ASSERT(breakpoint.sourceID != noSourceID);
328 
329     // FIXME: &lt;https://webkit.org/b/162771&gt; Web Inspector: Adopt TextPosition in Inspector to avoid oneBasedInt/zeroBasedInt ambiguity
330     // Inspector breakpoint line and column values are zero-based but the executable
<a name="9" id="anc9"></a><span class="line-modified">331     // and CodeBlock line values are one-based while column is zero-based.</span>
<span class="line-modified">332     int line = breakpoint.line + 1;</span>
<span class="line-modified">333     int column = breakpoint.column;</span>
<span class="line-added">334 </span>
<span class="line-added">335     // Account for a &lt;script&gt;&#39;s start position on the first line only.</span>
<span class="line-added">336     int providerStartLine = sourceProvider-&gt;startPosition().m_line.oneBasedInt(); // One based to match the already adjusted line.</span>
<span class="line-added">337     int providerStartColumn = sourceProvider-&gt;startPosition().m_column.zeroBasedInt(); // Zero based so column zero is zero.</span>
<span class="line-added">338     if (line == providerStartLine &amp;&amp; breakpoint.column) {</span>
<span class="line-added">339         ASSERT(providerStartColumn &lt;= column);</span>
<span class="line-added">340         if (providerStartColumn)</span>
<span class="line-added">341             column -= providerStartColumn;</span>
<span class="line-added">342     }</span>
343 
344     DebuggerParseData&amp; parseData = debuggerParseData(breakpoint.sourceID, sourceProvider);
<a name="10" id="anc10"></a><span class="line-modified">345     Optional&lt;JSTextPosition&gt; resolvedPosition = parseData.pausePositions.breakpointLocationForLineColumn(line, column);</span>
346     if (!resolvedPosition)
347         return;
348 
<a name="11" id="anc11"></a><span class="line-modified">349     int resolvedLine = resolvedPosition-&gt;line;</span>
<span class="line-modified">350     int resolvedColumn = resolvedPosition-&gt;column();</span>
<span class="line-added">351 </span>
<span class="line-added">352     // Re-account for a &lt;script&gt;&#39;s start position on the first line only.</span>
<span class="line-added">353     if (resolvedLine == providerStartLine &amp;&amp; breakpoint.column) {</span>
<span class="line-added">354         if (providerStartColumn)</span>
<span class="line-added">355             resolvedColumn += providerStartColumn;</span>
<span class="line-added">356     }</span>
357 
358     breakpoint.line = resolvedLine - 1;
<a name="12" id="anc12"></a><span class="line-modified">359     breakpoint.column = resolvedColumn;</span>
360     breakpoint.resolved = true;
361 }
362 
363 BreakpointID Debugger::setBreakpoint(Breakpoint&amp; breakpoint, bool&amp; existing)
364 {
365     ASSERT(breakpoint.resolved);
366     ASSERT(breakpoint.sourceID != noSourceID);
367 
368     SourceID sourceID = breakpoint.sourceID;
369     unsigned line = breakpoint.line;
370     unsigned column = breakpoint.column;
371 
372     SourceIDToBreakpointsMap::iterator it = m_sourceIDToBreakpoints.find(breakpoint.sourceID);
373     if (it == m_sourceIDToBreakpoints.end())
374         it = m_sourceIDToBreakpoints.set(sourceID, LineToBreakpointsMap()).iterator;
375 
376     LineToBreakpointsMap::iterator breaksIt = it-&gt;value.find(line);
377     if (breaksIt == it-&gt;value.end())
378         breaksIt = it-&gt;value.set(line, adoptRef(new BreakpointsList)).iterator;
379 
380     BreakpointsList&amp; breakpoints = *breaksIt-&gt;value;
381     for (Breakpoint* current = breakpoints.head(); current; current = current-&gt;next()) {
382         if (current-&gt;column == column) {
383             // Found existing breakpoint. Do not create a duplicate at this location.
384             existing = true;
385             return current-&gt;id;
386         }
387     }
388 
389     existing = false;
390     BreakpointID id = ++m_topBreakpointID;
391     RELEASE_ASSERT(id != noBreakpointID);
392 
393     breakpoint.id = id;
394 
395     Breakpoint* newBreakpoint = new Breakpoint(breakpoint);
396     breakpoints.append(newBreakpoint);
397     m_breakpointIDToBreakpoint.set(id, newBreakpoint);
398 
399     toggleBreakpoint(*newBreakpoint, BreakpointEnabled);
400 
401     return id;
402 }
403 
404 void Debugger::removeBreakpoint(BreakpointID id)
405 {
406     ASSERT(id != noBreakpointID);
407 
408     BreakpointIDToBreakpointMap::iterator idIt = m_breakpointIDToBreakpoint.find(id);
409     ASSERT(idIt != m_breakpointIDToBreakpoint.end());
410     Breakpoint* breakpoint = idIt-&gt;value;
411 
412     SourceID sourceID = breakpoint-&gt;sourceID;
413     ASSERT(sourceID);
414     SourceIDToBreakpointsMap::iterator it = m_sourceIDToBreakpoints.find(sourceID);
415     ASSERT(it != m_sourceIDToBreakpoints.end());
416     LineToBreakpointsMap::iterator breaksIt = it-&gt;value.find(breakpoint-&gt;line);
417     ASSERT(breaksIt != it-&gt;value.end());
418 
419     toggleBreakpoint(*breakpoint, BreakpointDisabled);
420 
421     BreakpointsList&amp; breakpoints = *breaksIt-&gt;value;
<a name="13" id="anc13"></a><span class="line-modified">422 #if ASSERT_ENABLED</span>
423     bool found = false;
424     for (Breakpoint* current = breakpoints.head(); current &amp;&amp; !found; current = current-&gt;next()) {
425         if (current-&gt;id == breakpoint-&gt;id)
426             found = true;
427     }
428     ASSERT(found);
<a name="14" id="anc14"></a><span class="line-modified">429 #endif // ASSERT_ENABLED</span>
430 
431     m_breakpointIDToBreakpoint.remove(idIt);
432     breakpoints.remove(breakpoint);
433     delete breakpoint;
434 
435     if (breakpoints.isEmpty()) {
436         it-&gt;value.remove(breaksIt);
437         if (it-&gt;value.isEmpty())
438             m_sourceIDToBreakpoints.remove(it);
439     }
440 }
441 
442 bool Debugger::hasBreakpoint(SourceID sourceID, const TextPosition&amp; position, Breakpoint *hitBreakpoint)
443 {
444     if (!m_breakpointsActivated)
445         return false;
446 
447     SourceIDToBreakpointsMap::const_iterator it = m_sourceIDToBreakpoints.find(sourceID);
448     if (it == m_sourceIDToBreakpoints.end())
449         return false;
450 
451     unsigned line = position.m_line.zeroBasedInt();
452     unsigned column = position.m_column.zeroBasedInt();
453 
454     LineToBreakpointsMap::const_iterator breaksIt = it-&gt;value.find(line);
455     if (breaksIt == it-&gt;value.end())
456         return false;
457 
458     bool hit = false;
459     const BreakpointsList&amp; breakpoints = *breaksIt-&gt;value;
460     Breakpoint* breakpoint;
461     for (breakpoint = breakpoints.head(); breakpoint; breakpoint = breakpoint-&gt;next()) {
462         unsigned breakLine = breakpoint-&gt;line;
463         unsigned breakColumn = breakpoint-&gt;column;
464         // Since frontend truncates the indent, the first statement in a line must match the breakpoint (line,0).
465         ASSERT(this == m_currentCallFrame-&gt;codeBlock()-&gt;globalObject()-&gt;debugger());
466         if ((line != m_lastExecutedLine &amp;&amp; line == breakLine &amp;&amp; !breakColumn)
467             || (line == breakLine &amp;&amp; column == breakColumn)) {
468             hit = true;
469             break;
470         }
471     }
472     if (!hit)
473         return false;
474 
475     if (hitBreakpoint)
476         *hitBreakpoint = *breakpoint;
477 
478     breakpoint-&gt;hitCount++;
479     if (breakpoint-&gt;ignoreCount &gt;= breakpoint-&gt;hitCount)
480         return false;
481 
482     if (breakpoint-&gt;condition.isEmpty())
483         return true;
484 
485     // We cannot stop in the debugger while executing condition code,
486     // so make it looks like the debugger is already paused.
487     TemporaryPausedState pausedState(*this);
488 
489     NakedPtr&lt;Exception&gt; exception;
490     DebuggerCallFrame&amp; debuggerCallFrame = currentDebuggerCallFrame();
491     JSObject* scopeExtensionObject = nullptr;
492     JSValue result = debuggerCallFrame.evaluateWithScopeExtension(breakpoint-&gt;condition, scopeExtensionObject, exception);
493 
494     // We can lose the debugger while executing JavaScript.
495     if (!m_currentCallFrame)
496         return false;
497 
<a name="15" id="anc15"></a><span class="line-added">498     JSGlobalObject* globalObject = m_currentCallFrame-&gt;lexicalGlobalObject(m_vm);</span>
499     if (exception) {
500         // An erroneous condition counts as &quot;false&quot;.
<a name="16" id="anc16"></a><span class="line-modified">501         handleExceptionInBreakpointCondition(globalObject, exception);</span>
502         return false;
503     }
504 
<a name="17" id="anc17"></a><span class="line-modified">505     return result.toBoolean(globalObject);</span>
506 }
507 
508 class Debugger::ClearCodeBlockDebuggerRequestsFunctor {
509 public:
510     ClearCodeBlockDebuggerRequestsFunctor(Debugger* debugger)
511         : m_debugger(debugger)
512     {
513     }
514 
515     void operator()(CodeBlock* codeBlock) const
516     {
517         if (codeBlock-&gt;hasDebuggerRequests() &amp;&amp; m_debugger == codeBlock-&gt;globalObject()-&gt;debugger())
518             codeBlock-&gt;clearDebuggerRequests();
519     }
520 
521 private:
522     Debugger* m_debugger;
523 };
524 
525 void Debugger::clearBreakpoints()
526 {
527     m_vm.heap.completeAllJITPlans();
528 
529     m_topBreakpointID = noBreakpointID;
530     m_breakpointIDToBreakpoint.clear();
531     m_sourceIDToBreakpoints.clear();
532 
533     ClearCodeBlockDebuggerRequestsFunctor functor(this);
534     m_vm.heap.forEachCodeBlock(functor);
535 }
536 
537 class Debugger::ClearDebuggerRequestsFunctor {
538 public:
539     ClearDebuggerRequestsFunctor(JSGlobalObject* globalObject)
540         : m_globalObject(globalObject)
541     {
542     }
543 
544     void operator()(CodeBlock* codeBlock) const
545     {
546         if (codeBlock-&gt;hasDebuggerRequests() &amp;&amp; m_globalObject == codeBlock-&gt;globalObject())
547             codeBlock-&gt;clearDebuggerRequests();
548     }
549 
550 private:
551     JSGlobalObject* m_globalObject;
552 };
553 
554 void Debugger::clearDebuggerRequests(JSGlobalObject* globalObject)
555 {
556     m_vm.heap.completeAllJITPlans();
557 
558     ClearDebuggerRequestsFunctor functor(globalObject);
559     m_vm.heap.forEachCodeBlock(functor);
560 }
561 
562 void Debugger::clearParsedData()
563 {
564     m_parseDataMap.clear();
565 }
566 
567 void Debugger::setBreakpointsActivated(bool activated)
568 {
569     if (activated == m_breakpointsActivated)
570         return;
571 
572     m_breakpointsActivated = activated;
573     recompileAllJSFunctions();
574 }
575 
576 void Debugger::setPauseOnExceptionsState(PauseOnExceptionsState pause)
577 {
578     m_pauseOnExceptionsState = pause;
579 }
580 
581 void Debugger::setPauseOnNextStatement(bool pause)
582 {
583     m_pauseAtNextOpportunity = pause;
584     if (pause)
585         setSteppingMode(SteppingModeEnabled);
586 }
587 
588 void Debugger::breakProgram()
589 {
590     if (m_isPaused)
591         return;
592 
593     if (!m_vm.topCallFrame)
594         return;
595 
596     m_pauseAtNextOpportunity = true;
597     setSteppingMode(SteppingModeEnabled);
598     m_currentCallFrame = m_vm.topCallFrame;
<a name="18" id="anc18"></a><span class="line-modified">599     pauseIfNeeded(m_currentCallFrame-&gt;lexicalGlobalObject(m_vm));</span>
600 }
601 
602 void Debugger::continueProgram()
603 {
604     clearNextPauseState();
605 
606     if (!m_isPaused)
607         return;
608 
609     notifyDoneProcessingDebuggerEvents();
610 }
611 
612 void Debugger::stepIntoStatement()
613 {
614     if (!m_isPaused)
615         return;
616 
617     m_pauseAtNextOpportunity = true;
618     setSteppingMode(SteppingModeEnabled);
619     notifyDoneProcessingDebuggerEvents();
620 }
621 
622 void Debugger::stepOverStatement()
623 {
624     if (!m_isPaused)
625         return;
626 
627     m_pauseOnCallFrame = m_currentCallFrame;
628     setSteppingMode(SteppingModeEnabled);
629     notifyDoneProcessingDebuggerEvents();
630 }
631 
632 void Debugger::stepOutOfFunction()
633 {
634     if (!m_isPaused)
635         return;
636 
637     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
638     m_pauseOnCallFrame = m_currentCallFrame ? m_currentCallFrame-&gt;callerFrame(topEntryFrame) : nullptr;
639     m_pauseOnStepOut = true;
640     setSteppingMode(SteppingModeEnabled);
641     notifyDoneProcessingDebuggerEvents();
642 }
643 
<a name="19" id="anc19"></a><span class="line-modified">644 static inline JSGlobalObject* lexicalGlobalObjectForCallFrame(VM&amp; vm, CallFrame* callFrame)</span>
<span class="line-added">645 {</span>
<span class="line-added">646     if (!callFrame)</span>
<span class="line-added">647         return nullptr;</span>
<span class="line-added">648     return callFrame-&gt;lexicalGlobalObject(vm);</span>
<span class="line-added">649 }</span>
<span class="line-added">650 </span>
<span class="line-added">651 void Debugger::updateCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrameUpdateAction action)</span>
652 {
653     if (!callFrame) {
654         m_currentCallFrame = nullptr;
655         return;
656     }
<a name="20" id="anc20"></a>
657     updateCallFrameInternal(callFrame);
658 
659     if (action == AttemptPause)
<a name="21" id="anc21"></a><span class="line-modified">660         pauseIfNeeded(globalObject);</span>
661 
662     if (!isStepping())
663         m_currentCallFrame = nullptr;
664 }
665 
666 void Debugger::updateCallFrameInternal(CallFrame* callFrame)
667 {
668     m_currentCallFrame = callFrame;
669     SourceID sourceID = DebuggerCallFrame::sourceIDForCallFrame(callFrame);
670     if (m_lastExecutedSourceID != sourceID) {
671         m_lastExecutedLine = UINT_MAX;
672         m_lastExecutedSourceID = sourceID;
673     }
674 }
675 
<a name="22" id="anc22"></a><span class="line-modified">676 void Debugger::pauseIfNeeded(JSGlobalObject* globalObject)</span>
677 {
678     VM&amp; vm = m_vm;
679     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="23" id="anc23"></a>
680 
681     if (m_isPaused)
682         return;
683 
684     if (m_suppressAllPauses)
685         return;
686 
687     intptr_t sourceID = DebuggerCallFrame::sourceIDForCallFrame(m_currentCallFrame);
<a name="24" id="anc24"></a><span class="line-modified">688 </span>
<span class="line-added">689     auto blackboxTypeIterator = m_blackboxedScripts.find(sourceID);</span>
<span class="line-added">690     if (blackboxTypeIterator != m_blackboxedScripts.end() &amp;&amp; blackboxTypeIterator-&gt;value == BlackboxType::Ignored)</span>
691         return;
692 
693     DebuggerPausedScope debuggerPausedScope(*this);
694 
695     bool pauseNow = m_pauseAtNextOpportunity;
696     pauseNow |= (m_pauseOnCallFrame == m_currentCallFrame);
697 
698     bool didPauseForStep = pauseNow;
699 
700     Breakpoint breakpoint;
701     TextPosition position = DebuggerCallFrame::positionForCallFrame(vm, m_currentCallFrame);
702     bool didHitBreakpoint = hasBreakpoint(sourceID, position, &amp;breakpoint);
703     pauseNow |= didHitBreakpoint;
704     m_lastExecutedLine = position.m_line.zeroBasedInt();
705     if (!pauseNow)
706         return;
707 
<a name="25" id="anc25"></a><span class="line-added">708     bool afterBlackboxedScript = m_afterBlackboxedScript;</span>
709     clearNextPauseState();
710 
711     // Make sure we are not going to pause again on breakpoint actions by
712     // reseting the pause state before executing any breakpoint actions.
713     TemporaryPausedState pausedState(*this);
714 
<a name="26" id="anc26"></a>

715     if (didHitBreakpoint) {
<a name="27" id="anc27"></a><span class="line-modified">716         handleBreakpointHit(globalObject, breakpoint);</span>
717         // Note that the actions can potentially stop the debugger, so we need to check that
718         // we still have a current call frame when we get back.
719         if (!m_currentCallFrame)
720             return;
721 
722         if (breakpoint.autoContinue) {
723             if (!didPauseForStep)
724                 return;
725             didHitBreakpoint = false;
726         } else
727             m_pausingBreakpointID = breakpoint.id;
728     }
729 
<a name="28" id="anc28"></a><span class="line-added">730     if (blackboxTypeIterator != m_blackboxedScripts.end() &amp;&amp; blackboxTypeIterator-&gt;value == BlackboxType::Deferred) {</span>
<span class="line-added">731         m_afterBlackboxedScript = true;</span>
<span class="line-added">732         setPauseOnNextStatement(true);</span>
<span class="line-added">733         return;</span>
<span class="line-added">734     }</span>
<span class="line-added">735 </span>
736     {
<a name="29" id="anc29"></a><span class="line-modified">737         auto reason = m_reasonForPause;</span>
<span class="line-modified">738         if (afterBlackboxedScript)</span>
<span class="line-added">739             reason = PausedAfterBlackboxedScript;</span>
<span class="line-added">740         else if (didHitBreakpoint)</span>
<span class="line-added">741             reason = PausedForBreakpoint;</span>
<span class="line-added">742         PauseReasonDeclaration rauseReasonDeclaration(*this, reason);</span>
<span class="line-added">743 </span>
<span class="line-added">744         handlePause(globalObject, m_reasonForPause);</span>
745         scope.releaseAssertNoException();
746     }
747 
748     m_pausingBreakpointID = noBreakpointID;
749 
750     if (!m_pauseAtNextOpportunity &amp;&amp; !m_pauseOnCallFrame) {
751         setSteppingMode(SteppingModeDisabled);
752         m_currentCallFrame = nullptr;
753     }
754 }
755 
<a name="30" id="anc30"></a><span class="line-modified">756 void Debugger::exception(JSGlobalObject* globalObject, CallFrame* callFrame, JSValue exception, bool hasCatchHandler)</span>
757 {
758     if (m_isPaused)
759         return;
760 
761     if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(m_vm, exception)) {
762         if (object-&gt;isErrorInstance()) {
763             ErrorInstance* error = static_cast&lt;ErrorInstance*&gt;(object);
764             // FIXME: &lt;https://webkit.org/b/173625&gt; Web Inspector: Should be able to pause and debug a StackOverflow Exception
765             // FIXME: &lt;https://webkit.org/b/173627&gt; Web Inspector: Should be able to pause and debug an OutOfMemory Exception
766             if (error-&gt;isStackOverflowError() || error-&gt;isOutOfMemoryError())
767                 return;
768         }
769     }
770 
771     PauseReasonDeclaration reason(*this, PausedForException);
772     if (m_pauseOnExceptionsState == PauseOnAllExceptions || (m_pauseOnExceptionsState == PauseOnUncaughtExceptions &amp;&amp; !hasCatchHandler)) {
773         m_pauseAtNextOpportunity = true;
774         setSteppingMode(SteppingModeEnabled);
775     }
776 
777     m_hasHandlerForExceptionCallback = true;
778     m_currentException = exception;
<a name="31" id="anc31"></a><span class="line-modified">779     updateCallFrame(globalObject, callFrame, AttemptPause);</span>
780     m_currentException = JSValue();
781     m_hasHandlerForExceptionCallback = false;
782 }
783 
784 void Debugger::atStatement(CallFrame* callFrame)
785 {
786     if (m_isPaused)
787         return;
788 
789     m_pastFirstExpressionInStatement = false;
790 
791     PauseReasonDeclaration reason(*this, PausedAtStatement);
<a name="32" id="anc32"></a><span class="line-modified">792     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
793 }
794 
795 void Debugger::atExpression(CallFrame* callFrame)
796 {
797     if (m_isPaused)
798         return;
799 
800     // If this is the first call in a statement, then we would have paused at the statement.
801     if (!m_pastFirstExpressionInStatement) {
802         m_pastFirstExpressionInStatement = true;
803         return;
804     }
805 
806     // Only pause at the next expression with step-in and step-out, not step-over.
807     bool shouldAttemptPause = m_pauseAtNextOpportunity || m_pauseOnStepOut;
808 
809     PauseReasonDeclaration reason(*this, PausedAtExpression);
<a name="33" id="anc33"></a><span class="line-modified">810     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, shouldAttemptPause ? AttemptPause : NoPause);</span>
811 }
812 
813 void Debugger::callEvent(CallFrame* callFrame)
814 {
815     if (m_isPaused)
816         return;
817 
<a name="34" id="anc34"></a><span class="line-modified">818     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
819 }
820 
821 void Debugger::returnEvent(CallFrame* callFrame)
822 {
823     if (m_isPaused)
824         return;
825 
826     {
827         PauseReasonDeclaration reason(*this, PausedBeforeReturn);
<a name="35" id="anc35"></a><span class="line-modified">828         updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
829     }
830 
831     // Detach may have been called during pauseIfNeeded.
832     if (!m_currentCallFrame)
833         return;
834 
835     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
836     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
837 
838     // Returning from a call, there was at least one expression on the statement we are returning to.
839     m_pastFirstExpressionInStatement = true;
840 
841     // Treat stepping over a return statement like a step-out.
842     if (m_currentCallFrame == m_pauseOnCallFrame) {
843         m_pauseOnCallFrame = callerFrame;
844         m_pauseOnStepOut = true;
845     }
846 
<a name="36" id="anc36"></a><span class="line-modified">847     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
848 }
849 
850 void Debugger::unwindEvent(CallFrame* callFrame)
851 {
852     if (m_isPaused)
853         return;
854 
<a name="37" id="anc37"></a><span class="line-modified">855     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
856 
857     if (!m_currentCallFrame)
858         return;
859 
860     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
861     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
862 
863     // Treat stepping over an exception location like a step-out.
864     if (m_currentCallFrame == m_pauseOnCallFrame)
865         m_pauseOnCallFrame = callerFrame;
866 
<a name="38" id="anc38"></a><span class="line-modified">867     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
868 }
869 
870 void Debugger::willExecuteProgram(CallFrame* callFrame)
871 {
872     if (m_isPaused)
873         return;
874 
<a name="39" id="anc39"></a><span class="line-modified">875     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, NoPause);</span>
876 }
877 
878 void Debugger::didExecuteProgram(CallFrame* callFrame)
879 {
880     if (m_isPaused)
881         return;
882 
883     PauseReasonDeclaration reason(*this, PausedAtEndOfProgram);
<a name="40" id="anc40"></a><span class="line-modified">884     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
885 
886     // Detach may have been called during pauseIfNeeded.
887     if (!m_currentCallFrame)
888         return;
889 
890     EntryFrame* topEntryFrame = m_vm.topEntryFrame;
891     CallFrame* callerFrame = m_currentCallFrame-&gt;callerFrame(topEntryFrame);
892 
893     // Returning from a program, could be eval(), there was at least one expression on the statement we are returning to.
894     m_pastFirstExpressionInStatement = true;
895 
896     // Treat stepping over the end of a program like a step-out.
897     if (m_currentCallFrame == m_pauseOnCallFrame) {
898         m_pauseOnCallFrame = callerFrame;
899         m_pauseAtNextOpportunity = true;
900     }
901 
<a name="41" id="anc41"></a><span class="line-modified">902     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callerFrame), callerFrame, NoPause);</span>
903 
904     // Do not continue stepping into an unknown future program.
905     if (!m_currentCallFrame)
906         clearNextPauseState();
907 }
908 
909 void Debugger::clearNextPauseState()
910 {
911     m_pauseOnCallFrame = nullptr;
912     m_pauseAtNextOpportunity = false;
913     m_pauseOnStepOut = false;
<a name="42" id="anc42"></a><span class="line-added">914     m_afterBlackboxedScript = false;</span>
915 }
916 
<a name="43" id="anc43"></a><span class="line-modified">917 void Debugger::didReachDebuggerStatement(CallFrame* callFrame)</span>
918 {
919     if (m_isPaused)
920         return;
921 
<a name="44" id="anc44"></a><span class="line-added">922     if (!m_pauseOnDebuggerStatements)</span>
<span class="line-added">923         return;</span>
<span class="line-added">924 </span>
925     PauseReasonDeclaration reason(*this, PausedForDebuggerStatement);
926     m_pauseAtNextOpportunity = true;
927     setSteppingMode(SteppingModeEnabled);
<a name="45" id="anc45"></a><span class="line-modified">928     updateCallFrame(lexicalGlobalObjectForCallFrame(m_vm, callFrame), callFrame, AttemptPause);</span>
929 }
930 
931 DebuggerCallFrame&amp; Debugger::currentDebuggerCallFrame()
932 {
933     if (!m_currentDebuggerCallFrame)
934         m_currentDebuggerCallFrame = DebuggerCallFrame::create(m_vm, m_currentCallFrame);
935     return *m_currentDebuggerCallFrame;
936 }
937 
<a name="46" id="anc46"></a><span class="line-modified">938 void Debugger::setBlackboxType(SourceID sourceID, Optional&lt;BlackboxType&gt; type)</span>





939 {
<a name="47" id="anc47"></a><span class="line-modified">940     if (type)</span>
<span class="line-added">941         m_blackboxedScripts.set(sourceID, type.value());</span>
<span class="line-added">942     else</span>
<span class="line-added">943         m_blackboxedScripts.remove(sourceID);</span>
944 }
945 
<a name="48" id="anc48"></a><span class="line-modified">946 void Debugger::clearBlackbox()</span>
947 {
<a name="49" id="anc49"></a><span class="line-modified">948     m_blackboxedScripts.clear();</span>
949 }
950 
951 } // namespace JSC
<a name="50" id="anc50"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="50" type="hidden" />
</body>
</html>
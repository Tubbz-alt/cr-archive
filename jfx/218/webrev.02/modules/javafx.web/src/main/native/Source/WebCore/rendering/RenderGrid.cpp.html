<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011 Apple Inc. All rights reserved.
   3  * Copyright (C) 2013-2017 Igalia S.L.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;RenderGrid.h&quot;
  29 
  30 #include &quot;GridArea.h&quot;
  31 #include &quot;GridLayoutFunctions.h&quot;
  32 #include &quot;GridPositionsResolver.h&quot;
  33 #include &quot;GridTrackSizingAlgorithm.h&quot;
  34 #include &quot;LayoutRepainter.h&quot;
  35 #include &quot;RenderChildIterator.h&quot;
  36 #include &quot;RenderLayer.h&quot;
  37 #include &quot;RenderLayoutState.h&quot;
  38 #include &quot;RenderTreeBuilder.h&quot;
  39 #include &quot;RenderView.h&quot;
  40 #include &lt;cstdlib&gt;
  41 #include &lt;wtf/IsoMallocInlines.h&gt;
  42 
  43 namespace WebCore {
  44 
  45 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderGrid);
  46 
  47 enum TrackSizeRestriction {
  48     AllowInfinity,
  49     ForbidInfinity,
  50 };
  51 
  52 RenderGrid::RenderGrid(Element&amp; element, RenderStyle&amp;&amp; style)
  53     : RenderBlock(element, WTFMove(style), 0)
  54     , m_grid(*this)
  55     , m_trackSizingAlgorithm(this, m_grid)
  56 {
  57     // All of our children must be block level.
  58     setChildrenInline(false);
  59 }
  60 
  61 RenderGrid::~RenderGrid() = default;
  62 
  63 StyleSelfAlignmentData RenderGrid::selfAlignmentForChild(GridAxis axis, const RenderBox&amp; child, const RenderStyle* gridStyle) const
  64 {
  65     return axis == GridRowAxis ? justifySelfForChild(child, gridStyle) : alignSelfForChild(child, gridStyle);
  66 }
  67 
  68 bool RenderGrid::selfAlignmentChangedToStretch(GridAxis axis, const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle, const RenderBox&amp; child) const
  69 {
  70     return selfAlignmentForChild(axis, child, &amp;oldStyle).position() != ItemPosition::Stretch
  71         &amp;&amp; selfAlignmentForChild(axis, child, &amp;newStyle).position() == ItemPosition::Stretch;
  72 }
  73 
  74 bool RenderGrid::selfAlignmentChangedFromStretch(GridAxis axis, const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle, const RenderBox&amp; child) const
  75 {
  76     return selfAlignmentForChild(axis, child, &amp;oldStyle).position() == ItemPosition::Stretch
  77         &amp;&amp; selfAlignmentForChild(axis, child, &amp;newStyle).position() != ItemPosition::Stretch;
  78 }
  79 
  80 void RenderGrid::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
  81 {
  82     RenderBlock::styleDidChange(diff, oldStyle);
  83     if (!oldStyle || diff != StyleDifference::Layout)
  84         return;
  85 
  86     const RenderStyle&amp; newStyle = this-&gt;style();
  87     if (oldStyle-&gt;resolvedAlignItems(selfAlignmentNormalBehavior(this)).position() == ItemPosition::Stretch) {
  88         // Style changes on the grid container implying stretching (to-stretch) or
  89         // shrinking (from-stretch) require the affected items to be laid out again.
  90         // These logic only applies to &#39;stretch&#39; since the rest of the alignment
  91         // values don&#39;t change the size of the box.
  92         // In any case, the items&#39; overrideSize will be cleared and recomputed (if
  93         // necessary)  as part of the Grid layout logic, triggered by this style
  94         // change.
  95         for (auto&amp; child : childrenOfType&lt;RenderBox&gt;(*this)) {
  96             if (child.isOutOfFlowPositioned())
  97                 continue;
  98             if (selfAlignmentChangedToStretch(GridRowAxis, *oldStyle, newStyle, child)
  99                 || selfAlignmentChangedFromStretch(GridRowAxis, *oldStyle, newStyle, child)
 100                 || selfAlignmentChangedToStretch(GridColumnAxis, *oldStyle, newStyle, child)
 101                 || selfAlignmentChangedFromStretch(GridColumnAxis, *oldStyle, newStyle, child)) {
 102                 child.setNeedsLayout();
 103             }
 104         }
 105     }
 106 
 107     if (explicitGridDidResize(*oldStyle) || namedGridLinesDefinitionDidChange(*oldStyle) || oldStyle-&gt;gridAutoFlow() != style().gridAutoFlow()
 108         || (style().gridAutoRepeatColumns().size() || style().gridAutoRepeatRows().size()))
 109         dirtyGrid();
 110 }
 111 
 112 bool RenderGrid::explicitGridDidResize(const RenderStyle&amp; oldStyle) const
 113 {
 114     return oldStyle.gridColumns().size() != style().gridColumns().size()
 115         || oldStyle.gridRows().size() != style().gridRows().size()
 116         || oldStyle.namedGridAreaColumnCount() != style().namedGridAreaColumnCount()
 117         || oldStyle.namedGridAreaRowCount() != style().namedGridAreaRowCount()
 118         || oldStyle.gridAutoRepeatColumns().size() != style().gridAutoRepeatColumns().size()
 119         || oldStyle.gridAutoRepeatRows().size() != style().gridAutoRepeatRows().size();
 120 }
 121 
 122 bool RenderGrid::namedGridLinesDefinitionDidChange(const RenderStyle&amp; oldStyle) const
 123 {
 124     return oldStyle.namedGridRowLines() != style().namedGridRowLines()
 125         || oldStyle.namedGridColumnLines() != style().namedGridColumnLines();
 126 }
 127 
 128 // This method optimizes the gutters computation by skiping the available size
 129 // call if gaps are fixed size (it&#39;s only needed for percentages).
 130 Optional&lt;LayoutUnit&gt; RenderGrid::availableSpaceForGutters(GridTrackSizingDirection direction) const
 131 {
 132     bool isRowAxis = direction == ForColumns;
 133     const GapLength&amp; gapLength = isRowAxis ? style().columnGap() : style().rowGap();
 134     if (gapLength.isNormal() || !gapLength.length().isPercentOrCalculated())
 135         return WTF::nullopt;
 136 
 137     return isRowAxis ? availableLogicalWidth() : contentLogicalHeight();
 138 }
 139 
 140 void RenderGrid::computeTrackSizesForDefiniteSize(GridTrackSizingDirection direction, LayoutUnit availableSpace)
 141 {
 142     LayoutUnit totalGuttersSize = guttersSize(m_grid, direction, 0, m_grid.numTracks(direction), availableSpace);
 143     LayoutUnit freeSpace = availableSpace - totalGuttersSize;
 144 
 145     m_trackSizingAlgorithm.setup(direction, numTracks(direction, m_grid), TrackSizing, availableSpace, freeSpace);
 146     m_trackSizingAlgorithm.run();
 147 
 148     ASSERT(m_trackSizingAlgorithm.tracksAreWiderThanMinTrackBreadth());
 149 }
 150 
 151 void RenderGrid::repeatTracksSizingIfNeeded(LayoutUnit availableSpaceForColumns, LayoutUnit availableSpaceForRows)
 152 {
 153     // In orthogonal flow cases column track&#39;s size is determined by using the computed
 154     // row track&#39;s size, which it was estimated during the first cycle of the sizing
 155     // algorithm. Hence we need to repeat computeUsedBreadthOfGridTracks for both,
 156     // columns and rows, to determine the final values.
 157     // TODO (lajava): orthogonal flows is just one of the cases which may require
 158     // a new cycle of the sizing algorithm; there may be more. In addition, not all the
 159     // cases with orthogonal flows require this extra cycle; we need a more specific
 160     // condition to detect whether child&#39;s min-content contribution has changed or not.
 161     if (m_hasAnyOrthogonalItem || m_trackSizingAlgorithm.hasAnyPercentSizedRowsIndefiniteHeight()) {
 162         computeTrackSizesForDefiniteSize(ForColumns, availableSpaceForColumns);
 163         computeContentPositionAndDistributionOffset(ForColumns, m_trackSizingAlgorithm.freeSpace(ForColumns).value(), nonCollapsedTracks(ForColumns));
 164         computeTrackSizesForDefiniteSize(ForRows, availableSpaceForRows);
 165         computeContentPositionAndDistributionOffset(ForRows, m_trackSizingAlgorithm.freeSpace(ForRows).value(), nonCollapsedTracks(ForRows));
 166     }
 167 }
 168 
 169 bool RenderGrid::canPerformSimplifiedLayout() const
 170 {
 171     // We cannot perform a simplified layout if we need to position the items and we have some
 172     // positioned items to be laid out.
 173     if (m_grid.needsItemsPlacement() &amp;&amp; posChildNeedsLayout())
 174         return false;
 175 
 176     return RenderBlock::canPerformSimplifiedLayout();
 177 }
 178 
 179 void RenderGrid::layoutBlock(bool relayoutChildren, LayoutUnit)
 180 {
 181     ASSERT(needsLayout());
 182 
 183     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 184         return;
 185 
 186     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 187     {
 188         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 189 
 190         preparePaginationBeforeBlockLayout(relayoutChildren);
 191         beginUpdateScrollInfoAfterLayoutTransaction();
 192 
 193         LayoutSize previousSize = size();
 194         // FIXME: We should use RenderBlock::hasDefiniteLogicalHeight() but it does not work for positioned stuff.
 195         // FIXME: Consider caching the hasDefiniteLogicalHeight value throughout the layout.
 196         bool hasDefiniteLogicalHeight = hasOverrideContentLogicalHeight() || computeContentLogicalHeight(MainOrPreferredSize, style().logicalHeight(), WTF::nullopt);
 197 
 198         m_hasAnyOrthogonalItem = false;
 199         for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 200             if (child-&gt;isOutOfFlowPositioned())
 201                 continue;
 202             // Grid&#39;s layout logic controls the grid item&#39;s override height, hence we need to
 203             // clear any override height set previously, so it doesn&#39;t interfere in current layout
 204             // execution. Grid never uses the override width, that&#39;s why we don&#39;t need to clear  it.
 205             child-&gt;clearOverrideContentLogicalHeight();
 206 
 207             // We may need to repeat the track sizing in case of any grid item was orthogonal.
 208             if (GridLayoutFunctions::isOrthogonalChild(*this, *child))
 209                 m_hasAnyOrthogonalItem = true;
 210 
 211             // We keep a cache of items with baseline as alignment values so
 212             // that we only compute the baseline shims for such items. This
 213             // cache is needed for performance related reasons due to the
 214             // cost of evaluating the item&#39;s participation in a baseline
 215             // context during the track sizing algorithm.
 216             if (isBaselineAlignmentForChild(*child, GridColumnAxis))
 217                 m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridColumnAxis);
 218             if (isBaselineAlignmentForChild(*child, GridRowAxis))
 219                 m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridRowAxis);
 220         }
 221         m_baselineItemsCached = true;
 222         resetLogicalHeightBeforeLayoutIfNeeded();
 223         updateLogicalWidth();
 224 
 225         // Fieldsets need to find their legend and position it inside the border of the object.
 226         // The legend then gets skipped during normal layout. The same is true for ruby text.
 227         // It doesn&#39;t get included in the normal layout process but is instead skipped.
 228         layoutExcludedChildren(relayoutChildren);
 229 
 230         LayoutUnit availableSpaceForColumns = availableLogicalWidth();
 231         placeItemsOnGrid(m_trackSizingAlgorithm, availableSpaceForColumns);
 232 
 233         performGridItemsPreLayout(m_trackSizingAlgorithm);
 234 
 235         // 1- First, the track sizing algorithm is used to resolve the sizes of the
 236         // grid columns.
 237         // At this point the logical width is always definite as the above call to
 238         // updateLogicalWidth() properly resolves intrinsic sizes. We cannot do the
 239         // same for heights though because many code paths inside
 240         // updateLogicalHeight() require a previous call to setLogicalHeight() to
 241         // resolve heights properly (like for positioned items for example).
 242         computeTrackSizesForDefiniteSize(ForColumns, availableSpaceForColumns);
 243 
 244         // 1.5- Compute Content Distribution offsets for column tracks
 245         computeContentPositionAndDistributionOffset(ForColumns, m_trackSizingAlgorithm.freeSpace(ForColumns).value(), nonCollapsedTracks(ForColumns));
 246 
 247         // 2- Next, the track sizing algorithm resolves the sizes of the grid rows,
 248         // using the grid column sizes calculated in the previous step.
 249         if (!hasDefiniteLogicalHeight)
 250             computeTrackSizesForIndefiniteSize(m_trackSizingAlgorithm, ForRows);
 251         else
 252             computeTrackSizesForDefiniteSize(ForRows, availableLogicalHeight(ExcludeMarginBorderPadding));
 253         LayoutUnit trackBasedLogicalHeight = m_trackSizingAlgorithm.computeTrackBasedSize() + borderAndPaddingLogicalHeight() + scrollbarLogicalHeight();
 254         setLogicalHeight(trackBasedLogicalHeight);
 255 
 256         LayoutUnit oldClientAfterEdge = clientLogicalBottom();
 257         updateLogicalHeight();
 258 
 259         // Once grid&#39;s indefinite height is resolved, we can compute the
 260         // available free space for Content Alignment.
 261         if (!hasDefiniteLogicalHeight)
 262             m_trackSizingAlgorithm.setFreeSpace(ForRows, logicalHeight() - trackBasedLogicalHeight);
 263 
 264         // 2.5- Compute Content Distribution offsets for rows tracks
 265         computeContentPositionAndDistributionOffset(ForRows, m_trackSizingAlgorithm.freeSpace(ForRows).value(), nonCollapsedTracks(ForRows));
 266 
 267         // 3- If the min-content contribution of any grid items have changed based on the row
 268         // sizes calculated in step 2, steps 1 and 2 are repeated with the new min-content
 269         // contribution (once only).
 270         repeatTracksSizingIfNeeded(availableSpaceForColumns, contentLogicalHeight());
 271 
 272         // Grid container should have the minimum height of a line if it&#39;s editable. That does not affect track sizing though.
 273         if (hasLineIfEmpty()) {
 274             LayoutUnit minHeightForEmptyLine = borderAndPaddingLogicalHeight()
 275                 + lineHeight(true, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes)
 276                 + scrollbarLogicalHeight();
 277             setLogicalHeight(std::max(logicalHeight(), minHeightForEmptyLine));
 278         }
 279 
 280         layoutGridItems();
 281         m_trackSizingAlgorithm.reset();
 282 
 283         endAndCommitUpdateScrollInfoAfterLayoutTransaction();
 284 
 285         if (size() != previousSize)
 286             relayoutChildren = true;
 287 
 288         m_outOfFlowItemColumn.clear();
 289         m_outOfFlowItemRow.clear();
 290 
 291         layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());
 292 
 293         computeOverflow(oldClientAfterEdge);
 294     }
 295 
 296     updateLayerTransform();
 297 
 298     // Update our scroll information if we&#39;re overflow:auto/scroll/hidden now that we know if
 299     // we overflow or not.
 300     updateScrollInfoAfterLayout();
 301 
 302     repainter.repaintAfterLayout();
 303 
 304     clearNeedsLayout();
 305 
 306     m_trackSizingAlgorithm.clearBaselineItemsCache();
 307     m_baselineItemsCached = false;
 308 }
 309 
 310 LayoutUnit RenderGrid::gridGap(GridTrackSizingDirection direction, Optional&lt;LayoutUnit&gt; availableSize) const
 311 {
 312     const GapLength&amp; gapLength = direction == ForColumns? style().columnGap() : style().rowGap();
 313     if (gapLength.isNormal())
 314         return 0_lu;
 315 
 316     return valueForLength(gapLength.length(), availableSize.valueOr(0));
 317 }
 318 
 319 LayoutUnit RenderGrid::gridGap(GridTrackSizingDirection direction) const
 320 {
 321     return gridGap(direction, availableSpaceForGutters(direction));
 322 }
 323 
 324 LayoutUnit RenderGrid::gridItemOffset(GridTrackSizingDirection direction) const
 325 {
 326     return direction == ForRows ? m_offsetBetweenRows.distributionOffset : m_offsetBetweenColumns.distributionOffset;
 327 }
 328 
 329 LayoutUnit RenderGrid::guttersSize(const Grid&amp; grid, GridTrackSizingDirection direction, unsigned startLine, unsigned span, Optional&lt;LayoutUnit&gt; availableSize) const
 330 {
 331     if (span &lt;= 1)
 332         return { };
 333 
 334     LayoutUnit gap = gridGap(direction, availableSize);
 335 
 336     // Fast path, no collapsing tracks.
 337     if (!grid.hasAutoRepeatEmptyTracks(direction))
 338         return gap * (span - 1);
 339 
 340     // If there are collapsing tracks we need to be sure that gutters are properly collapsed. Apart
 341     // from that, if we have a collapsed track in the edges of the span we&#39;re considering, we need
 342     // to move forward (or backwards) in order to know whether the collapsed tracks reach the end of
 343     // the grid (so the gap becomes 0) or there is a non empty track before that.
 344 
 345     LayoutUnit gapAccumulator;
 346     unsigned endLine = startLine + span;
 347 
 348     for (unsigned line = startLine; line &lt; endLine - 1; ++line) {
 349         if (!grid.isEmptyAutoRepeatTrack(direction, line))
 350             gapAccumulator += gap;
 351     }
 352 
 353     // The above loop adds one extra gap for trailing collapsed tracks.
 354     if (gapAccumulator &amp;&amp; grid.isEmptyAutoRepeatTrack(direction, endLine - 1)) {
 355         ASSERT(gapAccumulator &gt;= gap);
 356         gapAccumulator -= gap;
 357     }
 358 
 359     // If the startLine is the start line of a collapsed track we need to go backwards till we reach
 360     // a non collapsed track. If we find a non collapsed track we need to add that gap.
 361     size_t nonEmptyTracksBeforeStartLine = 0;
 362     if (startLine &amp;&amp; grid.isEmptyAutoRepeatTrack(direction, startLine)) {
 363         nonEmptyTracksBeforeStartLine = startLine;
 364         auto begin = grid.autoRepeatEmptyTracks(direction)-&gt;begin();
 365         for (auto it = begin; *it != startLine; ++it) {
 366             ASSERT(nonEmptyTracksBeforeStartLine);
 367             --nonEmptyTracksBeforeStartLine;
 368         }
 369         if (nonEmptyTracksBeforeStartLine)
 370             gapAccumulator += gap;
 371     }
 372 
 373     // If the endLine is the end line of a collapsed track we need to go forward till we reach a non
 374     // collapsed track. If we find a non collapsed track we need to add that gap.
 375     if (grid.isEmptyAutoRepeatTrack(direction, endLine - 1)) {
 376         unsigned nonEmptyTracksAfterEndLine = grid.numTracks(direction) - endLine;
 377         auto currentEmptyTrack = grid.autoRepeatEmptyTracks(direction)-&gt;find(endLine - 1);
 378         auto endEmptyTrack = grid.autoRepeatEmptyTracks(direction)-&gt;end();
 379         // HashSet iterators do not implement operator- so we have to manually iterate to know the number of remaining empty tracks.
 380         for (auto it = ++currentEmptyTrack; it != endEmptyTrack; ++it) {
 381             ASSERT(nonEmptyTracksAfterEndLine &gt;= 1);
 382             --nonEmptyTracksAfterEndLine;
 383         }
 384         if (nonEmptyTracksAfterEndLine) {
 385             // We shouldn&#39;t count the gap twice if the span starts and ends in a collapsed track bewtween two non-empty tracks.
 386             if (!nonEmptyTracksBeforeStartLine)
 387                 gapAccumulator += gap;
 388         } else if (nonEmptyTracksBeforeStartLine) {
 389             // We shouldn&#39;t count the gap if the the span starts and ends in a collapsed but there isn&#39;t non-empty tracks afterwards (it&#39;s at the end of the grid).
 390             gapAccumulator -= gap;
 391         }
 392     }
 393 
 394     return gapAccumulator;
 395 }
 396 
 397 void RenderGrid::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
 398 {
 399     LayoutUnit childMinWidth;
 400     LayoutUnit childMaxWidth;
 401     bool hadExcludedChildren = computePreferredWidthsForExcludedChildren(childMinWidth, childMaxWidth);
 402 
 403     Grid grid(const_cast&lt;RenderGrid&amp;&gt;(*this));
 404     GridTrackSizingAlgorithm algorithm(this, grid);
 405     placeItemsOnGrid(algorithm, WTF::nullopt);
 406 
 407     performGridItemsPreLayout(algorithm);
 408 
 409     if (m_baselineItemsCached)
 410         algorithm.copyBaselineItemsCache(m_trackSizingAlgorithm, GridRowAxis);
 411     else {
 412         for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 413             if (child-&gt;isOutOfFlowPositioned())
 414                 continue;
 415             if (isBaselineAlignmentForChild(*child, GridRowAxis))
 416                 algorithm.cacheBaselineAlignedItem(*child, GridRowAxis);
 417         }
 418     }
 419 
 420     computeTrackSizesForIndefiniteSize(algorithm, ForColumns, &amp;minLogicalWidth, &amp;maxLogicalWidth);
 421 
 422     if (hadExcludedChildren) {
 423         minLogicalWidth = std::max(minLogicalWidth, childMinWidth);
 424         maxLogicalWidth = std::max(maxLogicalWidth, childMaxWidth);
 425     }
 426 
 427     LayoutUnit scrollbarWidth = intrinsicScrollbarLogicalWidth();
 428     minLogicalWidth += scrollbarWidth;
 429     maxLogicalWidth += scrollbarWidth;
 430 }
 431 
 432 void RenderGrid::computeTrackSizesForIndefiniteSize(GridTrackSizingAlgorithm&amp; algorithm, GridTrackSizingDirection direction, LayoutUnit* minIntrinsicSize, LayoutUnit* maxIntrinsicSize) const
 433 {
 434     const Grid&amp; grid = algorithm.grid();
 435     algorithm.setup(direction, numTracks(direction, grid), IntrinsicSizeComputation, WTF::nullopt, WTF::nullopt);
 436     algorithm.run();
 437 
 438     size_t numberOfTracks = algorithm.tracks(direction).size();
 439     LayoutUnit totalGuttersSize = guttersSize(grid, direction, 0, numberOfTracks, WTF::nullopt);
 440 
 441     if (minIntrinsicSize)
 442         *minIntrinsicSize = algorithm.minContentSize() + totalGuttersSize;
 443     if (maxIntrinsicSize)
 444         *maxIntrinsicSize = algorithm.maxContentSize() + totalGuttersSize;
 445 
 446     ASSERT(algorithm.tracksAreWiderThanMinTrackBreadth());
 447 }
 448 
 449 unsigned RenderGrid::computeAutoRepeatTracksCount(GridTrackSizingDirection direction, Optional&lt;LayoutUnit&gt; availableSize) const
 450 {
 451     ASSERT(!availableSize || availableSize.value() != -1);
 452     bool isRowAxis = direction == ForColumns;
 453     const auto&amp; autoRepeatTracks = isRowAxis ? style().gridAutoRepeatColumns() : style().gridAutoRepeatRows();
 454     unsigned autoRepeatTrackListLength = autoRepeatTracks.size();
 455 
 456     if (!autoRepeatTrackListLength)
 457         return 0;
 458 
 459     bool needsToFulfillMinimumSize = false;
 460     if (!availableSize) {
 461         const Length&amp; maxSize = isRowAxis ? style().logicalMaxWidth() : style().logicalMaxHeight();
 462         Optional&lt;LayoutUnit&gt; containingBlockAvailableSize;
 463         Optional&lt;LayoutUnit&gt; availableMaxSize;
 464         if (maxSize.isSpecified()) {
 465             if (maxSize.isPercentOrCalculated())
 466                 containingBlockAvailableSize = isRowAxis ? containingBlockLogicalWidthForContent() : containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);
 467             LayoutUnit maxSizeValue = valueForLength(maxSize, containingBlockAvailableSize.valueOr(LayoutUnit()));
 468             availableMaxSize = isRowAxis ? adjustContentBoxLogicalWidthForBoxSizing(maxSizeValue) : adjustContentBoxLogicalHeightForBoxSizing(maxSizeValue);
 469         }
 470 
 471         const Length&amp; minSize = isRowAxis ? style().logicalMinWidth() : style().logicalMinHeight();
 472         if (!availableMaxSize &amp;&amp; !minSize.isSpecified())
 473             return autoRepeatTrackListLength;
 474 
 475         Optional&lt;LayoutUnit&gt; availableMinSize;
 476         if (minSize.isSpecified()) {
 477             if (!containingBlockAvailableSize &amp;&amp; minSize.isPercentOrCalculated())
 478                 containingBlockAvailableSize = isRowAxis ? containingBlockLogicalWidthForContent() : containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);
 479             LayoutUnit minSizeValue = valueForLength(minSize, containingBlockAvailableSize.valueOr(LayoutUnit()));
 480             availableMinSize = isRowAxis ? adjustContentBoxLogicalWidthForBoxSizing(minSizeValue) : adjustContentBoxLogicalHeightForBoxSizing(minSizeValue);
 481             if (!maxSize.isSpecified())
 482                 needsToFulfillMinimumSize = true;
 483         }
 484 
 485         availableSize = std::max(availableMinSize.valueOr(LayoutUnit()), availableMaxSize.valueOr(LayoutUnit()));
 486     }
 487 
 488     LayoutUnit autoRepeatTracksSize;
 489     for (auto&amp; autoTrackSize : autoRepeatTracks) {
 490         ASSERT(autoTrackSize.minTrackBreadth().isLength());
 491         ASSERT(!autoTrackSize.minTrackBreadth().isFlex());
 492         bool hasDefiniteMaxTrackSizingFunction = autoTrackSize.maxTrackBreadth().isLength() &amp;&amp; !autoTrackSize.maxTrackBreadth().isContentSized();
 493         auto trackLength = hasDefiniteMaxTrackSizingFunction ? autoTrackSize.maxTrackBreadth().length() : autoTrackSize.minTrackBreadth().length();
 494         autoRepeatTracksSize += valueForLength(trackLength, availableSize.value());
 495     }
 496     // For the purpose of finding the number of auto-repeated tracks, the UA must floor the track size to a UA-specified
 497     // value to avoid division by zero. It is suggested that this floor be 1px.
 498     autoRepeatTracksSize = std::max&lt;LayoutUnit&gt;(1_lu, autoRepeatTracksSize);
 499 
 500     // There will be always at least 1 auto-repeat track, so take it already into account when computing the total track size.
 501     LayoutUnit tracksSize = autoRepeatTracksSize;
 502     auto&amp; trackSizes = isRowAxis ? style().gridColumns() : style().gridRows();
 503 
 504     for (const auto&amp; track : trackSizes) {
 505         bool hasDefiniteMaxTrackBreadth = track.maxTrackBreadth().isLength() &amp;&amp; !track.maxTrackBreadth().isContentSized();
 506         ASSERT(hasDefiniteMaxTrackBreadth || (track.minTrackBreadth().isLength() &amp;&amp; !track.minTrackBreadth().isContentSized()));
 507         tracksSize += valueForLength(hasDefiniteMaxTrackBreadth ? track.maxTrackBreadth().length() : track.minTrackBreadth().length(), availableSize.value());
 508     }
 509 
 510     // Add gutters as if there where only 1 auto repeat track. Gaps between auto repeat tracks will be added later when
 511     // computing the repetitions.
 512     LayoutUnit gapSize = gridGap(direction, availableSize);
 513     tracksSize += gapSize * trackSizes.size();
 514 
 515     LayoutUnit freeSpace = availableSize.value() - tracksSize;
 516     if (freeSpace &lt;= 0)
 517         return autoRepeatTrackListLength;
 518 
 519     LayoutUnit autoRepeatSizeWithGap = autoRepeatTracksSize + gapSize;
 520     unsigned repetitions = 1 + (freeSpace / autoRepeatSizeWithGap).toUnsigned();
 521     freeSpace -= autoRepeatSizeWithGap * (repetitions - 1);
 522     ASSERT(freeSpace &gt;= 0);
 523 
 524     // Provided the grid container does not have a definite size or max-size in the relevant axis,
 525     // if the min size is definite then the number of repetitions is the largest possible positive
 526     // integer that fulfills that minimum requirement.
 527     if (needsToFulfillMinimumSize &amp;&amp; freeSpace)
 528         ++repetitions;
 529 
 530     return repetitions * autoRepeatTrackListLength;
 531 }
 532 
 533 
 534 std::unique_ptr&lt;OrderedTrackIndexSet&gt; RenderGrid::computeEmptyTracksForAutoRepeat(Grid&amp; grid, GridTrackSizingDirection direction) const
 535 {
 536     bool isRowAxis = direction == ForColumns;
 537     if ((isRowAxis &amp;&amp; style().gridAutoRepeatColumnsType() != AutoRepeatType::Fit)
 538         || (!isRowAxis &amp;&amp; style().gridAutoRepeatRowsType() != AutoRepeatType::Fit))
 539         return nullptr;
 540 
 541     std::unique_ptr&lt;OrderedTrackIndexSet&gt; emptyTrackIndexes;
 542     unsigned insertionPoint = isRowAxis ? style().gridAutoRepeatColumnsInsertionPoint() : style().gridAutoRepeatRowsInsertionPoint();
 543     unsigned firstAutoRepeatTrack = insertionPoint + std::abs(grid.smallestTrackStart(direction));
 544     unsigned lastAutoRepeatTrack = firstAutoRepeatTrack + grid.autoRepeatTracks(direction);
 545 
 546     if (!grid.hasGridItems()) {
 547         emptyTrackIndexes = makeUnique&lt;OrderedTrackIndexSet&gt;();
 548         for (unsigned trackIndex = firstAutoRepeatTrack; trackIndex &lt; lastAutoRepeatTrack; ++trackIndex)
 549             emptyTrackIndexes-&gt;add(trackIndex);
 550     } else {
 551         for (unsigned trackIndex = firstAutoRepeatTrack; trackIndex &lt; lastAutoRepeatTrack; ++trackIndex) {
 552             GridIterator iterator(grid, direction, trackIndex);
 553             if (!iterator.nextGridItem()) {
 554                 if (!emptyTrackIndexes)
 555                     emptyTrackIndexes = makeUnique&lt;OrderedTrackIndexSet&gt;();
 556                 emptyTrackIndexes-&gt;add(trackIndex);
 557             }
 558         }
 559     }
 560     return emptyTrackIndexes;
 561 }
 562 
 563 unsigned RenderGrid::clampAutoRepeatTracks(GridTrackSizingDirection direction, unsigned autoRepeatTracks) const
 564 {
 565     if (!autoRepeatTracks)
 566         return 0;
 567 
 568     unsigned insertionPoint = direction == ForColumns ? style().gridAutoRepeatColumnsInsertionPoint() : style().gridAutoRepeatRowsInsertionPoint();
 569     unsigned maxTracks = static_cast&lt;unsigned&gt;(GridPosition::max());
 570 
 571     if (!insertionPoint)
 572         return std::min(autoRepeatTracks, maxTracks);
 573 
 574     if (insertionPoint &gt;= maxTracks)
 575         return 0;
 576 
 577     return std::min(autoRepeatTracks, maxTracks - insertionPoint);
 578 }
 579 
 580 // FIXME: We shouldn&#39;t have to pass the available logical width as argument. The problem is that
 581 // availableLogicalWidth() does always return a value even if we cannot resolve it like when
 582 // computing the intrinsic size (preferred widths). That&#39;s why we pass the responsibility to the
 583 // caller who does know whether the available logical width is indefinite or not.
 584 void RenderGrid::placeItemsOnGrid(GridTrackSizingAlgorithm&amp; algorithm, Optional&lt;LayoutUnit&gt; availableLogicalWidth) const
 585 {
 586     Grid&amp; grid = algorithm.mutableGrid();
 587     unsigned autoRepeatColumns = computeAutoRepeatTracksCount(ForColumns, availableLogicalWidth);
 588     unsigned autoRepeatRows = computeAutoRepeatTracksCount(ForRows, availableLogicalHeightForPercentageComputation());
 589 
 590     autoRepeatRows = clampAutoRepeatTracks(ForRows, autoRepeatRows);
 591     autoRepeatColumns = clampAutoRepeatTracks(ForColumns, autoRepeatColumns);
 592 
 593     if (autoRepeatColumns != grid.autoRepeatTracks(ForColumns) || autoRepeatRows != grid.autoRepeatTracks(ForRows)) {
 594         grid.setNeedsItemsPlacement(true);
 595         grid.setAutoRepeatTracks(autoRepeatRows, autoRepeatColumns);
 596     }
 597 
 598     if (!grid.needsItemsPlacement())
 599         return;
 600 
 601     ASSERT(!grid.hasGridItems());
 602     populateExplicitGridAndOrderIterator(grid);
 603 
 604     Vector&lt;RenderBox*&gt; autoMajorAxisAutoGridItems;
 605     Vector&lt;RenderBox*&gt; specifiedMajorAxisAutoGridItems;
 606     for (auto* child = grid.orderIterator().first(); child; child = grid.orderIterator().next()) {
 607         if (grid.orderIterator().shouldSkipChild(*child))
 608             continue;
 609 
 610         // Grid items should use the grid area sizes instead of the containing block (grid container)
 611         // sizes, we initialize the overrides here if needed to ensure it.
 612         if (!child-&gt;hasOverrideContainingBlockContentLogicalWidth())
 613             child-&gt;setOverrideContainingBlockContentLogicalWidth(LayoutUnit());
 614         if (!child-&gt;hasOverrideContainingBlockContentLogicalHeight())
 615             child-&gt;setOverrideContainingBlockContentLogicalHeight(LayoutUnit(-1));
 616 
 617         GridArea area = grid.gridItemArea(*child);
 618         if (!area.rows.isIndefinite())
 619             area.rows.translate(std::abs(grid.smallestTrackStart(ForRows)));
 620         if (!area.columns.isIndefinite())
 621             area.columns.translate(std::abs(grid.smallestTrackStart(ForColumns)));
 622 
 623         if (area.rows.isIndefinite() || area.columns.isIndefinite()) {
 624             grid.setGridItemArea(*child, area);
 625             bool majorAxisDirectionIsForColumns = autoPlacementMajorAxisDirection() == ForColumns;
 626             if ((majorAxisDirectionIsForColumns &amp;&amp; area.columns.isIndefinite())
 627                 || (!majorAxisDirectionIsForColumns &amp;&amp; area.rows.isIndefinite()))
 628                 autoMajorAxisAutoGridItems.append(child);
 629             else
 630                 specifiedMajorAxisAutoGridItems.append(child);
 631             continue;
 632         }
 633         grid.insert(*child, { area.rows, area.columns });
 634     }
 635 
 636 #if ASSERT_ENABLED
 637     if (grid.hasGridItems()) {
 638         ASSERT(grid.numTracks(ForRows) &gt;= GridPositionsResolver::explicitGridRowCount(style(), grid.autoRepeatTracks(ForRows)));
 639         ASSERT(grid.numTracks(ForColumns) &gt;= GridPositionsResolver::explicitGridColumnCount(style(), grid.autoRepeatTracks(ForColumns)));
 640     }
 641 #endif
 642 
 643     placeSpecifiedMajorAxisItemsOnGrid(grid, specifiedMajorAxisAutoGridItems);
 644     placeAutoMajorAxisItemsOnGrid(grid, autoMajorAxisAutoGridItems);
 645 
 646     // Compute collapsible tracks for auto-fit.
 647     grid.setAutoRepeatEmptyColumns(computeEmptyTracksForAutoRepeat(grid, ForColumns));
 648     grid.setAutoRepeatEmptyRows(computeEmptyTracksForAutoRepeat(grid, ForRows));
 649 
 650     grid.setNeedsItemsPlacement(false);
 651 
 652 #if ASSERT_ENABLED
 653     for (auto* child = grid.orderIterator().first(); child; child = grid.orderIterator().next()) {
 654         if (grid.orderIterator().shouldSkipChild(*child))
 655             continue;
 656 
 657         GridArea area = grid.gridItemArea(*child);
 658         ASSERT(area.rows.isTranslatedDefinite() &amp;&amp; area.columns.isTranslatedDefinite());
 659     }
 660 #endif
 661 }
 662 
 663 void RenderGrid::performGridItemsPreLayout(const GridTrackSizingAlgorithm&amp; algorithm) const
 664 {
 665     ASSERT(!algorithm.grid().needsItemsPlacement());
 666     // FIXME: We need a way when we are calling this during intrinsic size compuation before performing
 667     // the layout. Maybe using the PreLayout phase ?
 668     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 669         if (child-&gt;isOutOfFlowPositioned())
 670             continue;
 671         // Orthogonal items should be laid out in order to properly compute content-sized tracks that may depend on item&#39;s intrinsic size.
 672         // We also need to properly estimate its grid area size, since it may affect to the baseline shims if such item particiaptes in baseline alignment.
 673         if (GridLayoutFunctions::isOrthogonalChild(*this, *child)) {
 674             updateGridAreaLogicalSize(*child, algorithm.estimatedGridAreaBreadthForChild(*child));
 675             child-&gt;layoutIfNeeded();
 676             continue;
 677         }
 678         // We need to layout the item to know whether it must synthesize its
 679         // baseline or not, which may imply a cyclic sizing dependency.
 680         // FIXME: Can we avoid it ?
 681         if (isBaselineAlignmentForChild(*child)) {
 682             updateGridAreaLogicalSize(*child, algorithm.estimatedGridAreaBreadthForChild(*child));
 683             child-&gt;layoutIfNeeded();
 684         }
 685     }
 686 }
 687 
 688 void RenderGrid::populateExplicitGridAndOrderIterator(Grid&amp; grid) const
 689 {
 690     OrderIteratorPopulator populator(grid.orderIterator());
 691     int smallestRowStart = 0;
 692     int smallestColumnStart = 0;
 693     unsigned autoRepeatRows = grid.autoRepeatTracks(ForRows);
 694     unsigned autoRepeatColumns = grid.autoRepeatTracks(ForColumns);
 695     unsigned maximumRowIndex = GridPositionsResolver::explicitGridRowCount(style(), autoRepeatRows);
 696     unsigned maximumColumnIndex = GridPositionsResolver::explicitGridColumnCount(style(), autoRepeatColumns);
 697 
 698     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 699         if (!populator.collectChild(*child))
 700             continue;
 701 
 702         GridSpan rowPositions = GridPositionsResolver::resolveGridPositionsFromStyle(style(), *child, ForRows, autoRepeatRows);
 703         if (!rowPositions.isIndefinite()) {
 704             smallestRowStart = std::min(smallestRowStart, rowPositions.untranslatedStartLine());
 705             maximumRowIndex = std::max&lt;int&gt;(maximumRowIndex, rowPositions.untranslatedEndLine());
 706         } else {
 707             // Grow the grid for items with a definite row span, getting the largest such span.
 708             unsigned spanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(*child, ForRows);
 709             maximumRowIndex = std::max(maximumRowIndex, spanSize);
 710         }
 711 
 712         GridSpan columnPositions = GridPositionsResolver::resolveGridPositionsFromStyle(style(), *child, ForColumns, autoRepeatColumns);
 713         if (!columnPositions.isIndefinite()) {
 714             smallestColumnStart = std::min(smallestColumnStart, columnPositions.untranslatedStartLine());
 715             maximumColumnIndex = std::max&lt;int&gt;(maximumColumnIndex, columnPositions.untranslatedEndLine());
 716         } else {
 717             // Grow the grid for items with a definite column span, getting the largest such span.
 718             unsigned spanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(*child, ForColumns);
 719             maximumColumnIndex = std::max(maximumColumnIndex, spanSize);
 720         }
 721 
 722         grid.setGridItemArea(*child, { rowPositions, columnPositions });
 723     }
 724 
 725     grid.setSmallestTracksStart(smallestRowStart, smallestColumnStart);
 726     grid.ensureGridSize(maximumRowIndex + std::abs(smallestRowStart), maximumColumnIndex + std::abs(smallestColumnStart));
 727 }
 728 
 729 std::unique_ptr&lt;GridArea&gt; RenderGrid::createEmptyGridAreaAtSpecifiedPositionsOutsideGrid(Grid&amp; grid, const RenderBox&amp; gridItem, GridTrackSizingDirection specifiedDirection, const GridSpan&amp; specifiedPositions) const
 730 {
 731     GridTrackSizingDirection crossDirection = specifiedDirection == ForColumns ? ForRows : ForColumns;
 732     const unsigned endOfCrossDirection = grid.numTracks(crossDirection);
 733     unsigned crossDirectionSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(gridItem, crossDirection);
 734     GridSpan crossDirectionPositions = GridSpan::translatedDefiniteGridSpan(endOfCrossDirection, endOfCrossDirection + crossDirectionSpanSize);
 735     return makeUnique&lt;GridArea&gt;(specifiedDirection == ForColumns ? crossDirectionPositions : specifiedPositions, specifiedDirection == ForColumns ? specifiedPositions : crossDirectionPositions);
 736 }
 737 
 738 void RenderGrid::placeSpecifiedMajorAxisItemsOnGrid(Grid&amp; grid, const Vector&lt;RenderBox*&gt;&amp; autoGridItems) const
 739 {
 740     bool isForColumns = autoPlacementMajorAxisDirection() == ForColumns;
 741     bool isGridAutoFlowDense = style().isGridAutoFlowAlgorithmDense();
 742 
 743     // Mapping between the major axis tracks (rows or columns) and the last auto-placed item&#39;s position inserted on
 744     // that track. This is needed to implement &quot;sparse&quot; packing for items locked to a given track.
 745     // See http://dev.w3.org/csswg/css-grid/#auto-placement-algorithm
 746     HashMap&lt;unsigned, unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; minorAxisCursors;
 747 
 748     for (auto&amp; autoGridItem : autoGridItems) {
 749         GridSpan majorAxisPositions = grid.gridItemSpan(*autoGridItem, autoPlacementMajorAxisDirection());
 750         ASSERT(majorAxisPositions.isTranslatedDefinite());
 751         ASSERT(grid.gridItemSpan(*autoGridItem, autoPlacementMinorAxisDirection()).isIndefinite());
 752         unsigned minorAxisSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(*autoGridItem, autoPlacementMinorAxisDirection());
 753         unsigned majorAxisInitialPosition = majorAxisPositions.startLine();
 754 
 755         GridIterator iterator(grid, autoPlacementMajorAxisDirection(), majorAxisPositions.startLine(), isGridAutoFlowDense ? 0 : minorAxisCursors.get(majorAxisInitialPosition));
 756         std::unique_ptr&lt;GridArea&gt; emptyGridArea = iterator.nextEmptyGridArea(majorAxisPositions.integerSpan(), minorAxisSpanSize);
 757         if (!emptyGridArea)
 758             emptyGridArea = createEmptyGridAreaAtSpecifiedPositionsOutsideGrid(grid, *autoGridItem, autoPlacementMajorAxisDirection(), majorAxisPositions);
 759 
 760         grid.insert(*autoGridItem, *emptyGridArea);
 761 
 762         if (!isGridAutoFlowDense)
 763             minorAxisCursors.set(majorAxisInitialPosition, isForColumns ? emptyGridArea-&gt;rows.startLine() : emptyGridArea-&gt;columns.startLine());
 764     }
 765 }
 766 
 767 void RenderGrid::placeAutoMajorAxisItemsOnGrid(Grid&amp; grid, const Vector&lt;RenderBox*&gt;&amp; autoGridItems) const
 768 {
 769     AutoPlacementCursor autoPlacementCursor = {0, 0};
 770     bool isGridAutoFlowDense = style().isGridAutoFlowAlgorithmDense();
 771 
 772     for (auto&amp; autoGridItem : autoGridItems) {
 773         placeAutoMajorAxisItemOnGrid(grid, *autoGridItem, autoPlacementCursor);
 774 
 775         if (isGridAutoFlowDense) {
 776             autoPlacementCursor.first = 0;
 777             autoPlacementCursor.second = 0;
 778         }
 779     }
 780 }
 781 
 782 void RenderGrid::placeAutoMajorAxisItemOnGrid(Grid&amp; grid, RenderBox&amp; gridItem, AutoPlacementCursor&amp; autoPlacementCursor) const
 783 {
 784     ASSERT(grid.gridItemSpan(gridItem, autoPlacementMajorAxisDirection()).isIndefinite());
 785     unsigned majorAxisSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(gridItem, autoPlacementMajorAxisDirection());
 786 
 787     const unsigned endOfMajorAxis = grid.numTracks(autoPlacementMajorAxisDirection());
 788     unsigned majorAxisAutoPlacementCursor = autoPlacementMajorAxisDirection() == ForColumns ? autoPlacementCursor.second : autoPlacementCursor.first;
 789     unsigned minorAxisAutoPlacementCursor = autoPlacementMajorAxisDirection() == ForColumns ? autoPlacementCursor.first : autoPlacementCursor.second;
 790 
 791     std::unique_ptr&lt;GridArea&gt; emptyGridArea;
 792     GridSpan minorAxisPositions = grid.gridItemSpan(gridItem, autoPlacementMinorAxisDirection());
 793     if (minorAxisPositions.isTranslatedDefinite()) {
 794         // Move to the next track in major axis if initial position in minor axis is before auto-placement cursor.
 795         if (minorAxisPositions.startLine() &lt; minorAxisAutoPlacementCursor)
 796             majorAxisAutoPlacementCursor++;
 797 
 798         if (majorAxisAutoPlacementCursor &lt; endOfMajorAxis) {
 799             GridIterator iterator(grid, autoPlacementMinorAxisDirection(), minorAxisPositions.startLine(), majorAxisAutoPlacementCursor);
 800             emptyGridArea = iterator.nextEmptyGridArea(minorAxisPositions.integerSpan(), majorAxisSpanSize);
 801         }
 802 
 803         if (!emptyGridArea)
 804             emptyGridArea = createEmptyGridAreaAtSpecifiedPositionsOutsideGrid(grid, gridItem, autoPlacementMinorAxisDirection(), minorAxisPositions);
 805     } else {
 806         unsigned minorAxisSpanSize = GridPositionsResolver::spanSizeForAutoPlacedItem(gridItem, autoPlacementMinorAxisDirection());
 807 
 808         for (unsigned majorAxisIndex = majorAxisAutoPlacementCursor; majorAxisIndex &lt; endOfMajorAxis; ++majorAxisIndex) {
 809             GridIterator iterator(grid, autoPlacementMajorAxisDirection(), majorAxisIndex, minorAxisAutoPlacementCursor);
 810             emptyGridArea = iterator.nextEmptyGridArea(majorAxisSpanSize, minorAxisSpanSize);
 811 
 812             if (emptyGridArea) {
 813                 // Check that it fits in the minor axis direction, as we shouldn&#39;t grow in that direction here (it was already managed in populateExplicitGridAndOrderIterator()).
 814                 unsigned minorAxisFinalPositionIndex = autoPlacementMinorAxisDirection() == ForColumns ? emptyGridArea-&gt;columns.endLine() : emptyGridArea-&gt;rows.endLine();
 815                 const unsigned endOfMinorAxis = grid.numTracks(autoPlacementMinorAxisDirection());
 816                 if (minorAxisFinalPositionIndex &lt;= endOfMinorAxis)
 817                     break;
 818 
 819                 // Discard empty grid area as it does not fit in the minor axis direction.
 820                 // We don&#39;t need to create a new empty grid area yet as we might find a valid one in the next iteration.
 821                 emptyGridArea = nullptr;
 822             }
 823 
 824             // As we&#39;re moving to the next track in the major axis we should reset the auto-placement cursor in the minor axis.
 825             minorAxisAutoPlacementCursor = 0;
 826         }
 827 
 828         if (!emptyGridArea)
 829             emptyGridArea = createEmptyGridAreaAtSpecifiedPositionsOutsideGrid(grid, gridItem, autoPlacementMinorAxisDirection(), GridSpan::translatedDefiniteGridSpan(0, minorAxisSpanSize));
 830     }
 831 
 832     grid.insert(gridItem, *emptyGridArea);
 833     autoPlacementCursor.first = emptyGridArea-&gt;rows.startLine();
 834     autoPlacementCursor.second = emptyGridArea-&gt;columns.startLine();
 835 }
 836 
 837 GridTrackSizingDirection RenderGrid::autoPlacementMajorAxisDirection() const
 838 {
 839     return style().isGridAutoFlowDirectionColumn() ? ForColumns : ForRows;
 840 }
 841 
 842 GridTrackSizingDirection RenderGrid::autoPlacementMinorAxisDirection() const
 843 {
 844     return style().isGridAutoFlowDirectionColumn() ? ForRows : ForColumns;
 845 }
 846 
 847 void RenderGrid::dirtyGrid()
 848 {
 849     if (m_grid.needsItemsPlacement())
 850         return;
 851 
 852     m_grid.setNeedsItemsPlacement(true);
 853 }
 854 
 855 Vector&lt;LayoutUnit&gt; RenderGrid::trackSizesForComputedStyle(GridTrackSizingDirection direction) const
 856 {
 857     bool isRowAxis = direction == ForColumns;
 858     auto&amp; positions = isRowAxis ? m_columnPositions : m_rowPositions;
 859     size_t numPositions = positions.size();
 860     LayoutUnit offsetBetweenTracks = isRowAxis ? m_offsetBetweenColumns.distributionOffset : m_offsetBetweenRows.distributionOffset;
 861 
 862     Vector&lt;LayoutUnit&gt; tracks;
 863     if (numPositions &lt; 2)
 864         return tracks;
 865 
 866     ASSERT(!m_grid.needsItemsPlacement());
 867     bool hasCollapsedTracks = m_grid.hasAutoRepeatEmptyTracks(direction);
 868     LayoutUnit gap = !hasCollapsedTracks ? gridGap(direction) : 0_lu;
 869     size_t explicitStart = -m_grid.smallestTrackStart(direction);
 870     size_t explicitEnd = explicitStart + (isRowAxis ? style().gridColumns() : style().gridRows()).size() + autoRepeatCountForDirection(direction);
 871     // Usually we have `explicitEnd &lt;= numPositions - 1`, but the latter may be smaller when the maximum number of tracks is reached.
 872     explicitEnd = std::min(explicitEnd, numPositions - 1);
 873     tracks.reserveCapacity(explicitEnd - explicitStart);
 874     size_t loopEnd = std::min(explicitEnd, numPositions - 2);
 875     for (size_t i = explicitStart; i &lt; loopEnd; ++i)
 876         tracks.append(positions[i + 1] - positions[i] - offsetBetweenTracks - gap);
 877     if (loopEnd &lt; explicitEnd)
 878         tracks.append(positions[explicitEnd] - positions[explicitEnd - 1]);
 879 
 880     if (!hasCollapsedTracks)
 881         return tracks;
 882 
 883     size_t remainingEmptyTracks = m_grid.autoRepeatEmptyTracks(direction)-&gt;size();
 884     size_t lastLine = tracks.size();
 885     gap = gridGap(direction);
 886     for (size_t i = 1; i &lt; lastLine; ++i) {
 887         if (m_grid.isEmptyAutoRepeatTrack(direction, i - 1 + explicitStart))
 888             --remainingEmptyTracks;
 889         else {
 890             // Remove the gap between consecutive non empty tracks. Remove it also just once for an
 891             // arbitrary number of empty tracks between two non empty ones.
 892             bool allRemainingTracksAreEmpty = remainingEmptyTracks == (lastLine - i);
 893             if (!allRemainingTracksAreEmpty || !m_grid.isEmptyAutoRepeatTrack(direction, i + explicitStart))
 894                 tracks[i - 1] -= gap;
 895         }
 896     }
 897 
 898     return tracks;
 899 }
 900 
 901 static const StyleContentAlignmentData&amp; contentAlignmentNormalBehaviorGrid()
 902 {
 903     static const StyleContentAlignmentData normalBehavior = {ContentPosition::Normal, ContentDistribution::Stretch};
 904     return normalBehavior;
 905 }
 906 
 907 static bool overrideSizeChanged(const RenderBox&amp; child, GridTrackSizingDirection direction, LayoutSize size)
 908 {
 909     if (direction == ForColumns)
 910         return !child.hasOverrideContainingBlockContentLogicalWidth() || child.overrideContainingBlockContentLogicalWidth() != size.width();
 911     return !child.hasOverrideContainingBlockContentLogicalHeight() || child.overrideContainingBlockContentLogicalHeight() != size.height();
 912 }
 913 
 914 static bool hasRelativeBlockAxisSize(const RenderGrid&amp; grid, const RenderBox&amp; child)
 915 {
 916     return GridLayoutFunctions::isOrthogonalChild(grid, child) ? child.hasRelativeLogicalWidth() || child.style().logicalWidth().isAuto() : child.hasRelativeLogicalHeight();
 917 }
 918 
 919 void RenderGrid::updateGridAreaLogicalSize(RenderBox&amp; child, LayoutSize gridAreaLogicalSize) const
 920 {
 921     // Because the grid area cannot be styled, we don&#39;t need to adjust
 922     // the grid breadth to account for &#39;box-sizing&#39;.
 923     bool gridAreaWidthChanged = overrideSizeChanged(child, ForColumns, gridAreaLogicalSize);
 924     bool gridAreaHeightChanged = overrideSizeChanged(child, ForRows, gridAreaLogicalSize);
 925     if (gridAreaWidthChanged || (gridAreaHeightChanged &amp;&amp; hasRelativeBlockAxisSize(*this, child)))
 926         child.setNeedsLayout(MarkOnlyThis);
 927 
 928     child.setOverrideContainingBlockContentLogicalWidth(gridAreaLogicalSize.width());
 929     child.setOverrideContainingBlockContentLogicalHeight(gridAreaLogicalSize.height());
 930 }
 931 
 932 void RenderGrid::layoutGridItems()
 933 {
 934     populateGridPositionsForDirection(ForColumns);
 935     populateGridPositionsForDirection(ForRows);
 936 
 937     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 938 
 939         if (m_grid.orderIterator().shouldSkipChild(*child)) {
 940             if (child-&gt;isOutOfFlowPositioned())
 941                 prepareChildForPositionedLayout(*child);
 942             continue;
 943         }
 944 
 945         // Setting the definite grid area&#39;s sizes. It may imply that the
 946         // item must perform a layout if its area differs from the one
 947         // used during the track sizing algorithm.
 948         updateGridAreaLogicalSize(*child, LayoutSize(gridAreaBreadthForChildIncludingAlignmentOffsets(*child, ForColumns), gridAreaBreadthForChildIncludingAlignmentOffsets(*child, ForRows)));
 949 
 950         LayoutRect oldChildRect = child-&gt;frameRect();
 951 
 952         // Stretching logic might force a child layout, so we need to run it before the layoutIfNeeded
 953         // call to avoid unnecessary relayouts. This might imply that child margins, needed to correctly
 954         // determine the available space before stretching, are not set yet.
 955         applyStretchAlignmentToChildIfNeeded(*child);
 956 
 957         child-&gt;layoutIfNeeded();
 958 
 959         // We need pending layouts to be done in order to compute auto-margins properly.
 960         updateAutoMarginsInColumnAxisIfNeeded(*child);
 961         updateAutoMarginsInRowAxisIfNeeded(*child);
 962 
 963         setLogicalPositionForChild(*child);
 964 
 965         // If the child moved, we have to repaint it as well as any floating/positioned
 966         // descendants. An exception is if we need a layout. In this case, we know we&#39;re going to
 967         // repaint ourselves (and the child) anyway.
 968         if (!selfNeedsLayout() &amp;&amp; child-&gt;checkForRepaintDuringLayout())
 969             child-&gt;repaintDuringLayoutIfMoved(oldChildRect);
 970     }
 971 }
 972 
 973 void RenderGrid::prepareChildForPositionedLayout(RenderBox&amp; child)
 974 {
 975     ASSERT(child.isOutOfFlowPositioned());
 976     child.containingBlock()-&gt;insertPositionedObject(child);
 977 
 978     RenderLayer* childLayer = child.layer();
 979     // Static position of a positioned child should use the content-box (https://drafts.csswg.org/css-grid/#static-position).
 980     childLayer-&gt;setStaticInlinePosition(borderAndPaddingStart());
 981     childLayer-&gt;setStaticBlockPosition(borderAndPaddingBefore());
 982 }
 983 
 984 bool RenderGrid::hasStaticPositionForChild(const RenderBox&amp; child, GridTrackSizingDirection direction) const
 985 {
 986     return direction == ForColumns ? child.style().hasStaticInlinePosition(isHorizontalWritingMode()) : child.style().hasStaticBlockPosition(isHorizontalWritingMode());
 987 }
 988 
 989 void RenderGrid::layoutPositionedObject(RenderBox&amp; child, bool relayoutChildren, bool fixedPositionObjectsOnly)
 990 {
 991     LayoutUnit columnBreadth = gridAreaBreadthForOutOfFlowChild(child, ForColumns);
 992     LayoutUnit rowBreadth = gridAreaBreadthForOutOfFlowChild(child, ForRows);
 993 
 994     child.setOverrideContainingBlockContentLogicalWidth(columnBreadth);
 995     child.setOverrideContainingBlockContentLogicalHeight(rowBreadth);
 996 
 997     // Mark for layout as we&#39;re resetting the position before and we relay in generic layout logic
 998     // for positioned items in order to get the offsets properly resolved.
 999     child.setChildNeedsLayout(MarkOnlyThis);
1000 
1001     RenderBlock::layoutPositionedObject(child, relayoutChildren, fixedPositionObjectsOnly);
1002 
1003     setLogicalOffsetForChild(child, ForColumns);
1004     setLogicalOffsetForChild(child, ForRows);
1005 }
1006 
1007 LayoutUnit RenderGrid::gridAreaBreadthForChildIncludingAlignmentOffsets(const RenderBox&amp; child, GridTrackSizingDirection direction) const
1008 {
1009     // We need the cached value when available because Content Distribution alignment properties
1010     // may have some influence in the final grid area breadth.
1011     const auto&amp; tracks = m_trackSizingAlgorithm.tracks(direction);
1012     const auto&amp; span = m_grid.gridItemSpan(child, direction);
1013     const auto&amp; linePositions = (direction == ForColumns) ? m_columnPositions : m_rowPositions;
1014 
1015     LayoutUnit initialTrackPosition = linePositions[span.startLine()];
1016     LayoutUnit finalTrackPosition = linePositions[span.endLine() - 1];
1017 
1018     // Track Positions vector stores the &#39;start&#39; grid line of each track, so we have to add last track&#39;s baseSize.
1019     return finalTrackPosition - initialTrackPosition + tracks[span.endLine() - 1].baseSize();
1020 }
1021 
1022 void RenderGrid::populateGridPositionsForDirection(GridTrackSizingDirection direction)
1023 {
1024     // Since we add alignment offsets and track gutters, grid lines are not always adjacent. Hence we will have to
1025     // assume from now on that we just store positions of the initial grid lines of each track,
1026     // except the last one, which is the only one considered as a final grid line of a track.
1027 
1028     // The grid container&#39;s frame elements (border, padding and &lt;content-position&gt; offset) are sensible to the
1029     // inline-axis flow direction. However, column lines positions are &#39;direction&#39; unaware. This simplification
1030     // allows us to use the same indexes to identify the columns independently on the inline-axis direction.
1031     bool isRowAxis = direction == ForColumns;
1032     auto&amp; tracks = m_trackSizingAlgorithm.tracks(direction);
1033     unsigned numberOfTracks = tracks.size();
1034     unsigned numberOfLines = numberOfTracks + 1;
1035     unsigned lastLine = numberOfLines - 1;
1036     bool hasCollapsedTracks = m_grid.hasAutoRepeatEmptyTracks(direction);
1037     size_t numberOfCollapsedTracks = hasCollapsedTracks ? m_grid.autoRepeatEmptyTracks(direction)-&gt;size() : 0;
1038     const auto&amp; offset = direction == ForColumns ? m_offsetBetweenColumns : m_offsetBetweenRows;
1039     auto&amp; positions = isRowAxis ? m_columnPositions : m_rowPositions;
1040     positions.resize(numberOfLines);
1041 
1042     auto borderAndPadding = isRowAxis ? borderAndPaddingLogicalLeft() : borderAndPaddingBefore();
1043 #if !PLATFORM(IOS_FAMILY)
1044     // FIXME: Ideally scrollbarLogicalWidth() should return zero in iOS so we don&#39;t need this
1045     // (see bug https://webkit.org/b/191857).
1046     // If we are in horizontal writing mode and RTL direction the scrollbar is painted on the left,
1047     // so we need to take into account when computing the position of the columns.
1048     if (isRowAxis &amp;&amp; style().isHorizontalWritingMode() &amp;&amp; !style().isLeftToRightDirection())
1049         borderAndPadding += scrollbarLogicalWidth();
1050 #endif
1051 
1052     positions[0] = borderAndPadding + offset.positionOffset;
1053     if (numberOfLines &gt; 1) {
1054         // If we have collapsed tracks we just ignore gaps here and add them later as we might not
1055         // compute the gap between two consecutive tracks without examining the surrounding ones.
1056         LayoutUnit gap = !hasCollapsedTracks ? gridGap(direction) : 0_lu;
1057         unsigned nextToLastLine = numberOfLines - 2;
1058         for (unsigned i = 0; i &lt; nextToLastLine; ++i)
1059             positions[i + 1] = positions[i] + offset.distributionOffset + tracks[i].baseSize() + gap;
1060         positions[lastLine] = positions[nextToLastLine] + tracks[nextToLastLine].baseSize();
1061 
1062         // Adjust collapsed gaps. Collapsed tracks cause the surrounding gutters to collapse (they
1063         // coincide exactly) except on the edges of the grid where they become 0.
1064         if (hasCollapsedTracks) {
1065             gap = gridGap(direction);
1066             unsigned remainingEmptyTracks = numberOfCollapsedTracks;
1067             LayoutUnit offsetAccumulator;
1068             LayoutUnit gapAccumulator;
1069             for (unsigned i = 1; i &lt; lastLine; ++i) {
1070                 if (m_grid.isEmptyAutoRepeatTrack(direction, i - 1)) {
1071                     --remainingEmptyTracks;
1072                     offsetAccumulator += offset.distributionOffset;
1073                 } else {
1074                     // Add gap between consecutive non empty tracks. Add it also just once for an
1075                     // arbitrary number of empty tracks between two non empty ones.
1076                     bool allRemainingTracksAreEmpty = remainingEmptyTracks == (lastLine - i);
1077                     if (!allRemainingTracksAreEmpty || !m_grid.isEmptyAutoRepeatTrack(direction, i))
1078                         gapAccumulator += gap;
1079                 }
1080                 positions[i] += gapAccumulator - offsetAccumulator;
1081             }
1082             positions[lastLine] += gapAccumulator - offsetAccumulator;
1083         }
1084     }
1085 }
1086 
1087 static LayoutUnit computeOverflowAlignmentOffset(OverflowAlignment overflow, LayoutUnit trackSize, LayoutUnit childSize)
1088 {
1089     LayoutUnit offset = trackSize - childSize;
1090     switch (overflow) {
1091     case OverflowAlignment::Safe:
1092         // If overflow is &#39;safe&#39;, we have to make sure we don&#39;t overflow the &#39;start&#39;
1093         // edge (potentially cause some data loss as the overflow is unreachable).
1094         return std::max&lt;LayoutUnit&gt;(0, offset);
1095     case OverflowAlignment::Unsafe:
1096     case OverflowAlignment::Default:
1097         // If we overflow our alignment container and overflow is &#39;true&#39; (default), we
1098         // ignore the overflow and just return the value regardless (which may cause data
1099         // loss as we overflow the &#39;start&#39; edge).
1100         return offset;
1101     }
1102 
1103     ASSERT_NOT_REACHED();
1104     return 0;
1105 }
1106 
1107 LayoutUnit RenderGrid::availableAlignmentSpaceForChildBeforeStretching(LayoutUnit gridAreaBreadthForChild, const RenderBox&amp; child) const
1108 {
1109     // Because we want to avoid multiple layouts, stretching logic might be performed before
1110     // children are laid out, so we can&#39;t use the child cached values. Hence, we need to
1111     // compute margins in order to determine the available height before stretching.
1112     GridTrackSizingDirection childBlockFlowDirection = GridLayoutFunctions::flowAwareDirectionForChild(*this, child, ForRows);
1113     return gridAreaBreadthForChild - GridLayoutFunctions::marginLogicalSizeForChild(*this, childBlockFlowDirection, child);
1114 }
1115 
1116 StyleSelfAlignmentData RenderGrid::alignSelfForChild(const RenderBox&amp; child, const RenderStyle* gridStyle) const
1117 {
1118     if (!gridStyle)
1119         gridStyle = &amp;style();
1120     return child.style().resolvedAlignSelf(gridStyle, selfAlignmentNormalBehavior(&amp;child));
1121 }
1122 
1123 StyleSelfAlignmentData RenderGrid::justifySelfForChild(const RenderBox&amp; child, const RenderStyle* gridStyle) const
1124 {
1125     if (!gridStyle)
1126         gridStyle = &amp;style();
1127     return child.style().resolvedJustifySelf(gridStyle, selfAlignmentNormalBehavior(&amp;child));
1128 }
1129 
1130 // FIXME: This logic is shared by RenderFlexibleBox, so it should be moved to RenderBox.
1131 void RenderGrid::applyStretchAlignmentToChildIfNeeded(RenderBox&amp; child)
1132 {
1133     ASSERT(child.overrideContainingBlockContentLogicalHeight());
1134 
1135     // We clear height override values because we will decide now whether it&#39;s allowed or
1136     // not, evaluating the conditions which might have changed since the old values were set.
1137     child.clearOverrideContentLogicalHeight();
1138 
1139     GridTrackSizingDirection childBlockDirection = GridLayoutFunctions::flowAwareDirectionForChild(*this, child, ForRows);
1140     bool blockFlowIsColumnAxis = childBlockDirection == ForRows;
1141     bool allowedToStretchChildBlockSize = blockFlowIsColumnAxis ? allowedToStretchChildAlongColumnAxis(child) : allowedToStretchChildAlongRowAxis(child);
1142     if (allowedToStretchChildBlockSize) {
1143         LayoutUnit stretchedLogicalHeight = availableAlignmentSpaceForChildBeforeStretching(GridLayoutFunctions::overrideContainingBlockContentSizeForChild(child, childBlockDirection).value(), child);
1144         LayoutUnit desiredLogicalHeight = child.constrainLogicalHeightByMinMax(stretchedLogicalHeight, -1_lu);
1145         child.setOverrideContentLogicalHeight(desiredLogicalHeight - child.borderAndPaddingLogicalHeight());
1146         if (desiredLogicalHeight != child.logicalHeight()) {
1147             // FIXME: Can avoid laying out here in some cases. See https://webkit.org/b/87905.
1148             child.setLogicalHeight(0_lu);
1149             child.setNeedsLayout();
1150         }
1151     }
1152 }
1153 
1154 // FIXME: This logic is shared by RenderFlexibleBox, so it should be moved to RenderBox.
1155 bool RenderGrid::hasAutoMarginsInColumnAxis(const RenderBox&amp; child) const
1156 {
1157     if (isHorizontalWritingMode())
1158         return child.style().marginTop().isAuto() || child.style().marginBottom().isAuto();
1159     return child.style().marginLeft().isAuto() || child.style().marginRight().isAuto();
1160 }
1161 
1162 // FIXME: This logic is shared by RenderFlexibleBox, so it should be moved to RenderBox.
1163 bool RenderGrid::hasAutoMarginsInRowAxis(const RenderBox&amp; child) const
1164 {
1165     if (isHorizontalWritingMode())
1166         return child.style().marginLeft().isAuto() || child.style().marginRight().isAuto();
1167     return child.style().marginTop().isAuto() || child.style().marginBottom().isAuto();
1168 }
1169 
1170 // FIXME: This logic is shared by RenderFlexibleBox, so it should be moved to RenderBox.
1171 void RenderGrid::updateAutoMarginsInRowAxisIfNeeded(RenderBox&amp; child)
1172 {
1173     ASSERT(!child.isOutOfFlowPositioned());
1174 
1175     LayoutUnit availableAlignmentSpace = child.overrideContainingBlockContentLogicalWidth().value() - child.logicalWidth() - child.marginLogicalWidth();
1176     if (availableAlignmentSpace &lt;= 0)
1177         return;
1178 
1179     const RenderStyle&amp; parentStyle = style();
1180     Length marginStart = child.style().marginStartUsing(&amp;parentStyle);
1181     Length marginEnd = child.style().marginEndUsing(&amp;parentStyle);
1182     if (marginStart.isAuto() &amp;&amp; marginEnd.isAuto()) {
1183         child.setMarginStart(availableAlignmentSpace / 2, &amp;parentStyle);
1184         child.setMarginEnd(availableAlignmentSpace / 2, &amp;parentStyle);
1185     } else if (marginStart.isAuto()) {
1186         child.setMarginStart(availableAlignmentSpace, &amp;parentStyle);
1187     } else if (marginEnd.isAuto()) {
1188         child.setMarginEnd(availableAlignmentSpace, &amp;parentStyle);
1189     }
1190 }
1191 
1192 // FIXME: This logic is shared by RenderFlexibleBox, so it should be moved to RenderBox.
1193 void RenderGrid::updateAutoMarginsInColumnAxisIfNeeded(RenderBox&amp; child)
1194 {
1195     ASSERT(!child.isOutOfFlowPositioned());
1196 
1197     LayoutUnit availableAlignmentSpace = child.overrideContainingBlockContentLogicalHeight().value() - child.logicalHeight() - child.marginLogicalHeight();
1198     if (availableAlignmentSpace &lt;= 0)
1199         return;
1200 
1201     const RenderStyle&amp; parentStyle = style();
1202     Length marginBefore = child.style().marginBeforeUsing(&amp;parentStyle);
1203     Length marginAfter = child.style().marginAfterUsing(&amp;parentStyle);
1204     if (marginBefore.isAuto() &amp;&amp; marginAfter.isAuto()) {
1205         child.setMarginBefore(availableAlignmentSpace / 2, &amp;parentStyle);
1206         child.setMarginAfter(availableAlignmentSpace / 2, &amp;parentStyle);
1207     } else if (marginBefore.isAuto()) {
1208         child.setMarginBefore(availableAlignmentSpace, &amp;parentStyle);
1209     } else if (marginAfter.isAuto()) {
1210         child.setMarginAfter(availableAlignmentSpace, &amp;parentStyle);
1211     }
1212 }
1213 
1214 // FIXME: This logic could be refactored somehow and defined in RenderBox.
1215 static int synthesizedBaselineFromBorderBox(const RenderBox&amp; box, LineDirectionMode direction)
1216 {
1217     return (direction == HorizontalLine ? box.size().height() : box.size().width()).toInt();
1218 }
1219 
1220 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child) const
1221 {
1222     return isBaselineAlignmentForChild(child, GridRowAxis) || isBaselineAlignmentForChild(child, GridColumnAxis);
1223 }
1224 
1225 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child, GridAxis baselineAxis) const
1226 {
1227     if (child.isOutOfFlowPositioned())
1228         return false;
1229     ItemPosition align = selfAlignmentForChild(baselineAxis, child).position();
1230     bool hasAutoMargins = baselineAxis == GridColumnAxis ? hasAutoMarginsInColumnAxis(child) : hasAutoMarginsInRowAxis(child);
1231     return isBaselinePosition(align) &amp;&amp; !hasAutoMargins;
1232 }
1233 
1234 // FIXME: This logic is shared by RenderFlexibleBox, so it might be refactored somehow.
1235 int RenderGrid::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode mode) const
1236 {
1237     ASSERT_UNUSED(mode, mode == PositionOnContainingLine);
1238     auto baseline = firstLineBaseline();
1239     if (!baseline)
1240         return synthesizedBaselineFromBorderBox(*this, direction) + marginLogicalHeight();
1241 
1242     return baseline.value() + (direction == HorizontalLine ? marginTop() : marginRight()).toInt();
1243 }
1244 
1245 Optional&lt;int&gt; RenderGrid::firstLineBaseline() const
1246 {
1247     if (isWritingModeRoot() || !m_grid.hasGridItems())
1248         return WTF::nullopt;
1249 
1250     const RenderBox* baselineChild = nullptr;
1251     // Finding the first grid item in grid order.
1252     unsigned numColumns = m_grid.numTracks(ForColumns);
1253     for (size_t column = 0; column &lt; numColumns; column++) {
1254         for (auto&amp; child : m_grid.cell(0, column)) {
1255             ASSERT(child.get());
1256             // If an item participates in baseline alignment, we select such item.
1257             if (isBaselineAlignmentForChild(*child)) {
1258                 // FIXME: self-baseline and content-baseline alignment not implemented yet.
1259                 baselineChild = child.get();
1260                 break;
1261             }
1262             if (!baselineChild)
1263                 baselineChild = child.get();
1264         }
1265     }
1266 
1267     if (!baselineChild)
1268         return WTF::nullopt;
1269 
1270     auto baseline = GridLayoutFunctions::isOrthogonalChild(*this, *baselineChild) ? WTF::nullopt : baselineChild-&gt;firstLineBaseline();
1271     // We take border-box&#39;s bottom if no valid baseline.
1272     if (!baseline) {
1273         // FIXME: We should pass |direction| into firstLineBaseline and stop bailing out if we&#39;re a writing
1274         // mode root. This would also fix some cases where the grid is orthogonal to its container.
1275         LineDirectionMode direction = isHorizontalWritingMode() ? HorizontalLine : VerticalLine;
1276         return synthesizedBaselineFromBorderBox(*baselineChild, direction) + logicalTopForChild(*baselineChild).toInt();
1277     }
1278     return baseline.value() + baselineChild-&gt;logicalTop().toInt();
1279 }
1280 
1281 Optional&lt;int&gt; RenderGrid::inlineBlockBaseline(LineDirectionMode) const
1282 {
1283     return firstLineBaseline();
1284 }
1285 
1286 LayoutUnit RenderGrid::columnAxisBaselineOffsetForChild(const RenderBox&amp; child) const
1287 {
1288     return m_trackSizingAlgorithm.baselineOffsetForChild(child, GridColumnAxis);
1289 }
1290 
1291 LayoutUnit RenderGrid::rowAxisBaselineOffsetForChild(const RenderBox&amp; child) const
1292 {
1293     return m_trackSizingAlgorithm.baselineOffsetForChild(child, GridRowAxis);
1294 }
1295 
1296 GridAxisPosition RenderGrid::columnAxisPositionForChild(const RenderBox&amp; child) const
1297 {
1298     bool hasSameWritingMode = child.style().writingMode() == style().writingMode();
1299     bool childIsLTR = child.style().isLeftToRightDirection();
1300     if (child.isOutOfFlowPositioned() &amp;&amp; !hasStaticPositionForChild(child, ForRows))
1301         return GridAxisStart;
1302 
1303     switch (alignSelfForChild(child).position()) {
1304     case ItemPosition::SelfStart:
1305         // FIXME: Should we implement this logic in a generic utility function ?
1306         // Aligns the alignment subject to be flush with the edge of the alignment container
1307         // corresponding to the alignment subject&#39;s &#39;start&#39; side in the column axis.
1308         if (GridLayoutFunctions::isOrthogonalChild(*this, child)) {
1309             // If orthogonal writing-modes, self-start will be based on the child&#39;s inline-axis
1310             // direction (inline-start), because it&#39;s the one parallel to the column axis.
1311             if (style().isFlippedBlocksWritingMode())
1312                 return childIsLTR ? GridAxisEnd : GridAxisStart;
1313             return childIsLTR ? GridAxisStart : GridAxisEnd;
1314         }
1315         // self-start is based on the child&#39;s block-flow direction. That&#39;s why we need to check against the grid container&#39;s block-flow direction.
1316         return hasSameWritingMode ? GridAxisStart : GridAxisEnd;
1317     case ItemPosition::SelfEnd:
1318         // FIXME: Should we implement this logic in a generic utility function ?
1319         // Aligns the alignment subject to be flush with the edge of the alignment container
1320         // corresponding to the alignment subject&#39;s &#39;end&#39; side in the column axis.
1321         if (GridLayoutFunctions::isOrthogonalChild(*this, child)) {
1322             // If orthogonal writing-modes, self-end will be based on the child&#39;s inline-axis
1323             // direction, (inline-end) because it&#39;s the one parallel to the column axis.
1324             if (style().isFlippedBlocksWritingMode())
1325                 return childIsLTR ? GridAxisStart : GridAxisEnd;
1326             return childIsLTR ? GridAxisEnd : GridAxisStart;
1327         }
1328         // self-end is based on the child&#39;s block-flow direction. That&#39;s why we need to check against the grid container&#39;s block-flow direction.
1329         return hasSameWritingMode ? GridAxisEnd : GridAxisStart;
1330     case ItemPosition::Left:
1331         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;line-left&#39; edge.
1332         // The alignment axis (column axis) is always orthogonal to the inline axis, hence this value behaves as &#39;start&#39;.
1333         return GridAxisStart;
1334     case ItemPosition::Right:
1335         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;line-right&#39; edge.
1336         // The alignment axis (column axis) is always orthogonal to the inline axis, hence this value behaves as &#39;start&#39;.
1337         return GridAxisStart;
1338     case ItemPosition::Center:
1339         return GridAxisCenter;
1340     case ItemPosition::FlexStart: // Only used in flex layout, otherwise equivalent to &#39;start&#39;.
1341         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;start&#39; edge (block-start) in the column axis.
1342     case ItemPosition::Start:
1343         return GridAxisStart;
1344     case ItemPosition::FlexEnd: // Only used in flex layout, otherwise equivalent to &#39;end&#39;.
1345         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;end&#39; edge (block-end) in the column axis.
1346     case ItemPosition::End:
1347         return GridAxisEnd;
1348     case ItemPosition::Stretch:
1349         return GridAxisStart;
1350     case ItemPosition::Baseline:
1351     case ItemPosition::LastBaseline:
1352         // FIXME: Implement the previous values. For now, we always &#39;start&#39; align the child.
1353         return GridAxisStart;
1354     case ItemPosition::Legacy:
1355     case ItemPosition::Auto:
1356     case ItemPosition::Normal:
1357         break;
1358     }
1359 
1360     ASSERT_NOT_REACHED();
1361     return GridAxisStart;
1362 }
1363 
1364 GridAxisPosition RenderGrid::rowAxisPositionForChild(const RenderBox&amp; child) const
1365 {
1366     bool hasSameDirection = child.style().direction() == style().direction();
1367     bool gridIsLTR = style().isLeftToRightDirection();
1368     if (child.isOutOfFlowPositioned() &amp;&amp; !hasStaticPositionForChild(child, ForColumns))
1369         return GridAxisStart;
1370 
1371     switch (justifySelfForChild(child).position()) {
1372     case ItemPosition::SelfStart:
1373         // FIXME: Should we implement this logic in a generic utility function ?
1374         // Aligns the alignment subject to be flush with the edge of the alignment container
1375         // corresponding to the alignment subject&#39;s &#39;start&#39; side in the row axis.
1376         if (GridLayoutFunctions::isOrthogonalChild(*this, child)) {
1377             // If orthogonal writing-modes, self-start will be based on the child&#39;s block-axis
1378             // direction, because it&#39;s the one parallel to the row axis.
1379             if (child.style().isFlippedBlocksWritingMode())
1380                 return gridIsLTR ? GridAxisEnd : GridAxisStart;
1381             return gridIsLTR ? GridAxisStart : GridAxisEnd;
1382         }
1383         // self-start is based on the child&#39;s inline-flow direction. That&#39;s why we need to check against the grid container&#39;s direction.
1384         return hasSameDirection ? GridAxisStart : GridAxisEnd;
1385     case ItemPosition::SelfEnd:
1386         // FIXME: Should we implement this logic in a generic utility function ?
1387         // Aligns the alignment subject to be flush with the edge of the alignment container
1388         // corresponding to the alignment subject&#39;s &#39;end&#39; side in the row axis.
1389         if (GridLayoutFunctions::isOrthogonalChild(*this, child)) {
1390             // If orthogonal writing-modes, self-end will be based on the child&#39;s block-axis
1391             // direction, because it&#39;s the one parallel to the row axis.
1392             if (child.style().isFlippedBlocksWritingMode())
1393                 return gridIsLTR ? GridAxisStart : GridAxisEnd;
1394             return gridIsLTR ? GridAxisEnd : GridAxisStart;
1395         }
1396         // self-end is based on the child&#39;s inline-flow direction. That&#39;s why we need to check against the grid container&#39;s direction.
1397         return hasSameDirection ? GridAxisEnd : GridAxisStart;
1398     case ItemPosition::Left:
1399         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;line-left&#39; edge.
1400         // We want the physical &#39;left&#39; side, so we have to take account, container&#39;s inline-flow direction.
1401         return gridIsLTR ? GridAxisStart : GridAxisEnd;
1402     case ItemPosition::Right:
1403         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;line-right&#39; edge.
1404         // We want the physical &#39;right&#39; side, so we have to take account, container&#39;s inline-flow direction.
1405         return gridIsLTR ? GridAxisEnd : GridAxisStart;
1406     case ItemPosition::Center:
1407         return GridAxisCenter;
1408     case ItemPosition::FlexStart: // Only used in flex layout, otherwise equivalent to &#39;start&#39;.
1409         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;start&#39; edge (inline-start) in the row axis.
1410     case ItemPosition::Start:
1411         return GridAxisStart;
1412     case ItemPosition::FlexEnd: // Only used in flex layout, otherwise equivalent to &#39;end&#39;.
1413         // Aligns the alignment subject to be flush with the alignment container&#39;s &#39;end&#39; edge (inline-end) in the row axis.
1414     case ItemPosition::End:
1415         return GridAxisEnd;
1416     case ItemPosition::Stretch:
1417         return GridAxisStart;
1418     case ItemPosition::Baseline:
1419     case ItemPosition::LastBaseline:
1420         // FIXME: Implement the previous values. For now, we always &#39;start&#39; align the child.
1421         return GridAxisStart;
1422     case ItemPosition::Legacy:
1423     case ItemPosition::Auto:
1424     case ItemPosition::Normal:
1425         break;
1426     }
1427 
1428     ASSERT_NOT_REACHED();
1429     return GridAxisStart;
1430 }
1431 
1432 LayoutUnit RenderGrid::columnAxisOffsetForChild(const RenderBox&amp; child) const
1433 {
1434     LayoutUnit startOfRow;
1435     LayoutUnit endOfRow;
1436     gridAreaPositionForChild(child, ForRows, startOfRow, endOfRow);
1437     LayoutUnit startPosition = startOfRow + marginBeforeForChild(child);
1438     if (hasAutoMarginsInColumnAxis(child))
1439         return startPosition;
1440     GridAxisPosition axisPosition = columnAxisPositionForChild(child);
1441     switch (axisPosition) {
1442     case GridAxisStart:
1443         return startPosition + columnAxisBaselineOffsetForChild(child);
1444     case GridAxisEnd:
1445     case GridAxisCenter: {
1446         LayoutUnit columnAxisChildSize = GridLayoutFunctions::isOrthogonalChild(*this, child) ? child.logicalWidth() + child.marginLogicalWidth() : child.logicalHeight() + child.marginLogicalHeight();
1447         auto overflow = alignSelfForChild(child).overflow();
1448         LayoutUnit offsetFromStartPosition = computeOverflowAlignmentOffset(overflow, endOfRow - startOfRow, columnAxisChildSize);
1449         return startPosition + (axisPosition == GridAxisEnd ? offsetFromStartPosition : offsetFromStartPosition / 2);
1450     }
1451     }
1452 
1453     ASSERT_NOT_REACHED();
1454     return 0;
1455 }
1456 
1457 LayoutUnit RenderGrid::rowAxisOffsetForChild(const RenderBox&amp; child) const
1458 {
1459     LayoutUnit startOfColumn;
1460     LayoutUnit endOfColumn;
1461     gridAreaPositionForChild(child, ForColumns, startOfColumn, endOfColumn);
1462     LayoutUnit startPosition = startOfColumn + marginStartForChild(child);
1463     if (hasAutoMarginsInRowAxis(child))
1464         return startPosition;
1465     GridAxisPosition axisPosition = rowAxisPositionForChild(child);
1466     switch (axisPosition) {
1467     case GridAxisStart:
1468         return startPosition + rowAxisBaselineOffsetForChild(child);
1469     case GridAxisEnd:
1470     case GridAxisCenter: {
1471         LayoutUnit rowAxisChildSize = GridLayoutFunctions::isOrthogonalChild(*this, child) ? child.logicalHeight() + child.marginLogicalHeight() : child.logicalWidth() + child.marginLogicalWidth();
1472         auto overflow = justifySelfForChild(child).overflow();
1473         LayoutUnit offsetFromStartPosition = computeOverflowAlignmentOffset(overflow, endOfColumn - startOfColumn, rowAxisChildSize);
1474         return startPosition + (axisPosition == GridAxisEnd ? offsetFromStartPosition : offsetFromStartPosition / 2);
1475     }
1476     }
1477 
1478     ASSERT_NOT_REACHED();
1479     return 0;
1480 }
1481 
1482 LayoutUnit RenderGrid::resolveAutoStartGridPosition(GridTrackSizingDirection direction) const
1483 {
1484     if (direction == ForRows || style().isLeftToRightDirection())
1485         return 0_lu;
1486 
1487     int lastLine = numTracks(ForColumns, m_grid);
1488     ContentPosition position = style().resolvedJustifyContentPosition(contentAlignmentNormalBehaviorGrid());
1489     if (position == ContentPosition::End)
1490         return m_columnPositions[lastLine] - clientLogicalWidth();
1491     if (position == ContentPosition::Start || style().resolvedJustifyContentDistribution(contentAlignmentNormalBehaviorGrid()) == ContentDistribution::Stretch)
1492         return m_columnPositions[0] - borderAndPaddingLogicalLeft();
1493     return 0_lu;
1494 }
1495 
1496 LayoutUnit RenderGrid::resolveAutoEndGridPosition(GridTrackSizingDirection direction) const
1497 {
1498     if (direction == ForRows)
1499         return clientLogicalHeight();
1500     if (style().isLeftToRightDirection())
1501         return clientLogicalWidth();
1502 
1503     int lastLine = numTracks(ForColumns, m_grid);
1504     ContentPosition position = style().resolvedJustifyContentPosition(contentAlignmentNormalBehaviorGrid());
1505     if (position == ContentPosition::End)
1506         return m_columnPositions[lastLine];
1507     if (position == ContentPosition::Start || style().resolvedJustifyContentDistribution(contentAlignmentNormalBehaviorGrid()) == ContentDistribution::Stretch)
1508         return m_columnPositions[0] - borderAndPaddingLogicalLeft() + clientLogicalWidth();
1509     return clientLogicalWidth();
1510 }
1511 
1512 LayoutUnit RenderGrid::gridAreaBreadthForOutOfFlowChild(const RenderBox&amp; child, GridTrackSizingDirection direction)
1513 {
1514     ASSERT(child.isOutOfFlowPositioned());
1515     bool isRowAxis = direction == ForColumns;
1516     GridSpan span = GridPositionsResolver::resolveGridPositionsFromStyle(style(), child, direction, autoRepeatCountForDirection(direction));
1517     if (span.isIndefinite())
1518         return isRowAxis ? clientLogicalWidth() : clientLogicalHeight();
1519 
1520     int smallestStart = abs(m_grid.smallestTrackStart(direction));
1521     int startLine = span.untranslatedStartLine() + smallestStart;
1522     int endLine = span.untranslatedEndLine() + smallestStart;
1523     int lastLine = numTracks(direction, m_grid);
1524     GridPosition startPosition = direction == ForColumns ? child.style().gridItemColumnStart() : child.style().gridItemRowStart();
1525     GridPosition endPosition = direction == ForColumns ? child.style().gridItemColumnEnd() : child.style().gridItemRowEnd();
1526 
1527     bool startIsAuto = startPosition.isAuto() || startLine &lt; 0 || startLine &gt; lastLine;
1528     bool endIsAuto = endPosition.isAuto() || endLine &lt; 0 || endLine &gt; lastLine;
1529 
1530     if (startIsAuto &amp;&amp; endIsAuto)
1531         return isRowAxis ? clientLogicalWidth() : clientLogicalHeight();
1532 
1533     LayoutUnit start;
1534     LayoutUnit end;
1535     auto&amp; positions = isRowAxis ? m_columnPositions : m_rowPositions;
1536     auto&amp; outOfFlowItemLine = isRowAxis ? m_outOfFlowItemColumn : m_outOfFlowItemRow;
1537     LayoutUnit borderEdge = isRowAxis ? borderLogicalLeft() : borderBefore();
1538     if (startIsAuto)
1539         start = resolveAutoStartGridPosition(direction) + borderEdge;
1540     else {
1541         outOfFlowItemLine.set(&amp;child, startLine);
1542         start = positions[startLine];
1543     }
1544     if (endIsAuto)
1545         end = resolveAutoEndGridPosition(direction) + borderEdge;
1546     else {
1547         end = positions[endLine];
1548         // These vectors store line positions including gaps, but we shouldn&#39;t consider them for the edges of the grid.
1549         Optional&lt;LayoutUnit&gt; availableSizeForGutters = availableSpaceForGutters(direction);
1550         if (endLine &gt; 0 &amp;&amp; endLine &lt; lastLine) {
1551             ASSERT(!m_grid.needsItemsPlacement());
1552             end -= guttersSize(m_grid, direction, endLine - 1, 2, availableSizeForGutters);
1553             end -= isRowAxis ? m_offsetBetweenColumns.distributionOffset : m_offsetBetweenRows.distributionOffset;
1554         }
1555     }
1556     return std::max(end - start, 0_lu);
1557 }
1558 
1559 LayoutUnit RenderGrid::logicalOffsetForOutOfFlowChild(const RenderBox&amp; child, GridTrackSizingDirection direction, LayoutUnit trackBreadth) const
1560 {
1561     ASSERT(child.isOutOfFlowPositioned());
1562     if (hasStaticPositionForChild(child, direction))
1563         return 0_lu;
1564 
1565     bool isRowAxis = direction == ForColumns;
1566     bool isFlowAwareRowAxis = GridLayoutFunctions::flowAwareDirectionForChild(*this, child, direction) == ForColumns;
1567     LayoutUnit childPosition = isFlowAwareRowAxis ? child.logicalLeft() : child.logicalTop();
1568     LayoutUnit gridBorder = isRowAxis ? borderLogicalLeft() : borderBefore();
1569     LayoutUnit childMargin = isFlowAwareRowAxis ? child.marginLogicalLeft() : child.marginBefore();
1570     LayoutUnit offset = childPosition - gridBorder - childMargin;
1571     if (!isRowAxis || style().isLeftToRightDirection())
1572         return offset;
1573 
1574     LayoutUnit childBreadth = isFlowAwareRowAxis ? child.logicalWidth() + child.marginLogicalWidth() : child.logicalHeight() + child.marginLogicalHeight();
1575     return trackBreadth - offset - childBreadth;
1576 }
1577 
1578 void RenderGrid::gridAreaPositionForOutOfFlowChild(const RenderBox&amp; child, GridTrackSizingDirection direction, LayoutUnit&amp; start, LayoutUnit&amp; end) const
1579 {
1580     ASSERT(child.isOutOfFlowPositioned());
1581     ASSERT(GridLayoutFunctions::hasOverrideContainingBlockContentSizeForChild(child, direction));
1582     LayoutUnit trackBreadth = GridLayoutFunctions::overrideContainingBlockContentSizeForChild(child, direction).value();
1583     bool isRowAxis = direction == ForColumns;
1584     auto&amp; outOfFlowItemLine = isRowAxis ? m_outOfFlowItemColumn : m_outOfFlowItemRow;
1585     start = isRowAxis ? borderLogicalLeft() : borderBefore();
1586     if (auto line = outOfFlowItemLine.get(&amp;child)) {
1587         auto&amp; positions = isRowAxis ? m_columnPositions : m_rowPositions;
1588         start = positions[line.value()];
1589     }
1590     start += logicalOffsetForOutOfFlowChild(child, direction, trackBreadth);
1591     end = start + trackBreadth;
1592 }
1593 
1594 void RenderGrid::gridAreaPositionForInFlowChild(const RenderBox&amp; child, GridTrackSizingDirection direction, LayoutUnit&amp; start, LayoutUnit&amp; end) const
1595 {
1596     ASSERT(!child.isOutOfFlowPositioned());
1597     const GridSpan&amp; span = m_grid.gridItemSpan(child, direction);
1598     // FIXME (lajava): This is a common pattern, why not defining a function like
1599     // positions(direction) ?
1600     auto&amp; positions = direction == ForColumns ? m_columnPositions : m_rowPositions;
1601     start = positions[span.startLine()];
1602     end = positions[span.endLine()];
1603     // The &#39;positions&#39; vector includes distribution offset (because of content
1604     // alignment) and gutters so we need to subtract them to get the actual
1605     // end position for a given track (this does not have to be done for the
1606     // last track as there are no more positions&#39;s elements after it, nor for
1607     // collapsed tracks).
1608     if (span.endLine() &lt; positions.size() - 1
1609         &amp;&amp; !(m_grid.hasAutoRepeatEmptyTracks(direction)
1610         &amp;&amp; m_grid.isEmptyAutoRepeatTrack(direction, span.endLine()))) {
1611         end -= gridGap(direction) + gridItemOffset(direction);
1612     }
1613 }
1614 
1615 void RenderGrid::gridAreaPositionForChild(const RenderBox&amp; child, GridTrackSizingDirection direction, LayoutUnit&amp; start, LayoutUnit&amp; end) const
1616 {
1617     if (child.isOutOfFlowPositioned())
1618         gridAreaPositionForOutOfFlowChild(child, direction, start, end);
1619     else
1620         gridAreaPositionForInFlowChild(child, direction, start, end);
1621 }
1622 
1623 ContentPosition static resolveContentDistributionFallback(ContentDistribution distribution)
1624 {
1625     switch (distribution) {
1626     case ContentDistribution::SpaceBetween:
1627         return ContentPosition::Start;
1628     case ContentDistribution::SpaceAround:
1629         return ContentPosition::Center;
1630     case ContentDistribution::SpaceEvenly:
1631         return ContentPosition::Center;
1632     case ContentDistribution::Stretch:
1633         return ContentPosition::Start;
1634     case ContentDistribution::Default:
1635         return ContentPosition::Normal;
1636     }
1637 
1638     ASSERT_NOT_REACHED();
1639     return ContentPosition::Normal;
1640 }
1641 
1642 static void contentDistributionOffset(ContentAlignmentData&amp; offset, const LayoutUnit&amp; availableFreeSpace, ContentPosition&amp; fallbackPosition, ContentDistribution distribution, unsigned numberOfGridTracks)
1643 {
1644     if (distribution != ContentDistribution::Default &amp;&amp; fallbackPosition == ContentPosition::Normal)
1645         fallbackPosition = resolveContentDistributionFallback(distribution);
1646 
1647     // Initialize to an invalid offset.
1648     offset.positionOffset = -1_lu;
1649     offset.distributionOffset = -1_lu;
1650     if (availableFreeSpace &lt;= 0)
1651         return;
1652 
1653     LayoutUnit positionOffset;
1654     LayoutUnit distributionOffset;
1655     switch (distribution) {
1656     case ContentDistribution::SpaceBetween:
1657         if (numberOfGridTracks &lt; 2)
1658             return;
1659         distributionOffset = availableFreeSpace / (numberOfGridTracks - 1);
1660         positionOffset = 0_lu;
1661         break;
1662     case ContentDistribution::SpaceAround:
1663         if (numberOfGridTracks &lt; 1)
1664             return;
1665         distributionOffset = availableFreeSpace / numberOfGridTracks;
1666         positionOffset = distributionOffset / 2;
1667         break;
1668     case ContentDistribution::SpaceEvenly:
1669         distributionOffset = availableFreeSpace / (numberOfGridTracks + 1);
1670         positionOffset = distributionOffset;
1671         break;
1672     case ContentDistribution::Stretch:
1673     case ContentDistribution::Default:
1674         return;
1675     default:
1676         ASSERT_NOT_REACHED();
1677         return;
1678     }
1679 
1680     offset.positionOffset = positionOffset;
1681     offset.distributionOffset = distributionOffset;
1682 }
1683 
1684 StyleContentAlignmentData RenderGrid::contentAlignment(GridTrackSizingDirection direction) const
1685 {
1686     return direction == ForColumns ? style().resolvedJustifyContent(contentAlignmentNormalBehaviorGrid()) : style().resolvedAlignContent(contentAlignmentNormalBehaviorGrid());
1687 }
1688 
1689 void RenderGrid::computeContentPositionAndDistributionOffset(GridTrackSizingDirection direction, const LayoutUnit&amp; availableFreeSpace, unsigned numberOfGridTracks)
1690 {
1691     bool isRowAxis = direction == ForColumns;
1692     auto&amp; offset =
1693         isRowAxis ? m_offsetBetweenColumns : m_offsetBetweenRows;
1694     auto contentAlignmentData = contentAlignment(direction);
1695     auto position = contentAlignmentData.position();
1696     // If &lt;content-distribution&gt; value can&#39;t be applied, &#39;position&#39; will become the associated
1697     // &lt;content-position&gt; fallback value.
1698     contentDistributionOffset(offset, availableFreeSpace, position, contentAlignmentData.distribution(), numberOfGridTracks);
1699     if (offset.isValid())
1700         return;
1701 
1702     if (availableFreeSpace &lt;= 0 &amp;&amp; contentAlignmentData.overflow() == OverflowAlignment::Safe) {
1703         offset.positionOffset = 0_lu;
1704         offset.distributionOffset = 0_lu;
1705         return;
1706     }
1707 
1708     LayoutUnit positionOffset;
1709     switch (position) {
1710     case ContentPosition::Left:
1711         ASSERT(isRowAxis);
1712         break;
1713     case ContentPosition::Right:
1714         ASSERT(isRowAxis);
1715         positionOffset = availableFreeSpace;
1716         break;
1717     case ContentPosition::Center:
1718         positionOffset = availableFreeSpace / 2;
1719         break;
1720     case ContentPosition::FlexEnd: // Only used in flex layout, for other layout, it&#39;s equivalent to &#39;end&#39;.
1721     case ContentPosition::End:
1722         if (isRowAxis)
1723             positionOffset = style().isLeftToRightDirection() ? availableFreeSpace : 0_lu;
1724         else
1725             positionOffset = availableFreeSpace;
1726         break;
1727     case ContentPosition::FlexStart: // Only used in flex layout, for other layout, it&#39;s equivalent to &#39;start&#39;.
1728     case ContentPosition::Start:
1729         if (isRowAxis)
1730             positionOffset = style().isLeftToRightDirection() ? 0_lu : availableFreeSpace;
1731         break;
1732     case ContentPosition::Baseline:
1733     case ContentPosition::LastBaseline:
1734         // FIXME: Implement the previous values. For now, we always &#39;start&#39; align.
1735         // http://webkit.org/b/145566
1736         if (isRowAxis)
1737             positionOffset = style().isLeftToRightDirection() ? 0_lu : availableFreeSpace;
1738         break;
1739     case ContentPosition::Normal:
1740     default:
1741         ASSERT_NOT_REACHED();
1742         return;
1743     }
1744 
1745     offset.positionOffset = positionOffset;
1746     offset.distributionOffset = 0_lu;
1747 }
1748 
1749 LayoutUnit RenderGrid::translateOutOfFlowRTLCoordinate(const RenderBox&amp; child, LayoutUnit coordinate) const
1750 {
1751     ASSERT(child.isOutOfFlowPositioned());
1752     ASSERT(!style().isLeftToRightDirection());
1753 
1754     if (m_outOfFlowItemColumn.get(&amp;child))
1755         return translateRTLCoordinate(coordinate);
1756 
1757     return borderLogicalLeft() + borderLogicalRight() + clientLogicalWidth() - coordinate;
1758 }
1759 
1760 LayoutUnit RenderGrid::translateRTLCoordinate(LayoutUnit coordinate) const
1761 {
1762     ASSERT(!style().isLeftToRightDirection());
1763 
1764     LayoutUnit alignmentOffset = m_columnPositions[0];
1765     LayoutUnit rightGridEdgePosition = m_columnPositions[m_columnPositions.size() - 1];
1766     return rightGridEdgePosition + alignmentOffset - coordinate;
1767 }
1768 
1769 // FIXME: SetLogicalPositionForChild has only one caller, consider its refactoring in the future.
1770 void RenderGrid::setLogicalPositionForChild(RenderBox&amp; child) const
1771 {
1772     // &quot;In the positioning phase [...] calculations are performed according to the writing mode of the containing block of the box establishing the
1773     // orthogonal flow.&quot; However, &#39;setLogicalLocation&#39; will only take into account the child&#39;s writing-mode, so the position may need to be transposed.
1774     LayoutPoint childLocation(logicalOffsetForChild(child, ForColumns), logicalOffsetForChild(child, ForRows));
1775     child.setLogicalLocation(GridLayoutFunctions::isOrthogonalChild(*this, child) ? childLocation.transposedPoint() : childLocation);
1776 }
1777 
1778 void RenderGrid::setLogicalOffsetForChild(RenderBox&amp; child, GridTrackSizingDirection direction) const
1779 {
1780     if (!child.isGridItem() &amp;&amp; hasStaticPositionForChild(child, direction))
1781         return;
1782     // &#39;setLogicalLeft&#39; and &#39;setLogicalTop&#39; only take into account the child&#39;s writing-mode, that&#39;s why &#39;flowAwareDirectionForChild&#39; is needed.
1783     if (GridLayoutFunctions::flowAwareDirectionForChild(*this, child, direction) == ForColumns)
1784         child.setLogicalLeft(logicalOffsetForChild(child, direction));
1785     else
1786         child.setLogicalTop(logicalOffsetForChild(child, direction));
1787 }
1788 
1789 LayoutUnit RenderGrid::logicalOffsetForChild(const RenderBox&amp; child, GridTrackSizingDirection direction) const
1790 {
1791     if (direction == ForRows)
1792         return columnAxisOffsetForChild(child);
1793     LayoutUnit rowAxisOffset = rowAxisOffsetForChild(child);
1794     // We stored m_columnPositions&#39;s data ignoring the direction, hence we might need now
1795     // to translate positions from RTL to LTR, as it&#39;s more convenient for painting.
1796     if (!style().isLeftToRightDirection())
1797         rowAxisOffset = (child.isOutOfFlowPositioned() ? translateOutOfFlowRTLCoordinate(child, rowAxisOffset) : translateRTLCoordinate(rowAxisOffset)) - (GridLayoutFunctions::isOrthogonalChild(*this, child) ? child.logicalHeight()  : child.logicalWidth());
1798     return rowAxisOffset;
1799 }
1800 
1801 unsigned RenderGrid::nonCollapsedTracks(GridTrackSizingDirection direction) const
1802 {
1803     auto&amp; tracks = m_trackSizingAlgorithm.tracks(direction);
1804     size_t numberOfTracks = tracks.size();
1805     bool hasCollapsedTracks = m_grid.hasAutoRepeatEmptyTracks(direction);
1806     size_t numberOfCollapsedTracks = hasCollapsedTracks ? m_grid.autoRepeatEmptyTracks(direction)-&gt;size() : 0;
1807     return numberOfTracks - numberOfCollapsedTracks;
1808 }
1809 
1810 unsigned RenderGrid::numTracks(GridTrackSizingDirection direction, const Grid&amp; grid) const
1811 {
1812     // Due to limitations in our internal representation, we cannot know the number of columns from
1813     // m_grid *if* there is no row (because m_grid would be empty). That&#39;s why in that case we need
1814     // to get it from the style. Note that we know for sure that there are&#39;t any implicit tracks,
1815     // because not having rows implies that there are no &quot;normal&quot; children (out-of-flow children are
1816     // not stored in m_grid).
1817     ASSERT(!grid.needsItemsPlacement());
1818     if (direction == ForRows)
1819         return grid.numTracks(ForRows);
1820 
1821     // FIXME: This still requires knowledge about m_grid internals.
1822     return grid.numTracks(ForRows) ? grid.numTracks(ForColumns) : GridPositionsResolver::explicitGridColumnCount(style(), grid.autoRepeatTracks(ForColumns));
1823 }
1824 
1825 void RenderGrid::paintChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; forChild, bool usePrintRect)
1826 {
1827     ASSERT(!m_grid.needsItemsPlacement());
1828     for (RenderBox* child = m_grid.orderIterator().first(); child; child = m_grid.orderIterator().next())
1829         paintChild(*child, paintInfo, paintOffset, forChild, usePrintRect, PaintAsInlineBlock);
1830 }
1831 
1832 const char* RenderGrid::renderName() const
1833 {
1834     if (isFloating())
1835         return &quot;RenderGrid (floating)&quot;;
1836     if (isOutOfFlowPositioned())
1837         return &quot;RenderGrid (positioned)&quot;;
1838     if (isAnonymous())
1839         return &quot;RenderGrid (generated)&quot;;
1840     if (isRelativelyPositioned())
1841         return &quot;RenderGrid (relative positioned)&quot;;
1842     return &quot;RenderGrid&quot;;
1843 }
1844 
1845 } // namespace WebCore
    </pre>
  </body>
</html>
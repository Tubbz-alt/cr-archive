<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPropertyParser.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParserHelpers.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,37 ***</span>
  
  class CSSProperty;
  class CSSValue;
  class StylePropertyShorthand;
  class StyleSheetContents;
<span class="line-modified">! class StyleResolver;</span>
  
  // Inputs: PropertyID, isImportant bool, CSSParserTokenRange.
  // Outputs: Vector of CSSProperties
  
  class CSSPropertyParser {
      WTF_MAKE_NONCOPYABLE(CSSPropertyParser);
  public:
      static bool parseValue(CSSPropertyID, bool important,
          const CSSParserTokenRange&amp;, const CSSParserContext&amp;,
<span class="line-modified">!         Vector&lt;CSSProperty, 256&gt;&amp;, StyleRule::Type);</span>
  
      // Parses a non-shorthand CSS property
      static RefPtr&lt;CSSValue&gt; parseSingleValue(CSSPropertyID, const CSSParserTokenRange&amp;, const CSSParserContext&amp;);
      static bool canParseTypedCustomPropertyValue(const String&amp; syntax, const CSSParserTokenRange&amp;, const CSSParserContext&amp;);
<span class="line-modified">!     static RefPtr&lt;CSSCustomPropertyValue&gt; parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp;, const StyleResolver&amp;, const CSSParserContext&amp;);</span>
      static void collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp;, const CSSParserContext&amp;);
  
  private:
      CSSPropertyParser(const CSSParserTokenRange&amp;, const CSSParserContext&amp;, Vector&lt;CSSProperty, 256&gt;*, bool consumeWhitespace = true);
  
      // FIXME: Rename once the CSSParserValue-based parseValue is removed
      bool parseValueStart(CSSPropertyID, bool important);
      bool consumeCSSWideKeyword(CSSPropertyID, bool important);
      RefPtr&lt;CSSValue&gt; parseSingleValue(CSSPropertyID, CSSPropertyID = CSSPropertyInvalid);
      bool canParseTypedCustomPropertyValue(const String&amp; syntax);
<span class="line-modified">!     RefPtr&lt;CSSCustomPropertyValue&gt; parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const StyleResolver&amp;);</span>
      void collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies);
  
      bool inQuirksMode() const { return m_context.mode == HTMLQuirksMode; }
  
      bool parseViewportDescriptor(CSSPropertyID propId, bool important);
<span class="line-new-header">--- 30,40 ---</span>
  
  class CSSProperty;
  class CSSValue;
  class StylePropertyShorthand;
  class StyleSheetContents;
<span class="line-modified">! </span>
<span class="line-added">+ namespace Style {</span>
<span class="line-added">+ class BuilderState;</span>
<span class="line-added">+ }</span>
  
  // Inputs: PropertyID, isImportant bool, CSSParserTokenRange.
  // Outputs: Vector of CSSProperties
  
  class CSSPropertyParser {
      WTF_MAKE_NONCOPYABLE(CSSPropertyParser);
  public:
      static bool parseValue(CSSPropertyID, bool important,
          const CSSParserTokenRange&amp;, const CSSParserContext&amp;,
<span class="line-modified">!         Vector&lt;CSSProperty, 256&gt;&amp;, StyleRuleType);</span>
  
      // Parses a non-shorthand CSS property
      static RefPtr&lt;CSSValue&gt; parseSingleValue(CSSPropertyID, const CSSParserTokenRange&amp;, const CSSParserContext&amp;);
      static bool canParseTypedCustomPropertyValue(const String&amp; syntax, const CSSParserTokenRange&amp;, const CSSParserContext&amp;);
<span class="line-modified">!     static RefPtr&lt;CSSCustomPropertyValue&gt; parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp;, const Style::BuilderState&amp;, const CSSParserContext&amp;);</span>
      static void collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp;, const CSSParserContext&amp;);
  
  private:
      CSSPropertyParser(const CSSParserTokenRange&amp;, const CSSParserContext&amp;, Vector&lt;CSSProperty, 256&gt;*, bool consumeWhitespace = true);
  
      // FIXME: Rename once the CSSParserValue-based parseValue is removed
      bool parseValueStart(CSSPropertyID, bool important);
      bool consumeCSSWideKeyword(CSSPropertyID, bool important);
      RefPtr&lt;CSSValue&gt; parseSingleValue(CSSPropertyID, CSSPropertyID = CSSPropertyInvalid);
      bool canParseTypedCustomPropertyValue(const String&amp; syntax);
<span class="line-modified">!     RefPtr&lt;CSSCustomPropertyValue&gt; parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const Style::BuilderState&amp;);</span>
      void collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies);
  
      bool inQuirksMode() const { return m_context.mode == HTMLQuirksMode; }
  
      bool parseViewportDescriptor(CSSPropertyID propId, bool important);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,10 ***</span>
<span class="line-new-header">--- 80,11 ---</span>
      bool consume4ValueShorthand(const StylePropertyShorthand&amp;, bool important);
  
      // Legacy parsing allows &lt;string&gt;s for animation-name
      bool consumeAnimationShorthand(const StylePropertyShorthand&amp;, bool important);
      bool consumeBackgroundShorthand(const StylePropertyShorthand&amp;, bool important);
<span class="line-added">+     bool consumeOverflowShorthand(bool important);</span>
  
      bool consumeColumns(bool important);
  
      bool consumeGridItemPositionShorthand(CSSPropertyID, bool important);
      bool consumeGridTemplateRowsAndAreasAndColumns(CSSPropertyID, bool important);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,11 ***</span>
      // Outputs:
      Vector&lt;CSSProperty, 256&gt;* m_parsedProperties;
  };
  
  CSSPropertyID cssPropertyID(StringView);
<span class="line-modified">! CSSValueID cssValueKeywordID(StringView);</span>
  bool isCustomPropertyName(const String&amp;);
  
  #if PLATFORM(IOS_FAMILY)
  void cssPropertyNameIOSAliasing(const char* propertyName, const char*&amp; propertyNameAlias, unsigned&amp; newLength);
  #endif
<span class="line-new-header">--- 120,11 ---</span>
      // Outputs:
      Vector&lt;CSSProperty, 256&gt;* m_parsedProperties;
  };
  
  CSSPropertyID cssPropertyID(StringView);
<span class="line-modified">! WEBCORE_EXPORT CSSValueID cssValueKeywordID(StringView);</span>
  bool isCustomPropertyName(const String&amp;);
  
  #if PLATFORM(IOS_FAMILY)
  void cssPropertyNameIOSAliasing(const char* propertyName, const char*&amp; propertyNameAlias, unsigned&amp; newLength);
  #endif
</pre>
<center><a href="CSSPropertyParser.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParserHelpers.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
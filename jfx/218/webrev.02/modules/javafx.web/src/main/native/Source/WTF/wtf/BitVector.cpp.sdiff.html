<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/BitVector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Bag.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BitVector.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/BitVector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &lt;wtf/BitVector.h&gt;
 28 
 29 #include &lt;algorithm&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;wtf/Assertions.h&gt;
 32 #include &lt;wtf/FastMalloc.h&gt;

 33 #include &lt;wtf/StdLibExtras.h&gt;
 34 
 35 namespace WTF {
 36 




 37 void BitVector::setSlow(const BitVector&amp; other)
 38 {
 39     uintptr_t newBitsOrPointer;
 40     if (other.isInline() || other.isEmptyOrDeletedValue())
 41         newBitsOrPointer = other.m_bitsOrPointer;
 42     else {
 43         OutOfLineBits* newOutOfLineBits = OutOfLineBits::create(other.size());
 44         memcpy(newOutOfLineBits-&gt;bits(), other.bits(), byteCount(other.size()));
 45         newBitsOrPointer = bitwise_cast&lt;uintptr_t&gt;(newOutOfLineBits) &gt;&gt; 1;
 46     }
 47     if (!isInline() &amp;&amp; !isEmptyOrDeletedValue())
 48         OutOfLineBits::destroy(outOfLineBits());
 49     m_bitsOrPointer = newBitsOrPointer;
 50 }
 51 
 52 void BitVector::resize(size_t numBits)
 53 {
 54     if (numBits &lt;= maxInlineBits()) {
 55         if (isInline())
 56             return;
</pre>
<hr />
<pre>
 59         m_bitsOrPointer = makeInlineBits(*myOutOfLineBits-&gt;bits());
 60         OutOfLineBits::destroy(myOutOfLineBits);
 61         return;
 62     }
 63 
 64     resizeOutOfLine(numBits);
 65 }
 66 
 67 void BitVector::clearAll()
 68 {
 69     if (isInline())
 70         m_bitsOrPointer = makeInlineBits(0);
 71     else
 72         memset(outOfLineBits()-&gt;bits(), 0, byteCount(size()));
 73 }
 74 
 75 BitVector::OutOfLineBits* BitVector::OutOfLineBits::create(size_t numBits)
 76 {
 77     numBits = (numBits + bitsInPointer() - 1) &amp; ~(static_cast&lt;size_t&gt;(bitsInPointer()) - 1);
 78     size_t size = sizeof(OutOfLineBits) + sizeof(uintptr_t) * (numBits / bitsInPointer());
<span class="line-modified"> 79     OutOfLineBits* result = new (NotNull, fastMalloc(size)) OutOfLineBits(numBits);</span>
 80     return result;
 81 }
 82 
 83 void BitVector::OutOfLineBits::destroy(OutOfLineBits* outOfLineBits)
 84 {
<span class="line-modified"> 85     fastFree(outOfLineBits);</span>
 86 }
 87 
 88 void BitVector::resizeOutOfLine(size_t numBits)
 89 {
 90     ASSERT(numBits &gt; maxInlineBits());
 91     OutOfLineBits* newOutOfLineBits = OutOfLineBits::create(numBits);
 92     size_t newNumWords = newOutOfLineBits-&gt;numWords();
 93     if (isInline()) {
 94         // Make sure that all of the bits are zero in case we do a no-op resize.
 95         *newOutOfLineBits-&gt;bits() = m_bitsOrPointer &amp; ~(static_cast&lt;uintptr_t&gt;(1) &lt;&lt; maxInlineBits());
 96         memset(newOutOfLineBits-&gt;bits() + 1, 0, (newNumWords - 1) * sizeof(void*));
 97     } else {
 98         if (numBits &gt; size()) {
 99             size_t oldNumWords = outOfLineBits()-&gt;numWords();
100             memcpy(newOutOfLineBits-&gt;bits(), outOfLineBits()-&gt;bits(), oldNumWords * sizeof(void*));
101             memset(newOutOfLineBits-&gt;bits() + oldNumWords, 0, (newNumWords - oldNumWords) * sizeof(void*));
102         } else
103             memcpy(newOutOfLineBits-&gt;bits(), outOfLineBits()-&gt;bits(), newOutOfLineBits-&gt;numWords() * sizeof(void*));
104         OutOfLineBits::destroy(outOfLineBits());
105     }
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &lt;wtf/BitVector.h&gt;
 28 
 29 #include &lt;algorithm&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;wtf/Assertions.h&gt;
 32 #include &lt;wtf/FastMalloc.h&gt;
<span class="line-added"> 33 #include &lt;wtf/NeverDestroyed.h&gt;</span>
 34 #include &lt;wtf/StdLibExtras.h&gt;
 35 
 36 namespace WTF {
 37 
<span class="line-added"> 38 </span>
<span class="line-added"> 39 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BitVector);</span>
<span class="line-added"> 40 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BitVector);</span>
<span class="line-added"> 41 </span>
 42 void BitVector::setSlow(const BitVector&amp; other)
 43 {
 44     uintptr_t newBitsOrPointer;
 45     if (other.isInline() || other.isEmptyOrDeletedValue())
 46         newBitsOrPointer = other.m_bitsOrPointer;
 47     else {
 48         OutOfLineBits* newOutOfLineBits = OutOfLineBits::create(other.size());
 49         memcpy(newOutOfLineBits-&gt;bits(), other.bits(), byteCount(other.size()));
 50         newBitsOrPointer = bitwise_cast&lt;uintptr_t&gt;(newOutOfLineBits) &gt;&gt; 1;
 51     }
 52     if (!isInline() &amp;&amp; !isEmptyOrDeletedValue())
 53         OutOfLineBits::destroy(outOfLineBits());
 54     m_bitsOrPointer = newBitsOrPointer;
 55 }
 56 
 57 void BitVector::resize(size_t numBits)
 58 {
 59     if (numBits &lt;= maxInlineBits()) {
 60         if (isInline())
 61             return;
</pre>
<hr />
<pre>
 64         m_bitsOrPointer = makeInlineBits(*myOutOfLineBits-&gt;bits());
 65         OutOfLineBits::destroy(myOutOfLineBits);
 66         return;
 67     }
 68 
 69     resizeOutOfLine(numBits);
 70 }
 71 
 72 void BitVector::clearAll()
 73 {
 74     if (isInline())
 75         m_bitsOrPointer = makeInlineBits(0);
 76     else
 77         memset(outOfLineBits()-&gt;bits(), 0, byteCount(size()));
 78 }
 79 
 80 BitVector::OutOfLineBits* BitVector::OutOfLineBits::create(size_t numBits)
 81 {
 82     numBits = (numBits + bitsInPointer() - 1) &amp; ~(static_cast&lt;size_t&gt;(bitsInPointer()) - 1);
 83     size_t size = sizeof(OutOfLineBits) + sizeof(uintptr_t) * (numBits / bitsInPointer());
<span class="line-modified"> 84     OutOfLineBits* result = new (NotNull, BitVectorMalloc::malloc(size)) OutOfLineBits(numBits);</span>
 85     return result;
 86 }
 87 
 88 void BitVector::OutOfLineBits::destroy(OutOfLineBits* outOfLineBits)
 89 {
<span class="line-modified"> 90     BitVectorMalloc::free(outOfLineBits);</span>
 91 }
 92 
 93 void BitVector::resizeOutOfLine(size_t numBits)
 94 {
 95     ASSERT(numBits &gt; maxInlineBits());
 96     OutOfLineBits* newOutOfLineBits = OutOfLineBits::create(numBits);
 97     size_t newNumWords = newOutOfLineBits-&gt;numWords();
 98     if (isInline()) {
 99         // Make sure that all of the bits are zero in case we do a no-op resize.
100         *newOutOfLineBits-&gt;bits() = m_bitsOrPointer &amp; ~(static_cast&lt;uintptr_t&gt;(1) &lt;&lt; maxInlineBits());
101         memset(newOutOfLineBits-&gt;bits() + 1, 0, (newNumWords - 1) * sizeof(void*));
102     } else {
103         if (numBits &gt; size()) {
104             size_t oldNumWords = outOfLineBits()-&gt;numWords();
105             memcpy(newOutOfLineBits-&gt;bits(), outOfLineBits()-&gt;bits(), oldNumWords * sizeof(void*));
106             memset(newOutOfLineBits-&gt;bits() + oldNumWords, 0, (newNumWords - oldNumWords) * sizeof(void*));
107         } else
108             memcpy(newOutOfLineBits-&gt;bits(), outOfLineBits()-&gt;bits(), newOutOfLineBits-&gt;numWords() * sizeof(void*));
109         OutOfLineBits::destroy(outOfLineBits());
110     }
</pre>
</td>
</tr>
</table>
<center><a href="Bag.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BitVector.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
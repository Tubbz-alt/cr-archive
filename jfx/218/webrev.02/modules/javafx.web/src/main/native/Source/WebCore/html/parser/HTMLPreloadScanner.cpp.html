<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLPreloadScanner.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008, 2014 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2009 Torch Mobile, Inc. http://www.torchmobile.com/
  4  * Copyright (C) 2010 Google Inc. All Rights Reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;HTMLPreloadScanner.h&quot;
 30 
 31 #include &quot;HTMLNames.h&quot;
 32 #include &quot;HTMLParserIdioms.h&quot;
 33 #include &quot;HTMLSrcsetParser.h&quot;
 34 #include &quot;HTMLTokenizer.h&quot;
 35 #include &quot;InputTypeNames.h&quot;
 36 #include &quot;LinkLoader.h&quot;
 37 #include &quot;LinkRelAttribute.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MIMETypeRegistry.h&quot;
 40 #include &quot;MediaList.h&quot;
 41 #include &quot;MediaQueryEvaluator.h&quot;
 42 #include &quot;MediaQueryParser.h&quot;
 43 #include &quot;RenderView.h&quot;
 44 #include &quot;RuntimeEnabledFeatures.h&quot;
 45 #include &quot;SecurityPolicy.h&quot;
 46 #include &quot;Settings.h&quot;
 47 #include &quot;SizesAttributeParser.h&quot;
 48 #include &lt;wtf/MainThread.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 using namespace HTMLNames;
 53 
 54 TokenPreloadScanner::TagId TokenPreloadScanner::tagIdFor(const HTMLToken::DataVector&amp; data)
 55 {
 56     AtomString tagName(data);
 57     if (tagName == imgTag)
 58         return TagId::Img;
 59     if (tagName == inputTag)
 60         return TagId::Input;
 61     if (tagName == linkTag)
 62         return TagId::Link;
 63     if (tagName == scriptTag)
 64         return TagId::Script;
 65     if (tagName == styleTag)
 66         return TagId::Style;
 67     if (tagName == baseTag)
 68         return TagId::Base;
 69     if (tagName == templateTag)
 70         return TagId::Template;
 71     if (tagName == metaTag)
 72         return TagId::Meta;
 73     if (tagName == pictureTag)
 74         return TagId::Picture;
 75     if (tagName == sourceTag)
 76         return TagId::Source;
 77     return TagId::Unknown;
 78 }
 79 
 80 String TokenPreloadScanner::initiatorFor(TagId tagId)
 81 {
 82     switch (tagId) {
 83     case TagId::Source:
 84     case TagId::Img:
 85         return &quot;img&quot;_s;
 86     case TagId::Input:
 87         return &quot;input&quot;_s;
 88     case TagId::Link:
 89         return &quot;link&quot;_s;
 90     case TagId::Script:
 91         return &quot;script&quot;_s;
 92     case TagId::Unknown:
 93     case TagId::Style:
 94     case TagId::Base:
 95     case TagId::Template:
 96     case TagId::Meta:
 97     case TagId::Picture:
 98         ASSERT_NOT_REACHED();
 99         return &quot;unknown&quot;_s;
100     }
101     ASSERT_NOT_REACHED();
102     return &quot;unknown&quot;_s;
103 }
104 
105 class TokenPreloadScanner::StartTagScanner {
106 public:
107     explicit StartTagScanner(TagId tagId, float deviceScaleFactor = 1.0)
108         : m_tagId(tagId)
109         , m_linkIsStyleSheet(false)
110         , m_linkIsPreload(false)
111         , m_metaIsViewport(false)
112         , m_metaIsDisabledAdaptations(false)
113         , m_inputIsImage(false)
114         , m_deviceScaleFactor(deviceScaleFactor)
115     {
116     }
117 
118     void processAttributes(const HTMLToken::AttributeList&amp; attributes, Document&amp; document, Vector&lt;bool&gt;&amp; pictureState)
119     {
120         ASSERT(isMainThread());
121         if (m_tagId &gt;= TagId::Unknown)
122             return;
123 
124         for (auto&amp; attribute : attributes) {
125             AtomString attributeName(attribute.name);
126             String attributeValue = StringImpl::create8BitIfPossible(attribute.value);
127             processAttribute(attributeName, attributeValue, document, pictureState);
128         }
129 
130         if (m_tagId == TagId::Source &amp;&amp; !pictureState.isEmpty() &amp;&amp; !pictureState.last() &amp;&amp; m_mediaMatched &amp;&amp; m_typeMatched &amp;&amp; !m_srcSetAttribute.isEmpty()) {
131 
132             auto sourceSize = SizesAttributeParser(m_sizesAttribute, document).length();
133             ImageCandidate imageCandidate = bestFitSourceForImageAttributes(m_deviceScaleFactor, m_urlToLoad, m_srcSetAttribute, sourceSize);
134             if (!imageCandidate.isEmpty()) {
135                 pictureState.last() = true;
136                 setUrlToLoad(imageCandidate.string.toString(), true);
137             }
138         }
139 
140         // Resolve between src and srcSet if we have them and the tag is img.
141         if (m_tagId == TagId::Img &amp;&amp; !m_srcSetAttribute.isEmpty()) {
142             auto sourceSize = SizesAttributeParser(m_sizesAttribute, document).length();
143             ImageCandidate imageCandidate = bestFitSourceForImageAttributes(m_deviceScaleFactor, m_urlToLoad, m_srcSetAttribute, sourceSize);
144             setUrlToLoad(imageCandidate.string.toString(), true);
145         }
146 
147         if (m_metaIsViewport &amp;&amp; !m_metaContent.isNull())
148             document.processViewport(m_metaContent, ViewportArguments::ViewportMeta);
149 
150         if (m_metaIsDisabledAdaptations &amp;&amp; !m_metaContent.isNull())
151             document.processDisabledAdaptations(m_metaContent);
152     }
153 
154     std::unique_ptr&lt;PreloadRequest&gt; createPreloadRequest(const URL&amp; predictedBaseURL)
155     {
156         if (!shouldPreload())
157             return nullptr;
158 
159         auto type = resourceType();
160         if (!type)
161             return nullptr;
162 
163         if (!LinkLoader::isSupportedType(type.value(), m_typeAttribute))
164             return nullptr;
165 
166         auto request = makeUnique&lt;PreloadRequest&gt;(initiatorFor(m_tagId), m_urlToLoad, predictedBaseURL, type.value(), m_mediaAttribute, m_moduleScript, m_referrerPolicy);
167         request-&gt;setCrossOriginMode(m_crossOriginMode);
168         request-&gt;setNonce(m_nonceAttribute);
169 
170         // According to the spec, the module tag ignores the &quot;charset&quot; attribute as the same to the worker&#39;s
171         // importScript. But WebKit supports the &quot;charset&quot; for importScript intentionally. So to be consistent,
172         // even for the module tags, we handle the &quot;charset&quot; attribute.
173         request-&gt;setCharset(charset());
174         return request;
175     }
176 
177     static bool match(const AtomString&amp; name, const QualifiedName&amp; qName)
178     {
179         ASSERT(isMainThread());
180         return qName.localName() == name;
181     }
182 
183 private:
184     void processImageAndScriptAttribute(const AtomString&amp; attributeName, const String&amp; attributeValue)
185     {
186         if (match(attributeName, srcAttr))
187             setUrlToLoad(attributeValue);
188         else if (match(attributeName, crossoriginAttr))
189             m_crossOriginMode = stripLeadingAndTrailingHTMLSpaces(attributeValue);
190         else if (match(attributeName, charsetAttr))
191             m_charset = attributeValue;
192     }
193 
194     void processAttribute(const AtomString&amp; attributeName, const String&amp; attributeValue, Document&amp; document, const Vector&lt;bool&gt;&amp; pictureState)
195     {
196         bool inPicture = !pictureState.isEmpty();
197         bool alreadyMatchedSource = inPicture &amp;&amp; pictureState.last();
198 
199         switch (m_tagId) {
200         case TagId::Img:
201             if (inPicture &amp;&amp; alreadyMatchedSource)
202                 break;
203             if (match(attributeName, srcsetAttr) &amp;&amp; m_srcSetAttribute.isNull()) {
204                 m_srcSetAttribute = attributeValue;
205                 break;
206             }
207             if (match(attributeName, sizesAttr) &amp;&amp; m_sizesAttribute.isNull()) {
208                 m_sizesAttribute = attributeValue;
209                 break;
210             }
211             processImageAndScriptAttribute(attributeName, attributeValue);
212             break;
213         case TagId::Source:
214             if (inPicture &amp;&amp; alreadyMatchedSource)
215                 break;
216             if (match(attributeName, srcsetAttr) &amp;&amp; m_srcSetAttribute.isNull()) {
217                 m_srcSetAttribute = attributeValue;
218                 break;
219             }
220             if (match(attributeName, sizesAttr) &amp;&amp; m_sizesAttribute.isNull()) {
221                 m_sizesAttribute = attributeValue;
222                 break;
223             }
224             if (match(attributeName, mediaAttr) &amp;&amp; m_mediaAttribute.isNull()) {
225                 m_mediaAttribute = attributeValue;
226                 auto mediaSet = MediaQuerySet::create(attributeValue, MediaQueryParserContext(document));
227                 auto documentElement = makeRefPtr(document.documentElement());
228                 LOG(MediaQueries, &quot;HTMLPreloadScanner %p processAttribute evaluating media queries&quot;, this);
229                 m_mediaMatched = MediaQueryEvaluator { document.printing() ? &quot;print&quot; : &quot;screen&quot;, document, documentElement ? documentElement-&gt;computedStyle() : nullptr }.evaluate(mediaSet.get());
230             }
231             if (match(attributeName, typeAttr) &amp;&amp; m_typeAttribute.isNull()) {
232                 // when multiple type attributes present: first value wins, ignore subsequent (to match ImageElement parser and Blink behaviours)
233                 m_typeAttribute = attributeValue;
234                 m_typeMatched &amp;= MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(m_typeAttribute);
235             }
236             break;
237         case TagId::Script:
238             if (match(attributeName, typeAttr)) {
239                 m_moduleScript = equalLettersIgnoringASCIICase(attributeValue, &quot;module&quot;) ? PreloadRequest::ModuleScript::Yes : PreloadRequest::ModuleScript::No;
240                 break;
241             } else if (match(attributeName, nonceAttr)) {
242                 m_nonceAttribute = attributeValue;
243                 break;
244             } else if (match(attributeName, referrerpolicyAttr)) {
245                 m_referrerPolicy = parseReferrerPolicy(attributeValue, ReferrerPolicySource::ReferrerPolicyAttribute).valueOr(ReferrerPolicy::EmptyString);
246                 break;
247             } else if (match(attributeName, nomoduleAttr)) {
248                 m_scriptIsNomodule = true;
249                 break;
250             }
251             processImageAndScriptAttribute(attributeName, attributeValue);
252             break;
253         case TagId::Link:
254             if (match(attributeName, hrefAttr))
255                 setUrlToLoad(attributeValue);
256             else if (match(attributeName, relAttr)) {
257                 LinkRelAttribute parsedAttribute { document, attributeValue };
258                 m_linkIsStyleSheet = relAttributeIsStyleSheet(parsedAttribute);
259                 m_linkIsPreload = parsedAttribute.isLinkPreload;
260             } else if (match(attributeName, mediaAttr))
261                 m_mediaAttribute = attributeValue;
262             else if (match(attributeName, charsetAttr))
263                 m_charset = attributeValue;
264             else if (match(attributeName, crossoriginAttr))
265                 m_crossOriginMode = stripLeadingAndTrailingHTMLSpaces(attributeValue);
266             else if (match(attributeName, nonceAttr))
267                 m_nonceAttribute = attributeValue;
268             else if (match(attributeName, asAttr))
269                 m_asAttribute = attributeValue;
270             else if (match(attributeName, typeAttr))
271                 m_typeAttribute = attributeValue;
272             break;
273         case TagId::Input:
274             if (match(attributeName, srcAttr))
275                 setUrlToLoad(attributeValue);
276             else if (match(attributeName, typeAttr))
277                 m_inputIsImage = equalLettersIgnoringASCIICase(attributeValue, &quot;image&quot;);
278             break;
279         case TagId::Meta:
280             if (match(attributeName, contentAttr))
281                 m_metaContent = attributeValue;
282             else if (match(attributeName, nameAttr))
283                 m_metaIsViewport = equalLettersIgnoringASCIICase(attributeValue, &quot;viewport&quot;);
284             else if (RuntimeEnabledFeatures::sharedFeatures().disabledAdaptationsMetaTagEnabled() &amp;&amp; match(attributeName, nameAttr))
285                 m_metaIsDisabledAdaptations = equalLettersIgnoringASCIICase(attributeValue, &quot;disabled-adaptations&quot;);
286             break;
287         case TagId::Base:
288         case TagId::Style:
289         case TagId::Template:
290         case TagId::Picture:
291         case TagId::Unknown:
292             break;
293         }
294     }
295 
296     static bool relAttributeIsStyleSheet(const LinkRelAttribute&amp; parsedAttribute)
297     {
298         return parsedAttribute.isStyleSheet &amp;&amp; !parsedAttribute.isAlternate &amp;&amp; !parsedAttribute.iconType &amp;&amp; !parsedAttribute.isDNSPrefetch;
299     }
300 
301     void setUrlToLoad(const String&amp; value, bool allowReplacement = false)
302     {
303         // We only respect the first src/href, per HTML5:
304         // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#attribute-name-state
305         if (!allowReplacement &amp;&amp; !m_urlToLoad.isEmpty())
306             return;
307         String url = stripLeadingAndTrailingHTMLSpaces(value);
308         if (url.isEmpty())
309             return;
310         m_urlToLoad = url;
311     }
312 
313     const String&amp; charset() const
314     {
315         return m_charset;
316     }
317 
318     Optional&lt;CachedResource::Type&gt; resourceType() const
319     {
320         switch (m_tagId) {
321         case TagId::Script:
322             return CachedResource::Type::Script;
323         case TagId::Img:
324         case TagId::Input:
325         case TagId::Source:
326             ASSERT(m_tagId != TagId::Input || m_inputIsImage);
327             return CachedResource::Type::ImageResource;
328         case TagId::Link:
329             if (m_linkIsStyleSheet)
330                 return CachedResource::Type::CSSStyleSheet;
331             if (m_linkIsPreload)
332                 return LinkLoader::resourceTypeFromAsAttribute(m_asAttribute);
333             break;
334         case TagId::Meta:
335         case TagId::Unknown:
336         case TagId::Style:
337         case TagId::Base:
338         case TagId::Template:
339         case TagId::Picture:
340             break;
341         }
342         ASSERT_NOT_REACHED();
343         return CachedResource::Type::RawResource;
344     }
345 
346     bool shouldPreload()
347     {
348         if (m_urlToLoad.isEmpty())
349             return false;
350 
351         if (protocolIs(m_urlToLoad, &quot;data&quot;) || protocolIs(m_urlToLoad, &quot;about&quot;))
352             return false;
353 
354         if (m_tagId == TagId::Link &amp;&amp; !m_linkIsStyleSheet &amp;&amp; !m_linkIsPreload)
355             return false;
356 
357         if (m_tagId == TagId::Input &amp;&amp; !m_inputIsImage)
358             return false;
359 
360         if (m_tagId == TagId::Script &amp;&amp; m_moduleScript == PreloadRequest::ModuleScript::No &amp;&amp; m_scriptIsNomodule)
361             return false;
362 
363         return true;
364     }
365 
366     TagId m_tagId;
367     String m_urlToLoad;
368     String m_srcSetAttribute;
369     String m_sizesAttribute;
370     bool m_mediaMatched { true };
371     bool m_typeMatched { true };
372     String m_charset;
373     String m_crossOriginMode;
374     bool m_linkIsStyleSheet;
375     bool m_linkIsPreload;
376     String m_mediaAttribute;
377     String m_nonceAttribute;
378     String m_metaContent;
379     String m_asAttribute;
380     String m_typeAttribute;
381     bool m_metaIsViewport;
382     bool m_metaIsDisabledAdaptations;
383     bool m_inputIsImage;
384     bool m_scriptIsNomodule { false };
385     float m_deviceScaleFactor;
386     PreloadRequest::ModuleScript m_moduleScript { PreloadRequest::ModuleScript::No };
387     ReferrerPolicy m_referrerPolicy { ReferrerPolicy::EmptyString };
388 };
389 
390 TokenPreloadScanner::TokenPreloadScanner(const URL&amp; documentURL, float deviceScaleFactor)
391     : m_documentURL(documentURL)
392     , m_deviceScaleFactor(deviceScaleFactor)
393 {
394 }
395 
396 void TokenPreloadScanner::scan(const HTMLToken&amp; token, Vector&lt;std::unique_ptr&lt;PreloadRequest&gt;&gt;&amp; requests, Document&amp; document)
397 {
398     switch (token.type()) {
399     case HTMLToken::Character:
400         if (!m_inStyle)
401             return;
402         m_cssScanner.scan(token.characters(), requests);
403         return;
404 
405     case HTMLToken::EndTag: {
406         TagId tagId = tagIdFor(token.name());
407         if (tagId == TagId::Template) {
408             if (m_templateCount)
409                 --m_templateCount;
410             return;
411         }
412         if (tagId == TagId::Style) {
413             if (m_inStyle)
414                 m_cssScanner.reset();
415             m_inStyle = false;
416         } else if (tagId == TagId::Picture &amp;&amp; !m_pictureSourceState.isEmpty())
417             m_pictureSourceState.removeLast();
418 
419         return;
420     }
421 
422     case HTMLToken::StartTag: {
423         if (m_templateCount)
424             return;
425         TagId tagId = tagIdFor(token.name());
426         if (tagId == TagId::Template) {
427             ++m_templateCount;
428             return;
429         }
430         if (tagId == TagId::Style) {
431             m_inStyle = true;
432             return;
433         }
434         if (tagId == TagId::Base) {
435             // The first &lt;base&gt; element is the one that wins.
436             if (!m_predictedBaseElementURL.isEmpty())
437                 return;
438             updatePredictedBaseURL(token, document.settings().shouldRestrictBaseURLSchemes());
439             return;
440         }
441         if (tagId == TagId::Picture) {
442             m_pictureSourceState.append(false);
443             return;
444         }
445 
446         StartTagScanner scanner(tagId, m_deviceScaleFactor);
447         scanner.processAttributes(token.attributes(), document, m_pictureSourceState);
448         if (auto request = scanner.createPreloadRequest(m_predictedBaseElementURL))
449             requests.append(WTFMove(request));
450         return;
451     }
452 
453     default:
454         return;
455     }
456 }
457 
458 void TokenPreloadScanner::updatePredictedBaseURL(const HTMLToken&amp; token, bool shouldRestrictBaseURLSchemes)
459 {
460     ASSERT(m_predictedBaseElementURL.isEmpty());
461     auto* hrefAttribute = findAttribute(token.attributes(), hrefAttr-&gt;localName().string());
462     if (!hrefAttribute)
463         return;
464     URL temp { m_documentURL, stripLeadingAndTrailingHTMLSpaces(StringImpl::create8BitIfPossible(hrefAttribute-&gt;value)) };
465     if (!shouldRestrictBaseURLSchemes || SecurityPolicy::isBaseURLSchemeAllowed(temp))
466         m_predictedBaseElementURL = temp.isolatedCopy();
467 }
468 
469 HTMLPreloadScanner::HTMLPreloadScanner(const HTMLParserOptions&amp; options, const URL&amp; documentURL, float deviceScaleFactor)
470     : m_scanner(documentURL, deviceScaleFactor)
471     , m_tokenizer(options)
472 {
473 }
474 
475 void HTMLPreloadScanner::appendToEnd(const SegmentedString&amp; source)
476 {
477     m_source.append(source);
478 }
479 
480 void HTMLPreloadScanner::scan(HTMLResourcePreloader&amp; preloader, Document&amp; document)
481 {
482     ASSERT(isMainThread()); // HTMLTokenizer::updateStateFor only works on the main thread.
483 
484     const URL&amp; startingBaseElementURL = document.baseElementURL();
485 
486     // When we start scanning, our best prediction of the baseElementURL is the real one!
487     if (!startingBaseElementURL.isEmpty())
488         m_scanner.setPredictedBaseElementURL(startingBaseElementURL);
489 
490     PreloadRequestStream requests;
491 
492     while (auto token = m_tokenizer.nextToken(m_source)) {
493         if (token-&gt;type() == HTMLToken::StartTag)
494             m_tokenizer.updateStateFor(AtomString(token-&gt;name()));
495         m_scanner.scan(*token, requests, document);
496     }
497 
498     preloader.preload(WTFMove(requests));
499 }
500 
501 bool testPreloadScannerViewportSupport(Document* document)
502 {
503     ASSERT(document);
504     HTMLParserOptions options(*document);
505     HTMLPreloadScanner scanner(options, document-&gt;url());
506     HTMLResourcePreloader preloader(*document);
507     scanner.appendToEnd(String(&quot;&lt;meta name=viewport content=&#39;width=400&#39;&gt;&quot;));
508     scanner.scan(preloader, *document);
509     return (document-&gt;viewportArguments().width == 400);
510 }
511 
512 }
    </pre>
  </body>
</html>
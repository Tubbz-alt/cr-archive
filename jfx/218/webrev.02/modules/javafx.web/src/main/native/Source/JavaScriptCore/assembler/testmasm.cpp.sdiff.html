<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="X86Registers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../b3/B3Bank.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 160     CCallHelpers jit;
 161     generate(jit);
 162     LinkBuffer linkBuffer(jit, nullptr);
 163     return FINALIZE_CODE(linkBuffer, JSEntryPtrTag, &quot;testmasm compilation&quot;);
 164 }
 165 
 166 template&lt;typename T, typename... Arguments&gt;
 167 T invoke(const MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt;&amp; code, Arguments... arguments)
 168 {
 169     void* executableAddress = untagCFunctionPtr&lt;JSEntryPtrTag&gt;(code.code().executableAddress());
 170     T (*function)(Arguments...) = bitwise_cast&lt;T(*)(Arguments...)&gt;(executableAddress);
 171     return function(arguments...);
 172 }
 173 
 174 template&lt;typename T, typename... Arguments&gt;
 175 T compileAndRun(Generator&amp;&amp; generator, Arguments... arguments)
 176 {
 177     return invoke&lt;T&gt;(compile(WTFMove(generator)), arguments...);
 178 }
 179 




















 180 void testSimple()
 181 {
 182     CHECK_EQ(compileAndRun&lt;int&gt;([] (CCallHelpers&amp; jit) {
<span class="line-modified"> 183         jit.emitFunctionPrologue();</span>
 184         jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
<span class="line-modified"> 185         jit.emitFunctionEpilogue();</span>
 186         jit.ret();
 187     }), 42);
 188 }
 189 
 190 void testGetEffectiveAddress(size_t pointer, ptrdiff_t length, int32_t offset, CCallHelpers::Scale scale)
 191 {
 192     CHECK_EQ(compileAndRun&lt;size_t&gt;([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 193         jit.emitFunctionPrologue();</span>
 194         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(pointer)), GPRInfo::regT0);
 195         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(length)), GPRInfo::regT1);
 196         jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, scale, offset), GPRInfo::returnValueGPR);
<span class="line-modified"> 197         jit.emitFunctionEpilogue();</span>
 198         jit.ret();
 199     }), pointer + offset + (static_cast&lt;size_t&gt;(1) &lt;&lt; static_cast&lt;int&gt;(scale)) * length);
 200 }
 201 
 202 // branchTruncateDoubleToInt32(), when encountering Infinity, -Infinity or a
 203 // Nan, should either yield 0 in dest or fail.
 204 void testBranchTruncateDoubleToInt32(double val, int32_t expected)
 205 {
 206     const uint64_t valAsUInt = *reinterpret_cast&lt;uint64_t*&gt;(&amp;val);
 207 #if CPU(BIG_ENDIAN)
 208     const bool isBigEndian = true;
 209 #else
 210     const bool isBigEndian = false;
 211 #endif
 212     CHECK_EQ(compileAndRun&lt;int&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 213         jit.emitFunctionPrologue();</span>
 214         jit.subPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
 215         if (isBigEndian) {
 216             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
 217                 MacroAssembler::stackPointerRegister);
 218             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
 219                 MacroAssembler::Address(MacroAssembler::stackPointerRegister, 4));
 220         } else {
 221             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
 222                 MacroAssembler::stackPointerRegister);
 223             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
 224                 MacroAssembler::Address(MacroAssembler::stackPointerRegister, 4));
 225         }
 226         jit.loadDouble(MacroAssembler::stackPointerRegister, FPRInfo::fpRegT0);
 227 
 228         MacroAssembler::Jump done;
 229         done = jit.branchTruncateDoubleToInt32(FPRInfo::fpRegT0, GPRInfo::returnValueGPR, MacroAssembler::BranchIfTruncateSuccessful);
 230 
 231         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 232 
 233         done.link(&amp;jit);
 234         jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
<span class="line-modified"> 235         jit.emitFunctionEpilogue();</span>
 236         jit.ret();
 237     }), expected);
 238 }
 239 
 240 
 241 static Vector&lt;double&gt; doubleOperands()
 242 {
 243     return Vector&lt;double&gt; {
 244         0,
 245         -0,
 246         1,
 247         -1,
 248         42,
 249         -42,
 250         std::numeric_limits&lt;double&gt;::max(),
 251         std::numeric_limits&lt;double&gt;::min(),
 252         std::numeric_limits&lt;double&gt;::lowest(),
 253         std::numeric_limits&lt;double&gt;::quiet_NaN(),
 254         std::numeric_limits&lt;double&gt;::infinity(),
 255         -std::numeric_limits&lt;double&gt;::infinity(),
</pre>
<hr />
<pre>
 299     return Vector&lt;int64_t&gt; {
 300         0,
 301         1,
 302         -1,
 303         2,
 304         -2,
 305         42,
 306         -42,
 307         64,
 308         std::numeric_limits&lt;int32_t&gt;::max(),
 309         std::numeric_limits&lt;int32_t&gt;::min(),
 310         std::numeric_limits&lt;int64_t&gt;::max(),
 311         std::numeric_limits&lt;int64_t&gt;::min(),
 312     };
 313 }
 314 #endif
 315 
 316 #if CPU(X86_64)
 317 void testBranchTestBit32RegReg()
 318 {
<span class="line-modified"> 319     for (uint32_t value : int32Operands()) {</span>
 320         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 321             jit.emitFunctionPrologue();</span>
 322 
 323             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 324             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 325             auto done = jit.jump();
 326             branch.link(&amp;jit);
 327             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 328             done.link(&amp;jit);
 329 
<span class="line-modified"> 330             jit.emitFunctionEpilogue();</span>
 331             jit.ret();
 332         });
 333 
<span class="line-modified"> 334         for (uint32_t value2 : int32Operands())</span>
 335             CHECK_EQ(invoke&lt;int&gt;(test, value, value2), (value&gt;&gt;(value2%32))&amp;1);
 336     }
 337 }
 338 
 339 void testBranchTestBit32RegImm()
 340 {
<span class="line-modified"> 341     for (uint32_t value : int32Operands()) {</span>
 342         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 343             jit.emitFunctionPrologue();</span>
 344 
 345             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
 346             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 347             auto done = jit.jump();
 348             branch.link(&amp;jit);
 349             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 350             done.link(&amp;jit);
 351 
<span class="line-modified"> 352             jit.emitFunctionEpilogue();</span>
 353             jit.ret();
 354         });
 355 
<span class="line-modified"> 356         for (uint32_t value2 : int32Operands())</span>
 357             CHECK_EQ(invoke&lt;int&gt;(test, value2), (value2&gt;&gt;(value%32))&amp;1);
 358     }
 359 }
 360 
 361 void testBranchTestBit32AddrImm()
 362 {
<span class="line-modified"> 363     for (uint32_t value : int32Operands()) {</span>
 364         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 365             jit.emitFunctionPrologue();</span>
 366 
 367             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
 368             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 369             auto done = jit.jump();
 370             branch.link(&amp;jit);
 371             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 372             done.link(&amp;jit);
 373 
<span class="line-modified"> 374             jit.emitFunctionEpilogue();</span>
 375             jit.ret();
 376         });
 377 
<span class="line-modified"> 378         for (uint32_t value2 : int32Operands())</span>
 379             CHECK_EQ(invoke&lt;int&gt;(test, &amp;value2), (value2&gt;&gt;(value%32))&amp;1);
 380     }
 381 }
 382 
 383 void testBranchTestBit64RegReg()
 384 {
<span class="line-modified"> 385     for (uint64_t value : int64Operands()) {</span>
 386         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 387             jit.emitFunctionPrologue();</span>
 388 
 389             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 390             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 391             auto done = jit.jump();
 392             branch.link(&amp;jit);
 393             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 394             done.link(&amp;jit);
 395 
<span class="line-modified"> 396             jit.emitFunctionEpilogue();</span>
 397             jit.ret();
 398         });
 399 
<span class="line-modified"> 400         for (uint64_t value2 : int64Operands())</span>
 401             CHECK_EQ(invoke&lt;long int&gt;(test, value, value2), (value&gt;&gt;(value2%64))&amp;1);
 402     }
 403 }
 404 
 405 void testBranchTestBit64RegImm()
 406 {
<span class="line-modified"> 407     for (uint64_t value : int64Operands()) {</span>
 408         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 409             jit.emitFunctionPrologue();</span>
 410 
 411             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
 412             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 413             auto done = jit.jump();
 414             branch.link(&amp;jit);
 415             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 416             done.link(&amp;jit);
 417 
<span class="line-modified"> 418             jit.emitFunctionEpilogue();</span>
 419             jit.ret();
 420         });
 421 
<span class="line-modified"> 422         for (uint64_t value2 : int64Operands())</span>
 423             CHECK_EQ(invoke&lt;long int&gt;(test, value2), (value2&gt;&gt;(value%64))&amp;1);
 424     }
 425 }
 426 
 427 void testBranchTestBit64AddrImm()
 428 {
<span class="line-modified"> 429     for (uint64_t value : int64Operands()) {</span>
 430         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 431             jit.emitFunctionPrologue();</span>
 432 
 433             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
 434             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 435             auto done = jit.jump();
 436             branch.link(&amp;jit);
 437             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 438             done.link(&amp;jit);
 439 
<span class="line-modified"> 440             jit.emitFunctionEpilogue();</span>
 441             jit.ret();
 442         });
 443 
<span class="line-modified"> 444         for (uint64_t value2 : int64Operands())</span>
 445             CHECK_EQ(invoke&lt;long int&gt;(test, &amp;value2), (value2&gt;&gt;(value%64))&amp;1);
 446     }
 447 }
 448 
 449 #endif
 450 
 451 void testCompareDouble(MacroAssembler::DoubleCondition condition)
 452 {
 453     double arg1 = 0;
 454     double arg2 = 0;
 455 
 456     auto compareDouble = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 457         jit.emitFunctionPrologue();</span>
 458 
 459         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 460         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 461         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 462         jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 463 
<span class="line-modified"> 464         jit.emitFunctionEpilogue();</span>
 465         jit.ret();
 466     });
 467 
 468     auto compareDoubleGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 469         jit.emitFunctionPrologue();</span>
 470 
 471         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 472         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 473         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 474         auto jump = jit.branchDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
 475         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 476         jump.link(&amp;jit);
 477 
<span class="line-modified"> 478         jit.emitFunctionEpilogue();</span>
 479         jit.ret();
 480     });
 481 
 482     auto operands = doubleOperands();
 483     for (auto a : operands) {
 484         for (auto b : operands) {
 485             arg1 = a;
 486             arg2 = b;
 487             CHECK_EQ(invoke&lt;int&gt;(compareDouble), invoke&lt;int&gt;(compareDoubleGeneric));
 488         }
 489     }
 490 }
 491 
 492 void testMul32WithImmediates()
 493 {
 494     for (auto immediate : int32Operands()) {
 495         auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 496             jit.emitFunctionPrologue();</span>
 497 
 498             jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 499 
<span class="line-modified"> 500             jit.emitFunctionEpilogue();</span>
 501             jit.ret();
 502         });
 503 
 504         for (auto value : int32Operands())
 505             CHECK_EQ(invoke&lt;int&gt;(mul, value), immediate * value);
 506     }
 507 }
 508 
 509 #if CPU(ARM64)
 510 void testMul32SignExtend()
 511 {
 512     for (auto value : int32Operands()) {
 513         auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 514             jit.emitFunctionPrologue();</span>
 515 
 516             jit.multiplySignExtend32(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::returnValueGPR);
 517 
<span class="line-modified"> 518             jit.emitFunctionEpilogue();</span>
 519             jit.ret();
 520         });
 521 
 522         for (auto value2 : int32Operands())
 523             CHECK_EQ(invoke&lt;long int&gt;(mul, value, value2), ((long int) value) * ((long int) value2));
 524     }
 525 }
 526 #endif
 527 
 528 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
 529 void testCompareFloat(MacroAssembler::DoubleCondition condition)
 530 {
 531     float arg1 = 0;
 532     float arg2 = 0;
 533 
 534     auto compareFloat = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 535         jit.emitFunctionPrologue();</span>
 536 
 537         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 538         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 539         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 540         jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 541 
<span class="line-modified"> 542         jit.emitFunctionEpilogue();</span>
 543         jit.ret();
 544     });
 545 
 546     auto compareFloatGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 547         jit.emitFunctionPrologue();</span>
 548 
 549         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 550         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 551         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 552         auto jump = jit.branchFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
 553         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 554         jump.link(&amp;jit);
 555 
<span class="line-modified"> 556         jit.emitFunctionEpilogue();</span>
 557         jit.ret();
 558     });
 559 
 560     auto operands = floatOperands();
 561     for (auto a : operands) {
 562         for (auto b : operands) {
 563             arg1 = a;
 564             arg2 = b;
 565             CHECK_EQ(invoke&lt;int&gt;(compareFloat), invoke&lt;int&gt;(compareFloatGeneric));
 566         }
 567     }
 568 }
 569 #endif
 570 
 571 #if ENABLE(MASM_PROBE)
 572 void testProbeReadsArgumentRegisters()
 573 {
 574     bool probeWasCalled = false;
 575     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 576         jit.emitFunctionPrologue();</span>
 577 
 578         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 579         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 580 
 581         jit.move(CCallHelpers::TrustedImm32(testWord32(0)), GPRInfo::argumentGPR0);
 582         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT0);
 583         jit.move(CCallHelpers::TrustedImm32(testWord32(1)), GPRInfo::argumentGPR0);
 584         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT1);
 585 #if USE(JSVALUE64)
 586         jit.move(CCallHelpers::TrustedImm64(testWord(0)), GPRInfo::argumentGPR0);
 587         jit.move(CCallHelpers::TrustedImm64(testWord(1)), GPRInfo::argumentGPR1);
 588         jit.move(CCallHelpers::TrustedImm64(testWord(2)), GPRInfo::argumentGPR2);
 589         jit.move(CCallHelpers::TrustedImm64(testWord(3)), GPRInfo::argumentGPR3);
 590 #else
 591         jit.move(CCallHelpers::TrustedImm32(testWord(0)), GPRInfo::argumentGPR0);
 592         jit.move(CCallHelpers::TrustedImm32(testWord(1)), GPRInfo::argumentGPR1);
 593         jit.move(CCallHelpers::TrustedImm32(testWord(2)), GPRInfo::argumentGPR2);
 594         jit.move(CCallHelpers::TrustedImm32(testWord(3)), GPRInfo::argumentGPR3);
 595 #endif
 596 
 597         jit.probe([&amp;] (Probe::Context&amp; context) {
 598             auto&amp; cpu = context.cpu;
 599             probeWasCalled = true;
 600             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR0), testWord(0));
 601             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR1), testWord(1));
 602             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR2), testWord(2));
 603             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR3), testWord(3));
 604 
 605             CHECK_EQ(cpu.fpr(FPRInfo::fpRegT0), testWord32(0));
 606             CHECK_EQ(cpu.fpr(FPRInfo::fpRegT1), testWord32(1));
 607         });
 608 
 609         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 610         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 611 
<span class="line-modified"> 612         jit.emitFunctionEpilogue();</span>
 613         jit.ret();
 614     });
 615     CHECK_EQ(probeWasCalled, true);
 616 }
 617 
 618 void testProbeWritesArgumentRegisters()
 619 {
 620     // This test relies on testProbeReadsArgumentRegisters() having already validated
 621     // that we can read from argument registers. We&#39;ll use that ability to validate
 622     // that our writes did take effect.
 623     unsigned probeCallCount = 0;
 624     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 625         jit.emitFunctionPrologue();</span>
 626 
 627         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 628         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 629 
 630         // Pre-initialize with non-expected values.
 631 #if USE(JSVALUE64)
 632         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR0);
 633         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR1);
 634         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR2);
 635         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR3);
 636 #else
 637         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR0);
 638         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR1);
 639         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR2);
 640         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR3);
 641 #endif
 642         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT0);
 643         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT1);
 644 
 645         // Write expected values.
</pre>
<hr />
<pre>
 654             cpu.fpr(FPRInfo::fpRegT0) = bitwise_cast&lt;double&gt;(testWord64(0));
 655             cpu.fpr(FPRInfo::fpRegT1) = bitwise_cast&lt;double&gt;(testWord64(1));
 656         });
 657 
 658         // Validate that expected values were written.
 659         jit.probe([&amp;] (Probe::Context&amp; context) {
 660             auto&amp; cpu = context.cpu;
 661             probeCallCount++;
 662             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR0), testWord(0));
 663             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR1), testWord(1));
 664             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR2), testWord(2));
 665             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR3), testWord(3));
 666 
 667             CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(FPRInfo::fpRegT0), testWord64(0));
 668             CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(FPRInfo::fpRegT1), testWord64(1));
 669         });
 670 
 671         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 672         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 673 
<span class="line-modified"> 674         jit.emitFunctionEpilogue();</span>
 675         jit.ret();
 676     });
 677     CHECK_EQ(probeCallCount, 2);
 678 }
 679 
 680 static NEVER_INLINE NOT_TAIL_CALLED int testFunctionToTrashGPRs(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j)
 681 {
 682     if (j &gt; 0)
 683         return testFunctionToTrashGPRs(a + 1, b + a, c + b, d + 5, e - a, f * 1.5, g ^ a, h - b, i, j - 1);
 684     return a + 1;
 685 }
 686 static NEVER_INLINE NOT_TAIL_CALLED double testFunctionToTrashFPRs(double a, double b, double c, double d, double e, double f, double g, double h, double i, double j)
 687 {
 688     if (j &gt; 0)
 689         return testFunctionToTrashFPRs(a + 1, b + a, c + b, d + 5, e - a, f * 1.5, pow(g, a), h - b, i, j - 1);
 690     return a + 1;
 691 }
 692 
 693 void testProbePreservesGPRS()
 694 {
 695     // This test relies on testProbeReadsArgumentRegisters() and testProbeWritesArgumentRegisters()
 696     // having already validated that we can read and write from registers. We&#39;ll use these abilities
 697     // to validate that the probe preserves register values.
 698     unsigned probeCallCount = 0;
 699     CPUState originalState;
 700 
 701     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 702         jit.emitFunctionPrologue();</span>
 703 
 704         // Write expected values into the registers (except for sp, fp, and pc).
 705         jit.probe([&amp;] (Probe::Context&amp; context) {
 706             auto&amp; cpu = context.cpu;
 707             probeCallCount++;
 708             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 709                 originalState.gpr(id) = cpu.gpr(id);
 710                 if (isSpecialGPR(id))
 711                     continue;
 712                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
 713             }
 714             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
 715                 originalState.fpr(id) = cpu.fpr(id);
 716                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
 717             }
 718         });
 719 
 720         // Invoke the probe to call a lot of functions and trash register values.
 721         jit.probe([&amp;] (Probe::Context&amp;) {
 722             probeCallCount++;
</pre>
<hr />
<pre>
 756             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 757                 cpu.fpr(id) = originalState.fpr(id);
 758         });
 759 
 760         // Validate that the original state was restored.
 761         jit.probe([&amp;] (Probe::Context&amp; context) {
 762             auto&amp; cpu = context.cpu;
 763             probeCallCount++;
 764             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 765                 if (isSpecialGPR(id))
 766                     continue;
 767                 CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 768             }
 769             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 770 #if CPU(MIPS)
 771                 if (!(id &amp; 1))
 772 #endif
 773                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
 774         });
 775 
<span class="line-modified"> 776         jit.emitFunctionEpilogue();</span>
 777         jit.ret();
 778     });
 779     CHECK_EQ(probeCallCount, 5);
 780 }
 781 
 782 void testProbeModifiesStackPointer(WTF::Function&lt;void*(Probe::Context&amp;)&gt; computeModifiedStackPointer)
 783 {
 784     unsigned probeCallCount = 0;
 785     CPUState originalState;
 786     void* originalSP { nullptr };
 787     void* modifiedSP { nullptr };
 788 #if !(CPU(MIPS))
 789     uintptr_t modifiedFlags { 0 };
 790 #endif
 791 
 792 #if CPU(X86) || CPU(X86_64)
 793     auto flagsSPR = X86Registers::eflags;
 794     uintptr_t flagsMask = 0xc5;
 795 #elif CPU(ARM_THUMB2)
 796     auto flagsSPR = ARMRegisters::apsr;
 797     uintptr_t flagsMask = 0xf8000000;
 798 #elif CPU(ARM64)
 799     auto flagsSPR = ARM64Registers::nzcv;
 800     uintptr_t flagsMask = 0xf0000000;
 801 #endif
 802 
 803     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 804         jit.emitFunctionPrologue();</span>
 805 
 806         // Preserve original stack pointer and modify the sp, and
 807         // write expected values into other registers (except for fp, and pc).
 808         jit.probe([&amp;] (Probe::Context&amp; context) {
 809             auto&amp; cpu = context.cpu;
 810             probeCallCount++;
 811             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 812                 originalState.gpr(id) = cpu.gpr(id);
 813                 if (isSpecialGPR(id))
 814                     continue;
 815                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
 816             }
 817             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
 818                 originalState.fpr(id) = cpu.fpr(id);
 819                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
 820             }
 821 
 822 #if !(CPU(MIPS))
 823             originalState.spr(flagsSPR) = cpu.spr(flagsSPR);
 824             modifiedFlags = originalState.spr(flagsSPR) ^ flagsMask;
</pre>
<hr />
<pre>
 874         // Validate that the original state was restored.
 875         jit.probe([&amp;] (Probe::Context&amp; context) {
 876             auto&amp; cpu = context.cpu;
 877             probeCallCount++;
 878             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 879                 if (isSpecialGPR(id))
 880                     continue;
 881                 CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 882             }
 883             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 884 #if CPU(MIPS)
 885                 if (!(id &amp; 1))
 886 #endif
 887                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
 888 #if !(CPU(MIPS))
 889             CHECK_EQ(cpu.spr(flagsSPR) &amp; flagsMask, originalState.spr(flagsSPR) &amp; flagsMask);
 890 #endif
 891             CHECK_EQ(cpu.sp(), originalSP);
 892         });
 893 
<span class="line-modified"> 894         jit.emitFunctionEpilogue();</span>
 895         jit.ret();
 896     });
 897     CHECK_EQ(probeCallCount, 4);
 898 }
 899 
 900 void testProbeModifiesStackPointerToInsideProbeStateOnStack()
 901 {
 902     size_t increment = sizeof(uintptr_t);
 903 #if CPU(ARM64)
 904     // The ARM64 probe uses ldp and stp which require 16 byte alignment.
 905     increment = 2 * sizeof(uintptr_t);
 906 #endif
 907     for (size_t offset = 0; offset &lt; sizeof(Probe::State); offset += increment) {
 908         testProbeModifiesStackPointer([=] (Probe::Context&amp; context) -&gt; void* {
 909             return reinterpret_cast&lt;uint8_t*&gt;(probeStateForContext(context)) + offset;
 910 
 911         });
 912     }
 913 }
 914 
</pre>
<hr />
<pre>
 924             return context.cpu.sp&lt;uint8_t*&gt;() - offset;
 925         });
 926     }
 927 }
 928 
 929 void testProbeModifiesProgramCounter()
 930 {
 931     // This test relies on testProbeReadsArgumentRegisters() and testProbeWritesArgumentRegisters()
 932     // having already validated that we can read and write from registers. We&#39;ll use these abilities
 933     // to validate that the probe preserves register values.
 934     unsigned probeCallCount = 0;
 935     bool continuationWasReached = false;
 936 
 937     MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt; continuation = compile([&amp;] (CCallHelpers&amp; jit) {
 938         // Validate that we reached the continuation.
 939         jit.probe([&amp;] (Probe::Context&amp;) {
 940             probeCallCount++;
 941             continuationWasReached = true;
 942         });
 943 
<span class="line-modified"> 944         jit.emitFunctionEpilogue();</span>
 945         jit.ret();
 946     });
 947 
 948     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 949         jit.emitFunctionPrologue();</span>
 950 
 951         // Write expected values into the registers.
 952         jit.probe([&amp;] (Probe::Context&amp; context) {
 953             probeCallCount++;
 954             context.cpu.pc() = untagCodePtr(continuation.code().executableAddress(), JSEntryPtrTag);
 955         });
 956 
 957         jit.breakpoint(); // We should never get here.
 958     });
 959     CHECK_EQ(probeCallCount, 2);
 960     CHECK_EQ(continuationWasReached, true);
 961 }
 962 
 963 void testProbeModifiesStackValues()
 964 {
 965     unsigned probeCallCount = 0;
 966     CPUState originalState;
 967     void* originalSP { nullptr };
 968     void* newSP { nullptr };
 969 #if !CPU(MIPS)
 970     uintptr_t modifiedFlags { 0 };
 971 #endif
 972     size_t numberOfExtraEntriesToWrite { 10 }; // ARM64 requires that this be 2 word aligned.
 973 
 974 #if CPU(X86) || CPU(X86_64)
 975     MacroAssembler::SPRegisterID flagsSPR = X86Registers::eflags;
 976     uintptr_t flagsMask = 0xc5;
 977 #elif CPU(ARM_THUMB2)
 978     MacroAssembler::SPRegisterID flagsSPR = ARMRegisters::apsr;
 979     uintptr_t flagsMask = 0xf8000000;
 980 #elif CPU(ARM64)
 981     MacroAssembler::SPRegisterID flagsSPR = ARM64Registers::nzcv;
 982     uintptr_t flagsMask = 0xf0000000;
 983 #endif
 984 
 985     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 986         jit.emitFunctionPrologue();</span>
 987 
 988         // Write expected values into the registers.
 989         jit.probe([&amp;] (Probe::Context&amp; context) {
 990             auto&amp; cpu = context.cpu;
 991             auto&amp; stack = context.stack();
 992             probeCallCount++;
 993 
 994             // Preserve the original CPU state.
 995             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 996                 originalState.gpr(id) = cpu.gpr(id);
 997                 if (isSpecialGPR(id))
 998                     continue;
 999                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
1000             }
1001             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
1002                 originalState.fpr(id) = cpu.fpr(id);
1003                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
1004             }
1005 #if !(CPU(MIPS))
1006             originalState.spr(flagsSPR) = cpu.spr(flagsSPR);
</pre>
<hr />
<pre>
1059                 CHECK_EQ(stack.get&lt;uintptr_t&gt;(p++), testWord(count++));
1060         });
1061 
1062         // Restore the original state.
1063         jit.probe([&amp;] (Probe::Context&amp; context) {
1064             auto&amp; cpu = context.cpu;
1065             probeCallCount++;
1066             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
1067                 if (isSpecialGPR(id))
1068                     continue;
1069                 cpu.gpr(id) = originalState.gpr(id);
1070             }
1071             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
1072                 cpu.fpr(id) = originalState.fpr(id);
1073 #if !(CPU(MIPS))
1074             cpu.spr(flagsSPR) = originalState.spr(flagsSPR);
1075 #endif
1076             cpu.sp() = originalSP;
1077         });
1078 
<span class="line-modified">1079         jit.emitFunctionEpilogue();</span>
1080         jit.ret();
1081     });
1082 
1083     CHECK_EQ(probeCallCount, 3);
1084 }
1085 #endif // ENABLE(MASM_PROBE)
1086 



































1087 void testByteSwap()
1088 {
1089 #if CPU(X86_64) || CPU(ARM64)
1090     auto byteSwap16 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1091         jit.emitFunctionPrologue();</span>
1092         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1093         jit.byteSwap16(GPRInfo::returnValueGPR);
<span class="line-modified">1094         jit.emitFunctionEpilogue();</span>
1095         jit.ret();
1096     });
1097     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x2211));
1098     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff));
1099 
1100     auto byteSwap32 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1101         jit.emitFunctionPrologue();</span>
1102         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1103         jit.byteSwap32(GPRInfo::returnValueGPR);
<span class="line-modified">1104         jit.emitFunctionEpilogue();</span>
1105         jit.ret();
1106     });
1107     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100ee));
1108     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00ee));
1109 
1110     auto byteSwap64 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1111         jit.emitFunctionPrologue();</span>
1112         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1113         jit.byteSwap64(GPRInfo::returnValueGPR);
<span class="line-modified">1114         jit.emitFunctionEpilogue();</span>
1115         jit.ret();
1116     });
1117     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100eeddccbbaa));
1118     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00eeddccbbaa));
1119 #endif
1120 }
1121 
1122 void testMoveDoubleConditionally32()
1123 {
1124 #if CPU(X86_64) | CPU(ARM64)
1125     double arg1 = 0;
1126     double arg2 = 0;
1127     const double zero = -0;
1128 
1129     const double chosenDouble = 6.00000059604644775390625;
1130     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
1131 
1132     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">1133         jit.emitFunctionPrologue();</span>
1134         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
1135         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
1136         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
1137 
1138         jit.move(MacroAssembler::TrustedImm32(-1), GPRInfo::regT0);
1139         jit.moveDoubleConditionally32(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
1140 
<span class="line-modified">1141         jit.emitFunctionEpilogue();</span>
1142         jit.ret();
1143     });
1144 
1145     arg1 = chosenDouble;
1146     arg2 = 43;
1147     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);
1148 
1149     arg1 = 43;
1150     arg2 = chosenDouble;
1151     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);
1152 
1153 #endif
1154 }
1155 
1156 void testMoveDoubleConditionally64()
1157 {
1158 #if CPU(X86_64) | CPU(ARM64)
1159     double arg1 = 0;
1160     double arg2 = 0;
1161     const double zero = -0;
1162 
1163     const double chosenDouble = 6.00000059604644775390625;
1164     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
1165 
1166     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">1167         jit.emitFunctionPrologue();</span>
1168         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
1169         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
1170         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
1171 
1172         jit.move(MacroAssembler::TrustedImm64(-1), GPRInfo::regT0);
1173         jit.moveDoubleConditionally64(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
1174 
<span class="line-modified">1175         jit.emitFunctionEpilogue();</span>
1176         jit.ret();
1177     });
1178 
1179     arg1 = chosenDouble;
1180     arg2 = 43;
1181     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);
1182 
1183     arg1 = 43;
1184     arg2 = chosenDouble;
1185     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);
1186 
1187 #endif
1188 }
1189 
1190 static void testCagePreservesPACFailureBit()
1191 {
1192 #if GIGACAGE_ENABLED
<span class="line-modified">1193     ASSERT(!Gigacage::isDisablingPrimitiveGigacageDisabled());</span>




1194     auto cage = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1195         jit.emitFunctionPrologue();</span>
1196         jit.cageConditionally(Gigacage::Primitive, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
1197         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">1198         jit.emitFunctionEpilogue();</span>
1199         jit.ret();
1200     });
1201 
1202     void* ptr = Gigacage::tryMalloc(Gigacage::Primitive, 1);
1203     void* taggedPtr = tagArrayPtr(ptr, 1);
<span class="line-modified">1204     ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));</span>
1205     void* notCagedPtr = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) + (Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));
1206     CHECK_NOT_EQ(Gigacage::caged(Gigacage::Primitive, notCagedPtr), notCagedPtr);
1207     void* taggedNotCagedPtr = tagArrayPtr(notCagedPtr, 1);
1208 
1209     if (isARM64E()) {
1210         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.
1211         CHECK_NOT_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
1212         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedNotCagedPtr, 1), untagArrayPtr(taggedPtr, 2));
1213     } else
1214         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
1215 
1216     CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 1), ptr);
1217 
1218     auto cageWithoutAuthentication = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1219         jit.emitFunctionPrologue();</span>
1220         jit.cageWithoutUntagging(Gigacage::Primitive, GPRInfo::argumentGPR0);
1221         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">1222         jit.emitFunctionEpilogue();</span>
1223         jit.ret();
1224     });
1225 
1226     CHECK_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedPtr), taggedPtr);
1227     if (isARM64E()) {
1228         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.
1229         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedNotCagedPtr);
1230         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), notCagedPtr);
1231         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedPtr);
1232         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), ptr);
1233     }
1234 
1235     Gigacage::free(Gigacage::Primitive, ptr);
1236 #endif
1237 }
1238 
1239 #define RUN(test) do {                          \
1240         if (!shouldRun(#test))                  \
1241             break;                              \
1242         numberOfTests++;                        \
</pre>
<hr />
<pre>
1319     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrUnordered));
1320     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
1321 #endif
1322 
1323 #if ENABLE(MASM_PROBE)
1324     RUN(testProbeReadsArgumentRegisters());
1325     RUN(testProbeWritesArgumentRegisters());
1326     RUN(testProbePreservesGPRS());
1327     RUN(testProbeModifiesStackPointerToInsideProbeStateOnStack());
1328     RUN(testProbeModifiesStackPointerToNBytesBelowSP());
1329     RUN(testProbeModifiesProgramCounter());
1330     RUN(testProbeModifiesStackValues());
1331 #endif // ENABLE(MASM_PROBE)
1332 
1333     RUN(testByteSwap());
1334     RUN(testMoveDoubleConditionally32());
1335     RUN(testMoveDoubleConditionally64());
1336 
1337     RUN(testCagePreservesPACFailureBit());
1338 


1339     if (tasks.isEmpty())
1340         usage();
1341 
1342     Lock lock;
1343 
1344     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
1345     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
1346         threads.append(
1347             Thread::create(
1348                 &quot;testmasm thread&quot;,
1349                 [&amp;] () {
1350                     for (;;) {
1351                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
1352                         {
1353                             LockHolder locker(lock);
1354                             if (tasks.isEmpty())
1355                                 return;
1356                             task = tasks.takeFirst();
1357                         }
1358 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 160     CCallHelpers jit;
 161     generate(jit);
 162     LinkBuffer linkBuffer(jit, nullptr);
 163     return FINALIZE_CODE(linkBuffer, JSEntryPtrTag, &quot;testmasm compilation&quot;);
 164 }
 165 
 166 template&lt;typename T, typename... Arguments&gt;
 167 T invoke(const MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt;&amp; code, Arguments... arguments)
 168 {
 169     void* executableAddress = untagCFunctionPtr&lt;JSEntryPtrTag&gt;(code.code().executableAddress());
 170     T (*function)(Arguments...) = bitwise_cast&lt;T(*)(Arguments...)&gt;(executableAddress);
 171     return function(arguments...);
 172 }
 173 
 174 template&lt;typename T, typename... Arguments&gt;
 175 T compileAndRun(Generator&amp;&amp; generator, Arguments... arguments)
 176 {
 177     return invoke&lt;T&gt;(compile(WTFMove(generator)), arguments...);
 178 }
 179 
<span class="line-added"> 180 void emitFunctionPrologue(CCallHelpers&amp; jit)</span>
<span class="line-added"> 181 {</span>
<span class="line-added"> 182     jit.emitFunctionPrologue();</span>
<span class="line-added"> 183 #if CPU(ARM_THUMB2)</span>
<span class="line-added"> 184     // MacroAssemblerARMv7 uses r6 as a temporary register, which is a</span>
<span class="line-added"> 185     // callee-saved register, see 5.1.1 of the Procedure Call Standard for</span>
<span class="line-added"> 186     // the ARM Architecture.</span>
<span class="line-added"> 187     // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf</span>
<span class="line-added"> 188     jit.push(ARMRegisters::r6);</span>
<span class="line-added"> 189 #endif</span>
<span class="line-added"> 190 }</span>
<span class="line-added"> 191 </span>
<span class="line-added"> 192 void emitFunctionEpilogue(CCallHelpers&amp; jit)</span>
<span class="line-added"> 193 {</span>
<span class="line-added"> 194 #if CPU(ARM_THUMB2)</span>
<span class="line-added"> 195     jit.pop(ARMRegisters::r6);</span>
<span class="line-added"> 196 #endif</span>
<span class="line-added"> 197     jit.emitFunctionEpilogue();</span>
<span class="line-added"> 198 }</span>
<span class="line-added"> 199 </span>
 200 void testSimple()
 201 {
 202     CHECK_EQ(compileAndRun&lt;int&gt;([] (CCallHelpers&amp; jit) {
<span class="line-modified"> 203         emitFunctionPrologue(jit);</span>
 204         jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
<span class="line-modified"> 205         emitFunctionEpilogue(jit);</span>
 206         jit.ret();
 207     }), 42);
 208 }
 209 
 210 void testGetEffectiveAddress(size_t pointer, ptrdiff_t length, int32_t offset, CCallHelpers::Scale scale)
 211 {
 212     CHECK_EQ(compileAndRun&lt;size_t&gt;([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 213         emitFunctionPrologue(jit);</span>
 214         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(pointer)), GPRInfo::regT0);
 215         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast&lt;void*&gt;(length)), GPRInfo::regT1);
 216         jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, scale, offset), GPRInfo::returnValueGPR);
<span class="line-modified"> 217         emitFunctionEpilogue(jit);</span>
 218         jit.ret();
 219     }), pointer + offset + (static_cast&lt;size_t&gt;(1) &lt;&lt; static_cast&lt;int&gt;(scale)) * length);
 220 }
 221 
 222 // branchTruncateDoubleToInt32(), when encountering Infinity, -Infinity or a
 223 // Nan, should either yield 0 in dest or fail.
 224 void testBranchTruncateDoubleToInt32(double val, int32_t expected)
 225 {
 226     const uint64_t valAsUInt = *reinterpret_cast&lt;uint64_t*&gt;(&amp;val);
 227 #if CPU(BIG_ENDIAN)
 228     const bool isBigEndian = true;
 229 #else
 230     const bool isBigEndian = false;
 231 #endif
 232     CHECK_EQ(compileAndRun&lt;int&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 233         emitFunctionPrologue(jit);</span>
 234         jit.subPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
 235         if (isBigEndian) {
 236             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
 237                 MacroAssembler::stackPointerRegister);
 238             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
 239                 MacroAssembler::Address(MacroAssembler::stackPointerRegister, 4));
 240         } else {
 241             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &amp; 0xffffffff),
 242                 MacroAssembler::stackPointerRegister);
 243             jit.store32(CCallHelpers::TrustedImm32(valAsUInt &gt;&gt; 32),
 244                 MacroAssembler::Address(MacroAssembler::stackPointerRegister, 4));
 245         }
 246         jit.loadDouble(MacroAssembler::stackPointerRegister, FPRInfo::fpRegT0);
 247 
 248         MacroAssembler::Jump done;
 249         done = jit.branchTruncateDoubleToInt32(FPRInfo::fpRegT0, GPRInfo::returnValueGPR, MacroAssembler::BranchIfTruncateSuccessful);
 250 
 251         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 252 
 253         done.link(&amp;jit);
 254         jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
<span class="line-modified"> 255         emitFunctionEpilogue(jit);</span>
 256         jit.ret();
 257     }), expected);
 258 }
 259 
 260 
 261 static Vector&lt;double&gt; doubleOperands()
 262 {
 263     return Vector&lt;double&gt; {
 264         0,
 265         -0,
 266         1,
 267         -1,
 268         42,
 269         -42,
 270         std::numeric_limits&lt;double&gt;::max(),
 271         std::numeric_limits&lt;double&gt;::min(),
 272         std::numeric_limits&lt;double&gt;::lowest(),
 273         std::numeric_limits&lt;double&gt;::quiet_NaN(),
 274         std::numeric_limits&lt;double&gt;::infinity(),
 275         -std::numeric_limits&lt;double&gt;::infinity(),
</pre>
<hr />
<pre>
 319     return Vector&lt;int64_t&gt; {
 320         0,
 321         1,
 322         -1,
 323         2,
 324         -2,
 325         42,
 326         -42,
 327         64,
 328         std::numeric_limits&lt;int32_t&gt;::max(),
 329         std::numeric_limits&lt;int32_t&gt;::min(),
 330         std::numeric_limits&lt;int64_t&gt;::max(),
 331         std::numeric_limits&lt;int64_t&gt;::min(),
 332     };
 333 }
 334 #endif
 335 
 336 #if CPU(X86_64)
 337 void testBranchTestBit32RegReg()
 338 {
<span class="line-modified"> 339     for (auto value : int32Operands()) {</span>
 340         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 341             emitFunctionPrologue(jit);</span>
 342 
 343             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 344             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 345             auto done = jit.jump();
 346             branch.link(&amp;jit);
 347             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 348             done.link(&amp;jit);
 349 
<span class="line-modified"> 350             emitFunctionEpilogue(jit);</span>
 351             jit.ret();
 352         });
 353 
<span class="line-modified"> 354         for (auto value2 : int32Operands())</span>
 355             CHECK_EQ(invoke&lt;int&gt;(test, value, value2), (value&gt;&gt;(value2%32))&amp;1);
 356     }
 357 }
 358 
 359 void testBranchTestBit32RegImm()
 360 {
<span class="line-modified"> 361     for (auto value : int32Operands()) {</span>
 362         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 363             emitFunctionPrologue(jit);</span>
 364 
 365             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
 366             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 367             auto done = jit.jump();
 368             branch.link(&amp;jit);
 369             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 370             done.link(&amp;jit);
 371 
<span class="line-modified"> 372             emitFunctionEpilogue(jit);</span>
 373             jit.ret();
 374         });
 375 
<span class="line-modified"> 376         for (auto value2 : int32Operands())</span>
 377             CHECK_EQ(invoke&lt;int&gt;(test, value2), (value2&gt;&gt;(value%32))&amp;1);
 378     }
 379 }
 380 
 381 void testBranchTestBit32AddrImm()
 382 {
<span class="line-modified"> 383     for (auto value : int32Operands()) {</span>
 384         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 385             emitFunctionPrologue(jit);</span>
 386 
 387             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
 388             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 389             auto done = jit.jump();
 390             branch.link(&amp;jit);
 391             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 392             done.link(&amp;jit);
 393 
<span class="line-modified"> 394             emitFunctionEpilogue(jit);</span>
 395             jit.ret();
 396         });
 397 
<span class="line-modified"> 398         for (auto value2 : int32Operands())</span>
 399             CHECK_EQ(invoke&lt;int&gt;(test, &amp;value2), (value2&gt;&gt;(value%32))&amp;1);
 400     }
 401 }
 402 
 403 void testBranchTestBit64RegReg()
 404 {
<span class="line-modified"> 405     for (auto value : int64Operands()) {</span>
 406         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 407             emitFunctionPrologue(jit);</span>
 408 
 409             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 410             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 411             auto done = jit.jump();
 412             branch.link(&amp;jit);
 413             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 414             done.link(&amp;jit);
 415 
<span class="line-modified"> 416             emitFunctionEpilogue(jit);</span>
 417             jit.ret();
 418         });
 419 
<span class="line-modified"> 420         for (auto value2 : int64Operands())</span>
 421             CHECK_EQ(invoke&lt;long int&gt;(test, value, value2), (value&gt;&gt;(value2%64))&amp;1);
 422     }
 423 }
 424 
 425 void testBranchTestBit64RegImm()
 426 {
<span class="line-modified"> 427     for (auto value : int64Operands()) {</span>
 428         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 429             emitFunctionPrologue(jit);</span>
 430 
 431             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
 432             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 433             auto done = jit.jump();
 434             branch.link(&amp;jit);
 435             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 436             done.link(&amp;jit);
 437 
<span class="line-modified"> 438             emitFunctionEpilogue(jit);</span>
 439             jit.ret();
 440         });
 441 
<span class="line-modified"> 442         for (auto value2 : int64Operands())</span>
 443             CHECK_EQ(invoke&lt;long int&gt;(test, value2), (value2&gt;&gt;(value%64))&amp;1);
 444     }
 445 }
 446 
 447 void testBranchTestBit64AddrImm()
 448 {
<span class="line-modified"> 449     for (auto value : int64Operands()) {</span>
 450         auto test = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 451             emitFunctionPrologue(jit);</span>
 452 
 453             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
 454             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
 455             auto done = jit.jump();
 456             branch.link(&amp;jit);
 457             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
 458             done.link(&amp;jit);
 459 
<span class="line-modified"> 460             emitFunctionEpilogue(jit);</span>
 461             jit.ret();
 462         });
 463 
<span class="line-modified"> 464         for (auto value2 : int64Operands())</span>
 465             CHECK_EQ(invoke&lt;long int&gt;(test, &amp;value2), (value2&gt;&gt;(value%64))&amp;1);
 466     }
 467 }
 468 
 469 #endif
 470 
 471 void testCompareDouble(MacroAssembler::DoubleCondition condition)
 472 {
 473     double arg1 = 0;
 474     double arg2 = 0;
 475 
 476     auto compareDouble = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 477         emitFunctionPrologue(jit);</span>
 478 
 479         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 480         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 481         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 482         jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 483 
<span class="line-modified"> 484         emitFunctionEpilogue(jit);</span>
 485         jit.ret();
 486     });
 487 
 488     auto compareDoubleGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 489         emitFunctionPrologue(jit);</span>
 490 
 491         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 492         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 493         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 494         auto jump = jit.branchDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
 495         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 496         jump.link(&amp;jit);
 497 
<span class="line-modified"> 498         emitFunctionEpilogue(jit);</span>
 499         jit.ret();
 500     });
 501 
 502     auto operands = doubleOperands();
 503     for (auto a : operands) {
 504         for (auto b : operands) {
 505             arg1 = a;
 506             arg2 = b;
 507             CHECK_EQ(invoke&lt;int&gt;(compareDouble), invoke&lt;int&gt;(compareDoubleGeneric));
 508         }
 509     }
 510 }
 511 
 512 void testMul32WithImmediates()
 513 {
 514     for (auto immediate : int32Operands()) {
 515         auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 516             emitFunctionPrologue(jit);</span>
 517 
 518             jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 519 
<span class="line-modified"> 520             emitFunctionEpilogue(jit);</span>
 521             jit.ret();
 522         });
 523 
 524         for (auto value : int32Operands())
 525             CHECK_EQ(invoke&lt;int&gt;(mul, value), immediate * value);
 526     }
 527 }
 528 
 529 #if CPU(ARM64)
 530 void testMul32SignExtend()
 531 {
 532     for (auto value : int32Operands()) {
 533         auto mul = compile([=] (CCallHelpers&amp; jit) {
<span class="line-modified"> 534             emitFunctionPrologue(jit);</span>
 535 
 536             jit.multiplySignExtend32(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::returnValueGPR);
 537 
<span class="line-modified"> 538             emitFunctionEpilogue(jit);</span>
 539             jit.ret();
 540         });
 541 
 542         for (auto value2 : int32Operands())
 543             CHECK_EQ(invoke&lt;long int&gt;(mul, value, value2), ((long int) value) * ((long int) value2));
 544     }
 545 }
 546 #endif
 547 
 548 #if CPU(X86) || CPU(X86_64) || CPU(ARM64)
 549 void testCompareFloat(MacroAssembler::DoubleCondition condition)
 550 {
 551     float arg1 = 0;
 552     float arg2 = 0;
 553 
 554     auto compareFloat = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 555         emitFunctionPrologue(jit);</span>
 556 
 557         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 558         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 559         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
 560         jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 561 
<span class="line-modified"> 562         emitFunctionEpilogue(jit);</span>
 563         jit.ret();
 564     });
 565 
 566     auto compareFloatGeneric = compile([&amp;, condition] (CCallHelpers&amp; jit) {
<span class="line-modified"> 567         emitFunctionPrologue(jit);</span>
 568 
 569         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT0);
 570         jit.loadFloat(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT1);
 571         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
 572         auto jump = jit.branchFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
 573         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 574         jump.link(&amp;jit);
 575 
<span class="line-modified"> 576         emitFunctionEpilogue(jit);</span>
 577         jit.ret();
 578     });
 579 
 580     auto operands = floatOperands();
 581     for (auto a : operands) {
 582         for (auto b : operands) {
 583             arg1 = a;
 584             arg2 = b;
 585             CHECK_EQ(invoke&lt;int&gt;(compareFloat), invoke&lt;int&gt;(compareFloatGeneric));
 586         }
 587     }
 588 }
 589 #endif
 590 
 591 #if ENABLE(MASM_PROBE)
 592 void testProbeReadsArgumentRegisters()
 593 {
 594     bool probeWasCalled = false;
 595     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 596         emitFunctionPrologue(jit);</span>
 597 
 598         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 599         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 600 
 601         jit.move(CCallHelpers::TrustedImm32(testWord32(0)), GPRInfo::argumentGPR0);
 602         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT0);
 603         jit.move(CCallHelpers::TrustedImm32(testWord32(1)), GPRInfo::argumentGPR0);
 604         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT1);
 605 #if USE(JSVALUE64)
 606         jit.move(CCallHelpers::TrustedImm64(testWord(0)), GPRInfo::argumentGPR0);
 607         jit.move(CCallHelpers::TrustedImm64(testWord(1)), GPRInfo::argumentGPR1);
 608         jit.move(CCallHelpers::TrustedImm64(testWord(2)), GPRInfo::argumentGPR2);
 609         jit.move(CCallHelpers::TrustedImm64(testWord(3)), GPRInfo::argumentGPR3);
 610 #else
 611         jit.move(CCallHelpers::TrustedImm32(testWord(0)), GPRInfo::argumentGPR0);
 612         jit.move(CCallHelpers::TrustedImm32(testWord(1)), GPRInfo::argumentGPR1);
 613         jit.move(CCallHelpers::TrustedImm32(testWord(2)), GPRInfo::argumentGPR2);
 614         jit.move(CCallHelpers::TrustedImm32(testWord(3)), GPRInfo::argumentGPR3);
 615 #endif
 616 
 617         jit.probe([&amp;] (Probe::Context&amp; context) {
 618             auto&amp; cpu = context.cpu;
 619             probeWasCalled = true;
 620             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR0), testWord(0));
 621             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR1), testWord(1));
 622             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR2), testWord(2));
 623             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR3), testWord(3));
 624 
 625             CHECK_EQ(cpu.fpr(FPRInfo::fpRegT0), testWord32(0));
 626             CHECK_EQ(cpu.fpr(FPRInfo::fpRegT1), testWord32(1));
 627         });
 628 
 629         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 630         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 631 
<span class="line-modified"> 632         emitFunctionEpilogue(jit);</span>
 633         jit.ret();
 634     });
 635     CHECK_EQ(probeWasCalled, true);
 636 }
 637 
 638 void testProbeWritesArgumentRegisters()
 639 {
 640     // This test relies on testProbeReadsArgumentRegisters() having already validated
 641     // that we can read from argument registers. We&#39;ll use that ability to validate
 642     // that our writes did take effect.
 643     unsigned probeCallCount = 0;
 644     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 645         emitFunctionPrologue(jit);</span>
 646 
 647         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 648         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 649 
 650         // Pre-initialize with non-expected values.
 651 #if USE(JSVALUE64)
 652         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR0);
 653         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR1);
 654         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR2);
 655         jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::argumentGPR3);
 656 #else
 657         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR0);
 658         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR1);
 659         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR2);
 660         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::argumentGPR3);
 661 #endif
 662         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT0);
 663         jit.convertInt32ToDouble(GPRInfo::argumentGPR0, FPRInfo::fpRegT1);
 664 
 665         // Write expected values.
</pre>
<hr />
<pre>
 674             cpu.fpr(FPRInfo::fpRegT0) = bitwise_cast&lt;double&gt;(testWord64(0));
 675             cpu.fpr(FPRInfo::fpRegT1) = bitwise_cast&lt;double&gt;(testWord64(1));
 676         });
 677 
 678         // Validate that expected values were written.
 679         jit.probe([&amp;] (Probe::Context&amp; context) {
 680             auto&amp; cpu = context.cpu;
 681             probeCallCount++;
 682             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR0), testWord(0));
 683             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR1), testWord(1));
 684             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR2), testWord(2));
 685             CHECK_EQ(cpu.gpr(GPRInfo::argumentGPR3), testWord(3));
 686 
 687             CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(FPRInfo::fpRegT0), testWord64(0));
 688             CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(FPRInfo::fpRegT1), testWord64(1));
 689         });
 690 
 691         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 692         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 693 
<span class="line-modified"> 694         emitFunctionEpilogue(jit);</span>
 695         jit.ret();
 696     });
 697     CHECK_EQ(probeCallCount, 2);
 698 }
 699 
 700 static NEVER_INLINE NOT_TAIL_CALLED int testFunctionToTrashGPRs(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j)
 701 {
 702     if (j &gt; 0)
 703         return testFunctionToTrashGPRs(a + 1, b + a, c + b, d + 5, e - a, f * 1.5, g ^ a, h - b, i, j - 1);
 704     return a + 1;
 705 }
 706 static NEVER_INLINE NOT_TAIL_CALLED double testFunctionToTrashFPRs(double a, double b, double c, double d, double e, double f, double g, double h, double i, double j)
 707 {
 708     if (j &gt; 0)
 709         return testFunctionToTrashFPRs(a + 1, b + a, c + b, d + 5, e - a, f * 1.5, pow(g, a), h - b, i, j - 1);
 710     return a + 1;
 711 }
 712 
 713 void testProbePreservesGPRS()
 714 {
 715     // This test relies on testProbeReadsArgumentRegisters() and testProbeWritesArgumentRegisters()
 716     // having already validated that we can read and write from registers. We&#39;ll use these abilities
 717     // to validate that the probe preserves register values.
 718     unsigned probeCallCount = 0;
 719     CPUState originalState;
 720 
 721     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 722         emitFunctionPrologue(jit);</span>
 723 
 724         // Write expected values into the registers (except for sp, fp, and pc).
 725         jit.probe([&amp;] (Probe::Context&amp; context) {
 726             auto&amp; cpu = context.cpu;
 727             probeCallCount++;
 728             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 729                 originalState.gpr(id) = cpu.gpr(id);
 730                 if (isSpecialGPR(id))
 731                     continue;
 732                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
 733             }
 734             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
 735                 originalState.fpr(id) = cpu.fpr(id);
 736                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
 737             }
 738         });
 739 
 740         // Invoke the probe to call a lot of functions and trash register values.
 741         jit.probe([&amp;] (Probe::Context&amp;) {
 742             probeCallCount++;
</pre>
<hr />
<pre>
 776             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 777                 cpu.fpr(id) = originalState.fpr(id);
 778         });
 779 
 780         // Validate that the original state was restored.
 781         jit.probe([&amp;] (Probe::Context&amp; context) {
 782             auto&amp; cpu = context.cpu;
 783             probeCallCount++;
 784             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 785                 if (isSpecialGPR(id))
 786                     continue;
 787                 CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 788             }
 789             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 790 #if CPU(MIPS)
 791                 if (!(id &amp; 1))
 792 #endif
 793                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
 794         });
 795 
<span class="line-modified"> 796         emitFunctionEpilogue(jit);</span>
 797         jit.ret();
 798     });
 799     CHECK_EQ(probeCallCount, 5);
 800 }
 801 
 802 void testProbeModifiesStackPointer(WTF::Function&lt;void*(Probe::Context&amp;)&gt; computeModifiedStackPointer)
 803 {
 804     unsigned probeCallCount = 0;
 805     CPUState originalState;
 806     void* originalSP { nullptr };
 807     void* modifiedSP { nullptr };
 808 #if !(CPU(MIPS))
 809     uintptr_t modifiedFlags { 0 };
 810 #endif
 811 
 812 #if CPU(X86) || CPU(X86_64)
 813     auto flagsSPR = X86Registers::eflags;
 814     uintptr_t flagsMask = 0xc5;
 815 #elif CPU(ARM_THUMB2)
 816     auto flagsSPR = ARMRegisters::apsr;
 817     uintptr_t flagsMask = 0xf8000000;
 818 #elif CPU(ARM64)
 819     auto flagsSPR = ARM64Registers::nzcv;
 820     uintptr_t flagsMask = 0xf0000000;
 821 #endif
 822 
 823     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 824         emitFunctionPrologue(jit);</span>
 825 
 826         // Preserve original stack pointer and modify the sp, and
 827         // write expected values into other registers (except for fp, and pc).
 828         jit.probe([&amp;] (Probe::Context&amp; context) {
 829             auto&amp; cpu = context.cpu;
 830             probeCallCount++;
 831             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 832                 originalState.gpr(id) = cpu.gpr(id);
 833                 if (isSpecialGPR(id))
 834                     continue;
 835                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
 836             }
 837             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
 838                 originalState.fpr(id) = cpu.fpr(id);
 839                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
 840             }
 841 
 842 #if !(CPU(MIPS))
 843             originalState.spr(flagsSPR) = cpu.spr(flagsSPR);
 844             modifiedFlags = originalState.spr(flagsSPR) ^ flagsMask;
</pre>
<hr />
<pre>
 894         // Validate that the original state was restored.
 895         jit.probe([&amp;] (Probe::Context&amp; context) {
 896             auto&amp; cpu = context.cpu;
 897             probeCallCount++;
 898             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
 899                 if (isSpecialGPR(id))
 900                     continue;
 901                 CHECK_EQ(cpu.gpr(id), originalState.gpr(id));
 902             }
 903             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
 904 #if CPU(MIPS)
 905                 if (!(id &amp; 1))
 906 #endif
 907                 CHECK_EQ(cpu.fpr&lt;uint64_t&gt;(id), originalState.fpr&lt;uint64_t&gt;(id));
 908 #if !(CPU(MIPS))
 909             CHECK_EQ(cpu.spr(flagsSPR) &amp; flagsMask, originalState.spr(flagsSPR) &amp; flagsMask);
 910 #endif
 911             CHECK_EQ(cpu.sp(), originalSP);
 912         });
 913 
<span class="line-modified"> 914         emitFunctionEpilogue(jit);</span>
 915         jit.ret();
 916     });
 917     CHECK_EQ(probeCallCount, 4);
 918 }
 919 
 920 void testProbeModifiesStackPointerToInsideProbeStateOnStack()
 921 {
 922     size_t increment = sizeof(uintptr_t);
 923 #if CPU(ARM64)
 924     // The ARM64 probe uses ldp and stp which require 16 byte alignment.
 925     increment = 2 * sizeof(uintptr_t);
 926 #endif
 927     for (size_t offset = 0; offset &lt; sizeof(Probe::State); offset += increment) {
 928         testProbeModifiesStackPointer([=] (Probe::Context&amp; context) -&gt; void* {
 929             return reinterpret_cast&lt;uint8_t*&gt;(probeStateForContext(context)) + offset;
 930 
 931         });
 932     }
 933 }
 934 
</pre>
<hr />
<pre>
 944             return context.cpu.sp&lt;uint8_t*&gt;() - offset;
 945         });
 946     }
 947 }
 948 
 949 void testProbeModifiesProgramCounter()
 950 {
 951     // This test relies on testProbeReadsArgumentRegisters() and testProbeWritesArgumentRegisters()
 952     // having already validated that we can read and write from registers. We&#39;ll use these abilities
 953     // to validate that the probe preserves register values.
 954     unsigned probeCallCount = 0;
 955     bool continuationWasReached = false;
 956 
 957     MacroAssemblerCodeRef&lt;JSEntryPtrTag&gt; continuation = compile([&amp;] (CCallHelpers&amp; jit) {
 958         // Validate that we reached the continuation.
 959         jit.probe([&amp;] (Probe::Context&amp;) {
 960             probeCallCount++;
 961             continuationWasReached = true;
 962         });
 963 
<span class="line-modified"> 964         emitFunctionEpilogue(jit);</span>
 965         jit.ret();
 966     });
 967 
 968     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified"> 969         emitFunctionPrologue(jit);</span>
 970 
 971         // Write expected values into the registers.
 972         jit.probe([&amp;] (Probe::Context&amp; context) {
 973             probeCallCount++;
 974             context.cpu.pc() = untagCodePtr(continuation.code().executableAddress(), JSEntryPtrTag);
 975         });
 976 
 977         jit.breakpoint(); // We should never get here.
 978     });
 979     CHECK_EQ(probeCallCount, 2);
 980     CHECK_EQ(continuationWasReached, true);
 981 }
 982 
 983 void testProbeModifiesStackValues()
 984 {
 985     unsigned probeCallCount = 0;
 986     CPUState originalState;
 987     void* originalSP { nullptr };
 988     void* newSP { nullptr };
 989 #if !CPU(MIPS)
 990     uintptr_t modifiedFlags { 0 };
 991 #endif
 992     size_t numberOfExtraEntriesToWrite { 10 }; // ARM64 requires that this be 2 word aligned.
 993 
 994 #if CPU(X86) || CPU(X86_64)
 995     MacroAssembler::SPRegisterID flagsSPR = X86Registers::eflags;
 996     uintptr_t flagsMask = 0xc5;
 997 #elif CPU(ARM_THUMB2)
 998     MacroAssembler::SPRegisterID flagsSPR = ARMRegisters::apsr;
 999     uintptr_t flagsMask = 0xf8000000;
1000 #elif CPU(ARM64)
1001     MacroAssembler::SPRegisterID flagsSPR = ARM64Registers::nzcv;
1002     uintptr_t flagsMask = 0xf0000000;
1003 #endif
1004 
1005     compileAndRun&lt;void&gt;([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">1006         emitFunctionPrologue(jit);</span>
1007 
1008         // Write expected values into the registers.
1009         jit.probe([&amp;] (Probe::Context&amp; context) {
1010             auto&amp; cpu = context.cpu;
1011             auto&amp; stack = context.stack();
1012             probeCallCount++;
1013 
1014             // Preserve the original CPU state.
1015             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
1016                 originalState.gpr(id) = cpu.gpr(id);
1017                 if (isSpecialGPR(id))
1018                     continue;
1019                 cpu.gpr(id) = testWord(static_cast&lt;int&gt;(id));
1020             }
1021             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id)) {
1022                 originalState.fpr(id) = cpu.fpr(id);
1023                 cpu.fpr(id) = bitwise_cast&lt;double&gt;(testWord64(id));
1024             }
1025 #if !(CPU(MIPS))
1026             originalState.spr(flagsSPR) = cpu.spr(flagsSPR);
</pre>
<hr />
<pre>
1079                 CHECK_EQ(stack.get&lt;uintptr_t&gt;(p++), testWord(count++));
1080         });
1081 
1082         // Restore the original state.
1083         jit.probe([&amp;] (Probe::Context&amp; context) {
1084             auto&amp; cpu = context.cpu;
1085             probeCallCount++;
1086             for (auto id = CCallHelpers::firstRegister(); id &lt;= CCallHelpers::lastRegister(); id = nextID(id)) {
1087                 if (isSpecialGPR(id))
1088                     continue;
1089                 cpu.gpr(id) = originalState.gpr(id);
1090             }
1091             for (auto id = CCallHelpers::firstFPRegister(); id &lt;= CCallHelpers::lastFPRegister(); id = nextID(id))
1092                 cpu.fpr(id) = originalState.fpr(id);
1093 #if !(CPU(MIPS))
1094             cpu.spr(flagsSPR) = originalState.spr(flagsSPR);
1095 #endif
1096             cpu.sp() = originalSP;
1097         });
1098 
<span class="line-modified">1099         emitFunctionEpilogue(jit);</span>
1100         jit.ret();
1101     });
1102 
1103     CHECK_EQ(probeCallCount, 3);
1104 }
1105 #endif // ENABLE(MASM_PROBE)
1106 
<span class="line-added">1107 void testOrImmMem()</span>
<span class="line-added">1108 {</span>
<span class="line-added">1109     // FIXME: this does not test that the or does not touch beyond its width.</span>
<span class="line-added">1110     // I am not sure how to do such a test without a lot of complexity (running multiple threads, with a race on the high bits of the memory location).</span>
<span class="line-added">1111     uint64_t memoryLocation = 0x12341234;</span>
<span class="line-added">1112     auto or32 = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1113         emitFunctionPrologue(jit);</span>
<span class="line-added">1114         jit.or32(CCallHelpers::TrustedImm32(42), CCallHelpers::AbsoluteAddress(&amp;memoryLocation));</span>
<span class="line-added">1115         emitFunctionEpilogue(jit);</span>
<span class="line-added">1116         jit.ret();</span>
<span class="line-added">1117     });</span>
<span class="line-added">1118     invoke&lt;void&gt;(or32);</span>
<span class="line-added">1119     CHECK_EQ(memoryLocation, 0x12341234 | 42);</span>
<span class="line-added">1120 </span>
<span class="line-added">1121     memoryLocation = 0x12341234;</span>
<span class="line-added">1122     auto or16 = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1123         emitFunctionPrologue(jit);</span>
<span class="line-added">1124         jit.or16(CCallHelpers::TrustedImm32(42), CCallHelpers::AbsoluteAddress(&amp;memoryLocation));</span>
<span class="line-added">1125         emitFunctionEpilogue(jit);</span>
<span class="line-added">1126         jit.ret();</span>
<span class="line-added">1127     });</span>
<span class="line-added">1128     invoke&lt;void&gt;(or16);</span>
<span class="line-added">1129     CHECK_EQ(memoryLocation, 0x12341234 | 42);</span>
<span class="line-added">1130 </span>
<span class="line-added">1131     memoryLocation = 0x12341234;</span>
<span class="line-added">1132     auto or16InvalidLogicalImmInARM64 = compile([&amp;] (CCallHelpers&amp; jit) {</span>
<span class="line-added">1133         emitFunctionPrologue(jit);</span>
<span class="line-added">1134         jit.or16(CCallHelpers::TrustedImm32(0), CCallHelpers::AbsoluteAddress(&amp;memoryLocation));</span>
<span class="line-added">1135         emitFunctionEpilogue(jit);</span>
<span class="line-added">1136         jit.ret();</span>
<span class="line-added">1137     });</span>
<span class="line-added">1138     invoke&lt;void&gt;(or16InvalidLogicalImmInARM64);</span>
<span class="line-added">1139     CHECK_EQ(memoryLocation, 0x12341234);</span>
<span class="line-added">1140 }</span>
<span class="line-added">1141 </span>
1142 void testByteSwap()
1143 {
1144 #if CPU(X86_64) || CPU(ARM64)
1145     auto byteSwap16 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1146         emitFunctionPrologue(jit);</span>
1147         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1148         jit.byteSwap16(GPRInfo::returnValueGPR);
<span class="line-modified">1149         emitFunctionEpilogue(jit);</span>
1150         jit.ret();
1151     });
1152     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x2211));
1153     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap16, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff));
1154 
1155     auto byteSwap32 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1156         emitFunctionPrologue(jit);</span>
1157         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1158         jit.byteSwap32(GPRInfo::returnValueGPR);
<span class="line-modified">1159         emitFunctionEpilogue(jit);</span>
1160         jit.ret();
1161     });
1162     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100ee));
1163     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap32, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00ee));
1164 
1165     auto byteSwap64 = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1166         emitFunctionPrologue(jit);</span>
1167         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
1168         jit.byteSwap64(GPRInfo::returnValueGPR);
<span class="line-modified">1169         emitFunctionEpilogue(jit);</span>
1170         jit.ret();
1171     });
1172     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee001122), static_cast&lt;uint64_t&gt;(0x221100eeddccbbaa));
1173     CHECK_EQ(invoke&lt;uint64_t&gt;(byteSwap64, 0xaabbccddee00ffaa), static_cast&lt;uint64_t&gt;(0xaaff00eeddccbbaa));
1174 #endif
1175 }
1176 
1177 void testMoveDoubleConditionally32()
1178 {
1179 #if CPU(X86_64) | CPU(ARM64)
1180     double arg1 = 0;
1181     double arg2 = 0;
1182     const double zero = -0;
1183 
1184     const double chosenDouble = 6.00000059604644775390625;
1185     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
1186 
1187     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">1188         emitFunctionPrologue(jit);</span>
1189         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
1190         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
1191         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
1192 
1193         jit.move(MacroAssembler::TrustedImm32(-1), GPRInfo::regT0);
1194         jit.moveDoubleConditionally32(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
1195 
<span class="line-modified">1196         emitFunctionEpilogue(jit);</span>
1197         jit.ret();
1198     });
1199 
1200     arg1 = chosenDouble;
1201     arg2 = 43;
1202     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);
1203 
1204     arg1 = 43;
1205     arg2 = chosenDouble;
1206     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);
1207 
1208 #endif
1209 }
1210 
1211 void testMoveDoubleConditionally64()
1212 {
1213 #if CPU(X86_64) | CPU(ARM64)
1214     double arg1 = 0;
1215     double arg2 = 0;
1216     const double zero = -0;
1217 
1218     const double chosenDouble = 6.00000059604644775390625;
1219     CHECK_EQ(static_cast&lt;double&gt;(static_cast&lt;float&gt;(chosenDouble)) == chosenDouble, false);
1220 
1221     auto sel = compile([&amp;] (CCallHelpers&amp; jit) {
<span class="line-modified">1222         emitFunctionPrologue(jit);</span>
1223         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;zero), FPRInfo::returnValueFPR);
1224         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg1), FPRInfo::fpRegT1);
1225         jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;arg2), FPRInfo::fpRegT2);
1226 
1227         jit.move(MacroAssembler::TrustedImm64(-1), GPRInfo::regT0);
1228         jit.moveDoubleConditionally64(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
1229 
<span class="line-modified">1230         emitFunctionEpilogue(jit);</span>
1231         jit.ret();
1232     });
1233 
1234     arg1 = chosenDouble;
1235     arg2 = 43;
1236     CHECK_EQ(invoke&lt;double&gt;(sel), chosenDouble);
1237 
1238     arg1 = 43;
1239     arg2 = chosenDouble;
1240     CHECK_EQ(invoke&lt;double&gt;(sel), 43.0);
1241 
1242 #endif
1243 }
1244 
1245 static void testCagePreservesPACFailureBit()
1246 {
1247 #if GIGACAGE_ENABLED
<span class="line-modified">1248     // Placate ASan builds and any environments that disables the Gigacage.</span>
<span class="line-added">1249     if (!Gigacage::shouldBeEnabled())</span>
<span class="line-added">1250         return;</span>
<span class="line-added">1251 </span>
<span class="line-added">1252     RELEASE_ASSERT(!Gigacage::isDisablingPrimitiveGigacageForbidden());</span>
1253     auto cage = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1254         emitFunctionPrologue(jit);</span>
1255         jit.cageConditionally(Gigacage::Primitive, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
1256         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">1257         emitFunctionEpilogue(jit);</span>
1258         jit.ret();
1259     });
1260 
1261     void* ptr = Gigacage::tryMalloc(Gigacage::Primitive, 1);
1262     void* taggedPtr = tagArrayPtr(ptr, 1);
<span class="line-modified">1263     RELEASE_ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));</span>
1264     void* notCagedPtr = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) + (Gigacage::size(Gigacage::Primitive) &lt;&lt; 2));
1265     CHECK_NOT_EQ(Gigacage::caged(Gigacage::Primitive, notCagedPtr), notCagedPtr);
1266     void* taggedNotCagedPtr = tagArrayPtr(notCagedPtr, 1);
1267 
1268     if (isARM64E()) {
1269         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.
1270         CHECK_NOT_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
1271         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedNotCagedPtr, 1), untagArrayPtr(taggedPtr, 2));
1272     } else
1273         CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 2), ptr);
1274 
1275     CHECK_EQ(invoke&lt;void*&gt;(cage, taggedPtr, 1), ptr);
1276 
1277     auto cageWithoutAuthentication = compile([] (CCallHelpers&amp; jit) {
<span class="line-modified">1278         emitFunctionPrologue(jit);</span>
1279         jit.cageWithoutUntagging(Gigacage::Primitive, GPRInfo::argumentGPR0);
1280         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
<span class="line-modified">1281         emitFunctionEpilogue(jit);</span>
1282         jit.ret();
1283     });
1284 
1285     CHECK_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedPtr), taggedPtr);
1286     if (isARM64E()) {
1287         // FIXME: This won&#39;t work if authentication failures trap but I don&#39;t know how to test for that right now.
1288         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedNotCagedPtr);
1289         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), notCagedPtr);
1290         CHECK_NOT_EQ(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), taggedPtr);
1291         CHECK_NOT_EQ(untagArrayPtr(invoke&lt;void*&gt;(cageWithoutAuthentication, taggedNotCagedPtr), 1), ptr);
1292     }
1293 
1294     Gigacage::free(Gigacage::Primitive, ptr);
1295 #endif
1296 }
1297 
1298 #define RUN(test) do {                          \
1299         if (!shouldRun(#test))                  \
1300             break;                              \
1301         numberOfTests++;                        \
</pre>
<hr />
<pre>
1378     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrUnordered));
1379     RUN(testCompareFloat(MacroAssembler::DoubleLessThanOrEqualOrUnordered));
1380 #endif
1381 
1382 #if ENABLE(MASM_PROBE)
1383     RUN(testProbeReadsArgumentRegisters());
1384     RUN(testProbeWritesArgumentRegisters());
1385     RUN(testProbePreservesGPRS());
1386     RUN(testProbeModifiesStackPointerToInsideProbeStateOnStack());
1387     RUN(testProbeModifiesStackPointerToNBytesBelowSP());
1388     RUN(testProbeModifiesProgramCounter());
1389     RUN(testProbeModifiesStackValues());
1390 #endif // ENABLE(MASM_PROBE)
1391 
1392     RUN(testByteSwap());
1393     RUN(testMoveDoubleConditionally32());
1394     RUN(testMoveDoubleConditionally64());
1395 
1396     RUN(testCagePreservesPACFailureBit());
1397 
<span class="line-added">1398     RUN(testOrImmMem());</span>
<span class="line-added">1399 </span>
1400     if (tasks.isEmpty())
1401         usage();
1402 
1403     Lock lock;
1404 
1405     Vector&lt;Ref&lt;Thread&gt;&gt; threads;
1406     for (unsigned i = filter ? 1 : WTF::numberOfProcessorCores(); i--;) {
1407         threads.append(
1408             Thread::create(
1409                 &quot;testmasm thread&quot;,
1410                 [&amp;] () {
1411                     for (;;) {
1412                         RefPtr&lt;SharedTask&lt;void()&gt;&gt; task;
1413                         {
1414                             LockHolder locker(lock);
1415                             if (tasks.isEmpty())
1416                                 return;
1417                             task = tasks.takeFirst();
1418                         }
1419 
</pre>
</td>
</tr>
</table>
<center><a href="X86Registers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../b3/B3Bank.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
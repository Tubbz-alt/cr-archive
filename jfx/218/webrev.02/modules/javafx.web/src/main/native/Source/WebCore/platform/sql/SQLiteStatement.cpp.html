<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/sql/SQLiteStatement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2007, 2008 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SQLiteStatement.h&quot;
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &quot;SQLValue.h&quot;
 31 #include &lt;sqlite3.h&gt;
 32 #include &lt;wtf/Assertions.h&gt;
 33 #include &lt;wtf/Variant.h&gt;
 34 #include &lt;wtf/text/StringView.h&gt;
 35 
 36 // SQLite 3.6.16 makes sqlite3_prepare_v2 automatically retry preparing the statement
 37 // once if the database scheme has changed. We rely on this behavior.
 38 #if SQLITE_VERSION_NUMBER &lt; 3006016
 39 #error SQLite version 3.6.16 or newer is required
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 SQLiteStatement::SQLiteStatement(SQLiteDatabase&amp; db, const String&amp; sql)
 45     : m_database(db)
 46     , m_query(sql)
 47     , m_statement(0)
 48 {
 49 }
 50 
 51 SQLiteStatement::~SQLiteStatement()
 52 {
 53     finalize();
 54 }
 55 
 56 int SQLiteStatement::prepare()
 57 {
 58     ASSERT(!m_isPrepared);
 59 
 60     LockHolder databaseLock(m_database.databaseMutex());
 61 
 62     CString query = m_query.stripWhiteSpace().utf8();
 63 
 64     LOG(SQLDatabase, &quot;SQL - prepare - %s&quot;, query.data());
 65 
 66     // Pass the length of the string including the null character to sqlite3_prepare_v2;
 67     // this lets SQLite avoid an extra string copy.
 68     size_t lengthIncludingNullCharacter = query.length() + 1;
 69 
 70     const char* tail = nullptr;
 71     int error = sqlite3_prepare_v2(m_database.sqlite3Handle(), query.data(), lengthIncludingNullCharacter, &amp;m_statement, &amp;tail);
 72 
 73     if (error != SQLITE_OK)
 74         LOG(SQLDatabase, &quot;sqlite3_prepare16 failed (%i)\n%s\n%s&quot;, error, query.data(), sqlite3_errmsg(m_database.sqlite3Handle()));
 75 
 76     if (tail &amp;&amp; *tail)
 77         error = SQLITE_ERROR;
 78 
 79 #if ASSERT_ENABLED
 80     m_isPrepared = error == SQLITE_OK;
 81 #endif
 82     return error;
 83 }
 84 
 85 int SQLiteStatement::step()
 86 {
 87     LockHolder databaseLock(m_database.databaseMutex());
 88 
 89     if (!m_statement)
 90         return SQLITE_OK;
 91 
 92     // The database needs to update its last changes count before each statement
 93     // in order to compute properly the lastChanges() return value.
 94     m_database.updateLastChangesCount();
 95 
 96     LOG(SQLDatabase, &quot;SQL - step - %s&quot;, m_query.ascii().data());
 97     int error = sqlite3_step(m_statement);
 98     if (error != SQLITE_DONE &amp;&amp; error != SQLITE_ROW) {
 99         LOG(SQLDatabase, &quot;sqlite3_step failed (%i)\nQuery - %s\nError - %s&quot;,
100             error, m_query.ascii().data(), sqlite3_errmsg(m_database.sqlite3Handle()));
101     }
102 
103     return error;
104 }
105 
106 int SQLiteStatement::finalize()
107 {
108 #if ASSERT_ENABLED
109     m_isPrepared = false;
110 #endif
111     if (!m_statement)
112         return SQLITE_OK;
113     LOG(SQLDatabase, &quot;SQL - finalize - %s&quot;, m_query.ascii().data());
114     int result = sqlite3_finalize(m_statement);
115     m_statement = 0;
116     return result;
117 }
118 
119 int SQLiteStatement::reset()
120 {
121     ASSERT(m_isPrepared);
122     if (!m_statement)
123         return SQLITE_OK;
124     LOG(SQLDatabase, &quot;SQL - reset - %s&quot;, m_query.ascii().data());
125     return sqlite3_reset(m_statement);
126 }
127 
128 bool SQLiteStatement::executeCommand()
129 {
130     if (!m_statement &amp;&amp; prepare() != SQLITE_OK)
131         return false;
132     ASSERT(m_isPrepared);
133     if (step() != SQLITE_DONE) {
134         finalize();
135         return false;
136     }
137     finalize();
138     return true;
139 }
140 
141 bool SQLiteStatement::returnsAtLeastOneResult()
142 {
143     if (!m_statement &amp;&amp; prepare() != SQLITE_OK)
144         return false;
145     ASSERT(m_isPrepared);
146     if (step() != SQLITE_ROW) {
147         finalize();
148         return false;
149     }
150     finalize();
151     return true;
152 
153 }
154 
155 int SQLiteStatement::bindBlob(int index, const void* blob, int size)
156 {
157     ASSERT(m_isPrepared);
158     ASSERT(index &gt; 0);
159     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
160     ASSERT(blob || !size);
161     ASSERT(size &gt;= 0);
162 
163     if (!m_statement)
164         return SQLITE_ERROR;
165 
166     return sqlite3_bind_blob(m_statement, index, blob, size, SQLITE_TRANSIENT);
167 }
168 
169 int SQLiteStatement::bindBlob(int index, const String&amp; text)
170 {
171     // String::characters() returns 0 for the empty string, which SQLite
172     // treats as a null, so we supply a non-null pointer for that case.
173     auto upconvertedCharacters = StringView(text).upconvertedCharacters();
174     UChar anyCharacter = 0;
175     const UChar* characters;
176     if (text.isEmpty() &amp;&amp; !text.isNull())
177         characters = &amp;anyCharacter;
178     else
179         characters = upconvertedCharacters;
180 
181     return bindBlob(index, characters, text.length() * sizeof(UChar));
182 }
183 
184 int SQLiteStatement::bindText(int index, const String&amp; text)
185 {
186     ASSERT(m_isPrepared);
187     ASSERT(index &gt; 0);
188     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
189 
190     // String::characters() returns 0 for the empty string, which SQLite
191     // treats as a null, so we supply a non-null pointer for that case.
192     auto upconvertedCharacters = StringView(text).upconvertedCharacters();
193     UChar anyCharacter = 0;
194     const UChar* characters;
195     if (text.isEmpty() &amp;&amp; !text.isNull())
196         characters = &amp;anyCharacter;
197     else
198         characters = upconvertedCharacters;
199 
200     return sqlite3_bind_text16(m_statement, index, characters, sizeof(UChar) * text.length(), SQLITE_TRANSIENT);
201 }
202 
203 int SQLiteStatement::bindInt(int index, int integer)
204 {
205     ASSERT(m_isPrepared);
206     ASSERT(index &gt; 0);
207     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
208 
209     return sqlite3_bind_int(m_statement, index, integer);
210 }
211 
212 int SQLiteStatement::bindInt64(int index, int64_t integer)
213 {
214     ASSERT(m_isPrepared);
215     ASSERT(index &gt; 0);
216     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
217 
218     return sqlite3_bind_int64(m_statement, index, integer);
219 }
220 
221 int SQLiteStatement::bindDouble(int index, double number)
222 {
223     ASSERT(m_isPrepared);
224     ASSERT(index &gt; 0);
225     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
226 
227     return sqlite3_bind_double(m_statement, index, number);
228 }
229 
230 int SQLiteStatement::bindNull(int index)
231 {
232     ASSERT(m_isPrepared);
233     ASSERT(index &gt; 0);
234     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
235 
236     return sqlite3_bind_null(m_statement, index);
237 }
238 
239 int SQLiteStatement::bindValue(int index, const SQLValue&amp; value)
240 {
241     return WTF::switchOn(value,
242         [&amp;] (const std::nullptr_t&amp;) { return bindNull(index); },
243         [&amp;] (const String&amp; string) { return bindText(index, string); },
244         [&amp;] (double number) { return bindDouble(index, number); }
245     );
246 }
247 
248 unsigned SQLiteStatement::bindParameterCount() const
249 {
250     ASSERT(m_isPrepared);
251     if (!m_statement)
252         return 0;
253     return sqlite3_bind_parameter_count(m_statement);
254 }
255 
256 int SQLiteStatement::columnCount()
257 {
258     ASSERT(m_isPrepared);
259     if (!m_statement)
260         return 0;
261     return sqlite3_data_count(m_statement);
262 }
263 
264 bool SQLiteStatement::isColumnNull(int col)
265 {
266     ASSERT(col &gt;= 0);
267     if (!m_statement)
268         if (prepareAndStep() != SQLITE_ROW)
269             return false;
270     if (columnCount() &lt;= col)
271         return false;
272 
273     return sqlite3_column_type(m_statement, col) == SQLITE_NULL;
274 }
275 
276 bool SQLiteStatement::isColumnDeclaredAsBlob(int col)
277 {
278     ASSERT(col &gt;= 0);
279     if (!m_statement) {
280         if (prepare() != SQLITE_OK)
281             return false;
282     }
283     return equalLettersIgnoringASCIICase(StringView(sqlite3_column_decltype(m_statement, col)), &quot;blob&quot;);
284 }
285 
286 String SQLiteStatement::getColumnName(int col)
287 {
288     ASSERT(col &gt;= 0);
289     if (!m_statement)
290         if (prepareAndStep() != SQLITE_ROW)
291             return String();
292     if (columnCount() &lt;= col)
293         return String();
294     return String(reinterpret_cast&lt;const UChar*&gt;(sqlite3_column_name16(m_statement, col)));
295 }
296 
297 SQLValue SQLiteStatement::getColumnValue(int col)
298 {
299     ASSERT(col &gt;= 0);
300     if (!m_statement)
301         if (prepareAndStep() != SQLITE_ROW)
302             return nullptr;
303     if (columnCount() &lt;= col)
304         return nullptr;
305 
306     // SQLite is typed per value. optional column types are
307     // &quot;(mostly) ignored&quot;
308     sqlite3_value* value = sqlite3_column_value(m_statement, col);
309     switch (sqlite3_value_type(value)) {
310         case SQLITE_INTEGER:    // SQLValue and JS don&#39;t represent integers, so use FLOAT -case
311         case SQLITE_FLOAT:
312             return sqlite3_value_double(value);
313         case SQLITE_BLOB:       // SQLValue and JS don&#39;t represent blobs, so use TEXT -case
314         case SQLITE_TEXT: {
315             const UChar* string = reinterpret_cast&lt;const UChar*&gt;(sqlite3_value_text16(value));
316             return StringImpl::create8BitIfPossible(string);
317         }
318         case SQLITE_NULL:
319             return nullptr;
320         default:
321             break;
322     }
323 
324     ASSERT_NOT_REACHED();
325     return nullptr;
326 }
327 
328 String SQLiteStatement::getColumnText(int col)
329 {
330     ASSERT(col &gt;= 0);
331     if (!m_statement)
332         if (prepareAndStep() != SQLITE_ROW)
333             return String();
334     if (columnCount() &lt;= col)
335         return String();
336     return String(reinterpret_cast&lt;const UChar*&gt;(sqlite3_column_text16(m_statement, col)), sqlite3_column_bytes16(m_statement, col) / sizeof(UChar));
337 }
338 
339 double SQLiteStatement::getColumnDouble(int col)
340 {
341     ASSERT(col &gt;= 0);
342     if (!m_statement)
343         if (prepareAndStep() != SQLITE_ROW)
344             return 0.0;
345     if (columnCount() &lt;= col)
346         return 0.0;
347     return sqlite3_column_double(m_statement, col);
348 }
349 
350 int SQLiteStatement::getColumnInt(int col)
351 {
352     ASSERT(col &gt;= 0);
353     if (!m_statement)
354         if (prepareAndStep() != SQLITE_ROW)
355             return 0;
356     if (columnCount() &lt;= col)
357         return 0;
358     return sqlite3_column_int(m_statement, col);
359 }
360 
361 int64_t SQLiteStatement::getColumnInt64(int col)
362 {
363     ASSERT(col &gt;= 0);
364     if (!m_statement)
365         if (prepareAndStep() != SQLITE_ROW)
366             return 0;
367     if (columnCount() &lt;= col)
368         return 0;
369     return sqlite3_column_int64(m_statement, col);
370 }
371 
372 String SQLiteStatement::getColumnBlobAsString(int col)
373 {
374     ASSERT(col &gt;= 0);
375 
376     if (!m_statement &amp;&amp; prepareAndStep() != SQLITE_ROW)
377         return String();
378 
379     if (columnCount() &lt;= col)
380         return String();
381 
382     const void* blob = sqlite3_column_blob(m_statement, col);
383     if (!blob)
384         return emptyString();
385 
386     int size = sqlite3_column_bytes(m_statement, col);
387     if (size &lt; 0)
388         return String();
389 
390     ASSERT(!(size % sizeof(UChar)));
391     return String(static_cast&lt;const UChar*&gt;(blob), size / sizeof(UChar));
392 }
393 
394 void SQLiteStatement::getColumnBlobAsVector(int col, Vector&lt;char&gt;&amp; result)
395 {
396     ASSERT(col &gt;= 0);
397 
398     if (!m_statement &amp;&amp; prepareAndStep() != SQLITE_ROW) {
399         result.clear();
400         return;
401     }
402 
403     if (columnCount() &lt;= col) {
404         result.clear();
405         return;
406     }
407 
408     const void* blob = sqlite3_column_blob(m_statement, col);
409     if (!blob) {
410         result.clear();
411         return;
412     }
413 
414     int size = sqlite3_column_bytes(m_statement, col);
415     result.resize((size_t)size);
416     for (int i = 0; i &lt; size; ++i)
417         result[i] = (static_cast&lt;const unsigned char*&gt;(blob))[i];
418 }
419 
420 void SQLiteStatement::getColumnBlobAsVector(int col, Vector&lt;uint8_t&gt;&amp; result)
421 {
422     ASSERT(col &gt;= 0);
423 
424     if (!m_statement &amp;&amp; prepareAndStep() != SQLITE_ROW) {
425         result.clear();
426         return;
427     }
428 
429     if (columnCount() &lt;= col) {
430         result.clear();
431         return;
432     }
433 
434     const void* blob = sqlite3_column_blob(m_statement, col);
435     if (!blob) {
436         result.clear();
437         return;
438     }
439 
440     int size = sqlite3_column_bytes(m_statement, col);
441     result.resize((size_t)size);
442     for (int i = 0; i &lt; size; ++i)
443         result[i] = (static_cast&lt;const uint8_t*&gt;(blob))[i];
444 }
445 
446 bool SQLiteStatement::returnTextResults(int col, Vector&lt;String&gt;&amp; v)
447 {
448     ASSERT(col &gt;= 0);
449 
450     v.clear();
451 
452     if (m_statement)
453         finalize();
454     if (prepare() != SQLITE_OK)
455         return false;
456 
457     while (step() == SQLITE_ROW)
458         v.append(getColumnText(col));
459     bool result = true;
460     if (m_database.lastError() != SQLITE_DONE) {
461         result = false;
462         LOG(SQLDatabase, &quot;Error reading results from database query %s&quot;, m_query.ascii().data());
463     }
464     finalize();
465     return result;
466 }
467 
468 bool SQLiteStatement::returnIntResults(int col, Vector&lt;int&gt;&amp; v)
469 {
470     v.clear();
471 
472     if (m_statement)
473         finalize();
474     if (prepare() != SQLITE_OK)
475         return false;
476 
477     while (step() == SQLITE_ROW)
478         v.append(getColumnInt(col));
479     bool result = true;
480     if (m_database.lastError() != SQLITE_DONE) {
481         result = false;
482         LOG(SQLDatabase, &quot;Error reading results from database query %s&quot;, m_query.ascii().data());
483     }
484     finalize();
485     return result;
486 }
487 
488 bool SQLiteStatement::returnInt64Results(int col, Vector&lt;int64_t&gt;&amp; v)
489 {
490     v.clear();
491 
492     if (m_statement)
493         finalize();
494     if (prepare() != SQLITE_OK)
495         return false;
496 
497     while (step() == SQLITE_ROW)
498         v.append(getColumnInt64(col));
499     bool result = true;
500     if (m_database.lastError() != SQLITE_DONE) {
501         result = false;
502         LOG(SQLDatabase, &quot;Error reading results from database query %s&quot;, m_query.ascii().data());
503     }
504     finalize();
505     return result;
506 }
507 
508 bool SQLiteStatement::returnDoubleResults(int col, Vector&lt;double&gt;&amp; v)
509 {
510     v.clear();
511 
512     if (m_statement)
513         finalize();
514     if (prepare() != SQLITE_OK)
515         return false;
516 
517     while (step() == SQLITE_ROW)
518         v.append(getColumnDouble(col));
519     bool result = true;
520     if (m_database.lastError() != SQLITE_DONE) {
521         result = false;
522         LOG(SQLDatabase, &quot;Error reading results from database query %s&quot;, m_query.ascii().data());
523     }
524     finalize();
525     return result;
526 }
527 
528 bool SQLiteStatement::isExpired()
529 {
530     return !m_statement;
531 }
532 
533 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeUpdaterGeneratedContent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeUpdaterGeneratedContent.h&quot;
 28 
 29 #include &quot;ContentData.h&quot;
 30 #include &quot;InspectorInstrumentation.h&quot;
 31 #include &quot;PseudoElement.h&quot;
 32 #include &quot;RenderDescendantIterator.h&quot;
 33 #include &quot;RenderElement.h&quot;
 34 #include &quot;RenderImage.h&quot;
 35 #include &quot;RenderQuote.h&quot;
 36 #include &quot;RenderTreeUpdater.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 37 #include &quot;RenderView.h&quot;</span>
 38 #include &quot;StyleTreeResolver.h&quot;
 39 
 40 namespace WebCore {
 41 
 42 RenderTreeUpdater::GeneratedContent::GeneratedContent(RenderTreeUpdater&amp; updater)
 43     : m_updater(updater)
 44 {
 45 }
 46 
 47 void RenderTreeUpdater::GeneratedContent::updateRemainingQuotes()
 48 {
 49     if (!m_updater.renderView().hasQuotesNeedingUpdate())
 50         return;
 51     updateQuotesUpTo(nullptr);
 52     m_previousUpdatedQuote = nullptr;
 53     m_updater.renderView().setHasQuotesNeedingUpdate(false);
 54 }
 55 
 56 void RenderTreeUpdater::GeneratedContent::updateQuotesUpTo(RenderQuote* lastQuote)
 57 {
 58     auto quoteRenderers = descendantsOfType&lt;RenderQuote&gt;(m_updater.renderView());
 59     auto it = m_previousUpdatedQuote ? ++quoteRenderers.at(*m_previousUpdatedQuote) : quoteRenderers.begin();
 60     auto end = quoteRenderers.end();
 61     for (; it != end; ++it) {
 62         auto&amp; quote = *it;
 63         // Quote character depends on quote depth so we chain the updates.
 64         quote.updateRenderer(m_updater.m_builder, m_previousUpdatedQuote.get());
 65         m_previousUpdatedQuote = makeWeakPtr(quote);
 66         if (&amp;quote == lastQuote)
 67             return;
 68     }
 69     ASSERT(!lastQuote);
 70 }
 71 
 72 static void createContentRenderers(RenderTreeBuilder&amp; builder, RenderElement&amp; pseudoRenderer, const RenderStyle&amp; style)
 73 {
 74     ASSERT(style.contentData());
 75 
 76     for (const ContentData* content = style.contentData(); content; content = content-&gt;next()) {
 77         auto child = content-&gt;createContentRenderer(pseudoRenderer.document(), style);
 78         if (pseudoRenderer.isChildAllowed(*child, style))
 79             builder.attach(pseudoRenderer, WTFMove(child));
 80     }
 81 }
 82 
 83 static void updateStyleForContentRenderers(RenderElement&amp; pseudoRenderer, const RenderStyle&amp; style)
 84 {
 85     for (auto&amp; contentRenderer : descendantsOfType&lt;RenderElement&gt;(pseudoRenderer)) {
 86         // We only manage the style for the generated content which must be images or text.
 87         if (!is&lt;RenderImage&gt;(contentRenderer) &amp;&amp; !is&lt;RenderQuote&gt;(contentRenderer))
 88             continue;
 89         contentRenderer.setStyle(RenderStyle::createStyleInheritingFromPseudoStyle(style));
 90     }
 91 }
 92 
 93 void RenderTreeUpdater::GeneratedContent::updatePseudoElement(Element&amp; current, const Optional&lt;Style::ElementUpdate&gt;&amp; update, PseudoId pseudoId)
 94 {
 95     PseudoElement* pseudoElement = pseudoId == PseudoId::Before ? current.beforePseudoElement() : current.afterPseudoElement();
 96 
 97     if (auto* renderer = pseudoElement ? pseudoElement-&gt;renderer() : nullptr)
 98         m_updater.renderTreePosition().invalidateNextSibling(*renderer);
 99 
100     if (!needsPseudoElement(update)) {
101         if (pseudoElement) {
102             if (pseudoId == PseudoId::Before)
103                 removeBeforePseudoElement(current, m_updater.m_builder);
104             else
105                 removeAfterPseudoElement(current, m_updater.m_builder);
106         }
107         return;
108     }
109 
110     RefPtr&lt;PseudoElement&gt; newPseudoElement;
111     if (!pseudoElement) {
112         newPseudoElement = PseudoElement::create(current, pseudoId);
113         pseudoElement = newPseudoElement.get();
114     }
115 
116     if (update-&gt;change == Style::NoChange)
117         return;
118 
119     if (newPseudoElement) {
120         if (pseudoId == PseudoId::Before)
121             current.setBeforePseudoElement(newPseudoElement.releaseNonNull());
122         else
123             current.setAfterPseudoElement(newPseudoElement.releaseNonNull());
124     }
125 
126     if (update-&gt;style-&gt;display() == DisplayType::Contents) {
127         // For display:contents we create an inline wrapper that inherits its
128         // style from the display:contents style.
129         auto contentsStyle = RenderStyle::createPtr();
130         contentsStyle-&gt;setStyleType(pseudoId);
131         contentsStyle-&gt;inheritFrom(*update-&gt;style);
132         contentsStyle-&gt;copyContentFrom(*update-&gt;style);
133 
134         Style::ElementUpdate contentsUpdate { WTFMove(contentsStyle), update-&gt;change, update-&gt;recompositeLayer };
135         m_updater.updateElementRenderer(*pseudoElement, contentsUpdate);
136         pseudoElement-&gt;storeDisplayContentsStyle(RenderStyle::clonePtr(*update-&gt;style));
137     } else {
138         m_updater.updateElementRenderer(*pseudoElement, *update);
139         ASSERT(!pseudoElement-&gt;hasDisplayContents());
140     }
141 
142     auto* pseudoElementRenderer = pseudoElement-&gt;renderer();
143     if (!pseudoElementRenderer)
144         return;
145 
146     if (update-&gt;change == Style::Detach)
147         createContentRenderers(m_updater.m_builder, *pseudoElementRenderer, *update-&gt;style);
148     else
149         updateStyleForContentRenderers(*pseudoElementRenderer, *update-&gt;style);
150 
151     if (m_updater.renderView().hasQuotesNeedingUpdate()) {
152         for (auto&amp; child : descendantsOfType&lt;RenderQuote&gt;(*pseudoElementRenderer))
153             updateQuotesUpTo(&amp;child);
154     }
155     m_updater.m_builder.updateAfterDescendants(*pseudoElementRenderer);
156 }
157 
158 bool RenderTreeUpdater::GeneratedContent::needsPseudoElement(const Optional&lt;Style::ElementUpdate&gt;&amp; update)
159 {
160     if (!update)
161         return false;
162     if (!m_updater.renderTreePosition().parent().canHaveGeneratedChildren())
163         return false;
164     if (!pseudoElementRendererIsNeeded(update-&gt;style.get()))
165         return false;
166     return true;
167 }
168 
169 void RenderTreeUpdater::GeneratedContent::removeBeforePseudoElement(Element&amp; element, RenderTreeBuilder&amp; builder)
170 {
171     auto* pseudoElement = element.beforePseudoElement();
172     if (!pseudoElement)
173         return;
174     tearDownRenderers(*pseudoElement, TeardownType::Full, builder);
175     element.clearBeforePseudoElement();
176 }
177 
178 void RenderTreeUpdater::GeneratedContent::removeAfterPseudoElement(Element&amp; element, RenderTreeBuilder&amp; builder)
179 {
180     auto* pseudoElement = element.afterPseudoElement();
181     if (!pseudoElement)
182         return;
183     tearDownRenderers(*pseudoElement, TeardownType::Full, builder);
184     element.clearAfterPseudoElement();
185 }
186 
187 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMExceptionHandling.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertXPathNSResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMExceptionHandling.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMExceptionHandling.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,57 ***</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! void reportException(ExecState* exec, JSValue exceptionValue, CachedScript* cachedScript)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      auto* exception = jsDynamicCast&lt;JSC::Exception*&gt;(vm, exceptionValue);
      if (!exception) {
          exception = vm.lastException();
          if (!exception)
<span class="line-modified">!             exception = JSC::Exception::create(exec-&gt;vm(), exceptionValue, JSC::Exception::DoNotCaptureStack);</span>
      }
  
<span class="line-modified">!     reportException(exec, exception, cachedScript);</span>
  }
  
<span class="line-modified">! String retrieveErrorMessage(ExecState&amp; state, VM&amp; vm, JSValue exception, CatchScope&amp; catchScope)</span>
  {
      // FIXME: &lt;http://webkit.org/b/115087&gt; Web Inspector: WebCore::reportException should not evaluate JavaScript handling exceptions
      // If this is a custom exception object, call toString on it to try and get a nice string representation for the exception.
      String errorMessage;
      if (auto* error = jsDynamicCast&lt;ErrorInstance*&gt;(vm, exception))
<span class="line-modified">!         errorMessage = error-&gt;sanitizedToString(&amp;state);</span>
      else
<span class="line-modified">!         errorMessage = exception.toWTFString(&amp;state);</span>
  
      // We need to clear any new exception that may be thrown in the toString() call above.
      // reportException() is not supposed to be making new exceptions.
      catchScope.clearException();
      vm.clearLastException();
      return errorMessage;
  }
  
<span class="line-modified">! void reportException(ExecState* exec, JSC::Exception* exception, CachedScript* cachedScript, ExceptionDetails* exceptionDetails)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (isTerminatedExecutionException(vm, exception))
          return;
  
<span class="line-modified">!     ErrorHandlingScope errorScope(exec-&gt;vm());</span>
  
<span class="line-modified">!     auto callStack = Inspector::createScriptCallStackFromException(exec, exception);</span>
      scope.clearException();
      vm.clearLastException();
  
<span class="line-modified">!     auto* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(exec-&gt;lexicalGlobalObject());</span>
      if (auto* window = jsDynamicCast&lt;JSDOMWindow*&gt;(vm, globalObject)) {
          if (!window-&gt;wrapped().isCurrentlyDisplayedInFrame())
              return;
      }
  
<span class="line-new-header">--- 37,57 ---</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! void reportException(JSGlobalObject* lexicalGlobalObject, JSValue exceptionValue, CachedScript* cachedScript)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      auto* exception = jsDynamicCast&lt;JSC::Exception*&gt;(vm, exceptionValue);
      if (!exception) {
          exception = vm.lastException();
          if (!exception)
<span class="line-modified">!             exception = JSC::Exception::create(lexicalGlobalObject-&gt;vm(), exceptionValue, JSC::Exception::DoNotCaptureStack);</span>
      }
  
<span class="line-modified">!     reportException(lexicalGlobalObject, exception, cachedScript);</span>
  }
  
<span class="line-modified">! String retrieveErrorMessage(JSGlobalObject&amp; lexicalGlobalObject, VM&amp; vm, JSValue exception, CatchScope&amp; catchScope)</span>
  {
      // FIXME: &lt;http://webkit.org/b/115087&gt; Web Inspector: WebCore::reportException should not evaluate JavaScript handling exceptions
      // If this is a custom exception object, call toString on it to try and get a nice string representation for the exception.
      String errorMessage;
      if (auto* error = jsDynamicCast&lt;ErrorInstance*&gt;(vm, exception))
<span class="line-modified">!         errorMessage = error-&gt;sanitizedToString(&amp;lexicalGlobalObject);</span>
      else
<span class="line-modified">!         errorMessage = exception.toWTFString(&amp;lexicalGlobalObject);</span>
  
      // We need to clear any new exception that may be thrown in the toString() call above.
      // reportException() is not supposed to be making new exceptions.
      catchScope.clearException();
      vm.clearLastException();
      return errorMessage;
  }
  
<span class="line-modified">! void reportException(JSGlobalObject* lexicalGlobalObject, JSC::Exception* exception, CachedScript* cachedScript, ExceptionDetails* exceptionDetails)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (isTerminatedExecutionException(vm, exception))
          return;
  
<span class="line-modified">!     ErrorHandlingScope errorScope(lexicalGlobalObject-&gt;vm());</span>
  
<span class="line-modified">!     auto callStack = Inspector::createScriptCallStackFromException(lexicalGlobalObject, exception);</span>
      scope.clearException();
      vm.clearLastException();
  
<span class="line-modified">!     auto* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject);</span>
      if (auto* window = jsDynamicCast&lt;JSDOMWindow*&gt;(vm, globalObject)) {
          if (!window-&gt;wrapped().isCurrentlyDisplayedInFrame())
              return;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,76 ***</span>
          lineNumber = callFrame-&gt;lineNumber();
          columnNumber = callFrame-&gt;columnNumber();
          exceptionSourceURL = callFrame-&gt;sourceURL();
      }
  
<span class="line-modified">!     auto errorMessage = retrieveErrorMessage(*exec, vm, exception-&gt;value(), scope);</span>
      globalObject-&gt;scriptExecutionContext()-&gt;reportException(errorMessage, lineNumber, columnNumber, exceptionSourceURL, exception, callStack-&gt;size() ? callStack.ptr() : nullptr, cachedScript);
  
      if (exceptionDetails) {
          exceptionDetails-&gt;message = errorMessage;
          exceptionDetails-&gt;lineNumber = lineNumber;
          exceptionDetails-&gt;columnNumber = columnNumber;
          exceptionDetails-&gt;sourceURL = exceptionSourceURL;
      }
  }
  
<span class="line-modified">! void reportCurrentException(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
      auto* exception = scope.exception();
      scope.clearException();
<span class="line-modified">!     reportException(exec, exception);</span>
  }
  
<span class="line-modified">! JSValue createDOMException(ExecState* exec, ExceptionCode ec, const String&amp; message)</span>
  {
      if (ec == ExistingExceptionError)
          return jsUndefined();
  
      // FIXME: Handle other WebIDL exception types.
      if (ec == TypeError) {
          if (message.isEmpty())
<span class="line-modified">!             return createTypeError(exec);</span>
<span class="line-modified">!         return createTypeError(exec, message);</span>
      }
  
      if (ec == RangeError) {
          if (message.isEmpty())
<span class="line-modified">!             return createRangeError(exec, &quot;Bad value&quot;_s);</span>
<span class="line-modified">!         return createRangeError(exec, message);</span>
      }
  
      if (ec == StackOverflowError)
<span class="line-modified">!         return createStackOverflowError(exec);</span>
  
      // FIXME: All callers to createDOMException need to pass in the correct global object.
      // For now, we&#39;re going to assume the lexicalGlobalObject. Which is wrong in cases like this:
      // frames[0].document.createElement(null, null); // throws an exception which should have the subframe&#39;s prototypes.
<span class="line-modified">!     JSDOMGlobalObject* globalObject = deprecatedGlobalObjectForPrototype(exec);</span>
<span class="line-modified">!     JSValue errorObject = toJS(exec, globalObject, DOMException::create(ec, message));</span>
  
      ASSERT(errorObject);
<span class="line-modified">!     addErrorInfo(exec, asObject(errorObject), true);</span>
      return errorObject;
  }
  
<span class="line-modified">! JSValue createDOMException(ExecState&amp; state, Exception&amp;&amp; exception)</span>
  {
<span class="line-modified">!     return createDOMException(&amp;state, exception.code(), exception.releaseMessage());</span>
  }
  
<span class="line-modified">! void propagateExceptionSlowPath(JSC::ExecState&amp; state, JSC::ThrowScope&amp; throwScope, Exception&amp;&amp; exception)</span>
  {
      throwScope.assertNoException();
<span class="line-modified">!     throwException(&amp;state, throwScope, createDOMException(state, WTFMove(exception)));</span>
  }
  
<span class="line-modified">! static EncodedJSValue throwTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const String&amp; errorMessage)</span>
  {
<span class="line-modified">!     return throwVMTypeError(&amp;state, scope, errorMessage);</span>
  }
  
  static void appendArgumentMustBe(StringBuilder&amp; builder, unsigned argumentIndex, const char* argumentName, const char* interfaceName, const char* functionName)
  {
      builder.append(&quot;Argument &quot;, argumentIndex + 1, &quot; (&#39;&quot;, argumentName, &quot;&#39;) to &quot;);
<span class="line-new-header">--- 98,76 ---</span>
          lineNumber = callFrame-&gt;lineNumber();
          columnNumber = callFrame-&gt;columnNumber();
          exceptionSourceURL = callFrame-&gt;sourceURL();
      }
  
<span class="line-modified">!     auto errorMessage = retrieveErrorMessage(*lexicalGlobalObject, vm, exception-&gt;value(), scope);</span>
      globalObject-&gt;scriptExecutionContext()-&gt;reportException(errorMessage, lineNumber, columnNumber, exceptionSourceURL, exception, callStack-&gt;size() ? callStack.ptr() : nullptr, cachedScript);
  
      if (exceptionDetails) {
          exceptionDetails-&gt;message = errorMessage;
          exceptionDetails-&gt;lineNumber = lineNumber;
          exceptionDetails-&gt;columnNumber = columnNumber;
          exceptionDetails-&gt;sourceURL = exceptionSourceURL;
      }
  }
  
<span class="line-modified">! void reportCurrentException(JSGlobalObject* lexicalGlobalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
      auto* exception = scope.exception();
      scope.clearException();
<span class="line-modified">!     reportException(lexicalGlobalObject, exception);</span>
  }
  
<span class="line-modified">! JSValue createDOMException(JSGlobalObject* lexicalGlobalObject, ExceptionCode ec, const String&amp; message)</span>
  {
      if (ec == ExistingExceptionError)
          return jsUndefined();
  
      // FIXME: Handle other WebIDL exception types.
      if (ec == TypeError) {
          if (message.isEmpty())
<span class="line-modified">!             return createTypeError(lexicalGlobalObject);</span>
<span class="line-modified">!         return createTypeError(lexicalGlobalObject, message);</span>
      }
  
      if (ec == RangeError) {
          if (message.isEmpty())
<span class="line-modified">!             return createRangeError(lexicalGlobalObject, &quot;Bad value&quot;_s);</span>
<span class="line-modified">!         return createRangeError(lexicalGlobalObject, message);</span>
      }
  
      if (ec == StackOverflowError)
<span class="line-modified">!         return createStackOverflowError(lexicalGlobalObject);</span>
  
      // FIXME: All callers to createDOMException need to pass in the correct global object.
      // For now, we&#39;re going to assume the lexicalGlobalObject. Which is wrong in cases like this:
      // frames[0].document.createElement(null, null); // throws an exception which should have the subframe&#39;s prototypes.
<span class="line-modified">!     JSDOMGlobalObject* globalObject = deprecatedGlobalObjectForPrototype(lexicalGlobalObject);</span>
<span class="line-modified">!     JSValue errorObject = toJS(lexicalGlobalObject, globalObject, DOMException::create(ec, message));</span>
  
      ASSERT(errorObject);
<span class="line-modified">!     addErrorInfo(lexicalGlobalObject, asObject(errorObject), true);</span>
      return errorObject;
  }
  
<span class="line-modified">! JSValue createDOMException(JSGlobalObject&amp; lexicalGlobalObject, Exception&amp;&amp; exception)</span>
  {
<span class="line-modified">!     return createDOMException(&amp;lexicalGlobalObject, exception.code(), exception.releaseMessage());</span>
  }
  
<span class="line-modified">! void propagateExceptionSlowPath(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; throwScope, Exception&amp;&amp; exception)</span>
  {
      throwScope.assertNoException();
<span class="line-modified">!     throwException(&amp;lexicalGlobalObject, throwScope, createDOMException(lexicalGlobalObject, WTFMove(exception)));</span>
  }
  
<span class="line-modified">! static EncodedJSValue throwTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const String&amp; errorMessage)</span>
  {
<span class="line-modified">!     return throwVMTypeError(&amp;lexicalGlobalObject, scope, errorMessage);</span>
  }
  
  static void appendArgumentMustBe(StringBuilder&amp; builder, unsigned argumentIndex, const char* argumentName, const char* interfaceName, const char* functionName)
  {
      builder.append(&quot;Argument &quot;, argumentIndex + 1, &quot; (&#39;&quot;, argumentName, &quot;&#39;) to &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,134 ***</span>
      else
          builder.append(interfaceName, &#39;.&#39;, functionName);
      builder.appendLiteral(&quot; must be &quot;);
  }
  
<span class="line-modified">! void throwNotSupportedError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, ASCIILiteral message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;state, scope, createDOMException(&amp;state, NotSupportedError, message));</span>
  }
  
<span class="line-modified">! void throwInvalidStateError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, ASCIILiteral message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;state, scope, createDOMException(&amp;state, InvalidStateError, message));</span>
  }
  
<span class="line-modified">! void throwSecurityError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const String&amp; message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;state, scope, createDOMException(&amp;state, SecurityError, message));</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwArgumentMustBeEnumError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, unsigned argumentIndex, const char* argumentName, const char* functionInterfaceName, const char* functionName, const char* expectedValues)</span>
  {
      StringBuilder builder;
      appendArgumentMustBe(builder, argumentIndex, argumentName, functionInterfaceName, functionName);
      builder.append(&quot;one of: &quot;, expectedValues);
<span class="line-modified">!     return throwVMTypeError(&amp;state, scope, builder.toString());</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwArgumentMustBeFunctionError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, unsigned argumentIndex, const char* argumentName, const char* interfaceName, const char* functionName)</span>
  {
      StringBuilder builder;
      appendArgumentMustBe(builder, argumentIndex, argumentName, interfaceName, functionName);
      builder.appendLiteral(&quot;a function&quot;);
<span class="line-modified">!     return throwVMTypeError(&amp;state, scope, builder.toString());</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwArgumentTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, unsigned argumentIndex, const char* argumentName, const char* functionInterfaceName, const char* functionName, const char* expectedType)</span>
  {
      StringBuilder builder;
      appendArgumentMustBe(builder, argumentIndex, argumentName, functionInterfaceName, functionName);
      builder.append(&quot;an instance of &quot;, expectedType);
<span class="line-modified">!     return throwVMTypeError(&amp;state, scope, builder.toString());</span>
  }
  
<span class="line-modified">! void throwAttributeTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* attributeName, const char* expectedType)</span>
  {
<span class="line-modified">!     throwTypeError(state, scope, makeString(&quot;The &quot;, interfaceName, &#39;.&#39;, attributeName, &quot; attribute must be an instance of &quot;, expectedType));</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwRequiredMemberTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const char* memberName, const char* dictionaryName, const char* expectedType)</span>
  {
      StringBuilder builder;
      builder.appendLiteral(&quot;Member &quot;);
      builder.append(dictionaryName);
      builder.append(&#39;.&#39;);
      builder.append(memberName);
      builder.appendLiteral(&quot; is required and must be an instance of &quot;);
      builder.append(expectedType);
<span class="line-modified">!     return throwVMTypeError(&amp;state, scope, builder.toString());</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwConstructorScriptExecutionContextUnavailableError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const char* interfaceName)</span>
  {
<span class="line-modified">!     return throwVMError(&amp;state, scope, createReferenceError(&amp;state, makeString(interfaceName, &quot; constructor associated execution context is unavailable&quot;)));</span>
  }
  
<span class="line-modified">! void throwSequenceTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     throwTypeError(state, scope, &quot;Value is not a sequence&quot;_s);</span>
  }
  
<span class="line-modified">! void throwNonFiniteTypeError(ExecState&amp; state, JSC::ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     throwTypeError(&amp;state, scope, &quot;The provided value is non-finite&quot;_s);</span>
  }
  
  String makeGetterTypeErrorMessage(const char* interfaceName, const char* attributeName)
  {
      return makeString(&quot;The &quot;, interfaceName, &#39;.&#39;, attributeName, &quot; getter can only be used on instances of &quot;, interfaceName);
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwGetterTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* attributeName)</span>
  {
<span class="line-modified">!     return throwVMGetterTypeError(&amp;state, scope, makeGetterTypeErrorMessage(interfaceName, attributeName));</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue rejectPromiseWithGetterTypeError(JSC::ExecState&amp; state, const char* interfaceName, const char* attributeName)</span>
  {
<span class="line-modified">!     return createRejectedPromiseWithTypeError(state, makeGetterTypeErrorMessage(interfaceName, attributeName), RejectedPromiseWithTypeErrorCause::NativeGetter);</span>
  }
  
<span class="line-modified">! bool throwSetterTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* attributeName)</span>
  {
<span class="line-modified">!     throwTypeError(state, scope, makeString(&quot;The &quot;, interfaceName, &#39;.&#39;, attributeName, &quot; setter can only be used on instances of &quot;, interfaceName));</span>
      return false;
  }
  
  String makeThisTypeErrorMessage(const char* interfaceName, const char* functionName)
  {
      return makeString(&quot;Can only call &quot;, interfaceName, &#39;.&#39;, functionName, &quot; on instances of &quot;, interfaceName);
  }
  
<span class="line-modified">! EncodedJSValue throwThisTypeError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* functionName)</span>
  {
<span class="line-modified">!     return throwTypeError(state, scope, makeThisTypeErrorMessage(interfaceName, functionName));</span>
  }
  
  JSC::EncodedJSValue rejectPromiseWithThisTypeError(DeferredPromise&amp; promise, const char* interfaceName, const char* methodName)
  {
      promise.reject(TypeError, makeThisTypeErrorMessage(interfaceName, methodName));
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! JSC::EncodedJSValue rejectPromiseWithThisTypeError(JSC::ExecState&amp; state, const char* interfaceName, const char* methodName)</span>
  {
<span class="line-modified">!     return createRejectedPromiseWithTypeError(state, makeThisTypeErrorMessage(interfaceName, methodName), RejectedPromiseWithTypeErrorCause::InvalidThis);</span>
  }
  
<span class="line-modified">! void throwDOMSyntaxError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, ASCIILiteral message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;state, scope, createDOMException(&amp;state, SyntaxError, message));</span>
  }
  
<span class="line-modified">! void throwDataCloneError(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;state, scope, createDOMException(&amp;state, DataCloneError));</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 176,134 ---</span>
      else
          builder.append(interfaceName, &#39;.&#39;, functionName);
      builder.appendLiteral(&quot; must be &quot;);
  }
  
<span class="line-modified">! void throwNotSupportedError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, ASCIILiteral message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;lexicalGlobalObject, scope, createDOMException(&amp;lexicalGlobalObject, NotSupportedError, message));</span>
  }
  
<span class="line-modified">! void throwInvalidStateError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, ASCIILiteral message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;lexicalGlobalObject, scope, createDOMException(&amp;lexicalGlobalObject, InvalidStateError, message));</span>
  }
  
<span class="line-modified">! void throwSecurityError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const String&amp; message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;lexicalGlobalObject, scope, createDOMException(&amp;lexicalGlobalObject, SecurityError, message));</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwArgumentMustBeEnumError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, unsigned argumentIndex, const char* argumentName, const char* functionInterfaceName, const char* functionName, const char* expectedValues)</span>
  {
      StringBuilder builder;
      appendArgumentMustBe(builder, argumentIndex, argumentName, functionInterfaceName, functionName);
      builder.append(&quot;one of: &quot;, expectedValues);
<span class="line-modified">!     return throwVMTypeError(&amp;lexicalGlobalObject, scope, builder.toString());</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwArgumentMustBeFunctionError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, unsigned argumentIndex, const char* argumentName, const char* interfaceName, const char* functionName)</span>
  {
      StringBuilder builder;
      appendArgumentMustBe(builder, argumentIndex, argumentName, interfaceName, functionName);
      builder.appendLiteral(&quot;a function&quot;);
<span class="line-modified">!     return throwVMTypeError(&amp;lexicalGlobalObject, scope, builder.toString());</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwArgumentTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, unsigned argumentIndex, const char* argumentName, const char* functionInterfaceName, const char* functionName, const char* expectedType)</span>
  {
      StringBuilder builder;
      appendArgumentMustBe(builder, argumentIndex, argumentName, functionInterfaceName, functionName);
      builder.append(&quot;an instance of &quot;, expectedType);
<span class="line-modified">!     return throwVMTypeError(&amp;lexicalGlobalObject, scope, builder.toString());</span>
  }
  
<span class="line-modified">! void throwAttributeTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* attributeName, const char* expectedType)</span>
  {
<span class="line-modified">!     throwTypeError(lexicalGlobalObject, scope, makeString(&quot;The &quot;, interfaceName, &#39;.&#39;, attributeName, &quot; attribute must be an instance of &quot;, expectedType));</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwRequiredMemberTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const char* memberName, const char* dictionaryName, const char* expectedType)</span>
  {
      StringBuilder builder;
      builder.appendLiteral(&quot;Member &quot;);
      builder.append(dictionaryName);
      builder.append(&#39;.&#39;);
      builder.append(memberName);
      builder.appendLiteral(&quot; is required and must be an instance of &quot;);
      builder.append(expectedType);
<span class="line-modified">!     return throwVMTypeError(&amp;lexicalGlobalObject, scope, builder.toString());</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwConstructorScriptExecutionContextUnavailableError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const char* interfaceName)</span>
  {
<span class="line-modified">!     return throwVMError(&amp;lexicalGlobalObject, scope, createReferenceError(&amp;lexicalGlobalObject, makeString(interfaceName, &quot; constructor associated execution context is unavailable&quot;)));</span>
  }
  
<span class="line-modified">! void throwSequenceTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     throwTypeError(lexicalGlobalObject, scope, &quot;Value is not a sequence&quot;_s);</span>
  }
  
<span class="line-modified">! void throwNonFiniteTypeError(JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope)</span>
  {
<span class="line-modified">!     throwTypeError(&amp;lexicalGlobalObject, scope, &quot;The provided value is non-finite&quot;_s);</span>
  }
  
  String makeGetterTypeErrorMessage(const char* interfaceName, const char* attributeName)
  {
      return makeString(&quot;The &quot;, interfaceName, &#39;.&#39;, attributeName, &quot; getter can only be used on instances of &quot;, interfaceName);
  }
  
<span class="line-modified">! JSC::EncodedJSValue throwGetterTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* attributeName)</span>
  {
<span class="line-modified">!     return throwVMGetterTypeError(&amp;lexicalGlobalObject, scope, makeGetterTypeErrorMessage(interfaceName, attributeName));</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue rejectPromiseWithGetterTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, const char* interfaceName, const char* attributeName)</span>
  {
<span class="line-modified">!     return createRejectedPromiseWithTypeError(lexicalGlobalObject, makeGetterTypeErrorMessage(interfaceName, attributeName), RejectedPromiseWithTypeErrorCause::NativeGetter);</span>
  }
  
<span class="line-modified">! bool throwSetterTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* attributeName)</span>
  {
<span class="line-modified">!     throwTypeError(lexicalGlobalObject, scope, makeString(&quot;The &quot;, interfaceName, &#39;.&#39;, attributeName, &quot; setter can only be used on instances of &quot;, interfaceName));</span>
      return false;
  }
  
  String makeThisTypeErrorMessage(const char* interfaceName, const char* functionName)
  {
      return makeString(&quot;Can only call &quot;, interfaceName, &#39;.&#39;, functionName, &quot; on instances of &quot;, interfaceName);
  }
  
<span class="line-modified">! EncodedJSValue throwThisTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, const char* interfaceName, const char* functionName)</span>
  {
<span class="line-modified">!     return throwTypeError(lexicalGlobalObject, scope, makeThisTypeErrorMessage(interfaceName, functionName));</span>
  }
  
  JSC::EncodedJSValue rejectPromiseWithThisTypeError(DeferredPromise&amp; promise, const char* interfaceName, const char* methodName)
  {
      promise.reject(TypeError, makeThisTypeErrorMessage(interfaceName, methodName));
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! JSC::EncodedJSValue rejectPromiseWithThisTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, const char* interfaceName, const char* methodName)</span>
  {
<span class="line-modified">!     return createRejectedPromiseWithTypeError(lexicalGlobalObject, makeThisTypeErrorMessage(interfaceName, methodName), RejectedPromiseWithTypeErrorCause::InvalidThis);</span>
  }
  
<span class="line-modified">! void throwDOMSyntaxError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope, ASCIILiteral message)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;lexicalGlobalObject, scope, createDOMException(&amp;lexicalGlobalObject, SyntaxError, message));</span>
  }
  
<span class="line-modified">! void throwDataCloneError(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope)</span>
  {
      scope.assertNoException();
<span class="line-modified">!     throwException(&amp;lexicalGlobalObject, scope, createDOMException(&amp;lexicalGlobalObject, DataCloneError));</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="JSDOMConvertXPathNSResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMExceptionHandling.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorTargetAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorTargetAgent.h&quot;
 28 
 29 #include &quot;InspectorTarget.h&quot;
 30 
 31 namespace Inspector {
 32 
 33 InspectorTargetAgent::InspectorTargetAgent(FrontendRouter&amp; frontendRouter, BackendDispatcher&amp; backendDispatcher)
 34     : InspectorAgentBase(&quot;Target&quot;_s)
 35     , m_router(frontendRouter)
 36     , m_frontendDispatcher(makeUnique&lt;TargetFrontendDispatcher&gt;(frontendRouter))
 37     , m_backendDispatcher(TargetBackendDispatcher::create(backendDispatcher, this))
 38 {
 39 }
 40 
 41 InspectorTargetAgent::~InspectorTargetAgent() = default;
 42 
 43 void InspectorTargetAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 44 {
 45     m_isConnected = true;
 46 
 47     connectToTargets();
 48 }
 49 
 50 void InspectorTargetAgent::willDestroyFrontendAndBackend(DisconnectReason)
 51 {
 52     disconnectFromTargets();
 53 
 54     m_isConnected = false;
 55     m_shouldPauseOnStart = false;
 56 }
 57 
 58 void InspectorTargetAgent::setPauseOnStart(ErrorString&amp;, bool pauseOnStart)
 59 {
 60     m_shouldPauseOnStart = pauseOnStart;
 61 }
 62 
 63 void InspectorTargetAgent::resume(ErrorString&amp; errorString, const String&amp; targetId)
 64 {
 65     auto* target = m_targets.get(targetId);
 66     if (!target) {
 67         errorString = &quot;Missing target for given targetId&quot;_s;
 68         return;
 69     }
 70 
 71     if (!target-&gt;isPaused()) {
 72         errorString = &quot;Target for given targetId is not paused&quot;_s;
 73         return;
 74     }
 75 
 76     target-&gt;resume();
 77 }
 78 
 79 void InspectorTargetAgent::sendMessageToTarget(ErrorString&amp; errorString, const String&amp; targetId, const String&amp; message)
 80 {
 81     InspectorTarget* target = m_targets.get(targetId);
 82     if (!target) {
 83         errorString = &quot;Missing target for given targetId&quot;_s;
 84         return;
 85     }
 86 
 87     target-&gt;sendMessageToTargetBackend(message);
 88 }
 89 
 90 void InspectorTargetAgent::sendMessageFromTargetToFrontend(const String&amp; targetId, const String&amp; message)
 91 {
 92     ASSERT_WITH_MESSAGE(m_targets.get(targetId), &quot;Sending a message from an untracked target to the frontend.&quot;);
 93 
 94     m_frontendDispatcher-&gt;dispatchMessageFromTarget(targetId, message);
 95 }
 96 
 97 static Protocol::Target::TargetInfo::Type targetTypeToProtocolType(InspectorTargetType type)
 98 {
 99     switch (type) {
100     case InspectorTargetType::Page:
101         return Protocol::Target::TargetInfo::Type::Page;
102     case InspectorTargetType::DedicatedWorker:
103         return Protocol::Target::TargetInfo::Type::Worker;
104     case InspectorTargetType::ServiceWorker:
105         return Protocol::Target::TargetInfo::Type::ServiceWorker;
106     }
107 
108     ASSERT_NOT_REACHED();
109     return Protocol::Target::TargetInfo::Type::Page;
110 }
111 
112 static Ref&lt;Protocol::Target::TargetInfo&gt; buildTargetInfoObject(const InspectorTarget&amp; target)
113 {
114     auto result = Protocol::Target::TargetInfo::create()
115         .setTargetId(target.identifier())
116         .setType(targetTypeToProtocolType(target.type()))
117         .release();
118     if (target.isProvisional())
119         result-&gt;setIsProvisional(true);
120     if (target.isPaused())
121         result-&gt;setIsPaused(true);
122     return result;
123 }
124 
125 void InspectorTargetAgent::targetCreated(InspectorTarget&amp; target)
126 {
127     auto addResult = m_targets.set(target.identifier(), &amp;target);
128     ASSERT_UNUSED(addResult, addResult.isNewEntry);
129 
130     if (!m_isConnected)
131         return;
132 
133     if (m_shouldPauseOnStart)
134         target.pause();
135     target.connect(connectionType());
136 
137     m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(target));
138 }
139 
140 void InspectorTargetAgent::targetDestroyed(InspectorTarget&amp; target)
141 {
142     m_targets.remove(target.identifier());
143 
144     if (!m_isConnected)
145         return;
146 
147     m_frontendDispatcher-&gt;targetDestroyed(target.identifier());
148 }
149 
150 void InspectorTargetAgent::didCommitProvisionalTarget(const String&amp; oldTargetID, const String&amp; committedTargetID)
151 {
152     if (!m_isConnected)
153         return;
154 
155     auto* target = m_targets.get(committedTargetID);
156     if (!target)
157         return;
158 
159     m_frontendDispatcher-&gt;didCommitProvisionalTarget(oldTargetID, committedTargetID);
160 }
161 
162 FrontendChannel::ConnectionType InspectorTargetAgent::connectionType() const
163 {
164     return m_router.hasLocalFrontend() ? Inspector::FrontendChannel::ConnectionType::Local : Inspector::FrontendChannel::ConnectionType::Remote;
165 }
166 
167 void InspectorTargetAgent::connectToTargets()
168 {
169     for (InspectorTarget* target : m_targets.values()) {
170         target-&gt;connect(connectionType());
171         m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(*target));
172     }
173 }
174 
175 void InspectorTargetAgent::disconnectFromTargets()
176 {
177     for (InspectorTarget* target : m_targets.values())
178         target-&gt;disconnect();
179 }
180 
181 } // namespace Inspector
    </pre>
  </body>
</html>
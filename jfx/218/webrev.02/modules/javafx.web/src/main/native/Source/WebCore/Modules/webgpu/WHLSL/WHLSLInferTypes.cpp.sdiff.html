<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLInferTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLHighZombieFinder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLIntrinsics.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLInferTypes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &quot;WHLSLEnumerationDefinition.h&quot;
 34 #include &quot;WHLSLFunctionDeclaration.h&quot;
 35 #include &quot;WHLSLNamedType.h&quot;
 36 #include &quot;WHLSLNativeTypeDeclaration.h&quot;
 37 #include &quot;WHLSLPointerType.h&quot;
 38 #include &quot;WHLSLResolvableType.h&quot;
 39 #include &quot;WHLSLStructureDefinition.h&quot;
 40 #include &quot;WHLSLTypeDefinition.h&quot;
 41 #include &quot;WHLSLTypeReference.h&quot;
 42 
 43 namespace WebCore {
 44 
 45 namespace WHLSL {
 46 
 47 static bool matches(const AST::Type&amp; unifyThis, const AST::Type&amp; unifyOther)
 48 {
 49     if (&amp;unifyThis == &amp;unifyOther)
 50         return true;
 51 
 52     if (is&lt;AST::NamedType&gt;(unifyThis) &amp;&amp; is&lt;AST::NamedType&gt;(unifyOther)) {
<span class="line-modified"> 53 #if !ASSERT_DISABLED</span>
 54         auto&amp; namedThis = downcast&lt;AST::NamedType&gt;(unifyThis);
 55         auto&amp; namedOther = downcast&lt;AST::NamedType&gt;(unifyOther);
 56         ASSERT(!is&lt;AST::TypeDefinition&gt;(namedThis) &amp;&amp; !is&lt;AST::TypeDefinition&gt;(namedOther));
 57 #endif
 58         return false;
 59     }
 60     if (is&lt;AST::UnnamedType&gt;(unifyThis) &amp;&amp; is&lt;AST::UnnamedType&gt;(unifyOther)) {
 61         auto&amp; unnamedThis = downcast&lt;AST::UnnamedType&gt;(unifyThis);
 62         auto&amp; unnamedOther = downcast&lt;AST::UnnamedType&gt;(unifyOther);
 63         ASSERT(!is&lt;AST::TypeReference&gt;(unnamedThis) &amp;&amp; !is&lt;AST::TypeReference&gt;(unnamedOther));
 64         return unnamedThis == unnamedOther;
 65     }
 66     return false;
 67 }
 68 
 69 bool matches(const AST::UnnamedType&amp; unnamedType, const AST::UnnamedType&amp; other)
 70 {
 71     return matches(unnamedType.unifyNode(), other.unifyNode());
 72 }
 73 
</pre>
<hr />
<pre>
110 
111 RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(AST::ResolvableType&amp; resolvableType1, AST::ResolvableType&amp; resolvableType2)
112 {
113     ASSERT(!resolvableType1.maybeResolvedType());
114     ASSERT(!resolvableType2.maybeResolvedType());
115     if (is&lt;AST::FloatLiteralType&gt;(resolvableType1) &amp;&amp; is&lt;AST::FloatLiteralType&gt;(resolvableType2)) {
116         resolvableType1.resolve(downcast&lt;AST::FloatLiteralType&gt;(resolvableType1).preferredType());
117         resolvableType2.resolve(downcast&lt;AST::FloatLiteralType&gt;(resolvableType2).preferredType());
118         return &amp;downcast&lt;AST::FloatLiteralType&gt;(resolvableType1).preferredType();
119     }
120     if (is&lt;AST::IntegerLiteralType&gt;(resolvableType1) &amp;&amp; is&lt;AST::IntegerLiteralType&gt;(resolvableType2)) {
121         resolvableType1.resolve(downcast&lt;AST::IntegerLiteralType&gt;(resolvableType1).preferredType());
122         resolvableType2.resolve(downcast&lt;AST::IntegerLiteralType&gt;(resolvableType2).preferredType());
123         return &amp;downcast&lt;AST::IntegerLiteralType&gt;(resolvableType1).preferredType();
124     }
125     if (is&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType1) &amp;&amp; is&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType2)) {
126         resolvableType1.resolve(downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType1).preferredType());
127         resolvableType2.resolve(downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType2).preferredType());
128         return &amp;downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType1).preferredType();
129     }
<span class="line-removed">130     if (is&lt;AST::NullLiteralType&gt;(resolvableType1) &amp;&amp; is&lt;AST::NullLiteralType&gt;(resolvableType2)) {</span>
<span class="line-removed">131         // FIXME: Trying to match nullptr and nullptr fails.</span>
<span class="line-removed">132         return nullptr;</span>
<span class="line-removed">133     }</span>
134     return nullptr;
135 }
136 
137 RefPtr&lt;AST::UnnamedType&gt; commit(AST::ResolvableType&amp; resolvableType)
138 {
139     ASSERT(!resolvableType.maybeResolvedType());
140     if (is&lt;AST::FloatLiteralType&gt;(resolvableType)) {
141         auto&amp; floatLiteralType = downcast&lt;AST::FloatLiteralType&gt;(resolvableType);
142         resolvableType.resolve(floatLiteralType.preferredType());
143         return &amp;floatLiteralType.preferredType();
144     }
145     if (is&lt;AST::IntegerLiteralType&gt;(resolvableType)) {
146         auto&amp; integerLiteralType = downcast&lt;AST::IntegerLiteralType&gt;(resolvableType);
147         resolvableType.resolve(integerLiteralType.preferredType());
148         return &amp;integerLiteralType.preferredType();
149     }
150     if (is&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType)) {
151         auto&amp; unsignedIntegerLiteralType = downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType);
152         resolvableType.resolve(unsignedIntegerLiteralType.preferredType());
153         return &amp;unsignedIntegerLiteralType.preferredType();
154     }
<span class="line-removed">155     if (is&lt;AST::NullLiteralType&gt;(resolvableType)) {</span>
<span class="line-removed">156         // FIXME: Trying to match nullptr and nullptr fails.</span>
<span class="line-removed">157         return nullptr;</span>
<span class="line-removed">158     }</span>
159     return nullptr;
160 }
161 
162 bool inferTypesForTypeArguments(AST::NamedType&amp; possibleType, AST::TypeArguments&amp; typeArguments)
163 {
164     if (is&lt;AST::TypeDefinition&gt;(possibleType)
165         || is&lt;AST::StructureDefinition&gt;(possibleType)
166         || is&lt;AST::EnumerationDefinition&gt;(possibleType)) {
167         return typeArguments.isEmpty();
168     }
169 
170     auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(possibleType);
171     if (nativeTypeDeclaration.typeArguments().size() != typeArguments.size())
172         return false;
173     for (size_t i = 0; i &lt; nativeTypeDeclaration.typeArguments().size(); ++i) {
174         AST::ConstantExpression* typeArgumentExpression = nullptr;
175         AST::TypeReference* typeArgumentTypeReference = nullptr;
176         AST::ConstantExpression* nativeTypeArgumentExpression = nullptr;
177         AST::TypeReference* nativeTypeArgumentTypeReference = nullptr;
178 
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &quot;WHLSLEnumerationDefinition.h&quot;
 34 #include &quot;WHLSLFunctionDeclaration.h&quot;
 35 #include &quot;WHLSLNamedType.h&quot;
 36 #include &quot;WHLSLNativeTypeDeclaration.h&quot;
 37 #include &quot;WHLSLPointerType.h&quot;
 38 #include &quot;WHLSLResolvableType.h&quot;
 39 #include &quot;WHLSLStructureDefinition.h&quot;
 40 #include &quot;WHLSLTypeDefinition.h&quot;
 41 #include &quot;WHLSLTypeReference.h&quot;
 42 
 43 namespace WebCore {
 44 
 45 namespace WHLSL {
 46 
 47 static bool matches(const AST::Type&amp; unifyThis, const AST::Type&amp; unifyOther)
 48 {
 49     if (&amp;unifyThis == &amp;unifyOther)
 50         return true;
 51 
 52     if (is&lt;AST::NamedType&gt;(unifyThis) &amp;&amp; is&lt;AST::NamedType&gt;(unifyOther)) {
<span class="line-modified"> 53 #if ASSERT_ENABLED</span>
 54         auto&amp; namedThis = downcast&lt;AST::NamedType&gt;(unifyThis);
 55         auto&amp; namedOther = downcast&lt;AST::NamedType&gt;(unifyOther);
 56         ASSERT(!is&lt;AST::TypeDefinition&gt;(namedThis) &amp;&amp; !is&lt;AST::TypeDefinition&gt;(namedOther));
 57 #endif
 58         return false;
 59     }
 60     if (is&lt;AST::UnnamedType&gt;(unifyThis) &amp;&amp; is&lt;AST::UnnamedType&gt;(unifyOther)) {
 61         auto&amp; unnamedThis = downcast&lt;AST::UnnamedType&gt;(unifyThis);
 62         auto&amp; unnamedOther = downcast&lt;AST::UnnamedType&gt;(unifyOther);
 63         ASSERT(!is&lt;AST::TypeReference&gt;(unnamedThis) &amp;&amp; !is&lt;AST::TypeReference&gt;(unnamedOther));
 64         return unnamedThis == unnamedOther;
 65     }
 66     return false;
 67 }
 68 
 69 bool matches(const AST::UnnamedType&amp; unnamedType, const AST::UnnamedType&amp; other)
 70 {
 71     return matches(unnamedType.unifyNode(), other.unifyNode());
 72 }
 73 
</pre>
<hr />
<pre>
110 
111 RefPtr&lt;AST::UnnamedType&gt; matchAndCommit(AST::ResolvableType&amp; resolvableType1, AST::ResolvableType&amp; resolvableType2)
112 {
113     ASSERT(!resolvableType1.maybeResolvedType());
114     ASSERT(!resolvableType2.maybeResolvedType());
115     if (is&lt;AST::FloatLiteralType&gt;(resolvableType1) &amp;&amp; is&lt;AST::FloatLiteralType&gt;(resolvableType2)) {
116         resolvableType1.resolve(downcast&lt;AST::FloatLiteralType&gt;(resolvableType1).preferredType());
117         resolvableType2.resolve(downcast&lt;AST::FloatLiteralType&gt;(resolvableType2).preferredType());
118         return &amp;downcast&lt;AST::FloatLiteralType&gt;(resolvableType1).preferredType();
119     }
120     if (is&lt;AST::IntegerLiteralType&gt;(resolvableType1) &amp;&amp; is&lt;AST::IntegerLiteralType&gt;(resolvableType2)) {
121         resolvableType1.resolve(downcast&lt;AST::IntegerLiteralType&gt;(resolvableType1).preferredType());
122         resolvableType2.resolve(downcast&lt;AST::IntegerLiteralType&gt;(resolvableType2).preferredType());
123         return &amp;downcast&lt;AST::IntegerLiteralType&gt;(resolvableType1).preferredType();
124     }
125     if (is&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType1) &amp;&amp; is&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType2)) {
126         resolvableType1.resolve(downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType1).preferredType());
127         resolvableType2.resolve(downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType2).preferredType());
128         return &amp;downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType1).preferredType();
129     }




130     return nullptr;
131 }
132 
133 RefPtr&lt;AST::UnnamedType&gt; commit(AST::ResolvableType&amp; resolvableType)
134 {
135     ASSERT(!resolvableType.maybeResolvedType());
136     if (is&lt;AST::FloatLiteralType&gt;(resolvableType)) {
137         auto&amp; floatLiteralType = downcast&lt;AST::FloatLiteralType&gt;(resolvableType);
138         resolvableType.resolve(floatLiteralType.preferredType());
139         return &amp;floatLiteralType.preferredType();
140     }
141     if (is&lt;AST::IntegerLiteralType&gt;(resolvableType)) {
142         auto&amp; integerLiteralType = downcast&lt;AST::IntegerLiteralType&gt;(resolvableType);
143         resolvableType.resolve(integerLiteralType.preferredType());
144         return &amp;integerLiteralType.preferredType();
145     }
146     if (is&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType)) {
147         auto&amp; unsignedIntegerLiteralType = downcast&lt;AST::UnsignedIntegerLiteralType&gt;(resolvableType);
148         resolvableType.resolve(unsignedIntegerLiteralType.preferredType());
149         return &amp;unsignedIntegerLiteralType.preferredType();
150     }




151     return nullptr;
152 }
153 
154 bool inferTypesForTypeArguments(AST::NamedType&amp; possibleType, AST::TypeArguments&amp; typeArguments)
155 {
156     if (is&lt;AST::TypeDefinition&gt;(possibleType)
157         || is&lt;AST::StructureDefinition&gt;(possibleType)
158         || is&lt;AST::EnumerationDefinition&gt;(possibleType)) {
159         return typeArguments.isEmpty();
160     }
161 
162     auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(possibleType);
163     if (nativeTypeDeclaration.typeArguments().size() != typeArguments.size())
164         return false;
165     for (size_t i = 0; i &lt; nativeTypeDeclaration.typeArguments().size(); ++i) {
166         AST::ConstantExpression* typeArgumentExpression = nullptr;
167         AST::TypeReference* typeArgumentTypeReference = nullptr;
168         AST::ConstantExpression* nativeTypeArgumentExpression = nullptr;
169         AST::TypeReference* nativeTypeArgumentTypeReference = nullptr;
170 
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLHighZombieFinder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLIntrinsics.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SQLiteIDBCursor.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBCursorInfo.h&quot;
 32 #include &quot;IDBGetResult.h&quot;
 33 #include &quot;IDBSerialization.h&quot;
 34 #include &quot;Logging.h&quot;
 35 #include &quot;SQLiteIDBBackingStore.h&quot;
 36 #include &quot;SQLiteIDBTransaction.h&quot;
 37 #include &quot;SQLiteStatement.h&quot;
 38 #include &quot;SQLiteTransaction.h&quot;
 39 #include &lt;sqlite3.h&gt;
 40 #include &lt;wtf/text/StringBuilder.h&gt;
 41 
 42 namespace WebCore {
 43 namespace IDBServer {
 44 
 45 static const size_t prefetchLimit = 256;
 46 static const size_t prefetchSizeLimit = 1 * MB;
 47 
 48 std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreate(SQLiteIDBTransaction&amp; transaction, const IDBCursorInfo&amp; info)
 49 {
 50     auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, info);
 51 
 52     if (!cursor-&gt;establishStatement())
 53         return nullptr;
 54 
 55     if (!cursor-&gt;advance(1))
 56         return nullptr;
 57 
 58     return cursor;
 59 }
 60 
 61 std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreateBackingStoreCursor(SQLiteIDBTransaction&amp; transaction, const uint64_t objectStoreID, const uint64_t indexID, const IDBKeyRangeData&amp; range)
 62 {
 63     auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, objectStoreID, indexID, range);
 64 
 65     if (!cursor-&gt;establishStatement())
 66         return nullptr;
 67 
 68     if (!cursor-&gt;advance(1))
 69         return nullptr;
 70 
 71     return cursor;
 72 }
 73 
 74 SQLiteIDBCursor::SQLiteIDBCursor(SQLiteIDBTransaction&amp; transaction, const IDBCursorInfo&amp; info)
 75     : m_transaction(&amp;transaction)
 76     , m_cursorIdentifier(info.identifier())
 77     , m_objectStoreID(info.objectStoreIdentifier())
 78     , m_indexID(info.cursorSource() == IndexedDB::CursorSource::Index ? info.sourceIdentifier() : IDBIndexInfo::InvalidId)
 79     , m_cursorDirection(info.cursorDirection())
 80     , m_cursorType(info.cursorType())
 81     , m_keyRange(info.range())
 82 {
 83     ASSERT(m_objectStoreID);
 84 }
 85 
 86 SQLiteIDBCursor::SQLiteIDBCursor(SQLiteIDBTransaction&amp; transaction, const uint64_t objectStoreID, const uint64_t indexID, const IDBKeyRangeData&amp; range)
 87     : m_transaction(&amp;transaction)
 88     , m_cursorIdentifier(transaction.transactionIdentifier())
 89     , m_objectStoreID(objectStoreID)
 90     , m_indexID(indexID ? indexID : IDBIndexInfo::InvalidId)
 91     , m_cursorDirection(IndexedDB::CursorDirection::Next)
 92     , m_cursorType(IndexedDB::CursorType::KeyAndValue)
 93     , m_keyRange(range)
 94     , m_backingStoreCursor(true)
 95 {
 96     ASSERT(m_objectStoreID);
 97 }
 98 
 99 SQLiteIDBCursor::~SQLiteIDBCursor()
100 {
101     if (m_backingStoreCursor)
102         m_transaction-&gt;closeCursor(*this);
103 }
104 
105 void SQLiteIDBCursor::currentData(IDBGetResult&amp; result, const Optional&lt;IDBKeyPath&gt;&amp; keyPath, ShouldIncludePrefetchedRecords shouldIncludePrefetchedRecords)
106 {
107     ASSERT(!m_fetchedRecords.isEmpty());
108 
109     auto&amp; currentRecord = m_fetchedRecords.first();
110     if (currentRecord.completed) {
111         ASSERT(!currentRecord.errored);
112         result = { };
113         return;
114     }
115 
116     if (shouldIncludePrefetchedRecords == ShouldIncludePrefetchedRecords::No) {
117         result = { currentRecord.record.key, currentRecord.record.primaryKey, IDBValue(currentRecord.record.value), keyPath };
118         return;
119     }
120 
121     Vector&lt;IDBCursorRecord&gt; prefetchedRecords;
122     prefetchedRecords.reserveCapacity(m_fetchedRecords.size());
123     for (auto&amp; record : m_fetchedRecords) {
124         if (record.isTerminalRecord())
125             break;
126 
127         prefetchedRecords.append(record.record);
128     }
129 
130     // First record will be returned as current record.
131     if (!prefetchedRecords.isEmpty())
132         prefetchedRecords.remove(0);
133 
134     result = { currentRecord.record.key, currentRecord.record.primaryKey, IDBValue(currentRecord.record.value), keyPath, WTFMove(prefetchedRecords) };
135 }
136 
137 static String buildPreIndexStatement(bool isDirectionNext)
138 {
139     StringBuilder builder;
140 
141     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND key = CAST(? AS TEXT) AND value &quot;);
142     if (isDirectionNext)
143         builder.append(&#39;&gt;&#39;);
144     else
145         builder.append(&#39;&lt;&#39;);
146 
147     builder.appendLiteral(&quot; CAST(? AS TEXT) ORDER BY value&quot;);
148     if (!isDirectionNext)
149         builder.appendLiteral(&quot; DESC&quot;);
150 
151     builder.append(&#39;;&#39;);
152 
153     return builder.toString();
154 }
155 
156 static String buildIndexStatement(const IDBKeyRangeData&amp; keyRange, IndexedDB::CursorDirection cursorDirection)
157 {
158     StringBuilder builder;
159 
160     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND key &quot;);
161     if (!keyRange.lowerKey.isNull() &amp;&amp; !keyRange.lowerOpen)
162         builder.appendLiteral(&quot;&gt;=&quot;);
163     else
164         builder.append(&#39;&gt;&#39;);
165 
166     builder.appendLiteral(&quot; CAST(? AS TEXT) AND key &quot;);
167     if (!keyRange.upperKey.isNull() &amp;&amp; !keyRange.upperOpen)
168         builder.appendLiteral(&quot;&lt;=&quot;);
169     else
170         builder.append(&#39;&lt;&#39;);
171 
172     builder.appendLiteral(&quot; CAST(? AS TEXT) ORDER BY key&quot;);
173     if (cursorDirection == IndexedDB::CursorDirection::Prev || cursorDirection == IndexedDB::CursorDirection::Prevunique)
174         builder.appendLiteral(&quot; DESC&quot;);
175 
176     builder.appendLiteral(&quot;, value&quot;);
177     if (cursorDirection == IndexedDB::CursorDirection::Prev)
178         builder.appendLiteral(&quot; DESC&quot;);
179 
180     builder.append(&#39;;&#39;);
181 
182     return builder.toString();
183 }
184 
185 static String buildObjectStoreStatement(const IDBKeyRangeData&amp; keyRange, IndexedDB::CursorDirection cursorDirection)
186 {
187     StringBuilder builder;
188 
189     builder.appendLiteral(&quot;SELECT rowid, key, value FROM Records WHERE objectStoreID = ? AND key &quot;);
190 
191     if (!keyRange.lowerKey.isNull() &amp;&amp; !keyRange.lowerOpen)
192         builder.appendLiteral(&quot;&gt;=&quot;);
193     else
194         builder.append(&#39;&gt;&#39;);
195 
196     builder.appendLiteral(&quot; CAST(? AS TEXT) AND key &quot;);
197 
198     if (!keyRange.upperKey.isNull() &amp;&amp; !keyRange.upperOpen)
199         builder.appendLiteral(&quot;&lt;=&quot;);
200     else
201         builder.append(&#39;&lt;&#39;);
202 
203     builder.appendLiteral(&quot; CAST(? AS TEXT) ORDER BY key&quot;);
204 
205     if (cursorDirection == IndexedDB::CursorDirection::Prev || cursorDirection == IndexedDB::CursorDirection::Prevunique)
206         builder.appendLiteral(&quot; DESC&quot;);
207 
208     builder.append(&#39;;&#39;);
209 
210     return builder.toString();
211 }
212 
213 bool SQLiteIDBCursor::establishStatement()
214 {
215     ASSERT(!m_statement);
216     String sql;
217 
218     if (m_indexID != IDBIndexInfo::InvalidId) {
219         sql = buildIndexStatement(m_keyRange, m_cursorDirection);
220         m_boundID = m_indexID;
221     } else {
222         sql = buildObjectStoreStatement(m_keyRange, m_cursorDirection);
223         m_boundID = m_objectStoreID;
224     }
225 
226     m_currentLowerKey = m_keyRange.lowerKey.isNull() ? IDBKeyData::minimum() : m_keyRange.lowerKey;
227     m_currentUpperKey = m_keyRange.upperKey.isNull() ? IDBKeyData::maximum() : m_keyRange.upperKey;
228 
229     return createSQLiteStatement(sql);
230 }
231 
232 bool SQLiteIDBCursor::createSQLiteStatement(const String&amp; sql)
233 {
234     LOG(IndexedDB, &quot;Creating cursor with SQL query: \&quot;%s\&quot;&quot;, sql.utf8().data());
235 
236     ASSERT(!m_currentLowerKey.isNull());
237     ASSERT(!m_currentUpperKey.isNull());
238     ASSERT(m_transaction-&gt;sqliteTransaction());
239 
240     m_statement = makeUnique&lt;SQLiteStatement&gt;(m_transaction-&gt;sqliteTransaction()-&gt;database(), sql);
241 
242     if (m_statement-&gt;prepare() != SQLITE_OK) {
243         LOG_ERROR(&quot;Could not create cursor statement (prepare/id) - &#39;%s&#39;&quot;, m_transaction-&gt;sqliteTransaction()-&gt;database().lastErrorMsg());
244         return false;
245     }
246 
247     return bindArguments();
248 }
249 
250 void SQLiteIDBCursor::objectStoreRecordsChanged()
251 {
252     if (m_statementNeedsReset)
253         return;
254 
255     ASSERT(!m_fetchedRecords.isEmpty());
256 
257     m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
258     if (m_indexID != IDBIndexInfo::InvalidId)
259         m_currentIndexRecordValue = m_fetchedRecords.first().record.primaryKey;
260 
261     // If ObjectStore or Index contents changed, we need to reset the statement and bind new parameters to it.
262     // This is to pick up any changes that might exist.
263     m_statementNeedsReset = true;
264 
265     if (isDirectionNext()) {
266         m_currentLowerKey = m_currentKeyForUniqueness;
267         if (!m_keyRange.lowerOpen) {
268             m_keyRange.lowerOpen = true;
269             m_keyRange.lowerKey = m_currentLowerKey;
270             m_statement = nullptr;
271         }
272     } else {
273         m_currentUpperKey = m_currentKeyForUniqueness;
274         if (!m_keyRange.upperOpen) {
275             m_keyRange.upperOpen = true;
276             m_keyRange.upperKey = m_currentUpperKey;
277             m_statement = nullptr;
278         }
279     }
280 
281     // We also need to throw away any fetched records as they may no longer be valid.
282     m_fetchedRecords.clear();
283     m_fetchedRecordsSize = 0;
284 
285     m_prefetchCount = 0;
286 }
287 
288 void SQLiteIDBCursor::resetAndRebindStatement()
289 {
290     ASSERT(!m_currentLowerKey.isNull());
291     ASSERT(!m_currentUpperKey.isNull());
292     ASSERT(m_transaction-&gt;sqliteTransaction());
293     ASSERT(m_statementNeedsReset);
294 
295     m_statementNeedsReset = false;
296 
297     if (!m_statement &amp;&amp; !establishStatement()) {
298         LOG_ERROR(&quot;Unable to establish new statement for cursor iteration&quot;);
299         return;
300     }
301 
302     if (m_statement-&gt;reset() != SQLITE_OK) {
303         LOG_ERROR(&quot;Could not reset cursor statement to respond to object store changes&quot;);
304         return;
305     }
306 
307     bindArguments();
308 }
309 
310 bool SQLiteIDBCursor::bindArguments()
311 {
312     LOG(IndexedDB, &quot;Cursor is binding lower key &#39;%s&#39; and upper key &#39;%s&#39;&quot;, m_currentLowerKey.loggingString().utf8().data(), m_currentUpperKey.loggingString().utf8().data());
313 
314     int currentBindArgument = 1;
315 
316     if (m_statement-&gt;bindInt64(currentBindArgument++, m_boundID) != SQLITE_OK) {
317         LOG_ERROR(&quot;Could not bind id argument (bound ID)&quot;);
318         return false;
319     }
320 
321     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(m_currentLowerKey);
322     if (m_statement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
323         LOG_ERROR(&quot;Could not create cursor statement (lower key)&quot;);
324         return false;
325     }
326 
327     buffer = serializeIDBKeyData(m_currentUpperKey);
328     if (m_statement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
329         LOG_ERROR(&quot;Could not create cursor statement (upper key)&quot;);
330         return false;
331     }
332 
333     return true;
334 }
335 
336 bool SQLiteIDBCursor::resetAndRebindPreIndexStatementIfNecessary()
337 {
338     if (m_indexID == IDBIndexInfo::InvalidId)
339         return true;
340 
341     if (m_currentIndexRecordValue.isNull())
342         return true;
343 
344     auto&amp; database = m_transaction-&gt;sqliteTransaction()-&gt;database();
345     if (!m_preIndexStatement) {
346         m_preIndexStatement = makeUnique&lt;SQLiteStatement&gt;(database, buildPreIndexStatement(isDirectionNext()));
347 
348         if (m_preIndexStatement-&gt;prepare() != SQLITE_OK) {
349             LOG_ERROR(&quot;Could not prepare pre statement - &#39;%s&#39;&quot;, database.lastErrorMsg());
350             return false;
351         }
352     }
353 
354     if (m_preIndexStatement-&gt;reset() != SQLITE_OK) {
355         LOG_ERROR(&quot;Could not reset pre statement - &#39;%s&#39;&quot;, database.lastErrorMsg());
356         return false;
357     }
358 
359     auto key = isDirectionNext() ? m_currentLowerKey : m_currentUpperKey;
360     int currentBindArgument = 1;
361 
362     if (m_preIndexStatement-&gt;bindInt64(currentBindArgument++, m_boundID) != SQLITE_OK) {
363         LOG_ERROR(&quot;Could not bind id argument to pre statement (bound ID)&quot;);
364         return false;
365     }
366 
367     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
368     if (m_preIndexStatement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
369         LOG_ERROR(&quot;Could not bind id argument to pre statement (key)&quot;);
370         return false;
371     }
372 
373     buffer = serializeIDBKeyData(m_currentIndexRecordValue);
374     if (m_preIndexStatement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
375         LOG_ERROR(&quot;Could not bind id argument to pre statement (value)&quot;);
376         return false;
377     }
378 
379     return true;
380 }
381 
382 bool SQLiteIDBCursor::prefetchOneRecord()
383 {
384     LOG(IndexedDB, &quot;SQLiteIDBCursor::prefetchOneRecord() - Cursor already has %zu fetched records&quot;, m_fetchedRecords.size());
385 
386     if (m_fetchedRecordsSize &gt;= prefetchSizeLimit || m_fetchedRecords.isEmpty() || m_fetchedRecords.size() &gt;= prefetchLimit || m_fetchedRecords.last().isTerminalRecord())
387         return false;
388 
389     m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;
390 
391     return fetch() &amp;&amp; m_fetchedRecords.size() &lt; prefetchLimit &amp;&amp; m_fetchedRecordsSize &lt; prefetchSizeLimit;
392 }
393 
394 void SQLiteIDBCursor::increaseCountToPrefetch()
395 {
396     m_prefetchCount = m_prefetchCount ? m_prefetchCount * 2 : 1;
397 }
398 
399 bool SQLiteIDBCursor::prefetch()
400 {
401     for (unsigned i = 0; i &lt; m_prefetchCount; ++i) {
402         if (!prefetchOneRecord())
403             return false;
404     }
405 
406     increaseCountToPrefetch();
407     return true;
408 }
409 
410 bool SQLiteIDBCursor::advance(uint64_t count)
411 {
412     LOG(IndexedDB, &quot;SQLiteIDBCursor::advance() - Count %&quot; PRIu64 &quot;, %zu fetched records&quot;, count, m_fetchedRecords.size());
413     ASSERT(count);
414 
415     if (!m_fetchedRecords.isEmpty() &amp;&amp; m_fetchedRecords.first().isTerminalRecord()) {
416         LOG_ERROR(&quot;Attempt to advance a completed cursor&quot;);
417         return false;
418     }
419 
420     if (!m_fetchedRecords.isEmpty())
421         m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;
422 
423     // Drop already-fetched records up to `count` to see if we&#39;ve already fetched the record we&#39;re looking for.
424     bool hadCurrentRecord = !m_fetchedRecords.isEmpty();
425     for (; count &amp;&amp; !m_fetchedRecords.isEmpty(); --count) {
426         if (m_fetchedRecords.first().isTerminalRecord())
427             break;
428 
429         ASSERT(m_fetchedRecordsSize &gt;= m_fetchedRecords.first().record.size());
430         m_fetchedRecordsSize -= m_fetchedRecords.first().record.size();
431         m_fetchedRecords.removeFirst();
432     }
433 
434     // If we still have any records left, the first record is our new current record.
435     if (!m_fetchedRecords.isEmpty())
436         return true;
437 
438     ASSERT(m_fetchedRecords.isEmpty());
439 
440     // If we started out with a current record, we burnt a count on removing it.
441     // Replace that count now.
442     if (hadCurrentRecord)
443         ++count;
444 
445     for (; count; --count) {
446         if (!m_fetchedRecords.isEmpty()) {
447             ASSERT(m_fetchedRecords.size() == 1);
448             m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
449 
450             ASSERT(m_fetchedRecordsSize &gt;= m_fetchedRecords.first().record.size());
451             m_fetchedRecordsSize -= m_fetchedRecords.first().record.size();
452             m_fetchedRecords.removeFirst();
453         }
454 
455         if (!fetch())
456             return false;
457 
458         ASSERT(!m_fetchedRecords.isEmpty());
459         ASSERT(!m_fetchedRecords.first().errored);
460         if (m_fetchedRecords.first().completed)
461             break;
462     }
463 
464     return true;
465 }
466 
467 bool SQLiteIDBCursor::fetch()
468 {
469     ASSERT(m_fetchedRecords.isEmpty() || !m_fetchedRecords.last().isTerminalRecord());
470 
471     m_fetchedRecords.append({ });
472 
473     bool isUnique = m_cursorDirection == IndexedDB::CursorDirection::Nextunique || m_cursorDirection == IndexedDB::CursorDirection::Prevunique;
474     if (!isUnique) {
475         bool fetchSucceeded = fetchNextRecord(m_fetchedRecords.last());
476         if (fetchSucceeded)
477             m_fetchedRecordsSize += m_fetchedRecords.last().record.size();
478         return fetchSucceeded;
479     }
480 
481     while (fetchNextRecord(m_fetchedRecords.last())) {
482         m_fetchedRecordsSize += m_fetchedRecords.last().record.size();
483 
484         if (m_currentKeyForUniqueness.compare(m_fetchedRecords.last().record.key))
485             return true;
486 
487         if (m_fetchedRecords.last().completed)
488             return false;
489 
490         m_fetchedRecordsSize -= m_fetchedRecords.last().record.size();
491     }
492 
493     return false;
494 }
495 
496 bool SQLiteIDBCursor::fetchNextRecord(SQLiteCursorRecord&amp; record)
497 {
498     if (m_statementNeedsReset) {
499         resetAndRebindPreIndexStatementIfNecessary();
500         resetAndRebindStatement();
501     }
502 
503     FetchResult result;
504     do {
505         result = internalFetchNextRecord(record);
506     } while (result == FetchResult::ShouldFetchAgain);
507 
508     return result == FetchResult::Success;
509 }
510 
511 void SQLiteIDBCursor::markAsErrored(SQLiteCursorRecord&amp; record)
512 {
513     record.record = { };
514     record.completed = true;
515     record.errored = true;
516     record.rowID = 0;
517 }
518 
519 SQLiteIDBCursor::FetchResult SQLiteIDBCursor::internalFetchNextRecord(SQLiteCursorRecord&amp; record)
520 {
521     ASSERT(m_transaction-&gt;sqliteTransaction());
522     ASSERT(m_statement);
523     ASSERT(!m_fetchedRecords.isEmpty());
524     ASSERT(!m_fetchedRecords.last().isTerminalRecord());
525 
526     record.record.value = { };
527 
528     auto&amp; database = m_transaction-&gt;sqliteTransaction()-&gt;database();
529     SQLiteStatement* statement = nullptr;
530 
531     int result;
532     if (m_preIndexStatement) {
533         ASSERT(m_indexID != IDBIndexInfo::InvalidId);
534 
535         result = m_preIndexStatement-&gt;step();
536         if (result == SQLITE_ROW)
537             statement = m_preIndexStatement.get();
538         else if (result != SQLITE_DONE)
539             LOG_ERROR(&quot;Error advancing with pre statement - (%i) %s&quot;, result, database.lastErrorMsg());
540     }
541 
542     if (!statement) {
543         result = m_statement-&gt;step();
544         if (result == SQLITE_DONE) {
545             record = { };
546             record.completed = true;
547             return FetchResult::Success;
548         }
549         if (result != SQLITE_ROW) {
550             LOG_ERROR(&quot;Error advancing cursor - (%i) %s&quot;, result, database.lastErrorMsg());
551             markAsErrored(record);
552             return FetchResult::Failure;
553         }
554         statement = m_statement.get();
555     }
556 
557     record.rowID = statement-&gt;getColumnInt64(0);
558     ASSERT(record.rowID);
559 
560     Vector&lt;uint8_t&gt; keyData;
561     statement-&gt;getColumnBlobAsVector(1, keyData);
562 
563     if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.key)) {
564         LOG_ERROR(&quot;Unable to deserialize key data from database while advancing cursor&quot;);
565         markAsErrored(record);
566         return FetchResult::Failure;
567     }
568 
569     statement-&gt;getColumnBlobAsVector(2, keyData);
570 
571     // The primaryKey of an ObjectStore cursor is the same as its key.
572     if (m_indexID == IDBIndexInfo::InvalidId) {
573         record.record.primaryKey = record.record.key;
574 
575         Vector&lt;String&gt; blobURLs, blobFilePaths;
576         auto error = m_transaction-&gt;backingStore().getBlobRecordsForObjectStoreRecord(record.rowID, blobURLs, blobFilePaths);
577         if (!error.isNull()) {
578             LOG_ERROR(&quot;Unable to fetch blob records from database while advancing cursor&quot;);
579             markAsErrored(record);
580             return FetchResult::Failure;
581         }
582 
583         if (m_cursorType == IndexedDB::CursorType::KeyAndValue)
584             record.record.value = { ThreadSafeDataBuffer::create(WTFMove(keyData)), blobURLs, blobFilePaths };
585     } else {
586         if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.primaryKey)) {
587             LOG_ERROR(&quot;Unable to deserialize value data from database while advancing index cursor&quot;);
588             markAsErrored(record);
589             return FetchResult::Failure;
590         }
591 
592         if (!m_cachedObjectStoreStatement || m_cachedObjectStoreStatement-&gt;reset() != SQLITE_OK) {
593             m_cachedObjectStoreStatement = makeUnique&lt;SQLiteStatement&gt;(database, &quot;SELECT value FROM Records WHERE key = CAST(? AS TEXT) and objectStoreID = ?;&quot;);
594             if (m_cachedObjectStoreStatement-&gt;prepare() != SQLITE_OK)
595                 m_cachedObjectStoreStatement = nullptr;
596         }
597 
598         if (!m_cachedObjectStoreStatement
599             || m_cachedObjectStoreStatement-&gt;bindBlob(1, keyData.data(), keyData.size()) != SQLITE_OK
600             || m_cachedObjectStoreStatement-&gt;bindInt64(2, m_objectStoreID) != SQLITE_OK) {
601             LOG_ERROR(&quot;Could not create index cursor statement into object store records (%i) &#39;%s&#39;&quot;, database.lastError(), database.lastErrorMsg());
602             markAsErrored(record);
603             return FetchResult::Failure;
604         }
605 
606         int result = m_cachedObjectStoreStatement-&gt;step();
607 
608         if (result == SQLITE_ROW) {
609             m_cachedObjectStoreStatement-&gt;getColumnBlobAsVector(0, keyData);
610             record.record.value = { ThreadSafeDataBuffer::create(WTFMove(keyData)) };
611         } else if (result == SQLITE_DONE) {
612             // This indicates that the record we&#39;re trying to retrieve has been removed from the object store.
613             // Skip over it.
614             return FetchResult::ShouldFetchAgain;
615         } else {
616             LOG_ERROR(&quot;Could not step index cursor statement into object store records (%i) &#39;%s&#39;&quot;, database.lastError(), database.lastErrorMsg());
617             markAsErrored(record);
618             return FetchResult::Failure;
619 
620         }
621     }
622 
623     return FetchResult::Success;
624 }
625 
626 bool SQLiteIDBCursor::iterate(const IDBKeyData&amp; targetKey, const IDBKeyData&amp; targetPrimaryKey)
627 {
628     ASSERT(m_transaction-&gt;sqliteTransaction());
629     ASSERT(m_statement);
630 
631     bool result = advance(1);
632     ASSERT(!m_fetchedRecords.isEmpty());
633 
634     // Iterating with no key is equivalent to advancing 1 step.
635     if (targetKey.isNull() || !result)
636         return result;
637 
638     while (!m_fetchedRecords.first().isTerminalRecord()) {
639         if (!result)
640             return false;
641 
642         // Search for the next key &gt;= the target if the cursor is a Next cursor, or the next key &lt;= if the cursor is a Previous cursor.
643         if (m_cursorDirection == IndexedDB::CursorDirection::Next || m_cursorDirection == IndexedDB::CursorDirection::Nextunique) {
644             if (m_fetchedRecords.first().record.key.compare(targetKey) &gt;= 0)
645                 break;
646         } else if (m_fetchedRecords.first().record.key.compare(targetKey) &lt;= 0)
647             break;
648 
649         result = advance(1);
650     }
651 
652     if (targetPrimaryKey.isValid()) {
653         while (!m_fetchedRecords.first().isTerminalRecord() &amp;&amp; !m_fetchedRecords.first().record.key.compare(targetKey)) {
654             if (!result)
655                 return false;
656 
657             // Search for the next primary key &gt;= the primary target if the cursor is a Next cursor, or the next key &lt;= if the cursor is a Previous cursor.
658             if (m_cursorDirection == IndexedDB::CursorDirection::Next || m_cursorDirection == IndexedDB::CursorDirection::Nextunique) {
659                 if (m_fetchedRecords.first().record.primaryKey.compare(targetPrimaryKey) &gt;= 0)
660                     break;
661             } else if (m_fetchedRecords.first().record.primaryKey.compare(targetPrimaryKey) &lt;= 0)
662                 break;
663 
664             result = advance(1);
665         }
666     }
667 
668     return result;
669 }
670 
671 const IDBKeyData&amp; SQLiteIDBCursor::currentKey() const
672 {
673     ASSERT(!m_fetchedRecords.isEmpty());
674     return m_fetchedRecords.first().record.key;
675 }
676 
677 const IDBKeyData&amp; SQLiteIDBCursor::currentPrimaryKey() const
678 {
679     ASSERT(!m_fetchedRecords.isEmpty());
680     return m_fetchedRecords.first().record.primaryKey;
681 }
682 
683 const IDBValue&amp; SQLiteIDBCursor::currentValue() const
684 {
685     ASSERT(!m_fetchedRecords.isEmpty());
686     return m_fetchedRecords.first().record.value;
687 }
688 
689 bool SQLiteIDBCursor::didComplete() const
690 {
691     ASSERT(!m_fetchedRecords.isEmpty());
692     return m_fetchedRecords.first().completed;
693 }
694 
695 bool SQLiteIDBCursor::didError() const
696 {
697     ASSERT(!m_fetchedRecords.isEmpty());
698     return m_fetchedRecords.first().errored;
699 }
700 
701 int64_t SQLiteIDBCursor::currentRecordRowID() const
702 {
703     ASSERT(!m_fetchedRecords.isEmpty());
704     return m_fetchedRecords.first().rowID;
705 }
706 
707 
708 } // namespace IDBServer
709 } // namespace WebCore
710 
711 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
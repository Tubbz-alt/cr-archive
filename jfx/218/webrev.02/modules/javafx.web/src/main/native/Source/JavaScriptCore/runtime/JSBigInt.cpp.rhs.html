<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2017 Caio Lima &lt;ticaiolima@gmail.com&gt;
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  *
  26  * Parts of the implementation below:
  27  *
  28  * Copyright 2017 the V8 project authors. All rights reserved.
  29  * Use of this source code is governed by a BSD-style license that can be
  30  * found in the LICENSE file.
  31  *
  32  *
  33  * Copyright (c) 2014 the Dart project authors.  Please see the AUTHORS file [1]
  34  * for details. All rights reserved. Use of this source code is governed by a
  35  * BSD-style license that can be found in the LICENSE file [2].
  36  *
  37  * [1] https://github.com/dart-lang/sdk/blob/master/AUTHORS
  38  * [2] https://github.com/dart-lang/sdk/blob/master/LICENSE
  39  *
  40  * Copyright 2009 The Go Authors. All rights reserved.
  41  * Use of this source code is governed by a BSD-style
  42  * license that can be found in the LICENSE file [3].
  43  *
  44  * [3] https://golang.org/LICENSE
  45  */
  46 
  47 #include &quot;config.h&quot;
  48 #include &quot;JSBigInt.h&quot;
  49 
  50 #include &quot;BigIntObject.h&quot;
  51 #include &quot;CatchScope.h&quot;
  52 #include &quot;JSCInlines.h&quot;
  53 #include &quot;MathCommon.h&quot;
  54 #include &quot;ParseInt.h&quot;
  55 #include &lt;algorithm&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 
  58 #define STATIC_ASSERT(cond) static_assert(cond, &quot;JSBigInt assumes &quot; #cond)
  59 
  60 namespace JSC {
  61 
  62 const ClassInfo JSBigInt::s_info = { &quot;BigInt&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(JSBigInt) };
  63 
<a name="2" id="anc2"></a><span class="line-modified">  64 JSBigInt::JSBigInt(VM&amp; vm, Structure* structure, Digit* data, unsigned length)</span>
  65     : Base(vm, structure)
  66     , m_length(length)
<a name="3" id="anc3"></a><span class="line-added">  67     , m_data(data, length)</span>
  68 { }
  69 
<a name="4" id="anc4"></a><span class="line-added">  70 void JSBigInt::destroy(JSCell* thisCell)</span>
<span class="line-added">  71 {</span>
<span class="line-added">  72     static_cast&lt;JSBigInt*&gt;(thisCell)-&gt;~JSBigInt();</span>
<span class="line-added">  73 }</span>
<span class="line-added">  74 </span>
  75 void JSBigInt::initialize(InitializationType initType)
  76 {
  77     if (initType == InitializationType::WithZero)
  78         memset(dataStorage(), 0, length() * sizeof(Digit));
  79 }
  80 
  81 Structure* JSBigInt::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  82 {
  83     return Structure::create(vm, globalObject, prototype, TypeInfo(BigIntType, StructureFlags), info());
  84 }
  85 
  86 JSBigInt* JSBigInt::createZero(VM&amp; vm)
  87 {
  88     JSBigInt* zeroBigInt = createWithLengthUnchecked(vm, 0);
  89     return zeroBigInt;
  90 }
  91 
<a name="5" id="anc5"></a><span class="line-modified">  92 JSBigInt* JSBigInt::tryCreateWithLength(JSGlobalObject* globalObject, unsigned length)</span>
  93 {
<a name="6" id="anc6"></a><span class="line-modified">  94     VM&amp; vm = globalObject-&gt;vm();</span>






  95     auto scope = DECLARE_THROW_SCOPE(vm);
  96 
  97     if (UNLIKELY(length &gt; maxLength)) {
<a name="7" id="anc7"></a><span class="line-modified">  98         throwOutOfMemoryError(globalObject, scope);</span>
  99         return nullptr;
 100     }
 101 
 102     scope.release();
 103 
 104     return createWithLengthUnchecked(vm, length);
 105 }
 106 
 107 JSBigInt* JSBigInt::createWithLengthUnchecked(VM&amp; vm, unsigned length)
 108 {
 109     ASSERT(length &lt;= maxLength);
<a name="8" id="anc8"></a><span class="line-modified"> 110     void* data = Gigacage::malloc(Gigacage::Primitive, length * sizeof(Digit));</span>
<span class="line-added"> 111     JSBigInt* bigInt = new (NotNull, allocateCell&lt;JSBigInt&gt;(vm.heap)) JSBigInt(vm, vm.bigIntStructure.get(), reinterpret_cast&lt;Digit*&gt;(data), length);</span>
 112     bigInt-&gt;finishCreation(vm);
 113     return bigInt;
 114 }
 115 
 116 JSBigInt* JSBigInt::createFrom(VM&amp; vm, int32_t value)
 117 {
 118     if (!value)
 119         return createZero(vm);
 120 
 121     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 122     if (value &lt; 0) {
 123         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(-1 * static_cast&lt;int64_t&gt;(value)));
 124         bigInt-&gt;setSign(true);
 125     } else
 126         bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 127 
 128     return bigInt;
 129 }
 130 
 131 JSBigInt* JSBigInt::createFrom(VM&amp; vm, uint32_t value)
 132 {
 133     if (!value)
 134         return createZero(vm);
 135 
 136     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 137     bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 138     return bigInt;
 139 }
 140 
 141 JSBigInt* JSBigInt::createFrom(VM&amp; vm, int64_t value)
 142 {
 143     if (!value)
 144         return createZero(vm);
 145 
 146     if (sizeof(Digit) == 8) {
 147         JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 148         if (value &lt; 0) {
 149             bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(static_cast&lt;uint64_t&gt;(-(value + 1)) + 1));
 150             bigInt-&gt;setSign(true);
 151         } else
 152             bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 153 
 154         return bigInt;
 155     }
 156 
 157     JSBigInt* bigInt = createWithLengthUnchecked(vm, 2);
 158     uint64_t tempValue;
 159     bool sign = false;
 160     if (value &lt; 0) {
 161         tempValue = static_cast&lt;uint64_t&gt;(-(value + 1)) + 1;
 162         sign = true;
 163     } else
 164         tempValue = value;
 165 
 166     Digit lowBits  = static_cast&lt;Digit&gt;(tempValue &amp; 0xffffffff);
 167     Digit highBits = static_cast&lt;Digit&gt;((tempValue &gt;&gt; 32) &amp; 0xffffffff);
 168 
 169     bigInt-&gt;setDigit(0, lowBits);
 170     bigInt-&gt;setDigit(1, highBits);
 171     bigInt-&gt;setSign(sign);
 172 
 173     return bigInt;
 174 }
 175 
 176 JSBigInt* JSBigInt::createFrom(VM&amp; vm, bool value)
 177 {
 178     if (!value)
 179         return createZero(vm);
 180 
 181     JSBigInt* bigInt = createWithLengthUnchecked(vm, 1);
 182     bigInt-&gt;setDigit(0, static_cast&lt;Digit&gt;(value));
 183     return bigInt;
 184 }
 185 
<a name="9" id="anc9"></a><span class="line-modified"> 186 JSValue JSBigInt::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const</span>
 187 {
 188     return const_cast&lt;JSBigInt*&gt;(this);
 189 }
 190 
 191 Optional&lt;uint8_t&gt; JSBigInt::singleDigitValueForString()
 192 {
 193     if (isZero())
 194         return 0;
 195 
 196     if (length() == 1 &amp;&amp; !sign()) {
 197         Digit rDigit = digit(0);
 198         if (rDigit &lt;= 9)
 199             return static_cast&lt;uint8_t&gt;(rDigit);
 200     }
 201     return { };
 202 }
 203 
<a name="10" id="anc10"></a><span class="line-modified"> 204 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, StringView s, ErrorParseMode parserMode)</span>
 205 {
 206     if (s.is8Bit())
<a name="11" id="anc11"></a><span class="line-modified"> 207         return parseInt(globalObject, s.characters8(), s.length(), parserMode);</span>
<span class="line-modified"> 208     return parseInt(globalObject, s.characters16(), s.length(), parserMode);</span>
 209 }
 210 
<a name="12" id="anc12"></a><span class="line-modified"> 211 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM&amp; vm, StringView s, uint8_t radix, ErrorParseMode parserMode, ParseIntSign sign)</span>
 212 {
 213     if (s.is8Bit())
<a name="13" id="anc13"></a><span class="line-modified"> 214         return parseInt(globalObject, vm, s.characters8(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
<span class="line-modified"> 215     return parseInt(globalObject, vm, s.characters16(), s.length(), 0, radix, parserMode, sign, ParseIntMode::DisallowEmptyString);</span>
 216 }
 217 
<a name="14" id="anc14"></a><span class="line-modified"> 218 JSBigInt* JSBigInt::stringToBigInt(JSGlobalObject* globalObject, StringView s)</span>
 219 {
<a name="15" id="anc15"></a><span class="line-modified"> 220     return parseInt(globalObject, s, ErrorParseMode::IgnoreExceptions);</span>
 221 }
 222 
<a name="16" id="anc16"></a><span class="line-modified"> 223 String JSBigInt::toString(JSGlobalObject* globalObject, unsigned radix)</span>
 224 {
 225     if (this-&gt;isZero())
<a name="17" id="anc17"></a><span class="line-modified"> 226         return globalObject-&gt;vm().smallStrings.singleCharacterStringRep(&#39;0&#39;);</span>
 227 
 228     if (hasOneBitSet(radix))
<a name="18" id="anc18"></a><span class="line-modified"> 229         return toStringBasePowerOfTwo(globalObject-&gt;vm(), globalObject, this, radix);</span>
 230 
<a name="19" id="anc19"></a><span class="line-modified"> 231     return toStringGeneric(globalObject-&gt;vm(), globalObject, this, radix);</span>
 232 }
 233 
 234 String JSBigInt::tryGetString(VM&amp; vm, JSBigInt* bigInt, unsigned radix)
 235 {
 236     if (bigInt-&gt;isZero())
 237         return vm.smallStrings.singleCharacterStringRep(&#39;0&#39;);
 238 
 239     if (hasOneBitSet(radix))
 240         return toStringBasePowerOfTwo(vm, nullptr, bigInt, radix);
 241 
 242     return toStringGeneric(vm, nullptr, bigInt, radix);
 243 }
 244 
 245 // Multiplies {this} with {factor} and adds {summand} to the result.
 246 void JSBigInt::inplaceMultiplyAdd(Digit factor, Digit summand)
 247 {
 248     internalMultiplyAdd(this, factor, summand, length(), this);
 249 }
 250 
<a name="20" id="anc20"></a><span class="line-modified"> 251 JSBigInt* JSBigInt::exponentiate(JSGlobalObject* globalObject, JSBigInt* base, JSBigInt* exponent)</span>
 252 {
<a name="21" id="anc21"></a><span class="line-modified"> 253     VM&amp; vm = globalObject-&gt;vm();</span>
 254     auto scope = DECLARE_THROW_SCOPE(vm);
 255 
 256     if (exponent-&gt;sign()) {
<a name="22" id="anc22"></a><span class="line-modified"> 257         throwRangeError(globalObject, scope, &quot;Negative exponent is not allowed&quot;_s);</span>
 258         return nullptr;
 259     }
 260 
 261     // 2. If base is 0n and exponent is 0n, return 1n.
 262     if (exponent-&gt;isZero())
 263         return JSBigInt::createFrom(vm, 1);
 264 
 265     // 3. Return a BigInt representing the mathematical value of base raised
 266     //    to the power exponent.
 267     if (base-&gt;isZero())
 268         return base;
 269 
 270     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 1) {
 271         // (-1) ** even_number == 1.
 272         if (base-&gt;sign() &amp;&amp; !(exponent-&gt;digit(0) &amp; 1))
 273             return JSBigInt::unaryMinus(vm, base);
 274 
 275         // (-1) ** odd_number == -1; 1 ** anything == 1.
 276         return base;
 277     }
 278 
 279     // For all bases &gt;= 2, very large exponents would lead to unrepresentable
 280     // results.
 281     static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit::max()&quot;);
 282     if (exponent-&gt;length() &gt; 1) {
<a name="23" id="anc23"></a><span class="line-modified"> 283         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
 284         return nullptr;
 285     }
 286 
 287     Digit expValue = exponent-&gt;digit(0);
 288     if (expValue == 1)
 289         return base;
 290     if (expValue &gt;= maxLengthBits) {
<a name="24" id="anc24"></a><span class="line-modified"> 291         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
 292         return nullptr;
 293     }
 294 
 295     static_assert(maxLengthBits &lt;= maxInt, &quot;maxLengthBits needs to be &lt;= maxInt&quot;);
 296     int n = static_cast&lt;int&gt;(expValue);
 297     if (base-&gt;length() == 1 &amp;&amp; base-&gt;digit(0) == 2) {
 298         // Fast path for 2^n.
 299         int neededDigits = 1 + (n / digitBits);
<a name="25" id="anc25"></a><span class="line-modified"> 300         JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, neededDigits);</span>
 301         RETURN_IF_EXCEPTION(scope, nullptr);
 302 
 303         result-&gt;initialize(InitializationType::WithZero);
 304         // All bits are zero. Now set the n-th bit.
 305         Digit msd = static_cast&lt;Digit&gt;(1) &lt;&lt; (n % digitBits);
 306         result-&gt;setDigit(neededDigits - 1, msd);
 307         // Result is negative for odd powers of -2n.
 308         if (base-&gt;sign())
 309             result-&gt;setSign(static_cast&lt;bool&gt;(n &amp; 1));
 310 
 311         return result;
 312     }
 313 
 314     JSBigInt* result = nullptr;
 315     JSBigInt* runningSquare = base;
 316 
 317     // This implicitly sets the result&#39;s sign correctly.
 318     if (n &amp; 1)
 319         result = base;
 320 
 321     n &gt;&gt;= 1;
 322     for (; n; n &gt;&gt;= 1) {
<a name="26" id="anc26"></a><span class="line-modified"> 323         JSBigInt* maybeResult = JSBigInt::multiply(globalObject, runningSquare, runningSquare);</span>
 324         RETURN_IF_EXCEPTION(scope, nullptr);
 325         runningSquare = maybeResult;
 326         if (n &amp; 1) {
 327             if (!result)
 328                 result = runningSquare;
 329             else {
<a name="27" id="anc27"></a><span class="line-modified"> 330                 maybeResult = JSBigInt::multiply(globalObject, result, runningSquare);</span>
 331                 RETURN_IF_EXCEPTION(scope, nullptr);
 332                 result = maybeResult;
 333             }
 334         }
 335     }
 336 
 337     return result;
 338 }
 339 
<a name="28" id="anc28"></a><span class="line-modified"> 340 JSBigInt* JSBigInt::multiply(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 341 {
<a name="29" id="anc29"></a><span class="line-modified"> 342     VM&amp; vm = globalObject-&gt;vm();</span>
 343     auto scope = DECLARE_THROW_SCOPE(vm);
 344 
 345     if (x-&gt;isZero())
 346         return x;
 347     if (y-&gt;isZero())
 348         return y;
 349 
 350     unsigned resultLength = x-&gt;length() + y-&gt;length();
<a name="30" id="anc30"></a><span class="line-modified"> 351     JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, resultLength);</span>
 352     RETURN_IF_EXCEPTION(scope, nullptr);
 353     result-&gt;initialize(InitializationType::WithZero);
 354 
 355     for (unsigned i = 0; i &lt; x-&gt;length(); i++)
 356         multiplyAccumulate(y, x-&gt;digit(i), result, i);
 357 
 358     result-&gt;setSign(x-&gt;sign() != y-&gt;sign());
 359     return result-&gt;rightTrim(vm);
 360 }
 361 
<a name="31" id="anc31"></a><span class="line-modified"> 362 JSBigInt* JSBigInt::divide(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 363 {
 364     // 1. If y is 0n, throw a RangeError exception.
<a name="32" id="anc32"></a><span class="line-modified"> 365     VM&amp; vm = globalObject-&gt;vm();</span>
 366     auto scope = DECLARE_THROW_SCOPE(vm);
 367 
 368     if (y-&gt;isZero()) {
<a name="33" id="anc33"></a><span class="line-modified"> 369         throwRangeError(globalObject, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
 370         return nullptr;
 371     }
 372 
 373     // 2. Let quotient be the mathematical value of x divided by y.
 374     // 3. Return a BigInt representing quotient rounded towards 0 to the next
 375     //    integral value.
 376     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 377         return createZero(vm);
 378 
 379     JSBigInt* quotient = nullptr;
 380     bool resultSign = x-&gt;sign() != y-&gt;sign();
 381     if (y-&gt;length() == 1) {
 382         Digit divisor = y-&gt;digit(0);
 383         if (divisor == 1)
 384             return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 385 
 386         Digit remainder;
 387         absoluteDivWithDigitDivisor(vm, x, divisor, &amp;quotient, remainder);
 388     } else {
<a name="34" id="anc34"></a><span class="line-modified"> 389         absoluteDivWithBigIntDivisor(globalObject, x, y, &amp;quotient, nullptr);</span>
 390         RETURN_IF_EXCEPTION(scope, nullptr);
 391     }
 392 
 393     quotient-&gt;setSign(resultSign);
 394     return quotient-&gt;rightTrim(vm);
 395 }
 396 
 397 JSBigInt* JSBigInt::copy(VM&amp; vm, JSBigInt* x)
 398 {
 399     ASSERT(!x-&gt;isZero());
 400 
 401     JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, x-&gt;length());
 402     std::copy(x-&gt;dataStorage(), x-&gt;dataStorage() + x-&gt;length(), result-&gt;dataStorage());
 403     result-&gt;setSign(x-&gt;sign());
 404     return result;
 405 }
 406 
 407 JSBigInt* JSBigInt::unaryMinus(VM&amp; vm, JSBigInt* x)
 408 {
 409     if (x-&gt;isZero())
 410         return x;
 411 
 412     JSBigInt* result = copy(vm, x);
 413     result-&gt;setSign(!x-&gt;sign());
 414     return result;
 415 }
 416 
<a name="35" id="anc35"></a><span class="line-modified"> 417 JSBigInt* JSBigInt::remainder(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 418 {
 419     // 1. If y is 0n, throw a RangeError exception.
<a name="36" id="anc36"></a><span class="line-modified"> 420     VM&amp; vm = globalObject-&gt;vm();</span>
 421     auto scope = DECLARE_THROW_SCOPE(vm);
 422 
 423     if (y-&gt;isZero()) {
<a name="37" id="anc37"></a><span class="line-modified"> 424         throwRangeError(globalObject, scope, &quot;0 is an invalid divisor value.&quot;_s);</span>
 425         return nullptr;
 426     }
 427 
 428     // 2. Return the JSBigInt representing x modulo y.
 429     // See https://github.com/tc39/proposal-bigint/issues/84 though.
 430     if (absoluteCompare(x, y) == ComparisonResult::LessThan)
 431         return x;
 432 
 433     JSBigInt* remainder;
 434     if (y-&gt;length() == 1) {
 435         Digit divisor = y-&gt;digit(0);
 436         if (divisor == 1)
 437             return createZero(vm);
 438 
 439         Digit remainderDigit;
 440         absoluteDivWithDigitDivisor(vm, x, divisor, nullptr, remainderDigit);
 441         if (!remainderDigit)
 442             return createZero(vm);
 443 
 444         remainder = createWithLengthUnchecked(vm, 1);
 445         remainder-&gt;setDigit(0, remainderDigit);
 446     } else {
<a name="38" id="anc38"></a><span class="line-modified"> 447         absoluteDivWithBigIntDivisor(globalObject, x, y, nullptr, &amp;remainder);</span>
 448         RETURN_IF_EXCEPTION(scope, nullptr);
 449     }
 450 
 451     remainder-&gt;setSign(x-&gt;sign());
 452     return remainder-&gt;rightTrim(vm);
 453 }
 454 
<a name="39" id="anc39"></a><span class="line-modified"> 455 JSBigInt* JSBigInt::inc(JSGlobalObject* globalObject, JSBigInt* x)</span>
<span class="line-added"> 456 {</span>
<span class="line-added"> 457     // FIXME: we can probably do something a fair bit more efficient here</span>
<span class="line-added"> 458     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 459     return add(globalObject, x, vm.bigIntConstantOne.get());</span>
<span class="line-added"> 460 }</span>
<span class="line-added"> 461 </span>
<span class="line-added"> 462 JSBigInt* JSBigInt::dec(JSGlobalObject* globalObject, JSBigInt* x)</span>
 463 {
<a name="40" id="anc40"></a><span class="line-modified"> 464     // FIXME: we can probably do something a fair bit more efficient here</span>
<span class="line-added"> 465     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 466     return sub(globalObject, x, vm.bigIntConstantOne.get());</span>
<span class="line-added"> 467 }</span>
<span class="line-added"> 468 </span>
<span class="line-added"> 469 JSBigInt* JSBigInt::add(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
<span class="line-added"> 470 {</span>
<span class="line-added"> 471     VM&amp; vm = globalObject-&gt;vm();</span>
 472     bool xSign = x-&gt;sign();
 473 
 474     // x + y == x + y
 475     // -x + -y == -(x + y)
 476     if (xSign == y-&gt;sign())
<a name="41" id="anc41"></a><span class="line-modified"> 477         return absoluteAdd(globalObject, x, y, xSign);</span>
 478 
 479     // x + -y == x - y == -(y - x)
 480     // -x + y == y - x == -(x - y)
 481     ComparisonResult comparisonResult = absoluteCompare(x, y);
 482     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 483         return absoluteSub(vm, x, y, xSign);
 484 
 485     return absoluteSub(vm, y, x, !xSign);
 486 }
 487 
<a name="42" id="anc42"></a><span class="line-modified"> 488 JSBigInt* JSBigInt::sub(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 489 {
<a name="43" id="anc43"></a><span class="line-modified"> 490     VM&amp; vm = globalObject-&gt;vm();</span>
 491     bool xSign = x-&gt;sign();
 492     if (xSign != y-&gt;sign()) {
 493         // x - (-y) == x + y
 494         // (-x) - y == -(x + y)
<a name="44" id="anc44"></a><span class="line-modified"> 495         return absoluteAdd(globalObject, x, y, xSign);</span>
 496     }
 497     // x - y == -(y - x)
 498     // (-x) - (-y) == y - x == -(x - y)
 499     ComparisonResult comparisonResult = absoluteCompare(x, y);
 500     if (comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal)
 501         return absoluteSub(vm, x, y, xSign);
 502 
 503     return absoluteSub(vm, y, x, !xSign);
 504 }
 505 
<a name="45" id="anc45"></a><span class="line-modified"> 506 JSBigInt* JSBigInt::bitwiseAnd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 507 {
<a name="46" id="anc46"></a><span class="line-modified"> 508     VM&amp; vm = globalObject-&gt;vm();</span>
 509     auto scope = DECLARE_THROW_SCOPE(vm);
 510 
 511     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 512         scope.release();
 513         return absoluteAnd(vm, x, y);
 514     }
 515 
 516     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 517         int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 518         // (-x) &amp; (-y) == ~(x-1) &amp; ~(y-1) == ~((x-1) | (y-1))
 519         // == -(((x-1) | (y-1)) + 1)
<a name="47" id="anc47"></a><span class="line-modified"> 520         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
 521         RETURN_IF_EXCEPTION(scope, nullptr);
 522 
<a name="48" id="anc48"></a><span class="line-modified"> 523         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 524         RETURN_IF_EXCEPTION(scope, nullptr);
 525         result = absoluteOr(vm, result, y1);
 526         scope.release();
<a name="49" id="anc49"></a><span class="line-modified"> 527         return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 528     }
 529 
 530     ASSERT(x-&gt;sign() != y-&gt;sign());
 531     // Assume that x is the positive BigInt.
 532     if (x-&gt;sign())
 533         std::swap(x, y);
 534 
 535     // x &amp; (-y) == x &amp; ~(y-1) == x &amp; ~(y-1)
<a name="50" id="anc50"></a><span class="line-modified"> 536     JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 537     RETURN_IF_EXCEPTION(scope, nullptr);
 538     return absoluteAndNot(vm, x, y1);
 539 }
 540 
<a name="51" id="anc51"></a><span class="line-modified"> 541 JSBigInt* JSBigInt::bitwiseOr(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 542 {
<a name="52" id="anc52"></a><span class="line-modified"> 543     VM&amp; vm = globalObject-&gt;vm();</span>
 544     auto scope = DECLARE_THROW_SCOPE(vm);
 545 
 546     unsigned resultLength = std::max(x-&gt;length(), y-&gt;length());
 547 
 548     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 549         scope.release();
 550         return absoluteOr(vm, x, y);
 551     }
 552 
 553     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 554         // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) &amp; (y-1))
 555         // == -(((x-1) &amp; (y-1)) + 1)
<a name="53" id="anc53"></a><span class="line-modified"> 556         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
 557         RETURN_IF_EXCEPTION(scope, nullptr);
<a name="54" id="anc54"></a><span class="line-modified"> 558         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 559         RETURN_IF_EXCEPTION(scope, nullptr);
 560         result = absoluteAnd(vm, result, y1);
 561         RETURN_IF_EXCEPTION(scope, nullptr);
 562 
 563         scope.release();
<a name="55" id="anc55"></a><span class="line-modified"> 564         return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 565     }
 566 
 567     ASSERT(x-&gt;sign() != y-&gt;sign());
 568 
 569     // Assume that x is the positive BigInt.
 570     if (x-&gt;sign())
 571         std::swap(x, y);
 572 
 573     // x | (-y) == x | ~(y-1) == ~((y-1) &amp;~ x) == -(((y-1) &amp;~ x) + 1)
<a name="56" id="anc56"></a><span class="line-modified"> 574     JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);</span>
 575     RETURN_IF_EXCEPTION(scope, nullptr);
 576     result = absoluteAndNot(vm, result, x);
 577 
 578     scope.release();
<a name="57" id="anc57"></a><span class="line-modified"> 579     return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 580 }
 581 
<a name="58" id="anc58"></a><span class="line-modified"> 582 JSBigInt* JSBigInt::bitwiseXor(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 583 {
<a name="59" id="anc59"></a><span class="line-modified"> 584     VM&amp; vm = globalObject-&gt;vm();</span>
 585     auto scope = DECLARE_THROW_SCOPE(vm);
 586 
 587     if (!x-&gt;sign() &amp;&amp; !y-&gt;sign()) {
 588         scope.release();
 589         return absoluteXor(vm, x, y);
 590     }
 591 
 592     if (x-&gt;sign() &amp;&amp; y-&gt;sign()) {
 593         int resultLength = std::max(x-&gt;length(), y-&gt;length());
 594 
 595         // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)
<a name="60" id="anc60"></a><span class="line-modified"> 596         JSBigInt* result = absoluteSubOne(globalObject, x, resultLength);</span>
 597         RETURN_IF_EXCEPTION(scope, nullptr);
<a name="61" id="anc61"></a><span class="line-modified"> 598         JSBigInt* y1 = absoluteSubOne(globalObject, y, y-&gt;length());</span>
 599         RETURN_IF_EXCEPTION(scope, nullptr);
 600 
 601         scope.release();
 602         return absoluteXor(vm, result, y1);
 603     }
 604     ASSERT(x-&gt;sign() != y-&gt;sign());
 605     int resultLength = std::max(x-&gt;length(), y-&gt;length()) + 1;
 606 
 607     // Assume that x is the positive BigInt.
 608     if (x-&gt;sign())
 609         std::swap(x, y);
 610 
 611     // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)
<a name="62" id="anc62"></a><span class="line-modified"> 612     JSBigInt* result = absoluteSubOne(globalObject, y, resultLength);</span>
 613     RETURN_IF_EXCEPTION(scope, nullptr);
 614 
 615     result = absoluteXor(vm, result, x);
 616     scope.release();
<a name="63" id="anc63"></a><span class="line-modified"> 617     return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
 618 }
 619 
<a name="64" id="anc64"></a><span class="line-modified"> 620 JSBigInt* JSBigInt::leftShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 621 {
 622     if (y-&gt;isZero() || x-&gt;isZero())
 623         return x;
 624 
 625     if (y-&gt;sign())
<a name="65" id="anc65"></a><span class="line-modified"> 626         return rightShiftByAbsolute(globalObject, x, y);</span>
 627 
<a name="66" id="anc66"></a><span class="line-modified"> 628     return leftShiftByAbsolute(globalObject, x, y);</span>
 629 }
 630 
<a name="67" id="anc67"></a><span class="line-modified"> 631 JSBigInt* JSBigInt::signedRightShift(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
 632 {
 633     if (y-&gt;isZero() || x-&gt;isZero())
 634         return x;
 635 
 636     if (y-&gt;sign())
<a name="68" id="anc68"></a><span class="line-modified"> 637         return leftShiftByAbsolute(globalObject, x, y);</span>
 638 
<a name="69" id="anc69"></a><span class="line-modified"> 639     return rightShiftByAbsolute(globalObject, x, y);</span>
 640 }
 641 
<a name="70" id="anc70"></a><span class="line-modified"> 642 JSBigInt* JSBigInt::bitwiseNot(JSGlobalObject* globalObject, JSBigInt* x)</span>
 643 {
 644     if (x-&gt;sign()) {
 645         // ~(-x) == ~(~(x-1)) == x-1
<a name="71" id="anc71"></a><span class="line-modified"> 646         return absoluteSubOne(globalObject, x, x-&gt;length());</span>
 647     }
 648     // ~x == -x-1 == -(x+1)
<a name="72" id="anc72"></a><span class="line-modified"> 649     return absoluteAddOne(globalObject, x, SignOption::Signed);</span>
 650 }
 651 
 652 #if USE(JSVALUE32_64)
 653 #define HAVE_TWO_DIGIT 1
 654 typedef uint64_t TwoDigit;
 655 #elif HAVE(INT128_T)
 656 #define HAVE_TWO_DIGIT 1
 657 typedef __uint128_t TwoDigit;
 658 #else
 659 #define HAVE_TWO_DIGIT 0
 660 #endif
 661 
 662 // {carry} must point to an initialized Digit and will either be incremented
 663 // by one or left alone.
 664 inline JSBigInt::Digit JSBigInt::digitAdd(Digit a, Digit b, Digit&amp; carry)
 665 {
 666     Digit result = a + b;
 667     carry += static_cast&lt;bool&gt;(result &lt; a);
 668     return result;
 669 }
 670 
 671 // {borrow} must point to an initialized Digit and will either be incremented
 672 // by one or left alone.
 673 inline JSBigInt::Digit JSBigInt::digitSub(Digit a, Digit b, Digit&amp; borrow)
 674 {
 675     Digit result = a - b;
 676     borrow += static_cast&lt;bool&gt;(result &gt; a);
 677     return result;
 678 }
 679 
 680 // Returns the low half of the result. High half is in {high}.
 681 inline JSBigInt::Digit JSBigInt::digitMul(Digit a, Digit b, Digit&amp; high)
 682 {
 683 #if HAVE(TWO_DIGIT)
 684     TwoDigit result = static_cast&lt;TwoDigit&gt;(a) * static_cast&lt;TwoDigit&gt;(b);
 685     high = result &gt;&gt; digitBits;
 686 
 687     return static_cast&lt;Digit&gt;(result);
 688 #else
 689     // Multiply in half-pointer-sized chunks.
 690     // For inputs [AH AL]*[BH BL], the result is:
 691     //
 692     //            [AL*BL]  // rLow
 693     //    +    [AL*BH]     // rMid1
 694     //    +    [AH*BL]     // rMid2
 695     //    + [AH*BH]        // rHigh
 696     //    = [R4 R3 R2 R1]  // high = [R4 R3], low = [R2 R1]
 697     //
 698     // Where of course we must be careful with carries between the columns.
 699     Digit aLow = a &amp; halfDigitMask;
 700     Digit aHigh = a &gt;&gt; halfDigitBits;
 701     Digit bLow = b &amp; halfDigitMask;
 702     Digit bHigh = b &gt;&gt; halfDigitBits;
 703 
 704     Digit rLow = aLow * bLow;
 705     Digit rMid1 = aLow * bHigh;
 706     Digit rMid2 = aHigh * bLow;
 707     Digit rHigh = aHigh * bHigh;
 708 
 709     Digit carry = 0;
 710     Digit low = digitAdd(rLow, rMid1 &lt;&lt; halfDigitBits, carry);
 711     low = digitAdd(low, rMid2 &lt;&lt; halfDigitBits, carry);
 712 
 713     high = (rMid1 &gt;&gt; halfDigitBits) + (rMid2 &gt;&gt; halfDigitBits) + rHigh + carry;
 714 
 715     return low;
 716 #endif
 717 }
 718 
 719 // Raises {base} to the power of {exponent}. Does not check for overflow.
 720 inline JSBigInt::Digit JSBigInt::digitPow(Digit base, Digit exponent)
 721 {
 722     Digit result = 1ull;
 723     while (exponent &gt; 0) {
 724         if (exponent &amp; 1)
 725             result *= base;
 726 
 727         exponent &gt;&gt;= 1;
 728         base *= base;
 729     }
 730 
 731     return result;
 732 }
 733 
 734 // Returns the quotient.
 735 // quotient = (high &lt;&lt; digitBits + low - remainder) / divisor
 736 inline JSBigInt::Digit JSBigInt::digitDiv(Digit high, Digit low, Digit divisor, Digit&amp; remainder)
 737 {
 738     ASSERT(high &lt; divisor);
 739 #if CPU(X86_64) &amp;&amp; COMPILER(GCC_COMPATIBLE)
 740     Digit quotient;
 741     Digit rem;
 742     __asm__(&quot;divq  %[divisor]&quot;
 743         // Outputs: {quotient} will be in rax, {rem} in rdx.
 744         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 745         // Inputs: put {high} into rdx, {low} into rax, and {divisor} into
 746         // any register or stack slot.
 747         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 748     remainder = rem;
 749     return quotient;
 750 #elif CPU(X86) &amp;&amp; COMPILER(GCC_COMPATIBLE)
 751     Digit quotient;
 752     Digit rem;
 753     __asm__(&quot;divl  %[divisor]&quot;
 754         // Outputs: {quotient} will be in eax, {rem} in edx.
 755         : &quot;=a&quot;(quotient), &quot;=d&quot;(rem)
 756         // Inputs: put {high} into edx, {low} into eax, and {divisor} into
 757         // any register or stack slot.
 758         : &quot;d&quot;(high), &quot;a&quot;(low), [divisor] &quot;rm&quot;(divisor));
 759     remainder = rem;
 760     return quotient;
 761 #else
 762     static constexpr Digit halfDigitBase = 1ull &lt;&lt; halfDigitBits;
 763     // Adapted from Warren, Hacker&#39;s Delight, p. 152.
 764     unsigned s = clz(divisor);
 765     // If {s} is digitBits here, it causes an undefined behavior.
 766     // But {s} is never digitBits since {divisor} is never zero here.
 767     ASSERT(s != digitBits);
 768     divisor &lt;&lt;= s;
 769 
 770     Digit vn1 = divisor &gt;&gt; halfDigitBits;
 771     Digit vn0 = divisor &amp; halfDigitMask;
 772 
 773     // {sZeroMask} which is 0 if s == 0 and all 1-bits otherwise.
 774     // {s} can be 0. If {s} is 0, performing &quot;low &gt;&gt; (digitBits - s)&quot; must not be done since it causes an undefined behavior
 775     // since `&gt;&gt; digitBits` is undefied in C++. Quoted from C++ spec, &quot;The type of the result is that of the promoted left operand.
 776     // The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted
 777     // left operand&quot;. We mask the right operand of the shift by {shiftMask} (`digitBits - 1`), which makes `digitBits - 0` zero.
 778     // This shifting produces a value which covers 0 &lt; {s} &lt;= (digitBits - 1) cases. {s} == digitBits never happen as we asserted.
 779     // Since {sZeroMask} clears the value in the case of {s} == 0, {s} == 0 case is also covered.
 780     STATIC_ASSERT(sizeof(CPURegister) == sizeof(Digit));
 781     Digit sZeroMask = static_cast&lt;Digit&gt;((-static_cast&lt;CPURegister&gt;(s)) &gt;&gt; (digitBits - 1));
 782     static constexpr unsigned shiftMask = digitBits - 1;
 783     Digit un32 = (high &lt;&lt; s) | ((low &gt;&gt; ((digitBits - s) &amp; shiftMask)) &amp; sZeroMask);
 784 
 785     Digit un10 = low &lt;&lt; s;
 786     Digit un1 = un10 &gt;&gt; halfDigitBits;
 787     Digit un0 = un10 &amp; halfDigitMask;
 788     Digit q1 = un32 / vn1;
 789     Digit rhat = un32 - q1 * vn1;
 790 
 791     while (q1 &gt;= halfDigitBase || q1 * vn0 &gt; rhat * halfDigitBase + un1) {
 792         q1--;
 793         rhat += vn1;
 794         if (rhat &gt;= halfDigitBase)
 795             break;
 796     }
 797 
 798     Digit un21 = un32 * halfDigitBase + un1 - q1 * divisor;
 799     Digit q0 = un21 / vn1;
 800     rhat = un21 - q0 * vn1;
 801 
 802     while (q0 &gt;= halfDigitBase || q0 * vn0 &gt; rhat * halfDigitBase + un0) {
 803         q0--;
 804         rhat += vn1;
 805         if (rhat &gt;= halfDigitBase)
 806             break;
 807     }
 808 
 809     remainder = (un21 * halfDigitBase + un0 - q0 * divisor) &gt;&gt; s;
 810     return q1 * halfDigitBase + q0;
 811 #endif
 812 }
 813 
 814 // Multiplies {source} with {factor} and adds {summand} to the result.
 815 // {result} and {source} may be the same BigInt for inplace modification.
 816 void JSBigInt::internalMultiplyAdd(JSBigInt* source, Digit factor, Digit summand, unsigned n, JSBigInt* result)
 817 {
 818     ASSERT(source-&gt;length() &gt;= n);
 819     ASSERT(result-&gt;length() &gt;= n);
 820 
 821     Digit carry = summand;
 822     Digit high = 0;
 823     for (unsigned i = 0; i &lt; n; i++) {
 824         Digit current = source-&gt;digit(i);
 825         Digit newCarry = 0;
 826 
 827         // Compute this round&#39;s multiplication.
 828         Digit newHigh = 0;
 829         current = digitMul(current, factor, newHigh);
 830 
 831         // Add last round&#39;s carryovers.
 832         current = digitAdd(current, high, newCarry);
 833         current = digitAdd(current, carry, newCarry);
 834 
 835         // Store result and prepare for next round.
 836         result-&gt;setDigit(i, current);
 837         carry = newCarry;
 838         high = newHigh;
 839     }
 840 
 841     if (result-&gt;length() &gt; n) {
 842         result-&gt;setDigit(n++, carry + high);
 843 
 844         // Current callers don&#39;t pass in such large results, but let&#39;s be robust.
 845         while (n &lt; result-&gt;length())
 846             result-&gt;setDigit(n++, 0);
 847     } else
 848         ASSERT(!(carry + high));
 849 }
 850 
 851 // Multiplies {multiplicand} with {multiplier} and adds the result to
 852 // {accumulator}, starting at {accumulatorIndex} for the least-significant
 853 // digit.
 854 // Callers must ensure that {accumulator} is big enough to hold the result.
 855 void JSBigInt::multiplyAccumulate(JSBigInt* multiplicand, Digit multiplier, JSBigInt* accumulator, unsigned accumulatorIndex)
 856 {
 857     ASSERT(accumulator-&gt;length() &gt; multiplicand-&gt;length() + accumulatorIndex);
 858     if (!multiplier)
 859         return;
 860 
 861     Digit carry = 0;
 862     Digit high = 0;
 863     for (unsigned i = 0; i &lt; multiplicand-&gt;length(); i++, accumulatorIndex++) {
 864         Digit acc = accumulator-&gt;digit(accumulatorIndex);
 865         Digit newCarry = 0;
 866 
 867         // Add last round&#39;s carryovers.
 868         acc = digitAdd(acc, high, newCarry);
 869         acc = digitAdd(acc, carry, newCarry);
 870 
 871         // Compute this round&#39;s multiplication.
 872         Digit multiplicandDigit = multiplicand-&gt;digit(i);
 873         Digit low = digitMul(multiplier, multiplicandDigit, high);
 874         acc = digitAdd(acc, low, newCarry);
 875 
 876         // Store result and prepare for next round.
 877         accumulator-&gt;setDigit(accumulatorIndex, acc);
 878         carry = newCarry;
 879     }
 880 
 881     while (carry || high) {
 882         ASSERT(accumulatorIndex &lt; accumulator-&gt;length());
 883         Digit acc = accumulator-&gt;digit(accumulatorIndex);
 884         Digit newCarry = 0;
 885         acc = digitAdd(acc, high, newCarry);
 886         high = 0;
 887         acc = digitAdd(acc, carry, newCarry);
 888         accumulator-&gt;setDigit(accumulatorIndex, acc);
 889         carry = newCarry;
 890         accumulatorIndex++;
 891     }
 892 }
 893 
 894 bool JSBigInt::equals(JSBigInt* x, JSBigInt* y)
 895 {
 896     if (x-&gt;sign() != y-&gt;sign())
 897         return false;
 898 
 899     if (x-&gt;length() != y-&gt;length())
 900         return false;
 901 
 902     for (unsigned i = 0; i &lt; x-&gt;length(); i++) {
 903         if (x-&gt;digit(i) != y-&gt;digit(i))
 904             return false;
 905     }
 906 
 907     return true;
 908 }
 909 
 910 JSBigInt::ComparisonResult JSBigInt::compare(JSBigInt* x, JSBigInt* y)
 911 {
 912     bool xSign = x-&gt;sign();
 913 
 914     if (xSign != y-&gt;sign())
 915         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 916 
 917     ComparisonResult result = absoluteCompare(x, y);
 918     if (result == ComparisonResult::GreaterThan)
 919         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 920     if (result == ComparisonResult::LessThan)
 921         return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
 922 
 923     return ComparisonResult::Equal;
 924 }
 925 
 926 inline JSBigInt::ComparisonResult JSBigInt::absoluteCompare(JSBigInt* x, JSBigInt* y)
 927 {
 928     ASSERT(!x-&gt;length() || x-&gt;digit(x-&gt;length() - 1));
 929     ASSERT(!y-&gt;length() || y-&gt;digit(y-&gt;length() - 1));
 930 
 931     int diff = x-&gt;length() - y-&gt;length();
 932     if (diff)
 933         return diff &lt; 0 ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
 934 
 935     int i = x-&gt;length() - 1;
 936     while (i &gt;= 0 &amp;&amp; x-&gt;digit(i) == y-&gt;digit(i))
 937         i--;
 938 
 939     if (i &lt; 0)
 940         return ComparisonResult::Equal;
 941 
 942     return x-&gt;digit(i) &gt; y-&gt;digit(i) ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
 943 }
 944 
<a name="73" id="anc73"></a><span class="line-modified"> 945 JSBigInt* JSBigInt::absoluteAdd(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y, bool resultSign)</span>
 946 {
<a name="74" id="anc74"></a><span class="line-modified"> 947     VM&amp; vm = globalObject-&gt;vm();</span>
 948 
 949     if (x-&gt;length() &lt; y-&gt;length())
<a name="75" id="anc75"></a><span class="line-modified"> 950         return absoluteAdd(globalObject, y, x, resultSign);</span>
 951 
 952     if (x-&gt;isZero()) {
 953         ASSERT(y-&gt;isZero());
 954         return x;
 955     }
 956 
 957     if (y-&gt;isZero())
 958         return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 959 
<a name="76" id="anc76"></a><span class="line-modified"> 960     JSBigInt* result = JSBigInt::tryCreateWithLength(globalObject, x-&gt;length() + 1);</span>
 961     if (!result)
 962         return nullptr;
 963     Digit carry = 0;
 964     unsigned i = 0;
 965     for (; i &lt; y-&gt;length(); i++) {
 966         Digit newCarry = 0;
 967         Digit sum = digitAdd(x-&gt;digit(i), y-&gt;digit(i), newCarry);
 968         sum = digitAdd(sum, carry, newCarry);
 969         result-&gt;setDigit(i, sum);
 970         carry = newCarry;
 971     }
 972 
 973     for (; i &lt; x-&gt;length(); i++) {
 974         Digit newCarry = 0;
 975         Digit sum = digitAdd(x-&gt;digit(i), carry, newCarry);
 976         result-&gt;setDigit(i, sum);
 977         carry = newCarry;
 978     }
 979 
 980     result-&gt;setDigit(i, carry);
 981     result-&gt;setSign(resultSign);
 982 
 983     return result-&gt;rightTrim(vm);
 984 }
 985 
 986 JSBigInt* JSBigInt::absoluteSub(VM&amp; vm, JSBigInt* x, JSBigInt* y, bool resultSign)
 987 {
 988     ComparisonResult comparisonResult = absoluteCompare(x, y);
 989     ASSERT(x-&gt;length() &gt;= y-&gt;length());
 990     ASSERT(comparisonResult == ComparisonResult::GreaterThan || comparisonResult == ComparisonResult::Equal);
 991 
 992     if (x-&gt;isZero()) {
 993         ASSERT(y-&gt;isZero());
 994         return x;
 995     }
 996 
 997     if (y-&gt;isZero())
 998         return resultSign == x-&gt;sign() ? x : unaryMinus(vm, x);
 999 
1000     if (comparisonResult == ComparisonResult::Equal)
1001         return JSBigInt::createZero(vm);
1002 
1003     JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, x-&gt;length());
1004 
1005     Digit borrow = 0;
1006     unsigned i = 0;
1007     for (; i &lt; y-&gt;length(); i++) {
1008         Digit newBorrow = 0;
1009         Digit difference = digitSub(x-&gt;digit(i), y-&gt;digit(i), newBorrow);
1010         difference = digitSub(difference, borrow, newBorrow);
1011         result-&gt;setDigit(i, difference);
1012         borrow = newBorrow;
1013     }
1014 
1015     for (; i &lt; x-&gt;length(); i++) {
1016         Digit newBorrow = 0;
1017         Digit difference = digitSub(x-&gt;digit(i), borrow, newBorrow);
1018         result-&gt;setDigit(i, difference);
1019         borrow = newBorrow;
1020     }
1021 
1022     ASSERT(!borrow);
1023     result-&gt;setSign(resultSign);
1024     return result-&gt;rightTrim(vm);
1025 }
1026 
1027 // Divides {x} by {divisor}, returning the result in {quotient} and {remainder}.
1028 // Mathematically, the contract is:
1029 // quotient = (x - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
1030 // If {quotient} is an empty handle, an appropriately sized BigInt will be
1031 // allocated for it; otherwise the caller must ensure that it is big enough.
1032 // {quotient} can be the same as {x} for an in-place division. {quotient} can
1033 // also be nullptr if the caller is only interested in the remainder.
1034 void JSBigInt::absoluteDivWithDigitDivisor(VM&amp; vm, JSBigInt* x, Digit divisor, JSBigInt** quotient, Digit&amp; remainder)
1035 {
1036     ASSERT(divisor);
1037 
1038     ASSERT(!x-&gt;isZero());
1039     remainder = 0;
1040     if (divisor == 1) {
1041         if (quotient != nullptr)
1042             *quotient = x;
1043         return;
1044     }
1045 
1046     unsigned length = x-&gt;length();
1047     if (quotient != nullptr) {
1048         if (*quotient == nullptr)
1049             *quotient = JSBigInt::createWithLengthUnchecked(vm, length);
1050 
1051         for (int i = length - 1; i &gt;= 0; i--) {
1052             Digit q = digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1053             (*quotient)-&gt;setDigit(i, q);
1054         }
1055     } else {
1056         for (int i = length - 1; i &gt;= 0; i--)
1057             digitDiv(remainder, x-&gt;digit(i), divisor, remainder);
1058     }
1059 }
1060 
1061 // Divides {dividend} by {divisor}, returning the result in {quotient} and
1062 // {remainder}. Mathematically, the contract is:
1063 // quotient = (dividend - remainder) / divisor, with 0 &lt;= remainder &lt; divisor.
1064 // Both {quotient} and {remainder} are optional, for callers that are only
1065 // interested in one of them.
1066 // See Knuth, Volume 2, section 4.3.1, Algorithm D.
<a name="77" id="anc77"></a><span class="line-modified">1067 void JSBigInt::absoluteDivWithBigIntDivisor(JSGlobalObject* globalObject, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder)</span>
1068 {
1069     ASSERT(divisor-&gt;length() &gt;= 2);
1070     ASSERT(dividend-&gt;length() &gt;= divisor-&gt;length());
<a name="78" id="anc78"></a><span class="line-modified">1071     VM&amp; vm = globalObject-&gt;vm();</span>
1072     auto scope = DECLARE_THROW_SCOPE(vm);
1073 
1074     // The unusual variable names inside this function are consistent with
1075     // Knuth&#39;s book, as well as with Go&#39;s implementation of this algorithm.
1076     // Maintaining this consistency is probably more useful than trying to
1077     // come up with more descriptive names for them.
1078     unsigned n = divisor-&gt;length();
1079     unsigned m = dividend-&gt;length() - n;
1080 
1081     // The quotient to be computed.
1082     JSBigInt* q = nullptr;
1083     if (quotient != nullptr)
<a name="79" id="anc79"></a><span class="line-modified">1084         q = createWithLengthUnchecked(globalObject-&gt;vm(), m + 1);</span>
1085 
1086     // In each iteration, {qhatv} holds {divisor} * {current quotient digit}.
1087     // &quot;v&quot; is the book&#39;s name for {divisor}, &quot;qhat&quot; the current quotient digit.
<a name="80" id="anc80"></a><span class="line-modified">1088     JSBigInt* qhatv = tryCreateWithLength(globalObject, n + 1);</span>
1089     RETURN_IF_EXCEPTION(scope, void());
1090 
1091     // D1.
1092     // Left-shift inputs so that the divisor&#39;s MSB is set. This is necessary
1093     // to prevent the digit-wise divisions (see digit_div call below) from
1094     // overflowing (they take a two digits wide input, and return a one digit
1095     // result).
1096     Digit lastDigit = divisor-&gt;digit(n - 1);
1097     unsigned shift = clz(lastDigit);
1098 
1099     if (shift &gt; 0) {
<a name="81" id="anc81"></a><span class="line-modified">1100         divisor = absoluteLeftShiftAlwaysCopy(globalObject, divisor, shift, LeftShiftMode::SameSizeResult);</span>
1101         RETURN_IF_EXCEPTION(scope, void());
1102     }
1103 
1104     // Holds the (continuously updated) remaining part of the dividend, which
1105     // eventually becomes the remainder.
<a name="82" id="anc82"></a><span class="line-modified">1106     JSBigInt* u = absoluteLeftShiftAlwaysCopy(globalObject, dividend, shift, LeftShiftMode::AlwaysAddOneDigit);</span>
1107     RETURN_IF_EXCEPTION(scope, void());
1108 
1109     // D2.
1110     // Iterate over the dividend&#39;s digit (like the &quot;grad school&quot; algorithm).
1111     // {vn1} is the divisor&#39;s most significant digit.
1112     Digit vn1 = divisor-&gt;digit(n - 1);
1113     for (int j = m; j &gt;= 0; j--) {
1114         // D3.
1115         // Estimate the current iteration&#39;s quotient digit (see Knuth for details).
1116         // {qhat} is the current quotient digit.
1117         Digit qhat = std::numeric_limits&lt;Digit&gt;::max();
1118 
1119         // {ujn} is the dividend&#39;s most significant remaining digit.
1120         Digit ujn = u-&gt;digit(j + n);
1121         if (ujn != vn1) {
1122             // {rhat} is the current iteration&#39;s remainder.
1123             Digit rhat = 0;
1124             // Estimate the current quotient digit by dividing the most significant
1125             // digits of dividend and divisor. The result will not be too small,
1126             // but could be a bit too large.
1127             qhat = digitDiv(ujn, u-&gt;digit(j + n - 1), vn1, rhat);
1128 
1129             // Decrement the quotient estimate as needed by looking at the next
1130             // digit, i.e. by testing whether
1131             // qhat * v_{n-2} &gt; (rhat &lt;&lt; digitBits) + u_{j+n-2}.
1132             Digit vn2 = divisor-&gt;digit(n - 2);
1133             Digit ujn2 = u-&gt;digit(j + n - 2);
1134             while (productGreaterThan(qhat, vn2, rhat, ujn2)) {
1135                 qhat--;
1136                 Digit prevRhat = rhat;
1137                 rhat += vn1;
1138                 // v[n-1] &gt;= 0, so this tests for overflow.
1139                 if (rhat &lt; prevRhat)
1140                     break;
1141             }
1142         }
1143 
1144         // D4.
1145         // Multiply the divisor with the current quotient digit, and subtract
1146         // it from the dividend. If there was &quot;borrow&quot;, then the quotient digit
1147         // was one too high, so we must correct it and undo one subtraction of
1148         // the (shifted) divisor.
1149         internalMultiplyAdd(divisor, qhat, 0, n, qhatv);
1150         Digit c = u-&gt;absoluteInplaceSub(qhatv, j);
1151         if (c) {
1152             c = u-&gt;absoluteInplaceAdd(divisor, j);
1153             u-&gt;setDigit(j + n, u-&gt;digit(j + n) + c);
1154             qhat--;
1155         }
1156 
1157         if (quotient != nullptr)
1158             q-&gt;setDigit(j, qhat);
1159     }
1160 
1161     if (quotient != nullptr) {
1162         // Caller will right-trim.
1163         *quotient = q;
1164     }
1165 
1166     if (remainder != nullptr) {
1167         u-&gt;inplaceRightShift(shift);
1168         *remainder = u;
1169     }
1170 }
1171 
1172 // Returns whether (factor1 * factor2) &gt; (high &lt;&lt; digitBits) + low.
1173 inline bool JSBigInt::productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low)
1174 {
1175     Digit resultHigh;
1176     Digit resultLow = digitMul(factor1, factor2, resultHigh);
1177     return resultHigh &gt; high || (resultHigh == high &amp;&amp; resultLow &gt; low);
1178 }
1179 
1180 // Adds {summand} onto {this}, starting with {summand}&#39;s 0th digit
1181 // at {this}&#39;s {startIndex}&#39;th digit. Returns the &quot;carry&quot; (0 or 1).
1182 JSBigInt::Digit JSBigInt::absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex)
1183 {
1184     Digit carry = 0;
1185     unsigned n = summand-&gt;length();
1186     ASSERT(length() &gt;= startIndex + n);
1187     for (unsigned i = 0; i &lt; n; i++) {
1188         Digit newCarry = 0;
1189         Digit sum = digitAdd(digit(startIndex + i), summand-&gt;digit(i), newCarry);
1190         sum = digitAdd(sum, carry, newCarry);
1191         setDigit(startIndex + i, sum);
1192         carry = newCarry;
1193     }
1194 
1195     return carry;
1196 }
1197 
1198 // Subtracts {subtrahend} from {this}, starting with {subtrahend}&#39;s 0th digit
1199 // at {this}&#39;s {startIndex}-th digit. Returns the &quot;borrow&quot; (0 or 1).
1200 JSBigInt::Digit JSBigInt::absoluteInplaceSub(JSBigInt* subtrahend, unsigned startIndex)
1201 {
1202     Digit borrow = 0;
1203     unsigned n = subtrahend-&gt;length();
1204     ASSERT(length() &gt;= startIndex + n);
1205     for (unsigned i = 0; i &lt; n; i++) {
1206         Digit newBorrow = 0;
1207         Digit difference = digitSub(digit(startIndex + i), subtrahend-&gt;digit(i), newBorrow);
1208         difference = digitSub(difference, borrow, newBorrow);
1209         setDigit(startIndex + i, difference);
1210         borrow = newBorrow;
1211     }
1212 
1213     return borrow;
1214 }
1215 
1216 void JSBigInt::inplaceRightShift(unsigned shift)
1217 {
1218     ASSERT(shift &lt; digitBits);
1219     ASSERT(!(digit(0) &amp; ((static_cast&lt;Digit&gt;(1) &lt;&lt; shift) - 1)));
1220 
1221     if (!shift)
1222         return;
1223 
1224     Digit carry = digit(0) &gt;&gt; shift;
1225     unsigned last = length() - 1;
1226     for (unsigned i = 0; i &lt; last; i++) {
1227         Digit d = digit(i + 1);
1228         setDigit(i, (d &lt;&lt; (digitBits - shift)) | carry);
1229         carry = d &gt;&gt; shift;
1230     }
1231     setDigit(last, carry);
1232 }
1233 
1234 // Always copies the input, even when {shift} == 0.
<a name="83" id="anc83"></a><span class="line-modified">1235 JSBigInt* JSBigInt::absoluteLeftShiftAlwaysCopy(JSGlobalObject* globalObject, JSBigInt* x, unsigned shift, LeftShiftMode mode)</span>
1236 {
1237     ASSERT(shift &lt; digitBits);
1238     ASSERT(!x-&gt;isZero());
1239 
1240     unsigned n = x-&gt;length();
1241     unsigned resultLength = mode == LeftShiftMode::AlwaysAddOneDigit ? n + 1 : n;
<a name="84" id="anc84"></a><span class="line-modified">1242     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1243     if (!result)
1244         return nullptr;
1245 
1246     if (!shift) {
1247         for (unsigned i = 0; i &lt; n; i++)
1248             result-&gt;setDigit(i, x-&gt;digit(i));
1249         if (mode == LeftShiftMode::AlwaysAddOneDigit)
1250             result-&gt;setDigit(n, 0);
1251 
1252         return result;
1253     }
1254 
1255     Digit carry = 0;
1256     for (unsigned i = 0; i &lt; n; i++) {
1257         Digit d = x-&gt;digit(i);
1258         result-&gt;setDigit(i, (d &lt;&lt; shift) | carry);
1259         carry = d &gt;&gt; (digitBits - shift);
1260     }
1261 
1262     if (mode == LeftShiftMode::AlwaysAddOneDigit)
1263         result-&gt;setDigit(n, carry);
1264     else {
1265         ASSERT(mode == LeftShiftMode::SameSizeResult);
1266         ASSERT(!carry);
1267     }
1268 
1269     return result;
1270 }
1271 
1272 // Helper for Absolute{And,AndNot,Or,Xor}.
1273 // Performs the given binary {op} on digit pairs of {x} and {y}; when the
1274 // end of the shorter of the two is reached, {extraDigits} configures how
1275 // remaining digits in the longer input (if {symmetric} == Symmetric, in
1276 // {x} otherwise) are handled: copied to the result or ignored.
1277 // Example:
1278 //       y:             [ y2 ][ y1 ][ y0 ]
1279 //       x:       [ x3 ][ x2 ][ x1 ][ x0 ]
1280 //                   |     |     |     |
1281 //                (Copy)  (op)  (op)  (op)
1282 //                   |     |     |     |
1283 //                   v     v     v     v
1284 // result: [  0 ][ x3 ][ r2 ][ r1 ][ r0 ]
1285 template&lt;typename BitwiseOp&gt;
1286 inline JSBigInt* JSBigInt::absoluteBitwiseOp(VM&amp; vm, JSBigInt* x, JSBigInt* y, ExtraDigitsHandling extraDigits, SymmetricOp symmetric, BitwiseOp&amp;&amp; op)
1287 {
1288     unsigned xLength = x-&gt;length();
1289     unsigned yLength = y-&gt;length();
1290     unsigned numPairs = yLength;
1291     if (xLength &lt; yLength) {
1292         numPairs = xLength;
1293         if (symmetric == SymmetricOp::Symmetric) {
1294             std::swap(x, y);
1295             std::swap(xLength, yLength);
1296         }
1297     }
1298 
1299     ASSERT(numPairs == std::min(xLength, yLength));
1300     unsigned resultLength = extraDigits == ExtraDigitsHandling::Copy ? xLength : numPairs;
1301     JSBigInt* result = createWithLengthUnchecked(vm, resultLength);
1302     unsigned i = 0;
1303     for (; i &lt; numPairs; i++)
1304         result-&gt;setDigit(i, op(x-&gt;digit(i), y-&gt;digit(i)));
1305 
1306     if (extraDigits == ExtraDigitsHandling::Copy) {
1307         for (; i &lt; xLength; i++)
1308             result-&gt;setDigit(i, x-&gt;digit(i));
1309     }
1310 
1311     for (; i &lt; resultLength; i++)
1312         result-&gt;setDigit(i, 0);
1313 
1314     return result-&gt;rightTrim(vm);
1315 }
1316 
1317 JSBigInt* JSBigInt::absoluteAnd(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1318 {
1319     auto digitOperation = [](Digit a, Digit b) {
1320         return a &amp; b;
1321     };
1322     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Skip, SymmetricOp::Symmetric, digitOperation);
1323 }
1324 
1325 JSBigInt* JSBigInt::absoluteOr(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1326 {
1327     auto digitOperation = [](Digit a, Digit b) {
1328         return a | b;
1329     };
1330     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1331 }
1332 
1333 JSBigInt* JSBigInt::absoluteAndNot(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1334 {
1335     auto digitOperation = [](Digit a, Digit b) {
1336         return a &amp; ~b;
1337     };
1338     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::NotSymmetric, digitOperation);
1339 }
1340 
1341 JSBigInt* JSBigInt::absoluteXor(VM&amp; vm, JSBigInt* x, JSBigInt* y)
1342 {
1343     auto digitOperation = [](Digit a, Digit b) {
1344         return a ^ b;
1345     };
1346     return absoluteBitwiseOp(vm, x, y, ExtraDigitsHandling::Copy, SymmetricOp::Symmetric, digitOperation);
1347 }
1348 
<a name="85" id="anc85"></a><span class="line-modified">1349 JSBigInt* JSBigInt::absoluteAddOne(JSGlobalObject* globalObject, JSBigInt* x, SignOption signOption)</span>
1350 {
1351     unsigned inputLength = x-&gt;length();
1352     // The addition will overflow into a new digit if all existing digits are
1353     // at maximum.
1354     bool willOverflow = true;
1355     for (unsigned i = 0; i &lt; inputLength; i++) {
1356         if (std::numeric_limits&lt;Digit&gt;::max() != x-&gt;digit(i)) {
1357             willOverflow = false;
1358             break;
1359         }
1360     }
1361 
1362     unsigned resultLength = inputLength + willOverflow;
<a name="86" id="anc86"></a><span class="line-modified">1363     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1364     if (!result)
1365         return nullptr;
1366 
1367     Digit carry = 1;
1368     for (unsigned i = 0; i &lt; inputLength; i++) {
1369         Digit newCarry = 0;
1370         result-&gt;setDigit(i, digitAdd(x-&gt;digit(i), carry, newCarry));
1371         carry = newCarry;
1372     }
1373     if (resultLength &gt; inputLength)
1374         result-&gt;setDigit(inputLength, carry);
1375     else
1376         ASSERT(!carry);
1377 
1378     result-&gt;setSign(signOption == SignOption::Signed);
<a name="87" id="anc87"></a><span class="line-modified">1379     return result-&gt;rightTrim(globalObject-&gt;vm());</span>
1380 }
1381 
<a name="88" id="anc88"></a><span class="line-modified">1382 JSBigInt* JSBigInt::absoluteSubOne(JSGlobalObject* globalObject, JSBigInt* x, unsigned resultLength)</span>
1383 {
1384     ASSERT(!x-&gt;isZero());
1385     ASSERT(resultLength &gt;= x-&gt;length());
<a name="89" id="anc89"></a><span class="line-modified">1386     VM&amp; vm = globalObject-&gt;vm();</span>
1387     auto scope = DECLARE_THROW_SCOPE(vm);
1388 
<a name="90" id="anc90"></a><span class="line-modified">1389     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1390     RETURN_IF_EXCEPTION(scope, nullptr);
1391 
1392     unsigned length = x-&gt;length();
1393     Digit borrow = 1;
1394     for (unsigned i = 0; i &lt; length; i++) {
1395         Digit newBorrow = 0;
1396         result-&gt;setDigit(i, digitSub(x-&gt;digit(i), borrow, newBorrow));
1397         borrow = newBorrow;
1398     }
1399     ASSERT(!borrow);
1400     for (unsigned i = length; i &lt; resultLength; i++)
1401         result-&gt;setDigit(i, borrow);
1402 
1403     return result-&gt;rightTrim(vm);
1404 }
1405 
<a name="91" id="anc91"></a><span class="line-modified">1406 JSBigInt* JSBigInt::leftShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
1407 {
<a name="92" id="anc92"></a><span class="line-modified">1408     VM&amp; vm = globalObject-&gt;vm();</span>
1409     auto scope = DECLARE_THROW_SCOPE(vm);
1410 
1411     auto optionalShift = toShiftAmount(y);
1412     if (!optionalShift) {
<a name="93" id="anc93"></a><span class="line-modified">1413         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
1414         return nullptr;
1415     }
1416 
1417     Digit shift = *optionalShift;
1418     unsigned digitShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1419     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1420     unsigned length = x-&gt;length();
1421     bool grow = bitsShift &amp;&amp; (x-&gt;digit(length - 1) &gt;&gt; (digitBits - bitsShift));
1422     int resultLength = length + digitShift + grow;
1423     if (static_cast&lt;unsigned&gt;(resultLength) &gt; maxLength) {
<a name="94" id="anc94"></a><span class="line-modified">1424         throwRangeError(globalObject, scope, &quot;BigInt generated from this operation is too big&quot;_s);</span>
1425         return nullptr;
1426     }
1427 
<a name="95" id="anc95"></a><span class="line-modified">1428     JSBigInt* result = tryCreateWithLength(globalObject, resultLength);</span>
1429     RETURN_IF_EXCEPTION(scope, nullptr);
1430     if (!bitsShift) {
1431         unsigned i = 0;
1432         for (; i &lt; digitShift; i++)
1433             result-&gt;setDigit(i, 0ul);
1434 
1435         for (; i &lt; static_cast&lt;unsigned&gt;(resultLength); i++)
1436             result-&gt;setDigit(i, x-&gt;digit(i - digitShift));
1437     } else {
1438         Digit carry = 0;
1439         for (unsigned i = 0; i &lt; digitShift; i++)
1440             result-&gt;setDigit(i, 0ul);
1441 
1442         for (unsigned i = 0; i &lt; length; i++) {
1443             Digit d = x-&gt;digit(i);
1444             result-&gt;setDigit(i + digitShift, (d &lt;&lt; bitsShift) | carry);
1445             carry = d &gt;&gt; (digitBits - bitsShift);
1446         }
1447 
1448         if (grow)
1449             result-&gt;setDigit(length + digitShift, carry);
1450         else
1451             ASSERT(!carry);
1452     }
1453 
1454     result-&gt;setSign(x-&gt;sign());
1455     return result-&gt;rightTrim(vm);
1456 }
1457 
<a name="96" id="anc96"></a><span class="line-modified">1458 JSBigInt* JSBigInt::rightShiftByAbsolute(JSGlobalObject* globalObject, JSBigInt* x, JSBigInt* y)</span>
1459 {
<a name="97" id="anc97"></a><span class="line-modified">1460     VM&amp; vm = globalObject-&gt;vm();</span>
1461     unsigned length = x-&gt;length();
1462     bool sign = x-&gt;sign();
1463     auto optionalShift = toShiftAmount(y);
1464     if (!optionalShift)
1465         return rightShiftByMaximum(vm, sign);
1466 
1467     Digit shift = *optionalShift;
1468     unsigned digitalShift = static_cast&lt;unsigned&gt;(shift / digitBits);
1469     unsigned bitsShift = static_cast&lt;unsigned&gt;(shift % digitBits);
1470     int resultLength = length - digitalShift;
1471     if (resultLength &lt;= 0)
1472         return rightShiftByMaximum(vm, sign);
1473 
1474     // For negative numbers, round down if any bit was shifted out (so that e.g.
1475     // -5n &gt;&gt; 1n == -3n and not -2n). Check now whether this will happen and
1476     // whether it can cause overflow into a new digit. If we allocate the result
1477     // large enough up front, it avoids having to do a second allocation later.
1478     bool mustRoundDown = false;
1479     if (sign) {
1480         const Digit mask = (static_cast&lt;Digit&gt;(1) &lt;&lt; bitsShift) - 1;
1481         if (x-&gt;digit(digitalShift) &amp; mask)
1482             mustRoundDown = true;
1483         else {
1484             for (unsigned i = 0; i &lt; digitalShift; i++) {
1485                 if (x-&gt;digit(i)) {
1486                     mustRoundDown = true;
1487                     break;
1488                 }
1489             }
1490         }
1491     }
1492 
1493     // If bitsShift is non-zero, it frees up bits, preventing overflow.
1494     if (mustRoundDown &amp;&amp; !bitsShift) {
1495         // Overflow cannot happen if the most significant digit has unset bits.
1496         Digit msd = x-&gt;digit(length - 1);
1497         bool roundingCanOverflow = !static_cast&lt;Digit&gt;(~msd);
1498         if (roundingCanOverflow)
1499             resultLength++;
1500     }
1501 
1502     ASSERT(static_cast&lt;unsigned&gt;(resultLength) &lt;= length);
1503     JSBigInt* result = createWithLengthUnchecked(vm, static_cast&lt;unsigned&gt;(resultLength));
1504     if (!bitsShift) {
1505         for (unsigned i = digitalShift; i &lt; length; i++)
1506             result-&gt;setDigit(i - digitalShift, x-&gt;digit(i));
1507     } else {
1508         Digit carry = x-&gt;digit(digitalShift) &gt;&gt; bitsShift;
1509         unsigned last = length - digitalShift - 1;
1510         for (unsigned i = 0; i &lt; last; i++) {
1511             Digit d = x-&gt;digit(i + digitalShift + 1);
1512             result-&gt;setDigit(i, (d &lt;&lt; (digitBits - bitsShift)) | carry);
1513             carry = d &gt;&gt; bitsShift;
1514         }
1515         result-&gt;setDigit(last, carry);
1516     }
1517 
1518     if (sign) {
1519         result-&gt;setSign(true);
1520         if (mustRoundDown) {
1521             // Since the result is negative, rounding down means adding one to
1522             // its absolute value. This cannot overflow.
1523             result = result-&gt;rightTrim(vm);
<a name="98" id="anc98"></a><span class="line-modified">1524             return absoluteAddOne(globalObject, result, SignOption::Signed);</span>
1525         }
1526     }
1527 
1528     return result-&gt;rightTrim(vm);
1529 }
1530 
1531 JSBigInt* JSBigInt::rightShiftByMaximum(VM&amp; vm, bool sign)
1532 {
1533     if (sign)
1534         return createFrom(vm, -1);
1535 
1536     return createZero(vm);
1537 }
1538 
1539 // Lookup table for the maximum number of bits required per character of a
1540 // base-N string representation of a number. To increase accuracy, the array
1541 // value is the actual value multiplied by 32. To generate this table:
1542 // for (var i = 0; i &lt;= 36; i++) { print(Math.ceil(Math.log2(i) * 32) + &quot;,&quot;); }
1543 constexpr uint8_t maxBitsPerCharTable[] = {
1544     0,   0,   32,  51,  64,  75,  83,  90,  96, // 0..8
1545     102, 107, 111, 115, 119, 122, 126, 128,     // 9..16
1546     131, 134, 136, 139, 141, 143, 145, 147,     // 17..24
1547     149, 151, 153, 154, 156, 158, 159, 160,     // 25..32
1548     162, 163, 165, 166,                         // 33..36
1549 };
1550 
1551 static constexpr unsigned bitsPerCharTableShift = 5;
1552 static constexpr size_t bitsPerCharTableMultiplier = 1u &lt;&lt; bitsPerCharTableShift;
1553 
1554 // Compute (an overapproximation of) the length of the resulting string:
1555 // Divide bit length of the BigInt by bits representable per character.
1556 uint64_t JSBigInt::calculateMaximumCharactersRequired(unsigned length, unsigned radix, Digit lastDigit, bool sign)
1557 {
1558     unsigned leadingZeros = clz(lastDigit);
1559 
1560     size_t bitLength = length * digitBits - leadingZeros;
1561 
1562     // Maximum number of bits we can represent with one character. We&#39;ll use this
1563     // to find an appropriate chunk size below.
1564     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1565 
1566     // For estimating result length, we have to be pessimistic and work with
1567     // the minimum number of bits one character can represent.
1568     uint8_t minBitsPerChar = maxBitsPerChar - 1;
1569 
1570     // Perform the following computation with uint64_t to avoid overflows.
1571     uint64_t maximumCharactersRequired = bitLength;
1572     maximumCharactersRequired *= bitsPerCharTableMultiplier;
1573 
1574     // Round up.
1575     maximumCharactersRequired += minBitsPerChar - 1;
1576     maximumCharactersRequired /= minBitsPerChar;
1577     maximumCharactersRequired += sign;
1578 
1579     return maximumCharactersRequired;
1580 }
1581 
<a name="99" id="anc99"></a><span class="line-modified">1582 String JSBigInt::toStringBasePowerOfTwo(VM&amp; vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)</span>
1583 {
1584     ASSERT(hasOneBitSet(radix));
1585     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 32);
1586     ASSERT(!x-&gt;isZero());
1587 
1588     const unsigned length = x-&gt;length();
1589     const bool sign = x-&gt;sign();
1590     const unsigned bitsPerChar = ctz(radix);
1591     const unsigned charMask = radix - 1;
1592     // Compute the length of the resulting string: divide the bit length of the
1593     // BigInt by the number of bits representable per character (rounding up).
1594     const Digit msd = x-&gt;digit(length - 1);
1595 
1596     const unsigned msdLeadingZeros = clz(msd);
1597 
1598     const size_t bitLength = length * digitBits - msdLeadingZeros;
1599     const size_t charsRequired = (bitLength + bitsPerChar - 1) / bitsPerChar + sign;
1600 
1601     if (charsRequired &gt; JSString::MaxLength) {
<a name="100" id="anc100"></a><span class="line-modified">1602         if (globalObject) {</span>
1603             auto scope = DECLARE_THROW_SCOPE(vm);
<a name="101" id="anc101"></a><span class="line-modified">1604             throwOutOfMemoryError(globalObject, scope);</span>
1605         }
1606         return String();
1607     }
1608 
1609     Vector&lt;LChar&gt; resultString(charsRequired);
1610     Digit digit = 0;
1611     // Keeps track of how many unprocessed bits there are in {digit}.
1612     unsigned availableBits = 0;
1613     int pos = static_cast&lt;int&gt;(charsRequired - 1);
1614     for (unsigned i = 0; i &lt; length - 1; i++) {
1615         Digit newDigit = x-&gt;digit(i);
1616         // Take any leftover bits from the last iteration into account.
1617         int current = (digit | (newDigit &lt;&lt; availableBits)) &amp; charMask;
1618         resultString[pos--] = radixDigits[current];
1619         int consumedBits = bitsPerChar - availableBits;
1620         digit = newDigit &gt;&gt; consumedBits;
1621         availableBits = digitBits - consumedBits;
1622         while (availableBits &gt;= bitsPerChar) {
1623             resultString[pos--] = radixDigits[digit &amp; charMask];
1624             digit &gt;&gt;= bitsPerChar;
1625             availableBits -= bitsPerChar;
1626         }
1627     }
1628     // Take any leftover bits from the last iteration into account.
1629     int current = (digit | (msd &lt;&lt; availableBits)) &amp; charMask;
1630     resultString[pos--] = radixDigits[current];
1631     digit = msd &gt;&gt; (bitsPerChar - availableBits);
1632     while (digit) {
1633         resultString[pos--] = radixDigits[digit &amp; charMask];
1634         digit &gt;&gt;= bitsPerChar;
1635     }
1636 
1637     if (sign)
1638         resultString[pos--] = &#39;-&#39;;
1639 
1640     ASSERT(pos == -1);
1641     return StringImpl::adopt(WTFMove(resultString));
1642 }
1643 
<a name="102" id="anc102"></a><span class="line-modified">1644 String JSBigInt::toStringGeneric(VM&amp; vm, JSGlobalObject* globalObject, JSBigInt* x, unsigned radix)</span>
1645 {
1646     // FIXME: [JSC] Revisit usage of Vector into JSBigInt::toString
1647     // https://bugs.webkit.org/show_bug.cgi?id=18067
1648     Vector&lt;LChar&gt; resultString;
1649 
1650     ASSERT(radix &gt;= 2 &amp;&amp; radix &lt;= 36);
1651     ASSERT(!x-&gt;isZero());
1652 
1653     unsigned length = x-&gt;length();
1654     bool sign = x-&gt;sign();
1655 
1656     uint8_t maxBitsPerChar = maxBitsPerCharTable[radix];
1657     uint64_t maximumCharactersRequired = calculateMaximumCharactersRequired(length, radix, x-&gt;digit(length - 1), sign);
1658 
1659     if (maximumCharactersRequired &gt; JSString::MaxLength) {
<a name="103" id="anc103"></a><span class="line-modified">1660         if (globalObject) {</span>
1661             auto scope = DECLARE_THROW_SCOPE(vm);
<a name="104" id="anc104"></a><span class="line-modified">1662             throwOutOfMemoryError(globalObject, scope);</span>
1663         }
1664         return String();
1665     }
1666 
1667     Digit lastDigit;
1668     if (length == 1)
1669         lastDigit = x-&gt;digit(0);
1670     else {
1671         unsigned chunkChars = digitBits * bitsPerCharTableMultiplier / maxBitsPerChar;
1672         Digit chunkDivisor = digitPow(radix, chunkChars);
1673 
1674         // By construction of chunkChars, there can&#39;t have been overflow.
1675         ASSERT(chunkDivisor);
1676         unsigned nonZeroDigit = length - 1;
1677         ASSERT(x-&gt;digit(nonZeroDigit));
1678 
1679         // {rest} holds the part of the BigInt that we haven&#39;t looked at yet.
1680         // Not to be confused with &quot;remainder&quot;!
1681         JSBigInt* rest = nullptr;
1682 
1683         // In the first round, divide the input, allocating a new BigInt for
1684         // the result == rest; from then on divide the rest in-place.
1685         JSBigInt** dividend = &amp;x;
1686         do {
1687             Digit chunk;
1688             absoluteDivWithDigitDivisor(vm, *dividend, chunkDivisor, &amp;rest, chunk);
1689             dividend = &amp;rest;
1690             for (unsigned i = 0; i &lt; chunkChars; i++) {
1691                 resultString.append(radixDigits[chunk % radix]);
1692                 chunk /= radix;
1693             }
1694             ASSERT(!chunk);
1695 
1696             if (!rest-&gt;digit(nonZeroDigit))
1697                 nonZeroDigit--;
1698 
1699             // We can never clear more than one digit per iteration, because
1700             // chunkDivisor is smaller than max digit value.
1701             ASSERT(rest-&gt;digit(nonZeroDigit));
1702         } while (nonZeroDigit &gt; 0);
1703 
1704         lastDigit = rest-&gt;digit(0);
1705     }
1706 
1707     do {
1708         resultString.append(radixDigits[lastDigit % radix]);
1709         lastDigit /= radix;
1710     } while (lastDigit &gt; 0);
1711     ASSERT(resultString.size());
1712     ASSERT(resultString.size() &lt;= static_cast&lt;size_t&gt;(maximumCharactersRequired));
1713 
1714     // Remove leading zeroes.
1715     unsigned newSizeNoLeadingZeroes = resultString.size();
1716     while (newSizeNoLeadingZeroes  &gt; 1 &amp;&amp; resultString[newSizeNoLeadingZeroes - 1] == &#39;0&#39;)
1717         newSizeNoLeadingZeroes--;
1718 
1719     resultString.shrink(newSizeNoLeadingZeroes);
1720 
1721     if (sign)
1722         resultString.append(&#39;-&#39;);
1723 
1724     std::reverse(resultString.begin(), resultString.end());
1725 
1726     return StringImpl::adopt(WTFMove(resultString));
1727 }
1728 
1729 JSBigInt* JSBigInt::rightTrim(VM&amp; vm)
1730 {
1731     if (isZero()) {
1732         ASSERT(!sign());
1733         return this;
1734     }
1735 
1736     int nonZeroIndex = m_length - 1;
1737     while (nonZeroIndex &gt;= 0 &amp;&amp; !digit(nonZeroIndex))
1738         nonZeroIndex--;
1739 
1740     if (nonZeroIndex &lt; 0)
1741         return createZero(vm);
1742 
1743     if (nonZeroIndex == static_cast&lt;int&gt;(m_length - 1))
1744         return this;
1745 
1746     unsigned newLength = nonZeroIndex + 1;
1747     JSBigInt* trimmedBigInt = createWithLengthUnchecked(vm, newLength);
1748     std::copy(dataStorage(), dataStorage() + newLength, trimmedBigInt-&gt;dataStorage());
1749 
1750     trimmedBigInt-&gt;setSign(this-&gt;sign());
1751 
1752     return trimmedBigInt;
1753 }
1754 
<a name="105" id="anc105"></a><span class="line-modified">1755 JSBigInt* JSBigInt::allocateFor(JSGlobalObject* globalObject, VM&amp; vm, unsigned radix, unsigned charcount)</span>
1756 {
1757     ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
1758 
1759     size_t bitsPerChar = maxBitsPerCharTable[radix];
1760     size_t chars = charcount;
1761     const unsigned roundup = bitsPerCharTableMultiplier - 1;
1762     if (chars &lt;= (std::numeric_limits&lt;size_t&gt;::max() - roundup) / bitsPerChar) {
1763         size_t bitsMin = bitsPerChar * chars;
1764 
1765         // Divide by 32 (see table), rounding up.
1766         bitsMin = (bitsMin + roundup) &gt;&gt; bitsPerCharTableShift;
1767         if (bitsMin &lt;= static_cast&lt;size_t&gt;(maxInt)) {
1768             // Divide by kDigitsBits, rounding up.
1769             unsigned length = (bitsMin + digitBits - 1) / digitBits;
1770             if (length &lt;= maxLength) {
1771                 JSBigInt* result = JSBigInt::createWithLengthUnchecked(vm, length);
1772                 return result;
1773             }
1774         }
1775     }
1776 
<a name="106" id="anc106"></a><span class="line-modified">1777     if (globalObject) {</span>
1778         auto scope = DECLARE_THROW_SCOPE(vm);
<a name="107" id="anc107"></a><span class="line-modified">1779         throwOutOfMemoryError(globalObject, scope);</span>
1780     }
1781     return nullptr;
1782 }
1783 
1784 size_t JSBigInt::estimatedSize(JSCell* cell, VM&amp; vm)
1785 {
1786     return Base::estimatedSize(cell, vm) + jsCast&lt;JSBigInt*&gt;(cell)-&gt;m_length * sizeof(Digit);
1787 }
1788 
<a name="108" id="anc108"></a><span class="line-modified">1789 double JSBigInt::toNumber(JSGlobalObject* globalObject) const</span>
1790 {
<a name="109" id="anc109"></a><span class="line-modified">1791     VM&amp; vm = globalObject-&gt;vm();</span>
1792     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="110" id="anc110"></a><span class="line-modified">1793     throwTypeError(globalObject, scope, &quot;Conversion from &#39;BigInt&#39; to &#39;number&#39; is not allowed.&quot;_s);</span>
1794     return 0.0;
1795 }
1796 
<a name="111" id="anc111"></a><span class="line-modified">1797 bool JSBigInt::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
1798 {
1799     result = this;
<a name="112" id="anc112"></a><span class="line-modified">1800     number = toNumber(globalObject);</span>
1801     return true;
1802 }
1803 
1804 template &lt;typename CharType&gt;
<a name="113" id="anc113"></a><span class="line-modified">1805 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, CharType*  data, unsigned length, ErrorParseMode errorParseMode)</span>
1806 {
<a name="114" id="anc114"></a><span class="line-modified">1807     VM&amp; vm = globalObject-&gt;vm();</span>
1808 
1809     unsigned p = 0;
1810     while (p &lt; length &amp;&amp; isStrWhiteSpace(data[p]))
1811         ++p;
1812 
1813     // Check Radix from frist characters
1814     if (static_cast&lt;unsigned&gt;(p) + 1 &lt; static_cast&lt;unsigned&gt;(length) &amp;&amp; data[p] == &#39;0&#39;) {
1815         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;b&#39;))
<a name="115" id="anc115"></a><span class="line-modified">1816             return parseInt(globalObject, vm, data, length, p + 2, 2, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1817 
1818         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;x&#39;))
<a name="116" id="anc116"></a><span class="line-modified">1819             return parseInt(globalObject, vm, data, length, p + 2, 16, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1820 
1821         if (isASCIIAlphaCaselessEqual(data[p + 1], &#39;o&#39;))
<a name="117" id="anc117"></a><span class="line-modified">1822             return parseInt(globalObject, vm, data, length, p + 2, 8, errorParseMode, ParseIntSign::Unsigned, ParseIntMode::DisallowEmptyString);</span>
1823     }
1824 
1825     ParseIntSign sign = ParseIntSign::Unsigned;
1826     if (p &lt; length) {
1827         if (data[p] == &#39;+&#39;)
1828             ++p;
1829         else if (data[p] == &#39;-&#39;) {
1830             sign = ParseIntSign::Signed;
1831             ++p;
1832         }
1833     }
1834 
<a name="118" id="anc118"></a><span class="line-modified">1835     JSBigInt* result = parseInt(globalObject, vm, data, length, p, 10, errorParseMode, sign);</span>
1836 
1837     if (result &amp;&amp; !result-&gt;isZero())
1838         result-&gt;setSign(sign == ParseIntSign::Signed);
1839 
1840     return result;
1841 }
1842 
1843 template &lt;typename CharType&gt;
<a name="119" id="anc119"></a><span class="line-modified">1844 JSBigInt* JSBigInt::parseInt(JSGlobalObject* globalObject, VM&amp; vm, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode errorParseMode, ParseIntSign sign, ParseIntMode parseMode)</span>
1845 {
1846     ASSERT(length &gt;= 0);
1847     unsigned p = startIndex;
1848 
1849     auto scope = DECLARE_THROW_SCOPE(vm);
1850 
1851     if (parseMode != ParseIntMode::AllowEmptyString &amp;&amp; startIndex == length) {
<a name="120" id="anc120"></a><span class="line-modified">1852         ASSERT(globalObject);</span>
1853         if (errorParseMode == ErrorParseMode::ThrowExceptions)
<a name="121" id="anc121"></a><span class="line-modified">1854             throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Failed to parse String to BigInt&quot;));</span>
1855         return nullptr;
1856     }
1857 
1858     // Skipping leading zeros
1859     while (p &lt; length &amp;&amp; data[p] == &#39;0&#39;)
1860         ++p;
1861 
1862     int endIndex = length - 1;
1863     // Removing trailing spaces
1864     while (endIndex &gt;= static_cast&lt;int&gt;(p) &amp;&amp; isStrWhiteSpace(data[endIndex]))
1865         --endIndex;
1866 
1867     length = endIndex + 1;
1868 
1869     if (p == length)
1870         return createZero(vm);
1871 
1872     unsigned limit0 = &#39;0&#39; + (radix &lt; 10 ? radix : 10);
1873     unsigned limita = &#39;a&#39; + (radix - 10);
1874     unsigned limitA = &#39;A&#39; + (radix - 10);
1875 
<a name="122" id="anc122"></a><span class="line-modified">1876     JSBigInt* result = allocateFor(globalObject, vm, radix, length - p);</span>
1877     RETURN_IF_EXCEPTION(scope, nullptr);
<a name="123" id="anc123"></a><span class="line-added">1878     // result can still be null if we don&#39;t have access to global object, as allocateFor cannot throw an exception in that case.</span>
<span class="line-added">1879     if (!result)</span>
<span class="line-added">1880         return nullptr;</span>
1881 
1882     result-&gt;initialize(InitializationType::WithZero);
1883 
1884     for (unsigned i = p; i &lt; length; i++, p++) {
1885         uint32_t digit;
1886         if (data[i] &gt;= &#39;0&#39; &amp;&amp; data[i] &lt; limit0)
1887             digit = data[i] - &#39;0&#39;;
1888         else if (data[i] &gt;= &#39;a&#39; &amp;&amp; data[i] &lt; limita)
1889             digit = data[i] - &#39;a&#39; + 10;
1890         else if (data[i] &gt;= &#39;A&#39; &amp;&amp; data[i] &lt; limitA)
1891             digit = data[i] - &#39;A&#39; + 10;
1892         else
1893             break;
1894 
1895         result-&gt;inplaceMultiplyAdd(static_cast&lt;Digit&gt;(radix), static_cast&lt;Digit&gt;(digit));
1896     }
1897 
1898     result-&gt;setSign(sign == ParseIntSign::Signed ? true : false);
1899     if (p == length)
1900         return result-&gt;rightTrim(vm);
1901 
<a name="124" id="anc124"></a><span class="line-modified">1902     ASSERT(globalObject);</span>
1903     if (errorParseMode == ErrorParseMode::ThrowExceptions)
<a name="125" id="anc125"></a><span class="line-modified">1904         throwVMError(globalObject, scope, createSyntaxError(globalObject, &quot;Failed to parse String to BigInt&quot;));</span>
1905 
1906     return nullptr;
1907 }
1908 
1909 inline JSBigInt::Digit JSBigInt::digit(unsigned n)
1910 {
1911     ASSERT(n &lt; length());
1912     return dataStorage()[n];
1913 }
1914 
1915 inline void JSBigInt::setDigit(unsigned n, Digit value)
1916 {
1917     ASSERT(n &lt; length());
1918     dataStorage()[n] = value;
1919 }
1920 
<a name="126" id="anc126"></a><span class="line-modified">1921 JSObject* JSBigInt::toObject(JSGlobalObject* globalObject) const</span>
1922 {
<a name="127" id="anc127"></a><span class="line-modified">1923     return BigIntObject::create(globalObject-&gt;vm(), globalObject, const_cast&lt;JSBigInt*&gt;(this));</span>
1924 }
1925 
1926 bool JSBigInt::equalsToNumber(JSValue numValue)
1927 {
1928     ASSERT(numValue.isNumber());
1929 
1930     if (numValue.isInt32()) {
1931         int value = numValue.asInt32();
1932         if (!value)
1933             return this-&gt;isZero();
1934 
1935         return (this-&gt;length() == 1) &amp;&amp; (this-&gt;sign() == (value &lt; 0)) &amp;&amp; (this-&gt;digit(0) == static_cast&lt;Digit&gt;(std::abs(static_cast&lt;int64_t&gt;(value))));
1936     }
1937 
1938     double value = numValue.asDouble();
1939     return compareToDouble(this, value) == ComparisonResult::Equal;
1940 }
1941 
1942 JSBigInt::ComparisonResult JSBigInt::compareToDouble(JSBigInt* x, double y)
1943 {
1944     // This algorithm expect that the double format is IEEE 754
1945 
1946     uint64_t doubleBits = bitwise_cast&lt;uint64_t&gt;(y);
1947     int rawExponent = static_cast&lt;int&gt;(doubleBits &gt;&gt; 52) &amp; 0x7FF;
1948 
1949     if (rawExponent == 0x7FF) {
1950         if (std::isnan(y))
1951             return ComparisonResult::Undefined;
1952 
1953         return (y == std::numeric_limits&lt;double&gt;::infinity()) ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1954     }
1955 
1956     bool xSign = x-&gt;sign();
1957 
1958     // Note that this is different from the double&#39;s sign bit for -0. That&#39;s
1959     // intentional because -0 must be treated like 0.
1960     bool ySign = y &lt; 0;
1961     if (xSign != ySign)
1962         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1963 
1964     if (!y) {
1965         ASSERT(!xSign);
1966         return x-&gt;isZero() ? ComparisonResult::Equal : ComparisonResult::GreaterThan;
1967     }
1968 
1969     if (x-&gt;isZero())
1970         return ComparisonResult::LessThan;
1971 
1972     uint64_t mantissa = doubleBits &amp; 0x000FFFFFFFFFFFFF;
1973 
1974     // Non-finite doubles are handled above.
1975     ASSERT(rawExponent != 0x7FF);
1976     int exponent = rawExponent - 0x3FF;
1977     if (exponent &lt; 0) {
1978         // The absolute value of the double is less than 1. Only 0n has an
1979         // absolute value smaller than that, but we&#39;ve already covered that case.
1980         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1981     }
1982 
1983     int xLength = x-&gt;length();
1984     Digit xMSD = x-&gt;digit(xLength - 1);
1985     int msdLeadingZeros = clz(xMSD);
1986 
1987     int xBitLength = xLength * digitBits - msdLeadingZeros;
1988     int yBitLength = exponent + 1;
1989     if (xBitLength &lt; yBitLength)
1990         return xSign? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
1991 
1992     if (xBitLength &gt; yBitLength)
1993         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
1994 
1995     // At this point, we know that signs and bit lengths (i.e. position of
1996     // the most significant bit in exponent-free representation) are identical.
1997     // {x} is not zero, {y} is finite and not denormal.
1998     // Now we virtually convert the double to an integer by shifting its
1999     // mantissa according to its exponent, so it will align with the BigInt {x},
2000     // and then we compare them bit for bit until we find a difference or the
2001     // least significant bit.
2002     //                    &lt;----- 52 ------&gt; &lt;-- virtual trailing zeroes --&gt;
2003     // y / mantissa:     1yyyyyyyyyyyyyyyyy 0000000000000000000000000000000
2004     // x / digits:    0001xxxx xxxxxxxx xxxxxxxx ...
2005     //                    &lt;--&gt;          &lt;------&gt;
2006     //              msdTopBit         digitBits
2007     //
2008     mantissa |= 0x0010000000000000;
2009     const int mantissaTopBit = 52; // 0-indexed.
2010 
2011     // 0-indexed position of {x}&#39;s most significant bit within the {msd}.
2012     int msdTopBit = digitBits - 1 - msdLeadingZeros;
2013     ASSERT(msdTopBit == static_cast&lt;int&gt;((xBitLength - 1) % digitBits));
2014 
2015     // Shifted chunk of {mantissa} for comparing with {digit}.
2016     Digit compareMantissa;
2017 
2018     // Number of unprocessed bits in {mantissa}. We&#39;ll keep them shifted to
2019     // the left (i.e. most significant part) of the underlying uint64_t.
2020     int remainingMantissaBits = 0;
2021 
2022     // First, compare the most significant digit against the beginning of
2023     // the mantissa and then we align them.
2024     if (msdTopBit &lt; mantissaTopBit) {
2025         remainingMantissaBits = (mantissaTopBit - msdTopBit);
2026         compareMantissa = static_cast&lt;Digit&gt;(mantissa &gt;&gt; remainingMantissaBits);
2027         mantissa = mantissa &lt;&lt; (64 - remainingMantissaBits);
2028     } else {
2029         compareMantissa = static_cast&lt;Digit&gt;(mantissa &lt;&lt; (msdTopBit - mantissaTopBit));
2030         mantissa = 0;
2031     }
2032 
2033     if (xMSD &gt; compareMantissa)
2034         return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
2035 
2036     if (xMSD &lt; compareMantissa)
2037         return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
2038 
2039     // Then, compare additional digits against any remaining mantissa bits.
2040     for (int digitIndex = xLength - 2; digitIndex &gt;= 0; digitIndex--) {
2041         if (remainingMantissaBits &gt; 0) {
2042             remainingMantissaBits -= digitBits;
2043             if (sizeof(mantissa) != sizeof(xMSD)) {
2044                 compareMantissa = static_cast&lt;Digit&gt;(mantissa &gt;&gt; (64 - digitBits));
2045                 // &quot;&amp; 63&quot; to appease compilers. digitBits is 32 here anyway.
2046                 mantissa = mantissa &lt;&lt; (digitBits &amp; 63);
2047             } else {
2048                 compareMantissa = static_cast&lt;Digit&gt;(mantissa);
2049                 mantissa = 0;
2050             }
2051         } else
2052             compareMantissa = 0;
2053 
2054         Digit digit = x-&gt;digit(digitIndex);
2055         if (digit &gt; compareMantissa)
2056             return xSign ? ComparisonResult::LessThan : ComparisonResult::GreaterThan;
2057         if (digit &lt; compareMantissa)
2058             return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
2059     }
2060 
2061     // Integer parts are equal; check whether {y} has a fractional part.
2062     if (mantissa) {
2063         ASSERT(remainingMantissaBits &gt; 0);
2064         return xSign ? ComparisonResult::GreaterThan : ComparisonResult::LessThan;
2065     }
2066 
2067     return ComparisonResult::Equal;
2068 }
2069 
2070 Optional&lt;JSBigInt::Digit&gt; JSBigInt::toShiftAmount(JSBigInt* x)
2071 {
2072     if (x-&gt;length() &gt; 1)
2073         return WTF::nullopt;
2074 
2075     Digit value = x-&gt;digit(0);
2076     static_assert(maxLengthBits &lt; std::numeric_limits&lt;Digit&gt;::max(), &quot;maxLengthBits needs to be less than digit&quot;);
2077 
2078     if (value &gt; maxLengthBits)
2079         return WTF::nullopt;
2080 
2081     return value;
2082 }
2083 
2084 } // namespace JSC
<a name="128" id="anc128"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="128" type="hidden" />
</body>
</html>
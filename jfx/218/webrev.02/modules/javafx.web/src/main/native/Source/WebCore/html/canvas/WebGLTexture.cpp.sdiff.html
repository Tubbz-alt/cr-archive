<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLSync.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLTexture.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;WebGLTexture.h&quot;
 31 
 32 #include &quot;WebGLContextGroup.h&quot;
 33 #include &quot;WebGLFramebuffer.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 Ref&lt;WebGLTexture&gt; WebGLTexture::create(WebGLRenderingContextBase&amp; ctx)
 39 {
 40     return adoptRef(*new WebGLTexture(ctx));
 41 }
 42 
 43 WebGLTexture::WebGLTexture(WebGLRenderingContextBase&amp; ctx)
 44     : WebGLSharedObject(ctx)
 45     , m_target(0)
<span class="line-modified"> 46     , m_minFilter(GraphicsContext3D::NEAREST_MIPMAP_LINEAR)</span>
<span class="line-modified"> 47     , m_magFilter(GraphicsContext3D::LINEAR)</span>
<span class="line-modified"> 48     , m_wrapS(GraphicsContext3D::REPEAT)</span>
<span class="line-modified"> 49     , m_wrapT(GraphicsContext3D::REPEAT)</span>
 50     , m_isNPOT(false)
 51     , m_isComplete(false)
 52     , m_needToUseBlackTexture(false)
 53     , m_isCompressed(false)
 54     , m_isFloatType(false)
 55     , m_isHalfFloatType(false)
 56     , m_isForWebGL1(ctx.isWebGL1())
 57 {
<span class="line-modified"> 58     setObject(ctx.graphicsContext3D()-&gt;createTexture());</span>
 59 }
 60 
 61 WebGLTexture::~WebGLTexture()
 62 {
 63     deleteObject(0);
 64 }
 65 
<span class="line-modified"> 66 void WebGLTexture::setTarget(GC3Denum target, GC3Dint maxLevel)</span>
 67 {
 68     if (!object())
 69         return;
 70     // Target is finalized the first time bindTexture() is called.
 71     if (m_target)
 72         return;
 73     switch (target) {
<span class="line-modified"> 74     case GraphicsContext3D::TEXTURE_2D:</span>
 75         m_target = target;
 76         m_info.resize(1);
 77         m_info[0].resize(maxLevel);
 78         break;
<span class="line-modified"> 79     case GraphicsContext3D::TEXTURE_CUBE_MAP:</span>
 80         m_target = target;
 81         m_info.resize(6);
 82         for (int ii = 0; ii &lt; 6; ++ii)
 83             m_info[ii].resize(maxLevel);
 84         break;
 85     }
 86 }
 87 
<span class="line-modified"> 88 void WebGLTexture::setParameteri(GC3Denum pname, GC3Dint param)</span>
 89 {
 90     if (!object() || !m_target)
 91         return;
 92     switch (pname) {
<span class="line-modified"> 93     case GraphicsContext3D::TEXTURE_MIN_FILTER:</span>
 94         switch (param) {
<span class="line-modified"> 95         case GraphicsContext3D::NEAREST:</span>
<span class="line-modified"> 96         case GraphicsContext3D::LINEAR:</span>
<span class="line-modified"> 97         case GraphicsContext3D::NEAREST_MIPMAP_NEAREST:</span>
<span class="line-modified"> 98         case GraphicsContext3D::LINEAR_MIPMAP_NEAREST:</span>
<span class="line-modified"> 99         case GraphicsContext3D::NEAREST_MIPMAP_LINEAR:</span>
<span class="line-modified">100         case GraphicsContext3D::LINEAR_MIPMAP_LINEAR:</span>
101             m_minFilter = param;
102             break;
103         }
104         break;
<span class="line-modified">105     case GraphicsContext3D::TEXTURE_MAG_FILTER:</span>
106         switch (param) {
<span class="line-modified">107         case GraphicsContext3D::NEAREST:</span>
<span class="line-modified">108         case GraphicsContext3D::LINEAR:</span>
109             m_magFilter = param;
110             break;
111         }
112         break;
<span class="line-modified">113     case GraphicsContext3D::TEXTURE_WRAP_S:</span>
114         switch (param) {
<span class="line-modified">115         case GraphicsContext3D::CLAMP_TO_EDGE:</span>
<span class="line-modified">116         case GraphicsContext3D::MIRRORED_REPEAT:</span>
<span class="line-modified">117         case GraphicsContext3D::REPEAT:</span>
118             m_wrapS = param;
119             break;
120         }
121         break;
<span class="line-modified">122     case GraphicsContext3D::TEXTURE_WRAP_T:</span>
123         switch (param) {
<span class="line-modified">124         case GraphicsContext3D::CLAMP_TO_EDGE:</span>
<span class="line-modified">125         case GraphicsContext3D::MIRRORED_REPEAT:</span>
<span class="line-modified">126         case GraphicsContext3D::REPEAT:</span>
127             m_wrapT = param;
128             break;
129         }
130         break;
131     default:
132         return;
133     }
134     update();
135 }
136 
<span class="line-modified">137 void WebGLTexture::setParameterf(GC3Denum pname, GC3Dfloat param)</span>
138 {
139     if (!object() || !m_target)
140         return;
<span class="line-modified">141     GC3Dint iparam = static_cast&lt;GC3Dint&gt;(param);</span>
142     setParameteri(pname, iparam);
143 }
144 
<span class="line-modified">145 void WebGLTexture::setLevelInfo(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Denum type)</span>
146 {
147     if (!object() || !m_target)
148         return;
149     // We assume level, internalFormat, width, height, and type have all been
150     // validated already.
151     int index = mapTargetToIndex(target);
152     if (index &lt; 0)
153         return;
154     m_info[index][level].setInfo(internalFormat, width, height, type);
155     update();
156 }
157 
158 void WebGLTexture::generateMipmapLevelInfo()
159 {
160     if (!object() || !m_target)
161         return;
162     if (!canGenerateMipmaps())
163         return;
164     if (!m_isComplete) {
165         for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
166             const LevelInfo&amp; info0 = m_info[ii][0];
<span class="line-modified">167             GC3Dsizei width = info0.width;</span>
<span class="line-modified">168             GC3Dsizei height = info0.height;</span>
<span class="line-modified">169             GC3Dint levelCount = computeLevelCount(width, height);</span>
<span class="line-modified">170             for (GC3Dint level = 1; level &lt; levelCount; ++level) {</span>
171                 width = std::max(1, width &gt;&gt; 1);
172                 height = std::max(1, height &gt;&gt; 1);
173                 LevelInfo&amp; info = m_info[ii][level];
174                 info.setInfo(info0.internalFormat, width, height, info0.type);
175             }
176         }
177         m_isComplete = true;
178     }
179     m_needToUseBlackTexture = false;
180 }
181 
<span class="line-modified">182 GC3Denum WebGLTexture::getInternalFormat(GC3Denum target, GC3Dint level) const</span>
183 {
184     const LevelInfo* info = getLevelInfo(target, level);
185     if (!info)
186         return 0;
187     return info-&gt;internalFormat;
188 }
189 
<span class="line-modified">190 GC3Denum WebGLTexture::getType(GC3Denum target, GC3Dint level) const</span>
191 {
192     ASSERT(m_isForWebGL1);
193     const LevelInfo* info = getLevelInfo(target, level);
194     if (!info)
195         return 0;
196     return info-&gt;type;
197 }
198 
<span class="line-modified">199 GC3Dsizei WebGLTexture::getWidth(GC3Denum target, GC3Dint level) const</span>
200 {
201     const LevelInfo* info = getLevelInfo(target, level);
202     if (!info)
203         return 0;
204     return info-&gt;width;
205 }
206 
<span class="line-modified">207 GC3Dsizei WebGLTexture::getHeight(GC3Denum target, GC3Dint level) const</span>
208 {
209     const LevelInfo* info = getLevelInfo(target, level);
210     if (!info)
211         return 0;
212     return info-&gt;height;
213 }
214 
<span class="line-modified">215 bool WebGLTexture::isValid(GC3Denum target, GC3Dint level) const</span>
216 {
217     const LevelInfo* info = getLevelInfo(target, level);
218     if (!info)
219         return 0;
220     return info-&gt;valid;
221 }
222 
<span class="line-modified">223 void WebGLTexture::markInvalid(GC3Denum target, GC3Dint level)</span>
224 {
225     int index = mapTargetToIndex(target);
226     if (index &lt; 0)
227         return;
228     m_info[index][level].valid = false;
229     update();
230 }
231 
<span class="line-modified">232 bool WebGLTexture::isNPOT(GC3Dsizei width, GC3Dsizei height)</span>
233 {
234     ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
235     if (!width || !height)
236         return false;
237     if ((width &amp; (width - 1)) || (height &amp; (height - 1)))
238         return true;
239     return false;
240 }
241 
242 bool WebGLTexture::isNPOT() const
243 {
244     if (!object())
245         return false;
246     return m_isNPOT;
247 }
248 
249 bool WebGLTexture::needToUseBlackTexture(TextureExtensionFlag extensions) const
250 {
251     if (!object())
252         return false;
253     if (m_needToUseBlackTexture)
254         return true;
<span class="line-modified">255     if (m_magFilter == GraphicsContext3D::NEAREST &amp;&amp; (m_minFilter == GraphicsContext3D::NEAREST || m_minFilter == GraphicsContext3D::NEAREST_MIPMAP_NEAREST))</span>
256         return false;
257     if (m_isForWebGL1 &amp;&amp; m_isHalfFloatType &amp;&amp; !(extensions &amp; TextureExtensionHalfFloatLinearEnabled))
258         return true;
259     if (m_isFloatType &amp;&amp; !(extensions &amp; TextureExtensionFloatLinearEnabled))
260         return true;
261     return false;
262 }
263 
264 bool WebGLTexture::isCompressed() const
265 {
266     if (!object())
267         return false;
268     return m_isCompressed;
269 }
270 
271 void WebGLTexture::setCompressed()
272 {
273     ASSERT(object());
274     m_isCompressed = true;
275 }
276 
<span class="line-modified">277 void WebGLTexture::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)</span>
278 {
279     context3d-&gt;deleteTexture(object);
280 }
281 
<span class="line-modified">282 int WebGLTexture::mapTargetToIndex(GC3Denum target) const</span>
283 {
<span class="line-modified">284     if (m_target == GraphicsContext3D::TEXTURE_2D) {</span>
<span class="line-modified">285         if (target == GraphicsContext3D::TEXTURE_2D)</span>
286             return 0;
<span class="line-modified">287     } else if (m_target == GraphicsContext3D::TEXTURE_CUBE_MAP) {</span>
288         switch (target) {
<span class="line-modified">289         case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
290             return 0;
<span class="line-modified">291         case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
292             return 1;
<span class="line-modified">293         case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
294             return 2;
<span class="line-modified">295         case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
296             return 3;
<span class="line-modified">297         case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
298             return 4;
<span class="line-modified">299         case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
300             return 5;
301         }
302     }
303     return -1;
304 }
305 
306 bool WebGLTexture::canGenerateMipmaps()
307 {
308     if (isNPOT())
309         return false;
310     const LevelInfo&amp; first = m_info[0][0];
311     for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
312         const LevelInfo&amp; info = m_info[ii][0];
313         if (!info.valid
314             || info.width != first.width || info.height != first.height
315             || info.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info.type != first.type))
316             return false;
317     }
318     return true;
319 }
320 
<span class="line-modified">321 GC3Dint WebGLTexture::computeLevelCount(GC3Dsizei width, GC3Dsizei height)</span>
322 {
323     // return 1 + log2Floor(std::max(width, height));
<span class="line-modified">324     GC3Dsizei n = std::max(width, height);</span>
325     if (n &lt;= 0)
326         return 0;
<span class="line-modified">327     GC3Dint log = 0;</span>
<span class="line-modified">328     GC3Dsizei value = n;</span>
329     for (int ii = 4; ii &gt;= 0; --ii) {
330         int shift = (1 &lt;&lt; ii);
<span class="line-modified">331         GC3Dsizei x = (value &gt;&gt; shift);</span>
332         if (x) {
333             value = x;
334             log += shift;
335         }
336     }
337     ASSERT(value == 1);
338     return log + 1;
339 }
340 
<span class="line-modified">341 static bool internalFormatIsFloatType(GC3Denum internalFormat)</span>
342 {
343     switch (internalFormat) {
<span class="line-modified">344     case GraphicsContext3D::R32F:</span>
<span class="line-modified">345     case GraphicsContext3D::RG32F:</span>
<span class="line-modified">346     case GraphicsContext3D::RGB32F:</span>
<span class="line-modified">347     case GraphicsContext3D::RGBA32F:</span>
<span class="line-modified">348     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified">349     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
350         return true;
351     default:
352         return false;
353     }
354 }
355 
<span class="line-modified">356 static bool internalFormatIsHalfFloatType(GC3Denum internalFormat)</span>
357 {
358     switch (internalFormat) {
<span class="line-modified">359     case GraphicsContext3D::R16F:</span>
<span class="line-modified">360     case GraphicsContext3D::RG16F:</span>
<span class="line-modified">361     case GraphicsContext3D::R11F_G11F_B10F:</span>
<span class="line-modified">362     case GraphicsContext3D::RGB9_E5:</span>
<span class="line-modified">363     case GraphicsContext3D::RGB16F:</span>
<span class="line-modified">364     case GraphicsContext3D::RGBA16F:</span>
365         return true;
366     default:
367         return false;
368     }
369 }
370 
371 void WebGLTexture::update()
372 {
373     m_isNPOT = false;
374     for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
375         if (isNPOT(m_info[ii][0].width, m_info[ii][0].height)) {
376             m_isNPOT = true;
377             break;
378         }
379     }
380     m_isComplete = true;
381     const LevelInfo&amp; first = m_info[0][0];
<span class="line-modified">382     GC3Dint levelCount = computeLevelCount(first.width, first.height);</span>
383     if (levelCount &lt; 1)
384         m_isComplete = false;
385     else {
386         for (size_t ii = 0; ii &lt; m_info.size() &amp;&amp; m_isComplete; ++ii) {
387             const LevelInfo&amp; info0 = m_info[ii][0];
388             if (!info0.valid
389                 || info0.width != first.width || info0.height != first.height
390                 || info0.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info0.type != first.type)) {
391                 m_isComplete = false;
392                 break;
393             }
<span class="line-modified">394             GC3Dsizei width = info0.width;</span>
<span class="line-modified">395             GC3Dsizei height = info0.height;</span>
<span class="line-modified">396             for (GC3Dint level = 1; level &lt; levelCount; ++level) {</span>
397                 width = std::max(1, width &gt;&gt; 1);
398                 height = std::max(1, height &gt;&gt; 1);
399                 const LevelInfo&amp; info = m_info[ii][level];
400                 if (!info.valid
401                     || info.width != width || info.height != height
402                     || info.internalFormat != info0.internalFormat || (m_isForWebGL1 &amp;&amp; info.type != info0.type)) {
403                     m_isComplete = false;
404                     break;
405                 }
406 
407             }
408         }
409     }
410 
411     m_isFloatType = false;
412     if (m_isForWebGL1) {
413         if (m_isComplete) {
414             if (m_isForWebGL1)
<span class="line-modified">415                 m_isFloatType = m_info[0][0].type == GraphicsContext3D::FLOAT;</span>
416             else
417                 m_isFloatType = internalFormatIsFloatType(m_info[0][0].internalFormat);
418         } else {
419             for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">420                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContext3D::FLOAT)</span>
421                     || (!m_isForWebGL1 &amp;&amp; internalFormatIsFloatType(m_info[ii][0].internalFormat))) {
422                     m_isFloatType = true;
423                     break;
424                 }
425             }
426         }
427     }
428 
429     m_isHalfFloatType = false;
430     if (m_isForWebGL1) {
431         if (m_isComplete) {
432             if (m_isForWebGL1)
433                 m_isHalfFloatType = internalFormatIsHalfFloatType(m_info[0][0].internalFormat);
434             else
<span class="line-modified">435                 m_isHalfFloatType = m_info[0][0].type == GraphicsContext3D::HALF_FLOAT_OES;</span>
436         } else {
437             for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">438                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContext3D::HALF_FLOAT_OES)</span>
439                     || (!m_isForWebGL1 &amp;&amp; internalFormatIsHalfFloatType(m_info[ii][0].internalFormat))) {
440                     m_isHalfFloatType = true;
441                     break;
442                 }
443             }
444         }
445     }
446 
447     m_needToUseBlackTexture = false;
448     // NPOT
<span class="line-modified">449     if (m_isNPOT &amp;&amp; ((m_minFilter != GraphicsContext3D::NEAREST &amp;&amp; m_minFilter != GraphicsContext3D::LINEAR)</span>
<span class="line-modified">450                      || m_wrapS != GraphicsContext3D::CLAMP_TO_EDGE || m_wrapT != GraphicsContext3D::CLAMP_TO_EDGE))</span>
451         m_needToUseBlackTexture = true;
452     // Completeness
<span class="line-modified">453     if (!m_isComplete &amp;&amp; m_minFilter != GraphicsContext3D::NEAREST &amp;&amp; m_minFilter != GraphicsContext3D::LINEAR)</span>
454         m_needToUseBlackTexture = true;
455 }
456 
<span class="line-modified">457 const WebGLTexture::LevelInfo* WebGLTexture::getLevelInfo(GC3Denum target, GC3Dint level) const</span>
458 {
459     if (!object() || !m_target)
460         return 0;
461     int targetIndex = mapTargetToIndex(target);
462     if (targetIndex &lt; 0 || targetIndex &gt;= static_cast&lt;int&gt;(m_info.size()))
463         return 0;
<span class="line-modified">464     if (level &lt; 0 || level &gt;= static_cast&lt;GC3Dint&gt;(m_info[targetIndex].size()))</span>
465         return 0;
466     return &amp;(m_info[targetIndex][level]);
467 }
468 
469 }
470 
471 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;WebGLTexture.h&quot;
 31 
 32 #include &quot;WebGLContextGroup.h&quot;
 33 #include &quot;WebGLFramebuffer.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 Ref&lt;WebGLTexture&gt; WebGLTexture::create(WebGLRenderingContextBase&amp; ctx)
 39 {
 40     return adoptRef(*new WebGLTexture(ctx));
 41 }
 42 
 43 WebGLTexture::WebGLTexture(WebGLRenderingContextBase&amp; ctx)
 44     : WebGLSharedObject(ctx)
 45     , m_target(0)
<span class="line-modified"> 46     , m_minFilter(GraphicsContextGL::NEAREST_MIPMAP_LINEAR)</span>
<span class="line-modified"> 47     , m_magFilter(GraphicsContextGL::LINEAR)</span>
<span class="line-modified"> 48     , m_wrapS(GraphicsContextGL::REPEAT)</span>
<span class="line-modified"> 49     , m_wrapT(GraphicsContextGL::REPEAT)</span>
 50     , m_isNPOT(false)
 51     , m_isComplete(false)
 52     , m_needToUseBlackTexture(false)
 53     , m_isCompressed(false)
 54     , m_isFloatType(false)
 55     , m_isHalfFloatType(false)
 56     , m_isForWebGL1(ctx.isWebGL1())
 57 {
<span class="line-modified"> 58     setObject(ctx.graphicsContextGL()-&gt;createTexture());</span>
 59 }
 60 
 61 WebGLTexture::~WebGLTexture()
 62 {
 63     deleteObject(0);
 64 }
 65 
<span class="line-modified"> 66 void WebGLTexture::setTarget(GCGLenum target, GCGLint maxLevel)</span>
 67 {
 68     if (!object())
 69         return;
 70     // Target is finalized the first time bindTexture() is called.
 71     if (m_target)
 72         return;
 73     switch (target) {
<span class="line-modified"> 74     case GraphicsContextGL::TEXTURE_2D:</span>
 75         m_target = target;
 76         m_info.resize(1);
 77         m_info[0].resize(maxLevel);
 78         break;
<span class="line-modified"> 79     case GraphicsContextGL::TEXTURE_CUBE_MAP:</span>
 80         m_target = target;
 81         m_info.resize(6);
 82         for (int ii = 0; ii &lt; 6; ++ii)
 83             m_info[ii].resize(maxLevel);
 84         break;
 85     }
 86 }
 87 
<span class="line-modified"> 88 void WebGLTexture::setParameteri(GCGLenum pname, GCGLint param)</span>
 89 {
 90     if (!object() || !m_target)
 91         return;
 92     switch (pname) {
<span class="line-modified"> 93     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
 94         switch (param) {
<span class="line-modified"> 95         case GraphicsContextGL::NEAREST:</span>
<span class="line-modified"> 96         case GraphicsContextGL::LINEAR:</span>
<span class="line-modified"> 97         case GraphicsContextGL::NEAREST_MIPMAP_NEAREST:</span>
<span class="line-modified"> 98         case GraphicsContextGL::LINEAR_MIPMAP_NEAREST:</span>
<span class="line-modified"> 99         case GraphicsContextGL::NEAREST_MIPMAP_LINEAR:</span>
<span class="line-modified">100         case GraphicsContextGL::LINEAR_MIPMAP_LINEAR:</span>
101             m_minFilter = param;
102             break;
103         }
104         break;
<span class="line-modified">105     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
106         switch (param) {
<span class="line-modified">107         case GraphicsContextGL::NEAREST:</span>
<span class="line-modified">108         case GraphicsContextGL::LINEAR:</span>
109             m_magFilter = param;
110             break;
111         }
112         break;
<span class="line-modified">113     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
114         switch (param) {
<span class="line-modified">115         case GraphicsContextGL::CLAMP_TO_EDGE:</span>
<span class="line-modified">116         case GraphicsContextGL::MIRRORED_REPEAT:</span>
<span class="line-modified">117         case GraphicsContextGL::REPEAT:</span>
118             m_wrapS = param;
119             break;
120         }
121         break;
<span class="line-modified">122     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
123         switch (param) {
<span class="line-modified">124         case GraphicsContextGL::CLAMP_TO_EDGE:</span>
<span class="line-modified">125         case GraphicsContextGL::MIRRORED_REPEAT:</span>
<span class="line-modified">126         case GraphicsContextGL::REPEAT:</span>
127             m_wrapT = param;
128             break;
129         }
130         break;
131     default:
132         return;
133     }
134     update();
135 }
136 
<span class="line-modified">137 void WebGLTexture::setParameterf(GCGLenum pname, GCGLfloat param)</span>
138 {
139     if (!object() || !m_target)
140         return;
<span class="line-modified">141     GCGLint iparam = static_cast&lt;GCGLint&gt;(param);</span>
142     setParameteri(pname, iparam);
143 }
144 
<span class="line-modified">145 void WebGLTexture::setLevelInfo(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum type)</span>
146 {
147     if (!object() || !m_target)
148         return;
149     // We assume level, internalFormat, width, height, and type have all been
150     // validated already.
151     int index = mapTargetToIndex(target);
152     if (index &lt; 0)
153         return;
154     m_info[index][level].setInfo(internalFormat, width, height, type);
155     update();
156 }
157 
158 void WebGLTexture::generateMipmapLevelInfo()
159 {
160     if (!object() || !m_target)
161         return;
162     if (!canGenerateMipmaps())
163         return;
164     if (!m_isComplete) {
165         for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
166             const LevelInfo&amp; info0 = m_info[ii][0];
<span class="line-modified">167             GCGLsizei width = info0.width;</span>
<span class="line-modified">168             GCGLsizei height = info0.height;</span>
<span class="line-modified">169             GCGLint levelCount = computeLevelCount(width, height);</span>
<span class="line-modified">170             for (GCGLint level = 1; level &lt; levelCount; ++level) {</span>
171                 width = std::max(1, width &gt;&gt; 1);
172                 height = std::max(1, height &gt;&gt; 1);
173                 LevelInfo&amp; info = m_info[ii][level];
174                 info.setInfo(info0.internalFormat, width, height, info0.type);
175             }
176         }
177         m_isComplete = true;
178     }
179     m_needToUseBlackTexture = false;
180 }
181 
<span class="line-modified">182 GCGLenum WebGLTexture::getInternalFormat(GCGLenum target, GCGLint level) const</span>
183 {
184     const LevelInfo* info = getLevelInfo(target, level);
185     if (!info)
186         return 0;
187     return info-&gt;internalFormat;
188 }
189 
<span class="line-modified">190 GCGLenum WebGLTexture::getType(GCGLenum target, GCGLint level) const</span>
191 {
192     ASSERT(m_isForWebGL1);
193     const LevelInfo* info = getLevelInfo(target, level);
194     if (!info)
195         return 0;
196     return info-&gt;type;
197 }
198 
<span class="line-modified">199 GCGLsizei WebGLTexture::getWidth(GCGLenum target, GCGLint level) const</span>
200 {
201     const LevelInfo* info = getLevelInfo(target, level);
202     if (!info)
203         return 0;
204     return info-&gt;width;
205 }
206 
<span class="line-modified">207 GCGLsizei WebGLTexture::getHeight(GCGLenum target, GCGLint level) const</span>
208 {
209     const LevelInfo* info = getLevelInfo(target, level);
210     if (!info)
211         return 0;
212     return info-&gt;height;
213 }
214 
<span class="line-modified">215 bool WebGLTexture::isValid(GCGLenum target, GCGLint level) const</span>
216 {
217     const LevelInfo* info = getLevelInfo(target, level);
218     if (!info)
219         return 0;
220     return info-&gt;valid;
221 }
222 
<span class="line-modified">223 void WebGLTexture::markInvalid(GCGLenum target, GCGLint level)</span>
224 {
225     int index = mapTargetToIndex(target);
226     if (index &lt; 0)
227         return;
228     m_info[index][level].valid = false;
229     update();
230 }
231 
<span class="line-modified">232 bool WebGLTexture::isNPOT(GCGLsizei width, GCGLsizei height)</span>
233 {
234     ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
235     if (!width || !height)
236         return false;
237     if ((width &amp; (width - 1)) || (height &amp; (height - 1)))
238         return true;
239     return false;
240 }
241 
242 bool WebGLTexture::isNPOT() const
243 {
244     if (!object())
245         return false;
246     return m_isNPOT;
247 }
248 
249 bool WebGLTexture::needToUseBlackTexture(TextureExtensionFlag extensions) const
250 {
251     if (!object())
252         return false;
253     if (m_needToUseBlackTexture)
254         return true;
<span class="line-modified">255     if (m_magFilter == GraphicsContextGL::NEAREST &amp;&amp; (m_minFilter == GraphicsContextGL::NEAREST || m_minFilter == GraphicsContextGL::NEAREST_MIPMAP_NEAREST))</span>
256         return false;
257     if (m_isForWebGL1 &amp;&amp; m_isHalfFloatType &amp;&amp; !(extensions &amp; TextureExtensionHalfFloatLinearEnabled))
258         return true;
259     if (m_isFloatType &amp;&amp; !(extensions &amp; TextureExtensionFloatLinearEnabled))
260         return true;
261     return false;
262 }
263 
264 bool WebGLTexture::isCompressed() const
265 {
266     if (!object())
267         return false;
268     return m_isCompressed;
269 }
270 
271 void WebGLTexture::setCompressed()
272 {
273     ASSERT(object());
274     m_isCompressed = true;
275 }
276 
<span class="line-modified">277 void WebGLTexture::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
278 {
279     context3d-&gt;deleteTexture(object);
280 }
281 
<span class="line-modified">282 int WebGLTexture::mapTargetToIndex(GCGLenum target) const</span>
283 {
<span class="line-modified">284     if (m_target == GraphicsContextGL::TEXTURE_2D) {</span>
<span class="line-modified">285         if (target == GraphicsContextGL::TEXTURE_2D)</span>
286             return 0;
<span class="line-modified">287     } else if (m_target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
288         switch (target) {
<span class="line-modified">289         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
290             return 0;
<span class="line-modified">291         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
292             return 1;
<span class="line-modified">293         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
294             return 2;
<span class="line-modified">295         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
296             return 3;
<span class="line-modified">297         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
298             return 4;
<span class="line-modified">299         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
300             return 5;
301         }
302     }
303     return -1;
304 }
305 
306 bool WebGLTexture::canGenerateMipmaps()
307 {
308     if (isNPOT())
309         return false;
310     const LevelInfo&amp; first = m_info[0][0];
311     for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
312         const LevelInfo&amp; info = m_info[ii][0];
313         if (!info.valid
314             || info.width != first.width || info.height != first.height
315             || info.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info.type != first.type))
316             return false;
317     }
318     return true;
319 }
320 
<span class="line-modified">321 GCGLint WebGLTexture::computeLevelCount(GCGLsizei width, GCGLsizei height)</span>
322 {
323     // return 1 + log2Floor(std::max(width, height));
<span class="line-modified">324     GCGLsizei n = std::max(width, height);</span>
325     if (n &lt;= 0)
326         return 0;
<span class="line-modified">327     GCGLint log = 0;</span>
<span class="line-modified">328     GCGLsizei value = n;</span>
329     for (int ii = 4; ii &gt;= 0; --ii) {
330         int shift = (1 &lt;&lt; ii);
<span class="line-modified">331         GCGLsizei x = (value &gt;&gt; shift);</span>
332         if (x) {
333             value = x;
334             log += shift;
335         }
336     }
337     ASSERT(value == 1);
338     return log + 1;
339 }
340 
<span class="line-modified">341 static bool internalFormatIsFloatType(GCGLenum internalFormat)</span>
342 {
343     switch (internalFormat) {
<span class="line-modified">344     case GraphicsContextGL::R32F:</span>
<span class="line-modified">345     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">346     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">347     case GraphicsContextGL::RGBA32F:</span>
<span class="line-modified">348     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified">349     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
350         return true;
351     default:
352         return false;
353     }
354 }
355 
<span class="line-modified">356 static bool internalFormatIsHalfFloatType(GCGLenum internalFormat)</span>
357 {
358     switch (internalFormat) {
<span class="line-modified">359     case GraphicsContextGL::R16F:</span>
<span class="line-modified">360     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">361     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified">362     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified">363     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">364     case GraphicsContextGL::RGBA16F:</span>
365         return true;
366     default:
367         return false;
368     }
369 }
370 
371 void WebGLTexture::update()
372 {
373     m_isNPOT = false;
374     for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
375         if (isNPOT(m_info[ii][0].width, m_info[ii][0].height)) {
376             m_isNPOT = true;
377             break;
378         }
379     }
380     m_isComplete = true;
381     const LevelInfo&amp; first = m_info[0][0];
<span class="line-modified">382     GCGLint levelCount = computeLevelCount(first.width, first.height);</span>
383     if (levelCount &lt; 1)
384         m_isComplete = false;
385     else {
386         for (size_t ii = 0; ii &lt; m_info.size() &amp;&amp; m_isComplete; ++ii) {
387             const LevelInfo&amp; info0 = m_info[ii][0];
388             if (!info0.valid
389                 || info0.width != first.width || info0.height != first.height
390                 || info0.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info0.type != first.type)) {
391                 m_isComplete = false;
392                 break;
393             }
<span class="line-modified">394             GCGLsizei width = info0.width;</span>
<span class="line-modified">395             GCGLsizei height = info0.height;</span>
<span class="line-modified">396             for (GCGLint level = 1; level &lt; levelCount; ++level) {</span>
397                 width = std::max(1, width &gt;&gt; 1);
398                 height = std::max(1, height &gt;&gt; 1);
399                 const LevelInfo&amp; info = m_info[ii][level];
400                 if (!info.valid
401                     || info.width != width || info.height != height
402                     || info.internalFormat != info0.internalFormat || (m_isForWebGL1 &amp;&amp; info.type != info0.type)) {
403                     m_isComplete = false;
404                     break;
405                 }
406 
407             }
408         }
409     }
410 
411     m_isFloatType = false;
412     if (m_isForWebGL1) {
413         if (m_isComplete) {
414             if (m_isForWebGL1)
<span class="line-modified">415                 m_isFloatType = m_info[0][0].type == GraphicsContextGL::FLOAT;</span>
416             else
417                 m_isFloatType = internalFormatIsFloatType(m_info[0][0].internalFormat);
418         } else {
419             for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">420                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContextGL::FLOAT)</span>
421                     || (!m_isForWebGL1 &amp;&amp; internalFormatIsFloatType(m_info[ii][0].internalFormat))) {
422                     m_isFloatType = true;
423                     break;
424                 }
425             }
426         }
427     }
428 
429     m_isHalfFloatType = false;
430     if (m_isForWebGL1) {
431         if (m_isComplete) {
432             if (m_isForWebGL1)
433                 m_isHalfFloatType = internalFormatIsHalfFloatType(m_info[0][0].internalFormat);
434             else
<span class="line-modified">435                 m_isHalfFloatType = m_info[0][0].type == GraphicsContextGL::HALF_FLOAT_OES;</span>
436         } else {
437             for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">438                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContextGL::HALF_FLOAT_OES)</span>
439                     || (!m_isForWebGL1 &amp;&amp; internalFormatIsHalfFloatType(m_info[ii][0].internalFormat))) {
440                     m_isHalfFloatType = true;
441                     break;
442                 }
443             }
444         }
445     }
446 
447     m_needToUseBlackTexture = false;
448     // NPOT
<span class="line-modified">449     if (m_isNPOT &amp;&amp; ((m_minFilter != GraphicsContextGL::NEAREST &amp;&amp; m_minFilter != GraphicsContextGL::LINEAR)</span>
<span class="line-modified">450         || m_wrapS != GraphicsContextGL::CLAMP_TO_EDGE || m_wrapT != GraphicsContextGL::CLAMP_TO_EDGE))</span>
451         m_needToUseBlackTexture = true;
452     // Completeness
<span class="line-modified">453     if (!m_isComplete &amp;&amp; m_minFilter != GraphicsContextGL::NEAREST &amp;&amp; m_minFilter != GraphicsContextGL::LINEAR)</span>
454         m_needToUseBlackTexture = true;
455 }
456 
<span class="line-modified">457 const WebGLTexture::LevelInfo* WebGLTexture::getLevelInfo(GCGLenum target, GCGLint level) const</span>
458 {
459     if (!object() || !m_target)
460         return 0;
461     int targetIndex = mapTargetToIndex(target);
462     if (targetIndex &lt; 0 || targetIndex &gt;= static_cast&lt;int&gt;(m_info.size()))
463         return 0;
<span class="line-modified">464     if (level &lt; 0 || level &gt;= static_cast&lt;GCGLint&gt;(m_info[targetIndex].size()))</span>
465         return 0;
466     return &amp;(m_info[targetIndex][level]);
467 }
468 
469 }
470 
471 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLSync.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLTexture.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
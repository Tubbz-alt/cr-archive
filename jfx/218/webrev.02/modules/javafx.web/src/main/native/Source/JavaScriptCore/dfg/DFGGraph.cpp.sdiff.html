<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGGraph.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGForAllKills.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGGraph.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 168     printWhiteSpace(out, amountOfNodeWhiteSpace(node));
 169 }
 170 
 171 void Graph::dump(PrintStream&amp; out, const char* prefixStr, Node* node, DumpContext* context)
 172 {
 173     Prefix myPrefix(prefixStr);
 174     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;
 175 
 176     NodeType op = node-&gt;op();
 177 
 178     unsigned refCount = node-&gt;refCount();
 179     bool mustGenerate = node-&gt;mustGenerate();
 180     if (mustGenerate)
 181         --refCount;
 182 
 183     out.print(prefix);
 184     printNodeWhiteSpace(out, node);
 185 
 186     // Example/explanation of dataflow dump output
 187     //
<span class="line-modified"> 188     //   14:   &lt;!2:7&gt;  GetByVal(@3, @13)</span>
<span class="line-modified"> 189     //   ^1     ^2 ^3     ^4       ^5</span>
 190     //
 191     // (1) The nodeIndex of this operation.
 192     // (2) The reference count. The number printed is the &#39;real&#39; count,
 193     //     not including the &#39;mustGenerate&#39; ref. If the node is
 194     //     &#39;mustGenerate&#39; then the count it prefixed with &#39;!&#39;.
 195     // (3) The virtual register slot assigned to this node.
 196     // (4) The name of the operation.
 197     // (5) The arguments to the operation. The may be of the form:
<span class="line-modified"> 198     //         @#   - a NodeIndex referencing a prior node in the graph.</span>
 199     //         arg# - an argument number.
 200     //         id#  - the index in the CodeBlock of an identifier { if codeBlock is passed to dump(), the string representation is displayed }.
 201     //         var# - the index of a var on the global object, used by GetGlobalVar/GetGlobalLexicalVariable/PutGlobalVariable operations.
<span class="line-modified"> 202     out.printf(&quot;% 4d:&lt;%c%u:&quot;, (int)node-&gt;index(), mustGenerate ? &#39;!&#39; : &#39; &#39;, refCount);</span>


 203     if (node-&gt;hasResult() &amp;&amp; node-&gt;hasVirtualRegister() &amp;&amp; node-&gt;virtualRegister().isValid())
 204         out.print(node-&gt;virtualRegister());
 205     else
 206         out.print(&quot;-&quot;);
 207     out.print(&quot;&gt;\t&quot;, opName(op), &quot;(&quot;);
 208     CommaPrinter comma;
 209     if (node-&gt;flags() &amp; NodeHasVarArgs) {
 210         for (unsigned childIdx = node-&gt;firstChild(); childIdx &lt; node-&gt;firstChild() + node-&gt;numChildren(); childIdx++) {
 211             if (!m_varArgChildren[childIdx])
 212                 continue;
 213             out.print(comma, m_varArgChildren[childIdx]);
 214         }
 215     } else {
 216         if (!!node-&gt;child1() || !!node-&gt;child2() || !!node-&gt;child3())
 217             out.print(comma, node-&gt;child1());
 218         if (!!node-&gt;child2() || !!node-&gt;child3())
 219             out.print(comma, node-&gt;child2());
 220         if (!!node-&gt;child3())
 221             out.print(comma, node-&gt;child3());
 222     }
</pre>
<hr />
<pre>
 226     if (node-&gt;prediction())
 227         out.print(comma, SpeculationDump(node-&gt;prediction()));
 228     if (node-&gt;hasNumberOfArgumentsToSkip())
 229         out.print(comma, &quot;numberOfArgumentsToSkip = &quot;, node-&gt;numberOfArgumentsToSkip());
 230     if (node-&gt;hasArrayMode())
 231         out.print(comma, node-&gt;arrayMode());
 232     if (node-&gt;hasArithUnaryType())
 233         out.print(comma, &quot;Type:&quot;, node-&gt;arithUnaryType());
 234     if (node-&gt;hasArithMode())
 235         out.print(comma, node-&gt;arithMode());
 236     if (node-&gt;hasArithRoundingMode())
 237         out.print(comma, &quot;Rounding:&quot;, node-&gt;arithRoundingMode());
 238     if (node-&gt;hasScopeOffset())
 239         out.print(comma, node-&gt;scopeOffset());
 240     if (node-&gt;hasDirectArgumentsOffset())
 241         out.print(comma, node-&gt;capturedArgumentsOffset());
 242     if (node-&gt;hasArgumentIndex())
 243         out.print(comma, node-&gt;argumentIndex());
 244     if (node-&gt;hasRegisterPointer())
 245         out.print(comma, &quot;global&quot;, &quot;(&quot;, RawPointer(node-&gt;variablePointer()), &quot;)&quot;);
<span class="line-modified"> 246     if (node-&gt;hasIdentifier())</span>
 247         out.print(comma, &quot;id&quot;, node-&gt;identifierNumber(), &quot;{&quot;, identifiers()[node-&gt;identifierNumber()], &quot;}&quot;);
 248     if (node-&gt;hasPromotedLocationDescriptor())
 249         out.print(comma, node-&gt;promotedLocationDescriptor());
 250     if (node-&gt;hasClassInfo())
 251         out.print(comma, *node-&gt;classInfo());
 252     if (node-&gt;hasStructureSet())
 253         out.print(comma, inContext(node-&gt;structureSet().toStructureSet(), context));
 254     if (node-&gt;hasStructure())
 255         out.print(comma, inContext(*node-&gt;structure().get(), context));
 256     if (node-&gt;op() == CPUIntrinsic)
 257         out.print(comma, intrinsicName(node-&gt;intrinsic()));
 258     if (node-&gt;hasTransition()) {
 259         out.print(comma, pointerDumpInContext(node-&gt;transition(), context));
 260 #if USE(JSVALUE64)
 261         out.print(&quot;, ID:&quot;, node-&gt;transition()-&gt;next-&gt;id());
 262 #else
 263         out.print(&quot;, ID:&quot;, RawPointer(node-&gt;transition()-&gt;next.get()));
 264 #endif
 265     }
 266     if (node-&gt;hasCellOperand()) {
 267         if (!node-&gt;cellOperand()-&gt;value() || !node-&gt;cellOperand()-&gt;value().isCell())
 268             out.print(comma, &quot;invalid cell operand: &quot;, node-&gt;cellOperand()-&gt;value());
 269         else {
 270             out.print(comma, pointerDump(node-&gt;cellOperand()-&gt;value().asCell()));
 271             if (node-&gt;cellOperand()-&gt;value().isCell()) {
 272                 CallVariant variant(node-&gt;cellOperand()-&gt;value().asCell());
 273                 if (ExecutableBase* executable = variant.executable()) {
 274                     if (executable-&gt;isHostFunction())
 275                         out.print(comma, &quot;&lt;host function&gt;&quot;);
 276                     else if (FunctionExecutable* functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, executable))
 277                         out.print(comma, FunctionExecutableDump(functionExecutable));
 278                     else
 279                         out.print(comma, &quot;&lt;non-function executable&gt;&quot;);
 280                 }
 281             }
 282         }
 283     }
<span class="line-modified"> 284     if (node-&gt;hasSpeculatedTypeForQuery())</span>
<span class="line-modified"> 285         out.print(comma, SpeculationDump(node-&gt;speculatedTypeForQuery()));</span>
 286     if (node-&gt;hasStorageAccessData()) {
 287         StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
 288         out.print(comma, &quot;id&quot;, storageAccessData.identifierNumber, &quot;{&quot;, identifiers()[storageAccessData.identifierNumber], &quot;}&quot;);
 289         out.print(&quot;, &quot;, static_cast&lt;ptrdiff_t&gt;(storageAccessData.offset));
 290     }
 291     if (node-&gt;hasMultiGetByOffsetData()) {
 292         MultiGetByOffsetData&amp; data = node-&gt;multiGetByOffsetData();
 293         out.print(comma, &quot;id&quot;, data.identifierNumber, &quot;{&quot;, identifiers()[data.identifierNumber], &quot;}&quot;);
 294         for (unsigned i = 0; i &lt; data.cases.size(); ++i)
 295             out.print(comma, inContext(data.cases[i], context));
 296     }
 297     if (node-&gt;hasMultiPutByOffsetData()) {
 298         MultiPutByOffsetData&amp; data = node-&gt;multiPutByOffsetData();
 299         out.print(comma, &quot;id&quot;, data.identifierNumber, &quot;{&quot;, identifiers()[data.identifierNumber], &quot;}&quot;);
 300         for (unsigned i = 0; i &lt; data.variants.size(); ++i)
 301             out.print(comma, inContext(data.variants[i], context));
 302     }
 303     if (node-&gt;hasMatchStructureData()) {
 304         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants)
 305             out.print(comma, inContext(*variant.structure.get(), context), &quot;=&gt;&quot;, variant.result);
 306     }
 307     ASSERT(node-&gt;hasVariableAccessData(*this) == node-&gt;accessesStack(*this));
 308     if (node-&gt;hasVariableAccessData(*this)) {
 309         VariableAccessData* variableAccessData = node-&gt;tryGetVariableAccessData();
 310         if (variableAccessData) {
<span class="line-modified"> 311             VirtualRegister operand = variableAccessData-&gt;local();</span>
<span class="line-modified"> 312             out.print(comma, variableAccessData-&gt;local(), &quot;(&quot;, VariableAccessDataDump(*this, variableAccessData), &quot;)&quot;);</span>
 313             operand = variableAccessData-&gt;machineLocal();
 314             if (operand.isValid())
 315                 out.print(comma, &quot;machine:&quot;, operand);
 316         }
 317     }
 318     if (node-&gt;hasStackAccessData()) {
 319         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified"> 320         out.print(comma, data-&gt;local);</span>
 321         if (data-&gt;machineLocal.isValid())
 322             out.print(comma, &quot;machine:&quot;, data-&gt;machineLocal);
 323         out.print(comma, data-&gt;format);
 324     }
<span class="line-modified"> 325     if (node-&gt;hasUnlinkedLocal())</span>
<span class="line-modified"> 326         out.print(comma, node-&gt;unlinkedLocal());</span>
 327     if (node-&gt;hasVectorLengthHint())
 328         out.print(comma, &quot;vectorLengthHint = &quot;, node-&gt;vectorLengthHint());
 329     if (node-&gt;hasLazyJSValue())
 330         out.print(comma, node-&gt;lazyJSValue());
 331     if (node-&gt;hasIndexingType())
 332         out.print(comma, IndexingTypeDump(node-&gt;indexingMode()));
 333     if (node-&gt;hasTypedArrayType())
 334         out.print(comma, node-&gt;typedArrayType());
 335     if (node-&gt;hasPhi())
 336         out.print(comma, &quot;^&quot;, node-&gt;phi()-&gt;index());
 337     if (node-&gt;hasExecutionCounter())
 338         out.print(comma, RawPointer(node-&gt;executionCounter()));
 339     if (node-&gt;hasWatchpointSet())
 340         out.print(comma, RawPointer(node-&gt;watchpointSet()));
 341     if (node-&gt;hasStoragePointer())
 342         out.print(comma, RawPointer(node-&gt;storagePointer()));
 343     if (node-&gt;hasObjectMaterializationData())
 344         out.print(comma, node-&gt;objectMaterializationData());
 345     if (node-&gt;hasCallVarargsData())
 346         out.print(comma, &quot;firstVarArgOffset = &quot;, node-&gt;callVarargsData()-&gt;firstVarArgOffset);
 347     if (node-&gt;hasLoadVarargsData()) {
 348         LoadVarargsData* data = node-&gt;loadVarargsData();
 349         out.print(comma, &quot;start = &quot;, data-&gt;start, &quot;, count = &quot;, data-&gt;count);
 350         if (data-&gt;machineStart.isValid())
 351             out.print(&quot;, machineStart = &quot;, data-&gt;machineStart);
 352         if (data-&gt;machineCount.isValid())
 353             out.print(&quot;, machineCount = &quot;, data-&gt;machineCount);
 354         out.print(&quot;, offset = &quot;, data-&gt;offset, &quot;, mandatoryMinimum = &quot;, data-&gt;mandatoryMinimum);
 355         out.print(&quot;, limit = &quot;, data-&gt;limit);
 356     }




 357     if (node-&gt;hasCallDOMGetterData()) {
 358         CallDOMGetterData* data = node-&gt;callDOMGetterData();
 359         out.print(comma, &quot;id&quot;, data-&gt;identifierNumber, &quot;{&quot;, identifiers()[data-&gt;identifierNumber], &quot;}&quot;);
 360         out.print(&quot;, domJIT = &quot;, RawPointer(data-&gt;domJIT));
 361     }
 362     if (node-&gt;hasIgnoreLastIndexIsWritable())
 363         out.print(comma, &quot;ignoreLastIndexIsWritable = &quot;, node-&gt;ignoreLastIndexIsWritable());


 364     if (node-&gt;isConstant())
 365         out.print(comma, pointerDumpInContext(node-&gt;constant(), context));
 366     if (node-&gt;hasCallLinkStatus())
 367         out.print(comma, *node-&gt;callLinkStatus());
<span class="line-modified"> 368     if (node-&gt;hasGetByIdStatus())</span>
<span class="line-modified"> 369         out.print(comma, *node-&gt;getByIdStatus());</span>
 370     if (node-&gt;hasInByIdStatus())
 371         out.print(comma, *node-&gt;inByIdStatus());
 372     if (node-&gt;hasPutByIdStatus())
 373         out.print(comma, *node-&gt;putByIdStatus());
 374     if (node-&gt;isJump())
 375         out.print(comma, &quot;T:&quot;, *node-&gt;targetBlock());
 376     if (node-&gt;isBranch())
 377         out.print(comma, &quot;T:&quot;, node-&gt;branchData()-&gt;taken, &quot;, F:&quot;, node-&gt;branchData()-&gt;notTaken);
 378     if (node-&gt;isSwitch()) {
 379         SwitchData* data = node-&gt;switchData();
 380         out.print(comma, data-&gt;kind);
 381         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 382             out.print(comma, inContext(data-&gt;cases[i].value, context), &quot;:&quot;, data-&gt;cases[i].target);
 383         out.print(comma, &quot;default:&quot;, data-&gt;fallThrough);
 384     }
 385     if (node-&gt;isEntrySwitch()) {
 386         EntrySwitchData* data = node-&gt;entrySwitchData();
 387         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 388             out.print(comma, BranchTarget(data-&gt;cases[i]));
 389     }
 390     ClobberSet reads;
 391     ClobberSet writes;
 392     addReadsAndWrites(*this, node, reads, writes);
 393     if (!reads.isEmpty())
 394         out.print(comma, &quot;R:&quot;, sortedListDump(reads.direct(), &quot;,&quot;));
 395     if (!writes.isEmpty())
 396         out.print(comma, &quot;W:&quot;, sortedListDump(writes.direct(), &quot;,&quot;));
 397     ExitMode exitMode = mayExit(*this, node);
 398     if (exitMode != DoesNotExit)
 399         out.print(comma, exitMode);
 400     if (clobbersExitState(*this, node))
 401         out.print(comma, &quot;ClobbersExit&quot;);
 402     if (node-&gt;origin.isSet()) {
<span class="line-modified"> 403         out.print(comma, &quot;bc#&quot;, node-&gt;origin.semantic.bytecodeIndex());</span>
 404         if (node-&gt;origin.semantic != node-&gt;origin.forExit &amp;&amp; node-&gt;origin.forExit.isSet())
 405             out.print(comma, &quot;exit: &quot;, node-&gt;origin.forExit);
 406     }
 407     out.print(comma, node-&gt;origin.exitOK ? &quot;ExitValid&quot; : &quot;ExitInvalid&quot;);
 408     if (node-&gt;origin.wasHoisted)
 409         out.print(comma, &quot;WasHoisted&quot;);
 410     out.print(&quot;)&quot;);
 411 
 412     if (node-&gt;accessesStack(*this) &amp;&amp; node-&gt;tryGetVariableAccessData())
 413         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;tryGetVariableAccessData()-&gt;prediction()));
 414     else if (node-&gt;hasHeapPrediction())
 415         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;getHeapPrediction()));
 416 
 417     out.print(&quot;\n&quot;);
 418 }
 419 
 420 bool Graph::terminalsAreValid()
 421 {
 422     for (BasicBlock* block : blocksInNaturalOrder()) {
 423         if (!block-&gt;terminal())
</pre>
<hr />
<pre>
 492         }
 493 
 494         auto containingLoops = naturalLoops-&gt;loopsOf(block);
 495         if (!containingLoops.isEmpty()) {
 496             out.print(prefix, &quot;  Containing loop headers:&quot;);
 497             for (unsigned i = 0; i &lt; containingLoops.size(); ++i)
 498                 out.print(&quot; &quot;, *unboxLoopNode(containingLoops[i]-&gt;header()));
 499             out.print(&quot;\n&quot;);
 500         }
 501     };
 502 
 503     if (m_ssaNaturalLoops)
 504         printNaturalLoops(m_ssaNaturalLoops);
 505     else if (m_cpsNaturalLoops)
 506         printNaturalLoops(m_cpsNaturalLoops);
 507 
 508     if (!block-&gt;phis.isEmpty()) {
 509         out.print(prefix, &quot;  Phi Nodes:&quot;);
 510         for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 511             Node* phiNode = block-&gt;phis[i];

 512             if (!phiNode-&gt;shouldGenerate() &amp;&amp; phiNodeDumpMode == DumpLivePhisOnly)
 513                 continue;
<span class="line-modified"> 514             out.print(&quot; @&quot;, phiNode-&gt;index(), &quot;&lt;&quot;, phiNode-&gt;local(), &quot;,&quot;, phiNode-&gt;refCount(), &quot;&gt;-&gt;(&quot;);</span>
 515             if (phiNode-&gt;child1()) {
<span class="line-modified"> 516                 out.print(&quot;@&quot;, phiNode-&gt;child1()-&gt;index());</span>
 517                 if (phiNode-&gt;child2()) {
<span class="line-modified"> 518                     out.print(&quot;, @&quot;, phiNode-&gt;child2()-&gt;index());</span>
 519                     if (phiNode-&gt;child3())
<span class="line-modified"> 520                         out.print(&quot;, @&quot;, phiNode-&gt;child3()-&gt;index());</span>
 521                 }
 522             }
 523             out.print(&quot;)&quot;, i + 1 &lt; block-&gt;phis.size() ? &quot;,&quot; : &quot;&quot;);
 524         }
 525         out.print(&quot;\n&quot;);
 526     }
 527 }
 528 
 529 void Graph::dump(PrintStream&amp; out, DumpContext* context)
 530 {
 531     Prefix&amp; prefix = m_prefix;
 532     DumpContext myContext;
 533     myContext.graph = this;
 534     if (!context)
 535         context = &amp;myContext;
 536 
 537     out.print(&quot;\n&quot;);
 538     out.print(prefix, &quot;DFG for &quot;, CodeBlockWithJITType(m_codeBlock, JITType::DFGJIT), &quot;:\n&quot;);
 539     out.print(prefix, &quot;  Fixpoint state: &quot;, m_fixpointState, &quot;; Form: &quot;, m_form, &quot;; Unification state: &quot;, m_unificationState, &quot;; Ref count state: &quot;, m_refCountState, &quot;\n&quot;);
 540     if (m_form == SSA) {
 541         for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_argumentFormats.size(); ++entrypointIndex)
 542             out.print(prefix, &quot;  Argument formats for entrypoint index: &quot;, entrypointIndex, &quot; : &quot;, listDump(m_argumentFormats[entrypointIndex]), &quot;\n&quot;);
 543     }
 544     else {
<span class="line-modified"> 545         for (auto pair : m_rootToArguments)</span>
 546             out.print(prefix, &quot;  Arguments for block#&quot;, pair.key-&gt;index, &quot;: &quot;, listDump(pair.value), &quot;\n&quot;);
 547     }
 548     out.print(&quot;\n&quot;);
 549 
 550     Node* lastNode = nullptr;
 551     for (size_t b = 0; b &lt; m_blocks.size(); ++b) {
 552         BasicBlock* block = m_blocks[b].get();
 553         if (!block)
 554             continue;
 555         prefix.blockIndex = block-&gt;index;
 556         dumpBlockHeader(out, Prefix::noString, block, DumpAllPhis, context);
 557         out.print(prefix, &quot;  States: &quot;, block-&gt;cfaStructureClobberStateAtHead);
 558         if (!block-&gt;cfaHasVisited)
 559             out.print(&quot;, CurrentlyCFAUnreachable&quot;);
 560         if (!block-&gt;intersectionOfCFAHasVisited)
 561             out.print(&quot;, CFAUnreachable&quot;);
 562         out.print(&quot;\n&quot;);
 563         switch (m_form) {
 564         case LoadStore:
 565         case ThreadedCPS: {
</pre>
<hr />
<pre>
 861     m_backwardsCFG = nullptr;
 862     m_cpsCFG = nullptr;
 863 }
 864 
 865 void Graph::invalidateNodeLiveness()
 866 {
 867     if (m_form != SSA)
 868         return;
 869 
 870     for (BasicBlock* block : blocksInNaturalOrder())
 871         block-&gt;ssa-&gt;invalidate();
 872 }
 873 
 874 void Graph::substituteGetLocal(BasicBlock&amp; block, unsigned startIndexInBlock, VariableAccessData* variableAccessData, Node* newGetLocal)
 875 {
 876     for (unsigned indexInBlock = startIndexInBlock; indexInBlock &lt; block.size(); ++indexInBlock) {
 877         Node* node = block[indexInBlock];
 878         bool shouldContinue = true;
 879         switch (node-&gt;op()) {
 880         case SetLocal: {
<span class="line-modified"> 881             if (node-&gt;local() == variableAccessData-&gt;local())</span>
 882                 shouldContinue = false;
 883             break;
 884         }
 885 
 886         case GetLocal: {
 887             if (node-&gt;variableAccessData() != variableAccessData)
 888                 continue;
 889             substitute(block, indexInBlock, node, newGetLocal);
<span class="line-modified"> 890             Node* oldTailNode = block.variablesAtTail.operand(variableAccessData-&gt;local());</span>
 891             if (oldTailNode == node)
<span class="line-modified"> 892                 block.variablesAtTail.operand(variableAccessData-&gt;local()) = newGetLocal;</span>
 893             shouldContinue = false;
 894             break;
 895         }
 896 
 897         default:
 898             break;
 899         }
 900         if (!shouldContinue)
 901             break;
 902     }
 903 }
 904 
 905 BlockList Graph::blocksInPreOrder()
 906 {
 907     BlockList result;
 908     result.reserveInitialCapacity(m_blocks.size());
 909     BlockWorklist worklist;
 910     for (BasicBlock* entrypoint : m_roots)
 911         worklist.push(entrypoint);
 912     while (BasicBlock* block = worklist.pop()) {
</pre>
<hr />
<pre>
1110 }
1111 
1112 BytecodeKills&amp; Graph::killsFor(CodeBlock* codeBlock)
1113 {
1114     HashMap&lt;CodeBlock*, std::unique_ptr&lt;BytecodeKills&gt;&gt;::iterator iter = m_bytecodeKills.find(codeBlock);
1115     if (iter != m_bytecodeKills.end())
1116         return *iter-&gt;value;
1117 
1118     std::unique_ptr&lt;BytecodeKills&gt; kills = makeUnique&lt;BytecodeKills&gt;();
1119     codeBlock-&gt;livenessAnalysis().computeKills(codeBlock, *kills);
1120     BytecodeKills&amp; result = *kills;
1121     m_bytecodeKills.add(codeBlock, WTFMove(kills));
1122     return result;
1123 }
1124 
1125 BytecodeKills&amp; Graph::killsFor(InlineCallFrame* inlineCallFrame)
1126 {
1127     return killsFor(baselineCodeBlockFor(inlineCallFrame));
1128 }
1129 
<span class="line-modified">1130 bool Graph::isLiveInBytecode(VirtualRegister operand, CodeOrigin codeOrigin)</span>
1131 {
<span class="line-modified">1132     static const bool verbose = false;</span>
1133 
1134     if (verbose)
1135         dataLog(&quot;Checking of operand is live: &quot;, operand, &quot;\n&quot;);


1136     CodeOrigin* codeOriginPtr = &amp;codeOrigin;
<span class="line-modified">1137     for (;;) {</span>
<span class="line-modified">1138         VirtualRegister reg = VirtualRegister(</span>
<span class="line-modified">1139             operand.offset() - codeOriginPtr-&gt;stackOffset());</span>




















1140 
1141         if (verbose)
1142             dataLog(&quot;reg = &quot;, reg, &quot;\n&quot;);
1143 
<span class="line-modified">1144         auto* inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
<span class="line-removed">1145         if (operand.offset() &lt; codeOriginPtr-&gt;stackOffset() + CallFrame::headerSizeInRegisters) {</span>
1146             if (reg.isArgument()) {
1147                 RELEASE_ASSERT(reg.offset() &lt; CallFrame::headerSizeInRegisters);
1148 
1149 
1150                 if (inlineCallFrame-&gt;isClosureCall
<span class="line-modified">1151                     &amp;&amp; reg.offset() == CallFrameSlot::callee) {</span>
1152                     if (verbose)
1153                         dataLog(&quot;Looks like a callee.\n&quot;);
1154                     return true;
1155                 }
1156 
1157                 if (inlineCallFrame-&gt;isVarargs()
<span class="line-modified">1158                     &amp;&amp; reg.offset() == CallFrameSlot::argumentCount) {</span>
1159                     if (verbose)
1160                         dataLog(&quot;Looks like the argument count.\n&quot;);
1161                     return true;
1162                 }
1163 
1164                 return false;
1165             }
1166 
1167             if (verbose)
1168                 dataLog(&quot;Asking the bytecode liveness.\n&quot;);
<span class="line-modified">1169             return livenessFor(inlineCallFrame).operandIsLive(reg.offset(), codeOriginPtr-&gt;bytecodeIndex());</span>
<span class="line-modified">1170         }</span>
<span class="line-modified">1171 </span>
<span class="line-modified">1172         if (!inlineCallFrame) {</span>
<span class="line-removed">1173             if (verbose)</span>
<span class="line-removed">1174                 dataLog(&quot;Ran out of stack, returning true.\n&quot;);</span>
<span class="line-removed">1175             return true;</span>
1176         }
1177 
1178         // Arguments are always live. This would be redundant if it wasn&#39;t for our
1179         // op_call_varargs inlining.
<span class="line-modified">1180         if (reg.isArgument()</span>
1181             &amp;&amp; static_cast&lt;size_t&gt;(reg.toArgument()) &lt; inlineCallFrame-&gt;argumentsWithFixup.size()) {
1182             if (verbose)
1183                 dataLog(&quot;Argument is live.\n&quot;);
1184             return true;
1185         }
1186 
<span class="line-modified">1187         // We need to handle tail callers because we may decide to exit to the</span>
<span class="line-removed">1188         // the return bytecode following the tail call.</span>
<span class="line-removed">1189         codeOriginPtr = &amp;inlineCallFrame-&gt;directCaller;</span>
1190     }
1191 
<span class="line-modified">1192     RELEASE_ASSERT_NOT_REACHED();</span>





1193 }
1194 
<span class="line-modified">1195 BitVector Graph::localsLiveInBytecode(CodeOrigin codeOrigin)</span>
1196 {
1197     BitVector result;
<span class="line-modified">1198     result.ensureSize(block(0)-&gt;variablesAtHead.numberOfLocals());</span>
<span class="line-modified">1199     forAllLocalsLiveInBytecode(</span>

1200         codeOrigin,
<span class="line-modified">1201         [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified">1202             ASSERT(reg.isLocal());</span>
<span class="line-modified">1203             result.quickSet(reg.toLocal());</span>
1204         });
1205     return result;
1206 }
1207 
1208 unsigned Graph::parameterSlotsForArgCount(unsigned argCount)
1209 {
1210     size_t frameSize = CallFrame::headerSizeInRegisters + argCount;
1211     size_t alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), frameSize);
1212     return alignedFrameSize - CallerFrameAndPC::sizeInRegisters;
1213 }
1214 
1215 unsigned Graph::frameRegisterCount()
1216 {
1217     unsigned result = m_nextMachineLocal + std::max(m_parameterSlots, static_cast&lt;unsigned&gt;(maxFrameExtentForSlowPathCallInRegisters));
1218     return roundLocalRegisterCountForFramePointerOffset(result);
1219 }
1220 
1221 unsigned Graph::stackPointerOffset()
1222 {
1223     return virtualRegisterForLocal(frameRegisterCount() - 1).offset();
</pre>
<hr />
<pre>
1371     return tryGetConstantClosureVar(value.m_value, offset);
1372 }
1373 
1374 JSValue Graph::tryGetConstantClosureVar(Node* node, ScopeOffset offset)
1375 {
1376     if (!node-&gt;hasConstant())
1377         return JSValue();
1378     return tryGetConstantClosureVar(node-&gt;asJSValue(), offset);
1379 }
1380 
1381 JSArrayBufferView* Graph::tryGetFoldableView(JSValue value)
1382 {
1383     if (!value)
1384         return nullptr;
1385     JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(m_vm, value);
1386     if (!view)
1387         return nullptr;
1388     if (!view-&gt;length())
1389         return nullptr;
1390     WTF::loadLoadFence();

1391     watchpoints().addLazily(view);
1392     return view;
1393 }
1394 
1395 JSArrayBufferView* Graph::tryGetFoldableView(JSValue value, ArrayMode arrayMode)
1396 {
1397     if (arrayMode.type() != Array::AnyTypedArray &amp;&amp; arrayMode.typedArrayType() == NotTypedArray)
1398         return nullptr;
1399     return tryGetFoldableView(value);
1400 }
1401 
1402 void Graph::registerFrozenValues()
1403 {

1404     m_codeBlock-&gt;constants().shrink(0);
1405     m_codeBlock-&gt;constantsSourceCodeRepresentation().resize(0);
1406     for (FrozenValue* value : m_frozenValues) {
1407         if (!value-&gt;pointsToHeap())
1408             continue;
1409 
1410         ASSERT(value-&gt;structure());
1411         ASSERT(m_plan.weakReferences().contains(value-&gt;structure()));
1412 
1413         switch (value-&gt;strength()) {
1414         case WeakValue: {
1415             m_plan.weakReferences().addLazily(value-&gt;value().asCell());
1416             break;
1417         }
1418         case StrongValue: {
<span class="line-modified">1419             unsigned constantIndex = m_codeBlock-&gt;addConstantLazily();</span>
1420             // We already have a barrier on the code block.
1421             m_codeBlock-&gt;constants()[constantIndex].setWithoutWriteBarrier(value-&gt;value());
1422             break;
1423         } }
1424     }
1425     m_codeBlock-&gt;constants().shrinkToFit();
1426     m_codeBlock-&gt;constantsSourceCodeRepresentation().shrinkToFit();
1427 }
1428 
1429 void Graph::visitChildren(SlotVisitor&amp; visitor)
1430 {
1431     for (FrozenValue* value : m_frozenValues) {
1432         visitor.appendUnbarriered(value-&gt;value());
1433         visitor.appendUnbarriered(value-&gt;structure());
1434     }
1435 }
1436 
1437 FrozenValue* Graph::freeze(JSValue value)
1438 {
1439     if (UNLIKELY(!value))
</pre>
<hr />
<pre>
1604 {
1605     RELEASE_ASSERT(m_form == SSA);
1606     if (!m_backwardsDominators)
1607         m_backwardsDominators = makeUnique&lt;BackwardsDominators&gt;(*this);
1608     return *m_backwardsDominators;
1609 }
1610 
1611 ControlEquivalenceAnalysis&amp; Graph::ensureControlEquivalenceAnalysis()
1612 {
1613     RELEASE_ASSERT(m_form == SSA);
1614     if (!m_controlEquivalenceAnalysis)
1615         m_controlEquivalenceAnalysis = makeUnique&lt;ControlEquivalenceAnalysis&gt;(*this);
1616     return *m_controlEquivalenceAnalysis;
1617 }
1618 
1619 MethodOfGettingAValueProfile Graph::methodOfGettingAValueProfileFor(Node* currentNode, Node* operandNode)
1620 {
1621     // This represents IR like `CurrentNode(@operandNode)`. For example: `GetByVal(..., Int32:@GetLocal)`.
1622 
1623     for (Node* node = operandNode; node;) {













1624         // currentNode is null when we&#39;re doing speculation checks for checkArgumentTypes().
1625         if (!currentNode || node-&gt;origin.semantic != currentNode-&gt;origin.semantic || !currentNode-&gt;hasResult()) {
1626             CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);
1627 
1628             if (node-&gt;accessesStack(*this)) {
<span class="line-removed">1629                 if (m_form != SSA &amp;&amp; node-&gt;local().isArgument()) {</span>
<span class="line-removed">1630                     int argument = node-&gt;local().toArgument();</span>
<span class="line-removed">1631                     Node* argumentNode = m_rootToArguments.find(block(0))-&gt;value[argument];</span>
<span class="line-removed">1632                     // FIXME: We should match SetArgumentDefinitely nodes at other entrypoints as well:</span>
<span class="line-removed">1633                     // https://bugs.webkit.org/show_bug.cgi?id=175841</span>
<span class="line-removed">1634                     if (argumentNode &amp;&amp; node-&gt;variableAccessData() == argumentNode-&gt;variableAccessData())</span>
<span class="line-removed">1635                         return &amp;profiledBlock-&gt;valueProfileForArgument(argument);</span>
<span class="line-removed">1636                 }</span>
<span class="line-removed">1637 </span>
1638                 if (node-&gt;op() == GetLocal) {
1639                     return MethodOfGettingAValueProfile::fromLazyOperand(
1640                         profiledBlock,
1641                         LazyOperandValueProfileKey(
<span class="line-modified">1642                             node-&gt;origin.semantic.bytecodeIndex(), node-&gt;local()));</span>
1643                 }
1644             }
1645 
1646             if (node-&gt;hasHeapPrediction())
<span class="line-modified">1647                 return &amp;profiledBlock-&gt;valueProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex());</span>
1648 
1649             if (profiledBlock-&gt;hasBaselineJITProfiling()) {
<span class="line-modified">1650                 if (ArithProfile* result = profiledBlock-&gt;arithProfileForBytecodeOffset(node-&gt;origin.semantic.bytecodeIndex()))</span>


1651                     return result;
1652             }
1653         }
1654 
1655         switch (node-&gt;op()) {
1656         case BooleanToNumber:
1657         case Identity:
1658         case ValueRep:
1659         case DoubleRep:
1660         case Int52Rep:
1661             node = node-&gt;child1().node();
1662             break;
1663         default:
1664             node = nullptr;
1665         }
1666     }
1667 
1668     return MethodOfGettingAValueProfile();
1669 }
1670 
</pre>
<hr />
<pre>
1728     ASSERT(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;classInfo(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;vm()) == StringPrototype::info());
1729 
1730     if (!watchConditions(generateConditionsForPropertyMissConcurrently(m_vm, globalObject, stringObjectStructure, m_vm.propertyNames-&gt;toPrimitiveSymbol.impl())))
1731         return false;
1732 
1733     // We&#39;re being conservative here. We want DFG&#39;s ToString on StringObject to be
1734     // used in both numeric contexts (that would call valueOf()) and string contexts
1735     // (that would call toString()). We don&#39;t want the DFG to have to distinguish
1736     // between the two, just because that seems like it would get confusing. So we
1737     // just require both methods to be sane.
1738     if (!isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;valueOf.impl()))
1739         return false;
1740     return isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;toString.impl());
1741 }
1742 
1743 bool Graph::willCatchExceptionInMachineFrame(CodeOrigin codeOrigin, CodeOrigin&amp; opCatchOriginOut, HandlerInfo*&amp; catchHandlerOut)
1744 {
1745     if (!m_hasExceptionHandlers)
1746         return false;
1747 
<span class="line-modified">1748     unsigned bytecodeIndexToCheck = codeOrigin.bytecodeIndex();</span>
1749     while (1) {
1750         InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame();
1751         CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);
<span class="line-modified">1752         if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeOffset(bytecodeIndexToCheck)) {</span>
<span class="line-modified">1753             opCatchOriginOut = CodeOrigin(handler-&gt;target, inlineCallFrame);</span>
1754             catchHandlerOut = handler;
1755             return true;
1756         }
1757 
1758         if (!inlineCallFrame)
1759             return false;
1760 
1761         bytecodeIndexToCheck = inlineCallFrame-&gt;directCaller.bytecodeIndex();
1762         codeOrigin = inlineCallFrame-&gt;directCaller;
1763     }
1764 
1765     RELEASE_ASSERT_NOT_REACHED();
1766 }
1767 
1768 bool Graph::canDoFastSpread(Node* node, const AbstractValue&amp; value)
1769 {
1770     // The parameter &#39;value&#39; is the AbstractValue for child1 (the thing being spread).
1771     ASSERT(node-&gt;op() == Spread);
1772 
1773     if (node-&gt;child1().useKind() != ArrayUse) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2011-2020 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 168     printWhiteSpace(out, amountOfNodeWhiteSpace(node));
 169 }
 170 
 171 void Graph::dump(PrintStream&amp; out, const char* prefixStr, Node* node, DumpContext* context)
 172 {
 173     Prefix myPrefix(prefixStr);
 174     Prefix&amp; prefix = prefixStr ? myPrefix : m_prefix;
 175 
 176     NodeType op = node-&gt;op();
 177 
 178     unsigned refCount = node-&gt;refCount();
 179     bool mustGenerate = node-&gt;mustGenerate();
 180     if (mustGenerate)
 181         --refCount;
 182 
 183     out.print(prefix);
 184     printNodeWhiteSpace(out, node);
 185 
 186     // Example/explanation of dataflow dump output
 187     //
<span class="line-modified"> 188     //   D@14:   &lt;!2:7&gt;  GetByVal(@3, @13)</span>
<span class="line-modified"> 189     //     ^1     ^2 ^3     ^4       ^5</span>
 190     //
 191     // (1) The nodeIndex of this operation.
 192     // (2) The reference count. The number printed is the &#39;real&#39; count,
 193     //     not including the &#39;mustGenerate&#39; ref. If the node is
 194     //     &#39;mustGenerate&#39; then the count it prefixed with &#39;!&#39;.
 195     // (3) The virtual register slot assigned to this node.
 196     // (4) The name of the operation.
 197     // (5) The arguments to the operation. The may be of the form:
<span class="line-modified"> 198     //         D@#  - a NodeIndex referencing a prior node in the graph.</span>
 199     //         arg# - an argument number.
 200     //         id#  - the index in the CodeBlock of an identifier { if codeBlock is passed to dump(), the string representation is displayed }.
 201     //         var# - the index of a var on the global object, used by GetGlobalVar/GetGlobalLexicalVariable/PutGlobalVariable operations.
<span class="line-modified"> 202     int nodeIndex = node-&gt;index();</span>
<span class="line-added"> 203     const char* prefixPadding = nodeIndex &lt; 10 ? &quot;   &quot; : nodeIndex &lt; 100 ? &quot;  &quot; : &quot; &quot;;</span>
<span class="line-added"> 204     out.printf(&quot;%sD@%d:&lt;%c%u:&quot;, prefixPadding, nodeIndex, mustGenerate ? &#39;!&#39; : &#39; &#39;, refCount);</span>
 205     if (node-&gt;hasResult() &amp;&amp; node-&gt;hasVirtualRegister() &amp;&amp; node-&gt;virtualRegister().isValid())
 206         out.print(node-&gt;virtualRegister());
 207     else
 208         out.print(&quot;-&quot;);
 209     out.print(&quot;&gt;\t&quot;, opName(op), &quot;(&quot;);
 210     CommaPrinter comma;
 211     if (node-&gt;flags() &amp; NodeHasVarArgs) {
 212         for (unsigned childIdx = node-&gt;firstChild(); childIdx &lt; node-&gt;firstChild() + node-&gt;numChildren(); childIdx++) {
 213             if (!m_varArgChildren[childIdx])
 214                 continue;
 215             out.print(comma, m_varArgChildren[childIdx]);
 216         }
 217     } else {
 218         if (!!node-&gt;child1() || !!node-&gt;child2() || !!node-&gt;child3())
 219             out.print(comma, node-&gt;child1());
 220         if (!!node-&gt;child2() || !!node-&gt;child3())
 221             out.print(comma, node-&gt;child2());
 222         if (!!node-&gt;child3())
 223             out.print(comma, node-&gt;child3());
 224     }
</pre>
<hr />
<pre>
 228     if (node-&gt;prediction())
 229         out.print(comma, SpeculationDump(node-&gt;prediction()));
 230     if (node-&gt;hasNumberOfArgumentsToSkip())
 231         out.print(comma, &quot;numberOfArgumentsToSkip = &quot;, node-&gt;numberOfArgumentsToSkip());
 232     if (node-&gt;hasArrayMode())
 233         out.print(comma, node-&gt;arrayMode());
 234     if (node-&gt;hasArithUnaryType())
 235         out.print(comma, &quot;Type:&quot;, node-&gt;arithUnaryType());
 236     if (node-&gt;hasArithMode())
 237         out.print(comma, node-&gt;arithMode());
 238     if (node-&gt;hasArithRoundingMode())
 239         out.print(comma, &quot;Rounding:&quot;, node-&gt;arithRoundingMode());
 240     if (node-&gt;hasScopeOffset())
 241         out.print(comma, node-&gt;scopeOffset());
 242     if (node-&gt;hasDirectArgumentsOffset())
 243         out.print(comma, node-&gt;capturedArgumentsOffset());
 244     if (node-&gt;hasArgumentIndex())
 245         out.print(comma, node-&gt;argumentIndex());
 246     if (node-&gt;hasRegisterPointer())
 247         out.print(comma, &quot;global&quot;, &quot;(&quot;, RawPointer(node-&gt;variablePointer()), &quot;)&quot;);
<span class="line-modified"> 248     if (node-&gt;hasIdentifier() &amp;&amp; node-&gt;identifierNumber() != UINT32_MAX)</span>
 249         out.print(comma, &quot;id&quot;, node-&gt;identifierNumber(), &quot;{&quot;, identifiers()[node-&gt;identifierNumber()], &quot;}&quot;);
 250     if (node-&gt;hasPromotedLocationDescriptor())
 251         out.print(comma, node-&gt;promotedLocationDescriptor());
 252     if (node-&gt;hasClassInfo())
 253         out.print(comma, *node-&gt;classInfo());
 254     if (node-&gt;hasStructureSet())
 255         out.print(comma, inContext(node-&gt;structureSet().toStructureSet(), context));
 256     if (node-&gt;hasStructure())
 257         out.print(comma, inContext(*node-&gt;structure().get(), context));
 258     if (node-&gt;op() == CPUIntrinsic)
 259         out.print(comma, intrinsicName(node-&gt;intrinsic()));
 260     if (node-&gt;hasTransition()) {
 261         out.print(comma, pointerDumpInContext(node-&gt;transition(), context));
 262 #if USE(JSVALUE64)
 263         out.print(&quot;, ID:&quot;, node-&gt;transition()-&gt;next-&gt;id());
 264 #else
 265         out.print(&quot;, ID:&quot;, RawPointer(node-&gt;transition()-&gt;next.get()));
 266 #endif
 267     }
 268     if (node-&gt;hasCellOperand()) {
 269         if (!node-&gt;cellOperand()-&gt;value() || !node-&gt;cellOperand()-&gt;value().isCell())
 270             out.print(comma, &quot;invalid cell operand: &quot;, node-&gt;cellOperand()-&gt;value());
 271         else {
 272             out.print(comma, pointerDump(node-&gt;cellOperand()-&gt;value().asCell()));
 273             if (node-&gt;cellOperand()-&gt;value().isCell()) {
 274                 CallVariant variant(node-&gt;cellOperand()-&gt;value().asCell());
 275                 if (ExecutableBase* executable = variant.executable()) {
 276                     if (executable-&gt;isHostFunction())
 277                         out.print(comma, &quot;&lt;host function&gt;&quot;);
 278                     else if (FunctionExecutable* functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, executable))
 279                         out.print(comma, FunctionExecutableDump(functionExecutable));
 280                     else
 281                         out.print(comma, &quot;&lt;non-function executable&gt;&quot;);
 282                 }
 283             }
 284         }
 285     }
<span class="line-modified"> 286     if (node-&gt;hasQueriedType())</span>
<span class="line-modified"> 287         out.print(comma, node-&gt;queriedType());</span>
 288     if (node-&gt;hasStorageAccessData()) {
 289         StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
 290         out.print(comma, &quot;id&quot;, storageAccessData.identifierNumber, &quot;{&quot;, identifiers()[storageAccessData.identifierNumber], &quot;}&quot;);
 291         out.print(&quot;, &quot;, static_cast&lt;ptrdiff_t&gt;(storageAccessData.offset));
 292     }
 293     if (node-&gt;hasMultiGetByOffsetData()) {
 294         MultiGetByOffsetData&amp; data = node-&gt;multiGetByOffsetData();
 295         out.print(comma, &quot;id&quot;, data.identifierNumber, &quot;{&quot;, identifiers()[data.identifierNumber], &quot;}&quot;);
 296         for (unsigned i = 0; i &lt; data.cases.size(); ++i)
 297             out.print(comma, inContext(data.cases[i], context));
 298     }
 299     if (node-&gt;hasMultiPutByOffsetData()) {
 300         MultiPutByOffsetData&amp; data = node-&gt;multiPutByOffsetData();
 301         out.print(comma, &quot;id&quot;, data.identifierNumber, &quot;{&quot;, identifiers()[data.identifierNumber], &quot;}&quot;);
 302         for (unsigned i = 0; i &lt; data.variants.size(); ++i)
 303             out.print(comma, inContext(data.variants[i], context));
 304     }
 305     if (node-&gt;hasMatchStructureData()) {
 306         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants)
 307             out.print(comma, inContext(*variant.structure.get(), context), &quot;=&gt;&quot;, variant.result);
 308     }
 309     ASSERT(node-&gt;hasVariableAccessData(*this) == node-&gt;accessesStack(*this));
 310     if (node-&gt;hasVariableAccessData(*this)) {
 311         VariableAccessData* variableAccessData = node-&gt;tryGetVariableAccessData();
 312         if (variableAccessData) {
<span class="line-modified"> 313             Operand operand = variableAccessData-&gt;operand();</span>
<span class="line-modified"> 314             out.print(comma, variableAccessData-&gt;operand(), &quot;(&quot;, VariableAccessDataDump(*this, variableAccessData), &quot;)&quot;);</span>
 315             operand = variableAccessData-&gt;machineLocal();
 316             if (operand.isValid())
 317                 out.print(comma, &quot;machine:&quot;, operand);
 318         }
 319     }
 320     if (node-&gt;hasStackAccessData()) {
 321         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified"> 322         out.print(comma, data-&gt;operand);</span>
 323         if (data-&gt;machineLocal.isValid())
 324             out.print(comma, &quot;machine:&quot;, data-&gt;machineLocal);
 325         out.print(comma, data-&gt;format);
 326     }
<span class="line-modified"> 327     if (node-&gt;hasUnlinkedOperand())</span>
<span class="line-modified"> 328         out.print(comma, node-&gt;unlinkedOperand());</span>
 329     if (node-&gt;hasVectorLengthHint())
 330         out.print(comma, &quot;vectorLengthHint = &quot;, node-&gt;vectorLengthHint());
 331     if (node-&gt;hasLazyJSValue())
 332         out.print(comma, node-&gt;lazyJSValue());
 333     if (node-&gt;hasIndexingType())
 334         out.print(comma, IndexingTypeDump(node-&gt;indexingMode()));
 335     if (node-&gt;hasTypedArrayType())
 336         out.print(comma, node-&gt;typedArrayType());
 337     if (node-&gt;hasPhi())
 338         out.print(comma, &quot;^&quot;, node-&gt;phi()-&gt;index());
 339     if (node-&gt;hasExecutionCounter())
 340         out.print(comma, RawPointer(node-&gt;executionCounter()));
 341     if (node-&gt;hasWatchpointSet())
 342         out.print(comma, RawPointer(node-&gt;watchpointSet()));
 343     if (node-&gt;hasStoragePointer())
 344         out.print(comma, RawPointer(node-&gt;storagePointer()));
 345     if (node-&gt;hasObjectMaterializationData())
 346         out.print(comma, node-&gt;objectMaterializationData());
 347     if (node-&gt;hasCallVarargsData())
 348         out.print(comma, &quot;firstVarArgOffset = &quot;, node-&gt;callVarargsData()-&gt;firstVarArgOffset);
 349     if (node-&gt;hasLoadVarargsData()) {
 350         LoadVarargsData* data = node-&gt;loadVarargsData();
 351         out.print(comma, &quot;start = &quot;, data-&gt;start, &quot;, count = &quot;, data-&gt;count);
 352         if (data-&gt;machineStart.isValid())
 353             out.print(&quot;, machineStart = &quot;, data-&gt;machineStart);
 354         if (data-&gt;machineCount.isValid())
 355             out.print(&quot;, machineCount = &quot;, data-&gt;machineCount);
 356         out.print(&quot;, offset = &quot;, data-&gt;offset, &quot;, mandatoryMinimum = &quot;, data-&gt;mandatoryMinimum);
 357         out.print(&quot;, limit = &quot;, data-&gt;limit);
 358     }
<span class="line-added"> 359     if (node-&gt;hasIsInternalPromise())</span>
<span class="line-added"> 360         out.print(comma, &quot;isInternalPromise = &quot;, node-&gt;isInternalPromise());</span>
<span class="line-added"> 361     if (node-&gt;hasInternalFieldIndex())</span>
<span class="line-added"> 362         out.print(comma, &quot;internalFieldIndex = &quot;, node-&gt;internalFieldIndex());</span>
 363     if (node-&gt;hasCallDOMGetterData()) {
 364         CallDOMGetterData* data = node-&gt;callDOMGetterData();
 365         out.print(comma, &quot;id&quot;, data-&gt;identifierNumber, &quot;{&quot;, identifiers()[data-&gt;identifierNumber], &quot;}&quot;);
 366         out.print(&quot;, domJIT = &quot;, RawPointer(data-&gt;domJIT));
 367     }
 368     if (node-&gt;hasIgnoreLastIndexIsWritable())
 369         out.print(comma, &quot;ignoreLastIndexIsWritable = &quot;, node-&gt;ignoreLastIndexIsWritable());
<span class="line-added"> 370     if (node-&gt;hasIntrinsic())</span>
<span class="line-added"> 371         out.print(comma, &quot;intrinsic = &quot;, node-&gt;intrinsic());</span>
 372     if (node-&gt;isConstant())
 373         out.print(comma, pointerDumpInContext(node-&gt;constant(), context));
 374     if (node-&gt;hasCallLinkStatus())
 375         out.print(comma, *node-&gt;callLinkStatus());
<span class="line-modified"> 376     if (node-&gt;hasGetByStatus())</span>
<span class="line-modified"> 377         out.print(comma, *node-&gt;getByStatus());</span>
 378     if (node-&gt;hasInByIdStatus())
 379         out.print(comma, *node-&gt;inByIdStatus());
 380     if (node-&gt;hasPutByIdStatus())
 381         out.print(comma, *node-&gt;putByIdStatus());
 382     if (node-&gt;isJump())
 383         out.print(comma, &quot;T:&quot;, *node-&gt;targetBlock());
 384     if (node-&gt;isBranch())
 385         out.print(comma, &quot;T:&quot;, node-&gt;branchData()-&gt;taken, &quot;, F:&quot;, node-&gt;branchData()-&gt;notTaken);
 386     if (node-&gt;isSwitch()) {
 387         SwitchData* data = node-&gt;switchData();
 388         out.print(comma, data-&gt;kind);
 389         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 390             out.print(comma, inContext(data-&gt;cases[i].value, context), &quot;:&quot;, data-&gt;cases[i].target);
 391         out.print(comma, &quot;default:&quot;, data-&gt;fallThrough);
 392     }
 393     if (node-&gt;isEntrySwitch()) {
 394         EntrySwitchData* data = node-&gt;entrySwitchData();
 395         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i)
 396             out.print(comma, BranchTarget(data-&gt;cases[i]));
 397     }
 398     ClobberSet reads;
 399     ClobberSet writes;
 400     addReadsAndWrites(*this, node, reads, writes);
 401     if (!reads.isEmpty())
 402         out.print(comma, &quot;R:&quot;, sortedListDump(reads.direct(), &quot;,&quot;));
 403     if (!writes.isEmpty())
 404         out.print(comma, &quot;W:&quot;, sortedListDump(writes.direct(), &quot;,&quot;));
 405     ExitMode exitMode = mayExit(*this, node);
 406     if (exitMode != DoesNotExit)
 407         out.print(comma, exitMode);
 408     if (clobbersExitState(*this, node))
 409         out.print(comma, &quot;ClobbersExit&quot;);
 410     if (node-&gt;origin.isSet()) {
<span class="line-modified"> 411         out.print(comma, node-&gt;origin.semantic.bytecodeIndex());</span>
 412         if (node-&gt;origin.semantic != node-&gt;origin.forExit &amp;&amp; node-&gt;origin.forExit.isSet())
 413             out.print(comma, &quot;exit: &quot;, node-&gt;origin.forExit);
 414     }
 415     out.print(comma, node-&gt;origin.exitOK ? &quot;ExitValid&quot; : &quot;ExitInvalid&quot;);
 416     if (node-&gt;origin.wasHoisted)
 417         out.print(comma, &quot;WasHoisted&quot;);
 418     out.print(&quot;)&quot;);
 419 
 420     if (node-&gt;accessesStack(*this) &amp;&amp; node-&gt;tryGetVariableAccessData())
 421         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;tryGetVariableAccessData()-&gt;prediction()));
 422     else if (node-&gt;hasHeapPrediction())
 423         out.print(&quot;  predicting &quot;, SpeculationDump(node-&gt;getHeapPrediction()));
 424 
 425     out.print(&quot;\n&quot;);
 426 }
 427 
 428 bool Graph::terminalsAreValid()
 429 {
 430     for (BasicBlock* block : blocksInNaturalOrder()) {
 431         if (!block-&gt;terminal())
</pre>
<hr />
<pre>
 500         }
 501 
 502         auto containingLoops = naturalLoops-&gt;loopsOf(block);
 503         if (!containingLoops.isEmpty()) {
 504             out.print(prefix, &quot;  Containing loop headers:&quot;);
 505             for (unsigned i = 0; i &lt; containingLoops.size(); ++i)
 506                 out.print(&quot; &quot;, *unboxLoopNode(containingLoops[i]-&gt;header()));
 507             out.print(&quot;\n&quot;);
 508         }
 509     };
 510 
 511     if (m_ssaNaturalLoops)
 512         printNaturalLoops(m_ssaNaturalLoops);
 513     else if (m_cpsNaturalLoops)
 514         printNaturalLoops(m_cpsNaturalLoops);
 515 
 516     if (!block-&gt;phis.isEmpty()) {
 517         out.print(prefix, &quot;  Phi Nodes:&quot;);
 518         for (size_t i = 0; i &lt; block-&gt;phis.size(); ++i) {
 519             Node* phiNode = block-&gt;phis[i];
<span class="line-added"> 520             ASSERT(phiNode-&gt;op() == Phi);</span>
 521             if (!phiNode-&gt;shouldGenerate() &amp;&amp; phiNodeDumpMode == DumpLivePhisOnly)
 522                 continue;
<span class="line-modified"> 523             out.print(&quot; D@&quot;, phiNode-&gt;index(), &quot;&lt;&quot;, phiNode-&gt;operand(), &quot;,&quot;, phiNode-&gt;refCount(), &quot;&gt;-&gt;(&quot;);</span>
 524             if (phiNode-&gt;child1()) {
<span class="line-modified"> 525                 out.print(&quot;D@&quot;, phiNode-&gt;child1()-&gt;index());</span>
 526                 if (phiNode-&gt;child2()) {
<span class="line-modified"> 527                     out.print(&quot;, D@&quot;, phiNode-&gt;child2()-&gt;index());</span>
 528                     if (phiNode-&gt;child3())
<span class="line-modified"> 529                         out.print(&quot;, D@&quot;, phiNode-&gt;child3()-&gt;index());</span>
 530                 }
 531             }
 532             out.print(&quot;)&quot;, i + 1 &lt; block-&gt;phis.size() ? &quot;,&quot; : &quot;&quot;);
 533         }
 534         out.print(&quot;\n&quot;);
 535     }
 536 }
 537 
 538 void Graph::dump(PrintStream&amp; out, DumpContext* context)
 539 {
 540     Prefix&amp; prefix = m_prefix;
 541     DumpContext myContext;
 542     myContext.graph = this;
 543     if (!context)
 544         context = &amp;myContext;
 545 
 546     out.print(&quot;\n&quot;);
 547     out.print(prefix, &quot;DFG for &quot;, CodeBlockWithJITType(m_codeBlock, JITType::DFGJIT), &quot;:\n&quot;);
 548     out.print(prefix, &quot;  Fixpoint state: &quot;, m_fixpointState, &quot;; Form: &quot;, m_form, &quot;; Unification state: &quot;, m_unificationState, &quot;; Ref count state: &quot;, m_refCountState, &quot;\n&quot;);
 549     if (m_form == SSA) {
 550         for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_argumentFormats.size(); ++entrypointIndex)
 551             out.print(prefix, &quot;  Argument formats for entrypoint index: &quot;, entrypointIndex, &quot; : &quot;, listDump(m_argumentFormats[entrypointIndex]), &quot;\n&quot;);
 552     }
 553     else {
<span class="line-modified"> 554         for (const auto&amp; pair : m_rootToArguments)</span>
 555             out.print(prefix, &quot;  Arguments for block#&quot;, pair.key-&gt;index, &quot;: &quot;, listDump(pair.value), &quot;\n&quot;);
 556     }
 557     out.print(&quot;\n&quot;);
 558 
 559     Node* lastNode = nullptr;
 560     for (size_t b = 0; b &lt; m_blocks.size(); ++b) {
 561         BasicBlock* block = m_blocks[b].get();
 562         if (!block)
 563             continue;
 564         prefix.blockIndex = block-&gt;index;
 565         dumpBlockHeader(out, Prefix::noString, block, DumpAllPhis, context);
 566         out.print(prefix, &quot;  States: &quot;, block-&gt;cfaStructureClobberStateAtHead);
 567         if (!block-&gt;cfaHasVisited)
 568             out.print(&quot;, CurrentlyCFAUnreachable&quot;);
 569         if (!block-&gt;intersectionOfCFAHasVisited)
 570             out.print(&quot;, CFAUnreachable&quot;);
 571         out.print(&quot;\n&quot;);
 572         switch (m_form) {
 573         case LoadStore:
 574         case ThreadedCPS: {
</pre>
<hr />
<pre>
 870     m_backwardsCFG = nullptr;
 871     m_cpsCFG = nullptr;
 872 }
 873 
 874 void Graph::invalidateNodeLiveness()
 875 {
 876     if (m_form != SSA)
 877         return;
 878 
 879     for (BasicBlock* block : blocksInNaturalOrder())
 880         block-&gt;ssa-&gt;invalidate();
 881 }
 882 
 883 void Graph::substituteGetLocal(BasicBlock&amp; block, unsigned startIndexInBlock, VariableAccessData* variableAccessData, Node* newGetLocal)
 884 {
 885     for (unsigned indexInBlock = startIndexInBlock; indexInBlock &lt; block.size(); ++indexInBlock) {
 886         Node* node = block[indexInBlock];
 887         bool shouldContinue = true;
 888         switch (node-&gt;op()) {
 889         case SetLocal: {
<span class="line-modified"> 890             if (node-&gt;operand() == variableAccessData-&gt;operand())</span>
 891                 shouldContinue = false;
 892             break;
 893         }
 894 
 895         case GetLocal: {
 896             if (node-&gt;variableAccessData() != variableAccessData)
 897                 continue;
 898             substitute(block, indexInBlock, node, newGetLocal);
<span class="line-modified"> 899             Node* oldTailNode = block.variablesAtTail.operand(variableAccessData-&gt;operand());</span>
 900             if (oldTailNode == node)
<span class="line-modified"> 901                 block.variablesAtTail.operand(variableAccessData-&gt;operand()) = newGetLocal;</span>
 902             shouldContinue = false;
 903             break;
 904         }
 905 
 906         default:
 907             break;
 908         }
 909         if (!shouldContinue)
 910             break;
 911     }
 912 }
 913 
 914 BlockList Graph::blocksInPreOrder()
 915 {
 916     BlockList result;
 917     result.reserveInitialCapacity(m_blocks.size());
 918     BlockWorklist worklist;
 919     for (BasicBlock* entrypoint : m_roots)
 920         worklist.push(entrypoint);
 921     while (BasicBlock* block = worklist.pop()) {
</pre>
<hr />
<pre>
1119 }
1120 
1121 BytecodeKills&amp; Graph::killsFor(CodeBlock* codeBlock)
1122 {
1123     HashMap&lt;CodeBlock*, std::unique_ptr&lt;BytecodeKills&gt;&gt;::iterator iter = m_bytecodeKills.find(codeBlock);
1124     if (iter != m_bytecodeKills.end())
1125         return *iter-&gt;value;
1126 
1127     std::unique_ptr&lt;BytecodeKills&gt; kills = makeUnique&lt;BytecodeKills&gt;();
1128     codeBlock-&gt;livenessAnalysis().computeKills(codeBlock, *kills);
1129     BytecodeKills&amp; result = *kills;
1130     m_bytecodeKills.add(codeBlock, WTFMove(kills));
1131     return result;
1132 }
1133 
1134 BytecodeKills&amp; Graph::killsFor(InlineCallFrame* inlineCallFrame)
1135 {
1136     return killsFor(baselineCodeBlockFor(inlineCallFrame));
1137 }
1138 
<span class="line-modified">1139 bool Graph::isLiveInBytecode(Operand operand, CodeOrigin codeOrigin)</span>
1140 {
<span class="line-modified">1141     static constexpr bool verbose = false;</span>
1142 
1143     if (verbose)
1144         dataLog(&quot;Checking of operand is live: &quot;, operand, &quot;\n&quot;);
<span class="line-added">1145     bool isCallerOrigin = false;</span>
<span class="line-added">1146 </span>
1147     CodeOrigin* codeOriginPtr = &amp;codeOrigin;
<span class="line-modified">1148     auto* inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
<span class="line-modified">1149     // We need to handle tail callers because we may decide to exit to the</span>
<span class="line-modified">1150     // the return bytecode following the tail call.</span>
<span class="line-added">1151     for (; codeOriginPtr; codeOriginPtr = inlineCallFrame ? &amp;inlineCallFrame-&gt;directCaller : nullptr) {</span>
<span class="line-added">1152         inlineCallFrame = codeOriginPtr-&gt;inlineCallFrame();</span>
<span class="line-added">1153         if (operand.isTmp()) {</span>
<span class="line-added">1154             unsigned tmpOffset = inlineCallFrame ? inlineCallFrame-&gt;tmpOffset : 0;</span>
<span class="line-added">1155             unsigned operandIndex = static_cast&lt;unsigned&gt;(operand.value());</span>
<span class="line-added">1156 </span>
<span class="line-added">1157             ASSERT(operand.value() &gt;= 0);</span>
<span class="line-added">1158             // This tmp should have belonged to someone we inlined.</span>
<span class="line-added">1159             if (operandIndex &gt; tmpOffset + maxNumCheckpointTmps)</span>
<span class="line-added">1160                 return false;</span>
<span class="line-added">1161 </span>
<span class="line-added">1162             CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);</span>
<span class="line-added">1163             if (!codeBlock-&gt;numTmps() || operandIndex &lt; tmpOffset)</span>
<span class="line-added">1164                 continue;</span>
<span class="line-added">1165 </span>
<span class="line-added">1166             auto bitMap = tmpLivenessForCheckpoint(*codeBlock, codeOriginPtr-&gt;bytecodeIndex());</span>
<span class="line-added">1167             return bitMap.get(operandIndex - tmpOffset);</span>
<span class="line-added">1168         }</span>
<span class="line-added">1169 </span>
<span class="line-added">1170         VirtualRegister reg = operand.virtualRegister() - codeOriginPtr-&gt;stackOffset();</span>
1171 
1172         if (verbose)
1173             dataLog(&quot;reg = &quot;, reg, &quot;\n&quot;);
1174 
<span class="line-modified">1175         if (operand.virtualRegister().offset() &lt; codeOriginPtr-&gt;stackOffset() + CallFrame::headerSizeInRegisters) {</span>

1176             if (reg.isArgument()) {
1177                 RELEASE_ASSERT(reg.offset() &lt; CallFrame::headerSizeInRegisters);
1178 
1179 
1180                 if (inlineCallFrame-&gt;isClosureCall
<span class="line-modified">1181                     &amp;&amp; reg == CallFrameSlot::callee) {</span>
1182                     if (verbose)
1183                         dataLog(&quot;Looks like a callee.\n&quot;);
1184                     return true;
1185                 }
1186 
1187                 if (inlineCallFrame-&gt;isVarargs()
<span class="line-modified">1188                     &amp;&amp; reg == CallFrameSlot::argumentCountIncludingThis) {</span>
1189                     if (verbose)
1190                         dataLog(&quot;Looks like the argument count.\n&quot;);
1191                     return true;
1192                 }
1193 
1194                 return false;
1195             }
1196 
1197             if (verbose)
1198                 dataLog(&quot;Asking the bytecode liveness.\n&quot;);
<span class="line-modified">1199             CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);</span>
<span class="line-modified">1200             FullBytecodeLiveness&amp; fullLiveness = livenessFor(codeBlock);</span>
<span class="line-modified">1201             BytecodeIndex bytecodeIndex = codeOriginPtr-&gt;bytecodeIndex();</span>
<span class="line-modified">1202             return fullLiveness.virtualRegisterIsLive(reg, bytecodeIndex, appropriateLivenessCalculationPoint(*codeOriginPtr, isCallerOrigin));</span>



1203         }
1204 
1205         // Arguments are always live. This would be redundant if it wasn&#39;t for our
1206         // op_call_varargs inlining.
<span class="line-modified">1207         if (inlineCallFrame &amp;&amp; reg.isArgument()</span>
1208             &amp;&amp; static_cast&lt;size_t&gt;(reg.toArgument()) &lt; inlineCallFrame-&gt;argumentsWithFixup.size()) {
1209             if (verbose)
1210                 dataLog(&quot;Argument is live.\n&quot;);
1211             return true;
1212         }
1213 
<span class="line-modified">1214         isCallerOrigin = true;</span>


1215     }
1216 
<span class="line-modified">1217     if (operand.isTmp())</span>
<span class="line-added">1218         return false;</span>
<span class="line-added">1219 </span>
<span class="line-added">1220     if (verbose)</span>
<span class="line-added">1221         dataLog(&quot;Ran out of stack, returning true.\n&quot;);</span>
<span class="line-added">1222     return true;</span>
1223 }
1224 
<span class="line-modified">1225 BitVector Graph::localsAndTmpsLiveInBytecode(CodeOrigin codeOrigin)</span>
1226 {
1227     BitVector result;
<span class="line-modified">1228     unsigned numLocals = block(0)-&gt;variablesAtHead.numberOfLocals();</span>
<span class="line-modified">1229     result.ensureSize(numLocals + block(0)-&gt;variablesAtHead.numberOfTmps());</span>
<span class="line-added">1230     forAllLocalsAndTmpsLiveInBytecode(</span>
1231         codeOrigin,
<span class="line-modified">1232         [&amp;] (Operand operand) {</span>
<span class="line-modified">1233             unsigned offset = operand.isTmp() ? numLocals + operand.value() : operand.toLocal();</span>
<span class="line-modified">1234             result.quickSet(offset);</span>
1235         });
1236     return result;
1237 }
1238 
1239 unsigned Graph::parameterSlotsForArgCount(unsigned argCount)
1240 {
1241     size_t frameSize = CallFrame::headerSizeInRegisters + argCount;
1242     size_t alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), frameSize);
1243     return alignedFrameSize - CallerFrameAndPC::sizeInRegisters;
1244 }
1245 
1246 unsigned Graph::frameRegisterCount()
1247 {
1248     unsigned result = m_nextMachineLocal + std::max(m_parameterSlots, static_cast&lt;unsigned&gt;(maxFrameExtentForSlowPathCallInRegisters));
1249     return roundLocalRegisterCountForFramePointerOffset(result);
1250 }
1251 
1252 unsigned Graph::stackPointerOffset()
1253 {
1254     return virtualRegisterForLocal(frameRegisterCount() - 1).offset();
</pre>
<hr />
<pre>
1402     return tryGetConstantClosureVar(value.m_value, offset);
1403 }
1404 
1405 JSValue Graph::tryGetConstantClosureVar(Node* node, ScopeOffset offset)
1406 {
1407     if (!node-&gt;hasConstant())
1408         return JSValue();
1409     return tryGetConstantClosureVar(node-&gt;asJSValue(), offset);
1410 }
1411 
1412 JSArrayBufferView* Graph::tryGetFoldableView(JSValue value)
1413 {
1414     if (!value)
1415         return nullptr;
1416     JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(m_vm, value);
1417     if (!view)
1418         return nullptr;
1419     if (!view-&gt;length())
1420         return nullptr;
1421     WTF::loadLoadFence();
<span class="line-added">1422     freeze(view);</span>
1423     watchpoints().addLazily(view);
1424     return view;
1425 }
1426 
1427 JSArrayBufferView* Graph::tryGetFoldableView(JSValue value, ArrayMode arrayMode)
1428 {
1429     if (arrayMode.type() != Array::AnyTypedArray &amp;&amp; arrayMode.typedArrayType() == NotTypedArray)
1430         return nullptr;
1431     return tryGetFoldableView(value);
1432 }
1433 
1434 void Graph::registerFrozenValues()
1435 {
<span class="line-added">1436     ConcurrentJSLocker locker(m_codeBlock-&gt;m_lock);</span>
1437     m_codeBlock-&gt;constants().shrink(0);
1438     m_codeBlock-&gt;constantsSourceCodeRepresentation().resize(0);
1439     for (FrozenValue* value : m_frozenValues) {
1440         if (!value-&gt;pointsToHeap())
1441             continue;
1442 
1443         ASSERT(value-&gt;structure());
1444         ASSERT(m_plan.weakReferences().contains(value-&gt;structure()));
1445 
1446         switch (value-&gt;strength()) {
1447         case WeakValue: {
1448             m_plan.weakReferences().addLazily(value-&gt;value().asCell());
1449             break;
1450         }
1451         case StrongValue: {
<span class="line-modified">1452             unsigned constantIndex = m_codeBlock-&gt;addConstantLazily(locker);</span>
1453             // We already have a barrier on the code block.
1454             m_codeBlock-&gt;constants()[constantIndex].setWithoutWriteBarrier(value-&gt;value());
1455             break;
1456         } }
1457     }
1458     m_codeBlock-&gt;constants().shrinkToFit();
1459     m_codeBlock-&gt;constantsSourceCodeRepresentation().shrinkToFit();
1460 }
1461 
1462 void Graph::visitChildren(SlotVisitor&amp; visitor)
1463 {
1464     for (FrozenValue* value : m_frozenValues) {
1465         visitor.appendUnbarriered(value-&gt;value());
1466         visitor.appendUnbarriered(value-&gt;structure());
1467     }
1468 }
1469 
1470 FrozenValue* Graph::freeze(JSValue value)
1471 {
1472     if (UNLIKELY(!value))
</pre>
<hr />
<pre>
1637 {
1638     RELEASE_ASSERT(m_form == SSA);
1639     if (!m_backwardsDominators)
1640         m_backwardsDominators = makeUnique&lt;BackwardsDominators&gt;(*this);
1641     return *m_backwardsDominators;
1642 }
1643 
1644 ControlEquivalenceAnalysis&amp; Graph::ensureControlEquivalenceAnalysis()
1645 {
1646     RELEASE_ASSERT(m_form == SSA);
1647     if (!m_controlEquivalenceAnalysis)
1648         m_controlEquivalenceAnalysis = makeUnique&lt;ControlEquivalenceAnalysis&gt;(*this);
1649     return *m_controlEquivalenceAnalysis;
1650 }
1651 
1652 MethodOfGettingAValueProfile Graph::methodOfGettingAValueProfileFor(Node* currentNode, Node* operandNode)
1653 {
1654     // This represents IR like `CurrentNode(@operandNode)`. For example: `GetByVal(..., Int32:@GetLocal)`.
1655 
1656     for (Node* node = operandNode; node;) {
<span class="line-added">1657         if (node-&gt;accessesStack(*this)) {</span>
<span class="line-added">1658             if (m_form != SSA &amp;&amp; node-&gt;operand().isArgument()) {</span>
<span class="line-added">1659                 int argument = node-&gt;operand().toArgument();</span>
<span class="line-added">1660                 Node* argumentNode = m_rootToArguments.find(block(0))-&gt;value[argument];</span>
<span class="line-added">1661                 // FIXME: We should match SetArgumentDefinitely nodes at other entrypoints as well:</span>
<span class="line-added">1662                 // https://bugs.webkit.org/show_bug.cgi?id=175841</span>
<span class="line-added">1663                 if (argumentNode &amp;&amp; node-&gt;variableAccessData() == argumentNode-&gt;variableAccessData()) {</span>
<span class="line-added">1664                     CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);</span>
<span class="line-added">1665                     return &amp;profiledBlock-&gt;valueProfileForArgument(argument);</span>
<span class="line-added">1666                 }</span>
<span class="line-added">1667             }</span>
<span class="line-added">1668         }</span>
<span class="line-added">1669 </span>
1670         // currentNode is null when we&#39;re doing speculation checks for checkArgumentTypes().
1671         if (!currentNode || node-&gt;origin.semantic != currentNode-&gt;origin.semantic || !currentNode-&gt;hasResult()) {
1672             CodeBlock* profiledBlock = baselineCodeBlockFor(node-&gt;origin.semantic);
1673 
1674             if (node-&gt;accessesStack(*this)) {









1675                 if (node-&gt;op() == GetLocal) {
1676                     return MethodOfGettingAValueProfile::fromLazyOperand(
1677                         profiledBlock,
1678                         LazyOperandValueProfileKey(
<span class="line-modified">1679                             node-&gt;origin.semantic.bytecodeIndex(), node-&gt;operand()));</span>
1680                 }
1681             }
1682 
1683             if (node-&gt;hasHeapPrediction())
<span class="line-modified">1684                 return &amp;profiledBlock-&gt;valueProfileForBytecodeIndex(node-&gt;origin.semantic.bytecodeIndex());</span>
1685 
1686             if (profiledBlock-&gt;hasBaselineJITProfiling()) {
<span class="line-modified">1687                 if (BinaryArithProfile* result = profiledBlock-&gt;binaryArithProfileForBytecodeIndex(node-&gt;origin.semantic.bytecodeIndex()))</span>
<span class="line-added">1688                     return result;</span>
<span class="line-added">1689                 if (UnaryArithProfile* result = profiledBlock-&gt;unaryArithProfileForBytecodeIndex(node-&gt;origin.semantic.bytecodeIndex()))</span>
1690                     return result;
1691             }
1692         }
1693 
1694         switch (node-&gt;op()) {
1695         case BooleanToNumber:
1696         case Identity:
1697         case ValueRep:
1698         case DoubleRep:
1699         case Int52Rep:
1700             node = node-&gt;child1().node();
1701             break;
1702         default:
1703             node = nullptr;
1704         }
1705     }
1706 
1707     return MethodOfGettingAValueProfile();
1708 }
1709 
</pre>
<hr />
<pre>
1767     ASSERT(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;classInfo(stringObjectStructure-&gt;storedPrototype().asCell()-&gt;vm()) == StringPrototype::info());
1768 
1769     if (!watchConditions(generateConditionsForPropertyMissConcurrently(m_vm, globalObject, stringObjectStructure, m_vm.propertyNames-&gt;toPrimitiveSymbol.impl())))
1770         return false;
1771 
1772     // We&#39;re being conservative here. We want DFG&#39;s ToString on StringObject to be
1773     // used in both numeric contexts (that would call valueOf()) and string contexts
1774     // (that would call toString()). We don&#39;t want the DFG to have to distinguish
1775     // between the two, just because that seems like it would get confusing. So we
1776     // just require both methods to be sane.
1777     if (!isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;valueOf.impl()))
1778         return false;
1779     return isStringPrototypeMethodSane(globalObject, m_vm.propertyNames-&gt;toString.impl());
1780 }
1781 
1782 bool Graph::willCatchExceptionInMachineFrame(CodeOrigin codeOrigin, CodeOrigin&amp; opCatchOriginOut, HandlerInfo*&amp; catchHandlerOut)
1783 {
1784     if (!m_hasExceptionHandlers)
1785         return false;
1786 
<span class="line-modified">1787     BytecodeIndex bytecodeIndexToCheck = codeOrigin.bytecodeIndex();</span>
1788     while (1) {
1789         InlineCallFrame* inlineCallFrame = codeOrigin.inlineCallFrame();
1790         CodeBlock* codeBlock = baselineCodeBlockFor(inlineCallFrame);
<span class="line-modified">1791         if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeIndex(bytecodeIndexToCheck)) {</span>
<span class="line-modified">1792             opCatchOriginOut = CodeOrigin(BytecodeIndex(handler-&gt;target), inlineCallFrame);</span>
1793             catchHandlerOut = handler;
1794             return true;
1795         }
1796 
1797         if (!inlineCallFrame)
1798             return false;
1799 
1800         bytecodeIndexToCheck = inlineCallFrame-&gt;directCaller.bytecodeIndex();
1801         codeOrigin = inlineCallFrame-&gt;directCaller;
1802     }
1803 
1804     RELEASE_ASSERT_NOT_REACHED();
1805 }
1806 
1807 bool Graph::canDoFastSpread(Node* node, const AbstractValue&amp; value)
1808 {
1809     // The parameter &#39;value&#39; is the AbstractValue for child1 (the thing being spread).
1810     ASSERT(node-&gt;op() == Spread);
1811 
1812     if (node-&gt;child1().useKind() != ArrayUse) {
</pre>
</td>
</tr>
</table>
<center><a href="DFGForAllKills.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGGraph.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
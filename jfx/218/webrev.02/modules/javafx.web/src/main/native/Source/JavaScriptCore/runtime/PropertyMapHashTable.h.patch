diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyMapHashTable.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyMapHashTable.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyMapHashTable.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyMapHashTable.h
@@ -1,7 +1,7 @@
 /*
- *  Copyright (C) 2004, 2005, 2006, 2007, 2008, 2014 Apple Inc. All rights reserved.
+ *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Library General Public
  *  License as published by the Free Software Foundation; either
  *  version 2 of the License, or (at your option) any later version.
@@ -35,10 +35,12 @@
 
 #define PROPERTY_MAP_DELETED_ENTRY_KEY ((UniquedStringImpl*)1)
 
 namespace JSC {
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PropertyTable);
+
 #if DUMP_PROPERTYMAP_STATS
 
 struct PropertyMapHashTableStats {
     std::atomic<unsigned> numFinds;
     std::atomic<unsigned> numCollisions;
@@ -119,19 +121,19 @@
         T* m_endValuePtr;
     };
 
 public:
     typedef JSCell Base;
-    static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
 
     template<typename CellType, SubspaceAccess>
     static IsoSubspace* subspaceFor(VM& vm)
     {
         return &vm.propertyTableSpace;
     }
 
-    static const bool needsDestruction = true;
+    static constexpr bool needsDestruction = true;
     static void destroy(JSCell*);
 
     DECLARE_EXPORT_INFO;
 
     static Structure* createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
@@ -165,12 +167,11 @@
 
     // Find a value in the table.
     find_iterator find(const KeyType&);
     ValueType* get(const KeyType&);
     // Add a value to the table
-    enum EffectOnPropertyOffset { PropertyOffsetMayChange, PropertyOffsetMustNotChange };
-    std::pair<find_iterator, bool> add(const ValueType& entry, PropertyOffset&, EffectOnPropertyOffset);
+    std::pair<find_iterator, bool> WARN_UNUSED_RETURN add(const ValueType& entry);
     // Remove a value from the table.
     void remove(const find_iterator& iter);
     void remove(const KeyType& key);
 
     // Returns the number of values in the hashtable.
@@ -200,11 +201,11 @@
 
     static ptrdiff_t offsetOfIndexSize() { return OBJECT_OFFSETOF(PropertyTable, m_indexSize); }
     static ptrdiff_t offsetOfIndexMask() { return OBJECT_OFFSETOF(PropertyTable, m_indexMask); }
     static ptrdiff_t offsetOfIndex() { return OBJECT_OFFSETOF(PropertyTable, m_index); }
 
-    static const unsigned EmptyEntryIndex = 0;
+    static constexpr unsigned EmptyEntryIndex = 0;
 
 private:
     PropertyTable(VM&, unsigned initialCapacity);
     PropertyTable(VM&, const PropertyTable&);
     PropertyTable(VM&, unsigned initialCapacity, const PropertyTable&);
@@ -256,11 +257,11 @@
     unsigned* m_index;
     unsigned m_keyCount;
     unsigned m_deletedCount;
     std::unique_ptr<Vector<PropertyOffset>> m_deletedOffsets;
 
-    static const unsigned MinimumTableSize = 16;
+    static constexpr unsigned MinimumTableSize = 16;
 };
 
 inline PropertyTable::iterator PropertyTable::begin()
 {
     auto* tableEnd = this->tableEnd();
@@ -317,10 +318,11 @@
 
 inline PropertyTable::ValueType* PropertyTable::get(const KeyType& key)
 {
     ASSERT(key);
     ASSERT(key->isAtom() || key->isSymbol());
+    ASSERT(key != PROPERTY_MAP_DELETED_ENTRY_KEY);
 
     if (!m_keyCount)
         return nullptr;
 
     unsigned hash = IdentifierRepHash::hash(key);
@@ -331,29 +333,31 @@
 
     while (true) {
         unsigned entryIndex = m_index[hash & m_indexMask];
         if (entryIndex == EmptyEntryIndex)
             return nullptr;
-        if (key == table()[entryIndex - 1].key)
+        if (key == table()[entryIndex - 1].key) {
+            ASSERT(!m_deletedOffsets || !m_deletedOffsets->contains(table()[entryIndex - 1].offset));
             return &table()[entryIndex - 1];
+        }
 
 #if DUMP_PROPERTYMAP_STATS
         ++propertyMapHashTableStats->numLookupProbing;
 #endif
 
         hash++;
     }
 }
 
-inline std::pair<PropertyTable::find_iterator, bool> PropertyTable::add(const ValueType& entry, PropertyOffset& offset, EffectOnPropertyOffset offsetEffect)
+inline std::pair<PropertyTable::find_iterator, bool> WARN_UNUSED_RETURN PropertyTable::add(const ValueType& entry)
 {
+    ASSERT(!m_deletedOffsets || !m_deletedOffsets->contains(entry.offset));
+
     // Look for a value with a matching key already in the array.
     find_iterator iter = find(entry.key);
-    if (iter.first) {
-        RELEASE_ASSERT(iter.first->offset <= offset);
+    if (iter.first)
         return std::make_pair(iter, false);
-    }
 
 #if DUMP_PROPERTYMAP_STATS
     ++propertyMapHashTableStats->numAdds;
 #endif
 
@@ -373,15 +377,10 @@
     iter.first = &table()[entryIndex - 1];
     *iter.first = entry;
 
     ++m_keyCount;
 
-    if (offsetEffect == PropertyOffsetMayChange)
-        offset = std::max(offset, entry.offset);
-    else
-        RELEASE_ASSERT(offset >= entry.offset);
-
     return std::make_pair(iter, true);
 }
 
 inline void PropertyTable::remove(const find_iterator& iter)
 {
@@ -447,10 +446,11 @@
 
 inline void PropertyTable::addDeletedOffset(PropertyOffset offset)
 {
     if (!m_deletedOffsets)
         m_deletedOffsets = makeUnique<Vector<PropertyOffset>>();
+    ASSERT(!m_deletedOffsets->contains(offset));
     m_deletedOffsets->append(offset);
 }
 
 inline PropertyOffset PropertyTable::nextOffset(PropertyOffset inlineCapacity)
 {
@@ -512,18 +512,19 @@
 
     m_indexSize = sizeForCapacity(newCapacity);
     m_indexMask = m_indexSize - 1;
     m_keyCount = 0;
     m_deletedCount = 0;
-    m_index = static_cast<unsigned*>(fastZeroedMalloc(dataSize()));
+
+    m_index = static_cast<unsigned*>(PropertyTableMalloc::zeroedMalloc(dataSize()));
 
     for (; iter != end; ++iter) {
         ASSERT(canInsert());
         reinsert(*iter);
     }
 
-    fastFree(oldEntryIndices);
+    PropertyTableMalloc::free(oldEntryIndices);
 }
 
 inline unsigned PropertyTable::tableCapacity() const { return m_indexSize >> 1; }
 
 inline unsigned PropertyTable::deletedEntryIndex() const { return tableCapacity() + 1; }

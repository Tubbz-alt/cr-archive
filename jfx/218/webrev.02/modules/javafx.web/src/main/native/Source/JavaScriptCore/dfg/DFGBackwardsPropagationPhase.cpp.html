<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGBackwardsPropagationPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGPhase.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 class BackwardsPropagationPhase : public Phase {
 39 public:
 40     BackwardsPropagationPhase(Graph&amp; graph)
 41         : Phase(graph, &quot;backwards propagation&quot;)
 42     {
 43     }
 44 
 45     bool run()
 46     {
 47         m_changed = true;
 48         while (m_changed) {
 49             m_changed = false;
 50             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 51                 BasicBlock* block = m_graph.block(blockIndex);
 52                 if (!block)
 53                     continue;
 54 
 55                 // Prevent a tower of overflowing additions from creating a value that is out of the
 56                 // safe 2^48 range.
 57                 m_allowNestedOverflowingAdditions = block-&gt;size() &lt; (1 &lt;&lt; 16);
 58 
 59                 for (unsigned indexInBlock = block-&gt;size(); indexInBlock--;)
 60                     propagate(block-&gt;at(indexInBlock));
 61             }
 62         }
 63 
 64         return true;
 65     }
 66 
 67 private:
 68     bool isNotNegZero(Node* node)
 69     {
 70         if (!node-&gt;isNumberConstant())
 71             return false;
 72         double value = node-&gt;asNumber();
 73         return (value || 1.0 / value &gt; 0.0);
 74     }
 75 
 76     bool isNotPosZero(Node* node)
 77     {
 78         if (!node-&gt;isNumberConstant())
 79             return false;
 80         double value = node-&gt;asNumber();
 81         return (value || 1.0 / value &lt; 0.0);
 82     }
 83 
 84     // Tests if the absolute value is strictly less than the power of two.
 85     template&lt;int power&gt;
 86     bool isWithinPowerOfTwoForConstant(Node* node)
 87     {
 88         JSValue immediateValue = node-&gt;asJSValue();
 89         if (!immediateValue.isNumber())
 90             return false;
 91         double immediate = immediateValue.asNumber();
 92         return immediate &gt; -(static_cast&lt;int64_t&gt;(1) &lt;&lt; power) &amp;&amp; immediate &lt; (static_cast&lt;int64_t&gt;(1) &lt;&lt; power);
 93     }
 94 
 95     template&lt;int power&gt;
 96     bool isWithinPowerOfTwoNonRecursive(Node* node)
 97     {
 98         if (!node-&gt;isNumberConstant())
 99             return false;
100         return isWithinPowerOfTwoForConstant&lt;power&gt;(node);
101     }
102 
103     template&lt;int power&gt;
104     bool isWithinPowerOfTwo(Node* node)
105     {
106         switch (node-&gt;op()) {
107         case DoubleConstant:
108         case JSConstant:
109         case Int52Constant: {
110             return isWithinPowerOfTwoForConstant&lt;power&gt;(node);
111         }
112 
113         case ValueBitAnd:
114         case ArithBitAnd: {
115             if (power &gt; 31)
116                 return true;
117 
118             return isWithinPowerOfTwoNonRecursive&lt;power&gt;(node-&gt;child1().node())
119                 || isWithinPowerOfTwoNonRecursive&lt;power&gt;(node-&gt;child2().node());
120         }
121 
122         case ArithBitOr:
123         case ArithBitXor:
124         case ValueBitOr:
125         case ValueBitXor:
126         case ValueBitLShift:
127         case ArithBitLShift: {
128             return power &gt; 31;
129         }
130 
131         case ArithBitRShift:
132         case ValueBitRShift:
133         case BitURShift: {
134             if (power &gt; 31)
135                 return true;
136 
137             Node* shiftAmount = node-&gt;child2().node();
138             if (!node-&gt;isNumberConstant())
139                 return false;
140             JSValue immediateValue = shiftAmount-&gt;asJSValue();
141             if (!immediateValue.isInt32())
142                 return false;
143             return immediateValue.asInt32() &gt; 32 - power;
144         }
145 
146         default:
147             return false;
148         }
149     }
150 
151     template&lt;int power&gt;
152     bool isWithinPowerOfTwo(Edge edge)
153     {
154         return isWithinPowerOfTwo&lt;power&gt;(edge.node());
155     }
156 
157     bool mergeDefaultFlags(Node* node)
158     {
159         bool changed = false;
160         if (node-&gt;flags() &amp; NodeHasVarArgs) {
161             for (unsigned childIdx = node-&gt;firstChild();
162                 childIdx &lt; node-&gt;firstChild() + node-&gt;numChildren();
163                 childIdx++) {
164                 if (!!m_graph.m_varArgChildren[childIdx])
165                     changed |= m_graph.m_varArgChildren[childIdx]-&gt;mergeFlags(NodeBytecodeUsesAsValue);
166             }
167         } else {
168             if (!node-&gt;child1())
169                 return changed;
170             changed |= node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
171             if (!node-&gt;child2())
172                 return changed;
173             changed |= node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
174             if (!node-&gt;child3())
175                 return changed;
176             changed |= node-&gt;child3()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
177         }
178         return changed;
179     }
180 
181     void propagate(Node* node)
182     {
183         NodeFlags flags = node-&gt;flags() &amp; NodeBytecodeBackPropMask;
184 
185         switch (node-&gt;op()) {
186         case GetLocal: {
187             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
188             flags &amp;= ~NodeBytecodeUsesAsInt; // We don&#39;t care about cross-block uses-as-int.
189             m_changed |= variableAccessData-&gt;mergeFlags(flags);
190             break;
191         }
192 
193         case SetLocal: {
194             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
195             if (!variableAccessData-&gt;isLoadedFrom())
196                 break;
197             flags = variableAccessData-&gt;flags();
198             RELEASE_ASSERT(!(flags &amp; ~NodeBytecodeBackPropMask));
199             flags |= NodeBytecodeUsesAsNumber; // Account for the fact that control flow may cause overflows that our modeling can&#39;t handle.
200             node-&gt;child1()-&gt;mergeFlags(flags);
201             break;
202         }
203 
204         case Flush: {
205             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
206             m_changed |= variableAccessData-&gt;mergeFlags(NodeBytecodeUsesAsValue);
207             break;
208         }
209 
210         case MovHint:
211         case Check:
212         case CheckVarargs:
213             break;
214 
215         case ValueBitNot:
216         case ArithBitNot: {
217             flags |= NodeBytecodeUsesAsInt;
218             flags &amp;= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther);
219             flags &amp;= ~NodeBytecodeUsesAsArrayIndex;
220             node-&gt;child1()-&gt;mergeFlags(flags);
221             break;
222         }
223 
224         case ArithBitAnd:
225         case ArithBitOr:
226         case ArithBitXor:
227         case ValueBitAnd:
228         case ValueBitOr:
229         case ValueBitXor:
230         case ValueBitLShift:
231         case ArithBitLShift:
232         case ArithBitRShift:
233         case ValueBitRShift:
234         case BitURShift:
235         case ArithIMul: {
236             flags |= NodeBytecodeUsesAsInt;
237             flags &amp;= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther);
238             flags &amp;= ~NodeBytecodeUsesAsArrayIndex;
239             node-&gt;child1()-&gt;mergeFlags(flags);
240             node-&gt;child2()-&gt;mergeFlags(flags);
241             break;
242         }
243 
244         case StringCharAt:
245         case StringCharCodeAt:
246         case StringCodePointAt: {
247             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
248             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsValue | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
249             break;
250         }
251 
252         case StringSlice: {
253             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsValue);
254             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
255             if (node-&gt;child3())
256                 node-&gt;child3()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
257             break;
258         }
259 
260         case ArraySlice: {
261             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
262 
263             if (node-&gt;numChildren() == 2)
264                 m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
265             else if (node-&gt;numChildren() == 3) {
266                 m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
267                 m_graph.varArgChild(node, 2)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
268             } else if (node-&gt;numChildren() == 4) {
269                 m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
270                 m_graph.varArgChild(node, 2)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
271                 m_graph.varArgChild(node, 3)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
272             }
273             break;
274         }
275 
276 
277         case UInt32ToNumber: {
278             node-&gt;child1()-&gt;mergeFlags(flags);
279             break;
280         }
281 
282         case ValueAdd: {
283             if (isNotNegZero(node-&gt;child1().node()) || isNotNegZero(node-&gt;child2().node()))
284                 flags &amp;= ~NodeBytecodeNeedsNegZero;
285             if (node-&gt;child1()-&gt;hasNumericResult() || node-&gt;child2()-&gt;hasNumericResult() || node-&gt;child1()-&gt;hasNumberResult() || node-&gt;child2()-&gt;hasNumberResult())
286                 flags &amp;= ~NodeBytecodeUsesAsOther;
287             if (!isWithinPowerOfTwo&lt;32&gt;(node-&gt;child1()) &amp;&amp; !isWithinPowerOfTwo&lt;32&gt;(node-&gt;child2()))
288                 flags |= NodeBytecodeUsesAsNumber;
289             if (!m_allowNestedOverflowingAdditions)
290                 flags |= NodeBytecodeUsesAsNumber;
291 
292             node-&gt;child1()-&gt;mergeFlags(flags);
293             node-&gt;child2()-&gt;mergeFlags(flags);
294             break;
295         }
296 
297         case ArithAdd: {
298             flags &amp;= ~NodeBytecodeUsesAsOther;
299             if (isNotNegZero(node-&gt;child1().node()) || isNotNegZero(node-&gt;child2().node()))
300                 flags &amp;= ~NodeBytecodeNeedsNegZero;
301             if (!isWithinPowerOfTwo&lt;32&gt;(node-&gt;child1()) &amp;&amp; !isWithinPowerOfTwo&lt;32&gt;(node-&gt;child2()))
302                 flags |= NodeBytecodeUsesAsNumber;
303             if (!m_allowNestedOverflowingAdditions)
304                 flags |= NodeBytecodeUsesAsNumber;
305 
306             node-&gt;child1()-&gt;mergeFlags(flags);
307             node-&gt;child2()-&gt;mergeFlags(flags);
308             break;
309         }
310 
311         case ArithClz32: {
312             flags &amp;= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther | ~NodeBytecodeUsesAsArrayIndex);
313             flags |= NodeBytecodeUsesAsInt;
314             node-&gt;child1()-&gt;mergeFlags(flags);
315             break;
316         }
317 
318         case ArithSub: {
319             flags &amp;= ~NodeBytecodeUsesAsOther;
320             if (isNotNegZero(node-&gt;child1().node()) || isNotPosZero(node-&gt;child2().node()))
321                 flags &amp;= ~NodeBytecodeNeedsNegZero;
322             if (!isWithinPowerOfTwo&lt;32&gt;(node-&gt;child1()) &amp;&amp; !isWithinPowerOfTwo&lt;32&gt;(node-&gt;child2()))
323                 flags |= NodeBytecodeUsesAsNumber;
324             if (!m_allowNestedOverflowingAdditions)
325                 flags |= NodeBytecodeUsesAsNumber;
326 
327             node-&gt;child1()-&gt;mergeFlags(flags);
328             node-&gt;child2()-&gt;mergeFlags(flags);
329             break;
330         }
331 
332         case ArithNegate: {
333             flags &amp;= ~NodeBytecodeUsesAsOther;
334 
335             node-&gt;child1()-&gt;mergeFlags(flags);
336             break;
337         }
338 
339         case Inc:
340         case Dec: {
341             flags &amp;= ~NodeBytecodeNeedsNegZero;
342             flags &amp;= ~NodeBytecodeUsesAsOther;
343             if (!isWithinPowerOfTwo&lt;32&gt;(node-&gt;child1()))
344                 flags |= NodeBytecodeUsesAsNumber;
345             if (!m_allowNestedOverflowingAdditions)
346                 flags |= NodeBytecodeUsesAsNumber;
347 
348             node-&gt;child1()-&gt;mergeFlags(flags);
349             break;
350         }
351 
352         case ValueMul:
353         case ArithMul: {
354             // As soon as a multiply happens, we can easily end up in the part
355             // of the double domain where the point at which you do truncation
356             // can change the outcome. So, ArithMul always forces its inputs to
357             // check for overflow. Additionally, it will have to check for overflow
358             // itself unless we can prove that there is no way for the values
359             // produced to cause double rounding.
360 
361             if (!isWithinPowerOfTwo&lt;22&gt;(node-&gt;child1().node())
362                 &amp;&amp; !isWithinPowerOfTwo&lt;22&gt;(node-&gt;child2().node()))
363                 flags |= NodeBytecodeUsesAsNumber;
364 
365             node-&gt;mergeFlags(flags);
366 
367             flags |= NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero;
368             flags &amp;= ~NodeBytecodeUsesAsOther;
369 
370             node-&gt;child1()-&gt;mergeFlags(flags);
371             node-&gt;child2()-&gt;mergeFlags(flags);
372             break;
373         }
374 
375         case ValueDiv:
376         case ArithDiv: {
377             flags |= NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero;
378             flags &amp;= ~NodeBytecodeUsesAsOther;
379 
380             node-&gt;child1()-&gt;mergeFlags(flags);
381             node-&gt;child2()-&gt;mergeFlags(flags);
382             break;
383         }
384 
385         case ValueMod:
386         case ArithMod: {
387             flags |= NodeBytecodeUsesAsNumber;
388             flags &amp;= ~NodeBytecodeUsesAsOther;
389 
390             node-&gt;child1()-&gt;mergeFlags(flags);
391             node-&gt;child2()-&gt;mergeFlags(flags &amp; ~NodeBytecodeNeedsNegZero);
392             break;
393         }
394 
395         case GetByVal: {
396             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
397             m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
398             break;
399         }
400 
401         case NewTypedArray:
402         case NewArrayWithSize: {
403             // Negative zero is not observable. NaN versus undefined are only observable
404             // in that you would get a different exception message. So, like, whatever: we
405             // claim here that NaN v. undefined is observable.
406             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsInt | NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsArrayIndex);
407             break;
408         }
409 
410         case ToString:
411         case CallStringConstructor: {
412             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
413             break;
414         }
415 
416         case ToPrimitive:
417         case ToNumber:
418         case ToNumeric: {
419             node-&gt;child1()-&gt;mergeFlags(flags);
420             break;
421         }
422 
423         case CompareLess:
424         case CompareLessEq:
425         case CompareGreater:
426         case CompareGreaterEq:
427         case CompareBelow:
428         case CompareBelowEq:
429         case CompareEq:
430         case CompareStrictEq: {
431             node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
432             node-&gt;child2()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
433             break;
434         }
435 
436         case PutByValDirect:
437         case PutByVal: {
438             m_graph.varArgChild(node, 0)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
439             m_graph.varArgChild(node, 1)-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
440             m_graph.varArgChild(node, 2)-&gt;mergeFlags(NodeBytecodeUsesAsValue);
441             break;
442         }
443 
444         case Switch: {
445             SwitchData* data = node-&gt;switchData();
446             switch (data-&gt;kind) {
447             case SwitchImm:
448                 // We don&#39;t need NodeBytecodeNeedsNegZero because if the cases are all integers
449                 // then -0 and 0 are treated the same.  We don&#39;t need NodeBytecodeUsesAsOther
450                 // because if all of the cases are integers then NaN and undefined are
451                 // treated the same (i.e. they will take default).
452                 node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsInt);
453                 break;
454             case SwitchChar: {
455                 // We don&#39;t need NodeBytecodeNeedsNegZero because if the cases are all strings
456                 // then -0 and 0 are treated the same.  We don&#39;t need NodeBytecodeUsesAsOther
457                 // because if all of the cases are single-character strings then NaN
458                 // and undefined are treated the same (i.e. they will take default).
459                 node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber);
460                 break;
461             }
462             case SwitchString:
463                 // We don&#39;t need NodeBytecodeNeedsNegZero because if the cases are all strings
464                 // then -0 and 0 are treated the same.
465                 node-&gt;child1()-&gt;mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
466                 break;
467             case SwitchCell:
468                 // There is currently no point to being clever here since this is used for switching
469                 // on objects.
470                 mergeDefaultFlags(node);
471                 break;
472             }
473             break;
474         }
475 
476         case Identity:
477             // This would be trivial to handle but we just assert that we cannot see these yet.
478             RELEASE_ASSERT_NOT_REACHED();
479             break;
480 
481         // Note: ArithSqrt, ArithUnary and other math intrinsics don&#39;t have special
482         // rules in here because they are always followed by Phantoms to signify that if the
483         // method call speculation fails, the bytecode may use the arguments in arbitrary ways.
484         // This corresponds to that possibility of someone doing something like:
485         // Math.sin = function(x) { doArbitraryThingsTo(x); }
486 
487         default:
488             mergeDefaultFlags(node);
489             break;
490         }
491     }
492 
493     bool m_allowNestedOverflowingAdditions;
494     bool m_changed;
495 };
496 
497 bool performBackwardsPropagation(Graph&amp; graph)
498 {
499     return runPhase&lt;BackwardsPropagationPhase&gt;(graph);
500 }
501 
502 } } // namespace JSC::DFG
503 
504 #endif // ENABLE(DFG_JIT)
505 
    </pre>
  </body>
</html>
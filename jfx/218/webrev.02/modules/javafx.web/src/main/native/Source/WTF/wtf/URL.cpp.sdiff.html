<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/URL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TinyPtrSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="URL.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/URL.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 #include &lt;wtf/URL.h&gt;
  29 
  30 #include &quot;URLParser.h&quot;
  31 #include &lt;stdio.h&gt;
  32 #include &lt;unicode/uidna.h&gt;
  33 #include &lt;wtf/HashMap.h&gt;
  34 #include &lt;wtf/NeverDestroyed.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/UUID.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/StringBuilder.h&gt;
  39 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  40 #include &lt;wtf/text/StringHash.h&gt;
  41 #include &lt;wtf/text/TextStream.h&gt;
  42 
  43 namespace WTF {
  44 
  45 typedef Vector&lt;char, 512&gt; CharBuffer;
  46 typedef Vector&lt;UChar, 512&gt; UCharBuffer;
  47 
<span class="line-modified">  48 static const unsigned invalidPortNumber = 0xFFFF;</span>
  49 
  50 // Copies the source to the destination, assuming all the source characters are
  51 // ASCII. The destination buffer must be large enough. Null characters are allowed
  52 // in the source string, and no attempt is made to null-terminate the result.
  53 static void copyASCII(const String&amp; string, char* dest)
  54 {
  55     if (string.isEmpty())
  56         return;
  57 
  58     if (string.is8Bit())
  59         memcpy(dest, string.characters8(), string.length());
  60     else {
  61         const UChar* src = string.characters16();
  62         size_t length = string.length();
  63         for (size_t i = 0; i &lt; length; i++)
  64             dest[i] = static_cast&lt;char&gt;(src[i]);
  65     }
  66 }
  67 
  68 void URL::invalidate()
</pre>
<hr />
<pre>
 361 {
 362     unsigned portEnd = m_hostEnd + m_portLength;
 363     return m_string.substring(portEnd, m_pathEnd - portEnd);
 364 }
 365 
 366 bool URL::setProtocol(const String&amp; s)
 367 {
 368     // Firefox and IE remove everything after the first &#39;:&#39;.
 369     size_t separatorPosition = s.find(&#39;:&#39;);
 370     String newProtocol = s.substring(0, separatorPosition);
 371     auto canonicalized = URLParser::maybeCanonicalizeScheme(newProtocol);
 372     if (!canonicalized)
 373         return false;
 374 
 375     if (!m_isValid) {
 376         URLParser parser(makeString(*canonicalized, &quot;:&quot;, m_string));
 377         *this = parser.result();
 378         return true;
 379     }
 380 






 381     URLParser parser(makeString(*canonicalized, m_string.substring(m_schemeEnd)));
 382     *this = parser.result();
 383     return true;
 384 }
 385 
 386 static bool isAllASCII(StringView string)
 387 {
 388     if (string.is8Bit())
 389         return charactersAreAllASCII(string.characters8(), string.length());
 390     return charactersAreAllASCII(string.characters16(), string.length());
 391 }
 392 
 393 // Appends the punycoded hostname identified by the given string and length to
 394 // the output buffer. The result will not be null terminated.
 395 // Return value of false means error in encoding.
 396 static bool appendEncodedHostname(UCharBuffer&amp; buffer, StringView string)
 397 {
 398     // Needs to be big enough to hold an IDN-encoded name.
 399     // For host names bigger than this, we won&#39;t do IDN encoding, which is almost certainly OK.
 400     const unsigned hostnameBufferLength = 2048;
</pre>
<hr />
<pre>
 451 void URL::removePort()
 452 {
 453     if (!m_portLength)
 454         return;
 455     URLParser parser(makeString(StringView(m_string).left(m_hostEnd), StringView(m_string).substring(m_hostEnd + m_portLength)));
 456     *this = parser.result();
 457 }
 458 
 459 void URL::setPort(unsigned short i)
 460 {
 461     if (!m_isValid)
 462         return;
 463 
 464     bool colonNeeded = !m_portLength;
 465     unsigned portStart = (colonNeeded ? m_hostEnd : m_hostEnd + 1);
 466 
 467     URLParser parser(makeString(StringView(m_string).left(portStart), (colonNeeded ? &quot;:&quot; : &quot;&quot;), static_cast&lt;unsigned&gt;(i), StringView(m_string).substring(m_hostEnd + m_portLength)));
 468     *this = parser.result();
 469 }
 470 









 471 void URL::setHostAndPort(const String&amp; hostAndPort)
 472 {
 473     if (!m_isValid)
 474         return;
 475 
 476     StringView hostName(hostAndPort);
 477     StringView port;
 478 
 479     auto colonIndex = hostName.find(&#39;:&#39;);
 480     if (colonIndex != notFound) {
 481         port = hostName.substring(colonIndex + 1);
 482         bool ok;
 483         int portInt = port.toIntStrict(ok);
 484         if (!ok || portInt &lt; 0)
 485             return;
 486         hostName = hostName.substring(0, colonIndex);
 487     }
 488 
 489     if (hostName.isEmpty())
 490         return;
</pre>
</td>
<td>
<hr />
<pre>
  28 #include &lt;wtf/URL.h&gt;
  29 
  30 #include &quot;URLParser.h&quot;
  31 #include &lt;stdio.h&gt;
  32 #include &lt;unicode/uidna.h&gt;
  33 #include &lt;wtf/HashMap.h&gt;
  34 #include &lt;wtf/NeverDestroyed.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/UUID.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/StringBuilder.h&gt;
  39 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  40 #include &lt;wtf/text/StringHash.h&gt;
  41 #include &lt;wtf/text/TextStream.h&gt;
  42 
  43 namespace WTF {
  44 
  45 typedef Vector&lt;char, 512&gt; CharBuffer;
  46 typedef Vector&lt;UChar, 512&gt; UCharBuffer;
  47 
<span class="line-modified">  48 static constexpr unsigned invalidPortNumber = 0xFFFF;</span>
  49 
  50 // Copies the source to the destination, assuming all the source characters are
  51 // ASCII. The destination buffer must be large enough. Null characters are allowed
  52 // in the source string, and no attempt is made to null-terminate the result.
  53 static void copyASCII(const String&amp; string, char* dest)
  54 {
  55     if (string.isEmpty())
  56         return;
  57 
  58     if (string.is8Bit())
  59         memcpy(dest, string.characters8(), string.length());
  60     else {
  61         const UChar* src = string.characters16();
  62         size_t length = string.length();
  63         for (size_t i = 0; i &lt; length; i++)
  64             dest[i] = static_cast&lt;char&gt;(src[i]);
  65     }
  66 }
  67 
  68 void URL::invalidate()
</pre>
<hr />
<pre>
 361 {
 362     unsigned portEnd = m_hostEnd + m_portLength;
 363     return m_string.substring(portEnd, m_pathEnd - portEnd);
 364 }
 365 
 366 bool URL::setProtocol(const String&amp; s)
 367 {
 368     // Firefox and IE remove everything after the first &#39;:&#39;.
 369     size_t separatorPosition = s.find(&#39;:&#39;);
 370     String newProtocol = s.substring(0, separatorPosition);
 371     auto canonicalized = URLParser::maybeCanonicalizeScheme(newProtocol);
 372     if (!canonicalized)
 373         return false;
 374 
 375     if (!m_isValid) {
 376         URLParser parser(makeString(*canonicalized, &quot;:&quot;, m_string));
 377         *this = parser.result();
 378         return true;
 379     }
 380 
<span class="line-added"> 381     if ((m_passwordEnd != m_userStart || port()) &amp;&amp; *canonicalized == &quot;file&quot;)</span>
<span class="line-added"> 382         return true;</span>
<span class="line-added"> 383 </span>
<span class="line-added"> 384     if (isLocalFile() &amp;&amp; host().isEmpty())</span>
<span class="line-added"> 385         return true;</span>
<span class="line-added"> 386 </span>
 387     URLParser parser(makeString(*canonicalized, m_string.substring(m_schemeEnd)));
 388     *this = parser.result();
 389     return true;
 390 }
 391 
 392 static bool isAllASCII(StringView string)
 393 {
 394     if (string.is8Bit())
 395         return charactersAreAllASCII(string.characters8(), string.length());
 396     return charactersAreAllASCII(string.characters16(), string.length());
 397 }
 398 
 399 // Appends the punycoded hostname identified by the given string and length to
 400 // the output buffer. The result will not be null terminated.
 401 // Return value of false means error in encoding.
 402 static bool appendEncodedHostname(UCharBuffer&amp; buffer, StringView string)
 403 {
 404     // Needs to be big enough to hold an IDN-encoded name.
 405     // For host names bigger than this, we won&#39;t do IDN encoding, which is almost certainly OK.
 406     const unsigned hostnameBufferLength = 2048;
</pre>
<hr />
<pre>
 457 void URL::removePort()
 458 {
 459     if (!m_portLength)
 460         return;
 461     URLParser parser(makeString(StringView(m_string).left(m_hostEnd), StringView(m_string).substring(m_hostEnd + m_portLength)));
 462     *this = parser.result();
 463 }
 464 
 465 void URL::setPort(unsigned short i)
 466 {
 467     if (!m_isValid)
 468         return;
 469 
 470     bool colonNeeded = !m_portLength;
 471     unsigned portStart = (colonNeeded ? m_hostEnd : m_hostEnd + 1);
 472 
 473     URLParser parser(makeString(StringView(m_string).left(portStart), (colonNeeded ? &quot;:&quot; : &quot;&quot;), static_cast&lt;unsigned&gt;(i), StringView(m_string).substring(m_hostEnd + m_portLength)));
 474     *this = parser.result();
 475 }
 476 
<span class="line-added"> 477 void URL::removeHostAndPort()</span>
<span class="line-added"> 478 {</span>
<span class="line-added"> 479     if (!m_isValid)</span>
<span class="line-added"> 480         return;</span>
<span class="line-added"> 481     if (!host().isEmpty())</span>
<span class="line-added"> 482         setHost({ });</span>
<span class="line-added"> 483     removePort();</span>
<span class="line-added"> 484 }</span>
<span class="line-added"> 485 </span>
 486 void URL::setHostAndPort(const String&amp; hostAndPort)
 487 {
 488     if (!m_isValid)
 489         return;
 490 
 491     StringView hostName(hostAndPort);
 492     StringView port;
 493 
 494     auto colonIndex = hostName.find(&#39;:&#39;);
 495     if (colonIndex != notFound) {
 496         port = hostName.substring(colonIndex + 1);
 497         bool ok;
 498         int portInt = port.toIntStrict(ok);
 499         if (!ok || portInt &lt; 0)
 500             return;
 501         hostName = hostName.substring(0, colonIndex);
 502     }
 503 
 504     if (hostName.isEmpty())
 505         return;
</pre>
</td>
</tr>
</table>
<center><a href="TinyPtrSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="URL.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/DirectArguments.cpp
@@ -64,23 +64,23 @@
         result->storage()[i].setUndefined();
 
     return result;
 }
 
-DirectArguments* DirectArguments::createByCopying(ExecState* exec)
+DirectArguments* DirectArguments::createByCopying(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
-    unsigned length = exec->argumentCount();
-    unsigned capacity = std::max(length, static_cast<unsigned>(exec->codeBlock()->numParameters() - 1));
+    unsigned length = callFrame->argumentCount();
+    unsigned capacity = std::max(length, static_cast<unsigned>(callFrame->codeBlock()->numParameters() - 1));
     DirectArguments* result = createUninitialized(
-        vm, exec->lexicalGlobalObject()->directArgumentsStructure(), length, capacity);
+        vm, globalObject->directArgumentsStructure(), length, capacity);
 
     for (unsigned i = capacity; i--;)
-        result->storage()[i].set(vm, result, exec->getArgumentUnsafe(i));
+        result->storage()[i].set(vm, result, callFrame->getArgumentUnsafe(i));
 
-    result->setCallee(vm, jsCast<JSFunction*>(exec->jsCallee()));
+    result->setCallee(vm, jsCast<JSFunction*>(callFrame->jsCallee()));
 
     return result;
 }
 
 size_t DirectArguments::estimatedSize(JSCell* cell, VM& vm)
@@ -108,51 +108,62 @@
 Structure* DirectArguments::createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
 {
     return Structure::create(vm, globalObject, prototype, TypeInfo(DirectArgumentsType, StructureFlags), info());
 }
 
-void DirectArguments::overrideThings(VM& vm)
+void DirectArguments::overrideThings(JSGlobalObject* globalObject)
 {
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
     RELEASE_ASSERT(!m_mappedArguments);
 
     putDirect(vm, vm.propertyNames->length, jsNumber(m_length), static_cast<unsigned>(PropertyAttribute::DontEnum));
     putDirect(vm, vm.propertyNames->callee, m_callee.get(), static_cast<unsigned>(PropertyAttribute::DontEnum));
-    putDirect(vm, vm.propertyNames->iteratorSymbol, globalObject(vm)->arrayProtoValuesFunction(), static_cast<unsigned>(PropertyAttribute::DontEnum));
+    putDirect(vm, vm.propertyNames->iteratorSymbol, globalObject->arrayProtoValuesFunction(), static_cast<unsigned>(PropertyAttribute::DontEnum));
 
-    void* backingStore = vm.gigacageAuxiliarySpace(m_mappedArguments.kind).allocateNonVirtual(vm, mappedArgumentsSize(), nullptr, AllocationFailureMode::Assert);
+    void* backingStore = vm.gigacageAuxiliarySpace(m_mappedArguments.kind).allocateNonVirtual(vm, mappedArgumentsSize(), nullptr, AllocationFailureMode::ReturnNull);
+    if (UNLIKELY(!backingStore)) {
+        throwOutOfMemoryError(globalObject, scope);
+        return;
+    }
     bool* overrides = static_cast<bool*>(backingStore);
     m_mappedArguments.set(vm, this, overrides, internalLength());
     for (unsigned i = internalLength(); i--;)
         overrides[i] = false;
 }
 
-void DirectArguments::overrideThingsIfNecessary(VM& vm)
+void DirectArguments::overrideThingsIfNecessary(JSGlobalObject* globalObject)
 {
     if (!m_mappedArguments)
-        overrideThings(vm);
+        overrideThings(globalObject);
 }
 
-void DirectArguments::unmapArgument(VM& vm, unsigned index)
+void DirectArguments::unmapArgument(JSGlobalObject* globalObject, unsigned index)
 {
-    overrideThingsIfNecessary(vm);
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
+    overrideThingsIfNecessary(globalObject);
+    RETURN_IF_EXCEPTION(scope, void());
+
     m_mappedArguments.at(index, internalLength()) = true;
 }
 
-void DirectArguments::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)
+void DirectArguments::copyToArguments(JSGlobalObject* globalObject, JSValue* firstElementDest, unsigned offset, unsigned length)
 {
     if (!m_mappedArguments) {
         unsigned limit = std::min(length + offset, m_length);
         unsigned i;
-        VirtualRegister start = firstElementDest - offset;
         for (i = offset; i < limit; ++i)
-            exec->r(start + i) = storage()[i].get();
+            firstElementDest[i - offset] = storage()[i].get();
         for (; i < length; ++i)
-            exec->r(start + i) = get(exec, i);
+            firstElementDest[i - offset] = get(globalObject, i);
         return;
     }
 
-    GenericArguments::copyToArguments(exec, firstElementDest, offset, length);
+    GenericArguments::copyToArguments(globalObject, firstElementDest, offset, length);
 }
 
 unsigned DirectArguments::mappedArgumentsSize()
 {
     // We always allocate something; in the relatively uncommon case of overriding an empty argument we

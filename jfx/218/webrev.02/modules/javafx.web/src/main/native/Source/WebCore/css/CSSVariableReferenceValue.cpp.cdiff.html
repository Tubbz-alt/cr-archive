<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSValuePool.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSVariableReferenceValue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;CSSVariableReferenceValue.h&quot;
  
  #include &quot;RenderStyle.h&quot;
<span class="line-added">+ #include &quot;StyleBuilder.h&quot;</span>
  #include &quot;StyleResolver.h&quot;
  
  namespace WebCore {
  
  String CSSVariableReferenceValue::customCSSText() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,37 ***</span>
          m_stringValue = m_data-&gt;tokenRange().serialize();
      }
      return m_stringValue;
  }
  
<span class="line-modified">! static bool resolveTokenRange(CSSParserTokenRange, Vector&lt;CSSParserToken&gt;&amp;, ApplyCascadedPropertyState&amp;);</span>
  
<span class="line-modified">! static bool resolveVariableFallback(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, ApplyCascadedPropertyState&amp; state)</span>
  {
      if (range.atEnd())
          return false;
      ASSERT(range.peek().type() == CommaToken);
      range.consume();
<span class="line-modified">!     return resolveTokenRange(range, result, state);</span>
  }
  
<span class="line-modified">! static bool resolveVariableReference(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, ApplyCascadedPropertyState&amp; state)</span>
  {
<span class="line-modified">!     auto&amp; registeredProperties = state.styleResolver-&gt;document().getCSSRegisteredCustomPropertySet();</span>
<span class="line-modified">!     auto&amp; style = *state.styleResolver-&gt;style();</span>
  
      range.consumeWhitespace();
      ASSERT(range.peek().type() == IdentToken);
      String variableName = range.consumeIncludingWhitespace().value().toString();
      ASSERT(range.atEnd() || (range.peek().type() == CommaToken));
  
      // Apply this variable first, in case it is still unresolved
<span class="line-modified">!     state.styleResolver-&gt;applyCascadedCustomProperty(variableName, state);</span>
  
      // Apply fallback to detect cycles
      Vector&lt;CSSParserToken&gt; fallbackResult;
<span class="line-modified">!     bool fallbackReturn = resolveVariableFallback(CSSParserTokenRange(range), fallbackResult, state);</span>
  
      auto* property = style.getCustomProperty(variableName);
  
      if (!property || property-&gt;isUnset()) {
          auto* registered = registeredProperties.get(variableName);
<span class="line-new-header">--- 43,37 ---</span>
          m_stringValue = m_data-&gt;tokenRange().serialize();
      }
      return m_stringValue;
  }
  
<span class="line-modified">! static bool resolveTokenRange(CSSParserTokenRange, Vector&lt;CSSParserToken&gt;&amp;, Style::BuilderState&amp;);</span>
  
<span class="line-modified">! static bool resolveVariableFallback(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, Style::BuilderState&amp; builderState)</span>
  {
      if (range.atEnd())
          return false;
      ASSERT(range.peek().type() == CommaToken);
      range.consume();
<span class="line-modified">!     return resolveTokenRange(range, result, builderState);</span>
  }
  
<span class="line-modified">! static bool resolveVariableReference(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, Style::BuilderState&amp; builderState)</span>
  {
<span class="line-modified">!     auto&amp; registeredProperties = builderState.document().getCSSRegisteredCustomPropertySet();</span>
<span class="line-modified">!     auto&amp; style = builderState.style();</span>
  
      range.consumeWhitespace();
      ASSERT(range.peek().type() == IdentToken);
      String variableName = range.consumeIncludingWhitespace().value().toString();
      ASSERT(range.atEnd() || (range.peek().type() == CommaToken));
  
      // Apply this variable first, in case it is still unresolved
<span class="line-modified">!     builderState.builder().applyCustomProperty(variableName);</span>
  
      // Apply fallback to detect cycles
      Vector&lt;CSSParserToken&gt; fallbackResult;
<span class="line-modified">!     bool fallbackReturn = resolveVariableFallback(CSSParserTokenRange(range), fallbackResult, builderState);</span>
  
      auto* property = style.getCustomProperty(variableName);
  
      if (!property || property-&gt;isUnset()) {
          auto* registered = registeredProperties.get(variableName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,28 ***</span>
      result.appendVector(property-&gt;tokens());
  
      return true;
  }
  
<span class="line-modified">! static bool resolveTokenRange(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, ApplyCascadedPropertyState&amp; state)</span>
  {
      bool success = true;
      while (!range.atEnd()) {
          if (range.peek().functionId() == CSSValueVar || range.peek().functionId() == CSSValueEnv)
<span class="line-modified">!             success &amp;= resolveVariableReference(range.consumeBlock(), result, state);</span>
          else
              result.append(range.consume());
      }
      return success;
  }
  
<span class="line-modified">! RefPtr&lt;CSSVariableData&gt; CSSVariableReferenceValue::resolveVariableReferences(ApplyCascadedPropertyState&amp; state) const</span>
  {
      Vector&lt;CSSParserToken&gt; resolvedTokens;
      CSSParserTokenRange range = m_data-&gt;tokenRange();
  
<span class="line-modified">!     if (!resolveTokenRange(range, resolvedTokens, state))</span>
          return nullptr;
  
      return CSSVariableData::create(resolvedTokens);
  }
  
<span class="line-new-header">--- 91,28 ---</span>
      result.appendVector(property-&gt;tokens());
  
      return true;
  }
  
<span class="line-modified">! static bool resolveTokenRange(CSSParserTokenRange range, Vector&lt;CSSParserToken&gt;&amp; result, Style::BuilderState&amp; builderState)</span>
  {
      bool success = true;
      while (!range.atEnd()) {
          if (range.peek().functionId() == CSSValueVar || range.peek().functionId() == CSSValueEnv)
<span class="line-modified">!             success &amp;= resolveVariableReference(range.consumeBlock(), result, builderState);</span>
          else
              result.append(range.consume());
      }
      return success;
  }
  
<span class="line-modified">! RefPtr&lt;CSSVariableData&gt; CSSVariableReferenceValue::resolveVariableReferences(Style::BuilderState&amp; builderState) const</span>
  {
      Vector&lt;CSSParserToken&gt; resolvedTokens;
      CSSParserTokenRange range = m_data-&gt;tokenRange();
  
<span class="line-modified">!     if (!resolveTokenRange(range, resolvedTokens, builderState))</span>
          return nullptr;
  
      return CSSVariableData::create(resolvedTokens);
  }
  
</pre>
<center><a href="CSSValuePool.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSVariableReferenceValue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
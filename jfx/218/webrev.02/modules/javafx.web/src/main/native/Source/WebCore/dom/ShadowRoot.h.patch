diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.h b/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.h
@@ -27,24 +27,31 @@
 #pragma once
 
 #include "Document.h"
 #include "DocumentFragment.h"
 #include "Element.h"
+#if ENABLE(PICTURE_IN_PICTURE_API)
+#include "HTMLVideoElement.h"
+#endif
 #include "ShadowRootMode.h"
+#include <wtf/HashMap.h>
 
 namespace WebCore {
 
 class HTMLSlotElement;
 class SlotAssignment;
 class StyleSheetList;
 
 class ShadowRoot final : public DocumentFragment, public TreeScope {
     WTF_MAKE_ISO_ALLOCATED(ShadowRoot);
 public:
-    static Ref<ShadowRoot> create(Document& document, ShadowRootMode type)
+
+    enum class DelegatesFocus : uint8_t { Yes, No };
+
+    static Ref<ShadowRoot> create(Document& document, ShadowRootMode type, DelegatesFocus delegatesFocus = DelegatesFocus::No)
     {
-        return adoptRef(*new ShadowRoot(document, type));
+        return adoptRef(*new ShadowRoot(document, type, delegatesFocus));
     }
 
     static Ref<ShadowRoot> create(Document& document, std::unique_ptr<SlotAssignment>&& assignment)
     {
         return adoptRef(*new ShadowRoot(document, WTFMove(assignment)));
@@ -58,10 +65,14 @@
     StyleSheetList& styleSheets();
 
     bool resetStyleInheritance() const { return m_resetStyleInheritance; }
     void setResetStyleInheritance(bool);
 
+    bool delegatesFocus() const { return m_delegatesFocus; }
+    bool containsFocusedElement() const { return m_containsFocusedElement; }
+    void setContainsFocusedElement(bool flag) { m_containsFocusedElement = flag; }
+
     Element* host() const { return m_host; }
     void setHost(Element* host) { m_host = host; }
 
     String innerHTML() const;
     ExceptionOr<void> setInnerHTML(const String&);
@@ -90,16 +101,22 @@
     const Vector<Node*>* assignedNodesForSlot(const HTMLSlotElement&);
 
     void moveShadowRootToNewParentScope(TreeScope&, Document&);
     void moveShadowRootToNewDocument(Document&);
 
-protected:
-    ShadowRoot(Document&, ShadowRootMode);
+    using PartMappings = HashMap<AtomString, Vector<AtomString, 1>>;
+    const PartMappings& partMappings() const;
+    void invalidatePartMappings();
 
-    ShadowRoot(Document&, std::unique_ptr<SlotAssignment>&&);
+#if ENABLE(PICTURE_IN_PICTURE_API)
+    HTMLVideoElement* pictureInPictureElement() const;
+#endif
 
 private:
+    ShadowRoot(Document&, ShadowRootMode, DelegatesFocus);
+    ShadowRoot(Document&, std::unique_ptr<SlotAssignment>&&);
+
     bool childTypeAllowed(NodeType) const override;
 
     Ref<Node> cloneNodeInternal(Document&, CloningOperation) override;
 
     Node::InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&) override;
@@ -107,17 +124,20 @@
 
     void childrenChanged(const ChildChange&) override;
 
     bool m_resetStyleInheritance { false };
     bool m_hasBegunDeletingDetachedChildren { false };
+    bool m_delegatesFocus { false };
+    bool m_containsFocusedElement { false };
     ShadowRootMode m_type { ShadowRootMode::UserAgent };
 
     Element* m_host { nullptr };
     RefPtr<StyleSheetList> m_styleSheetList;
 
     std::unique_ptr<Style::Scope> m_styleScope;
     std::unique_ptr<SlotAssignment> m_slotAssignment;
+    mutable Optional<PartMappings> m_partMappings;
 };
 
 inline Element* ShadowRoot::activeElement() const
 {
     return treeScope().focusedElementInScope();

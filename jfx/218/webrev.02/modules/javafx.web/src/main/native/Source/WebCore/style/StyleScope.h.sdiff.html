<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleScope.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSharingResolver.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;Timer.h&quot;
 31 #include &lt;memory&gt;
 32 #include &lt;wtf/FastMalloc.h&gt;
 33 #include &lt;wtf/HashSet.h&gt;
 34 #include &lt;wtf/ListHashSet.h&gt;
 35 #include &lt;wtf/RefPtr.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 class CSSStyleSheet;
 42 class Document;
 43 class Element;
 44 class Node;
 45 class ProcessingInstruction;
<span class="line-removed"> 46 class StyleResolver;</span>
 47 class StyleSheet;
 48 class StyleSheetContents;
 49 class StyleSheetList;
 50 class ShadowRoot;
 51 class TreeScope;
 52 
 53 namespace Style {
 54 


 55 // This is used to identify style scopes that can affect an element.
 56 // Scopes are in tree-of-trees order. Styles from earlier scopes win over later ones (modulo !important).
 57 enum class ScopeOrdinal : int {
<span class="line-modified"> 58     ContainingHost = -1, // Author-exposed UA pseudo classes from the host tree scope.</span>
 59     Element = 0, // Normal rules in the same tree where the element is.
 60     FirstSlot = 1, // ::slotted rules in the parent&#39;s shadow tree. Values greater than FirstSlot indicate subsequent slots in the chain.
 61     Shadow = std::numeric_limits&lt;int&gt;::max(), // :host rules in element&#39;s own shadow tree.
 62 };
 63 
 64 class Scope {
 65     WTF_MAKE_FAST_ALLOCATED;
 66 public:
 67     explicit Scope(Document&amp;);
 68     explicit Scope(ShadowRoot&amp;);
 69 
 70     ~Scope();
 71 
 72     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; activeStyleSheets() const { return m_activeStyleSheets; }
 73 
 74     const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; styleSheetsForStyleSheetList();
 75     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; activeStyleSheetsForInspector();
 76 
 77     void addStyleSheetCandidateNode(Node&amp;, bool createdByParser);
 78     void removeStyleSheetCandidateNode(Node&amp;);
</pre>
<hr />
<pre>
 90     bool hasPendingSheet(const Element&amp;) const;
 91     bool hasPendingSheetInBody(const Element&amp;) const;
 92     bool hasPendingSheet(const ProcessingInstruction&amp;) const;
 93 
 94     bool usesStyleBasedEditability() { return m_usesStyleBasedEditability; }
 95 
 96     bool activeStyleSheetsContains(const CSSStyleSheet*) const;
 97 
 98     void evaluateMediaQueriesForViewportChange();
 99     void evaluateMediaQueriesForAccessibilitySettingsChange();
100     void evaluateMediaQueriesForAppearanceChange();
101 
102     // This is called when some stylesheet becomes newly enabled or disabled.
103     void didChangeActiveStyleSheetCandidates();
104     // This is called when contents of a stylesheet is mutated.
105     void didChangeStyleSheetContents();
106     // This is called when the environment where we intrepret the stylesheets changes (for example switching to printing).
107     // The change is assumed to potentially affect all author and user stylesheets including shadow roots.
108     WEBCORE_EXPORT void didChangeStyleSheetEnvironment();
109 


110     bool hasPendingUpdate() const { return m_pendingUpdate || m_hasDescendantWithPendingUpdate; }
111     void flushPendingUpdate();
112 
113 #if ENABLE(XSLT)
114     Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; collectXSLTransforms();
115 #endif
116 
<span class="line-modified">117     StyleResolver&amp; resolver();</span>
<span class="line-modified">118     StyleResolver* resolverIfExists();</span>
119     void clearResolver();
120     void releaseMemory();
121 
122     const Document&amp; document() const { return m_document; }



123 
124     static Scope&amp; forNode(Node&amp;);
125     static Scope* forOrdinal(Element&amp;, ScopeOrdinal);
126 
127 private:
128     bool shouldUseSharedUserAgentShadowTreeStyleResolver() const;
129 
130     void didRemovePendingStylesheet();
131 
132     enum class UpdateType { ActiveSet, ContentsOrInterpretation };
133     void updateActiveStyleSheets(UpdateType);
134     void scheduleUpdate(UpdateType);
135 
136     template &lt;typename TestFunction&gt; void evaluateMediaQueries(TestFunction&amp;&amp;);
137 
138     WEBCORE_EXPORT void flushPendingSelfUpdate();
139     WEBCORE_EXPORT void flushPendingDescendantUpdates();
140 
141     void collectActiveStyleSheets(Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp;);
142 
<span class="line-modified">143     enum StyleResolverUpdateType {</span>
144         Reconstruct,
145         Reset,
146         Additive
147     };
<span class="line-modified">148     StyleResolverUpdateType analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets, bool&amp; requiresFullStyleRecalc);</span>
<span class="line-modified">149     void updateStyleResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp;, StyleResolverUpdateType);</span>






150 
151     void pendingUpdateTimerFired();
152     void clearPendingUpdate();
153 
154     Document&amp; m_document;
155     ShadowRoot* m_shadowRoot { nullptr };
156 
<span class="line-modified">157     std::unique_ptr&lt;StyleResolver&gt; m_resolver;</span>
158 
159     Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; m_styleSheetsForStyleSheetList;
160     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; m_activeStyleSheets;
161 
162     Timer m_pendingUpdateTimer;
163 
164     mutable std::unique_ptr&lt;HashSet&lt;const CSSStyleSheet*&gt;&gt; m_weakCopyOfActiveStyleSheetListForFastLookup;
165 
166     // Track the currently loading top-level stylesheets needed for rendering.
167     // Sheets loaded using the @import directive are not included in this count.
168     // We use this count of pending sheets to detect when we can begin attaching
169     // elements and when it is safe to execute scripts.
170     HashSet&lt;const ProcessingInstruction*&gt; m_processingInstructionsWithPendingSheets;
171     HashSet&lt;const Element*&gt; m_elementsInHeadWithPendingSheets;
172     HashSet&lt;const Element*&gt; m_elementsInBodyWithPendingSheets;
173 
174     Optional&lt;UpdateType&gt; m_pendingUpdate;
175     bool m_hasDescendantWithPendingUpdate { false };
176 
177     ListHashSet&lt;Node*&gt; m_styleSheetCandidateNodes;
</pre>
</td>
<td>
<hr />
<pre>
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;Timer.h&quot;
 31 #include &lt;memory&gt;
 32 #include &lt;wtf/FastMalloc.h&gt;
 33 #include &lt;wtf/HashSet.h&gt;
 34 #include &lt;wtf/ListHashSet.h&gt;
 35 #include &lt;wtf/RefPtr.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 class CSSStyleSheet;
 42 class Document;
 43 class Element;
 44 class Node;
 45 class ProcessingInstruction;

 46 class StyleSheet;
 47 class StyleSheetContents;
 48 class StyleSheetList;
 49 class ShadowRoot;
 50 class TreeScope;
 51 
 52 namespace Style {
 53 
<span class="line-added"> 54 class Resolver;</span>
<span class="line-added"> 55 </span>
 56 // This is used to identify style scopes that can affect an element.
 57 // Scopes are in tree-of-trees order. Styles from earlier scopes win over later ones (modulo !important).
 58 enum class ScopeOrdinal : int {
<span class="line-modified"> 59     ContainingHost = -1, // ::part rules and author-exposed UA pseudo classes from the host tree scope.</span>
 60     Element = 0, // Normal rules in the same tree where the element is.
 61     FirstSlot = 1, // ::slotted rules in the parent&#39;s shadow tree. Values greater than FirstSlot indicate subsequent slots in the chain.
 62     Shadow = std::numeric_limits&lt;int&gt;::max(), // :host rules in element&#39;s own shadow tree.
 63 };
 64 
 65 class Scope {
 66     WTF_MAKE_FAST_ALLOCATED;
 67 public:
 68     explicit Scope(Document&amp;);
 69     explicit Scope(ShadowRoot&amp;);
 70 
 71     ~Scope();
 72 
 73     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; activeStyleSheets() const { return m_activeStyleSheets; }
 74 
 75     const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; styleSheetsForStyleSheetList();
 76     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; activeStyleSheetsForInspector();
 77 
 78     void addStyleSheetCandidateNode(Node&amp;, bool createdByParser);
 79     void removeStyleSheetCandidateNode(Node&amp;);
</pre>
<hr />
<pre>
 91     bool hasPendingSheet(const Element&amp;) const;
 92     bool hasPendingSheetInBody(const Element&amp;) const;
 93     bool hasPendingSheet(const ProcessingInstruction&amp;) const;
 94 
 95     bool usesStyleBasedEditability() { return m_usesStyleBasedEditability; }
 96 
 97     bool activeStyleSheetsContains(const CSSStyleSheet*) const;
 98 
 99     void evaluateMediaQueriesForViewportChange();
100     void evaluateMediaQueriesForAccessibilitySettingsChange();
101     void evaluateMediaQueriesForAppearanceChange();
102 
103     // This is called when some stylesheet becomes newly enabled or disabled.
104     void didChangeActiveStyleSheetCandidates();
105     // This is called when contents of a stylesheet is mutated.
106     void didChangeStyleSheetContents();
107     // This is called when the environment where we intrepret the stylesheets changes (for example switching to printing).
108     // The change is assumed to potentially affect all author and user stylesheets including shadow roots.
109     WEBCORE_EXPORT void didChangeStyleSheetEnvironment();
110 
<span class="line-added">111     void invalidateMatchedDeclarationsCache();</span>
<span class="line-added">112 </span>
113     bool hasPendingUpdate() const { return m_pendingUpdate || m_hasDescendantWithPendingUpdate; }
114     void flushPendingUpdate();
115 
116 #if ENABLE(XSLT)
117     Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; collectXSLTransforms();
118 #endif
119 
<span class="line-modified">120     WEBCORE_EXPORT Resolver&amp; resolver();</span>
<span class="line-modified">121     Resolver* resolverIfExists();</span>
122     void clearResolver();
123     void releaseMemory();
124 
125     const Document&amp; document() const { return m_document; }
<span class="line-added">126     Document&amp; document() { return m_document; }</span>
<span class="line-added">127     const ShadowRoot* shadowRoot() const { return m_shadowRoot; }</span>
<span class="line-added">128     ShadowRoot* shadowRoot() { return m_shadowRoot; }</span>
129 
130     static Scope&amp; forNode(Node&amp;);
131     static Scope* forOrdinal(Element&amp;, ScopeOrdinal);
132 
133 private:
134     bool shouldUseSharedUserAgentShadowTreeStyleResolver() const;
135 
136     void didRemovePendingStylesheet();
137 
138     enum class UpdateType { ActiveSet, ContentsOrInterpretation };
139     void updateActiveStyleSheets(UpdateType);
140     void scheduleUpdate(UpdateType);
141 
142     template &lt;typename TestFunction&gt; void evaluateMediaQueries(TestFunction&amp;&amp;);
143 
144     WEBCORE_EXPORT void flushPendingSelfUpdate();
145     WEBCORE_EXPORT void flushPendingDescendantUpdates();
146 
147     void collectActiveStyleSheets(Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp;);
148 
<span class="line-modified">149     enum class ResolverUpdateType {</span>
150         Reconstruct,
151         Reset,
152         Additive
153     };
<span class="line-modified">154     struct StyleSheetChange {</span>
<span class="line-modified">155         ResolverUpdateType resolverUpdateType;</span>
<span class="line-added">156         Vector&lt;StyleSheetContents*&gt; addedSheets { };</span>
<span class="line-added">157     };</span>
<span class="line-added">158     StyleSheetChange analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets);</span>
<span class="line-added">159     void invalidateStyleAfterStyleSheetChange(const StyleSheetChange&amp;);</span>
<span class="line-added">160 </span>
<span class="line-added">161     void updateResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp;, ResolverUpdateType);</span>
162 
163     void pendingUpdateTimerFired();
164     void clearPendingUpdate();
165 
166     Document&amp; m_document;
167     ShadowRoot* m_shadowRoot { nullptr };
168 
<span class="line-modified">169     std::unique_ptr&lt;Resolver&gt; m_resolver;</span>
170 
171     Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; m_styleSheetsForStyleSheetList;
172     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; m_activeStyleSheets;
173 
174     Timer m_pendingUpdateTimer;
175 
176     mutable std::unique_ptr&lt;HashSet&lt;const CSSStyleSheet*&gt;&gt; m_weakCopyOfActiveStyleSheetListForFastLookup;
177 
178     // Track the currently loading top-level stylesheets needed for rendering.
179     // Sheets loaded using the @import directive are not included in this count.
180     // We use this count of pending sheets to detect when we can begin attaching
181     // elements and when it is safe to execute scripts.
182     HashSet&lt;const ProcessingInstruction*&gt; m_processingInstructionsWithPendingSheets;
183     HashSet&lt;const Element*&gt; m_elementsInHeadWithPendingSheets;
184     HashSet&lt;const Element*&gt; m_elementsInBodyWithPendingSheets;
185 
186     Optional&lt;UpdateType&gt; m_pendingUpdate;
187     bool m_hasDescendantWithPendingUpdate { false };
188 
189     ListHashSet&lt;Node*&gt; m_styleSheetCandidateNodes;
</pre>
</td>
</tr>
</table>
<center><a href="StyleScope.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleSharingResolver.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRExit.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGOSRExit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSRExitBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRExit.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 89     SpeculationRecoveryType type() { return m_type; }
 90     GPRReg dest() { return m_dest; }
 91     GPRReg src() { return m_src; }
 92     int32_t immediate() { return m_immediate; }
 93 
 94 private:
 95     // different recovery types may required different additional information here.
 96     union {
 97         GPRReg m_src;
 98         int32_t m_immediate;
 99     };
100     GPRReg m_dest;
101 
102     // Indicates the type of additional recovery to be performed.
103     SpeculationRecoveryType m_type;
104 };
105 
106 enum class ExtraInitializationLevel;
107 
108 struct OSRExitState : RefCounted&lt;OSRExitState&gt; {
<span class="line-modified">109     OSRExitState(OSRExitBase&amp; exit, CodeBlock* codeBlock, CodeBlock* baselineCodeBlock, Operands&lt;ValueRecovery&gt;&amp; operands, Vector&lt;UndefinedOperandSpan&gt;&amp;&amp; undefinedOperandSpans, SpeculationRecovery* recovery, ptrdiff_t stackPointerOffset, int32_t activeThreshold, double memoryUsageAdjustedThreshold, void* jumpTarget, ArrayProfile* arrayProfile)</span>
110         : exit(exit)
111         , codeBlock(codeBlock)
112         , baselineCodeBlock(baselineCodeBlock)
113         , operands(operands)
114         , undefinedOperandSpans(undefinedOperandSpans)
115         , recovery(recovery)
116         , stackPointerOffset(stackPointerOffset)
117         , activeThreshold(activeThreshold)
118         , memoryUsageAdjustedThreshold(memoryUsageAdjustedThreshold)
119         , jumpTarget(jumpTarget)
120         , arrayProfile(arrayProfile)

121     { }
122 
123     OSRExitBase&amp; exit;
124     CodeBlock* codeBlock;
125     CodeBlock* baselineCodeBlock;
126     Operands&lt;ValueRecovery&gt; operands;
127     Vector&lt;UndefinedOperandSpan&gt; undefinedOperandSpans;
128     SpeculationRecovery* recovery;
129     ptrdiff_t stackPointerOffset;
130     uint32_t activeThreshold;
131     double memoryUsageAdjustedThreshold;
132     void* jumpTarget;
133     ArrayProfile* arrayProfile;

134 
135     ExtraInitializationLevel extraInitializationLevel;
136     Profiler::OSRExit* profilerExit { nullptr };
137 };
138 



139 // === OSRExit ===
140 //
141 // This structure describes how to exit the speculative path by
142 // going into baseline code.
143 struct OSRExit : public OSRExitBase {
144     OSRExit(ExitKind, JSValueSource, MethodOfGettingAValueProfile, SpeculativeJIT*, unsigned streamIndex, unsigned recoveryIndex = UINT_MAX);
145 
<span class="line-modified">146     static void JIT_OPERATION compileOSRExit(ExecState*) WTF_INTERNAL;</span>
<span class="line-removed">147     static void executeOSRExit(Probe::Context&amp;);</span>
148 
149     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_patchableJumpLocation;
150     MacroAssemblerCodeRef&lt;OSRExitPtrTag&gt; m_code;
151 
152     RefPtr&lt;OSRExitState&gt; exitState;
153 
154     JSValueSource m_jsValueSource;
155     MethodOfGettingAValueProfile m_valueProfile;
156 
157     unsigned m_recoveryIndex;
158 
159     CodeLocationJump&lt;JSInternalPtrTag&gt; codeLocationForRepatch() const;
160 
161     unsigned m_streamIndex;
162     void considerAddingAsFrequentExitSite(CodeBlock* profiledCodeBlock)
163     {
164         OSRExitBase::considerAddingAsFrequentExitSite(profiledCodeBlock, ExitFromDFG);
165     }
166 
167 private:
168     static void compileExit(CCallHelpers&amp;, VM&amp;, const OSRExit&amp;, const Operands&lt;ValueRecovery&gt;&amp;, SpeculationRecovery*);
<span class="line-modified">169     static void emitRestoreArguments(CCallHelpers&amp;, const Operands&lt;ValueRecovery&gt;&amp;);</span>
<span class="line-modified">170     static void JIT_OPERATION debugOperationPrintSpeculationFailure(ExecState*, void*, void*) WTF_INTERNAL;</span>
171 };
172 
173 struct SpeculationFailureDebugInfo {
174     WTF_MAKE_STRUCT_FAST_ALLOCATED;
175     CodeBlock* codeBlock;
176     ExitKind kind;
<span class="line-modified">177     unsigned bytecodeOffset;</span>
178 };
179 
180 } } // namespace JSC::DFG
181 
182 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
 89     SpeculationRecoveryType type() { return m_type; }
 90     GPRReg dest() { return m_dest; }
 91     GPRReg src() { return m_src; }
 92     int32_t immediate() { return m_immediate; }
 93 
 94 private:
 95     // different recovery types may required different additional information here.
 96     union {
 97         GPRReg m_src;
 98         int32_t m_immediate;
 99     };
100     GPRReg m_dest;
101 
102     // Indicates the type of additional recovery to be performed.
103     SpeculationRecoveryType m_type;
104 };
105 
106 enum class ExtraInitializationLevel;
107 
108 struct OSRExitState : RefCounted&lt;OSRExitState&gt; {
<span class="line-modified">109     OSRExitState(OSRExitBase&amp; exit, CodeBlock* codeBlock, CodeBlock* baselineCodeBlock, Operands&lt;ValueRecovery&gt;&amp; operands, Vector&lt;UndefinedOperandSpan&gt;&amp;&amp; undefinedOperandSpans, SpeculationRecovery* recovery, ptrdiff_t stackPointerOffset, int32_t activeThreshold, double memoryUsageAdjustedThreshold, void* jumpTarget, ArrayProfile* arrayProfile, bool isJumpToLLInt)</span>
110         : exit(exit)
111         , codeBlock(codeBlock)
112         , baselineCodeBlock(baselineCodeBlock)
113         , operands(operands)
114         , undefinedOperandSpans(undefinedOperandSpans)
115         , recovery(recovery)
116         , stackPointerOffset(stackPointerOffset)
117         , activeThreshold(activeThreshold)
118         , memoryUsageAdjustedThreshold(memoryUsageAdjustedThreshold)
119         , jumpTarget(jumpTarget)
120         , arrayProfile(arrayProfile)
<span class="line-added">121         , isJumpToLLInt(isJumpToLLInt)</span>
122     { }
123 
124     OSRExitBase&amp; exit;
125     CodeBlock* codeBlock;
126     CodeBlock* baselineCodeBlock;
127     Operands&lt;ValueRecovery&gt; operands;
128     Vector&lt;UndefinedOperandSpan&gt; undefinedOperandSpans;
129     SpeculationRecovery* recovery;
130     ptrdiff_t stackPointerOffset;
131     uint32_t activeThreshold;
132     double memoryUsageAdjustedThreshold;
133     void* jumpTarget;
134     ArrayProfile* arrayProfile;
<span class="line-added">135     bool isJumpToLLInt;</span>
136 
137     ExtraInitializationLevel extraInitializationLevel;
138     Profiler::OSRExit* profilerExit { nullptr };
139 };
140 
<span class="line-added">141 void JIT_OPERATION operationCompileOSRExit(CallFrame*) WTF_INTERNAL;</span>
<span class="line-added">142 void JIT_OPERATION operationDebugPrintSpeculationFailure(CallFrame*, void*, void*) WTF_INTERNAL;</span>
<span class="line-added">143 </span>
144 // === OSRExit ===
145 //
146 // This structure describes how to exit the speculative path by
147 // going into baseline code.
148 struct OSRExit : public OSRExitBase {
149     OSRExit(ExitKind, JSValueSource, MethodOfGettingAValueProfile, SpeculativeJIT*, unsigned streamIndex, unsigned recoveryIndex = UINT_MAX);
150 
<span class="line-modified">151     friend void JIT_OPERATION operationCompileOSRExit(CallFrame*);</span>

152 
153     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_patchableJumpLocation;
154     MacroAssemblerCodeRef&lt;OSRExitPtrTag&gt; m_code;
155 
156     RefPtr&lt;OSRExitState&gt; exitState;
157 
158     JSValueSource m_jsValueSource;
159     MethodOfGettingAValueProfile m_valueProfile;
160 
161     unsigned m_recoveryIndex;
162 
163     CodeLocationJump&lt;JSInternalPtrTag&gt; codeLocationForRepatch() const;
164 
165     unsigned m_streamIndex;
166     void considerAddingAsFrequentExitSite(CodeBlock* profiledCodeBlock)
167     {
168         OSRExitBase::considerAddingAsFrequentExitSite(profiledCodeBlock, ExitFromDFG);
169     }
170 
171 private:
172     static void compileExit(CCallHelpers&amp;, VM&amp;, const OSRExit&amp;, const Operands&lt;ValueRecovery&gt;&amp;, SpeculationRecovery*);
<span class="line-modified">173     static void emitRestoreArguments(CCallHelpers&amp;, VM&amp;, const Operands&lt;ValueRecovery&gt;&amp;);</span>
<span class="line-modified">174     friend void JIT_OPERATION operationDebugPrintSpeculationFailure(CallFrame*, void*, void*);</span>
175 };
176 
177 struct SpeculationFailureDebugInfo {
178     WTF_MAKE_STRUCT_FAST_ALLOCATED;
179     CodeBlock* codeBlock;
180     ExitKind kind;
<span class="line-modified">181     BytecodeIndex bytecodeIndex;</span>
182 };
183 
184 } } // namespace JSC::DFG
185 
186 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGOSRExit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSRExitBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
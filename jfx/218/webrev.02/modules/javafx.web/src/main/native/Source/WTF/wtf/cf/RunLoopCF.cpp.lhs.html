<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/cf/RunLoopCF.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2010, 2012 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &lt;wtf/RunLoop.h&gt;
 28 
 29 #include &lt;CoreFoundation/CoreFoundation.h&gt;
 30 #include &lt;dispatch/dispatch.h&gt;
 31 #include &lt;wtf/AutodrainedPool.h&gt;
 32 
 33 namespace WTF {
 34 
 35 void RunLoop::performWork(void* context)
 36 {
 37     AutodrainedPool pool;
 38     static_cast&lt;RunLoop*&gt;(context)-&gt;performWork();
 39 }
 40 
 41 RunLoop::RunLoop()
 42     : m_runLoop(CFRunLoopGetCurrent())
 43 {
 44     CFRunLoopSourceContext context = { 0, this, 0, 0, 0, 0, 0, 0, 0, performWork };
 45     m_runLoopSource = adoptCF(CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;context));
 46     CFRunLoopAddSource(m_runLoop.get(), m_runLoopSource.get(), kCFRunLoopCommonModes);
 47 }
 48 
 49 RunLoop::~RunLoop()
 50 {
 51     CFRunLoopSourceInvalidate(m_runLoopSource.get());
 52 }
 53 
 54 void RunLoop::runForDuration(Seconds duration)
 55 {
 56     CFRunLoopRunInMode(kCFRunLoopDefaultMode, duration.seconds(), true);
 57 }
 58 
 59 void RunLoop::wakeUp()
 60 {
 61     CFRunLoopSourceSignal(m_runLoopSource.get());
 62     CFRunLoopWakeUp(m_runLoop.get());
 63 }
 64 
<a name="2" id="anc2"></a>






 65 void RunLoop::run()
 66 {
 67     AutodrainedPool pool;
 68     CFRunLoopRun();
 69 }
 70 
 71 void RunLoop::stop()
 72 {
 73     ASSERT(m_runLoop == CFRunLoopGetCurrent());
 74     CFRunLoopStop(m_runLoop.get());
 75 }
 76 
 77 // RunLoop::Timer
 78 
 79 void RunLoop::TimerBase::timerFired(CFRunLoopTimerRef, void* context)
 80 {
 81     TimerBase* timer = static_cast&lt;TimerBase*&gt;(context);
 82 
 83     AutodrainedPool pool;
 84     timer-&gt;fired();
 85 }
 86 
 87 RunLoop::TimerBase::TimerBase(RunLoop&amp; runLoop)
 88     : m_runLoop(runLoop)
 89 {
 90 }
 91 
 92 RunLoop::TimerBase::~TimerBase()
 93 {
 94     stop();
 95 }
 96 
 97 void RunLoop::TimerBase::start(Seconds nextFireInterval, bool repeat)
 98 {
 99     if (m_timer)
100         stop();
101 
102     CFRunLoopTimerContext context = { 0, this, 0, 0, 0 };
103     Seconds repeatInterval = repeat ? nextFireInterval : 0_s;
104     m_timer = adoptCF(CFRunLoopTimerCreate(kCFAllocatorDefault, CFAbsoluteTimeGetCurrent() + nextFireInterval.seconds(), repeatInterval.seconds(), 0, 0, timerFired, &amp;context));
105     CFRunLoopAddTimer(m_runLoop-&gt;m_runLoop.get(), m_timer.get(), kCFRunLoopCommonModes);
106 }
107 
108 void RunLoop::TimerBase::stop()
109 {
110     if (!m_timer)
111         return;
112 
113     CFRunLoopTimerInvalidate(m_timer.get());
114     m_timer = nullptr;
115 }
116 
117 bool RunLoop::TimerBase::isActive() const
118 {
119     return m_timer &amp;&amp; CFRunLoopTimerIsValid(m_timer.get());
120 }
121 
122 Seconds RunLoop::TimerBase::secondsUntilFire() const
123 {
124     if (isActive())
125         return std::max&lt;Seconds&gt;(Seconds { CFRunLoopTimerGetNextFireDate(m_timer.get()) - CFAbsoluteTimeGetCurrent() }, 0_s);
126     return 0_s;
127 }
128 
129 } // namespace WTF
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
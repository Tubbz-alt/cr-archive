<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLVisitor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLVisitor.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLAST.h&quot;
 32 #include &quot;WHLSLProgram.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 namespace WHLSL {
 37 
 38 void Visitor::visit(Program&amp; program)
 39 {
 40     // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
 41     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 42         checkErrorAndVisit(program.typeDefinitions()[i]);
 43     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 44         checkErrorAndVisit(program.structureDefinitions()[i]);
 45     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 46         checkErrorAndVisit(program.enumerationDefinitions()[i]);
 47     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 48         checkErrorAndVisit(program.functionDefinitions()[i]);
 49     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 50         checkErrorAndVisit(program.nativeFunctionDeclarations()[i]);
 51     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 52         checkErrorAndVisit(program.nativeTypeDeclarations()[i]);
 53 }
 54 
 55 void Visitor::visit(AST::UnnamedType&amp; unnamedType)
 56 {
 57     if (is&lt;AST::TypeReference&gt;(unnamedType))
 58         checkErrorAndVisit(downcast&lt;AST::TypeReference&gt;(unnamedType));
 59     else if (is&lt;AST::PointerType&gt;(unnamedType))
 60         checkErrorAndVisit(downcast&lt;AST::PointerType&gt;(unnamedType));
 61     else if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))
 62         checkErrorAndVisit(downcast&lt;AST::ArrayReferenceType&gt;(unnamedType));
 63     else
 64         checkErrorAndVisit(downcast&lt;AST::ArrayType&gt;(unnamedType));
 65 }
 66 
 67 void Visitor::visit(AST::NamedType&amp; namedType)
 68 {
 69     if (is&lt;AST::TypeDefinition&gt;(namedType))
 70         checkErrorAndVisit(downcast&lt;AST::TypeDefinition&gt;(namedType));
 71     else if (is&lt;AST::StructureDefinition&gt;(namedType))
 72         checkErrorAndVisit(downcast&lt;AST::StructureDefinition&gt;(namedType));
 73     else if (is&lt;AST::EnumerationDefinition&gt;(namedType))
 74         checkErrorAndVisit(downcast&lt;AST::EnumerationDefinition&gt;(namedType));
 75     else
 76         checkErrorAndVisit(downcast&lt;AST::NativeTypeDeclaration&gt;(namedType));
 77 }
 78 
 79 void Visitor::visit(AST::TypeDefinition&amp; typeDefinition)
 80 {
 81     checkErrorAndVisit(typeDefinition.type());
 82 }
 83 
 84 void Visitor::visit(AST::StructureDefinition&amp; structureDefinition)
 85 {
 86     for (auto&amp; structureElement : structureDefinition.structureElements())
 87         checkErrorAndVisit(structureElement);
 88 }
 89 
 90 void Visitor::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
 91 {
 92     checkErrorAndVisit(enumerationDefinition.type());
 93     for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers())
 94         checkErrorAndVisit(enumerationMember);
 95 }
 96 
 97 void Visitor::visit(AST::FunctionDefinition&amp; functionDefinition)
 98 {
 99     checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));
100     checkErrorAndVisit(functionDefinition.block());
101 }
102 
103 void Visitor::visit(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration)
104 {
105     checkErrorAndVisit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(nativeFunctionDeclaration));
106 }
107 
108 void Visitor::visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
109 {
110     for (auto&amp; typeArgument : nativeTypeDeclaration.typeArguments())
111         checkErrorAndVisit(typeArgument);
112 }
113 
114 void Visitor::visit(AST::TypeReference&amp; typeReference)
115 {
116     for (auto&amp; typeArgument : typeReference.typeArguments())
117         checkErrorAndVisit(typeArgument);
118     if (typeReference.maybeResolvedType() &amp;&amp; is&lt;AST::TypeDefinition&gt;(typeReference.resolvedType())) {
119         auto&amp; typeDefinition = downcast&lt;AST::TypeDefinition&gt;(typeReference.resolvedType());
120         checkErrorAndVisit(typeDefinition.type());
121     }
122 }
123 
124 void Visitor::visit(AST::PointerType&amp; pointerType)
125 {
126     checkErrorAndVisit(static_cast&lt;AST::ReferenceType&amp;&gt;(pointerType));
127 }
128 
129 void Visitor::visit(AST::ArrayReferenceType&amp; arrayReferenceType)
130 {
131     checkErrorAndVisit(static_cast&lt;AST::ReferenceType&amp;&gt;(arrayReferenceType));
132 }
133 
134 void Visitor::visit(AST::ArrayType&amp; arrayType)
135 {
136     checkErrorAndVisit(arrayType.type());
137 }
138 
139 void Visitor::visit(AST::StructureElement&amp; structureElement)
140 {
141     checkErrorAndVisit(structureElement.type());
142     if (structureElement.semantic())
143         checkErrorAndVisit(*structureElement.semantic());
144 }
145 
146 void Visitor::visit(AST::EnumerationMember&amp;)
147 {
148 }
149 
150 void Visitor::visit(AST::FunctionDeclaration&amp; functionDeclaration)
151 {
152     checkErrorAndVisit(functionDeclaration.attributeBlock());
153     checkErrorAndVisit(functionDeclaration.type());
154     for (auto&amp; parameter : functionDeclaration.parameters())
155         checkErrorAndVisit(parameter);
156     if (functionDeclaration.semantic())
157         checkErrorAndVisit(*functionDeclaration.semantic());
158 }
159 
160 void Visitor::visit(AST::TypeArgument&amp; typeArgument)
161 {
162     WTF::visit(WTF::makeVisitor([&amp;](AST::ConstantExpression&amp; constantExpression) {
163         checkErrorAndVisit(constantExpression);
164     }, [&amp;](Ref&lt;AST::TypeReference&gt;&amp; typeReference) {
165         checkErrorAndVisit(typeReference);
166     }), typeArgument);
167 }
168 
169 void Visitor::visit(AST::ReferenceType&amp; referenceType)
170 {
171     checkErrorAndVisit(referenceType.elementType());
172 }
173 
174 void Visitor::visit(AST::Semantic&amp; semantic)
175 {
176     WTF::visit(WTF::makeVisitor([&amp;](AST::BuiltInSemantic&amp; builtInSemantic) {
177         checkErrorAndVisit(builtInSemantic);
178     }, [&amp;](AST::ResourceSemantic&amp; resourceSemantic) {
179         checkErrorAndVisit(resourceSemantic);
180     }, [&amp;](AST::SpecializationConstantSemantic&amp; specializationConstantSemantic) {
181         checkErrorAndVisit(specializationConstantSemantic);
182     }, [&amp;](AST::StageInOutSemantic&amp; stageInOutSemantic) {
183         checkErrorAndVisit(stageInOutSemantic);
184     }), semantic);
185 }
186 
187 void Visitor::visit(AST::ConstantExpression&amp; constantExpression)
188 {
189     constantExpression.visit(WTF::makeVisitor([&amp;](AST::IntegerLiteral&amp; integerLiteral) {
190         checkErrorAndVisit(integerLiteral);
191     }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
192         checkErrorAndVisit(unsignedIntegerLiteral);
193     }, [&amp;](AST::FloatLiteral&amp; floatLiteral) {
194         checkErrorAndVisit(floatLiteral);
<a name="1" id="anc1"></a>

195     }, [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
196         checkErrorAndVisit(booleanLiteral);
197     }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
198         checkErrorAndVisit(enumerationMemberLiteral);
199     }));
200 }
201 
202 void Visitor::visit(AST::AttributeBlock&amp; attributeBlock)
203 {
204     for (auto&amp; functionAttribute : attributeBlock)
205         checkErrorAndVisit(functionAttribute);
206 }
207 
208 void Visitor::visit(AST::BuiltInSemantic&amp;)
209 {
210 }
211 
212 void Visitor::visit(AST::ResourceSemantic&amp;)
213 {
214 }
215 
216 void Visitor::visit(AST::SpecializationConstantSemantic&amp;)
217 {
218 }
219 
220 void Visitor::visit(AST::StageInOutSemantic&amp;)
221 {
222 }
223 
224 void Visitor::visit(AST::IntegerLiteral&amp; integerLiteral)
225 {
226     checkErrorAndVisit(integerLiteral.type());
227 }
228 
229 void Visitor::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
230 {
231     checkErrorAndVisit(unsignedIntegerLiteral.type());
232 }
233 
234 void Visitor::visit(AST::FloatLiteral&amp; floatLiteral)
235 {
236     checkErrorAndVisit(floatLiteral.type());
237 }
238 
<a name="2" id="anc2"></a>




239 void Visitor::visit(AST::BooleanLiteral&amp;)
240 {
241 }
242 
243 void Visitor::visit(AST::IntegerLiteralType&amp; integerLiteralType)
244 {
245     if (integerLiteralType.maybeResolvedType())
246         checkErrorAndVisit(integerLiteralType.resolvedType());
247     checkErrorAndVisit(integerLiteralType.preferredType());
248 }
249 
250 void Visitor::visit(AST::UnsignedIntegerLiteralType&amp; unsignedIntegerLiteralType)
251 {
252     if (unsignedIntegerLiteralType.maybeResolvedType())
253         checkErrorAndVisit(unsignedIntegerLiteralType.resolvedType());
254     checkErrorAndVisit(unsignedIntegerLiteralType.preferredType());
255 }
256 
257 void Visitor::visit(AST::FloatLiteralType&amp; floatLiteralType)
258 {
259     if (floatLiteralType.maybeResolvedType())
260         checkErrorAndVisit(floatLiteralType.resolvedType());
261     checkErrorAndVisit(floatLiteralType.preferredType());
262 }
263 
<a name="3" id="anc3"></a>





264 void Visitor::visit(AST::EnumerationMemberLiteral&amp;)
265 {
266 }
267 
268 void Visitor::visit(AST::FunctionAttribute&amp; functionAttribute)
269 {
270     WTF::visit(WTF::makeVisitor([&amp;](AST::NumThreadsFunctionAttribute&amp; numThreadsFunctionAttribute) {
271         checkErrorAndVisit(numThreadsFunctionAttribute);
272     }), functionAttribute);
273 }
274 
275 void Visitor::visit(AST::NumThreadsFunctionAttribute&amp;)
276 {
277 }
278 
279 void Visitor::visit(AST::Block&amp; block)
280 {
281     for (auto&amp; statement : block.statements())
282         checkErrorAndVisit(statement);
283 }
284 
285 void Visitor::visit(AST::StatementList&amp; statementList)
286 {
287     for (auto&amp; statement : statementList.statements())
288         checkErrorAndVisit(statement);
289 }
290 
291 void Visitor::visit(AST::Statement&amp; statement)
292 {
293     switch (statement.kind()) {
294     case AST::Statement::Kind::Block:
295         checkErrorAndVisit(downcast&lt;AST::Block&gt;(statement));
296         break;
297     case AST::Statement::Kind::Break:
298         checkErrorAndVisit(downcast&lt;AST::Break&gt;(statement));
299         break;
300     case AST::Statement::Kind::Continue:
301         checkErrorAndVisit(downcast&lt;AST::Continue&gt;(statement));
302         break;
303     case AST::Statement::Kind::DoWhileLoop:
304         checkErrorAndVisit(downcast&lt;AST::DoWhileLoop&gt;(statement));
305         break;
306     case AST::Statement::Kind::EffectfulExpression:
307         checkErrorAndVisit(downcast&lt;AST::EffectfulExpressionStatement&gt;(statement));
308         break;
309     case AST::Statement::Kind::Fallthrough:
310         checkErrorAndVisit(downcast&lt;AST::Fallthrough&gt;(statement));
311         break;
312     case AST::Statement::Kind::ForLoop:
313         checkErrorAndVisit(downcast&lt;AST::ForLoop&gt;(statement));
314         break;
315     case AST::Statement::Kind::If:
316         checkErrorAndVisit(downcast&lt;AST::IfStatement&gt;(statement));
317         break;
318     case AST::Statement::Kind::Return:
319         checkErrorAndVisit(downcast&lt;AST::Return&gt;(statement));
320         break;
321     case AST::Statement::Kind::StatementList:
322         checkErrorAndVisit(downcast&lt;AST::StatementList&gt;(statement));
323         break;
324     case AST::Statement::Kind::SwitchCase:
325         checkErrorAndVisit(downcast&lt;AST::SwitchCase&gt;(statement));
326         break;
327     case AST::Statement::Kind::Switch:
328         checkErrorAndVisit(downcast&lt;AST::SwitchStatement&gt;(statement));
329         break;
330     case AST::Statement::Kind::VariableDeclarations:
331         checkErrorAndVisit(downcast&lt;AST::VariableDeclarationsStatement&gt;(statement));
332         break;
333     case AST::Statement::Kind::WhileLoop:
334         checkErrorAndVisit(downcast&lt;AST::WhileLoop&gt;(statement));
335         break;
336     }
337 }
338 
339 void Visitor::visit(AST::Break&amp;)
340 {
341 }
342 
343 void Visitor::visit(AST::Continue&amp;)
344 {
345 }
346 
347 void Visitor::visit(AST::DoWhileLoop&amp; doWhileLoop)
348 {
349     checkErrorAndVisit(doWhileLoop.body());
350     checkErrorAndVisit(doWhileLoop.conditional());
351 }
352 
353 void Visitor::visit(AST::Expression&amp; expression)
354 {
355     switch (expression.kind()) {
356     case AST::Expression::Kind::Assignment:
357         checkErrorAndVisit(downcast&lt;AST::AssignmentExpression&gt;(expression));
358         break;
359     case AST::Expression::Kind::BooleanLiteral:
360         checkErrorAndVisit(downcast&lt;AST::BooleanLiteral&gt;(expression));
361         break;
362     case AST::Expression::Kind::Call:
363         checkErrorAndVisit(downcast&lt;AST::CallExpression&gt;(expression));
364         break;
365     case AST::Expression::Kind::Comma:
366         checkErrorAndVisit(downcast&lt;AST::CommaExpression&gt;(expression));
367         break;
368     case AST::Expression::Kind::Dereference:
369         checkErrorAndVisit(downcast&lt;AST::DereferenceExpression&gt;(expression));
370         break;
371     case AST::Expression::Kind::FloatLiteral:
372         checkErrorAndVisit(downcast&lt;AST::FloatLiteral&gt;(expression));
373         break;
374     case AST::Expression::Kind::IntegerLiteral:
375         checkErrorAndVisit(downcast&lt;AST::IntegerLiteral&gt;(expression));
376         break;
377     case AST::Expression::Kind::Logical:
378         checkErrorAndVisit(downcast&lt;AST::LogicalExpression&gt;(expression));
379         break;
380     case AST::Expression::Kind::LogicalNot:
381         checkErrorAndVisit(downcast&lt;AST::LogicalNotExpression&gt;(expression));
382         break;
383     case AST::Expression::Kind::MakeArrayReference:
384         checkErrorAndVisit(downcast&lt;AST::MakeArrayReferenceExpression&gt;(expression));
385         break;
386     case AST::Expression::Kind::MakePointer:
387         checkErrorAndVisit(downcast&lt;AST::MakePointerExpression&gt;(expression));
388         break;
<a name="4" id="anc4"></a>


389     case AST::Expression::Kind::Dot:
390         checkErrorAndVisit(downcast&lt;AST::DotExpression&gt;(expression));
391         break;
392     case AST::Expression::Kind::GlobalVariableReference:
393         checkErrorAndVisit(downcast&lt;AST::GlobalVariableReference&gt;(expression));
394         break;
395     case AST::Expression::Kind::Index:
396         checkErrorAndVisit(downcast&lt;AST::IndexExpression&gt;(expression));
397         break;
398     case AST::Expression::Kind::ReadModifyWrite:
399         checkErrorAndVisit(downcast&lt;AST::ReadModifyWriteExpression&gt;(expression));
400         break;
401     case AST::Expression::Kind::Ternary:
402         checkErrorAndVisit(downcast&lt;AST::TernaryExpression&gt;(expression));
403         break;
404     case AST::Expression::Kind::UnsignedIntegerLiteral:
405         checkErrorAndVisit(downcast&lt;AST::UnsignedIntegerLiteral&gt;(expression));
406         break;
407     case AST::Expression::Kind::EnumerationMemberLiteral:
408         checkErrorAndVisit(downcast&lt;AST::EnumerationMemberLiteral&gt;(expression));
409         break;
410     case AST::Expression::Kind::VariableReference:
411         checkErrorAndVisit(downcast&lt;AST::VariableReference&gt;(expression));
412         break;
413     }
414 }
415 
416 void Visitor::visit(AST::DotExpression&amp; dotExpression)
417 {
418     checkErrorAndVisit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(dotExpression));
419 }
420 
421 void Visitor::visit(AST::GlobalVariableReference&amp; globalVariableReference)
422 {
423     checkErrorAndVisit(globalVariableReference.base());
424 }
425 
426 void Visitor::visit(AST::IndexExpression&amp; indexExpression)
427 {
428     checkErrorAndVisit(indexExpression.indexExpression());
429     checkErrorAndVisit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(indexExpression));
430 }
431 
432 void Visitor::visit(AST::PropertyAccessExpression&amp; expression)
433 {
434     checkErrorAndVisit(expression.base());
435 }
436 
437 void Visitor::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
438 {
439     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
440 }
441 
442 void Visitor::visit(AST::Fallthrough&amp;)
443 {
444 }
445 
446 void Visitor::visit(AST::ForLoop&amp; forLoop)
447 {
448     checkErrorAndVisit(forLoop.initialization());
449     if (forLoop.condition())
450         checkErrorAndVisit(*forLoop.condition());
451     if (forLoop.increment())
452         checkErrorAndVisit(*forLoop.increment());
453     checkErrorAndVisit(forLoop.body());
454 }
455 
456 void Visitor::visit(AST::IfStatement&amp; ifStatement)
457 {
458     checkErrorAndVisit(ifStatement.conditional());
459     checkErrorAndVisit(ifStatement.body());
460     if (ifStatement.elseBody())
461         checkErrorAndVisit(*ifStatement.elseBody());
462 }
463 
464 void Visitor::visit(AST::Return&amp; returnStatement)
465 {
466     if (returnStatement.value())
467         checkErrorAndVisit(*returnStatement.value());
468 }
469 
470 void Visitor::visit(AST::SwitchCase&amp; switchCase)
471 {
472     if (switchCase.value())
473         checkErrorAndVisit(*switchCase.value());
474     checkErrorAndVisit(switchCase.block());
475 }
476 
477 void Visitor::visit(AST::SwitchStatement&amp; switchStatement)
478 {
479     checkErrorAndVisit(switchStatement.value());
480     for (auto&amp; switchCase : switchStatement.switchCases())
481         checkErrorAndVisit(switchCase);
482 }
483 
484 void Visitor::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
485 {
486     for (auto&amp; variableDeclaration : variableDeclarationsStatement.variableDeclarations())
487         checkErrorAndVisit(variableDeclaration.get());
488 }
489 
490 void Visitor::visit(AST::WhileLoop&amp; whileLoop)
491 {
492     checkErrorAndVisit(whileLoop.conditional());
493     checkErrorAndVisit(whileLoop.body());
494 }
495 
496 void Visitor::visit(AST::VariableDeclaration&amp; variableDeclaration)
497 {
498     if (variableDeclaration.type())
499         checkErrorAndVisit(*variableDeclaration.type());
500     if (variableDeclaration.semantic())
501         checkErrorAndVisit(*variableDeclaration.semantic());
502     if (variableDeclaration.initializer())
503         checkErrorAndVisit(*variableDeclaration.initializer());
504 }
505 
506 void Visitor::visit(AST::AssignmentExpression&amp; assignmentExpression)
507 {
508     checkErrorAndVisit(assignmentExpression.left());
509     checkErrorAndVisit(assignmentExpression.right());
510 }
511 
512 void Visitor::visit(AST::CallExpression&amp; callExpression)
513 {
514     for (auto&amp; argument : callExpression.arguments())
515         checkErrorAndVisit(argument);
516     if (callExpression.castReturnType())
517         checkErrorAndVisit(*callExpression.castReturnType());
518 }
519 
520 void Visitor::visit(AST::CommaExpression&amp; commaExpression)
521 {
522     for (auto&amp; expression : commaExpression.list())
523         checkErrorAndVisit(expression);
524 }
525 
526 void Visitor::visit(AST::DereferenceExpression&amp; dereferenceExpression)
527 {
528     checkErrorAndVisit(dereferenceExpression.pointer());
529 }
530 
531 void Visitor::visit(AST::LogicalExpression&amp; logicalExpression)
532 {
533     checkErrorAndVisit(logicalExpression.left());
534     checkErrorAndVisit(logicalExpression.right());
535 }
536 
537 void Visitor::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
538 {
539     checkErrorAndVisit(logicalNotExpression.operand());
540 }
541 
542 void Visitor::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
543 {
544     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());
545 }
546 
547 void Visitor::visit(AST::MakePointerExpression&amp; makePointerExpression)
548 {
549     checkErrorAndVisit(makePointerExpression.leftValue());
550 }
551 
552 void Visitor::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
553 {
554     checkErrorAndVisit(readModifyWriteExpression.leftValue());
555     checkErrorAndVisit(readModifyWriteExpression.oldValue());
556     checkErrorAndVisit(readModifyWriteExpression.newValue());
557     checkErrorAndVisit(readModifyWriteExpression.newValueExpression());
558     checkErrorAndVisit(readModifyWriteExpression.resultExpression());
559 }
560 
561 void Visitor::visit(AST::TernaryExpression&amp; ternaryExpression)
562 {
563     checkErrorAndVisit(ternaryExpression.predicate());
564     checkErrorAndVisit(ternaryExpression.bodyExpression());
565     checkErrorAndVisit(ternaryExpression.elseExpression());
566 }
567 
568 void Visitor::visit(AST::VariableReference&amp;)
569 {
570 }
571 
572 } // namespace WHLSL
573 
574 } // namespace WebCore
575 
576 #endif // ENABLE(WEBGPU)
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
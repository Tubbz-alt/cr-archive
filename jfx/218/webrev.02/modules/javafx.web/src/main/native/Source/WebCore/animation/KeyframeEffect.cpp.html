<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;KeyframeEffect.h&quot;
  28 
  29 #include &quot;Animation.h&quot;
  30 #include &quot;CSSAnimation.h&quot;
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSKeyframeRule.h&quot;
  33 #include &quot;CSSPropertyAnimation.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSStyleDeclaration.h&quot;
  36 #include &quot;CSSTimingFunctionValue.h&quot;
  37 #include &quot;CSSTransition.h&quot;
  38 #include &quot;Element.h&quot;
  39 #include &quot;FontCascade.h&quot;
  40 #include &quot;FrameView.h&quot;
  41 #include &quot;GeometryUtilities.h&quot;
  42 #include &quot;InspectorInstrumentation.h&quot;
  43 #include &quot;JSCompositeOperation.h&quot;
  44 #include &quot;JSCompositeOperationOrAuto.h&quot;
  45 #include &quot;JSDOMConvert.h&quot;
  46 #include &quot;JSKeyframeEffect.h&quot;
  47 #include &quot;KeyframeEffectStack.h&quot;
  48 #include &quot;Logging.h&quot;
  49 #include &quot;RenderBox.h&quot;
  50 #include &quot;RenderBoxModelObject.h&quot;
  51 #include &quot;RenderElement.h&quot;
  52 #include &quot;RenderStyle.h&quot;
  53 #include &quot;RuntimeEnabledFeatures.h&quot;
  54 #include &quot;StyleAdjuster.h&quot;
  55 #include &quot;StylePendingResources.h&quot;
  56 #include &quot;StyleResolver.h&quot;
  57 #include &quot;TimingFunction.h&quot;
  58 #include &quot;TranslateTransformOperation.h&quot;
  59 #include &quot;WillChangeData.h&quot;
  60 #include &lt;JavaScriptCore/Exception.h&gt;
  61 #include &lt;wtf/UUID.h&gt;
  62 #include &lt;wtf/text/TextStream.h&gt;
  63 
  64 namespace WebCore {
  65 using namespace JSC;
  66 
  67 static inline void invalidateElement(Element* element)
  68 {
  69     if (element)
  70         element-&gt;invalidateStyle();
  71 }
  72 
  73 static inline String CSSPropertyIDToIDLAttributeName(CSSPropertyID cssPropertyId)
  74 {
  75     // https://drafts.csswg.org/web-animations-1/#animation-property-name-to-idl-attribute-name
  76     // 1. If property follows the &lt;custom-property-name&gt; production, return property.
  77     // FIXME: We don&#39;t handle custom properties yet.
  78 
  79     // 2. If property refers to the CSS float property, return the string &quot;cssFloat&quot;.
  80     if (cssPropertyId == CSSPropertyFloat)
  81         return &quot;cssFloat&quot;;
  82 
  83     // 3. If property refers to the CSS offset property, return the string &quot;cssOffset&quot;.
  84     // FIXME: we don&#39;t support the CSS &quot;offset&quot; property
  85 
  86     // 4. Otherwise, return the result of applying the CSS property to IDL attribute algorithm [CSSOM] to property.
  87     return getJSPropertyName(cssPropertyId);
  88 }
  89 
  90 static inline CSSPropertyID IDLAttributeNameToAnimationPropertyName(const String&amp; idlAttributeName)
  91 {
  92     // https://drafts.csswg.org/web-animations-1/#idl-attribute-name-to-animation-property-name
  93     // 1. If attribute conforms to the &lt;custom-property-name&gt; production, return attribute.
  94     // FIXME: We don&#39;t handle custom properties yet.
  95 
  96     // 2. If attribute is the string &quot;cssFloat&quot;, then return an animation property representing the CSS float property.
  97     if (idlAttributeName == &quot;cssFloat&quot;)
  98         return CSSPropertyFloat;
  99 
 100     // 3. If attribute is the string &quot;cssOffset&quot;, then return an animation property representing the CSS offset property.
 101     // FIXME: We don&#39;t support the CSS &quot;offset&quot; property.
 102 
 103     // 4. Otherwise, return the result of applying the IDL attribute to CSS property algorithm [CSSOM] to attribute.
 104     auto cssPropertyId = CSSStyleDeclaration::getCSSPropertyIDFromJavaScriptPropertyName(idlAttributeName);
 105 
 106     // We need to check that converting the property back to IDL form yields the same result such that a property passed
 107     // in non-IDL form is rejected, for instance &quot;font-size&quot;.
 108     if (idlAttributeName != CSSPropertyIDToIDLAttributeName(cssPropertyId))
 109         return CSSPropertyInvalid;
 110 
 111     return cssPropertyId;
 112 }
 113 
 114 static inline void computeMissingKeyframeOffsets(Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; keyframes)
 115 {
 116     // https://drafts.csswg.org/web-animations-1/#compute-missing-keyframe-offsets
 117 
 118     if (keyframes.isEmpty())
 119         return;
 120 
 121     // 1. For each keyframe, in keyframes, let the computed keyframe offset of the keyframe be equal to its keyframe offset value.
 122     // In our implementation, we only set non-null values to avoid making computedOffset Optional&lt;double&gt;. Instead, we&#39;ll know
 123     // that a keyframe hasn&#39;t had a computed offset by checking if it has a null offset and a 0 computedOffset, since the first
 124     // keyframe will already have a 0 computedOffset.
 125     for (auto&amp; keyframe : keyframes) {
 126         auto computedOffset = keyframe.offset;
 127         keyframe.computedOffset = computedOffset ? *computedOffset : 0;
 128     }
 129 
 130     // 2. If keyframes contains more than one keyframe and the computed keyframe offset of the first keyframe in keyframes is null,
 131     //    set the computed keyframe offset of the first keyframe to 0.
 132     if (keyframes.size() &gt; 1 &amp;&amp; !keyframes[0].offset)
 133         keyframes[0].computedOffset = 0;
 134 
 135     // 3. If the computed keyframe offset of the last keyframe in keyframes is null, set its computed keyframe offset to 1.
 136     if (!keyframes.last().offset)
 137         keyframes.last().computedOffset = 1;
 138 
 139     // 4. For each pair of keyframes A and B where:
 140     //    - A appears before B in keyframes, and
 141     //    - A and B have a computed keyframe offset that is not null, and
 142     //    - all keyframes between A and B have a null computed keyframe offset,
 143     //    calculate the computed keyframe offset of each keyframe between A and B as follows:
 144     //    1. Let offsetk be the computed keyframe offset of a keyframe k.
 145     //    2. Let n be the number of keyframes between and including A and B minus 1.
 146     //    3. Let index refer to the position of keyframe in the sequence of keyframes between A and B such that the first keyframe after A has an index of 1.
 147     //    4. Set the computed keyframe offset of keyframe to offsetA + (offsetB − offsetA) × index / n.
 148     size_t indexOfLastKeyframeWithNonNullOffset = 0;
 149     for (size_t i = 1; i &lt; keyframes.size(); ++i) {
 150         auto&amp; keyframe = keyframes[i];
 151         // Keyframes with a null offset that don&#39;t yet have a non-zero computed offset are keyframes
 152         // with an offset that needs to be computed.
 153         if (!keyframe.offset &amp;&amp; !keyframe.computedOffset)
 154             continue;
 155         if (indexOfLastKeyframeWithNonNullOffset != i - 1) {
 156             double lastNonNullOffset = keyframes[indexOfLastKeyframeWithNonNullOffset].computedOffset;
 157             double offsetDelta = keyframe.computedOffset - lastNonNullOffset;
 158             double offsetIncrement = offsetDelta / (i - indexOfLastKeyframeWithNonNullOffset);
 159             size_t indexOfFirstKeyframeWithNullOffset = indexOfLastKeyframeWithNonNullOffset + 1;
 160             for (size_t j = indexOfFirstKeyframeWithNullOffset; j &lt; i; ++j)
 161                 keyframes[j].computedOffset = lastNonNullOffset + (j - indexOfLastKeyframeWithNonNullOffset) * offsetIncrement;
 162         }
 163         indexOfLastKeyframeWithNonNullOffset = i;
 164     }
 165 }
 166 
 167 static inline ExceptionOr&lt;KeyframeEffect::KeyframeLikeObject&gt; processKeyframeLikeObject(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, bool allowLists)
 168 {
 169     // https://drafts.csswg.org/web-animations-1/#process-a-keyframe-like-object
 170 
 171     VM&amp; vm = lexicalGlobalObject.vm();
 172     auto scope = DECLARE_THROW_SCOPE(vm);
 173 
 174     // 1. Run the procedure to convert an ECMAScript value to a dictionary type [WEBIDL] with keyframe input as the ECMAScript value as follows:
 175     //
 176     //    If allow lists is true, use the following dictionary type:
 177     //
 178     //    dictionary BasePropertyIndexedKeyframe {
 179     //        (double? or sequence&lt;double?&gt;)                                   offset = [];
 180     //        (DOMString or sequence&lt;DOMString&gt;)                               easing = [];
 181     //        (CompositeOperationOrAuto or sequence&lt;CompositeOperationOrAuto&gt;) composite = [];
 182     //    };
 183     //
 184     //    Otherwise, use the following dictionary type:
 185     //
 186     //    dictionary BaseKeyframe {
 187     //        double?                  offset = null;
 188     //        DOMString                easing = &quot;linear&quot;;
 189     //        CompositeOperationOrAuto composite = &quot;auto&quot;;
 190     //    };
 191     //
 192     //    Store the result of this procedure as keyframe output.
 193     KeyframeEffect::BasePropertyIndexedKeyframe baseProperties;
 194     if (allowLists)
 195         baseProperties = convert&lt;IDLDictionary&lt;KeyframeEffect::BasePropertyIndexedKeyframe&gt;&gt;(lexicalGlobalObject, keyframesInput.get());
 196     else {
 197         auto baseKeyframe = convert&lt;IDLDictionary&lt;KeyframeEffect::BaseKeyframe&gt;&gt;(lexicalGlobalObject, keyframesInput.get());
 198         if (baseKeyframe.offset)
 199             baseProperties.offset = baseKeyframe.offset.value();
 200         else
 201             baseProperties.offset = nullptr;
 202         baseProperties.easing = baseKeyframe.easing;
 203         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())
 204             baseProperties.composite = baseKeyframe.composite;
 205     }
 206     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 207 
 208     KeyframeEffect::KeyframeLikeObject keyframeOuput;
 209     keyframeOuput.baseProperties = baseProperties;
 210 
 211     // 2. Build up a list of animatable properties as follows:
 212     //
 213     //    1. Let animatable properties be a list of property names (including shorthand properties that have longhand sub-properties
 214     //       that are animatable) that can be animated by the implementation.
 215     //    2. Convert each property name in animatable properties to the equivalent IDL attribute by applying the animation property
 216     //       name to IDL attribute name algorithm.
 217 
 218     // 3. Let input properties be the result of calling the EnumerableOwnNames operation with keyframe input as the object.
 219     PropertyNameArray inputProperties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
 220     JSObject::getOwnPropertyNames(keyframesInput.get(), &amp;lexicalGlobalObject, inputProperties, EnumerationMode());
 221 
 222     // 4. Make up a new list animation properties that consists of all of the properties that are in both input properties and animatable
 223     //    properties, or which are in input properties and conform to the &lt;custom-property-name&gt; production.
 224     Vector&lt;JSC::Identifier&gt; animationProperties;
 225     size_t numberOfProperties = inputProperties.size();
 226     for (size_t i = 0; i &lt; numberOfProperties; ++i) {
 227         if (CSSPropertyAnimation::isPropertyAnimatable(IDLAttributeNameToAnimationPropertyName(inputProperties[i].string())))
 228             animationProperties.append(inputProperties[i]);
 229     }
 230 
 231     // 5. Sort animation properties in ascending order by the Unicode codepoints that define each property name.
 232     std::sort(animationProperties.begin(), animationProperties.end(), [](auto&amp; lhs, auto&amp; rhs) {
 233         return lhs.string().utf8() &lt; rhs.string().utf8();
 234     });
 235 
 236     // 6. For each property name in animation properties,
 237     size_t numberOfAnimationProperties = animationProperties.size();
 238     for (size_t i = 0; i &lt; numberOfAnimationProperties; ++i) {
 239         // 1. Let raw value be the result of calling the [[Get]] internal method on keyframe input, with property name as the property
 240         //    key and keyframe input as the receiver.
 241         auto rawValue = keyframesInput-&gt;get(&amp;lexicalGlobalObject, animationProperties[i]);
 242 
 243         // 2. Check the completion record of raw value.
 244         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 245 
 246         // 3. Convert raw value to a DOMString or sequence of DOMStrings property values as follows:
 247         Vector&lt;String&gt; propertyValues;
 248         if (allowLists) {
 249             // If allow lists is true,
 250             // Let property values be the result of converting raw value to IDL type (DOMString or sequence&lt;DOMString&gt;)
 251             // using the procedures defined for converting an ECMAScript value to an IDL value [WEBIDL].
 252             // If property values is a single DOMString, replace property values with a sequence of DOMStrings with the original value of property
 253             // Values as the only element.
 254             if (rawValue.isObject())
 255                 propertyValues = convert&lt;IDLSequence&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, rawValue);
 256             else
 257                 propertyValues = { rawValue.toWTFString(&amp;lexicalGlobalObject) };
 258         } else {
 259             // Otherwise,
 260             // Let property values be the result of converting raw value to a DOMString using the procedure for converting an ECMAScript value to a DOMString.
 261             propertyValues = { convert&lt;IDLDOMString&gt;(lexicalGlobalObject, rawValue) };
 262         }
 263         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 264 
 265         // 4. Calculate the normalized property name as the result of applying the IDL attribute name to animation property name algorithm to property name.
 266         auto cssPropertyID = IDLAttributeNameToAnimationPropertyName(animationProperties[i].string());
 267 
 268         // 5. Add a property to to keyframe output with normalized property name as the property name, and property values as the property value.
 269         keyframeOuput.propertiesAndValues.append({ cssPropertyID, propertyValues });
 270     }
 271 
 272     // 7. Return keyframe output.
 273     return { WTFMove(keyframeOuput) };
 274 }
 275 
 276 static inline ExceptionOr&lt;void&gt; processIterableKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, JSValue method, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes)
 277 {
 278     // 1. Let iter be GetIterator(object, method).
 279     forEachInIterable(lexicalGlobalObject, keyframesInput.get(), method, [&amp;parsedKeyframes](VM&amp; vm, JSGlobalObject&amp; lexicalGlobalObject, JSValue nextValue) -&gt; ExceptionOr&lt;void&gt; {
 280         // Steps 2 through 6 are already implemented by forEachInIterable().
 281         auto scope = DECLARE_THROW_SCOPE(vm);
 282         if (!nextValue || !nextValue.isObject()) {
 283             throwException(&amp;lexicalGlobalObject, scope, JSC::Exception::create(vm, createTypeError(&amp;lexicalGlobalObject)));
 284             return { };
 285         }
 286 
 287         // 7. Append to processed keyframes the result of running the procedure to process a keyframe-like object passing nextItem
 288         // as the keyframe input and with the allow lists flag set to false.
 289         auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, Strong&lt;JSObject&gt;(vm, nextValue.toObject(&amp;lexicalGlobalObject)), false);
 290         if (processKeyframeLikeObjectResult.hasException())
 291             return processKeyframeLikeObjectResult.releaseException();
 292         auto keyframeLikeObject = processKeyframeLikeObjectResult.returnValue();
 293 
 294         KeyframeEffect::ParsedKeyframe keyframeOutput;
 295 
 296         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only offset
 297         // alternatives we should expect are double and nullptr.
 298         if (WTF::holds_alternative&lt;double&gt;(keyframeLikeObject.baseProperties.offset))
 299             keyframeOutput.offset = WTF::get&lt;double&gt;(keyframeLikeObject.baseProperties.offset);
 300         else
 301             ASSERT(WTF::holds_alternative&lt;std::nullptr_t&gt;(keyframeLikeObject.baseProperties.offset));
 302 
 303         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only easing
 304         // alternative we should expect is String.
 305         ASSERT(WTF::holds_alternative&lt;String&gt;(keyframeLikeObject.baseProperties.easing));
 306         keyframeOutput.easing = WTF::get&lt;String&gt;(keyframeLikeObject.baseProperties.easing);
 307 
 308         // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false, the only composite
 309         // alternatives we should expect is CompositeOperationAuto.
 310         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {
 311             ASSERT(WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite));
 312             keyframeOutput.composite = WTF::get&lt;CompositeOperationOrAuto&gt;(keyframeLikeObject.baseProperties.composite);
 313         }
 314 
 315         for (auto&amp; propertyAndValue : keyframeLikeObject.propertiesAndValues) {
 316             auto cssPropertyId = propertyAndValue.property;
 317             // When calling processKeyframeLikeObject() with the &quot;allow lists&quot; flag set to false,
 318             // there should only ever be a single value for a given property.
 319             ASSERT(propertyAndValue.values.size() == 1);
 320             auto stringValue = propertyAndValue.values[0];
 321             if (keyframeOutput.style-&gt;setProperty(cssPropertyId, stringValue))
 322                 keyframeOutput.unparsedStyle.set(cssPropertyId, stringValue);
 323         }
 324 
 325         parsedKeyframes.append(WTFMove(keyframeOutput));
 326 
 327         return { };
 328     });
 329 
 330     return { };
 331 }
 332 
 333 static inline ExceptionOr&lt;void&gt; processPropertyIndexedKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput, Vector&lt;KeyframeEffect::ParsedKeyframe&gt;&amp; parsedKeyframes, Vector&lt;String&gt;&amp; unusedEasings)
 334 {
 335     // 1. Let property-indexed keyframe be the result of running the procedure to process a keyframe-like object passing object as the keyframe input.
 336     auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, WTFMove(keyframesInput), true);
 337     if (processKeyframeLikeObjectResult.hasException())
 338         return processKeyframeLikeObjectResult.releaseException();
 339     auto propertyIndexedKeyframe = processKeyframeLikeObjectResult.returnValue();
 340 
 341     // 2. For each member, m, in property-indexed keyframe, perform the following steps:
 342     for (auto&amp; m : propertyIndexedKeyframe.propertiesAndValues) {
 343         // 1. Let property name be the key for m.
 344         auto propertyName = m.property;
 345         // 2. If property name is “composite”, or “easing”, or “offset”, skip the remaining steps in this loop and continue from the next member in property-indexed
 346         //    keyframe after m.
 347         //    We skip this test since we split those properties and the actual CSS properties that we&#39;re currently iterating over.
 348         // 3. Let property values be the value for m.
 349         auto propertyValues = m.values;
 350         // 4. Let property keyframes be an empty sequence of keyframes.
 351         Vector&lt;KeyframeEffect::ParsedKeyframe&gt; propertyKeyframes;
 352         // 5. For each value, v, in property values perform the following steps:
 353         for (auto&amp; v : propertyValues) {
 354             // 1. Let k be a new keyframe with a null keyframe offset.
 355             KeyframeEffect::ParsedKeyframe k;
 356             // 2. Add the property-value pair, property name → v, to k.
 357             if (k.style-&gt;setProperty(propertyName, v))
 358                 k.unparsedStyle.set(propertyName, v);
 359             // 3. Append k to property keyframes.
 360             propertyKeyframes.append(WTFMove(k));
 361         }
 362         // 6. Apply the procedure to compute missing keyframe offsets to property keyframes.
 363         computeMissingKeyframeOffsets(propertyKeyframes);
 364 
 365         // 7. Add keyframes in property keyframes to processed keyframes.
 366         for (auto&amp; keyframe : propertyKeyframes)
 367             parsedKeyframes.append(WTFMove(keyframe));
 368     }
 369 
 370     // 3. Sort processed keyframes by the computed keyframe offset of each keyframe in increasing order.
 371     std::sort(parsedKeyframes.begin(), parsedKeyframes.end(), [](auto&amp; lhs, auto&amp; rhs) {
 372         return lhs.computedOffset &lt; rhs.computedOffset;
 373     });
 374 
 375     // 4. Merge adjacent keyframes in processed keyframes when they have equal computed keyframe offsets.
 376     size_t i = 1;
 377     while (i &lt; parsedKeyframes.size()) {
 378         auto&amp; keyframe = parsedKeyframes[i];
 379         auto&amp; previousKeyframe = parsedKeyframes[i - 1];
 380         // If the offsets of this keyframe and the previous keyframe are different,
 381         // this means that the two keyframes should not be merged and we can move
 382         // on to the next keyframe.
 383         if (keyframe.computedOffset != previousKeyframe.computedOffset) {
 384             i++;
 385             continue;
 386         }
 387         // Otherwise, both this keyframe and the previous keyframe should be merged.
 388         // Unprocessed keyframes in parsedKeyframes at this stage have at most a single
 389         // property in cssPropertiesAndValues, so just set this on the previous keyframe.
 390         // In case an invalid or null value was originally provided, then the property
 391         // was not set and the property count is 0, in which case there is nothing to merge.
 392         if (keyframe.style-&gt;propertyCount()) {
 393             auto property = keyframe.style-&gt;propertyAt(0);
 394             previousKeyframe.style-&gt;setProperty(property.id(), property.value());
 395             previousKeyframe.unparsedStyle.set(property.id(), keyframe.unparsedStyle.get(property.id()));
 396         }
 397         // Since we&#39;ve processed this keyframe, we can remove it and keep i the same
 398         // so that we process the next keyframe in the next loop iteration.
 399         parsedKeyframes.remove(i);
 400     }
 401 
 402     // 5. Let offsets be a sequence of nullable double values assigned based on the type of the “offset” member of the property-indexed keyframe as follows:
 403     //    - sequence&lt;double?&gt;, the value of “offset” as-is.
 404     //    - double?, a sequence of length one with the value of “offset” as its single item, i.e. « offset »,
 405     Vector&lt;Optional&lt;double&gt;&gt; offsets;
 406     if (WTF::holds_alternative&lt;Vector&lt;Optional&lt;double&gt;&gt;&gt;(propertyIndexedKeyframe.baseProperties.offset))
 407         offsets = WTF::get&lt;Vector&lt;Optional&lt;double&gt;&gt;&gt;(propertyIndexedKeyframe.baseProperties.offset);
 408     else if (WTF::holds_alternative&lt;double&gt;(propertyIndexedKeyframe.baseProperties.offset))
 409         offsets.append(WTF::get&lt;double&gt;(propertyIndexedKeyframe.baseProperties.offset));
 410     else if (WTF::holds_alternative&lt;std::nullptr_t&gt;(propertyIndexedKeyframe.baseProperties.offset))
 411         offsets.append(WTF::nullopt);
 412 
 413     // 6. Assign each value in offsets to the keyframe offset of the keyframe with corresponding position in property keyframes until the end of either sequence is reached.
 414     for (size_t i = 0; i &lt; offsets.size() &amp;&amp; i &lt; parsedKeyframes.size(); ++i)
 415         parsedKeyframes[i].offset = offsets[i];
 416 
 417     // 7. Let easings be a sequence of DOMString values assigned based on the type of the “easing” member of the property-indexed keyframe as follows:
 418     //    - sequence&lt;DOMString&gt;, the value of “easing” as-is.
 419     //    - DOMString, a sequence of length one with the value of “easing” as its single item, i.e. « easing »,
 420     Vector&lt;String&gt; easings;
 421     if (WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(propertyIndexedKeyframe.baseProperties.easing))
 422         easings = WTF::get&lt;Vector&lt;String&gt;&gt;(propertyIndexedKeyframe.baseProperties.easing);
 423     else if (WTF::holds_alternative&lt;String&gt;(propertyIndexedKeyframe.baseProperties.easing))
 424         easings.append(WTF::get&lt;String&gt;(propertyIndexedKeyframe.baseProperties.easing));
 425 
 426     // 8. If easings is an empty sequence, let it be a sequence of length one containing the single value “linear”, i.e. « &quot;linear&quot; ».
 427     if (easings.isEmpty())
 428         easings.append(&quot;linear&quot;);
 429 
 430     // 9. If easings has fewer items than property keyframes, repeat the elements in easings successively starting from the beginning of the list until easings has as many
 431     //    items as property keyframes.
 432     if (easings.size() &lt; parsedKeyframes.size()) {
 433         size_t initialNumberOfEasings = easings.size();
 434         for (i = initialNumberOfEasings; i &lt; parsedKeyframes.size(); ++i)
 435             easings.append(easings[i % initialNumberOfEasings]);
 436     }
 437 
 438     // 10. If easings has more items than property keyframes, store the excess items as unused easings.
 439     while (easings.size() &gt; parsedKeyframes.size())
 440         unusedEasings.append(easings.takeLast());
 441 
 442     // 11. Assign each value in easings to a property named “easing” on the keyframe with the corresponding position in property keyframes until the end of property keyframes
 443     //     is reached.
 444     for (size_t i = 0; i &lt; parsedKeyframes.size(); ++i)
 445         parsedKeyframes[i].easing = easings[i];
 446 
 447     // 12. If the “composite” member of the property-indexed keyframe is not an empty sequence:
 448     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {
 449         Vector&lt;CompositeOperationOrAuto&gt; compositeModes;
 450         if (WTF::holds_alternative&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite))
 451             compositeModes = WTF::get&lt;Vector&lt;CompositeOperationOrAuto&gt;&gt;(propertyIndexedKeyframe.baseProperties.composite);
 452         else if (WTF::holds_alternative&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite))
 453             compositeModes.append(WTF::get&lt;CompositeOperationOrAuto&gt;(propertyIndexedKeyframe.baseProperties.composite));
 454         if (!compositeModes.isEmpty()) {
 455             // 1. Let composite modes be a sequence of CompositeOperationOrAuto values assigned from the “composite” member of property-indexed keyframe. If that member is a single
 456             //    CompositeOperationOrAuto value operation, let composite modes be a sequence of length one, with the value of the “composite” as its single item.
 457             // 2. As with easings, if composite modes has fewer items than processed keyframes, repeat the elements in composite modes successively starting from the beginning of
 458             //    the list until composite modes has as many items as processed keyframes.
 459             if (compositeModes.size() &lt; parsedKeyframes.size()) {
 460                 size_t initialNumberOfCompositeModes = compositeModes.size();
 461                 for (i = initialNumberOfCompositeModes; i &lt; parsedKeyframes.size(); ++i)
 462                     compositeModes.append(compositeModes[i % initialNumberOfCompositeModes]);
 463             }
 464             // 3. Assign each value in composite modes that is not auto to the keyframe-specific composite operation on the keyframe with the corresponding position in processed
 465             //    keyframes until the end of processed keyframes is reached.
 466             for (size_t i = 0; i &lt; compositeModes.size() &amp;&amp; i &lt; parsedKeyframes.size(); ++i) {
 467                 if (compositeModes[i] != CompositeOperationOrAuto::Auto)
 468                     parsedKeyframes[i].composite = compositeModes[i];
 469             }
 470         }
 471     }
 472 
 473     return { };
 474 }
 475 
 476 ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSGlobalObject&amp; lexicalGlobalObject, Element* target, Strong&lt;JSObject&gt;&amp;&amp; keyframes, Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt;&amp;&amp; options)
 477 {
 478     auto keyframeEffect = adoptRef(*new KeyframeEffect(target));
 479 
 480     if (options) {
 481         OptionalEffectTiming timing;
 482         auto optionsValue = options.value();
 483         if (WTF::holds_alternative&lt;double&gt;(optionsValue)) {
 484             Variant&lt;double, String&gt; duration = WTF::get&lt;double&gt;(optionsValue);
 485             timing.duration = duration;
 486         } else {
 487             auto keyframeEffectOptions = WTF::get&lt;KeyframeEffectOptions&gt;(optionsValue);
 488             timing = {
 489                 keyframeEffectOptions.duration,
 490                 keyframeEffectOptions.iterations,
 491                 keyframeEffectOptions.delay,
 492                 keyframeEffectOptions.endDelay,
 493                 keyframeEffectOptions.iterationStart,
 494                 keyframeEffectOptions.easing,
 495                 keyframeEffectOptions.fill,
 496                 keyframeEffectOptions.direction
 497             };
 498         }
 499         auto updateTimingResult = keyframeEffect-&gt;updateTiming(timing);
 500         if (updateTimingResult.hasException())
 501             return updateTimingResult.releaseException();
 502     }
 503 
 504     auto processKeyframesResult = keyframeEffect-&gt;processKeyframes(lexicalGlobalObject, WTFMove(keyframes));
 505     if (processKeyframesResult.hasException())
 506         return processKeyframesResult.releaseException();
 507 
 508     return keyframeEffect;
 509 }
 510 
 511 ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; KeyframeEffect::create(JSC::JSGlobalObject&amp;, Ref&lt;KeyframeEffect&gt;&amp;&amp; source)
 512 {
 513     auto keyframeEffect = adoptRef(*new KeyframeEffect(nullptr));
 514     keyframeEffect-&gt;copyPropertiesFromSource(WTFMove(source));
 515     return keyframeEffect;
 516 }
 517 
 518 Ref&lt;KeyframeEffect&gt; KeyframeEffect::create(const Element&amp; target)
 519 {
 520     return adoptRef(*new KeyframeEffect(const_cast&lt;Element*&gt;(&amp;target)));
 521 }
 522 
 523 KeyframeEffect::KeyframeEffect(Element* target)
 524     : m_target(makeWeakPtr(target))
 525 {
 526 }
 527 
 528 void KeyframeEffect::copyPropertiesFromSource(Ref&lt;KeyframeEffect&gt;&amp;&amp; source)
 529 {
 530     m_target = source-&gt;m_target;
 531     m_compositeOperation = source-&gt;m_compositeOperation;
 532     m_iterationCompositeOperation = source-&gt;m_iterationCompositeOperation;
 533 
 534     Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
 535     for (auto&amp; sourceParsedKeyframe : source-&gt;m_parsedKeyframes) {
 536         ParsedKeyframe parsedKeyframe;
 537         parsedKeyframe.easing = sourceParsedKeyframe.easing;
 538         parsedKeyframe.offset = sourceParsedKeyframe.offset;
 539         parsedKeyframe.composite = sourceParsedKeyframe.composite;
 540         parsedKeyframe.unparsedStyle = sourceParsedKeyframe.unparsedStyle;
 541         parsedKeyframe.computedOffset = sourceParsedKeyframe.computedOffset;
 542         parsedKeyframe.timingFunction = sourceParsedKeyframe.timingFunction;
 543         parsedKeyframe.style = sourceParsedKeyframe.style-&gt;mutableCopy();
 544         parsedKeyframes.append(WTFMove(parsedKeyframe));
 545     }
 546     m_parsedKeyframes = WTFMove(parsedKeyframes);
 547 
 548     setFill(source-&gt;fill());
 549     setDelay(source-&gt;delay());
 550     setEndDelay(source-&gt;endDelay());
 551     setDirection(source-&gt;direction());
 552     setIterations(source-&gt;iterations());
 553     setTimingFunction(source-&gt;timingFunction());
 554     setIterationStart(source-&gt;iterationStart());
 555     setIterationDuration(source-&gt;iterationDuration());
 556     updateStaticTimingProperties();
 557 
 558     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
 559     for (auto&amp; keyframe : source-&gt;m_blendingKeyframes.keyframes()) {
 560         KeyframeValue keyframeValue(keyframe.key(), RenderStyle::clonePtr(*keyframe.style()));
 561         for (auto propertyId : keyframe.properties())
 562             keyframeValue.addProperty(propertyId);
 563         keyframeList.insert(WTFMove(keyframeValue));
 564     }
 565     setBlendingKeyframes(keyframeList);
 566 }
 567 
 568 Vector&lt;Strong&lt;JSObject&gt;&gt; KeyframeEffect::getKeyframes(JSGlobalObject&amp; lexicalGlobalObject)
 569 {
 570     // https://drafts.csswg.org/web-animations-1/#dom-keyframeeffectreadonly-getkeyframes
 571 
 572     auto lock = JSLockHolder { &amp;lexicalGlobalObject };
 573 
 574     // Since keyframes are represented by a partially open-ended dictionary type that is not currently able to be expressed with WebIDL,
 575     // the procedure used to prepare the result of this method is defined in prose below:
 576     //
 577     // 1. Let result be an empty sequence of objects.
 578     Vector&lt;Strong&lt;JSObject&gt;&gt; result;
 579 
 580     // 2. Let keyframes be the result of applying the procedure to compute missing keyframe offsets to the keyframes for this keyframe effect.
 581 
 582     // 3. For each keyframe in keyframes perform the following steps:
 583     if (is&lt;DeclarativeAnimation&gt;(animation())) {
 584         auto* renderer = m_target-&gt;renderer();
 585         auto computedStyleExtractor = ComputedStyleExtractor(m_target.get());
 586         for (size_t i = 0; i &lt; m_blendingKeyframes.size(); ++i) {
 587             // 1. Initialize a dictionary object, output keyframe, using the following definition:
 588             //
 589             // dictionary BaseComputedKeyframe {
 590             //      double?                  offset = null;
 591             //      double                   computedOffset;
 592             //      DOMString                easing = &quot;linear&quot;;
 593             //      CompositeOperationOrAuto composite = &quot;auto&quot;;
 594             // };
 595 
 596             auto&amp; keyframe = m_blendingKeyframes[i];
 597 
 598             // 2. Set offset, computedOffset, easing members of output keyframe to the respective values keyframe offset, computed keyframe offset,
 599             // and keyframe-specific timing function of keyframe.
 600             BaseComputedKeyframe computedKeyframe;
 601             computedKeyframe.offset = keyframe.key();
 602             computedKeyframe.computedOffset = keyframe.key();
 603             // For CSS transitions, all keyframes should return &quot;linear&quot; since the effect&#39;s global timing function applies.
 604             computedKeyframe.easing = is&lt;CSSTransition&gt;(animation()) ? &quot;linear&quot; : timingFunctionForKeyframeAtIndex(i)-&gt;cssText();
 605 
 606             auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), computedKeyframe);
 607 
 608             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
 609             auto&amp; style = *keyframe.style();
 610             for (auto cssPropertyId : keyframe.properties()) {
 611                 if (cssPropertyId == CSSPropertyCustom)
 612                     continue;
 613                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
 614                 auto propertyName = CSSPropertyIDToIDLAttributeName(cssPropertyId);
 615                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
 616                 String idlValue = &quot;&quot;;
 617                 if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId, renderer))
 618                     idlValue = cssValue-&gt;cssText();
 619                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
 620                 auto value = toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, idlValue);
 621                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
 622                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
 623                 JSObject::defineOwnProperty(outputKeyframe, &amp;lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);
 624             }
 625 
 626             // 5. Append output keyframe to result.
 627             result.append(JSC::Strong&lt;JSC::JSObject&gt; { lexicalGlobalObject.vm(), outputKeyframe });
 628         }
 629     } else {
 630         for (size_t i = 0; i &lt; m_parsedKeyframes.size(); ++i) {
 631             // 1. Initialize a dictionary object, output keyframe, using the following definition:
 632             //
 633             // dictionary BaseComputedKeyframe {
 634             //      double?                  offset = null;
 635             //      double                   computedOffset;
 636             //      DOMString                easing = &quot;linear&quot;;
 637             //      CompositeOperationOrAuto composite = &quot;auto&quot;;
 638             // };
 639 
 640             auto&amp; parsedKeyframe = m_parsedKeyframes[i];
 641 
 642             // 2. Set offset, computedOffset, easing, composite members of output keyframe to the respective values keyframe offset, computed keyframe
 643             // offset, keyframe-specific timing function and keyframe-specific composite operation of keyframe.
 644             BaseComputedKeyframe computedKeyframe;
 645             computedKeyframe.offset = parsedKeyframe.offset;
 646             computedKeyframe.computedOffset = parsedKeyframe.computedOffset;
 647             computedKeyframe.easing = timingFunctionForKeyframeAtIndex(i)-&gt;cssText();
 648             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())
 649                 computedKeyframe.composite = parsedKeyframe.composite;
 650 
 651             auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), computedKeyframe);
 652 
 653             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
 654             for (auto it = parsedKeyframe.unparsedStyle.begin(), end = parsedKeyframe.unparsedStyle.end(); it != end; ++it) {
 655                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
 656                 auto propertyName = CSSPropertyIDToIDLAttributeName(it-&gt;key);
 657                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
 658                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
 659                 auto value = toJS&lt;IDLDOMString&gt;(lexicalGlobalObject, it-&gt;value);
 660                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
 661                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
 662                 JSObject::defineOwnProperty(outputKeyframe, &amp;lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);
 663             }
 664 
 665             // 4. Append output keyframe to result.
 666             result.append(JSC::Strong&lt;JSC::JSObject&gt; { lexicalGlobalObject.vm(), outputKeyframe });
 667         }
 668     }
 669 
 670     // 4. Return result.
 671     return result;
 672 }
 673 
 674 ExceptionOr&lt;void&gt; KeyframeEffect::setKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)
 675 {
 676     auto processKeyframesResult = processKeyframes(lexicalGlobalObject, WTFMove(keyframesInput));
 677     if (!processKeyframesResult.hasException() &amp;&amp; animation())
 678         animation()-&gt;effectTimingDidChange();
 679     return processKeyframesResult;
 680 }
 681 
 682 ExceptionOr&lt;void&gt; KeyframeEffect::processKeyframes(JSGlobalObject&amp; lexicalGlobalObject, Strong&lt;JSObject&gt;&amp;&amp; keyframesInput)
 683 {
 684     // 1. If object is null, return an empty sequence of keyframes.
 685     if (!keyframesInput.get())
 686         return { };
 687 
 688     VM&amp; vm = lexicalGlobalObject.vm();
 689     auto scope = DECLARE_THROW_SCOPE(vm);
 690 
 691     // 2. Let processed keyframes be an empty sequence of keyframes.
 692     Vector&lt;ParsedKeyframe&gt; parsedKeyframes;
 693 
 694     // 3. Let method be the result of GetMethod(object, @@iterator).
 695     auto method = keyframesInput.get()-&gt;get(&amp;lexicalGlobalObject, vm.propertyNames-&gt;iteratorSymbol);
 696 
 697     // 4. Check the completion record of method.
 698     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 699 
 700     // 5. Perform the steps corresponding to the first matching condition from below,
 701     Vector&lt;String&gt; unusedEasings;
 702     if (!method.isUndefined())
 703         processIterableKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), WTFMove(method), parsedKeyframes);
 704     else
 705         processPropertyIndexedKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), parsedKeyframes, unusedEasings);
 706 
 707     // 6. If processed keyframes is not loosely sorted by offset, throw a TypeError and abort these steps.
 708     // 7. If there exist any keyframe in processed keyframes whose keyframe offset is non-null and less than
 709     //    zero or greater than one, throw a TypeError and abort these steps.
 710     double lastNonNullOffset = -1;
 711     for (auto&amp; keyframe : parsedKeyframes) {
 712         if (!keyframe.offset)
 713             continue;
 714         auto offset = keyframe.offset.value();
 715         if (offset &lt; lastNonNullOffset || offset &lt; 0 || offset &gt; 1)
 716             return Exception { TypeError };
 717         lastNonNullOffset = offset;
 718     }
 719 
 720     // We take a slight detour from the spec text and compute the missing keyframe offsets right away
 721     // since they can be computed up-front.
 722     computeMissingKeyframeOffsets(parsedKeyframes);
 723 
 724     // 8. For each frame in processed keyframes, perform the following steps:
 725     for (auto&amp; keyframe : parsedKeyframes) {
 726         // Let the timing function of frame be the result of parsing the “easing” property on frame using the CSS syntax
 727         // defined for the easing property of the AnimationEffectTiming interface.
 728         // If parsing the “easing” property fails, throw a TypeError and abort this procedure.
 729         auto timingFunctionResult = TimingFunction::createFromCSSText(keyframe.easing);
 730         if (timingFunctionResult.hasException())
 731             return timingFunctionResult.releaseException();
 732         keyframe.timingFunction = timingFunctionResult.returnValue();
 733     }
 734 
 735     // 9. Parse each of the values in unused easings using the CSS syntax defined for easing property of the
 736     //    AnimationEffectTiming interface, and if any of the values fail to parse, throw a TypeError
 737     //    and abort this procedure.
 738     for (auto&amp; easing : unusedEasings) {
 739         auto timingFunctionResult = TimingFunction::createFromCSSText(easing);
 740         if (timingFunctionResult.hasException())
 741             return timingFunctionResult.releaseException();
 742     }
 743 
 744     m_parsedKeyframes = WTFMove(parsedKeyframes);
 745 
 746     clearBlendingKeyframes();
 747 
 748     return { };
 749 }
 750 
 751 void KeyframeEffect::updateBlendingKeyframes(RenderStyle&amp; elementStyle)
 752 {
 753     if (!m_blendingKeyframes.isEmpty() || !m_target)
 754         return;
 755 
 756     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
 757     auto&amp; styleResolver = m_target-&gt;styleResolver();
 758 
 759     for (auto&amp; keyframe : m_parsedKeyframes) {
 760         KeyframeValue keyframeValue(keyframe.computedOffset, nullptr);
 761 
 762         auto styleProperties = keyframe.style-&gt;immutableCopyIfNeeded();
 763         for (unsigned i = 0; i &lt; styleProperties-&gt;propertyCount(); ++i)
 764             keyframeList.addProperty(styleProperties-&gt;propertyAt(i).id());
 765 
 766         auto keyframeRule = StyleRuleKeyframe::create(WTFMove(styleProperties));
 767         keyframeValue.setStyle(styleResolver.styleForKeyframe(*m_target, &amp;elementStyle, keyframeRule.ptr(), keyframeValue));
 768         keyframeList.insert(WTFMove(keyframeValue));
 769     }
 770 
 771     setBlendingKeyframes(keyframeList);
 772 }
 773 
 774 bool KeyframeEffect::animatesProperty(CSSPropertyID property) const
 775 {
 776     if (!m_blendingKeyframes.isEmpty())
 777         return m_blendingKeyframes.properties().contains(property);
 778 
 779     for (auto&amp; keyframe : m_parsedKeyframes) {
 780         for (auto keyframeProperty : keyframe.unparsedStyle.keys()) {
 781             if (keyframeProperty == property)
 782                 return true;
 783         }
 784     }
 785     return false;
 786 }
 787 
 788 bool KeyframeEffect::forceLayoutIfNeeded()
 789 {
 790     if (!m_needsForcedLayout || !m_target)
 791         return false;
 792 
 793     auto* renderer = m_target-&gt;renderer();
 794     if (!renderer || !renderer-&gt;parent())
 795         return false;
 796 
 797     auto* frameView = m_target-&gt;document().view();
 798     if (!frameView)
 799         return false;
 800 
 801     frameView-&gt;forceLayout();
 802     return true;
 803 }
 804 
 805 
 806 void KeyframeEffect::clearBlendingKeyframes()
 807 {
 808     m_blendingKeyframesSource = BlendingKeyframesSource::WebAnimation;
 809     m_unanimatedStyle = nullptr;
 810     m_blendingKeyframes.clear();
 811 }
 812 
 813 void KeyframeEffect::setBlendingKeyframes(KeyframeList&amp; blendingKeyframes)
 814 {
 815     m_blendingKeyframes = WTFMove(blendingKeyframes);
 816 
 817     computedNeedsForcedLayout();
 818     computeStackingContextImpact();
 819     computeAcceleratedPropertiesState();
 820 
 821     checkForMatchingTransformFunctionLists();
 822     checkForMatchingFilterFunctionLists();
 823 #if ENABLE(FILTERS_LEVEL_2)
 824     checkForMatchingBackdropFilterFunctionLists();
 825 #endif
 826     checkForMatchingColorFilterFunctionLists();
 827 }
 828 
 829 void KeyframeEffect::checkForMatchingTransformFunctionLists()
 830 {
 831     m_transformFunctionListsMatch = false;
 832 
 833     if (m_blendingKeyframes.size() &lt; 2 || !m_blendingKeyframes.containsProperty(CSSPropertyTransform))
 834         return;
 835 
 836     // Empty transforms match anything, so find the first non-empty entry as the reference.
 837     size_t numKeyframes = m_blendingKeyframes.size();
 838     size_t firstNonEmptyTransformKeyframeIndex = numKeyframes;
 839 
 840     for (size_t i = 0; i &lt; numKeyframes; ++i) {
 841         const KeyframeValue&amp; currentKeyframe = m_blendingKeyframes[i];
 842         if (currentKeyframe.style()-&gt;transform().operations().size()) {
 843             firstNonEmptyTransformKeyframeIndex = i;
 844             break;
 845         }
 846     }
 847 
 848     if (firstNonEmptyTransformKeyframeIndex == numKeyframes)
 849         return;
 850 
 851     const TransformOperations* firstVal = &amp;m_blendingKeyframes[firstNonEmptyTransformKeyframeIndex].style()-&gt;transform();
 852     for (size_t i = firstNonEmptyTransformKeyframeIndex + 1; i &lt; numKeyframes; ++i) {
 853         const KeyframeValue&amp; currentKeyframe = m_blendingKeyframes[i];
 854         const TransformOperations* val = &amp;currentKeyframe.style()-&gt;transform();
 855 
 856         // An empty transform list matches anything.
 857         if (val-&gt;operations().isEmpty())
 858             continue;
 859 
 860         if (!firstVal-&gt;operationsMatch(*val))
 861             return;
 862     }
 863 
 864     m_transformFunctionListsMatch = true;
 865 }
 866 
 867 bool KeyframeEffect::checkForMatchingFilterFunctionLists(CSSPropertyID propertyID, const std::function&lt;const FilterOperations&amp; (const RenderStyle&amp;)&gt;&amp; filtersGetter) const
 868 {
 869     if (m_blendingKeyframes.size() &lt; 2 || !m_blendingKeyframes.containsProperty(propertyID))
 870         return false;
 871 
 872     // Empty filters match anything, so find the first non-empty entry as the reference.
 873     size_t numKeyframes = m_blendingKeyframes.size();
 874     size_t firstNonEmptyKeyframeIndex = numKeyframes;
 875 
 876     for (size_t i = 0; i &lt; numKeyframes; ++i) {
 877         if (filtersGetter(*m_blendingKeyframes[i].style()).operations().size()) {
 878             firstNonEmptyKeyframeIndex = i;
 879             break;
 880         }
 881     }
 882 
 883     if (firstNonEmptyKeyframeIndex == numKeyframes)
 884         return false;
 885 
 886     auto&amp; firstVal = filtersGetter(*m_blendingKeyframes[firstNonEmptyKeyframeIndex].style());
 887     for (size_t i = firstNonEmptyKeyframeIndex + 1; i &lt; numKeyframes; ++i) {
 888         auto&amp; value = filtersGetter(*m_blendingKeyframes[i].style());
 889 
 890         // An empty filter list matches anything.
 891         if (value.operations().isEmpty())
 892             continue;
 893 
 894         if (!firstVal.operationsMatch(value))
 895             return false;
 896     }
 897 
 898     return true;
 899 }
 900 
 901 void KeyframeEffect::checkForMatchingFilterFunctionLists()
 902 {
 903     m_filterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
 904         return style.filter();
 905     });
 906 }
 907 
 908 #if ENABLE(FILTERS_LEVEL_2)
 909 void KeyframeEffect::checkForMatchingBackdropFilterFunctionLists()
 910 {
 911     m_backdropFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyWebkitBackdropFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
 912         return style.backdropFilter();
 913     });
 914 }
 915 #endif
 916 
 917 void KeyframeEffect::checkForMatchingColorFilterFunctionLists()
 918 {
 919     m_colorFilterFunctionListsMatch = checkForMatchingFilterFunctionLists(CSSPropertyAppleColorFilter, [] (const RenderStyle&amp; style) -&gt; const FilterOperations&amp; {
 920         return style.appleColorFilter();
 921     });
 922 }
 923 
 924 void KeyframeEffect::computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
 925 {
 926     ASSERT(is&lt;DeclarativeAnimation&gt;(animation()));
 927     if (is&lt;CSSAnimation&gt;(animation()))
 928         computeCSSAnimationBlendingKeyframes(newStyle);
 929     else if (is&lt;CSSTransition&gt;(animation()))
 930         computeCSSTransitionBlendingKeyframes(oldStyle, newStyle);
 931 }
 932 
 933 void KeyframeEffect::computeCSSAnimationBlendingKeyframes(const RenderStyle&amp; unanimatedStyle)
 934 {
 935     ASSERT(is&lt;CSSAnimation&gt;(animation()));
 936 
 937     auto cssAnimation = downcast&lt;CSSAnimation&gt;(animation());
 938     auto&amp; backingAnimation = cssAnimation-&gt;backingAnimation();
 939 
 940     KeyframeList keyframeList(backingAnimation.name());
 941     if (auto* styleScope = Style::Scope::forOrdinal(*m_target, backingAnimation.nameStyleScopeOrdinal()))
 942         styleScope-&gt;resolver().keyframeStylesForAnimation(*m_target, &amp;unanimatedStyle, keyframeList);
 943 
 944     // Ensure resource loads for all the frames.
 945     for (auto&amp; keyframe : keyframeList.keyframes()) {
 946         if (auto* style = const_cast&lt;RenderStyle*&gt;(keyframe.style()))
 947             Style::loadPendingResources(*style, m_target-&gt;document(), m_target.get());
 948     }
 949 
 950     m_blendingKeyframesSource = BlendingKeyframesSource::CSSAnimation;
 951     setBlendingKeyframes(keyframeList);
 952 }
 953 
 954 void KeyframeEffect::computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle)
 955 {
 956     ASSERT(is&lt;CSSTransition&gt;(animation()));
 957 
 958     if (!oldStyle || m_blendingKeyframes.size())
 959         return;
 960 
 961     auto property = downcast&lt;CSSTransition&gt;(animation())-&gt;property();
 962 
 963     auto toStyle = RenderStyle::clonePtr(newStyle);
 964     if (m_target)
 965         Style::loadPendingResources(*toStyle, m_target-&gt;document(), m_target.get());
 966 
 967     KeyframeList keyframeList(&quot;keyframe-effect-&quot; + createCanonicalUUIDString());
 968     keyframeList.addProperty(property);
 969 
 970     KeyframeValue fromKeyframeValue(0, RenderStyle::clonePtr(*oldStyle));
 971     fromKeyframeValue.addProperty(property);
 972     keyframeList.insert(WTFMove(fromKeyframeValue));
 973 
 974     KeyframeValue toKeyframeValue(1, WTFMove(toStyle));
 975     toKeyframeValue.addProperty(property);
 976     keyframeList.insert(WTFMove(toKeyframeValue));
 977 
 978     m_blendingKeyframesSource = BlendingKeyframesSource::CSSTransition;
 979     setBlendingKeyframes(keyframeList);
 980 }
 981 
 982 void KeyframeEffect::computedNeedsForcedLayout()
 983 {
 984     m_needsForcedLayout = false;
 985     if (is&lt;CSSTransition&gt;(animation()) || !m_blendingKeyframes.containsProperty(CSSPropertyTransform))
 986         return;
 987 
 988     size_t numberOfKeyframes = m_blendingKeyframes.size();
 989     for (size_t i = 0; i &lt; numberOfKeyframes; i++) {
 990         auto* keyframeStyle = m_blendingKeyframes[i].style();
 991         if (!keyframeStyle) {
 992             ASSERT_NOT_REACHED();
 993             continue;
 994         }
 995         if (keyframeStyle-&gt;hasTransform()) {
 996             auto&amp; transformOperations = keyframeStyle-&gt;transform();
 997             for (const auto&amp; operation : transformOperations.operations()) {
 998                 if (operation-&gt;isTranslateTransformOperationType()) {
 999                     auto translation = downcast&lt;TranslateTransformOperation&gt;(operation.get());
1000                     if (translation-&gt;x().isPercent() || translation-&gt;y().isPercent()) {
1001                         m_needsForcedLayout = true;
1002                         return;
1003                     }
1004                 }
1005             }
1006         }
1007     }
1008 }
1009 
1010 void KeyframeEffect::computeStackingContextImpact()
1011 {
1012     m_triggersStackingContext = false;
1013     for (auto cssPropertyId : m_blendingKeyframes.properties()) {
1014         if (WillChangeData::propertyCreatesStackingContext(cssPropertyId)) {
1015             m_triggersStackingContext = true;
1016             break;
1017         }
1018     }
1019 }
1020 
1021 void KeyframeEffect::animationTimelineDidChange(AnimationTimeline* timeline)
1022 {
1023     if (!m_target)
1024         return;
1025 
1026     if (timeline)
1027         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);
1028     else {
1029         m_target-&gt;ensureKeyframeEffectStack().removeEffect(*this);
1030         m_inTargetEffectStack = false;
1031     }
1032 }
1033 
1034 void KeyframeEffect::animationTimingDidChange()
1035 {
1036     updateEffectStackMembership();
1037 }
1038 
1039 void KeyframeEffect::updateEffectStackMembership()
1040 {
1041     if (!m_target)
1042         return;
1043 
1044     bool isRelevant = animation() &amp;&amp; animation()-&gt;isRelevant();
1045     if (isRelevant &amp;&amp; !m_inTargetEffectStack)
1046         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);
1047     else if (!isRelevant &amp;&amp; m_inTargetEffectStack) {
1048         m_target-&gt;ensureKeyframeEffectStack().removeEffect(*this);
1049         m_inTargetEffectStack = false;
1050     }
1051 }
1052 
1053 void KeyframeEffect::setAnimation(WebAnimation* animation)
1054 {
1055     bool animationChanged = animation != this-&gt;animation();
1056     AnimationEffect::setAnimation(animation);
1057 
1058     if (!animationChanged)
1059         return;
1060 
1061     if (animation)
1062         animation-&gt;updateRelevance();
1063     updateEffectStackMembership();
1064 }
1065 
1066 void KeyframeEffect::setTarget(RefPtr&lt;Element&gt;&amp;&amp; newTarget)
1067 {
1068     if (m_target.get() == newTarget.get())
1069         return;
1070 
1071     auto previousTarget = std::exchange(m_target, makeWeakPtr(newTarget.get()));
1072 
1073     if (auto* effectAnimation = animation())
1074         effectAnimation-&gt;effectTargetDidChange(previousTarget.get(), m_target.get());
1075 
1076     clearBlendingKeyframes();
1077 
1078     // We need to invalidate the effect now that the target has changed
1079     // to ensure the effect&#39;s styles are applied to the new target right away.
1080     invalidate();
1081 
1082     // Likewise, we need to invalidate styles on the previous target so that
1083     // any animated styles are removed immediately.
1084     invalidateElement(previousTarget.get());
1085 
1086     if (previousTarget) {
1087         previousTarget-&gt;ensureKeyframeEffectStack().removeEffect(*this);
1088         m_inTargetEffectStack = false;
1089     }
1090     if (m_target)
1091         m_inTargetEffectStack = m_target-&gt;ensureKeyframeEffectStack().addEffect(*this);
1092 }
1093 
1094 void KeyframeEffect::apply(RenderStyle&amp; targetStyle)
1095 {
1096     if (!m_target)
1097         return;
1098 
1099     updateBlendingKeyframes(targetStyle);
1100 
1101     auto computedTiming = getComputedTiming();
1102     m_phaseAtLastApplication = computedTiming.phase;
1103 
1104     InspectorInstrumentation::willApplyKeyframeEffect(*m_target, *this, computedTiming);
1105 
1106     if (!computedTiming.progress)
1107         return;
1108 
1109     if (!m_unanimatedStyle)
1110         m_unanimatedStyle = RenderStyle::clonePtr(targetStyle);
1111 
1112     setAnimatedPropertiesInStyle(targetStyle, computedTiming.progress.value());
1113 }
1114 
1115 bool KeyframeEffect::isCurrentlyAffectingProperty(CSSPropertyID property, Accelerated accelerated) const
1116 {
1117     if (accelerated == Accelerated::Yes &amp;&amp; !isRunningAccelerated() &amp;&amp; !isAboutToRunAccelerated())
1118         return false;
1119 
1120     if (!m_blendingKeyframes.properties().contains(property))
1121         return false;
1122 
1123     return m_phaseAtLastApplication == AnimationEffectPhase::Active;
1124 }
1125 
1126 bool KeyframeEffect::isRunningAcceleratedAnimationForProperty(CSSPropertyID property) const
1127 {
1128     return m_isRunningAccelerated &amp;&amp; CSSPropertyAnimation::animationOfPropertyIsAccelerated(property) &amp;&amp; m_blendingKeyframes.properties().contains(property);
1129 }
1130 
1131 void KeyframeEffect::invalidate()
1132 {
1133     invalidateElement(m_target.get());
1134 }
1135 
1136 void KeyframeEffect::computeAcceleratedPropertiesState()
1137 {
1138     bool hasSomeAcceleratedProperties = false;
1139     bool hasSomeUnacceleratedProperties = false;
1140 
1141     for (auto cssPropertyId : m_blendingKeyframes.properties()) {
1142         // If any animated property can be accelerated, then the animation should run accelerated.
1143         if (CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId))
1144             hasSomeAcceleratedProperties = true;
1145         else
1146             hasSomeUnacceleratedProperties = true;
1147         if (hasSomeAcceleratedProperties &amp;&amp; hasSomeUnacceleratedProperties)
1148             break;
1149     }
1150 
1151     if (!hasSomeAcceleratedProperties)
1152         m_acceleratedPropertiesState = AcceleratedProperties::None;
1153     else if (hasSomeUnacceleratedProperties)
1154         m_acceleratedPropertiesState = AcceleratedProperties::Some;
1155     else
1156         m_acceleratedPropertiesState = AcceleratedProperties::All;
1157 }
1158 
1159 void KeyframeEffect::getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; animatedStyle)
1160 {
1161     if (!m_target || !animation())
1162         return;
1163 
1164     auto progress = getComputedTiming().progress;
1165     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;KeyframeEffect &quot; &lt;&lt; this &lt;&lt; &quot; getAnimatedStyle - progress &quot; &lt;&lt; progress);
1166     if (!progress)
1167         return;
1168 
1169     if (!animatedStyle)
1170         animatedStyle = RenderStyle::clonePtr(renderer()-&gt;style());
1171 
1172     setAnimatedPropertiesInStyle(*animatedStyle.get(), progress.value());
1173 }
1174 
1175 void KeyframeEffect::setAnimatedPropertiesInStyle(RenderStyle&amp; targetStyle, double iterationProgress)
1176 {
1177     auto&amp; properties = m_blendingKeyframes.properties();
1178 
1179     // In the case of CSS Transitions we already know that there are only two keyframes, one where offset=0 and one where offset=1,
1180     // and only a single CSS property so we can simply blend based on the style available on those keyframes with the provided iteration
1181     // progress which already accounts for the transition&#39;s timing function.
1182     if (m_blendingKeyframesSource == BlendingKeyframesSource::CSSTransition) {
1183         ASSERT(properties.size() == 1);
1184         CSSPropertyAnimation::blendProperties(this, *properties.begin(), &amp;targetStyle, m_blendingKeyframes[0].style(), m_blendingKeyframes[1].style(), iterationProgress);
1185         return;
1186     }
1187 
1188     // 4.4.3. The effect value of a keyframe effect
1189     // https://drafts.csswg.org/web-animations-1/#the-effect-value-of-a-keyframe-animation-effect
1190     //
1191     // The effect value of a single property referenced by a keyframe effect as one of its target properties,
1192     // for a given iteration progress, current iteration and underlying value is calculated as follows.
1193 
1194     updateBlendingKeyframes(targetStyle);
1195     if (m_blendingKeyframes.isEmpty())
1196         return;
1197 
1198     for (auto cssPropertyId : properties) {
1199         // 1. If iteration progress is unresolved abort this procedure.
1200         // 2. Let target property be the longhand property for which the effect value is to be calculated.
1201         // 3. If animation type of the target property is not animatable abort this procedure since the effect cannot be applied.
1202         // 4. Define the neutral value for composition as a value which, when combined with an underlying value using the add composite operation,
1203         //    produces the underlying value.
1204 
1205         // 5. Let property-specific keyframes be the result of getting the set of computed keyframes for this keyframe effect.
1206         // 6. Remove any keyframes from property-specific keyframes that do not have a property value for target property.
1207         unsigned numberOfKeyframesWithZeroOffset = 0;
1208         unsigned numberOfKeyframesWithOneOffset = 0;
1209         Vector&lt;Optional&lt;size_t&gt;&gt; propertySpecificKeyframes;
1210         for (size_t i = 0; i &lt; m_blendingKeyframes.size(); ++i) {
1211             auto&amp; keyframe = m_blendingKeyframes[i];
1212             auto offset = keyframe.key();
1213             if (!keyframe.containsProperty(cssPropertyId)) {
1214                 // If we&#39;re dealing with a CSS animation, we consider the first and last keyframes to always have the property listed
1215                 // since the underlying style was provided and should be captured.
1216                 if (m_blendingKeyframesSource == BlendingKeyframesSource::WebAnimation || (offset &amp;&amp; offset &lt; 1))
1217                     continue;
1218             }
1219             if (!offset)
1220                 numberOfKeyframesWithZeroOffset++;
1221             if (offset == 1)
1222                 numberOfKeyframesWithOneOffset++;
1223             propertySpecificKeyframes.append(i);
1224         }
1225 
1226         // 7. If property-specific keyframes is empty, return underlying value.
1227         if (propertySpecificKeyframes.isEmpty())
1228             continue;
1229 
1230         // 8. If there is no keyframe in property-specific keyframes with a computed keyframe offset of 0, create a new keyframe with a computed keyframe
1231         //    offset of 0, a property value set to the neutral value for composition, and a composite operation of add, and prepend it to the beginning of
1232         //    property-specific keyframes.
1233         if (!numberOfKeyframesWithZeroOffset) {
1234             propertySpecificKeyframes.insert(0, WTF::nullopt);
1235             numberOfKeyframesWithZeroOffset = 1;
1236         }
1237 
1238         // 9. Similarly, if there is no keyframe in property-specific keyframes with a computed keyframe offset of 1, create a new keyframe with a computed
1239         //    keyframe offset of 1, a property value set to the neutral value for composition, and a composite operation of add, and append it to the end of
1240         //    property-specific keyframes.
1241         if (!numberOfKeyframesWithOneOffset) {
1242             propertySpecificKeyframes.append(WTF::nullopt);
1243             numberOfKeyframesWithOneOffset = 1;
1244         }
1245 
1246         // 10. Let interval endpoints be an empty sequence of keyframes.
1247         Vector&lt;Optional&lt;size_t&gt;&gt; intervalEndpoints;
1248 
1249         // 11. Populate interval endpoints by following the steps from the first matching condition from below:
1250         if (iterationProgress &lt; 0 &amp;&amp; numberOfKeyframesWithZeroOffset &gt; 1) {
1251             // If iteration progress &lt; 0 and there is more than one keyframe in property-specific keyframes with a computed keyframe offset of 0,
1252             // Add the first keyframe in property-specific keyframes to interval endpoints.
1253             intervalEndpoints.append(propertySpecificKeyframes.first());
1254         } else if (iterationProgress &gt;= 1 &amp;&amp; numberOfKeyframesWithOneOffset &gt; 1) {
1255             // If iteration progress ≥ 1 and there is more than one keyframe in property-specific keyframes with a computed keyframe offset of 1,
1256             // Add the last keyframe in property-specific keyframes to interval endpoints.
1257             intervalEndpoints.append(propertySpecificKeyframes.last());
1258         } else {
1259             // Otherwise,
1260             // 1. Append to interval endpoints the last keyframe in property-specific keyframes whose computed keyframe offset is less than or equal
1261             //    to iteration progress and less than 1. If there is no such keyframe (because, for example, the iteration progress is negative),
1262             //    add the last keyframe whose computed keyframe offset is 0.
1263             // 2. Append to interval endpoints the next keyframe in property-specific keyframes after the one added in the previous step.
1264             size_t indexOfLastKeyframeWithZeroOffset = 0;
1265             int indexOfFirstKeyframeToAddToIntervalEndpoints = -1;
1266             for (size_t i = 0; i &lt; propertySpecificKeyframes.size(); ++i) {
1267                 auto keyframeIndex = propertySpecificKeyframes[i];
1268                 auto offset = [&amp;] () -&gt; double {
1269                     if (!keyframeIndex)
1270                         return i ? 1 : 0;
1271                     return m_blendingKeyframes[keyframeIndex.value()].key();
1272                 }();
1273                 if (!offset)
1274                     indexOfLastKeyframeWithZeroOffset = i;
1275                 if (offset &lt;= iterationProgress &amp;&amp; offset &lt; 1)
1276                     indexOfFirstKeyframeToAddToIntervalEndpoints = i;
1277                 else
1278                     break;
1279             }
1280 
1281             if (indexOfFirstKeyframeToAddToIntervalEndpoints &gt;= 0) {
1282                 intervalEndpoints.append(propertySpecificKeyframes[indexOfFirstKeyframeToAddToIntervalEndpoints]);
1283                 intervalEndpoints.append(propertySpecificKeyframes[indexOfFirstKeyframeToAddToIntervalEndpoints + 1]);
1284             } else {
1285                 ASSERT(indexOfLastKeyframeWithZeroOffset &lt; propertySpecificKeyframes.size() - 1);
1286                 intervalEndpoints.append(propertySpecificKeyframes[indexOfLastKeyframeWithZeroOffset]);
1287                 intervalEndpoints.append(propertySpecificKeyframes[indexOfLastKeyframeWithZeroOffset + 1]);
1288             }
1289         }
1290 
1291         // 12. For each keyframe in interval endpoints…
1292         // FIXME: we don&#39;t support this step yet since we don&#39;t deal with any composite operation other than &quot;replace&quot;.
1293 
1294         // 13. If there is only one keyframe in interval endpoints return the property value of target property on that keyframe.
1295         if (intervalEndpoints.size() == 1) {
1296             auto keyframeIndex = intervalEndpoints[0];
1297             auto keyframeStyle = !keyframeIndex ? &amp;targetStyle : m_blendingKeyframes[keyframeIndex.value()].style();
1298             CSSPropertyAnimation::blendProperties(this, cssPropertyId, &amp;targetStyle, keyframeStyle, keyframeStyle, 0);
1299             continue;
1300         }
1301 
1302         // 14. Let start offset be the computed keyframe offset of the first keyframe in interval endpoints.
1303         auto startKeyframeIndex = intervalEndpoints.first();
1304         auto startOffset = !startKeyframeIndex ? 0 : m_blendingKeyframes[startKeyframeIndex.value()].key();
1305 
1306         // 15. Let end offset be the computed keyframe offset of last keyframe in interval endpoints.
1307         auto endKeyframeIndex = intervalEndpoints.last();
1308         auto endOffset = !endKeyframeIndex ? 1 : m_blendingKeyframes[endKeyframeIndex.value()].key();
1309 
1310         // 16. Let interval distance be the result of evaluating (iteration progress - start offset) / (end offset - start offset).
1311         auto intervalDistance = (iterationProgress - startOffset) / (endOffset - startOffset);
1312 
1313         // 17. Let transformed distance be the result of evaluating the timing function associated with the first keyframe in interval endpoints
1314         //     passing interval distance as the input progress.
1315         auto transformedDistance = intervalDistance;
1316         if (startKeyframeIndex) {
1317             if (auto duration = iterationDuration()) {
1318                 auto rangeDuration = (endOffset - startOffset) * duration.seconds();
1319                 if (auto* timingFunction = timingFunctionForKeyframeAtIndex(startKeyframeIndex.value()))
1320                     transformedDistance = timingFunction-&gt;transformTime(intervalDistance, rangeDuration);
1321             }
1322         }
1323 
1324         // 18. Return the result of applying the interpolation procedure defined by the animation type of the target property, to the values of the target
1325         //     property specified on the two keyframes in interval endpoints taking the first such value as Vstart and the second as Vend and using transformed
1326         //     distance as the interpolation parameter p.
1327         auto startStyle = !startKeyframeIndex ? &amp;targetStyle : m_blendingKeyframes[startKeyframeIndex.value()].style();
1328         auto endStyle = !endKeyframeIndex ? &amp;targetStyle : m_blendingKeyframes[endKeyframeIndex.value()].style();
1329         CSSPropertyAnimation::blendProperties(this, cssPropertyId, &amp;targetStyle, startStyle, endStyle, transformedDistance);
1330     }
1331 }
1332 
1333 TimingFunction* KeyframeEffect::timingFunctionForKeyframeAtIndex(size_t index)
1334 {
1335     if (!m_parsedKeyframes.isEmpty())
1336         return m_parsedKeyframes[index].timingFunction.get();
1337 
1338     auto effectAnimation = animation();
1339     if (is&lt;DeclarativeAnimation&gt;(effectAnimation)) {
1340         // If we&#39;re dealing with a CSS Animation, the timing function is specified either on the keyframe itself.
1341         if (is&lt;CSSAnimation&gt;(effectAnimation)) {
1342             if (auto* timingFunction = m_blendingKeyframes[index].timingFunction())
1343                 return timingFunction;
1344         }
1345 
1346         // Failing that, or for a CSS Transition, the timing function is inherited from the backing Animation object.
1347         return downcast&lt;DeclarativeAnimation&gt;(effectAnimation)-&gt;backingAnimation().timingFunction();
1348     }
1349 
1350     return nullptr;
1351 }
1352 
1353 void KeyframeEffect::updateAcceleratedActions()
1354 {
1355     if (m_acceleratedPropertiesState == AcceleratedProperties::None)
1356         return;
1357 
1358     auto computedTiming = getComputedTiming();
1359 
1360     // If we&#39;re not already running accelerated, the only thing we&#39;re interested in is whether we need to start the animation
1361     // which we need to do once we&#39;re in the active phase. Otherwise, there&#39;s no change in accelerated state to consider.
1362     bool isActive = computedTiming.phase == AnimationEffectPhase::Active;
1363     if (!m_isRunningAccelerated) {
1364         if (isActive &amp;&amp; animation()-&gt;playState() == WebAnimation::PlayState::Running)
1365             addPendingAcceleratedAction(AcceleratedAction::Play);
1366         return;
1367     }
1368 
1369     // If we&#39;re no longer active, we need to remove the accelerated animation.
1370     if (!isActive) {
1371         addPendingAcceleratedAction(AcceleratedAction::Stop);
1372         return;
1373     }
1374 
1375     auto playState = animation()-&gt;playState();
1376     // The only thing left to consider is whether we need to pause or resume the animation following a change of play-state.
1377     if (playState == WebAnimation::PlayState::Paused) {
1378         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Pause) {
1379             if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop)
1380                 addPendingAcceleratedAction(AcceleratedAction::Play);
1381             addPendingAcceleratedAction(AcceleratedAction::Pause);
1382         }
1383     } else if (playState == WebAnimation::PlayState::Running &amp;&amp; isActive) {
1384         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Play)
1385             addPendingAcceleratedAction(AcceleratedAction::Play);
1386     }
1387 }
1388 
1389 void KeyframeEffect::addPendingAcceleratedAction(AcceleratedAction action)
1390 {
1391     if (action == m_lastRecordedAcceleratedAction)
1392         return;
1393 
1394     if (action == AcceleratedAction::Stop)
1395         m_pendingAcceleratedActions.clear();
1396     m_pendingAcceleratedActions.append(action);
1397     if (action != AcceleratedAction::Seek)
1398         m_lastRecordedAcceleratedAction = action;
1399     animation()-&gt;acceleratedStateDidChange();
1400 }
1401 
1402 void KeyframeEffect::animationDidTick()
1403 {
1404     invalidate();
1405     updateAcceleratedActions();
1406 }
1407 
1408 void KeyframeEffect::animationDidPlay()
1409 {
1410     if (m_acceleratedPropertiesState != AcceleratedProperties::None)
1411         addPendingAcceleratedAction(AcceleratedAction::Play);
1412 }
1413 
1414 void KeyframeEffect::animationDidSeek()
1415 {
1416     // There is no need to seek if we&#39;re not playing an animation already. If seeking
1417     // means we&#39;re moving into an active lexicalGlobalObject, we&#39;ll pick this up in apply().
1418     if (m_isRunningAccelerated || isAboutToRunAccelerated())
1419         addPendingAcceleratedAction(AcceleratedAction::Seek);
1420 }
1421 
1422 void KeyframeEffect::animationWasCanceled()
1423 {
1424     if (m_isRunningAccelerated || isAboutToRunAccelerated())
1425         addPendingAcceleratedAction(AcceleratedAction::Stop);
1426 }
1427 
1428 void KeyframeEffect::willChangeRenderer()
1429 {
1430     if (m_isRunningAccelerated || isAboutToRunAccelerated())
1431         addPendingAcceleratedAction(AcceleratedAction::Stop);
1432 }
1433 
1434 void KeyframeEffect::animationSuspensionStateDidChange(bool animationIsSuspended)
1435 {
1436     if (m_isRunningAccelerated || isAboutToRunAccelerated())
1437         addPendingAcceleratedAction(animationIsSuspended ? AcceleratedAction::Pause : AcceleratedAction::Play);
1438 }
1439 
1440 void KeyframeEffect::applyPendingAcceleratedActions()
1441 {
1442     // Once an accelerated animation has been committed, we no longer want to force a layout.
1443     // This should have been performed by a call to forceLayoutIfNeeded() prior to applying
1444     // pending accelerated actions.
1445     m_needsForcedLayout = false;
1446 
1447     if (m_pendingAcceleratedActions.isEmpty())
1448         return;
1449 
1450     auto* renderer = this-&gt;renderer();
1451     if (!renderer || !renderer-&gt;isComposited()) {
1452         // The renderer may no longer be composited because the accelerated animation ended before we had a chance to update it,
1453         // in which case if we asked for the animation to stop, we can discard the current set of accelerated actions.
1454         if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop) {
1455             m_pendingAcceleratedActions.clear();
1456             m_isRunningAccelerated = false;
1457         }
1458         return;
1459     }
1460 
1461     auto pendingAcceleratedActions = m_pendingAcceleratedActions;
1462     m_pendingAcceleratedActions.clear();
1463 
1464     // To simplify the code we use a default of 0s for an unresolved current time since for a Stop action that is acceptable.
1465     auto timeOffset = animation()-&gt;currentTime().valueOr(0_s).seconds() - delay().seconds();
1466 
1467     for (const auto&amp; action : pendingAcceleratedActions) {
1468         switch (action) {
1469         case AcceleratedAction::Play:
1470             m_isRunningAccelerated = renderer-&gt;startAnimation(timeOffset, backingAnimationForCompositedRenderer(), m_blendingKeyframes);
1471             if (!m_isRunningAccelerated) {
1472                 m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;
1473                 return;
1474             }
1475             break;
1476         case AcceleratedAction::Pause:
1477             renderer-&gt;animationPaused(timeOffset, m_blendingKeyframes.animationName());
1478             break;
1479         case AcceleratedAction::Seek:
1480             renderer-&gt;animationSeeked(timeOffset, m_blendingKeyframes.animationName());
1481             break;
1482         case AcceleratedAction::Stop:
1483             renderer-&gt;animationFinished(m_blendingKeyframes.animationName());
1484             if (!m_target-&gt;document().renderTreeBeingDestroyed())
1485                 m_target-&gt;invalidateStyleAndLayerComposition();
1486             m_isRunningAccelerated = false;
1487             break;
1488         }
1489     }
1490 }
1491 
1492 Ref&lt;const Animation&gt; KeyframeEffect::backingAnimationForCompositedRenderer() const
1493 {
1494     auto effectAnimation = animation();
1495     if (is&lt;DeclarativeAnimation&gt;(effectAnimation))
1496         return downcast&lt;DeclarativeAnimation&gt;(effectAnimation)-&gt;backingAnimation();
1497 
1498     // FIXME: The iterationStart and endDelay AnimationEffectTiming properties do not have
1499     // corresponding Animation properties.
1500     auto animation = Animation::create();
1501     animation-&gt;setDuration(iterationDuration().seconds());
1502     animation-&gt;setDelay(delay().seconds());
1503     animation-&gt;setIterationCount(iterations());
1504     animation-&gt;setTimingFunction(timingFunction()-&gt;clone());
1505 
1506     switch (fill()) {
1507     case FillMode::None:
1508     case FillMode::Auto:
1509         animation-&gt;setFillMode(AnimationFillMode::None);
1510         break;
1511     case FillMode::Backwards:
1512         animation-&gt;setFillMode(AnimationFillMode::Backwards);
1513         break;
1514     case FillMode::Forwards:
1515         animation-&gt;setFillMode(AnimationFillMode::Forwards);
1516         break;
1517     case FillMode::Both:
1518         animation-&gt;setFillMode(AnimationFillMode::Both);
1519         break;
1520     }
1521 
1522     switch (direction()) {
1523     case PlaybackDirection::Normal:
1524         animation-&gt;setDirection(Animation::AnimationDirectionNormal);
1525         break;
1526     case PlaybackDirection::Alternate:
1527         animation-&gt;setDirection(Animation::AnimationDirectionAlternate);
1528         break;
1529     case PlaybackDirection::Reverse:
1530         animation-&gt;setDirection(Animation::AnimationDirectionReverse);
1531         break;
1532     case PlaybackDirection::AlternateReverse:
1533         animation-&gt;setDirection(Animation::AnimationDirectionAlternateReverse);
1534         break;
1535     }
1536 
1537     return animation;
1538 }
1539 
1540 RenderElement* KeyframeEffect::renderer() const
1541 {
1542     return m_target ? m_target-&gt;renderer() : nullptr;
1543 }
1544 
1545 const RenderStyle&amp; KeyframeEffect::currentStyle() const
1546 {
1547     if (auto* renderer = this-&gt;renderer())
1548         return renderer-&gt;style();
1549     return RenderStyle::defaultStyle();
1550 }
1551 
1552 bool KeyframeEffect::computeExtentOfTransformAnimation(LayoutRect&amp; bounds) const
1553 {
1554     ASSERT(m_blendingKeyframes.containsProperty(CSSPropertyTransform));
1555 
1556     if (!is&lt;RenderBox&gt;(renderer()))
1557         return true; // Non-boxes don&#39;t get transformed;
1558 
1559     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer());
1560     auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
1561 
1562     LayoutRect cumulativeBounds;
1563 
1564     for (const auto&amp; keyframe : m_blendingKeyframes.keyframes()) {
1565         const auto* keyframeStyle = keyframe.style();
1566 
1567         // FIXME: maybe for declarative animations we always say it&#39;s true for the first and last keyframe.
1568         if (!keyframe.containsProperty(CSSPropertyTransform)) {
1569             // If the first keyframe is missing transform style, use the current style.
1570             if (!keyframe.key())
1571                 keyframeStyle = &amp;box.style();
1572             else
1573                 continue;
1574         }
1575 
1576         auto keyframeBounds = bounds;
1577 
1578         bool canCompute;
1579         if (transformFunctionListsMatch())
1580             canCompute = computeTransformedExtentViaTransformList(rendererBox, *keyframeStyle, keyframeBounds);
1581         else
1582             canCompute = computeTransformedExtentViaMatrix(rendererBox, *keyframeStyle, keyframeBounds);
1583 
1584         if (!canCompute)
1585             return false;
1586 
1587         cumulativeBounds.unite(keyframeBounds);
1588     }
1589 
1590     bounds = cumulativeBounds;
1591     return true;
1592 }
1593 
1594 static bool containsRotation(const Vector&lt;RefPtr&lt;TransformOperation&gt;&gt;&amp; operations)
1595 {
1596     for (const auto&amp; operation : operations) {
1597         if (operation-&gt;type() == TransformOperation::ROTATE)
1598             return true;
1599     }
1600     return false;
1601 }
1602 
1603 bool KeyframeEffect::computeTransformedExtentViaTransformList(const FloatRect&amp; rendererBox, const RenderStyle&amp; style, LayoutRect&amp; bounds) const
1604 {
1605     FloatRect floatBounds = bounds;
1606     FloatPoint transformOrigin;
1607 
1608     bool applyTransformOrigin = containsRotation(style.transform().operations()) || style.transform().affectedByTransformOrigin();
1609     if (applyTransformOrigin) {
1610         transformOrigin.setX(rendererBox.x() + floatValueForLength(style.transformOriginX(), rendererBox.width()));
1611         transformOrigin.setY(rendererBox.y() + floatValueForLength(style.transformOriginY(), rendererBox.height()));
1612         // Ignore transformOriginZ because we&#39;ll bail if we encounter any 3D transforms.
1613 
1614         floatBounds.moveBy(-transformOrigin);
1615     }
1616 
1617     for (const auto&amp; operation : style.transform().operations()) {
1618         if (operation-&gt;type() == TransformOperation::ROTATE) {
1619             // For now, just treat this as a full rotation. This could take angle into account to reduce inflation.
1620             floatBounds = boundsOfRotatingRect(floatBounds);
1621         } else {
1622             TransformationMatrix transform;
1623             operation-&gt;apply(transform, rendererBox.size());
1624             if (!transform.isAffine())
1625                 return false;
1626 
1627             if (operation-&gt;type() == TransformOperation::MATRIX || operation-&gt;type() == TransformOperation::MATRIX_3D) {
1628                 TransformationMatrix::Decomposed2Type toDecomp;
1629                 transform.decompose2(toDecomp);
1630                 // Any rotation prevents us from using a simple start/end rect union.
1631                 if (toDecomp.angle)
1632                     return false;
1633             }
1634 
1635             floatBounds = transform.mapRect(floatBounds);
1636         }
1637     }
1638 
1639     if (applyTransformOrigin)
1640         floatBounds.moveBy(transformOrigin);
1641 
1642     bounds = LayoutRect(floatBounds);
1643     return true;
1644 }
1645 
1646 bool KeyframeEffect::computeTransformedExtentViaMatrix(const FloatRect&amp; rendererBox, const RenderStyle&amp; style, LayoutRect&amp; bounds) const
1647 {
1648     TransformationMatrix transform;
1649     style.applyTransform(transform, rendererBox, RenderStyle::IncludeTransformOrigin);
1650     if (!transform.isAffine())
1651         return false;
1652 
1653     TransformationMatrix::Decomposed2Type fromDecomp;
1654     transform.decompose2(fromDecomp);
1655     // Any rotation prevents us from using a simple start/end rect union.
1656     if (fromDecomp.angle)
1657         return false;
1658 
1659     bounds = LayoutRect(transform.mapRect(bounds));
1660     return true;
1661 }
1662 
1663 } // namespace WebCore
    </pre>
  </body>
</html>
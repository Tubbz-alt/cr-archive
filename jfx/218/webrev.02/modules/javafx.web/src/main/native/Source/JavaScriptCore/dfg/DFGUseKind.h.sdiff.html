<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGUseKind.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGUseKind.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGValidate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGUseKind.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 
 39     // 1. The JSValue representation for a JSValue that must be stored in a GP
 40     //    register (or a GP register pair), and follows rules for boxing and unboxing
 41     //    that allow the JSValue to be stored as either fully boxed JSValues, or
 42     //    unboxed Int32, Booleans, Cells, etc. in 32-bit as appropriate.
 43     UntypedUse, // UntypedUse must come first (value 0).
 44     Int32Use,
 45     KnownInt32Use,
 46     AnyIntUse,
 47     NumberUse,
 48     RealNumberUse,
 49     BooleanUse,
 50     KnownBooleanUse,
 51     CellUse,
 52     KnownCellUse,
 53     CellOrOtherUse,
 54     ObjectUse,
 55     ArrayUse,
 56     FunctionUse,
 57     FinalObjectUse,

 58     RegExpObjectUse,
 59     ProxyObjectUse,
 60     DerivedArrayUse,
 61     ObjectOrOtherUse,
 62     StringIdentUse,
 63     StringUse,
 64     StringOrOtherUse,
 65     KnownStringUse,
 66     KnownPrimitiveUse, // This bizarre type arises for op_strcat, which has a bytecode guarantee that it will only see primitives (i.e. not objects).
 67     SymbolUse,
 68     BigIntUse,

 69     MapObjectUse,
 70     SetObjectUse,
 71     WeakMapObjectUse,
 72     WeakSetObjectUse,
 73     DataViewObjectUse,
 74     StringObjectUse,
 75     StringOrStringObjectUse,
 76     NotStringVarUse,
 77     NotSymbolUse,
 78     NotCellUse,
 79     KnownOtherUse,
 80     OtherUse,
 81     MiscUse,
 82 
 83     // 2. The Double representation for an unboxed double value that must be stored
 84     //    in an FP register.
 85     DoubleRepUse,
 86     DoubleRepRealUse,
 87     DoubleRepAnyIntUse,
 88 
</pre>
<hr />
<pre>
135         return SpecRegExpObject;
136     case ProxyObjectUse:
137         return SpecProxyObject;
138     case DerivedArrayUse:
139         return SpecDerivedArray;
140     case ObjectOrOtherUse:
141         return SpecObject | SpecOther;
142     case StringIdentUse:
143         return SpecStringIdent;
144     case StringUse:
145     case KnownStringUse:
146         return SpecString;
147     case StringOrOtherUse:
148         return SpecString | SpecOther;
149     case KnownPrimitiveUse:
150         return SpecHeapTop &amp; ~SpecObject;
151     case SymbolUse:
152         return SpecSymbol;
153     case BigIntUse:
154         return SpecBigInt;




155     case MapObjectUse:
156         return SpecMapObject;
157     case SetObjectUse:
158         return SpecSetObject;
159     case WeakMapObjectUse:
160         return SpecWeakMapObject;
161     case WeakSetObjectUse:
162         return SpecWeakSetObject;
163     case DataViewObjectUse:
164         return SpecDataViewObject;
165     case StringObjectUse:
166         return SpecStringObject;
167     case StringOrStringObjectUse:
168         return SpecString | SpecStringObject;
169     case NotStringVarUse:
170         return ~SpecStringVar;
171     case NotSymbolUse:
172         return ~SpecSymbol;
173     case NotCellUse:
174         return ~SpecCellCheck;
</pre>
<hr />
<pre>
231     case DoubleRepRealUse:
232     case DoubleRepAnyIntUse:
233         return true;
234     default:
235         return false;
236     }
237 }
238 
239 // Returns true if the use kind only admits cells, and is therefore appropriate for
240 // SpeculateCellOperand in the DFG or lowCell() in the FTL.
241 inline bool isCell(UseKind kind)
242 {
243     switch (kind) {
244     case CellUse:
245     case KnownCellUse:
246     case ObjectUse:
247     case ArrayUse:
248     case FunctionUse:
249     case FinalObjectUse:
250     case RegExpObjectUse:

251     case ProxyObjectUse:
252     case DerivedArrayUse:
253     case StringIdentUse:
254     case StringUse:
255     case KnownStringUse:
256     case SymbolUse:
257     case BigIntUse:
258     case StringObjectUse:
259     case StringOrStringObjectUse:

260     case MapObjectUse:
261     case SetObjectUse:
262     case WeakMapObjectUse:
263     case WeakSetObjectUse:
264     case DataViewObjectUse:
265         return true;
266     default:
267         return false;
268     }
269 }
270 
271 // Returns true if we&#39;ve already guaranteed the type
272 inline bool alreadyChecked(UseKind kind, SpeculatedType type)
273 {
274     return !(type &amp; ~typeFilterFor(kind));
275 }
276 
277 inline UseKind useKindForResult(NodeFlags result)
278 {
279     ASSERT(!(result &amp; ~NodeResultMask));
</pre>
</td>
<td>
<hr />
<pre>
 38 
 39     // 1. The JSValue representation for a JSValue that must be stored in a GP
 40     //    register (or a GP register pair), and follows rules for boxing and unboxing
 41     //    that allow the JSValue to be stored as either fully boxed JSValues, or
 42     //    unboxed Int32, Booleans, Cells, etc. in 32-bit as appropriate.
 43     UntypedUse, // UntypedUse must come first (value 0).
 44     Int32Use,
 45     KnownInt32Use,
 46     AnyIntUse,
 47     NumberUse,
 48     RealNumberUse,
 49     BooleanUse,
 50     KnownBooleanUse,
 51     CellUse,
 52     KnownCellUse,
 53     CellOrOtherUse,
 54     ObjectUse,
 55     ArrayUse,
 56     FunctionUse,
 57     FinalObjectUse,
<span class="line-added"> 58     PromiseObjectUse,</span>
 59     RegExpObjectUse,
 60     ProxyObjectUse,
 61     DerivedArrayUse,
 62     ObjectOrOtherUse,
 63     StringIdentUse,
 64     StringUse,
 65     StringOrOtherUse,
 66     KnownStringUse,
 67     KnownPrimitiveUse, // This bizarre type arises for op_strcat, which has a bytecode guarantee that it will only see primitives (i.e. not objects).
 68     SymbolUse,
 69     BigIntUse,
<span class="line-added"> 70     DateObjectUse,</span>
 71     MapObjectUse,
 72     SetObjectUse,
 73     WeakMapObjectUse,
 74     WeakSetObjectUse,
 75     DataViewObjectUse,
 76     StringObjectUse,
 77     StringOrStringObjectUse,
 78     NotStringVarUse,
 79     NotSymbolUse,
 80     NotCellUse,
 81     KnownOtherUse,
 82     OtherUse,
 83     MiscUse,
 84 
 85     // 2. The Double representation for an unboxed double value that must be stored
 86     //    in an FP register.
 87     DoubleRepUse,
 88     DoubleRepRealUse,
 89     DoubleRepAnyIntUse,
 90 
</pre>
<hr />
<pre>
137         return SpecRegExpObject;
138     case ProxyObjectUse:
139         return SpecProxyObject;
140     case DerivedArrayUse:
141         return SpecDerivedArray;
142     case ObjectOrOtherUse:
143         return SpecObject | SpecOther;
144     case StringIdentUse:
145         return SpecStringIdent;
146     case StringUse:
147     case KnownStringUse:
148         return SpecString;
149     case StringOrOtherUse:
150         return SpecString | SpecOther;
151     case KnownPrimitiveUse:
152         return SpecHeapTop &amp; ~SpecObject;
153     case SymbolUse:
154         return SpecSymbol;
155     case BigIntUse:
156         return SpecBigInt;
<span class="line-added">157     case PromiseObjectUse:</span>
<span class="line-added">158         return SpecPromiseObject;</span>
<span class="line-added">159     case DateObjectUse:</span>
<span class="line-added">160         return SpecDateObject;</span>
161     case MapObjectUse:
162         return SpecMapObject;
163     case SetObjectUse:
164         return SpecSetObject;
165     case WeakMapObjectUse:
166         return SpecWeakMapObject;
167     case WeakSetObjectUse:
168         return SpecWeakSetObject;
169     case DataViewObjectUse:
170         return SpecDataViewObject;
171     case StringObjectUse:
172         return SpecStringObject;
173     case StringOrStringObjectUse:
174         return SpecString | SpecStringObject;
175     case NotStringVarUse:
176         return ~SpecStringVar;
177     case NotSymbolUse:
178         return ~SpecSymbol;
179     case NotCellUse:
180         return ~SpecCellCheck;
</pre>
<hr />
<pre>
237     case DoubleRepRealUse:
238     case DoubleRepAnyIntUse:
239         return true;
240     default:
241         return false;
242     }
243 }
244 
245 // Returns true if the use kind only admits cells, and is therefore appropriate for
246 // SpeculateCellOperand in the DFG or lowCell() in the FTL.
247 inline bool isCell(UseKind kind)
248 {
249     switch (kind) {
250     case CellUse:
251     case KnownCellUse:
252     case ObjectUse:
253     case ArrayUse:
254     case FunctionUse:
255     case FinalObjectUse:
256     case RegExpObjectUse:
<span class="line-added">257     case PromiseObjectUse:</span>
258     case ProxyObjectUse:
259     case DerivedArrayUse:
260     case StringIdentUse:
261     case StringUse:
262     case KnownStringUse:
263     case SymbolUse:
264     case BigIntUse:
265     case StringObjectUse:
266     case StringOrStringObjectUse:
<span class="line-added">267     case DateObjectUse:</span>
268     case MapObjectUse:
269     case SetObjectUse:
270     case WeakMapObjectUse:
271     case WeakSetObjectUse:
272     case DataViewObjectUse:
273         return true;
274     default:
275         return false;
276     }
277 }
278 
279 // Returns true if we&#39;ve already guaranteed the type
280 inline bool alreadyChecked(UseKind kind, SpeculatedType type)
281 {
282     return !(type &amp; ~typeFilterFor(kind));
283 }
284 
285 inline UseKind useKindForResult(NodeFlags result)
286 {
287     ASSERT(!(result &amp; ~NodeResultMask));
</pre>
</td>
</tr>
</table>
<center><a href="DFGUseKind.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGValidate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
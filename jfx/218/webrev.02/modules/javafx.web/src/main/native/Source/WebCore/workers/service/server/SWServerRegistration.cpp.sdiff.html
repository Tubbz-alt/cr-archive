<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerRegistration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SWServerJobQueue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerRegistration.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerRegistration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServerRegistration.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 

 31 #include &quot;SWServer.h&quot;

 32 #include &quot;SWServerWorker.h&quot;
 33 #include &quot;ServiceWorkerTypes.h&quot;
 34 #include &quot;ServiceWorkerUpdateViaCache.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 static ServiceWorkerRegistrationIdentifier generateServiceWorkerRegistrationIdentifier()
 39 {
 40     return ServiceWorkerRegistrationIdentifier::generate();
 41 }
 42 
 43 SWServerRegistration::SWServerRegistration(SWServer&amp; server, const ServiceWorkerRegistrationKey&amp; key, ServiceWorkerUpdateViaCache updateViaCache, const URL&amp; scopeURL, const URL&amp; scriptURL)
 44     : m_identifier(generateServiceWorkerRegistrationIdentifier())
 45     , m_registrationKey(key)
 46     , m_updateViaCache(updateViaCache)
 47     , m_scopeURL(scopeURL)
 48     , m_scriptURL(scriptURL)
 49     , m_server(server)
 50     , m_creationTime(MonotonicTime::now())

 51 {
 52     m_scopeURL.removeFragmentIdentifier();
 53 }
 54 
 55 SWServerRegistration::~SWServerRegistration()
 56 {
 57     ASSERT(!m_preInstallationWorker || !m_preInstallationWorker-&gt;isRunning());
 58     ASSERT(!m_installingWorker || !m_installingWorker-&gt;isRunning());
 59     ASSERT(!m_waitingWorker || !m_waitingWorker-&gt;isRunning());
 60     ASSERT(!m_activeWorker || !m_activeWorker-&gt;isRunning());
 61 }
 62 
 63 SWServerWorker* SWServerRegistration::getNewestWorker()
 64 {
 65     if (m_installingWorker)
 66         return m_installingWorker.get();
 67     if (m_waitingWorker)
 68         return m_waitingWorker.get();
 69 
 70     return m_activeWorker.get();
</pre>
<hr />
<pre>
242     }
243     RefPtr&lt;SWServerWorker&gt; waitingWorker = this-&gt;waitingWorker();
244     if (waitingWorker) {
245         waitingWorker-&gt;terminate();
246         updateRegistrationState(ServiceWorkerRegistrationState::Waiting, nullptr);
247     }
248     RefPtr&lt;SWServerWorker&gt; activeWorker = this-&gt;activeWorker();
249     if (activeWorker) {
250         activeWorker-&gt;terminate();
251         updateRegistrationState(ServiceWorkerRegistrationState::Active, nullptr);
252     }
253 
254     if (installingWorker)
255         updateWorkerState(*installingWorker, ServiceWorkerState::Redundant);
256     if (waitingWorker)
257         updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
258     if (activeWorker)
259         updateWorkerState(*activeWorker, ServiceWorkerState::Redundant);
260 
261     // Remove scope to registration map[scopeString].
<span class="line-modified">262     m_server.removeRegistration(key());</span>
263 }
264 
265 // https://w3c.github.io/ServiceWorker/#try-activate-algorithm
266 void SWServerRegistration::tryActivate()
267 {
268     // If registration&#39;s waiting worker is null, return.
269     if (!waitingWorker())
270         return;
271     // If registration&#39;s active worker is not null and registration&#39;s active worker&#39;s state is activating, return.
272     if (activeWorker() &amp;&amp; activeWorker()-&gt;state() == ServiceWorkerState::Activating)
273         return;
274 
275     // Invoke Activate with registration if either of the following is true:
276     // - registration&#39;s active worker is null.
277     // - The result of running Service Worker Has No Pending Events with registration&#39;s active worker is true,
278     //   and no service worker client is using registration or registration&#39;s waiting worker&#39;s skip waiting flag is set.
279     if (!activeWorker() || (!activeWorker()-&gt;hasPendingEvents() &amp;&amp; (!hasClientsUsingRegistration() || waitingWorker()-&gt;isSkipWaitingFlagSet())))
280         activate();
281 }
282 
</pre>
<hr />
<pre>
316     // Queue a task to fire the activate event.
317     ASSERT(activeWorker());
318     m_server.fireActivateEvent(*activeWorker());
319 }
320 
321 // https://w3c.github.io/ServiceWorker/#activate (post activate event steps).
322 void SWServerRegistration::didFinishActivation(ServiceWorkerIdentifier serviceWorkerIdentifier)
323 {
324     if (!activeWorker() || activeWorker()-&gt;identifier() != serviceWorkerIdentifier)
325         return;
326 
327     // Run the Update Worker State algorithm passing registration&#39;s active worker and activated as the arguments.
328     updateWorkerState(*activeWorker(), ServiceWorkerState::Activated);
329 }
330 
331 // https://w3c.github.io/ServiceWorker/#on-client-unload-algorithm
332 void SWServerRegistration::handleClientUnload()
333 {
334     if (hasClientsUsingRegistration())
335         return;
<span class="line-modified">336     if (isUninstalling() &amp;&amp; tryClear())</span>
337         return;
338     tryActivate();
339 }
340 





341 void SWServerRegistration::controlClient(ServiceWorkerClientIdentifier identifier)
342 {
343     ASSERT(activeWorker());
344 
345     addClientUsingRegistration(identifier);
346 
347     HashSet&lt;DocumentIdentifier&gt; identifiers;
348     identifiers.add(identifier.contextIdentifier);
349     m_server.connection(identifier.serverConnectionIdentifier)-&gt;notifyClientsOfControllerChange(identifiers, activeWorker()-&gt;data());
350 }
351 
<span class="line-modified">352 void SWServerRegistration::setIsUninstalling(bool value)</span>
353 {
<span class="line-modified">354     if (m_uninstalling == value)</span>
<span class="line-modified">355         return;</span>
356 
<span class="line-modified">357     m_uninstalling = value;</span>

358 
<span class="line-modified">359     if (!m_uninstalling &amp;&amp; activeWorker()) {</span>
<span class="line-modified">360         // Registration with active worker has been resurrected, we need to check if any ready promises were waiting for this.</span>
<span class="line-modified">361         m_server.resolveRegistrationReadyRequests(*this);</span>
<span class="line-modified">362     }</span>










363 }
364 
365 } // namespace WebCore
366 
367 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServerRegistration.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
<span class="line-added"> 31 #include &quot;Logging.h&quot;</span>
 32 #include &quot;SWServer.h&quot;
<span class="line-added"> 33 #include &quot;SWServerToContextConnection.h&quot;</span>
 34 #include &quot;SWServerWorker.h&quot;
 35 #include &quot;ServiceWorkerTypes.h&quot;
 36 #include &quot;ServiceWorkerUpdateViaCache.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static ServiceWorkerRegistrationIdentifier generateServiceWorkerRegistrationIdentifier()
 41 {
 42     return ServiceWorkerRegistrationIdentifier::generate();
 43 }
 44 
 45 SWServerRegistration::SWServerRegistration(SWServer&amp; server, const ServiceWorkerRegistrationKey&amp; key, ServiceWorkerUpdateViaCache updateViaCache, const URL&amp; scopeURL, const URL&amp; scriptURL)
 46     : m_identifier(generateServiceWorkerRegistrationIdentifier())
 47     , m_registrationKey(key)
 48     , m_updateViaCache(updateViaCache)
 49     , m_scopeURL(scopeURL)
 50     , m_scriptURL(scriptURL)
 51     , m_server(server)
 52     , m_creationTime(MonotonicTime::now())
<span class="line-added"> 53     , m_softUpdateTimer { *this, &amp;SWServerRegistration::softUpdate }</span>
 54 {
 55     m_scopeURL.removeFragmentIdentifier();
 56 }
 57 
 58 SWServerRegistration::~SWServerRegistration()
 59 {
 60     ASSERT(!m_preInstallationWorker || !m_preInstallationWorker-&gt;isRunning());
 61     ASSERT(!m_installingWorker || !m_installingWorker-&gt;isRunning());
 62     ASSERT(!m_waitingWorker || !m_waitingWorker-&gt;isRunning());
 63     ASSERT(!m_activeWorker || !m_activeWorker-&gt;isRunning());
 64 }
 65 
 66 SWServerWorker* SWServerRegistration::getNewestWorker()
 67 {
 68     if (m_installingWorker)
 69         return m_installingWorker.get();
 70     if (m_waitingWorker)
 71         return m_waitingWorker.get();
 72 
 73     return m_activeWorker.get();
</pre>
<hr />
<pre>
245     }
246     RefPtr&lt;SWServerWorker&gt; waitingWorker = this-&gt;waitingWorker();
247     if (waitingWorker) {
248         waitingWorker-&gt;terminate();
249         updateRegistrationState(ServiceWorkerRegistrationState::Waiting, nullptr);
250     }
251     RefPtr&lt;SWServerWorker&gt; activeWorker = this-&gt;activeWorker();
252     if (activeWorker) {
253         activeWorker-&gt;terminate();
254         updateRegistrationState(ServiceWorkerRegistrationState::Active, nullptr);
255     }
256 
257     if (installingWorker)
258         updateWorkerState(*installingWorker, ServiceWorkerState::Redundant);
259     if (waitingWorker)
260         updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
261     if (activeWorker)
262         updateWorkerState(*activeWorker, ServiceWorkerState::Redundant);
263 
264     // Remove scope to registration map[scopeString].
<span class="line-modified">265     m_server.removeRegistration(identifier());</span>
266 }
267 
268 // https://w3c.github.io/ServiceWorker/#try-activate-algorithm
269 void SWServerRegistration::tryActivate()
270 {
271     // If registration&#39;s waiting worker is null, return.
272     if (!waitingWorker())
273         return;
274     // If registration&#39;s active worker is not null and registration&#39;s active worker&#39;s state is activating, return.
275     if (activeWorker() &amp;&amp; activeWorker()-&gt;state() == ServiceWorkerState::Activating)
276         return;
277 
278     // Invoke Activate with registration if either of the following is true:
279     // - registration&#39;s active worker is null.
280     // - The result of running Service Worker Has No Pending Events with registration&#39;s active worker is true,
281     //   and no service worker client is using registration or registration&#39;s waiting worker&#39;s skip waiting flag is set.
282     if (!activeWorker() || (!activeWorker()-&gt;hasPendingEvents() &amp;&amp; (!hasClientsUsingRegistration() || waitingWorker()-&gt;isSkipWaitingFlagSet())))
283         activate();
284 }
285 
</pre>
<hr />
<pre>
319     // Queue a task to fire the activate event.
320     ASSERT(activeWorker());
321     m_server.fireActivateEvent(*activeWorker());
322 }
323 
324 // https://w3c.github.io/ServiceWorker/#activate (post activate event steps).
325 void SWServerRegistration::didFinishActivation(ServiceWorkerIdentifier serviceWorkerIdentifier)
326 {
327     if (!activeWorker() || activeWorker()-&gt;identifier() != serviceWorkerIdentifier)
328         return;
329 
330     // Run the Update Worker State algorithm passing registration&#39;s active worker and activated as the arguments.
331     updateWorkerState(*activeWorker(), ServiceWorkerState::Activated);
332 }
333 
334 // https://w3c.github.io/ServiceWorker/#on-client-unload-algorithm
335 void SWServerRegistration::handleClientUnload()
336 {
337     if (hasClientsUsingRegistration())
338         return;
<span class="line-modified">339     if (isUnregistered() &amp;&amp; tryClear())</span>
340         return;
341     tryActivate();
342 }
343 
<span class="line-added">344 bool SWServerRegistration::isUnregistered() const</span>
<span class="line-added">345 {</span>
<span class="line-added">346     return m_server.getRegistration(key()) != this;</span>
<span class="line-added">347 }</span>
<span class="line-added">348 </span>
349 void SWServerRegistration::controlClient(ServiceWorkerClientIdentifier identifier)
350 {
351     ASSERT(activeWorker());
352 
353     addClientUsingRegistration(identifier);
354 
355     HashSet&lt;DocumentIdentifier&gt; identifiers;
356     identifiers.add(identifier.contextIdentifier);
357     m_server.connection(identifier.serverConnectionIdentifier)-&gt;notifyClientsOfControllerChange(identifiers, activeWorker()-&gt;data());
358 }
359 
<span class="line-modified">360 bool SWServerRegistration::shouldSoftUpdate(const FetchOptions&amp; options) const</span>
361 {
<span class="line-modified">362     if (options.mode == FetchOptions::Mode::Navigate)</span>
<span class="line-modified">363         return true;</span>
364 
<span class="line-modified">365     return WebCore::isNonSubresourceRequest(options.destination) &amp;&amp; isStale();</span>
<span class="line-added">366 }</span>
367 
<span class="line-modified">368 void SWServerRegistration::softUpdate()</span>
<span class="line-modified">369 {</span>
<span class="line-modified">370     m_server.softUpdate(*this);</span>
<span class="line-modified">371 }</span>
<span class="line-added">372 </span>
<span class="line-added">373 void SWServerRegistration::scheduleSoftUpdate()</span>
<span class="line-added">374 {</span>
<span class="line-added">375     // To avoid scheduling many updates during a single page load, we do soft updates on a 1 second delay and keep delaying</span>
<span class="line-added">376     // as long as soft update requests keep coming. This seems to match Chrome&#39;s behavior.</span>
<span class="line-added">377     if (m_softUpdateTimer.isActive())</span>
<span class="line-added">378         return;</span>
<span class="line-added">379 </span>
<span class="line-added">380     RELEASE_LOG(ServiceWorker, &quot;SWServerRegistration::softUpdateIfNeeded&quot;);</span>
<span class="line-added">381     m_softUpdateTimer.startOneShot(softUpdateDelay);</span>
382 }
383 
384 } // namespace WebCore
385 
386 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
</tr>
</table>
<center><a href="SWServerJobQueue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerRegistration.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
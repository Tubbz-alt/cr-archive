<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBreaker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineLineBreaker.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;FontCascade.h&quot;
 32 #include &quot;Hyphenation.h&quot;
 33 #include &quot;InlineItem.h&quot;
 34 #include &quot;InlineTextItem.h&quot;
 35 #include &quot;RuntimeEnabledFeatures.h&quot;
 36 #include &quot;TextUtil.h&quot;
 37 
 38 namespace WebCore {
 39 namespace Layout {
 40 
 41 static inline bool isWrappingAllowed(const RenderStyle&amp; style)
 42 {
 43     // Do not try to push overflown &#39;pre&#39; and &#39;no-wrap&#39; content to next line.
 44     return style.whiteSpace() != WhiteSpace::Pre &amp;&amp; style.whiteSpace() != WhiteSpace::NoWrap;
 45 }
 46 
 47 static inline bool shouldKeepBeginningOfLineWhitespace(const RenderStyle&amp; style)
 48 {
 49     auto whitespace = style.whiteSpace();
 50     return whitespace == WhiteSpace::Pre || whitespace == WhiteSpace::PreWrap || whitespace == WhiteSpace::BreakSpaces;
 51 }
 52 
 53 static inline Optional&lt;size_t&gt; lastWrapOpportunityIndex(const LineBreaker::RunList&amp; runList)
 54 {
 55     // &lt;span style=&quot;white-space: pre&quot;&gt;no_wrap&lt;/span&gt;&lt;span&gt;yes wrap&lt;/span&gt;&lt;span style=&quot;white-space: pre&quot;&gt;no_wrap&lt;/span&gt;.
 56     // [container start][no_wrap][container end][container start][yes] &lt;- continuous content
 57     // [ ] &lt;- continuous content
 58     // [wrap][container end][container start][no_wrap][container end] &lt;- continuous content
 59     // Return #0 as the index where the second continuous content can wrap at.
 60     ASSERT(!runList.isEmpty());
 61     auto lastItemIndex = runList.size() - 1;
 62     return isWrappingAllowed(runList[lastItemIndex].inlineItem.style()) ? makeOptional(lastItemIndex) : WTF::nullopt;
 63 }
 64 
 65 struct ContinuousContent {
 66     ContinuousContent(const LineBreaker::RunList&amp;, InlineLayoutUnit contentLogicalWidth);
 67 
 68     const LineBreaker::RunList&amp; runs() const { return m_runs; }
 69     bool isEmpty() const { return m_runs.isEmpty(); }
 70     bool hasTextContentOnly() const;
 71     bool isVisuallyEmptyWhitespaceContentOnly() const;
 72     bool hasNonContentRunsOnly() const;
 73     size_t size() const { return m_runs.size(); }
 74     InlineLayoutUnit width() const { return m_width; }
 75     InlineLayoutUnit nonCollapsibleWidth() const { return m_width - m_trailingCollapsibleContent.width; }
 76 
 77     bool hasTrailingCollapsibleContent() const { return !!m_trailingCollapsibleContent.width; }
 78     bool isTrailingContentFullyCollapsible() const { return m_trailingCollapsibleContent.isFullyCollapsible; }
 79 
 80     Optional&lt;size_t&gt; firstTextRunIndex() const;
 81     Optional&lt;size_t&gt; lastContentRunIndex() const;
 82 
 83 private:
 84     const LineBreaker::RunList&amp; m_runs;
 85     struct TrailingCollapsibleContent {
 86         void reset();
 87 
 88         bool isFullyCollapsible { false };
 89         InlineLayoutUnit width { 0 };
 90     };
 91     TrailingCollapsibleContent m_trailingCollapsibleContent;
 92     InlineLayoutUnit m_width { 0 };
 93 };
 94 
 95 struct WrappedTextContent {
 96     unsigned trailingRunIndex { 0 };
 97     bool contentOverflows { false };
 98     Optional&lt;LineBreaker::PartialRun&gt; partialTrailingRun;
 99 };
100 
101 bool LineBreaker::isContentWrappingAllowed(const ContinuousContent&amp; candidateRuns) const
102 {
103     // Use the last inline item with content (where we would be wrapping) to decide if content wrapping is allowed.
104     auto runIndex = candidateRuns.lastContentRunIndex().valueOr(candidateRuns.size() - 1);
105     return isWrappingAllowed(candidateRuns.runs()[runIndex].inlineItem.style());
106 }
107 
108 bool LineBreaker::shouldKeepEndOfLineWhitespace(const ContinuousContent&amp; candidateRuns) const
109 {
110     // Grab the style and check for white-space property to decided whether we should let this whitespace content overflow the current line.
111     // Note that the &quot;keep&quot; in the context means we let the whitespace content sit on the current line.
112     // It might very well get collapsed when we close the line (normal/nowrap/pre-line).
113     // See https://www.w3.org/TR/css-text-3/#white-space-property
114     auto whitespace = candidateRuns.runs()[*candidateRuns.firstTextRunIndex()].inlineItem.style().whiteSpace();
115     return whitespace == WhiteSpace::Normal || whitespace == WhiteSpace::NoWrap || whitespace == WhiteSpace::PreWrap || whitespace == WhiteSpace::PreLine;
116 }
117 
118 LineBreaker::Result LineBreaker::shouldWrapInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp; lineStatus)
119 {
120     auto inlineContentWrapping = [&amp;] {
121         if (candidateContentLogicalWidth &lt;= lineStatus.availableWidth)
122             return Result { Result::Action::Keep };
123 #if USE_FLOAT_AS_INLINE_LAYOUT_UNIT
124         // Preferred width computation sums up floats while line breaker substracts them. This can lead to epsilon-scale differences.
125         if (WTF::areEssentiallyEqual(candidateContentLogicalWidth, lineStatus.availableWidth))
126             return Result { Result::Action::Keep };
127 #endif
128         return tryWrappingInlineContent(candidateRuns, candidateContentLogicalWidth, lineStatus);
129     };
130 
131     auto result = inlineContentWrapping();
132     if (result.action == Result::Action::Keep) {
133         // If this is not the end of the line, hold on to the last eligible line wrap opportunity so that we could revert back
134         // to this position if no other line breaking opportunity exists in this content.
135         if (auto lastLineWrapOpportunityIndex = lastWrapOpportunityIndex(candidateRuns)) {
136             auto isEligibleLineWrapOpportunity = [&amp;] (auto&amp; candidateItem) {
137                 // Just check for leading collapsible whitespace for now.
138                 if (!lineStatus.lineIsEmpty || !candidateItem.isText() || !downcast&lt;InlineTextItem&gt;(candidateItem).isWhitespace())
139                     return true;
140                 return shouldKeepBeginningOfLineWhitespace(candidateItem.style());
141             };
142             auto&amp; inlineItem = candidateRuns[*lastLineWrapOpportunityIndex].inlineItem;
143             if (isEligibleLineWrapOpportunity(inlineItem))
144                 m_lastWrapOpportunity = &amp;inlineItem;
145         }
146     }
147     return result;
148 }
149 
150 LineBreaker::Result LineBreaker::tryWrappingInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp; lineStatus) const
151 {
152     auto candidateContent = ContinuousContent { candidateRuns, candidateContentLogicalWidth };
153     ASSERT(!candidateContent.isEmpty());
154 
155     ASSERT(candidateContent.width() &gt; lineStatus.availableWidth);
156     if (candidateContent.hasTrailingCollapsibleContent()) {
157         ASSERT(candidateContent.hasTextContentOnly());
158         auto IsEndOfLine = isContentWrappingAllowed(candidateContent) ? IsEndOfLine::Yes : IsEndOfLine::No;
159         // First check if the content fits without the trailing collapsible part.
160         if (candidateContent.nonCollapsibleWidth() &lt;= lineStatus.availableWidth)
161             return { Result::Action::Keep, IsEndOfLine };
162         // Now check if we can trim the line too.
163         if (lineStatus.lineHasFullyCollapsibleTrailingRun &amp;&amp; candidateContent.isTrailingContentFullyCollapsible()) {
164             // If this new content is fully collapsible, it should surely fit.
165             return { Result::Action::Keep, IsEndOfLine };
166         }
167     } else if (lineStatus.collapsibleWidth &amp;&amp; candidateContent.hasNonContentRunsOnly()) {
168         // Let&#39;s see if the non-content runs fit when the line has trailing collapsible content.
169         // &quot;text content &lt;span style=&quot;padding: 1px&quot;&gt;&lt;/span&gt;&quot; &lt;- the &lt;span&gt;&lt;/span&gt; runs could fit after collapsing the trailing whitespace.
170         if (candidateContent.width() &lt;= lineStatus.availableWidth + lineStatus.collapsibleWidth)
171             return { Result::Action::Keep };
172     }
173     if (candidateContent.isVisuallyEmptyWhitespaceContentOnly() &amp;&amp; shouldKeepEndOfLineWhitespace(candidateContent)) {
174         // This overflowing content apparently falls into the remove/hang end-of-line-spaces category.
175         // see https://www.w3.org/TR/css-text-3/#white-space-property matrix
176         return { Result::Action::Keep };
177     }
178 
179     if (candidateContent.hasTextContentOnly()) {
180         auto&amp; runs = candidateContent.runs();
181         if (auto wrappedTextContent = wrapTextContent(runs, lineStatus)) {
182             if (!wrappedTextContent-&gt;trailingRunIndex &amp;&amp; wrappedTextContent-&gt;contentOverflows) {
183                 // We tried to split the content but the available space can&#39;t even accommodate the first character.
184                 // 1. Push the content over to the next line when we&#39;ve got content on the line already.
185                 // 2. Keep the first character on the empty line (or keep the whole run if it has only one character).
186                 if (!lineStatus.lineIsEmpty)
187                     return { Result::Action::Push, IsEndOfLine::Yes, { } };
188                 auto firstTextRunIndex = *candidateContent.firstTextRunIndex();
189                 auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(runs[firstTextRunIndex].inlineItem);
190                 ASSERT(inlineTextItem.length());
191                 if (inlineTextItem.length() == 1)
192                     return Result { Result::Action::Keep, IsEndOfLine::Yes };
193                 auto firstCharacterWidth = TextUtil::width(inlineTextItem, inlineTextItem.start(), inlineTextItem.start() + 1);
194                 auto firstCharacterRun = PartialRun { 1, firstCharacterWidth, false };
195                 return { Result::Action::Split, IsEndOfLine::Yes, Result::PartialTrailingContent { firstTextRunIndex, firstCharacterRun } };
196             }
197             auto splitContent = Result::PartialTrailingContent { wrappedTextContent-&gt;trailingRunIndex, wrappedTextContent-&gt;partialTrailingRun };
198             return { Result::Action::Split, IsEndOfLine::Yes, splitContent };
199         }
200     }
201     // If we are not allowed to break this overflowing content, we still need to decide whether keep it or push it to the next line.
202     if (lineStatus.lineIsEmpty) {
203         ASSERT(!m_lastWrapOpportunity);
204         return { Result::Action::Keep, IsEndOfLine::No };
205     }
206     // Now either wrap here or at an earlier position, or not wrap at all.
207     if (isContentWrappingAllowed(candidateContent))
208         return { Result::Action::Push, IsEndOfLine::Yes };
209     if (m_lastWrapOpportunity)
210         return { Result::Action::Revert, IsEndOfLine::Yes, { }, m_lastWrapOpportunity };
211     return { Result::Action::Keep, IsEndOfLine::No };
212 }
213 
214 bool LineBreaker::shouldWrapFloatBox(InlineLayoutUnit floatLogicalWidth, InlineLayoutUnit availableWidth, bool lineIsEmpty)
215 {
216     return !lineIsEmpty &amp;&amp; floatLogicalWidth &gt; availableWidth;
217 }
218 
219 Optional&lt;WrappedTextContent&gt; LineBreaker::wrapTextContent(const RunList&amp; runs, const LineStatus&amp; lineStatus) const
220 {
221     auto isContentSplitAllowed = [] (auto&amp; run) {
222         ASSERT(run.inlineItem.isText() || run.inlineItem.isContainerStart() || run.inlineItem.isContainerEnd());
223         if (!run.inlineItem.isText()) {
224             // Can&#39;t split horizontal spacing -&gt; e.g. &lt;span style=&quot;padding-right: 100px;&quot;&gt;textcontent&lt;/span&gt;, if the [container end] is the overflown inline item
225             // we need to check if there&#39;s another inline item beyond the [container end] to split.
226             return false;
227         }
228         return isWrappingAllowed(run.inlineItem.style());
229     };
230 
231     // Check where the overflow occurs and use the corresponding style to figure out the breaking behaviour.
232     // &lt;span style=&quot;word-break: normal&quot;&gt;first&lt;/span&gt;&lt;span style=&quot;word-break: break-all&quot;&gt;second&lt;/span&gt;&lt;span style=&quot;word-break: normal&quot;&gt;third&lt;/span&gt;
233     InlineLayoutUnit accumulatedRunWidth = 0;
234     unsigned index = 0;
235     while (index &lt; runs.size()) {
236         auto&amp; run = runs[index];
237         ASSERT(run.inlineItem.isText() || run.inlineItem.isContainerStart() || run.inlineItem.isContainerEnd());
238         if (accumulatedRunWidth + run.logicalWidth &gt; lineStatus.availableWidth &amp;&amp; isContentSplitAllowed(run)) {
239             // At this point the available width can very well be negative e.g. when some part of the continuous text content can not be broken into parts -&gt;
240             // &lt;span style=&quot;word-break: keep-all&quot;&gt;textcontentwithnobreak&lt;/span&gt;&lt;span&gt;textcontentwithyesbreak&lt;/span&gt;
241             // When the first span computes longer than the available space, by the time we get to the second span, the adjusted available space becomes negative.
242             auto adjustedAvailableWidth = std::max&lt;InlineLayoutUnit&gt;(0, lineStatus.availableWidth - accumulatedRunWidth);
243             if (auto partialRun = tryBreakingTextRun(run, adjustedAvailableWidth)) {
244                  if (partialRun-&gt;length)
245                      return WrappedTextContent { index, false, partialRun };
246                  // When the content is wrapped at the run boundary, the trailing run is the previous run.
247                  if (index)
248                      return WrappedTextContent { index - 1, false, { } };
249                  // Sometimes we can&#39;t accommodate even the very first character.
250                  return WrappedTextContent { 0, true, { } };
251              }
252             // If this run is not breakable, we need to check if any previous run is breakable
253             break;
254         }
255         accumulatedRunWidth += run.logicalWidth;
256         ++index;
257     }
258     // We did not manage to break the run that actually overflows the line.
259     // Let&#39;s try to find the first breakable run and wrap it at the content boundary (as it surely fits).
260     while (index--) {
261         auto&amp; run = runs[index];
262         if (isContentSplitAllowed(run)) {
263             ASSERT(run.inlineItem.isText());
264             if (auto partialRun = tryBreakingTextRun(run, maxInlineLayoutUnit())) {
265                  // We know this run fits, so if wrapping is allowed on the run, it should return a non-empty left-side.
266                  ASSERT(partialRun-&gt;length);
267                  return WrappedTextContent { index, false, partialRun };
268             }
269         }
270     }
271     // Give up, there&#39;s no breakable run in here.
272     return { };
273 }
274 
275 LineBreaker::WordBreakRule LineBreaker::wordBreakBehavior(const RenderStyle&amp; style) const
276 {
277     // Disregard any prohibition against line breaks mandated by the word-break property.
278     // The different wrapping opportunities must not be prioritized. Hyphenation is not applied.
279     if (style.lineBreak() == LineBreak::Anywhere)
280         return WordBreakRule::AtArbitraryPosition;
281     // Breaking is allowed within “words”.
282     if (style.wordBreak() == WordBreak::BreakAll)
283         return WordBreakRule::AtArbitraryPosition;
284     // Breaking is forbidden within “words”.
285     if (style.wordBreak() == WordBreak::KeepAll)
286         return WordBreakRule::NoBreak;
287     // For compatibility with legacy content, the word-break property also supports a deprecated break-word keyword.
288     // When specified, this has the same effect as word-break: normal and overflow-wrap: anywhere, regardless of the actual value of the overflow-wrap property.
289     if (style.wordBreak() == WordBreak::BreakWord &amp;&amp; !m_lastWrapOpportunity)
290         return WordBreakRule::AtArbitraryPosition;
291     // OverflowWrap::Break: An otherwise unbreakable sequence of characters may be broken at an arbitrary point if there are no otherwise-acceptable break points in the line.
292     if (style.overflowWrap() == OverflowWrap::Break &amp;&amp; !m_lastWrapOpportunity)
293         return WordBreakRule::AtArbitraryPosition;
294 
295     if (!n_hyphenationIsDisabled &amp;&amp; style.hyphens() == Hyphens::Auto &amp;&amp; canHyphenate(style.locale()))
296         return WordBreakRule::OnlyHyphenationAllowed;
297 
298     return WordBreakRule::NoBreak;
299 }
300 
301 Optional&lt;LineBreaker::PartialRun&gt; LineBreaker::tryBreakingTextRun(const Run&amp; overflowRun, InlineLayoutUnit availableWidth) const
302 {
303     ASSERT(overflowRun.inlineItem.isText());
304     auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(overflowRun.inlineItem);
305     auto&amp; style = inlineTextItem.style();
306     auto findLastBreakablePosition = availableWidth == maxInlineLayoutUnit();
307 
308     auto breakRule = wordBreakBehavior(style);
309     if (breakRule == WordBreakRule::AtArbitraryPosition) {
310         if (findLastBreakablePosition) {
311             // When the run can be split at arbitrary position,
312             // let&#39;s just return the entire run when it is intended to fit on the line.
313             return PartialRun { inlineTextItem.length(), overflowRun.logicalWidth, false };
314         }
315         // FIXME: Pass in the content logical left to be able to measure tabs.
316         auto splitData = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), inlineTextItem.length(), overflowRun.logicalWidth, availableWidth, { });
317         return PartialRun { splitData.length, splitData.logicalWidth, false };
318     }
319 
320     if (breakRule == WordBreakRule::OnlyHyphenationAllowed) {
321         // Find the hyphen position as follows:
322         // 1. Split the text by taking the hyphen width into account
323         // 2. Find the last hyphen position before the split position
324         auto runLength = inlineTextItem.length();
325         unsigned limitBefore = style.hyphenationLimitBefore() == RenderStyle::initialHyphenationLimitBefore() ? 0 : style.hyphenationLimitBefore();
326         unsigned limitAfter = style.hyphenationLimitAfter() == RenderStyle::initialHyphenationLimitAfter() ? 0 : style.hyphenationLimitAfter();
327         // Check if this run can accommodate the before/after limits at all before start measuring text.
328         if (limitBefore &gt;= runLength || limitAfter &gt;= runLength || limitBefore + limitAfter &gt; runLength)
329             return { };
330 
331         unsigned leftSideLength = runLength;
332         // FIXME: We might want to cache the hyphen width.
333         auto&amp; fontCascade = style.fontCascade();
334         auto hyphenWidth = InlineLayoutUnit { fontCascade.width(TextRun { StringView { style.hyphenString() } }) };
335         if (!findLastBreakablePosition) {
336             auto availableWidthExcludingHyphen = availableWidth - hyphenWidth;
337             if (availableWidthExcludingHyphen &lt;= 0 || !enoughWidthForHyphenation(availableWidthExcludingHyphen, fontCascade.pixelSize()))
338                 return { };
339             leftSideLength = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), runLength, overflowRun.logicalWidth, availableWidthExcludingHyphen, { }).length;
340         }
341         if (leftSideLength &lt; limitBefore)
342             return { };
343         auto textContent = inlineTextItem.layoutBox().textContext()-&gt;content;
344         // Adjust before index to accommodate the limit-after value (it&#39;s the last potential hyphen location in this run).
345         auto hyphenBefore = std::min(leftSideLength, runLength - limitAfter) + 1;
346         unsigned hyphenLocation = lastHyphenLocation(StringView(textContent).substring(inlineTextItem.start(), inlineTextItem.length()), hyphenBefore, style.locale());
347         if (!hyphenLocation || hyphenLocation &lt; limitBefore)
348             return { };
349         // hyphenLocation is relative to the start of this InlineItemText.
350         auto trailingPartialRunWidthWithHyphen = TextUtil::width(inlineTextItem, inlineTextItem.start(), inlineTextItem.start() + hyphenLocation) + hyphenWidth;
351         return PartialRun { hyphenLocation, trailingPartialRunWidthWithHyphen, true };
352     }
353 
354     ASSERT(breakRule == WordBreakRule::NoBreak);
355     return { };
356 }
357 
358 ContinuousContent::ContinuousContent(const LineBreaker::RunList&amp; runs, InlineLayoutUnit contentLogicalWidth)
359     : m_runs(runs)
360     , m_width(contentLogicalWidth)
361 {
362     // Figure out the trailing collapsible state.
363     for (auto&amp; run : WTF::makeReversedRange(m_runs)) {
364         auto&amp; inlineItem = run.inlineItem;
365         if (inlineItem.isBox()) {
366             // We did reach a non-collapsible content. We have all the trailing whitespace now.
367             break;
368         }
369         if (inlineItem.isText()) {
370             auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);
371             auto isFullyCollapsible = [&amp;] {
372                 return inlineTextItem.isWhitespace() &amp;&amp; !TextUtil::shouldPreserveTrailingWhitespace(inlineTextItem.style());
373             };
374             if (isFullyCollapsible()) {
375                 m_trailingCollapsibleContent.width += run.logicalWidth;
376                 m_trailingCollapsibleContent.isFullyCollapsible = true;
377                 // Let&#39;s see if we&#39;ve got more trailing whitespace content.
378                 continue;
379             }
380             if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
381                 // A run with trailing letter spacing is partially collapsible.
382                 if (auto collapsibleWidth = inlineTextItem.style().letterSpacing()) {
383                     m_trailingCollapsibleContent.width += collapsibleWidth;
384                     m_trailingCollapsibleContent.isFullyCollapsible = false;
385                 }
386             }
387             // End of whitespace content.
388             break;
389         }
390     }
391 }
392 
393 bool ContinuousContent::hasTextContentOnly() const
394 {
395     // &lt;span&gt;text&lt;/span&gt; is considered a text run even with the [container start][container end] inline items.
396     // Due to commit boundary rules, we just need to check the first non-typeless inline item (can&#39;t have both [img] and [text])
397     for (auto&amp; run : m_runs) {
398         auto&amp; inlineItem = run.inlineItem;
399         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())
400             continue;
401         return inlineItem.isText();
402     }
403     return false;
404 }
405 
406 bool ContinuousContent::isVisuallyEmptyWhitespaceContentOnly() const
407 {
408     // [&lt;span&gt;&lt;/span&gt; ] [&lt;span&gt; &lt;/span&gt;] [ &lt;span style=&quot;padding: 0px;&quot;&gt;&lt;/span&gt;] are all considered visually empty whitespace content.
409     // [&lt;span style=&quot;border: 1px solid red&quot;&gt;&lt;/span&gt; ] while this is whitespace content only, it is not considered visually empty.
410     // Due to commit boundary rules, we just need to check the first non-typeless inline item (can&#39;t have both [img] and [text])
411     for (auto&amp; run : m_runs) {
412         auto&amp; inlineItem = run.inlineItem;
413         // FIXME: check for padding border etc.
414         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())
415             continue;
416         return inlineItem.isText() &amp;&amp; downcast&lt;InlineTextItem&gt;(inlineItem).isWhitespace();
417     }
418     return false;
419 }
420 
421 Optional&lt;size_t&gt; ContinuousContent::firstTextRunIndex() const
422 {
423     for (size_t index = 0; index &lt; m_runs.size(); ++index) {
424         if (m_runs[index].inlineItem.isText())
425             return index;
426     }
427     return { };
428 }
429 
430 Optional&lt;size_t&gt; ContinuousContent::lastContentRunIndex() const
431 {
432     for (size_t index = m_runs.size(); index--;) {
433         if (m_runs[index].inlineItem.isText() || m_runs[index].inlineItem.isBox())
434             return index;
435     }
436     return { };
437 }
438 
439 bool ContinuousContent::hasNonContentRunsOnly() const
440 {
441     // &lt;span&gt;&lt;/span&gt; &lt;- non content runs.
442     for (auto&amp; run : m_runs) {
443         auto&amp; inlineItem = run.inlineItem;
444         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())
445             continue;
446         return false;
447     }
448     return true;
449 }
450 
451 void ContinuousContent::TrailingCollapsibleContent::reset()
452 {
453     isFullyCollapsible = false;
454     width = 0_lu;
455 }
456 
457 }
458 }
459 #endif
    </pre>
  </body>
</html>
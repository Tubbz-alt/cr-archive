<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;DFGCommon.h&quot;
 29 
 30 #if ENABLE(FTL_JIT)
 31 
 32 #include &quot;B3BasicBlockInlines.h&quot;
 33 #include &quot;B3CCallValue.h&quot;
 34 #include &quot;B3Compilation.h&quot;
 35 #include &quot;B3FrequentedBlock.h&quot;
 36 #include &quot;B3Procedure.h&quot;
 37 #include &quot;B3SwitchValue.h&quot;
 38 #include &quot;B3Width.h&quot;
 39 #include &quot;FTLAbbreviatedTypes.h&quot;
 40 #include &quot;FTLAbstractHeapRepository.h&quot;
 41 #include &quot;FTLCommonValues.h&quot;
 42 #include &quot;FTLSelectPredictability.h&quot;
 43 #include &quot;FTLState.h&quot;
 44 #include &quot;FTLSwitchCase.h&quot;
 45 #include &quot;FTLTypedPointer.h&quot;
 46 #include &quot;FTLValueFromBlock.h&quot;
 47 #include &quot;FTLWeight.h&quot;
 48 #include &quot;FTLWeightedTarget.h&quot;
 49 #include &quot;HeapCell.h&quot;
 50 #include &lt;wtf/OrderMaker.h&gt;
 51 #include &lt;wtf/StringPrintStream.h&gt;
 52 
 53 // FIXME: remove this once everything can be generated through B3.
 54 IGNORE_WARNINGS_BEGIN(&quot;missing-noreturn&quot;)
 55 ALLOW_UNUSED_PARAMETERS_BEGIN
 56 
 57 namespace JSC {
 58 
 59 namespace DFG {
 60 struct Node;
 61 } // namespace DFG
 62 
 63 namespace B3 {
 64 class FenceValue;
 65 class SlotBaseValue;
 66 } // namespace B3
 67 
 68 namespace FTL {
 69 
 70 enum Scale { ScaleOne, ScaleTwo, ScaleFour, ScaleEight, ScalePtr };
 71 
 72 class Output : public CommonValues {
 73 public:
 74     Output(State&amp;);
 75     ~Output();
 76 
 77     void initialize(AbstractHeapRepository&amp;);
 78 
 79     void setFrequency(double value)
 80     {
 81         m_frequency = value;
 82     }
 83 
 84     LBasicBlock newBlock();
 85 
 86     LBasicBlock insertNewBlocksBefore(LBasicBlock nextBlock)
 87     {
 88         LBasicBlock lastNextBlock = m_nextBlock;
 89         m_nextBlock = nextBlock;
 90         return lastNextBlock;
 91     }
 92 
 93     void applyBlockOrder();
 94 
 95     LBasicBlock appendTo(LBasicBlock, LBasicBlock nextBlock);
 96     void appendTo(LBasicBlock);
 97 
 98     void setOrigin(DFG::Node* node) { m_origin = node; }
 99     B3::Origin origin() { return B3::Origin(m_origin); }
100 
101     LValue framePointer();
102 
103     B3::SlotBaseValue* lockedStackSlot(size_t bytes);
104 
105     LValue constBool(bool value);
106     LValue constInt32(int32_t value);
107 
108     LValue alreadyRegisteredWeakPointer(DFG::Graph&amp; graph, JSCell* cell)
109     {
110         ASSERT(graph.m_plan.weakReferences().contains(cell));
111 
112         return constIntPtr(bitwise_cast&lt;intptr_t&gt;(cell));
113     }
114 
115     LValue alreadyRegisteredFrozenPointer(DFG::FrozenValue* value)
116     {
117         RELEASE_ASSERT(value-&gt;value().isCell());
118 
119         return constIntPtr(bitwise_cast&lt;intptr_t&gt;(value-&gt;cell()));
120     }
121 
122     template&lt;typename T&gt;
123     LValue constIntPtr(T* value)
124     {
125         static_assert(!std::is_base_of&lt;HeapCell, T&gt;::value, &quot;To use a GC pointer, the graph must be aware of it. Use gcPointer instead and make sure the graph is aware of this reference.&quot;);
126         if (sizeof(void*) == 8)
127             return constInt64(bitwise_cast&lt;intptr_t&gt;(value));
128         return constInt32(bitwise_cast&lt;intptr_t&gt;(value));
129     }
130     template&lt;typename T&gt;
131     LValue constIntPtr(T value)
132     {
133         if (sizeof(void*) == 8)
134             return constInt64(static_cast&lt;intptr_t&gt;(value));
135         return constInt32(static_cast&lt;intptr_t&gt;(value));
136     }
137     LValue constInt64(int64_t value);
138     LValue constDouble(double value);
139 
140     LValue phi(LType);
141     template&lt;typename... Params&gt;
142     LValue phi(LType, ValueFromBlock, Params... theRest);
143     template&lt;typename VectorType&gt;
144     LValue phi(LType, const VectorType&amp;);
145     void addIncomingToPhi(LValue phi, ValueFromBlock);
146     template&lt;typename... Params&gt;
147     void addIncomingToPhi(LValue phi, ValueFromBlock, Params... theRest);
148 
149     LValue opaque(LValue);
150 
151     LValue add(LValue, LValue);
152     LValue sub(LValue, LValue);
153     LValue mul(LValue, LValue);
154     LValue div(LValue, LValue);
155     LValue chillDiv(LValue, LValue);
156     LValue mod(LValue, LValue);
157     LValue chillMod(LValue, LValue);
158     LValue neg(LValue);
159 
160     LValue doubleAdd(LValue, LValue);
161     LValue doubleSub(LValue, LValue);
162     LValue doubleMul(LValue, LValue);
163     LValue doubleDiv(LValue, LValue);
164     LValue doubleMod(LValue, LValue);
165     LValue doubleNeg(LValue value) { return neg(value); }
166 
167     LValue bitAnd(LValue, LValue);
168     LValue bitOr(LValue, LValue);
169     LValue bitXor(LValue, LValue);
170     LValue shl(LValue, LValue shiftAmount);
171     LValue aShr(LValue, LValue shiftAmount);
172     LValue lShr(LValue, LValue shiftAmount);
173     LValue bitNot(LValue);
174     LValue logicalNot(LValue);
175 
176     LValue ctlz32(LValue);
177     LValue doubleAbs(LValue);
178     LValue doubleCeil(LValue);
179     LValue doubleFloor(LValue);
180     LValue doubleTrunc(LValue);
181 
182     LValue doubleUnary(DFG::Arith::UnaryType, LValue);
183 
184     LValue doublePow(LValue base, LValue exponent);
185     LValue doublePowi(LValue base, LValue exponent);
186 
187     LValue doubleSqrt(LValue);
188 
189     LValue doubleLog(LValue);
190 
191     LValue doubleToInt(LValue);
192     LValue doubleToInt64(LValue);
193     LValue doubleToUInt(LValue);
194 
195     LValue signExt32To64(LValue);
196     LValue signExt32ToPtr(LValue);
197     LValue zeroExt(LValue, LType);
198     LValue zeroExtPtr(LValue value) { return zeroExt(value, B3::Int64); }
199     LValue intToDouble(LValue);
200     LValue unsignedToDouble(LValue);
201     LValue castToInt32(LValue);
202     LValue doubleToFloat(LValue);
203     LValue floatToDouble(LValue);
204     LValue bitCast(LValue, LType);
205     LValue fround(LValue);
206 
207     LValue load(TypedPointer, LType);
208     LValue store(LValue, TypedPointer);
209     B3::FenceValue* fence(const AbstractHeap* read, const AbstractHeap* write);
210 
211     LValue load8SignExt32(TypedPointer);
212     LValue load8ZeroExt32(TypedPointer);
213     LValue load16SignExt32(TypedPointer);
214     LValue load16ZeroExt32(TypedPointer);
215     LValue load32(TypedPointer pointer) { return load(pointer, B3::Int32); }
216     LValue load64(TypedPointer pointer) { return load(pointer, B3::Int64); }
217     LValue loadPtr(TypedPointer pointer) { return load(pointer, B3::pointerType()); }
218     LValue loadFloat(TypedPointer pointer) { return load(pointer, B3::Float); }
219     LValue loadDouble(TypedPointer pointer) { return load(pointer, B3::Double); }
220     LValue store32As8(LValue, TypedPointer);
221     LValue store32As16(LValue, TypedPointer);
222     LValue store32(LValue value, TypedPointer pointer)
223     {
224         ASSERT(value-&gt;type() == B3::Int32);
225         return store(value, pointer);
226     }
227     LValue store64(LValue value, TypedPointer pointer)
228     {
229         ASSERT(value-&gt;type() == B3::Int64);
230         return store(value, pointer);
231     }
232     LValue storePtr(LValue value, TypedPointer pointer)
233     {
234         ASSERT(value-&gt;type() == B3::pointerType());
235         return store(value, pointer);
236     }
237     LValue storeFloat(LValue value, TypedPointer pointer)
238     {
239         ASSERT(value-&gt;type() == B3::Float);
240         return store(value, pointer);
241     }
242     LValue storeDouble(LValue value, TypedPointer pointer)
243     {
244         ASSERT(value-&gt;type() == B3::Double);
245         return store(value, pointer);
246     }
247 
248     enum LoadType {
249         Load8SignExt32,
250         Load8ZeroExt32,
251         Load16SignExt32,
252         Load16ZeroExt32,
253         Load32,
254         Load64,
255         LoadPtr,
256         LoadFloat,
257         LoadDouble
258     };
259 
260     LValue load(TypedPointer, LoadType);
261 
262     enum StoreType {
263         Store32As8,
264         Store32As16,
265         Store32,
266         Store64,
267         StorePtr,
268         StoreFloat,
269         StoreDouble
270     };
271 
272     LValue store(LValue, TypedPointer, StoreType);
273 
274     LValue addPtr(LValue value, ptrdiff_t immediate = 0)
275     {
276         if (!immediate)
277             return value;
278         return add(value, constIntPtr(immediate));
279     }
280 
281     // Construct an address by offsetting base by the requested amount and ascribing
282     // the requested abstract heap to it.
283     TypedPointer address(const AbstractHeap&amp; heap, LValue base, ptrdiff_t offset = 0)
284     {
285         return TypedPointer(heap, addPtr(base, offset));
286     }
287     // Construct an address by offsetting base by the amount specified by the field,
288     // and optionally an additional amount (use this with care), and then creating
289     // a TypedPointer with the given field as the heap.
290     TypedPointer address(LValue base, const AbstractHeap&amp; field, ptrdiff_t offset = 0)
291     {
292         return address(field, base, offset + field.offset());
293     }
294 
295     LValue baseIndex(LValue base, LValue index, Scale, ptrdiff_t offset = 0);
296 
297     TypedPointer baseIndex(const AbstractHeap&amp; heap, LValue base, LValue index, Scale scale, ptrdiff_t offset = 0)
298     {
299         return TypedPointer(heap, baseIndex(base, index, scale, offset));
300     }
301     TypedPointer baseIndex(IndexedAbstractHeap&amp; heap, LValue base, LValue index, JSValue indexAsConstant = JSValue(), ptrdiff_t offset = 0, LValue mask = nullptr)
302     {
303         return heap.baseIndex(*this, base, index, indexAsConstant, offset, mask);
304     }
305 
306     TypedPointer absolute(const void* address);
307 
308     LValue load8SignExt32(LValue base, const AbstractHeap&amp; field) { return load8SignExt32(address(base, field)); }
309     LValue load8ZeroExt32(LValue base, const AbstractHeap&amp; field) { return load8ZeroExt32(address(base, field)); }
310     LValue load16SignExt32(LValue base, const AbstractHeap&amp; field) { return load16SignExt32(address(base, field)); }
311     LValue load16ZeroExt32(LValue base, const AbstractHeap&amp; field) { return load16ZeroExt32(address(base, field)); }
312     LValue load32(LValue base, const AbstractHeap&amp; field) { return load32(address(base, field)); }
313     LValue load64(LValue base, const AbstractHeap&amp; field) { return load64(address(base, field)); }
314     LValue loadPtr(LValue base, const AbstractHeap&amp; field) { return loadPtr(address(base, field)); }
315     LValue loadDouble(LValue base, const AbstractHeap&amp; field) { return loadDouble(address(base, field)); }
316     void store32As8(LValue value, LValue base, const AbstractHeap&amp; field) { store32As8(value, address(base, field)); }
317     void store32As16(LValue value, LValue base, const AbstractHeap&amp; field) { store32As16(value, address(base, field)); }
318     void store32(LValue value, LValue base, const AbstractHeap&amp; field) { store32(value, address(base, field)); }
319     void store64(LValue value, LValue base, const AbstractHeap&amp; field) { store64(value, address(base, field)); }
320     void storePtr(LValue value, LValue base, const AbstractHeap&amp; field) { storePtr(value, address(base, field)); }
321     void storeDouble(LValue value, LValue base, const AbstractHeap&amp; field) { storeDouble(value, address(base, field)); }
322 
323     // FIXME: Explore adding support for value range constraints to B3. Maybe it could be as simple as having
324     // a load instruction that guarantees that its result is non-negative.
325     // https://bugs.webkit.org/show_bug.cgi?id=151458
326     void ascribeRange(LValue, const ValueRange&amp;) { }
327     LValue nonNegative32(LValue loadInstruction) { return loadInstruction; }
328     LValue load32NonNegative(TypedPointer pointer) { return load32(pointer); }
329     LValue load32NonNegative(LValue base, const AbstractHeap&amp; field) { return load32(base, field); }
330 
331     LValue equal(LValue, LValue);
332     LValue notEqual(LValue, LValue);
333     LValue above(LValue, LValue);
334     LValue aboveOrEqual(LValue, LValue);
335     LValue below(LValue, LValue);
336     LValue belowOrEqual(LValue, LValue);
337     LValue greaterThan(LValue, LValue);
338     LValue greaterThanOrEqual(LValue, LValue);
339     LValue lessThan(LValue, LValue);
340     LValue lessThanOrEqual(LValue, LValue);
341 
342     LValue doubleEqual(LValue, LValue);
343     LValue doubleEqualOrUnordered(LValue, LValue);
344     LValue doubleNotEqualOrUnordered(LValue, LValue);
345     LValue doubleLessThan(LValue, LValue);
346     LValue doubleLessThanOrEqual(LValue, LValue);
347     LValue doubleGreaterThan(LValue, LValue);
348     LValue doubleGreaterThanOrEqual(LValue, LValue);
349     LValue doubleNotEqualAndOrdered(LValue, LValue);
350     LValue doubleLessThanOrUnordered(LValue, LValue);
351     LValue doubleLessThanOrEqualOrUnordered(LValue, LValue);
352     LValue doubleGreaterThanOrUnordered(LValue, LValue);
353     LValue doubleGreaterThanOrEqualOrUnordered(LValue, LValue);
354 
355     LValue isZero32(LValue);
356     LValue notZero32(LValue);
357     LValue isZero64(LValue);
358     LValue notZero64(LValue);
359     LValue isNull(LValue value) { return isZero64(value); }
360     LValue notNull(LValue value) { return notZero64(value); }
361 
362     LValue testIsZero32(LValue value, LValue mask) { return isZero32(bitAnd(value, mask)); }
363     LValue testNonZero32(LValue value, LValue mask) { return notZero32(bitAnd(value, mask)); }
364     LValue testIsZero64(LValue value, LValue mask) { return isZero64(bitAnd(value, mask)); }
365     LValue testNonZero64(LValue value, LValue mask) { return notZero64(bitAnd(value, mask)); }
366     LValue testIsZeroPtr(LValue value, LValue mask) { return isNull(bitAnd(value, mask)); }
367     LValue testNonZeroPtr(LValue value, LValue mask) { return notNull(bitAnd(value, mask)); }
368 
369     LValue select(LValue value, LValue taken, LValue notTaken, SelectPredictability = SelectPredictability::NotPredictable);
370 
371     // These are relaxed atomics by default. Use AbstractHeapRepository::decorateFencedAccess() with a
372     // non-null heap to make them seq_cst fenced.
373     LValue atomicXchgAdd(LValue operand, TypedPointer pointer, B3::Width);
374     LValue atomicXchgAnd(LValue operand, TypedPointer pointer, B3::Width);
375     LValue atomicXchgOr(LValue operand, TypedPointer pointer, B3::Width);
376     LValue atomicXchgSub(LValue operand, TypedPointer pointer, B3::Width);
377     LValue atomicXchgXor(LValue operand, TypedPointer pointer, B3::Width);
378     LValue atomicXchg(LValue operand, TypedPointer pointer, B3::Width);
379     LValue atomicStrongCAS(LValue expected, LValue newValue, TypedPointer pointer, B3::Width);
380 
381     template&lt;typename VectorType&gt;
382     LValue call(LType type, LValue function, const VectorType&amp; vector)
383     {
384         B3::CCallValue* result = m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function);
385         result-&gt;appendArgs(vector);
386         return result;
387     }
388     LValue call(LType type, LValue function) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function); }
389     LValue call(LType type, LValue function, LValue arg1) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function, arg1); }
390     template&lt;typename... Args&gt;
391     LValue call(LType type, LValue function, LValue arg1, Args... args) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function, arg1, args...); }
392 
393     template&lt;typename Function, typename... Args&gt;
394     LValue callWithoutSideEffects(B3::Type type, Function function, LValue arg1, Args... args)
395     {
396         static_assert(!std::is_same&lt;Function, LValue&gt;::value);
397         return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), B3::Effects::none(),
398             constIntPtr(tagCFunctionPtr&lt;void*&gt;(function, B3CCallPtrTag)), arg1, args...);
399     }
400 
401     // FIXME: Consider enhancing this to allow the client to choose the target PtrTag to use.
402     // https://bugs.webkit.org/show_bug.cgi?id=184324
403     template&lt;typename FunctionType&gt;
404     LValue operation(FunctionType function) { return constIntPtr(tagCFunctionPtr&lt;void*&gt;(function, B3CCallPtrTag)); }
405 
406     void jump(LBasicBlock);
407     void branch(LValue condition, LBasicBlock taken, Weight takenWeight, LBasicBlock notTaken, Weight notTakenWeight);
408     void branch(LValue condition, WeightedTarget taken, WeightedTarget notTaken)
409     {
410         branch(condition, taken.target(), taken.weight(), notTaken.target(), notTaken.weight());
411     }
412 
413     // Branches to an already-created handler if true, &quot;falls through&quot; if false. Fall-through is
414     // simulated by creating a continuation for you.
415     void check(LValue condition, WeightedTarget taken, Weight notTakenWeight);
416 
417     // Same as check(), but uses Weight::inverse() to compute the notTakenWeight.
418     void check(LValue condition, WeightedTarget taken);
419 
420     template&lt;typename VectorType&gt;
421     void switchInstruction(LValue value, const VectorType&amp; cases, LBasicBlock fallThrough, Weight fallThroughWeight)
422     {
423         B3::SwitchValue* switchValue = m_block-&gt;appendNew&lt;B3::SwitchValue&gt;(m_proc, origin(), value);
424         switchValue-&gt;setFallThrough(B3::FrequentedBlock(fallThrough));
425         for (const SwitchCase&amp; switchCase : cases) {
426             int64_t value = switchCase.value()-&gt;asInt();
427             B3::FrequentedBlock target(switchCase.target(), switchCase.weight().frequencyClass());
428             switchValue-&gt;appendCase(B3::SwitchCase(value, target));
429         }
430     }
431 
432     void entrySwitch(const Vector&lt;LBasicBlock&gt;&amp;);
433 
434     void ret(LValue);
435 
436     void unreachable();
437 
438     void appendSuccessor(WeightedTarget);
439 
440     B3::CheckValue* speculate(LValue);
441     B3::CheckValue* speculateAdd(LValue, LValue);
442     B3::CheckValue* speculateSub(LValue, LValue);
443     B3::CheckValue* speculateMul(LValue, LValue);
444 
445     B3::PatchpointValue* patchpoint(LType);
446 
447     void trap();
448 
449     ValueFromBlock anchor(LValue);
450 
451     void incrementSuperSamplerCount();
452     void decrementSuperSamplerCount();
453 
454 #if PLATFORM(COCOA)
455 #pragma mark - States
456 #endif
457     B3::Procedure&amp; m_proc;
458 
459     DFG::Node* m_origin { nullptr };
460     LBasicBlock m_block { nullptr };
461     LBasicBlock m_nextBlock { nullptr };
462 
463     AbstractHeapRepository* m_heaps;
464 
465     double m_frequency { 1 };
466 
467 private:
468     OrderMaker&lt;LBasicBlock&gt; m_blockOrder;
469 };
470 
471 template&lt;typename... Params&gt;
472 inline LValue Output::phi(LType type, ValueFromBlock value, Params... theRest)
473 {
474     LValue phiNode = phi(type);
475     addIncomingToPhi(phiNode, value, theRest...);
476     return phiNode;
477 }
478 
479 template&lt;typename VectorType&gt;
480 inline LValue Output::phi(LType type, const VectorType&amp; vector)
481 {
482     LValue phiNode = phi(type);
483     for (const ValueFromBlock&amp; valueFromBlock : vector)
484         addIncomingToPhi(phiNode, valueFromBlock);
485     return phiNode;
486 }
487 
488 template&lt;typename... Params&gt;
489 inline void Output::addIncomingToPhi(LValue phi, ValueFromBlock value, Params... theRest)
490 {
491     addIncomingToPhi(phi, value);
492     addIncomingToPhi(phi, theRest...);
493 }
494 
495 ALLOW_UNUSED_PARAMETERS_END
496 IGNORE_WARNINGS_END
497 
498 } } // namespace JSC::FTL
499 
500 #endif // ENABLE(FTL_JIT)
    </pre>
  </body>
</html>
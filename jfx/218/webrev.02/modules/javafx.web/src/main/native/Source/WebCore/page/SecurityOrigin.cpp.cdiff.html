<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollToOptions.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SecurityOrigin.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2007-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,13 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  
  #include &quot;BlobURL.h&quot;
  #include &quot;OriginAccessEntry.h&quot;
  #include &quot;PublicSuffix.h&quot;
<span class="line-modified">! #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;SecurityPolicy.h&quot;
  #include &quot;TextEncoding.h&quot;
  #include &quot;ThreadableBlobRegistry.h&quot;
  #include &lt;wtf/FileSystem.h&gt;
  #include &lt;wtf/MainThread.h&gt;
<span class="line-new-header">--- 28,14 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  
  #include &quot;BlobURL.h&quot;
<span class="line-added">+ #include &quot;LegacySchemeRegistry.h&quot;</span>
  #include &quot;OriginAccessEntry.h&quot;
  #include &quot;PublicSuffix.h&quot;
<span class="line-modified">! #include &quot;RuntimeApplicationChecks.h&quot;</span>
  #include &quot;SecurityPolicy.h&quot;
  #include &quot;TextEncoding.h&quot;
  #include &quot;ThreadableBlobRegistry.h&quot;
  #include &lt;wtf/FileSystem.h&gt;
  #include &lt;wtf/MainThread.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,18 ***</span>
<span class="line-new-header">--- 44,25 ---</span>
  #include &lt;wtf/URL.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
<span class="line-added">+ constexpr unsigned maximumURLSize = 0x04000000;</span>
<span class="line-added">+ </span>
  static bool schemeRequiresHost(const URL&amp; url)
  {
      // We expect URLs with these schemes to have authority components. If the
      // URL lacks an authority component, we get concerned and mark the origin
      // as unique.
      return url.protocolIsInHTTPFamily() || url.protocolIs(&quot;ftp&quot;);
  }
  
<span class="line-added">+ bool SecurityOrigin::shouldIgnoreHost(const URL&amp; url)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return url.protocolIsData() || url.protocolIsAbout() || protocolIsJavaScript(url) || url.protocolIs(&quot;file&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool SecurityOrigin::shouldUseInnerURL(const URL&amp; url)
  {
      // FIXME: Blob URLs don&#39;t have inner URLs. Their form is &quot;blob:&lt;inner-origin&gt;/&lt;UUID&gt;&quot;, so treating the part after &quot;blob:&quot; as a URL is incorrect.
      if (url.protocolIsBlob())
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
      // This is an additional safety net against bugs in URL parsing, and for network back-ends that parse URLs differently,
      // and could misinterpret another component for hostname.
      if (schemeRequiresHost(innerURL) &amp;&amp; innerURL.host().isEmpty())
          return true;
  
<span class="line-modified">!     if (SchemeRegistry::shouldTreatURLSchemeAsNoAccess(innerURL.protocol().toStringWithoutCopying()))</span>
          return true;
  
      // This is the common case.
      return false;
  }
<span class="line-new-header">--- 101,11 ---</span>
      // This is an additional safety net against bugs in URL parsing, and for network back-ends that parse URLs differently,
      // and could misinterpret another component for hostname.
      if (schemeRequiresHost(innerURL) &amp;&amp; innerURL.host().isEmpty())
          return true;
  
<span class="line-modified">!     if (LegacySchemeRegistry::shouldTreatURLSchemeAsNoAccess(innerURL.protocol().toStringWithoutCopying()))</span>
          return true;
  
      // This is the common case.
      return false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,17 ***</span>
  }
  
  // https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy (Editor&#39;s Draft, 17 November 2016)
  static bool shouldTreatAsPotentiallyTrustworthy(const String&amp; protocol, const String&amp; host)
  {
<span class="line-modified">!     if (SchemeRegistry::shouldTreatURLSchemeAsSecure(protocol))</span>
          return true;
  
      if (SecurityOrigin::isLocalHostOrLoopbackIPAddress(host))
          return true;
  
<span class="line-modified">!     if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
          return true;
  
      return false;
  }
  
<span class="line-new-header">--- 132,17 ---</span>
  }
  
  // https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy (Editor&#39;s Draft, 17 November 2016)
  static bool shouldTreatAsPotentiallyTrustworthy(const String&amp; protocol, const String&amp; host)
  {
<span class="line-modified">!     if (LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(protocol))</span>
          return true;
  
      if (SecurityOrigin::isLocalHostOrLoopbackIPAddress(host))
          return true;
  
<span class="line-modified">!     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
          return true;
  
      return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,11 ***</span>
      return shouldTreatAsPotentiallyTrustworthy(url.protocol().toStringWithoutCopying(), url.host().toStringWithoutCopying());
  }
  
  SecurityOrigin::SecurityOrigin(const URL&amp; url)
      : m_data(SecurityOriginData::fromURL(url))
<span class="line-modified">!     , m_isLocal(SchemeRegistry::shouldTreatURLSchemeAsLocal(m_data.protocol))</span>
  {
      // document.domain starts as m_data.host, but can be set by the DOM.
      m_domain = m_data.host;
  
      if (m_data.port &amp;&amp; WTF::isDefaultPortForProtocol(m_data.port.value(), m_data.protocol))
<span class="line-new-header">--- 151,11 ---</span>
      return shouldTreatAsPotentiallyTrustworthy(url.protocol().toStringWithoutCopying(), url.host().toStringWithoutCopying());
  }
  
  SecurityOrigin::SecurityOrigin(const URL&amp; url)
      : m_data(SecurityOriginData::fromURL(url))
<span class="line-modified">!     , m_isLocal(LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_data.protocol))</span>
  {
      // document.domain starts as m_data.host, but can be set by the DOM.
      m_domain = m_data.host;
  
      if (m_data.port &amp;&amp; WTF::isDefaultPortForProtocol(m_data.port.value(), m_data.protocol))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,15 ***</span>
  }
  
  bool SecurityOrigin::isSecure(const URL&amp; url)
  {
      // Invalid URLs are secure, as are URLs which have a secure protocol.
<span class="line-modified">!     if (!url.isValid() || SchemeRegistry::shouldTreatURLSchemeAsSecure(url.protocol().toStringWithoutCopying()))</span>
          return true;
  
      // URLs that wrap inner URLs are secure if those inner URLs are secure.
<span class="line-modified">!     if (shouldUseInnerURL(url) &amp;&amp; SchemeRegistry::shouldTreatURLSchemeAsSecure(extractInnerURL(url).protocol().toStringWithoutCopying()))</span>
          return true;
  
      return false;
  }
  
<span class="line-new-header">--- 235,15 ---</span>
  }
  
  bool SecurityOrigin::isSecure(const URL&amp; url)
  {
      // Invalid URLs are secure, as are URLs which have a secure protocol.
<span class="line-modified">!     if (!url.isValid() || LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(url.protocol().toStringWithoutCopying()))</span>
          return true;
  
      // URLs that wrap inner URLs are secure if those inner URLs are secure.
<span class="line-modified">!     if (shouldUseInnerURL(url) &amp;&amp; LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(extractInnerURL(url).protocol().toStringWithoutCopying()))</span>
          return true;
  
      return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,36 ***</span>
          || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:https:&quot;);
  }
  
  bool SecurityOrigin::canDisplay(const URL&amp; url) const
  {
      if (m_universalAccess)
          return true;
  
<span class="line-modified">! #if !PLATFORM(IOS_FAMILY)</span>
      if (m_data.protocol == &quot;file&quot; &amp;&amp; url.isLocalFile() &amp;&amp; !FileSystem::filesHaveSameVolume(m_filePath, url.fileSystemPath()))
          return false;
  #endif
  
      if (isFeedWithNestedProtocolInHTTPFamily(url))
          return true;
  
      String protocol = url.protocol().toString();
  
<span class="line-modified">!     if (SchemeRegistry::canDisplayOnlyIfCanRequest(protocol))</span>
          return canRequest(url);
  
<span class="line-modified">!     if (SchemeRegistry::shouldTreatURLSchemeAsDisplayIsolated(protocol))</span>
          return equalIgnoringASCIICase(m_data.protocol, protocol) || SecurityPolicy::isAccessToURLWhiteListed(this, url);
  
      if (!SecurityPolicy::restrictAccessToLocal())
          return true;
  
      if (url.isLocalFile() &amp;&amp; url.fileSystemPath() == m_filePath)
          return true;
  
<span class="line-modified">!     if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
          return canLoadLocalResources() || SecurityPolicy::isAccessToURLWhiteListed(this, url);
  
      return true;
  }
  
<span class="line-new-header">--- 359,40 ---</span>
          || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:https:&quot;);
  }
  
  bool SecurityOrigin::canDisplay(const URL&amp; url) const
  {
<span class="line-added">+     ASSERT(!isInNetworkProcess());</span>
      if (m_universalAccess)
          return true;
  
<span class="line-modified">!     if (url.pathEnd() &gt; maximumURLSize)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if !PLATFORM(IOS_FAMILY) &amp;&amp; !ENABLE(BUBBLEWRAP_SANDBOX)</span>
      if (m_data.protocol == &quot;file&quot; &amp;&amp; url.isLocalFile() &amp;&amp; !FileSystem::filesHaveSameVolume(m_filePath, url.fileSystemPath()))
          return false;
  #endif
  
      if (isFeedWithNestedProtocolInHTTPFamily(url))
          return true;
  
      String protocol = url.protocol().toString();
  
<span class="line-modified">!     if (LegacySchemeRegistry::canDisplayOnlyIfCanRequest(protocol))</span>
          return canRequest(url);
  
<span class="line-modified">!     if (LegacySchemeRegistry::shouldTreatURLSchemeAsDisplayIsolated(protocol))</span>
          return equalIgnoringASCIICase(m_data.protocol, protocol) || SecurityPolicy::isAccessToURLWhiteListed(this, url);
  
      if (!SecurityPolicy::restrictAccessToLocal())
          return true;
  
      if (url.isLocalFile() &amp;&amp; url.fileSystemPath() == m_filePath)
          return true;
  
<span class="line-modified">!     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
          return canLoadLocalResources() || SecurityPolicy::isAccessToURLWhiteListed(this, url);
  
      return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 480,11 ***</span>
          return emptyString();
  
      if (isHTTPFamily())
          return host();
  
<span class="line-modified">!     if (SchemeRegistry::shouldPartitionCacheForURLScheme(m_data.protocol))</span>
          return host();
  
      return emptyString();
  }
  
<span class="line-new-header">--- 492,11 ---</span>
          return emptyString();
  
      if (isHTTPFamily())
          return host();
  
<span class="line-modified">!     if (LegacySchemeRegistry::shouldPartitionCacheForURLScheme(m_data.protocol))</span>
          return host();
  
      return emptyString();
  }
  
</pre>
<center><a href="ScrollToOptions.idl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SecurityOrigin.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
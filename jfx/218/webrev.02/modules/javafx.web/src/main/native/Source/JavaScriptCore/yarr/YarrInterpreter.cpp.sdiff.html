<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="YarrErrorCode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrInterpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;YarrInterpreter.h&quot;
  29 
  30 #include &quot;Options.h&quot;
  31 #include &quot;SuperSampler.h&quot;
  32 #include &quot;Yarr.h&quot;
  33 #include &quot;YarrCanonicalize.h&quot;
  34 #include &lt;wtf/BumpPointerAllocator.h&gt;
  35 #include &lt;wtf/CheckedArithmetic.h&gt;
  36 #include &lt;wtf/DataLog.h&gt;

  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/WTFString.h&gt;
  39 
  40 namespace JSC { namespace Yarr {
  41 
  42 template&lt;typename CharType&gt;
  43 class Interpreter {
  44 public:
  45     struct ParenthesesDisjunctionContext;
  46 
  47     struct BackTrackInfoParentheses {
  48         uintptr_t matchAmount;
  49         ParenthesesDisjunctionContext* lastContext;
  50     };
  51 
  52     static inline void appendParenthesesDisjunctionContext(BackTrackInfoParentheses* backTrack, ParenthesesDisjunctionContext* context)
  53     {
  54         context-&gt;next = backTrack-&gt;lastContext;
  55         backTrack-&gt;lastContext = context;
  56         ++backTrack-&gt;matchAmount;
</pre>
<hr />
<pre>
1677 
1678 class ByteCompiler {
1679     struct ParenthesesStackEntry {
1680         unsigned beginTerm;
1681         unsigned savedAlternativeIndex;
1682         ParenthesesStackEntry(unsigned beginTerm, unsigned savedAlternativeIndex/*, unsigned subpatternId, bool capture = false*/)
1683             : beginTerm(beginTerm)
1684             , savedAlternativeIndex(savedAlternativeIndex)
1685         {
1686         }
1687     };
1688 
1689 public:
1690     ByteCompiler(YarrPattern&amp; pattern)
1691         : m_pattern(pattern)
1692     {
1693     }
1694 
1695     std::unique_ptr&lt;BytecodePattern&gt; compile(BumpPointerAllocator* allocator, ConcurrentJSLock* lock, ErrorCode&amp; errorCode)
1696     {





1697         regexBegin(m_pattern.m_numSubpatterns, m_pattern.m_body-&gt;m_callFrameSize, m_pattern.m_body-&gt;m_alternatives[0]-&gt;onceThrough());
1698         if (auto error = emitDisjunction(m_pattern.m_body, 0, 0)) {
1699             errorCode = error.value();
1700             return nullptr;
1701         }
1702         regexEnd();
1703 
1704 #ifndef NDEBUG
1705         if (Options::dumpCompiledRegExpPatterns())
1706             dumpDisjunction(m_bodyDisjunction.get());
1707 #endif
1708 
1709         return makeUnique&lt;BytecodePattern&gt;(WTFMove(m_bodyDisjunction), m_allParenthesesInfo, m_pattern, allocator, lock);
1710     }
1711 
1712     void checkInput(unsigned count)
1713     {
1714         m_bodyDisjunction-&gt;terms.append(ByteTerm::CheckInput(count));
1715     }
1716 
</pre>
<hr />
<pre>
2011     void alternativeBodyDisjunction(bool onceThrough)
2012     {
2013         unsigned newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
2014         m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
2015         m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeDisjunction(onceThrough));
2016 
2017         m_currentAlternativeIndex = newAlternativeIndex;
2018     }
2019 
2020     void alternativeDisjunction()
2021     {
2022         unsigned newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
2023         m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
2024         m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeDisjunction());
2025 
2026         m_currentAlternativeIndex = newAlternativeIndex;
2027     }
2028 
2029     Optional&lt;ErrorCode&gt; WARN_UNUSED_RETURN emitDisjunction(PatternDisjunction* disjunction, Checked&lt;unsigned, RecordOverflow&gt; inputCountAlreadyChecked, unsigned parenthesesInputCountAlreadyChecked)
2030     {



2031         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
2032             auto currentCountAlreadyChecked = inputCountAlreadyChecked;
2033 
2034             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
2035 
2036             if (alt) {
2037                 if (disjunction == m_pattern.m_body)
2038                     alternativeBodyDisjunction(alternative-&gt;onceThrough());
2039                 else
2040                     alternativeDisjunction();
2041             }
2042 
2043             unsigned minimumSize = alternative-&gt;m_minimumSize;
2044             ASSERT(minimumSize &gt;= parenthesesInputCountAlreadyChecked);
2045             unsigned countToCheck = minimumSize - parenthesesInputCountAlreadyChecked;
2046 
2047             if (countToCheck) {
2048                 checkInput(countToCheck);
2049                 currentCountAlreadyChecked += countToCheck;
2050                 if (currentCountAlreadyChecked.hasOverflowed())
</pre>
<hr />
<pre>
2388             case ByteTerm::TypeCheckInput:
2389                 outputTermIndexAndNest(idx, nesting);
2390                 out.print(&quot;CheckInput &quot;, term.checkInputCount);
2391                 break;
2392             case ByteTerm::TypeUncheckInput:
2393                 outputTermIndexAndNest(idx, nesting);
2394                 out.print(&quot;UncheckInput &quot;, term.checkInputCount);
2395                 break;
2396             case ByteTerm::TypeDotStarEnclosure:
2397                 outputTermIndexAndNest(idx, nesting);
2398                 out.print(&quot;DotStarEnclosure&quot;);
2399                 break;
2400             }
2401             if (outputNewline)
2402                 out.print(&quot;\n&quot;);
2403         }
2404     }
2405 #endif
2406 
2407 private:


2408     YarrPattern&amp; m_pattern;
2409     std::unique_ptr&lt;ByteDisjunction&gt; m_bodyDisjunction;

2410     unsigned m_currentAlternativeIndex { 0 };
2411     Vector&lt;ParenthesesStackEntry&gt; m_parenthesesStack;
2412     Vector&lt;std::unique_ptr&lt;ByteDisjunction&gt;&gt; m_allParenthesesInfo;
2413 };
2414 
2415 std::unique_ptr&lt;BytecodePattern&gt; byteCompile(YarrPattern&amp; pattern, BumpPointerAllocator* allocator, ErrorCode&amp; errorCode, ConcurrentJSLock* lock)
2416 {
2417     return ByteCompiler(pattern).compile(allocator, lock, errorCode);
2418 }
2419 
2420 unsigned interpret(BytecodePattern* bytecode, const String&amp; input, unsigned start, unsigned* output)
2421 {
2422     SuperSamplerScope superSamplerScope(false);
2423     if (input.is8Bit())
2424         return Interpreter&lt;LChar&gt;(bytecode, output, input.characters8(), input.length(), start).interpret();
2425     return Interpreter&lt;UChar&gt;(bytecode, output, input.characters16(), input.length(), start).interpret();
2426 }
2427 
2428 unsigned interpret(BytecodePattern* bytecode, const LChar* input, unsigned length, unsigned start, unsigned* output)
2429 {
</pre>
</td>
<td>
<hr />
<pre>
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;YarrInterpreter.h&quot;
  29 
  30 #include &quot;Options.h&quot;
  31 #include &quot;SuperSampler.h&quot;
  32 #include &quot;Yarr.h&quot;
  33 #include &quot;YarrCanonicalize.h&quot;
  34 #include &lt;wtf/BumpPointerAllocator.h&gt;
  35 #include &lt;wtf/CheckedArithmetic.h&gt;
  36 #include &lt;wtf/DataLog.h&gt;
<span class="line-added">  37 #include &lt;wtf/StackCheck.h&gt;</span>
  38 #include &lt;wtf/text/CString.h&gt;
  39 #include &lt;wtf/text/WTFString.h&gt;
  40 
  41 namespace JSC { namespace Yarr {
  42 
  43 template&lt;typename CharType&gt;
  44 class Interpreter {
  45 public:
  46     struct ParenthesesDisjunctionContext;
  47 
  48     struct BackTrackInfoParentheses {
  49         uintptr_t matchAmount;
  50         ParenthesesDisjunctionContext* lastContext;
  51     };
  52 
  53     static inline void appendParenthesesDisjunctionContext(BackTrackInfoParentheses* backTrack, ParenthesesDisjunctionContext* context)
  54     {
  55         context-&gt;next = backTrack-&gt;lastContext;
  56         backTrack-&gt;lastContext = context;
  57         ++backTrack-&gt;matchAmount;
</pre>
<hr />
<pre>
1678 
1679 class ByteCompiler {
1680     struct ParenthesesStackEntry {
1681         unsigned beginTerm;
1682         unsigned savedAlternativeIndex;
1683         ParenthesesStackEntry(unsigned beginTerm, unsigned savedAlternativeIndex/*, unsigned subpatternId, bool capture = false*/)
1684             : beginTerm(beginTerm)
1685             , savedAlternativeIndex(savedAlternativeIndex)
1686         {
1687         }
1688     };
1689 
1690 public:
1691     ByteCompiler(YarrPattern&amp; pattern)
1692         : m_pattern(pattern)
1693     {
1694     }
1695 
1696     std::unique_ptr&lt;BytecodePattern&gt; compile(BumpPointerAllocator* allocator, ConcurrentJSLock* lock, ErrorCode&amp; errorCode)
1697     {
<span class="line-added">1698         if (UNLIKELY(!isSafeToRecurse())) {</span>
<span class="line-added">1699             errorCode = ErrorCode::TooManyDisjunctions;</span>
<span class="line-added">1700             return nullptr;</span>
<span class="line-added">1701         }</span>
<span class="line-added">1702 </span>
1703         regexBegin(m_pattern.m_numSubpatterns, m_pattern.m_body-&gt;m_callFrameSize, m_pattern.m_body-&gt;m_alternatives[0]-&gt;onceThrough());
1704         if (auto error = emitDisjunction(m_pattern.m_body, 0, 0)) {
1705             errorCode = error.value();
1706             return nullptr;
1707         }
1708         regexEnd();
1709 
1710 #ifndef NDEBUG
1711         if (Options::dumpCompiledRegExpPatterns())
1712             dumpDisjunction(m_bodyDisjunction.get());
1713 #endif
1714 
1715         return makeUnique&lt;BytecodePattern&gt;(WTFMove(m_bodyDisjunction), m_allParenthesesInfo, m_pattern, allocator, lock);
1716     }
1717 
1718     void checkInput(unsigned count)
1719     {
1720         m_bodyDisjunction-&gt;terms.append(ByteTerm::CheckInput(count));
1721     }
1722 
</pre>
<hr />
<pre>
2017     void alternativeBodyDisjunction(bool onceThrough)
2018     {
2019         unsigned newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
2020         m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
2021         m_bodyDisjunction-&gt;terms.append(ByteTerm::BodyAlternativeDisjunction(onceThrough));
2022 
2023         m_currentAlternativeIndex = newAlternativeIndex;
2024     }
2025 
2026     void alternativeDisjunction()
2027     {
2028         unsigned newAlternativeIndex = m_bodyDisjunction-&gt;terms.size();
2029         m_bodyDisjunction-&gt;terms[m_currentAlternativeIndex].alternative.next = newAlternativeIndex - m_currentAlternativeIndex;
2030         m_bodyDisjunction-&gt;terms.append(ByteTerm::AlternativeDisjunction());
2031 
2032         m_currentAlternativeIndex = newAlternativeIndex;
2033     }
2034 
2035     Optional&lt;ErrorCode&gt; WARN_UNUSED_RETURN emitDisjunction(PatternDisjunction* disjunction, Checked&lt;unsigned, RecordOverflow&gt; inputCountAlreadyChecked, unsigned parenthesesInputCountAlreadyChecked)
2036     {
<span class="line-added">2037         if (UNLIKELY(!isSafeToRecurse()))</span>
<span class="line-added">2038             return ErrorCode::TooManyDisjunctions;</span>
<span class="line-added">2039 </span>
2040         for (unsigned alt = 0; alt &lt; disjunction-&gt;m_alternatives.size(); ++alt) {
2041             auto currentCountAlreadyChecked = inputCountAlreadyChecked;
2042 
2043             PatternAlternative* alternative = disjunction-&gt;m_alternatives[alt].get();
2044 
2045             if (alt) {
2046                 if (disjunction == m_pattern.m_body)
2047                     alternativeBodyDisjunction(alternative-&gt;onceThrough());
2048                 else
2049                     alternativeDisjunction();
2050             }
2051 
2052             unsigned minimumSize = alternative-&gt;m_minimumSize;
2053             ASSERT(minimumSize &gt;= parenthesesInputCountAlreadyChecked);
2054             unsigned countToCheck = minimumSize - parenthesesInputCountAlreadyChecked;
2055 
2056             if (countToCheck) {
2057                 checkInput(countToCheck);
2058                 currentCountAlreadyChecked += countToCheck;
2059                 if (currentCountAlreadyChecked.hasOverflowed())
</pre>
<hr />
<pre>
2397             case ByteTerm::TypeCheckInput:
2398                 outputTermIndexAndNest(idx, nesting);
2399                 out.print(&quot;CheckInput &quot;, term.checkInputCount);
2400                 break;
2401             case ByteTerm::TypeUncheckInput:
2402                 outputTermIndexAndNest(idx, nesting);
2403                 out.print(&quot;UncheckInput &quot;, term.checkInputCount);
2404                 break;
2405             case ByteTerm::TypeDotStarEnclosure:
2406                 outputTermIndexAndNest(idx, nesting);
2407                 out.print(&quot;DotStarEnclosure&quot;);
2408                 break;
2409             }
2410             if (outputNewline)
2411                 out.print(&quot;\n&quot;);
2412         }
2413     }
2414 #endif
2415 
2416 private:
<span class="line-added">2417     inline bool isSafeToRecurse() { return m_stackCheck.isSafeToRecurse(); }</span>
<span class="line-added">2418 </span>
2419     YarrPattern&amp; m_pattern;
2420     std::unique_ptr&lt;ByteDisjunction&gt; m_bodyDisjunction;
<span class="line-added">2421     StackCheck m_stackCheck;</span>
2422     unsigned m_currentAlternativeIndex { 0 };
2423     Vector&lt;ParenthesesStackEntry&gt; m_parenthesesStack;
2424     Vector&lt;std::unique_ptr&lt;ByteDisjunction&gt;&gt; m_allParenthesesInfo;
2425 };
2426 
2427 std::unique_ptr&lt;BytecodePattern&gt; byteCompile(YarrPattern&amp; pattern, BumpPointerAllocator* allocator, ErrorCode&amp; errorCode, ConcurrentJSLock* lock)
2428 {
2429     return ByteCompiler(pattern).compile(allocator, lock, errorCode);
2430 }
2431 
2432 unsigned interpret(BytecodePattern* bytecode, const String&amp; input, unsigned start, unsigned* output)
2433 {
2434     SuperSamplerScope superSamplerScope(false);
2435     if (input.is8Bit())
2436         return Interpreter&lt;LChar&gt;(bytecode, output, input.characters8(), input.length(), start).interpret();
2437     return Interpreter&lt;UChar&gt;(bytecode, output, input.characters16(), input.length(), start).interpret();
2438 }
2439 
2440 unsigned interpret(BytecodePattern* bytecode, const LChar* input, unsigned length, unsigned start, unsigned* output)
2441 {
</pre>
</td>
</tr>
</table>
<center><a href="YarrErrorCode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="YarrJIT.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/AsyncFromSyncIteratorPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Oleksandr Skachkov &lt;gskachkov@gmail.com&gt;.
  3  * Copyright (C) 2019 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 function next(value)
 28 {
 29     &quot;use strict&quot;;
 30 
 31     var promise = @newPromise();
 32 
 33     if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
 34         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));
 35         return promise;
 36     }
 37 
 38     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);
 39 
 40     try {
 41         var nextResult = @getByIdDirectPrivate(this, &quot;nextMethod&quot;).@call(syncIterator, value);
 42         var nextDone = !!nextResult.done;
 43         var nextValue = nextResult.value;
 44         @resolveWithoutPromise(nextValue,
 45             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: nextDone }); },
 46             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });
 47     } catch (e) {
 48         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);
 49     }
 50 
 51     return promise;
 52 }
 53 
 54 function return(value)
 55 {
 56     &quot;use strict&quot;;
 57 
 58     var promise = @newPromise();
 59 
 60     if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
 61         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));
 62         return promise;
 63     }
 64 
 65     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);
 66 
 67     var returnMethod;
 68 
 69     try {
 70         returnMethod = syncIterator.return;
 71     } catch (e) {
 72         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);
 73         return promise;
 74     }
 75 
 76     if (returnMethod === @undefined) {
 77         @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value, done: true });
 78         return promise;
 79     }
 80     
 81     try {
 82         var returnResult = returnMethod.@call(syncIterator, value);
 83 
 84         if (!@isObject(returnResult)) {
 85             @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));
 86             return promise;
 87         }
 88 
 89         var resultDone = !!returnResult.done;
 90         var resultValue = returnResult.value;
 91         @resolveWithoutPromise(resultValue,
 92             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: resultDone }); },
 93             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });
 94     } catch (e) {
 95         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);
 96     }
 97 
 98     return promise;
 99 }
100 
101 function throw(exception)
102 {
103     &quot;use strict&quot;;
104 
105     var promise = @newPromise();
106 
107     if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
108         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));
109         return promise;
110     }
111 
112     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);
113 
114     var throwMethod;
115 
116     try {
117         throwMethod = syncIterator.throw;
118     } catch (e) {
119         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);
120         return promise;
121     }
122 
123     if (throwMethod === @undefined) {
124         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, exception);
125         return promise;
126     }
127     
128     try {
129         var throwResult = throwMethod.@call(syncIterator, exception);
130         
131         if (!@isObject(throwResult)) {
132             @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));
133             return promise;
134         }
135         
136         var throwDone = !!throwResult.done;
137         var throwValue = throwResult.value;
138         @resolveWithoutPromise(throwValue,
139             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: throwDone }); },
140             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });
141     } catch (e) {
142         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);
143     }
144     
145     return promise;
146 }
147 
148 @globalPrivate
149 function createAsyncFromSyncIterator(syncIterator, nextMethod)
150 {
151     &quot;use strict&quot;;
152 
153     if (!@isObject(syncIterator))
154         @throwTypeError(&#39;Only objects can be wrapped by async-from-sync wrapper&#39;);
155 
156     return new @AsyncFromSyncIterator(syncIterator, nextMethod);
157 }
158 
159 @globalPrivate
160 @constructor
161 function AsyncFromSyncIterator(syncIterator, nextMethod)
162 {
163     &quot;use strict&quot;;
164 
165     @putByIdDirectPrivate(this, &quot;syncIterator&quot;, syncIterator);
166     @putByIdDirectPrivate(this, &quot;nextMethod&quot;, nextMethod);
167 }
    </pre>
  </body>
</html>
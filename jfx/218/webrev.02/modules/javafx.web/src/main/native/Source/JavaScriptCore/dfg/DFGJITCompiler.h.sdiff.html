<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCompiler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGJITCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITFinalizer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCompiler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 81 // DFG::JITCompiler is responsible for generating JIT code from the dataflow graph.
 82 // It does so by delegating to the speculative &amp; non-speculative JITs, which
 83 // generate to a MacroAssembler (which the JITCompiler owns through an inheritance
 84 // relationship). The JITCompiler holds references to information required during
 85 // compilation, and also records information used in linking (e.g. a list of all
 86 // call to be linked).
 87 class JITCompiler : public CCallHelpers {
 88 public:
 89     JITCompiler(Graph&amp; dfg);
 90     ~JITCompiler();
 91 
 92     void compile();
 93     void compileFunction();
 94 
 95     // Accessors for properties.
 96     Graph&amp; graph() { return m_graph; }
 97 
 98     // Methods to set labels for the disassembler.
 99     void setStartOfCode()
100     {
<span class="line-modified">101         m_pcToCodeOriginMapBuilder.appendItem(labelIgnoringWatchpoints(), CodeOrigin(0, nullptr));</span>
102         if (LIKELY(!m_disassembler))
103             return;
104         m_disassembler-&gt;setStartOfCode(labelIgnoringWatchpoints());
105     }
106 
107     void setForBlockIndex(BlockIndex blockIndex)
108     {
109         if (LIKELY(!m_disassembler))
110             return;
111         m_disassembler-&gt;setForBlockIndex(blockIndex, labelIgnoringWatchpoints());
112     }
113 
114     void setForNode(Node* node)
115     {
116         if (LIKELY(!m_disassembler))
117             return;
118         m_disassembler-&gt;setForNode(node, labelIgnoringWatchpoints());
119     }
120 
121     void setEndOfMainPath();
122     void setEndOfCode();
123 
124     CallSiteIndex addCallSite(CodeOrigin codeOrigin)
125     {
126         return m_jitCode-&gt;common.addCodeOrigin(codeOrigin);
127     }
128 
129     CallSiteIndex emitStoreCodeOrigin(CodeOrigin codeOrigin)
130     {
131         CallSiteIndex callSite = addCallSite(codeOrigin);
132         emitStoreCallSiteIndex(callSite);
133         return callSite;
134     }
135 
136     void emitStoreCallSiteIndex(CallSiteIndex callSite)
137     {
<span class="line-modified">138         store32(TrustedImm32(callSite.bits()), tagFor(static_cast&lt;VirtualRegister&gt;(CallFrameSlot::argumentCount)));</span>
139     }
140 
141     // Add a call out from JIT code, without an exception check.
142     Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
143     {
144         Call functionCall = call(OperationPtrTag);
145         m_calls.append(CallLinkRecord(functionCall, function.retagged&lt;OperationPtrTag&gt;()));
146         return functionCall;
147     }
148 
149     void exceptionCheck();
150 
151     void exceptionCheckWithCallFrameRollback()
152     {
153         m_exceptionChecksWithCallFrameRollback.append(emitExceptionCheck(vm()));
154     }
155 
156     // Add a call out from JIT code, with a fast exception check that tests if the return value is zero.
157     void fastExceptionCheck()
158     {
</pre>
<hr />
<pre>
165         OSRExitCompilationInfo info;
166         info.m_failureJumps = jumpsToFail;
167         m_exitCompilationInfo.append(info);
168         return m_exitCompilationInfo.last();
169     }
170 
171 #if USE(JSVALUE32_64)
172     void* addressOfDoubleConstant(Node*);
173 #endif
174 
175     void addGetById(const JITGetByIdGenerator&amp; gen, SlowPathGenerator* slowPath)
176     {
177         m_getByIds.append(InlineCacheWrapper&lt;JITGetByIdGenerator&gt;(gen, slowPath));
178     }
179 
180     void addGetByIdWithThis(const JITGetByIdWithThisGenerator&amp; gen, SlowPathGenerator* slowPath)
181     {
182         m_getByIdsWithThis.append(InlineCacheWrapper&lt;JITGetByIdWithThisGenerator&gt;(gen, slowPath));
183     }
184 





185     void addPutById(const JITPutByIdGenerator&amp; gen, SlowPathGenerator* slowPath)
186     {
187         m_putByIds.append(InlineCacheWrapper&lt;JITPutByIdGenerator&gt;(gen, slowPath));
188     }
189 
190     void addInstanceOf(const JITInstanceOfGenerator&amp; gen, SlowPathGenerator* slowPath)
191     {
192         m_instanceOfs.append(InlineCacheWrapper&lt;JITInstanceOfGenerator&gt;(gen, slowPath));
193     }
194 
195     void addInById(const JITInByIdGenerator&amp; gen, SlowPathGenerator* slowPath)
196     {
197         m_inByIds.append(InlineCacheWrapper&lt;JITInByIdGenerator&gt;(gen, slowPath));
198     }
199 
200     void addJSCall(Call fastCall, Call slowCall, DataLabelPtr targetToCheck, CallLinkInfo* info)
201     {
202         m_jsCalls.append(JSCallRecord(fastCall, slowCall, targetToCheck, info));
203     }
204 
</pre>
<hr />
<pre>
324 
325     struct JSDirectTailCallRecord {
326         JSDirectTailCallRecord(PatchableJump patchableJump, Call call, Label slowPath, CallLinkInfo* info)
327             : patchableJump(patchableJump)
328             , call(call)
329             , slowPath(slowPath)
330             , info(info)
331         {
332             ASSERT(call.isFlagSet(Call::Near) &amp;&amp; call.isFlagSet(Call::Tail));
333         }
334 
335         PatchableJump patchableJump;
336         Call call;
337         Label slowPath;
338         CallLinkInfo* info;
339     };
340 
341 
342     Vector&lt;InlineCacheWrapper&lt;JITGetByIdGenerator&gt;, 4&gt; m_getByIds;
343     Vector&lt;InlineCacheWrapper&lt;JITGetByIdWithThisGenerator&gt;, 4&gt; m_getByIdsWithThis;

344     Vector&lt;InlineCacheWrapper&lt;JITPutByIdGenerator&gt;, 4&gt; m_putByIds;
345     Vector&lt;InlineCacheWrapper&lt;JITInByIdGenerator&gt;, 4&gt; m_inByIds;
346     Vector&lt;InlineCacheWrapper&lt;JITInstanceOfGenerator&gt;, 4&gt; m_instanceOfs;
347     Vector&lt;JSCallRecord, 4&gt; m_jsCalls;
348     Vector&lt;JSDirectCallRecord, 4&gt; m_jsDirectCalls;
349     Vector&lt;JSDirectTailCallRecord, 4&gt; m_jsDirectTailCalls;
350     SegmentedVector&lt;OSRExitCompilationInfo, 4&gt; m_exitCompilationInfo;
351     Vector&lt;Vector&lt;Label&gt;&gt; m_exitSiteLabels;
352 
353     struct ExceptionHandlingOSRExitInfo {
354         OSRExitCompilationInfo&amp; exitInfo;
355         HandlerInfo baselineExceptionHandler;
356         CallSiteIndex callSiteIndex;
357     };
358     Vector&lt;ExceptionHandlingOSRExitInfo&gt; m_exceptionHandlerOSRExitCallSites;
359 
360     std::unique_ptr&lt;SpeculativeJIT&gt; m_speculative;
361     PCToCodeOriginMapBuilder m_pcToCodeOriginMapBuilder;
362 };
363 
</pre>
</td>
<td>
<hr />
<pre>
 81 // DFG::JITCompiler is responsible for generating JIT code from the dataflow graph.
 82 // It does so by delegating to the speculative &amp; non-speculative JITs, which
 83 // generate to a MacroAssembler (which the JITCompiler owns through an inheritance
 84 // relationship). The JITCompiler holds references to information required during
 85 // compilation, and also records information used in linking (e.g. a list of all
 86 // call to be linked).
 87 class JITCompiler : public CCallHelpers {
 88 public:
 89     JITCompiler(Graph&amp; dfg);
 90     ~JITCompiler();
 91 
 92     void compile();
 93     void compileFunction();
 94 
 95     // Accessors for properties.
 96     Graph&amp; graph() { return m_graph; }
 97 
 98     // Methods to set labels for the disassembler.
 99     void setStartOfCode()
100     {
<span class="line-modified">101         m_pcToCodeOriginMapBuilder.appendItem(labelIgnoringWatchpoints(), CodeOrigin(BytecodeIndex(0)));</span>
102         if (LIKELY(!m_disassembler))
103             return;
104         m_disassembler-&gt;setStartOfCode(labelIgnoringWatchpoints());
105     }
106 
107     void setForBlockIndex(BlockIndex blockIndex)
108     {
109         if (LIKELY(!m_disassembler))
110             return;
111         m_disassembler-&gt;setForBlockIndex(blockIndex, labelIgnoringWatchpoints());
112     }
113 
114     void setForNode(Node* node)
115     {
116         if (LIKELY(!m_disassembler))
117             return;
118         m_disassembler-&gt;setForNode(node, labelIgnoringWatchpoints());
119     }
120 
121     void setEndOfMainPath();
122     void setEndOfCode();
123 
124     CallSiteIndex addCallSite(CodeOrigin codeOrigin)
125     {
126         return m_jitCode-&gt;common.addCodeOrigin(codeOrigin);
127     }
128 
129     CallSiteIndex emitStoreCodeOrigin(CodeOrigin codeOrigin)
130     {
131         CallSiteIndex callSite = addCallSite(codeOrigin);
132         emitStoreCallSiteIndex(callSite);
133         return callSite;
134     }
135 
136     void emitStoreCallSiteIndex(CallSiteIndex callSite)
137     {
<span class="line-modified">138         store32(TrustedImm32(callSite.bits()), tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
139     }
140 
141     // Add a call out from JIT code, without an exception check.
142     Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
143     {
144         Call functionCall = call(OperationPtrTag);
145         m_calls.append(CallLinkRecord(functionCall, function.retagged&lt;OperationPtrTag&gt;()));
146         return functionCall;
147     }
148 
149     void exceptionCheck();
150 
151     void exceptionCheckWithCallFrameRollback()
152     {
153         m_exceptionChecksWithCallFrameRollback.append(emitExceptionCheck(vm()));
154     }
155 
156     // Add a call out from JIT code, with a fast exception check that tests if the return value is zero.
157     void fastExceptionCheck()
158     {
</pre>
<hr />
<pre>
165         OSRExitCompilationInfo info;
166         info.m_failureJumps = jumpsToFail;
167         m_exitCompilationInfo.append(info);
168         return m_exitCompilationInfo.last();
169     }
170 
171 #if USE(JSVALUE32_64)
172     void* addressOfDoubleConstant(Node*);
173 #endif
174 
175     void addGetById(const JITGetByIdGenerator&amp; gen, SlowPathGenerator* slowPath)
176     {
177         m_getByIds.append(InlineCacheWrapper&lt;JITGetByIdGenerator&gt;(gen, slowPath));
178     }
179 
180     void addGetByIdWithThis(const JITGetByIdWithThisGenerator&amp; gen, SlowPathGenerator* slowPath)
181     {
182         m_getByIdsWithThis.append(InlineCacheWrapper&lt;JITGetByIdWithThisGenerator&gt;(gen, slowPath));
183     }
184 
<span class="line-added">185     void addGetByVal(const JITGetByValGenerator&amp; gen, SlowPathGenerator* slowPath)</span>
<span class="line-added">186     {</span>
<span class="line-added">187         m_getByVals.append(InlineCacheWrapper&lt;JITGetByValGenerator&gt;(gen, slowPath));</span>
<span class="line-added">188     }</span>
<span class="line-added">189 </span>
190     void addPutById(const JITPutByIdGenerator&amp; gen, SlowPathGenerator* slowPath)
191     {
192         m_putByIds.append(InlineCacheWrapper&lt;JITPutByIdGenerator&gt;(gen, slowPath));
193     }
194 
195     void addInstanceOf(const JITInstanceOfGenerator&amp; gen, SlowPathGenerator* slowPath)
196     {
197         m_instanceOfs.append(InlineCacheWrapper&lt;JITInstanceOfGenerator&gt;(gen, slowPath));
198     }
199 
200     void addInById(const JITInByIdGenerator&amp; gen, SlowPathGenerator* slowPath)
201     {
202         m_inByIds.append(InlineCacheWrapper&lt;JITInByIdGenerator&gt;(gen, slowPath));
203     }
204 
205     void addJSCall(Call fastCall, Call slowCall, DataLabelPtr targetToCheck, CallLinkInfo* info)
206     {
207         m_jsCalls.append(JSCallRecord(fastCall, slowCall, targetToCheck, info));
208     }
209 
</pre>
<hr />
<pre>
329 
330     struct JSDirectTailCallRecord {
331         JSDirectTailCallRecord(PatchableJump patchableJump, Call call, Label slowPath, CallLinkInfo* info)
332             : patchableJump(patchableJump)
333             , call(call)
334             , slowPath(slowPath)
335             , info(info)
336         {
337             ASSERT(call.isFlagSet(Call::Near) &amp;&amp; call.isFlagSet(Call::Tail));
338         }
339 
340         PatchableJump patchableJump;
341         Call call;
342         Label slowPath;
343         CallLinkInfo* info;
344     };
345 
346 
347     Vector&lt;InlineCacheWrapper&lt;JITGetByIdGenerator&gt;, 4&gt; m_getByIds;
348     Vector&lt;InlineCacheWrapper&lt;JITGetByIdWithThisGenerator&gt;, 4&gt; m_getByIdsWithThis;
<span class="line-added">349     Vector&lt;InlineCacheWrapper&lt;JITGetByValGenerator&gt;, 4&gt; m_getByVals;</span>
350     Vector&lt;InlineCacheWrapper&lt;JITPutByIdGenerator&gt;, 4&gt; m_putByIds;
351     Vector&lt;InlineCacheWrapper&lt;JITInByIdGenerator&gt;, 4&gt; m_inByIds;
352     Vector&lt;InlineCacheWrapper&lt;JITInstanceOfGenerator&gt;, 4&gt; m_instanceOfs;
353     Vector&lt;JSCallRecord, 4&gt; m_jsCalls;
354     Vector&lt;JSDirectCallRecord, 4&gt; m_jsDirectCalls;
355     Vector&lt;JSDirectTailCallRecord, 4&gt; m_jsDirectTailCalls;
356     SegmentedVector&lt;OSRExitCompilationInfo, 4&gt; m_exitCompilationInfo;
357     Vector&lt;Vector&lt;Label&gt;&gt; m_exitSiteLabels;
358 
359     struct ExceptionHandlingOSRExitInfo {
360         OSRExitCompilationInfo&amp; exitInfo;
361         HandlerInfo baselineExceptionHandler;
362         CallSiteIndex callSiteIndex;
363     };
364     Vector&lt;ExceptionHandlingOSRExitInfo&gt; m_exceptionHandlerOSRExitCallSites;
365 
366     std::unique_ptr&lt;SpeculativeJIT&gt; m_speculative;
367     PCToCodeOriginMapBuilder m_pcToCodeOriginMapBuilder;
368 };
369 
</pre>
</td>
</tr>
</table>
<center><a href="DFGJITCompiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITFinalizer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
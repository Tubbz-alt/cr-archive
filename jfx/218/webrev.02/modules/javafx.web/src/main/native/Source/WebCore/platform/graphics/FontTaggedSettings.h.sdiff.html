<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontTaggedSettings.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontSelectionAlgorithm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FormatConverter.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontTaggedSettings.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 }
 36 
 37 namespace WebCore {
 38 
 39 typedef std::array&lt;char, 4&gt; FontTag;
 40 
 41 inline FontTag fontFeatureTag(const char arr[4]) { return {{ arr[0], arr[1], arr[2], arr[3] }}; }
 42 
 43 struct FourCharacterTagHash {
 44     static unsigned hash(const FontTag&amp; characters) { return (characters[0] &lt;&lt; 24) | (characters[1] &lt;&lt; 16) | (characters[2] &lt;&lt; 8) | characters[3]; }
 45     static bool equal(const FontTag&amp; a, const FontTag&amp; b) { return a == b; }
 46     static const bool safeToCompareToEmptyOrDeleted = true;
 47 };
 48 
 49 struct FourCharacterTagHashTraits : WTF::GenericHashTraits&lt;FontTag&gt; {
 50     static const bool emptyValueIsZero = true;
 51     static void constructDeletedValue(FontTag&amp; slot) { new (NotNull, std::addressof(slot)) FontTag({{ ff, ff, ff, ff }}); }
 52     static bool isDeletedValue(const FontTag&amp; value) { return value == FontTag({{ ff, ff, ff, ff }}); }
 53 
 54 private:
<span class="line-modified"> 55     const static char ff = static_cast&lt;char&gt;(0xFF);</span>
 56 };
 57 
 58 template &lt;typename T&gt;
 59 class FontTaggedSetting {
 60 public:
 61     FontTaggedSetting() = delete;
 62     FontTaggedSetting(const FontTag&amp;, T value);
 63     FontTaggedSetting(FontTag&amp;&amp;, T value);
 64 
 65     bool operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 66     bool operator!=(const FontTaggedSetting&lt;T&gt;&amp; other) const { return !(*this == other); }
 67     bool operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 68 
 69     const FontTag&amp; tag() const { return m_tag; }
 70     T value() const { return m_value; }
 71     bool enabled() const { return value(); }
 72 



 73 private:
 74     FontTag m_tag;
 75     T m_value;
 76 };
 77 
 78 template &lt;typename T&gt;
 79 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(const FontTag&amp; tag, T value)
 80     : m_tag(tag)
 81     , m_value(value)
 82 {
 83 }
 84 
 85 template &lt;typename T&gt;
 86 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(FontTag&amp;&amp; tag, T value)
 87     : m_tag(WTFMove(tag))
 88     , m_value(value)
 89 {
 90 }
 91 
 92 template &lt;typename T&gt;
 93 bool FontTaggedSetting&lt;T&gt;::operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const
 94 {
 95     return m_tag == other.m_tag &amp;&amp; m_value == other.m_value;
 96 }
 97 
 98 template &lt;typename T&gt;
 99 bool FontTaggedSetting&lt;T&gt;::operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const
100 {
101     return (m_tag &lt; other.m_tag) || (m_tag == other.m_tag &amp;&amp; m_value &lt; other.m_value);
102 }
103 
















































104 template &lt;typename T&gt;
105 class FontTaggedSettings {
106 public:
107     void insert(FontTaggedSetting&lt;T&gt;&amp;&amp;);
108     bool operator==(const FontTaggedSettings&lt;T&gt;&amp; other) const { return m_list == other.m_list; }
109     bool operator!=(const FontTaggedSettings&lt;T&gt;&amp; other) const { return !(*this == other); }
110 
111     bool isEmpty() const { return !size(); }
112     size_t size() const { return m_list.size(); }
113     const FontTaggedSetting&lt;T&gt;&amp; operator[](int index) const { return m_list[index]; }
114     const FontTaggedSetting&lt;T&gt;&amp; at(size_t index) const { return m_list.at(index); }
115 
116     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator begin() const { return m_list.begin(); }
117     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator end() const { return m_list.end(); }
118 
119     unsigned hash() const;
120 



121 private:
122     Vector&lt;FontTaggedSetting&lt;T&gt;&gt; m_list;
123 };
124 
125 template &lt;typename T&gt;
126 void FontTaggedSettings&lt;T&gt;::insert(FontTaggedSetting&lt;T&gt;&amp;&amp; feature)
127 {
128     // This vector will almost always have 0 or 1 items in it. Don&#39;t bother with the overhead of a binary search or a hash set.
129     size_t i;
130     for (i = 0; i &lt; m_list.size(); ++i) {
131         if (!(feature &lt; m_list[i]))
132             break;
133     }
134     if (i &lt; m_list.size() &amp;&amp; feature.tag() == m_list[i].tag())
135         m_list.remove(i);
136     m_list.insert(i, WTFMove(feature));
137 }
138 





















139 typedef FontTaggedSetting&lt;int&gt; FontFeature;
140 typedef FontTaggedSettings&lt;int&gt; FontFeatureSettings;
141 
142 template &lt;&gt; unsigned FontFeatureSettings::hash() const;
143 
144 #if ENABLE(VARIATION_FONTS)
145 
146 typedef FontTaggedSettings&lt;float&gt; FontVariationSettings;
147 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const FontVariationSettings&amp;);
148 
149 template &lt;&gt; unsigned FontVariationSettings::hash() const;
150 
151 #else
152 
153 struct FontVariationSettings {
154     bool isEmpty() const { return true; }
155 };
156 
157 #endif
158 
</pre>
</td>
<td>
<hr />
<pre>
 35 }
 36 
 37 namespace WebCore {
 38 
 39 typedef std::array&lt;char, 4&gt; FontTag;
 40 
 41 inline FontTag fontFeatureTag(const char arr[4]) { return {{ arr[0], arr[1], arr[2], arr[3] }}; }
 42 
 43 struct FourCharacterTagHash {
 44     static unsigned hash(const FontTag&amp; characters) { return (characters[0] &lt;&lt; 24) | (characters[1] &lt;&lt; 16) | (characters[2] &lt;&lt; 8) | characters[3]; }
 45     static bool equal(const FontTag&amp; a, const FontTag&amp; b) { return a == b; }
 46     static const bool safeToCompareToEmptyOrDeleted = true;
 47 };
 48 
 49 struct FourCharacterTagHashTraits : WTF::GenericHashTraits&lt;FontTag&gt; {
 50     static const bool emptyValueIsZero = true;
 51     static void constructDeletedValue(FontTag&amp; slot) { new (NotNull, std::addressof(slot)) FontTag({{ ff, ff, ff, ff }}); }
 52     static bool isDeletedValue(const FontTag&amp; value) { return value == FontTag({{ ff, ff, ff, ff }}); }
 53 
 54 private:
<span class="line-modified"> 55     static constexpr char ff = static_cast&lt;char&gt;(0xFF);</span>
 56 };
 57 
 58 template &lt;typename T&gt;
 59 class FontTaggedSetting {
 60 public:
 61     FontTaggedSetting() = delete;
 62     FontTaggedSetting(const FontTag&amp;, T value);
 63     FontTaggedSetting(FontTag&amp;&amp;, T value);
 64 
 65     bool operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 66     bool operator!=(const FontTaggedSetting&lt;T&gt;&amp; other) const { return !(*this == other); }
 67     bool operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 68 
 69     const FontTag&amp; tag() const { return m_tag; }
 70     T value() const { return m_value; }
 71     bool enabled() const { return value(); }
 72 
<span class="line-added"> 73     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 74     template&lt;class Decoder&gt; static Optional&lt;FontTaggedSetting&lt;T&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 75 </span>
 76 private:
 77     FontTag m_tag;
 78     T m_value;
 79 };
 80 
 81 template &lt;typename T&gt;
 82 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(const FontTag&amp; tag, T value)
 83     : m_tag(tag)
 84     , m_value(value)
 85 {
 86 }
 87 
 88 template &lt;typename T&gt;
 89 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(FontTag&amp;&amp; tag, T value)
 90     : m_tag(WTFMove(tag))
 91     , m_value(value)
 92 {
 93 }
 94 
 95 template &lt;typename T&gt;
 96 bool FontTaggedSetting&lt;T&gt;::operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const
 97 {
 98     return m_tag == other.m_tag &amp;&amp; m_value == other.m_value;
 99 }
100 
101 template &lt;typename T&gt;
102 bool FontTaggedSetting&lt;T&gt;::operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const
103 {
104     return (m_tag &lt; other.m_tag) || (m_tag == other.m_tag &amp;&amp; m_value &lt; other.m_value);
105 }
106 
<span class="line-added">107 template &lt;typename T&gt;</span>
<span class="line-added">108 template &lt;class Encoder&gt;</span>
<span class="line-added">109 void FontTaggedSetting&lt;T&gt;::encode(Encoder&amp; encoder) const</span>
<span class="line-added">110 {</span>
<span class="line-added">111     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[0]);</span>
<span class="line-added">112     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[1]);</span>
<span class="line-added">113     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[2]);</span>
<span class="line-added">114     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[3]);</span>
<span class="line-added">115     encoder &lt;&lt; m_value;</span>
<span class="line-added">116 }</span>
<span class="line-added">117 </span>
<span class="line-added">118 template &lt;typename T&gt;</span>
<span class="line-added">119 template &lt;class Decoder&gt;</span>
<span class="line-added">120 Optional&lt;FontTaggedSetting&lt;T&gt;&gt; FontTaggedSetting&lt;T&gt;::decode(Decoder&amp; decoder)</span>
<span class="line-added">121 {</span>
<span class="line-added">122     Optional&lt;uint8_t&gt; char0;</span>
<span class="line-added">123     decoder &gt;&gt; char0;</span>
<span class="line-added">124     if (!char0)</span>
<span class="line-added">125         return WTF::nullopt;</span>
<span class="line-added">126 </span>
<span class="line-added">127     Optional&lt;uint8_t&gt; char1;</span>
<span class="line-added">128     decoder &gt;&gt; char1;</span>
<span class="line-added">129     if (!char1)</span>
<span class="line-added">130         return WTF::nullopt;</span>
<span class="line-added">131 </span>
<span class="line-added">132     Optional&lt;uint8_t&gt; char2;</span>
<span class="line-added">133     decoder &gt;&gt; char2;</span>
<span class="line-added">134     if (!char2)</span>
<span class="line-added">135         return WTF::nullopt;</span>
<span class="line-added">136 </span>
<span class="line-added">137     Optional&lt;uint8_t&gt; char3;</span>
<span class="line-added">138     decoder &gt;&gt; char3;</span>
<span class="line-added">139     if (!char3)</span>
<span class="line-added">140         return WTF::nullopt;</span>
<span class="line-added">141 </span>
<span class="line-added">142     Optional&lt;T&gt; value;</span>
<span class="line-added">143     decoder &gt;&gt; value;</span>
<span class="line-added">144     if (!value)</span>
<span class="line-added">145         return WTF::nullopt;</span>
<span class="line-added">146 </span>
<span class="line-added">147     return FontTaggedSetting&lt;T&gt;({{</span>
<span class="line-added">148         static_cast&lt;char&gt;(*char0),</span>
<span class="line-added">149         static_cast&lt;char&gt;(*char1),</span>
<span class="line-added">150         static_cast&lt;char&gt;(*char2),</span>
<span class="line-added">151         static_cast&lt;char&gt;(*char3)</span>
<span class="line-added">152     }}, *value);</span>
<span class="line-added">153 }</span>
<span class="line-added">154 </span>
155 template &lt;typename T&gt;
156 class FontTaggedSettings {
157 public:
158     void insert(FontTaggedSetting&lt;T&gt;&amp;&amp;);
159     bool operator==(const FontTaggedSettings&lt;T&gt;&amp; other) const { return m_list == other.m_list; }
160     bool operator!=(const FontTaggedSettings&lt;T&gt;&amp; other) const { return !(*this == other); }
161 
162     bool isEmpty() const { return !size(); }
163     size_t size() const { return m_list.size(); }
164     const FontTaggedSetting&lt;T&gt;&amp; operator[](int index) const { return m_list[index]; }
165     const FontTaggedSetting&lt;T&gt;&amp; at(size_t index) const { return m_list.at(index); }
166 
167     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator begin() const { return m_list.begin(); }
168     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator end() const { return m_list.end(); }
169 
170     unsigned hash() const;
171 
<span class="line-added">172     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">173     template&lt;class Decoder&gt; static Optional&lt;FontTaggedSettings&lt;T&gt;&gt; decode(Decoder&amp;);</span>
<span class="line-added">174 </span>
175 private:
176     Vector&lt;FontTaggedSetting&lt;T&gt;&gt; m_list;
177 };
178 
179 template &lt;typename T&gt;
180 void FontTaggedSettings&lt;T&gt;::insert(FontTaggedSetting&lt;T&gt;&amp;&amp; feature)
181 {
182     // This vector will almost always have 0 or 1 items in it. Don&#39;t bother with the overhead of a binary search or a hash set.
183     size_t i;
184     for (i = 0; i &lt; m_list.size(); ++i) {
185         if (!(feature &lt; m_list[i]))
186             break;
187     }
188     if (i &lt; m_list.size() &amp;&amp; feature.tag() == m_list[i].tag())
189         m_list.remove(i);
190     m_list.insert(i, WTFMove(feature));
191 }
192 
<span class="line-added">193 template &lt;typename T&gt;</span>
<span class="line-added">194 template &lt;class Encoder&gt;</span>
<span class="line-added">195 void FontTaggedSettings&lt;T&gt;::encode(Encoder&amp; encoder) const</span>
<span class="line-added">196 {</span>
<span class="line-added">197     encoder &lt;&lt; m_list;</span>
<span class="line-added">198 }</span>
<span class="line-added">199 </span>
<span class="line-added">200 template &lt;typename T&gt;</span>
<span class="line-added">201 template &lt;class Decoder&gt;</span>
<span class="line-added">202 Optional&lt;FontTaggedSettings&lt;T&gt;&gt; FontTaggedSettings&lt;T&gt;::decode(Decoder&amp; decoder)</span>
<span class="line-added">203 {</span>
<span class="line-added">204     Optional&lt;Vector&lt;FontTaggedSetting&lt;T&gt;&gt;&gt; list;</span>
<span class="line-added">205     decoder &gt;&gt; list;</span>
<span class="line-added">206     if (!list)</span>
<span class="line-added">207         return WTF::nullopt;</span>
<span class="line-added">208 </span>
<span class="line-added">209     FontTaggedSettings result;</span>
<span class="line-added">210     result.m_list = WTFMove(*list);</span>
<span class="line-added">211     return result;</span>
<span class="line-added">212 }</span>
<span class="line-added">213 </span>
214 typedef FontTaggedSetting&lt;int&gt; FontFeature;
215 typedef FontTaggedSettings&lt;int&gt; FontFeatureSettings;
216 
217 template &lt;&gt; unsigned FontFeatureSettings::hash() const;
218 
219 #if ENABLE(VARIATION_FONTS)
220 
221 typedef FontTaggedSettings&lt;float&gt; FontVariationSettings;
222 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const FontVariationSettings&amp;);
223 
224 template &lt;&gt; unsigned FontVariationSettings::hash() const;
225 
226 #else
227 
228 struct FontVariationSettings {
229     bool isEmpty() const { return true; }
230 };
231 
232 #endif
233 
</pre>
</td>
</tr>
</table>
<center><a href="FontSelectionAlgorithm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FormatConverter.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
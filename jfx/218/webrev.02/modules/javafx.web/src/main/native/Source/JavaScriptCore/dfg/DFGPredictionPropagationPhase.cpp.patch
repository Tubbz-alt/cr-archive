diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp
@@ -177,10 +177,11 @@
             else
                 changed |= mergePrediction(SpecBytecodeNumber);
             break;
         }
 
+        case ValueBitRShift:
         case ValueBitLShift: {
             SpeculatedType left = node->child1()->prediction();
             SpeculatedType right = node->child2()->prediction();
 
             if (left && right) {
@@ -291,10 +292,35 @@
             }
 
             break;
         }
 
+        case Inc:
+        case Dec: {
+            SpeculatedType prediction = node->child1()->prediction();
+
+            if (prediction) {
+                if (isFullNumberOrBooleanSpeculationExpectingDefined(prediction)) {
+                    if (m_graph.unaryArithShouldSpeculateInt32(node, m_pass))
+                        changed |= mergePrediction(SpecInt32Only);
+                    else if (m_graph.unaryArithShouldSpeculateInt52(node, m_pass))
+                        changed |= mergePrediction(SpecInt52Any);
+                    else
+                        changed |= mergePrediction(speculatedDoubleTypeForPrediction(prediction));
+                } else if (isBigIntSpeculation(prediction))
+                    changed |= mergePrediction(SpecBigInt);
+                else {
+                    changed |= mergePrediction(SpecInt32Only);
+                    if (node->mayHaveDoubleResult())
+                        changed |= mergePrediction(SpecBytecodeDouble);
+                    if (node->mayHaveBigIntResult())
+                        changed |= mergePrediction(SpecBigInt);
+                }
+            }
+            break;
+        }
+
         case ValuePow: {
             SpeculatedType left = node->child1()->prediction();
             SpeculatedType right = node->child2()->prediction();
 
             if (left && right) {
@@ -547,10 +573,17 @@
             if (child)
                 changed |= mergePrediction(resultOfToPrimitive(child));
             break;
         }
 
+        case ToPropertyKey: {
+            SpeculatedType child = node->child1()->prediction();
+            if (child)
+                changed |= mergePrediction(resultOfToPropertyKey(child));
+            break;
+        }
+
         case NormalizeMapKey: {
             SpeculatedType prediction = node->child1()->prediction();
             if (prediction)
                 changed |= mergePrediction(prediction);
             break;
@@ -781,11 +814,11 @@
 
         case ArithBitNot:
         case ArithBitAnd:
         case ArithBitOr:
         case ArithBitXor:
-        case BitRShift:
+        case ArithBitRShift:
         case ArithBitLShift:
         case BitURShift:
         case ArithIMul:
         case ArithClz32: {
             setPrediction(SpecInt32Only);
@@ -825,14 +858,16 @@
         case ConstructForwardVarargs:
         case TailCallForwardVarargsInlinedCaller:
         case GetGlobalVar:
         case GetGlobalLexicalVariable:
         case GetClosureVar:
+        case GetInternalField:
         case GetFromArguments:
         case LoadKeyFromMapBucket:
         case LoadValueFromMapBucket:
         case ToNumber:
+        case ToNumeric:
         case ToObject:
         case ValueBitAnd:
         case ValueBitXor:
         case ValueBitOr:
         case ValueBitNot:
@@ -841,15 +876,21 @@
         case CallDOMGetter:
         case GetDynamicVar:
         case GetPrototypeOf:
         case ExtractValueFromWeakMapGet:
         case DataViewGetInt:
-        case DataViewGetFloat: {
+        case DataViewGetFloat:
+        case DateGetInt32OrNaN: {
             setPrediction(m_currentNode->getHeapPrediction());
             break;
         }
 
+        case DateGetTime: {
+            setPrediction(SpecFullNumber);
+            break;
+        }
+
         case WeakMapGet:
         case ResolveScopeForHoistingFuncDeclInEval: {
             setPrediction(SpecBytecodeTop);
             break;
         }
@@ -903,11 +944,12 @@
         case GetVectorLength: {
             setPrediction(SpecInt32Only);
             break;
         }
 
-        case StringCharCodeAt: {
+        case StringCharCodeAt:
+        case StringCodePointAt: {
             setPrediction(SpecInt32Only);
             break;
         }
 
         case StringValueOf:
@@ -1007,10 +1049,23 @@
         case NewObject: {
             setPrediction(SpecFinalObject);
             break;
         }
 
+        case CreatePromise:
+        case NewPromise:
+            setPrediction(SpecPromiseObject);
+            break;
+
+        case CreateGenerator:
+        case NewGenerator:
+        case CreateAsyncGenerator:
+        case NewAsyncGenerator:
+        case NewArrayIterator:
+            setPrediction(SpecObjectOther);
+            break;
+
         case ArraySlice:
         case NewArrayWithSpread:
         case NewArray:
         case NewArrayWithSize:
         case CreateRest:
@@ -1077,10 +1132,15 @@
         case CreateClonedArguments: {
             setPrediction(SpecObjectOther);
             break;
         }
 
+        case CreateArgumentsButterfly: {
+            setPrediction(SpecCellOther);
+            break;
+        }
+
         case FiatInt52: {
             RELEASE_ASSERT(enableInt52());
             setPrediction(SpecInt52Any);
             break;
         }
@@ -1152,10 +1212,13 @@
         case ValueMul:
         case ValueDiv:
         case ValueMod:
         case ValuePow:
         case ValueBitLShift:
+        case ValueBitRShift:
+        case Inc:
+        case Dec:
         case ArithAdd:
         case ArithSub:
         case ArithNegate:
         case ArithMin:
         case ArithMax:
@@ -1164,10 +1227,11 @@
         case ArithMod:
         case ArithAbs:
         case GetByVal:
         case ToThis:
         case ToPrimitive:
+        case ToPropertyKey:
         case NormalizeMapKey:
         case AtomicsAdd:
         case AtomicsAnd:
         case AtomicsCompareExchange:
         case AtomicsExchange:
@@ -1193,11 +1257,10 @@
             break;
         }
 
         case PutByValAlias:
         case DoubleAsInt32:
-        case CheckArray:
         case CheckTypeInfoFlags:
         case Arrayify:
         case ArrayifyToStructure:
         case CheckTierUpInLoop:
         case CheckTierUpAtReturn:
@@ -1219,19 +1282,22 @@
         case PhantomDirectArguments:
         case PhantomCreateRest:
         case PhantomSpread:
         case PhantomNewArrayWithSpread:
         case PhantomNewArrayBuffer:
+        case PhantomNewArrayIterator:
         case PhantomClonedArguments:
         case PhantomNewRegexp:
         case GetMyArgumentByVal:
         case GetMyArgumentByValOutOfBounds:
         case PutHint:
         case CheckStructureImmediate:
         case CheckStructureOrEmpty:
+        case CheckArrayOrEmpty:
         case MaterializeNewObject:
         case MaterializeCreateActivation:
+        case MaterializeNewInternalFieldObject:
         case PutStack:
         case KillStack:
         case StoreBarrier:
         case FencedStoreBarrier:
         case GetStack:
@@ -1262,10 +1328,11 @@
         case PutByValDirect:
         case PutByValWithThis:
         case PutByIdWithThis:
         case PutByVal:
         case PutClosureVar:
+        case PutInternalField:
         case PutToArguments:
         case Return:
         case Throw:
         case ThrowStaticError:
         case TailCall:
@@ -1295,15 +1362,17 @@
         case SetFunctionName:
         case CheckStructure:
         case CheckCell:
         case CheckNotEmpty:
         case AssertNotEmpty:
-        case CheckStringIdent:
+        case CheckIdent:
         case CheckBadCell:
         case PutStructure:
         case Phantom:
         case Check:
+        case CheckArray:
+        case CheckNeutered:
         case CheckVarargs:
         case PutGlobalVariable:
         case CheckTraps:
         case LogShadowChickenPrologue:
         case LogShadowChickenTail:
@@ -1312,19 +1381,20 @@
         case NotifyWrite:
         case ConstantStoragePointer:
         case MovHint:
         case ZombieHint:
         case ExitOK:
+        case VarargsLength:
         case LoadVarargs:
         case ForwardVarargs:
         case PutDynamicVar:
         case NukeStructureAndSetButterfly:
         case InitializeEntrypointArguments:
         case WeakSetAdd:
         case WeakMapSet:
         case FilterCallLinkStatus:
-        case FilterGetByIdStatus:
+        case FilterGetByStatus:
         case FilterPutByIdStatus:
         case FilterInByIdStatus:
         case ClearCatchLocals:
         case DataViewSet:
         case InvalidationPoint:
@@ -1368,10 +1438,22 @@
         }
 
         return type;
     }
 
+    SpeculatedType resultOfToPropertyKey(SpeculatedType type)
+    {
+        // Propagate the prediction of the source directly if already proven to be a property key.
+        if (type && !(type & ~(SpecString | SpecSymbol)))
+            return type;
+
+        if (type & SpecStringObject && m_graph.canOptimizeStringObjectAccess(m_currentNode->origin.semantic))
+            return mergeSpeculations(type & SpecSymbol, SpecString);
+
+        return SpecString | SpecSymbol;
+    }
+
     Vector<Node*> m_dependentNodes;
     Node* m_currentNode;
     bool m_changed { false };
     PredictionPass m_pass { PrimaryPass }; // We use different logic for considering predictions depending on how far along we are in propagation.
 };

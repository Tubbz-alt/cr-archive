<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NodeConstructors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Nodes.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17 *  Library General Public License for more details.
 18 *
 19 *  You should have received a copy of the GNU Library General Public License
 20 *  along with this library; see the file COPYING.LIB.  If not, write to
 21 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22 *  Boston, MA 02110-1301, USA.
 23 *
 24 */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Nodes.h&quot;
 28 #include &quot;NodeConstructors.h&quot;
 29 
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;ModuleScopeData.h&quot;
 32 #include &lt;wtf/Assertions.h&gt;
 33 
 34 namespace JSC {
 35 


 36 // ------------------------------ StatementNode --------------------------------
 37 
 38 void StatementNode::setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
 39 {
 40     m_lastLine = lastLine;
 41     m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
 42     ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
 43 }
 44 
 45 // ------------------------------ SourceElements --------------------------------
 46 
 47 void SourceElements::append(StatementNode* statement)
 48 {
 49     if (statement-&gt;isEmptyStatement())
 50         return;
 51 
 52     if (!m_head) {
 53         m_head = statement;
 54         m_tail = statement;
 55         return;
</pre>
<hr />
<pre>
181 
182 // ------------------------------ EvalNode -----------------------------
183 
184 EvalNode::EvalNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, unsigned, unsigned endColumn, SourceElements* children, VariableEnvironment&amp; varEnvironment, FunctionStack&amp;&amp; funcStack, VariableEnvironment&amp; lexicalVariables, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, FunctionParameters*, const SourceCode&amp; source, CodeFeatures features, InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;)
185     : ScopeNode(parserArena, startLocation, endLocation, source, children, varEnvironment, WTFMove(funcStack), lexicalVariables, WTFMove(sloppyModeHoistedFunctions), features, innerArrowFunctionCodeFeatures, numConstants)
186     , m_endColumn(endColumn)
187 {
188 }
189 
190 // ------------------------------ FunctionMetadataNode -----------------------------
191 
192 FunctionMetadataNode::FunctionMetadataNode(
193     ParserArena&amp;, const JSTokenLocation&amp; startLocation,
194     const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn,
195     int functionKeywordStart, int functionNameStart, int parametersStart, bool isInStrictContext,
196     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
197         : Node(endLocation)
198         , m_isInStrictContext(isInStrictContext)
199         , m_superBinding(static_cast&lt;unsigned&gt;(superBinding))
200         , m_constructorKind(static_cast&lt;unsigned&gt;(constructorKind))

201         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
202         , m_parseMode(mode)
203         , m_startColumn(startColumn)
204         , m_endColumn(endColumn)
205         , m_functionKeywordStart(functionKeywordStart)
206         , m_functionNameStart(functionNameStart)
207         , m_parametersStart(parametersStart)
208         , m_startStartOffset(startLocation.startOffset)
209         , m_parameterCount(parameterCount)
210 {
211     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(superBinding));
212     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(constructorKind));
213 }
214 
215 FunctionMetadataNode::FunctionMetadataNode(
216     const JSTokenLocation&amp; startLocation,
217     const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn,
218     int functionKeywordStart, int functionNameStart, int parametersStart, bool isInStrictContext,
219     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
220         : Node(endLocation)
221         , m_isInStrictContext(isInStrictContext)
222         , m_superBinding(static_cast&lt;unsigned&gt;(superBinding))
223         , m_constructorKind(static_cast&lt;unsigned&gt;(constructorKind))

224         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
225         , m_parseMode(mode)
226         , m_startColumn(startColumn)
227         , m_endColumn(endColumn)
228         , m_functionKeywordStart(functionKeywordStart)
229         , m_functionNameStart(functionNameStart)
230         , m_parametersStart(parametersStart)
231         , m_startStartOffset(startLocation.startOffset)
232         , m_parameterCount(parameterCount)
233 {
234     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(superBinding));
235     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(constructorKind));
236 }
237 
238 void FunctionMetadataNode::finishParsing(const SourceCode&amp; source, const Identifier&amp; ident, FunctionMode functionMode)
239 {
240     m_source = source;
241     m_ident = ident;
242     m_functionMode = functionMode;
243 }
244 
245 void FunctionMetadataNode::setEndPosition(JSTextPosition position)
246 {
247     m_lastLine = position.line;
248     m_endColumn = position.offset - position.lineStartOffset;
249 }
250 
251 bool FunctionMetadataNode::operator==(const FunctionMetadataNode&amp; other) const
252 {
<span class="line-modified">253     return m_parseMode== other.m_parseMode</span>
254         &amp;&amp; m_isInStrictContext == other.m_isInStrictContext
255         &amp;&amp; m_superBinding == other.m_superBinding
256         &amp;&amp; m_constructorKind == other.m_constructorKind
257         &amp;&amp; m_isArrowFunctionBodyExpression == other.m_isArrowFunctionBodyExpression
258         &amp;&amp; m_ident == other.m_ident
259         &amp;&amp; m_ecmaName == other.m_ecmaName
<span class="line-modified">260         &amp;&amp; m_functionMode== other.m_functionMode</span>
<span class="line-modified">261         &amp;&amp; m_startColumn== other.m_startColumn</span>
<span class="line-modified">262         &amp;&amp; m_endColumn== other.m_endColumn</span>
<span class="line-modified">263         &amp;&amp; m_functionKeywordStart== other.m_functionKeywordStart</span>
<span class="line-modified">264         &amp;&amp; m_functionNameStart== other.m_functionNameStart</span>
<span class="line-modified">265         &amp;&amp; m_parametersStart== other.m_parametersStart</span>
<span class="line-modified">266         &amp;&amp; m_source== other.m_source</span>
<span class="line-modified">267         &amp;&amp; m_classSource== other.m_classSource</span>
<span class="line-modified">268         &amp;&amp; m_startStartOffset== other.m_startStartOffset</span>
<span class="line-modified">269         &amp;&amp; m_parameterCount== other.m_parameterCount</span>
<span class="line-modified">270         &amp;&amp; m_lastLine== other.m_lastLine</span>
271         &amp;&amp; m_position == other.m_position;
272 }
273 
274 void FunctionMetadataNode::dump(PrintStream&amp; stream) const
275 {
276     stream.println(&quot;m_parseMode &quot;, static_cast&lt;uint32_t&gt;(m_parseMode));
277     stream.println(&quot;m_isInStrictContext &quot;, m_isInStrictContext);
278     stream.println(&quot;m_superBinding &quot;, m_superBinding);
279     stream.println(&quot;m_constructorKind &quot;, m_constructorKind);
280     stream.println(&quot;m_isArrowFunctionBodyExpression &quot;, m_isArrowFunctionBodyExpression);
281     stream.println(&quot;m_ident &quot;, m_ident);
282     stream.println(&quot;m_ecmaName &quot;, m_ecmaName);
283     stream.println(&quot;m_functionMode &quot;, static_cast&lt;uint32_t&gt;(m_functionMode));
284     stream.println(&quot;m_startColumn &quot;, m_startColumn);
285     stream.println(&quot;m_endColumn &quot;, m_endColumn);
286     stream.println(&quot;m_functionKeywordStart &quot;, m_functionKeywordStart);
287     stream.println(&quot;m_functionNameStart &quot;, m_functionNameStart);
288     stream.println(&quot;m_parametersStart &quot;, m_parametersStart);
289     stream.println(&quot;m_classSource.isNull() &quot;, m_classSource.isNull());
290     stream.println(&quot;m_startStartOffset &quot;, m_startStartOffset);
</pre>
<hr />
<pre>
309 {
310     ASSERT(!source().isNull());
311     m_ident = ident;
312     m_functionMode = functionMode;
313 }
314 
315 bool PropertyListNode::hasStaticallyNamedProperty(const Identifier&amp; propName)
316 {
317     PropertyListNode* list = this;
318     while (list) {
319         if (list-&gt;m_node-&gt;isStaticClassProperty()) {
320             const Identifier* currentNodeName = list-&gt;m_node-&gt;name();
321             if (currentNodeName &amp;&amp; *currentNodeName == propName)
322                 return true;
323         }
324         list = list-&gt;m_next;
325     }
326     return false;
327 }
328 

























329 VariableEnvironmentNode::VariableEnvironmentNode(VariableEnvironment&amp; lexicalVariables)
330 {
331     m_lexicalVariables.swap(lexicalVariables);
332 }
333 
334 VariableEnvironmentNode::VariableEnvironmentNode(VariableEnvironment&amp; lexicalVariables, FunctionStack&amp;&amp; functionStack)
335 {
336     m_lexicalVariables.swap(lexicalVariables);
337     m_functionStack = WTFMove(functionStack);
338 }
339 
340 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 16 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17 *  Library General Public License for more details.
 18 *
 19 *  You should have received a copy of the GNU Library General Public License
 20 *  along with this library; see the file COPYING.LIB.  If not, write to
 21 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22 *  Boston, MA 02110-1301, USA.
 23 *
 24 */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Nodes.h&quot;
 28 #include &quot;NodeConstructors.h&quot;
 29 
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;ModuleScopeData.h&quot;
 32 #include &lt;wtf/Assertions.h&gt;
 33 
 34 namespace JSC {
 35 
<span class="line-added"> 36 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
<span class="line-added"> 37 </span>
 38 // ------------------------------ StatementNode --------------------------------
 39 
 40 void StatementNode::setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
 41 {
 42     m_lastLine = lastLine;
 43     m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
 44     ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
 45 }
 46 
 47 // ------------------------------ SourceElements --------------------------------
 48 
 49 void SourceElements::append(StatementNode* statement)
 50 {
 51     if (statement-&gt;isEmptyStatement())
 52         return;
 53 
 54     if (!m_head) {
 55         m_head = statement;
 56         m_tail = statement;
 57         return;
</pre>
<hr />
<pre>
183 
184 // ------------------------------ EvalNode -----------------------------
185 
186 EvalNode::EvalNode(ParserArena&amp; parserArena, const JSTokenLocation&amp; startLocation, const JSTokenLocation&amp; endLocation, unsigned, unsigned endColumn, SourceElements* children, VariableEnvironment&amp; varEnvironment, FunctionStack&amp;&amp; funcStack, VariableEnvironment&amp; lexicalVariables, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, FunctionParameters*, const SourceCode&amp; source, CodeFeatures features, InnerArrowFunctionCodeFeatures innerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;)
187     : ScopeNode(parserArena, startLocation, endLocation, source, children, varEnvironment, WTFMove(funcStack), lexicalVariables, WTFMove(sloppyModeHoistedFunctions), features, innerArrowFunctionCodeFeatures, numConstants)
188     , m_endColumn(endColumn)
189 {
190 }
191 
192 // ------------------------------ FunctionMetadataNode -----------------------------
193 
194 FunctionMetadataNode::FunctionMetadataNode(
195     ParserArena&amp;, const JSTokenLocation&amp; startLocation,
196     const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn,
197     int functionKeywordStart, int functionNameStart, int parametersStart, bool isInStrictContext,
198     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
199         : Node(endLocation)
200         , m_isInStrictContext(isInStrictContext)
201         , m_superBinding(static_cast&lt;unsigned&gt;(superBinding))
202         , m_constructorKind(static_cast&lt;unsigned&gt;(constructorKind))
<span class="line-added">203         , m_needsClassFieldInitializer(static_cast&lt;unsigned&gt;(NeedsClassFieldInitializer::No))</span>
204         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
205         , m_parseMode(mode)
206         , m_startColumn(startColumn)
207         , m_endColumn(endColumn)
208         , m_functionKeywordStart(functionKeywordStart)
209         , m_functionNameStart(functionNameStart)
210         , m_parametersStart(parametersStart)
211         , m_startStartOffset(startLocation.startOffset)
212         , m_parameterCount(parameterCount)
213 {
214     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(superBinding));
215     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(constructorKind));
216 }
217 
218 FunctionMetadataNode::FunctionMetadataNode(
219     const JSTokenLocation&amp; startLocation,
220     const JSTokenLocation&amp; endLocation, unsigned startColumn, unsigned endColumn,
221     int functionKeywordStart, int functionNameStart, int parametersStart, bool isInStrictContext,
222     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
223         : Node(endLocation)
224         , m_isInStrictContext(isInStrictContext)
225         , m_superBinding(static_cast&lt;unsigned&gt;(superBinding))
226         , m_constructorKind(static_cast&lt;unsigned&gt;(constructorKind))
<span class="line-added">227         , m_needsClassFieldInitializer(static_cast&lt;unsigned&gt;(NeedsClassFieldInitializer::No))</span>
228         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
229         , m_parseMode(mode)
230         , m_startColumn(startColumn)
231         , m_endColumn(endColumn)
232         , m_functionKeywordStart(functionKeywordStart)
233         , m_functionNameStart(functionNameStart)
234         , m_parametersStart(parametersStart)
235         , m_startStartOffset(startLocation.startOffset)
236         , m_parameterCount(parameterCount)
237 {
238     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(superBinding));
239     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(constructorKind));
240 }
241 
242 void FunctionMetadataNode::finishParsing(const SourceCode&amp; source, const Identifier&amp; ident, FunctionMode functionMode)
243 {
244     m_source = source;
245     m_ident = ident;
246     m_functionMode = functionMode;
247 }
248 
249 void FunctionMetadataNode::setEndPosition(JSTextPosition position)
250 {
251     m_lastLine = position.line;
252     m_endColumn = position.offset - position.lineStartOffset;
253 }
254 
255 bool FunctionMetadataNode::operator==(const FunctionMetadataNode&amp; other) const
256 {
<span class="line-modified">257     return m_parseMode == other.m_parseMode</span>
258         &amp;&amp; m_isInStrictContext == other.m_isInStrictContext
259         &amp;&amp; m_superBinding == other.m_superBinding
260         &amp;&amp; m_constructorKind == other.m_constructorKind
261         &amp;&amp; m_isArrowFunctionBodyExpression == other.m_isArrowFunctionBodyExpression
262         &amp;&amp; m_ident == other.m_ident
263         &amp;&amp; m_ecmaName == other.m_ecmaName
<span class="line-modified">264         &amp;&amp; m_functionMode == other.m_functionMode</span>
<span class="line-modified">265         &amp;&amp; m_startColumn == other.m_startColumn</span>
<span class="line-modified">266         &amp;&amp; m_endColumn == other.m_endColumn</span>
<span class="line-modified">267         &amp;&amp; m_functionKeywordStart == other.m_functionKeywordStart</span>
<span class="line-modified">268         &amp;&amp; m_functionNameStart == other.m_functionNameStart</span>
<span class="line-modified">269         &amp;&amp; m_parametersStart == other.m_parametersStart</span>
<span class="line-modified">270         &amp;&amp; m_source == other.m_source</span>
<span class="line-modified">271         &amp;&amp; m_classSource == other.m_classSource</span>
<span class="line-modified">272         &amp;&amp; m_startStartOffset == other.m_startStartOffset</span>
<span class="line-modified">273         &amp;&amp; m_parameterCount == other.m_parameterCount</span>
<span class="line-modified">274         &amp;&amp; m_lastLine == other.m_lastLine</span>
275         &amp;&amp; m_position == other.m_position;
276 }
277 
278 void FunctionMetadataNode::dump(PrintStream&amp; stream) const
279 {
280     stream.println(&quot;m_parseMode &quot;, static_cast&lt;uint32_t&gt;(m_parseMode));
281     stream.println(&quot;m_isInStrictContext &quot;, m_isInStrictContext);
282     stream.println(&quot;m_superBinding &quot;, m_superBinding);
283     stream.println(&quot;m_constructorKind &quot;, m_constructorKind);
284     stream.println(&quot;m_isArrowFunctionBodyExpression &quot;, m_isArrowFunctionBodyExpression);
285     stream.println(&quot;m_ident &quot;, m_ident);
286     stream.println(&quot;m_ecmaName &quot;, m_ecmaName);
287     stream.println(&quot;m_functionMode &quot;, static_cast&lt;uint32_t&gt;(m_functionMode));
288     stream.println(&quot;m_startColumn &quot;, m_startColumn);
289     stream.println(&quot;m_endColumn &quot;, m_endColumn);
290     stream.println(&quot;m_functionKeywordStart &quot;, m_functionKeywordStart);
291     stream.println(&quot;m_functionNameStart &quot;, m_functionNameStart);
292     stream.println(&quot;m_parametersStart &quot;, m_parametersStart);
293     stream.println(&quot;m_classSource.isNull() &quot;, m_classSource.isNull());
294     stream.println(&quot;m_startStartOffset &quot;, m_startStartOffset);
</pre>
<hr />
<pre>
313 {
314     ASSERT(!source().isNull());
315     m_ident = ident;
316     m_functionMode = functionMode;
317 }
318 
319 bool PropertyListNode::hasStaticallyNamedProperty(const Identifier&amp; propName)
320 {
321     PropertyListNode* list = this;
322     while (list) {
323         if (list-&gt;m_node-&gt;isStaticClassProperty()) {
324             const Identifier* currentNodeName = list-&gt;m_node-&gt;name();
325             if (currentNodeName &amp;&amp; *currentNodeName == propName)
326                 return true;
327         }
328         list = list-&gt;m_next;
329     }
330     return false;
331 }
332 
<span class="line-added">333 // FIXME: calculate this feature once when parsing the property list.</span>
<span class="line-added">334 // https://bugs.webkit.org/show_bug.cgi?id=206174</span>
<span class="line-added">335 bool PropertyListNode::shouldCreateLexicalScopeForClass(PropertyListNode* list)</span>
<span class="line-added">336 {</span>
<span class="line-added">337     while (list) {</span>
<span class="line-added">338         if (list-&gt;m_node-&gt;isComputedClassField())</span>
<span class="line-added">339             return true;</span>
<span class="line-added">340         list = list-&gt;m_next;</span>
<span class="line-added">341     }</span>
<span class="line-added">342     return false;</span>
<span class="line-added">343 }</span>
<span class="line-added">344 </span>
<span class="line-added">345 // ------------------------------ ClassExprNode -----------------------------</span>
<span class="line-added">346 </span>
<span class="line-added">347 // FIXME: calculate this feature once when parsing the property list.</span>
<span class="line-added">348 // https://bugs.webkit.org/show_bug.cgi?id=206174</span>
<span class="line-added">349 bool PropertyListNode::hasInstanceFields() const</span>
<span class="line-added">350 {</span>
<span class="line-added">351     for (auto list = this; list; list = list-&gt;m_next) {</span>
<span class="line-added">352         if (list-&gt;m_node-&gt;isInstanceClassField())</span>
<span class="line-added">353             return true;</span>
<span class="line-added">354     }</span>
<span class="line-added">355     return false;</span>
<span class="line-added">356 }</span>
<span class="line-added">357 </span>
358 VariableEnvironmentNode::VariableEnvironmentNode(VariableEnvironment&amp; lexicalVariables)
359 {
360     m_lexicalVariables.swap(lexicalVariables);
361 }
362 
363 VariableEnvironmentNode::VariableEnvironmentNode(VariableEnvironment&amp; lexicalVariables, FunctionStack&amp;&amp; functionStack)
364 {
365     m_lexicalVariables.swap(lexicalVariables);
366     m_functionStack = WTFMove(functionStack);
367 }
368 
369 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="NodeConstructors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Nodes.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
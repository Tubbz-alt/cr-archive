<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/libwebrtc/GStreamerVideoDecoderFactory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../RealtimeVideoSource.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GStreamerVideoEncoderFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/libwebrtc/GStreamerVideoDecoderFactory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
177         return makeElement(&quot;identity&quot;);
178     }
179 
180     int32_t Release() final
181     {
182         if (m_pipeline.get()) {
183             GRefPtr&lt;GstBus&gt; bus = adoptGRef(gst_pipeline_get_bus(GST_PIPELINE(m_pipeline.get())));
184             gst_bus_set_sync_handler(bus.get(), nullptr, nullptr, nullptr);
185 
186             gst_element_set_state(m_pipeline.get(), GST_STATE_NULL);
187             m_src = nullptr;
188             m_sink = nullptr;
189             m_pipeline = nullptr;
190         }
191 
192         return WEBRTC_VIDEO_CODEC_OK;
193     }
194 
195     int32_t Decode(const webrtc::EncodedImage&amp; inputImage,
196         bool,
<span class="line-removed">197         const webrtc::CodecSpecificInfo*,</span>
198         int64_t renderTimeMs) override
199     {
200         if (m_needsKeyframe) {
<span class="line-modified">201             if (inputImage._frameType != webrtc::kVideoFrameKey) {</span>
202                 GST_ERROR(&quot;Waiting for keyframe but got a delta unit... asking for keyframe&quot;);
203                 return WEBRTC_VIDEO_CODEC_ERROR;
204             }
205             if (inputImage._completeFrame)
206                 m_needsKeyframe = false;
207             else {
208                 GST_ERROR(&quot;Waiting for keyframe but didn&#39;t get full frame, getting out&quot;);
209                 return WEBRTC_VIDEO_CODEC_ERROR;
210             }
211         }
212 
213 
214         if (!m_src) {
215             GST_ERROR(&quot;No source set, can&#39;t decode.&quot;);
216 
217             return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
218         }
219 
220         if (!GST_CLOCK_TIME_IS_VALID(m_firstBufferPts)) {
221             GRefPtr&lt;GstPad&gt; srcpad = adoptGRef(gst_element_get_static_pad(m_src, &quot;src&quot;));
222             m_firstBufferPts = (static_cast&lt;guint64&gt;(renderTimeMs)) * GST_MSECOND;
223             m_firstBufferDts = (static_cast&lt;guint64&gt;(inputImage.Timestamp())) * GST_MSECOND;
224         }
225 
226         // FIXME- Use a GstBufferPool.
<span class="line-modified">227         auto buffer = adoptGRef(gst_buffer_new_wrapped(g_memdup(inputImage._buffer, inputImage._size),</span>
<span class="line-modified">228             inputImage._size));</span>
229         GST_BUFFER_DTS(buffer.get()) = (static_cast&lt;guint64&gt;(inputImage.Timestamp()) * GST_MSECOND) - m_firstBufferDts;
230         GST_BUFFER_PTS(buffer.get()) = (static_cast&lt;guint64&gt;(renderTimeMs) * GST_MSECOND) - m_firstBufferPts;
231         InputTimestamps timestamps = {inputImage.Timestamp(), renderTimeMs};
232         m_dtsPtsMap[GST_BUFFER_PTS(buffer.get())] = timestamps;
233 
234         GST_LOG_OBJECT(pipeline(), &quot;%&quot; G_GINT64_FORMAT &quot; Decoding: %&quot; GST_PTR_FORMAT, renderTimeMs, buffer.get());
235         auto sample = adoptGRef(gst_sample_new(buffer.get(), GetCapsForFrame(inputImage), nullptr, nullptr));
236         switch (gst_app_src_push_sample(GST_APP_SRC(m_src), sample.get())) {
237         case GST_FLOW_OK:
238             break;
239         case GST_FLOW_FLUSHING:
240             return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
241         default:
242             return WEBRTC_VIDEO_CODEC_ERROR;
243         }
244 
245         return pullSample();
246     }
247 
248     int32_t pullSample()
</pre>
<hr />
<pre>
337     GstElement* m_sink;
338     GstElement* m_src;
339 
340     GstVideoInfo m_info;
341     webrtc::DecodedImageCallback* m_imageReadyCb;
342 
343     StdMap&lt;GstClockTime, InputTimestamps&gt; m_dtsPtsMap;
344     GstClockTime m_firstBufferPts;
345     GstClockTime m_firstBufferDts;
346 };
347 
348 class H264Decoder : public GStreamerVideoDecoder {
349 public:
350     H264Decoder() { m_requireParse = true; }
351 
352     int32_t InitDecode(const webrtc::VideoCodec* codecInfo, int32_t nCores) final
353     {
354         if (codecInfo &amp;&amp; codecInfo-&gt;codecType != webrtc::kVideoCodecH264)
355             return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
356 
<span class="line-removed">357         m_profile = nullptr;</span>
<span class="line-removed">358         if (codecInfo) {</span>
<span class="line-removed">359             auto h264Info = codecInfo-&gt;H264();</span>
<span class="line-removed">360 </span>
<span class="line-removed">361             switch (h264Info.profile) {</span>
<span class="line-removed">362             case webrtc::H264::kProfileConstrainedBaseline:</span>
<span class="line-removed">363                 m_profile = &quot;constrained-baseline&quot;;</span>
<span class="line-removed">364                 break;</span>
<span class="line-removed">365             case webrtc::H264::kProfileBaseline:</span>
<span class="line-removed">366                 m_profile = &quot;baseline&quot;;</span>
<span class="line-removed">367                 break;</span>
<span class="line-removed">368             case webrtc::H264::kProfileMain:</span>
<span class="line-removed">369                 m_profile = &quot;main&quot;;</span>
<span class="line-removed">370                 break;</span>
<span class="line-removed">371             case webrtc::H264::kProfileConstrainedHigh:</span>
<span class="line-removed">372                 m_profile = &quot;constrained-high&quot;;</span>
<span class="line-removed">373                 break;</span>
<span class="line-removed">374             case webrtc::H264::kProfileHigh:</span>
<span class="line-removed">375                 m_profile = &quot;high&quot;;</span>
<span class="line-removed">376                 break;</span>
<span class="line-removed">377             }</span>
<span class="line-removed">378         }</span>
<span class="line-removed">379 </span>
380         return GStreamerVideoDecoder::InitDecode(codecInfo, nCores);
381     }
382 
383     GstCaps* GetCapsForFrame(const webrtc::EncodedImage&amp; image) final
384     {
385         if (!m_caps) {
386             m_caps = adoptGRef(gst_caps_new_simple(Caps(),
387                 &quot;width&quot;, G_TYPE_INT, image._encodedWidth ? image._encodedWidth : m_width,
388                 &quot;height&quot;, G_TYPE_INT, image._encodedHeight ? image._encodedHeight : m_height,
389                 &quot;alignment&quot;, G_TYPE_STRING, &quot;au&quot;,
390                 nullptr));
391         }
392 
393         return m_caps.get();
394     }
395     const gchar* Caps() final { return &quot;video/x-h264&quot;; }
396     const gchar* Name() final { return cricket::kH264CodecName; }
397     webrtc::VideoCodecType CodecType() final { return webrtc::kVideoCodecH264; }
<span class="line-removed">398 </span>
<span class="line-removed">399 private:</span>
<span class="line-removed">400     const gchar* m_profile;</span>
401 };
402 
403 class VP8Decoder : public GStreamerVideoDecoder {
404 public:
405     VP8Decoder() { }
406     const gchar* Caps() final { return &quot;video/x-vp8&quot;; }
407     const gchar* Name() final { return cricket::kVp8CodecName; }
408     webrtc::VideoCodecType CodecType() final { return webrtc::kVideoCodecVP8; }
409     static std::unique_ptr&lt;webrtc::VideoDecoder&gt; Create()
410     {
411         auto factory = GstDecoderFactory(&quot;video/x-vp8&quot;);
412 
413         if (factory &amp;&amp; !g_strcmp0(GST_OBJECT_NAME(GST_OBJECT(factory.get())), &quot;vp8dec&quot;)) {
414             GST_INFO(&quot;Our best GStreamer VP8 decoder is vp8dec, better use the one from LibWebRTC&quot;);
415 
416             return std::unique_ptr&lt;webrtc::VideoDecoder&gt;(new webrtc::LibvpxVp8Decoder());
417         }
418 
419         return std::unique_ptr&lt;webrtc::VideoDecoder&gt;(new VP8Decoder());
420     }
</pre>
</td>
<td>
<hr />
<pre>
177         return makeElement(&quot;identity&quot;);
178     }
179 
180     int32_t Release() final
181     {
182         if (m_pipeline.get()) {
183             GRefPtr&lt;GstBus&gt; bus = adoptGRef(gst_pipeline_get_bus(GST_PIPELINE(m_pipeline.get())));
184             gst_bus_set_sync_handler(bus.get(), nullptr, nullptr, nullptr);
185 
186             gst_element_set_state(m_pipeline.get(), GST_STATE_NULL);
187             m_src = nullptr;
188             m_sink = nullptr;
189             m_pipeline = nullptr;
190         }
191 
192         return WEBRTC_VIDEO_CODEC_OK;
193     }
194 
195     int32_t Decode(const webrtc::EncodedImage&amp; inputImage,
196         bool,

197         int64_t renderTimeMs) override
198     {
199         if (m_needsKeyframe) {
<span class="line-modified">200             if (inputImage._frameType != webrtc::VideoFrameType::kVideoFrameKey) {</span>
201                 GST_ERROR(&quot;Waiting for keyframe but got a delta unit... asking for keyframe&quot;);
202                 return WEBRTC_VIDEO_CODEC_ERROR;
203             }
204             if (inputImage._completeFrame)
205                 m_needsKeyframe = false;
206             else {
207                 GST_ERROR(&quot;Waiting for keyframe but didn&#39;t get full frame, getting out&quot;);
208                 return WEBRTC_VIDEO_CODEC_ERROR;
209             }
210         }
211 
212 
213         if (!m_src) {
214             GST_ERROR(&quot;No source set, can&#39;t decode.&quot;);
215 
216             return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
217         }
218 
219         if (!GST_CLOCK_TIME_IS_VALID(m_firstBufferPts)) {
220             GRefPtr&lt;GstPad&gt; srcpad = adoptGRef(gst_element_get_static_pad(m_src, &quot;src&quot;));
221             m_firstBufferPts = (static_cast&lt;guint64&gt;(renderTimeMs)) * GST_MSECOND;
222             m_firstBufferDts = (static_cast&lt;guint64&gt;(inputImage.Timestamp())) * GST_MSECOND;
223         }
224 
225         // FIXME- Use a GstBufferPool.
<span class="line-modified">226         auto buffer = adoptGRef(gst_buffer_new_wrapped(g_memdup(inputImage.data(), inputImage.size()),</span>
<span class="line-modified">227             inputImage.size()));</span>
228         GST_BUFFER_DTS(buffer.get()) = (static_cast&lt;guint64&gt;(inputImage.Timestamp()) * GST_MSECOND) - m_firstBufferDts;
229         GST_BUFFER_PTS(buffer.get()) = (static_cast&lt;guint64&gt;(renderTimeMs) * GST_MSECOND) - m_firstBufferPts;
230         InputTimestamps timestamps = {inputImage.Timestamp(), renderTimeMs};
231         m_dtsPtsMap[GST_BUFFER_PTS(buffer.get())] = timestamps;
232 
233         GST_LOG_OBJECT(pipeline(), &quot;%&quot; G_GINT64_FORMAT &quot; Decoding: %&quot; GST_PTR_FORMAT, renderTimeMs, buffer.get());
234         auto sample = adoptGRef(gst_sample_new(buffer.get(), GetCapsForFrame(inputImage), nullptr, nullptr));
235         switch (gst_app_src_push_sample(GST_APP_SRC(m_src), sample.get())) {
236         case GST_FLOW_OK:
237             break;
238         case GST_FLOW_FLUSHING:
239             return WEBRTC_VIDEO_CODEC_UNINITIALIZED;
240         default:
241             return WEBRTC_VIDEO_CODEC_ERROR;
242         }
243 
244         return pullSample();
245     }
246 
247     int32_t pullSample()
</pre>
<hr />
<pre>
336     GstElement* m_sink;
337     GstElement* m_src;
338 
339     GstVideoInfo m_info;
340     webrtc::DecodedImageCallback* m_imageReadyCb;
341 
342     StdMap&lt;GstClockTime, InputTimestamps&gt; m_dtsPtsMap;
343     GstClockTime m_firstBufferPts;
344     GstClockTime m_firstBufferDts;
345 };
346 
347 class H264Decoder : public GStreamerVideoDecoder {
348 public:
349     H264Decoder() { m_requireParse = true; }
350 
351     int32_t InitDecode(const webrtc::VideoCodec* codecInfo, int32_t nCores) final
352     {
353         if (codecInfo &amp;&amp; codecInfo-&gt;codecType != webrtc::kVideoCodecH264)
354             return WEBRTC_VIDEO_CODEC_ERR_PARAMETER;
355 























356         return GStreamerVideoDecoder::InitDecode(codecInfo, nCores);
357     }
358 
359     GstCaps* GetCapsForFrame(const webrtc::EncodedImage&amp; image) final
360     {
361         if (!m_caps) {
362             m_caps = adoptGRef(gst_caps_new_simple(Caps(),
363                 &quot;width&quot;, G_TYPE_INT, image._encodedWidth ? image._encodedWidth : m_width,
364                 &quot;height&quot;, G_TYPE_INT, image._encodedHeight ? image._encodedHeight : m_height,
365                 &quot;alignment&quot;, G_TYPE_STRING, &quot;au&quot;,
366                 nullptr));
367         }
368 
369         return m_caps.get();
370     }
371     const gchar* Caps() final { return &quot;video/x-h264&quot;; }
372     const gchar* Name() final { return cricket::kH264CodecName; }
373     webrtc::VideoCodecType CodecType() final { return webrtc::kVideoCodecH264; }



374 };
375 
376 class VP8Decoder : public GStreamerVideoDecoder {
377 public:
378     VP8Decoder() { }
379     const gchar* Caps() final { return &quot;video/x-vp8&quot;; }
380     const gchar* Name() final { return cricket::kVp8CodecName; }
381     webrtc::VideoCodecType CodecType() final { return webrtc::kVideoCodecVP8; }
382     static std::unique_ptr&lt;webrtc::VideoDecoder&gt; Create()
383     {
384         auto factory = GstDecoderFactory(&quot;video/x-vp8&quot;);
385 
386         if (factory &amp;&amp; !g_strcmp0(GST_OBJECT_NAME(GST_OBJECT(factory.get())), &quot;vp8dec&quot;)) {
387             GST_INFO(&quot;Our best GStreamer VP8 decoder is vp8dec, better use the one from LibWebRTC&quot;);
388 
389             return std::unique_ptr&lt;webrtc::VideoDecoder&gt;(new webrtc::LibvpxVp8Decoder());
390         }
391 
392         return std::unique_ptr&lt;webrtc::VideoDecoder&gt;(new VP8Decoder());
393     }
</pre>
</td>
</tr>
</table>
<center><a href="../RealtimeVideoSource.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="GStreamerVideoEncoderFactory.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
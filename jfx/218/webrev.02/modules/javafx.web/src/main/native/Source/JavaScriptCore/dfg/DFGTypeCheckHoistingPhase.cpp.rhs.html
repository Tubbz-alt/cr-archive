<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGTypeCheckHoistingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBasicBlock.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;DFGVariableAccessDataDump.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &lt;wtf/HashMap.h&gt;
 38 
 39 namespace JSC { namespace DFG {
 40 
 41 enum CheckBallot { VoteOther, VoteStructureCheck = 1, VoteCheckArray = 1 };
 42 
 43 struct ArrayTypeCheck;
 44 struct StructureTypeCheck;
 45 
 46 struct CheckData {
 47     Structure* m_structure;
 48     ArrayMode m_arrayMode;
 49     bool m_arrayModeIsValid;
 50     bool m_arrayModeHoistingOkay;
 51 
 52     CheckData()
 53         : m_structure(0)
 54         , m_arrayModeIsValid(false)
 55         , m_arrayModeHoistingOkay(false)
 56     {
 57     }
 58 
 59     CheckData(Structure* structure)
 60         : m_structure(structure)
 61         , m_arrayModeIsValid(false)
 62         , m_arrayModeHoistingOkay(true)
 63     {
 64     }
 65 
 66     CheckData(ArrayMode arrayMode)
 67         : m_structure(0)
 68         , m_arrayMode(arrayMode)
 69         , m_arrayModeIsValid(true)
 70         , m_arrayModeHoistingOkay(true)
 71     {
 72     }
 73 
 74     void disableCheckArrayHoisting()
 75     {
 76         m_arrayModeIsValid = false;
 77         m_arrayModeHoistingOkay = false;
 78     }
 79 };
 80 
 81 class TypeCheckHoistingPhase : public Phase {
 82 public:
 83     TypeCheckHoistingPhase(Graph&amp; graph)
 84         : Phase(graph, &quot;structure check hoisting&quot;)
 85     {
 86     }
 87 
 88     bool run()
 89     {
 90         ASSERT(m_graph.m_form == ThreadedCPS);
 91 
 92         clearVariableVotes();
 93         identifyRedundantStructureChecks();
 94         disableHoistingForVariablesWithInsufficientVotes&lt;StructureTypeCheck&gt;();
 95 
 96         clearVariableVotes();
 97         identifyRedundantArrayChecks();
 98         disableHoistingForVariablesWithInsufficientVotes&lt;ArrayTypeCheck&gt;();
 99 
100         disableHoistingAcrossOSREntries&lt;StructureTypeCheck&gt;();
101         disableHoistingAcrossOSREntries&lt;ArrayTypeCheck&gt;();
102 
103         bool changed = false;
104 
105         // Place CheckStructure&#39;s at SetLocal sites.
106         InsertionSet insertionSet(m_graph);
107         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
108             BasicBlock* block = m_graph.block(blockIndex);
109             if (!block)
110                 continue;
111             unsigned indexForChecks = UINT_MAX;
112             NodeOrigin originForChecks;
113             for (unsigned indexInBlock = 0; indexInBlock &lt; block-&gt;size(); ++indexInBlock) {
114                 Node* node = block-&gt;at(indexInBlock);
115 
116                 if (node-&gt;origin.exitOK) {
117                     indexForChecks = indexInBlock;
118                     originForChecks = node-&gt;origin;
119                 }
120 
121                 // Be careful not to use &#39;node&#39; after appending to the graph. In those switch
122                 // cases where we need to append, we first carefully extract everything we need
123                 // from the node, before doing any appending.
124                 switch (node-&gt;op()) {
125                 case SetArgumentDefinitely: {
126                     // Insert a GetLocal and a CheckStructure immediately following this
127                     // SetArgumentDefinitely, if the variable was a candidate for structure hoisting.
128                     // If the basic block previously only had the SetArgumentDefinitely as its
129                     // variable-at-tail, then replace it with this GetLocal.
130                     VariableAccessData* variable = node-&gt;variableAccessData();
131                     HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
132                     if (iter == m_map.end())
133                         break;
134                     if (!iter-&gt;value.m_structure &amp;&amp; !iter-&gt;value.m_arrayModeIsValid)
135                         break;
136 
137                     // Currently we should only be doing this hoisting for SetArguments at a CFG root.
138                     ASSERT(m_graph.isRoot(block));
139 
140                     NodeOrigin origin = node-&gt;origin;
141                     RELEASE_ASSERT(origin.exitOK);
142 
143                     Node* getLocal = insertionSet.insertNode(
144                         indexInBlock + 1, variable-&gt;prediction(), GetLocal, origin,
145                         OpInfo(variable), Edge(node));
<a name="1" id="anc1"></a><span class="line-modified">146 </span>
<span class="line-modified">147                     auto needsEmptyCheck = [](Node* node) -&gt; bool {</span>
<span class="line-modified">148                         if (!(SpecCellCheck &amp; SpecEmpty))</span>
<span class="line-modified">149                             return false;</span>
<span class="line-modified">150                         VirtualRegister local = node-&gt;variableAccessData()-&gt;operand().virtualRegister();</span>
<span class="line-modified">151                         auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified">152                         if ((local - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0)) == virtualRegisterForArgumentIncludingThis(0)) {</span>
<span class="line-modified">153                             // |this| can be the TDZ value. The call entrypoint won&#39;t have |this| as TDZ,</span>
<span class="line-modified">154                             // but a catch or a loop OSR entry may have |this| be TDZ.</span>
<span class="line-modified">155                             return true;</span>
156                         }
<a name="2" id="anc2"></a><span class="line-added">157                         return false;</span>
<span class="line-added">158                     };</span>
159 
<a name="3" id="anc3"></a><span class="line-added">160                     if (iter-&gt;value.m_structure) {</span>
<span class="line-added">161                         auto checkOp = CheckStructure;</span>
<span class="line-added">162                         if (needsEmptyCheck(node))</span>
<span class="line-added">163                             checkOp = CheckStructureOrEmpty;</span>
164                         insertionSet.insertNode(
165                             indexInBlock + 1, SpecNone, checkOp, origin,
166                             OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
167                             Edge(getLocal, CellUse));
168                     } else if (iter-&gt;value.m_arrayModeIsValid) {
169                         ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
<a name="4" id="anc4"></a><span class="line-added">170                         auto checkOp = CheckArray;</span>
<span class="line-added">171                         if (needsEmptyCheck(node))</span>
<span class="line-added">172                             checkOp = CheckArrayOrEmpty;</span>
173                         insertionSet.insertNode(
<a name="5" id="anc5"></a><span class="line-modified">174                             indexInBlock + 1, SpecNone, checkOp, origin,</span>
175                             OpInfo(iter-&gt;value.m_arrayMode.asWord()),
176                             Edge(getLocal, CellUse));
177                     } else
178                         RELEASE_ASSERT_NOT_REACHED();
179 
<a name="6" id="anc6"></a><span class="line-modified">180                     if (block-&gt;variablesAtTail.operand(variable-&gt;operand()) == node)</span>
<span class="line-modified">181                         block-&gt;variablesAtTail.operand(variable-&gt;operand()) = getLocal;</span>
182 
183                     m_graph.substituteGetLocal(*block, indexInBlock, variable, getLocal);
184 
185                     changed = true;
186                     break;
187                 }
188 
189                 case SetLocal: {
190                     VariableAccessData* variable = node-&gt;variableAccessData();
191                     HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
192                     if (iter == m_map.end())
193                         break;
194                     if (!iter-&gt;value.m_structure &amp;&amp; !iter-&gt;value.m_arrayModeIsValid)
195                         break;
196 
197                     NodeOrigin origin = node-&gt;origin;
198                     Edge child1 = node-&gt;child1();
199 
<a name="7" id="anc7"></a><span class="line-added">200                     // Note: On 64-bit platforms, cell checks allow the empty value to flow through.</span>
<span class="line-added">201                     // This means that this structure/array check may see the empty value as input. We need</span>
<span class="line-added">202                     // to emit a node that explicitly handles the empty value. Most of the time, CheckStructureOrEmpty/CheckArrayOrEmpty</span>
<span class="line-added">203                     // will be folded to CheckStructure/CheckArray because AI proves that the incoming value is</span>
<span class="line-added">204                     // definitely not empty.</span>
205                     if (iter-&gt;value.m_structure) {
<a name="8" id="anc8"></a>




206                         insertionSet.insertNode(
207                             indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckStructureOrEmpty : CheckStructure,
208                             originForChecks.withSemantic(origin.semantic),
209                             OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
210                             Edge(child1.node(), CellUse));
211                     } else if (iter-&gt;value.m_arrayModeIsValid) {
212                         ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
213                         insertionSet.insertNode(
<a name="9" id="anc9"></a><span class="line-modified">214                             indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckArrayOrEmpty : CheckArray,</span>
215                             originForChecks.withSemantic(origin.semantic),
216                             OpInfo(iter-&gt;value.m_arrayMode.asWord()),
217                             Edge(child1.node(), CellUse));
218                     } else
219                         RELEASE_ASSERT_NOT_REACHED();
220                     changed = true;
221                     break;
222                 }
223 
224                 default:
225                     break;
226                 }
227             }
228             insertionSet.execute(block);
229         }
230 
231         return changed;
232     }
233 
234 private:
235     void clearVariableVotes()
236     {
237         for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
238             VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
239             if (!variable-&gt;isRoot())
240                 continue;
241             variable-&gt;clearVotes();
242         }
243     }
244 
245     // Identify the set of variables that are always subject to the same structure
246     // checks. For now, only consider monomorphic structure checks (one structure).
247     void identifyRedundantStructureChecks()
248     {
249         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
250             BasicBlock* block = m_graph.block(blockIndex);
251             if (!block)
252                 continue;
253             for (unsigned indexInBlock = 0; indexInBlock &lt; block-&gt;size(); ++indexInBlock) {
254                 Node* node = block-&gt;at(indexInBlock);
255                 switch (node-&gt;op()) {
256                 case CheckStructure: {
257                     Node* child = node-&gt;child1().node();
258                     if (child-&gt;op() != GetLocal)
259                         break;
260                     VariableAccessData* variable = child-&gt;variableAccessData();
261                     variable-&gt;vote(VoteStructureCheck);
262                     if (!shouldConsiderForHoisting&lt;StructureTypeCheck&gt;(variable))
263                         break;
264                     noticeStructureCheck(variable, node-&gt;structureSet());
265                     break;
266                 }
267 
268                 case ArrayifyToStructure:
269                 case Arrayify:
270                 case GetByOffset:
271                 case PutByOffset:
272                 case PutStructure:
273                 case AllocatePropertyStorage:
274                 case ReallocatePropertyStorage:
275                 case NukeStructureAndSetButterfly:
276                 case GetButterfly:
277                 case GetByVal:
278                 case PutByValDirect:
279                 case PutByVal:
280                 case PutByValAlias:
281                 case GetArrayLength:
282                 case CheckArray:
<a name="10" id="anc10"></a><span class="line-added">283                 case CheckNeutered:</span>
284                 case GetIndexedPropertyStorage:
285                 case GetTypedArrayByteOffset:
286                 case Phantom:
287                 case MovHint:
288                 case MultiGetByOffset:
289                 case MultiPutByOffset:
290                     // Don&#39;t count these uses.
291                     break;
292 
293                 case SetLocal: {
294                     // Find all uses of the source of the SetLocal. If any of them are a
295                     // kind of CheckStructure, then we should notice them to ensure that
296                     // we&#39;re not hoisting a check that would contravene checks that are
297                     // already being performed.
298                     VariableAccessData* variable = node-&gt;variableAccessData();
299                     if (!shouldConsiderForHoisting&lt;StructureTypeCheck&gt;(variable))
300                         break;
301                     Node* source = node-&gt;child1().node();
302                     for (auto* subNode : *block) {
303                         switch (subNode-&gt;op()) {
304                         case CheckStructure: {
305                             if (subNode-&gt;child1() != source)
306                                 break;
307 
308                             noticeStructureCheck(variable, subNode-&gt;structureSet());
309                             break;
310                         }
311                         default:
312                             break;
313                         }
314                     }
315 
316                     m_graph.voteChildren(node, VoteOther);
317                     break;
318                 }
319 
320                 default:
321                     m_graph.voteChildren(node, VoteOther);
322                     break;
323                 }
324             }
325         }
326     }
327 
328     void identifyRedundantArrayChecks()
329     {
330         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
331             BasicBlock* block = m_graph.block(blockIndex);
332             if (!block)
333                 continue;
334             for (auto* node : *block) {
335                 switch (node-&gt;op()) {
336                 case CheckArray: {
337                     Node* child = node-&gt;child1().node();
338                     if (child-&gt;op() != GetLocal)
339                         break;
340                     VariableAccessData* variable = child-&gt;variableAccessData();
341                     variable-&gt;vote(VoteCheckArray);
342                     if (!shouldConsiderForHoisting&lt;ArrayTypeCheck&gt;(variable))
343                         break;
344                     noticeCheckArray(variable, node-&gt;arrayMode());
345                     break;
346                 }
347 
348                 case CheckStructure:
<a name="11" id="anc11"></a><span class="line-added">349                 case CheckNeutered:</span>
350                 case GetByOffset:
351                 case PutByOffset:
352                 case PutStructure:
353                 case ReallocatePropertyStorage:
354                 case GetButterfly:
355                 case GetByVal:
356                 case PutByValDirect:
357                 case PutByVal:
358                 case PutByValAlias:
359                 case GetArrayLength:
360                 case GetIndexedPropertyStorage:
361                 case Phantom:
362                 case MovHint:
363                 case MultiGetByOffset:
364                 case MultiPutByOffset:
365                     // Don&#39;t count these uses.
366                     break;
367 
368                 case AllocatePropertyStorage:
369                 case ArrayifyToStructure:
370                 case Arrayify: {
371                     // Any Arrayify could change our indexing type, so disable
372                     // all CheckArray hoisting.
373                     Node* child = node-&gt;child1().node();
374                     if (child-&gt;op() != GetLocal)
375                         break;
376                     VariableAccessData* variable = child-&gt;variableAccessData();
377                     variable-&gt;vote(VoteOther);
378                     if (!shouldConsiderForHoisting&lt;ArrayTypeCheck&gt;(variable))
379                         break;
380                     disableCheckArrayHoisting(variable);
381                     break;
382                 }
383 
384                 case SetLocal: {
385                     // Find all uses of the source of the SetLocal. If any of them are a
386                     // kind of CheckStructure, then we should notice them to ensure that
387                     // we&#39;re not hoisting a check that would contravene checks that are
388                     // already being performed.
389                     VariableAccessData* variable = node-&gt;variableAccessData();
390                     if (!shouldConsiderForHoisting&lt;ArrayTypeCheck&gt;(variable))
391                         break;
392                     Node* source = node-&gt;child1().node();
393                     for (auto subNode : *block) {
394                         switch (subNode-&gt;op()) {
395                         case CheckStructure: {
396                             if (subNode-&gt;child1() != source)
397                                 break;
398 
399                             noticeStructureCheckAccountingForArrayMode(variable, subNode-&gt;structureSet());
400                             break;
401                         }
402                         case CheckArray: {
403                             if (subNode-&gt;child1() != source)
404                                 break;
405                             noticeCheckArray(variable, subNode-&gt;arrayMode());
406                             break;
407                         }
408                         default:
409                             break;
410                         }
411                     }
412 
413                     m_graph.voteChildren(node, VoteOther);
414                     break;
415                 }
416 
417                 default:
418                     m_graph.voteChildren(node, VoteOther);
419                     break;
420                 }
421             }
422         }
423     }
424 
425     // Disable hoisting on variables that appear to mostly be used in
426     // contexts where it doesn&#39;t make sense.
427     template &lt;typename TypeCheck&gt;
428     void disableHoistingForVariablesWithInsufficientVotes()
429     {
430         for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
431             VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
432             if (!variable-&gt;isRoot())
433                 continue;
434             if (TypeCheck::hasEnoughVotesToHoist(variable))
435                 continue;
436             HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
437             if (iter == m_map.end())
438                 continue;
439             TypeCheck::disableHoisting(iter-&gt;value);
440         }
441     }
442 
443     // Disable check hoisting for variables that cross the OSR entry that
444     // we&#39;re currently taking, and where the value currently does not have the
445     // particular form we want (e.g. a contradictory ArrayMode or Struture).
446     template &lt;typename TypeCheck&gt;
447     void disableHoistingAcrossOSREntries()
448     {
449         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
450             BasicBlock* block = m_graph.block(blockIndex);
451             if (!block)
452                 continue;
453             ASSERT(block-&gt;isReachable);
454             if (!block-&gt;isOSRTarget)
455                 continue;
456             if (block-&gt;bytecodeBegin != m_graph.m_plan.osrEntryBytecodeIndex())
457                 continue;
458             const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
459             for (size_t i = 0; i &lt; mustHandleValues.size(); ++i) {
<a name="12" id="anc12"></a><span class="line-modified">460                 Operand operand = mustHandleValues.operandForIndex(i);</span>
461                 Node* node = block-&gt;variablesAtHead.operand(operand);
462                 if (!node)
463                     continue;
464                 VariableAccessData* variable = node-&gt;variableAccessData();
465                 HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
466                 if (iter == m_map.end())
467                     continue;
468                 if (!TypeCheck::isValidToHoist(iter-&gt;value))
469                     continue;
470                 Optional&lt;JSValue&gt; value = mustHandleValues[i];
471                 if (!value || !value.value() || !value.value().isCell() || TypeCheck::isContravenedByValue(iter-&gt;value, value.value())) {
472                     TypeCheck::disableHoisting(iter-&gt;value);
473                     continue;
474                 }
475             }
476         }
477     }
478 
479     void disableCheckArrayHoisting(VariableAccessData* variable)
480     {
481         HashMap&lt;VariableAccessData*, CheckData&gt;::AddResult result = m_map.add(variable, CheckData());
482         result.iterator-&gt;value.disableCheckArrayHoisting();
483     }
484 
485     template &lt;typename TypeCheck&gt;
486     bool shouldConsiderForHoisting(VariableAccessData* variable)
487     {
488         if (!variable-&gt;shouldUnboxIfPossible())
489             return false;
490         if (TypeCheck::hoistingPreviouslyFailed(variable))
491             return false;
492         if (!isCellSpeculation(variable-&gt;prediction()))
493             return false;
494         return true;
495     }
496 
497     void noticeStructureCheck(VariableAccessData* variable, RegisteredStructure structure)
498     {
499         HashMap&lt;VariableAccessData*, CheckData&gt;::AddResult result = m_map.add(variable, CheckData(structure.get()));
500         if (result.isNewEntry)
501             return;
502         if (result.iterator-&gt;value.m_structure == structure.get())
503             return;
504         result.iterator-&gt;value.m_structure = 0;
505     }
506 
507     void noticeStructureCheck(VariableAccessData* variable, RegisteredStructureSet set)
508     {
509         if (set.size() != 1) {
510             noticeStructureCheck(variable, RegisteredStructure());
511             return;
512         }
513         noticeStructureCheck(variable, set.at(0));
514     }
515 
516     void noticeCheckArray(VariableAccessData* variable, ArrayMode arrayMode)
517     {
518         HashMap&lt;VariableAccessData*, CheckData&gt;::AddResult result = m_map.add(variable, CheckData(arrayMode));
519         if (result.isNewEntry)
520             return;
521         if (!result.iterator-&gt;value.m_arrayModeHoistingOkay)
522             return;
523         if (result.iterator-&gt;value.m_arrayMode == arrayMode)
524             return;
525         if (!result.iterator-&gt;value.m_arrayModeIsValid) {
526             result.iterator-&gt;value.m_arrayMode = arrayMode;
527             result.iterator-&gt;value.m_arrayModeIsValid = true;
528             return;
529         }
530         result.iterator-&gt;value.disableCheckArrayHoisting();
531     }
532 
533     void noticeStructureCheckAccountingForArrayMode(VariableAccessData* variable, RegisteredStructure structure)
534     {
535         HashMap&lt;VariableAccessData*, CheckData&gt;::iterator result = m_map.find(variable);
536         if (result == m_map.end())
537             return;
538         if (!result-&gt;value.m_arrayModeHoistingOkay || !result-&gt;value.m_arrayModeIsValid)
539             return;
540         if (result-&gt;value.m_arrayMode.structureWouldPassArrayModeFiltering(structure.get()))
541             return;
542         result-&gt;value.disableCheckArrayHoisting();
543     }
544 
545     void noticeStructureCheckAccountingForArrayMode(VariableAccessData* variable, RegisteredStructureSet set)
546     {
547         for (unsigned i = 0; i &lt; set.size(); i++)
548             noticeStructureCheckAccountingForArrayMode(variable, set.at(i));
549     }
550 
551     HashMap&lt;VariableAccessData*, CheckData&gt; m_map;
552 };
553 
554 bool performTypeCheckHoisting(Graph&amp; graph)
555 {
556     return runPhase&lt;TypeCheckHoistingPhase&gt;(graph);
557 }
558 
559 struct ArrayTypeCheck {
560     static bool isValidToHoist(CheckData&amp; checkData)
561     {
562         return checkData.m_arrayModeIsValid;
563     }
564 
565     static void disableHoisting(CheckData&amp; checkData)
566     {
567         checkData.disableCheckArrayHoisting();
568     }
569 
570     static bool isContravenedByValue(CheckData&amp; checkData, JSValue value)
571     {
572         ASSERT(value.isCell());
573         return !checkData.m_arrayMode.structureWouldPassArrayModeFiltering(value.asCell()-&gt;structure());
574     }
575 
576     static bool hasEnoughVotesToHoist(VariableAccessData* variable)
577     {
578         return variable-&gt;voteRatio() &gt;= Options::checkArrayVoteRatioForHoisting();
579     }
580 
581     static bool hoistingPreviouslyFailed(VariableAccessData* variable)
582     {
583         return variable-&gt;checkArrayHoistingFailed();
584     }
585 };
586 
587 struct StructureTypeCheck {
588     static bool isValidToHoist(CheckData&amp; checkData)
589     {
590         return checkData.m_structure;
591     }
592 
593     static void disableHoisting(CheckData&amp; checkData)
594     {
595         checkData.m_structure = 0;
596     }
597 
598     static bool isContravenedByValue(CheckData&amp; checkData, JSValue value)
599     {
600         ASSERT(value.isCell());
601         return checkData.m_structure != value.asCell()-&gt;structure();
602     }
603 
604     static bool hasEnoughVotesToHoist(VariableAccessData* variable)
605     {
606         return variable-&gt;voteRatio() &gt;= Options::structureCheckVoteRatioForHoisting();
607     }
608 
609     static bool hoistingPreviouslyFailed(VariableAccessData* variable)
610     {
611         return variable-&gt;structureCheckHoistingFailed();
612     }
613 };
614 
615 } } // namespace JSC::DFG
616 
617 #endif // ENABLE(DFG_JIT)
618 
619 
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
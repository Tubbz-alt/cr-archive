<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2008, 2013 Apple Inc. All rights reserved.
  3  * Copyright (C) 2007 Nicholas Shanks &lt;webkit@nickshanks.com&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;FontCache.h&quot;
 32 
 33 #include &quot;FontCascade.h&quot;
 34 #include &quot;FontPlatformData.h&quot;
 35 #include &quot;FontSelector.h&quot;
 36 #include &quot;Logging.h&quot;
 37 #include &quot;WebKitFontFamilyNames.h&quot;
 38 #include &lt;wtf/HashMap.h&gt;
 39 #include &lt;wtf/MemoryPressureHandler.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/StdLibExtras.h&gt;
 42 #include &lt;wtf/text/AtomStringHash.h&gt;
 43 #include &lt;wtf/text/StringHash.h&gt;
 44 
 45 #if ENABLE(OPENTYPE_VERTICAL)
 46 #include &quot;OpenTypeVerticalData.h&quot;
 47 #endif
 48 
 49 #if PLATFORM(IOS_FAMILY)
 50 #include &lt;wtf/Lock.h&gt;
 51 #include &lt;wtf/RecursiveLockAdapter.h&gt;
 52 
 53 static RecursiveLock fontLock;
 54 
 55 #endif // PLATFORM(IOS_FAMILY)
 56 
 57 
 58 namespace WebCore {
 59 using namespace WTF;
 60 
 61 FontCache&amp; FontCache::singleton()
 62 {
 63     static NeverDestroyed&lt;FontCache&gt; globalFontCache;
 64     return globalFontCache;
 65 }
 66 
 67 FontCache::FontCache()
 68     : m_purgeTimer(*this, &amp;FontCache::purgeInactiveFontDataIfNeeded)
 69 {
 70 }
 71 
 72 struct FontPlatformDataCacheKey {
 73     WTF_MAKE_FAST_ALLOCATED;
 74 public:
 75     FontPlatformDataCacheKey() { }
 76     FontPlatformDataCacheKey(const AtomString&amp; family, const FontDescription&amp; description, const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities)
 77         : m_fontDescriptionKey(description)
 78         , m_family(family)
 79         , m_fontFaceFeatures(fontFaceFeatures ? *fontFaceFeatures : FontFeatureSettings())
 80         , m_fontFaceCapabilities(fontFaceCapabilities)
 81     { }
 82 
 83     explicit FontPlatformDataCacheKey(HashTableDeletedValueType t)
 84         : m_fontDescriptionKey(t)
 85     { }
 86 
 87     bool isHashTableDeletedValue() const { return m_fontDescriptionKey.isHashTableDeletedValue(); }
 88 
 89     bool operator==(const FontPlatformDataCacheKey&amp; other) const
 90     {
 91         if (m_fontDescriptionKey != other.m_fontDescriptionKey
 92             || m_fontFaceFeatures != other.m_fontFaceFeatures
 93             || m_fontFaceCapabilities != other.m_fontFaceCapabilities)
 94             return false;
 95         if (m_family.impl() == other.m_family.impl())
 96             return true;
 97         if (m_family.isNull() || other.m_family.isNull())
 98             return false;
 99         return FontCascadeDescription::familyNamesAreEqual(m_family, other.m_family);
100     }
101 
102     FontDescriptionKey m_fontDescriptionKey;
103     AtomString m_family;
104     FontFeatureSettings m_fontFaceFeatures;
105     FontSelectionSpecifiedCapabilities m_fontFaceCapabilities;
106 };
107 
108 struct FontPlatformDataCacheKeyHash {
109     static unsigned hash(const FontPlatformDataCacheKey&amp; fontKey)
110     {
111         IntegerHasher hasher;
112         hasher.add(FontCascadeDescription::familyNameHash(fontKey.m_family));
113         hasher.add(fontKey.m_fontDescriptionKey.computeHash());
114         hasher.add(fontKey.m_fontFaceFeatures.hash());
115         if (auto weight = fontKey.m_fontFaceCapabilities.weight)
116             hasher.add(weight-&gt;uniqueValue());
117         else
118             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
119         if (auto width = fontKey.m_fontFaceCapabilities.weight)
120             hasher.add(width-&gt;uniqueValue());
121         else
122             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
123         if (auto slope = fontKey.m_fontFaceCapabilities.weight)
124             hasher.add(slope-&gt;uniqueValue());
125         else
126             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
127         return hasher.hash();
128     }
129 
130     static bool equal(const FontPlatformDataCacheKey&amp; a, const FontPlatformDataCacheKey&amp; b)
131     {
132         return a == b;
133     }
134 
135     static const bool safeToCompareToEmptyOrDeleted = true;
136 };
137 
138 struct FontPlatformDataCacheKeyHashTraits : public SimpleClassHashTraits&lt;FontPlatformDataCacheKey&gt; {
139     static const bool emptyValueIsZero = false;
140 };
141 
142 typedef HashMap&lt;FontPlatformDataCacheKey, std::unique_ptr&lt;FontPlatformData&gt;, FontPlatformDataCacheKeyHash, FontPlatformDataCacheKeyHashTraits&gt; FontPlatformDataCache;
143 
144 static FontPlatformDataCache&amp; fontPlatformDataCache()
145 {
146     static NeverDestroyed&lt;FontPlatformDataCache&gt; cache;
147     return cache;
148 }
149 
150 const AtomString&amp; FontCache::alternateFamilyName(const AtomString&amp; familyName)
151 {
152     static NeverDestroyed&lt;AtomString&gt; arial(&quot;Arial&quot;, AtomString::ConstructFromLiteral);
153     static NeverDestroyed&lt;AtomString&gt; courier(&quot;Courier&quot;, AtomString::ConstructFromLiteral);
154     static NeverDestroyed&lt;AtomString&gt; courierNew(&quot;Courier New&quot;, AtomString::ConstructFromLiteral);
155     static NeverDestroyed&lt;AtomString&gt; helvetica(&quot;Helvetica&quot;, AtomString::ConstructFromLiteral);
156     static NeverDestroyed&lt;AtomString&gt; times(&quot;Times&quot;, AtomString::ConstructFromLiteral);
157     static NeverDestroyed&lt;AtomString&gt; timesNewRoman(&quot;Times New Roman&quot;, AtomString::ConstructFromLiteral);
158 
159     const AtomString&amp; platformSpecificAlternate = platformAlternateFamilyName(familyName);
160     if (!platformSpecificAlternate.isNull())
161         return platformSpecificAlternate;
162 
163     switch (familyName.length()) {
164     case 5:
165         if (equalLettersIgnoringASCIICase(familyName, &quot;arial&quot;))
166             return helvetica;
167         if (equalLettersIgnoringASCIICase(familyName, &quot;times&quot;))
168             return timesNewRoman;
169         break;
170     case 7:
171         if (equalLettersIgnoringASCIICase(familyName, &quot;courier&quot;))
172             return courierNew;
173         break;
174     case 9:
175         if (equalLettersIgnoringASCIICase(familyName, &quot;helvetica&quot;))
176             return arial;
177         break;
178 #if !OS(WINDOWS)
179     // On Windows, Courier New is a TrueType font that is always present and
180     // Courier is a bitmap font that we do not support. So, we don&#39;t want to map
181     // Courier New to Courier.
182     // FIXME: Not sure why this is harmful on Windows, since the alternative will
183     // only be tried if Courier New is not found.
184     case 11:
185         if (equalLettersIgnoringASCIICase(familyName, &quot;courier new&quot;))
186             return courier;
187         break;
188 #endif
189     case 15:
190         if (equalLettersIgnoringASCIICase(familyName, &quot;times new roman&quot;))
191             return times;
192         break;
193     }
194 
195     return nullAtom();
196 }
197 
198 FontPlatformData* FontCache::getCachedFontPlatformData(const FontDescription&amp; fontDescription, const AtomString&amp; passedFamilyName,
199     const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities, bool checkingAlternateName)
200 {
201 #if PLATFORM(IOS_FAMILY)
202     auto locker = holdLock(fontLock);
203 #endif
204 
205 #if OS(WINDOWS) &amp;&amp; ENABLE(OPENTYPE_VERTICAL)
206     // Leading &quot;@&quot; in the font name enables Windows vertical flow flag for the font.
207     // Because we do vertical flow by ourselves, we don&#39;t want to use the Windows feature.
208     // IE disregards &quot;@&quot; regardless of the orientatoin, so we follow the behavior.
209     const AtomString&amp; familyName = (passedFamilyName.isEmpty() || passedFamilyName[0] != &#39;@&#39;) ?
210         passedFamilyName : AtomString(passedFamilyName.impl()-&gt;substring(1));
211 #else
212     const AtomString&amp; familyName = passedFamilyName;
213 #endif
214 
215     static bool initialized;
216     if (!initialized) {
217         platformInit();
218         initialized = true;
219     }
220 
221     FontPlatformDataCacheKey key(familyName, fontDescription, fontFaceFeatures, fontFaceCapabilities);
222 
223     auto addResult = fontPlatformDataCache().add(key, nullptr);
224     FontPlatformDataCache::iterator it = addResult.iterator;
225     if (addResult.isNewEntry) {
226         it-&gt;value = createFontPlatformData(fontDescription, familyName, fontFaceFeatures, fontFaceCapabilities);
227 
228         if (!it-&gt;value &amp;&amp; !checkingAlternateName) {
229             // We were unable to find a font.  We have a small set of fonts that we alias to other names,
230             // e.g., Arial/Helvetica, Courier/Courier New, etc.  Try looking up the font under the aliased name.
231             const AtomString&amp; alternateName = alternateFamilyName(familyName);
232             if (!alternateName.isNull()) {
233                 FontPlatformData* fontPlatformDataForAlternateName = getCachedFontPlatformData(fontDescription, alternateName, fontFaceFeatures, fontFaceCapabilities, true);
234                 // Lookup the key in the hash table again as the previous iterator may have
235                 // been invalidated by the recursive call to getCachedFontPlatformData().
236                 it = fontPlatformDataCache().find(key);
237                 ASSERT(it != fontPlatformDataCache().end());
238                 if (fontPlatformDataForAlternateName)
239                     it-&gt;value = makeUnique&lt;FontPlatformData&gt;(*fontPlatformDataForAlternateName);
240             }
241         }
242     }
243 
244     return it-&gt;value.get();
245 }
246 
247 struct FontDataCacheKeyHash {
248     static unsigned hash(const FontPlatformData&amp; platformData)
249     {
250         return platformData.hash();
251     }
252 
253     static bool equal(const FontPlatformData&amp; a, const FontPlatformData&amp; b)
254     {
255         return a == b;
256     }
257 
258     static const bool safeToCompareToEmptyOrDeleted = true;
259 };
260 
261 struct FontDataCacheKeyTraits : WTF::GenericHashTraits&lt;FontPlatformData&gt; {
262     static const bool emptyValueIsZero = true;
263     static const FontPlatformData&amp; emptyValue()
264     {
265         static NeverDestroyed&lt;FontPlatformData&gt; key(0.f, false, false);
266         return key;
267     }
268     static void constructDeletedValue(FontPlatformData&amp; slot)
269     {
270         new (NotNull, &amp;slot) FontPlatformData(HashTableDeletedValue);
271     }
272     static bool isDeletedValue(const FontPlatformData&amp; value)
273     {
274         return value.isHashTableDeletedValue();
275     }
276 };
277 
278 typedef HashMap&lt;FontPlatformData, Ref&lt;Font&gt;, FontDataCacheKeyHash, FontDataCacheKeyTraits&gt; FontDataCache;
279 
280 static FontDataCache&amp; cachedFonts()
281 {
282     static NeverDestroyed&lt;FontDataCache&gt; cache;
283     return cache;
284 }
285 
286 #if ENABLE(OPENTYPE_VERTICAL)
287 typedef HashMap&lt;FontPlatformData, RefPtr&lt;OpenTypeVerticalData&gt;, FontDataCacheKeyHash, FontDataCacheKeyTraits&gt; FontVerticalDataCache;
288 
289 FontVerticalDataCache&amp; fontVerticalDataCache()
290 {
291     static NeverDestroyed&lt;FontVerticalDataCache&gt; fontVerticalDataCache;
292     return fontVerticalDataCache;
293 }
294 
295 RefPtr&lt;OpenTypeVerticalData&gt; FontCache::verticalData(const FontPlatformData&amp; platformData)
296 {
297     auto addResult = fontVerticalDataCache().ensure(platformData, [&amp;platformData] {
298         return OpenTypeVerticalData::create(platformData);
299     });
300     return addResult.iterator-&gt;value;
301 }
302 #endif
303 
304 #if PLATFORM(IOS_FAMILY)
305 const unsigned cMaxInactiveFontData = 120;
306 const unsigned cTargetInactiveFontData = 100;
307 #else
308 const unsigned cMaxInactiveFontData = 225;
309 const unsigned cTargetInactiveFontData = 200;
310 #endif
311 
312 const unsigned cMaxUnderMemoryPressureInactiveFontData = 50;
313 const unsigned cTargetUnderMemoryPressureInactiveFontData = 30;
314 
315 RefPtr&lt;Font&gt; FontCache::fontForFamily(const FontDescription&amp; fontDescription, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities, bool checkingAlternateName)
316 {
317     if (!m_purgeTimer.isActive())
318         m_purgeTimer.startOneShot(0_s);
319 
320     if (auto* platformData = getCachedFontPlatformData(fontDescription, family, fontFaceFeatures, fontFaceCapabilities, checkingAlternateName))
321         return fontForPlatformData(*platformData);
322 
323     return nullptr;
324 }
325 
326 Ref&lt;Font&gt; FontCache::fontForPlatformData(const FontPlatformData&amp; platformData)
327 {
328 #if PLATFORM(IOS_FAMILY)
329     auto locker = holdLock(fontLock);
330 #endif
331 
332     auto addResult = cachedFonts().ensure(platformData, [&amp;] {
333         return Font::create(platformData);
334     });
335 
336     ASSERT(addResult.iterator-&gt;value-&gt;platformData() == platformData);
337 
338     return addResult.iterator-&gt;value.copyRef();
339 }
340 
341 void FontCache::purgeInactiveFontDataIfNeeded()
342 {
343     bool underMemoryPressure = MemoryPressureHandler::singleton().isUnderMemoryPressure();
344     unsigned inactiveFontDataLimit = underMemoryPressure ? cMaxUnderMemoryPressureInactiveFontData : cMaxInactiveFontData;
345 
346     LOG(Fonts, &quot;FontCache::purgeInactiveFontDataIfNeeded() - underMemoryPressure %d, inactiveFontDataLimit %u&quot;, underMemoryPressure, inactiveFontDataLimit);
347 
348     if (cachedFonts().size() &lt; inactiveFontDataLimit)
349         return;
350     unsigned inactiveCount = inactiveFontCount();
351     if (inactiveCount &lt;= inactiveFontDataLimit)
352         return;
353 
354     unsigned targetFontDataLimit = underMemoryPressure ? cTargetUnderMemoryPressureInactiveFontData : cTargetInactiveFontData;
355     purgeInactiveFontData(inactiveCount - targetFontDataLimit);
356 }
357 
358 void FontCache::purgeInactiveFontData(unsigned purgeCount)
359 {
360     LOG(Fonts, &quot;FontCache::purgeInactiveFontData(%u)&quot;, purgeCount);
361 
362     pruneUnreferencedEntriesFromFontCascadeCache();
363     pruneSystemFallbackFonts();
364 
365 #if PLATFORM(IOS_FAMILY)
366     auto locker = holdLock(fontLock);
367 #endif
368 
369     while (purgeCount) {
370         Vector&lt;Ref&lt;Font&gt;, 20&gt; fontsToDelete;
371         for (auto&amp; font : cachedFonts().values()) {
372             LOG(Fonts, &quot; trying to purge font %s (has one ref %d)&quot;, font-&gt;platformData().description().utf8().data(), font-&gt;hasOneRef());
373             if (!font-&gt;hasOneRef())
374                 continue;
375             fontsToDelete.append(font.copyRef());
376             if (!--purgeCount)
377                 break;
378         }
379         // Fonts may ref other fonts so we loop until there are no changes.
380         if (fontsToDelete.isEmpty())
381             break;
382         for (auto&amp; font : fontsToDelete) {
383             bool success = cachedFonts().remove(font-&gt;platformData());
384             ASSERT_UNUSED(success, success);
385 #if ENABLE(OPENTYPE_VERTICAL)
386             fontVerticalDataCache().remove(font-&gt;platformData());
387 #endif
388         }
389     };
390 
391     Vector&lt;FontPlatformDataCacheKey&gt; keysToRemove;
392     keysToRemove.reserveInitialCapacity(fontPlatformDataCache().size());
393     for (auto&amp; entry : fontPlatformDataCache()) {
394         if (entry.value &amp;&amp; !cachedFonts().contains(*entry.value))
395             keysToRemove.uncheckedAppend(entry.key);
396     }
397 
398     LOG(Fonts, &quot; removing %lu keys&quot;, keysToRemove.size());
399 
400     for (auto&amp; key : keysToRemove)
401         fontPlatformDataCache().remove(key);
402 
403     platformPurgeInactiveFontData();
404 }
405 
406 size_t FontCache::fontCount()
407 {
408     return cachedFonts().size();
409 }
410 
411 size_t FontCache::inactiveFontCount()
412 {
413 #if PLATFORM(IOS_FAMILY)
414     auto locker = holdLock(fontLock);
415 #endif
416     unsigned count = 0;
417     for (auto&amp; font : cachedFonts().values()) {
418         if (font-&gt;hasOneRef())
419             ++count;
420     }
421     return count;
422 }
423 
424 static HashSet&lt;FontSelector*&gt;* gClients;
425 
426 void FontCache::addClient(FontSelector&amp; client)
427 {
428     if (!gClients)
429         gClients = new HashSet&lt;FontSelector*&gt;;
430 
431     ASSERT(!gClients-&gt;contains(&amp;client));
432     gClients-&gt;add(&amp;client);
433 }
434 
435 void FontCache::removeClient(FontSelector&amp; client)
436 {
437     ASSERT(gClients);
438     ASSERT(gClients-&gt;contains(&amp;client));
439 
440     gClients-&gt;remove(&amp;client);
441 }
442 
443 static unsigned short gGeneration = 0;
444 
445 unsigned short FontCache::generation()
446 {
447     return gGeneration;
448 }
449 
450 void FontCache::invalidate()
451 {
452     if (!gClients) {
453         ASSERT(fontPlatformDataCache().isEmpty());
454         return;
455     }
456 
457     fontPlatformDataCache().clear();
458 #if ENABLE(OPENTYPE_VERTICAL)
459     fontVerticalDataCache().clear();
460 #endif
461     invalidateFontCascadeCache();
462 
463     gGeneration++;
464 
465     Vector&lt;Ref&lt;FontSelector&gt;&gt; clients;
466     clients.reserveInitialCapacity(gClients-&gt;size());
467     for (auto it = gClients-&gt;begin(), end = gClients-&gt;end(); it != end; ++it)
468         clients.uncheckedAppend(**it);
469 
470     for (unsigned i = 0; i &lt; clients.size(); ++i)
471         clients[i]-&gt;fontCacheInvalidated();
472 
473     purgeInactiveFontData();
474 }
475 
476 #if !PLATFORM(COCOA)
477 
478 FontCache::PrewarmInformation FontCache::collectPrewarmInformation() const
479 {
480     return { };
481 }
482 
483 void FontCache::prewarmGlobally()
484 {
485 }
486 
487 void FontCache::prewarm(const PrewarmInformation&amp;)
488 {
489 }
490 
491 RefPtr&lt;Font&gt; FontCache::similarFont(const FontDescription&amp;, const AtomString&amp;)
492 {
493     return nullptr;
494 }
495 #endif
496 
497 } // namespace WebCore
    </pre>
  </body>
</html>
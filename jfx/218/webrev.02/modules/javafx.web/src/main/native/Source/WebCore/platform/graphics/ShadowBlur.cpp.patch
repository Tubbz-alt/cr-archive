diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp
@@ -59,20 +59,20 @@
     WTF_MAKE_FAST_ALLOCATED;
 public:
     ScratchBuffer()
         : m_purgeTimer(*this, &ScratchBuffer::clearScratchBuffer)
         , m_lastWasInset(false)
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
         , m_bufferInUse(false)
 #endif
     {
     }
 
     ImageBuffer* getScratchBuffer(const IntSize& size)
     {
         ASSERT(!m_bufferInUse);
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
         m_bufferInUse = true;
 #endif
         // We do not need to recreate the buffer if the current buffer is large enough.
         if (m_imageBuffer && m_imageBuffer->logicalSize().width() >= size.width() && m_imageBuffer->logicalSize().height() >= size.height())
             return m_imageBuffer.get();
@@ -81,11 +81,11 @@
         IntSize roundedSize(roundUpToMultipleOf32(size.width()), roundUpToMultipleOf32(size.height()));
 
         clearScratchBuffer();
 
         // ShadowBlur is not used with accelerated drawing, so it's OK to make an unconditionally unaccelerated buffer.
-        m_imageBuffer = ImageBuffer::create(roundedSize, Unaccelerated, 1);
+        m_imageBuffer = ImageBuffer::create(roundedSize, RenderingMode::Unaccelerated, 1);
         return m_imageBuffer.get();
     }
 
     bool setCachedShadowValues(const FloatSize& radius, const Color& color, const FloatRect& shadowRect, const FloatRoundedRect::Radii& radii, const FloatSize& layerSize)
     {
@@ -117,11 +117,11 @@
         return true;
     }
 
     void scheduleScratchBufferPurge()
     {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
         m_bufferInUse = false;
 #endif
         if (m_purgeTimer.isActive())
             m_purgeTimer.stop();
 
@@ -148,11 +148,11 @@
     Color m_lastColor;
     FloatSize m_lastRadius;
     bool m_lastWasInset;
     FloatSize m_lastLayerSize;
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     bool m_bufferInUse;
 #endif
 };
 
 ScratchBuffer& ScratchBuffer::singleton()
@@ -591,11 +591,11 @@
         drawInsetShadowWithoutTiling(transform, fullRect, holeRect, *layerImageProperties, drawBuffer);
 }
 
 void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&, const FloatRoundedRect& shadowedRect, const LayerImageProperties& layerImageProperties, const DrawBufferCallback& drawBuffer)
 {
-    auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);
+    auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), RenderingMode::Unaccelerated, 1);
     if (!layerImage)
         return;
 
     GraphicsContext& shadowContext = layerImage->context();
     GraphicsContextStateSaver stateSaver(shadowContext);
@@ -619,11 +619,11 @@
     drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);
 }
 
 void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&, const FloatRect& fullRect, const FloatRoundedRect& holeRect, const LayerImageProperties& layerImageProperties, const DrawBufferCallback& drawBuffer)
 {
-    auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);
+    auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), RenderingMode::Unaccelerated, 1);
     if (!layerImage)
         return;
 
     {
         GraphicsContext& shadowContext = layerImage->context();
@@ -683,11 +683,11 @@
 {
 #if USE(CG)
     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
 #else
     UNUSED_PARAM(layerImageProperties);
-    auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);
+    auto layerImageBuffer = ImageBuffer::create(templateSize, RenderingMode::Unaccelerated, 1);
     auto* layerImage = layerImageBuffer.get();
 #endif
 
     if (!layerImage)
         return;
@@ -737,11 +737,11 @@
 void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform& transform, const FloatRect& fullRect, const FloatRoundedRect& holeRect, const IntSize& templateSize, const IntSize& edgeSize, const DrawImageCallback& drawImage, const FillRectWithHoleCallback& fillRectWithHole)
 {
 #if USE(CG)
     auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
 #else
-    auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);
+    auto layerImageBuffer = ImageBuffer::create(templateSize, RenderingMode::Unaccelerated, 1);
     auto* layerImage = layerImageBuffer.get();
 #endif
 
     if (!layerImage)
         return;
@@ -897,11 +897,11 @@
     blurShadowBuffer(layerImage, templateSize);
 
     // Mask the image with the shadow color.
     GraphicsContext& shadowContext = layerImage.context();
     GraphicsContextStateSaver stateSaver(shadowContext);
-    shadowContext.setCompositeOperation(CompositeSourceIn);
+    shadowContext.setCompositeOperation(CompositeOperator::SourceIn);
     shadowContext.setFillColor(m_color);
     shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
 }
 
 void ShadowBlur::drawShadowLayer(const AffineTransform& transform, const IntRect& clipBounds, const FloatRect& layerArea, const DrawShadowCallback& drawShadow, const DrawBufferCallback& drawBuffer)
@@ -910,11 +910,11 @@
     if (!layerImageProperties)
         return;
 
     adjustBlurRadius(transform);
 
-    auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties->layerSize), Unaccelerated, 1);
+    auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties->layerSize), RenderingMode::Unaccelerated, 1);
     if (!layerImage)
         return;
 
     {
         GraphicsContext& shadowContext = layerImage->context();

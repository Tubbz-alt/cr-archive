<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascadeFonts.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006, 2013-2015 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FontCascadeFonts.h&quot;
 31 
 32 #include &quot;FontCache.h&quot;
 33 #include &quot;FontCascade.h&quot;
 34 #include &quot;GlyphPage.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 class MixedFontGlyphPage {
 39     WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     MixedFontGlyphPage(const GlyphPage* initialPage)
 42     {
 43         if (initialPage) {
 44             for (unsigned i = 0; i &lt; GlyphPage::size; ++i)
 45                 setGlyphDataForIndex(i, initialPage-&gt;glyphDataForIndex(i));
 46         }
 47     }
 48 
 49     GlyphData glyphDataForCharacter(UChar32 c) const
 50     {
 51         unsigned index = GlyphPage::indexForCodePoint(c);
 52         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; GlyphPage::size);
 53         return { m_glyphs[index], m_fonts[index] };
 54     }
 55 
 56     void setGlyphDataForCharacter(UChar32 c, GlyphData glyphData)
 57     {
 58         setGlyphDataForIndex(GlyphPage::indexForCodePoint(c), glyphData);
 59     }
 60 
 61 private:
 62     void setGlyphDataForIndex(unsigned index, const GlyphData&amp; glyphData)
 63     {
 64         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; GlyphPage::size);
 65         m_glyphs[index] = glyphData.glyph;
 66         m_fonts[index] = glyphData.font;
 67     }
 68 
 69     Glyph m_glyphs[GlyphPage::size] { };
 70     const Font* m_fonts[GlyphPage::size] { };
 71 };
 72 
 73 GlyphData FontCascadeFonts::GlyphPageCacheEntry::glyphDataForCharacter(UChar32 character)
 74 {
 75     ASSERT(!(m_singleFont &amp;&amp; m_mixedFont));
 76     if (m_singleFont)
 77         return m_singleFont-&gt;glyphDataForCharacter(character);
 78     if (m_mixedFont)
 79         return m_mixedFont-&gt;glyphDataForCharacter(character);
 80     return 0;
 81 }
 82 
 83 void FontCascadeFonts::GlyphPageCacheEntry::setGlyphDataForCharacter(UChar32 character, GlyphData glyphData)
 84 {
 85     ASSERT(!glyphDataForCharacter(character).glyph);
 86     if (!m_mixedFont) {
 87         m_mixedFont = makeUnique&lt;MixedFontGlyphPage&gt;(m_singleFont.get());
 88         m_singleFont = nullptr;
 89     }
 90     m_mixedFont-&gt;setGlyphDataForCharacter(character, glyphData);
 91 }
 92 
 93 void FontCascadeFonts::GlyphPageCacheEntry::setSingleFontPage(RefPtr&lt;GlyphPage&gt;&amp;&amp; page)
 94 {
 95     ASSERT(isNull());
 96     m_singleFont = page;
 97 }
 98 
<a name="1" id="anc1"></a><span class="line-added"> 99 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(FontCascadeFonts);</span>
<span class="line-added">100 </span>
101 FontCascadeFonts::FontCascadeFonts(RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector)
102     : m_cachedPrimaryFont(nullptr)
103     , m_fontSelector(fontSelector)
104     , m_fontSelectorVersion(m_fontSelector ? m_fontSelector-&gt;version() : 0)
105     , m_generation(FontCache::singleton().generation())
106 {
107 }
108 
109 FontCascadeFonts::FontCascadeFonts(const FontPlatformData&amp; platformData)
110     : m_cachedPrimaryFont(nullptr)
111     , m_fontSelectorVersion(0)
112     , m_generation(FontCache::singleton().generation())
113     , m_isForPlatformFont(true)
114 {
115     m_realizedFallbackRanges.append(FontRanges(FontCache::singleton().fontForPlatformData(platformData)));
116 }
117 
118 FontCascadeFonts::~FontCascadeFonts() = default;
119 
120 void FontCascadeFonts::determinePitch(const FontCascadeDescription&amp; description)
121 {
122     auto&amp; primaryRanges = realizeFallbackRangesAt(description, 0);
123     unsigned numRanges = primaryRanges.size();
124     if (numRanges == 1)
125         m_pitch = primaryRanges.fontForFirstRange().pitch();
126     else
127         m_pitch = VariablePitch;
128 }
129 
130 bool FontCascadeFonts::isLoadingCustomFonts() const
131 {
132     for (auto&amp; fontRanges : m_realizedFallbackRanges) {
133         if (fontRanges.isLoading())
134             return true;
135     }
136     return false;
137 }
138 
139 static FontRanges realizeNextFallback(const FontCascadeDescription&amp; description, unsigned&amp; index, FontSelector* fontSelector)
140 {
141     ASSERT(index &lt; description.effectiveFamilyCount());
142 
143     auto&amp; fontCache = FontCache::singleton();
144     while (index &lt; description.effectiveFamilyCount()) {
145         auto visitor = WTF::makeVisitor([&amp;](const AtomString&amp; family) -&gt; FontRanges {
146             if (family.isEmpty())
147                 return FontRanges();
148             if (fontSelector) {
149                 auto ranges = fontSelector-&gt;fontRangesForFamily(description, family);
150                 if (!ranges.isNull())
151                     return ranges;
152             }
153             if (auto font = fontCache.fontForFamily(description, family))
154                 return FontRanges(WTFMove(font));
155             return FontRanges();
156         }, [&amp;](const FontFamilyPlatformSpecification&amp; fontFamilySpecification) -&gt; FontRanges {
157             return fontFamilySpecification.fontRanges(description);
158         });
159         const auto&amp; currentFamily = description.effectiveFamilyAt(index++);
160         auto ranges = WTF::visit(visitor, currentFamily);
161         if (!ranges.isNull())
162             return ranges;
163     }
164     // We didn&#39;t find a font. Try to find a similar font using our own specific knowledge about our platform.
165     // For example on OS X, we know to map any families containing the words Arabic, Pashto, or Urdu to the
166     // Geeza Pro font.
167     for (auto&amp; family : description.families()) {
168         if (auto font = fontCache.similarFont(description, family))
169             return FontRanges(WTFMove(font));
170     }
171     return { };
172 }
173 
174 const FontRanges&amp; FontCascadeFonts::realizeFallbackRangesAt(const FontCascadeDescription&amp; description, unsigned index)
175 {
176     if (index &lt; m_realizedFallbackRanges.size())
177         return m_realizedFallbackRanges[index];
178 
179     ASSERT(index == m_realizedFallbackRanges.size());
180     ASSERT(FontCache::singleton().generation() == m_generation);
181 
182     m_realizedFallbackRanges.append(FontRanges());
183     auto&amp; fontRanges = m_realizedFallbackRanges.last();
184 
185     if (!index) {
186         fontRanges = realizeNextFallback(description, m_lastRealizedFallbackIndex, m_fontSelector.get());
187         if (fontRanges.isNull() &amp;&amp; m_fontSelector)
188             fontRanges = m_fontSelector-&gt;fontRangesForFamily(description, standardFamily);
189         if (fontRanges.isNull())
190             fontRanges = FontRanges(FontCache::singleton().lastResortFallbackFont(description));
191         return fontRanges;
192     }
193 
194     if (m_lastRealizedFallbackIndex &lt; description.effectiveFamilyCount())
195         fontRanges = realizeNextFallback(description, m_lastRealizedFallbackIndex, m_fontSelector.get());
196 
197     if (fontRanges.isNull() &amp;&amp; m_fontSelector) {
198         ASSERT(m_lastRealizedFallbackIndex &gt;= description.effectiveFamilyCount());
199 
200         unsigned fontSelectorFallbackIndex = m_lastRealizedFallbackIndex - description.effectiveFamilyCount();
201         if (fontSelectorFallbackIndex == m_fontSelector-&gt;fallbackFontCount())
202             return fontRanges;
203         ++m_lastRealizedFallbackIndex;
204         fontRanges = FontRanges(m_fontSelector-&gt;fallbackFontAt(description, fontSelectorFallbackIndex));
205     }
206 
207     return fontRanges;
208 }
209 
210 static inline bool isInRange(UChar32 character, UChar32 lowerBound, UChar32 upperBound)
211 {
212     return character &gt;= lowerBound &amp;&amp; character &lt;= upperBound;
213 }
214 
215 static bool shouldIgnoreRotation(UChar32 character)
216 {
217     if (character == 0x000A7 || character == 0x000A9 || character == 0x000AE)
218         return true;
219 
220     if (character == 0x000B6 || character == 0x000BC || character == 0x000BD || character == 0x000BE)
221         return true;
222 
223     if (isInRange(character, 0x002E5, 0x002EB))
224         return true;
225 
226     if (isInRange(character, 0x01100, 0x011FF) || isInRange(character, 0x01401, 0x0167F) || isInRange(character, 0x01800, 0x018FF))
227         return true;
228 
229     if (character == 0x02016 || character == 0x02020 || character == 0x02021 || character == 0x2030 || character == 0x02031)
230         return true;
231 
232     if (isInRange(character, 0x0203B, 0x0203D) || character == 0x02042 || character == 0x02044 || character == 0x02047
233         || character == 0x02048 || character == 0x02049 || character == 0x2051)
234         return true;
235 
236     if (isInRange(character, 0x02065, 0x02069) || isInRange(character, 0x020DD, 0x020E0)
237         || isInRange(character, 0x020E2, 0x020E4) || isInRange(character, 0x02100, 0x02117)
238         || isInRange(character, 0x02119, 0x02131) || isInRange(character, 0x02133, 0x0213F))
239         return true;
240 
241     if (isInRange(character, 0x02145, 0x0214A) || character == 0x0214C || character == 0x0214D
242         || isInRange(character, 0x0214F, 0x0218F))
243         return true;
244 
245     if (isInRange(character, 0x02300, 0x02307) || isInRange(character, 0x0230C, 0x0231F)
246         || isInRange(character, 0x02322, 0x0232B) || isInRange(character, 0x0237D, 0x0239A)
247         || isInRange(character, 0x023B4, 0x023B6) || isInRange(character, 0x023BA, 0x023CF)
248         || isInRange(character, 0x023D1, 0x023DB) || isInRange(character, 0x023E2, 0x024FF))
249         return true;
250 
251     if (isInRange(character, 0x025A0, 0x02619) || isInRange(character, 0x02620, 0x02767)
252         || isInRange(character, 0x02776, 0x02793) || isInRange(character, 0x02B12, 0x02B2F)
253         || isInRange(character, 0x02B4D, 0x02BFF) || isInRange(character, 0x02E80, 0x03007))
254         return true;
255 
256     if (character == 0x03012 || character == 0x03013 || isInRange(character, 0x03020, 0x0302F)
257         || isInRange(character, 0x03031, 0x0309F) || isInRange(character, 0x030A1, 0x030FB)
258         || isInRange(character, 0x030FD, 0x0A4CF))
259         return true;
260 
261     if (isInRange(character, 0x0A840, 0x0A87F) || isInRange(character, 0x0A960, 0x0A97F)
262         || isInRange(character, 0x0AC00, 0x0D7FF) || isInRange(character, 0x0E000, 0x0FAFF))
263         return true;
264 
265     if (isInRange(character, 0x0FE10, 0x0FE1F) || isInRange(character, 0x0FE30, 0x0FE48)
266         || isInRange(character, 0x0FE50, 0x0FE57) || isInRange(character, 0x0FE5F, 0x0FE62)
267         || isInRange(character, 0x0FE67, 0x0FE6F))
268         return true;
269 
270     if (isInRange(character, 0x0FF01, 0x0FF07) || isInRange(character, 0x0FF0A, 0x0FF0C)
271         || isInRange(character, 0x0FF0E, 0x0FF19) || character == 0x0FF1B || isInRange(character, 0x0FF1F, 0x0FF3A))
272         return true;
273 
274     if (character == 0x0FF3C || character == 0x0FF3E)
275         return true;
276 
277     if (isInRange(character, 0x0FF40, 0x0FF5A) || isInRange(character, 0x0FFE0, 0x0FFE2)
278         || isInRange(character, 0x0FFE4, 0x0FFE7) || isInRange(character, 0x0FFF0, 0x0FFF8)
279         || character == 0x0FFFD)
280         return true;
281 
282     if (isInRange(character, 0x13000, 0x1342F) || isInRange(character, 0x1B000, 0x1B0FF)
283         || isInRange(character, 0x1D000, 0x1D1FF) || isInRange(character, 0x1D300, 0x1D37F)
284         || isInRange(character, 0x1F000, 0x1F64F) || isInRange(character, 0x1F680, 0x1F77F))
285         return true;
286 
287     if (isInRange(character, 0x20000, 0x2FFFD) || isInRange(character, 0x30000, 0x3FFFD))
288         return true;
289 
290     return false;
291 }
292 
293 static GlyphData glyphDataForNonCJKCharacterWithGlyphOrientation(UChar32 character, NonCJKGlyphOrientation orientation, const GlyphData&amp; data)
294 {
295     bool syntheticOblique = data.font-&gt;platformData().syntheticOblique();
296     if (orientation == NonCJKGlyphOrientation::Upright || shouldIgnoreRotation(character)) {
297         GlyphData uprightData = data.font-&gt;uprightOrientationFont().glyphDataForCharacter(character);
298         // If the glyphs are the same, then we know we can just use the horizontal glyph rotated vertically
299         // to be upright. For synthetic oblique, however, we will always return the uprightData to ensure
300         // that non-CJK and CJK runs are broken up. This guarantees that vertical
301         // fonts without isTextOrientationFallback() set contain CJK characters only and thus we can get
302         // the oblique slant correct.
303         if (data.glyph == uprightData.glyph &amp;&amp; !syntheticOblique)
304             return data;
305         // The glyphs are distinct, meaning that the font has a vertical-right glyph baked into it. We can&#39;t use that
306         // glyph, so we fall back to the upright data and use the horizontal glyph.
307         if (uprightData.font)
308             return uprightData;
309     } else if (orientation == NonCJKGlyphOrientation::Mixed) {
310         GlyphData verticalRightData = data.font-&gt;verticalRightOrientationFont().glyphDataForCharacter(character);
311 
312         // If there is a baked-in rotated glyph, we will use it unless syntheticOblique is set. If
313         // synthetic oblique is set, we fall back to the horizontal glyph. This guarantees that vertical
314         // fonts without isTextOrientationFallback() set contain CJK characters only and thus we can get
315         // the oblique slant correct.
316         if (data.glyph != verticalRightData.glyph &amp;&amp; !syntheticOblique)
317             return data;
318 
319         // The glyphs are identical, meaning that we should just use the horizontal glyph.
320         if (verticalRightData.font)
321             return verticalRightData;
322     }
323     return data;
324 }
325 
326 static const Font* findBestFallbackFont(FontCascadeFonts&amp; fontCascadeFonts, const FontCascadeDescription&amp; description, UChar32 character)
327 {
328     for (unsigned fallbackIndex = 0; ; ++fallbackIndex) {
329         auto&amp; fontRanges = fontCascadeFonts.realizeFallbackRangesAt(description, fallbackIndex);
330         if (fontRanges.isNull())
331             break;
332         auto* currentFont = fontRanges.glyphDataForCharacter(character, ExternalResourceDownloadPolicy::Forbid).font;
333         if (!currentFont)
334             currentFont = &amp;fontRanges.fontForFirstRange();
335 
336         if (!currentFont-&gt;isInterstitial())
337             return currentFont;
338     }
339 
340     return nullptr;
341 }
342 
343 GlyphData FontCascadeFonts::glyphDataForSystemFallback(UChar32 character, const FontCascadeDescription&amp; description, FontVariant variant, bool systemFallbackShouldBeInvisible)
344 {
345     const Font* font = findBestFallbackFont(*this, description, character);
346 
347     if (!font)
348         font = &amp;realizeFallbackRangesAt(description, 0).fontForFirstRange();
349 
350     auto systemFallbackFont = font-&gt;systemFallbackFontForCharacter(character, description, m_isForPlatformFont ? IsForPlatformFont::Yes : IsForPlatformFont::No);
351     if (!systemFallbackFont)
352         return GlyphData();
353 
354 #if HAVE(DISALLOWABLE_USER_INSTALLED_FONTS)
355     ASSERT(!systemFallbackFont-&gt;isUserInstalledFont() || description.shouldAllowUserInstalledFonts() == AllowUserInstalledFonts::Yes);
356 #endif
357 
358     if (systemFallbackShouldBeInvisible)
359         systemFallbackFont = const_cast&lt;Font*&gt;(&amp;systemFallbackFont-&gt;invisibleFont());
360 
361     if (systemFallbackFont-&gt;platformData().orientation() == FontOrientation::Vertical &amp;&amp; !systemFallbackFont-&gt;hasVerticalGlyphs() &amp;&amp; FontCascade::isCJKIdeographOrSymbol(character))
362         variant = BrokenIdeographVariant;
363 
364     GlyphData fallbackGlyphData;
365     if (variant == NormalVariant)
366         fallbackGlyphData = systemFallbackFont-&gt;glyphDataForCharacter(character);
367     else
368         fallbackGlyphData = systemFallbackFont-&gt;variantFont(description, variant)-&gt;glyphDataForCharacter(character);
369 
370     if (fallbackGlyphData.font &amp;&amp; fallbackGlyphData.font-&gt;platformData().orientation() == FontOrientation::Vertical &amp;&amp; !fallbackGlyphData.font-&gt;isTextOrientationFallback()) {
371         if (variant == NormalVariant &amp;&amp; !FontCascade::isCJKIdeographOrSymbol(character))
372             fallbackGlyphData = glyphDataForNonCJKCharacterWithGlyphOrientation(character, description.nonCJKGlyphOrientation(), fallbackGlyphData);
373     }
374 
375     // Keep the system fallback fonts we use alive.
376     if (fallbackGlyphData.glyph)
377         m_systemFallbackFontSet.add(WTFMove(systemFallbackFont));
378 
379     return fallbackGlyphData;
380 }
381 
382 enum class FallbackVisibility {
383     Immaterial,
384     Visible,
385     Invisible
386 };
387 
388 static void opportunisticallyStartFontDataURLLoading(const FontCascadeDescription&amp; description, FontSelector* fontSelector)
389 {
390     // It is a somewhat common practice for a font foundry to break up a single font into two fonts, each having a random half of
391     // the alphabet, and then encoding the two fonts as data: urls (with different font-family names).
392     // Therefore, if these two fonts don&#39;t get loaded at (nearly) the same time, there will be a flash of unintelligible text where
393     // only a random half of the letters are visible.
394     // This code attempts to pre-warm these data urls to make them load at closer to the same time. However, font loading is
395     // asynchronous, and this code doesn&#39;t actually fix the race - it just makes it more likely for the two fonts to tie in the race.
396     if (!fontSelector)
397         return;
398     for (unsigned i = 0; i &lt; description.familyCount(); ++i)
399         fontSelector-&gt;opportunisticallyStartFontDataURLLoading(description, description.familyAt(i));
400 }
401 
402 GlyphData FontCascadeFonts::glyphDataForVariant(UChar32 character, const FontCascadeDescription&amp; description, FontVariant variant, unsigned fallbackIndex)
403 {
404     FallbackVisibility fallbackVisibility = FallbackVisibility::Immaterial;
405     ExternalResourceDownloadPolicy policy = ExternalResourceDownloadPolicy::Allow;
406     GlyphData loadingResult;
407     opportunisticallyStartFontDataURLLoading(description, m_fontSelector.get());
408     for (; ; ++fallbackIndex) {
409         auto&amp; fontRanges = realizeFallbackRangesAt(description, fallbackIndex);
410         if (fontRanges.isNull())
411             break;
412 
413         GlyphData data = fontRanges.glyphDataForCharacter(character, policy);
414         if (!data.font)
415             continue;
416 
417         if (data.font-&gt;isInterstitial()) {
418             policy = ExternalResourceDownloadPolicy::Forbid;
419             if (fallbackVisibility == FallbackVisibility::Immaterial)
420                 fallbackVisibility = data.font-&gt;visibility() == Font::Visibility::Visible ? FallbackVisibility::Visible : FallbackVisibility::Invisible;
421             if (!loadingResult.font &amp;&amp; data.glyph)
422                 loadingResult = data;
423             continue;
424         }
425 
426         if (fallbackVisibility == FallbackVisibility::Invisible &amp;&amp; data.font-&gt;visibility() == Font::Visibility::Visible)
427             data.font = &amp;data.font-&gt;invisibleFont();
428 
429         if (variant == NormalVariant) {
430             if (data.font-&gt;platformData().orientation() == FontOrientation::Vertical &amp;&amp; !data.font-&gt;isTextOrientationFallback()) {
431                 if (!FontCascade::isCJKIdeographOrSymbol(character))
432                     return glyphDataForNonCJKCharacterWithGlyphOrientation(character, description.nonCJKGlyphOrientation(), data);
433 
434                 if (!data.font-&gt;hasVerticalGlyphs()) {
435                     // Use the broken ideograph font data. The broken ideograph font will use the horizontal width of glyphs
436                     // to make sure you get a square (even for broken glyphs like symbols used for punctuation).
437                     return glyphDataForVariant(character, description, BrokenIdeographVariant, fallbackIndex);
438                 }
439             }
440         } else {
441             // The variantFont function should not normally return 0.
442             // But if it does, we will just render the capital letter big.
443             if (const Font* variantFont = data.font-&gt;variantFont(description, variant))
444                 return variantFont-&gt;glyphDataForCharacter(character);
445         }
446 
447         return data;
448     }
449 
450     if (loadingResult.font)
451         return loadingResult;
452     return glyphDataForSystemFallback(character, description, variant, fallbackVisibility == FallbackVisibility::Invisible);
453 }
454 
455 static RefPtr&lt;GlyphPage&gt; glyphPageFromFontRanges(unsigned pageNumber, const FontRanges&amp; fontRanges)
456 {
457     const Font* font = nullptr;
458     UChar32 pageRangeFrom = pageNumber * GlyphPage::size;
459     UChar32 pageRangeTo = pageRangeFrom + GlyphPage::size - 1;
460     auto policy = ExternalResourceDownloadPolicy::Allow;
461     FallbackVisibility desiredVisibility = FallbackVisibility::Immaterial;
462     for (unsigned i = 0; i &lt; fontRanges.size(); ++i) {
463         auto&amp; range = fontRanges.rangeAt(i);
464         if (range.from() &lt;= pageRangeFrom &amp;&amp; pageRangeTo &lt;= range.to()) {
465             font = range.font(policy);
466             if (!font)
467                 continue;
468             if (font-&gt;isInterstitial()) {
469                 if (desiredVisibility == FallbackVisibility::Immaterial) {
470                     auto fontVisibility = font-&gt;visibility();
471                     if (fontVisibility == Font::Visibility::Visible)
472                         desiredVisibility = FallbackVisibility::Visible;
473                     else {
474                         ASSERT(fontVisibility == Font::Visibility::Invisible);
475                         desiredVisibility = FallbackVisibility::Invisible;
476                     }
477                 }
478                 font = nullptr;
479                 policy = ExternalResourceDownloadPolicy::Forbid;
480                 continue;
481             }
482         }
483         break;
484     }
485     if (!font || font-&gt;platformData().orientation() == FontOrientation::Vertical)
486         return nullptr;
487 
488     if (desiredVisibility == FallbackVisibility::Invisible &amp;&amp; font-&gt;visibility() == Font::Visibility::Visible)
489         return const_cast&lt;GlyphPage*&gt;(font-&gt;invisibleFont().glyphPage(pageNumber));
490     return const_cast&lt;GlyphPage*&gt;(font-&gt;glyphPage(pageNumber));
491 }
492 
493 GlyphData FontCascadeFonts::glyphDataForCharacter(UChar32 c, const FontCascadeDescription&amp; description, FontVariant variant)
494 {
495     ASSERT(isMainThread());
496     ASSERT(variant != AutoVariant);
497 
498     if (variant != NormalVariant)
499         return glyphDataForVariant(c, description, variant);
500 
501     const unsigned pageNumber = GlyphPage::pageNumberForCodePoint(c);
502 
503     auto&amp; cacheEntry = pageNumber ? m_cachedPages.add(pageNumber, GlyphPageCacheEntry()).iterator-&gt;value : m_cachedPageZero;
504 
505     // Initialize cache with a full page of glyph mappings from a single font.
506     if (cacheEntry.isNull())
507         cacheEntry.setSingleFontPage(glyphPageFromFontRanges(pageNumber, realizeFallbackRangesAt(description, 0)));
508 
509     GlyphData glyphData = cacheEntry.glyphDataForCharacter(c);
510     if (!glyphData.glyph) {
511         // No glyph, resolve per-character.
512         ASSERT(variant == NormalVariant);
513         glyphData = glyphDataForVariant(c, description, variant);
514         // Cache the results.
515         cacheEntry.setGlyphDataForCharacter(c, glyphData);
516     }
517 
518     return glyphData;
519 }
520 
521 void FontCascadeFonts::pruneSystemFallbacks()
522 {
523     if (m_systemFallbackFontSet.isEmpty())
524         return;
525     // Mutable glyph pages may reference fallback fonts.
526     if (m_cachedPageZero.isMixedFont())
527         m_cachedPageZero = { };
528     m_cachedPages.removeIf([](auto&amp; keyAndValue) {
529         return keyAndValue.value.isMixedFont();
530     });
531     m_systemFallbackFontSet.clear();
532 }
533 
534 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
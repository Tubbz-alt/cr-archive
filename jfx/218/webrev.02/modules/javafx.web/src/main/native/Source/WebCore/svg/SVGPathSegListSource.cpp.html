<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGPathSegListSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  3  * Copyright (C) 2019 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;SVGPathSegListSource.h&quot;
 23 
 24 #include &quot;SVGPathSeg.h&quot;
 25 #include &quot;SVGPathSegList.h&quot;
 26 #include &quot;SVGPathSegValue.h&quot;
 27 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 28 
 29 namespace WebCore {
 30 
 31 SVGPathSegListSource::SVGPathSegListSource(const SVGPathSegList&amp; pathSegList)
 32     : m_pathSegList(pathSegList)
 33 {
 34     m_itemCurrent = 0;
 35     m_itemEnd = m_pathSegList.size();
 36 }
 37 
 38 bool SVGPathSegListSource::hasMoreData() const
 39 {
 40     return m_itemCurrent &lt; m_itemEnd;
 41 }
 42 
 43 bool SVGPathSegListSource::parseSVGSegmentType(SVGPathSegType&amp; pathSegType)
 44 {
 45     m_segment = m_pathSegList.at(m_itemCurrent);
 46     pathSegType = static_cast&lt;SVGPathSegType&gt;(m_segment-&gt;pathSegType());
 47     ++m_itemCurrent;
 48     return true;
 49 }
 50 
 51 SVGPathSegType SVGPathSegListSource::nextCommand(SVGPathSegType)
 52 {
 53     m_segment = m_pathSegList.at(m_itemCurrent);
 54     SVGPathSegType pathSegType = static_cast&lt;SVGPathSegType&gt;(m_segment-&gt;pathSegType());
 55     ++m_itemCurrent;
 56     return pathSegType;
 57 }
 58 
 59 bool SVGPathSegListSource::parseMoveToSegment(FloatPoint&amp; targetPoint)
 60 {
 61     ASSERT(m_segment);
 62     ASSERT(m_segment-&gt;pathSegType() == PathSegMoveToAbs || m_segment-&gt;pathSegType() == PathSegMoveToRel);
 63     SVGPathSegSingleCoordinate* moveTo = static_cast&lt;SVGPathSegSingleCoordinate*&gt;(m_segment.get());
 64     targetPoint = FloatPoint(moveTo-&gt;x(), moveTo-&gt;y());
 65     return true;
 66 }
 67 
 68 bool SVGPathSegListSource::parseLineToSegment(FloatPoint&amp; targetPoint)
 69 {
 70     ASSERT(m_segment);
 71     ASSERT(m_segment-&gt;pathSegType() == PathSegLineToAbs || m_segment-&gt;pathSegType() == PathSegLineToRel);
 72     SVGPathSegSingleCoordinate* lineTo = static_cast&lt;SVGPathSegSingleCoordinate*&gt;(m_segment.get());
 73     targetPoint = FloatPoint(lineTo-&gt;x(), lineTo-&gt;y());
 74     return true;
 75 }
 76 
 77 bool SVGPathSegListSource::parseLineToHorizontalSegment(float&amp; x)
 78 {
 79     ASSERT(m_segment);
 80     ASSERT(m_segment-&gt;pathSegType() == PathSegLineToHorizontalAbs || m_segment-&gt;pathSegType() == PathSegLineToHorizontalRel);
 81     SVGPathSegLinetoHorizontal* horizontal = static_cast&lt;SVGPathSegLinetoHorizontal*&gt;(m_segment.get());
 82     x = horizontal-&gt;x();
 83     return true;
 84 }
 85 
 86 bool SVGPathSegListSource::parseLineToVerticalSegment(float&amp; y)
 87 {
 88     ASSERT(m_segment);
 89     ASSERT(m_segment-&gt;pathSegType() == PathSegLineToVerticalAbs || m_segment-&gt;pathSegType() == PathSegLineToVerticalRel);
 90     SVGPathSegLinetoVertical* vertical = static_cast&lt;SVGPathSegLinetoVertical*&gt;(m_segment.get());
 91     y = vertical-&gt;y();
 92     return true;
 93 }
 94 
 95 bool SVGPathSegListSource::parseCurveToCubicSegment(FloatPoint&amp; point1, FloatPoint&amp; point2, FloatPoint&amp; targetPoint)
 96 {
 97     ASSERT(m_segment);
 98     ASSERT(m_segment-&gt;pathSegType() == PathSegCurveToCubicAbs || m_segment-&gt;pathSegType() == PathSegCurveToCubicRel);
 99     SVGPathSegCurvetoCubic* cubic = static_cast&lt;SVGPathSegCurvetoCubic*&gt;(m_segment.get());
100     point1 = FloatPoint(cubic-&gt;x1(), cubic-&gt;y1());
101     point2 = FloatPoint(cubic-&gt;x2(), cubic-&gt;y2());
102     targetPoint = FloatPoint(cubic-&gt;x(), cubic-&gt;y());
103     return true;
104 }
105 
106 bool SVGPathSegListSource::parseCurveToCubicSmoothSegment(FloatPoint&amp; point2, FloatPoint&amp; targetPoint)
107 {
108     ASSERT(m_segment);
109     ASSERT(m_segment-&gt;pathSegType() == PathSegCurveToCubicSmoothAbs || m_segment-&gt;pathSegType() == PathSegCurveToCubicSmoothRel);
110     SVGPathSegCurvetoCubicSmooth* cubicSmooth = static_cast&lt;SVGPathSegCurvetoCubicSmooth*&gt;(m_segment.get());
111     point2 = FloatPoint(cubicSmooth-&gt;x2(), cubicSmooth-&gt;y2());
112     targetPoint = FloatPoint(cubicSmooth-&gt;x(), cubicSmooth-&gt;y());
113     return true;
114 }
115 
116 bool SVGPathSegListSource::parseCurveToQuadraticSegment(FloatPoint&amp; point1, FloatPoint&amp; targetPoint)
117 {
118     ASSERT(m_segment);
119     ASSERT(m_segment-&gt;pathSegType() == PathSegCurveToQuadraticAbs || m_segment-&gt;pathSegType() == PathSegCurveToQuadraticRel);
120     SVGPathSegCurvetoQuadratic* quadratic = static_cast&lt;SVGPathSegCurvetoQuadratic*&gt;(m_segment.get());
121     point1 = FloatPoint(quadratic-&gt;x1(), quadratic-&gt;y1());
122     targetPoint = FloatPoint(quadratic-&gt;x(), quadratic-&gt;y());
123     return true;
124 }
125 
126 bool SVGPathSegListSource::parseCurveToQuadraticSmoothSegment(FloatPoint&amp; targetPoint)
127 {
128     ASSERT(m_segment);
129     ASSERT(m_segment-&gt;pathSegType() == PathSegCurveToQuadraticSmoothAbs || m_segment-&gt;pathSegType() == PathSegCurveToQuadraticSmoothRel);
130     SVGPathSegSingleCoordinate* quadraticSmooth = static_cast&lt;SVGPathSegSingleCoordinate*&gt;(m_segment.get());
131     targetPoint = FloatPoint(quadraticSmooth-&gt;x(), quadraticSmooth-&gt;y());
132     return true;
133 }
134 
135 bool SVGPathSegListSource::parseArcToSegment(float&amp; rx, float&amp; ry, float&amp; angle, bool&amp; largeArc, bool&amp; sweep, FloatPoint&amp; targetPoint)
136 {
137     ASSERT(m_segment);
138     ASSERT(m_segment-&gt;pathSegType() == PathSegArcAbs || m_segment-&gt;pathSegType() == PathSegArcRel);
139     SVGPathSegArc* arcTo = static_cast&lt;SVGPathSegArc*&gt;(m_segment.get());
140     rx = arcTo-&gt;r1();
141     ry = arcTo-&gt;r2();
142     angle = arcTo-&gt;angle();
143     largeArc = arcTo-&gt;largeArcFlag();
144     sweep = arcTo-&gt;sweepFlag();
145     targetPoint = FloatPoint(arcTo-&gt;x(), arcTo-&gt;y());
146     return true;
147 }
148 
149 }
    </pre>
  </body>
</html>
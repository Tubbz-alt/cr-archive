<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WeakBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakSet.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/WeakSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WeakSet.h&quot;
 28 
 29 #include &quot;Heap.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;VM.h&quot;
 32 
 33 namespace JSC {
 34 
 35 WeakSet::~WeakSet()
 36 {
 37     if (isOnList())
 38         remove();
 39 
 40     Heap&amp; heap = *this-&gt;heap();
<span class="line-modified"> 41     WeakBlock* next = 0;</span>
 42     for (WeakBlock* block = m_blocks.head(); block; block = next) {
 43         next = block-&gt;next();
 44         WeakBlock::destroy(heap, block);
 45     }
 46     m_blocks.clear();
 47 }
 48 
 49 void WeakSet::sweep()
 50 {
 51     for (WeakBlock* block = m_blocks.head(); block;) {
 52         heap()-&gt;sweepNextLogicallyEmptyWeakBlock();
 53 
 54         WeakBlock* nextBlock = block-&gt;next();
 55         block-&gt;sweep();
 56         if (block-&gt;isLogicallyEmptyButNotFree()) {
 57             // If this WeakBlock is logically empty, but still has Weaks pointing into it,
 58             // we can&#39;t destroy it just yet. Detach it from the WeakSet and hand ownership
<span class="line-modified"> 59             // to the Heap so we don&#39;t pin down the entire MarkedBlock or LargeAllocation.</span>
 60             m_blocks.remove(block);
 61             heap()-&gt;addLogicallyEmptyWeakBlock(block);
 62             block-&gt;disconnectContainer();
 63         }
 64         block = nextBlock;
 65     }
 66 
 67     resetAllocator();
 68 }
 69 
 70 void WeakSet::shrink()
 71 {
 72     WeakBlock* next;
 73     for (WeakBlock* block = m_blocks.head(); block; block = next) {
 74         next = block-&gt;next();
 75 
 76         if (block-&gt;isEmpty())
 77             removeAllocator(block);
 78     }
 79 
 80     resetAllocator();
 81 
 82     if (m_blocks.isEmpty() &amp;&amp; isOnList())
 83         remove();
 84 }
 85 
<span class="line-modified"> 86 WeakBlock::FreeCell* WeakSet::findAllocator()</span>
 87 {
 88     if (WeakBlock::FreeCell* allocator = tryFindAllocator())
 89         return allocator;
 90 
<span class="line-modified"> 91     return addAllocator();</span>
 92 }
 93 
 94 WeakBlock::FreeCell* WeakSet::tryFindAllocator()
 95 {
 96     while (m_nextAllocator) {
 97         WeakBlock* block = m_nextAllocator;
 98         m_nextAllocator = m_nextAllocator-&gt;next();
 99 
100         WeakBlock::SweepResult sweepResult = block-&gt;takeSweepResult();
101         if (sweepResult.freeList)
102             return sweepResult.freeList;
103     }
104 
105     return 0;
106 }
107 
<span class="line-modified">108 WeakBlock::FreeCell* WeakSet::addAllocator()</span>
109 {
110     if (!isOnList())
111         heap()-&gt;objectSpace().addActiveWeakSet(this);
112 
<span class="line-modified">113     WeakBlock* block = WeakBlock::create(*heap(), m_container);</span>
114     heap()-&gt;didAllocate(WeakBlock::blockSize);
115     m_blocks.append(block);
116     WeakBlock::SweepResult sweepResult = block-&gt;takeSweepResult();
117     ASSERT(!sweepResult.isNull() &amp;&amp; sweepResult.freeList);
118     return sweepResult.freeList;
119 }
120 
121 void WeakSet::removeAllocator(WeakBlock* block)
122 {
123     m_blocks.remove(block);
124     WeakBlock::destroy(*heap(), block);
125 }
126 
127 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WeakSet.h&quot;
 28 
 29 #include &quot;Heap.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;VM.h&quot;
 32 
 33 namespace JSC {
 34 
 35 WeakSet::~WeakSet()
 36 {
 37     if (isOnList())
 38         remove();
 39 
 40     Heap&amp; heap = *this-&gt;heap();
<span class="line-modified"> 41     WeakBlock* next = nullptr;</span>
 42     for (WeakBlock* block = m_blocks.head(); block; block = next) {
 43         next = block-&gt;next();
 44         WeakBlock::destroy(heap, block);
 45     }
 46     m_blocks.clear();
 47 }
 48 
 49 void WeakSet::sweep()
 50 {
 51     for (WeakBlock* block = m_blocks.head(); block;) {
 52         heap()-&gt;sweepNextLogicallyEmptyWeakBlock();
 53 
 54         WeakBlock* nextBlock = block-&gt;next();
 55         block-&gt;sweep();
 56         if (block-&gt;isLogicallyEmptyButNotFree()) {
 57             // If this WeakBlock is logically empty, but still has Weaks pointing into it,
 58             // we can&#39;t destroy it just yet. Detach it from the WeakSet and hand ownership
<span class="line-modified"> 59             // to the Heap so we don&#39;t pin down the entire MarkedBlock or PreciseAllocation.</span>
 60             m_blocks.remove(block);
 61             heap()-&gt;addLogicallyEmptyWeakBlock(block);
 62             block-&gt;disconnectContainer();
 63         }
 64         block = nextBlock;
 65     }
 66 
 67     resetAllocator();
 68 }
 69 
 70 void WeakSet::shrink()
 71 {
 72     WeakBlock* next;
 73     for (WeakBlock* block = m_blocks.head(); block; block = next) {
 74         next = block-&gt;next();
 75 
 76         if (block-&gt;isEmpty())
 77             removeAllocator(block);
 78     }
 79 
 80     resetAllocator();
 81 
 82     if (m_blocks.isEmpty() &amp;&amp; isOnList())
 83         remove();
 84 }
 85 
<span class="line-modified"> 86 WeakBlock::FreeCell* WeakSet::findAllocator(CellContainer container)</span>
 87 {
 88     if (WeakBlock::FreeCell* allocator = tryFindAllocator())
 89         return allocator;
 90 
<span class="line-modified"> 91     return addAllocator(container);</span>
 92 }
 93 
 94 WeakBlock::FreeCell* WeakSet::tryFindAllocator()
 95 {
 96     while (m_nextAllocator) {
 97         WeakBlock* block = m_nextAllocator;
 98         m_nextAllocator = m_nextAllocator-&gt;next();
 99 
100         WeakBlock::SweepResult sweepResult = block-&gt;takeSweepResult();
101         if (sweepResult.freeList)
102             return sweepResult.freeList;
103     }
104 
105     return 0;
106 }
107 
<span class="line-modified">108 WeakBlock::FreeCell* WeakSet::addAllocator(CellContainer container)</span>
109 {
110     if (!isOnList())
111         heap()-&gt;objectSpace().addActiveWeakSet(this);
112 
<span class="line-modified">113     WeakBlock* block = WeakBlock::create(*heap(), container);</span>
114     heap()-&gt;didAllocate(WeakBlock::blockSize);
115     m_blocks.append(block);
116     WeakBlock::SweepResult sweepResult = block-&gt;takeSweepResult();
117     ASSERT(!sweepResult.isNull() &amp;&amp; sweepResult.freeList);
118     return sweepResult.freeList;
119 }
120 
121 void WeakSet::removeAllocator(WeakBlock* block)
122 {
123     m_blocks.remove(block);
124     WeakBlock::destroy(*heap(), block);
125 }
126 
127 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="WeakBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WeakSet.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSExecState.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSExecState.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSExecStateInstrumentation.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSExecState.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,132 ***</span>
  #include &lt;wtf/ForbidHeapAllocation.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  
<span class="line-removed">- class InspectorInstrumentationCookie;</span>
  class ScriptExecutionContext;
  
  class JSExecState {
      WTF_MAKE_NONCOPYABLE(JSExecState);
      WTF_FORBID_HEAP_ALLOCATION;
      friend class JSMainThreadNullState;
  public:
<span class="line-modified">!     static JSC::ExecState* currentState()</span>
      {
          return threadGlobalData().currentState();
      };
  
<span class="line-modified">!     static JSC::JSValue call(JSC::ExecState* exec, JSC::JSValue functionObject, JSC::CallType callType, const JSC::CallData&amp; callData, JSC::JSValue thisValue, const JSC::ArgList&amp; args, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(exec);</span>
<span class="line-modified">!         return JSC::call(exec, functionObject, callType, callData, thisValue, args, returnedException);</span>
      };
  
<span class="line-modified">!     static JSC::JSValue evaluate(JSC::ExecState* exec, const JSC::SourceCode&amp; source, JSC::JSValue thisValue, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(exec);</span>
<span class="line-modified">!         return JSC::evaluate(exec, source, thisValue, returnedException);</span>
      };
  
<span class="line-modified">!     static JSC::JSValue evaluate(JSC::ExecState* exec, const JSC::SourceCode&amp; source, JSC::JSValue thisValue = JSC::JSValue())</span>
      {
          NakedPtr&lt;JSC::Exception&gt; unused;
<span class="line-modified">!         return evaluate(exec, source, thisValue, unused);</span>
      };
  
<span class="line-modified">!     static JSC::JSValue profiledCall(JSC::ExecState* exec, JSC::ProfilingReason reason, JSC::JSValue functionObject, JSC::CallType callType, const JSC::CallData&amp; callData, JSC::JSValue thisValue, const JSC::ArgList&amp; args, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(exec);</span>
<span class="line-modified">!         return JSC::profiledCall(exec, reason, functionObject, callType, callData, thisValue, args, returnedException);</span>
      }
  
<span class="line-modified">!     static JSC::JSValue profiledEvaluate(JSC::ExecState* exec, JSC::ProfilingReason reason, const JSC::SourceCode&amp; source, JSC::JSValue thisValue, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(exec);</span>
<span class="line-modified">!         return JSC::profiledEvaluate(exec, reason, source, thisValue, returnedException);</span>
      }
  
<span class="line-modified">!     static JSC::JSValue profiledEvaluate(JSC::ExecState* exec, JSC::ProfilingReason reason, const JSC::SourceCode&amp; source, JSC::JSValue thisValue = JSC::JSValue())</span>
      {
          NakedPtr&lt;JSC::Exception&gt; unused;
<span class="line-modified">!         return profiledEvaluate(exec, reason, source, thisValue, unused);</span>
      }
  
<span class="line-modified">!     static void runTask(JSC::ExecState* exec, JSC::Microtask&amp; task)</span>
      {
<span class="line-modified">!         JSExecState currentState(exec);</span>
<span class="line-modified">!         task.run(exec);</span>
      }
  
<span class="line-modified">!     static JSC::JSInternalPromise&amp; loadModule(JSC::ExecState&amp; state, const String&amp; moduleName, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
      {
<span class="line-modified">!         JSExecState currentState(&amp;state);</span>
<span class="line-modified">!         return *JSC::loadModule(&amp;state, moduleName, parameters, scriptFetcher);</span>
      }
  
<span class="line-modified">!     static JSC::JSInternalPromise&amp; loadModule(JSC::ExecState&amp; state, const JSC::SourceCode&amp; sourceCode, JSC::JSValue scriptFetcher)</span>
      {
<span class="line-modified">!         JSExecState currentState(&amp;state);</span>
<span class="line-modified">!         return *JSC::loadModule(&amp;state, sourceCode, scriptFetcher);</span>
      }
  
<span class="line-modified">!     static JSC::JSValue linkAndEvaluateModule(JSC::ExecState&amp; state, const JSC::Identifier&amp; moduleKey, JSC::JSValue scriptFetcher, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSC::VM&amp; vm = state.vm();</span>
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         JSExecState currentState(&amp;state);</span>
<span class="line-modified">!         auto returnValue = JSC::linkAndEvaluateModule(&amp;state, moduleKey, scriptFetcher);</span>
          if (UNLIKELY(scope.exception())) {
              returnedException = scope.exception();
              scope.clearException();
              return JSC::jsUndefined();
          }
          return returnValue;
      }
  
<span class="line-modified">!     static InspectorInstrumentationCookie instrumentFunctionCall(ScriptExecutionContext*, JSC::CallType, const JSC::CallData&amp;);</span>
<span class="line-modified">!     static InspectorInstrumentationCookie instrumentFunctionConstruct(ScriptExecutionContext*, JSC::ConstructType, const JSC::ConstructData&amp;);</span>
  
  private:
<span class="line-modified">!     explicit JSExecState(JSC::ExecState* exec)</span>
          : m_previousState(currentState())
<span class="line-modified">!         , m_lock(exec)</span>
      {
<span class="line-modified">!         setCurrentState(exec);</span>
      };
  
      ~JSExecState()
      {
          JSC::VM&amp; vm = currentState()-&gt;vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
          scope.assertNoException();
  
<span class="line-modified">!         JSC::ExecState* state = currentState();</span>
<span class="line-modified">!         bool didExitJavaScript = state &amp;&amp; !m_previousState;</span>
  
          setCurrentState(m_previousState);
  
          if (didExitJavaScript)
<span class="line-modified">!             didLeaveScriptContext(state);</span>
      }
  
<span class="line-modified">!     static void setCurrentState(JSC::ExecState* state)</span>
      {
<span class="line-modified">!         threadGlobalData().setCurrentState(state);</span>
      }
  
<span class="line-modified">!     template&lt;typename Type, Type jsType, typename DataType&gt; static InspectorInstrumentationCookie instrumentFunctionInternal(ScriptExecutionContext*, Type, const DataType&amp;);</span>
  
<span class="line-modified">!     JSC::ExecState* m_previousState;</span>
      JSC::JSLockHolder m_lock;
  
<span class="line-modified">!     static void didLeaveScriptContext(JSC::ExecState*);</span>
  };
  
<span class="line-modified">! // Null state prevents origin security checks.</span>
  // Used by non-JavaScript bindings (ObjC, GObject).
  class JSMainThreadNullState {
      WTF_MAKE_NONCOPYABLE(JSMainThreadNullState);
      WTF_FORBID_HEAP_ALLOCATION;
  public:
<span class="line-new-header">--- 35,131 ---</span>
  #include &lt;wtf/ForbidHeapAllocation.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  
  class ScriptExecutionContext;
  
  class JSExecState {
      WTF_MAKE_NONCOPYABLE(JSExecState);
      WTF_FORBID_HEAP_ALLOCATION;
      friend class JSMainThreadNullState;
  public:
<span class="line-modified">!     static JSC::JSGlobalObject* currentState()</span>
      {
          return threadGlobalData().currentState();
      };
  
<span class="line-modified">!     static JSC::JSValue call(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSValue functionObject, JSC::CallType callType, const JSC::CallData&amp; callData, JSC::JSValue thisValue, const JSC::ArgList&amp; args, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(lexicalGlobalObject);</span>
<span class="line-modified">!         return JSC::call(lexicalGlobalObject, functionObject, callType, callData, thisValue, args, returnedException);</span>
      };
  
<span class="line-modified">!     static JSC::JSValue evaluate(JSC::JSGlobalObject* lexicalGlobalObject, const JSC::SourceCode&amp; source, JSC::JSValue thisValue, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(lexicalGlobalObject);</span>
<span class="line-modified">!         return JSC::evaluate(lexicalGlobalObject, source, thisValue, returnedException);</span>
      };
  
<span class="line-modified">!     static JSC::JSValue evaluate(JSC::JSGlobalObject* lexicalGlobalObject, const JSC::SourceCode&amp; source, JSC::JSValue thisValue = JSC::JSValue())</span>
      {
          NakedPtr&lt;JSC::Exception&gt; unused;
<span class="line-modified">!         return evaluate(lexicalGlobalObject, source, thisValue, unused);</span>
      };
  
<span class="line-modified">!     static JSC::JSValue profiledCall(JSC::JSGlobalObject* lexicalGlobalObject, JSC::ProfilingReason reason, JSC::JSValue functionObject, JSC::CallType callType, const JSC::CallData&amp; callData, JSC::JSValue thisValue, const JSC::ArgList&amp; args, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(lexicalGlobalObject);</span>
<span class="line-modified">!         return JSC::profiledCall(lexicalGlobalObject, reason, functionObject, callType, callData, thisValue, args, returnedException);</span>
      }
  
<span class="line-modified">!     static JSC::JSValue profiledEvaluate(JSC::JSGlobalObject* lexicalGlobalObject, JSC::ProfilingReason reason, const JSC::SourceCode&amp; source, JSC::JSValue thisValue, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSExecState currentState(lexicalGlobalObject);</span>
<span class="line-modified">!         return JSC::profiledEvaluate(lexicalGlobalObject, reason, source, thisValue, returnedException);</span>
      }
  
<span class="line-modified">!     static JSC::JSValue profiledEvaluate(JSC::JSGlobalObject* lexicalGlobalObject, JSC::ProfilingReason reason, const JSC::SourceCode&amp; source, JSC::JSValue thisValue = JSC::JSValue())</span>
      {
          NakedPtr&lt;JSC::Exception&gt; unused;
<span class="line-modified">!         return profiledEvaluate(lexicalGlobalObject, reason, source, thisValue, unused);</span>
      }
  
<span class="line-modified">!     static void runTask(JSC::JSGlobalObject* lexicalGlobalObject, JSC::Microtask&amp; task)</span>
      {
<span class="line-modified">!         JSExecState currentState(lexicalGlobalObject);</span>
<span class="line-modified">!         task.run(lexicalGlobalObject);</span>
      }
  
<span class="line-modified">!     static JSC::JSInternalPromise&amp; loadModule(JSC::JSGlobalObject&amp; lexicalGlobalObject, const String&amp; moduleName, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
      {
<span class="line-modified">!         JSExecState currentState(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!         return *JSC::loadModule(&amp;lexicalGlobalObject, moduleName, parameters, scriptFetcher);</span>
      }
  
<span class="line-modified">!     static JSC::JSInternalPromise&amp; loadModule(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::SourceCode&amp; sourceCode, JSC::JSValue scriptFetcher)</span>
      {
<span class="line-modified">!         JSExecState currentState(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!         return *JSC::loadModule(&amp;lexicalGlobalObject, sourceCode, scriptFetcher);</span>
      }
  
<span class="line-modified">!     static JSC::JSValue linkAndEvaluateModule(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::Identifier&amp; moduleKey, JSC::JSValue scriptFetcher, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException)</span>
      {
<span class="line-modified">!         JSC::VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
          auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         JSExecState currentState(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!         auto returnValue = JSC::linkAndEvaluateModule(&amp;lexicalGlobalObject, moduleKey, scriptFetcher);</span>
          if (UNLIKELY(scope.exception())) {
              returnedException = scope.exception();
              scope.clearException();
              return JSC::jsUndefined();
          }
          return returnValue;
      }
  
<span class="line-modified">!     static void instrumentFunctionCall(ScriptExecutionContext*, JSC::CallType, const JSC::CallData&amp;);</span>
<span class="line-modified">!     static void instrumentFunctionConstruct(ScriptExecutionContext*, JSC::ConstructType, const JSC::ConstructData&amp;);</span>
  
  private:
<span class="line-modified">!     explicit JSExecState(JSC::JSGlobalObject* lexicalGlobalObject)</span>
          : m_previousState(currentState())
<span class="line-modified">!         , m_lock(lexicalGlobalObject)</span>
      {
<span class="line-modified">!         setCurrentState(lexicalGlobalObject);</span>
      };
  
      ~JSExecState()
      {
          JSC::VM&amp; vm = currentState()-&gt;vm();
          auto scope = DECLARE_CATCH_SCOPE(vm);
          scope.assertNoException();
  
<span class="line-modified">!         JSC::JSGlobalObject* lexicalGlobalObject = currentState();</span>
<span class="line-modified">!         bool didExitJavaScript = lexicalGlobalObject &amp;&amp; !m_previousState;</span>
  
          setCurrentState(m_previousState);
  
          if (didExitJavaScript)
<span class="line-modified">!             didLeaveScriptContext(lexicalGlobalObject);</span>
      }
  
<span class="line-modified">!     static void setCurrentState(JSC::JSGlobalObject* lexicalGlobalObject)</span>
      {
<span class="line-modified">!         threadGlobalData().setCurrentState(lexicalGlobalObject);</span>
      }
  
<span class="line-modified">!     template&lt;typename Type, Type jsType, typename DataType&gt; static void instrumentFunctionInternal(ScriptExecutionContext*, Type, const DataType&amp;);</span>
  
<span class="line-modified">!     JSC::JSGlobalObject* m_previousState;</span>
      JSC::JSLockHolder m_lock;
  
<span class="line-modified">!     static void didLeaveScriptContext(JSC::JSGlobalObject*);</span>
  };
  
<span class="line-modified">! // Null lexicalGlobalObject prevents origin security checks.</span>
  // Used by non-JavaScript bindings (ObjC, GObject).
  class JSMainThreadNullState {
      WTF_MAKE_NONCOPYABLE(JSMainThreadNullState);
      WTF_FORBID_HEAP_ALLOCATION;
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,13 ***</span>
          ASSERT(isMainThread());
          JSExecState::setCurrentState(m_previousState);
      }
  
  private:
<span class="line-modified">!     JSC::ExecState* m_previousState;</span>
      CustomElementReactionStack m_customElementReactionStack;
  };
  
<span class="line-modified">! JSC::JSValue functionCallHandlerFromAnyThread(JSC::ExecState*, JSC::JSValue functionObject, JSC::CallType, const JSC::CallData&amp;, JSC::JSValue thisValue, const JSC::ArgList&amp; args, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException);</span>
<span class="line-modified">! JSC::JSValue evaluateHandlerFromAnyThread(JSC::ExecState*, const JSC::SourceCode&amp;, JSC::JSValue thisValue, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException);</span>
  
  } // namespace WebCore
<span class="line-new-header">--- 176,13 ---</span>
          ASSERT(isMainThread());
          JSExecState::setCurrentState(m_previousState);
      }
  
  private:
<span class="line-modified">!     JSC::JSGlobalObject* m_previousState;</span>
      CustomElementReactionStack m_customElementReactionStack;
  };
  
<span class="line-modified">! JSC::JSValue functionCallHandlerFromAnyThread(JSC::JSGlobalObject*, JSC::JSValue functionObject, JSC::CallType, const JSC::CallData&amp;, JSC::JSValue thisValue, const JSC::ArgList&amp; args, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException);</span>
<span class="line-modified">! JSC::JSValue evaluateHandlerFromAnyThread(JSC::JSGlobalObject*, const JSC::SourceCode&amp;, JSC::JSValue thisValue, NakedPtr&lt;JSC::Exception&gt;&amp; returnedException);</span>
  
  } // namespace WebCore
</pre>
<center><a href="JSExecState.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSExecStateInstrumentation.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
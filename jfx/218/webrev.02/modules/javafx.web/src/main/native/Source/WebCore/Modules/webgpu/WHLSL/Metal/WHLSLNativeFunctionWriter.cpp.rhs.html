<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLNativeFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;WHLSLAddressSpace.h&quot;
 33 #include &quot;WHLSLArrayType.h&quot;
 34 #include &quot;WHLSLEnumerationDefinition.h&quot;
 35 #include &quot;WHLSLInferTypes.h&quot;
 36 #include &quot;WHLSLIntrinsics.h&quot;
 37 #include &quot;WHLSLNamedType.h&quot;
 38 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;
 39 #include &quot;WHLSLNativeTypeDeclaration.h&quot;
 40 #include &quot;WHLSLPointerType.h&quot;
 41 #include &quot;WHLSLStructureDefinition.h&quot;
 42 #include &quot;WHLSLTypeDefinition.h&quot;
 43 #include &quot;WHLSLTypeNamer.h&quot;
 44 #include &quot;WHLSLUnnamedType.h&quot;
 45 #include &quot;WHLSLVariableDeclaration.h&quot;
 46 #include &lt;wtf/text/StringBuilder.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 namespace WHLSL {
 51 
 52 namespace Metal {
 53 
 54 static String mapFunctionName(String&amp; functionName)
 55 {
 56     if (functionName == &quot;ddx&quot;)
 57         return &quot;dfdx&quot;_str;
 58     if (functionName == &quot;ddy&quot;)
 59         return &quot;dfdy&quot;_str;
 60     if (functionName == &quot;asint&quot;)
 61         return &quot;as_type&lt;int32_t&gt;&quot;_str;
 62     if (functionName == &quot;asuint&quot;)
 63         return &quot;as_type&lt;uint32_t&gt;&quot;_str;
 64     if (functionName == &quot;asfloat&quot;)
 65         return &quot;as_type&lt;float&gt;&quot;_str;
 66     return functionName;
 67 }
 68 
 69 static String atomicName(String input)
 70 {
 71     if (input == &quot;Add&quot;)
 72         return &quot;fetch_add&quot;_str;
 73     if (input == &quot;And&quot;)
 74         return &quot;fetch_and&quot;_str;
 75     if (input == &quot;Exchange&quot;)
 76         return &quot;exchange&quot;_str;
 77     if (input == &quot;Max&quot;)
 78         return &quot;fetch_max&quot;_str;
 79     if (input == &quot;Min&quot;)
 80         return &quot;fetch_min&quot;_str;
 81     if (input == &quot;Or&quot;)
 82         return &quot;fetch_or&quot;_str;
 83     ASSERT(input == &quot;Xor&quot;);
 84         return &quot;fetch_xor&quot;_str;
 85 }
 86 
 87 static int vectorLength(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
 88 {
 89     int vectorLength = 1;
 90     if (!nativeTypeDeclaration.typeArguments().isEmpty()) {
 91         ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);
 92         ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
 93         vectorLength = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]).integerLiteral().value();
 94     }
 95     return vectorLength;
 96 }
 97 
<a name="1" id="anc1"></a>









 98 static const char* vectorSuffix(int vectorLength)
 99 {
100     switch (vectorLength) {
101     case 1:
102         return &quot;&quot;;
103     case 2:
104         return &quot;2&quot;;
105     case 3:
106         return &quot;3&quot;;
107     default:
108         ASSERT(vectorLength == 4);
109         return &quot;4&quot;;
110     }
111 }
112 
<a name="2" id="anc2"></a><span class="line-modified">113 enum class SampleType {</span>
<span class="line-added">114     Sample,</span>
<span class="line-added">115     SampleLevel,</span>
<span class="line-added">116     SampleBias,</span>
<span class="line-added">117     SampleGrad</span>
<span class="line-added">118 };</span>
<span class="line-added">119 </span>
<span class="line-added">120 static Optional&lt;SampleType&gt; sampleType(const String&amp; functionName)</span>
<span class="line-added">121 {</span>
<span class="line-added">122     if (functionName == &quot;Sample&quot;)</span>
<span class="line-added">123         return SampleType::Sample;</span>
<span class="line-added">124     if (functionName == &quot;SampleLevel&quot;)</span>
<span class="line-added">125         return SampleType::SampleLevel;</span>
<span class="line-added">126     if (functionName == &quot;SampleBias&quot;)</span>
<span class="line-added">127         return SampleType::SampleBias;</span>
<span class="line-added">128     if (functionName == &quot;SampleGrad&quot;)</span>
<span class="line-added">129         return SampleType::SampleGrad;</span>
<span class="line-added">130     return WTF::nullopt;</span>
<span class="line-added">131 }</span>
<span class="line-added">132 </span>
<span class="line-added">133 void inlineNativeFunction(StringBuilder&amp; stringBuilder, AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration, const Vector&lt;MangledVariableName&gt;&amp; args, MangledVariableName resultName, TypeNamer&amp; typeNamer)</span>
134 {
135     auto asMatrixType = [&amp;] (AST::UnnamedType&amp; unnamedType) -&gt; AST::NativeTypeDeclaration* {
136         auto&amp; realType = unnamedType.unifyNode();
137         if (!realType.isNativeTypeDeclaration())
138             return nullptr;
139 
140         auto&amp; maybeMatrixType = downcast&lt;AST::NativeTypeDeclaration&gt;(realType);
141         if (maybeMatrixType.isMatrix())
142             return &amp;maybeMatrixType;
143 
144         return nullptr;
145     };
146 
147     if (nativeFunctionDeclaration.isCast()) {
148         auto&amp; returnType = nativeFunctionDeclaration.type();
149         auto metalReturnTypeName = typeNamer.mangledNameForType(returnType);
150 
151         if (!nativeFunctionDeclaration.parameters().size()) {
<a name="3" id="anc3"></a><span class="line-modified">152             stringBuilder.append(metalReturnTypeName, &quot; { }&quot;);</span>
153             return;
154         }
155 
156         if (nativeFunctionDeclaration.parameters().size() == 1) {
157             auto&amp; parameterType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();
<a name="4" id="anc4"></a>
158 
159             auto isEnumerationDefinition = [] (auto&amp; type) {
160                 return is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(type));
161             };
162             auto&amp; unifiedReturnType = returnType.unifyNode();
163             if (isEnumerationDefinition(unifiedReturnType) &amp;&amp; !isEnumerationDefinition(parameterType.unifyNode())) {
<a name="5" id="anc5"></a>

164                 auto&amp; enumerationDefinition = downcast&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifiedReturnType));
<a name="6" id="anc6"></a><span class="line-modified">165                 stringBuilder.append(&quot;static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;((&quot;);</span>
<span class="line-modified">166                 bool loopedOnce = false;</span>
<span class="line-modified">167                 bool hasZeroCase = false;</span>
<span class="line-modified">168                 for (auto&amp; member : enumerationDefinition.enumerationMembers()) {</span>
<span class="line-modified">169                     if (loopedOnce)</span>
<span class="line-modified">170                         stringBuilder.append(&quot; || &quot;);</span>
<span class="line-modified">171                     hasZeroCase |= !member.get().value();</span>
<span class="line-modified">172                     stringBuilder.append(args[0], &quot; == &quot;, member.get().value());</span>
<span class="line-modified">173                     loopedOnce = true;</span>







174                 }
<a name="7" id="anc7"></a><span class="line-modified">175                 ASSERT_UNUSED(hasZeroCase, hasZeroCase);</span>
<span class="line-added">176 </span>
<span class="line-added">177                 stringBuilder.append(&quot;) ? &quot;, args[0], &quot; : 0)&quot;);</span>
178             } else
<a name="8" id="anc8"></a><span class="line-modified">179                 stringBuilder.append(&quot;static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, args[0], &quot;)&quot;);</span>
180 
181             return;
182         }
183 
184         if (auto* matrixType = asMatrixType(returnType)) {
<a name="9" id="anc9"></a><span class="line-modified">185             // We&#39;re either constructing with all individual elements, or with</span>
<span class="line-modified">186             // vectors for each column.</span>
<span class="line-modified">187 </span>
<span class="line-modified">188             stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">189             if (args.size() == matrixType-&gt;numberOfMatrixColumns()) {</span>
<span class="line-modified">190                 // Constructing with vectors for each column.</span>
<span class="line-modified">191                 for (size_t i = 0; i &lt; args.size(); ++i) {</span>
<span class="line-modified">192                     if (i)</span>
<span class="line-modified">193                         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-modified">194                     stringBuilder.append(resultName, &quot;.columns[&quot;, i, &quot;] = &quot;, args[i]);</span>




195                 }
196             } else {
<a name="10" id="anc10"></a><span class="line-modified">197                 // Constructing with all elements.</span>
<span class="line-modified">198                 RELEASE_ASSERT(args.size() == matrixType-&gt;numberOfMatrixColumns() * matrixType-&gt;numberOfMatrixRows());</span>
<span class="line-modified">199 </span>
<span class="line-modified">200                 size_t argNumber = 0;</span>
<span class="line-modified">201                 for (size_t i = 0; i &lt; matrixType-&gt;numberOfMatrixColumns(); ++i) {</span>
<span class="line-modified">202                     for (size_t j = 0; j &lt; matrixType-&gt;numberOfMatrixRows(); ++j) {</span>
<span class="line-added">203                         if (argNumber)</span>
<span class="line-added">204                             stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">205                         stringBuilder.append(resultName, &quot;.columns[&quot;, i, &quot;][&quot;, j, &quot;] = &quot;, args[argNumber]);</span>
<span class="line-added">206                         ++argNumber;</span>
207                     }
208                 }
209             }
210 
<a name="11" id="anc11"></a><span class="line-modified">211             stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);</span>
212             return;
213         }
214 
<a name="12" id="anc12"></a><span class="line-modified">215         stringBuilder.append(metalReturnTypeName, &#39;(&#39;);</span>
216         for (unsigned i = 0; i &lt; nativeFunctionDeclaration.parameters().size(); ++i) {
<a name="13" id="anc13"></a><span class="line-modified">217             if (i)</span>
218                 stringBuilder.append(&quot;, &quot;);
219             stringBuilder.append(args[i]);
220         }
<a name="14" id="anc14"></a><span class="line-modified">221         stringBuilder.append(&#39;)&#39;);</span>





























































































































































































































222         return;
223     }
224 
225     if (nativeFunctionDeclaration.isOperator()) {
226         auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());
<a name="15" id="anc15"></a><span class="line-modified">227 </span>
228         if (nativeFunctionDeclaration.parameters().size() == 1) {
<a name="16" id="anc16"></a><span class="line-added">229             // This is ok to do since the args to this function are all temps.</span>
<span class="line-added">230             // So things like ++ and -- are ok to do.</span>
<span class="line-added">231 </span>
232             if (auto* matrixType = asMatrixType(nativeFunctionDeclaration.type())) {
<a name="17" id="anc17"></a><span class="line-modified">233                 stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">234                 for (unsigned i = 0; i &lt; matrixType-&gt;numberOfMatrixColumns(); ++i) {</span>
<span class="line-modified">235                     if (i)</span>
<span class="line-modified">236                         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-modified">237                     stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, operatorName, args[0], &#39;[&#39;, i, &#39;]&#39;);</span>












238                 }
<a name="18" id="anc18"></a><span class="line-modified">239                 stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);</span>
<span class="line-modified">240             } else</span>
<span class="line-added">241                 stringBuilder.append(operatorName, args[0]);</span>
242             return;
243         }
244 
245         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
246         if (auto* leftMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type())) {
247             if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {
248                 // matrix &lt;op&gt; matrix
<a name="19" id="anc19"></a><span class="line-modified">249                 stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">250                 for (unsigned i = 0; i &lt; leftMatrix-&gt;numberOfMatrixColumns(); ++i) {</span>
<span class="line-modified">251                     if (i)</span>
<span class="line-modified">252                         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-modified">253                     stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, args[0], &#39;[&#39;, i, &quot;] &quot;, operatorName, &#39; &#39;, args[1], &#39;[&#39;, i, &#39;]&#39;);</span>



254                 }
<a name="20" id="anc20"></a><span class="line-modified">255                 stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);</span>
256             } else {
257                 // matrix &lt;op&gt; scalar
<a name="21" id="anc21"></a><span class="line-modified">258                 stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">259                 for (unsigned i = 0; i &lt; leftMatrix-&gt;numberOfMatrixColumns(); ++i) {</span>
<span class="line-modified">260                     if (i)</span>
<span class="line-modified">261                         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-modified">262                     stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, args[0], &#39;[&#39;, i, &quot;] &quot;, operatorName, &#39; &#39;, args[1]);</span>



263                 }
<a name="22" id="anc22"></a><span class="line-modified">264                 stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);</span>
265             }
266         } else if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {
267             ASSERT(!asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));
268             // scalar &lt;op&gt; matrix
<a name="23" id="anc23"></a><span class="line-modified">269             stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">270             for (unsigned i = 0; i &lt; rightMatrix-&gt;numberOfMatrixColumns(); ++i) {</span>
<span class="line-modified">271                 if (i)</span>
<span class="line-modified">272                     stringBuilder.append(&quot;, &quot;);</span>
<span class="line-modified">273                 stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &#39;[&#39;, i, &#39;]&#39;);</span>



274             }
<a name="24" id="anc24"></a><span class="line-modified">275             stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);</span>
276         } else {
277             // scalar &lt;op&gt; scalar
278             // vector &lt;op&gt; vector
279             // vector &lt;op&gt; scalar
280             // scalar &lt;op&gt; vector
281             stringBuilder.append(
<a name="25" id="anc25"></a><span class="line-modified">282                 &#39;(&#39;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &#39;)&#39;);</span>
283         }
284 
285         return;
286     }
287 
288     if (nativeFunctionDeclaration.name() == &quot;cos&quot;
289         || nativeFunctionDeclaration.name() == &quot;sin&quot;
290         || nativeFunctionDeclaration.name() == &quot;tan&quot;
291         || nativeFunctionDeclaration.name() == &quot;acos&quot;
292         || nativeFunctionDeclaration.name() == &quot;asin&quot;
293         || nativeFunctionDeclaration.name() == &quot;atan&quot;
294         || nativeFunctionDeclaration.name() == &quot;cosh&quot;
295         || nativeFunctionDeclaration.name() == &quot;sinh&quot;
296         || nativeFunctionDeclaration.name() == &quot;tanh&quot;
297         || nativeFunctionDeclaration.name() == &quot;ceil&quot;
298         || nativeFunctionDeclaration.name() == &quot;exp&quot;
299         || nativeFunctionDeclaration.name() == &quot;floor&quot;
300         || nativeFunctionDeclaration.name() == &quot;log&quot;
301         || nativeFunctionDeclaration.name() == &quot;round&quot;
302         || nativeFunctionDeclaration.name() == &quot;trunc&quot;
303         || nativeFunctionDeclaration.name() == &quot;ddx&quot;
304         || nativeFunctionDeclaration.name() == &quot;ddy&quot;
305         || nativeFunctionDeclaration.name() == &quot;isnormal&quot;
306         || nativeFunctionDeclaration.name() == &quot;isfinite&quot;
307         || nativeFunctionDeclaration.name() == &quot;isinf&quot;
308         || nativeFunctionDeclaration.name() == &quot;isnan&quot;
309         || nativeFunctionDeclaration.name() == &quot;asint&quot;
310         || nativeFunctionDeclaration.name() == &quot;asuint&quot;
311         || nativeFunctionDeclaration.name() == &quot;asfloat&quot;
312         || nativeFunctionDeclaration.name() == &quot;length&quot;) {
313         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
314         stringBuilder.append(
<a name="26" id="anc26"></a><span class="line-modified">315             mapFunctionName(nativeFunctionDeclaration.name()), &#39;(&#39;, args[0], &#39;)&#39;);</span>
316         return;
317     }
318 
319     if (nativeFunctionDeclaration.name() == &quot;pow&quot; || nativeFunctionDeclaration.name() == &quot;atan2&quot;) {
320         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
321         stringBuilder.append(
<a name="27" id="anc27"></a><span class="line-modified">322             nativeFunctionDeclaration.name(), &#39;(&#39;, args[0], &quot;, &quot;, args[1], &#39;)&#39;);</span>
323         return;
324     }
325 
326     if (nativeFunctionDeclaration.name() == &quot;clamp&quot;) {
327         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
<a name="28" id="anc28"></a>

328 
<a name="29" id="anc29"></a><span class="line-modified">329         if (auto* matrixType = asMatrixType(nativeFunctionDeclaration.type())) {</span>
<span class="line-modified">330             stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">331             bool ranOnce = false;</span>
<span class="line-modified">332             for (unsigned i = 0; i &lt; matrixType-&gt;numberOfMatrixColumns(); ++i) {</span>
<span class="line-modified">333                 for (unsigned j = 0; j &lt; matrixType-&gt;numberOfMatrixRows(); ++j) {</span>
<span class="line-modified">334                     if (ranOnce)</span>
<span class="line-modified">335                         stringBuilder.append(&quot;, &quot;);</span>
<span class="line-modified">336                     ranOnce = true;</span>
<span class="line-added">337                     stringBuilder.append(</span>
<span class="line-added">338                         resultName, &#39;[&#39;, i, &quot;][&quot;, j, &quot;] = clamp(&quot;, args[0], &#39;[&#39;, i, &quot;][&quot;, j, &quot;], &quot;, args[1], &#39;[&#39;, i, &quot;][&quot;, j, &quot;], &quot;, args[2], &#39;[&#39;, i, &quot;][&quot;, j, &quot;])&quot;);</span>
<span class="line-added">339                 }</span>
340             }
<a name="30" id="anc30"></a><span class="line-modified">341             stringBuilder.append(&quot;, &quot;, resultName, &quot;)&quot;);</span>
342         } else {
343             stringBuilder.append(
<a name="31" id="anc31"></a><span class="line-modified">344                 &quot;clamp(&quot;, args[0], &quot;, &quot;, args[1], &quot;, &quot;, args[2], &#39;)&#39;);</span>
345         }
346         return;
347     }
348 
349     if (nativeFunctionDeclaration.name() == &quot;AllMemoryBarrierWithGroupSync&quot;) {
350         ASSERT(!nativeFunctionDeclaration.parameters().size());
351         stringBuilder.append(
<a name="32" id="anc32"></a><span class="line-modified">352             &quot;(threadgroup_barrier(mem_flags::mem_device), threadgroup_barrier(mem_flags::mem_threadgroup), threadgroup_barrier(mem_flags::mem_texture))&quot;);</span>


353         return;
354     }
355 
356     if (nativeFunctionDeclaration.name() == &quot;DeviceMemoryBarrierWithGroupSync&quot;) {
357         ASSERT(!nativeFunctionDeclaration.parameters().size());
358         stringBuilder.append(
<a name="33" id="anc33"></a><span class="line-modified">359             &quot;threadgroup_barrier(mem_flags::mem_device)&quot;);</span>
360         return;
361     }
362 
363     if (nativeFunctionDeclaration.name() == &quot;GroupMemoryBarrierWithGroupSync&quot;) {
364         ASSERT(!nativeFunctionDeclaration.parameters().size());
365         stringBuilder.append(
<a name="34" id="anc34"></a><span class="line-modified">366             &quot;threadgroup_barrier(mem_flags::mem_threadgroup)&quot;);</span>
367         return;
368     }
369 
370     if (nativeFunctionDeclaration.name().startsWith(&quot;Interlocked&quot;_str)) {
371         if (nativeFunctionDeclaration.name() == &quot;InterlockedCompareExchange&quot;) {
372             ASSERT(nativeFunctionDeclaration.parameters().size() == 4);
373             stringBuilder.append(
<a name="35" id="anc35"></a><span class="line-modified">374                 &quot;(atomic_compare_exchange_weak_explicit(&quot;, args[0], &quot;, &amp;&quot;, args[1], &quot;, &quot;, args[2], &quot;, memory_order_relaxed, memory_order_relaxed), &quot;,</span>
<span class="line-modified">375                 &#39;*&#39;, args[3], &quot; = &quot;, args[1], &#39;)&#39;);</span>
376             return;
377         }
378 
379         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
380         auto name = atomicName(nativeFunctionDeclaration.name().substring(&quot;Interlocked&quot;_str.length()));
381         stringBuilder.append(
<a name="36" id="anc36"></a><span class="line-modified">382             &#39;*&#39;, args[2], &quot; = atomic_&quot;, name, &quot;_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed)&quot;);</span>
383         return;
384     }
385 
<a name="37" id="anc37"></a><span class="line-modified">386     if (auto sampleType = WHLSL::Metal::sampleType(nativeFunctionDeclaration.name())) {</span>
<span class="line-modified">387         size_t baseArgumentCount = 0;</span>
<span class="line-added">388         switch (*sampleType) {</span>
<span class="line-added">389         case SampleType::Sample:</span>
<span class="line-added">390             baseArgumentCount = 3;</span>
<span class="line-added">391             break;</span>
<span class="line-added">392         case SampleType::SampleLevel:</span>
<span class="line-added">393         case SampleType::SampleBias:</span>
<span class="line-added">394             baseArgumentCount = 4;</span>
<span class="line-added">395             break;</span>
<span class="line-added">396         case SampleType::SampleGrad:</span>
<span class="line-added">397             baseArgumentCount = 5;</span>
<span class="line-added">398             break;</span>
<span class="line-added">399         }</span>
<span class="line-added">400         ASSERT(nativeFunctionDeclaration.parameters().size() == baseArgumentCount || nativeFunctionDeclaration.parameters().size() == baseArgumentCount + 1);</span>
401 
402         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
403         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));
404         auto locationVectorLength = vectorLength(locationType);
405         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));
406         auto returnVectorLength = vectorLength(returnType);
407 
<a name="38" id="anc38"></a><span class="line-modified">408         int argumentIndex = 0;</span>
<span class="line-modified">409         stringBuilder.append(args[argumentIndex], &quot;.sample(&quot;, args[argumentIndex + 1], &quot;, &quot;);</span>
<span class="line-added">410         argumentIndex += 2;</span>
411 
412         if (textureType.isTextureArray()) {
413             ASSERT(locationVectorLength &gt; 1);
<a name="39" id="anc39"></a><span class="line-modified">414             stringBuilder.append(args[argumentIndex], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;, &quot;, args[argumentIndex], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1));</span>
<span class="line-added">415             ++argumentIndex;</span>
416         } else
<a name="40" id="anc40"></a><span class="line-modified">417             stringBuilder.append(args[argumentIndex++]);</span>
<span class="line-modified">418 </span>
<span class="line-modified">419         switch (*sampleType) {</span>
<span class="line-added">420         case SampleType::Sample:</span>
<span class="line-added">421             break;</span>
<span class="line-added">422         case SampleType::SampleLevel:</span>
<span class="line-added">423             stringBuilder.append(&quot;, level(&quot;, args[argumentIndex++], &quot;)&quot;);</span>
<span class="line-added">424             break;</span>
<span class="line-added">425         case SampleType::SampleBias:</span>
<span class="line-added">426             stringBuilder.append(&quot;, bias(&quot;, args[argumentIndex++], &quot;)&quot;);</span>
<span class="line-added">427             break;</span>
<span class="line-added">428         case SampleType::SampleGrad:</span>
<span class="line-added">429             if (textureType.isCubeTexture())</span>
<span class="line-added">430                 stringBuilder.append(&quot;, gradientcube(&quot;, args[argumentIndex], &quot;, &quot;, args[argumentIndex + 1], &quot;)&quot;);</span>
<span class="line-added">431             else</span>
<span class="line-added">432                 stringBuilder.append(&quot;, gradient2d(&quot;, args[argumentIndex], &quot;, &quot;, args[argumentIndex + 1], &quot;)&quot;);</span>
<span class="line-added">433             argumentIndex += 2;</span>
<span class="line-added">434             break;</span>
<span class="line-added">435         }</span>
<span class="line-added">436 </span>
<span class="line-added">437         if (nativeFunctionDeclaration.parameters().size() == baseArgumentCount + 1)</span>
<span class="line-added">438             stringBuilder.append(&quot;, &quot;, args[argumentIndex++]);</span>
439         stringBuilder.append(&quot;)&quot;);
440         if (!textureType.isDepthTexture())
441             stringBuilder.append(&quot;.&quot;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));
<a name="41" id="anc41"></a>
442 
443         return;
444     }
445 
446     if (nativeFunctionDeclaration.name() == &quot;Load&quot;) {
447         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
448 
449         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
450         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));
451         auto locationVectorLength = vectorLength(locationType);
452         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));
453         auto returnVectorLength = vectorLength(returnType);
<a name="42" id="anc42"></a><span class="line-added">454         auto locationTypeName = typeNamer.mangledNameForType(locationType);</span>
455 
<a name="43" id="anc43"></a><span class="line-modified">456         stringBuilder.append(&#39;(&#39;, args[1], &quot; = &quot;);</span>
<span class="line-modified">457         if (textureType.isTextureArray()) {</span>
<span class="line-modified">458             ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-modified">459             stringBuilder.append(&quot;clamp(&quot;, args[1], &quot;, &quot;, locationTypeName, &#39;(&#39;);</span>
<span class="line-modified">460             for (int i = 0; i &lt; locationVectorLength; ++i) {</span>
<span class="line-added">461                 if (i)</span>
<span class="line-added">462                     stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">463                 stringBuilder.append(&#39;0&#39;);</span>
<span class="line-added">464             }</span>
<span class="line-added">465             stringBuilder.append(&quot;), &quot;, locationTypeName, &#39;(&#39;);</span>
466 
<a name="44" id="anc44"></a><span class="line-modified">467             String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };</span>
<span class="line-modified">468             for (int i = 0; i &lt; locationVectorLength - 1; ++i) {</span>
<span class="line-modified">469                 if (i)</span>
<span class="line-modified">470                     stringBuilder.append(&quot;, &quot;);</span>








471                 stringBuilder.append(
<a name="45" id="anc45"></a><span class="line-modified">472                     args[0], &quot;.get_&quot;, dimensions[i], &quot;() - 1&quot;);</span>
<span class="line-modified">473             }</span>
<span class="line-modified">474             stringBuilder.append(</span>
<span class="line-modified">475                 args[0], &quot;.get_array_size() - 1))&quot;);</span>
<span class="line-modified">476         } else {</span>
<span class="line-modified">477             if (locationVectorLength == 1)</span>
<span class="line-modified">478                 stringBuilder.append(&quot;clamp(&quot;, args[1], &quot;, 0, &quot;, args[0], &quot;.get_width() - 1)&quot;);</span>
<span class="line-modified">479             else {</span>
<span class="line-modified">480                 stringBuilder.append(&quot;clamp(&quot;, args[1], &quot;, &quot;, locationTypeName, &quot;(0, 0&quot;);</span>
<span class="line-modified">481                 if (locationVectorLength &gt;= 3)</span>
<span class="line-modified">482                     stringBuilder.append(&quot;, 0&quot;);</span>
<span class="line-modified">483                 stringBuilder.append(&quot;), &quot;, locationTypeName, &#39;(&#39;, args[0], &quot;.get_width() - 1, &quot;, args[0], &quot;.get_height() - 1&quot;);</span>
<span class="line-modified">484                 if (locationVectorLength &gt;= 3)</span>
<span class="line-modified">485                     stringBuilder.append(&quot;, &quot;, args[0], &quot;.get_depth() - 1&quot;);</span>
<span class="line-modified">486                 stringBuilder.append(&quot;))&quot;);</span>














487             }
<a name="46" id="anc46"></a>









488         }
<a name="47" id="anc47"></a><span class="line-modified">489 </span>
<span class="line-added">490         stringBuilder.append(&quot;, &quot;, args[0], &quot;.read(&quot;);</span>
<span class="line-added">491 </span>
<span class="line-added">492         if (textureType.isTextureArray()) {</span>
<span class="line-added">493             ASSERT(locationVectorLength &gt; 1);</span>
<span class="line-added">494             stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);</span>
<span class="line-added">495         } else</span>
<span class="line-added">496             stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[1], &#39;)&#39;);</span>
<span class="line-added">497         stringBuilder.append(&#39;)&#39;);</span>
<span class="line-added">498         if (!textureType.isDepthTexture())</span>
<span class="line-added">499             stringBuilder.append(&#39;.&#39;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));</span>
<span class="line-added">500 </span>
<span class="line-added">501         stringBuilder.append(&#39;)&#39;);</span>
502 
503         return;
504     }
505 
506     if (nativeFunctionDeclaration.name() == &quot;load&quot;) {
507         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
508         stringBuilder.append(
<a name="48" id="anc48"></a><span class="line-modified">509             &quot;atomic_load_explicit(&quot;, args[0], &quot;, memory_order_relaxed)&quot;);</span>
510         return;
511     }
512 
513     if (nativeFunctionDeclaration.name() == &quot;store&quot;) {
514         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
515         stringBuilder.append(
<a name="49" id="anc49"></a><span class="line-modified">516             &quot;atomic_store_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed)&quot;);</span>
517         return;
518     }
519 
520     if (nativeFunctionDeclaration.name() == &quot;GetDimensions&quot;) {
<a name="50" id="anc50"></a><span class="line-added">521         stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">522 </span>
523         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
524 
525         size_t index = 1;
526         bool hasMipLevel = !textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1;
527         if (hasMipLevel)
528             ++index;
529         const MangledVariableName&amp; widthName = args[index];
530         ++index;
531         Optional&lt;MangledVariableName&gt; heightName;
532         if (textureType.textureDimension() &gt;= 2) {
533             heightName = args[index];
534             ++index;
535         }
536         Optional&lt;MangledVariableName&gt; depthName;
537         if (textureType.textureDimension() &gt;= 3) {
538             depthName = args[index];
539             ++index;
540         }
541         Optional&lt;MangledVariableName&gt; elementsName;
542         if (textureType.isTextureArray()) {
543             elementsName = args[index];
544             ++index;
545         }
546         Optional&lt;MangledVariableName&gt; numberOfLevelsName;
547         if (!textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1) {
548             numberOfLevelsName = args[index];
549             ++index;
550         }
551         ASSERT(index == nativeFunctionDeclaration.parameters().size());
552 
553         stringBuilder.append(
<a name="51" id="anc51"></a><span class="line-modified">554             &#39;*&#39;, widthName, &quot; = &quot;, args[0], &quot;.get_width(&quot;);</span>

555         if (hasMipLevel)
556             stringBuilder.append(args[1]);
<a name="52" id="anc52"></a><span class="line-modified">557         stringBuilder.append(&#39;)&#39;);</span>
558 
559         if (heightName) {
560             stringBuilder.append(
<a name="53" id="anc53"></a><span class="line-modified">561                 &quot;, *&quot;, *heightName, &quot; = &quot;, args[0], &quot;.get_height(&quot;);</span>

562             if (hasMipLevel)
563                 stringBuilder.append(args[1]);
<a name="54" id="anc54"></a><span class="line-modified">564             stringBuilder.append(&#39;)&#39;);</span>
565         }
566         if (depthName) {
567             stringBuilder.append(
<a name="55" id="anc55"></a><span class="line-modified">568                 &quot;, *&quot;, *depthName, &quot; = &quot;, args[0], &quot;.get_depth(&quot;);</span>

569             if (hasMipLevel)
570                 stringBuilder.append(args[1]);
<a name="56" id="anc56"></a><span class="line-modified">571             stringBuilder.append(&#39;)&#39;);</span>
572         }
573         if (elementsName) {
574             stringBuilder.append(
<a name="57" id="anc57"></a><span class="line-modified">575                 &quot;, *&quot;, *elementsName, &quot; = &quot;, args[0], &quot;.get_array_size()&quot;);</span>

576         }
577         if (numberOfLevelsName) {
578             stringBuilder.append(
<a name="58" id="anc58"></a><span class="line-modified">579                 &quot;, *&quot;, *numberOfLevelsName, &quot; = &quot;, args[0], &quot;.get_num_mip_levels()&quot;);</span>

580         }
<a name="59" id="anc59"></a>

581 
<a name="60" id="anc60"></a><span class="line-modified">582         stringBuilder.append(&#39;)&#39;);</span>
<span class="line-modified">583         return;</span>











584     }
585 
586     if (nativeFunctionDeclaration.name() == &quot;Gather&quot;) {
587         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
588         notImplemented();
589     }
590 
591     if (nativeFunctionDeclaration.name() == &quot;GatherRed&quot;) {
592         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
593         notImplemented();
594     }
595 
596     if (nativeFunctionDeclaration.name() == &quot;SampleCmp&quot;) {
597         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
598         notImplemented();
599     }
600 
601     if (nativeFunctionDeclaration.name() == &quot;SampleCmpLevelZero&quot;) {
602         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
603         notImplemented();
604     }
605 
606     if (nativeFunctionDeclaration.name() == &quot;Store&quot;) {
<a name="61" id="anc61"></a><span class="line-modified">607         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this</span>
<span class="line-modified">608         notImplemented();</span>


























































609     }
610 
611     if (nativeFunctionDeclaration.name() == &quot;GatherAlpha&quot;) {
612         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
613         notImplemented();
614     }
615 
616     if (nativeFunctionDeclaration.name() == &quot;GatherBlue&quot;) {
617         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
618         notImplemented();
619     }
620 
621     if (nativeFunctionDeclaration.name() == &quot;GatherCmp&quot;) {
622         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
623         notImplemented();
624     }
625 
626     if (nativeFunctionDeclaration.name() == &quot;GatherCmpRed&quot;) {
627         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
628         notImplemented();
629     }
630 
631     if (nativeFunctionDeclaration.name() == &quot;GatherGreen&quot;) {
632         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
633         notImplemented();
634     }
635 
636     ASSERT_NOT_REACHED();
637 }
638 
639 } // namespace Metal
640 
641 } // namespace WHLSL
642 
643 } // namespace WebCore
644 
645 #endif
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm b/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm
@@ -67,10 +67,11 @@
     isException => '$', # Used for exception interfaces
     isCallback => '$', # Used for callback interfaces
     isPartial => '$', # Used for partial interfaces
     iterable => '$', # Used for iterable interfaces
     mapLike => '$', # Used for mapLike interfaces
+    setLike => '$', # Used for setLike interfaces
     serializable => '$', # Used for serializable interfaces
     extendedAttributes => '$',
 });
 
 # Used to represent an argument to a IDLOperation.
@@ -91,10 +92,11 @@
     isStatic => '$',
     isIterable => '$',
     isSerializer => '$',
     isStringifier => '$',
     isMapLike => '$',
+    isSetLike => '$',
     specials => '@',
     extendedAttributes => '%',
 });
 
 
@@ -102,10 +104,11 @@
 struct( IDLAttribute => {
     name => '$',
     type => 'IDLType',
     isStatic => '$',
     isMapLike => '$',
+    isSetLike => '$',
     isStringifier => '$',
     isReadOnly => '$',
     isInherit => '$',
     extendedAttributes => '$',
 });
@@ -127,10 +130,19 @@
     attributes => '@', # MapLike attributes (size)
     operations => '@', # MapLike operations (entries, keys, values, forEach, get, has and if not readonly, delete, set and clear)
     extendedAttributes => '$',
 });
 
+# https://heycam.github.io/webidl/#es-setlike
+struct( IDLSetLike => {
+    isReadOnly => '$',
+    itemType => 'IDLType',
+    attributes => '@', # SetLike attributes (size)
+    operations => '@', # SetLike operations (entries, keys, values, forEach, has and if not readonly, delete, set and clear)
+    extendedAttributes => '$',
+});
+
 # https://heycam.github.io/webidl/#idl-serializers
 struct( IDLSerializable => {
     attributes => '@', # List of attributes to serialize
     hasAttribute => '$', # serializer = { attribute }
     hasInherit => '$', # serializer = { inherit }
@@ -581,10 +593,11 @@
     $clonedOperation->isStatic($operation->isStatic);
     $clonedOperation->isIterable($operation->isIterable);
     $clonedOperation->isSerializer($operation->isSerializer);
     $clonedOperation->isStringifier($operation->isStringifier);
     $clonedOperation->isMapLike($operation->isMapLike);
+    $clonedOperation->isSetLike($operation->isSetLike);
     $clonedOperation->specials($operation->specials);
 
     copyExtendedAttributes($clonedOperation->extendedAttributes, $operation->extendedAttributes);
 
     return $clonedOperation;
@@ -708,10 +721,21 @@
                 }
                 foreach my $operation (@{$definition->mapLike->operations}) {
                     $self->applyTypedefsToOperation($operation);
                 }
             }
+            if ($definition->setLike) {
+                if ($definition->setLike->itemType) {
+                    $definition->setLike->itemType($self->typeByApplyingTypedefs($definition->setLike->itemType));
+                }
+                foreach my $attribute (@{$definition->setLike->attributes}) {
+                    $attribute->type($self->typeByApplyingTypedefs($attribute->type));
+                }
+                foreach my $operation (@{$definition->setLike->operations}) {
+                    $self->applyTypedefsToOperation($operation);
+                }
+            }
         } elsif (ref($definition) eq "IDLDictionary") {
             foreach my $member (@{$definition->members}) {
                 $member->type($self->typeByApplyingTypedefs($member->type));
             }
         } elsif (ref($definition) eq "IDLCallbackFunction") {
@@ -1375,10 +1399,13 @@
         return $self->parseReadWriteAttribute($extendedAttributeList);
     }
     if ($next->value() eq "maplike") {
         return $self->parseMapLikeRest($extendedAttributeList, 0);
     }
+    if ($next->value() eq "setlike") {
+        return $self->parseSetLikeRest($extendedAttributeList, 0);
+    }
     if ($next->type() == IdentifierToken || $next->value() =~ /$nextOperation_1/) {
         return $self->parseOperation($extendedAttributeList);
     }
     $self->assertUnexpectedToken($next->value(), __LINE__);
 }
@@ -1399,10 +1426,13 @@
             return $attribute;
         }
         if ($next->value() eq "maplike") {
             return $self->parseMapLikeRest($extendedAttributeList, 1);
         }
+        if ($next->value() eq "setlike") {
+            return $self->parseSetLikeRest($extendedAttributeList, 1);
+        }
     }
     $self->assertUnexpectedToken($next->value(), __LINE__);
 }
 
 sub parseSerializer
@@ -1695,10 +1725,11 @@
 
 sub parseOperation
 {
     my $self = shift;
     my $extendedAttributeList = shift;
+    my $isReadOnly = shift;
 
     my $next = $self->nextToken();
     if ($next->value() =~ /$nextSpecials_1/) {
         return $self->parseSpecialOperation($extendedAttributeList);
     }
@@ -1964,43 +1995,176 @@
     push(@{$maplike->operations}, $valuesOperation);
     push(@{$maplike->operations}, $forEachOperation);
 
     return $maplike if $isReadOnly;
 
+    my $setOperation = IDLOperation->new();
+    $setOperation->name("set");
+    $setOperation->isMapLike(1);
+    my $setKeyArgument = IDLArgument->new();
+    $setKeyArgument->name("key");
+    $setKeyArgument->type($maplike->keyType);
+    $setKeyArgument->extendedAttributes($extendedAttributeList);
+    my $setValueArgument = IDLArgument->new();
+    $setValueArgument->name("value");
+    $setValueArgument->type($maplike->valueType);
+    $setValueArgument->extendedAttributes($extendedAttributeList);
+    push(@{$setOperation->arguments}, ($setKeyArgument));
+    push(@{$setOperation->arguments}, ($setValueArgument));
+    $setOperation->extendedAttributes($notEnumerableExtendedAttributeList);
+    $setOperation->type(makeSimpleType("any"));
+
+    my $clearOperation = IDLOperation->new();
+    $clearOperation->name("clear");
+    $clearOperation->isMapLike(1);
+    $clearOperation->extendedAttributes($notEnumerableExtendedAttributeList);
+    $clearOperation->type(makeSimpleType("void"));
+
+    my $deleteOperation = IDLOperation->new();
+    $deleteOperation->name("delete");
+    $deleteOperation->isMapLike(1);
+    my $deleteArgument = IDLArgument->new();
+    $deleteArgument->name("key");
+    $deleteArgument->type($maplike->keyType);
+    $deleteArgument->extendedAttributes($extendedAttributeList);
+    push(@{$deleteOperation->arguments}, ($deleteArgument));
+    $deleteOperation->extendedAttributes($notEnumerableExtendedAttributeList);
+    $deleteOperation->type(makeSimpleType("any"));
+
+    push(@{$maplike->operations}, $setOperation);
+    push(@{$maplike->operations}, $clearOperation);
+    push(@{$maplike->operations}, $deleteOperation);
+
+    return $maplike;
+}
+
+sub parseSetLikeRest
+{
+    my $self = shift;
+    my $extendedAttributeList = shift;
+    my $isReadOnly = shift;
+
+    my $next = $self->nextToken();
+    if ($next->value() eq "setlike") {
+        $self->assertTokenValue($self->getToken(), "setlike", __LINE__);
+        my $setLikeNode = $self->parseSetLikeProperties($extendedAttributeList, $isReadOnly);
+        $self->assertTokenValue($self->getToken(), ";", __LINE__);
+        return $setLikeNode;
+    }
+    $self->assertUnexpectedToken($next->value(), __LINE__);
+}
+
+sub parseSetLikeProperties
+{
+    my $self = shift;
+    my $extendedAttributeList = shift;
+    my $isReadOnly = shift;
+
+    my $setlike = IDLSetLike->new();
+    $setlike->extendedAttributes($extendedAttributeList);
+
+    $self->assertTokenValue($self->getToken(), "<", __LINE__);
+    $setlike->itemType($self->parseTypeWithExtendedAttributes());
+    $self->assertTokenValue($self->getToken(), ">", __LINE__);
+
+    # FIXME: Synthetic operations should not be added during parsing. Instead, the CodeGenerator
+    # should be responsible for them.
+
+    my $notEnumerableExtendedAttributeList = $extendedAttributeList;
+    $notEnumerableExtendedAttributeList->{NotEnumerable} = 1;
+
+    my $sizeAttribute = IDLAttribute->new();
+    $sizeAttribute->name("size");
+    $sizeAttribute->isSetLike(1);
+    $sizeAttribute->extendedAttributes($extendedAttributeList);
+    $sizeAttribute->isReadOnly(1);
+    $sizeAttribute->type(makeSimpleType("any"));
+    push(@{$setlike->attributes}, $sizeAttribute);
+
+    my $hasOperation = IDLOperation->new();
+    $hasOperation->name("has");
+    $hasOperation->isSetLike(1);
+    my $hasArgument = IDLArgument->new();
+    $hasArgument->name("key");
+    $hasArgument->type($setlike->itemType);
+    $hasArgument->extendedAttributes($extendedAttributeList);
+    push(@{$hasOperation->arguments}, ($hasArgument));
+    $hasOperation->extendedAttributes($notEnumerableExtendedAttributeList);
+    $hasOperation->type(makeSimpleType("any"));
+
+    my $entriesOperation = IDLOperation->new();
+    $entriesOperation->name("entries");
+    $entriesOperation->isSetLike(1);
+    $entriesOperation->extendedAttributes($notEnumerableExtendedAttributeList);
+    $entriesOperation->type(makeSimpleType("any"));
+
+    my $keysOperation = IDLOperation->new();
+    $keysOperation->name("keys");
+    $keysOperation->isSetLike(1);
+    $keysOperation->extendedAttributes($notEnumerableExtendedAttributeList);
+    $keysOperation->type(makeSimpleType("any"));
+
+    my $valuesOperation = IDLOperation->new();
+    $valuesOperation->name("values");
+    $valuesOperation->isSetLike(1);
+    $valuesOperation->extendedAttributes($extendedAttributeList);
+    $valuesOperation->extendedAttributes->{NotEnumerable} = 1;
+    $valuesOperation->type(makeSimpleType("any"));
+
+    my $forEachOperation = IDLOperation->new();
+    $forEachOperation->name("forEach");
+    $forEachOperation->isSetLike(1);
+    my $forEachArgument = IDLArgument->new();
+    $forEachArgument->name("callback");
+    $forEachArgument->type(makeSimpleType("any"));
+    $forEachArgument->extendedAttributes($extendedAttributeList);
+    push(@{$forEachOperation->arguments}, ($forEachArgument));
+    $forEachOperation->extendedAttributes($extendedAttributeList);
+    $forEachOperation->extendedAttributes->{Enumerable} = 1;
+    $forEachOperation->type(makeSimpleType("any"));
+
+    push(@{$setlike->operations}, $hasOperation);
+    push(@{$setlike->operations}, $entriesOperation);
+    push(@{$setlike->operations}, $keysOperation);
+    push(@{$setlike->operations}, $valuesOperation);
+    push(@{$setlike->operations}, $forEachOperation);
+
+    return $setlike if $isReadOnly;
+
     my $addOperation = IDLOperation->new();
     $addOperation->name("add");
-    $addOperation->isMapLike(1);
+    $addOperation->isSetLike(1);
     my $addArgument = IDLArgument->new();
     $addArgument->name("key");
-    $addArgument->type($maplike->keyType);
+    $addArgument->type($setlike->itemType);
     $addArgument->extendedAttributes($extendedAttributeList);
     push(@{$addOperation->arguments}, ($addArgument));
     $addOperation->extendedAttributes($notEnumerableExtendedAttributeList);
     $addOperation->type(makeSimpleType("any"));
 
     my $clearOperation = IDLOperation->new();
     $clearOperation->name("clear");
-    $clearOperation->isMapLike(1);
+    $clearOperation->isSetLike(1);
     $clearOperation->extendedAttributes($notEnumerableExtendedAttributeList);
     $clearOperation->type(makeSimpleType("void"));
 
     my $deleteOperation = IDLOperation->new();
     $deleteOperation->name("delete");
-    $deleteOperation->isMapLike(1);
+    $deleteOperation->isSetLike(1);
     my $deleteArgument = IDLArgument->new();
     $deleteArgument->name("key");
-    $deleteArgument->type($maplike->keyType);
+    $deleteArgument->type($setlike->itemType);
     $deleteArgument->extendedAttributes($extendedAttributeList);
     push(@{$deleteOperation->arguments}, ($deleteArgument));
     $deleteOperation->extendedAttributes($notEnumerableExtendedAttributeList);
     $deleteOperation->type(makeSimpleType("any"));
 
-    push(@{$maplike->operations}, $addOperation);
-    push(@{$maplike->operations}, $clearOperation);
-    push(@{$maplike->operations}, $deleteOperation);
+    push(@{$setlike->operations}, $addOperation);
+    push(@{$setlike->operations}, $clearOperation);
+    push(@{$setlike->operations}, $deleteOperation);
 
-    return $maplike;
+    return $setlike;
 }
 
 sub parseOperationRest
 {
     my $self = shift;
@@ -2849,10 +3013,14 @@
         }
         if (ref($item) eq "IDLMapLike") {
             $interface->mapLike($item);
             next;
         }
+        if (ref($item) eq "IDLSetLike") {
+            $interface->setLike($item);
+            next;
+        }
         if (ref($item) eq "IDLOperation") {
             if ($item->name eq "") {
                 push(@{$interface->anonymousOperations}, $item);
             } else {
                 push(@{$interface->operations}, $item);

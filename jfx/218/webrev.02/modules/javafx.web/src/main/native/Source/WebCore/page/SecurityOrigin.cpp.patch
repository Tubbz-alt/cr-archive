diff a/modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2007-2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -28,13 +28,14 @@
 
 #include "config.h"
 #include "SecurityOrigin.h"
 
 #include "BlobURL.h"
+#include "LegacySchemeRegistry.h"
 #include "OriginAccessEntry.h"
 #include "PublicSuffix.h"
-#include "SchemeRegistry.h"
+#include "RuntimeApplicationChecks.h"
 #include "SecurityPolicy.h"
 #include "TextEncoding.h"
 #include "ThreadableBlobRegistry.h"
 #include <wtf/FileSystem.h>
 #include <wtf/MainThread.h>
@@ -43,18 +44,25 @@
 #include <wtf/URL.h>
 #include <wtf/text/StringBuilder.h>
 
 namespace WebCore {
 
+constexpr unsigned maximumURLSize = 0x04000000;
+
 static bool schemeRequiresHost(const URL& url)
 {
     // We expect URLs with these schemes to have authority components. If the
     // URL lacks an authority component, we get concerned and mark the origin
     // as unique.
     return url.protocolIsInHTTPFamily() || url.protocolIs("ftp");
 }
 
+bool SecurityOrigin::shouldIgnoreHost(const URL& url)
+{
+    return url.protocolIsData() || url.protocolIsAbout() || protocolIsJavaScript(url) || url.protocolIs("file");
+}
+
 bool SecurityOrigin::shouldUseInnerURL(const URL& url)
 {
     // FIXME: Blob URLs don't have inner URLs. Their form is "blob:<inner-origin>/<UUID>", so treating the part after "blob:" as a URL is incorrect.
     if (url.protocolIsBlob())
         return true;
@@ -93,11 +101,11 @@
     // This is an additional safety net against bugs in URL parsing, and for network back-ends that parse URLs differently,
     // and could misinterpret another component for hostname.
     if (schemeRequiresHost(innerURL) && innerURL.host().isEmpty())
         return true;
 
-    if (SchemeRegistry::shouldTreatURLSchemeAsNoAccess(innerURL.protocol().toStringWithoutCopying()))
+    if (LegacySchemeRegistry::shouldTreatURLSchemeAsNoAccess(innerURL.protocol().toStringWithoutCopying()))
         return true;
 
     // This is the common case.
     return false;
 }
@@ -124,17 +132,17 @@
 }
 
 // https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy (Editor's Draft, 17 November 2016)
 static bool shouldTreatAsPotentiallyTrustworthy(const String& protocol, const String& host)
 {
-    if (SchemeRegistry::shouldTreatURLSchemeAsSecure(protocol))
+    if (LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(protocol))
         return true;
 
     if (SecurityOrigin::isLocalHostOrLoopbackIPAddress(host))
         return true;
 
-    if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))
+    if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))
         return true;
 
     return false;
 }
 
@@ -143,11 +151,11 @@
     return shouldTreatAsPotentiallyTrustworthy(url.protocol().toStringWithoutCopying(), url.host().toStringWithoutCopying());
 }
 
 SecurityOrigin::SecurityOrigin(const URL& url)
     : m_data(SecurityOriginData::fromURL(url))
-    , m_isLocal(SchemeRegistry::shouldTreatURLSchemeAsLocal(m_data.protocol))
+    , m_isLocal(LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_data.protocol))
 {
     // document.domain starts as m_data.host, but can be set by the DOM.
     m_domain = m_data.host;
 
     if (m_data.port && WTF::isDefaultPortForProtocol(m_data.port.value(), m_data.protocol))
@@ -227,15 +235,15 @@
 }
 
 bool SecurityOrigin::isSecure(const URL& url)
 {
     // Invalid URLs are secure, as are URLs which have a secure protocol.
-    if (!url.isValid() || SchemeRegistry::shouldTreatURLSchemeAsSecure(url.protocol().toStringWithoutCopying()))
+    if (!url.isValid() || LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(url.protocol().toStringWithoutCopying()))
         return true;
 
     // URLs that wrap inner URLs are secure if those inner URLs are secure.
-    if (shouldUseInnerURL(url) && SchemeRegistry::shouldTreatURLSchemeAsSecure(extractInnerURL(url).protocol().toStringWithoutCopying()))
+    if (shouldUseInnerURL(url) && LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(extractInnerURL(url).protocol().toStringWithoutCopying()))
         return true;
 
     return false;
 }
 
@@ -351,36 +359,40 @@
         || startsWithLettersIgnoringASCIICase(string, "feedsearch:https:");
 }
 
 bool SecurityOrigin::canDisplay(const URL& url) const
 {
+    ASSERT(!isInNetworkProcess());
     if (m_universalAccess)
         return true;
 
-#if !PLATFORM(IOS_FAMILY)
+    if (url.pathEnd() > maximumURLSize)
+        return false;
+
+#if !PLATFORM(IOS_FAMILY) && !ENABLE(BUBBLEWRAP_SANDBOX)
     if (m_data.protocol == "file" && url.isLocalFile() && !FileSystem::filesHaveSameVolume(m_filePath, url.fileSystemPath()))
         return false;
 #endif
 
     if (isFeedWithNestedProtocolInHTTPFamily(url))
         return true;
 
     String protocol = url.protocol().toString();
 
-    if (SchemeRegistry::canDisplayOnlyIfCanRequest(protocol))
+    if (LegacySchemeRegistry::canDisplayOnlyIfCanRequest(protocol))
         return canRequest(url);
 
-    if (SchemeRegistry::shouldTreatURLSchemeAsDisplayIsolated(protocol))
+    if (LegacySchemeRegistry::shouldTreatURLSchemeAsDisplayIsolated(protocol))
         return equalIgnoringASCIICase(m_data.protocol, protocol) || SecurityPolicy::isAccessToURLWhiteListed(this, url);
 
     if (!SecurityPolicy::restrictAccessToLocal())
         return true;
 
     if (url.isLocalFile() && url.fileSystemPath() == m_filePath)
         return true;
 
-    if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))
+    if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))
         return canLoadLocalResources() || SecurityPolicy::isAccessToURLWhiteListed(this, url);
 
     return true;
 }
 
@@ -480,11 +492,11 @@
         return emptyString();
 
     if (isHTTPFamily())
         return host();
 
-    if (SchemeRegistry::shouldPartitionCacheForURLScheme(m_data.protocol))
+    if (LegacySchemeRegistry::shouldPartitionCacheForURLScheme(m_data.protocol))
         return host();
 
     return emptyString();
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/MediaElementSession.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2014 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #if ENABLE(VIDEO)
  29 
  30 #include &quot;MediaElementSession.h&quot;
  31 
  32 #include &quot;Document.h&quot;
  33 #include &quot;DocumentLoader.h&quot;
  34 #include &quot;Frame.h&quot;
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;FullscreenManager.h&quot;
  37 #include &quot;HTMLAudioElement.h&quot;
  38 #include &quot;HTMLMediaElement.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;HTMLVideoElement.h&quot;
  41 #include &quot;HitTestResult.h&quot;
  42 #include &quot;Logging.h&quot;
  43 #include &quot;Page.h&quot;
  44 #include &quot;PlatformMediaSessionManager.h&quot;
  45 #include &quot;Quirks.h&quot;
  46 #include &quot;RenderMedia.h&quot;
  47 #include &quot;RenderView.h&quot;
  48 #include &quot;ScriptController.h&quot;
  49 #include &quot;Settings.h&quot;
  50 #include &quot;SourceBuffer.h&quot;
  51 #include &lt;wtf/text/StringBuilder.h&gt;
  52 
  53 #if PLATFORM(IOS_FAMILY)
  54 #include &quot;AudioSession.h&quot;
  55 #include &quot;RuntimeApplicationChecks.h&quot;
  56 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
  57 #endif
  58 
  59 namespace WebCore {
  60 
  61 static const Seconds clientDataBufferingTimerThrottleDelay { 100_ms };
  62 static const Seconds elementMainContentCheckInterval { 250_ms };
  63 
  64 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp;);
  65 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp;, MediaSessionMainContentPurpose);
  66 static bool isElementMainContentForPurposesOfAutoplay(const HTMLMediaElement&amp;, bool shouldHitTestMainFrame);
  67 
  68 #if !RELEASE_LOG_DISABLED
  69 static String restrictionNames(MediaElementSession::BehaviorRestrictions restriction)
  70 {
  71     StringBuilder restrictionBuilder;
  72 #define CASE(restrictionType) \
  73     if (restriction &amp; MediaElementSession::restrictionType) { \
  74         if (!restrictionBuilder.isEmpty()) \
  75             restrictionBuilder.appendLiteral(&quot;, &quot;); \
  76         restrictionBuilder.append(#restrictionType); \
  77     } \
  78 
  79     CASE(NoRestrictions)
  80     CASE(RequireUserGestureForLoad)
  81     CASE(RequireUserGestureForVideoRateChange)
  82     CASE(RequireUserGestureForAudioRateChange)
  83     CASE(RequireUserGestureForFullscreen)
  84     CASE(RequirePageConsentToLoadMedia)
  85     CASE(RequirePageConsentToResumeMedia)
  86     CASE(RequireUserGestureToShowPlaybackTargetPicker)
  87     CASE(WirelessVideoPlaybackDisabled)
  88     CASE(RequireUserGestureToAutoplayToExternalDevice)
  89     CASE(AutoPreloadingNotPermitted)
  90     CASE(InvisibleAutoplayNotPermitted)
  91     CASE(OverrideUserGestureRequirementForMainContent)
  92     CASE(RequireUserGestureToControlControlsManager)
  93     CASE(RequirePlaybackToControlControlsManager)
  94     CASE(RequireUserGestureForVideoDueToLowPowerMode)
  95 
  96     return restrictionBuilder.toString();
  97 }
  98 #endif
  99 
 100 static bool pageExplicitlyAllowsElementToAutoplayInline(const HTMLMediaElement&amp; element)
 101 {
 102     Document&amp; document = element.document();
 103     Page* page = document.page();
 104     return document.isMediaDocument() &amp;&amp; !document.ownerElement() &amp;&amp; page &amp;&amp; page-&gt;allowsMediaDocumentInlinePlayback();
 105 }
 106 
 107 MediaElementSession::MediaElementSession(HTMLMediaElement&amp; element)
 108     : PlatformMediaSession(element)
 109     , m_element(element)
 110     , m_restrictions(NoRestrictions)
 111 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 112     , m_targetAvailabilityChangedTimer(*this, &amp;MediaElementSession::targetAvailabilityChangedTimerFired)
 113     , m_hasPlaybackTargets(PlatformMediaSessionManager::sharedManager().hasWirelessTargetsAvailable())
 114 #endif
 115     , m_mainContentCheckTimer(*this, &amp;MediaElementSession::mainContentCheckTimerFired)
 116     , m_clientDataBufferingTimer(*this, &amp;MediaElementSession::clientDataBufferingTimerFired)
 117 #if !RELEASE_LOG_DISABLED
 118     , m_logIdentifier(element.logIdentifier())
 119 #endif
 120 {
 121 }
 122 
 123 void MediaElementSession::registerWithDocument(Document&amp; document)
 124 {
 125 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 126     document.addPlaybackTargetPickerClient(*this);
 127 #else
 128     UNUSED_PARAM(document);
 129 #endif
 130 }
 131 
 132 void MediaElementSession::unregisterWithDocument(Document&amp; document)
 133 {
 134 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 135     document.removePlaybackTargetPickerClient(*this);
 136 #else
 137     UNUSED_PARAM(document);
 138 #endif
 139 }
 140 
 141 void MediaElementSession::clientWillBeginAutoplaying()
 142 {
 143     PlatformMediaSession::clientWillBeginAutoplaying();
 144     m_elementIsHiddenBecauseItWasRemovedFromDOM = false;
 145     updateClientDataBuffering();
 146 }
 147 
 148 bool MediaElementSession::clientWillBeginPlayback()
 149 {
 150     if (!PlatformMediaSession::clientWillBeginPlayback())
 151         return false;
 152 
 153     m_elementIsHiddenBecauseItWasRemovedFromDOM = false;
 154     updateClientDataBuffering();
 155     return true;
 156 }
 157 
 158 bool MediaElementSession::clientWillPausePlayback()
 159 {
 160     if (!PlatformMediaSession::clientWillPausePlayback())
 161         return false;
 162 
 163     updateClientDataBuffering();
 164     return true;
 165 }
 166 
 167 void MediaElementSession::visibilityChanged()
 168 {
 169     scheduleClientDataBufferingCheck();
 170 
 171     if (m_element.elementIsHidden() &amp;&amp; !m_element.isFullscreen())
 172         m_elementIsHiddenUntilVisibleInViewport = true;
 173     else if (m_element.isVisibleInViewport())
 174         m_elementIsHiddenUntilVisibleInViewport = false;
 175 }
 176 
 177 void MediaElementSession::isVisibleInViewportChanged()
 178 {
 179     scheduleClientDataBufferingCheck();
 180 
 181     if (m_element.isFullscreen() || m_element.isVisibleInViewport())
 182         m_elementIsHiddenUntilVisibleInViewport = false;
 183 }
 184 
 185 void MediaElementSession::inActiveDocumentChanged()
 186 {
 187     m_elementIsHiddenBecauseItWasRemovedFromDOM = !m_element.inActiveDocument();
 188     scheduleClientDataBufferingCheck();
 189 }
 190 
 191 void MediaElementSession::scheduleClientDataBufferingCheck()
 192 {
 193     if (!m_clientDataBufferingTimer.isActive())
 194         m_clientDataBufferingTimer.startOneShot(clientDataBufferingTimerThrottleDelay);
 195 }
 196 
 197 void MediaElementSession::clientDataBufferingTimerFired()
 198 {
 199     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, m_element.elementIsHidden());
 200 
 201     updateClientDataBuffering();
 202 
 203 #if PLATFORM(IOS_FAMILY)
 204     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
 205 #endif
 206 
 207     if (state() != Playing || !m_element.elementIsHidden())
 208         return;
 209 
 210     PlatformMediaSessionManager::SessionRestrictions restrictions = PlatformMediaSessionManager::sharedManager().restrictions(mediaType());
 211     if ((restrictions &amp; PlatformMediaSessionManager::BackgroundTabPlaybackRestricted) == PlatformMediaSessionManager::BackgroundTabPlaybackRestricted)
 212         pauseSession();
 213 }
 214 
 215 void MediaElementSession::updateClientDataBuffering()
 216 {
 217     if (m_clientDataBufferingTimer.isActive())
 218         m_clientDataBufferingTimer.stop();
 219 
 220     m_element.setBufferingPolicy(preferredBufferingPolicy());
 221 }
 222 
 223 void MediaElementSession::addBehaviorRestriction(BehaviorRestrictions restrictions)
 224 {
 225     if (restrictions &amp; ~m_restrictions)
 226         INFO_LOG(LOGIDENTIFIER, &quot;adding &quot;, restrictionNames(restrictions &amp; ~m_restrictions));
 227 
 228     m_restrictions |= restrictions;
 229 
 230     if (restrictions &amp; OverrideUserGestureRequirementForMainContent)
 231         m_mainContentCheckTimer.startRepeating(elementMainContentCheckInterval);
 232 }
 233 
 234 void MediaElementSession::removeBehaviorRestriction(BehaviorRestrictions restriction)
 235 {
 236     if (restriction &amp; RequireUserGestureToControlControlsManager) {
 237         m_mostRecentUserInteractionTime = MonotonicTime::now();
 238         if (auto page = m_element.document().page())
 239             page-&gt;setAllowsPlaybackControlsForAutoplayingAudio(true);
 240     }
 241 
 242     if (!(m_restrictions &amp; restriction))
 243         return;
 244 
 245     INFO_LOG(LOGIDENTIFIER, &quot;removed &quot;, restrictionNames(m_restrictions &amp; restriction));
 246     m_restrictions &amp;= ~restriction;
 247 }
 248 
 249 SuccessOr&lt;MediaPlaybackDenialReason&gt; MediaElementSession::playbackPermitted() const
 250 {
 251     if (m_element.isSuspended()) {
 252         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is suspended&quot;);
 253         return MediaPlaybackDenialReason::InvalidState;
 254     }
 255 
 256     auto&amp; document = m_element.document();
 257     auto* page = document.page();
 258     if (!page || page-&gt;mediaPlaybackIsSuspended()) {
 259         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because media playback is suspended&quot;);
 260         return MediaPlaybackDenialReason::PageConsentRequired;
 261     }
 262 
 263     if (document.isMediaDocument() &amp;&amp; !document.ownerElement())
 264         return { };
 265 
 266     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 267         return { };
 268 
 269     if (requiresFullscreenForVideoPlayback() &amp;&amp; !fullscreenPermitted()) {
 270         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of fullscreen restriction&quot;);
 271         return MediaPlaybackDenialReason::FullscreenRequired;
 272     }
 273 
 274     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
 275         return { };
 276 
 277 #if ENABLE(MEDIA_STREAM)
 278     if (m_element.hasMediaStreamSrcObject()) {
 279         if (document.isCapturing())
 280             return { };
 281         if (document.mediaState() &amp; MediaProducer::IsPlayingAudio)
 282             return { };
 283     }
 284 #endif
 285 
 286     // FIXME: Why are we checking top-level document only for PerDocumentAutoplayBehavior?
 287     const auto&amp; topDocument = document.topDocument();
 288     if (topDocument.mediaState() &amp; MediaProducer::HasUserInteractedWithMediaElement &amp;&amp; topDocument.quirks().needsPerDocumentAutoplayBehavior())
 289         return { };
 290 
 291     if (document.hasHadUserInteraction() &amp;&amp; document.quirks().shouldAutoplayForArbitraryUserGesture())
 292         return { };
 293 
 294     if (m_restrictions &amp; RequireUserGestureForVideoRateChange &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
 295         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for video rate change restriction&quot;);
 296         return MediaPlaybackDenialReason::UserGestureRequired;
 297     }
 298 
 299     if (m_restrictions &amp; RequireUserGestureForAudioRateChange &amp;&amp; (!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume() &amp;&amp; !document.processingUserGestureForMedia()) {
 300         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because a user gesture is required for audio rate change restriction&quot;);
 301         return MediaPlaybackDenialReason::UserGestureRequired;
 302     }
 303 
 304     if (m_restrictions &amp; RequireUserGestureForVideoDueToLowPowerMode &amp;&amp; m_element.isVideo() &amp;&amp; !document.processingUserGestureForMedia()) {
 305         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because of video low power mode restriction&quot;);
 306         return MediaPlaybackDenialReason::UserGestureRequired;
 307     }
 308 
 309     return { };
 310 }
 311 
 312 bool MediaElementSession::autoplayPermitted() const
 313 {
 314     const Document&amp; document = m_element.document();
<a name="1" id="anc1"></a><span class="line-modified"> 315     if (document.backForwardCacheState() != Document::NotInBackForwardCache)</span>
 316         return false;
 317     if (document.activeDOMObjectsAreSuspended())
 318         return false;
 319 
 320     if (!hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
 321         return true;
 322 
 323     // If the media element is audible, allow autoplay even when not visible as pausing it would be observable by the user.
 324     if ((!m_element.isVideo() || m_element.hasAudio()) &amp;&amp; !m_element.muted() &amp;&amp; m_element.volume())
 325         return true;
 326 
 327     auto* renderer = m_element.renderer();
 328     if (!renderer) {
 329         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element has no renderer&quot;);
 330         return false;
 331     }
 332     if (renderer-&gt;style().visibility() != Visibility::Visible) {
 333         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible&quot;);
 334         return false;
 335     }
 336     if (renderer-&gt;view().frameView().isOffscreen()) {
 337         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because frame is offscreen&quot;);
 338         return false;
 339     }
 340     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes) {
 341         ALWAYS_LOG(LOGIDENTIFIER, &quot;Returning FALSE because element is not visible in the viewport&quot;);
 342         return false;
 343     }
 344     return true;
 345 }
 346 
 347 bool MediaElementSession::dataLoadingPermitted() const
 348 {
 349     if (m_restrictions &amp; OverrideUserGestureRequirementForMainContent &amp;&amp; updateIsMainContent())
 350         return true;
 351 
 352     if (m_restrictions &amp; RequireUserGestureForLoad &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
 353         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
 354         return false;
 355     }
 356 
 357     return true;
 358 }
 359 
 360 MediaPlayer::BufferingPolicy MediaElementSession::preferredBufferingPolicy() const
 361 {
 362     if (isSuspended())
 363         return MediaPlayer::BufferingPolicy::MakeResourcesPurgeable;
 364 
 365     if (bufferingSuspended())
 366         return MediaPlayer::BufferingPolicy::LimitReadAhead;
 367 
 368     if (state() == PlatformMediaSession::Playing)
 369         return MediaPlayer::BufferingPolicy::Default;
 370 
 371     if (shouldOverrideBackgroundLoadingRestriction())
 372         return MediaPlayer::BufferingPolicy::Default;
 373 
 374 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 375     if (m_shouldPlayToPlaybackTarget)
 376         return MediaPlayer::BufferingPolicy::Default;
 377 #endif
 378 
 379     if (m_elementIsHiddenUntilVisibleInViewport || m_elementIsHiddenBecauseItWasRemovedFromDOM || m_element.elementIsHidden())
 380         return MediaPlayer::BufferingPolicy::MakeResourcesPurgeable;
 381 
 382     return MediaPlayer::BufferingPolicy::Default;
 383 }
 384 
 385 bool MediaElementSession::fullscreenPermitted() const
 386 {
 387     if (m_restrictions &amp; RequireUserGestureForFullscreen &amp;&amp; !m_element.document().processingUserGestureForMedia()) {
 388         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
 389         return false;
 390     }
 391 
 392     return true;
 393 }
 394 
 395 bool MediaElementSession::pageAllowsDataLoading() const
 396 {
 397     Page* page = m_element.document().page();
 398     if (m_restrictions &amp; RequirePageConsentToLoadMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
 399         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
 400         return false;
 401     }
 402 
 403     return true;
 404 }
 405 
 406 bool MediaElementSession::pageAllowsPlaybackAfterResuming() const
 407 {
 408     Page* page = m_element.document().page();
 409     if (m_restrictions &amp; RequirePageConsentToResumeMedia &amp;&amp; page &amp;&amp; !page-&gt;canStartMedia()) {
 410         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE&quot;);
 411         return false;
 412     }
 413 
 414     return true;
 415 }
 416 
 417 bool MediaElementSession::canShowControlsManager(PlaybackControlsPurpose purpose) const
 418 {
 419     if (m_element.isSuspended() || !m_element.inActiveDocument()) {
 420         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: isSuspended()&quot;);
 421         return false;
 422     }
 423 
 424     if (m_element.isFullscreen()) {
 425         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is fullscreen&quot;);
 426         return true;
 427     }
 428 
 429     if (m_element.muted()) {
 430         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: muted&quot;);
 431         return false;
 432     }
 433 
 434     if (m_element.document().isMediaDocument() &amp;&amp; (m_element.document().frame() &amp;&amp; m_element.document().frame()-&gt;isMainFrame())) {
 435         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is media document&quot;);
 436         return true;
 437     }
 438 
<a name="2" id="anc2"></a><span class="line-modified"> 439     if (client().presentationType() == Audio &amp;&amp; purpose == PlaybackControlsPurpose::ControlsManager) {</span>
 440         if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
 441             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: audio element with user gesture&quot;);
 442             return true;
 443         }
 444 
 445         if (m_element.isPlaying() &amp;&amp; allowsPlaybackControlsForAutoplayingAudio()) {
 446             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: user has played media before&quot;);
 447             return true;
 448         }
 449 
 450         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: audio element is not suitable&quot;);
 451         return false;
 452     }
 453 
 454     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; !isElementRectMostlyInMainFrame(m_element)) {
 455         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: not in main frame&quot;);
 456         return false;
 457     }
 458 
 459     if (!m_element.hasAudio() &amp;&amp; !m_element.hasEverHadAudio()) {
 460         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no audio&quot;);
 461         return false;
 462     }
 463 
 464     if (!playbackPermitted()) {
 465         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: playback not permitted&quot;);
 466         return false;
 467     }
 468 
 469     if (!hasBehaviorRestriction(RequireUserGestureToControlControlsManager) || m_element.document().processingUserGestureForMedia()) {
 470         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: no user gesture required&quot;);
 471         return true;
 472     }
 473 
 474     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; hasBehaviorRestriction(RequirePlaybackToControlControlsManager) &amp;&amp; !m_element.isPlaying()) {
 475         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: needs to be playing&quot;);
 476         return false;
 477     }
 478 
 479     if (!m_element.hasEverNotifiedAboutPlaying()) {
 480         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: hasn&#39;t fired playing notification&quot;);
 481         return false;
 482     }
 483 
 484 #if ENABLE(FULLSCREEN_API)
 485     // Elements which are not descendents of the current fullscreen element cannot be main content.
 486     auto* fullscreenElement = m_element.document().fullscreenManager().currentFullscreenElement();
 487     if (fullscreenElement &amp;&amp; !m_element.isDescendantOf(*fullscreenElement)) {
 488         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: outside of full screen&quot;);
 489         return false;
 490     }
 491 #endif
 492 
 493     // Only allow the main content heuristic to forbid videos from showing up if our purpose is the controls manager.
 494     if (purpose == PlaybackControlsPurpose::ControlsManager &amp;&amp; m_element.isVideo()) {
 495         if (!m_element.renderer()) {
 496             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no renderer&quot;);
 497             return false;
 498         }
 499 
 500         if (!m_element.hasVideo() &amp;&amp; !m_element.hasEverHadVideo()) {
 501             INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no video&quot;);
 502             return false;
 503         }
 504 
 505         if (isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls)) {
 506             INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: is main content&quot;);
 507             return true;
 508         }
 509     }
 510 
 511     if (purpose == PlaybackControlsPurpose::NowPlaying) {
 512         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE: potentially plays audio&quot;);
 513         return true;
 514     }
 515 
 516     INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE: no user gesture&quot;);
 517     return false;
 518 }
 519 
 520 bool MediaElementSession::isLargeEnoughForMainContent(MediaSessionMainContentPurpose purpose) const
 521 {
 522     return isElementLargeEnoughForMainContent(m_element, purpose);
 523 }
 524 
 525 bool MediaElementSession::isMainContentForPurposesOfAutoplayEvents() const
 526 {
 527     return isElementMainContentForPurposesOfAutoplay(m_element, false);
 528 }
 529 
 530 MonotonicTime MediaElementSession::mostRecentUserInteractionTime() const
 531 {
 532     return m_mostRecentUserInteractionTime;
 533 }
 534 
 535 bool MediaElementSession::wantsToObserveViewportVisibilityForMediaControls() const
 536 {
 537     return isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls);
 538 }
 539 
 540 bool MediaElementSession::wantsToObserveViewportVisibilityForAutoplay() const
 541 {
 542     return m_element.isVideo();
 543 }
 544 
 545 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 546 void MediaElementSession::showPlaybackTargetPicker()
 547 {
 548     INFO_LOG(LOGIDENTIFIER);
 549 
 550     auto&amp; document = m_element.document();
 551     if (m_restrictions &amp; RequireUserGestureToShowPlaybackTargetPicker &amp;&amp; !document.processingUserGestureForMedia()) {
 552         INFO_LOG(LOGIDENTIFIER, &quot;returning early because of permissions&quot;);
 553         return;
 554     }
 555 
 556     if (!document.page()) {
 557         INFO_LOG(LOGIDENTIFIER, &quot;returning early because page is NULL&quot;);
 558         return;
 559     }
 560 
 561 #if !PLATFORM(IOS_FAMILY)
 562     if (m_element.readyState() &lt; HTMLMediaElementEnums::HAVE_METADATA) {
 563         INFO_LOG(LOGIDENTIFIER, &quot;returning early because element is not playable&quot;);
 564         return;
 565     }
 566 #endif
 567 
 568     auto&amp; audioSession = AudioSession::sharedSession();
 569     document.showPlaybackTargetPicker(*this, is&lt;HTMLVideoElement&gt;(m_element), audioSession.routeSharingPolicy(), audioSession.routingContextUID());
 570 }
 571 
 572 bool MediaElementSession::hasWirelessPlaybackTargets() const
 573 {
 574     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, m_hasPlaybackTargets);
 575 
 576     return m_hasPlaybackTargets;
 577 }
 578 
 579 bool MediaElementSession::wirelessVideoPlaybackDisabled() const
 580 {
 581     if (!m_element.document().settings().allowsAirPlayForMediaPlayback()) {
 582         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of settings&quot;);
 583         return true;
 584     }
 585 
 586     if (m_element.hasAttributeWithoutSynchronization(HTMLNames::webkitwirelessvideoplaybackdisabledAttr)) {
 587         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of attribute&quot;);
 588         return true;
 589     }
 590 
 591 #if PLATFORM(IOS_FAMILY)
 592     auto&amp; legacyAirplayAttributeValue = m_element.attributeWithoutSynchronization(HTMLNames::webkitairplayAttr);
 593     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;deny&quot;)) {
 594         INFO_LOG(LOGIDENTIFIER, &quot;returning TRUE because of legacy attribute&quot;);
 595         return true;
 596     }
 597     if (equalLettersIgnoringASCIICase(legacyAirplayAttributeValue, &quot;allow&quot;)) {
 598         INFO_LOG(LOGIDENTIFIER, &quot;returning FALSE because of legacy attribute&quot;);
 599         return false;
 600     }
 601 #endif
 602 
<a name="3" id="anc3"></a><span class="line-added"> 603     if (m_element.document().settings().remotePlaybackEnabled() &amp;&amp; m_element.hasAttributeWithoutSynchronization(HTMLNames::disableremoteplaybackAttr)) {</span>
<span class="line-added"> 604         LOG(Media, &quot;MediaElementSession::wirelessVideoPlaybackDisabled - returning TRUE because of RemotePlayback attribute&quot;);</span>
<span class="line-added"> 605         return true;</span>
<span class="line-added"> 606     }</span>
<span class="line-added"> 607 </span>
 608     auto player = m_element.player();
 609     if (!player)
 610         return true;
 611 
 612     bool disabled = player-&gt;wirelessVideoPlaybackDisabled();
 613     INFO_LOG(LOGIDENTIFIER, &quot;returning &quot;, disabled, &quot; because media engine says so&quot;);
 614 
 615     return disabled;
 616 }
 617 
 618 void MediaElementSession::setWirelessVideoPlaybackDisabled(bool disabled)
 619 {
 620     if (disabled)
 621         addBehaviorRestriction(WirelessVideoPlaybackDisabled);
 622     else
 623         removeBehaviorRestriction(WirelessVideoPlaybackDisabled);
 624 
 625     auto player = m_element.player();
 626     if (!player)
 627         return;
 628 
 629     INFO_LOG(LOGIDENTIFIER, disabled);
 630     player-&gt;setWirelessVideoPlaybackDisabled(disabled);
 631 }
 632 
 633 void MediaElementSession::setHasPlaybackTargetAvailabilityListeners(bool hasListeners)
 634 {
 635     INFO_LOG(LOGIDENTIFIER, hasListeners);
 636 
 637 #if PLATFORM(IOS_FAMILY)
 638     m_hasPlaybackTargetAvailabilityListeners = hasListeners;
 639     PlatformMediaSessionManager::sharedManager().configureWireLessTargetMonitoring();
 640 #else
 641     UNUSED_PARAM(hasListeners);
 642     m_element.document().playbackTargetPickerClientStateDidChange(*this, m_element.mediaState());
 643 #endif
 644 }
 645 
 646 void MediaElementSession::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
 647 {
 648     m_playbackTarget = WTFMove(device);
 649     client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
 650 }
 651 
 652 void MediaElementSession::targetAvailabilityChangedTimerFired()
 653 {
 654     client().wirelessRoutesAvailableDidChange();
 655 }
 656 
 657 void MediaElementSession::externalOutputDeviceAvailableDidChange(bool hasTargets)
 658 {
 659     if (m_hasPlaybackTargets == hasTargets)
 660         return;
 661 
 662     INFO_LOG(LOGIDENTIFIER, hasTargets);
 663 
 664     m_hasPlaybackTargets = hasTargets;
 665     m_targetAvailabilityChangedTimer.startOneShot(0_s);
 666 }
 667 
 668 bool MediaElementSession::isPlayingToWirelessPlaybackTarget() const
 669 {
 670 #if !PLATFORM(IOS_FAMILY)
 671     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute())
 672         return false;
 673 #endif
 674 
 675     return client().isPlayingToWirelessPlaybackTarget();
 676 }
 677 
 678 void MediaElementSession::setShouldPlayToPlaybackTarget(bool shouldPlay)
 679 {
 680     INFO_LOG(LOGIDENTIFIER, shouldPlay);
 681     m_shouldPlayToPlaybackTarget = shouldPlay;
 682     updateClientDataBuffering();
 683     client().setShouldPlayToPlaybackTarget(shouldPlay);
 684 }
 685 
<a name="4" id="anc4"></a><span class="line-added"> 686 void MediaElementSession::playbackTargetPickerWasDismissed()</span>
<span class="line-added"> 687 {</span>
<span class="line-added"> 688     INFO_LOG(LOGIDENTIFIER);</span>
<span class="line-added"> 689     client().playbackTargetPickerWasDismissed();</span>
<span class="line-added"> 690 }</span>
<span class="line-added"> 691 </span>
 692 void MediaElementSession::mediaStateDidChange(MediaProducer::MediaStateFlags state)
 693 {
 694     m_element.document().playbackTargetPickerClientStateDidChange(*this, state);
 695 }
 696 #endif
 697 
 698 MediaPlayer::Preload MediaElementSession::effectivePreloadForElement() const
 699 {
 700     MediaPlayer::Preload preload = m_element.preloadValue();
 701 
 702     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 703         return preload;
 704 
 705     if (m_restrictions &amp; AutoPreloadingNotPermitted) {
<a name="5" id="anc5"></a><span class="line-modified"> 706         if (preload &gt; MediaPlayer::Preload::MetaData)</span>
<span class="line-modified"> 707             return MediaPlayer::Preload::MetaData;</span>
 708     }
 709 
 710     return preload;
 711 }
 712 
 713 bool MediaElementSession::requiresFullscreenForVideoPlayback() const
 714 {
 715     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 716         return false;
 717 
 718     if (is&lt;HTMLAudioElement&gt;(m_element))
 719         return false;
 720 
 721     if (m_element.document().isMediaDocument()) {
 722         ASSERT(is&lt;HTMLVideoElement&gt;(m_element));
 723         const HTMLVideoElement&amp; videoElement = *downcast&lt;const HTMLVideoElement&gt;(&amp;m_element);
 724         if (m_element.readyState() &lt; HTMLVideoElement::HAVE_METADATA || !videoElement.hasEverHadVideo())
 725             return false;
 726     }
 727 
 728     if (m_element.isTemporarilyAllowingInlinePlaybackAfterFullscreen())
 729         return false;
 730 
 731     if (!m_element.document().settings().allowsInlineMediaPlayback())
 732         return true;
 733 
 734     if (!m_element.document().settings().inlineMediaPlaybackRequiresPlaysInlineAttribute())
 735         return false;
 736 
 737 #if PLATFORM(IOS_FAMILY)
 738     if (IOSApplication::isIBooks())
 739         return !m_element.hasAttributeWithoutSynchronization(HTMLNames::webkit_playsinlineAttr) &amp;&amp; !m_element.hasAttributeWithoutSynchronization(HTMLNames::playsinlineAttr);
 740     if (dyld_get_program_sdk_version() &lt; DYLD_IOS_VERSION_10_0)
 741         return !m_element.hasAttributeWithoutSynchronization(HTMLNames::webkit_playsinlineAttr);
 742 #endif
 743 
 744     if (m_element.document().isMediaDocument() &amp;&amp; m_element.document().ownerElement())
 745         return false;
 746 
 747     return !m_element.hasAttributeWithoutSynchronization(HTMLNames::playsinlineAttr);
 748 }
 749 
 750 bool MediaElementSession::allowsAutomaticMediaDataLoading() const
 751 {
 752     if (pageExplicitlyAllowsElementToAutoplayInline(m_element))
 753         return true;
 754 
 755     if (m_element.document().settings().mediaDataLoadsAutomatically())
 756         return true;
 757 
 758     return false;
 759 }
 760 
 761 void MediaElementSession::mediaEngineUpdated()
 762 {
 763     INFO_LOG(LOGIDENTIFIER);
 764 
 765 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 766     if (m_restrictions &amp; WirelessVideoPlaybackDisabled)
 767         setWirelessVideoPlaybackDisabled(true);
 768     if (m_playbackTarget)
 769         client().setWirelessPlaybackTarget(*m_playbackTarget.copyRef());
 770     if (m_shouldPlayToPlaybackTarget)
 771         client().setShouldPlayToPlaybackTarget(true);
 772 #endif
 773 
 774 }
 775 
 776 void MediaElementSession::resetPlaybackSessionState()
 777 {
 778     m_mostRecentUserInteractionTime = MonotonicTime();
 779     addBehaviorRestriction(RequireUserGestureToControlControlsManager | RequirePlaybackToControlControlsManager);
 780 }
 781 
 782 void MediaElementSession::suspendBuffering()
 783 {
 784     updateClientDataBuffering();
 785 }
 786 
 787 void MediaElementSession::resumeBuffering()
 788 {
 789     updateClientDataBuffering();
 790 }
 791 
 792 bool MediaElementSession::bufferingSuspended() const
 793 {
 794     if (auto* page = m_element.document().page())
 795         return page-&gt;mediaBufferingIsSuspended();
 796     return true;
 797 }
 798 
 799 bool MediaElementSession::allowsPictureInPicture() const
 800 {
 801     return m_element.document().settings().allowsPictureInPictureMediaPlayback();
 802 }
 803 
 804 #if PLATFORM(IOS_FAMILY)
 805 bool MediaElementSession::requiresPlaybackTargetRouteMonitoring() const
 806 {
 807     return m_hasPlaybackTargetAvailabilityListeners &amp;&amp; !m_element.elementIsHidden();
 808 }
 809 #endif
 810 
 811 #if ENABLE(MEDIA_SOURCE)
 812 size_t MediaElementSession::maximumMediaSourceBufferSize(const SourceBuffer&amp; buffer) const
 813 {
 814     // A good quality 1080p video uses 8,000 kbps and stereo audio uses 384 kbps, so assume 95% for video and 5% for audio.
 815     const float bufferBudgetPercentageForVideo = .95;
 816     const float bufferBudgetPercentageForAudio = .05;
 817 
 818     size_t maximum = buffer.document().settings().maximumSourceBufferSize();
 819 
 820     // Allow a SourceBuffer to buffer as though it is audio-only even if it doesn&#39;t have any active tracks (yet).
 821     size_t bufferSize = static_cast&lt;size_t&gt;(maximum * bufferBudgetPercentageForAudio);
 822     if (buffer.hasVideo())
 823         bufferSize += static_cast&lt;size_t&gt;(maximum * bufferBudgetPercentageForVideo);
 824 
 825     // FIXME: we might want to modify this algorithm to:
 826     // - decrease the maximum size for background tabs
 827     // - decrease the maximum size allowed for inactive elements when a process has more than one
 828     //   element, eg. so a page with many elements which are played one at a time doesn&#39;t keep
 829     //   everything buffered after an element has finished playing.
 830 
 831     return bufferSize;
 832 }
 833 #endif
 834 
 835 static bool isElementMainContentForPurposesOfAutoplay(const HTMLMediaElement&amp; element, bool shouldHitTestMainFrame)
 836 {
 837     Document&amp; document = element.document();
 838     if (!document.hasLivingRenderTree() || document.activeDOMObjectsAreStopped() || element.isSuspended() || !element.hasAudio() || !element.hasVideo())
 839         return false;
 840 
 841     // Elements which have not yet been laid out, or which are not yet in the DOM, cannot be main content.
 842     auto* renderer = element.renderer();
 843     if (!renderer)
 844         return false;
 845 
 846     if (!isElementLargeEnoughForMainContent(element, MediaSessionMainContentPurpose::Autoplay))
 847         return false;
 848 
 849     // Elements which are hidden by style, or have been scrolled out of view, cannot be main content.
 850     // But elements which have audio &amp; video and are already playing should not stop playing because
 851     // they are scrolled off the page.
 852     if (renderer-&gt;style().visibility() != Visibility::Visible)
 853         return false;
 854     if (renderer-&gt;visibleInViewportState() != VisibleInViewportState::Yes &amp;&amp; !element.isPlaying())
 855         return false;
 856 
 857     // Main content elements must be in the main frame.
 858     if (!document.frame() || !document.frame()-&gt;isMainFrame())
 859         return false;
 860 
 861     auto&amp; mainFrame = document.frame()-&gt;mainFrame();
 862     if (!mainFrame.view() || !mainFrame.view()-&gt;renderView())
 863         return false;
 864 
 865     if (!shouldHitTestMainFrame)
 866         return true;
 867 
 868     // Hit test the area of the main frame where the element appears, to determine if the element is being obscured.
 869     IntRect rectRelativeToView = element.clientRect();
 870     ScrollPosition scrollPosition = mainFrame.view()-&gt;documentScrollPositionRelativeToViewOrigin();
 871     IntRect rectRelativeToTopDocument(rectRelativeToView.location() + scrollPosition, rectRelativeToView.size());
 872     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent | HitTestRequest::IgnoreClipping | HitTestRequest::DisallowUserAgentShadowContent);
 873     HitTestResult result(rectRelativeToTopDocument.center());
 874 
 875     // Elements which are obscured by other elements cannot be main content.
 876     if (!mainFrame.document())
 877         return false;
 878     mainFrame.document()-&gt;hitTest(request, result);
 879     result.setToNonUserAgentShadowAncestor();
 880     RefPtr&lt;Element&gt; hitElement = result.targetElement();
 881     if (hitElement != &amp;element)
 882         return false;
 883 
 884     return true;
 885 }
 886 
 887 static bool isElementRectMostlyInMainFrame(const HTMLMediaElement&amp; element)
 888 {
 889     if (!element.renderer())
 890         return false;
 891 
 892     auto documentFrame = makeRefPtr(element.document().frame());
 893     if (!documentFrame)
 894         return false;
 895 
 896     auto mainFrameView = documentFrame-&gt;mainFrame().view();
 897     if (!mainFrameView)
 898         return false;
 899 
 900     IntRect mainFrameRectAdjustedForScrollPosition = IntRect(-mainFrameView-&gt;documentScrollPositionRelativeToViewOrigin(), mainFrameView-&gt;contentsSize());
 901     IntRect elementRectInMainFrame = element.clientRect();
 902     auto totalElementArea = elementRectInMainFrame.area&lt;RecordOverflow&gt;();
 903     if (totalElementArea.hasOverflowed())
 904         return false;
 905 
 906     elementRectInMainFrame.intersect(mainFrameRectAdjustedForScrollPosition);
 907 
 908     return elementRectInMainFrame.area().unsafeGet() &gt; totalElementArea.unsafeGet() / 2;
 909 }
 910 
 911 static bool isElementLargeRelativeToMainFrame(const HTMLMediaElement&amp; element)
 912 {
 913     static const double minimumPercentageOfMainFrameAreaForMainContent = 0.9;
 914     auto* renderer = element.renderer();
 915     if (!renderer)
 916         return false;
 917 
 918     auto documentFrame = makeRefPtr(element.document().frame());
 919     if (!documentFrame)
 920         return false;
 921 
 922     if (!documentFrame-&gt;mainFrame().view())
 923         return false;
 924 
 925     auto&amp; mainFrameView = *documentFrame-&gt;mainFrame().view();
 926     auto maxVisibleClientWidth = std::min(renderer-&gt;clientWidth().toInt(), mainFrameView.visibleWidth());
 927     auto maxVisibleClientHeight = std::min(renderer-&gt;clientHeight().toInt(), mainFrameView.visibleHeight());
 928 
 929     return maxVisibleClientWidth * maxVisibleClientHeight &gt; minimumPercentageOfMainFrameAreaForMainContent * mainFrameView.visibleWidth() * mainFrameView.visibleHeight();
 930 }
 931 
 932 static bool isElementLargeEnoughForMainContent(const HTMLMediaElement&amp; element, MediaSessionMainContentPurpose purpose)
 933 {
 934     static const double elementMainContentAreaMinimum = 400 * 300;
 935     static const double maximumAspectRatio = purpose == MediaSessionMainContentPurpose::MediaControls ? 3 : 1.8;
 936     static const double minimumAspectRatio = .5; // Slightly smaller than 9:16.
 937 
 938     // Elements which have not yet been laid out, or which are not yet in the DOM, cannot be main content.
 939     auto* renderer = element.renderer();
 940     if (!renderer)
 941         return false;
 942 
 943     double width = renderer-&gt;clientWidth();
 944     double height = renderer-&gt;clientHeight();
 945     double area = width * height;
 946     double aspectRatio = width / height;
 947 
 948     if (area &lt; elementMainContentAreaMinimum)
 949         return false;
 950 
 951     if (aspectRatio &gt;= minimumAspectRatio &amp;&amp; aspectRatio &lt;= maximumAspectRatio)
 952         return true;
 953 
 954     return isElementLargeRelativeToMainFrame(element);
 955 }
 956 
 957 void MediaElementSession::mainContentCheckTimerFired()
 958 {
 959     if (!hasBehaviorRestriction(OverrideUserGestureRequirementForMainContent))
 960         return;
 961 
 962     updateIsMainContent();
 963 }
 964 
 965 bool MediaElementSession::updateIsMainContent() const
 966 {
 967     if (m_element.isSuspended())
 968         return false;
 969 
 970     bool wasMainContent = m_isMainContent;
 971     m_isMainContent = isElementMainContentForPurposesOfAutoplay(m_element, true);
 972 
 973     if (m_isMainContent != wasMainContent)
 974         m_element.updateShouldPlay();
 975 
 976     return m_isMainContent;
 977 }
 978 
 979 bool MediaElementSession::allowsNowPlayingControlsVisibility() const
 980 {
 981     auto page = m_element.document().page();
 982     return page &amp;&amp; !page-&gt;isVisibleAndActive();
 983 }
 984 
 985 bool MediaElementSession::allowsPlaybackControlsForAutoplayingAudio() const
 986 {
 987     auto page = m_element.document().page();
 988     return page &amp;&amp; page-&gt;allowsPlaybackControlsForAutoplayingAudio();
 989 }
 990 
 991 String convertEnumerationToString(const MediaPlaybackDenialReason enumerationValue)
 992 {
 993     static const NeverDestroyed&lt;String&gt; values[] = {
 994         MAKE_STATIC_STRING_IMPL(&quot;UserGestureRequired&quot;),
 995         MAKE_STATIC_STRING_IMPL(&quot;FullscreenRequired&quot;),
 996         MAKE_STATIC_STRING_IMPL(&quot;PageConsentRequired&quot;),
 997         MAKE_STATIC_STRING_IMPL(&quot;InvalidState&quot;),
 998     };
 999     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::UserGestureRequired) == 0, &quot;MediaPlaybackDenialReason::UserGestureRequired is not 0 as expected&quot;);
1000     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::FullscreenRequired) == 1, &quot;MediaPlaybackDenialReason::FullscreenRequired is not 1 as expected&quot;);
1001     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::PageConsentRequired) == 2, &quot;MediaPlaybackDenialReason::PageConsentRequired is not 2 as expected&quot;);
1002     static_assert(static_cast&lt;size_t&gt;(MediaPlaybackDenialReason::InvalidState) == 3, &quot;MediaPlaybackDenialReason::InvalidState is not 3 as expected&quot;);
1003     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1004     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1005 }
1006 
1007 }
1008 
1009 #endif // ENABLE(VIDEO)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
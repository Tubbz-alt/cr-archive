diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/text/AtomStringImpl.cpp b/modules/javafx.web/src/main/native/Source/WTF/wtf/text/AtomStringImpl.cpp
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/text/AtomStringImpl.cpp
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/text/AtomStringImpl.cpp
@@ -65,11 +65,11 @@
     AtomStringTableLocker() { }
 };
 
 #endif // USE(WEB_THREAD)
 
-using StringTableImpl = HashSet<StringImpl*>;
+using StringTableImpl = HashSet<PackedPtr<StringImpl>>;
 
 static ALWAYS_INLINE StringTableImpl& stringTable()
 {
     return Thread::current().atomStringTable()->table();
 }
@@ -80,12 +80,12 @@
     auto addResult = atomStringTable.add<HashTranslator>(value);
 
     // If the string is newly-translated, then we need to adopt it.
     // The boolean in the pair tells us if that is so.
     if (addResult.isNewEntry)
-        return adoptRef(static_cast<AtomStringImpl&>(**addResult.iterator));
-    return *static_cast<AtomStringImpl*>(*addResult.iterator);
+        return adoptRef(static_cast<AtomStringImpl&>(*addResult.iterator->get()));
+    return *static_cast<AtomStringImpl*>(addResult.iterator->get());
 }
 
 template<typename T, typename HashTranslator>
 static inline Ref<AtomStringImpl> addToStringTable(const T& value)
 {
@@ -97,20 +97,21 @@
     static unsigned hash(const LChar* characters)
     {
         return StringHasher::computeHashAndMaskTop8Bits(characters);
     }
 
-    static inline bool equal(StringImpl* str, const LChar* characters)
+    static inline bool equal(PackedPtr<StringImpl> str, const LChar* characters)
     {
-        return WTF::equal(str, characters);
+        return WTF::equal(str.get(), characters);
     }
 
-    static void translate(StringImpl*& location, const LChar* const& characters, unsigned hash)
+    static void translate(PackedPtr<StringImpl>& location, const LChar* const& characters, unsigned hash)
     {
-        location = &StringImpl::create(characters).leakRef();
-        location->setHash(hash);
-        location->setIsAtom(true);
+        auto* pointer = &StringImpl::create(characters).leakRef();
+        pointer->setHash(hash);
+        pointer->setIsAtom(true);
+        location = pointer;
     }
 };
 
 RefPtr<AtomStringImpl> AtomStringImpl::add(const LChar* characters)
 {
@@ -148,20 +149,21 @@
     static unsigned hash(const UCharBuffer& buf)
     {
         return buf.hash;
     }
 
-    static bool equal(StringImpl* const& str, const UCharBuffer& buf)
+    static bool equal(PackedPtr<StringImpl> const& str, const UCharBuffer& buf)
     {
-        return WTF::equal(str, buf.characters, buf.length);
+        return WTF::equal(str.get(), buf.characters, buf.length);
     }
 
-    static void translate(StringImpl*& location, const UCharBuffer& buf, unsigned hash)
+    static void translate(PackedPtr<StringImpl>& location, const UCharBuffer& buf, unsigned hash)
     {
-        location = &StringImpl::create8BitIfPossible(buf.characters, buf.length).leakRef();
-        location->setHash(hash);
-        location->setIsAtom(true);
+        auto* pointer = &StringImpl::create8BitIfPossible(buf.characters, buf.length).leakRef();
+        pointer->setHash(hash);
+        pointer->setIsAtom(true);
+        location = pointer;
     }
 };
 
 struct HashAndUTF8Characters {
     unsigned hash;
@@ -174,12 +176,13 @@
     static unsigned hash(const HashAndUTF8Characters& buffer)
     {
         return buffer.hash;
     }
 
-    static bool equal(StringImpl* const& string, const HashAndUTF8Characters& buffer)
+    static bool equal(PackedPtr<StringImpl> const& passedString, const HashAndUTF8Characters& buffer)
     {
+        auto* string = passedString.get();
         if (buffer.utf16Length != string->length())
             return false;
 
         // If buffer contains only ASCII characters UTF-8 and UTF16 length are the same.
         if (buffer.utf16Length != buffer.length) {
@@ -210,11 +213,11 @@
         }
 
         return true;
     }
 
-    static void translate(StringImpl*& location, const HashAndUTF8Characters& buffer, unsigned hash)
+    static void translate(PackedPtr<StringImpl>& location, const HashAndUTF8Characters& buffer, unsigned hash)
     {
         UChar* target;
         auto newString = StringImpl::createUninitialized(buffer.utf16Length, target);
 
         bool isAllASCII;
@@ -223,13 +226,14 @@
             ASSERT_NOT_REACHED();
 
         if (isAllASCII)
             newString = StringImpl::create(buffer.characters, buffer.length);
 
-        location = &newString.leakRef();
-        location->setHash(hash);
-        location->setIsAtom(true);
+        auto* pointer = &newString.leakRef();
+        pointer->setHash(hash);
+        pointer->setIsAtom(true);
+        location = pointer;
     }
 };
 
 RefPtr<AtomStringImpl> AtomStringImpl::add(const UChar* characters, unsigned length)
 {
@@ -264,39 +268,40 @@
     unsigned start;
     unsigned length;
 };
 
 struct SubstringTranslator {
-    static void translate(StringImpl*& location, const SubstringLocation& buffer, unsigned hash)
+    static void translate(PackedPtr<StringImpl>& location, const SubstringLocation& buffer, unsigned hash)
     {
-        location = &StringImpl::createSubstringSharingImpl(*buffer.baseString, buffer.start, buffer.length).leakRef();
-        location->setHash(hash);
-        location->setIsAtom(true);
+        auto* pointer = &StringImpl::createSubstringSharingImpl(*buffer.baseString, buffer.start, buffer.length).leakRef();
+        pointer->setHash(hash);
+        pointer->setIsAtom(true);
+        location = pointer;
     }
 };
 
 struct SubstringTranslator8 : SubstringTranslator {
     static unsigned hash(const SubstringLocation& buffer)
     {
         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString->characters8() + buffer.start, buffer.length);
     }
 
-    static bool equal(StringImpl* const& string, const SubstringLocation& buffer)
+    static bool equal(PackedPtr<StringImpl> const& string, const SubstringLocation& buffer)
     {
-        return WTF::equal(string, buffer.baseString->characters8() + buffer.start, buffer.length);
+        return WTF::equal(string.get(), buffer.baseString->characters8() + buffer.start, buffer.length);
     }
 };
 
 struct SubstringTranslator16 : SubstringTranslator {
     static unsigned hash(const SubstringLocation& buffer)
     {
         return StringHasher::computeHashAndMaskTop8Bits(buffer.baseString->characters16() + buffer.start, buffer.length);
     }
 
-    static bool equal(StringImpl* const& string, const SubstringLocation& buffer)
+    static bool equal(PackedPtr<StringImpl> const& string, const SubstringLocation& buffer)
     {
-        return WTF::equal(string, buffer.baseString->characters16() + buffer.start, buffer.length);
+        return WTF::equal(string.get(), buffer.baseString->characters16() + buffer.start, buffer.length);
     }
 };
 
 RefPtr<AtomStringImpl> AtomStringImpl::add(StringImpl* baseString, unsigned start, unsigned length)
 {
@@ -324,20 +329,21 @@
     static unsigned hash(const LCharBuffer& buf)
     {
         return buf.hash;
     }
 
-    static bool equal(StringImpl* const& str, const LCharBuffer& buf)
+    static bool equal(PackedPtr<StringImpl> const& str, const LCharBuffer& buf)
     {
-        return WTF::equal(str, buf.characters, buf.length);
+        return WTF::equal(str.get(), buf.characters, buf.length);
     }
 
-    static void translate(StringImpl*& location, const LCharBuffer& buf, unsigned hash)
+    static void translate(PackedPtr<StringImpl>& location, const LCharBuffer& buf, unsigned hash)
     {
-        location = &StringImpl::create(buf.characters, buf.length).leakRef();
-        location->setHash(hash);
-        location->setIsAtom(true);
+        auto* pointer = &StringImpl::create(buf.characters, buf.length).leakRef();
+        pointer->setHash(hash);
+        pointer->setIsAtom(true);
+        location = pointer;
     }
 };
 
 template<typename CharType>
 struct BufferFromStaticDataTranslator {
@@ -345,20 +351,21 @@
     static unsigned hash(const Buffer& buf)
     {
         return buf.hash;
     }
 
-    static bool equal(StringImpl* const& str, const Buffer& buf)
+    static bool equal(PackedPtr<StringImpl> const& str, const Buffer& buf)
     {
-        return WTF::equal(str, buf.characters, buf.length);
+        return WTF::equal(str.get(), buf.characters, buf.length);
     }
 
-    static void translate(StringImpl*& location, const Buffer& buf, unsigned hash)
+    static void translate(PackedPtr<StringImpl>& location, const Buffer& buf, unsigned hash)
     {
-        location = &StringImpl::createWithoutCopying(buf.characters, buf.length).leakRef();
-        location->setHash(hash);
-        location->setIsAtom(true);
+        auto* pointer = &StringImpl::createWithoutCopying(buf.characters, buf.length).leakRef();
+        pointer->setHash(hash);
+        pointer->setIsAtom(true);
+        location = pointer;
     }
 };
 
 RefPtr<AtomStringImpl> AtomStringImpl::add(const LChar* characters, unsigned length)
 {
@@ -441,15 +448,15 @@
 
     AtomStringTableLocker locker;
     auto addResult = stringTable().add(&string);
 
     if (addResult.isNewEntry) {
-        ASSERT(*addResult.iterator == &string);
+        ASSERT(addResult.iterator->get() == &string);
         string.setIsAtom(true);
     }
 
-    return *static_cast<AtomStringImpl*>(*addResult.iterator);
+    return *static_cast<AtomStringImpl*>(addResult.iterator->get());
 }
 
 Ref<AtomStringImpl> AtomStringImpl::addSlowCase(AtomStringTable& stringTable, StringImpl& string)
 {
     // This check is necessary for null symbols.
@@ -471,25 +478,25 @@
 
     AtomStringTableLocker locker;
     auto addResult = stringTable.table().add(&string);
 
     if (addResult.isNewEntry) {
-        ASSERT(*addResult.iterator == &string);
+        ASSERT(addResult.iterator->get() == &string);
         string.setIsAtom(true);
     }
 
-    return *static_cast<AtomStringImpl*>(*addResult.iterator);
+    return *static_cast<AtomStringImpl*>(addResult.iterator->get());
 }
 
 void AtomStringImpl::remove(AtomStringImpl* string)
 {
     ASSERT(string->isAtom());
     AtomStringTableLocker locker;
     auto& atomStringTable = stringTable();
     auto iterator = atomStringTable.find(string);
     ASSERT_WITH_MESSAGE(iterator != atomStringTable.end(), "The string being removed is an atom in the string table of an other thread!");
-    ASSERT(string == *iterator);
+    ASSERT(string == iterator->get());
     atomStringTable.remove(iterator);
 }
 
 RefPtr<AtomStringImpl> AtomStringImpl::lookUpSlowCase(StringImpl& string)
 {
@@ -500,11 +507,11 @@
 
     AtomStringTableLocker locker;
     auto& atomStringTable = stringTable();
     auto iterator = atomStringTable.find(&string);
     if (iterator != atomStringTable.end())
-        return static_cast<AtomStringImpl*>(*iterator);
+        return static_cast<AtomStringImpl*>(iterator->get());
     return nullptr;
 }
 
 RefPtr<AtomStringImpl> AtomStringImpl::addUTF8(const char* charactersStart, const char* charactersEnd)
 {
@@ -524,11 +531,11 @@
     auto& table = stringTable();
 
     LCharBuffer buffer = { characters, length };
     auto iterator = table.find<LCharBufferTranslator>(buffer);
     if (iterator != table.end())
-        return static_cast<AtomStringImpl*>(*iterator);
+        return static_cast<AtomStringImpl*>(iterator->get());
     return nullptr;
 }
 
 RefPtr<AtomStringImpl> AtomStringImpl::lookUp(const UChar* characters, unsigned length)
 {
@@ -536,15 +543,15 @@
     auto& table = stringTable();
 
     UCharBuffer buffer { characters, length };
     auto iterator = table.find<UCharBufferTranslator>(buffer);
     if (iterator != table.end())
-        return static_cast<AtomStringImpl*>(*iterator);
+        return static_cast<AtomStringImpl*>(iterator->get());
     return nullptr;
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 bool AtomStringImpl::isInAtomStringTable(StringImpl* string)
 {
     AtomStringTableLocker locker;
     return stringTable().contains(string);
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScheduledAction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ReadableStreamDefaultController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptController.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScheduledAction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83 void ScheduledAction::execute(ScriptExecutionContext&amp; context)
 84 {
 85     if (is&lt;Document&gt;(context))
 86         execute(downcast&lt;Document&gt;(context));
 87     else
 88         execute(downcast&lt;WorkerGlobalScope&gt;(context));
 89 }
 90 
 91 void ScheduledAction::executeFunctionInContext(JSGlobalObject* globalObject, JSValue thisValue, ScriptExecutionContext&amp; context)
 92 {
 93     ASSERT(m_function);
 94     VM&amp; vm = context.vm();
 95     JSLockHolder lock(vm);
 96     auto scope = DECLARE_THROW_SCOPE(vm);
 97 
 98     CallData callData;
 99     CallType callType = getCallData(vm, m_function.get(), callData);
100     if (callType == CallType::None)
101         return;
102 
<span class="line-modified">103     ExecState* exec = globalObject-&gt;globalExec();</span>
104 
105     MarkedArgumentBuffer arguments;
106     for (auto&amp; argument : m_arguments)
107         arguments.append(argument.get());
108     if (UNLIKELY(arguments.hasOverflowed())) {
<span class="line-modified">109         throwOutOfMemoryError(exec, scope);</span>
110         NakedPtr&lt;JSC::Exception&gt; exception = scope.exception();
<span class="line-modified">111         reportException(exec, exception);</span>
112         return;
113     }
114 
<span class="line-modified">115     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionCall(&amp;context, callType, callData);</span>
116 
117     NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">118     JSExecState::profiledCall(exec, JSC::ProfilingReason::Other, m_function.get(), callType, callData, thisValue, arguments, exception);</span>
119 
<span class="line-modified">120     InspectorInstrumentation::didCallFunction(cookie, &amp;context);</span>
121 
122     if (exception)
<span class="line-modified">123         reportException(exec, exception);</span>
124 }
125 
126 void ScheduledAction::execute(Document&amp; document)
127 {
128     JSDOMWindow* window = toJSDOMWindow(document.frame(), m_isolatedWorld);
129     if (!window)
130         return;
131 
132     RefPtr&lt;Frame&gt; frame = window-&gt;wrapped().frame();
133     if (!frame || !frame-&gt;script().canExecuteScripts(AboutToExecuteScript))
134         return;
135 
136     if (m_function)
137         executeFunctionInContext(window, window-&gt;proxy(), document);
138     else
<span class="line-modified">139         frame-&gt;script().executeScriptInWorld(m_isolatedWorld, m_code);</span>
140 }
141 
142 void ScheduledAction::execute(WorkerGlobalScope&amp; workerGlobalScope)
143 {
144     // In a Worker, the execution should always happen on a worker thread.
145     ASSERT(workerGlobalScope.thread().thread() == &amp;Thread::current());
146 
147     WorkerScriptController* scriptController = workerGlobalScope.script();
148 
149     if (m_function) {
150         JSWorkerGlobalScope* contextWrapper = scriptController-&gt;workerGlobalScopeWrapper();
151         executeFunctionInContext(contextWrapper, contextWrapper, workerGlobalScope);
152     } else {
153         ScriptSourceCode code(m_code, URL(workerGlobalScope.url()));
154         scriptController-&gt;evaluate(code);
155     }
156 }
157 
158 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 83 void ScheduledAction::execute(ScriptExecutionContext&amp; context)
 84 {
 85     if (is&lt;Document&gt;(context))
 86         execute(downcast&lt;Document&gt;(context));
 87     else
 88         execute(downcast&lt;WorkerGlobalScope&gt;(context));
 89 }
 90 
 91 void ScheduledAction::executeFunctionInContext(JSGlobalObject* globalObject, JSValue thisValue, ScriptExecutionContext&amp; context)
 92 {
 93     ASSERT(m_function);
 94     VM&amp; vm = context.vm();
 95     JSLockHolder lock(vm);
 96     auto scope = DECLARE_THROW_SCOPE(vm);
 97 
 98     CallData callData;
 99     CallType callType = getCallData(vm, m_function.get(), callData);
100     if (callType == CallType::None)
101         return;
102 
<span class="line-modified">103     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
104 
105     MarkedArgumentBuffer arguments;
106     for (auto&amp; argument : m_arguments)
107         arguments.append(argument.get());
108     if (UNLIKELY(arguments.hasOverflowed())) {
<span class="line-modified">109         throwOutOfMemoryError(lexicalGlobalObject, scope);</span>
110         NakedPtr&lt;JSC::Exception&gt; exception = scope.exception();
<span class="line-modified">111         reportException(lexicalGlobalObject, exception);</span>
112         return;
113     }
114 
<span class="line-modified">115     JSExecState::instrumentFunctionCall(&amp;context, callType, callData);</span>
116 
117     NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">118     JSExecState::profiledCall(lexicalGlobalObject, JSC::ProfilingReason::Other, m_function.get(), callType, callData, thisValue, arguments, exception);</span>
119 
<span class="line-modified">120     InspectorInstrumentation::didCallFunction(&amp;context);</span>
121 
122     if (exception)
<span class="line-modified">123         reportException(lexicalGlobalObject, exception);</span>
124 }
125 
126 void ScheduledAction::execute(Document&amp; document)
127 {
128     JSDOMWindow* window = toJSDOMWindow(document.frame(), m_isolatedWorld);
129     if (!window)
130         return;
131 
132     RefPtr&lt;Frame&gt; frame = window-&gt;wrapped().frame();
133     if (!frame || !frame-&gt;script().canExecuteScripts(AboutToExecuteScript))
134         return;
135 
136     if (m_function)
137         executeFunctionInContext(window, window-&gt;proxy(), document);
138     else
<span class="line-modified">139         frame-&gt;script().executeScriptInWorldIgnoringException(m_isolatedWorld, m_code);</span>
140 }
141 
142 void ScheduledAction::execute(WorkerGlobalScope&amp; workerGlobalScope)
143 {
144     // In a Worker, the execution should always happen on a worker thread.
145     ASSERT(workerGlobalScope.thread().thread() == &amp;Thread::current());
146 
147     WorkerScriptController* scriptController = workerGlobalScope.script();
148 
149     if (m_function) {
150         JSWorkerGlobalScope* contextWrapper = scriptController-&gt;workerGlobalScopeWrapper();
151         executeFunctionInContext(contextWrapper, contextWrapper, workerGlobalScope);
152     } else {
153         ScriptSourceCode code(m_code, URL(workerGlobalScope.url()));
154         scriptController-&gt;evaluate(code);
155     }
156 }
157 
158 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ReadableStreamDefaultController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptController.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
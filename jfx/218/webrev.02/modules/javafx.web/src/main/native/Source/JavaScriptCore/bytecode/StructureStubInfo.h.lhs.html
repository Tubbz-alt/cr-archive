<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<a name="2" id="anc2"></a>
 28 #include &quot;CodeBlock.h&quot;
 29 #include &quot;CodeOrigin.h&quot;
 30 #include &quot;Instruction.h&quot;
 31 #include &quot;JITStubRoutine.h&quot;
 32 #include &quot;MacroAssembler.h&quot;
 33 #include &quot;Options.h&quot;
 34 #include &quot;RegisterSet.h&quot;
 35 #include &quot;Structure.h&quot;
 36 #include &quot;StructureSet.h&quot;
 37 #include &quot;StructureStubClearingWatchpoint.h&quot;
 38 #include &quot;StubInfoSummary.h&quot;
<a name="3" id="anc3"></a>
 39 
 40 namespace JSC {
 41 
 42 #if ENABLE(JIT)
 43 
 44 class AccessCase;
 45 class AccessGenerationResult;
 46 class PolymorphicAccess;
 47 
 48 enum class AccessType : int8_t {
<a name="4" id="anc4"></a><span class="line-modified"> 49     Get,</span>
<span class="line-modified"> 50     GetWithThis,</span>
<span class="line-modified"> 51     GetDirect,</span>
<span class="line-modified"> 52     TryGet,</span>

 53     Put,
 54     In,
 55     InstanceOf
 56 };
 57 
 58 enum class CacheType : int8_t {
 59     Unset,
 60     GetByIdSelf,
 61     PutByIdReplace,
 62     InByIdSelf,
 63     Stub,
 64     ArrayLength,
 65     StringLength
 66 };
 67 
 68 class StructureStubInfo {
 69     WTF_MAKE_NONCOPYABLE(StructureStubInfo);
 70     WTF_MAKE_FAST_ALLOCATED;
 71 public:
 72     StructureStubInfo(AccessType);
 73     ~StructureStubInfo();
 74 
<a name="5" id="anc5"></a><span class="line-modified"> 75     void initGetByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);</span>
 76     void initArrayLength();
 77     void initStringLength();
 78     void initPutByIdReplace(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
 79     void initInByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
 80 
<a name="6" id="anc6"></a><span class="line-modified"> 81     AccessGenerationResult addAccessCase(const GCSafeConcurrentJSLocker&amp;, CodeBlock*, const Identifier&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
 82 
 83     void reset(CodeBlock*);
 84 
 85     void deref();
 86     void aboutToDie();
 87 
<a name="7" id="anc7"></a>

 88     // Check if the stub has weak references that are dead. If it does, then it resets itself,
 89     // either entirely or just enough to ensure that those dead pointers don&#39;t get used anymore.
 90     void visitWeakReferences(CodeBlock*);
 91 
 92     // This returns true if it has marked everything that it will ever mark.
 93     bool propagateTransitions(SlotVisitor&amp;);
 94 
<a name="8" id="anc8"></a><span class="line-modified"> 95     ALWAYS_INLINE bool considerCaching(VM&amp; vm, CodeBlock* codeBlock, Structure* structure)</span>
 96     {
 97         DisallowGC disallowGC;
 98 
 99         // We never cache non-cells.
100         if (!structure) {
101             sawNonCell = true;
102             return false;
103         }
104 
105         // This method is called from the Optimize variants of IC slow paths. The first part of this
106         // method tries to determine if the Optimize variant should really behave like the
107         // non-Optimize variant and leave the IC untouched.
108         //
109         // If we determine that we should do something to the IC then the next order of business is
110         // to determine if this Structure would impact the IC at all. We know that it won&#39;t, if we
111         // have already buffered something on its behalf. That&#39;s what the bufferedStructures set is
112         // for.
113 
114         everConsidered = true;
115         if (!countdown) {
116             // Check if we have been doing repatching too frequently. If so, then we should cool off
117             // for a while.
118             WTF::incrementWithSaturation(repatchCount);
119             if (repatchCount &gt; Options::repatchCountForCoolDown()) {
120                 // We&#39;ve been repatching too much, so don&#39;t do it now.
121                 repatchCount = 0;
122                 // The amount of time we require for cool-down depends on the number of times we&#39;ve
123                 // had to cool down in the past. The relationship is exponential. The max value we
124                 // allow here is 2^256 - 2, since the slow paths may increment the count to indicate
125                 // that they&#39;d like to temporarily skip patching just this once.
126                 countdown = WTF::leftShiftWithSaturation(
127                     static_cast&lt;uint8_t&gt;(Options::initialCoolDownCount()),
128                     numberOfCoolDowns,
129                     static_cast&lt;uint8_t&gt;(std::numeric_limits&lt;uint8_t&gt;::max() - 1));
130                 WTF::incrementWithSaturation(numberOfCoolDowns);
131 
132                 // We may still have had something buffered. Trigger generation now.
133                 bufferingCountdown = 0;
134                 return true;
135             }
136 
137             // We don&#39;t want to return false due to buffering indefinitely.
138             if (!bufferingCountdown) {
139                 // Note that when this returns true, it&#39;s possible that we will not even get an
140                 // AccessCase because this may cause Repatch.cpp to simply do an in-place
141                 // repatching.
142                 return true;
143             }
144 
145             bufferingCountdown--;
146 
147             // Now protect the IC buffering. We want to proceed only if this is a structure that
148             // we don&#39;t already have a case buffered for. Note that if this returns true but the
149             // bufferingCountdown is not zero then we will buffer the access case for later without
150             // immediately generating code for it.
151             //
152             // NOTE: This will behave oddly for InstanceOf if the user varies the prototype but not
153             // the base&#39;s structure. That seems unlikely for the canonical use of instanceof, where
154             // the prototype is fixed.
<a name="9" id="anc9"></a><span class="line-modified">155             bool isNewlyAdded = bufferedStructures.add(structure);</span>
156             if (isNewlyAdded)
157                 vm.heap.writeBarrier(codeBlock);
158             return isNewlyAdded;
159         }
160         countdown--;
161         return false;
162     }
163 
<a name="10" id="anc10"></a><span class="line-modified">164     StubInfoSummary summary() const;</span>
165 
<a name="11" id="anc11"></a><span class="line-modified">166     static StubInfoSummary summary(const StructureStubInfo*);</span>
167 
168     bool containsPC(void* pc) const;
169 
170     CodeOrigin codeOrigin;
<a name="12" id="anc12"></a><span class="line-modified">171     CallSiteIndex callSiteIndex;</span>


172 
173     union {
174         struct {
175             WriteBarrierBase&lt;Structure&gt; baseObjectStructure;
176             PropertyOffset offset;
177         } byIdSelf;
178         PolymorphicAccess* stub;
179     } u;
180 
<a name="13" id="anc13"></a>






181     // Represents those structures that already have buffered AccessCases in the PolymorphicAccess.
182     // Note that it&#39;s always safe to clear this. If we clear it prematurely, then if we see the same
183     // structure again during this buffering countdown, we will create an AccessCase object for it.
184     // That&#39;s not so bad - we&#39;ll get rid of the redundant ones once we regenerate.
<a name="14" id="anc14"></a><span class="line-modified">185     StructureSet bufferedStructures;</span>

186 
<a name="15" id="anc15"></a><span class="line-modified">187     struct {</span>
<span class="line-modified">188         CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; start; // This is either the start of the inline IC for *byId caches. or the location of patchable jump for &#39;instanceof&#39; caches.</span>
<span class="line-modified">189         CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation;</span>
<span class="line-modified">190         CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation;</span>
<span class="line-removed">191         CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation;</span>
192 
<a name="16" id="anc16"></a><span class="line-modified">193         RegisterSet usedRegisters;</span>
194 
<a name="17" id="anc17"></a><span class="line-modified">195         uint32_t inlineSize() const</span>
<span class="line-modified">196         {</span>
<span class="line-modified">197             int32_t inlineSize = MacroAssembler::differenceBetweenCodePtr(start, doneLocation);</span>
<span class="line-modified">198             ASSERT(inlineSize &gt;= 0);</span>
<span class="line-modified">199             return inlineSize;</span>
<span class="line-modified">200         }</span>
201 
<a name="18" id="anc18"></a><span class="line-modified">202         GPRReg baseGPR;</span>
<span class="line-modified">203         GPRReg valueGPR;</span>

204         GPRReg thisGPR;
<a name="19" id="anc19"></a>


205 #if USE(JSVALUE32_64)
<a name="20" id="anc20"></a><span class="line-modified">206         GPRReg valueTagGPR;</span>
<span class="line-modified">207         GPRReg baseTagGPR;</span>



208         GPRReg thisTagGPR;
<a name="21" id="anc21"></a>

209 #endif
<a name="22" id="anc22"></a><span class="line-removed">210     } patch;</span>
211 
<a name="23" id="anc23"></a><span class="line-modified">212     GPRReg baseGPR() const</span>
213     {
<a name="24" id="anc24"></a><span class="line-modified">214         return patch.baseGPR;</span>

215     }
216 
<a name="25" id="anc25"></a><span class="line-modified">217     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation() { return patch.slowPathCallLocation; }</span>
<span class="line-modified">218     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation() { return patch.doneLocation; }</span>
<span class="line-modified">219     CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation() { return patch.slowPathStartLocation; }</span>





220 
<a name="26" id="anc26"></a><span class="line-modified">221     CodeLocationJump&lt;JSInternalPtrTag&gt; patchableJump()</span>
222     {
<a name="27" id="anc27"></a><span class="line-modified">223         ASSERT(accessType == AccessType::InstanceOf);</span>
<span class="line-modified">224         return patch.start.jumpAtOffset&lt;JSInternalPtrTag&gt;(0);</span>



225     }
226 
<a name="28" id="anc28"></a><span class="line-modified">227     JSValueRegs valueRegs() const</span>
228     {
229         return JSValueRegs(
230 #if USE(JSVALUE32_64)
<a name="29" id="anc29"></a><span class="line-modified">231             patch.valueTagGPR,</span>
232 #endif
<a name="30" id="anc30"></a><span class="line-modified">233             patch.valueGPR);</span>
234     }
235 
<a name="31" id="anc31"></a>






236 
237     AccessType accessType;
<a name="32" id="anc32"></a><span class="line-modified">238     CacheType cacheType;</span>




239     uint8_t countdown; // We repatch only when this is zero. If not zero, we decrement.
240     uint8_t repatchCount;
241     uint8_t numberOfCoolDowns;
<a name="33" id="anc33"></a>


242     uint8_t bufferingCountdown;
243     bool resetByGC : 1;
244     bool tookSlowPath : 1;
245     bool everConsidered : 1;
246     bool prototypeIsKnownObject : 1; // Only relevant for InstanceOf.
247     bool sawNonCell : 1;
<a name="34" id="anc34"></a>



248 };
249 
250 inline CodeOrigin getStructureStubInfoCodeOrigin(StructureStubInfo&amp; structureStubInfo)
251 {
252     return structureStubInfo.codeOrigin;
253 }
254 
<a name="35" id="anc35"></a><span class="line-modified">255 inline J_JITOperation_ESsiJI appropriateOptimizingGetByIdFunction(AccessType type)</span>
256 {
257     switch (type) {
<a name="36" id="anc36"></a><span class="line-modified">258     case AccessType::Get:</span>
259         return operationGetByIdOptimize;
<a name="37" id="anc37"></a><span class="line-modified">260     case AccessType::TryGet:</span>
261         return operationTryGetByIdOptimize;
<a name="38" id="anc38"></a><span class="line-modified">262     case AccessType::GetDirect:</span>
263         return operationGetByIdDirectOptimize;
<a name="39" id="anc39"></a><span class="line-modified">264     case AccessType::GetWithThis:</span>
265     default:
266         ASSERT_NOT_REACHED();
267         return nullptr;
268     }
269 }
270 
<a name="40" id="anc40"></a><span class="line-modified">271 inline J_JITOperation_EJI appropriateGenericGetByIdFunction(AccessType type)</span>
272 {
273     switch (type) {
<a name="41" id="anc41"></a><span class="line-modified">274     case AccessType::Get:</span>
275         return operationGetByIdGeneric;
<a name="42" id="anc42"></a><span class="line-modified">276     case AccessType::TryGet:</span>
277         return operationTryGetByIdGeneric;
<a name="43" id="anc43"></a><span class="line-modified">278     case AccessType::GetDirect:</span>
279         return operationGetByIdDirectGeneric;
<a name="44" id="anc44"></a><span class="line-modified">280     case AccessType::GetWithThis:</span>
281     default:
282         ASSERT_NOT_REACHED();
283         return nullptr;
284     }
285 }
286 
287 #else
288 
289 class StructureStubInfo;
290 
291 #endif // ENABLE(JIT)
292 
293 typedef HashMap&lt;CodeOrigin, StructureStubInfo*, CodeOriginApproximateHash&gt; StubInfoMap;
294 
295 } // namespace JSC
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
  6  * Copyright (C) 2004-2010, 2012-2013, 2015-2017 Apple Inc. All rights reserved.
  7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  8  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  9  * Copyright (C) 2011 Google Inc. All rights reserved.
 10  *
 11  * This library is free software; you can redistribute it and/or
 12  * modify it under the terms of the GNU Library General Public
 13  * License as published by the Free Software Foundation; either
 14  * version 2 of the License, or (at your option) any later version.
 15  *
 16  * This library is distributed in the hope that it will be useful,
 17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 19  * Library General Public License for more details.
 20  *
 21  * You should have received a copy of the GNU Library General Public License
 22  * along with this library; see the file COPYING.LIB.  If not, write to
 23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 24  * Boston, MA 02110-1301, USA.
 25  *
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;Timer.h&quot;
 31 #include &lt;memory&gt;
 32 #include &lt;wtf/FastMalloc.h&gt;
 33 #include &lt;wtf/HashSet.h&gt;
 34 #include &lt;wtf/ListHashSet.h&gt;
 35 #include &lt;wtf/RefPtr.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 class CSSStyleSheet;
 42 class Document;
 43 class Element;
 44 class Node;
 45 class ProcessingInstruction;
 46 class StyleResolver;
 47 class StyleSheet;
 48 class StyleSheetContents;
 49 class StyleSheetList;
 50 class ShadowRoot;
 51 class TreeScope;
 52 
 53 namespace Style {
 54 
 55 // This is used to identify style scopes that can affect an element.
 56 // Scopes are in tree-of-trees order. Styles from earlier scopes win over later ones (modulo !important).
 57 enum class ScopeOrdinal : int {
 58     ContainingHost = -1, // Author-exposed UA pseudo classes from the host tree scope.
 59     Element = 0, // Normal rules in the same tree where the element is.
 60     FirstSlot = 1, // ::slotted rules in the parent&#39;s shadow tree. Values greater than FirstSlot indicate subsequent slots in the chain.
 61     Shadow = std::numeric_limits&lt;int&gt;::max(), // :host rules in element&#39;s own shadow tree.
 62 };
 63 
 64 class Scope {
 65     WTF_MAKE_FAST_ALLOCATED;
 66 public:
 67     explicit Scope(Document&amp;);
 68     explicit Scope(ShadowRoot&amp;);
 69 
 70     ~Scope();
 71 
 72     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; activeStyleSheets() const { return m_activeStyleSheets; }
 73 
 74     const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; styleSheetsForStyleSheetList();
 75     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; activeStyleSheetsForInspector();
 76 
 77     void addStyleSheetCandidateNode(Node&amp;, bool createdByParser);
 78     void removeStyleSheetCandidateNode(Node&amp;);
 79 
 80     String preferredStylesheetSetName() const { return m_preferredStylesheetSetName; }
 81     void setPreferredStylesheetSetName(const String&amp;);
 82 
 83     void addPendingSheet(const Element&amp;);
 84     void removePendingSheet(const Element&amp;);
 85     void addPendingSheet(const ProcessingInstruction&amp;);
 86     void removePendingSheet(const ProcessingInstruction&amp;);
 87     bool hasPendingSheets() const;
 88     bool hasPendingSheetsBeforeBody() const;
 89     bool hasPendingSheetsInBody() const;
 90     bool hasPendingSheet(const Element&amp;) const;
 91     bool hasPendingSheetInBody(const Element&amp;) const;
 92     bool hasPendingSheet(const ProcessingInstruction&amp;) const;
 93 
 94     bool usesStyleBasedEditability() { return m_usesStyleBasedEditability; }
 95 
 96     bool activeStyleSheetsContains(const CSSStyleSheet*) const;
 97 
 98     void evaluateMediaQueriesForViewportChange();
 99     void evaluateMediaQueriesForAccessibilitySettingsChange();
100     void evaluateMediaQueriesForAppearanceChange();
101 
102     // This is called when some stylesheet becomes newly enabled or disabled.
103     void didChangeActiveStyleSheetCandidates();
104     // This is called when contents of a stylesheet is mutated.
105     void didChangeStyleSheetContents();
106     // This is called when the environment where we intrepret the stylesheets changes (for example switching to printing).
107     // The change is assumed to potentially affect all author and user stylesheets including shadow roots.
108     WEBCORE_EXPORT void didChangeStyleSheetEnvironment();
109 
110     bool hasPendingUpdate() const { return m_pendingUpdate || m_hasDescendantWithPendingUpdate; }
111     void flushPendingUpdate();
112 
113 #if ENABLE(XSLT)
114     Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; collectXSLTransforms();
115 #endif
116 
117     StyleResolver&amp; resolver();
118     StyleResolver* resolverIfExists();
119     void clearResolver();
120     void releaseMemory();
121 
122     const Document&amp; document() const { return m_document; }
123 
124     static Scope&amp; forNode(Node&amp;);
125     static Scope* forOrdinal(Element&amp;, ScopeOrdinal);
126 
127 private:
128     bool shouldUseSharedUserAgentShadowTreeStyleResolver() const;
129 
130     void didRemovePendingStylesheet();
131 
132     enum class UpdateType { ActiveSet, ContentsOrInterpretation };
133     void updateActiveStyleSheets(UpdateType);
134     void scheduleUpdate(UpdateType);
135 
136     template &lt;typename TestFunction&gt; void evaluateMediaQueries(TestFunction&amp;&amp;);
137 
138     WEBCORE_EXPORT void flushPendingSelfUpdate();
139     WEBCORE_EXPORT void flushPendingDescendantUpdates();
140 
141     void collectActiveStyleSheets(Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp;);
142 
143     enum StyleResolverUpdateType {
144         Reconstruct,
145         Reset,
146         Additive
147     };
148     StyleResolverUpdateType analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets, bool&amp; requiresFullStyleRecalc);
149     void updateStyleResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp;, StyleResolverUpdateType);
150 
151     void pendingUpdateTimerFired();
152     void clearPendingUpdate();
153 
154     Document&amp; m_document;
155     ShadowRoot* m_shadowRoot { nullptr };
156 
157     std::unique_ptr&lt;StyleResolver&gt; m_resolver;
158 
159     Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; m_styleSheetsForStyleSheetList;
160     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; m_activeStyleSheets;
161 
162     Timer m_pendingUpdateTimer;
163 
164     mutable std::unique_ptr&lt;HashSet&lt;const CSSStyleSheet*&gt;&gt; m_weakCopyOfActiveStyleSheetListForFastLookup;
165 
166     // Track the currently loading top-level stylesheets needed for rendering.
167     // Sheets loaded using the @import directive are not included in this count.
168     // We use this count of pending sheets to detect when we can begin attaching
169     // elements and when it is safe to execute scripts.
170     HashSet&lt;const ProcessingInstruction*&gt; m_processingInstructionsWithPendingSheets;
171     HashSet&lt;const Element*&gt; m_elementsInHeadWithPendingSheets;
172     HashSet&lt;const Element*&gt; m_elementsInBodyWithPendingSheets;
173 
174     Optional&lt;UpdateType&gt; m_pendingUpdate;
175     bool m_hasDescendantWithPendingUpdate { false };
176 
177     ListHashSet&lt;Node*&gt; m_styleSheetCandidateNodes;
178 
179     String m_preferredStylesheetSetName;
180 
181     bool m_usesStyleBasedEditability { false };
182     bool m_isUpdatingStyleResolver { false };
183 };
184 
185 inline bool Scope::hasPendingSheets() const
186 {
187     return hasPendingSheetsBeforeBody() || !m_elementsInBodyWithPendingSheets.isEmpty();
188 }
189 
190 inline bool Scope::hasPendingSheetsBeforeBody() const
191 {
192     return !m_elementsInHeadWithPendingSheets.isEmpty() || !m_processingInstructionsWithPendingSheets.isEmpty();
193 }
194 
195 inline bool Scope::hasPendingSheetsInBody() const
196 {
197     return !m_elementsInBodyWithPendingSheets.isEmpty();
198 }
199 
200 inline void Scope::flushPendingUpdate()
201 {
202     if (m_hasDescendantWithPendingUpdate)
203         flushPendingDescendantUpdates();
204     if (m_pendingUpdate)
205         flushPendingSelfUpdate();
206 }
207 
208 inline ScopeOrdinal&amp; operator++(ScopeOrdinal&amp; ordinal)
209 {
210     ASSERT(ordinal &lt; ScopeOrdinal::Shadow);
211     return ordinal = static_cast&lt;ScopeOrdinal&gt;(static_cast&lt;int&gt;(ordinal) + 1);
212 }
213 
214 }
215 }
    </pre>
  </body>
</html>
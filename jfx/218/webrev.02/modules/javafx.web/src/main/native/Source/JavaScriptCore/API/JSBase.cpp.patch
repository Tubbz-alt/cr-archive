diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSBase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSBase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSBase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSBase.cpp
@@ -31,14 +31,16 @@
 #include "APICast.h"
 #include "CallFrame.h"
 #include "Completion.h"
 #include "Exception.h"
 #include "GCActivityCallback.h"
+#include "Identifier.h"
 #include "InitializeThreading.h"
 #include "JSGlobalObject.h"
 #include "JSLock.h"
 #include "JSObject.h"
+#include "ObjectConstructor.h"
 #include "OpaqueJSString.h"
 #include "JSCInlines.h"
 #include "SourceCode.h"
 #include <wtf/text/StringHash.h>
 
@@ -46,85 +48,82 @@
 #include "JSGlobalObjectInspectorController.h"
 #endif
 
 using namespace JSC;
 
-JSValueRef JSEvaluateScriptInternal(const JSLockHolder&, ExecState* exec, JSContextRef ctx, JSObjectRef thisObject, const SourceCode& source, JSValueRef* exception)
+JSValueRef JSEvaluateScriptInternal(const JSLockHolder&, JSContextRef ctx, JSObjectRef thisObject, const SourceCode& source, JSValueRef* exception)
 {
-    UNUSED_PARAM(ctx);
-
     JSObject* jsThisObject = toJS(thisObject);
 
     // evaluate sets "this" to the global object if it is NULL
-    VM& vm = exec->vm();
-    JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);
+    JSGlobalObject* globalObject = toJS(ctx);
     NakedPtr<Exception> evaluationException;
-    JSValue returnValue = profiledEvaluate(globalObject->globalExec(), ProfilingReason::API, source, jsThisObject, evaluationException);
+    JSValue returnValue = profiledEvaluate(globalObject, ProfilingReason::API, source, jsThisObject, evaluationException);
 
     if (evaluationException) {
         if (exception)
-            *exception = toRef(exec, evaluationException->value());
+            *exception = toRef(globalObject, evaluationException->value());
 #if ENABLE(REMOTE_INSPECTOR)
         // FIXME: If we have a debugger attached we could learn about ParseError exceptions through
         // ScriptDebugServer::sourceParsed and this path could produce a duplicate warning. The
         // Debugger path is currently ignored by inspector.
         // NOTE: If we don't have a debugger, this SourceCode will be forever lost to the inspector.
         // We could stash it in the inspector in case an inspector is ever opened.
-        globalObject->inspectorController().reportAPIException(exec, evaluationException);
+        globalObject->inspectorController().reportAPIException(globalObject, evaluationException);
 #endif
         return nullptr;
     }
 
     if (returnValue)
-        return toRef(exec, returnValue);
+        return toRef(globalObject, returnValue);
 
     // happens, for example, when the only statement is an empty (';') statement
-    return toRef(exec, jsUndefined());
+    return toRef(globalObject, jsUndefined());
 }
 
 JSValueRef JSEvaluateScript(JSContextRef ctx, JSStringRef script, JSObjectRef thisObject, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return nullptr;
     }
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
     startingLineNumber = std::max(1, startingLineNumber);
 
     auto sourceURLString = sourceURL ? sourceURL->string() : String();
     SourceCode source = makeSource(script->string(), SourceOrigin { sourceURLString }, URL({ }, sourceURLString), TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));
 
-    return JSEvaluateScriptInternal(locker, exec, ctx, thisObject, source, exception);
+    return JSEvaluateScriptInternal(locker, ctx, thisObject, source, exception);
 }
 
 bool JSCheckScriptSyntax(JSContextRef ctx, JSStringRef script, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return false;
     }
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
     startingLineNumber = std::max(1, startingLineNumber);
 
     auto sourceURLString = sourceURL ? sourceURL->string() : String();
     SourceCode source = makeSource(script->string(), SourceOrigin { sourceURLString }, URL({ }, sourceURLString), TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));
 
     JSValue syntaxException;
-    bool isValidSyntax = checkSyntax(vm.vmEntryGlobalObject(exec)->globalExec(), source, &syntaxException);
+    bool isValidSyntax = checkSyntax(globalObject, source, &syntaxException);
 
     if (!isValidSyntax) {
         if (exception)
-            *exception = toRef(exec, syntaxException);
+            *exception = toRef(globalObject, syntaxException);
 #if ENABLE(REMOTE_INSPECTOR)
         Exception* exception = Exception::create(vm, syntaxException);
-        vm.vmEntryGlobalObject(exec)->inspectorController().reportAPIException(exec, exception);
+        globalObject->inspectorController().reportAPIException(globalObject, exception);
 #endif
         return false;
     }
 
     return true;
@@ -138,12 +137,12 @@
     // Because the function argument was originally ignored, some clients may pass their released context here,
     // in which case there is a risk of crashing if another thread performs GC on the same heap in between.
     if (!ctx)
         return;
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
     vm.heap.reportAbandonedObjectGraph();
 }
 
@@ -151,12 +150,12 @@
 {
     if (!ctx) {
         ASSERT_NOT_REACHED();
         return;
     }
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
 
     vm.heap.deprecatedReportExtraMemory(size);
 }
 
@@ -166,32 +165,55 @@
 void JSSynchronousGarbageCollectForDebugging(JSContextRef ctx)
 {
     if (!ctx)
         return;
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
     vm.heap.collectNow(Sync, CollectionScope::Full);
 }
 
 void JSSynchronousEdenCollectForDebugging(JSContextRef ctx)
 {
     if (!ctx)
         return;
 
-    ExecState* exec = toJS(ctx);
-    VM& vm = exec->vm();
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
     JSLockHolder locker(vm);
     vm.heap.collectSync(CollectionScope::Eden);
 }
 
 void JSDisableGCTimer(void)
 {
     GCActivityCallback::s_shouldCreateGCTimer = false;
 }
 
+JSObjectRef JSGetMemoryUsageStatistics(JSContextRef ctx)
+{
+    if (!ctx) {
+        ASSERT_NOT_REACHED();
+        return 0;
+    }
+
+    JSGlobalObject* globalObject = toJS(ctx);
+    VM& vm = globalObject->vm();
+    JSLockHolder locker(vm);
+
+    JSObject* object = constructEmptyObject(globalObject);
+    object->putDirect(vm, Identifier::fromString(vm, "heapSize"), jsNumber(vm.heap.size()));
+    object->putDirect(vm, Identifier::fromString(vm, "heapCapacity"), jsNumber(vm.heap.capacity()));
+    object->putDirect(vm, Identifier::fromString(vm, "extraMemorySize"), jsNumber(vm.heap.extraMemorySize()));
+    object->putDirect(vm, Identifier::fromString(vm, "objectCount"), jsNumber(vm.heap.objectCount()));
+    object->putDirect(vm, Identifier::fromString(vm, "protectedObjectCount"), jsNumber(vm.heap.protectedObjectCount()));
+    object->putDirect(vm, Identifier::fromString(vm, "globalObjectCount"), jsNumber(vm.heap.globalObjectCount()));
+    object->putDirect(vm, Identifier::fromString(vm, "protectedGlobalObjectCount"), jsNumber(vm.heap.protectedGlobalObjectCount()));
+
+    return toRef(object);
+}
+
 #if PLATFORM(IOS_FAMILY) && TARGET_OS_IOS
 // FIXME: Expose symbols to tell dyld where to find JavaScriptCore on older versions of
 // iOS (< 7.0). We should remove these symbols once we no longer need to support such
 // versions of iOS. See <rdar://problem/13696872> for more details.
 JS_EXPORT extern const char iosInstallName43 __asm("$ld$install_name$os4.3$/System/Library/PrivateFrameworks/JavaScriptCore.framework/JavaScriptCore");

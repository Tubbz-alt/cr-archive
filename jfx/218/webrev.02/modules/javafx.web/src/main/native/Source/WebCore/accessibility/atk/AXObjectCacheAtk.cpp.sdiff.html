<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../AccessibleSetValueEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObjectAtk.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/atk/AXObjectCacheAtk.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 #include &quot;TextIterator.h&quot;
 32 #include &quot;WebKitAccessible.h&quot;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 #include &lt;wtf/glib/GRefPtr.h&gt;
 35 #include &lt;wtf/text/CString.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 static AtkObject* wrapperParent(WebKitAccessible* wrapper)
 40 {
 41     // Look for the right object to emit the signal from, but using the implementation
 42     // of atk_object_get_parent from AtkObject class (which uses a cached pointer if set)
 43     // since the accessibility hierarchy in WebCore will no longer be navigable.
 44     gpointer webkitAccessibleClass = g_type_class_peek_parent(WEBKIT_ACCESSIBLE_GET_CLASS(wrapper));
 45     gpointer atkObjectClass = g_type_class_peek_parent(webkitAccessibleClass);
 46     AtkObject* atkParent = ATK_OBJECT_CLASS(atkObjectClass)-&gt;get_parent(ATK_OBJECT(wrapper));
 47     // We don&#39;t want to emit any signal from an object outside WebKit&#39;s world.
 48     return WEBKIT_IS_ACCESSIBLE(atkParent) ? atkParent : nullptr;
 49 }
 50 
<span class="line-modified"> 51 void AXObjectCache::detachWrapper(AccessibilityObject* obj, AccessibilityDetachmentType detachmentType)</span>
 52 {
 53     auto* wrapper = obj-&gt;wrapper();
 54     ASSERT(wrapper);
 55 
 56     // If an object is being detached NOT because of the AXObjectCache being destroyed,
 57     // then it&#39;s being removed from the accessibility tree and we should emit a signal.
 58     if (detachmentType != AccessibilityDetachmentType::CacheDestroyed &amp;&amp; obj-&gt;document() &amp;&amp; wrapperParent(wrapper))
 59         m_deferredDetachedWrapperList.add(wrapper);
 60 
 61     webkitAccessibleDetach(WEBKIT_ACCESSIBLE(wrapper));
 62 }
 63 
<span class="line-modified"> 64 void AXObjectCache::attachWrapper(AccessibilityObject* obj)</span>
 65 {
<span class="line-modified"> 66     GRefPtr&lt;WebKitAccessible&gt; wrapper = adoptGRef(webkitAccessibleNew(obj));</span>
<span class="line-modified"> 67     obj-&gt;setWrapper(wrapper.get());</span>





 68 
 69     // If an object is being attached and we are not in the middle of a layout update, then
 70     // we should report ATs by emitting the children-changed::add signal from the parent.
<span class="line-modified"> 71     Document* document = obj-&gt;document();</span>
 72     if (!document || document-&gt;childNeedsStyleRecalc())
 73         return;
 74 
 75     // Don&#39;t emit the signal when the actual object being added is not going to be exposed.
<span class="line-modified"> 76     if (obj-&gt;accessibilityIsIgnoredByDefault())</span>
 77         return;
 78 
 79     // Don&#39;t emit the signal if the object being added is not -- or not yet -- rendered,
 80     // which can occur in nested iframes. In these instances we don&#39;t want to ignore the
 81     // child. But if an assistive technology is listening, AT-SPI2 will attempt to create
 82     // and cache the state set for the child upon emission of the signal. If the object
 83     // has not yet been rendered, this will result in a crash.
<span class="line-modified"> 84     if (!obj-&gt;renderer())</span>
 85         return;
 86 
<span class="line-modified"> 87     m_deferredAttachedWrapperObjectList.add(obj);</span>
 88 }
 89 
 90 void AXObjectCache::platformPerformDeferredCacheUpdate()
 91 {
 92     for (auto&amp; coreObject : m_deferredAttachedWrapperObjectList) {
 93         auto* wrapper = coreObject-&gt;wrapper();
 94         if (!wrapper)
 95             continue;
 96 
 97         // Don&#39;t emit the signal for objects whose parents won&#39;t be exposed directly.
 98         auto* coreParent = coreObject-&gt;parentObjectUnignored();
 99         if (!coreParent || coreParent-&gt;accessibilityIsIgnoredByDefault())
100             continue;
101 
102         // Look for the right object to emit the signal from.
103         auto* atkParent = coreParent-&gt;wrapper();
104         if (!atkParent)
105             continue;
106 
107         size_t index = coreParent-&gt;children(false).find(coreObject);
108         g_signal_emit_by_name(atkParent, &quot;children-changed::add&quot;, index != notFound ? index : -1, wrapper);
109     }
110     m_deferredAttachedWrapperObjectList.clear();
111 
112     for (auto&amp; wrapper : m_deferredDetachedWrapperList) {
113         if (auto* atkParent = wrapperParent(wrapper.get())) {
114             // The accessibility hierarchy is already invalid, so the parent-children relationships
115             // in the AccessibilityObject tree are not there anymore, so we can&#39;t know the offset.
116             g_signal_emit_by_name(atkParent, &quot;children-changed::remove&quot;, -1, wrapper.get());
117         }
118     }
119     m_deferredDetachedWrapperList.clear();
120 }
121 
<span class="line-modified">122 static AccessibilityObject* getListObject(AccessibilityObject* object)</span>
123 {
124     // Only list boxes and menu lists supported so far.
125     if (!object-&gt;isListBox() &amp;&amp; !object-&gt;isMenuList())
126         return 0;
127 
128     // For list boxes the list object is just itself.
129     if (object-&gt;isListBox())
130         return object;
131 
132     // For menu lists we need to return the first accessible child,
133     // with role MenuListPopupRole, since that&#39;s the one holding the list
134     // of items with role MenuListOptionRole.
135     const AccessibilityObject::AccessibilityChildrenVector&amp; children = object-&gt;children();
136     if (!children.size())
137         return 0;
138 
<span class="line-modified">139     AccessibilityObject* listObject = children.at(0).get();</span>
140     if (!listObject-&gt;isMenuListPopup())
141         return 0;
142 
143     return listObject;
144 }
145 
<span class="line-modified">146 static void notifyChildrenSelectionChange(AccessibilityObject* object)</span>
147 {
148     // This static variables are needed to keep track of the old
149     // focused object and its associated list object, as per previous
150     // calls to this function, in order to properly decide whether to
151     // emit some signals or not.
<span class="line-modified">152     static NeverDestroyed&lt;RefPtr&lt;AccessibilityObject&gt;&gt; oldListObject;</span>
<span class="line-modified">153     static NeverDestroyed&lt;RefPtr&lt;AccessibilityObject&gt;&gt; oldFocusedObject;</span>
154 
155     // Only list boxes and menu lists supported so far.
156     if (!object || !(object-&gt;isListBox() || object-&gt;isMenuList()))
157         return;
158 
159     // Only support HTML select elements so far (ARIA selectors not supported).
160     Node* node = object-&gt;node();
161     if (!is&lt;HTMLSelectElement&gt;(node))
162         return;
163 
164     // Emit signal from the listbox&#39;s point of view first.
165     g_signal_emit_by_name(object-&gt;wrapper(), &quot;selection-changed&quot;);
166 
167     // Find the item where the selection change was triggered from.
168     HTMLSelectElement&amp; select = downcast&lt;HTMLSelectElement&gt;(*node);
169     int changedItemIndex = select.activeSelectionStartListIndex();
170 
<span class="line-modified">171     AccessibilityObject* listObject = getListObject(object);</span>
172     if (!listObject) {
173         oldListObject.get() = nullptr;
174         return;
175     }
176 
177     const AccessibilityObject::AccessibilityChildrenVector&amp; items = listObject-&gt;children();
178     if (changedItemIndex &lt; 0 || changedItemIndex &gt;= static_cast&lt;int&gt;(items.size()))
179         return;
<span class="line-modified">180     AccessibilityObject* item = items.at(changedItemIndex).get();</span>
181 
182     // Ensure the current list object is the same than the old one so
183     // further comparisons make sense. Otherwise, just reset
184     // oldFocusedObject so it won&#39;t be taken into account.
185     if (oldListObject.get() != listObject)
186         oldFocusedObject.get() = nullptr;
187 
188     WebKitAccessible* axItem = item ? item-&gt;wrapper() : nullptr;
189     WebKitAccessible* axOldFocusedObject = oldFocusedObject.get() ? oldFocusedObject.get()-&gt;wrapper() : nullptr;
190 
191     // Old focused object just lost focus, so emit the events.
192     if (axOldFocusedObject &amp;&amp; axItem != axOldFocusedObject) {
193         g_signal_emit_by_name(axOldFocusedObject, &quot;focus-event&quot;, false);
194         atk_object_notify_state_change(ATK_OBJECT(axOldFocusedObject), ATK_STATE_FOCUSED, false);
195     }
196 
197     // Emit needed events for the currently (un)selected item.
198     if (axItem) {
199         bool isSelected = item-&gt;isSelected();
200         atk_object_notify_state_change(ATK_OBJECT(axItem), ATK_STATE_SELECTED, isSelected);
201         // When the selection changes in a collapsed widget such as a combo box
202         // whose child menu is not showing, that collapsed widget retains focus.
203         if (!object-&gt;isCollapsed()) {
204             g_signal_emit_by_name(axItem, &quot;focus-event&quot;, isSelected);
205             atk_object_notify_state_change(ATK_OBJECT(axItem), ATK_STATE_FOCUSED, isSelected);
206         }
207     }
208 
209     // Update pointers to the previously involved objects.
210     oldListObject.get() = listObject;
211     oldFocusedObject.get() = item;
212 }
213 
<span class="line-modified">214 void AXObjectCache::postPlatformNotification(AccessibilityObject* coreObject, AXNotification notification)</span>
215 {
216     auto* axObject = ATK_OBJECT(coreObject-&gt;wrapper());
217     if (!axObject)
218         return;
219 
220     switch (notification) {
221     case AXCheckedStateChanged:
222         if (!coreObject-&gt;isCheckboxOrRadio() &amp;&amp; !coreObject-&gt;isSwitch())
223             return;
224         atk_object_notify_state_change(axObject, ATK_STATE_CHECKED, coreObject-&gt;isChecked());
225         break;
226 
227     case AXSelectedChildrenChanged:
228     case AXMenuListValueChanged:
229         // Accessible focus claims should not be made if the associated widget is not focused.
230         if (notification == AXMenuListValueChanged &amp;&amp; coreObject-&gt;isMenuList() &amp;&amp; coreObject-&gt;isFocused()) {
231             g_signal_emit_by_name(axObject, &quot;focus-event&quot;, true);
232             atk_object_notify_state_change(axObject, ATK_STATE_FOCUSED, true);
233         }
234         notifyChildrenSelectionChange(coreObject);
</pre>
<hr />
<pre>
276     case AXDisabledStateChanged: {
277         bool enabledState = coreObject-&gt;isEnabled();
278         atk_object_notify_state_change(axObject, ATK_STATE_ENABLED, enabledState);
279         atk_object_notify_state_change(axObject, ATK_STATE_SENSITIVE, enabledState);
280         break;
281     }
282 
283     case AXPressedStateChanged:
284         atk_object_notify_state_change(axObject, ATK_STATE_PRESSED, coreObject-&gt;isPressed());
285         break;
286 
287     case AXReadOnlyStatusChanged:
288         atk_object_notify_state_change(axObject, ATK_STATE_READ_ONLY, !coreObject-&gt;canSetValueAttribute());
289         break;
290 
291     case AXRequiredStatusChanged:
292         atk_object_notify_state_change(axObject, ATK_STATE_REQUIRED, coreObject-&gt;isRequired());
293         break;
294 
295     case AXActiveDescendantChanged:
<span class="line-modified">296         if (AccessibilityObject* descendant = coreObject-&gt;activeDescendant())</span>
297             platformHandleFocusedUIElementChanged(nullptr, descendant-&gt;node());
298         break;
299 
300     default:
301         break;
302     }
303 }
304 
305 void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject* object, AXTextChange textChange, unsigned offset, const String&amp; text)
306 {
307     if (!object || text.isEmpty())
308         return;
309 
<span class="line-modified">310     AccessibilityObject* parentObject = object-&gt;isNonNativeTextControl() ? object : object-&gt;parentObjectUnignored();</span>
311     if (!parentObject)
312         return;
313 
314     auto* wrapper = parentObject-&gt;wrapper();
315     if (!wrapper || !ATK_IS_TEXT(wrapper))
316         return;
317 
318     Node* node = object-&gt;node();
319     if (!node)
320         return;
321 
322     // Ensure document&#39;s layout is up-to-date before using TextIterator.
323     Document&amp; document = node-&gt;document();
324     document.updateLayout();
325 
326     // Select the right signal to be emitted
327     CString detail;
328     switch (textChange) {
329     case AXTextInserted:
330         detail = &quot;text-insert&quot;;
</pre>
</td>
<td>
<hr />
<pre>
 31 #include &quot;TextIterator.h&quot;
 32 #include &quot;WebKitAccessible.h&quot;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 #include &lt;wtf/glib/GRefPtr.h&gt;
 35 #include &lt;wtf/text/CString.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 static AtkObject* wrapperParent(WebKitAccessible* wrapper)
 40 {
 41     // Look for the right object to emit the signal from, but using the implementation
 42     // of atk_object_get_parent from AtkObject class (which uses a cached pointer if set)
 43     // since the accessibility hierarchy in WebCore will no longer be navigable.
 44     gpointer webkitAccessibleClass = g_type_class_peek_parent(WEBKIT_ACCESSIBLE_GET_CLASS(wrapper));
 45     gpointer atkObjectClass = g_type_class_peek_parent(webkitAccessibleClass);
 46     AtkObject* atkParent = ATK_OBJECT_CLASS(atkObjectClass)-&gt;get_parent(ATK_OBJECT(wrapper));
 47     // We don&#39;t want to emit any signal from an object outside WebKit&#39;s world.
 48     return WEBKIT_IS_ACCESSIBLE(atkParent) ? atkParent : nullptr;
 49 }
 50 
<span class="line-modified"> 51 void AXObjectCache::detachWrapper(AXCoreObject* obj, AccessibilityDetachmentType detachmentType)</span>
 52 {
 53     auto* wrapper = obj-&gt;wrapper();
 54     ASSERT(wrapper);
 55 
 56     // If an object is being detached NOT because of the AXObjectCache being destroyed,
 57     // then it&#39;s being removed from the accessibility tree and we should emit a signal.
 58     if (detachmentType != AccessibilityDetachmentType::CacheDestroyed &amp;&amp; obj-&gt;document() &amp;&amp; wrapperParent(wrapper))
 59         m_deferredDetachedWrapperList.add(wrapper);
 60 
 61     webkitAccessibleDetach(WEBKIT_ACCESSIBLE(wrapper));
 62 }
 63 
<span class="line-modified"> 64 void AXObjectCache::attachWrapper(AXCoreObject* obj)</span>
 65 {
<span class="line-modified"> 66     // FIXME: at the moment, only allow to attach AccessibilityObjects.</span>
<span class="line-modified"> 67     if (!is&lt;AccessibilityObject&gt;(obj))</span>
<span class="line-added"> 68         return;</span>
<span class="line-added"> 69     AccessibilityObject* accessibilityObject = downcast&lt;AccessibilityObject&gt;(obj);</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     GRefPtr&lt;WebKitAccessible&gt; wrapper = adoptGRef(webkitAccessibleNew(accessibilityObject));</span>
<span class="line-added"> 72     accessibilityObject-&gt;setWrapper(wrapper.get());</span>
 73 
 74     // If an object is being attached and we are not in the middle of a layout update, then
 75     // we should report ATs by emitting the children-changed::add signal from the parent.
<span class="line-modified"> 76     Document* document = accessibilityObject-&gt;document();</span>
 77     if (!document || document-&gt;childNeedsStyleRecalc())
 78         return;
 79 
 80     // Don&#39;t emit the signal when the actual object being added is not going to be exposed.
<span class="line-modified"> 81     if (accessibilityObject-&gt;accessibilityIsIgnoredByDefault())</span>
 82         return;
 83 
 84     // Don&#39;t emit the signal if the object being added is not -- or not yet -- rendered,
 85     // which can occur in nested iframes. In these instances we don&#39;t want to ignore the
 86     // child. But if an assistive technology is listening, AT-SPI2 will attempt to create
 87     // and cache the state set for the child upon emission of the signal. If the object
 88     // has not yet been rendered, this will result in a crash.
<span class="line-modified"> 89     if (!accessibilityObject-&gt;renderer())</span>
 90         return;
 91 
<span class="line-modified"> 92     m_deferredAttachedWrapperObjectList.add(accessibilityObject);</span>
 93 }
 94 
 95 void AXObjectCache::platformPerformDeferredCacheUpdate()
 96 {
 97     for (auto&amp; coreObject : m_deferredAttachedWrapperObjectList) {
 98         auto* wrapper = coreObject-&gt;wrapper();
 99         if (!wrapper)
100             continue;
101 
102         // Don&#39;t emit the signal for objects whose parents won&#39;t be exposed directly.
103         auto* coreParent = coreObject-&gt;parentObjectUnignored();
104         if (!coreParent || coreParent-&gt;accessibilityIsIgnoredByDefault())
105             continue;
106 
107         // Look for the right object to emit the signal from.
108         auto* atkParent = coreParent-&gt;wrapper();
109         if (!atkParent)
110             continue;
111 
112         size_t index = coreParent-&gt;children(false).find(coreObject);
113         g_signal_emit_by_name(atkParent, &quot;children-changed::add&quot;, index != notFound ? index : -1, wrapper);
114     }
115     m_deferredAttachedWrapperObjectList.clear();
116 
117     for (auto&amp; wrapper : m_deferredDetachedWrapperList) {
118         if (auto* atkParent = wrapperParent(wrapper.get())) {
119             // The accessibility hierarchy is already invalid, so the parent-children relationships
120             // in the AccessibilityObject tree are not there anymore, so we can&#39;t know the offset.
121             g_signal_emit_by_name(atkParent, &quot;children-changed::remove&quot;, -1, wrapper.get());
122         }
123     }
124     m_deferredDetachedWrapperList.clear();
125 }
126 
<span class="line-modified">127 static AXCoreObject* getListObject(AXCoreObject* object)</span>
128 {
129     // Only list boxes and menu lists supported so far.
130     if (!object-&gt;isListBox() &amp;&amp; !object-&gt;isMenuList())
131         return 0;
132 
133     // For list boxes the list object is just itself.
134     if (object-&gt;isListBox())
135         return object;
136 
137     // For menu lists we need to return the first accessible child,
138     // with role MenuListPopupRole, since that&#39;s the one holding the list
139     // of items with role MenuListOptionRole.
140     const AccessibilityObject::AccessibilityChildrenVector&amp; children = object-&gt;children();
141     if (!children.size())
142         return 0;
143 
<span class="line-modified">144     AXCoreObject* listObject = children.at(0).get();</span>
145     if (!listObject-&gt;isMenuListPopup())
146         return 0;
147 
148     return listObject;
149 }
150 
<span class="line-modified">151 static void notifyChildrenSelectionChange(AXCoreObject* object)</span>
152 {
153     // This static variables are needed to keep track of the old
154     // focused object and its associated list object, as per previous
155     // calls to this function, in order to properly decide whether to
156     // emit some signals or not.
<span class="line-modified">157     static NeverDestroyed&lt;RefPtr&lt;AXCoreObject&gt;&gt; oldListObject;</span>
<span class="line-modified">158     static NeverDestroyed&lt;RefPtr&lt;AXCoreObject&gt;&gt; oldFocusedObject;</span>
159 
160     // Only list boxes and menu lists supported so far.
161     if (!object || !(object-&gt;isListBox() || object-&gt;isMenuList()))
162         return;
163 
164     // Only support HTML select elements so far (ARIA selectors not supported).
165     Node* node = object-&gt;node();
166     if (!is&lt;HTMLSelectElement&gt;(node))
167         return;
168 
169     // Emit signal from the listbox&#39;s point of view first.
170     g_signal_emit_by_name(object-&gt;wrapper(), &quot;selection-changed&quot;);
171 
172     // Find the item where the selection change was triggered from.
173     HTMLSelectElement&amp; select = downcast&lt;HTMLSelectElement&gt;(*node);
174     int changedItemIndex = select.activeSelectionStartListIndex();
175 
<span class="line-modified">176     AXCoreObject* listObject = getListObject(object);</span>
177     if (!listObject) {
178         oldListObject.get() = nullptr;
179         return;
180     }
181 
182     const AccessibilityObject::AccessibilityChildrenVector&amp; items = listObject-&gt;children();
183     if (changedItemIndex &lt; 0 || changedItemIndex &gt;= static_cast&lt;int&gt;(items.size()))
184         return;
<span class="line-modified">185     AXCoreObject* item = items.at(changedItemIndex).get();</span>
186 
187     // Ensure the current list object is the same than the old one so
188     // further comparisons make sense. Otherwise, just reset
189     // oldFocusedObject so it won&#39;t be taken into account.
190     if (oldListObject.get() != listObject)
191         oldFocusedObject.get() = nullptr;
192 
193     WebKitAccessible* axItem = item ? item-&gt;wrapper() : nullptr;
194     WebKitAccessible* axOldFocusedObject = oldFocusedObject.get() ? oldFocusedObject.get()-&gt;wrapper() : nullptr;
195 
196     // Old focused object just lost focus, so emit the events.
197     if (axOldFocusedObject &amp;&amp; axItem != axOldFocusedObject) {
198         g_signal_emit_by_name(axOldFocusedObject, &quot;focus-event&quot;, false);
199         atk_object_notify_state_change(ATK_OBJECT(axOldFocusedObject), ATK_STATE_FOCUSED, false);
200     }
201 
202     // Emit needed events for the currently (un)selected item.
203     if (axItem) {
204         bool isSelected = item-&gt;isSelected();
205         atk_object_notify_state_change(ATK_OBJECT(axItem), ATK_STATE_SELECTED, isSelected);
206         // When the selection changes in a collapsed widget such as a combo box
207         // whose child menu is not showing, that collapsed widget retains focus.
208         if (!object-&gt;isCollapsed()) {
209             g_signal_emit_by_name(axItem, &quot;focus-event&quot;, isSelected);
210             atk_object_notify_state_change(ATK_OBJECT(axItem), ATK_STATE_FOCUSED, isSelected);
211         }
212     }
213 
214     // Update pointers to the previously involved objects.
215     oldListObject.get() = listObject;
216     oldFocusedObject.get() = item;
217 }
218 
<span class="line-modified">219 void AXObjectCache::postPlatformNotification(AXCoreObject* coreObject, AXNotification notification)</span>
220 {
221     auto* axObject = ATK_OBJECT(coreObject-&gt;wrapper());
222     if (!axObject)
223         return;
224 
225     switch (notification) {
226     case AXCheckedStateChanged:
227         if (!coreObject-&gt;isCheckboxOrRadio() &amp;&amp; !coreObject-&gt;isSwitch())
228             return;
229         atk_object_notify_state_change(axObject, ATK_STATE_CHECKED, coreObject-&gt;isChecked());
230         break;
231 
232     case AXSelectedChildrenChanged:
233     case AXMenuListValueChanged:
234         // Accessible focus claims should not be made if the associated widget is not focused.
235         if (notification == AXMenuListValueChanged &amp;&amp; coreObject-&gt;isMenuList() &amp;&amp; coreObject-&gt;isFocused()) {
236             g_signal_emit_by_name(axObject, &quot;focus-event&quot;, true);
237             atk_object_notify_state_change(axObject, ATK_STATE_FOCUSED, true);
238         }
239         notifyChildrenSelectionChange(coreObject);
</pre>
<hr />
<pre>
281     case AXDisabledStateChanged: {
282         bool enabledState = coreObject-&gt;isEnabled();
283         atk_object_notify_state_change(axObject, ATK_STATE_ENABLED, enabledState);
284         atk_object_notify_state_change(axObject, ATK_STATE_SENSITIVE, enabledState);
285         break;
286     }
287 
288     case AXPressedStateChanged:
289         atk_object_notify_state_change(axObject, ATK_STATE_PRESSED, coreObject-&gt;isPressed());
290         break;
291 
292     case AXReadOnlyStatusChanged:
293         atk_object_notify_state_change(axObject, ATK_STATE_READ_ONLY, !coreObject-&gt;canSetValueAttribute());
294         break;
295 
296     case AXRequiredStatusChanged:
297         atk_object_notify_state_change(axObject, ATK_STATE_REQUIRED, coreObject-&gt;isRequired());
298         break;
299 
300     case AXActiveDescendantChanged:
<span class="line-modified">301         if (AXCoreObject* descendant = coreObject-&gt;activeDescendant())</span>
302             platformHandleFocusedUIElementChanged(nullptr, descendant-&gt;node());
303         break;
304 
305     default:
306         break;
307     }
308 }
309 
310 void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject* object, AXTextChange textChange, unsigned offset, const String&amp; text)
311 {
312     if (!object || text.isEmpty())
313         return;
314 
<span class="line-modified">315     AXCoreObject* parentObject = object-&gt;isNonNativeTextControl() ? object : object-&gt;parentObjectUnignored();</span>
316     if (!parentObject)
317         return;
318 
319     auto* wrapper = parentObject-&gt;wrapper();
320     if (!wrapper || !ATK_IS_TEXT(wrapper))
321         return;
322 
323     Node* node = object-&gt;node();
324     if (!node)
325         return;
326 
327     // Ensure document&#39;s layout is up-to-date before using TextIterator.
328     Document&amp; document = node-&gt;document();
329     document.updateLayout();
330 
331     // Select the right signal to be emitted
332     CString detail;
333     switch (textChange) {
334     case AXTextInserted:
335         detail = &quot;text-insert&quot;;
</pre>
</td>
</tr>
</table>
<center><a href="../AccessibleSetValueEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityObjectAtk.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
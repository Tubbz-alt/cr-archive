<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerBacking.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,20 +30,20 @@</span>
  #include &quot;CSSAnimationController.h&quot;
  #include &quot;CSSPropertyNames.h&quot;
  #include &quot;CanvasRenderingContext.h&quot;
  #include &quot;Chrome.h&quot;
  #include &quot;ChromeClient.h&quot;
<span class="udiff-line-removed">- #include &quot;DocumentTimeline.h&quot;</span>
  #include &quot;Frame.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;FullscreenManager.h&quot;
  #include &quot;GraphicsLayer.h&quot;
  #include &quot;HTMLCanvasElement.h&quot;
  #include &quot;HTMLIFrameElement.h&quot;
  #include &quot;HTMLNames.h&quot;
  #include &quot;HitTestResult.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
<span class="udiff-line-added">+ #include &quot;KeyframeEffectStack.h&quot;</span>
  #include &quot;LayerAncestorClippingStack.h&quot;
  #include &quot;LayerOverlapMap.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;NodeList.h&quot;
  #include &quot;Page.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,10 +65,11 @@</span>
  #include &quot;TiledBacking.h&quot;
  #include &quot;TransformState.h&quot;
  #include &lt;wtf/HexNumber.h&gt;
  #include &lt;wtf/MemoryPressureHandler.h&gt;
  #include &lt;wtf/SetForScope.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/SystemTracing.h&gt;</span>
  #include &lt;wtf/text/CString.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,10 +197,32 @@</span>
  #if !LOG_DISABLED
      unsigned depth { 0 };
  #endif
  };
  
<span class="udiff-line-added">+ struct RenderLayerCompositor::UpdateBackingTraversalState {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     UpdateBackingTraversalState(RenderLayer* compAncestor = nullptr)</span>
<span class="udiff-line-added">+         : compositingAncestor(compAncestor)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     UpdateBackingTraversalState stateForDescendants() const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         UpdateBackingTraversalState state(compositingAncestor);</span>
<span class="udiff-line-added">+ #if !LOG_DISABLED</span>
<span class="udiff-line-added">+         state.depth = depth + 1;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+         return state;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     RenderLayer* compositingAncestor;</span>
<span class="udiff-line-added">+ #if !LOG_DISABLED</span>
<span class="udiff-line-added">+     unsigned depth { 0 };</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  class RenderLayerCompositor::BackingSharingState {
      WTF_MAKE_NONCOPYABLE(BackingSharingState);
  public:
      BackingSharingState() = default;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -679,22 +702,24 @@</span>
  // Returns true on a successful update.
  bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
  {
      LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; updateCompositingLayers &quot; &lt;&lt; updateType &lt;&lt; &quot; contentLayersCount &quot; &lt;&lt; m_contentLayersCount);
  
<span class="udiff-line-added">+     TraceScope tracingScope(CompositingUpdateStart, CompositingUpdateEnd);</span>
<span class="udiff-line-added">+ </span>
  #if ENABLE(TREE_DEBUGGING)
      if (compositingLogEnabled())
          showPaintOrderTree(m_renderView.layer());
  #endif
  
      if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
          cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
  
      m_updateCompositingLayersTimer.stop();
  
<span class="udiff-line-modified-removed">-     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache</span>
<span class="udiff-line-modified-removed">-         || m_renderView.document().pageCacheState() == Document::AboutToEnterPageCache);</span>
<span class="udiff-line-modified-added">+     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache</span>
<span class="udiff-line-modified-added">+         || m_renderView.document().backForwardCacheState() == Document::AboutToEnterBackForwardCache);</span>
  
      // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
      if (!m_renderView.document().visualUpdatesAllowed())
          return false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -786,12 +811,13 @@</span>
      if (updateRoot-&gt;hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot-&gt;needsUpdateBackingOrHierarchyTraversal()) {
          ScrollingTreeState scrollingTreeState = { 0, 0 };
          if (!m_renderView.frame().isMainFrame())
              scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
  
<span class="udiff-line-added">+         UpdateBackingTraversalState traversalState;</span>
          Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; childList;
<span class="udiff-line-modified-removed">-         updateBackingAndHierarchy(*updateRoot, childList, scrollingTreeState);</span>
<span class="udiff-line-modified-added">+         updateBackingAndHierarchy(*updateRoot, childList, traversalState, scrollingTreeState);</span>
  
          // Host the document layer in the RenderView&#39;s root layer.
          appendDocumentOverlayLayers(childList);
          // Even when childList is empty, don&#39;t drop out of compositing mode if there are
          // composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -836,10 +862,13 @@</span>
      return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);
  }
  
  void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
  {
<span class="udiff-line-added">+     layer.updateDescendantDependentFlags();</span>
<span class="udiff-line-added">+     layer.updateLayerListsIfNeeded();</span>
<span class="udiff-line-added">+ </span>
      if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()
          &amp;&amp; !layer.needsCompositingRequirementsTraversal()
          &amp;&amp; !compositingState.fullPaintOrderTraversalRequired
          &amp;&amp; !compositingState.descendantsRequireCompositingUpdate) {
          traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -850,13 +879,10 @@</span>
  
      // FIXME: maybe we can avoid updating all remaining layers in paint order.
      compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
      compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
  
<span class="udiff-line-removed">-     layer.updateDescendantDependentFlags();</span>
<span class="udiff-line-removed">-     layer.updateLayerListsIfNeeded();</span>
<span class="udiff-line-removed">- </span>
      layer.setHasCompositingDescendant(false);
  
      // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
      RequiresCompositingData queryData;
      bool willBeComposited = layer.isComposited();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -965,11 +991,11 @@</span>
          LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
      }
  
      backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      bool anyDescendantHas3DTransform = false;
      bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1009,27 +1035,23 @@</span>
      }
  
      ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
  #endif
      // Now check for reasons to become composited that depend on the state of descendant layers.
<span class="udiff-line-modified-removed">-     IndirectCompositingReason indirectCompositingReason;</span>
<span class="udiff-line-modified-removed">-     if (!willBeComposited &amp;&amp; canBeComposited(layer)</span>
<span class="udiff-line-modified-removed">-         &amp;&amp; requiresCompositingForIndirectReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking, indirectCompositingReason)) {</span>
<span class="udiff-line-modified-removed">-         layer.setIndirectCompositingReason(indirectCompositingReason);</span>
<span class="udiff-line-modified-removed">-         layerWillCompositePostDescendants();</span>
<span class="udiff-line-modified-added">+     if (!willBeComposited &amp;&amp; canBeComposited(layer)) {</span>
<span class="udiff-line-modified-added">+         auto indirectReason = computeIndirectCompositingReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking);</span>
<span class="udiff-line-modified-added">+         if (indirectReason != IndirectCompositingReason::None) {</span>
<span class="udiff-line-modified-added">+             layer.setIndirectCompositingReason(indirectReason);</span>
<span class="udiff-line-modified-added">+             layerWillCompositePostDescendants();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      if (layer.reflectionLayer()) {
          // FIXME: Shouldn&#39;t we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
          layer.reflectionLayer()-&gt;setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);
      }
  
<span class="udiff-line-removed">-     // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that now.</span>
<span class="udiff-line-removed">-     bool isCompositedClippingLayer = canBeComposited(layer) &amp;&amp; clipsCompositingDescendants(layer);</span>
<span class="udiff-line-removed">-     if (isCompositedClippingLayer &amp; !willBeComposited)</span>
<span class="udiff-line-removed">-         layerWillCompositePostDescendants();</span>
<span class="udiff-line-removed">- </span>
      // If we&#39;re back at the root, and no other layers need to be composited, and the root layer itself doesn&#39;t need
      // to be composited, then we can drop out of compositing mode altogether. However, don&#39;t drop out of compositing mode
      // if there are composited layers that we didn&#39;t hit in our traversal (e.g. because of visibility:hidden).
      RequiresCompositingData rootLayerQueryData;
      if (layer.isRenderViewLayer() &amp;&amp; !currentState.subtreeIsCompositing &amp;&amp; !requiresCompositingLayer(layer, rootLayerQueryData) &amp;&amp; !m_forceCompositingMode &amp;&amp; !needsCompositingForContentOrOverlays()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1051,11 +1073,11 @@</span>
          // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
          layer.setNeedsCompositingGeometryUpdateOnAncestors();
      }
  
      // Update layer state bits.
<span class="udiff-line-modified-removed">-     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))</span>
<span class="udiff-line-modified-added">+     if (layer.reflectionLayer() &amp;&amp; updateLayerCompositingState(*layer.reflectionLayer(), &amp;layer, queryData, CompositingChangeRepaintNow))</span>
          layer.setNeedsCompositingLayerConnection();
  
      // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
      if (layer.needsCompositingPaintOrderChildrenUpdate()) {
          layer.setChildrenNeedCompositingGeometryUpdate();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1081,19 +1103,19 @@</span>
  }
  
  // We have to traverse unchanged layers to fill in the overlap map.
  void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer&amp; layer, LayerOverlapMap&amp; overlapMap, CompositingState&amp; compositingState, BackingSharingState&amp; backingSharingState, bool&amp; descendantHas3DTransform)
  {
<span class="udiff-line-added">+     layer.updateDescendantDependentFlags();</span>
<span class="udiff-line-added">+     layer.updateLayerListsIfNeeded();</span>
<span class="udiff-line-added">+ </span>
      ASSERT(!compositingState.fullPaintOrderTraversalRequired);
      ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
      ASSERT(!layer.needsCompositingRequirementsTraversal());
  
      LOG_WITH_STREAM(Compositing, stream &lt;&lt; TextStream::Repeat(compositingState.depth * 2, &#39; &#39;) &lt;&lt; &amp;layer &lt;&lt; (layer.isNormalFlowOnly() ? &quot; n&quot; : &quot; s&quot;) &lt;&lt; &quot; traverseUnchangedSubtree&quot;);
  
<span class="udiff-line-removed">-     layer.updateDescendantDependentFlags();</span>
<span class="udiff-line-removed">-     layer.updateLayerListsIfNeeded();</span>
<span class="udiff-line-removed">- </span>
      bool layerIsComposited = layer.isComposited();
      bool layerPaintsIntoProvidedBacking = false;
      bool didPushOverlapContainer = false;
  
      OverlapExtent layerExtent;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1138,11 +1160,11 @@</span>
          LOG_WITH_STREAM(CompositingOverlap, stream &lt;&lt; &quot;unchangedSubtree: layer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; will share, pushed container &quot; &lt;&lt; overlapMap);
      }
  
      backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      bool anyDescendantHas3DTransform = false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1174,20 +1196,21 @@</span>
      overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
  
      ASSERT(!layer.needsCompositingRequirementsTraversal());
  }
  
<span class="udiff-line-modified-removed">- void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel, int depth)</span>
<span class="udiff-line-modified-added">+ void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer&amp; layer, Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; childLayersOfEnclosingLayer, UpdateBackingTraversalState&amp; traversalState, ScrollingTreeState&amp; scrollingTreeState, OptionSet&lt;UpdateLevel&gt; updateLevel)</span>
  {
      layer.updateDescendantDependentFlags();
      layer.updateLayerListsIfNeeded();
  
      bool layerNeedsUpdate = !updateLevel.isEmpty();
      if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
          updateLevel.add(UpdateLevel::AllDescendants);
  
<span class="udiff-line-modified-removed">-     ScrollingTreeState stateForDescendants = scrollingTreeState;</span>
<span class="udiff-line-modified-added">+     ScrollingTreeState scrollingStateForDescendants = scrollingTreeState;</span>
<span class="udiff-line-added">+     UpdateBackingTraversalState traversalStateForDescendants = traversalState.stateForDescendants();</span>
  
      auto* layerBacking = layer.backing();
      if (layerBacking) {
          updateLevel.remove(UpdateLevel::CompositedChildren);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1198,21 +1221,21 @@</span>
              // Our geometry can affect descendants.
              updateLevel.add(UpdateLevel::CompositedChildren);
          }
  
          if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
<span class="udiff-line-modified-removed">-             if (layerBacking-&gt;updateConfiguration()) {</span>
<span class="udiff-line-modified-added">+             if (layerBacking-&gt;updateConfiguration(traversalState.compositingAncestor)) {</span>
                  layerNeedsUpdate = true; // We also need to update geometry.
                  layer.setNeedsCompositingLayerConnection();
              }
  
              layerBacking-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
          }
  
          OptionSet&lt;ScrollingNodeChangeFlags&gt; scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
          if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {
<span class="udiff-line-modified-removed">-             layerBacking-&gt;updateGeometry();</span>
<span class="udiff-line-modified-added">+             layerBacking-&gt;updateGeometry(traversalState.compositingAncestor);</span>
              scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
          } else if (layer.needsScrollingTreeUpdate())
              scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
  
          // This needs to happen after any geometry update.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1221,27 +1244,27 @@</span>
              layerBacking-&gt;updateEventRegion();
  
          if (auto* reflection = layer.reflectionLayer()) {
              if (auto* reflectionBacking = reflection-&gt;backing()) {
                  reflectionBacking-&gt;updateCompositedBounds();
<span class="udiff-line-modified-removed">-                 reflectionBacking-&gt;updateGeometry();</span>
<span class="udiff-line-modified-added">+                 reflectionBacking-&gt;updateGeometry(&amp;layer);</span>
                  reflectionBacking-&gt;updateAfterDescendants();
              }
          }
  
          if (!layer.parent())
              updateRootLayerPosition();
  
          // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
          // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
<span class="udiff-line-modified-removed">-         stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, scrollingNodeChanges);</span>
<span class="udiff-line-modified-removed">-         stateForDescendants.nextChildIndex = 0;</span>
<span class="udiff-line-modified-added">+         scrollingStateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, traversalState.compositingAncestor, scrollingTreeState, scrollingNodeChanges);</span>
<span class="udiff-line-modified-added">+         scrollingStateForDescendants.nextChildIndex = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         traversalStateForDescendants.compositingAncestor = &amp;layer;</span>
  
  #if !LOG_DISABLED
<span class="udiff-line-modified-removed">-         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, depth);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-         UNUSED_PARAM(depth);</span>
<span class="udiff-line-modified-added">+         logLayerInfo(layer, &quot;updateBackingAndHierarchy&quot;, traversalState.depth);</span>
  #endif
      }
  
      if (layer.childrenNeedCompositingGeometryUpdate())
          updateLevel.add(UpdateLevel::CompositedChildren);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1254,11 +1277,11 @@</span>
      bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
          || (layer.hasCompositingDescendant() &amp;&amp; (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
  
      bool requiresChildRebuild = layerBacking &amp;&amp; layer.needsCompositingLayerConnection() &amp;&amp; !layer.hasCompositingDescendant();
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      auto appendForegroundLayerIfNecessary = [&amp;] {
          // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1268,19 +1291,19 @@</span>
          }
      };
  
      if (requireDescendantTraversal) {
          for (auto* renderLayer : layer.negativeZOrderLayers())
<span class="udiff-line-modified-removed">-             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);</span>
<span class="udiff-line-modified-added">+             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);</span>
  
          appendForegroundLayerIfNecessary();
  
          for (auto* renderLayer : layer.normalFlowLayers())
<span class="udiff-line-modified-removed">-             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);</span>
<span class="udiff-line-modified-added">+             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);</span>
  
          for (auto* renderLayer : layer.positiveZOrderLayers())
<span class="udiff-line-modified-removed">-             updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);</span>
<span class="udiff-line-modified-added">+             updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);</span>
      } else if (requiresChildRebuild)
          appendForegroundLayerIfNecessary();
  
      if (layerBacking) {
          if (requireDescendantTraversal || requiresChildRebuild) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1366,14 +1389,14 @@</span>
  
      LayoutRect absoluteBounds = backing-&gt;compositedBounds();
      absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
  
      StringBuilder logString;
<span class="udiff-line-modified-removed">-     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer))), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), &#39;-&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), &#39;,&#39;, FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);</span>
<span class="udiff-line-modified-added">+     logString.append(pad(&#39; &#39;, 12 + depth * 2, hex(reinterpret_cast&lt;uintptr_t&gt;(&amp;layer), Lowercase)), &quot; id &quot;, backing-&gt;graphicsLayer()-&gt;primaryLayerID(), &quot; (&quot;, absoluteBounds.x().toFloat(), &#39;,&#39;, absoluteBounds.y().toFloat(), &#39;-&#39;, absoluteBounds.maxX().toFloat(), &#39;,&#39;, absoluteBounds.maxY().toFloat(), &quot;) &quot;, FormattedNumber::fixedWidth(backing-&gt;backingStoreMemoryEstimate() / 1024, 2), &quot;KB&quot;);</span>
  
<span class="udiff-line-modified-removed">-     if (!layer.renderer().style().hasAutoZIndex())</span>
<span class="udiff-line-modified-removed">-         logString.append(&quot; z-index: &quot;, layer.renderer().style().zIndex());</span>
<span class="udiff-line-modified-added">+     if (!layer.renderer().style().hasAutoUsedZIndex())</span>
<span class="udiff-line-modified-added">+         logString.append(&quot; z-index: &quot;, layer.renderer().style().usedZIndex());</span>
  
      logString.append(&quot; (&quot;, logReasonsForCompositing(layer), &quot;) &quot;);
  
      if (backing-&gt;graphicsLayer()-&gt;contentsOpaque() || backing-&gt;paintsIntoCompositedAncestor() || backing-&gt;foregroundLayer() || backing-&gt;backgroundLayer()) {
          logString.append(&#39;[&#39;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1688,17 +1711,17 @@</span>
          layer.backing()-&gt;updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
  
      return layerChanged;
  }
  
<span class="udiff-line-modified-removed">- bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer&amp; layer, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint)</span>
<span class="udiff-line-modified-added">+ bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, RequiresCompositingData&amp; queryData, CompositingChangeRepaint shouldRepaint)</span>
  {
      bool layerChanged = updateBacking(layer, queryData, shouldRepaint);
  
      // See if we need content or clipping layers. Methods called here should assume
      // that the compositing state of descendant layers has not been updated yet.
<span class="udiff-line-modified-removed">-     if (layer.backing() &amp;&amp; layer.backing()-&gt;updateConfiguration())</span>
<span class="udiff-line-modified-added">+     if (layer.backing() &amp;&amp; layer.backing()-&gt;updateConfiguration(compositingAncestor))</span>
          layerChanged = true;
  
      return layerChanged;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1882,12 +1905,12 @@</span>
      } else
          clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&amp;rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.
  
      auto clippedBounds = extent.bounds;
      if (!clipRect.isInfinite()) {
<span class="udiff-line-modified-removed">-         // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="udiff-line-modified-removed">-         if (!m_renderView.settings().delegatesPageScaling())</span>
<span class="udiff-line-modified-added">+         // With delegated page scaling, pageScaleFactor() is not applied by RenderView, so we should not scale here.</span>
<span class="udiff-line-modified-added">+         if (!page().delegatesScaling())</span>
              clipRect.scale(pageScaleFactor());
  
          clippedBounds.intersect(clipRect);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1905,11 +1928,11 @@</span>
  
          OverlapExtent layerExtent;
          addToOverlapMap(overlapMap, layer, layerExtent);
      }
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
  #endif
  
      for (auto* renderLayer : layer.negativeZOrderLayers())
          addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &amp;layer);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2081,10 +2104,11 @@</span>
      }
  }
  
  String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
  {
<span class="udiff-line-added">+     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerCompositor &quot; &lt;&lt; this &lt;&lt; &quot; layerTreeAsText&quot;);</span>
      updateCompositingLayers(CompositingUpdateType::AfterLayout);
  
      if (!m_rootContentsLayer)
          return String();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2112,10 +2136,12 @@</span>
          layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
      if (flags &amp; LayerTreeFlagsIncludeRootLayerProperties)
          layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
      if (flags &amp; LayerTreeFlagsIncludeEventRegion)
          layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;
<span class="udiff-line-added">+     if (flags &amp; LayerTreeFlagsIncludeDeepColor)</span>
<span class="udiff-line-added">+         layerTreeBehavior |= LayerTreeAsTextIncludeDeepColor;</span>
  
      // We skip dumping the scroll and clip layers to keep layerTreeAsText output
      // similar between platforms.
      String layerTreeText = m_rootContentsLayer-&gt;layerTreeAsText(layerTreeBehavior);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2189,11 +2215,11 @@</span>
  
      // FIXME: This method does not work correctly with transforms.
      if (layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor())
          layer.setBackingNeedsRepaint();
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(layer);
  #endif
  
      if (layer.hasCompositingDescendant()) {
          for (auto* renderLayer : layer.negativeZOrderLayers())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2316,11 +2342,10 @@</span>
      auto&amp; renderer = rendererForCompositingTests(layer);
  
      // The root layer always has a compositing layer, but it may not have backing.
      return requiresCompositingForTransform(renderer)
          || requiresCompositingForAnimation(renderer)
<span class="udiff-line-removed">-         || clipsCompositingDescendants(*renderer.layer())</span>
          || requiresCompositingForPosition(renderer, *renderer.layer(), queryData)
          || requiresCompositingForCanvas(renderer)
          || requiresCompositingForFilters(renderer)
          || requiresCompositingForWillChange(renderer)
          || requiresCompositingForBackfaceVisibility(renderer)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2396,26 +2421,27 @@</span>
          || renderer.hasReflection()
          || renderer.hasFilter()
          || renderer.hasBackdropFilter())
          return true;
  
<span class="udiff-line-added">+     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // FIXME: We really need to keep track of the ancestor layer that has its own backing store.</span>
<span class="udiff-line-added">+     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+ </span>
      if (layer.mustCompositeForIndirectReasons()) {
          IndirectCompositingReason reason = layer.indirectCompositingReason();
          return reason == IndirectCompositingReason::Overlap
              || reason == IndirectCompositingReason::OverflowScrollPositioning
              || reason == IndirectCompositingReason::Stacking
              || reason == IndirectCompositingReason::BackgroundLayer
              || reason == IndirectCompositingReason::GraphicalEffect
              || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
      }
  
<span class="udiff-line-removed">-     if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (layer.isComposited() &amp;&amp; layer.backing()-&gt;hasBackingSharingLayers())</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">- </span>
      return false;
  }
  
  OptionSet&lt;CompositingReason&gt; RenderLayerCompositor::reasonsForCompositing(const RenderLayer&amp; layer) const
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2443,13 +2469,10 @@</span>
          reasons.add(CompositingReason::EmbeddedView);
  
      if ((canRender3DTransforms() &amp;&amp; renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
          reasons.add(CompositingReason::BackfaceVisibilityHidden);
  
<span class="udiff-line-removed">-     if (clipsCompositingDescendants(*renderer.layer()))</span>
<span class="udiff-line-removed">-         reasons.add(CompositingReason::ClipsCompositingDescendants);</span>
<span class="udiff-line-removed">- </span>
      if (requiresCompositingForAnimation(renderer))
          reasons.add(CompositingReason::Animation);
  
      if (requiresCompositingForFilters(renderer))
          reasons.add(CompositingReason::Filters);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2464,10 +2487,13 @@</span>
          reasons.add(CompositingReason::OverflowScrolling);
  
      switch (renderer.layer()-&gt;indirectCompositingReason()) {
      case IndirectCompositingReason::None:
          break;
<span class="udiff-line-added">+     case IndirectCompositingReason::Clipping:</span>
<span class="udiff-line-added">+         reasons.add(CompositingReason::ClipsCompositingDescendants);</span>
<span class="udiff-line-added">+         break;</span>
      case IndirectCompositingReason::Stacking:
          reasons.add(CompositingReason::Stacking);
          break;
      case IndirectCompositingReason::OverflowScrollPositioning:
          reasons.add(CompositingReason::OverflowScrollPositioning);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2750,13 +2776,18 @@</span>
  {
      if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
          return false;
  
      if (auto* element = renderer.element()) {
<span class="udiff-line-modified-removed">-         if (auto* timeline = element-&gt;document().existingTimeline()) {</span>
<span class="udiff-line-modified-removed">-             if (timeline-&gt;runningAnimationsForElementAreAllAccelerated(*element))</span>
<span class="udiff-line-modified-removed">-                 return true;</span>
<span class="udiff-line-modified-added">+         if (auto* effectsStack = element-&gt;keyframeEffectStack()) {</span>
<span class="udiff-line-modified-added">+             return (effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyOpacity)</span>
<span class="udiff-line-modified-added">+                 &amp;&amp; (usesCompositing() || (m_compositingTriggers &amp; ChromeClient::AnimatedOpacityTrigger)))</span>
<span class="udiff-line-added">+                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyFilter)</span>
<span class="udiff-line-added">+ #if ENABLE(FILTERS_LEVEL_2)</span>
<span class="udiff-line-added">+                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyWebkitBackdropFilter)</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+                 || effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyTransform);</span>
          }
      }
  
      if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2948,11 +2979,11 @@</span>
  bool RenderLayerCompositor::requiresCompositingForScrollableFrame(RequiresCompositingData&amp; queryData) const
  {
      if (isMainFrameCompositor())
          return false;
  
<span class="udiff-line-modified-removed">- #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
<span class="udiff-line-modified-added">+ #if PLATFORM(COCOA) || USE(NICOSIA)</span>
      if (!m_renderView.settings().asyncFrameScrollingEnabled())
          return false;
  #endif
  
      if (!(m_compositingTriggers &amp; ChromeClient::ScrollableNonMainFrameTrigger))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3037,46 +3068,40 @@</span>
      }
  
      return layer.hasCompositedScrollableOverflow();
  }
  
<span class="udiff-line-modified-removed">- // FIXME: why doesn&#39;t this handle the clipping cases?</span>
<span class="udiff-line-removed">- bool RenderLayerCompositor::requiresCompositingForIndirectReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason&amp; reason) const</span>
<span class="udiff-line-modified-added">+ IndirectCompositingReason RenderLayerCompositor::computeIndirectCompositingReason(const RenderLayer&amp; layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking) const</span>
  {
      // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
      // via compositing so that they also apply to those composited descendants.
      auto&amp; renderer = layer.renderer();
<span class="udiff-line-modified-removed">-     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {</span>
<span class="udiff-line-modified-removed">-         reason = IndirectCompositingReason::GraphicalEffect;</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (hasCompositedDescendants &amp;&amp; (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection()))</span>
<span class="udiff-line-modified-added">+         return IndirectCompositingReason::GraphicalEffect;</span>
  
      // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
      // will be affected by the preserve-3d or perspective.
      if (has3DTransformedDescendants) {
<span class="udiff-line-modified-removed">-         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {</span>
<span class="udiff-line-modified-removed">-             reason = IndirectCompositingReason::Preserve3D;</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D)</span>
<span class="udiff-line-modified-added">+             return IndirectCompositingReason::Preserve3D;</span>
  
<span class="udiff-line-modified-removed">-         if (renderer.style().hasPerspective()) {</span>
<span class="udiff-line-modified-removed">-             reason = IndirectCompositingReason::Perspective;</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         if (renderer.style().hasPerspective())</span>
<span class="udiff-line-modified-added">+             return IndirectCompositingReason::Perspective;</span>
      }
  
      // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.
      if (!paintsIntoProvidedBacking &amp;&amp; layer.hasCompositedScrollingAncestor()) {
          auto* paintDestination = layer.paintOrderParent();
<span class="udiff-line-modified-removed">-         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None) {</span>
<span class="udiff-line-modified-removed">-             reason = IndirectCompositingReason::OverflowScrollPositioning;</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         if (paintDestination &amp;&amp; layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None)</span>
<span class="udiff-line-modified-added">+             return IndirectCompositingReason::OverflowScrollPositioning;</span>
      }
  
<span class="udiff-line-modified-removed">-     reason = IndirectCompositingReason::None;</span>
<span class="udiff-line-modified-removed">-     return false;</span>
<span class="udiff-line-modified-added">+     // Check for clipping last; if compositing just for clipping, the layer doesn&#39;t need its own backing store.</span>
<span class="udiff-line-modified-added">+     if (hasCompositedDescendants &amp;&amp; clipsCompositingDescendants(layer))</span>
<span class="udiff-line-added">+         return IndirectCompositingReason::Clipping;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return IndirectCompositingReason::None;</span>
  }
  
  bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
  {
      if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3247,11 +3272,11 @@</span>
  
          return AncestorTraversal::Continue;
      });
  }
  
<span class="udiff-line-modified-removed">- ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer) const</span>
<span class="udiff-line-modified-added">+ ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer&amp; layer, const RenderLayer* compositedAncestor) const</span>
  {
      if (layer.isRenderViewLayer())
          return ScrollPositioningBehavior::None;
  
      if (layer.renderer().isFixedPositioned())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3262,11 +3287,10 @@</span>
  
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
      if (!scrollingCoordinator)
          return ScrollPositioningBehavior::None;
  
<span class="udiff-line-removed">-     auto* compositedAncestor = layer.ancestorCompositingLayer();</span>
      if (!compositedAncestor) {
          ASSERT_NOT_REACHED();
          return ScrollPositioningBehavior::None;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3316,17 +3340,18 @@</span>
  bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject&amp; renderer) const
  {
      if (!(m_compositingTriggers &amp; ChromeClient::AnimationTrigger))
          return false;
  
<span class="udiff-line-modified-removed">-     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {</span>
<span class="udiff-line-modified-removed">-         if (auto* element = renderer.element()) {</span>
<span class="udiff-line-modified-removed">-             if (auto* timeline = element-&gt;document().existingTimeline())</span>
<span class="udiff-line-removed">-                 return timeline-&gt;isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-modified-added">+     if (auto* element = renderer.element()) {</span>
<span class="udiff-line-modified-added">+         if (auto* effectsStack = element-&gt;keyframeEffectStack())</span>
<span class="udiff-line-modified-added">+             return effectsStack-&gt;isCurrentlyAffectingProperty(CSSPropertyTransform);</span>
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
  }
  
  // If an element has composited negative z-index children, those children render in front of the
  // layer background, so we need an extra &#39;contents&#39; layer for the foreground of the layer object.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3365,11 +3390,11 @@</span>
      transformedClip.moveBy(scrollbarRect.location());
      scrollbar-&gt;paint(context, transformedClip);
      context.restore();
  }
  
<span class="udiff-line-modified-removed">- void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, OptionSet&lt;GraphicsLayerPaintingPhase&gt;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
<span class="udiff-line-modified-added">+ void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior)</span>
  {
  #if PLATFORM(MAC)
      LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4092,11 +4117,11 @@</span>
      if (style.transformStyle3D() == TransformStyle3D::Preserve3D || style.hasPerspective() || style.transform().has3DOperation())
          return true;
  
      const_cast&lt;RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(layer));
  #endif
  
      for (auto* renderLayer : layer.negativeZOrderLayers()) {
          if (layerHas3DContent(*renderLayer))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4317,20 +4342,20 @@</span>
          detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);
  
      backing-&gt;detachFromScrollingCoordinator(roles);
  }
  
<span class="udiff-line-modified-removed">- OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer) const</span>
<span class="udiff-line-modified-added">+ OptionSet&lt;ScrollCoordinationRole&gt; RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer&amp; layer, const RenderLayer* compositingAncestor) const</span>
  {
      OptionSet&lt;ScrollCoordinationRole&gt; coordinationRoles;
      if (isViewportConstrainedFixedOrStickyLayer(layer))
          coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);
  
      if (useCoordinatedScrollingForLayer(layer))
          coordinationRoles.add(ScrollCoordinationRole::Scrolling);
  
<span class="udiff-line-modified-removed">-     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer);</span>
<span class="udiff-line-modified-added">+     auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer, compositingAncestor);</span>
      switch (coordinatedPositioning) {
      case ScrollPositioningBehavior::Moves:
          coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);
          break;
      case ScrollPositioningBehavior::Stationary:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4344,13 +4369,13 @@</span>
          coordinationRoles.add(ScrollCoordinationRole::FrameHosting);
  
      return coordinationRoles;
  }
  
<span class="udiff-line-modified-removed">- ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
<span class="udiff-line-modified-added">+ ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
  {
<span class="udiff-line-modified-removed">-     auto roles = coordinatedScrollingRolesForLayer(layer);</span>
<span class="udiff-line-modified-added">+     auto roles = coordinatedScrollingRolesForLayer(layer, compositingAncestor);</span>
  
  #if PLATFORM(IOS_FAMILY)
      if (m_legacyScrollingLayerCoordinator) {
          if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
              m_legacyScrollingLayerCoordinator-&gt;addViewportConstrainedLayer(layer);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4369,11 +4394,11 @@</span>
      ScrollingTreeState childTreeState;
      ScrollingTreeState* currentTreeState = &amp;treeState;
  
      // If there&#39;s a positioning node, it&#39;s the parent scrolling node for fixed/sticky/scrolling/frame hosting.
      if (roles.contains(ScrollCoordinationRole::Positioning)) {
<span class="udiff-line-modified-removed">-         newNodeID = updateScrollingNodeForPositioningRole(layer, *currentTreeState, changes);</span>
<span class="udiff-line-modified-added">+         newNodeID = updateScrollingNodeForPositioningRole(layer, compositingAncestor, *currentTreeState, changes);</span>
          childTreeState.parentNodeID = newNodeID;
          currentTreeState = &amp;childTreeState;
      } else
          detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4595,11 +4620,11 @@</span>
      }
  
      return newNodeID;
  }
  
<span class="udiff-line-modified-removed">- ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
<span class="udiff-line-modified-added">+ ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer&amp; layer, const RenderLayer* compositingAncestor, ScrollingTreeState&amp; treeState, OptionSet&lt;ScrollingNodeChangeFlags&gt; changes)</span>
  {
      auto* scrollingCoordinator = this-&gt;scrollingCoordinator();
  
      auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);
      if (!newNodeID) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4612,11 +4637,11 @@</span>
          scrollingCoordinator-&gt;setNodeLayers(newNodeID, { backing.graphicsLayer() });
      }
  
      if (changes &amp; ScrollingNodeChangeFlags::LayerGeometry &amp;&amp; treeState.parentNodeID) {
          // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.
<span class="udiff-line-modified-removed">-         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer);</span>
<span class="udiff-line-modified-added">+         auto positioningBehavior = computeCoordinatedPositioningForLayer(layer, compositingAncestor);</span>
          auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);
          scrollingCoordinator-&gt;setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));
  
          auto* graphicsLayer = layer.backing()-&gt;graphicsLayer();
          AbsolutePositionConstraints constraints;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4640,11 +4665,11 @@</span>
  {
      if (scrollingCoordinator())
          return;
  
  #if PLATFORM(IOS_FAMILY)
<span class="udiff-line-modified-removed">-     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);</span>
<span class="udiff-line-modified-added">+     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
      if (m_legacyScrollingLayerCoordinator)
          m_legacyScrollingLayerCoordinator-&gt;removeScrollingLayer(layer, backing);
  #else
      UNUSED_PARAM(layer);
      UNUSED_PARAM(backing);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4656,11 +4681,11 @@</span>
  {
      if (scrollingCoordinator())
          return;
  
  #if PLATFORM(IOS_FAMILY)
<span class="udiff-line-modified-removed">-     ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);</span>
<span class="udiff-line-modified-added">+     ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
      if (m_legacyScrollingLayerCoordinator)
          m_legacyScrollingLayerCoordinator-&gt;addScrollingLayer(layer);
  #else
      UNUSED_PARAM(layer);
  #endif
</pre>
<center><a href="RenderLayerBacking.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayerCompositor.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2017 Apple Inc. All rights reseved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  */
 19 
 20 #pragma once
 21 
 22 #include &quot;DOMWindow.h&quot;
 23 #include &quot;JSDOMGlobalObject.h&quot;
 24 #include &quot;JSDOMWrapperCache.h&quot;
 25 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
 26 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 27 #include &lt;JavaScriptCore/JSArray.h&gt;
 28 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 29 #include &lt;JavaScriptCore/JSCellInlines.h&gt;
 30 #include &lt;JavaScriptCore/JSObjectInlines.h&gt;
 31 #include &lt;JavaScriptCore/Lookup.h&gt;
 32 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
 33 #include &lt;JavaScriptCore/SlotVisitorInlines.h&gt;
 34 #include &lt;JavaScriptCore/StructureInlines.h&gt;
 35 #include &lt;JavaScriptCore/WriteBarrier.h&gt;
 36 #include &lt;cstddef&gt;
 37 #include &lt;wtf/Forward.h&gt;
 38 #include &lt;wtf/GetPtr.h&gt;
 39 #include &lt;wtf/Vector.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 class DOMWrapperWorld;
 44 class Frame;
 45 class FetchResponse;
 46 class JSDOMWindow;
 47 class JSDOMWindowBasePrivate;
 48 class JSWindowProxy;
 49 
 50 class WEBCORE_EXPORT JSDOMWindowBase : public JSDOMGlobalObject {
 51     typedef JSDOMGlobalObject Base;
 52 protected:
 53     JSDOMWindowBase(JSC::VM&amp;, JSC::Structure*, RefPtr&lt;DOMWindow&gt;&amp;&amp;, JSWindowProxy*);
 54     void finishCreation(JSC::VM&amp;, JSWindowProxy*);
 55 
 56     static void destroy(JSCell*);
 57 
 58 public:
 59     void updateDocument();
 60 
 61     DOMWindow&amp; wrapped() const { return *m_wrapped; }
 62     ScriptExecutionContext* scriptExecutionContext() const;
 63 
 64     // Called just before removing this window from the JSWindowProxy.
 65     void willRemoveFromWindowProxy();
 66 
 67     DECLARE_INFO;
 68 
 69     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSValue prototype)
 70     {
 71         return JSC::Structure::create(vm, 0, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());
 72     }
 73 
 74     static const JSC::GlobalObjectMethodTable s_globalObjectMethodTable;
 75 
 76     static bool supportsRichSourceInfo(const JSC::JSGlobalObject*);
 77     static bool shouldInterruptScript(const JSC::JSGlobalObject*);
 78     static bool shouldInterruptScriptBeforeTimeout(const JSC::JSGlobalObject*);
 79     static JSC::RuntimeFlags javaScriptRuntimeFlags(const JSC::JSGlobalObject*);
 80     static void queueTaskToEventLoop(JSC::JSGlobalObject&amp;, Ref&lt;JSC::Microtask&gt;&amp;&amp;);
 81 
 82     void printErrorMessage(const String&amp;) const;
 83 
 84     JSWindowProxy* proxy() const;
 85 
 86     static void fireFrameClearedWatchpointsForWindow(DOMWindow*);
 87 
 88 protected:
 89     JSC::WatchpointSet m_windowCloseWatchpoints;
 90 
 91 private:
 92     using ResponseCallback = WTF::Function&lt;void(const char*, size_t)&gt;;
 93 
 94     static JSC::Identifier moduleLoaderResolve(JSC::JSGlobalObject*, JSC::ExecState*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSValue, JSC::JSValue);
 95     static JSC::JSInternalPromise* moduleLoaderFetch(JSC::JSGlobalObject*, JSC::ExecState*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSValue, JSC::JSValue);
 96     static JSC::JSValue moduleLoaderEvaluate(JSC::JSGlobalObject*, JSC::ExecState*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSValue, JSC::JSValue);
 97     static JSC::JSInternalPromise* moduleLoaderImportModule(JSC::JSGlobalObject*, JSC::ExecState*, JSC::JSModuleLoader*, JSC::JSString*, JSC::JSValue, const JSC::SourceOrigin&amp;);
 98     static JSC::JSObject* moduleLoaderCreateImportMetaProperties(JSC::JSGlobalObject*, JSC::ExecState*, JSC::JSModuleLoader*, JSC::JSValue, JSC::JSModuleRecord*, JSC::JSValue);
 99 
100 #if ENABLE(WEBASSEMBLY)
101     static void compileStreaming(JSC::JSGlobalObject*, JSC::ExecState*, JSC::JSPromiseDeferred*, JSC::JSValue);
102     static void instantiateStreaming(JSC::JSGlobalObject*, JSC::ExecState*, JSC::JSPromiseDeferred*, JSC::JSValue, JSC::JSObject*);
103 #endif
104 
105     RefPtr&lt;DOMWindow&gt; m_wrapped;
106     JSWindowProxy* m_proxy;
107 };
108 
109 WEBCORE_EXPORT JSC::JSValue toJS(JSC::ExecState*, DOMWindow&amp;);
110 // The following return a JSWindowProxy or jsNull()
111 // JSDOMGlobalObject* is ignored, accessing a window in any context will use that DOMWindow&#39;s prototype chain.
112 inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject*, DOMWindow&amp; window) { return toJS(state, window); }
113 inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, DOMWindow* window) { return window ? toJS(state, globalObject, *window) : JSC::jsNull(); }
114 inline JSC::JSValue toJS(JSC::ExecState* state, DOMWindow* window) { return window ? toJS(state, *window) : JSC::jsNull(); }
115 
116 // The following return a JSDOMWindow or nullptr.
117 JSDOMWindow* toJSDOMWindow(Frame&amp;, DOMWrapperWorld&amp;);
118 inline JSDOMWindow* toJSDOMWindow(Frame* frame, DOMWrapperWorld&amp; world) { return frame ? toJSDOMWindow(*frame, world) : nullptr; }
119 WEBCORE_EXPORT JSDOMWindow* toJSDOMWindow(JSC::VM&amp;, JSC::JSValue);
120 
121 // DOMWindow associated with global object of the &quot;most-recently-entered author function or script
122 // on the stack, or the author function or script that originally scheduled the currently-running callback.&quot;
123 // (&lt;https://html.spec.whatwg.org/multipage/webappapis.html#concept-incumbent-everything&gt;, 27 April 2017)
124 // FIXME: Make this work for an &quot;author function or script that originally scheduled the currently-running callback.&quot;
125 // See &lt;https://bugs.webkit.org/show_bug.cgi?id=163412&gt;.
126 DOMWindow&amp; incumbentDOMWindow(JSC::ExecState&amp;);
127 
128 DOMWindow&amp; activeDOMWindow(JSC::ExecState&amp;);
129 DOMWindow&amp; firstDOMWindow(JSC::ExecState&amp;);
130 
131 // FIXME: This should probably be removed in favor of one of the other DOMWindow accessors. It is intended
132 //        to provide the document specfied as the &#39;responsible document&#39; in the algorithm for document.open()
133 //        (https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#document-open-steps steps 4
134 //        and 23 and https://html.spec.whatwg.org/multipage/webappapis.html#responsible-document). It is only
135 //        used by JSDocument.
136 Document* responsibleDocument(JSC::ExecState&amp;);
137 
138 } // namespace WebCore
    </pre>
  </body>
</html>
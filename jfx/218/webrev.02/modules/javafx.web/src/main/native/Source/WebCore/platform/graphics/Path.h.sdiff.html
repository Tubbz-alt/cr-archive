<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Path.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PathTraversalState.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/Function.h&gt;
 35 #include &lt;wtf/Forward.h&gt;
 36 
 37 #if USE(CG)
 38 
 39 #include &lt;wtf/RetainPtr.h&gt;
 40 #include &lt;CoreGraphics/CGPath.h&gt;
 41 typedef struct CGPath PlatformPath;
 42 
 43 #elif USE(DIRECT2D)
 44 #include &quot;COMPtr.h&quot;
 45 
 46 interface ID2D1Geometry;
 47 interface ID2D1GeometryGroup;
 48 interface ID2D1PathGeometry;
 49 interface ID2D1GeometrySink;
 50 
 51 typedef ID2D1GeometryGroup PlatformPath;
 52 




 53 #elif USE(CAIRO)
 54 
 55 namespace WebCore {
 56 class CairoPath;
 57 }
 58 typedef WebCore::CairoPath PlatformPath;
 59 
 60 #elif USE(WINGDI)
 61 
 62 namespace WebCore {
 63 class PlatformPath;
 64 }
 65 typedef WebCore::PlatformPath PlatformPath;
 66 
 67 #elif PLATFORM(JAVA)
 68 #include &lt;wtf/RefPtr.h&gt;
 69 #include &quot;RQRef.h&quot;
 70 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPath;
 71 
 72 #else
 73 
 74 typedef void PlatformPath;
 75 
 76 #endif
 77 
 78 #if PLATFORM(JAVA)
 79 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPathPtr;
 80 #else
 81 typedef PlatformPath* PlatformPathPtr;
 82 #endif
 83 
 84 namespace WTF {
 85 class TextStream;
 86 }
 87 
 88 namespace WebCore {
 89 
<span class="line-modified"> 90     class AffineTransform;</span>
<span class="line-modified"> 91     class FloatPoint;</span>
<span class="line-modified"> 92     class FloatRoundedRect;</span>
<span class="line-modified"> 93     class FloatSize;</span>
<span class="line-modified"> 94     class GraphicsContext;</span>
<span class="line-modified"> 95     class PathTraversalState;</span>
<span class="line-modified"> 96     class RoundedRect;</span>
<span class="line-modified"> 97     class StrokeStyleApplier;</span>
<span class="line-modified"> 98 </span>
<span class="line-modified"> 99     enum PathElementType {</span>
<span class="line-modified">100         PathElementMoveToPoint, // The points member will contain 1 value.</span>
<span class="line-modified">101         PathElementAddLineToPoint, // The points member will contain 1 value.</span>
<span class="line-modified">102         PathElementAddQuadCurveToPoint, // The points member will contain 2 values.</span>
<span class="line-modified">103         PathElementAddCurveToPoint, // The points member will contain 3 values.</span>
<span class="line-modified">104         PathElementCloseSubpath // The points member will contain no values.</span>




105     };
106 
<span class="line-modified">107     // The points in the structure are the same as those that would be used with the</span>
<span class="line-modified">108     // add... method. For example, a line returns the endpoint, while a cubic returns</span>
<span class="line-modified">109     // two tangent points and the endpoint.</span>
<span class="line-removed">110     struct PathElement {</span>
<span class="line-removed">111         PathElementType type;</span>
<span class="line-removed">112         FloatPoint* points;</span>
<span class="line-removed">113     };</span>
114 
<span class="line-modified">115     using PathApplierFunction = WTF::Function&lt;void (const PathElement&amp;)&gt;;</span>
116 
<span class="line-modified">117     class Path {</span>
<span class="line-modified">118         WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">119     public:</span>
<span class="line-modified">120         WEBCORE_EXPORT Path();</span>
121 #if USE(CG)
<span class="line-modified">122         Path(RetainPtr&lt;CGMutablePathRef&gt;);</span>
123 #endif
<span class="line-modified">124         WEBCORE_EXPORT ~Path();</span>
<span class="line-modified">125 </span>
<span class="line-modified">126         WEBCORE_EXPORT Path(const Path&amp;);</span>
<span class="line-modified">127         WEBCORE_EXPORT Path(Path&amp;&amp;);</span>
<span class="line-modified">128         WEBCORE_EXPORT Path&amp; operator=(const Path&amp;);</span>
<span class="line-modified">129         WEBCORE_EXPORT Path&amp; operator=(Path&amp;&amp;);</span>
<span class="line-modified">130 </span>
<span class="line-modified">131         static Path polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp;);</span>
<span class="line-modified">132 </span>
<span class="line-modified">133         bool contains(const FloatPoint&amp;, WindRule = WindRule::NonZero) const;</span>
<span class="line-modified">134         bool strokeContains(StrokeStyleApplier*, const FloatPoint&amp;) const;</span>
<span class="line-modified">135         // fastBoundingRect() should equal or contain boundingRect(); boundingRect()</span>
<span class="line-modified">136         // should perfectly bound the points within the path.</span>
<span class="line-modified">137         FloatRect boundingRect() const;</span>
<span class="line-modified">138         WEBCORE_EXPORT FloatRect fastBoundingRect() const;</span>
<span class="line-modified">139         FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;</span>
<span class="line-modified">140 </span>
<span class="line-modified">141         float length() const;</span>
<span class="line-modified">142         PathTraversalState traversalStateAtLength(float length, bool&amp; success) const;</span>
<span class="line-modified">143         FloatPoint pointAtLength(float length, bool&amp; success) const;</span>
<span class="line-modified">144         float normalAngleAtLength(float length, bool&amp; success) const;</span>
<span class="line-modified">145 </span>
<span class="line-modified">146         WEBCORE_EXPORT void clear();</span>
<span class="line-modified">147         bool isNull() const { return !m_path; }</span>
<span class="line-modified">148         bool isEmpty() const;</span>
<span class="line-modified">149         // Gets the current point of the current path, which is conceptually the final point reached by the path so far.</span>
<span class="line-modified">150         // Note the Path can be empty (isEmpty() == true) and still have a current point.</span>
<span class="line-modified">151         bool hasCurrentPoint() const;</span>
<span class="line-modified">152         FloatPoint currentPoint() const;</span>
<span class="line-modified">153 </span>
<span class="line-modified">154         WEBCORE_EXPORT void moveTo(const FloatPoint&amp;);</span>
<span class="line-modified">155         WEBCORE_EXPORT void addLineTo(const FloatPoint&amp;);</span>
<span class="line-modified">156         WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint&amp; controlPoint, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">157         WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint&amp; controlPoint1, const FloatPoint&amp; controlPoint2, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">158         void addArcTo(const FloatPoint&amp;, const FloatPoint&amp;, float radius);</span>
<span class="line-modified">159         WEBCORE_EXPORT void closeSubpath();</span>
<span class="line-modified">160 </span>
<span class="line-modified">161         void addArc(const FloatPoint&amp;, float radius, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">162         void addRect(const FloatRect&amp;);</span>
<span class="line-modified">163         void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">164         void addEllipse(const FloatRect&amp;);</span>
<span class="line-modified">165 </span>
<span class="line-modified">166         enum RoundedRectStrategy {</span>
<span class="line-modified">167             PreferNativeRoundedRect,</span>
<span class="line-modified">168             PreferBezierRoundedRect</span>
<span class="line-modified">169         };</span>
<span class="line-modified">170 </span>
<span class="line-modified">171         WEBCORE_EXPORT void addRoundedRect(const FloatRect&amp;, const FloatSize&amp; roundingRadii, RoundedRectStrategy = PreferNativeRoundedRect);</span>
<span class="line-modified">172         WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&amp;, RoundedRectStrategy = PreferNativeRoundedRect);</span>
<span class="line-modified">173         void addRoundedRect(const RoundedRect&amp;);</span>
<span class="line-modified">174 </span>
<span class="line-modified">175         void addPath(const Path&amp;, const AffineTransform&amp;);</span>
<span class="line-modified">176 </span>
<span class="line-modified">177         void translate(const FloatSize&amp;);</span>
<span class="line-modified">178 </span>
<span class="line-modified">179         // To keep Path() cheap, it does not allocate a PlatformPath immediately</span>
<span class="line-removed">180         // meaning Path::platformPath() can return null.</span>
181 #if USE(DIRECT2D)
<span class="line-modified">182         PlatformPathPtr platformPath() const { return m_path.get(); }</span>

183 #else
<span class="line-modified">184         PlatformPathPtr platformPath() const { return m_path; }</span>
185 #endif
<span class="line-modified">186         // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.</span>
<span class="line-modified">187         WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();</span>
188 
<span class="line-modified">189         WEBCORE_EXPORT void apply(const PathApplierFunction&amp;) const;</span>
<span class="line-modified">190         void transform(const AffineTransform&amp;);</span>
191 
<span class="line-modified">192         static float circleControlPoint()</span>
<span class="line-modified">193         {</span>
<span class="line-modified">194             // Approximation of control point positions on a bezier to simulate a quarter of a circle.</span>
<span class="line-modified">195             // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3</span>
<span class="line-modified">196             return 0.447715;</span>
<span class="line-modified">197         }</span>
198 
<span class="line-modified">199         void addBeziersForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
200 
201 #if USE(CG) || USE(DIRECT2D)
<span class="line-modified">202         void platformAddPathForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
203 #endif
204 
205 #if USE(DIRECT2D)
<span class="line-modified">206         ID2D1GeometrySink* activePath() const { return m_activePath.get(); }</span>
<span class="line-modified">207         void appendGeometry(ID2D1Geometry*);</span>
<span class="line-modified">208         void createGeometryWithFillMode(WindRule, COMPtr&lt;ID2D1GeometryGroup&gt;&amp;) const;</span>
<span class="line-modified">209         void drawDidComplete();</span>
<span class="line-modified">210 </span>
<span class="line-modified">211         HRESULT initializePathState();</span>
<span class="line-removed">212         void openFigureAtCurrentPointIfNecessary();</span>
<span class="line-removed">213         void closeAnyOpenGeometries();</span>
214 #endif
215 
216 #ifndef NDEBUG
<span class="line-modified">217         void dump() const;</span>
218 #endif
219 
<span class="line-modified">220     private:</span>



221 #if USE(DIRECT2D)
<span class="line-modified">222         COMPtr&lt;ID2D1GeometryGroup&gt; m_path;</span>
<span class="line-modified">223         COMPtr&lt;ID2D1PathGeometry&gt; m_activePathGeometry;</span>
<span class="line-modified">224         COMPtr&lt;ID2D1GeometrySink&gt; m_activePath;</span>
<span class="line-modified">225         size_t m_openFigureCount { 0 };</span>
226 #else
<span class="line-modified">227         PlatformPathPtr m_path { nullptr };</span>
228 #endif
<span class="line-modified">229     };</span>
230 
231 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Path&amp;);
232 




































































































233 }
234 
235 #endif
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/Function.h&gt;
 35 #include &lt;wtf/Forward.h&gt;
 36 
 37 #if USE(CG)
 38 
 39 #include &lt;wtf/RetainPtr.h&gt;
 40 #include &lt;CoreGraphics/CGPath.h&gt;
 41 typedef struct CGPath PlatformPath;
 42 
 43 #elif USE(DIRECT2D)
 44 #include &quot;COMPtr.h&quot;
 45 
 46 interface ID2D1Geometry;
 47 interface ID2D1GeometryGroup;
 48 interface ID2D1PathGeometry;
 49 interface ID2D1GeometrySink;
 50 
 51 typedef ID2D1GeometryGroup PlatformPath;
 52 
<span class="line-added"> 53 namespace WebCore {</span>
<span class="line-added"> 54 class PlatformContextDirect2D;</span>
<span class="line-added"> 55 }</span>
<span class="line-added"> 56 </span>
 57 #elif USE(CAIRO)
 58 
 59 namespace WebCore {
 60 class CairoPath;
 61 }
 62 typedef WebCore::CairoPath PlatformPath;
 63 
 64 #elif USE(WINGDI)
 65 
 66 namespace WebCore {
 67 class PlatformPath;
 68 }
 69 typedef WebCore::PlatformPath PlatformPath;
 70 
 71 #elif PLATFORM(JAVA)
 72 #include &lt;wtf/RefPtr.h&gt;
 73 #include &quot;RQRef.h&quot;
 74 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPath;
 75 
 76 #else
 77 
 78 typedef void PlatformPath;
 79 
 80 #endif
 81 
 82 #if PLATFORM(JAVA)
 83 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPathPtr;
 84 #else
 85 typedef PlatformPath* PlatformPathPtr;
 86 #endif
 87 
 88 namespace WTF {
 89 class TextStream;
 90 }
 91 
 92 namespace WebCore {
 93 
<span class="line-modified"> 94 class AffineTransform;</span>
<span class="line-modified"> 95 class FloatPoint;</span>
<span class="line-modified"> 96 class FloatRoundedRect;</span>
<span class="line-modified"> 97 class FloatSize;</span>
<span class="line-modified"> 98 class GraphicsContext;</span>
<span class="line-modified"> 99 class PathTraversalState;</span>
<span class="line-modified">100 class RoundedRect;</span>
<span class="line-modified">101 class StrokeStyleApplier;</span>
<span class="line-modified">102 </span>
<span class="line-modified">103 // The points in the structure are the same as those that would be used with the</span>
<span class="line-modified">104 // add... method. For example, a line returns the endpoint, while a cubic returns</span>
<span class="line-modified">105 // two tangent points and the endpoint.</span>
<span class="line-modified">106 struct PathElement {</span>
<span class="line-modified">107     enum class Type : uint8_t {</span>
<span class="line-modified">108         MoveToPoint, // The points member will contain 1 value.</span>
<span class="line-added">109         AddLineToPoint, // The points member will contain 1 value.</span>
<span class="line-added">110         AddQuadCurveToPoint, // The points member will contain 2 values.</span>
<span class="line-added">111         AddCurveToPoint, // The points member will contain 3 values.</span>
<span class="line-added">112         CloseSubpath // The points member will contain no values.</span>
113     };
114 
<span class="line-modified">115     FloatPoint points[3];</span>
<span class="line-modified">116     Type type;</span>
<span class="line-modified">117 };</span>




118 
<span class="line-modified">119 using PathApplierFunction = WTF::Function&lt;void(const PathElement&amp;)&gt;;</span>
120 
<span class="line-modified">121 class Path {</span>
<span class="line-modified">122     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">123 public:</span>
<span class="line-modified">124     WEBCORE_EXPORT Path();</span>
125 #if USE(CG)
<span class="line-modified">126     Path(RetainPtr&lt;CGMutablePathRef&gt;);</span>
127 #endif
<span class="line-modified">128     WEBCORE_EXPORT ~Path();</span>
<span class="line-modified">129 </span>
<span class="line-modified">130     WEBCORE_EXPORT Path(const Path&amp;);</span>
<span class="line-modified">131     WEBCORE_EXPORT Path(Path&amp;&amp;);</span>
<span class="line-modified">132     WEBCORE_EXPORT Path&amp; operator=(const Path&amp;);</span>
<span class="line-modified">133     WEBCORE_EXPORT Path&amp; operator=(Path&amp;&amp;);</span>
<span class="line-modified">134 </span>
<span class="line-modified">135     static Path polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp;);</span>
<span class="line-modified">136 </span>
<span class="line-modified">137     bool contains(const FloatPoint&amp;, WindRule = WindRule::NonZero) const;</span>
<span class="line-modified">138     bool strokeContains(StrokeStyleApplier&amp;, const FloatPoint&amp;) const;</span>
<span class="line-modified">139     // fastBoundingRect() should equal or contain boundingRect(); boundingRect()</span>
<span class="line-modified">140     // should perfectly bound the points within the path.</span>
<span class="line-modified">141     FloatRect boundingRect() const;</span>
<span class="line-modified">142     WEBCORE_EXPORT FloatRect fastBoundingRect() const;</span>
<span class="line-modified">143     FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;</span>
<span class="line-modified">144 </span>
<span class="line-modified">145     float length() const;</span>
<span class="line-modified">146     PathTraversalState traversalStateAtLength(float length) const;</span>
<span class="line-modified">147     FloatPoint pointAtLength(float length) const;</span>
<span class="line-modified">148 </span>
<span class="line-modified">149     WEBCORE_EXPORT void clear();</span>
<span class="line-modified">150     bool isNull() const { return !m_path; }</span>
<span class="line-modified">151     bool isEmpty() const;</span>
<span class="line-modified">152     // Gets the current point of the current path, which is conceptually the final point reached by the path so far.</span>
<span class="line-modified">153     // Note the Path can be empty (isEmpty() == true) and still have a current point.</span>
<span class="line-modified">154     bool hasCurrentPoint() const;</span>
<span class="line-modified">155     FloatPoint currentPoint() const;</span>
<span class="line-modified">156 </span>
<span class="line-modified">157     WEBCORE_EXPORT void moveTo(const FloatPoint&amp;);</span>
<span class="line-modified">158     WEBCORE_EXPORT void addLineTo(const FloatPoint&amp;);</span>
<span class="line-modified">159     WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint&amp; controlPoint, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">160     WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint&amp; controlPoint1, const FloatPoint&amp; controlPoint2, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">161     void addArcTo(const FloatPoint&amp;, const FloatPoint&amp;, float radius);</span>
<span class="line-modified">162     WEBCORE_EXPORT void closeSubpath();</span>
<span class="line-modified">163 </span>
<span class="line-modified">164     void addArc(const FloatPoint&amp;, float radius, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">165     void addRect(const FloatRect&amp;);</span>
<span class="line-modified">166     void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">167     void addEllipse(const FloatRect&amp;);</span>
<span class="line-modified">168 </span>
<span class="line-modified">169     enum class RoundedRectStrategy : uint8_t {</span>
<span class="line-modified">170         PreferNative,</span>
<span class="line-modified">171         PreferBezier</span>
<span class="line-modified">172     };</span>
<span class="line-modified">173 </span>
<span class="line-modified">174     WEBCORE_EXPORT void addRoundedRect(const FloatRect&amp;, const FloatSize&amp; roundingRadii, RoundedRectStrategy = RoundedRectStrategy::PreferNative);</span>
<span class="line-modified">175     WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&amp;, RoundedRectStrategy = RoundedRectStrategy::PreferNative);</span>
<span class="line-modified">176     void addRoundedRect(const RoundedRect&amp;);</span>
<span class="line-modified">177 </span>
<span class="line-modified">178     void addPath(const Path&amp;, const AffineTransform&amp;);</span>
<span class="line-modified">179 </span>
<span class="line-modified">180     void translate(const FloatSize&amp;);</span>
<span class="line-modified">181 </span>
<span class="line-modified">182     // To keep Path() cheap, it does not allocate a PlatformPath immediately</span>
<span class="line-modified">183     // meaning Path::platformPath() can return null.</span>

184 #if USE(DIRECT2D)
<span class="line-modified">185     FloatRect fastBoundingRectForStroke(const PlatformContextDirect2D&amp;) const;</span>
<span class="line-added">186     PlatformPathPtr platformPath() const { return m_path.get(); }</span>
187 #else
<span class="line-modified">188     PlatformPathPtr platformPath() const { return m_path; }</span>
189 #endif
<span class="line-modified">190     // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.</span>
<span class="line-modified">191     WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();</span>
192 
<span class="line-modified">193     WEBCORE_EXPORT void apply(const PathApplierFunction&amp;) const;</span>
<span class="line-modified">194     void transform(const AffineTransform&amp;);</span>
195 
<span class="line-modified">196     static float circleControlPoint()</span>
<span class="line-modified">197     {</span>
<span class="line-modified">198         // Approximation of control point positions on a bezier to simulate a quarter of a circle.</span>
<span class="line-modified">199         // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3</span>
<span class="line-modified">200         return 0.447715;</span>
<span class="line-modified">201     }</span>
202 
<span class="line-modified">203     void addBeziersForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
204 
205 #if USE(CG) || USE(DIRECT2D)
<span class="line-modified">206     void platformAddPathForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
207 #endif
208 
209 #if USE(DIRECT2D)
<span class="line-modified">210     void appendGeometry(ID2D1Geometry*);</span>
<span class="line-modified">211     void createGeometryWithFillMode(WindRule, COMPtr&lt;ID2D1GeometryGroup&gt;&amp;) const;</span>
<span class="line-modified">212 </span>
<span class="line-modified">213     void openFigureAtCurrentPointIfNecessary();</span>
<span class="line-modified">214     void closeAnyOpenGeometries(unsigned figureEndStyle) const;</span>
<span class="line-modified">215     void clearGeometries();</span>


216 #endif
217 
218 #ifndef NDEBUG
<span class="line-modified">219     void dump() const;</span>
220 #endif
221 
<span class="line-modified">222     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">223     template&lt;class Decoder&gt; static Optional&lt;Path&gt; decode(Decoder&amp;);</span>
<span class="line-added">224 </span>
<span class="line-added">225 private:</span>
226 #if USE(DIRECT2D)
<span class="line-modified">227     Vector&lt;ID2D1Geometry*&gt; m_geometries;</span>
<span class="line-modified">228     COMPtr&lt;ID2D1GeometryGroup&gt; m_path;</span>
<span class="line-modified">229     mutable COMPtr&lt;ID2D1GeometrySink&gt; m_activePath;</span>
<span class="line-modified">230     mutable bool m_figureIsOpened { false };</span>
231 #else
<span class="line-modified">232     PlatformPathPtr m_path { nullptr };</span>
233 #endif
<span class="line-modified">234 };</span>
235 
236 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Path&amp;);
237 
<span class="line-added">238 template&lt;class Encoder&gt; void Path::encode(Encoder&amp; encoder) const</span>
<span class="line-added">239 {</span>
<span class="line-added">240     uint64_t numPoints = 0;</span>
<span class="line-added">241     apply([&amp;numPoints](const PathElement&amp;) {</span>
<span class="line-added">242         ++numPoints;</span>
<span class="line-added">243     });</span>
<span class="line-added">244 </span>
<span class="line-added">245     encoder &lt;&lt; numPoints;</span>
<span class="line-added">246 </span>
<span class="line-added">247     apply([&amp;](auto&amp; element) {</span>
<span class="line-added">248         encoder.encodeEnum(element.type);</span>
<span class="line-added">249 </span>
<span class="line-added">250         switch (element.type) {</span>
<span class="line-added">251         case PathElement::Type::MoveToPoint:</span>
<span class="line-added">252             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">253             break;</span>
<span class="line-added">254         case PathElement::Type::AddLineToPoint:</span>
<span class="line-added">255             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">256             break;</span>
<span class="line-added">257         case PathElement::Type::AddQuadCurveToPoint:</span>
<span class="line-added">258             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">259             encoder &lt;&lt; element.points[1];</span>
<span class="line-added">260             break;</span>
<span class="line-added">261         case PathElement::Type::AddCurveToPoint:</span>
<span class="line-added">262             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">263             encoder &lt;&lt; element.points[1];</span>
<span class="line-added">264             encoder &lt;&lt; element.points[2];</span>
<span class="line-added">265             break;</span>
<span class="line-added">266         case PathElement::Type::CloseSubpath:</span>
<span class="line-added">267             break;</span>
<span class="line-added">268         }</span>
<span class="line-added">269     });</span>
<span class="line-added">270 }</span>
<span class="line-added">271 </span>
<span class="line-added">272 template&lt;class Decoder&gt; Optional&lt;Path&gt; Path::decode(Decoder&amp; decoder)</span>
<span class="line-added">273 {</span>
<span class="line-added">274     Path path;</span>
<span class="line-added">275     uint64_t numPoints;</span>
<span class="line-added">276     if (!decoder.decode(numPoints))</span>
<span class="line-added">277         return WTF::nullopt;</span>
<span class="line-added">278 </span>
<span class="line-added">279     path.clear();</span>
<span class="line-added">280 </span>
<span class="line-added">281     for (uint64_t i = 0; i &lt; numPoints; ++i) {</span>
<span class="line-added">282         PathElement::Type elementType;</span>
<span class="line-added">283         if (!decoder.decodeEnum(elementType))</span>
<span class="line-added">284             return WTF::nullopt;</span>
<span class="line-added">285 </span>
<span class="line-added">286         switch (elementType) {</span>
<span class="line-added">287         case PathElement::Type::MoveToPoint: {</span>
<span class="line-added">288             FloatPoint point;</span>
<span class="line-added">289             if (!decoder.decode(point))</span>
<span class="line-added">290                 return WTF::nullopt;</span>
<span class="line-added">291             path.moveTo(point);</span>
<span class="line-added">292             break;</span>
<span class="line-added">293         }</span>
<span class="line-added">294         case PathElement::Type::AddLineToPoint: {</span>
<span class="line-added">295             FloatPoint point;</span>
<span class="line-added">296             if (!decoder.decode(point))</span>
<span class="line-added">297                 return WTF::nullopt;</span>
<span class="line-added">298             path.addLineTo(point);</span>
<span class="line-added">299             break;</span>
<span class="line-added">300         }</span>
<span class="line-added">301         case PathElement::Type::AddQuadCurveToPoint: {</span>
<span class="line-added">302             FloatPoint controlPoint;</span>
<span class="line-added">303             if (!decoder.decode(controlPoint))</span>
<span class="line-added">304                 return WTF::nullopt;</span>
<span class="line-added">305 </span>
<span class="line-added">306             FloatPoint endPoint;</span>
<span class="line-added">307             if (!decoder.decode(endPoint))</span>
<span class="line-added">308                 return WTF::nullopt;</span>
<span class="line-added">309 </span>
<span class="line-added">310             path.addQuadCurveTo(controlPoint, endPoint);</span>
<span class="line-added">311             break;</span>
<span class="line-added">312         }</span>
<span class="line-added">313         case PathElement::Type::AddCurveToPoint: {</span>
<span class="line-added">314             FloatPoint controlPoint1;</span>
<span class="line-added">315             if (!decoder.decode(controlPoint1))</span>
<span class="line-added">316                 return WTF::nullopt;</span>
<span class="line-added">317 </span>
<span class="line-added">318             FloatPoint controlPoint2;</span>
<span class="line-added">319             if (!decoder.decode(controlPoint2))</span>
<span class="line-added">320                 return WTF::nullopt;</span>
<span class="line-added">321 </span>
<span class="line-added">322             FloatPoint endPoint;</span>
<span class="line-added">323             if (!decoder.decode(endPoint))</span>
<span class="line-added">324                 return WTF::nullopt;</span>
<span class="line-added">325 </span>
<span class="line-added">326             path.addBezierCurveTo(controlPoint1, controlPoint2, endPoint);</span>
<span class="line-added">327             break;</span>
<span class="line-added">328         }</span>
<span class="line-added">329         case PathElement::Type::CloseSubpath:</span>
<span class="line-added">330             path.closeSubpath();</span>
<span class="line-added">331             break;</span>
<span class="line-added">332         }</span>
<span class="line-added">333     }</span>
<span class="line-added">334 </span>
<span class="line-added">335     return path;</span>
<span class="line-added">336 }</span>
<span class="line-added">337 </span>
338 }
339 
340 #endif
</pre>
</td>
</tr>
</table>
<center><a href="Path.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PathTraversalState.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
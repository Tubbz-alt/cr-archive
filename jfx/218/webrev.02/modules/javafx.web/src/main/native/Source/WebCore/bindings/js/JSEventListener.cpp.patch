diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp
@@ -128,37 +128,42 @@
         ScriptController& script = window->wrapped().frame()->script();
         if (!script.canExecuteScripts(AboutToExecuteScript) || script.isPaused())
             return;
     }
 
-    ExecState* exec = globalObject->globalExec();
+    JSGlobalObject* lexicalGlobalObject = globalObject;
 
     JSValue handleEventFunction = jsFunction;
 
     CallData callData;
     CallType callType = getCallData(vm, handleEventFunction, callData);
 
-    // If jsFunction is not actually a function, see if it implements the EventListener interface and use that
+    // If jsFunction is not actually a function and this is an EventListener, see if it implements callback interface.
     if (callType == CallType::None) {
-        handleEventFunction = jsFunction->get(exec, Identifier::fromString(vm, "handleEvent"));
+        if (m_isAttribute)
+            return;
+
+        handleEventFunction = jsFunction->get(lexicalGlobalObject, Identifier::fromString(vm, "handleEvent"));
         if (UNLIKELY(scope.exception())) {
             auto* exception = scope.exception();
             scope.clearException();
             event.target()->uncaughtExceptionInEventHandler();
-            reportException(exec, exception);
+            reportException(lexicalGlobalObject, exception);
             return;
         }
         callType = getCallData(vm, handleEventFunction, callData);
+        if (callType == CallType::None) {
+            event.target()->uncaughtExceptionInEventHandler();
+            reportException(lexicalGlobalObject, createTypeError(lexicalGlobalObject, "'handleEvent' property of event listener should be callable"_s));
+            return;
+        }
     }
 
-    if (callType == CallType::None)
-        return;
-
     Ref<JSEventListener> protectedThis(*this);
 
     MarkedArgumentBuffer args;
-    args.append(toJS(exec, globalObject, &event));
+    args.append(toJS(lexicalGlobalObject, globalObject, &event));
     ASSERT(!args.hasOverflowed());
 
     Event* savedEvent = globalObject->currentEvent();
 
     // window.event should not be set when the target is inside a shadow tree, as per the DOM specification.
@@ -166,17 +171,17 @@
     if (!isTargetInsideShadowTree)
         globalObject->setCurrentEvent(&event);
 
     VMEntryScope entryScope(vm, vm.entryScope ? vm.entryScope->globalObject() : globalObject);
 
-    InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionCall(&scriptExecutionContext, callType, callData);
+    JSExecState::instrumentFunctionCall(&scriptExecutionContext, callType, callData);
 
-    JSValue thisValue = handleEventFunction == jsFunction ? toJS(exec, globalObject, event.currentTarget()) : jsFunction;
+    JSValue thisValue = handleEventFunction == jsFunction ? toJS(lexicalGlobalObject, globalObject, event.currentTarget()) : jsFunction;
     NakedPtr<JSC::Exception> exception;
-    JSValue retval = JSExecState::profiledCall(exec, JSC::ProfilingReason::Other, handleEventFunction, callType, callData, thisValue, args, exception);
+    JSValue retval = JSExecState::profiledCall(lexicalGlobalObject, JSC::ProfilingReason::Other, handleEventFunction, callType, callData, thisValue, args, exception);
 
-    InspectorInstrumentation::didCallFunction(cookie, &scriptExecutionContext);
+    InspectorInstrumentation::didCallFunction(&scriptExecutionContext);
 
     globalObject->setCurrentEvent(savedEvent);
 
     if (is<WorkerGlobalScope>(scriptExecutionContext)) {
         auto& scriptController = *downcast<WorkerGlobalScope>(scriptExecutionContext).script();
@@ -185,11 +190,11 @@
             scriptController.forbidExecution();
     }
 
     if (exception) {
         event.target()->uncaughtExceptionInEventHandler();
-        reportException(exec, exception);
+        reportException(lexicalGlobalObject, exception);
         return;
     }
 
     if (!m_isAttribute) {
         // This is an EventListener and there is therefore no need for any return value handling.
@@ -199,11 +204,11 @@
     // Do return value handling for event handlers (https://html.spec.whatwg.org/#the-event-handler-processing-algorithm).
 
     if (event.type() == eventNames().beforeunloadEvent) {
         // This is a OnBeforeUnloadEventHandler, and therefore the return value must be coerced into a String.
         if (is<BeforeUnloadEvent>(event))
-            handleBeforeUnloadEventReturnValue(downcast<BeforeUnloadEvent>(event), convert<IDLNullable<IDLDOMString>>(*exec, retval));
+            handleBeforeUnloadEventReturnValue(downcast<BeforeUnloadEvent>(event), convert<IDLNullable<IDLDOMString>>(*lexicalGlobalObject, retval));
         return;
     }
 
     if (retval.isFalse())
         event.preventDefault();
@@ -215,10 +220,25 @@
         return false;
     auto& other = downcast<JSEventListener>(listener);
     return m_jsFunction == other.m_jsFunction && m_isAttribute == other.m_isAttribute;
 }
 
+String JSEventListener::functionName() const
+{
+    if (!m_wrapper || !m_jsFunction)
+        return { };
+
+    auto& vm = isolatedWorld().vm();
+    JSC::JSLockHolder lock(vm);
+
+    auto* handlerFunction = JSC::jsDynamicCast<JSC::JSFunction*>(vm, m_jsFunction.get());
+    if (!handlerFunction)
+        return { };
+
+    return handlerFunction->name(vm);
+}
+
 static inline JSC::JSValue eventHandlerAttribute(EventListener* abstractListener, ScriptExecutionContext& context)
 {
     if (!is<JSEventListener>(abstractListener))
         return jsNull();
 
@@ -227,70 +247,70 @@
         return jsNull();
 
     return function;
 }
 
-static inline RefPtr<JSEventListener> createEventListenerForEventHandlerAttribute(JSC::ExecState& state, JSC::JSValue listener, JSC::JSObject& wrapper)
+static inline RefPtr<JSEventListener> createEventListenerForEventHandlerAttribute(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSValue listener, JSC::JSObject& wrapper)
 {
     if (!listener.isObject())
         return nullptr;
-    return JSEventListener::create(asObject(listener), &wrapper, true, currentWorld(state));
+    return JSEventListener::create(asObject(listener), &wrapper, true, currentWorld(lexicalGlobalObject));
 }
 
 JSC::JSValue eventHandlerAttribute(EventTarget& target, const AtomString& eventType, DOMWrapperWorld& isolatedWorld)
 {
     return eventHandlerAttribute(target.attributeEventListener(eventType, isolatedWorld), *target.scriptExecutionContext());
 }
 
-void setEventHandlerAttribute(JSC::ExecState& state, JSC::JSObject& wrapper, EventTarget& target, const AtomString& eventType, JSC::JSValue value)
+void setEventHandlerAttribute(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSObject& wrapper, EventTarget& target, const AtomString& eventType, JSC::JSValue value)
 {
-    target.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, wrapper), currentWorld(state));
+    target.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, wrapper), currentWorld(lexicalGlobalObject));
 }
 
 JSC::JSValue windowEventHandlerAttribute(HTMLElement& element, const AtomString& eventType, DOMWrapperWorld& isolatedWorld)
 {
     auto& document = element.document();
     return eventHandlerAttribute(document.getWindowAttributeEventListener(eventType, isolatedWorld), document);
 }
 
-void setWindowEventHandlerAttribute(JSC::ExecState& state, JSC::JSObject& wrapper, HTMLElement& element, const AtomString& eventType, JSC::JSValue value)
+void setWindowEventHandlerAttribute(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSObject& wrapper, HTMLElement& element, const AtomString& eventType, JSC::JSValue value)
 {
     ASSERT(wrapper.globalObject());
-    element.document().setWindowAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, *wrapper.globalObject()), currentWorld(state));
+    element.document().setWindowAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *wrapper.globalObject()), currentWorld(lexicalGlobalObject));
 }
 
 JSC::JSValue windowEventHandlerAttribute(DOMWindow& window, const AtomString& eventType, DOMWrapperWorld& isolatedWorld)
 {
     return eventHandlerAttribute(window, eventType, isolatedWorld);
 }
 
-void setWindowEventHandlerAttribute(JSC::ExecState& state, JSC::JSObject& wrapper, DOMWindow& window, const AtomString& eventType, JSC::JSValue value)
+void setWindowEventHandlerAttribute(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSObject& wrapper, DOMWindow& window, const AtomString& eventType, JSC::JSValue value)
 {
-    setEventHandlerAttribute(state, wrapper, window, eventType, value);
+    setEventHandlerAttribute(lexicalGlobalObject, wrapper, window, eventType, value);
 }
 
 JSC::JSValue documentEventHandlerAttribute(HTMLElement& element, const AtomString& eventType, DOMWrapperWorld& isolatedWorld)
 {
     auto& document = element.document();
     return eventHandlerAttribute(document.attributeEventListener(eventType, isolatedWorld), document);
 }
 
-void setDocumentEventHandlerAttribute(JSC::ExecState& state, JSC::JSObject& wrapper, HTMLElement& element, const AtomString& eventType, JSC::JSValue value)
+void setDocumentEventHandlerAttribute(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSObject& wrapper, HTMLElement& element, const AtomString& eventType, JSC::JSValue value)
 {
     ASSERT(wrapper.globalObject());
     auto& document = element.document();
-    auto* documentWrapper = JSC::jsCast<JSDocument*>(toJS(&state, JSC::jsCast<JSDOMGlobalObject*>(wrapper.globalObject()), document));
+    auto* documentWrapper = JSC::jsCast<JSDocument*>(toJS(&lexicalGlobalObject, JSC::jsCast<JSDOMGlobalObject*>(wrapper.globalObject()), document));
     ASSERT(documentWrapper);
-    document.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, *documentWrapper), currentWorld(state));
+    document.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *documentWrapper), currentWorld(lexicalGlobalObject));
 }
 
 JSC::JSValue documentEventHandlerAttribute(Document& document, const AtomString& eventType, DOMWrapperWorld& isolatedWorld)
 {
     return eventHandlerAttribute(document, eventType, isolatedWorld);
 }
 
-void setDocumentEventHandlerAttribute(JSC::ExecState& state, JSC::JSObject& wrapper, Document& document, const AtomString& eventType, JSC::JSValue value)
+void setDocumentEventHandlerAttribute(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSObject& wrapper, Document& document, const AtomString& eventType, JSC::JSValue value)
 {
-    setEventHandlerAttribute(state, wrapper, document, eventType, value);
+    setEventHandlerAttribute(lexicalGlobalObject, wrapper, document, eventType, value);
 }
 
 } // namespace WebCore

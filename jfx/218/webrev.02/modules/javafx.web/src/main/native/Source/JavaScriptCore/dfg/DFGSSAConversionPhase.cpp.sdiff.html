<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGRegisterBank.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSSALoweringPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGBlockInsertionSet.h&quot;
 33 #include &quot;DFGGraph.h&quot;
 34 #include &quot;DFGInsertionSet.h&quot;
 35 #include &quot;DFGPhase.h&quot;
 36 #include &quot;DFGSSACalculator.h&quot;
 37 #include &quot;DFGVariableAccessDataDump.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 
 40 #undef RELEASE_ASSERT
 41 #define RELEASE_ASSERT(assertion) do { \
 42     if (!(assertion)) { \
 43         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
 44         CRASH(); \
 45     } \
 46 } while (0)
 47 
 48 namespace JSC { namespace DFG {
 49 
 50 class SSAConversionPhase : public Phase {
<span class="line-modified"> 51     static const bool verbose = false;</span>
 52 
 53 public:
 54     SSAConversionPhase(Graph&amp; graph)
 55         : Phase(graph, &quot;SSA conversion&quot;)
 56         , m_insertionSet(graph)
 57     {
 58     }
 59 
 60     bool run()
 61     {
 62         RELEASE_ASSERT(m_graph.m_form == ThreadedCPS);
 63         RELEASE_ASSERT(!m_graph.m_isInSSAConversion);
 64         m_graph.m_isInSSAConversion = true;
 65 
 66         m_graph.clearReplacements();
 67         m_graph.clearCPSCFGData();
 68 
 69         HashMap&lt;unsigned, BasicBlock*, WTF::IntHash&lt;unsigned&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; entrypointIndexToArgumentsBlock;
 70 
 71         m_graph.m_numberOfEntrypoints = m_graph.m_roots.size();
</pre>
<hr />
<pre>
 80                 0, SpecNone, InitializeEntrypointArguments, origin, OpInfo(entrypointIndex));
 81             m_insertionSet.insertNode(
 82                 0, SpecNone, ExitOK, origin);
 83             m_insertionSet.execute(oldRoot);
 84         }
 85 
 86         if (m_graph.m_numberOfEntrypoints &gt; 1) {
 87             BlockInsertionSet blockInsertionSet(m_graph);
 88             BasicBlock* newRoot = blockInsertionSet.insert(0, 1.0f);
 89 
 90             EntrySwitchData* entrySwitchData = m_graph.m_entrySwitchData.add();
 91             for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_graph.m_numberOfEntrypoints; ++entrypointIndex) {
 92                 BasicBlock* oldRoot = m_graph.m_roots[entrypointIndex];
 93                 entrySwitchData-&gt;cases.append(oldRoot);
 94 
 95                 ASSERT(oldRoot-&gt;predecessors.isEmpty());
 96                 oldRoot-&gt;predecessors.append(newRoot);
 97 
 98                 if (oldRoot-&gt;isCatchEntrypoint) {
 99                     ASSERT(!!entrypointIndex);
<span class="line-modified">100                     m_graph.m_entrypointIndexToCatchBytecodeOffset.add(entrypointIndex, oldRoot-&gt;bytecodeBegin);</span>
101                 }
102             }
103 
104             RELEASE_ASSERT(entrySwitchData-&gt;cases[0] == m_graph.block(0)); // We strongly assume the normal call entrypoint is the first item in the list.
105 
106             const bool exitOK = false;
<span class="line-modified">107             NodeOrigin origin { CodeOrigin(0), CodeOrigin(0), exitOK };</span>
108             newRoot-&gt;appendNode(
109                 m_graph, SpecNone, EntrySwitch, origin, OpInfo(entrySwitchData));
110 
111             m_graph.m_roots.clear();
112             m_graph.m_roots.append(newRoot);
113 
114             blockInsertionSet.execute();
115         }
116 
117         SSACalculator calculator(m_graph);
118 
119         m_graph.ensureSSADominators();
120 
121         if (verbose) {
122             dataLog(&quot;Graph before SSA transformation:\n&quot;);
123             m_graph.dump();
124         }
125 
126         // Create a SSACalculator::Variable for every root VariableAccessData.
127         for (VariableAccessData&amp; variable : m_graph.m_variableAccessData) {
</pre>
<hr />
<pre>
141             if (!block)
142                 continue;
143 
144             // Must process the block in forward direction because we want to see the last
145             // assignment for every local.
146             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
147                 Node* node = block-&gt;at(nodeIndex);
148                 if (node-&gt;op() != SetLocal &amp;&amp; node-&gt;op() != SetArgumentDefinitely)
149                     continue;
150 
151                 VariableAccessData* variable = node-&gt;variableAccessData();
152 
153                 Node* childNode;
154                 if (node-&gt;op() == SetLocal)
155                     childNode = node-&gt;child1().node();
156                 else {
157                     ASSERT(node-&gt;op() == SetArgumentDefinitely);
158                     childNode = m_insertionSet.insertNode(
159                         nodeIndex, node-&gt;variableAccessData()-&gt;prediction(),
160                         GetStack, node-&gt;origin,
<span class="line-modified">161                         OpInfo(m_graph.m_stackAccessData.add(variable-&gt;local(), variable-&gt;flushFormat())));</span>
<span class="line-modified">162                     if (!ASSERT_DISABLED)</span>
163                         m_argumentGetters.add(childNode);
164                     m_argumentMapping.add(node, childNode);
165                 }
166 
167                 calculator.newDef(
168                     m_ssaVariableForVariable.get(variable), block, childNode);
169             }
170 
171             m_insertionSet.execute(block);
172         }
173 
174         // Decide where Phis are to be inserted. This creates the Phi&#39;s but doesn&#39;t insert them
175         // yet. We will later know where to insert based on where SSACalculator tells us to.
176         calculator.computePhis(
177             [&amp;] (SSACalculator::Variable* ssaVariable, BasicBlock* block) -&gt; Node* {
178                 VariableAccessData* variable = m_variableForSSAIndex[ssaVariable-&gt;index()];
179 
180                 // Prune by liveness. This doesn&#39;t buy us much other than compile times.
<span class="line-modified">181                 Node* headNode = block-&gt;variablesAtHead.operand(variable-&gt;local());</span>
182                 if (!headNode)
183                     return nullptr;
184 
185                 // There is the possibiltiy of &quot;rebirths&quot;. The SSA calculator will already prune
186                 // rebirths for the same VariableAccessData. But it will not be able to prune
187                 // rebirths that arose from the same local variable number but a different
188                 // VariableAccessData. We do that pruning here.
189                 //
190                 // Here&#39;s an example of a rebirth that this would catch:
191                 //
192                 //     var x;
193                 //     if (foo) {
194                 //         if (bar) {
195                 //             x = 42;
196                 //         } else {
197                 //             x = 43;
198                 //         }
199                 //         print(x);
200                 //         x = 44;
201                 //     } else {
</pre>
<hr />
<pre>
283                         dataLog(&quot;Considering live variable &quot;, VariableAccessDataDump(m_graph, variable), &quot; at head of block &quot;, *block, &quot;\n&quot;);
284 
285                     SSACalculator::Variable* ssaVariable = m_ssaVariableForVariable.get(variable);
286                     SSACalculator::Def* def = calculator.reachingDefAtHead(block, ssaVariable);
287                     if (!def) {
288                         // If we are required to insert a Phi, then we won&#39;t have a reaching def
289                         // at head.
290                         continue;
291                     }
292 
293                     Node* node = def-&gt;value();
294                     if (node-&gt;replacement()) {
295                         // This will occur when a SetLocal had a GetLocal as its source. The
296                         // GetLocal would get replaced with an actual SSA value by the time we get
297                         // here. Note that the SSA value with which the GetLocal got replaced
298                         // would not in turn have a replacement.
299                         node = node-&gt;replacement();
300                         ASSERT(!node-&gt;replacement());
301                     }
302                     if (verbose)
<span class="line-modified">303                         dataLog(&quot;Mapping: &quot;, VirtualRegister(valueForOperand.operandForIndex(i)), &quot; -&gt; &quot;, node, &quot;\n&quot;);</span>
304                     valueForOperand[i] = node;
305                 }
306             }
307 
308             // Insert Phis by asking the calculator what phis there are in this block. Also update
309             // valueForOperand with those Phis. For Phis associated with variables that are not
310             // flushed, we also insert a MovHint.
311             size_t phiInsertionPoint = 0;
312             for (SSACalculator::Def* phiDef : calculator.phisForBlock(block)) {
313                 VariableAccessData* variable = m_variableForSSAIndex[phiDef-&gt;variable()-&gt;index()];
314 
315                 m_insertionSet.insert(phiInsertionPoint, phiDef-&gt;value());
<span class="line-modified">316                 valueForOperand.operand(variable-&gt;local()) = phiDef-&gt;value();</span>
317 
318                 m_insertionSet.insertNode(
319                     phiInsertionPoint, SpecNone, MovHint, block-&gt;at(0)-&gt;origin.withInvalidExit(),
<span class="line-modified">320                     OpInfo(variable-&gt;local().offset()), phiDef-&gt;value()-&gt;defaultEdge());</span>
321             }
322 
323             if (block-&gt;at(0)-&gt;origin.exitOK)
324                 m_insertionSet.insertNode(phiInsertionPoint, SpecNone, ExitOK, block-&gt;at(0)-&gt;origin);
325 
326             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
327                 Node* node = block-&gt;at(nodeIndex);
328 
329                 if (verbose) {
330                     dataLog(&quot;Processing node &quot;, node, &quot;:\n&quot;);
331                     m_graph.dump(WTF::dataFile(), &quot;    &quot;, node);
332                 }
333 
334                 m_graph.performSubstitution(node);
335 
336                 switch (node-&gt;op()) {
337                 case MovHint: {
338                     m_insertionSet.insertNode(
339                         nodeIndex, SpecNone, KillStack, node-&gt;origin,
<span class="line-modified">340                         OpInfo(node-&gt;unlinkedLocal().offset()));</span>
341                     node-&gt;origin.exitOK = false; // KillStack clobbers exit.
342                     break;
343                 }
344 
345                 case SetLocal: {
346                     VariableAccessData* variable = node-&gt;variableAccessData();
347                     Node* child = node-&gt;child1().node();
348 
349                     if (!!(node-&gt;flags() &amp; NodeIsFlushed)) {
350                         node-&gt;convertToPutStack(
351                             m_graph.m_stackAccessData.add(
<span class="line-modified">352                                 variable-&gt;local(), variable-&gt;flushFormat()));</span>
353                     } else
354                         node-&gt;remove(m_graph);
355 
356                     if (verbose)
<span class="line-modified">357                         dataLog(&quot;Mapping: &quot;, variable-&gt;local(), &quot; -&gt; &quot;, child, &quot;\n&quot;);</span>
<span class="line-modified">358                     valueForOperand.operand(variable-&gt;local()) = child;</span>
359                     break;
360                 }
361 
362                 case GetStack: {
363                     ASSERT(m_argumentGetters.contains(node));
<span class="line-modified">364                     valueForOperand.operand(node-&gt;stackAccessData()-&gt;local) = node;</span>
365                     break;
366                 }
367 
368                 case GetLocal: {
369                     VariableAccessData* variable = node-&gt;variableAccessData();
370                     node-&gt;children.reset();
371 
372                     node-&gt;remove(m_graph);
373                     if (verbose)
<span class="line-modified">374                         dataLog(&quot;Replacing node &quot;, node, &quot; with &quot;, valueForOperand.operand(variable-&gt;local()), &quot;\n&quot;);</span>
<span class="line-modified">375                     node-&gt;setReplacement(valueForOperand.operand(variable-&gt;local()));</span>
376                     break;
377                 }
378 
379                 case Flush: {
380                     node-&gt;children.reset();
381                     node-&gt;remove(m_graph);
382                     break;
383                 }
384 
385                 case PhantomLocal: {
386                     ASSERT(node-&gt;child1().useKind() == UntypedUse);
387                     VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">388                     node-&gt;child1() = valueForOperand.operand(variable-&gt;local())-&gt;defaultEdge();</span>
389                     node-&gt;remove(m_graph);
390                     break;
391                 }
392 
393                 case SetArgumentDefinitely: {
394                     node-&gt;remove(m_graph);
395                     break;
396                 }
397 
398                 case SetArgumentMaybe: {
399                     node-&gt;remove(m_graph);
400                     break;
401                 }
402 
403                 default:
404                     break;
405                 }
406             }
407 
408             // We want to insert Upsilons just before the end of the block. On the surface this
409             // seems dangerous because the Upsilon will have a checking UseKind. But, we will not
410             // actually be performing the check at the point of the Upsilon; the check will
411             // already have been performed at the point where the original SetLocal was.
412             NodeAndIndex terminal = block-&gt;findTerminal();
413             size_t upsilonInsertionPoint = terminal.index;
414             NodeOrigin upsilonOrigin = terminal.node-&gt;origin;
415             for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
416                 BasicBlock* successorBlock = block-&gt;successor(successorIndex);
417                 for (SSACalculator::Def* phiDef : calculator.phisForBlock(successorBlock)) {
418                     Node* phiNode = phiDef-&gt;value();
419                     SSACalculator::Variable* ssaVariable = phiDef-&gt;variable();
420                     VariableAccessData* variable = m_variableForSSAIndex[ssaVariable-&gt;index()];
421                     FlushFormat format = variable-&gt;flushFormat();
422 
423                     // We can use an unchecked use kind because the SetLocal was turned into a Check.
424                     // We have to use an unchecked use because at least sometimes, the end of the block
425                     // is not exitOK.
426                     UseKind useKind = uncheckedUseKindFor(format);
427 


428                     m_insertionSet.insertNode(
429                         upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
430                         OpInfo(phiNode), Edge(
<span class="line-modified">431                             valueForOperand.operand(variable-&gt;local()),</span>
432                             useKind));
433                 }
434             }
435 
436             m_insertionSet.execute(block);
437         }
438 
439         // Free all CPS phis and reset variables vectors.
440         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
441             BasicBlock* block = m_graph.block(blockIndex);
442             if (!block)
443                 continue;
444             for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
445                 m_graph.deleteNode(block-&gt;phis[phiIndex]);
446             block-&gt;phis.clear();
447             block-&gt;variablesAtHead.clear();
448             block-&gt;variablesAtTail.clear();
449             block-&gt;valuesAtHead.clear();
450             block-&gt;valuesAtHead.clear();
451             block-&gt;ssa = makeUnique&lt;BasicBlock::SSAData&gt;(block);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGBlockInsertionSet.h&quot;
 33 #include &quot;DFGGraph.h&quot;
 34 #include &quot;DFGInsertionSet.h&quot;
 35 #include &quot;DFGPhase.h&quot;
 36 #include &quot;DFGSSACalculator.h&quot;
 37 #include &quot;DFGVariableAccessDataDump.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 
 40 #undef RELEASE_ASSERT
 41 #define RELEASE_ASSERT(assertion) do { \
 42     if (!(assertion)) { \
 43         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
 44         CRASH(); \
 45     } \
 46 } while (0)
 47 
 48 namespace JSC { namespace DFG {
 49 
 50 class SSAConversionPhase : public Phase {
<span class="line-modified"> 51     static constexpr bool verbose = false;</span>
 52 
 53 public:
 54     SSAConversionPhase(Graph&amp; graph)
 55         : Phase(graph, &quot;SSA conversion&quot;)
 56         , m_insertionSet(graph)
 57     {
 58     }
 59 
 60     bool run()
 61     {
 62         RELEASE_ASSERT(m_graph.m_form == ThreadedCPS);
 63         RELEASE_ASSERT(!m_graph.m_isInSSAConversion);
 64         m_graph.m_isInSSAConversion = true;
 65 
 66         m_graph.clearReplacements();
 67         m_graph.clearCPSCFGData();
 68 
 69         HashMap&lt;unsigned, BasicBlock*, WTF::IntHash&lt;unsigned&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; entrypointIndexToArgumentsBlock;
 70 
 71         m_graph.m_numberOfEntrypoints = m_graph.m_roots.size();
</pre>
<hr />
<pre>
 80                 0, SpecNone, InitializeEntrypointArguments, origin, OpInfo(entrypointIndex));
 81             m_insertionSet.insertNode(
 82                 0, SpecNone, ExitOK, origin);
 83             m_insertionSet.execute(oldRoot);
 84         }
 85 
 86         if (m_graph.m_numberOfEntrypoints &gt; 1) {
 87             BlockInsertionSet blockInsertionSet(m_graph);
 88             BasicBlock* newRoot = blockInsertionSet.insert(0, 1.0f);
 89 
 90             EntrySwitchData* entrySwitchData = m_graph.m_entrySwitchData.add();
 91             for (unsigned entrypointIndex = 0; entrypointIndex &lt; m_graph.m_numberOfEntrypoints; ++entrypointIndex) {
 92                 BasicBlock* oldRoot = m_graph.m_roots[entrypointIndex];
 93                 entrySwitchData-&gt;cases.append(oldRoot);
 94 
 95                 ASSERT(oldRoot-&gt;predecessors.isEmpty());
 96                 oldRoot-&gt;predecessors.append(newRoot);
 97 
 98                 if (oldRoot-&gt;isCatchEntrypoint) {
 99                     ASSERT(!!entrypointIndex);
<span class="line-modified">100                     m_graph.m_entrypointIndexToCatchBytecodeIndex.add(entrypointIndex, oldRoot-&gt;bytecodeBegin);</span>
101                 }
102             }
103 
104             RELEASE_ASSERT(entrySwitchData-&gt;cases[0] == m_graph.block(0)); // We strongly assume the normal call entrypoint is the first item in the list.
105 
106             const bool exitOK = false;
<span class="line-modified">107             NodeOrigin origin { CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), exitOK };</span>
108             newRoot-&gt;appendNode(
109                 m_graph, SpecNone, EntrySwitch, origin, OpInfo(entrySwitchData));
110 
111             m_graph.m_roots.clear();
112             m_graph.m_roots.append(newRoot);
113 
114             blockInsertionSet.execute();
115         }
116 
117         SSACalculator calculator(m_graph);
118 
119         m_graph.ensureSSADominators();
120 
121         if (verbose) {
122             dataLog(&quot;Graph before SSA transformation:\n&quot;);
123             m_graph.dump();
124         }
125 
126         // Create a SSACalculator::Variable for every root VariableAccessData.
127         for (VariableAccessData&amp; variable : m_graph.m_variableAccessData) {
</pre>
<hr />
<pre>
141             if (!block)
142                 continue;
143 
144             // Must process the block in forward direction because we want to see the last
145             // assignment for every local.
146             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
147                 Node* node = block-&gt;at(nodeIndex);
148                 if (node-&gt;op() != SetLocal &amp;&amp; node-&gt;op() != SetArgumentDefinitely)
149                     continue;
150 
151                 VariableAccessData* variable = node-&gt;variableAccessData();
152 
153                 Node* childNode;
154                 if (node-&gt;op() == SetLocal)
155                     childNode = node-&gt;child1().node();
156                 else {
157                     ASSERT(node-&gt;op() == SetArgumentDefinitely);
158                     childNode = m_insertionSet.insertNode(
159                         nodeIndex, node-&gt;variableAccessData()-&gt;prediction(),
160                         GetStack, node-&gt;origin,
<span class="line-modified">161                         OpInfo(m_graph.m_stackAccessData.add(variable-&gt;operand(), variable-&gt;flushFormat())));</span>
<span class="line-modified">162                     if (ASSERT_ENABLED)</span>
163                         m_argumentGetters.add(childNode);
164                     m_argumentMapping.add(node, childNode);
165                 }
166 
167                 calculator.newDef(
168                     m_ssaVariableForVariable.get(variable), block, childNode);
169             }
170 
171             m_insertionSet.execute(block);
172         }
173 
174         // Decide where Phis are to be inserted. This creates the Phi&#39;s but doesn&#39;t insert them
175         // yet. We will later know where to insert based on where SSACalculator tells us to.
176         calculator.computePhis(
177             [&amp;] (SSACalculator::Variable* ssaVariable, BasicBlock* block) -&gt; Node* {
178                 VariableAccessData* variable = m_variableForSSAIndex[ssaVariable-&gt;index()];
179 
180                 // Prune by liveness. This doesn&#39;t buy us much other than compile times.
<span class="line-modified">181                 Node* headNode = block-&gt;variablesAtHead.operand(variable-&gt;operand());</span>
182                 if (!headNode)
183                     return nullptr;
184 
185                 // There is the possibiltiy of &quot;rebirths&quot;. The SSA calculator will already prune
186                 // rebirths for the same VariableAccessData. But it will not be able to prune
187                 // rebirths that arose from the same local variable number but a different
188                 // VariableAccessData. We do that pruning here.
189                 //
190                 // Here&#39;s an example of a rebirth that this would catch:
191                 //
192                 //     var x;
193                 //     if (foo) {
194                 //         if (bar) {
195                 //             x = 42;
196                 //         } else {
197                 //             x = 43;
198                 //         }
199                 //         print(x);
200                 //         x = 44;
201                 //     } else {
</pre>
<hr />
<pre>
283                         dataLog(&quot;Considering live variable &quot;, VariableAccessDataDump(m_graph, variable), &quot; at head of block &quot;, *block, &quot;\n&quot;);
284 
285                     SSACalculator::Variable* ssaVariable = m_ssaVariableForVariable.get(variable);
286                     SSACalculator::Def* def = calculator.reachingDefAtHead(block, ssaVariable);
287                     if (!def) {
288                         // If we are required to insert a Phi, then we won&#39;t have a reaching def
289                         // at head.
290                         continue;
291                     }
292 
293                     Node* node = def-&gt;value();
294                     if (node-&gt;replacement()) {
295                         // This will occur when a SetLocal had a GetLocal as its source. The
296                         // GetLocal would get replaced with an actual SSA value by the time we get
297                         // here. Note that the SSA value with which the GetLocal got replaced
298                         // would not in turn have a replacement.
299                         node = node-&gt;replacement();
300                         ASSERT(!node-&gt;replacement());
301                     }
302                     if (verbose)
<span class="line-modified">303                         dataLog(&quot;Mapping: &quot;, valueForOperand.operandForIndex(i), &quot; -&gt; &quot;, node, &quot;\n&quot;);</span>
304                     valueForOperand[i] = node;
305                 }
306             }
307 
308             // Insert Phis by asking the calculator what phis there are in this block. Also update
309             // valueForOperand with those Phis. For Phis associated with variables that are not
310             // flushed, we also insert a MovHint.
311             size_t phiInsertionPoint = 0;
312             for (SSACalculator::Def* phiDef : calculator.phisForBlock(block)) {
313                 VariableAccessData* variable = m_variableForSSAIndex[phiDef-&gt;variable()-&gt;index()];
314 
315                 m_insertionSet.insert(phiInsertionPoint, phiDef-&gt;value());
<span class="line-modified">316                 valueForOperand.operand(variable-&gt;operand()) = phiDef-&gt;value();</span>
317 
318                 m_insertionSet.insertNode(
319                     phiInsertionPoint, SpecNone, MovHint, block-&gt;at(0)-&gt;origin.withInvalidExit(),
<span class="line-modified">320                     OpInfo(variable-&gt;operand()), phiDef-&gt;value()-&gt;defaultEdge());</span>
321             }
322 
323             if (block-&gt;at(0)-&gt;origin.exitOK)
324                 m_insertionSet.insertNode(phiInsertionPoint, SpecNone, ExitOK, block-&gt;at(0)-&gt;origin);
325 
326             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
327                 Node* node = block-&gt;at(nodeIndex);
328 
329                 if (verbose) {
330                     dataLog(&quot;Processing node &quot;, node, &quot;:\n&quot;);
331                     m_graph.dump(WTF::dataFile(), &quot;    &quot;, node);
332                 }
333 
334                 m_graph.performSubstitution(node);
335 
336                 switch (node-&gt;op()) {
337                 case MovHint: {
338                     m_insertionSet.insertNode(
339                         nodeIndex, SpecNone, KillStack, node-&gt;origin,
<span class="line-modified">340                         OpInfo(node-&gt;unlinkedOperand()));</span>
341                     node-&gt;origin.exitOK = false; // KillStack clobbers exit.
342                     break;
343                 }
344 
345                 case SetLocal: {
346                     VariableAccessData* variable = node-&gt;variableAccessData();
347                     Node* child = node-&gt;child1().node();
348 
349                     if (!!(node-&gt;flags() &amp; NodeIsFlushed)) {
350                         node-&gt;convertToPutStack(
351                             m_graph.m_stackAccessData.add(
<span class="line-modified">352                                 variable-&gt;operand(), variable-&gt;flushFormat()));</span>
353                     } else
354                         node-&gt;remove(m_graph);
355 
356                     if (verbose)
<span class="line-modified">357                         dataLog(&quot;Mapping: &quot;, variable-&gt;operand(), &quot; -&gt; &quot;, child, &quot;\n&quot;);</span>
<span class="line-modified">358                     valueForOperand.operand(variable-&gt;operand()) = child;</span>
359                     break;
360                 }
361 
362                 case GetStack: {
363                     ASSERT(m_argumentGetters.contains(node));
<span class="line-modified">364                     valueForOperand.operand(node-&gt;stackAccessData()-&gt;operand) = node;</span>
365                     break;
366                 }
367 
368                 case GetLocal: {
369                     VariableAccessData* variable = node-&gt;variableAccessData();
370                     node-&gt;children.reset();
371 
372                     node-&gt;remove(m_graph);
373                     if (verbose)
<span class="line-modified">374                         dataLog(&quot;Replacing node &quot;, node, &quot; with &quot;, valueForOperand.operand(variable-&gt;operand()), &quot;\n&quot;);</span>
<span class="line-modified">375                     node-&gt;setReplacement(valueForOperand.operand(variable-&gt;operand()));</span>
376                     break;
377                 }
378 
379                 case Flush: {
380                     node-&gt;children.reset();
381                     node-&gt;remove(m_graph);
382                     break;
383                 }
384 
385                 case PhantomLocal: {
386                     ASSERT(node-&gt;child1().useKind() == UntypedUse);
387                     VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">388                     node-&gt;child1() = valueForOperand.operand(variable-&gt;operand())-&gt;defaultEdge();</span>
389                     node-&gt;remove(m_graph);
390                     break;
391                 }
392 
393                 case SetArgumentDefinitely: {
394                     node-&gt;remove(m_graph);
395                     break;
396                 }
397 
398                 case SetArgumentMaybe: {
399                     node-&gt;remove(m_graph);
400                     break;
401                 }
402 
403                 default:
404                     break;
405                 }
406             }
407 
408             // We want to insert Upsilons just before the end of the block. On the surface this
409             // seems dangerous because the Upsilon will have a checking UseKind. But, we will not
410             // actually be performing the check at the point of the Upsilon; the check will
411             // already have been performed at the point where the original SetLocal was.
412             NodeAndIndex terminal = block-&gt;findTerminal();
413             size_t upsilonInsertionPoint = terminal.index;
414             NodeOrigin upsilonOrigin = terminal.node-&gt;origin;
415             for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
416                 BasicBlock* successorBlock = block-&gt;successor(successorIndex);
417                 for (SSACalculator::Def* phiDef : calculator.phisForBlock(successorBlock)) {
418                     Node* phiNode = phiDef-&gt;value();
419                     SSACalculator::Variable* ssaVariable = phiDef-&gt;variable();
420                     VariableAccessData* variable = m_variableForSSAIndex[ssaVariable-&gt;index()];
421                     FlushFormat format = variable-&gt;flushFormat();
422 
423                     // We can use an unchecked use kind because the SetLocal was turned into a Check.
424                     // We have to use an unchecked use because at least sometimes, the end of the block
425                     // is not exitOK.
426                     UseKind useKind = uncheckedUseKindFor(format);
427 
<span class="line-added">428                     dataLogLnIf(verbose, &quot;Inserting Upsilon for &quot;, variable-&gt;operand(), &quot; propagating &quot;, valueForOperand.operand(variable-&gt;operand()), &quot; to &quot;, phiNode);</span>
<span class="line-added">429 </span>
430                     m_insertionSet.insertNode(
431                         upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
432                         OpInfo(phiNode), Edge(
<span class="line-modified">433                             valueForOperand.operand(variable-&gt;operand()),</span>
434                             useKind));
435                 }
436             }
437 
438             m_insertionSet.execute(block);
439         }
440 
441         // Free all CPS phis and reset variables vectors.
442         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
443             BasicBlock* block = m_graph.block(blockIndex);
444             if (!block)
445                 continue;
446             for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
447                 m_graph.deleteNode(block-&gt;phis[phiIndex]);
448             block-&gt;phis.clear();
449             block-&gt;variablesAtHead.clear();
450             block-&gt;variablesAtTail.clear();
451             block-&gt;valuesAtHead.clear();
452             block-&gt;valuesAtHead.clear();
453             block-&gt;ssa = makeUnique&lt;BasicBlock::SSAData&gt;(block);
</pre>
</td>
</tr>
</table>
<center><a href="DFGRegisterBank.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSSALoweringPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
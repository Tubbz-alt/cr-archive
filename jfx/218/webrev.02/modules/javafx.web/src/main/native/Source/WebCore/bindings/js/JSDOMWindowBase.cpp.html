<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2006 Jon Shier (jshier@iastate.edu)
  4  *  Copyright (C) 2003-2017 Apple Inc. All rights reseved.
  5  *  Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
  6  *  Copyright (c) 2015 Canon Inc. All rights reserved.
  7  *
  8  *  This library is free software; you can redistribute it and/or
  9  *  modify it under the terms of the GNU Lesser General Public
 10  *  License as published by the Free Software Foundation; either
 11  *  version 2 of the License, or (at your option) any later version.
 12  *
 13  *  This library is distributed in the hope that it will be useful,
 14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  *  Lesser General Public License for more details.
 17  *
 18  *  You should have received a copy of the GNU Lesser General Public
 19  *  License along with this library; if not, write to the Free Software
 20  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
 21  *  USA
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;JSDOMWindowBase.h&quot;
 26 
 27 #include &quot;Chrome.h&quot;
 28 #include &quot;CommonVM.h&quot;
 29 #include &quot;DOMWindow.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;EventLoop.h&quot;
 32 #include &quot;FetchResponse.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;InspectorController.h&quot;
 35 #include &quot;JSDOMBindingSecurity.h&quot;
 36 #include &quot;JSDOMGlobalObjectTask.h&quot;
 37 #include &quot;JSDOMWindowCustom.h&quot;
 38 #include &quot;JSFetchResponse.h&quot;
 39 #include &quot;JSMicrotaskCallback.h&quot;
 40 #include &quot;JSNode.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RejectedPromiseTracker.h&quot;
 44 #include &quot;RuntimeApplicationChecks.h&quot;
 45 #include &quot;ScriptController.h&quot;
 46 #include &quot;ScriptModuleLoader.h&quot;
 47 #include &quot;SecurityOrigin.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;WebCoreJSClientData.h&quot;
 50 #include &lt;JavaScriptCore/CodeBlock.h&gt;
 51 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
 52 #include &lt;JavaScriptCore/JSWebAssembly.h&gt;
 53 #include &lt;JavaScriptCore/Microtask.h&gt;
 54 #include &lt;JavaScriptCore/PromiseTimer.h&gt;
 55 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 56 #include &lt;wtf/Language.h&gt;
 57 #include &lt;wtf/MainThread.h&gt;
 58 
 59 #if PLATFORM(IOS_FAMILY)
 60 #include &quot;ChromeClient.h&quot;
 61 #endif
 62 
 63 
 64 namespace WebCore {
 65 using namespace JSC;
 66 
 67 const ClassInfo JSDOMWindowBase::s_info = { &quot;Window&quot;, &amp;JSDOMGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDOMWindowBase) };
 68 
 69 const GlobalObjectMethodTable JSDOMWindowBase::s_globalObjectMethodTable = {
 70     &amp;supportsRichSourceInfo,
 71     &amp;shouldInterruptScript,
 72     &amp;javaScriptRuntimeFlags,
 73     &amp;queueMicrotaskToEventLoop,
 74     &amp;shouldInterruptScriptBeforeTimeout,
 75     &amp;moduleLoaderImportModule,
 76     &amp;moduleLoaderResolve,
 77     &amp;moduleLoaderFetch,
 78     &amp;moduleLoaderCreateImportMetaProperties,
 79     &amp;moduleLoaderEvaluate,
 80     &amp;promiseRejectionTracker,
 81     &amp;defaultLanguage,
 82 #if ENABLE(WEBASSEMBLY)
 83     &amp;compileStreaming,
 84     &amp;instantiateStreaming,
 85 #else
 86     nullptr,
 87     nullptr,
 88 #endif
 89 };
 90 
 91 JSDOMWindowBase::JSDOMWindowBase(VM&amp; vm, Structure* structure, RefPtr&lt;DOMWindow&gt;&amp;&amp; window, JSWindowProxy* proxy)
 92     : JSDOMGlobalObject(vm, structure, proxy-&gt;world(), &amp;s_globalObjectMethodTable)
 93     , m_windowCloseWatchpoints((window &amp;&amp; window-&gt;frame()) ? IsWatched : IsInvalidated)
 94     , m_wrapped(WTFMove(window))
 95     , m_proxy(proxy)
 96 {
 97 }
 98 
 99 void JSDOMWindowBase::finishCreation(VM&amp; vm, JSWindowProxy* proxy)
100 {
101     Base::finishCreation(vm, proxy);
102     ASSERT(inherits(vm, info()));
103 
104     auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
105 
106     GlobalPropertyInfo staticGlobals[] = {
107         GlobalPropertyInfo(builtinNames.documentPublicName(), jsNull(), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),
108         GlobalPropertyInfo(builtinNames.windowPublicName(), m_proxy, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly),
109     };
110 
111     addStaticGlobals(staticGlobals, WTF_ARRAY_LENGTH(staticGlobals));
112 
113     if (m_wrapped &amp;&amp; m_wrapped-&gt;frame() &amp;&amp; m_wrapped-&gt;frame()-&gt;settings().needsSiteSpecificQuirks())
114         setNeedsSiteSpecificQuirks(true);
115 }
116 
117 void JSDOMWindowBase::destroy(JSCell* cell)
118 {
119     static_cast&lt;JSDOMWindowBase*&gt;(cell)-&gt;JSDOMWindowBase::~JSDOMWindowBase();
120 }
121 
122 void JSDOMWindowBase::updateDocument()
123 {
124     // Since &quot;document&quot; property is defined as { configurable: false, writable: false, enumerable: true },
125     // users cannot change its attributes further.
126     // Reaching here, the attributes of &quot;document&quot; property should be never changed.
127     ASSERT(m_wrapped-&gt;document());
128     JSGlobalObject* lexicalGlobalObject = this;
129     bool shouldThrowReadOnlyError = false;
130     bool ignoreReadOnlyErrors = true;
131     bool putResult = false;
132     symbolTablePutTouchWatchpointSet(this, lexicalGlobalObject, static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject-&gt;vm().clientData)-&gt;builtinNames().documentPublicName(), toJS(lexicalGlobalObject, this, m_wrapped-&gt;document()), shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);
133 }
134 
135 ScriptExecutionContext* JSDOMWindowBase::scriptExecutionContext() const
136 {
137     return m_wrapped-&gt;document();
138 }
139 
140 void JSDOMWindowBase::printErrorMessage(const String&amp; message) const
141 {
142     printErrorMessageForFrame(wrapped().frame(), message);
143 }
144 
145 bool JSDOMWindowBase::supportsRichSourceInfo(const JSGlobalObject* object)
146 {
147     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
148     Frame* frame = thisObject-&gt;wrapped().frame();
149     if (!frame)
150         return false;
151 
152     Page* page = frame-&gt;page();
153     if (!page)
154         return false;
155 
156     bool enabled = page-&gt;inspectorController().enabled();
157     ASSERT(enabled || !thisObject-&gt;debugger());
158     return enabled;
159 }
160 
161 static inline bool shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(Page* page)
162 {
163     // See &lt;rdar://problem/5479443&gt;. We don&#39;t think that page can ever be NULL
164     // in this case, but if it is, we&#39;ve gotten into a lexicalGlobalObject where we may have
165     // hung the UI, with no way to ask the client whether to cancel execution.
166     // For now, our solution is just to cancel execution no matter what,
167     // ensuring that we never hang. We might want to consider other solutions
168     // if we discover problems with this one.
169     ASSERT(page);
170     return !page;
171 }
172 
173 bool JSDOMWindowBase::shouldInterruptScript(const JSGlobalObject* object)
174 {
175     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
176     ASSERT(thisObject-&gt;wrapped().frame());
177     Page* page = thisObject-&gt;wrapped().frame()-&gt;page();
178     return shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(page);
179 }
180 
181 bool JSDOMWindowBase::shouldInterruptScriptBeforeTimeout(const JSGlobalObject* object)
182 {
183     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
184     ASSERT(thisObject-&gt;wrapped().frame());
185     Page* page = thisObject-&gt;wrapped().frame()-&gt;page();
186 
187     if (shouldInterruptScriptToPreventInfiniteRecursionWhenClosingPage(page))
188         return true;
189 
190 #if PLATFORM(IOS_FAMILY)
191     if (page-&gt;chrome().client().isStopping())
192         return true;
193 #endif
194 
195     return JSGlobalObject::shouldInterruptScriptBeforeTimeout(object);
196 }
197 
198 RuntimeFlags JSDOMWindowBase::javaScriptRuntimeFlags(const JSGlobalObject* object)
199 {
200     const JSDOMWindowBase* thisObject = static_cast&lt;const JSDOMWindowBase*&gt;(object);
201     Frame* frame = thisObject-&gt;wrapped().frame();
202     if (!frame)
203         return RuntimeFlags();
204     return frame-&gt;settings().javaScriptRuntimeFlags();
205 }
206 
207 void JSDOMWindowBase::queueMicrotaskToEventLoop(JSGlobalObject&amp; object, Ref&lt;JSC::Microtask&gt;&amp;&amp; task)
208 {
209     JSDOMWindowBase&amp; thisObject = static_cast&lt;JSDOMWindowBase&amp;&gt;(object);
210 
211     auto callback = JSMicrotaskCallback::create(thisObject, WTFMove(task));
212     auto&amp; eventLoop = thisObject.scriptExecutionContext()-&gt;eventLoop();
213     eventLoop.queueMicrotask([callback = WTFMove(callback)]() mutable {
214         callback-&gt;call();
215     });
216 }
217 
218 void JSDOMWindowBase::willRemoveFromWindowProxy()
219 {
220     setCurrentEvent(0);
221 }
222 
223 JSWindowProxy* JSDOMWindowBase::proxy() const
224 {
225     return m_proxy;
226 }
227 
228 JSValue toJS(JSGlobalObject* lexicalGlobalObject, DOMWindow&amp; domWindow)
229 {
230     auto* frame = domWindow.frame();
231     if (!frame)
232         return jsNull();
233     return toJS(lexicalGlobalObject, frame-&gt;windowProxy());
234 }
235 
236 JSDOMWindow* toJSDOMWindow(Frame&amp; frame, DOMWrapperWorld&amp; world)
237 {
238     return frame.script().globalObject(world);
239 }
240 
241 JSDOMWindow* toJSDOMWindow(JSC::VM&amp; vm, JSValue value)
242 {
243     if (!value.isObject())
244         return nullptr;
245 
246     while (!value.isNull()) {
247         JSObject* object = asObject(value);
248         const ClassInfo* classInfo = object-&gt;classInfo(vm);
249         if (classInfo == JSDOMWindow::info())
250             return jsCast&lt;JSDOMWindow*&gt;(object);
251         if (classInfo == JSWindowProxy::info())
252             return jsDynamicCast&lt;JSDOMWindow*&gt;(vm, jsCast&lt;JSWindowProxy*&gt;(object)-&gt;window());
253         value = object-&gt;getPrototypeDirect(vm);
254     }
255     return nullptr;
256 }
257 
258 DOMWindow&amp; incumbentDOMWindow(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)
259 {
260     return asJSDOMWindow(&amp;callerGlobalObject(lexicalGlobalObject, callFrame))-&gt;wrapped();
261 }
262 
263 DOMWindow&amp; activeDOMWindow(JSGlobalObject&amp; lexicalGlobalObject)
264 {
265     return asJSDOMWindow(&amp;lexicalGlobalObject)-&gt;wrapped();
266 }
267 
268 DOMWindow&amp; firstDOMWindow(JSGlobalObject&amp; lexicalGlobalObject)
269 {
270     VM&amp; vm = lexicalGlobalObject.vm();
271     return asJSDOMWindow(vm.deprecatedVMEntryGlobalObject(&amp;lexicalGlobalObject))-&gt;wrapped();
272 }
273 
274 Document* responsibleDocument(VM&amp; vm, CallFrame&amp; callFrame)
275 {
276     CallerFunctor functor;
277     callFrame.iterate(vm, functor);
278     auto* callerFrame = functor.callerFrame();
279     if (!callerFrame)
280         return nullptr;
281     return asJSDOMWindow(callerFrame-&gt;lexicalGlobalObject(vm))-&gt;wrapped().document();
282 }
283 
284 void JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(DOMWindow* window)
285 {
286     JSC::VM&amp; vm = commonVM();
287     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(vm.clientData);
288     Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt; wrapperWorlds;
289     clientData-&gt;getAllWorlds(wrapperWorlds);
290     for (unsigned i = 0; i &lt; wrapperWorlds.size(); ++i) {
291         auto&amp; wrappers = wrapperWorlds[i]-&gt;wrappers();
292         auto result = wrappers.find(window);
293         if (result == wrappers.end())
294             continue;
295         JSC::JSObject* wrapper = result-&gt;value.get();
296         if (!wrapper)
297             continue;
298         JSDOMWindowBase* jsWindow = JSC::jsCast&lt;JSDOMWindowBase*&gt;(wrapper);
299         jsWindow-&gt;m_windowCloseWatchpoints.fireAll(vm, &quot;Frame cleared&quot;);
300     }
301 }
302 
303 JSC::Identifier JSDOMWindowBase::moduleLoaderResolve(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleName, JSC::JSValue importerModuleKey, JSC::JSValue scriptFetcher)
304 {
305     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
306     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
307         return document-&gt;moduleLoader().resolve(globalObject, moduleLoader, moduleName, importerModuleKey, scriptFetcher);
308     return { };
309 }
310 
311 JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderFetch(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue parameters, JSC::JSValue scriptFetcher)
312 {
313     VM&amp; vm = globalObject-&gt;vm();
314     auto scope = DECLARE_THROW_SCOPE(vm);
315     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
316     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
317         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().fetch(globalObject, moduleLoader, moduleKey, parameters, scriptFetcher));
318     JSC::JSInternalPromise* promise = JSC::JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
319     scope.release();
320     promise-&gt;reject(globalObject, jsUndefined());
321     return promise;
322 }
323 
324 JSC::JSValue JSDOMWindowBase::moduleLoaderEvaluate(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSValue moduleRecord, JSC::JSValue scriptFetcher)
325 {
326     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
327     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
328         return document-&gt;moduleLoader().evaluate(globalObject, moduleLoader, moduleKey, moduleRecord, scriptFetcher);
329     return JSC::jsUndefined();
330 }
331 
332 JSC::JSInternalPromise* JSDOMWindowBase::moduleLoaderImportModule(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)
333 {
334     VM&amp; vm = globalObject-&gt;vm();
335     auto scope = DECLARE_THROW_SCOPE(vm);
336     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
337     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
338         RELEASE_AND_RETURN(scope, document-&gt;moduleLoader().importModule(globalObject, moduleLoader, moduleName, parameters, sourceOrigin));
339     JSC::JSInternalPromise* promise = JSC::JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
340     scope.release();
341     promise-&gt;reject(globalObject, jsUndefined());
342     return promise;
343 }
344 
345 JSC::JSObject* JSDOMWindowBase::moduleLoaderCreateImportMetaProperties(JSC::JSGlobalObject* globalObject, JSC::JSModuleLoader* moduleLoader, JSC::JSValue moduleKey, JSC::JSModuleRecord* moduleRecord, JSC::JSValue scriptFetcher)
346 {
347     JSDOMWindowBase* thisObject = JSC::jsCast&lt;JSDOMWindowBase*&gt;(globalObject);
348     if (RefPtr&lt;Document&gt; document = thisObject-&gt;wrapped().document())
349         return document-&gt;moduleLoader().createImportMetaProperties(globalObject, moduleLoader, moduleKey, moduleRecord, scriptFetcher);
350     return constructEmptyObject(globalObject-&gt;vm(), globalObject-&gt;nullPrototypeObjectStructure());
351 }
352 
353 #if ENABLE(WEBASSEMBLY)
354 static Optional&lt;Vector&lt;uint8_t&gt;&gt; tryAllocate(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSPromise* promise, const char* data, size_t byteSize)
355 {
356     Vector&lt;uint8_t&gt; arrayBuffer;
357     if (!arrayBuffer.tryReserveCapacity(byteSize)) {
358         promise-&gt;reject(lexicalGlobalObject, createOutOfMemoryError(lexicalGlobalObject));
359         return WTF::nullopt;
360     }
361 
362     arrayBuffer.grow(byteSize);
363     memcpy(arrayBuffer.data(), data, byteSize);
364 
365     return arrayBuffer;
366 }
367 
368 static bool isResponseCorrect(JSC::JSGlobalObject* lexicalGlobalObject, FetchResponse* inputResponse, JSC::JSPromise* promise)
369 {
370     bool isResponseCorsSameOrigin = inputResponse-&gt;type() == ResourceResponse::Type::Basic || inputResponse-&gt;type() == ResourceResponse::Type::Cors || inputResponse-&gt;type() == ResourceResponse::Type::Default;
371 
372     if (!isResponseCorsSameOrigin) {
373         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Response is not CORS-same-origin&quot;_s));
374         return false;
375     }
376 
377     if (!inputResponse-&gt;ok()) {
378         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Response has not returned OK status&quot;_s));
379         return false;
380     }
381 
382     auto contentType = inputResponse-&gt;headers().fastGet(HTTPHeaderName::ContentType);
383     if (!equalLettersIgnoringASCIICase(contentType, &quot;application/wasm&quot;)) {
384         promise-&gt;reject(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;Unexpected response MIME type. Expected &#39;application/wasm&#39;&quot;_s));
385         return false;
386     }
387 
388     return true;
389 }
390 
391 static void handleResponseOnStreamingAction(JSC::JSGlobalObject* globalObject, FetchResponse* inputResponse, JSC::JSPromise* promise, Function&lt;void(JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize)&gt;&amp;&amp; actionCallback)
392 {
393     if (!isResponseCorrect(globalObject, inputResponse, promise))
394         return;
395 
396     if (inputResponse-&gt;isBodyReceivedByChunk()) {
397         inputResponse-&gt;consumeBodyReceivedByChunk([promise, callback = WTFMove(actionCallback), globalObject, data = SharedBuffer::create()] (auto&amp;&amp; result) mutable {
398             if (result.hasException()) {
399                 promise-&gt;reject(globalObject, createTypeError(globalObject, result.exception().message()));
400                 return;
401             }
402 
403             if (auto chunk = result.returnValue())
404                 data-&gt;append(reinterpret_cast&lt;const char*&gt;(chunk-&gt;data), chunk-&gt;size);
405             else {
406                 VM&amp; vm = globalObject-&gt;vm();
407                 JSLockHolder lock(vm);
408 
409                 callback(globalObject, data-&gt;data(), data-&gt;size());
410             }
411         });
412         return;
413     }
414 
415     auto body = inputResponse-&gt;consumeBody();
416     WTF::switchOn(body, [&amp;] (Ref&lt;FormData&gt;&amp; formData) {
417         if (auto buffer = formData-&gt;asSharedBuffer()) {
418             VM&amp; vm = globalObject-&gt;vm();
419             JSLockHolder lock(vm);
420 
421             actionCallback(globalObject, buffer-&gt;data(), buffer-&gt;size());
422             return;
423         }
424         // FIXME: http://webkit.org/b/184886&gt; Implement loading for the Blob type
425         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;Unexpected Response&#39;s Content-type&quot;_s));
426     }, [&amp;] (Ref&lt;SharedBuffer&gt;&amp; buffer) {
427         VM&amp; vm = globalObject-&gt;vm();
428         JSLockHolder lock(vm);
429 
430         actionCallback(globalObject, buffer-&gt;data(), buffer-&gt;size());
431     }, [&amp;] (std::nullptr_t&amp;) {
432         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;Unexpected Response&#39;s Content-type&quot;_s));
433     });
434 }
435 
436 void JSDOMWindowBase::compileStreaming(JSC::JSGlobalObject* globalObject, JSC::JSPromise* promise, JSC::JSValue source)
437 {
438     ASSERT(source);
439 
440     VM&amp; vm = globalObject-&gt;vm();
441 
442     ASSERT(vm.promiseTimer-&gt;hasPendingPromise(promise));
443     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));
444 
445     if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
446         handleResponseOnStreamingAction(globalObject, inputResponse, promise, [promise] (JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize) mutable {
447             if (auto arrayBuffer = tryAllocate(lexicalGlobalObject, promise, data, byteSize))
448                 JSC::JSWebAssembly::webAssemblyModuleValidateAsync(lexicalGlobalObject, promise, WTFMove(*arrayBuffer));
449         });
450     } else
451         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;first argument must be an Response or Promise for Response&quot;_s));
452 }
453 
454 void JSDOMWindowBase::instantiateStreaming(JSC::JSGlobalObject* globalObject, JSC::JSPromise* promise, JSC::JSValue source, JSC::JSObject* importedObject)
455 {
456     ASSERT(source);
457 
458     VM&amp; vm = globalObject-&gt;vm();
459 
460     ASSERT(vm.promiseTimer-&gt;hasPendingPromise(promise));
461     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, globalObject));
462     ASSERT(vm.promiseTimer-&gt;hasDependancyInPendingPromise(promise, importedObject));
463 
464     if (auto inputResponse = JSFetchResponse::toWrapped(vm, source)) {
465         handleResponseOnStreamingAction(globalObject, inputResponse, promise, [promise, importedObject] (JSC::JSGlobalObject* lexicalGlobalObject, const char* data, size_t byteSize) mutable {
466             if (auto arrayBuffer = tryAllocate(lexicalGlobalObject, promise, data, byteSize))
467                 JSC::JSWebAssembly::webAssemblyModuleInstantinateAsync(lexicalGlobalObject, promise, WTFMove(*arrayBuffer), importedObject);
468         });
469     } else
470         promise-&gt;reject(globalObject, createTypeError(globalObject, &quot;first argument must be an Response or Promise for Response&quot;_s));
471 }
472 #endif
473 
474 } // namespace WebCore
    </pre>
  </body>
</html>
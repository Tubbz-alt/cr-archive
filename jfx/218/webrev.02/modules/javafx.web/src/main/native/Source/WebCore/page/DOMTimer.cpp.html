<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008, 2014 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;DOMTimer.h&quot;
 29 
 30 #include &quot;HTMLPlugInElement.h&quot;
 31 #include &quot;InspectorInstrumentation.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;Page.h&quot;
 34 #include &quot;PluginViewBase.h&quot;
 35 #include &quot;ScheduledAction.h&quot;
 36 #include &quot;ScriptExecutionContext.h&quot;
 37 #include &quot;Settings.h&quot;
 38 #include &lt;wtf/HashMap.h&gt;
 39 #include &lt;wtf/MathExtras.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/RandomNumber.h&gt;
 42 #include &lt;wtf/StdLibExtras.h&gt;
 43 
 44 #if PLATFORM(IOS_FAMILY)
 45 #include &quot;ContentChangeObserver.h&quot;
 46 #include &quot;DOMTimerHoldingTank.h&quot;
 47 #endif
 48 
 49 namespace WebCore {
 50 
 51 static const Seconds maxIntervalForUserGestureForwarding { 1_s }; // One second matches Gecko.
 52 static const Seconds minIntervalForNonUserObservableChangeTimers { 1_s }; // Empirically determined to maximize battery life.
 53 static const int maxTimerNestingLevel = 5;
 54 
 55 class DOMTimerFireState {
 56 public:
 57     DOMTimerFireState(ScriptExecutionContext&amp; context, int nestingLevel)
 58         : m_context(context)
 59         , m_contextIsDocument(is&lt;Document&gt;(m_context))
 60     {
 61         // For worker threads, don&#39;t update the current DOMTimerFireState.
 62         // Setting this from workers would not be thread-safe, and its not relevant to current uses.
 63         if (m_contextIsDocument) {
 64             m_initialDOMTreeVersion = downcast&lt;Document&gt;(context).domTreeVersion();
 65             m_previous = current;
 66             current = this;
 67         }
 68 
 69         m_context.setTimerNestingLevel(nestingLevel);
 70     }
 71 
 72     ~DOMTimerFireState()
 73     {
 74         if (m_contextIsDocument)
 75             current = m_previous;
 76         m_context.setTimerNestingLevel(0);
 77     }
 78 
 79     Document* contextDocument() const { return m_contextIsDocument ? &amp;downcast&lt;Document&gt;(m_context) : nullptr; }
 80 
 81     void setScriptMadeUserObservableChanges() { m_scriptMadeUserObservableChanges = true; }
 82     void setScriptMadeNonUserObservableChanges() { m_scriptMadeNonUserObservableChanges = true; }
 83 
 84     bool scriptMadeNonUserObservableChanges() const { return m_scriptMadeNonUserObservableChanges; }
 85     bool scriptMadeUserObservableChanges() const
 86     {
 87         if (m_scriptMadeUserObservableChanges)
 88             return true;
 89 
 90         Document* document = contextDocument();
 91         // To be conservative, we also consider any DOM Tree change to be user observable.
 92         return document &amp;&amp; document-&gt;domTreeVersion() != m_initialDOMTreeVersion;
 93     }
 94 
 95     static DOMTimerFireState* current;
 96 
 97 private:
 98     ScriptExecutionContext&amp; m_context;
 99     uint64_t m_initialDOMTreeVersion;
100     DOMTimerFireState* m_previous;
101     bool m_contextIsDocument;
102     bool m_scriptMadeNonUserObservableChanges { false };
103     bool m_scriptMadeUserObservableChanges { false };
104 };
105 
106 DOMTimerFireState* DOMTimerFireState::current = nullptr;
107 
108 struct NestedTimersMap {
109     typedef HashMap&lt;int, Ref&lt;DOMTimer&gt;&gt;::const_iterator const_iterator;
110 
111     static NestedTimersMap* instanceForContext(ScriptExecutionContext&amp; context)
112     {
113         // For worker threads, we don&#39;t use NestedTimersMap as doing so would not
114         // be thread safe.
115         if (is&lt;Document&gt;(context))
116             return &amp;instance();
117         return nullptr;
118     }
119 
120     void startTracking()
121     {
122         // Make sure we start with an empty HashMap. In theory, it is possible the HashMap is not
123         // empty if a timer fires during the execution of another timer (may happen with the
124         // in-process Web Inspector).
125         nestedTimers.clear();
126         isTrackingNestedTimers = true;
127     }
128 
129     void stopTracking()
130     {
131         isTrackingNestedTimers = false;
132         nestedTimers.clear();
133     }
134 
135     void add(int timeoutId, Ref&lt;DOMTimer&gt;&amp;&amp; timer)
136     {
137         if (isTrackingNestedTimers)
138             nestedTimers.add(timeoutId, WTFMove(timer));
139     }
140 
141     void remove(int timeoutId)
142     {
143         if (isTrackingNestedTimers)
144             nestedTimers.remove(timeoutId);
145     }
146 
147     const_iterator begin() const { return nestedTimers.begin(); }
148     const_iterator end() const { return nestedTimers.end(); }
149 
150 private:
151     static NestedTimersMap&amp; instance()
152     {
153         static NeverDestroyed&lt;NestedTimersMap&gt; map;
154         return map;
155     }
156 
157     static bool isTrackingNestedTimers;
158     HashMap&lt;int /* timeoutId */, Ref&lt;DOMTimer&gt;&gt; nestedTimers;
159 };
160 
161 bool NestedTimersMap::isTrackingNestedTimers = false;
162 
163 DOMTimer::DOMTimer(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds interval, bool singleShot)
164     : SuspendableTimerBase(&amp;context)
165     , m_nestingLevel(context.timerNestingLevel())
166     , m_action(WTFMove(action))
167     , m_originalInterval(interval)
168     , m_throttleState(Undetermined)
169     , m_currentTimerInterval(intervalClampedToMinimum())
170     , m_userGestureTokenToForward(UserGestureIndicator::currentUserGesture())
171 {
172     if (singleShot)
173         startOneShot(m_currentTimerInterval);
174     else
175         startRepeating(m_currentTimerInterval);
176 }
177 
178 DOMTimer::~DOMTimer() = default;
179 
180 int DOMTimer::install(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds timeout, bool singleShot)
181 {
182     Ref&lt;DOMTimer&gt; timer = adoptRef(*new DOMTimer(context, WTFMove(action), timeout, singleShot));
183     timer-&gt;suspendIfNeeded();
184 
185     // Keep asking for the next id until we&#39;re given one that we don&#39;t already have.
186     do {
187         timer-&gt;m_timeoutId = context.circularSequentialID();
188     } while (!context.addTimeout(timer-&gt;m_timeoutId, timer.get()));
189 
190     InspectorInstrumentation::didInstallTimer(context, timer-&gt;m_timeoutId, timeout, singleShot);
191 
192     // Keep track of nested timer installs.
193     if (NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context))
194         nestedTimers-&gt;add(timer-&gt;m_timeoutId, timer.get());
195 #if PLATFORM(IOS_FAMILY)
196     if (is&lt;Document&gt;(context)) {
197         auto&amp; document = downcast&lt;Document&gt;(context);
198         document.contentChangeObserver().didInstallDOMTimer(timer.get(), timeout, singleShot);
199         if (DeferDOMTimersForScope::isDeferring())
200             document.domTimerHoldingTank().add(timer.get());
201     }
202 #endif
203     return timer-&gt;m_timeoutId;
204 }
205 
206 void DOMTimer::removeById(ScriptExecutionContext&amp; context, int timeoutId)
207 {
208     // timeout IDs have to be positive, and 0 and -1 are unsafe to
209     // even look up since they are the empty and deleted value
210     // respectively
211     if (timeoutId &lt;= 0)
212         return;
213 
214 #if PLATFORM(IOS_FAMILY)
215     if (is&lt;Document&gt;(context)) {
216         auto&amp; document = downcast&lt;Document&gt;(context);
217         if (auto* timer = document.findTimeout(timeoutId)) {
218             document.contentChangeObserver().didRemoveDOMTimer(*timer);
219             if (auto* holdingTank = document.domTimerHoldingTankIfExists())
220                 holdingTank-&gt;remove(*timer);
221         }
222     }
223 #endif
224 
225     if (NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context))
226         nestedTimers-&gt;remove(timeoutId);
227 
228     InspectorInstrumentation::didRemoveTimer(context, timeoutId);
229     context.removeTimeout(timeoutId);
230 }
231 
232 inline bool DOMTimer::isDOMTimersThrottlingEnabled(Document&amp; document) const
233 {
234     auto* page = document.page();
235     if (!page)
236         return true;
237     return page-&gt;settings().domTimersThrottlingEnabled();
238 }
239 
240 void DOMTimer::updateThrottlingStateIfNecessary(const DOMTimerFireState&amp; fireState)
241 {
242     Document* contextDocument = fireState.contextDocument();
243     // We don&#39;t throttle timers in worker threads.
244     if (!contextDocument)
245         return;
246 
247     if (UNLIKELY(!isDOMTimersThrottlingEnabled(*contextDocument))) {
248         if (m_throttleState == ShouldThrottle) {
249             // Unthrottle the timer in case it was throttled before the setting was updated.
250             LOG(DOMTimers, &quot;%p - Unthrottling DOM timer because throttling was disabled via settings.&quot;, this);
251             m_throttleState = ShouldNotThrottle;
252             updateTimerIntervalIfNecessary();
253         }
254         return;
255     }
256 
257     if (fireState.scriptMadeUserObservableChanges()) {
258         if (m_throttleState != ShouldNotThrottle) {
259             m_throttleState = ShouldNotThrottle;
260             updateTimerIntervalIfNecessary();
261         }
262     } else if (fireState.scriptMadeNonUserObservableChanges()) {
263         if (m_throttleState != ShouldThrottle) {
264             m_throttleState = ShouldThrottle;
265             updateTimerIntervalIfNecessary();
266         }
267     }
268 }
269 
270 void DOMTimer::scriptDidInteractWithPlugin(HTMLPlugInElement&amp; pluginElement)
271 {
272     if (!DOMTimerFireState::current)
273         return;
274 
275     if (pluginElement.isUserObservable())
276         DOMTimerFireState::current-&gt;setScriptMadeUserObservableChanges();
277     else
278         DOMTimerFireState::current-&gt;setScriptMadeNonUserObservableChanges();
279 }
280 
281 void DOMTimer::fired()
282 {
283     // Retain this - if the timer is cancelled while this function is on the stack (implicitly and always
284     // for one-shot timers, or if removeById is called on itself from within an interval timer fire) then
285     // wait unit the end of this function to delete DOMTimer.
286     Ref&lt;DOMTimer&gt; protectedThis(*this);
287 
288     ASSERT(scriptExecutionContext());
289     ScriptExecutionContext&amp; context = *scriptExecutionContext();
290 
291 #if PLATFORM(IOS_FAMILY)
292     if (is&lt;Document&gt;(context)) {
293         auto&amp; document = downcast&lt;Document&gt;(context);
294         if (auto* holdingTank = document.domTimerHoldingTankIfExists(); holdingTank &amp;&amp; holdingTank-&gt;contains(*this)) {
295             if (!repeatInterval())
296                 startOneShot(0_s);
297             return;
298         }
299     }
300 #endif
301 
302     DOMTimerFireState fireState(context, std::min(m_nestingLevel + 1, maxTimerNestingLevel));
303 
304     if (m_userGestureTokenToForward &amp;&amp; m_userGestureTokenToForward-&gt;hasExpired(maxIntervalForUserGestureForwarding))
305         m_userGestureTokenToForward = nullptr;
306 
307     ASSERT(!isSuspended());
308     ASSERT(!context.activeDOMObjectsAreSuspended());
309     UserGestureIndicator gestureIndicator(m_userGestureTokenToForward);
310     // Only the first execution of a multi-shot timer should get an affirmative user gesture indicator.
311     m_userGestureTokenToForward = nullptr;
312 
313     InspectorInstrumentation::willFireTimer(context, m_timeoutId, !repeatInterval());
314 
315     // Simple case for non-one-shot timers.
316     if (isActive()) {
317         if (m_nestingLevel &lt; maxTimerNestingLevel) {
318             m_nestingLevel++;
319             updateTimerIntervalIfNecessary();
320         }
321 
322         m_action-&gt;execute(context);
323 
324         InspectorInstrumentation::didFireTimer(context);
325 
326         updateThrottlingStateIfNecessary(fireState);
327         return;
328     }
329 
330     context.removeTimeout(m_timeoutId);
331 
332     // Keep track nested timer installs.
333     NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context);
334     if (nestedTimers)
335         nestedTimers-&gt;startTracking();
336 
337 #if PLATFORM(IOS_FAMILY)
338     ContentChangeObserver::DOMTimerScope observingScope(is&lt;Document&gt;(context) ? &amp;downcast&lt;Document&gt;(context) : nullptr, *this);
339 #endif
340     m_action-&gt;execute(context);
341 
342     InspectorInstrumentation::didFireTimer(context);
343 
344     // Check if we should throttle nested single-shot timers.
345     if (nestedTimers) {
346         for (auto&amp; idAndTimer : *nestedTimers) {
347             auto&amp; timer = idAndTimer.value;
348             if (timer-&gt;isActive() &amp;&amp; !timer-&gt;repeatInterval())
349                 timer-&gt;updateThrottlingStateIfNecessary(fireState);
350         }
351         nestedTimers-&gt;stopTracking();
352     }
353 }
354 
355 void DOMTimer::didStop()
356 {
357     // Need to release JS objects potentially protected by ScheduledAction
358     // because they can form circular references back to the ScriptExecutionContext
359     // which will cause a memory leak.
360     m_action = nullptr;
361 }
362 
363 void DOMTimer::updateTimerIntervalIfNecessary()
364 {
365     ASSERT(m_nestingLevel &lt;= maxTimerNestingLevel);
366 
367     auto previousInterval = m_currentTimerInterval;
368     m_currentTimerInterval = intervalClampedToMinimum();
369     if (previousInterval == m_currentTimerInterval)
370         return;
371 
372     if (repeatInterval()) {
373         ASSERT(repeatInterval() == previousInterval);
374         LOG(DOMTimers, &quot;%p - Updating DOMTimer&#39;s repeat interval from %.2f ms to %.2f ms due to throttling.&quot;, this, previousInterval.milliseconds(), m_currentTimerInterval.milliseconds());
375         augmentRepeatInterval(m_currentTimerInterval - previousInterval);
376     } else {
377         LOG(DOMTimers, &quot;%p - Updating DOMTimer&#39;s fire interval from %.2f ms to %.2f ms due to throttling.&quot;, this, previousInterval.milliseconds(), m_currentTimerInterval.milliseconds());
378         augmentFireInterval(m_currentTimerInterval - previousInterval);
379     }
380 }
381 
382 Seconds DOMTimer::intervalClampedToMinimum() const
383 {
384     ASSERT(scriptExecutionContext());
385     ASSERT(m_nestingLevel &lt;= maxTimerNestingLevel);
386 
387     Seconds interval = std::max(1_ms, m_originalInterval);
388 
389     // Only apply throttling to repeating timers.
390     if (m_nestingLevel &lt; maxTimerNestingLevel)
391         return interval;
392 
393     // Apply two throttles - the global (per Page) minimum, and also a per-timer throttle.
394     interval = std::max(interval, scriptExecutionContext()-&gt;minimumDOMTimerInterval());
395     if (m_throttleState == ShouldThrottle)
396         interval = std::max(interval, minIntervalForNonUserObservableChangeTimers);
397     return interval;
398 }
399 
400 Optional&lt;MonotonicTime&gt; DOMTimer::alignedFireTime(MonotonicTime fireTime) const
401 {
402     Seconds alignmentInterval = scriptExecutionContext()-&gt;domTimerAlignmentInterval(m_nestingLevel &gt;= maxTimerNestingLevel);
403     if (!alignmentInterval)
404         return WTF::nullopt;
405 
406     static const double randomizedProportion = randomNumber();
407 
408     // Force alignment to randomizedAlignment fraction of the way between alignemntIntervals, e.g.
409     // if alignmentInterval is 10_ms and randomizedAlignment is 0.3 this will align to 3, 13, 23, ...
410     Seconds randomizedOffset = alignmentInterval * randomizedProportion;
411     MonotonicTime adjustedFireTime = fireTime - randomizedOffset;
412     return adjustedFireTime - (adjustedFireTime % alignmentInterval) + alignmentInterval + randomizedOffset;
413 }
414 
415 const char* DOMTimer::activeDOMObjectName() const
416 {
417     return &quot;DOMTimer&quot;;
418 }
419 
420 } // namespace WebCore
    </pre>
  </body>
</html>
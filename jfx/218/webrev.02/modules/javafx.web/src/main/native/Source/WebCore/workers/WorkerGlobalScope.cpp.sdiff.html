<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WorkerDebuggerProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerGlobalScope.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;WorkerGlobalScope.h&quot;
 30 


 31 #include &quot;ContentSecurityPolicy.h&quot;
 32 #include &quot;Crypto.h&quot;
 33 #include &quot;IDBConnectionProxy.h&quot;
 34 #include &quot;ImageBitmapOptions.h&quot;
 35 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-removed"> 36 #include &quot;Microtasks.h&quot;</span>
 37 #include &quot;Performance.h&quot;
 38 #include &quot;RuntimeEnabledFeatures.h&quot;
 39 #include &quot;ScheduledAction.h&quot;
 40 #include &quot;ScriptSourceCode.h&quot;
 41 #include &quot;SecurityOrigin.h&quot;
 42 #include &quot;SecurityOriginPolicy.h&quot;
 43 #include &quot;ServiceWorkerGlobalScope.h&quot;
 44 #include &quot;SocketProvider.h&quot;

 45 #include &quot;WorkerInspectorController.h&quot;
 46 #include &quot;WorkerLoaderProxy.h&quot;
 47 #include &quot;WorkerLocation.h&quot;

 48 #include &quot;WorkerNavigator.h&quot;
 49 #include &quot;WorkerReportingProxy.h&quot;

 50 #include &quot;WorkerScriptLoader.h&quot;
 51 #include &quot;WorkerThread.h&quot;
 52 #include &lt;JavaScriptCore/ScriptArguments.h&gt;
 53 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 54 #include &lt;wtf/IsoMallocInlines.h&gt;
 55 
 56 namespace WebCore {
 57 using namespace Inspector;
 58 
 59 WTF_MAKE_ISO_ALLOCATED_IMPL(WorkerGlobalScope);
 60 
<span class="line-modified"> 61 WorkerGlobalScope::WorkerGlobalScope(const URL&amp; url, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, const String&amp; identifier, const String&amp; userAgent, bool isOnline, WorkerThread&amp; thread, bool shouldBypassMainWorldContentSecurityPolicy, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, PAL::SessionID sessionID)</span>
<span class="line-modified"> 62     : m_url(url)</span>
<span class="line-modified"> 63     , m_identifier(identifier)</span>
<span class="line-modified"> 64     , m_userAgent(userAgent)</span>
 65     , m_thread(thread)
 66     , m_script(makeUnique&lt;WorkerScriptController&gt;(this))
 67     , m_inspectorController(makeUnique&lt;WorkerInspectorController&gt;(*this))
<span class="line-modified"> 68     , m_microtaskQueue(makeUnique&lt;MicrotaskQueue&gt;(m_script-&gt;vm()))</span>
<span class="line-modified"> 69     , m_isOnline(isOnline)</span>
<span class="line-removed"> 70     , m_shouldBypassMainWorldContentSecurityPolicy(shouldBypassMainWorldContentSecurityPolicy)</span>
<span class="line-removed"> 71     , m_eventQueue(*this)</span>
 72     , m_topOrigin(WTFMove(topOrigin))
 73 #if ENABLE(INDEXED_DATABASE)
 74     , m_connectionProxy(connectionProxy)
 75 #endif
 76     , m_socketProvider(socketProvider)
<span class="line-modified"> 77     , m_performance(Performance::create(this, timeOrigin))</span>
<span class="line-modified"> 78     , m_sessionID(sessionID)</span>
 79 {
 80 #if !ENABLE(INDEXED_DATABASE)
 81     UNUSED_PARAM(connectionProxy);
 82 #endif
 83 
 84     if (m_topOrigin-&gt;hasUniversalAccess())
 85         origin-&gt;grantUniversalAccess();
 86     if (m_topOrigin-&gt;needsStorageAccessFromFileURLsQuirk())
 87         origin-&gt;grantStorageAccessFromFileURLsQuirk();
 88 
 89     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(origin)));
 90     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
 91 }
 92 
 93 WorkerGlobalScope::~WorkerGlobalScope()
 94 {
 95     ASSERT(thread().thread() == &amp;Thread::current());
 96     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this WorkerGlobalScope from another thread is safe.
 97     removeFromContextsMap();
 98 
 99     m_performance = nullptr;
100     m_crypto = nullptr;
101 
102     // Notify proxy that we are going away. This can free the WorkerThread object, so do not access it after this.
103     thread().workerReportingProxy().workerGlobalScopeDestroyed();
104 }
105 












106 String WorkerGlobalScope::origin() const
107 {
108     auto* securityOrigin = this-&gt;securityOrigin();
109     return securityOrigin ? securityOrigin-&gt;toString() : emptyString();
110 }
111 
112 void WorkerGlobalScope::prepareForTermination()
113 {
114 #if ENABLE(INDEXED_DATABASE)
115     stopIndexedDatabase();
116 #endif
117 


118     stopActiveDOMObjects();
119 
120     if (m_cacheStorageConnection)
121         m_cacheStorageConnection-&gt;clearPendingRequests();
122 
123     m_inspectorController-&gt;workerTerminating();
124 
125     // Event listeners would keep DOMWrapperWorld objects alive for too long. Also, they have references to JS objects,
126     // which become dangling once Heap is destroyed.
127     removeAllEventListeners();
128 
129     // MicrotaskQueue and RejectedPromiseTracker reference Heap.
<span class="line-modified">130     m_microtaskQueue = nullptr;</span>

131     removeRejectedPromiseTracker();
132 }
133 
134 void WorkerGlobalScope::removeAllEventListeners()
135 {
136     EventTarget::removeAllEventListeners();
137     m_performance-&gt;removeAllEventListeners();
138     m_performance-&gt;removeAllObservers();
139 }
140 
141 bool WorkerGlobalScope::isSecureContext() const
142 {
143     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
144         return true;
145 
146     return securityOrigin() &amp;&amp; securityOrigin()-&gt;isPotentiallyTrustworthy();
147 }
148 
149 void WorkerGlobalScope::applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders)
150 {
151     contentSecurityPolicy()-&gt;didReceiveHeaders(contentSecurityPolicyResponseHeaders, String { });
152 }
153 
<span class="line-modified">154 URL WorkerGlobalScope::completeURL(const String&amp; url) const</span>
155 {
156     // Always return a null URL when passed a null string.
157     // FIXME: Should we change the URL constructor to have this behavior?
158     if (url.isNull())
159         return URL();
160     // Always use UTF-8 in Workers.
161     return URL(m_url, url);
162 }
163 
164 String WorkerGlobalScope::userAgent(const URL&amp;) const
165 {
166     return m_userAgent;
167 }
168 
169 void WorkerGlobalScope::disableEval(const String&amp; errorMessage)
170 {
171     m_script-&gt;disableEval(errorMessage);
172 }
173 
174 void WorkerGlobalScope::disableWebAssembly(const String&amp; errorMessage)
</pre>
<hr />
<pre>
183 
184 #if ENABLE(INDEXED_DATABASE)
185 
186 IDBClient::IDBConnectionProxy* WorkerGlobalScope::idbConnectionProxy()
187 {
188 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
189     return m_connectionProxy.get();
190 #else
191     return nullptr;
192 #endif
193 }
194 
195 void WorkerGlobalScope::stopIndexedDatabase()
196 {
197 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
198     if (m_connectionProxy)
199         m_connectionProxy-&gt;forgetActivityForCurrentThread();
200 #endif
201 }
202 
















203 #endif // ENABLE(INDEXED_DATABASE)
204 
205 WorkerLocation&amp; WorkerGlobalScope::location() const
206 {
207     if (!m_location)
208         m_location = WorkerLocation::create(m_url);
209     return *m_location;
210 }
211 
212 void WorkerGlobalScope::close()
213 {
214     if (m_closing)
215         return;
216 
217     // Let current script run to completion but prevent future script evaluations.
218     // After m_closing is set, all the tasks in the queue continue to be fetched but only
219     // tasks with isCleanupTask()==true will be executed.
220     m_closing = true;
221     postTask({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context) {
222         ASSERT_WITH_SECURITY_IMPLICATION(is&lt;WorkerGlobalScope&gt;(context));
</pre>
<hr />
<pre>
228 
229 WorkerNavigator&amp; WorkerGlobalScope::navigator()
230 {
231     if (!m_navigator)
232         m_navigator = WorkerNavigator::create(*this, m_userAgent, m_isOnline);
233     return *m_navigator;
234 }
235 
236 void WorkerGlobalScope::setIsOnline(bool isOnline)
237 {
238     m_isOnline = isOnline;
239     if (m_navigator)
240         m_navigator-&gt;setIsOnline(isOnline);
241 }
242 
243 void WorkerGlobalScope::postTask(Task&amp;&amp; task)
244 {
245     thread().runLoop().postTask(WTFMove(task));
246 }
247 
<span class="line-modified">248 ExceptionOr&lt;int&gt; WorkerGlobalScope::setTimeout(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
249 {
250     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
251     if (action-&gt;type() == ScheduledAction::Type::Code) {
252         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
253             return 0;
254     }
255 
256     action-&gt;addArguments(WTFMove(arguments));
257 
258     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
259 }
260 
261 void WorkerGlobalScope::clearTimeout(int timeoutId)
262 {
263     DOMTimer::removeById(*this, timeoutId);
264 }
265 
<span class="line-modified">266 ExceptionOr&lt;int&gt; WorkerGlobalScope::setInterval(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
267 {
268     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
269     if (action-&gt;type() == ScheduledAction::Type::Code) {
270         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
271             return 0;
272     }
273 
274     action-&gt;addArguments(WTFMove(arguments));
275 
276     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
277 }
278 
279 void WorkerGlobalScope::clearInterval(int timeoutId)
280 {
281     DOMTimer::removeById(*this, timeoutId);
282 }
283 
284 ExceptionOr&lt;void&gt; WorkerGlobalScope::importScripts(const Vector&lt;String&gt;&amp; urls)
285 {
286     ASSERT(contentSecurityPolicy());
</pre>
<hr />
<pre>
340 void WorkerGlobalScope::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp;)
341 {
342     thread().workerReportingProxy().postExceptionToWorkerObject(errorMessage, lineNumber, columnNumber, sourceURL);
343 }
344 
345 void WorkerGlobalScope::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; message)
346 {
347     if (!isContextThread()) {
348         postTask(AddConsoleMessageTask(message-&gt;source(), message-&gt;level(), message-&gt;message()));
349         return;
350     }
351 
352     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
353 }
354 
355 void WorkerGlobalScope::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
356 {
357     addMessage(source, level, message, { }, 0, 0, nullptr, nullptr, requestIdentifier);
358 }
359 
<span class="line-modified">360 void WorkerGlobalScope::addMessage(MessageSource source, MessageLevel level, const String&amp; messageText, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)</span>
361 {
362     if (!isContextThread()) {
363         postTask(AddConsoleMessageTask(source, level, messageText));
364         return;
365     }
366 
367     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
368     if (callStack)
369         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, callStack.releaseNonNull(), requestIdentifier);
370     else
371         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, sourceURL, lineNumber, columnNumber, state, requestIdentifier);
372     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
373 }
374 
375 bool WorkerGlobalScope::isContextThread() const
376 {
377     return thread().thread() == &amp;Thread::current();
378 }
379 
380 bool WorkerGlobalScope::isJSExecutionForbidden() const
381 {
382     return m_script-&gt;isExecutionForbidden();
383 }
384 
<span class="line-removed">385 WorkerEventQueue&amp; WorkerGlobalScope::eventQueue() const</span>
<span class="line-removed">386 {</span>
<span class="line-removed">387     return m_eventQueue;</span>
<span class="line-removed">388 }</span>
<span class="line-removed">389 </span>
390 #if ENABLE(WEB_CRYPTO)
391 
392 class CryptoBufferContainer : public ThreadSafeRefCounted&lt;CryptoBufferContainer&gt; {
393 public:
394     static Ref&lt;CryptoBufferContainer&gt; create() { return adoptRef(*new CryptoBufferContainer); }
395     Vector&lt;uint8_t&gt;&amp; buffer() { return m_buffer; }
396 
397 private:
398     Vector&lt;uint8_t&gt; m_buffer;
399 };
400 










401 bool WorkerGlobalScope::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
402 {
<span class="line-modified">403     bool result = false;</span>
<span class="line-modified">404     std::atomic&lt;bool&gt; done = false;</span>
<span class="line-modified">405     auto container = CryptoBufferContainer::create();</span>
<span class="line-modified">406     m_thread.workerLoaderProxy().postTaskToLoader([&amp;result, key, containerRef = container.copyRef(), &amp;done, workerGlobalScope = this](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">407         result = context.wrapCryptoKey(key, containerRef-&gt;buffer());</span>
<span class="line-modified">408         done = true;</span>
<span class="line-modified">409         workerGlobalScope-&gt;postTask([](ScriptExecutionContext&amp; context) {</span>

410             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
<span class="line-modified">411         });</span>
412     });
413 
414     auto waitResult = MessageQueueMessageReceived;
<span class="line-modified">415     while (!done &amp;&amp; waitResult != MessageQueueTerminated)</span>
416         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
417 
<span class="line-modified">418     if (done)</span>
<span class="line-modified">419         wrappedKey.swap(container-&gt;buffer());</span>
<span class="line-modified">420     return result;</span>
421 }
422 
423 bool WorkerGlobalScope::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
424 {
<span class="line-modified">425     bool result = false;</span>
<span class="line-modified">426     std::atomic&lt;bool&gt; done = false;</span>
<span class="line-modified">427     auto container = CryptoBufferContainer::create();</span>
<span class="line-modified">428     m_thread.workerLoaderProxy().postTaskToLoader([&amp;result, wrappedKey, containerRef = container.copyRef(), &amp;done, workerGlobalScope = this](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">429         result = context.unwrapCryptoKey(wrappedKey, containerRef-&gt;buffer());</span>
<span class="line-modified">430         done = true;</span>
<span class="line-modified">431         workerGlobalScope-&gt;postTask([](ScriptExecutionContext&amp; context) {</span>

432             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
<span class="line-modified">433         });</span>
434     });
435 
436     auto waitResult = MessageQueueMessageReceived;
<span class="line-modified">437     while (!done &amp;&amp; waitResult != MessageQueueTerminated)</span>
438         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
439 
<span class="line-modified">440     if (done)</span>
<span class="line-modified">441         key.swap(container-&gt;buffer());</span>
<span class="line-modified">442     return result;</span>
443 }
444 
445 #endif // ENABLE(WEB_CRYPTO)
446 
447 Crypto&amp; WorkerGlobalScope::crypto()
448 {
449     if (!m_crypto)
450         m_crypto = Crypto::create(this);
451     return *m_crypto;
452 }
453 
454 Performance&amp; WorkerGlobalScope::performance() const
455 {
456     return *m_performance;
457 }
458 
459 WorkerCacheStorageConnection&amp; WorkerGlobalScope::cacheStorageConnection()
460 {
461     if (!m_cacheStorageConnection)
462         m_cacheStorageConnection = WorkerCacheStorageConnection::create(*this);
463     return *m_cacheStorageConnection;
464 }
465 
















466 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
467 {
468     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), WTFMove(promise));
469 }
470 
471 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
472 {
473     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
474 }
475 












476 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;WorkerGlobalScope.h&quot;
 30 
<span class="line-added"> 31 #include &quot;CSSValueList.h&quot;</span>
<span class="line-added"> 32 #include &quot;CSSValuePool.h&quot;</span>
 33 #include &quot;ContentSecurityPolicy.h&quot;
 34 #include &quot;Crypto.h&quot;
 35 #include &quot;IDBConnectionProxy.h&quot;
 36 #include &quot;ImageBitmapOptions.h&quot;
 37 #include &quot;InspectorInstrumentation.h&quot;

 38 #include &quot;Performance.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;ScheduledAction.h&quot;
 41 #include &quot;ScriptSourceCode.h&quot;
 42 #include &quot;SecurityOrigin.h&quot;
 43 #include &quot;SecurityOriginPolicy.h&quot;
 44 #include &quot;ServiceWorkerGlobalScope.h&quot;
 45 #include &quot;SocketProvider.h&quot;
<span class="line-added"> 46 #include &quot;WorkerEventLoop.h&quot;</span>
 47 #include &quot;WorkerInspectorController.h&quot;
 48 #include &quot;WorkerLoaderProxy.h&quot;
 49 #include &quot;WorkerLocation.h&quot;
<span class="line-added"> 50 #include &quot;WorkerMessagingProxy.h&quot;</span>
 51 #include &quot;WorkerNavigator.h&quot;
 52 #include &quot;WorkerReportingProxy.h&quot;
<span class="line-added"> 53 #include &quot;WorkerSWClientConnection.h&quot;</span>
 54 #include &quot;WorkerScriptLoader.h&quot;
 55 #include &quot;WorkerThread.h&quot;
 56 #include &lt;JavaScriptCore/ScriptArguments.h&gt;
 57 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 
 60 namespace WebCore {
 61 using namespace Inspector;
 62 
 63 WTF_MAKE_ISO_ALLOCATED_IMPL(WorkerGlobalScope);
 64 
<span class="line-modified"> 65 WorkerGlobalScope::WorkerGlobalScope(const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, WorkerThread&amp; thread, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)</span>
<span class="line-modified"> 66     : m_url(params.scriptURL)</span>
<span class="line-modified"> 67     , m_identifier(params.identifier)</span>
<span class="line-modified"> 68     , m_userAgent(params.userAgent)</span>
 69     , m_thread(thread)
 70     , m_script(makeUnique&lt;WorkerScriptController&gt;(this))
 71     , m_inspectorController(makeUnique&lt;WorkerInspectorController&gt;(*this))
<span class="line-modified"> 72     , m_isOnline(params.isOnline)</span>
<span class="line-modified"> 73     , m_shouldBypassMainWorldContentSecurityPolicy(params.shouldBypassMainWorldContentSecurityPolicy)</span>


 74     , m_topOrigin(WTFMove(topOrigin))
 75 #if ENABLE(INDEXED_DATABASE)
 76     , m_connectionProxy(connectionProxy)
 77 #endif
 78     , m_socketProvider(socketProvider)
<span class="line-modified"> 79     , m_performance(Performance::create(this, params.timeOrigin))</span>
<span class="line-modified"> 80     , m_referrerPolicy(params.referrerPolicy)</span>
 81 {
 82 #if !ENABLE(INDEXED_DATABASE)
 83     UNUSED_PARAM(connectionProxy);
 84 #endif
 85 
 86     if (m_topOrigin-&gt;hasUniversalAccess())
 87         origin-&gt;grantUniversalAccess();
 88     if (m_topOrigin-&gt;needsStorageAccessFromFileURLsQuirk())
 89         origin-&gt;grantStorageAccessFromFileURLsQuirk();
 90 
 91     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(origin)));
 92     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
 93 }
 94 
 95 WorkerGlobalScope::~WorkerGlobalScope()
 96 {
 97     ASSERT(thread().thread() == &amp;Thread::current());
 98     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this WorkerGlobalScope from another thread is safe.
 99     removeFromContextsMap();
100 
101     m_performance = nullptr;
102     m_crypto = nullptr;
103 
104     // Notify proxy that we are going away. This can free the WorkerThread object, so do not access it after this.
105     thread().workerReportingProxy().workerGlobalScopeDestroyed();
106 }
107 
<span class="line-added">108 EventLoopTaskGroup&amp; WorkerGlobalScope::eventLoop()</span>
<span class="line-added">109 {</span>
<span class="line-added">110     ASSERT(isContextThread());</span>
<span class="line-added">111     if (UNLIKELY(!m_defaultTaskGroup)) {</span>
<span class="line-added">112         m_eventLoop = WorkerEventLoop::create(*this);</span>
<span class="line-added">113         m_defaultTaskGroup = makeUnique&lt;EventLoopTaskGroup&gt;(*m_eventLoop);</span>
<span class="line-added">114         if (activeDOMObjectsAreStopped())</span>
<span class="line-added">115             m_defaultTaskGroup-&gt;stopAndDiscardAllTasks();</span>
<span class="line-added">116     }</span>
<span class="line-added">117     return *m_defaultTaskGroup;</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
120 String WorkerGlobalScope::origin() const
121 {
122     auto* securityOrigin = this-&gt;securityOrigin();
123     return securityOrigin ? securityOrigin-&gt;toString() : emptyString();
124 }
125 
126 void WorkerGlobalScope::prepareForTermination()
127 {
128 #if ENABLE(INDEXED_DATABASE)
129     stopIndexedDatabase();
130 #endif
131 
<span class="line-added">132     if (m_defaultTaskGroup)</span>
<span class="line-added">133         m_defaultTaskGroup-&gt;stopAndDiscardAllTasks();</span>
134     stopActiveDOMObjects();
135 
136     if (m_cacheStorageConnection)
137         m_cacheStorageConnection-&gt;clearPendingRequests();
138 
139     m_inspectorController-&gt;workerTerminating();
140 
141     // Event listeners would keep DOMWrapperWorld objects alive for too long. Also, they have references to JS objects,
142     // which become dangling once Heap is destroyed.
143     removeAllEventListeners();
144 
145     // MicrotaskQueue and RejectedPromiseTracker reference Heap.
<span class="line-modified">146     if (m_eventLoop)</span>
<span class="line-added">147         m_eventLoop-&gt;clearMicrotaskQueue();</span>
148     removeRejectedPromiseTracker();
149 }
150 
151 void WorkerGlobalScope::removeAllEventListeners()
152 {
153     EventTarget::removeAllEventListeners();
154     m_performance-&gt;removeAllEventListeners();
155     m_performance-&gt;removeAllObservers();
156 }
157 
158 bool WorkerGlobalScope::isSecureContext() const
159 {
160     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
161         return true;
162 
163     return securityOrigin() &amp;&amp; securityOrigin()-&gt;isPotentiallyTrustworthy();
164 }
165 
166 void WorkerGlobalScope::applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders)
167 {
168     contentSecurityPolicy()-&gt;didReceiveHeaders(contentSecurityPolicyResponseHeaders, String { });
169 }
170 
<span class="line-modified">171 URL WorkerGlobalScope::completeURL(const String&amp; url, ForceUTF8) const</span>
172 {
173     // Always return a null URL when passed a null string.
174     // FIXME: Should we change the URL constructor to have this behavior?
175     if (url.isNull())
176         return URL();
177     // Always use UTF-8 in Workers.
178     return URL(m_url, url);
179 }
180 
181 String WorkerGlobalScope::userAgent(const URL&amp;) const
182 {
183     return m_userAgent;
184 }
185 
186 void WorkerGlobalScope::disableEval(const String&amp; errorMessage)
187 {
188     m_script-&gt;disableEval(errorMessage);
189 }
190 
191 void WorkerGlobalScope::disableWebAssembly(const String&amp; errorMessage)
</pre>
<hr />
<pre>
200 
201 #if ENABLE(INDEXED_DATABASE)
202 
203 IDBClient::IDBConnectionProxy* WorkerGlobalScope::idbConnectionProxy()
204 {
205 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
206     return m_connectionProxy.get();
207 #else
208     return nullptr;
209 #endif
210 }
211 
212 void WorkerGlobalScope::stopIndexedDatabase()
213 {
214 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
215     if (m_connectionProxy)
216         m_connectionProxy-&gt;forgetActivityForCurrentThread();
217 #endif
218 }
219 
<span class="line-added">220 void WorkerGlobalScope::suspend()</span>
<span class="line-added">221 {</span>
<span class="line-added">222 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)</span>
<span class="line-added">223     if (m_connectionProxy)</span>
<span class="line-added">224         m_connectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), true);</span>
<span class="line-added">225 #endif</span>
<span class="line-added">226 }</span>
<span class="line-added">227 </span>
<span class="line-added">228 void WorkerGlobalScope::resume()</span>
<span class="line-added">229 {</span>
<span class="line-added">230 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)</span>
<span class="line-added">231     if (m_connectionProxy)</span>
<span class="line-added">232         m_connectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), false);</span>
<span class="line-added">233 #endif</span>
<span class="line-added">234 }</span>
<span class="line-added">235 </span>
236 #endif // ENABLE(INDEXED_DATABASE)
237 
238 WorkerLocation&amp; WorkerGlobalScope::location() const
239 {
240     if (!m_location)
241         m_location = WorkerLocation::create(m_url);
242     return *m_location;
243 }
244 
245 void WorkerGlobalScope::close()
246 {
247     if (m_closing)
248         return;
249 
250     // Let current script run to completion but prevent future script evaluations.
251     // After m_closing is set, all the tasks in the queue continue to be fetched but only
252     // tasks with isCleanupTask()==true will be executed.
253     m_closing = true;
254     postTask({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context) {
255         ASSERT_WITH_SECURITY_IMPLICATION(is&lt;WorkerGlobalScope&gt;(context));
</pre>
<hr />
<pre>
261 
262 WorkerNavigator&amp; WorkerGlobalScope::navigator()
263 {
264     if (!m_navigator)
265         m_navigator = WorkerNavigator::create(*this, m_userAgent, m_isOnline);
266     return *m_navigator;
267 }
268 
269 void WorkerGlobalScope::setIsOnline(bool isOnline)
270 {
271     m_isOnline = isOnline;
272     if (m_navigator)
273         m_navigator-&gt;setIsOnline(isOnline);
274 }
275 
276 void WorkerGlobalScope::postTask(Task&amp;&amp; task)
277 {
278     thread().runLoop().postTask(WTFMove(task));
279 }
280 
<span class="line-modified">281 ExceptionOr&lt;int&gt; WorkerGlobalScope::setTimeout(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
282 {
283     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
284     if (action-&gt;type() == ScheduledAction::Type::Code) {
285         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
286             return 0;
287     }
288 
289     action-&gt;addArguments(WTFMove(arguments));
290 
291     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
292 }
293 
294 void WorkerGlobalScope::clearTimeout(int timeoutId)
295 {
296     DOMTimer::removeById(*this, timeoutId);
297 }
298 
<span class="line-modified">299 ExceptionOr&lt;int&gt; WorkerGlobalScope::setInterval(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
300 {
301     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
302     if (action-&gt;type() == ScheduledAction::Type::Code) {
303         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
304             return 0;
305     }
306 
307     action-&gt;addArguments(WTFMove(arguments));
308 
309     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
310 }
311 
312 void WorkerGlobalScope::clearInterval(int timeoutId)
313 {
314     DOMTimer::removeById(*this, timeoutId);
315 }
316 
317 ExceptionOr&lt;void&gt; WorkerGlobalScope::importScripts(const Vector&lt;String&gt;&amp; urls)
318 {
319     ASSERT(contentSecurityPolicy());
</pre>
<hr />
<pre>
373 void WorkerGlobalScope::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp;)
374 {
375     thread().workerReportingProxy().postExceptionToWorkerObject(errorMessage, lineNumber, columnNumber, sourceURL);
376 }
377 
378 void WorkerGlobalScope::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; message)
379 {
380     if (!isContextThread()) {
381         postTask(AddConsoleMessageTask(message-&gt;source(), message-&gt;level(), message-&gt;message()));
382         return;
383     }
384 
385     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
386 }
387 
388 void WorkerGlobalScope::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
389 {
390     addMessage(source, level, message, { }, 0, 0, nullptr, nullptr, requestIdentifier);
391 }
392 
<span class="line-modified">393 void WorkerGlobalScope::addMessage(MessageSource source, MessageLevel level, const String&amp; messageText, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)</span>
394 {
395     if (!isContextThread()) {
396         postTask(AddConsoleMessageTask(source, level, messageText));
397         return;
398     }
399 
400     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
401     if (callStack)
402         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, callStack.releaseNonNull(), requestIdentifier);
403     else
404         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, sourceURL, lineNumber, columnNumber, state, requestIdentifier);
405     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
406 }
407 
408 bool WorkerGlobalScope::isContextThread() const
409 {
410     return thread().thread() == &amp;Thread::current();
411 }
412 
413 bool WorkerGlobalScope::isJSExecutionForbidden() const
414 {
415     return m_script-&gt;isExecutionForbidden();
416 }
417 





418 #if ENABLE(WEB_CRYPTO)
419 
420 class CryptoBufferContainer : public ThreadSafeRefCounted&lt;CryptoBufferContainer&gt; {
421 public:
422     static Ref&lt;CryptoBufferContainer&gt; create() { return adoptRef(*new CryptoBufferContainer); }
423     Vector&lt;uint8_t&gt;&amp; buffer() { return m_buffer; }
424 
425 private:
426     Vector&lt;uint8_t&gt; m_buffer;
427 };
428 
<span class="line-added">429 class CryptoBooleanContainer : public ThreadSafeRefCounted&lt;CryptoBooleanContainer&gt; {</span>
<span class="line-added">430 public:</span>
<span class="line-added">431     static Ref&lt;CryptoBooleanContainer&gt; create() { return adoptRef(*new CryptoBooleanContainer); }</span>
<span class="line-added">432     bool boolean() const { return m_boolean; }</span>
<span class="line-added">433     void setBoolean(bool boolean) { m_boolean = boolean; }</span>
<span class="line-added">434 </span>
<span class="line-added">435 private:</span>
<span class="line-added">436     std::atomic&lt;bool&gt; m_boolean { false };</span>
<span class="line-added">437 };</span>
<span class="line-added">438 </span>
439 bool WorkerGlobalScope::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
440 {
<span class="line-modified">441     Ref&lt;WorkerGlobalScope&gt; protectedThis(*this);</span>
<span class="line-modified">442     auto resultContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">443     auto doneContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">444     auto wrappedKeyContainer = CryptoBufferContainer::create();</span>
<span class="line-modified">445     m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), key, wrappedKeyContainer = wrappedKeyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast&lt;WorkerMessagingProxy&gt;(m_thread.workerLoaderProxy()))](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">446         resultContainer-&gt;setBoolean(context.wrapCryptoKey(key, wrappedKeyContainer-&gt;buffer()));</span>
<span class="line-modified">447         doneContainer-&gt;setBoolean(true);</span>
<span class="line-added">448         workerMessagingProxy-&gt;postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext&amp; context) {</span>
449             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
<span class="line-modified">450         }, WorkerRunLoop::defaultMode());</span>
451     });
452 
453     auto waitResult = MessageQueueMessageReceived;
<span class="line-modified">454     while (!doneContainer-&gt;boolean() &amp;&amp; waitResult != MessageQueueTerminated)</span>
455         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
456 
<span class="line-modified">457     if (doneContainer-&gt;boolean())</span>
<span class="line-modified">458         wrappedKey.swap(wrappedKeyContainer-&gt;buffer());</span>
<span class="line-modified">459     return resultContainer-&gt;boolean();</span>
460 }
461 
462 bool WorkerGlobalScope::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
463 {
<span class="line-modified">464     Ref&lt;WorkerGlobalScope&gt; protectedThis(*this);</span>
<span class="line-modified">465     auto resultContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">466     auto doneContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">467     auto keyContainer = CryptoBufferContainer::create();</span>
<span class="line-modified">468     m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), wrappedKey, keyContainer = keyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast&lt;WorkerMessagingProxy&gt;(m_thread.workerLoaderProxy()))](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">469         resultContainer-&gt;setBoolean(context.unwrapCryptoKey(wrappedKey, keyContainer-&gt;buffer()));</span>
<span class="line-modified">470         doneContainer-&gt;setBoolean(true);</span>
<span class="line-added">471         workerMessagingProxy-&gt;postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext&amp; context) {</span>
472             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
<span class="line-modified">473         }, WorkerRunLoop::defaultMode());</span>
474     });
475 
476     auto waitResult = MessageQueueMessageReceived;
<span class="line-modified">477     while (!doneContainer-&gt;boolean() &amp;&amp; waitResult != MessageQueueTerminated)</span>
478         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
479 
<span class="line-modified">480     if (doneContainer-&gt;boolean())</span>
<span class="line-modified">481         key.swap(keyContainer-&gt;buffer());</span>
<span class="line-modified">482     return resultContainer-&gt;boolean();</span>
483 }
484 
485 #endif // ENABLE(WEB_CRYPTO)
486 
487 Crypto&amp; WorkerGlobalScope::crypto()
488 {
489     if (!m_crypto)
490         m_crypto = Crypto::create(this);
491     return *m_crypto;
492 }
493 
494 Performance&amp; WorkerGlobalScope::performance() const
495 {
496     return *m_performance;
497 }
498 
499 WorkerCacheStorageConnection&amp; WorkerGlobalScope::cacheStorageConnection()
500 {
501     if (!m_cacheStorageConnection)
502         m_cacheStorageConnection = WorkerCacheStorageConnection::create(*this);
503     return *m_cacheStorageConnection;
504 }
505 
<span class="line-added">506 MessagePortChannelProvider&amp; WorkerGlobalScope::messagePortChannelProvider()</span>
<span class="line-added">507 {</span>
<span class="line-added">508     if (!m_messagePortChannelProvider)</span>
<span class="line-added">509         m_messagePortChannelProvider = makeUnique&lt;WorkerMessagePortChannelProvider&gt;(*this);</span>
<span class="line-added">510     return *m_messagePortChannelProvider;</span>
<span class="line-added">511 }</span>
<span class="line-added">512 </span>
<span class="line-added">513 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">514 WorkerSWClientConnection&amp; WorkerGlobalScope::swClientConnection()</span>
<span class="line-added">515 {</span>
<span class="line-added">516     if (!m_swClientConnection)</span>
<span class="line-added">517         m_swClientConnection = WorkerSWClientConnection::create(*this);</span>
<span class="line-added">518     return *m_swClientConnection;</span>
<span class="line-added">519 }</span>
<span class="line-added">520 #endif</span>
<span class="line-added">521 </span>
522 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
523 {
524     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), WTFMove(promise));
525 }
526 
527 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
528 {
529     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
530 }
531 
<span class="line-added">532 CSSValuePool&amp; WorkerGlobalScope::cssValuePool()</span>
<span class="line-added">533 {</span>
<span class="line-added">534     if (!m_cssValuePool)</span>
<span class="line-added">535         m_cssValuePool = makeUnique&lt;CSSValuePool&gt;();</span>
<span class="line-added">536     return *m_cssValuePool;</span>
<span class="line-added">537 }</span>
<span class="line-added">538 </span>
<span class="line-added">539 ReferrerPolicy WorkerGlobalScope::referrerPolicy() const</span>
<span class="line-added">540 {</span>
<span class="line-added">541     return m_referrerPolicy;</span>
<span class="line-added">542 }</span>
<span class="line-added">543 </span>
544 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="WorkerDebuggerProxy.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerGlobalScope.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
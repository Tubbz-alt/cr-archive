<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSLock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSLexicalEnvironment.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSLock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSLock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 #include &lt;wtf/threads/Signals.h&gt;
 37 
 38 #if USE(WEB_THREAD)
 39 #include &lt;wtf/ios/WebCoreThread.h&gt;
 40 #endif
 41 
 42 namespace JSC {
 43 
 44 Lock GlobalJSLock::s_sharedInstanceMutex;
 45 
 46 GlobalJSLock::GlobalJSLock()
 47 {
 48     s_sharedInstanceMutex.lock();
 49 }
 50 
 51 GlobalJSLock::~GlobalJSLock()
 52 {
 53     s_sharedInstanceMutex.unlock();
 54 }
 55 
<span class="line-modified"> 56 JSLockHolder::JSLockHolder(ExecState* exec)</span>
<span class="line-modified"> 57     : JSLockHolder(exec-&gt;vm())</span>
 58 {
 59 }
 60 
 61 JSLockHolder::JSLockHolder(VM* vm)
 62     : JSLockHolder(*vm)
 63 {
 64 }
 65 
 66 JSLockHolder::JSLockHolder(VM&amp; vm)
 67     : m_vm(&amp;vm)
 68 {
 69     m_vm-&gt;apiLock().lock();
 70 }
 71 
 72 JSLockHolder::~JSLockHolder()
 73 {
 74     RefPtr&lt;JSLock&gt; apiLock(&amp;m_vm-&gt;apiLock());
 75     m_vm = nullptr;
 76     apiLock-&gt;unlock();
 77 }
</pre>
<hr />
<pre>
187     RELEASE_ASSERT(currentThreadIsHoldingLock());
188     ASSERT(m_lockCount &gt;= unlockCount);
189 
190     // Maintain m_lockCount while calling willReleaseLock() so that its callees know that
191     // they still have the lock.
192     if (unlockCount == m_lockCount)
193         willReleaseLock();
194 
195     m_lockCount -= unlockCount;
196 
197     if (!m_lockCount) {
198         m_hasOwnerThread = false;
199         m_lock.unlock();
200     }
201 }
202 
203 void JSLock::willReleaseLock()
204 {
205     RefPtr&lt;VM&gt; vm = m_vm;
206     if (vm) {

207         vm-&gt;drainMicrotasks();
208 
209         if (!vm-&gt;topCallFrame)
210             vm-&gt;clearLastException();
211 
212         vm-&gt;heap.releaseDelayedReleasedObjects();
213         vm-&gt;setStackPointerAtVMEntry(nullptr);
214 
215         if (m_shouldReleaseHeapAccess)
216             vm-&gt;heap.releaseAccess();
217     }
218 
219     if (m_entryAtomStringTable) {
220         Thread::current().setCurrentAtomStringTable(m_entryAtomStringTable);
221         m_entryAtomStringTable = nullptr;
222     }
223 }
224 
<span class="line-modified">225 void JSLock::lock(ExecState* exec)</span>
226 {
<span class="line-modified">227     exec-&gt;vm().apiLock().lock();</span>
228 }
229 
<span class="line-modified">230 void JSLock::unlock(ExecState* exec)</span>
231 {
<span class="line-modified">232     exec-&gt;vm().apiLock().unlock();</span>
233 }
234 
235 // This function returns the number of locks that were dropped.
236 unsigned JSLock::dropAllLocks(DropAllLocks* dropper)
237 {
238     if (!currentThreadIsHoldingLock())
239         return 0;
240 
241     ++m_lockDropDepth;
242 
243     dropper-&gt;setDropDepth(m_lockDropDepth);
244 
245     Thread&amp; thread = Thread::current();
246     thread.setSavedStackPointerAtVMEntry(m_vm-&gt;stackPointerAtVMEntry());
247     thread.setSavedLastStackTop(m_vm-&gt;lastStackTop());
248 
249     unsigned droppedLockCount = m_lockCount;
250     unlock(droppedLockCount);
251 
252     return droppedLockCount;
</pre>
<hr />
<pre>
262     lock(droppedLockCount);
263 
264     while (dropper-&gt;dropDepth() != m_lockDropDepth) {
265         unlock(droppedLockCount);
266         Thread::yield();
267         lock(droppedLockCount);
268     }
269 
270     --m_lockDropDepth;
271 
272     Thread&amp; thread = Thread::current();
273     m_vm-&gt;setStackPointerAtVMEntry(thread.savedStackPointerAtVMEntry());
274     m_vm-&gt;setLastStackTop(thread.savedLastStackTop());
275 }
276 
277 JSLock::DropAllLocks::DropAllLocks(VM* vm)
278     : m_droppedLockCount(0)
279     // If the VM is in the middle of being destroyed then we don&#39;t want to resurrect it
280     // by allowing DropAllLocks to ref it. By this point the JSLock has already been
281     // released anyways, so it doesn&#39;t matter that DropAllLocks is a no-op.
<span class="line-modified">282     , m_vm(vm-&gt;refCount() ? vm : nullptr)</span>
283 {
284     if (!m_vm)
285         return;
286     RELEASE_ASSERT(!m_vm-&gt;apiLock().currentThreadIsHoldingLock() || !m_vm-&gt;isCollectorBusyOnCurrentThread());
287     m_droppedLockCount = m_vm-&gt;apiLock().dropAllLocks(this);
288 }
289 
<span class="line-modified">290 JSLock::DropAllLocks::DropAllLocks(ExecState* exec)</span>
<span class="line-modified">291     : DropAllLocks(exec ? &amp;exec-&gt;vm() : nullptr)</span>
292 {
293 }
294 
295 JSLock::DropAllLocks::DropAllLocks(VM&amp; vm)
296     : DropAllLocks(&amp;vm)
297 {
298 }
299 
300 JSLock::DropAllLocks::~DropAllLocks()
301 {
302     if (!m_vm)
303         return;
304     m_vm-&gt;apiLock().grabAllLocks(this, m_droppedLockCount);
305 }
306 
307 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 36 #include &lt;wtf/threads/Signals.h&gt;
 37 
 38 #if USE(WEB_THREAD)
 39 #include &lt;wtf/ios/WebCoreThread.h&gt;
 40 #endif
 41 
 42 namespace JSC {
 43 
 44 Lock GlobalJSLock::s_sharedInstanceMutex;
 45 
 46 GlobalJSLock::GlobalJSLock()
 47 {
 48     s_sharedInstanceMutex.lock();
 49 }
 50 
 51 GlobalJSLock::~GlobalJSLock()
 52 {
 53     s_sharedInstanceMutex.unlock();
 54 }
 55 
<span class="line-modified"> 56 JSLockHolder::JSLockHolder(JSGlobalObject* globalObject)</span>
<span class="line-modified"> 57     : JSLockHolder(globalObject-&gt;vm())</span>
 58 {
 59 }
 60 
 61 JSLockHolder::JSLockHolder(VM* vm)
 62     : JSLockHolder(*vm)
 63 {
 64 }
 65 
 66 JSLockHolder::JSLockHolder(VM&amp; vm)
 67     : m_vm(&amp;vm)
 68 {
 69     m_vm-&gt;apiLock().lock();
 70 }
 71 
 72 JSLockHolder::~JSLockHolder()
 73 {
 74     RefPtr&lt;JSLock&gt; apiLock(&amp;m_vm-&gt;apiLock());
 75     m_vm = nullptr;
 76     apiLock-&gt;unlock();
 77 }
</pre>
<hr />
<pre>
187     RELEASE_ASSERT(currentThreadIsHoldingLock());
188     ASSERT(m_lockCount &gt;= unlockCount);
189 
190     // Maintain m_lockCount while calling willReleaseLock() so that its callees know that
191     // they still have the lock.
192     if (unlockCount == m_lockCount)
193         willReleaseLock();
194 
195     m_lockCount -= unlockCount;
196 
197     if (!m_lockCount) {
198         m_hasOwnerThread = false;
199         m_lock.unlock();
200     }
201 }
202 
203 void JSLock::willReleaseLock()
204 {
205     RefPtr&lt;VM&gt; vm = m_vm;
206     if (vm) {
<span class="line-added">207         RELEASE_ASSERT_WITH_MESSAGE(!vm-&gt;hasCheckpointOSRSideState(), &quot;Releasing JSLock but pending checkpoint side state still available&quot;);</span>
208         vm-&gt;drainMicrotasks();
209 
210         if (!vm-&gt;topCallFrame)
211             vm-&gt;clearLastException();
212 
213         vm-&gt;heap.releaseDelayedReleasedObjects();
214         vm-&gt;setStackPointerAtVMEntry(nullptr);
215 
216         if (m_shouldReleaseHeapAccess)
217             vm-&gt;heap.releaseAccess();
218     }
219 
220     if (m_entryAtomStringTable) {
221         Thread::current().setCurrentAtomStringTable(m_entryAtomStringTable);
222         m_entryAtomStringTable = nullptr;
223     }
224 }
225 
<span class="line-modified">226 void JSLock::lock(JSGlobalObject* globalObject)</span>
227 {
<span class="line-modified">228     globalObject-&gt;vm().apiLock().lock();</span>
229 }
230 
<span class="line-modified">231 void JSLock::unlock(JSGlobalObject* globalObject)</span>
232 {
<span class="line-modified">233     globalObject-&gt;vm().apiLock().unlock();</span>
234 }
235 
236 // This function returns the number of locks that were dropped.
237 unsigned JSLock::dropAllLocks(DropAllLocks* dropper)
238 {
239     if (!currentThreadIsHoldingLock())
240         return 0;
241 
242     ++m_lockDropDepth;
243 
244     dropper-&gt;setDropDepth(m_lockDropDepth);
245 
246     Thread&amp; thread = Thread::current();
247     thread.setSavedStackPointerAtVMEntry(m_vm-&gt;stackPointerAtVMEntry());
248     thread.setSavedLastStackTop(m_vm-&gt;lastStackTop());
249 
250     unsigned droppedLockCount = m_lockCount;
251     unlock(droppedLockCount);
252 
253     return droppedLockCount;
</pre>
<hr />
<pre>
263     lock(droppedLockCount);
264 
265     while (dropper-&gt;dropDepth() != m_lockDropDepth) {
266         unlock(droppedLockCount);
267         Thread::yield();
268         lock(droppedLockCount);
269     }
270 
271     --m_lockDropDepth;
272 
273     Thread&amp; thread = Thread::current();
274     m_vm-&gt;setStackPointerAtVMEntry(thread.savedStackPointerAtVMEntry());
275     m_vm-&gt;setLastStackTop(thread.savedLastStackTop());
276 }
277 
278 JSLock::DropAllLocks::DropAllLocks(VM* vm)
279     : m_droppedLockCount(0)
280     // If the VM is in the middle of being destroyed then we don&#39;t want to resurrect it
281     // by allowing DropAllLocks to ref it. By this point the JSLock has already been
282     // released anyways, so it doesn&#39;t matter that DropAllLocks is a no-op.
<span class="line-modified">283     , m_vm(vm-&gt;heap.isShuttingDown() ? nullptr : vm)</span>
284 {
285     if (!m_vm)
286         return;
287     RELEASE_ASSERT(!m_vm-&gt;apiLock().currentThreadIsHoldingLock() || !m_vm-&gt;isCollectorBusyOnCurrentThread());
288     m_droppedLockCount = m_vm-&gt;apiLock().dropAllLocks(this);
289 }
290 
<span class="line-modified">291 JSLock::DropAllLocks::DropAllLocks(JSGlobalObject* globalObject)</span>
<span class="line-modified">292     : DropAllLocks(globalObject ? &amp;globalObject-&gt;vm() : nullptr)</span>
293 {
294 }
295 
296 JSLock::DropAllLocks::DropAllLocks(VM&amp; vm)
297     : DropAllLocks(&amp;vm)
298 {
299 }
300 
301 JSLock::DropAllLocks::~DropAllLocks()
302 {
303     if (!m_vm)
304         return;
305     m_vm-&gt;apiLock().grabAllLocks(this, m_droppedLockCount);
306 }
307 
308 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSLexicalEnvironment.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSLock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
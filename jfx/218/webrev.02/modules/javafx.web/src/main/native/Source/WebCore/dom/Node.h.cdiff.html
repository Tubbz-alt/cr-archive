<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Node.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodeRareData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 475,18 ***</span>
      WEBCORE_EXPORT void dispatchInputEvent();
  
      // Perform the default action for an event.
      virtual void defaultEventHandler(Event&amp;);
  
<span class="line-modified">!     void ref();</span>
<span class="line-modified">!     void deref();</span>
      bool hasOneRef() const;
      unsigned refCount() const;
  
<span class="line-modified">! #ifndef NDEBUG</span>
      bool m_deletionHasBegun { false };
<span class="line-modified">!     bool m_inRemovedLastRefFunction { false };</span>
      bool m_adoptionIsRequired { true };
  #endif
  
      EventTargetData* eventTargetData() final;
      EventTargetData* eventTargetDataConcurrently() final;
<span class="line-new-header">--- 475,18 ---</span>
      WEBCORE_EXPORT void dispatchInputEvent();
  
      // Perform the default action for an event.
      virtual void defaultEventHandler(Event&amp;);
  
<span class="line-modified">!     void ref() const;</span>
<span class="line-modified">!     void deref() const;</span>
      bool hasOneRef() const;
      unsigned refCount() const;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      bool m_deletionHasBegun { false };
<span class="line-modified">!     mutable bool m_inRemovedLastRefFunction { false };</span>
      bool m_adoptionIsRequired { true };
  #endif
  
      EventTargetData* eventTargetData() final;
      EventTargetData* eventTargetDataConcurrently() final;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,56 ***</span>
  
      struct NodeRareDataDeleter {
          void operator()(NodeRareData*) const;
      };
  
<span class="line-modified">!     uint32_t m_refCountAndParentBit { s_refCountIncrement };</span>
      mutable uint32_t m_nodeFlags;
  
      ContainerNode* m_parentNode { nullptr };
      TreeScope* m_treeScope { nullptr };
      Node* m_previous { nullptr };
      Node* m_next { nullptr };
      CompactPointerTuple&lt;RenderObject*, uint8_t&gt; m_rendererWithStyleFlags;
      std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt; m_rareData;
  };
  
<span class="line-modified">! #ifndef NDEBUG</span>
  inline void adopted(Node* node)
  {
      if (!node)
          return;
      ASSERT(!node-&gt;m_deletionHasBegun);
      ASSERT(!node-&gt;m_inRemovedLastRefFunction);
      node-&gt;m_adoptionIsRequired = false;
  }
<span class="line-modified">! #endif</span>
  
<span class="line-modified">! ALWAYS_INLINE void Node::ref()</span>
  {
      ASSERT(isMainThread());
      ASSERT(!m_deletionHasBegun);
      ASSERT(!m_inRemovedLastRefFunction);
      ASSERT(!m_adoptionIsRequired);
      m_refCountAndParentBit += s_refCountIncrement;
  }
  
<span class="line-modified">! ALWAYS_INLINE void Node::deref()</span>
  {
      ASSERT(isMainThread());
      ASSERT(refCount());
      ASSERT(!m_deletionHasBegun);
      ASSERT(!m_inRemovedLastRefFunction);
      ASSERT(!m_adoptionIsRequired);
      auto updatedRefCount = m_refCountAndParentBit - s_refCountIncrement;
      if (!updatedRefCount) {
          // Don&#39;t update m_refCountAndParentBit to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.
          // (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
<span class="line-modified">! #ifndef NDEBUG</span>
          m_inRemovedLastRefFunction = true;
  #endif
<span class="line-modified">!         removedLastRef();</span>
          return;
      }
      m_refCountAndParentBit = updatedRefCount;
  }
  
<span class="line-new-header">--- 666,56 ---</span>
  
      struct NodeRareDataDeleter {
          void operator()(NodeRareData*) const;
      };
  
<span class="line-modified">!     mutable uint32_t m_refCountAndParentBit { s_refCountIncrement };</span>
      mutable uint32_t m_nodeFlags;
  
      ContainerNode* m_parentNode { nullptr };
      TreeScope* m_treeScope { nullptr };
      Node* m_previous { nullptr };
      Node* m_next { nullptr };
      CompactPointerTuple&lt;RenderObject*, uint8_t&gt; m_rendererWithStyleFlags;
      std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt; m_rareData;
  };
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  inline void adopted(Node* node)
  {
      if (!node)
          return;
      ASSERT(!node-&gt;m_deletionHasBegun);
      ASSERT(!node-&gt;m_inRemovedLastRefFunction);
      node-&gt;m_adoptionIsRequired = false;
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
<span class="line-modified">! ALWAYS_INLINE void Node::ref() const</span>
  {
      ASSERT(isMainThread());
      ASSERT(!m_deletionHasBegun);
      ASSERT(!m_inRemovedLastRefFunction);
      ASSERT(!m_adoptionIsRequired);
      m_refCountAndParentBit += s_refCountIncrement;
  }
  
<span class="line-modified">! ALWAYS_INLINE void Node::deref() const</span>
  {
      ASSERT(isMainThread());
      ASSERT(refCount());
      ASSERT(!m_deletionHasBegun);
      ASSERT(!m_inRemovedLastRefFunction);
      ASSERT(!m_adoptionIsRequired);
      auto updatedRefCount = m_refCountAndParentBit - s_refCountIncrement;
      if (!updatedRefCount) {
          // Don&#39;t update m_refCountAndParentBit to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.
          // (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
<span class="line-modified">! #if ASSERT_ENABLED</span>
          m_inRemovedLastRefFunction = true;
  #endif
<span class="line-modified">!         const_cast&lt;Node&amp;&gt;(*this).removedLastRef();</span>
          return;
      }
      m_refCountAndParentBit = updatedRefCount;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 788,10 ***</span>
<span class="line-new-header">--- 788,12 ---</span>
      ASSERT(!m_deletionHasBegun);
      if (m_treeScope != &amp;newTreeScope)
          moveTreeToNewScope(*this, *m_treeScope, newTreeScope);
  }
  
<span class="line-added">+ bool areNodesConnectedInSameTreeScope(const Node*, const Node*);</span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #if ENABLE(TREE_DEBUGGING)
  // Outside the WebCore namespace for ease of invocation from the debugger.
  void showTree(const WebCore::Node*);
</pre>
<center><a href="Node.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodeRareData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
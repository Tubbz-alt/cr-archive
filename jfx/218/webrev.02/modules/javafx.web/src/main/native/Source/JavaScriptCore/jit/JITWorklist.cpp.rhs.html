<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITWorklist.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;JIT.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;VMInlines.h&quot;
 34 
 35 namespace JSC {
 36 
 37 class JITWorklist::Plan : public ThreadSafeRefCounted&lt;JITWorklist::Plan&gt; {
 38 public:
<a name="1" id="anc1"></a><span class="line-modified"> 39     Plan(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
 40         : m_codeBlock(codeBlock)
<a name="2" id="anc2"></a><span class="line-modified"> 41         , m_jit(codeBlock-&gt;vm(), codeBlock, loopOSREntryBytecodeIndex)</span>
 42     {
 43         m_jit.doMainThreadPreparationBeforeCompile();
 44     }
 45 
 46     void compileInThread()
 47     {
 48         m_jit.compileWithoutLinking(JITCompilationCanFail);
 49 
 50         LockHolder locker(m_lock);
 51         m_isFinishedCompiling = true;
 52     }
 53 
 54     void finalize()
 55     {
 56         CompilationResult result = m_jit.link();
 57         switch (result) {
 58         case CompilationFailed:
 59             CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;delayJITCompile&quot;, (&quot;compilation failed&quot;));
<a name="3" id="anc3"></a><span class="line-modified"> 60             dataLogLnIf(Options::verboseOSR(), &quot;    JIT compilation failed.&quot;);</span>

 61             m_codeBlock-&gt;dontJITAnytimeSoon();
 62             m_codeBlock-&gt;m_didFailJITCompilation = true;
 63             return;
 64         case CompilationSuccessful:
<a name="4" id="anc4"></a><span class="line-modified"> 65             dataLogLnIf(Options::verboseOSR(), &quot;    JIT compilation successful.&quot;);</span>

 66             m_codeBlock-&gt;ownerExecutable()-&gt;installCode(m_codeBlock);
 67             m_codeBlock-&gt;jitSoon();
 68             return;
 69         default:
 70             RELEASE_ASSERT_NOT_REACHED();
 71             return;
 72         }
 73     }
 74 
 75     CodeBlock* codeBlock() { return m_codeBlock; }
 76     VM&amp; vm() { return m_codeBlock-&gt;vm(); }
 77 
 78     bool isFinishedCompiling()
 79     {
 80         LockHolder locker(m_lock);
 81         return m_isFinishedCompiling;
 82     }
 83 
<a name="5" id="anc5"></a><span class="line-modified"> 84     static void compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
 85     {
<a name="6" id="anc6"></a><span class="line-modified"> 86         Plan plan(codeBlock, loopOSREntryBytecodeIndex);</span>
 87         plan.compileInThread();
 88         plan.finalize();
 89     }
 90 
 91 private:
 92     CodeBlock* m_codeBlock;
 93     JIT m_jit;
 94     Lock m_lock;
 95     bool m_isFinishedCompiling { false };
 96 };
 97 
 98 class JITWorklist::Thread : public AutomaticThread {
 99 public:
100     Thread(const AbstractLocker&amp; locker, JITWorklist&amp; worklist)
101         : AutomaticThread(locker, worklist.m_lock, worklist.m_condition.copyRef())
102         , m_worklist(worklist)
103     {
104         m_worklist.m_numAvailableThreads++;
105     }
106 
107     const char* name() const override
108     {
109 #if OS(LINUX)
110         return &quot;JITWorker&quot;;
111 #else
112         return &quot;JIT Worklist Helper Thread&quot;;
113 #endif
114     }
115 
116 protected:
117     PollResult poll(const AbstractLocker&amp;) override
118     {
119         RELEASE_ASSERT(m_worklist.m_numAvailableThreads);
120 
121         if (m_worklist.m_queue.isEmpty())
122             return PollResult::Wait;
123 
124         m_myPlans = WTFMove(m_worklist.m_queue);
125         m_worklist.m_numAvailableThreads--;
126         return PollResult::Work;
127     }
128 
129     WorkResult work() override
130     {
131         RELEASE_ASSERT(!m_myPlans.isEmpty());
132 
133         for (RefPtr&lt;Plan&gt;&amp; plan : m_myPlans) {
134             plan-&gt;compileInThread();
135             plan = nullptr;
136 
137             // Make sure that the main thread realizes that we just compiled something. Notifying
138             // a condition is basically free if nobody is waiting.
139             LockHolder locker(*m_worklist.m_lock);
140             m_worklist.m_condition-&gt;notifyAll(locker);
141         }
142 
143         m_myPlans.clear();
144 
145         LockHolder locker(*m_worklist.m_lock);
146         m_worklist.m_numAvailableThreads++;
147         return WorkResult::Continue;
148     }
149 
150 private:
151     JITWorklist&amp; m_worklist;
152     Plans m_myPlans;
153 };
154 
155 JITWorklist::JITWorklist()
156     : m_lock(Box&lt;Lock&gt;::create())
157     , m_condition(AutomaticThreadCondition::create())
158 {
159     LockHolder locker(*m_lock);
160     m_thread = new Thread(locker, *this);
161 }
162 
163 JITWorklist::~JITWorklist()
164 {
165     UNREACHABLE_FOR_PLATFORM();
166 }
167 
168 bool JITWorklist::completeAllForVM(VM&amp; vm)
169 {
170     bool result = false;
171     DeferGC deferGC(vm.heap);
172     for (;;) {
173         Vector&lt;RefPtr&lt;Plan&gt;, 32&gt; myPlans;
174         {
175             LockHolder locker(*m_lock);
176             for (;;) {
177                 bool didFindUnfinishedPlan = false;
178                 m_plans.removeAllMatching(
179                     [&amp;] (RefPtr&lt;Plan&gt;&amp; plan) {
180                         if (&amp;plan-&gt;vm() != &amp;vm)
181                             return false;
182                         if (!plan-&gt;isFinishedCompiling()) {
183                             didFindUnfinishedPlan = true;
184                             return false;
185                         }
186                         myPlans.append(WTFMove(plan));
187                         return true;
188                     });
189 
190                 // If we found plans then we should finalize them now.
191                 if (!myPlans.isEmpty())
192                     break;
193 
194                 // If we don&#39;t find plans, then we&#39;re either done or we need to wait, depending on
195                 // whether we found some unfinished plans.
196                 if (!didFindUnfinishedPlan)
197                     return result;
198 
199                 m_condition-&gt;wait(*m_lock);
200             }
201         }
202 
203         RELEASE_ASSERT(!myPlans.isEmpty());
204         result = true;
205         finalizePlans(myPlans);
206     }
207 }
208 
209 void JITWorklist::poll(VM&amp; vm)
210 {
211     DeferGC deferGC(vm.heap);
212     Plans myPlans;
213     {
214         LockHolder locker(*m_lock);
215         m_plans.removeAllMatching(
216             [&amp;] (RefPtr&lt;Plan&gt;&amp; plan) {
217                 if (&amp;plan-&gt;vm() != &amp;vm)
218                     return false;
219                 if (!plan-&gt;isFinishedCompiling())
220                     return false;
221                 myPlans.append(WTFMove(plan));
222                 return true;
223             });
224     }
225 
226     finalizePlans(myPlans);
227 }
228 
<a name="7" id="anc7"></a><span class="line-modified">229 void JITWorklist::compileLater(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
230 {
231     DeferGC deferGC(codeBlock-&gt;vm().heap);
232     RELEASE_ASSERT(codeBlock-&gt;jitType() == JITType::InterpreterThunk);
233 
234     if (codeBlock-&gt;m_didFailJITCompilation) {
235         codeBlock-&gt;dontJITAnytimeSoon();
236         return;
237     }
238 
239     if (!Options::useConcurrentJIT()) {
<a name="8" id="anc8"></a><span class="line-modified">240         Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);</span>
241         return;
242     }
243 
244     codeBlock-&gt;jitSoon();
245 
246     {
247         LockHolder locker(*m_lock);
248 
249         if (m_planned.contains(codeBlock))
250             return;
251 
252         if (m_numAvailableThreads) {
253             m_planned.add(codeBlock);
<a name="9" id="anc9"></a><span class="line-modified">254             RefPtr&lt;Plan&gt; plan = adoptRef(new Plan(codeBlock, loopOSREntryBytecodeIndex));</span>
255             m_plans.append(plan);
256             m_queue.append(plan);
257             m_condition-&gt;notifyAll(locker);
258             return;
259         }
260     }
261 
262     // Compiling on the main thread if the helper thread isn&#39;t available is a defense against this
263     // pathology:
264     //
265     // 1) Do something that is allowed to take a while, like load a giant piece of initialization
266     //    code. This plans the compile of the init code, but doesn&#39;t finish it. It will take a
267     //    while.
268     //
269     // 2) Do something that is supposed to be quick. Now all baseline compiles, and so all DFG and
270     //    FTL compiles, of everything is blocked on the long-running baseline compile of that
271     //    initialization code.
272     //
273     // The single-threaded concurrent JIT has this tendency to convoy everything while at the same
274     // time postponing when it happens, which means that the convoy delays are less predictable.
275     // This works around the issue. If the concurrent JIT thread is convoyed, we revert to main
276     // thread compiles. This is probably not as good as if we had multiple JIT threads. Maybe we
277     // can do that someday.
<a name="10" id="anc10"></a><span class="line-modified">278     Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);</span>
279 }
280 
<a name="11" id="anc11"></a><span class="line-modified">281 void JITWorklist::compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
282 {
283     VM&amp; vm = codeBlock-&gt;vm();
284     DeferGC deferGC(vm.heap);
285     if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
286         return;
287 
288     bool isPlanned;
289     {
290         LockHolder locker(*m_lock);
291         isPlanned = m_planned.contains(codeBlock);
292     }
293 
294     if (isPlanned) {
295         RELEASE_ASSERT(Options::useConcurrentJIT());
296         // This is expensive, but probably good enough.
297         completeAllForVM(vm);
298     }
299 
300     // Now it might be compiled!
301     if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
302         return;
303 
304     // We do this in case we had previously attempted, and then failed, to compile with the
305     // baseline JIT.
306     codeBlock-&gt;resetJITData();
307 
308     // OK, just compile it.
<a name="12" id="anc12"></a><span class="line-modified">309     JIT::compile(vm, codeBlock, JITCompilationMustSucceed, loopOSREntryBytecodeIndex);</span>
310     codeBlock-&gt;ownerExecutable()-&gt;installCode(codeBlock);
311 }
312 
313 void JITWorklist::finalizePlans(Plans&amp; myPlans)
314 {
315     for (RefPtr&lt;Plan&gt;&amp; plan : myPlans) {
316         plan-&gt;finalize();
317 
318         LockHolder locker(*m_lock);
319         m_planned.remove(plan-&gt;codeBlock());
320     }
321 }
322 
323 static JITWorklist* theGlobalJITWorklist { nullptr };
324 
325 JITWorklist* JITWorklist::existingGlobalWorklistOrNull()
326 {
327     return theGlobalJITWorklist;
328 }
329 
330 JITWorklist&amp; JITWorklist::ensureGlobalWorklist()
331 {
332     static std::once_flag once;
333     std::call_once(
334         once,
335         [] {
336             auto* worklist = new JITWorklist();
337             WTF::storeStoreFence();
338             theGlobalJITWorklist = worklist;
339         });
340     return *theGlobalJITWorklist;
341 }
342 
343 } // namespace JSC
344 
345 #endif // ENABLE(JIT)
346 
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
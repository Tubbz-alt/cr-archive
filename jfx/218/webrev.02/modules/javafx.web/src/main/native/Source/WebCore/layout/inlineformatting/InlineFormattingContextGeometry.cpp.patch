diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextGeometry.cpp b/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextGeometry.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextGeometry.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextGeometry.cpp
@@ -27,56 +27,61 @@
 #include "InlineFormattingContext.h"
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
 #include "FormattingContext.h"
-#include "InlineFormattingState.h"
 #include "LayoutBox.h"
 #include "LayoutContainer.h"
-#include "LayoutState.h"
-#include "TextUtil.h"
+#include "LengthFunctions.h"
 
 namespace WebCore {
 namespace Layout {
 
-WidthAndMargin InlineFormattingContext::Geometry::inlineBlockWidthAndMargin(LayoutState& layoutState, const Box& formattingContextRoot, UsedHorizontalValues usedValues)
+ContentWidthAndMargin InlineFormattingContext::Geometry::inlineBlockWidthAndMargin(const Box& formattingContextRoot, const HorizontalConstraints& horizontalConstraints, const OverrideHorizontalValues& overrideHorizontalValues)
 {
     ASSERT(formattingContextRoot.isInFlow());
 
     // 10.3.10 'Inline-block', replaced elements in normal flow
 
     // Exactly as inline replaced elements.
     if (formattingContextRoot.replaced())
-        return inlineReplacedWidthAndMargin(layoutState, formattingContextRoot, usedValues);
+        return inlineReplacedWidthAndMargin(formattingContextRoot, horizontalConstraints, overrideHorizontalValues);
 
     // 10.3.9 'Inline-block', non-replaced elements in normal flow
 
     // If 'width' is 'auto', the used value is the shrink-to-fit width as for floating elements.
     // A computed value of 'auto' for 'margin-left' or 'margin-right' becomes a used value of '0'.
     // #1
-    auto width = computedValueIfNotAuto(formattingContextRoot.style().logicalWidth(), usedValues.containingBlockWidth.valueOr(0));
+    auto width = computedValueIfNotAuto(formattingContextRoot.style().logicalWidth(), horizontalConstraints.logicalWidth);
     if (!width)
-        width = shrinkToFitWidth(layoutState, formattingContextRoot, usedValues);
+        width = shrinkToFitWidth(formattingContextRoot, horizontalConstraints.logicalWidth);
 
     // #2
-    auto computedHorizontalMargin = Geometry::computedHorizontalMargin(formattingContextRoot, usedValues);
+    auto computedHorizontalMargin = Geometry::computedHorizontalMargin(formattingContextRoot, horizontalConstraints);
 
-    return WidthAndMargin { *width, { computedHorizontalMargin.start.valueOr(0_lu), computedHorizontalMargin.end.valueOr(0_lu) }, computedHorizontalMargin };
+    return ContentWidthAndMargin { *width, { computedHorizontalMargin.start.valueOr(0_lu), computedHorizontalMargin.end.valueOr(0_lu) }, computedHorizontalMargin };
 }
 
-HeightAndMargin InlineFormattingContext::Geometry::inlineBlockHeightAndMargin(const LayoutState& layoutState, const Box& layoutBox)
+ContentHeightAndMargin InlineFormattingContext::Geometry::inlineBlockHeightAndMargin(const Box& layoutBox, const HorizontalConstraints& horizontalConstraints, const OverrideVerticalValues& overrideVerticalValues) const
 {
     ASSERT(layoutBox.isInFlow());
 
     // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, 'inline-block' replaced elements in normal flow and floating replaced elements
     if (layoutBox.replaced())
-        return inlineReplacedHeightAndMargin(layoutState, layoutBox, { });
+        return inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, overrideVerticalValues);
 
     // 10.6.6 Complicated cases
     // - 'Inline-block', non-replaced elements.
-    auto usedHorizontalValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };
-    return complicatedCases(layoutState, layoutBox, { }, usedHorizontalValues);
+    return complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);
+}
+
+Optional<InlineLayoutUnit> InlineFormattingContext::Geometry::computedTextIndent(const Container& formattingContextRoot, const HorizontalConstraints& horizontalConstraints) const
+{
+    auto textIndent = formattingContextRoot.style().textIndent();
+    if (textIndent == RenderStyle::initialTextIndent())
+        return { };
+    return InlineLayoutUnit { minimumValueForLength(textIndent, horizontalConstraints.logicalWidth) };
 }
 
 }
 }
 

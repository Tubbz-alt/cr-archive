<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGLiveCatchVariablePreservationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGLazyNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGMayExit.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGLiveCatchVariablePreservationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 61,11 ***</span>
          }
  
          return true;
      }
  
<span class="line-modified">!     bool isValidFlushLocation(BasicBlock* startingBlock, unsigned index, VirtualRegister operand)</span>
      {
          // This code is not meant to be fast. We just use it for assertions. If we got liveness wrong,
          // this function would return false for a Flush that we insert.
          Vector&lt;BasicBlock*, 4&gt; worklist;
          BlockSet seen;
<span class="line-new-header">--- 61,11 ---</span>
          }
  
          return true;
      }
  
<span class="line-modified">!     bool isValidFlushLocation(BasicBlock* startingBlock, unsigned index, Operand operand)</span>
      {
          // This code is not meant to be fast. We just use it for assertions. If we got liveness wrong,
          // this function would return false for a Flush that we insert.
          Vector&lt;BasicBlock*, 4&gt; worklist;
          BlockSet seen;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,11 ***</span>
          };
  
          auto flushIsDefinitelyInvalid = [&amp;] (BasicBlock* block, unsigned index) {
              bool allGood = false;
              for (unsigned i = index; i--; ) {
<span class="line-modified">!                 if (block-&gt;at(i)-&gt;accessesStack(m_graph) &amp;&amp; block-&gt;at(i)-&gt;local() == operand) {</span>
                      allGood = true;
                      break;
                  }
              }
  
<span class="line-new-header">--- 79,11 ---</span>
          };
  
          auto flushIsDefinitelyInvalid = [&amp;] (BasicBlock* block, unsigned index) {
              bool allGood = false;
              for (unsigned i = index; i--; ) {
<span class="line-modified">!                 if (block-&gt;at(i)-&gt;accessesStack(m_graph) &amp;&amp; block-&gt;at(i)-&gt;operand() == operand) {</span>
                      allGood = true;
                      break;
                  }
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,33 ***</span>
  
  
      void handleBlockForTryCatch(BasicBlock* block, InsertionSet&amp; insertionSet)
      {
          HandlerInfo* currentExceptionHandler = nullptr;
<span class="line-modified">!         FastBitVector liveAtCatchHead;</span>
<span class="line-removed">-         liveAtCatchHead.resize(m_graph.block(0)-&gt;variablesAtTail.numberOfLocals());</span>
  
          HandlerInfo* cachedHandlerResult;
          CodeOrigin cachedCodeOrigin;
          auto catchHandler = [&amp;] (CodeOrigin origin) -&gt; HandlerInfo* {
              ASSERT(origin);
              if (origin == cachedCodeOrigin)
                  return cachedHandlerResult;
  
<span class="line-modified">!             unsigned bytecodeIndexToCheck = origin.bytecodeIndex();</span>
  
              cachedCodeOrigin = origin;
  
              while (1) {
                  InlineCallFrame* inlineCallFrame = origin.inlineCallFrame();
                  CodeBlock* codeBlock = m_graph.baselineCodeBlockFor(inlineCallFrame);
<span class="line-modified">!                 if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeOffset(bytecodeIndexToCheck)) {</span>
<span class="line-modified">!                     liveAtCatchHead.clearAll();</span>
  
<span class="line-modified">!                     unsigned catchBytecodeIndex = handler-&gt;target;</span>
<span class="line-modified">!                     m_graph.forAllLocalsLiveInBytecode(CodeOrigin(catchBytecodeIndex, inlineCallFrame), [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">!                         liveAtCatchHead[operand.toLocal()] = true;</span>
                      });
  
                      cachedHandlerResult = handler;
                      break;
                  }
<span class="line-new-header">--- 113,32 ---</span>
  
  
      void handleBlockForTryCatch(BasicBlock* block, InsertionSet&amp; insertionSet)
      {
          HandlerInfo* currentExceptionHandler = nullptr;
<span class="line-modified">!         Operands&lt;bool&gt; liveAtCatchHead(0, m_graph.block(0)-&gt;variablesAtTail.numberOfLocals(), m_graph.block(0)-&gt;variablesAtTail.numberOfTmps());</span>
  
          HandlerInfo* cachedHandlerResult;
          CodeOrigin cachedCodeOrigin;
          auto catchHandler = [&amp;] (CodeOrigin origin) -&gt; HandlerInfo* {
              ASSERT(origin);
              if (origin == cachedCodeOrigin)
                  return cachedHandlerResult;
  
<span class="line-modified">!             BytecodeIndex bytecodeIndexToCheck = origin.bytecodeIndex();</span>
  
              cachedCodeOrigin = origin;
  
              while (1) {
                  InlineCallFrame* inlineCallFrame = origin.inlineCallFrame();
                  CodeBlock* codeBlock = m_graph.baselineCodeBlockFor(inlineCallFrame);
<span class="line-modified">!                 if (HandlerInfo* handler = codeBlock-&gt;handlerForBytecodeIndex(bytecodeIndexToCheck)) {</span>
<span class="line-modified">!                     liveAtCatchHead.fill(false);</span>
  
<span class="line-modified">!                     BytecodeIndex catchBytecodeIndex = BytecodeIndex(handler-&gt;target);</span>
<span class="line-modified">!                     m_graph.forAllLocalsAndTmpsLiveInBytecode(CodeOrigin(catchBytecodeIndex, inlineCallFrame), [&amp;] (Operand operand) {</span>
<span class="line-modified">!                         liveAtCatchHead.operand(operand) = true;</span>
                      });
  
                      cachedHandlerResult = handler;
                      break;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,16 ***</span>
              }
  
              return cachedHandlerResult;
          };
  
<span class="line-modified">!         Operands&lt;VariableAccessData*&gt; currentBlockAccessData(block-&gt;variablesAtTail.numberOfArguments(), block-&gt;variablesAtTail.numberOfLocals(), nullptr);</span>
  
          auto flushEverything = [&amp;] (NodeOrigin origin, unsigned index) {
              RELEASE_ASSERT(currentExceptionHandler);
<span class="line-modified">!             auto flush = [&amp;] (VirtualRegister operand) {</span>
<span class="line-modified">!                 if ((operand.isLocal() &amp;&amp; liveAtCatchHead[operand.toLocal()]) || operand.isArgument()) {</span>
  
                      ASSERT(isValidFlushLocation(block, index, operand));
  
                      VariableAccessData* accessData = currentBlockAccessData.operand(operand);
                      if (!accessData)
<span class="line-new-header">--- 153,16 ---</span>
              }
  
              return cachedHandlerResult;
          };
  
<span class="line-modified">!         Operands&lt;VariableAccessData*&gt; currentBlockAccessData(OperandsLike, block-&gt;variablesAtTail, nullptr);</span>
  
          auto flushEverything = [&amp;] (NodeOrigin origin, unsigned index) {
              RELEASE_ASSERT(currentExceptionHandler);
<span class="line-modified">!             auto flush = [&amp;] (Operand operand) {</span>
<span class="line-modified">!                 if (operand.isArgument() || liveAtCatchHead.operand(operand)) {</span>
  
                      ASSERT(isValidFlushLocation(block, index, operand));
  
                      VariableAccessData* accessData = currentBlockAccessData.operand(operand);
                      if (!accessData)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,10 ***</span>
<span class="line-new-header">--- 175,12 ---</span>
                  }
              };
  
              for (unsigned local = 0; local &lt; block-&gt;variablesAtTail.numberOfLocals(); local++)
                  flush(virtualRegisterForLocal(local));
<span class="line-added">+             for (unsigned tmp = 0; tmp &lt; block-&gt;variablesAtTail.numberOfTmps(); ++tmp)</span>
<span class="line-added">+                 flush(Operand::tmp(tmp));</span>
              flush(VirtualRegister(CallFrame::thisArgumentOffset()));
          };
  
          for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); nodeIndex++) {
              Node* node = block-&gt;at(nodeIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,13 ***</span>
                      flushEverything(node-&gt;origin, nodeIndex);
                  currentExceptionHandler = newHandler;
              }
  
              if (currentExceptionHandler &amp;&amp; (node-&gt;op() == SetLocal || node-&gt;op() == SetArgumentDefinitely || node-&gt;op() == SetArgumentMaybe)) {
<span class="line-modified">!                 VirtualRegister operand = node-&gt;local();</span>
<span class="line-modified">!                 if ((operand.isLocal() &amp;&amp; liveAtCatchHead[operand.toLocal()]) || operand.isArgument()) {</span>
<span class="line-removed">- </span>
                      ASSERT(isValidFlushLocation(block, nodeIndex, operand));
  
                      VariableAccessData* variableAccessData = currentBlockAccessData.operand(operand);
                      if (!variableAccessData)
                          variableAccessData = newVariableAccessData(operand);
<span class="line-new-header">--- 191,12 ---</span>
                      flushEverything(node-&gt;origin, nodeIndex);
                  currentExceptionHandler = newHandler;
              }
  
              if (currentExceptionHandler &amp;&amp; (node-&gt;op() == SetLocal || node-&gt;op() == SetArgumentDefinitely || node-&gt;op() == SetArgumentMaybe)) {
<span class="line-modified">!                 Operand operand = node-&gt;operand();</span>
<span class="line-modified">!                 if (operand.isArgument() || liveAtCatchHead.operand(operand)) {</span>
                      ASSERT(isValidFlushLocation(block, nodeIndex, operand));
  
                      VariableAccessData* variableAccessData = currentBlockAccessData.operand(operand);
                      if (!variableAccessData)
                          variableAccessData = newVariableAccessData(operand);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,20 ***</span>
                          Flush, node-&gt;origin, OpInfo(variableAccessData));
                  }
              }
  
              if (node-&gt;accessesStack(m_graph))
<span class="line-modified">!                 currentBlockAccessData.operand(node-&gt;local()) = node-&gt;variableAccessData();</span>
          }
  
          if (currentExceptionHandler) {
              NodeOrigin origin = block-&gt;at(block-&gt;size() - 1)-&gt;origin;
              flushEverything(origin, block-&gt;size());
          }
      }
  
<span class="line-modified">!     VariableAccessData* newVariableAccessData(VirtualRegister operand)</span>
      {
          ASSERT(!operand.isConstant());
  
          m_graph.m_variableAccessData.append(operand);
          return &amp;m_graph.m_variableAccessData.last();
<span class="line-new-header">--- 205,20 ---</span>
                          Flush, node-&gt;origin, OpInfo(variableAccessData));
                  }
              }
  
              if (node-&gt;accessesStack(m_graph))
<span class="line-modified">!                 currentBlockAccessData.operand(node-&gt;operand()) = node-&gt;variableAccessData();</span>
          }
  
          if (currentExceptionHandler) {
              NodeOrigin origin = block-&gt;at(block-&gt;size() - 1)-&gt;origin;
              flushEverything(origin, block-&gt;size());
          }
      }
  
<span class="line-modified">!     VariableAccessData* newVariableAccessData(Operand operand)</span>
      {
          ASSERT(!operand.isConstant());
  
          m_graph.m_variableAccessData.append(operand);
          return &amp;m_graph.m_variableAccessData.last();
</pre>
<center><a href="DFGLazyNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGMayExit.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
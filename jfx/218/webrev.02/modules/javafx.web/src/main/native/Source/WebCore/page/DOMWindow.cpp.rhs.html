<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;DOMWindow.h&quot;
  29 
  30 #include &quot;BackForwardController.h&quot;
  31 #include &quot;BarProp.h&quot;
  32 #include &quot;CSSComputedStyleDeclaration.h&quot;
  33 #include &quot;CSSRule.h&quot;
  34 #include &quot;CSSRuleList.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
  37 #include &quot;ComposedTreeIterator.h&quot;
  38 #include &quot;ContentExtensionActions.h&quot;
  39 #include &quot;ContentExtensionRule.h&quot;
  40 #include &quot;ContentRuleListResults.h&quot;
  41 #include &quot;Crypto.h&quot;
  42 #include &quot;CustomElementRegistry.h&quot;
  43 #include &quot;DOMApplicationCache.h&quot;
  44 #include &quot;DOMSelection.h&quot;
  45 #include &quot;DOMStringList.h&quot;
  46 #include &quot;DOMTimer.h&quot;
  47 #include &quot;DOMTokenList.h&quot;
  48 #include &quot;DOMURL.h&quot;
  49 #include &quot;DeviceMotionController.h&quot;
  50 #include &quot;DeviceMotionData.h&quot;
  51 #include &quot;DeviceMotionEvent.h&quot;
  52 #include &quot;DeviceOrientationAndMotionAccessController.h&quot;
  53 #include &quot;DeviceOrientationController.h&quot;
  54 #include &quot;Document.h&quot;
  55 #include &quot;DocumentLoader.h&quot;
  56 #include &quot;Editor.h&quot;
  57 #include &quot;Element.h&quot;
  58 #include &quot;EventHandler.h&quot;
  59 #include &quot;EventListener.h&quot;
  60 #include &quot;EventNames.h&quot;
  61 #include &quot;FloatRect.h&quot;
  62 #include &quot;FocusController.h&quot;
  63 #include &quot;Frame.h&quot;
  64 #include &quot;FrameLoadRequest.h&quot;
  65 #include &quot;FrameLoader.h&quot;
  66 #include &quot;FrameLoaderClient.h&quot;
  67 #include &quot;FrameTree.h&quot;
  68 #include &quot;FrameView.h&quot;
  69 #include &quot;HTTPParsers.h&quot;
  70 #include &quot;History.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  71 #include &quot;IdleRequestOptions.h&quot;</span>
  72 #include &quot;InspectorInstrumentation.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  73 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  74 #include &quot;JSDOMWindowBase.h&quot;
  75 #include &quot;JSExecState.h&quot;
  76 #include &quot;Location.h&quot;
  77 #include &quot;MediaQueryList.h&quot;
  78 #include &quot;MediaQueryMatcher.h&quot;
  79 #include &quot;MessageEvent.h&quot;
  80 #include &quot;MessageWithMessagePorts.h&quot;
  81 #include &quot;NavigationScheduler.h&quot;
  82 #include &quot;Navigator.h&quot;
  83 #include &quot;Page.h&quot;
  84 #include &quot;PageConsoleClient.h&quot;
  85 #include &quot;PageTransitionEvent.h&quot;
  86 #include &quot;Performance.h&quot;
  87 #include &quot;RequestAnimationFrameCallback.h&quot;
  88 #include &quot;ResourceLoadInfo.h&quot;
  89 #include &quot;ResourceLoadObserver.h&quot;
  90 #include &quot;RuntimeApplicationChecks.h&quot;
<a name="3" id="anc3"></a>
  91 #include &quot;ScheduledAction.h&quot;
  92 #include &quot;Screen.h&quot;
  93 #include &quot;SecurityOrigin.h&quot;
  94 #include &quot;SecurityOriginData.h&quot;
  95 #include &quot;SecurityPolicy.h&quot;
  96 #include &quot;SelectorQuery.h&quot;
  97 #include &quot;SerializedScriptValue.h&quot;
  98 #include &quot;Settings.h&quot;
  99 #include &quot;StaticNodeList.h&quot;
 100 #include &quot;Storage.h&quot;
 101 #include &quot;StorageArea.h&quot;
 102 #include &quot;StorageNamespace.h&quot;
 103 #include &quot;StorageNamespaceProvider.h&quot;
 104 #include &quot;StyleMedia.h&quot;
 105 #include &quot;StyleResolver.h&quot;
 106 #include &quot;StyleScope.h&quot;
 107 #include &quot;SuddenTermination.h&quot;
 108 #include &lt;wtf/URL.h&gt;
 109 #include &quot;UserGestureIndicator.h&quot;
 110 #include &quot;VisualViewport.h&quot;
 111 #include &quot;WebKitPoint.h&quot;
 112 #include &quot;WindowFeatures.h&quot;
 113 #include &quot;WindowFocusAllowedIndicator.h&quot;
 114 #include &quot;WindowProxy.h&quot;
 115 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 116 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 117 #include &lt;algorithm&gt;
 118 #include &lt;memory&gt;
 119 #include &lt;wtf/IsoMallocInlines.h&gt;
 120 #include &lt;wtf/Language.h&gt;
 121 #include &lt;wtf/MainThread.h&gt;
 122 #include &lt;wtf/MathExtras.h&gt;
 123 #include &lt;wtf/NeverDestroyed.h&gt;
 124 #include &lt;wtf/Ref.h&gt;
 125 #include &lt;wtf/SetForScope.h&gt;
 126 #include &lt;wtf/Variant.h&gt;
 127 #include &lt;wtf/text/WTFString.h&gt;
 128 
 129 #if ENABLE(USER_MESSAGE_HANDLERS)
 130 #include &quot;UserContentController.h&quot;
 131 #include &quot;UserMessageHandlerDescriptor.h&quot;
 132 #include &quot;WebKitNamespace.h&quot;
 133 #endif
 134 
 135 #if ENABLE(GAMEPAD)
 136 #include &quot;GamepadManager.h&quot;
 137 #endif
 138 
 139 #if ENABLE(GEOLOCATION)
 140 #include &quot;NavigatorGeolocation.h&quot;
 141 #endif
 142 
 143 #if ENABLE(POINTER_LOCK)
 144 #include &quot;PointerLockController.h&quot;
 145 #endif
 146 
 147 namespace WebCore {
 148 using namespace Inspector;
 149 
<a name="4" id="anc4"></a><span class="line-added"> 150 static const Seconds defaultTransientActivationDuration { 2_s };</span>
<span class="line-added"> 151 </span>
<span class="line-added"> 152 static Optional&lt;Seconds&gt;&amp; transientActivationDurationOverrideForTesting()</span>
<span class="line-added"> 153 {</span>
<span class="line-added"> 154     static NeverDestroyed&lt;Optional&lt;Seconds&gt;&gt; overrideForTesting;</span>
<span class="line-added"> 155     return overrideForTesting;</span>
<span class="line-added"> 156 }</span>
<span class="line-added"> 157 </span>
<span class="line-added"> 158 static Seconds transientActivationDuration()</span>
<span class="line-added"> 159 {</span>
<span class="line-added"> 160     if (auto override = transientActivationDurationOverrideForTesting())</span>
<span class="line-added"> 161         return *override;</span>
<span class="line-added"> 162     return defaultTransientActivationDuration;</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
 165 WTF_MAKE_ISO_ALLOCATED_IMPL(DOMWindow);
 166 
 167 class PostMessageTimer : public TimerBase {
 168 public:
 169     PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
 170         : m_window(window)
 171         , m_message(WTFMove(message))
 172         , m_origin(sourceOrigin)
 173         , m_source(source)
 174         , m_targetOrigin(WTFMove(targetOrigin))
 175         , m_stackTrace(stackTrace)
 176         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 177     {
 178     }
 179 
 180     Ref&lt;MessageEvent&gt; event(ScriptExecutionContext&amp; context)
 181     {
 182         return MessageEvent::create(MessagePort::entanglePorts(context, WTFMove(m_message.transferredPorts)), m_message.message.releaseNonNull(), m_origin, { }, m_source ? makeOptional(MessageEventSource(WTFMove(m_source))) : WTF::nullopt);
 183     }
 184 
 185     SecurityOrigin* targetOrigin() const { return m_targetOrigin.get(); }
 186     ScriptCallStack* stackTrace() const { return m_stackTrace.get(); }
 187 
 188 private:
 189     void fired() override
 190     {
 191         // This object gets deleted when std::unique_ptr falls out of scope..
 192         std::unique_ptr&lt;PostMessageTimer&gt; timer(this);
 193 
 194         UserGestureIndicator userGestureIndicator(m_userGestureToForward);
 195         m_window-&gt;postMessageTimerFired(*timer);
 196     }
 197 
 198     Ref&lt;DOMWindow&gt; m_window;
 199     MessageWithMessagePorts m_message;
 200     String m_origin;
 201     RefPtr&lt;WindowProxy&gt; m_source;
 202     RefPtr&lt;SecurityOrigin&gt; m_targetOrigin;
 203     RefPtr&lt;ScriptCallStack&gt; m_stackTrace;
 204     RefPtr&lt;UserGestureToken&gt; m_userGestureToForward;
 205 };
 206 
 207 typedef HashCountedSet&lt;DOMWindow*&gt; DOMWindowSet;
 208 
 209 static DOMWindowSet&amp; windowsWithUnloadEventListeners()
 210 {
 211     static NeverDestroyed&lt;DOMWindowSet&gt; windowsWithUnloadEventListeners;
 212     return windowsWithUnloadEventListeners;
 213 }
 214 
 215 static DOMWindowSet&amp; windowsWithBeforeUnloadEventListeners()
 216 {
 217     static NeverDestroyed&lt;DOMWindowSet&gt; windowsWithBeforeUnloadEventListeners;
 218     return windowsWithBeforeUnloadEventListeners;
 219 }
 220 
 221 static void addUnloadEventListener(DOMWindow* domWindow)
 222 {
 223     if (windowsWithUnloadEventListeners().add(domWindow).isNewEntry)
 224         domWindow-&gt;disableSuddenTermination();
 225 }
 226 
 227 static void removeUnloadEventListener(DOMWindow* domWindow)
 228 {
 229     if (windowsWithUnloadEventListeners().remove(domWindow))
 230         domWindow-&gt;enableSuddenTermination();
 231 }
 232 
 233 static void removeAllUnloadEventListeners(DOMWindow* domWindow)
 234 {
 235     if (windowsWithUnloadEventListeners().removeAll(domWindow))
 236         domWindow-&gt;enableSuddenTermination();
 237 }
 238 
 239 static void addBeforeUnloadEventListener(DOMWindow* domWindow)
 240 {
 241     if (windowsWithBeforeUnloadEventListeners().add(domWindow).isNewEntry)
 242         domWindow-&gt;disableSuddenTermination();
 243 }
 244 
 245 static void removeBeforeUnloadEventListener(DOMWindow* domWindow)
 246 {
 247     if (windowsWithBeforeUnloadEventListeners().remove(domWindow))
 248         domWindow-&gt;enableSuddenTermination();
 249 }
 250 
 251 static void removeAllBeforeUnloadEventListeners(DOMWindow* domWindow)
 252 {
 253     if (windowsWithBeforeUnloadEventListeners().removeAll(domWindow))
 254         domWindow-&gt;enableSuddenTermination();
 255 }
 256 
 257 static bool allowsBeforeUnloadListeners(DOMWindow* window)
 258 {
 259     ASSERT_ARG(window, window);
 260     Frame* frame = window-&gt;frame();
 261     if (!frame)
 262         return false;
 263     if (!frame-&gt;page())
 264         return false;
 265     return frame-&gt;isMainFrame();
 266 }
 267 
 268 bool DOMWindow::dispatchAllPendingBeforeUnloadEvents()
 269 {
 270     DOMWindowSet&amp; set = windowsWithBeforeUnloadEventListeners();
 271     if (set.isEmpty())
 272         return true;
 273 
 274     static bool alreadyDispatched = false;
 275     ASSERT(!alreadyDispatched);
 276     if (alreadyDispatched)
 277         return true;
 278 
 279     Vector&lt;Ref&lt;DOMWindow&gt;&gt; windows;
 280     windows.reserveInitialCapacity(set.size());
 281     for (auto&amp; window : set)
 282         windows.uncheckedAppend(*window.key);
 283 
 284     for (auto&amp; window : windows) {
 285         if (!set.contains(window.ptr()))
 286             continue;
 287 
 288         Frame* frame = window-&gt;frame();
 289         if (!frame)
 290             continue;
 291 
 292         if (!frame-&gt;loader().shouldClose())
 293             return false;
 294 
 295         window-&gt;enableSuddenTermination();
 296     }
 297 
 298     alreadyDispatched = true;
 299     return true;
 300 }
 301 
 302 unsigned DOMWindow::pendingUnloadEventListeners() const
 303 {
 304     return windowsWithUnloadEventListeners().count(const_cast&lt;DOMWindow*&gt;(this));
 305 }
 306 
 307 void DOMWindow::dispatchAllPendingUnloadEvents()
 308 {
 309     DOMWindowSet&amp; set = windowsWithUnloadEventListeners();
 310     if (set.isEmpty())
 311         return;
 312 
 313     static bool alreadyDispatched = false;
 314     ASSERT(!alreadyDispatched);
 315     if (alreadyDispatched)
 316         return;
 317 
 318     auto windows = WTF::map(set, [] (auto&amp; keyValue) {
 319         return Ref&lt;DOMWindow&gt;(*(keyValue.key));
 320     });
 321 
 322     for (auto&amp; window : windows) {
 323         if (!set.contains(window.ptr()))
 324             continue;
 325 
 326         window-&gt;dispatchEvent(PageTransitionEvent::create(eventNames().pagehideEvent, false), window-&gt;document());
 327         window-&gt;dispatchEvent(Event::create(eventNames().unloadEvent, Event::CanBubble::No, Event::IsCancelable::No), window-&gt;document());
 328 
 329         window-&gt;enableSuddenTermination();
 330     }
 331 
 332     alreadyDispatched = true;
 333 }
 334 
 335 // This function:
 336 // 1) Validates the pending changes are not changing any value to NaN; in that case keep original value.
 337 // 2) Constrains the window rect to the minimum window size and no bigger than the float rect&#39;s dimensions.
 338 // 3) Constrains the window rect to within the top and left boundaries of the available screen rect.
 339 // 4) Constrains the window rect to within the bottom and right boundaries of the available screen rect.
 340 // 5) Translate the window rect coordinates to be within the coordinate space of the screen.
 341 FloatRect DOMWindow::adjustWindowRect(Page&amp; page, const FloatRect&amp; pendingChanges)
 342 {
 343     FloatRect screen = screenAvailableRect(page.mainFrame().view());
 344     FloatRect window = page.chrome().windowRect();
 345 
 346     // Make sure we&#39;re in a valid state before adjusting dimensions.
 347     ASSERT(std::isfinite(screen.x()));
 348     ASSERT(std::isfinite(screen.y()));
 349     ASSERT(std::isfinite(screen.width()));
 350     ASSERT(std::isfinite(screen.height()));
 351     ASSERT(std::isfinite(window.x()));
 352     ASSERT(std::isfinite(window.y()));
 353     ASSERT(std::isfinite(window.width()));
 354     ASSERT(std::isfinite(window.height()));
 355 
 356     // Update window values if new requested values are not NaN.
 357     if (!std::isnan(pendingChanges.x()))
 358         window.setX(pendingChanges.x());
 359     if (!std::isnan(pendingChanges.y()))
 360         window.setY(pendingChanges.y());
 361     if (!std::isnan(pendingChanges.width()))
 362         window.setWidth(pendingChanges.width());
 363     if (!std::isnan(pendingChanges.height()))
 364         window.setHeight(pendingChanges.height());
 365 
 366     FloatSize minimumSize = page.chrome().client().minimumWindowSize();
 367     window.setWidth(std::min(std::max(minimumSize.width(), window.width()), screen.width()));
 368     window.setHeight(std::min(std::max(minimumSize.height(), window.height()), screen.height()));
 369 
 370     // Constrain the window position within the valid screen area.
 371     window.setX(std::max(screen.x(), std::min(window.x(), screen.maxX() - window.width())));
 372     window.setY(std::max(screen.y(), std::min(window.y(), screen.maxY() - window.height())));
 373 
 374     return window;
 375 }
 376 
 377 bool DOMWindow::allowPopUp(Frame&amp; firstFrame)
 378 {
 379     if (DocumentLoader* documentLoader = firstFrame.loader().documentLoader()) {
 380         // If pop-up policy was set during navigation, use it. If not, use the global settings.
 381         PopUpPolicy popUpPolicy = documentLoader-&gt;popUpPolicy();
 382         if (popUpPolicy == PopUpPolicy::Allow)
 383             return true;
 384 
 385         if (popUpPolicy == PopUpPolicy::Block)
 386             return false;
 387     }
 388 
 389     return UserGestureIndicator::processingUserGesture()
 390         || firstFrame.settings().javaScriptCanOpenWindowsAutomatically();
 391 }
 392 
 393 bool DOMWindow::allowPopUp()
 394 {
 395     auto* frame = this-&gt;frame();
 396     return frame &amp;&amp; allowPopUp(*frame);
 397 }
 398 
 399 bool DOMWindow::canShowModalDialog(const Frame&amp; frame)
 400 {
 401     // Override support for layout testing purposes.
 402     if (auto* document = frame.document()) {
 403         if (auto* window = document-&gt;domWindow()) {
 404             if (window-&gt;m_canShowModalDialogOverride)
 405                 return window-&gt;m_canShowModalDialogOverride.value();
 406         }
 407     }
 408 
 409     auto* page = frame.page();
 410     return page &amp;&amp; page-&gt;chrome().canRunModal();
 411 }
 412 
 413 static void languagesChangedCallback(void* context)
 414 {
 415     static_cast&lt;DOMWindow*&gt;(context)-&gt;languagesChanged();
 416 }
 417 
 418 void DOMWindow::setCanShowModalDialogOverride(bool allow)
 419 {
 420     m_canShowModalDialogOverride = allow;
 421 }
 422 
 423 DOMWindow::DOMWindow(Document&amp; document)
 424     : AbstractDOMWindow(GlobalWindowIdentifier { Process::identifier(), WindowIdentifier::generate() })
 425     , ContextDestructionObserver(&amp;document)
 426 {
 427     ASSERT(frame());
 428     addLanguageChangeObserver(this, &amp;languagesChangedCallback);
 429 }
 430 
 431 void DOMWindow::didSecureTransitionTo(Document&amp; document)
 432 {
 433     observeContext(&amp;document);
 434 
 435     // The Window is being transferred from one document to another so we need to reset data
 436     // members that store the window&#39;s document (rather than the window itself).
 437     m_crypto = nullptr;
 438     m_navigator = nullptr;
 439     m_performance = nullptr;
 440 }
 441 
 442 void DOMWindow::prewarmLocalStorageIfNecessary()
 443 {
 444     auto* page = this-&gt;page();
 445 
 446     // No need to prewarm for ephemeral sessions since the data is in memory only.
 447     if (!page || page-&gt;usesEphemeralSession())
 448         return;
 449 
 450     if (!page-&gt;mainFrame().mayPrewarmLocalStorage())
 451         return;
 452 
<a name="5" id="anc5"></a><span class="line-added"> 453     // This eagerly constructs the StorageArea, which will load items from disk.</span>
 454     auto localStorageResult = this-&gt;localStorage();
 455     if (localStorageResult.hasException())
 456         return;
 457 
 458     auto* localStorage = localStorageResult.returnValue();
 459     if (!localStorage)
 460         return;
 461 
 462     page-&gt;mainFrame().didPrewarmLocalStorage();
 463 }
 464 
 465 DOMWindow::~DOMWindow()
 466 {
 467     if (m_suspendedForDocumentSuspension)
 468         willDestroyCachedFrame();
 469     else
 470         willDestroyDocumentInFrame();
 471 
 472     removeAllUnloadEventListeners(this);
 473     removeAllBeforeUnloadEventListeners(this);
 474 
 475 #if ENABLE(GAMEPAD)
 476     if (m_gamepadEventListenerCount)
 477         GamepadManager::singleton().unregisterDOMWindow(this);
 478 #endif
 479 
 480     removeLanguageChangeObserver(this);
 481 }
 482 
 483 RefPtr&lt;MediaQueryList&gt; DOMWindow::matchMedia(const String&amp; media)
 484 {
 485     return document() ? document()-&gt;mediaQueryMatcher().matchMedia(media) : nullptr;
 486 }
 487 
 488 Page* DOMWindow::page()
 489 {
 490     return frame() ? frame()-&gt;page() : nullptr;
 491 }
 492 
 493 void DOMWindow::frameDestroyed()
 494 {
 495     Ref&lt;DOMWindow&gt; protectedThis(*this);
 496 
 497     willDestroyDocumentInFrame();
 498     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 499 }
 500 
 501 void DOMWindow::willDestroyCachedFrame()
 502 {
 503     // It is necessary to copy m_observers to a separate vector because the Observer may
 504     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInCachedFrame.
 505     for (auto* observer : copyToVector(m_observers)) {
 506         if (m_observers.contains(observer))
 507             observer-&gt;willDestroyGlobalObjectInCachedFrame();
 508     }
 509 }
 510 
 511 void DOMWindow::willDestroyDocumentInFrame()
 512 {
 513     // It is necessary to copy m_observers to a separate vector because the Observer may
 514     // unregister themselves from the DOMWindow as a result of the call to willDestroyGlobalObjectInFrame.
 515     for (auto* observer : copyToVector(m_observers)) {
 516         if (m_observers.contains(observer))
 517             observer-&gt;willDestroyGlobalObjectInFrame();
 518     }
 519 }
 520 
 521 void DOMWindow::willDetachDocumentFromFrame()
 522 {
 523     if (!frame())
 524         return;
 525 
 526     RELEASE_ASSERT(!m_isSuspendingObservers);
 527 
 528     // It is necessary to copy m_observers to a separate vector because the Observer may
 529     // unregister themselves from the DOMWindow as a result of the call to willDetachGlobalObjectFromFrame.
 530     for (auto&amp; observer : copyToVector(m_observers)) {
 531         if (m_observers.contains(observer))
 532             observer-&gt;willDetachGlobalObjectFromFrame();
 533     }
 534 
 535     if (m_performance)
 536         m_performance-&gt;clearResourceTimings();
 537 
 538     JSDOMWindowBase::fireFrameClearedWatchpointsForWindow(this);
 539     InspectorInstrumentation::frameWindowDiscarded(*frame(), this);
 540 }
 541 
 542 #if ENABLE(GAMEPAD)
 543 
 544 void DOMWindow::incrementGamepadEventListenerCount()
 545 {
 546     if (++m_gamepadEventListenerCount == 1)
 547         GamepadManager::singleton().registerDOMWindow(this);
 548 }
 549 
 550 void DOMWindow::decrementGamepadEventListenerCount()
 551 {
 552     ASSERT(m_gamepadEventListenerCount);
 553 
 554     if (!--m_gamepadEventListenerCount)
 555         GamepadManager::singleton().unregisterDOMWindow(this);
 556 }
 557 
 558 #endif
 559 
 560 void DOMWindow::registerObserver(Observer&amp; observer)
 561 {
 562     m_observers.add(&amp;observer);
 563 }
 564 
 565 void DOMWindow::unregisterObserver(Observer&amp; observer)
 566 {
 567     m_observers.remove(&amp;observer);
 568 }
 569 
 570 void DOMWindow::resetUnlessSuspendedForDocumentSuspension()
 571 {
 572     if (m_suspendedForDocumentSuspension)
 573         return;
 574     willDestroyDocumentInFrame();
 575 }
 576 
<a name="6" id="anc6"></a><span class="line-modified"> 577 void DOMWindow::suspendForBackForwardCache()</span>
 578 {
 579     SetForScope&lt;bool&gt; isSuspendingObservers(m_isSuspendingObservers, true);
 580     RELEASE_ASSERT(frame());
 581 
 582     for (auto* observer : copyToVector(m_observers)) {
 583         if (m_observers.contains(observer))
<a name="7" id="anc7"></a><span class="line-modified"> 584             observer-&gt;suspendForBackForwardCache();</span>
 585     }
 586     RELEASE_ASSERT(frame());
 587 
 588     m_suspendedForDocumentSuspension = true;
 589 }
 590 
<a name="8" id="anc8"></a><span class="line-modified"> 591 void DOMWindow::resumeFromBackForwardCache()</span>
 592 {
 593     for (auto* observer : copyToVector(m_observers)) {
 594         if (m_observers.contains(observer))
<a name="9" id="anc9"></a><span class="line-modified"> 595             observer-&gt;resumeFromBackForwardCache();</span>
 596     }
 597 
 598     m_suspendedForDocumentSuspension = false;
 599 }
 600 
 601 bool DOMWindow::isCurrentlyDisplayedInFrame() const
 602 {
 603     auto* frame = this-&gt;frame();
 604     return frame &amp;&amp; frame-&gt;document()-&gt;domWindow() == this;
 605 }
 606 
 607 CustomElementRegistry&amp; DOMWindow::ensureCustomElementRegistry()
 608 {
 609     if (!m_customElementRegistry)
 610         m_customElementRegistry = CustomElementRegistry::create(*this, scriptExecutionContext());
 611     return *m_customElementRegistry;
 612 }
 613 
 614 static ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryInFrame(Frame* frame, const String&amp; selectors)
 615 {
 616     if (!frame)
 617         return Exception { NotSupportedError };
 618 
 619     Document* document = frame-&gt;document();
 620     if (!document)
 621         return Exception { NotSupportedError };
 622 
 623     return document-&gt;selectorQueryForString(selectors);
 624 }
 625 
 626 ExceptionOr&lt;Ref&lt;NodeList&gt;&gt; DOMWindow::collectMatchingElementsInFlatTree(Node&amp; scope, const String&amp; selectors)
 627 {
 628     auto queryOrException = selectorQueryInFrame(frame(), selectors);
 629     if (queryOrException.hasException())
 630         return queryOrException.releaseException();
 631 
 632     if (!is&lt;ContainerNode&gt;(scope))
 633         return Ref&lt;NodeList&gt; { StaticElementList::create() };
 634 
 635     SelectorQuery&amp; query = queryOrException.releaseReturnValue();
 636 
 637     Vector&lt;Ref&lt;Element&gt;&gt; result;
 638     for (auto&amp; node : composedTreeDescendants(downcast&lt;ContainerNode&gt;(scope))) {
 639         if (is&lt;Element&gt;(node) &amp;&amp; query.matches(downcast&lt;Element&gt;(node)) &amp;&amp; !node.isInUserAgentShadowTree())
 640             result.append(downcast&lt;Element&gt;(node));
 641     }
 642 
 643     return Ref&lt;NodeList&gt; { StaticElementList::create(WTFMove(result)) };
 644 }
 645 
 646 ExceptionOr&lt;RefPtr&lt;Element&gt;&gt; DOMWindow::matchingElementInFlatTree(Node&amp; scope, const String&amp; selectors)
 647 {
 648     auto queryOrException = selectorQueryInFrame(frame(), selectors);
 649     if (queryOrException.hasException())
 650         return queryOrException.releaseException();
 651 
 652     if (!is&lt;ContainerNode&gt;(scope))
 653         return RefPtr&lt;Element&gt; { nullptr };
 654 
 655     SelectorQuery&amp; query = queryOrException.releaseReturnValue();
 656 
 657     for (auto&amp; node : composedTreeDescendants(downcast&lt;ContainerNode&gt;(scope))) {
 658         if (is&lt;Element&gt;(node) &amp;&amp; query.matches(downcast&lt;Element&gt;(node)) &amp;&amp; !node.isInUserAgentShadowTree())
 659             return &amp;downcast&lt;Element&gt;(node);
 660     }
 661 
 662     return RefPtr&lt;Element&gt; { nullptr };
 663 }
 664 
 665 #if ENABLE(ORIENTATION_EVENTS)
 666 
 667 int DOMWindow::orientation() const
 668 {
 669     auto* frame = this-&gt;frame();
 670     if (!frame)
 671         return 0;
 672 
 673     return frame-&gt;orientation();
 674 }
 675 
 676 #endif
 677 
 678 Screen&amp; DOMWindow::screen()
 679 {
 680     if (!m_screen)
 681         m_screen = Screen::create(*this);
 682     return *m_screen;
 683 }
 684 
 685 History&amp; DOMWindow::history()
 686 {
 687     if (!m_history)
 688         m_history = History::create(*this);
 689     return *m_history;
 690 }
 691 
 692 Crypto&amp; DOMWindow::crypto() const
 693 {
 694     if (!m_crypto)
 695         m_crypto = Crypto::create(document());
 696     ASSERT(m_crypto-&gt;scriptExecutionContext() == document());
 697     return *m_crypto;
 698 }
 699 
 700 BarProp&amp; DOMWindow::locationbar()
 701 {
 702     if (!m_locationbar)
 703         m_locationbar = BarProp::create(*this, BarProp::Locationbar);
 704     return *m_locationbar;
 705 }
 706 
 707 BarProp&amp; DOMWindow::menubar()
 708 {
 709     if (!m_menubar)
 710         m_menubar = BarProp::create(*this, BarProp::Menubar);
 711     return *m_menubar;
 712 }
 713 
 714 BarProp&amp; DOMWindow::personalbar()
 715 {
 716     if (!m_personalbar)
 717         m_personalbar = BarProp::create(*this, BarProp::Personalbar);
 718     return *m_personalbar;
 719 }
 720 
 721 BarProp&amp; DOMWindow::scrollbars()
 722 {
 723     if (!m_scrollbars)
 724         m_scrollbars = BarProp::create(*this, BarProp::Scrollbars);
 725     return *m_scrollbars;
 726 }
 727 
 728 BarProp&amp; DOMWindow::statusbar()
 729 {
 730     if (!m_statusbar)
 731         m_statusbar = BarProp::create(*this, BarProp::Statusbar);
 732     return *m_statusbar;
 733 }
 734 
 735 BarProp&amp; DOMWindow::toolbar()
 736 {
 737     if (!m_toolbar)
 738         m_toolbar = BarProp::create(*this, BarProp::Toolbar);
 739     return *m_toolbar;
 740 }
 741 
 742 PageConsoleClient* DOMWindow::console() const
 743 {
 744     // FIXME: This should not return nullptr when frameless.
 745     if (!isCurrentlyDisplayedInFrame())
 746         return nullptr;
 747     auto* frame = this-&gt;frame();
 748     return frame-&gt;page() ? &amp;frame-&gt;page()-&gt;console() : nullptr;
 749 }
 750 
 751 DOMApplicationCache&amp; DOMWindow::applicationCache()
 752 {
 753     if (!m_applicationCache)
 754         m_applicationCache = DOMApplicationCache::create(*this);
 755     return *m_applicationCache;
 756 }
 757 
 758 Navigator&amp; DOMWindow::navigator()
 759 {
 760     if (!m_navigator)
 761         m_navigator = Navigator::create(scriptExecutionContext(), *this);
 762     ASSERT(m_navigator-&gt;scriptExecutionContext() == document());
 763 
 764     return *m_navigator;
 765 }
 766 
 767 Performance&amp; DOMWindow::performance() const
 768 {
 769     if (!m_performance) {
 770         MonotonicTime timeOrigin = document() &amp;&amp; document()-&gt;loader() ? document()-&gt;loader()-&gt;timing().referenceMonotonicTime() : MonotonicTime::now();
 771         m_performance = Performance::create(document(), timeOrigin);
 772     }
 773     ASSERT(m_performance-&gt;scriptExecutionContext() == document());
 774     return *m_performance;
 775 }
 776 
 777 double DOMWindow::nowTimestamp() const
 778 {
 779     return performance().now() / 1000.;
 780 }
 781 
 782 Location&amp; DOMWindow::location()
 783 {
 784     if (!m_location)
 785         m_location = Location::create(*this);
 786     return *m_location;
 787 }
 788 
 789 VisualViewport&amp; DOMWindow::visualViewport()
 790 {
 791     if (!m_visualViewport)
 792         m_visualViewport = VisualViewport::create(*this);
 793     return *m_visualViewport;
 794 }
 795 
 796 #if ENABLE(USER_MESSAGE_HANDLERS)
 797 
 798 bool DOMWindow::shouldHaveWebKitNamespaceForWorld(DOMWrapperWorld&amp; world)
 799 {
 800     auto* frame = this-&gt;frame();
 801     if (!frame)
 802         return false;
 803 
 804     auto* page = frame-&gt;page();
 805     if (!page)
 806         return false;
 807 
 808     bool hasUserMessageHandler = false;
 809     page-&gt;userContentProvider().forEachUserMessageHandler([&amp;](const UserMessageHandlerDescriptor&amp; descriptor) {
 810         if (&amp;descriptor.world() == &amp;world) {
 811             hasUserMessageHandler = true;
 812             return;
 813         }
 814     });
 815 
 816     return hasUserMessageHandler;
 817 }
 818 
 819 WebKitNamespace* DOMWindow::webkitNamespace()
 820 {
 821     if (!isCurrentlyDisplayedInFrame())
 822         return nullptr;
 823     auto* page = frame()-&gt;page();
 824     if (!page)
 825         return nullptr;
 826     if (!m_webkitNamespace)
 827         m_webkitNamespace = WebKitNamespace::create(*this, page-&gt;userContentProvider());
 828     return m_webkitNamespace.get();
 829 }
 830 
 831 #endif
 832 
 833 ExceptionOr&lt;Storage*&gt; DOMWindow::sessionStorage()
 834 {
 835     if (!isCurrentlyDisplayedInFrame())
 836         return nullptr;
 837 
 838     auto* document = this-&gt;document();
 839     if (!document)
 840         return nullptr;
 841 
 842     if (!document-&gt;securityOrigin().canAccessSessionStorage(document-&gt;topOrigin()))
 843         return Exception { SecurityError };
 844 
 845     if (m_sessionStorage)
 846         return m_sessionStorage.get();
 847 
 848     auto* page = document-&gt;page();
 849     if (!page)
 850         return nullptr;
 851 
 852     auto storageArea = page-&gt;sessionStorage()-&gt;storageArea(document-&gt;securityOrigin().data());
 853     m_sessionStorage = Storage::create(*this, WTFMove(storageArea));
 854     return m_sessionStorage.get();
 855 }
 856 
 857 ExceptionOr&lt;Storage*&gt; DOMWindow::localStorage()
 858 {
 859     if (!isCurrentlyDisplayedInFrame())
 860         return nullptr;
 861 
 862     auto* document = this-&gt;document();
 863     if (!document)
 864         return nullptr;
 865 
 866     if (!document-&gt;securityOrigin().canAccessLocalStorage(nullptr))
 867         return Exception { SecurityError };
 868 
 869     auto* page = document-&gt;page();
 870     // FIXME: We should consider supporting access/modification to local storage
 871     // after calling window.close(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=135330&gt;.
 872     if (!page || !page-&gt;isClosing()) {
 873         if (m_localStorage)
 874             return m_localStorage.get();
 875     }
 876 
 877     if (!page)
 878         return nullptr;
 879 
 880     if (page-&gt;isClosing())
 881         return nullptr;
 882 
 883     if (!page-&gt;settings().localStorageEnabled())
 884         return nullptr;
 885 
 886     auto storageArea = page-&gt;storageNamespaceProvider().localStorageArea(*document);
 887     m_localStorage = Storage::create(*this, WTFMove(storageArea));
 888     return m_localStorage.get();
 889 }
 890 
<a name="10" id="anc10"></a><span class="line-modified"> 891 ExceptionOr&lt;void&gt; DOMWindow::postMessage(JSC::JSGlobalObject&amp; lexicalGlobalObject, DOMWindow&amp; incumbentWindow, JSC::JSValue messageValue, WindowPostMessageOptions&amp;&amp; options)</span>
 892 {
 893     if (!isCurrentlyDisplayedInFrame())
 894         return { };
 895 
 896     Document* sourceDocument = incumbentWindow.document();
 897 
 898     // Compute the target origin.  We need to do this synchronously in order
 899     // to generate the SyntaxError exception correctly.
 900     RefPtr&lt;SecurityOrigin&gt; target;
<a name="11" id="anc11"></a><span class="line-modified"> 901     if (options.targetOrigin == &quot;/&quot;) {</span>
 902         if (!sourceDocument)
 903             return { };
 904         target = &amp;sourceDocument-&gt;securityOrigin();
<a name="12" id="anc12"></a><span class="line-modified"> 905     } else if (options.targetOrigin != &quot;*&quot;) {</span>
<span class="line-modified"> 906         target = SecurityOrigin::createFromString(options.targetOrigin);</span>
 907         // It doesn&#39;t make sense target a postMessage at a unique origin
 908         // because there&#39;s no way to represent a unique origin in a string.
 909         if (target-&gt;isUnique())
 910             return Exception { SyntaxError };
 911     }
 912 
 913     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<a name="13" id="anc13"></a><span class="line-modified"> 914     auto messageData = SerializedScriptValue::create(lexicalGlobalObject, messageValue, WTFMove(options.transfer), ports, SerializationContext::WindowPostMessage);</span>
 915     if (messageData.hasException())
 916         return messageData.releaseException();
 917 
 918     auto disentangledPorts = MessagePort::disentanglePorts(WTFMove(ports));
 919     if (disentangledPorts.hasException())
 920         return disentangledPorts.releaseException();
 921 
 922     // Capture the source of the message.  We need to do this synchronously
 923     // in order to capture the source of the message correctly.
 924     if (!sourceDocument)
 925         return { };
 926     auto sourceOrigin = sourceDocument-&gt;securityOrigin().toString();
 927 
 928     // Capture stack trace only when inspector front-end is loaded as it may be time consuming.
 929     RefPtr&lt;ScriptCallStack&gt; stackTrace;
 930     if (InspectorInstrumentation::consoleAgentEnabled(sourceDocument))
 931         stackTrace = createScriptCallStack(JSExecState::currentState());
 932 
 933     MessageWithMessagePorts message { messageData.releaseReturnValue(), disentangledPorts.releaseReturnValue() };
 934 
 935     // Schedule the message.
 936     RefPtr&lt;WindowProxy&gt; incumbentWindowProxy = incumbentWindow.frame() ? &amp;incumbentWindow.frame()-&gt;windowProxy() : nullptr;
 937     auto* timer = new PostMessageTimer(*this, WTFMove(message), sourceOrigin, WTFMove(incumbentWindowProxy), WTFMove(target), WTFMove(stackTrace));
 938     timer-&gt;startOneShot(0_s);
 939 
<a name="14" id="anc14"></a><span class="line-modified"> 940     InspectorInstrumentation::didPostMessage(*frame(), *timer, lexicalGlobalObject);</span>
 941 
 942     return { };
 943 }
 944 
 945 void DOMWindow::postMessageTimerFired(PostMessageTimer&amp; timer)
 946 {
 947     if (!document() || !isCurrentlyDisplayedInFrame())
 948         return;
 949 
 950     Ref&lt;Frame&gt; frame = *this-&gt;frame();
 951     if (auto* intendedTargetOrigin = timer.targetOrigin()) {
 952         // Check target origin now since the target document may have changed since the timer was scheduled.
 953         if (!intendedTargetOrigin-&gt;isSameSchemeHostPort(document()-&gt;securityOrigin())) {
 954             if (auto* pageConsole = console()) {
 955                 String message = makeString(&quot;Unable to post message to &quot;, intendedTargetOrigin-&gt;toString(), &quot;. Recipient has origin &quot;, document()-&gt;securityOrigin().toString(), &quot;.\n&quot;);
 956                 if (timer.stackTrace())
 957                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message, *timer.stackTrace());
 958                 else
 959                     pageConsole-&gt;addMessage(MessageSource::Security, MessageLevel::Error, message);
 960             }
 961 
 962             InspectorInstrumentation::didFailPostMessage(frame, timer);
 963             return;
 964         }
 965     }
 966 
 967     InspectorInstrumentation::willDispatchPostMessage(frame, timer);
 968 
 969     dispatchEvent(timer.event(*document()));
 970 
 971     InspectorInstrumentation::didDispatchPostMessage(frame, timer);
 972 }
 973 
 974 DOMSelection* DOMWindow::getSelection()
 975 {
 976     if (!isCurrentlyDisplayedInFrame())
 977         return nullptr;
 978     if (!m_selection)
 979         m_selection = DOMSelection::create(*this);
 980     return m_selection.get();
 981 }
 982 
 983 Element* DOMWindow::frameElement() const
 984 {
 985     auto* frame = this-&gt;frame();
 986     if (!frame)
 987         return nullptr;
 988 
 989     return frame-&gt;ownerElement();
 990 }
 991 
 992 void DOMWindow::focus(DOMWindow&amp; incumbentWindow)
 993 {
 994     auto* frame = this-&gt;frame();
 995     auto* openerFrame = frame ? frame-&gt;loader().opener() : nullptr;
 996     focus(openerFrame &amp;&amp; openerFrame != frame &amp;&amp; incumbentWindow.frame() == openerFrame);
 997 }
 998 
 999 void DOMWindow::focus(bool allowFocus)
1000 {
1001     if (!frame())
1002         return;
1003 
<a name="15" id="anc15"></a><span class="line-modified">1004     auto protectedFrame = makeRefPtr(frame());</span>
<span class="line-added">1005 </span>
<span class="line-added">1006     Page* page = protectedFrame-&gt;page();</span>
1007     if (!page)
1008         return;
1009 
<a name="16" id="anc16"></a><span class="line-modified">1010     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !protectedFrame-&gt;settings().windowFocusRestricted();</span>
1011 
1012     // If we&#39;re a top level window, bring the window to the front.
<a name="17" id="anc17"></a><span class="line-modified">1013     if (protectedFrame-&gt;isMainFrame() &amp;&amp; allowFocus)</span>
1014         page-&gt;chrome().focus();
1015 
<a name="18" id="anc18"></a><span class="line-modified">1016     if (!protectedFrame-&gt;hasHadUserInteraction() &amp;&amp; !isSameSecurityOriginAsMainFrame())</span>



1017         return;
1018 
1019     // Clear the current frame&#39;s focused node if a new frame is about to be focused.
<a name="19" id="anc19"></a><span class="line-modified">1020     auto focusedFrame = makeRefPtr(page-&gt;focusController().focusedFrame());</span>
<span class="line-modified">1021     if (focusedFrame &amp;&amp; focusedFrame != protectedFrame)</span>
1022         focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
1023 
<a name="20" id="anc20"></a><span class="line-modified">1024     protectedFrame-&gt;eventHandler().focusDocumentView();</span>


1025 }
1026 
1027 void DOMWindow::blur()
1028 {
1029     auto* frame = this-&gt;frame();
1030     if (!frame)
1031         return;
1032 
1033     Page* page = frame-&gt;page();
1034     if (!page)
1035         return;
1036 
1037     if (frame-&gt;settings().windowFocusRestricted())
1038         return;
1039 
1040     if (!frame-&gt;isMainFrame())
1041         return;
1042 
1043     page-&gt;chrome().unfocus();
1044 }
1045 
1046 void DOMWindow::close(Document&amp; document)
1047 {
1048     if (!document.canNavigate(frame()))
1049         return;
1050     close();
1051 }
1052 
1053 void DOMWindow::close()
1054 {
1055     auto* frame = this-&gt;frame();
1056     if (!frame)
1057         return;
1058 
1059     Page* page = frame-&gt;page();
1060     if (!page)
1061         return;
1062 
1063     if (!frame-&gt;isMainFrame())
1064         return;
1065 
1066     if (!(page-&gt;openedByDOM() || page-&gt;backForward().count() &lt;= 1)) {
1067         console()-&gt;addMessage(MessageSource::JS, MessageLevel::Warning, &quot;Can&#39;t close the window since it was not opened by JavaScript&quot;_s);
1068         return;
1069     }
1070 
1071     if (!frame-&gt;loader().shouldClose())
1072         return;
1073 
<a name="21" id="anc21"></a><span class="line-added">1074     ResourceLoadObserver::shared().updateCentralStatisticsStore();</span>
<span class="line-added">1075 </span>
1076     page-&gt;setIsClosing();
1077     page-&gt;chrome().closeWindowSoon();
1078 }
1079 
1080 void DOMWindow::print()
1081 {
1082     auto* frame = this-&gt;frame();
1083     if (!frame)
1084         return;
1085 
1086     auto* page = frame-&gt;page();
1087     if (!page)
1088         return;
1089 
1090     if (!page-&gt;arePromptsAllowed()) {
1091         printErrorMessage(&quot;Use of window.print is not allowed while unloading a page.&quot;);
1092         return;
1093     }
1094 
1095     if (frame-&gt;loader().activeDocumentLoader()-&gt;isLoading()) {
1096         m_shouldPrintWhenFinishedLoading = true;
1097         return;
1098     }
1099     m_shouldPrintWhenFinishedLoading = false;
1100     page-&gt;chrome().print(*frame);
1101 }
1102 
1103 void DOMWindow::stop()
1104 {
1105     auto* frame = this-&gt;frame();
1106     if (!frame)
1107         return;
1108 
1109     // We must check whether the load is complete asynchronously, because we might still be parsing
1110     // the document until the callstack unwinds.
1111     frame-&gt;loader().stopForUserCancel(true);
1112 }
1113 
1114 void DOMWindow::alert(const String&amp; message)
1115 {
1116     auto* frame = this-&gt;frame();
1117     if (!frame)
1118         return;
1119 
1120     if (document()-&gt;isSandboxed(SandboxModals)) {
1121         printErrorMessage(&quot;Use of window.alert is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1122         return;
1123     }
1124 
1125     auto* page = frame-&gt;page();
1126     if (!page)
1127         return;
1128 
1129     if (!page-&gt;arePromptsAllowed()) {
1130         printErrorMessage(&quot;Use of window.alert is not allowed while unloading a page.&quot;);
1131         return;
1132     }
1133 
1134     frame-&gt;document()-&gt;updateStyleIfNeeded();
1135 #if ENABLE(POINTER_LOCK)
1136     page-&gt;pointerLockController().requestPointerUnlock();
1137 #endif
1138 
1139     page-&gt;chrome().runJavaScriptAlert(*frame, message);
1140 }
1141 
<a name="22" id="anc22"></a><span class="line-modified">1142 bool DOMWindow::confirmForBindings(const String&amp; message)</span>
1143 {
1144     auto* frame = this-&gt;frame();
1145     if (!frame)
1146         return false;
1147 
1148     if (document()-&gt;isSandboxed(SandboxModals)) {
1149         printErrorMessage(&quot;Use of window.confirm is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1150         return false;
1151     }
1152 
1153     auto* page = frame-&gt;page();
1154     if (!page)
1155         return false;
1156 
1157     if (!page-&gt;arePromptsAllowed()) {
1158         printErrorMessage(&quot;Use of window.confirm is not allowed while unloading a page.&quot;);
1159         return false;
1160     }
1161 
1162     frame-&gt;document()-&gt;updateStyleIfNeeded();
1163 #if ENABLE(POINTER_LOCK)
1164     page-&gt;pointerLockController().requestPointerUnlock();
1165 #endif
1166 
1167     return page-&gt;chrome().runJavaScriptConfirm(*frame, message);
1168 }
1169 
1170 String DOMWindow::prompt(const String&amp; message, const String&amp; defaultValue)
1171 {
1172     auto* frame = this-&gt;frame();
1173     if (!frame)
1174         return String();
1175 
1176     if (document()-&gt;isSandboxed(SandboxModals)) {
1177         printErrorMessage(&quot;Use of window.prompt is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
1178         return String();
1179     }
1180 
1181     auto* page = frame-&gt;page();
1182     if (!page)
1183         return String();
1184 
1185     if (!page-&gt;arePromptsAllowed()) {
1186         printErrorMessage(&quot;Use of window.prompt is not allowed while unloading a page.&quot;);
1187         return String();
1188     }
1189 
1190     frame-&gt;document()-&gt;updateStyleIfNeeded();
1191 #if ENABLE(POINTER_LOCK)
1192     page-&gt;pointerLockController().requestPointerUnlock();
1193 #endif
1194 
1195     String returnValue;
1196     if (page-&gt;chrome().runJavaScriptPrompt(*frame, message, defaultValue, returnValue))
1197         return returnValue;
1198 
1199     return String();
1200 }
1201 
1202 bool DOMWindow::find(const String&amp; string, bool caseSensitive, bool backwards, bool wrap, bool /*wholeWord*/, bool /*searchInFrames*/, bool /*showDialog*/) const
1203 {
1204     if (!isCurrentlyDisplayedInFrame())
1205         return false;
1206 
1207     // FIXME (13016): Support wholeWord, searchInFrames and showDialog.
1208     FindOptions options { DoNotTraverseFlatTree };
1209     if (backwards)
1210         options.add(Backwards);
1211     if (!caseSensitive)
1212         options.add(CaseInsensitive);
1213     if (wrap)
1214         options.add(WrapAround);
1215     return frame()-&gt;editor().findString(string, options);
1216 }
1217 
1218 bool DOMWindow::offscreenBuffering() const
1219 {
1220     return true;
1221 }
1222 
1223 int DOMWindow::outerHeight() const
1224 {
1225 #if PLATFORM(IOS_FAMILY)
1226     if (!frame())
1227         return 0;
1228 
1229     auto* view = frame()-&gt;isMainFrame() ? frame()-&gt;view() : frame()-&gt;mainFrame().view();
1230     if (!view)
1231         return 0;
1232 
1233     return view-&gt;frameRect().height();
1234 #else
1235     auto* frame = this-&gt;frame();
1236     if (!frame)
1237         return 0;
1238 
1239     Page* page = frame-&gt;page();
1240     if (!page)
1241         return 0;
1242 
1243     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().height());
1244 #endif
1245 }
1246 
1247 int DOMWindow::outerWidth() const
1248 {
1249 #if PLATFORM(IOS_FAMILY)
1250     if (!frame())
1251         return 0;
1252 
1253     auto* view = frame()-&gt;isMainFrame() ? frame()-&gt;view() : frame()-&gt;mainFrame().view();
1254     if (!view)
1255         return 0;
1256 
1257     return view-&gt;frameRect().width();
1258 #else
1259     auto* frame = this-&gt;frame();
1260     if (!frame)
1261         return 0;
1262 
1263     Page* page = frame-&gt;page();
1264     if (!page)
1265         return 0;
1266 
1267     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().width());
1268 #endif
1269 }
1270 
1271 int DOMWindow::innerHeight() const
1272 {
1273     if (!frame())
1274         return 0;
1275 
1276     // Force enough layout in the parent document to ensure that the FrameView has been resized.
1277     if (auto ownerElement = makeRefPtr(frameElement()))
1278         ownerElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*ownerElement, HeightDimensionsCheck);
1279 
1280     auto frame = makeRefPtr(this-&gt;frame());
1281     if (!frame)
1282         return 0;
1283 
1284     auto view = makeRefPtr(frame-&gt;view());
1285     if (!view)
1286         return 0;
1287 
1288     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().height()));
1289 }
1290 
1291 int DOMWindow::innerWidth() const
1292 {
1293     if (!frame())
1294         return 0;
1295 
1296     // Force enough layout in the parent document to ensure that the FrameView has been resized.
1297     if (auto ownerElement = makeRefPtr(frameElement()))
1298         ownerElement-&gt;document().updateLayoutIfDimensionsOutOfDate(*ownerElement, WidthDimensionsCheck);
1299 
1300     auto frame = makeRefPtr(this-&gt;frame());
1301     if (!frame)
1302         return 0;
1303 
1304     auto view = makeRefPtr(frame-&gt;view());
1305     if (!view)
1306         return 0;
1307 
1308     return view-&gt;mapFromLayoutToCSSUnits(static_cast&lt;int&gt;(view-&gt;unobscuredContentRectIncludingScrollbars().width()));
1309 }
1310 
1311 int DOMWindow::screenX() const
1312 {
1313     auto frame = makeRefPtr(this-&gt;frame());
1314     if (!frame)
1315         return 0;
1316 
1317     Page* page = frame-&gt;page();
1318     if (!page)
1319         return 0;
1320 
1321     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().x());
1322 }
1323 
1324 int DOMWindow::screenY() const
1325 {
1326     auto frame = makeRefPtr(this-&gt;frame());
1327     if (!frame)
1328         return 0;
1329 
1330     Page* page = frame-&gt;page();
1331     if (!page)
1332         return 0;
1333 
1334     return static_cast&lt;int&gt;(page-&gt;chrome().windowRect().y());
1335 }
1336 
1337 int DOMWindow::scrollX() const
1338 {
1339     auto frame = makeRefPtr(this-&gt;frame());
1340     if (!frame)
1341         return 0;
1342 
1343     auto view = makeRefPtr(frame-&gt;view());
1344     if (!view)
1345         return 0;
1346 
1347     int scrollX = view-&gt;contentsScrollPosition().x();
1348     if (!scrollX)
1349         return 0;
1350 
1351     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1352 
1353     // Layout may have affected the current frame:
1354     auto frameAfterLayout = makeRefPtr(this-&gt;frame());
1355     if (!frameAfterLayout)
1356         return 0;
1357 
1358     auto viewAfterLayout = makeRefPtr(frameAfterLayout-&gt;view());
1359     if (!viewAfterLayout)
1360         return 0;
1361 
1362     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().x());
1363 }
1364 
1365 int DOMWindow::scrollY() const
1366 {
1367     auto frame = makeRefPtr(this-&gt;frame());
1368     if (!frame)
1369         return 0;
1370 
1371     auto view = makeRefPtr(frame-&gt;view());
1372     if (!view)
1373         return 0;
1374 
1375     int scrollY = view-&gt;contentsScrollPosition().y();
1376     if (!scrollY)
1377         return 0;
1378 
1379     frame-&gt;document()-&gt;updateLayoutIgnorePendingStylesheets();
1380 
1381     // Layout may have affected the current frame:
1382     auto frameAfterLayout = makeRefPtr(this-&gt;frame());
1383     if (!frameAfterLayout)
1384         return 0;
1385 
1386     auto viewAfterLayout = makeRefPtr(frameAfterLayout-&gt;view());
1387     if (!viewAfterLayout)
1388         return 0;
1389 
1390     return viewAfterLayout-&gt;mapFromLayoutToCSSUnits(viewAfterLayout-&gt;contentsScrollPosition().y());
1391 }
1392 
1393 bool DOMWindow::closed() const
1394 {
1395     auto* frame = this-&gt;frame();
1396     if (!frame)
1397         return true;
1398 
1399     auto* page = frame-&gt;page();
1400     return !page || page-&gt;isClosing();
1401 }
1402 
1403 unsigned DOMWindow::length() const
1404 {
1405     if (!isCurrentlyDisplayedInFrame())
1406         return 0;
1407 
1408     return frame()-&gt;tree().scopedChildCount();
1409 }
1410 
1411 String DOMWindow::name() const
1412 {
1413     auto* frame = this-&gt;frame();
1414     if (!frame)
1415         return String();
1416 
1417     return frame-&gt;tree().name();
1418 }
1419 
1420 void DOMWindow::setName(const String&amp; string)
1421 {
1422     auto* frame = this-&gt;frame();
1423     if (!frame)
1424         return;
1425 
1426     frame-&gt;tree().setName(string);
1427 }
1428 
1429 void DOMWindow::setStatus(const String&amp; string)
1430 {
1431     m_status = string;
1432 
1433     auto* frame = this-&gt;frame();
1434     if (!frame)
1435         return;
1436 
1437     Page* page = frame-&gt;page();
1438     if (!page)
1439         return;
1440 
1441     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1442     page-&gt;chrome().setStatusbarText(*frame, m_status);
1443 }
1444 
1445 void DOMWindow::setDefaultStatus(const String&amp; string)
1446 {
1447     m_defaultStatus = string;
1448 
1449     auto* frame = this-&gt;frame();
1450     if (!frame)
1451         return;
1452 
1453     Page* page = frame-&gt;page();
1454     if (!page)
1455         return;
1456 
1457     ASSERT(frame-&gt;document()); // Client calls shouldn&#39;t be made when the frame is in inconsistent state.
1458     page-&gt;chrome().setStatusbarText(*frame, m_defaultStatus);
1459 }
1460 
1461 WindowProxy* DOMWindow::opener() const
1462 {
1463     auto* frame = this-&gt;frame();
1464     if (!frame)
1465         return nullptr;
1466 
1467     auto* openerFrame = frame-&gt;loader().opener();
1468     if (!openerFrame)
1469         return nullptr;
1470 
1471     return &amp;openerFrame-&gt;windowProxy();
1472 }
1473 
1474 void DOMWindow::disownOpener()
1475 {
1476     if (auto* frame = this-&gt;frame())
1477         frame-&gt;loader().setOpener(nullptr);
1478 }
1479 
1480 WindowProxy* DOMWindow::parent() const
1481 {
1482     auto* frame = this-&gt;frame();
1483     if (!frame)
1484         return nullptr;
1485 
1486     auto* parentFrame = frame-&gt;tree().parent();
1487     if (parentFrame)
1488         return &amp;parentFrame-&gt;windowProxy();
1489 
1490     return &amp;frame-&gt;windowProxy();
1491 }
1492 
1493 WindowProxy* DOMWindow::top() const
1494 {
1495     auto* frame = this-&gt;frame();
1496     if (!frame)
1497         return nullptr;
1498 
1499     if (!frame-&gt;page())
1500         return nullptr;
1501 
1502     return &amp;frame-&gt;tree().top().windowProxy();
1503 }
1504 
1505 String DOMWindow::origin() const
1506 {
<a name="23" id="anc23"></a><span class="line-modified">1507     auto* document = this-&gt;document();</span>
1508     return document ? document-&gt;securityOrigin().toString() : emptyString();
1509 }
1510 
<a name="24" id="anc24"></a><span class="line-added">1511 SecurityOrigin* DOMWindow::securityOrigin() const</span>
<span class="line-added">1512 {</span>
<span class="line-added">1513     auto* document = this-&gt;document();</span>
<span class="line-added">1514     return document ? &amp;document-&gt;securityOrigin() : nullptr;</span>
<span class="line-added">1515 }</span>
<span class="line-added">1516 </span>
1517 Document* DOMWindow::document() const
1518 {
1519     return downcast&lt;Document&gt;(ContextDestructionObserver::scriptExecutionContext());
1520 }
1521 
<a name="25" id="anc25"></a><span class="line-added">1522 void DOMWindow::overrideTransientActivationDurationForTesting(Optional&lt;Seconds&gt;&amp;&amp; override)</span>
<span class="line-added">1523 {</span>
<span class="line-added">1524     transientActivationDurationOverrideForTesting() = WTFMove(override);</span>
<span class="line-added">1525 }</span>
<span class="line-added">1526 </span>
<span class="line-added">1527 // When the current high resolution time is greater than or equal to the last activation timestamp in W, and</span>
<span class="line-added">1528 // less than the last activation timestamp in W plus the transient activation duration, then W is said to</span>
<span class="line-added">1529 // have transient activation. (https://html.spec.whatwg.org/multipage/interaction.html#transient-activation)</span>
<span class="line-added">1530 bool DOMWindow::hasTransientActivation() const</span>
<span class="line-added">1531 {</span>
<span class="line-added">1532     auto now = MonotonicTime::now();</span>
<span class="line-added">1533     return now &gt;= m_lastActivationTimestamp &amp;&amp; now &lt; (m_lastActivationTimestamp + transientActivationDuration());</span>
<span class="line-added">1534 }</span>
<span class="line-added">1535 </span>
<span class="line-added">1536 // https://html.spec.whatwg.org/multipage/interaction.html#consume-user-activation</span>
<span class="line-added">1537 bool DOMWindow::consumeTransientActivation()</span>
<span class="line-added">1538 {</span>
<span class="line-added">1539     if (!hasTransientActivation())</span>
<span class="line-added">1540         return false;</span>
<span class="line-added">1541 </span>
<span class="line-added">1542     for (Frame* frame = this-&gt;frame() ? &amp;this-&gt;frame()-&gt;tree().top() : nullptr; frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">1543         auto* window = frame-&gt;window();</span>
<span class="line-added">1544         if (!window || window-&gt;lastActivationTimestamp() != MonotonicTime::infinity())</span>
<span class="line-added">1545             window-&gt;setLastActivationTimestamp(-MonotonicTime::infinity());</span>
<span class="line-added">1546     }</span>
<span class="line-added">1547 </span>
<span class="line-added">1548     return true;</span>
<span class="line-added">1549 }</span>
<span class="line-added">1550 </span>
<span class="line-added">1551 // https://html.spec.whatwg.org/multipage/interaction.html#activation-notification</span>
<span class="line-added">1552 void DOMWindow::notifyActivated(MonotonicTime activationTime)</span>
<span class="line-added">1553 {</span>
<span class="line-added">1554     setLastActivationTimestamp(activationTime);</span>
<span class="line-added">1555     if (!frame())</span>
<span class="line-added">1556         return;</span>
<span class="line-added">1557 </span>
<span class="line-added">1558     for (Frame* ancestor = frame() ? frame()-&gt;tree().parent() : nullptr; ancestor; ancestor = ancestor-&gt;tree().parent()) {</span>
<span class="line-added">1559         if (auto* window = ancestor-&gt;window())</span>
<span class="line-added">1560             window-&gt;setLastActivationTimestamp(activationTime);</span>
<span class="line-added">1561     }</span>
<span class="line-added">1562 </span>
<span class="line-added">1563     auto* securityOrigin = this-&gt;securityOrigin();</span>
<span class="line-added">1564     if (!securityOrigin)</span>
<span class="line-added">1565         return;</span>
<span class="line-added">1566 </span>
<span class="line-added">1567     auto* descendant = frame();</span>
<span class="line-added">1568     while ((descendant = descendant-&gt;tree().traverseNext(frame()))) {</span>
<span class="line-added">1569         auto* descendantWindow = descendant-&gt;window();</span>
<span class="line-added">1570         if (!descendantWindow)</span>
<span class="line-added">1571             continue;</span>
<span class="line-added">1572 </span>
<span class="line-added">1573         auto* descendantSecurityOrigin = descendantWindow-&gt;securityOrigin();</span>
<span class="line-added">1574         if (!descendantSecurityOrigin || !descendantSecurityOrigin-&gt;isSameOriginAs(*securityOrigin))</span>
<span class="line-added">1575             continue;</span>
<span class="line-added">1576 </span>
<span class="line-added">1577         descendantWindow-&gt;setLastActivationTimestamp(activationTime);</span>
<span class="line-added">1578     }</span>
<span class="line-added">1579 }</span>
<span class="line-added">1580 </span>
1581 StyleMedia&amp; DOMWindow::styleMedia()
1582 {
1583     if (!m_media)
1584         m_media = StyleMedia::create(*this);
1585     return *m_media;
1586 }
1587 
1588 Ref&lt;CSSStyleDeclaration&gt; DOMWindow::getComputedStyle(Element&amp; element, const String&amp; pseudoElt) const
1589 {
1590     return CSSComputedStyleDeclaration::create(element, false, pseudoElt);
1591 }
1592 
1593 RefPtr&lt;CSSRuleList&gt; DOMWindow::getMatchedCSSRules(Element* element, const String&amp; pseudoElement, bool authorOnly) const
1594 {
1595     if (!isCurrentlyDisplayedInFrame())
1596         return nullptr;
1597 
1598     unsigned colonStart = pseudoElement[0] == &#39;:&#39; ? (pseudoElement[1] == &#39;:&#39; ? 2 : 1) : 0;
1599     auto pseudoType = CSSSelector::parsePseudoElementType(StringView { pseudoElement }.substring(colonStart));
1600     if (pseudoType == CSSSelector::PseudoElementUnknown &amp;&amp; !pseudoElement.isEmpty())
1601         return nullptr;
1602 
1603     auto* frame = this-&gt;frame();
1604     frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
1605 
<a name="26" id="anc26"></a><span class="line-modified">1606     unsigned rulesToInclude = Style::Resolver::AuthorCSSRules;</span>
1607     if (!authorOnly)
<a name="27" id="anc27"></a><span class="line-modified">1608         rulesToInclude |= Style::Resolver::UAAndUserCSSRules;</span>
1609 
1610     PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
1611 
1612     auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
1613     if (matchedRules.isEmpty())
1614         return nullptr;
1615 
1616     bool allowCrossOrigin = frame-&gt;settings().crossOriginCheckInGetMatchedCSSRulesDisabled();
1617 
1618     auto ruleList = StaticCSSRuleList::create();
1619     for (auto&amp; rule : matchedRules) {
1620         if (!allowCrossOrigin &amp;&amp; !rule-&gt;hasDocumentSecurityOrigin())
1621             continue;
1622         ruleList-&gt;rules().append(rule-&gt;createCSSOMWrapper());
1623     }
1624 
1625     if (ruleList-&gt;rules().isEmpty())
1626         return nullptr;
1627 
1628     return ruleList;
1629 }
1630 
1631 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromNodeToPage(Node* node, const WebKitPoint* p) const
1632 {
1633     if (!node || !p)
1634         return nullptr;
1635 
1636     if (!document())
1637         return nullptr;
1638 
1639     document()-&gt;updateLayoutIgnorePendingStylesheets();
1640 
1641     FloatPoint pagePoint(p-&gt;x(), p-&gt;y());
1642     pagePoint = node-&gt;convertToPage(pagePoint);
1643     return WebKitPoint::create(pagePoint.x(), pagePoint.y());
1644 }
1645 
1646 RefPtr&lt;WebKitPoint&gt; DOMWindow::webkitConvertPointFromPageToNode(Node* node, const WebKitPoint* p) const
1647 {
1648     if (!node || !p)
1649         return nullptr;
1650 
1651     if (!document())
1652         return nullptr;
1653 
1654     document()-&gt;updateLayoutIgnorePendingStylesheets();
1655 
1656     FloatPoint nodePoint(p-&gt;x(), p-&gt;y());
1657     nodePoint = node-&gt;convertFromPage(nodePoint);
1658     return WebKitPoint::create(nodePoint.x(), nodePoint.y());
1659 }
1660 
1661 double DOMWindow::devicePixelRatio() const
1662 {
1663     auto* frame = this-&gt;frame();
1664     if (!frame)
1665         return 0.0;
1666 
1667     Page* page = frame-&gt;page();
1668     if (!page)
1669         return 0.0;
1670 
1671     return page-&gt;deviceScaleFactor();
1672 }
1673 
1674 void DOMWindow::scrollBy(double x, double y) const
1675 {
1676     scrollBy({ x, y });
1677 }
1678 
1679 void DOMWindow::scrollBy(const ScrollToOptions&amp; options) const
1680 {
1681     if (!isCurrentlyDisplayedInFrame())
1682         return;
1683 
1684     document()-&gt;updateLayoutIgnorePendingStylesheets();
1685 
<a name="28" id="anc28"></a><span class="line-modified">1686     auto* frame = this-&gt;frame();</span>
<span class="line-added">1687     if (!frame)</span>
<span class="line-added">1688         return;</span>
<span class="line-added">1689 </span>
<span class="line-added">1690     auto view = makeRefPtr(frame-&gt;view());</span>
1691     if (!view)
1692         return;
1693 
1694     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
1695     scrollToOptions.left.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().x());
1696     scrollToOptions.top.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().y());
1697     scrollTo(scrollToOptions);
1698 }
1699 
1700 void DOMWindow::scrollTo(double x, double y, ScrollClamping clamping) const
1701 {
1702     scrollTo({ x, y }, clamping);
1703 }
1704 
<a name="29" id="anc29"></a><span class="line-modified">1705 void DOMWindow::scrollTo(const ScrollToOptions&amp; options, ScrollClamping clamping) const</span>
1706 {
1707     if (!isCurrentlyDisplayedInFrame())
1708         return;
1709 
1710     RefPtr&lt;FrameView&gt; view = frame()-&gt;view();
1711     if (!view)
1712         return;
1713 
1714     ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options,
1715         view-&gt;contentsScrollPosition().x(), view-&gt;contentsScrollPosition().y()
1716     );
1717 
1718     if (!scrollToOptions.left.value() &amp;&amp; !scrollToOptions.top.value() &amp;&amp; view-&gt;contentsScrollPosition() == IntPoint(0, 0))
1719         return;
1720 
1721     document()-&gt;updateLayoutIgnorePendingStylesheets();
1722 
1723     IntPoint layoutPos(view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.left.value()), view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.top.value()));
<a name="30" id="anc30"></a><span class="line-modified">1724     view-&gt;setContentsScrollPosition(layoutPos, clamping);</span>
1725 }
1726 
1727 bool DOMWindow::allowedToChangeWindowGeometry() const
1728 {
1729     auto* frame = this-&gt;frame();
1730     if (!frame)
1731         return false;
1732     if (!frame-&gt;page())
1733         return false;
1734     if (!frame-&gt;isMainFrame())
1735         return false;
1736     // Prevent web content from tricking the user into initiating a drag.
1737     if (frame-&gt;eventHandler().mousePressed())
1738         return false;
1739     return true;
1740 }
1741 
1742 void DOMWindow::moveBy(float x, float y) const
1743 {
1744     if (!allowedToChangeWindowGeometry())
1745         return;
1746 
1747     auto* page = frame()-&gt;page();
1748     FloatRect fr = page-&gt;chrome().windowRect();
1749     FloatRect update = fr;
1750     update.move(x, y);
1751     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1752 }
1753 
1754 void DOMWindow::moveTo(float x, float y) const
1755 {
1756     if (!allowedToChangeWindowGeometry())
1757         return;
1758 
1759     auto* page = frame()-&gt;page();
1760     FloatRect fr = page-&gt;chrome().windowRect();
1761     FloatRect sr = screenAvailableRect(page-&gt;mainFrame().view());
1762     fr.setLocation(sr.location());
1763     FloatRect update = fr;
1764     update.move(x, y);
1765     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1766 }
1767 
1768 void DOMWindow::resizeBy(float x, float y) const
1769 {
1770     if (!allowedToChangeWindowGeometry())
1771         return;
1772 
1773     auto* page = frame()-&gt;page();
1774     FloatRect fr = page-&gt;chrome().windowRect();
1775     FloatSize dest = fr.size() + FloatSize(x, y);
1776     FloatRect update(fr.location(), dest);
1777     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1778 }
1779 
1780 void DOMWindow::resizeTo(float width, float height) const
1781 {
1782     if (!allowedToChangeWindowGeometry())
1783         return;
1784 
1785     auto* page = frame()-&gt;page();
1786     FloatRect fr = page-&gt;chrome().windowRect();
1787     FloatSize dest = FloatSize(width, height);
1788     FloatRect update(fr.location(), dest);
1789     page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
1790 }
1791 
<a name="31" id="anc31"></a><span class="line-modified">1792 ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
1793 {
1794     auto* context = scriptExecutionContext();
1795     if (!context)
1796         return Exception { InvalidAccessError };
1797 
1798     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1799     if (action-&gt;type() == ScheduledAction::Type::Code) {
1800         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1801             return 0;
1802     }
1803 
1804     action-&gt;addArguments(WTFMove(arguments));
1805 
1806     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
1807 }
1808 
1809 void DOMWindow::clearTimeout(int timeoutId)
1810 {
1811     ScriptExecutionContext* context = scriptExecutionContext();
1812     if (!context)
1813         return;
1814     DOMTimer::removeById(*context, timeoutId);
1815 }
1816 
<a name="32" id="anc32"></a><span class="line-modified">1817 ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
1818 {
1819     auto* context = scriptExecutionContext();
1820     if (!context)
1821         return Exception { InvalidAccessError };
1822 
1823     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
1824     if (action-&gt;type() == ScheduledAction::Type::Code) {
1825         if (!context-&gt;contentSecurityPolicy()-&gt;allowEval(&amp;state))
1826             return 0;
1827     }
1828 
1829     action-&gt;addArguments(WTFMove(arguments));
1830 
1831     return DOMTimer::install(*context, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
1832 }
1833 
1834 void DOMWindow::clearInterval(int timeoutId)
1835 {
1836     ScriptExecutionContext* context = scriptExecutionContext();
1837     if (!context)
1838         return;
1839     DOMTimer::removeById(*context, timeoutId);
1840 }
1841 
1842 int DOMWindow::requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1843 {
1844     auto* document = this-&gt;document();
1845     if (!document)
1846         return 0;
1847     return document-&gt;requestAnimationFrame(WTFMove(callback));
1848 }
1849 
1850 int DOMWindow::webkitRequestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp; callback)
1851 {
1852     static bool firstTime = true;
1853     if (firstTime &amp;&amp; document()) {
1854         document()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;webkitRequestAnimationFrame() is deprecated and will be removed. Please use requestAnimationFrame() instead.&quot;_s);
1855         firstTime = false;
1856     }
1857     return requestAnimationFrame(WTFMove(callback));
1858 }
1859 
1860 void DOMWindow::cancelAnimationFrame(int id)
1861 {
1862     auto* document = this-&gt;document();
1863     if (!document)
1864         return;
1865     document-&gt;cancelAnimationFrame(id);
1866 }
1867 
<a name="33" id="anc33"></a><span class="line-added">1868 int DOMWindow::requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp; callback, const IdleRequestOptions&amp; options)</span>
<span class="line-added">1869 {</span>
<span class="line-added">1870     auto document = makeRefPtr(this-&gt;document());</span>
<span class="line-added">1871     if (!document)</span>
<span class="line-added">1872         return 0;</span>
<span class="line-added">1873     return document-&gt;requestIdleCallback(WTFMove(callback), Seconds::fromMilliseconds(options.timeout));</span>
<span class="line-added">1874 }</span>
<span class="line-added">1875 </span>
<span class="line-added">1876 void DOMWindow::cancelIdleCallback(int id)</span>
<span class="line-added">1877 {</span>
<span class="line-added">1878     auto document = makeRefPtr(this-&gt;document());</span>
<span class="line-added">1879     if (!document)</span>
<span class="line-added">1880         return;</span>
<span class="line-added">1881     return document-&gt;cancelIdleCallback(id);</span>
<span class="line-added">1882 }</span>
<span class="line-added">1883 </span>
1884 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1885 {
1886     auto* document = this-&gt;document();
1887     if (!document) {
1888         promise.reject(InvalidStateError);
1889         return;
1890     }
1891     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), WTFMove(promise));
1892 }
1893 
1894 void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
1895 {
1896     auto* document = this-&gt;document();
1897     if (!document) {
1898         promise.reject(InvalidStateError);
1899         return;
1900     }
1901     ImageBitmap::createPromise(*document, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
1902 }
1903 
1904 bool DOMWindow::isSecureContext() const
1905 {
1906     auto* document = this-&gt;document();
1907     if (!document)
1908         return false;
1909     return document-&gt;isSecureContext();
1910 }
1911 
1912 static void didAddStorageEventListener(DOMWindow&amp; window)
1913 {
1914     // Creating these WebCore::Storage objects informs the system that we&#39;d like to receive
1915     // notifications about storage events that might be triggered in other processes. Rather
1916     // than subscribe to these notifications explicitly, we subscribe to them implicitly to
1917     // simplify the work done by the system.
1918     window.localStorage();
1919     window.sessionStorage();
1920 }
1921 
1922 bool DOMWindow::isSameSecurityOriginAsMainFrame() const
1923 {
1924     auto* frame = this-&gt;frame();
1925     if (!frame || !frame-&gt;page() || !document())
1926         return false;
1927 
1928     if (frame-&gt;isMainFrame())
1929         return true;
1930 
1931     Document* mainFrameDocument = frame-&gt;mainFrame().document();
1932 
1933     if (mainFrameDocument &amp;&amp; document()-&gt;securityOrigin().canAccess(mainFrameDocument-&gt;securityOrigin()))
1934         return true;
1935 
1936     return false;
1937 }
1938 
1939 bool DOMWindow::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
1940 {
1941     if (!EventTarget::addEventListener(eventType, WTFMove(listener), options))
1942         return false;
1943 
1944     auto* document = this-&gt;document();
1945     if (document) {
1946         document-&gt;addListenerTypeIfNeeded(eventType);
1947         if (eventNames().isWheelEventType(eventType))
1948             document-&gt;didAddWheelEventHandler(*document);
1949         else if (eventNames().isTouchRelatedEventType(*document, eventType))
1950             document-&gt;didAddTouchEventHandler(*document);
1951         else if (eventType == eventNames().storageEvent)
1952             didAddStorageEventListener(*this);
1953     }
1954 
1955     if (eventType == eventNames().unloadEvent)
1956         addUnloadEventListener(this);
1957     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
1958         addBeforeUnloadEventListener(this);
1959 #if PLATFORM(IOS_FAMILY)
1960     else if (eventType == eventNames().scrollEvent)
1961         incrementScrollEventListenersCount();
1962 #endif
1963 #if ENABLE(IOS_TOUCH_EVENTS)
1964     else if (document &amp;&amp; eventNames().isTouchRelatedEventType(*document, eventType))
1965         ++m_touchAndGestureEventListenerCount;
1966 #endif
1967 #if ENABLE(IOS_GESTURE_EVENTS)
1968     else if (eventNames().isGestureEventType(eventType))
1969         ++m_touchAndGestureEventListenerCount;
1970 #endif
1971 #if ENABLE(GAMEPAD)
1972     else if (eventNames().isGamepadEventType(eventType))
1973         incrementGamepadEventListenerCount();
1974 #endif
1975 #if ENABLE(DEVICE_ORIENTATION)
1976     else if (eventType == eventNames().deviceorientationEvent)
1977         startListeningForDeviceOrientationIfNecessary();
1978     else if (eventType == eventNames().devicemotionEvent)
1979         startListeningForDeviceMotionIfNecessary();
1980 #endif
1981 
1982     return true;
1983 }
1984 
1985 #if ENABLE(DEVICE_ORIENTATION)
1986 
1987 DeviceOrientationController* DOMWindow::deviceOrientationController() const
1988 {
1989 #if PLATFORM(IOS_FAMILY)
1990     return document() ? &amp;document()-&gt;deviceOrientationController() : nullptr;
1991 #else
1992     return DeviceOrientationController::from(page());
1993 #endif
1994 }
1995 
1996 DeviceMotionController* DOMWindow::deviceMotionController() const
1997 {
1998 #if PLATFORM(IOS_FAMILY)
1999     return document() ? &amp;document()-&gt;deviceMotionController() : nullptr;
2000 #else
2001     return DeviceMotionController::from(page());
2002 #endif
2003 }
2004 
2005 bool DOMWindow::isAllowedToUseDeviceMotionOrientation(String&amp; message) const
2006 {
2007     if (!frame() || !frame()-&gt;settings().deviceOrientationEventEnabled()) {
2008         message = &quot;API is disabled&quot;_s;
2009         return false;
2010     }
2011 
2012     if (!isSecureContext()) {
2013         message = &quot;Browsing context is not secure&quot;_s;
2014         return false;
2015     }
2016 
2017     if (!isSameSecurityOriginAsMainFrame()) {
2018         message = &quot;Source frame did not have the same security origin as the main page&quot;_s;
2019         return false;
2020     }
2021     return true;
2022 }
2023 
2024 bool DOMWindow::isAllowedToAddDeviceMotionOrientationListener(String&amp; message) const
2025 {
2026     String innerMessage;
2027     if (!isAllowedToUseDeviceMotionOrientation(innerMessage)) {
2028         message = makeString(&quot;Blocked attempt to add a device motion or orientation event listener, reason: &quot;, innerMessage, &quot;.&quot;);
2029         return false;
2030     }
2031 
2032     if (frame()-&gt;settings().deviceOrientationPermissionAPIEnabled()) {
2033         auto accessState = document()-&gt;deviceOrientationAndMotionAccessController().accessState();
2034         switch (accessState) {
2035         case DeviceOrientationOrMotionPermissionState::Denied:
2036             message = &quot;No device motion or orientation events will be fired because permission to use the API was denied.&quot;_s;
2037             return false;
2038         case DeviceOrientationOrMotionPermissionState::Prompt:
2039             message = &quot;No device motion or orientation events will be fired until permission has been requested and granted.&quot;_s;
2040             return false;
2041         case DeviceOrientationOrMotionPermissionState::Granted:
2042             break;
2043         }
2044     }
2045 
2046     return true;
2047 }
2048 
2049 void DOMWindow::startListeningForDeviceOrientationIfNecessary()
2050 {
2051     if (!hasEventListeners(eventNames().deviceorientationEvent))
2052         return;
2053 
2054     auto* deviceController = deviceOrientationController();
2055     if (!deviceController || deviceController-&gt;hasDeviceEventListener(*this))
2056         return;
2057 
2058     String errorMessage;
2059     if (!isAllowedToAddDeviceMotionOrientationListener(errorMessage)) {
2060         if (auto* document = this-&gt;document())
2061             document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, errorMessage);
2062         return;
2063     }
2064 
2065     deviceController-&gt;addDeviceEventListener(*this);
2066 }
2067 
2068 void DOMWindow::stopListeningForDeviceOrientationIfNecessary()
2069 {
2070     if (hasEventListeners(eventNames().deviceorientationEvent))
2071         return;
2072 
2073     if (auto* deviceController = deviceOrientationController())
2074         deviceController-&gt;removeDeviceEventListener(*this);
2075 }
2076 
2077 void DOMWindow::startListeningForDeviceMotionIfNecessary()
2078 {
2079     if (!hasEventListeners(eventNames().devicemotionEvent))
2080         return;
2081 
2082     auto* deviceController = deviceMotionController();
2083     if (!deviceController || deviceController-&gt;hasDeviceEventListener(*this))
2084         return;
2085 
2086     String errorMessage;
2087     if (!isAllowedToAddDeviceMotionOrientationListener(errorMessage)) {
2088         failedToRegisterDeviceMotionEventListener();
2089         if (auto* document = this-&gt;document())
2090             document-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, errorMessage);
2091         return;
2092     }
2093 
2094     deviceController-&gt;addDeviceEventListener(*this);
2095 }
2096 
2097 void DOMWindow::stopListeningForDeviceMotionIfNecessary()
2098 {
2099     if (hasEventListeners(eventNames().devicemotionEvent))
2100         return;
2101 
2102     if (auto* deviceController = deviceMotionController())
2103         deviceController-&gt;removeDeviceEventListener(*this);
2104 }
2105 
2106 void DOMWindow::failedToRegisterDeviceMotionEventListener()
2107 {
2108 #if PLATFORM(IOS_FAMILY)
2109     if (!isSameSecurityOriginAsMainFrame() || !isSecureContext())
2110         return;
2111 
2112     // FIXME: This is a quirk for chase.com on iPad (&lt;rdar://problem/48423023&gt;).
2113     if (RegistrableDomain::uncheckedCreateFromRegistrableDomainString(&quot;chase.com&quot;_s).matches(document()-&gt;url())) {
2114         // Fire a fake DeviceMotionEvent with acceleration data to unblock the site&#39;s login flow.
2115         document()-&gt;postTask([](auto&amp; context) {
2116             if (auto* window = downcast&lt;Document&gt;(context).domWindow()) {
2117                 auto acceleration = DeviceMotionData::Acceleration::create();
2118                 window-&gt;dispatchEvent(DeviceMotionEvent::create(eventNames().devicemotionEvent, DeviceMotionData::create(acceleration.copyRef(), acceleration.copyRef(), DeviceMotionData::RotationRate::create(), WTF::nullopt).ptr()));
2119             }
2120         });
2121     }
2122 #endif // PLATFORM(IOS_FAMILY)
2123 }
2124 
2125 #endif // ENABLE(DEVICE_ORIENTATION)
2126 
2127 #if PLATFORM(IOS_FAMILY)
2128 
2129 void DOMWindow::incrementScrollEventListenersCount()
2130 {
2131     Document* document = this-&gt;document();
2132     if (++m_scrollEventListenerCount == 1 &amp;&amp; document == &amp;document-&gt;topDocument()) {
2133         Frame* frame = this-&gt;frame();
2134         if (frame &amp;&amp; frame-&gt;page())
2135             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, true);
2136     }
2137 }
2138 
2139 void DOMWindow::decrementScrollEventListenersCount()
2140 {
2141     Document* document = this-&gt;document();
2142     if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
2143         Frame* frame = this-&gt;frame();
<a name="34" id="anc34"></a><span class="line-modified">2144         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;backForwardCacheState() == Document::NotInBackForwardCache)</span>
2145             frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
2146     }
2147 }
2148 
2149 #endif
2150 
2151 void DOMWindow::resetAllGeolocationPermission()
2152 {
2153     // FIXME: Can we remove the PLATFORM(IOS_FAMILY)-guard?
2154 #if ENABLE(GEOLOCATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2155     if (m_navigator)
2156         NavigatorGeolocation::from(*m_navigator)-&gt;resetAllGeolocationPermission();
2157 #endif
2158 }
2159 
2160 bool DOMWindow::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
2161 {
2162     if (!EventTarget::removeEventListener(eventType, listener, options.capture))
2163         return false;
2164 
2165     auto* document = this-&gt;document();
2166     if (document) {
2167         if (eventNames().isWheelEventType(eventType))
2168             document-&gt;didRemoveWheelEventHandler(*document);
2169         else if (eventNames().isTouchRelatedEventType(*document, eventType))
2170             document-&gt;didRemoveTouchEventHandler(*document);
2171     }
2172 
2173     if (eventType == eventNames().unloadEvent)
2174         removeUnloadEventListener(this);
2175     else if (eventType == eventNames().beforeunloadEvent &amp;&amp; allowsBeforeUnloadListeners(this))
2176         removeBeforeUnloadEventListener(this);
2177 #if PLATFORM(IOS_FAMILY)
2178     else if (eventType == eventNames().scrollEvent)
2179         decrementScrollEventListenersCount();
2180 #endif
2181 #if ENABLE(IOS_TOUCH_EVENTS)
2182     else if (document &amp;&amp; eventNames().isTouchRelatedEventType(*document, eventType)) {
2183         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2184         --m_touchAndGestureEventListenerCount;
2185     }
2186 #endif
2187 #if ENABLE(IOS_GESTURE_EVENTS)
2188     else if (eventNames().isGestureEventType(eventType)) {
2189         ASSERT(m_touchAndGestureEventListenerCount &gt; 0);
2190         --m_touchAndGestureEventListenerCount;
2191     }
2192 #endif
2193 #if ENABLE(GAMEPAD)
2194     else if (eventNames().isGamepadEventType(eventType))
2195         decrementGamepadEventListenerCount();
2196 #endif
2197 #if ENABLE(DEVICE_ORIENTATION)
2198     else if (eventType == eventNames().deviceorientationEvent)
2199         stopListeningForDeviceOrientationIfNecessary();
2200     else if (eventType == eventNames().devicemotionEvent)
2201         stopListeningForDeviceMotionIfNecessary();
2202 #endif
2203 
2204     return true;
2205 }
2206 
2207 void DOMWindow::languagesChanged()
2208 {
<a name="35" id="anc35"></a><span class="line-modified">2209     // https://html.spec.whatwg.org/multipage/system-state.html#dom-navigator-languages</span>
<span class="line-modified">2210     if (auto document = makeRefPtr(this-&gt;document()))</span>
<span class="line-added">2211         document-&gt;queueTaskToDispatchEventOnWindow(TaskSource::DOMManipulation, Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
2212 }
2213 
2214 void DOMWindow::dispatchLoadEvent()
2215 {
2216     // If we did not protect it, the document loader and its timing subobject might get destroyed
2217     // as a side effect of what event handling code does.
2218     auto protectedThis = makeRef(*this);
2219     auto protectedLoader = makeRefPtr(frame() ? frame()-&gt;loader().documentLoader() : nullptr);
2220     bool shouldMarkLoadEventTimes = protectedLoader &amp;&amp; !protectedLoader-&gt;timing().loadEventStart();
2221 
2222     if (shouldMarkLoadEventTimes)
2223         protectedLoader-&gt;timing().markLoadEventStart();
2224 
2225     dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No), document());
2226 
2227     if (shouldMarkLoadEventTimes)
2228         protectedLoader-&gt;timing().markLoadEventEnd();
2229 
2230     // Send a separate load event to the element that owns this frame.
2231     if (frame()) {
2232         if (auto* owner = frame()-&gt;ownerElement())
2233             owner-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
2234     }
2235 
2236     InspectorInstrumentation::loadEventFired(frame());
2237 }
2238 
2239 void DOMWindow::dispatchEvent(Event&amp; event, EventTarget* target)
2240 {
2241     // FIXME: It&#39;s confusing to have both the inherited EventTarget::dispatchEvent function
2242     // and this function, which does something nearly identical but subtly different if
2243     // called with a target of null. Most callers pass the document as the target, though.
2244     // Fixing this could allow us to remove the special case in DocumentEventQueue::dispatchEvent.
2245 
2246     auto protectedThis = makeRef(*this);
2247 
2248     // Pausing a page may trigger pagehide and pageshow events. WebCore also implicitly fires these
2249     // events when closing a WebView. Here we keep track of the state of the page to prevent duplicate,
2250     // unbalanced events per the definition of the pageshow event:
2251     // &lt;http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#event-pageshow&gt;.
2252     // FIXME: This code should go at call sites where pageshowEvent and pagehideEvents are
2253     // generated, not here inside the event dispatching process.
2254     if (event.eventInterface() == PageTransitionEventInterfaceType) {
2255         if (event.type() == eventNames().pageshowEvent) {
2256             if (m_lastPageStatus == PageStatus::Shown)
2257                 return; // Event was previously dispatched; do not fire a duplicate event.
2258             m_lastPageStatus = PageStatus::Shown;
2259         } else if (event.type() == eventNames().pagehideEvent) {
2260             if (m_lastPageStatus == PageStatus::Hidden)
2261                 return; // Event was previously dispatched; do not fire a duplicate event.
2262             m_lastPageStatus = PageStatus::Hidden;
2263         }
2264     }
2265 
2266     // FIXME: It doesn&#39;t seem right to have the inspector instrumentation here since not all
2267     // events dispatched to the window object are guaranteed to flow through this function.
2268     // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
2269     event.setTarget(target ? target : this);
2270     event.setCurrentTarget(this);
2271     event.setEventPhase(Event::AT_TARGET);
2272     event.resetBeforeDispatch();
<a name="36" id="anc36"></a><span class="line-modified">2273 </span>
<span class="line-added">2274     Frame* protectedFrame = nullptr;</span>
<span class="line-added">2275     bool hasListenersForEvent = false;</span>
<span class="line-added">2276     if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {</span>
<span class="line-added">2277         protectedFrame = frame();</span>
<span class="line-added">2278         hasListenersForEvent = hasEventListeners(event.type());</span>
<span class="line-added">2279         if (hasListenersForEvent)</span>
<span class="line-added">2280             InspectorInstrumentation::willDispatchEventOnWindow(protectedFrame, event, *this);</span>
<span class="line-added">2281     }</span>
<span class="line-added">2282 </span>
2283     // FIXME: We should use EventDispatcher everywhere.
2284     fireEventListeners(event, EventInvokePhase::Capturing);
2285     fireEventListeners(event, EventInvokePhase::Bubbling);
<a name="37" id="anc37"></a><span class="line-modified">2286 </span>
<span class="line-added">2287     if (hasListenersForEvent)</span>
<span class="line-added">2288         InspectorInstrumentation::didDispatchEventOnWindow(protectedFrame, event);</span>
<span class="line-added">2289 </span>
2290     event.resetAfterDispatch();
2291 }
2292 
2293 void DOMWindow::removeAllEventListeners()
2294 {
2295     EventTarget::removeAllEventListeners();
2296 
2297 #if ENABLE(DEVICE_ORIENTATION)
2298         stopListeningForDeviceOrientationIfNecessary();
2299         stopListeningForDeviceMotionIfNecessary();
2300 #endif
2301 
2302 #if PLATFORM(IOS_FAMILY)
2303     if (m_scrollEventListenerCount) {
2304         m_scrollEventListenerCount = 1;
2305         decrementScrollEventListenersCount();
2306     }
2307 #endif
2308 
2309 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
2310     m_touchAndGestureEventListenerCount = 0;
2311 #endif
2312 
2313 #if ENABLE(TOUCH_EVENTS)
2314     if (Document* document = this-&gt;document())
2315         document-&gt;didRemoveEventTargetNode(*document);
2316 #endif
2317 
2318     if (m_performance) {
2319         m_performance-&gt;removeAllEventListeners();
2320         m_performance-&gt;removeAllObservers();
2321     }
2322 
2323     removeAllUnloadEventListeners(this);
2324     removeAllBeforeUnloadEventListeners(this);
2325 }
2326 
2327 void DOMWindow::captureEvents()
2328 {
2329     // Not implemented.
2330 }
2331 
2332 void DOMWindow::releaseEvents()
2333 {
2334     // Not implemented.
2335 }
2336 
2337 void DOMWindow::finishedLoading()
2338 {
2339     if (m_shouldPrintWhenFinishedLoading) {
2340         m_shouldPrintWhenFinishedLoading = false;
2341         if (frame()-&gt;loader().activeDocumentLoader()-&gt;mainDocumentError().isNull())
2342             print();
2343     }
2344 }
2345 
2346 void DOMWindow::setLocation(DOMWindow&amp; activeWindow, const URL&amp; completedURL, SetLocationLocking locking)
2347 {
2348     if (!isCurrentlyDisplayedInFrame())
2349         return;
2350 
2351     Document* activeDocument = activeWindow.document();
2352     if (!activeDocument)
2353         return;
2354 
2355     auto* frame = this-&gt;frame();
2356     if (!activeDocument-&gt;canNavigate(frame, completedURL))
2357         return;
2358 
2359     if (isInsecureScriptAccess(activeWindow, completedURL))
2360         return;
2361 
2362     // We want a new history item if we are processing a user gesture.
2363     LockHistory lockHistory = (locking != LockHistoryBasedOnGestureState || !UserGestureIndicator::processingUserGesture()) ? LockHistory::Yes : LockHistory::No;
2364     LockBackForwardList lockBackForwardList = (locking != LockHistoryBasedOnGestureState) ? LockBackForwardList::Yes : LockBackForwardList::No;
2365     frame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(),
2366         // FIXME: What if activeDocument()-&gt;frame() is 0?
2367         completedURL, activeDocument-&gt;frame()-&gt;loader().outgoingReferrer(),
2368         lockHistory, lockBackForwardList);
2369 }
2370 
<a name="38" id="anc38"></a><span class="line-modified">2371 void DOMWindow::printErrorMessage(const String&amp; message) const</span>
2372 {
2373     if (message.isEmpty())
2374         return;
2375 
2376     if (PageConsoleClient* pageConsole = console())
2377         pageConsole-&gt;addMessage(MessageSource::JS, MessageLevel::Error, message);
2378 }
2379 
2380 String DOMWindow::crossDomainAccessErrorMessage(const DOMWindow&amp; activeWindow, IncludeTargetOrigin includeTargetOrigin)
2381 {
2382     const URL&amp; activeWindowURL = activeWindow.document()-&gt;url();
2383     if (activeWindowURL.isNull())
2384         return String();
2385 
2386     ASSERT(!activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()));
2387 
2388     // FIXME: This message, and other console messages, have extra newlines. Should remove them.
2389     SecurityOrigin&amp; activeOrigin = activeWindow.document()-&gt;securityOrigin();
2390     SecurityOrigin&amp; targetOrigin = document()-&gt;securityOrigin();
2391     String message;
2392     if (includeTargetOrigin == IncludeTargetOrigin::Yes)
2393         message = makeString(&quot;Blocked a frame with origin \&quot;&quot;, activeOrigin.toString(), &quot;\&quot; from accessing a frame with origin \&quot;&quot;, targetOrigin.toString(), &quot;\&quot;. &quot;);
2394     else
2395         message = makeString(&quot;Blocked a frame with origin \&quot;&quot;, activeOrigin.toString(), &quot;\&quot; from accessing a cross-origin frame. &quot;);
2396 
2397     // Sandbox errors: Use the origin of the frames&#39; location, rather than their actual origin (since we know that at least one will be &quot;null&quot;).
2398     URL activeURL = activeWindow.document()-&gt;url();
2399     URL targetURL = document()-&gt;url();
2400     if (document()-&gt;isSandboxed(SandboxOrigin) || activeWindow.document()-&gt;isSandboxed(SandboxOrigin)) {
2401         if (includeTargetOrigin == IncludeTargetOrigin::Yes)
2402             message = makeString(&quot;Blocked a frame at \&quot;&quot;, SecurityOrigin::create(activeURL).get().toString(), &quot;\&quot; from accessing a frame at \&quot;&quot;, SecurityOrigin::create(targetURL).get().toString(), &quot;\&quot;. &quot;);
2403         else
2404             message = makeString(&quot;Blocked a frame at \&quot;&quot;, SecurityOrigin::create(activeURL).get().toString(), &quot;\&quot; from accessing a cross-origin frame. &quot;);
2405 
2406         if (document()-&gt;isSandboxed(SandboxOrigin) &amp;&amp; activeWindow.document()-&gt;isSandboxed(SandboxOrigin))
2407             return makeString(&quot;Sandbox access violation: &quot;, message, &quot; Both frames are sandboxed and lack the \&quot;allow-same-origin\&quot; flag.&quot;);
2408         if (document()-&gt;isSandboxed(SandboxOrigin))
2409             return makeString(&quot;Sandbox access violation: &quot;, message, &quot; The frame being accessed is sandboxed and lacks the \&quot;allow-same-origin\&quot; flag.&quot;);
2410         return makeString(&quot;Sandbox access violation: &quot;, message, &quot; The frame requesting access is sandboxed and lacks the \&quot;allow-same-origin\&quot; flag.&quot;);
2411     }
2412 
2413     if (includeTargetOrigin == IncludeTargetOrigin::Yes) {
2414         // Protocol errors: Use the URL&#39;s protocol rather than the origin&#39;s protocol so that we get a useful message for non-heirarchal URLs like &#39;data:&#39;.
2415         if (targetOrigin.protocol() != activeOrigin.protocol())
2416             return message + &quot; The frame requesting access has a protocol of \&quot;&quot; + activeURL.protocol() + &quot;\&quot;, the frame being accessed has a protocol of \&quot;&quot; + targetURL.protocol() + &quot;\&quot;. Protocols must match.\n&quot;;
2417 
2418         // &#39;document.domain&#39; errors.
2419         if (targetOrigin.domainWasSetInDOM() &amp;&amp; activeOrigin.domainWasSetInDOM())
2420             return message + &quot;The frame requesting access set \&quot;document.domain\&quot; to \&quot;&quot; + activeOrigin.domain() + &quot;\&quot;, the frame being accessed set it to \&quot;&quot; + targetOrigin.domain() + &quot;\&quot;. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2421         if (activeOrigin.domainWasSetInDOM())
2422             return message + &quot;The frame requesting access set \&quot;document.domain\&quot; to \&quot;&quot; + activeOrigin.domain() + &quot;\&quot;, but the frame being accessed did not. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2423         if (targetOrigin.domainWasSetInDOM())
2424             return message + &quot;The frame being accessed set \&quot;document.domain\&quot; to \&quot;&quot; + targetOrigin.domain() + &quot;\&quot;, but the frame requesting access did not. Both must set \&quot;document.domain\&quot; to the same value to allow access.&quot;;
2425     }
2426 
2427     // Default.
2428     return message + &quot;Protocols, domains, and ports must match.&quot;;
2429 }
2430 
2431 bool DOMWindow::isInsecureScriptAccess(DOMWindow&amp; activeWindow, const String&amp; urlString)
2432 {
2433     if (!WTF::protocolIsJavaScript(urlString))
2434         return false;
2435 
2436     // If this DOMWindow isn&#39;t currently active in the Frame, then there&#39;s no
2437     // way we should allow the access.
2438     // FIXME: Remove this check if we&#39;re able to disconnect DOMWindow from
2439     // Frame on navigation: https://bugs.webkit.org/show_bug.cgi?id=62054
2440     if (isCurrentlyDisplayedInFrame()) {
2441         // FIXME: Is there some way to eliminate the need for a separate &quot;activeWindow == this&quot; check?
2442         if (&amp;activeWindow == this)
2443             return false;
2444 
2445         // FIXME: The name canAccess seems to be a roundabout way to ask &quot;can execute script&quot;.
2446         // Can we name the SecurityOrigin function better to make this more clear?
2447         if (activeWindow.document()-&gt;securityOrigin().canAccess(document()-&gt;securityOrigin()))
2448             return false;
2449     }
2450 
2451     printErrorMessage(crossDomainAccessErrorMessage(activeWindow, IncludeTargetOrigin::Yes));
2452     return true;
2453 }
2454 
2455 ExceptionOr&lt;RefPtr&lt;Frame&gt;&gt; DOMWindow::createWindow(const String&amp; urlString, const AtomString&amp; frameName, const WindowFeatures&amp; windowFeatures, DOMWindow&amp; activeWindow, Frame&amp; firstFrame, Frame&amp; openerFrame, const WTF::Function&lt;void(DOMWindow&amp;)&gt;&amp; prepareDialogFunction)
2456 {
2457     Frame* activeFrame = activeWindow.frame();
2458     if (!activeFrame)
2459         return RefPtr&lt;Frame&gt; { nullptr };
2460 
2461     Document* activeDocument = activeWindow.document();
2462     if (!activeDocument)
2463         return RefPtr&lt;Frame&gt; { nullptr };
2464 
2465     URL completedURL = urlString.isEmpty() ? URL({ }, emptyString()) : firstFrame.document()-&gt;completeURL(urlString);
2466     if (!completedURL.isEmpty() &amp;&amp; !completedURL.isValid())
2467         return Exception { SyntaxError };
2468 
2469     // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
2470     String referrer = windowFeatures.noreferrer ? String() : SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());
2471     auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
2472 
2473     ResourceRequest resourceRequest { completedURL, referrer };
<a name="39" id="anc39"></a>
2474     FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2475 
2476     // We pass the opener frame for the lookupFrame in case the active frame is different from
2477     // the opener frame, and the name references a frame relative to the opener frame.
2478     bool created;
2479     auto newFrame = WebCore::createWindow(*activeFrame, openerFrame, WTFMove(frameLoadRequest), windowFeatures, created);
2480     if (!newFrame)
2481         return RefPtr&lt;Frame&gt; { nullptr };
2482 
2483     bool noopener = windowFeatures.noopener || windowFeatures.noreferrer;
2484     if (!noopener)
2485         newFrame-&gt;loader().setOpener(&amp;openerFrame);
2486 
2487     if (created)
2488         newFrame-&gt;page()-&gt;setOpenedByDOM();
2489 
2490     if (newFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
2491         return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;
2492 
2493     if (prepareDialogFunction)
2494         prepareDialogFunction(*newFrame-&gt;document()-&gt;domWindow());
2495 
2496     if (created) {
2497         ResourceRequest resourceRequest { completedURL, referrer, ResourceRequestCachePolicy::UseProtocolCachePolicy };
2498         FrameLoader::addSameSiteInfoToRequestIfNeeded(resourceRequest, openerFrame.document());
2499         FrameLoadRequest frameLoadRequest { *activeWindow.document(), activeWindow.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
2500         newFrame-&gt;loader().changeLocation(WTFMove(frameLoadRequest));
2501     } else if (!urlString.isEmpty()) {
2502         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2503         newFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, referrer, lockHistory, LockBackForwardList::No);
2504     }
2505 
2506     // Navigating the new frame could result in it being detached from its page by a navigation policy delegate.
2507     if (!newFrame-&gt;page())
2508         return RefPtr&lt;Frame&gt; { nullptr };
2509 
2510     return noopener ? RefPtr&lt;Frame&gt; { nullptr } : newFrame;
2511 }
2512 
2513 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; DOMWindow::open(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; urlStringToOpen, const AtomString&amp; frameName, const String&amp; windowFeaturesString)
2514 {
2515     if (!isCurrentlyDisplayedInFrame())
2516         return RefPtr&lt;WindowProxy&gt; { nullptr };
2517 
2518     auto* activeDocument = activeWindow.document();
2519     if (!activeDocument)
2520         return RefPtr&lt;WindowProxy&gt; { nullptr };
2521 
2522     auto* firstFrame = firstWindow.frame();
2523     if (!firstFrame)
2524         return RefPtr&lt;WindowProxy&gt; { nullptr };
2525 
2526     auto urlString = urlStringToOpen;
2527     if (activeDocument-&gt;quirks().shouldOpenAsAboutBlank(urlStringToOpen))
2528         urlString = &quot;about:blank&quot;_s;
2529 
2530 #if ENABLE(CONTENT_EXTENSIONS)
2531     if (firstFrame-&gt;document()
2532         &amp;&amp; firstFrame-&gt;page()
2533         &amp;&amp; firstFrame-&gt;mainFrame().document()
2534         &amp;&amp; firstFrame-&gt;mainFrame().document()-&gt;loader()) {
2535         auto results = firstFrame-&gt;page()-&gt;userContentProvider().processContentRuleListsForLoad(firstFrame-&gt;document()-&gt;completeURL(urlString), ContentExtensions::ResourceType::Popup, *firstFrame-&gt;mainFrame().document()-&gt;loader());
2536         if (results.summary.blockedLoad)
2537             return RefPtr&lt;WindowProxy&gt; { nullptr };
2538     }
2539 #endif
2540 
2541     auto* frame = this-&gt;frame();
2542     if (!firstWindow.allowPopUp()) {
2543         // Because FrameTree::findFrameForNavigation() returns true for empty strings, we must check for empty frame names.
2544         // Otherwise, illegitimate window.open() calls with no name will pass right through the popup blocker.
2545         if (frameName.isEmpty() || !frame-&gt;loader().findFrameForNavigation(frameName, activeDocument))
2546             return RefPtr&lt;WindowProxy&gt; { nullptr };
2547     }
2548 
2549     // Get the target frame for the special cases of _top and _parent.
2550     // In those cases, we schedule a location change right now and return early.
2551     Frame* targetFrame = nullptr;
2552     if (equalIgnoringASCIICase(frameName, &quot;_top&quot;))
2553         targetFrame = &amp;frame-&gt;tree().top();
2554     else if (equalIgnoringASCIICase(frameName, &quot;_parent&quot;)) {
2555         if (Frame* parent = frame-&gt;tree().parent())
2556             targetFrame = parent;
2557         else
2558             targetFrame = frame;
2559     }
2560     if (targetFrame) {
2561         if (!activeDocument-&gt;canNavigate(targetFrame))
2562             return RefPtr&lt;WindowProxy&gt; { nullptr };
2563 
2564         URL completedURL = firstFrame-&gt;document()-&gt;completeURL(urlString);
2565 
2566         if (targetFrame-&gt;document()-&gt;domWindow()-&gt;isInsecureScriptAccess(activeWindow, completedURL))
2567             return &amp;targetFrame-&gt;windowProxy();
2568 
2569         if (urlString.isEmpty())
2570             return &amp;targetFrame-&gt;windowProxy();
2571 
2572         // For whatever reason, Firefox uses the first window rather than the active window to
2573         // determine the outgoing referrer. We replicate that behavior here.
2574         LockHistory lockHistory = UserGestureIndicator::processingUserGesture() ? LockHistory::No : LockHistory::Yes;
2575         targetFrame-&gt;navigationScheduler().scheduleLocationChange(*activeDocument, activeDocument-&gt;securityOrigin(), completedURL, firstFrame-&gt;loader().outgoingReferrer(),
2576             lockHistory, LockBackForwardList::No);
2577         return &amp;targetFrame-&gt;windowProxy();
2578     }
2579 
2580     auto newFrameOrException = createWindow(urlString, frameName, parseWindowFeatures(windowFeaturesString), activeWindow, *firstFrame, *frame);
2581     if (newFrameOrException.hasException())
2582         return newFrameOrException.releaseException();
2583 
2584     auto newFrame = newFrameOrException.releaseReturnValue();
2585     return newFrame ? &amp;newFrame-&gt;windowProxy() : RefPtr&lt;WindowProxy&gt; { nullptr };
2586 }
2587 
2588 void DOMWindow::showModalDialog(const String&amp; urlString, const String&amp; dialogFeaturesString, DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const WTF::Function&lt;void (DOMWindow&amp;)&gt;&amp; prepareDialogFunction)
2589 {
2590     if (!isCurrentlyDisplayedInFrame())
2591         return;
2592     if (!activeWindow.frame())
2593         return;
2594     Frame* firstFrame = firstWindow.frame();
2595     if (!firstFrame)
2596         return;
2597 
2598     auto* frame = this-&gt;frame();
2599     auto* page = frame-&gt;page();
2600     if (!page)
2601         return;
2602 
2603     if (!page-&gt;arePromptsAllowed()) {
2604         printErrorMessage(&quot;Use of window.showModalDialog is not allowed while unloading a page.&quot;);
2605         return;
2606     }
2607 
2608     if (!canShowModalDialog(*frame) || !firstWindow.allowPopUp())
2609         return;
2610 
2611     auto dialogFrameOrException = createWindow(urlString, emptyAtom(), parseDialogFeatures(dialogFeaturesString, screenAvailableRect(frame-&gt;view())), activeWindow, *firstFrame, *frame, prepareDialogFunction);
2612     if (dialogFrameOrException.hasException())
2613         return;
2614     RefPtr&lt;Frame&gt; dialogFrame = dialogFrameOrException.releaseReturnValue();
2615     if (!dialogFrame)
2616         return;
2617     dialogFrame-&gt;page()-&gt;chrome().runModal();
2618 }
2619 
2620 void DOMWindow::enableSuddenTermination()
2621 {
2622     if (Page* page = this-&gt;page())
2623         page-&gt;chrome().enableSuddenTermination();
2624 }
2625 
2626 void DOMWindow::disableSuddenTermination()
2627 {
2628     if (Page* page = this-&gt;page())
2629         page-&gt;chrome().disableSuddenTermination();
2630 }
2631 
2632 Frame* DOMWindow::frame() const
2633 {
2634     auto* document = this-&gt;document();
2635     return document ? document-&gt;frame() : nullptr;
2636 }
2637 
2638 } // namespace WebCore
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
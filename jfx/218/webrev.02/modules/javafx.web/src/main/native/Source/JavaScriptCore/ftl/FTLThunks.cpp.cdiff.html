<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLThunks.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLState.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLThunks.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLThunks.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 84,10 ***</span>
<span class="line-new-header">--- 84,11 ---</span>
  
      jit.loadPtr(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
      jit.peek(
          GPRInfo::argumentGPR1,
          (stackMisalignment - MacroAssembler::pushToSaveByteOffset()) / sizeof(void*));
<span class="line-added">+     jit.prepareCallOperation(vm);</span>
      MacroAssembler::Call functionCall = jit.call(OperationPtrTag);
  
      // At this point we want to make a tail call to what was returned to us in the
      // returnValueGPR. But at the same time as we do this, we must restore all registers.
      // The way we will accomplish this is by arranging to have the tail call target in the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,18 ***</span>
  
  MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitGenerationThunkGenerator(VM&amp; vm)
  {
      unsigned extraPopsToRestore = 0;
      return genericGenerationThunkGenerator(
<span class="line-modified">!         vm, compileFTLOSRExit, OSRExitPtrTag, &quot;FTL OSR exit generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::Needed);</span>
  }
  
  MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; lazySlowPathGenerationThunkGenerator(VM&amp; vm)
  {
      unsigned extraPopsToRestore = 1;
      return genericGenerationThunkGenerator(
<span class="line-modified">!         vm, compileFTLLazySlowPath, JITStubRoutinePtrTag, &quot;FTL lazy slow path generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::NotNeeded);</span>
  }
  
  static void registerClobberCheck(AssemblyHelpers&amp; jit, RegisterSet dontClobber)
  {
      if (!Options::clobberAllRegsInFTLICSlowPath())
<span class="line-new-header">--- 131,18 ---</span>
  
  MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitGenerationThunkGenerator(VM&amp; vm)
  {
      unsigned extraPopsToRestore = 0;
      return genericGenerationThunkGenerator(
<span class="line-modified">!         vm, operationCompileFTLOSRExit, OSRExitPtrTag, &quot;FTL OSR exit generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::Needed);</span>
  }
  
  MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; lazySlowPathGenerationThunkGenerator(VM&amp; vm)
  {
      unsigned extraPopsToRestore = 1;
      return genericGenerationThunkGenerator(
<span class="line-modified">!         vm, operationCompileFTLLazySlowPath, JITStubRoutinePtrTag, &quot;FTL lazy slow path generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::NotNeeded);</span>
  }
  
  static void registerClobberCheck(AssemblyHelpers&amp; jit, RegisterSet dontClobber)
  {
      if (!Options::clobberAllRegsInFTLICSlowPath())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,11 ***</span>
      clobber.exclude(RegisterSet::reservedHardwareRegisters());
      clobber.exclude(RegisterSet::stackRegisters());
      clobber.exclude(RegisterSet::calleeSaveRegisters());
      clobber.exclude(dontClobber);
  
<span class="line-modified">!     GPRReg someGPR;</span>
      for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
          if (!clobber.get(reg) || !reg.isGPR())
              continue;
  
          jit.move(AssemblyHelpers::TrustedImm32(0x1337beef), reg.gpr());
<span class="line-new-header">--- 152,11 ---</span>
      clobber.exclude(RegisterSet::reservedHardwareRegisters());
      clobber.exclude(RegisterSet::stackRegisters());
      clobber.exclude(RegisterSet::calleeSaveRegisters());
      clobber.exclude(dontClobber);
  
<span class="line-modified">!     GPRReg someGPR = InvalidGPRReg;</span>
      for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
          if (!clobber.get(reg) || !reg.isGPR())
              continue;
  
          jit.move(AssemblyHelpers::TrustedImm32(0x1337beef), reg.gpr());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,22 ***</span>
  
          jit.move64ToDouble(someGPR, reg.fpr());
      }
  }
  
<span class="line-modified">! MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; slowPathCallThunkGenerator(const SlowPathCallKey&amp; key)</span>
  {
      AssemblyHelpers jit(nullptr);
      jit.tagReturnAddress();
  
      // We want to save the given registers at the given offset, then we want to save the
      // old return address somewhere past that offset, and then finally we want to make the
      // call.
  
      size_t currentOffset = key.offset() + sizeof(void*);
  
<span class="line-modified">! #if CPU(X86) || CPU(X86_64)</span>
      currentOffset += sizeof(void*);
  #endif
  
      for (MacroAssembler::RegisterID reg = MacroAssembler::firstRegister(); reg &lt;= MacroAssembler::lastRegister(); reg = static_cast&lt;MacroAssembler::RegisterID&gt;(reg + 1)) {
          if (!key.usedRegisters().get(reg))
<span class="line-new-header">--- 169,22 ---</span>
  
          jit.move64ToDouble(someGPR, reg.fpr());
      }
  }
  
<span class="line-modified">! MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; slowPathCallThunkGenerator(VM&amp; vm, const SlowPathCallKey&amp; key)</span>
  {
      AssemblyHelpers jit(nullptr);
      jit.tagReturnAddress();
  
      // We want to save the given registers at the given offset, then we want to save the
      // old return address somewhere past that offset, and then finally we want to make the
      // call.
  
      size_t currentOffset = key.offset() + sizeof(void*);
  
<span class="line-modified">! #if CPU(X86_64)</span>
      currentOffset += sizeof(void*);
  #endif
  
      for (MacroAssembler::RegisterID reg = MacroAssembler::firstRegister(); reg &lt;= MacroAssembler::lastRegister(); reg = static_cast&lt;MacroAssembler::RegisterID&gt;(reg + 1)) {
          if (!key.usedRegisters().get(reg))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,10 ***</span>
<span class="line-new-header">--- 200,11 ---</span>
          currentOffset += sizeof(double);
      }
  
      jit.preserveReturnAddressAfterCall(GPRInfo::nonArgGPR0);
      jit.storePtr(GPRInfo::nonArgGPR0, AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, key.offset()));
<span class="line-added">+     jit.prepareCallOperation(vm);</span>
  
      registerClobberCheck(jit, key.argumentRegisters());
  
      AssemblyHelpers::Call call = jit.call(OperationPtrTag);
  
</pre>
<center><a href="FTLState.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLThunks.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleRule.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleRuleImport.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSSelectorList.h&quot;
 25 #include &quot;CompiledSelector.h&quot;
 26 #include &quot;StyleProperties.h&quot;

 27 #include &lt;wtf/RefPtr.h&gt;
 28 #include &lt;wtf/TypeCasts.h&gt;
 29 #include &lt;wtf/UniqueArray.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class CSSRule;
 34 class CSSStyleRule;
 35 class CSSStyleSheet;
 36 class MediaQuerySet;
 37 class MutableStyleProperties;
 38 class StyleRuleKeyframe;
 39 class StyleProperties;
 40 class StyleRuleKeyframes;
 41 

 42 class StyleRuleBase : public WTF::RefCountedBase {
<span class="line-modified"> 43     WTF_MAKE_FAST_ALLOCATED;</span>
 44 public:
<span class="line-modified"> 45     enum Type {</span>
<span class="line-modified"> 46         Unknown, // Not used.</span>
<span class="line-modified"> 47         Style,</span>
<span class="line-modified"> 48         Charset, // Not used. These are internally strings owned by the style sheet.</span>
<span class="line-modified"> 49         Import,</span>
<span class="line-modified"> 50         Media,</span>
<span class="line-modified"> 51         FontFace,</span>
<span class="line-modified"> 52         Page,</span>
<span class="line-modified"> 53         Keyframes,</span>
<span class="line-modified"> 54         Keyframe, // Not used. These are internally non-rule StyleRuleKeyframe objects.</span>
<span class="line-modified"> 55         Namespace,</span>
<span class="line-removed"> 56         Supports = 12,</span>
<span class="line-removed"> 57 #if ENABLE(CSS_DEVICE_ADAPTATION)</span>
<span class="line-removed"> 58         Viewport = 15,</span>
<span class="line-removed"> 59 #endif</span>
<span class="line-removed"> 60     };</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62     Type type() const { return static_cast&lt;Type&gt;(m_type); }</span>
<span class="line-removed"> 63 </span>
<span class="line-removed"> 64     bool isCharsetRule() const { return type() == Charset; }</span>
<span class="line-removed"> 65     bool isFontFaceRule() const { return type() == FontFace; }</span>
<span class="line-removed"> 66     bool isKeyframesRule() const { return type() == Keyframes; }</span>
<span class="line-removed"> 67     bool isKeyframeRule() const { return type() == Keyframe; }</span>
<span class="line-removed"> 68     bool isNamespaceRule() const { return type() == Namespace; }</span>
<span class="line-removed"> 69     bool isMediaRule() const { return type() == Media; }</span>
<span class="line-removed"> 70     bool isPageRule() const { return type() == Page; }</span>
<span class="line-removed"> 71     bool isStyleRule() const { return type() == Style; }</span>
<span class="line-removed"> 72     bool isSupportsRule() const { return type() == Supports; }</span>
 73 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified"> 74     bool isViewportRule() const { return type() == Viewport; }</span>
 75 #endif
<span class="line-modified"> 76     bool isImportRule() const { return type() == Import; }</span>
 77 
 78     Ref&lt;StyleRuleBase&gt; copy() const;
 79 
<span class="line-modified"> 80     void deref()</span>
 81     {
 82         if (derefBase())
<span class="line-modified"> 83             destroy();</span>
 84     }
 85 
 86     // FIXME: There shouldn&#39;t be any need for the null parent version.
 87     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSStyleSheet* parentSheet = nullptr) const;
 88     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSRule* parentRule) const;
 89 
 90 protected:
<span class="line-modified"> 91     StyleRuleBase(Type type, bool hasDocumentSecurityOrigin = false)</span>
<span class="line-modified"> 92         : m_type(type)</span>
 93         , m_hasDocumentSecurityOrigin(hasDocumentSecurityOrigin)
 94     {
 95     }
 96 
 97     StyleRuleBase(const StyleRuleBase&amp; o)
 98         : WTF::RefCountedBase()
 99         , m_type(o.m_type)
100         , m_hasDocumentSecurityOrigin(o.m_hasDocumentSecurityOrigin)
101     {
102     }
103 
104     ~StyleRuleBase() = default;
105 
106     bool hasDocumentSecurityOrigin() const { return m_hasDocumentSecurityOrigin; }
107 
108 private:
109     WEBCORE_EXPORT void destroy();
110 
111     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSStyleSheet* parentSheet, CSSRule* parentRule) const;
112 
<span class="line-modified">113     unsigned m_type : 5;</span>
114     // This is only needed to support getMatchedCSSRules.
115     unsigned m_hasDocumentSecurityOrigin : 1;
116 };
117 

118 class StyleRule final : public StyleRuleBase {
<span class="line-modified">119     WTF_MAKE_FAST_ALLOCATED;</span>
120 public:
121     static Ref&lt;StyleRule&gt; create(Ref&lt;StylePropertiesBase&gt;&amp;&amp; properties, bool hasDocumentSecurityOrigin, CSSSelectorList&amp;&amp; selectors)
122     {
123         return adoptRef(*new StyleRule(WTFMove(properties), hasDocumentSecurityOrigin, WTFMove(selectors)));
124     }
125 
126     ~StyleRule();
127 
128     const CSSSelectorList&amp; selectorList() const { return m_selectorList; }
129 
130     const StyleProperties&amp; properties() const;
131     MutableStyleProperties&amp; mutableProperties();
132     const StyleProperties* propertiesWithoutDeferredParsing() const;
133 
134     using StyleRuleBase::hasDocumentSecurityOrigin;
135 
136     void wrapperAdoptSelectorList(CSSSelectorList&amp;&amp; selectors)
137     {
138         m_selectorList = WTFMove(selectors);
139 #if ENABLE(CSS_SELECTOR_JIT)
140         m_compiledSelectors = nullptr;
141 #endif
142     }
143 
144     Ref&lt;StyleRule&gt; copy() const { return adoptRef(*new StyleRule(*this)); }
145 
146     Vector&lt;RefPtr&lt;StyleRule&gt;&gt; splitIntoMultipleRulesWithMaximumSelectorComponentCount(unsigned) const;
147 
148 #if ENABLE(CSS_SELECTOR_JIT)
<span class="line-modified">149     CompiledSelector&amp; compiledSelectorForListIndex(unsigned index)</span>
150     {
151         if (!m_compiledSelectors)
152             m_compiledSelectors = makeUniqueArray&lt;CompiledSelector&gt;(m_selectorList.listSize());
153         return m_compiledSelectors[index];
154     }
155     void releaseCompiledSelectors() const
156     {
157         m_compiledSelectors = nullptr;
158     }
159 #endif
160 
161     static unsigned averageSizeInBytes();
162 
163 private:
164     StyleRule(Ref&lt;StylePropertiesBase&gt;&amp;&amp;, bool hasDocumentSecurityOrigin, CSSSelectorList&amp;&amp;);
165     StyleRule(const StyleRule&amp;);
166 
167     static Ref&lt;StyleRule&gt; createForSplitting(const Vector&lt;const CSSSelector*&gt;&amp;, Ref&lt;StyleProperties&gt;&amp;&amp;, bool hasDocumentSecurityOrigin);
168 
169     mutable Ref&lt;StylePropertiesBase&gt; m_properties;
</pre>
<hr />
<pre>
224 public:
225     DeferredStyleGroupRuleList(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
226 
227     void parseDeferredRules(Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp;);
228     void parseDeferredKeyframes(StyleRuleKeyframes&amp;);
229 
230 private:
231     Vector&lt;CSSParserToken&gt; m_tokens;
232     Ref&lt;CSSDeferredParser&gt; m_parser;
233 };
234 
235 class StyleRuleGroup : public StyleRuleBase {
236 public:
237     const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules() const;
238     const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;* childRulesWithoutDeferredParsing() const;
239 
240     void wrapperInsertRule(unsigned, Ref&lt;StyleRuleBase&gt;&amp;&amp;);
241     void wrapperRemoveRule(unsigned);
242 
243 protected:
<span class="line-modified">244     StyleRuleGroup(Type, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp;);</span>
<span class="line-modified">245     StyleRuleGroup(Type, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp;);</span>
246     StyleRuleGroup(const StyleRuleGroup&amp;);
247 
248 private:
249     void parseDeferredRulesIfNeeded() const;
250 
251     mutable Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; m_childRules;
252     mutable std::unique_ptr&lt;DeferredStyleGroupRuleList&gt; m_deferredRules;
253 };
254 
255 inline const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;* StyleRuleGroup::childRulesWithoutDeferredParsing() const
256 {
257     return !m_deferredRules ? &amp;m_childRules : nullptr;
258 }
259 
260 class StyleRuleMedia final : public StyleRuleGroup {
261 public:
262     static Ref&lt;StyleRuleMedia&gt; create(Ref&lt;MediaQuerySet&gt;&amp;&amp; media, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules)
263     {
264         return adoptRef(*new StyleRuleMedia(WTFMove(media), adoptRules));
265     }
</pre>
</td>
<td>
<hr />
<pre>
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSSelectorList.h&quot;
 25 #include &quot;CompiledSelector.h&quot;
 26 #include &quot;StyleProperties.h&quot;
<span class="line-added"> 27 #include &quot;StyleRuleType.h&quot;</span>
 28 #include &lt;wtf/RefPtr.h&gt;
 29 #include &lt;wtf/TypeCasts.h&gt;
 30 #include &lt;wtf/UniqueArray.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class CSSRule;
 35 class CSSStyleRule;
 36 class CSSStyleSheet;
 37 class MediaQuerySet;
 38 class MutableStyleProperties;
 39 class StyleRuleKeyframe;
 40 class StyleProperties;
 41 class StyleRuleKeyframes;
 42 
<span class="line-added"> 43 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRuleBase);</span>
 44 class StyleRuleBase : public WTF::RefCountedBase {
<span class="line-modified"> 45     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleRuleBase);</span>
 46 public:
<span class="line-modified"> 47     StyleRuleType type() const { return static_cast&lt;StyleRuleType&gt;(m_type); }</span>
<span class="line-modified"> 48 </span>
<span class="line-modified"> 49     bool isCharsetRule() const { return type() == StyleRuleType::Charset; }</span>
<span class="line-modified"> 50     bool isFontFaceRule() const { return type() == StyleRuleType::FontFace; }</span>
<span class="line-modified"> 51     bool isKeyframesRule() const { return type() == StyleRuleType::Keyframes; }</span>
<span class="line-modified"> 52     bool isKeyframeRule() const { return type() == StyleRuleType::Keyframe; }</span>
<span class="line-modified"> 53     bool isNamespaceRule() const { return type() == StyleRuleType::Namespace; }</span>
<span class="line-modified"> 54     bool isMediaRule() const { return type() == StyleRuleType::Media; }</span>
<span class="line-modified"> 55     bool isPageRule() const { return type() == StyleRuleType::Page; }</span>
<span class="line-modified"> 56     bool isStyleRule() const { return type() == StyleRuleType::Style; }</span>
<span class="line-modified"> 57     bool isSupportsRule() const { return type() == StyleRuleType::Supports; }</span>

















 58 #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified"> 59     bool isViewportRule() const { return type() == StyleRuleType::Viewport; }</span>
 60 #endif
<span class="line-modified"> 61     bool isImportRule() const { return type() == StyleRuleType::Import; }</span>
 62 
 63     Ref&lt;StyleRuleBase&gt; copy() const;
 64 
<span class="line-modified"> 65     void deref() const</span>
 66     {
 67         if (derefBase())
<span class="line-modified"> 68             const_cast&lt;StyleRuleBase&amp;&gt;(*this).destroy();</span>
 69     }
 70 
 71     // FIXME: There shouldn&#39;t be any need for the null parent version.
 72     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSStyleSheet* parentSheet = nullptr) const;
 73     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSRule* parentRule) const;
 74 
 75 protected:
<span class="line-modified"> 76     StyleRuleBase(StyleRuleType type, bool hasDocumentSecurityOrigin = false)</span>
<span class="line-modified"> 77         : m_type(static_cast&lt;unsigned&gt;(type))</span>
 78         , m_hasDocumentSecurityOrigin(hasDocumentSecurityOrigin)
 79     {
 80     }
 81 
 82     StyleRuleBase(const StyleRuleBase&amp; o)
 83         : WTF::RefCountedBase()
 84         , m_type(o.m_type)
 85         , m_hasDocumentSecurityOrigin(o.m_hasDocumentSecurityOrigin)
 86     {
 87     }
 88 
 89     ~StyleRuleBase() = default;
 90 
 91     bool hasDocumentSecurityOrigin() const { return m_hasDocumentSecurityOrigin; }
 92 
 93 private:
 94     WEBCORE_EXPORT void destroy();
 95 
 96     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSStyleSheet* parentSheet, CSSRule* parentRule) const;
 97 
<span class="line-modified"> 98     unsigned m_type : 5; // StyleRuleType</span>
 99     // This is only needed to support getMatchedCSSRules.
100     unsigned m_hasDocumentSecurityOrigin : 1;
101 };
102 
<span class="line-added">103 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRule);</span>
104 class StyleRule final : public StyleRuleBase {
<span class="line-modified">105     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleRule);</span>
106 public:
107     static Ref&lt;StyleRule&gt; create(Ref&lt;StylePropertiesBase&gt;&amp;&amp; properties, bool hasDocumentSecurityOrigin, CSSSelectorList&amp;&amp; selectors)
108     {
109         return adoptRef(*new StyleRule(WTFMove(properties), hasDocumentSecurityOrigin, WTFMove(selectors)));
110     }
111 
112     ~StyleRule();
113 
114     const CSSSelectorList&amp; selectorList() const { return m_selectorList; }
115 
116     const StyleProperties&amp; properties() const;
117     MutableStyleProperties&amp; mutableProperties();
118     const StyleProperties* propertiesWithoutDeferredParsing() const;
119 
120     using StyleRuleBase::hasDocumentSecurityOrigin;
121 
122     void wrapperAdoptSelectorList(CSSSelectorList&amp;&amp; selectors)
123     {
124         m_selectorList = WTFMove(selectors);
125 #if ENABLE(CSS_SELECTOR_JIT)
126         m_compiledSelectors = nullptr;
127 #endif
128     }
129 
130     Ref&lt;StyleRule&gt; copy() const { return adoptRef(*new StyleRule(*this)); }
131 
132     Vector&lt;RefPtr&lt;StyleRule&gt;&gt; splitIntoMultipleRulesWithMaximumSelectorComponentCount(unsigned) const;
133 
134 #if ENABLE(CSS_SELECTOR_JIT)
<span class="line-modified">135     CompiledSelector&amp; compiledSelectorForListIndex(unsigned index) const</span>
136     {
137         if (!m_compiledSelectors)
138             m_compiledSelectors = makeUniqueArray&lt;CompiledSelector&gt;(m_selectorList.listSize());
139         return m_compiledSelectors[index];
140     }
141     void releaseCompiledSelectors() const
142     {
143         m_compiledSelectors = nullptr;
144     }
145 #endif
146 
147     static unsigned averageSizeInBytes();
148 
149 private:
150     StyleRule(Ref&lt;StylePropertiesBase&gt;&amp;&amp;, bool hasDocumentSecurityOrigin, CSSSelectorList&amp;&amp;);
151     StyleRule(const StyleRule&amp;);
152 
153     static Ref&lt;StyleRule&gt; createForSplitting(const Vector&lt;const CSSSelector*&gt;&amp;, Ref&lt;StyleProperties&gt;&amp;&amp;, bool hasDocumentSecurityOrigin);
154 
155     mutable Ref&lt;StylePropertiesBase&gt; m_properties;
</pre>
<hr />
<pre>
210 public:
211     DeferredStyleGroupRuleList(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
212 
213     void parseDeferredRules(Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp;);
214     void parseDeferredKeyframes(StyleRuleKeyframes&amp;);
215 
216 private:
217     Vector&lt;CSSParserToken&gt; m_tokens;
218     Ref&lt;CSSDeferredParser&gt; m_parser;
219 };
220 
221 class StyleRuleGroup : public StyleRuleBase {
222 public:
223     const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules() const;
224     const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;* childRulesWithoutDeferredParsing() const;
225 
226     void wrapperInsertRule(unsigned, Ref&lt;StyleRuleBase&gt;&amp;&amp;);
227     void wrapperRemoveRule(unsigned);
228 
229 protected:
<span class="line-modified">230     StyleRuleGroup(StyleRuleType, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp;);</span>
<span class="line-modified">231     StyleRuleGroup(StyleRuleType, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp;);</span>
232     StyleRuleGroup(const StyleRuleGroup&amp;);
233 
234 private:
235     void parseDeferredRulesIfNeeded() const;
236 
237     mutable Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; m_childRules;
238     mutable std::unique_ptr&lt;DeferredStyleGroupRuleList&gt; m_deferredRules;
239 };
240 
241 inline const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;* StyleRuleGroup::childRulesWithoutDeferredParsing() const
242 {
243     return !m_deferredRules ? &amp;m_childRules : nullptr;
244 }
245 
246 class StyleRuleMedia final : public StyleRuleGroup {
247 public:
248     static Ref&lt;StyleRuleMedia&gt; create(Ref&lt;MediaQuerySet&gt;&amp;&amp; media, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules)
249     {
250         return adoptRef(*new StyleRuleMedia(WTFMove(media), adoptRules));
251     }
</pre>
</td>
</tr>
</table>
<center><a href="StyleRule.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleRuleImport.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
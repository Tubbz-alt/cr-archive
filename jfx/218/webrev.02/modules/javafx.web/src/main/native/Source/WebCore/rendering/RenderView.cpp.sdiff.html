<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderVTTCue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderView.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderView.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
404     Page* page = document().page();
405     float pageScaleFactor = page ? page-&gt;pageScaleFactor() : 1;
406 
407     // If painting will entirely fill the view, no need to fill the background.
408     if (rootFillsViewport &amp;&amp; rootObscuresBackground &amp;&amp; pageScaleFactor &gt;= 1)
409         return;
410 
411     // This code typically only executes if the root element&#39;s visibility has been set to hidden,
412     // if there is a transform on the &lt;html&gt;, or if there is a page scale factor less than 1.
413     // Only fill with a background color (typically white) if we&#39;re the root document,
414     // since iframes/frames with no background in the child document should show the parent&#39;s background.
415     // We use the base background color unless the backgroundShouldExtendBeyondPage setting is set,
416     // in which case we use the document&#39;s background color.
417     if (frameView().isTransparent()) // FIXME: This needs to be dynamic. We should be able to go back to blitting if we ever stop being transparent.
418         frameView().setCannotBlitToWindow(); // The parent must show behind the child.
419     else {
420         const Color&amp; documentBackgroundColor = frameView().documentBackgroundColor();
421         const Color&amp; backgroundColor = (settings().backgroundShouldExtendBeyondPage() &amp;&amp; documentBackgroundColor.isValid()) ? documentBackgroundColor : frameView().baseBackgroundColor();
422         if (backgroundColor.isVisible()) {
423             CompositeOperator previousOperator = paintInfo.context().compositeOperation();
<span class="line-modified">424             paintInfo.context().setCompositeOperation(CompositeCopy);</span>
425             paintInfo.context().fillRect(paintInfo.rect, backgroundColor);
426             paintInfo.context().setCompositeOperation(previousOperator);
427         } else
428             paintInfo.context().clearRect(paintInfo.rect);
429     }
430 }
431 
432 bool RenderView::shouldRepaint(const LayoutRect&amp; rect) const
433 {
434     return !printing() &amp;&amp; !rect.isEmpty();
435 }
436 
437 void RenderView::repaintRootContents()
438 {
439     if (layer()-&gt;isComposited()) {
440         layer()-&gt;setBackingNeedsRepaint(GraphicsLayer::DoNotClipToLayer);
441         return;
442     }
443 
444     // Always use layoutOverflowRect() to fix rdar://problem/27182267.
</pre>
<hr />
<pre>
860             columnNumber = (pagination.pageLength + pagination.gap - offset) / (pagination.pageLength + pagination.gap);
861         else
862             columnNumber = offset / (pagination.pageLength + pagination.gap);
863     }
864 
865     return columnNumber;
866 }
867 
868 unsigned RenderView::pageCount() const
869 {
870     const Pagination&amp; pagination = page().pagination();
871     if (pagination.mode == Pagination::Unpaginated)
872         return 0;
873 
874     if (multiColumnFlow() &amp;&amp; multiColumnFlow()-&gt;firstMultiColumnSet())
875         return multiColumnFlow()-&gt;firstMultiColumnSet()-&gt;columnCount();
876 
877     return 0;
878 }
879 


















880 #if ENABLE(CSS_SCROLL_SNAP)
881 void RenderView::registerBoxWithScrollSnapPositions(const RenderBox&amp; box)
882 {
883     m_boxesWithScrollSnapPositions.add(&amp;box);
884 }
885 
886 void RenderView::unregisterBoxWithScrollSnapPositions(const RenderBox&amp; box)
887 {
888     m_boxesWithScrollSnapPositions.remove(&amp;box);
889 }
890 #endif
891 
892 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
404     Page* page = document().page();
405     float pageScaleFactor = page ? page-&gt;pageScaleFactor() : 1;
406 
407     // If painting will entirely fill the view, no need to fill the background.
408     if (rootFillsViewport &amp;&amp; rootObscuresBackground &amp;&amp; pageScaleFactor &gt;= 1)
409         return;
410 
411     // This code typically only executes if the root element&#39;s visibility has been set to hidden,
412     // if there is a transform on the &lt;html&gt;, or if there is a page scale factor less than 1.
413     // Only fill with a background color (typically white) if we&#39;re the root document,
414     // since iframes/frames with no background in the child document should show the parent&#39;s background.
415     // We use the base background color unless the backgroundShouldExtendBeyondPage setting is set,
416     // in which case we use the document&#39;s background color.
417     if (frameView().isTransparent()) // FIXME: This needs to be dynamic. We should be able to go back to blitting if we ever stop being transparent.
418         frameView().setCannotBlitToWindow(); // The parent must show behind the child.
419     else {
420         const Color&amp; documentBackgroundColor = frameView().documentBackgroundColor();
421         const Color&amp; backgroundColor = (settings().backgroundShouldExtendBeyondPage() &amp;&amp; documentBackgroundColor.isValid()) ? documentBackgroundColor : frameView().baseBackgroundColor();
422         if (backgroundColor.isVisible()) {
423             CompositeOperator previousOperator = paintInfo.context().compositeOperation();
<span class="line-modified">424             paintInfo.context().setCompositeOperation(CompositeOperator::Copy);</span>
425             paintInfo.context().fillRect(paintInfo.rect, backgroundColor);
426             paintInfo.context().setCompositeOperation(previousOperator);
427         } else
428             paintInfo.context().clearRect(paintInfo.rect);
429     }
430 }
431 
432 bool RenderView::shouldRepaint(const LayoutRect&amp; rect) const
433 {
434     return !printing() &amp;&amp; !rect.isEmpty();
435 }
436 
437 void RenderView::repaintRootContents()
438 {
439     if (layer()-&gt;isComposited()) {
440         layer()-&gt;setBackingNeedsRepaint(GraphicsLayer::DoNotClipToLayer);
441         return;
442     }
443 
444     // Always use layoutOverflowRect() to fix rdar://problem/27182267.
</pre>
<hr />
<pre>
860             columnNumber = (pagination.pageLength + pagination.gap - offset) / (pagination.pageLength + pagination.gap);
861         else
862             columnNumber = offset / (pagination.pageLength + pagination.gap);
863     }
864 
865     return columnNumber;
866 }
867 
868 unsigned RenderView::pageCount() const
869 {
870     const Pagination&amp; pagination = page().pagination();
871     if (pagination.mode == Pagination::Unpaginated)
872         return 0;
873 
874     if (multiColumnFlow() &amp;&amp; multiColumnFlow()-&gt;firstMultiColumnSet())
875         return multiColumnFlow()-&gt;firstMultiColumnSet()-&gt;columnCount();
876 
877     return 0;
878 }
879 
<span class="line-added">880 void RenderView::layerChildrenChangedDuringStyleChange(RenderLayer&amp; layer)</span>
<span class="line-added">881 {</span>
<span class="line-added">882     if (!m_styleChangeLayerMutationRoot) {</span>
<span class="line-added">883         m_styleChangeLayerMutationRoot = makeWeakPtr(layer);</span>
<span class="line-added">884         return;</span>
<span class="line-added">885     }</span>
<span class="line-added">886 </span>
<span class="line-added">887     RenderLayer* commonAncestor = m_styleChangeLayerMutationRoot-&gt;commonAncestorWithLayer(layer);</span>
<span class="line-added">888     m_styleChangeLayerMutationRoot = makeWeakPtr(commonAncestor);</span>
<span class="line-added">889 }</span>
<span class="line-added">890 </span>
<span class="line-added">891 RenderLayer* RenderView::takeStyleChangeLayerTreeMutationRoot()</span>
<span class="line-added">892 {</span>
<span class="line-added">893     auto* result = m_styleChangeLayerMutationRoot.get();</span>
<span class="line-added">894     m_styleChangeLayerMutationRoot.clear();</span>
<span class="line-added">895     return result;</span>
<span class="line-added">896 }</span>
<span class="line-added">897 </span>
898 #if ENABLE(CSS_SCROLL_SNAP)
899 void RenderView::registerBoxWithScrollSnapPositions(const RenderBox&amp; box)
900 {
901     m_boxesWithScrollSnapPositions.add(&amp;box);
902 }
903 
904 void RenderView::unregisterBoxWithScrollSnapPositions(const RenderBox&amp; box)
905 {
906     m_boxesWithScrollSnapPositions.remove(&amp;box);
907 }
908 #endif
909 
910 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="RenderVTTCue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderView.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
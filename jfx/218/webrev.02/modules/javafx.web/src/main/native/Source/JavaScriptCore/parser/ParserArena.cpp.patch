diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ParserArena.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ParserArena.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ParserArena.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ParserArena.cpp
@@ -24,15 +24,20 @@
  */
 
 #include "config.h"
 #include "ParserArena.h"
 
+#include "CatchScope.h"
+#include "JSBigInt.h"
 #include "Nodes.h"
 #include "JSCInlines.h"
 
 namespace JSC {
 
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(IdentifierArena);
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArena);
+
 ParserArena::ParserArena()
     : m_freeableMemory(0)
     , m_freeablePoolEnd(0)
 {
 }
@@ -48,15 +53,15 @@
     size_t size = m_deletableObjects.size();
     for (size_t i = 0; i < size; ++i)
         m_deletableObjects[i]->~ParserArenaDeletable();
 
     if (m_freeablePoolEnd)
-        fastFree(freeablePool());
+        ParserArenaMalloc::free(freeablePool());
 
     size = m_freeablePools.size();
     for (size_t i = 0; i < size; ++i)
-        fastFree(m_freeablePools[i]);
+        ParserArenaMalloc::free(m_freeablePools[i]);
 }
 
 ParserArena::~ParserArena()
 {
     deallocateObjects();
@@ -65,12 +70,32 @@
 void ParserArena::allocateFreeablePool()
 {
     if (m_freeablePoolEnd)
         m_freeablePools.append(freeablePool());
 
-    char* pool = static_cast<char*>(fastMalloc(freeablePoolSize));
+    char* pool = static_cast<char*>(ParserArenaMalloc::malloc(freeablePoolSize));
     m_freeableMemory = pool;
     m_freeablePoolEnd = pool + freeablePoolSize;
     ASSERT(freeablePool() == pool);
 }
 
+const Identifier& IdentifierArena::makeBigIntDecimalIdentifier(VM& vm, const Identifier& identifier, uint8_t radix)
+{
+    if (radix == 10)
+        return identifier;
+
+    // FIXME: We are allocating a JSBigInt just to be able to use
+    // JSBigInt::tryGetString when radix is not 10.
+    // This creates some GC pressure, but since these identifiers
+    // will only be created when BigInt literal is used as a property name,
+    // it wont be much problematic, given such cases are very rare.
+    // There is a lot of optimizations we can apply here when necessary.
+    // https://bugs.webkit.org/show_bug.cgi?id=207627
+
+    auto scope = DECLARE_CATCH_SCOPE(vm);
+    JSBigInt* bigInt = JSBigInt::parseInt(nullptr, vm, identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, JSBigInt::ParseIntSign::Unsigned);
+    scope.assertNoException();
+    m_identifiers.append(Identifier::fromString(vm, JSBigInt::tryGetString(vm, bigInt, 10)));
+    return m_identifiers.last();
+}
+
 }

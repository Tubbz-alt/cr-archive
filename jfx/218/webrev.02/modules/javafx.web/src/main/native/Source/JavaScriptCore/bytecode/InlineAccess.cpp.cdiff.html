<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineAccess.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InByIdVariant.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineCallFrame.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineAccess.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 150,13 ***</span>
  
  
  template &lt;typename Function&gt;
  ALWAYS_INLINE static bool linkCodeInline(const char* name, CCallHelpers&amp; jit, StructureStubInfo&amp; stubInfo, const Function&amp; function)
  {
<span class="line-modified">!     if (jit.m_assembler.buffer().codeSize() &lt;= stubInfo.patch.inlineSize()) {</span>
          bool needsBranchCompaction = true;
<span class="line-modified">!         LinkBuffer linkBuffer(jit, stubInfo.patch.start, stubInfo.patch.inlineSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
          ASSERT(linkBuffer.isValid());
          function(linkBuffer);
          FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccessType: &#39;%s&#39;&quot;, name);
          return true;
      }
<span class="line-new-header">--- 150,13 ---</span>
  
  
  template &lt;typename Function&gt;
  ALWAYS_INLINE static bool linkCodeInline(const char* name, CCallHelpers&amp; jit, StructureStubInfo&amp; stubInfo, const Function&amp; function)
  {
<span class="line-modified">!     if (jit.m_assembler.buffer().codeSize() &lt;= stubInfo.inlineSize()) {</span>
          bool needsBranchCompaction = true;
<span class="line-modified">!         LinkBuffer linkBuffer(jit, stubInfo.start, stubInfo.inlineSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
          ASSERT(linkBuffer.isValid());
          function(linkBuffer);
          FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccessType: &#39;%s&#39;&quot;, name);
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,22 ***</span>
      // of randomness. It&#39;s helpful to flip this on when running tests or browsing
      // the web just to see how often it fails. You don&#39;t want an IC size that always fails.
      constexpr bool failIfCantInline = false;
      if (failIfCantInline) {
          dataLog(&quot;Failure for: &quot;, name, &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;real size: &quot;, jit.m_assembler.buffer().codeSize(), &quot; inline size:&quot;, stubInfo.patch.inlineSize(), &quot;\n&quot;);</span>
          CRASH();
      }
  
      return false;
  }
  
  bool InlineAccess::generateSelfPropertyAccess(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
  {
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR();</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
<span class="line-new-header">--- 167,25 ---</span>
      // of randomness. It&#39;s helpful to flip this on when running tests or browsing
      // the web just to see how often it fails. You don&#39;t want an IC size that always fails.
      constexpr bool failIfCantInline = false;
      if (failIfCantInline) {
          dataLog(&quot;Failure for: &quot;, name, &quot;\n&quot;);
<span class="line-modified">!         dataLog(&quot;real size: &quot;, jit.m_assembler.buffer().codeSize(), &quot; inline size:&quot;, stubInfo.inlineSize(), &quot;\n&quot;);</span>
          CRASH();
      }
  
      return false;
  }
  
  bool InlineAccess::generateSelfPropertyAccess(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
  {
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,23 ***</span>
  
      jit.loadValue(
          MacroAssembler::Address(storage, offsetRelativeToBase(offset)), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;property access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
      });
      return linkedCodeInline;
  }
  
  ALWAYS_INLINE static GPRReg getScratchRegister(StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="line-modified">!     allocator.lock(stubInfo.baseGPR());</span>
<span class="line-modified">!     allocator.lock(stubInfo.patch.valueGPR);</span>
  #if USE(JSVALUE32_64)
<span class="line-modified">!     allocator.lock(stubInfo.patch.baseTagGPR);</span>
<span class="line-modified">!     allocator.lock(stubInfo.patch.valueTagGPR);</span>
  #endif
      GPRReg scratch = allocator.allocateScratchGPR();
      if (allocator.didReuseRegisters())
          return InvalidGPRReg;
      return scratch;
<span class="line-new-header">--- 200,23 ---</span>
  
      jit.loadValue(
          MacroAssembler::Address(storage, offsetRelativeToBase(offset)), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;property access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  ALWAYS_INLINE static GPRReg getScratchRegister(StructureStubInfo&amp; stubInfo)
  {
<span class="line-modified">!     ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-modified">!     allocator.lock(stubInfo.baseGPR);</span>
<span class="line-modified">!     allocator.lock(stubInfo.valueGPR);</span>
  #if USE(JSVALUE32_64)
<span class="line-modified">!     allocator.lock(stubInfo.baseTagGPR);</span>
<span class="line-modified">!     allocator.lock(stubInfo.valueTagGPR);</span>
  #endif
      GPRReg scratch = allocator.allocateScratchGPR();
      if (allocator.didReuseRegisters())
          return InvalidGPRReg;
      return scratch;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,23 ***</span>
      return getScratchRegister(stubInfo) != InvalidGPRReg;
  }
  
  bool InlineAccess::canGenerateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, PropertyOffset offset)
  {
      if (isInlineOffset(offset))
          return true;
  
      return hasFreeRegister(stubInfo);
  }
  
  bool InlineAccess::generateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
  {
      ASSERT(canGenerateSelfPropertyReplace(stubInfo, offset));
  
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR();</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
<span class="line-new-header">--- 227,29 ---</span>
      return getScratchRegister(stubInfo) != InvalidGPRReg;
  }
  
  bool InlineAccess::canGenerateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, PropertyOffset offset)
  {
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (isInlineOffset(offset))
          return true;
  
      return hasFreeRegister(stubInfo);
  }
  
  bool InlineAccess::generateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
  {
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      ASSERT(canGenerateSelfPropertyReplace(stubInfo, offset));
  
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,32 ***</span>
  
      jit.storeValue(
          value, MacroAssembler::Address(storage, offsetRelativeToBase(offset)));
  
      bool linkedCodeInline = linkCodeInline(&quot;property replace&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
      });
      return linkedCodeInline;
  }
  
  bool InlineAccess::isCacheableArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
  {
      ASSERT(array-&gt;indexingType() &amp; IsArray);
  
      if (!hasFreeRegister(stubInfo))
          return false;
  
      return !hasAnyArrayStorage(array-&gt;indexingType()) &amp;&amp; array-&gt;indexingType() != ArrayClass;
  }
  
  bool InlineAccess::generateArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
  {
      ASSERT(isCacheableArrayLength(stubInfo, array));
  
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR();</span>
      JSValueRegs value = stubInfo.valueRegs();
      GPRReg scratch = getScratchRegister(stubInfo);
  
      jit.load8(CCallHelpers::Address(base, JSCell::indexingTypeAndMiscOffset()), scratch);
      jit.and32(CCallHelpers::TrustedImm32(IndexingTypeMask), scratch);
<span class="line-new-header">--- 266,38 ---</span>
  
      jit.storeValue(
          value, MacroAssembler::Address(storage, offsetRelativeToBase(offset)));
  
      bool linkedCodeInline = linkCodeInline(&quot;property replace&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  bool InlineAccess::isCacheableArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
  {
      ASSERT(array-&gt;indexingType() &amp; IsArray);
  
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (!hasFreeRegister(stubInfo))
          return false;
  
      return !hasAnyArrayStorage(array-&gt;indexingType()) &amp;&amp; array-&gt;indexingType() != ArrayClass;
  }
  
  bool InlineAccess::generateArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
  {
      ASSERT(isCacheableArrayLength(stubInfo, array));
  
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
      GPRReg scratch = getScratchRegister(stubInfo);
  
      jit.load8(CCallHelpers::Address(base, JSCell::indexingTypeAndMiscOffset()), scratch);
      jit.and32(CCallHelpers::TrustedImm32(IndexingTypeMask), scratch);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,27 ***</span>
      jit.loadPtr(CCallHelpers::Address(base, JSObject::butterflyOffset()), value.payloadGPR());
      jit.load32(CCallHelpers::Address(value.payloadGPR(), ArrayStorage::lengthOffset()), value.payloadGPR());
      jit.boxInt32(value.payloadGPR(), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;array length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
      });
      return linkedCodeInline;
  }
  
  bool InlineAccess::isCacheableStringLength(StructureStubInfo&amp; stubInfo)
  {
      return hasFreeRegister(stubInfo);
  }
  
  bool InlineAccess::generateStringLength(StructureStubInfo&amp; stubInfo)
  {
      ASSERT(isCacheableStringLength(stubInfo));
  
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR();</span>
      JSValueRegs value = stubInfo.valueRegs();
      GPRReg scratch = getScratchRegister(stubInfo);
  
      auto branchToSlowPath = jit.patchableBranch8(
          CCallHelpers::NotEqual,
<span class="line-new-header">--- 306,33 ---</span>
      jit.loadPtr(CCallHelpers::Address(base, JSObject::butterflyOffset()), value.payloadGPR());
      jit.load32(CCallHelpers::Address(value.payloadGPR(), ArrayStorage::lengthOffset()), value.payloadGPR());
      jit.boxInt32(value.payloadGPR(), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;array length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  bool InlineAccess::isCacheableStringLength(StructureStubInfo&amp; stubInfo)
  {
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      return hasFreeRegister(stubInfo);
  }
  
  bool InlineAccess::generateStringLength(StructureStubInfo&amp; stubInfo)
  {
      ASSERT(isCacheableStringLength(stubInfo));
  
<span class="line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
      GPRReg scratch = getScratchRegister(stubInfo);
  
      auto branchToSlowPath = jit.patchableBranch8(
          CCallHelpers::NotEqual,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,31 ***</span>
  
      done.link(&amp;jit);
      jit.boxInt32(value.payloadGPR(), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;string length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
      });
      return linkedCodeInline;
  }
  
  
  bool InlineAccess::generateSelfInAccess(StructureStubInfo&amp; stubInfo, Structure* structure)
  {
      CCallHelpers jit;
  
<span class="line-modified">!     GPRReg base = stubInfo.baseGPR();</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
          MacroAssembler::TrustedImm32(bitwise_cast&lt;uint32_t&gt;(structure-&gt;id())));
      jit.boxBoolean(true, value);
  
      bool linkedCodeInline = linkCodeInline(&quot;in access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
      });
      return linkedCodeInline;
  }
  
  void InlineAccess::rewireStubAsJump(StructureStubInfo&amp; stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; target)
<span class="line-new-header">--- 349,34 ---</span>
  
      done.link(&amp;jit);
      jit.boxInt32(value.payloadGPR(), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;string length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  
  bool InlineAccess::generateSelfInAccess(StructureStubInfo&amp; stubInfo, Structure* structure)
  {
      CCallHelpers jit;
  
<span class="line-modified">!     if (!stubInfo.hasConstantIdentifier)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
          MacroAssembler::TrustedImm32(bitwise_cast&lt;uint32_t&gt;(structure-&gt;id())));
      jit.boxBoolean(true, value);
  
      bool linkedCodeInline = linkCodeInline(&quot;in access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="line-modified">!         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  void InlineAccess::rewireStubAsJump(StructureStubInfo&amp; stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; target)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
  
      auto jump = jit.jump();
  
      // We don&#39;t need a nop sled here because nobody should be jumping into the middle of an IC.
      bool needsBranchCompaction = false;
<span class="line-modified">!     LinkBuffer linkBuffer(jit, stubInfo.patch.start, jit.m_assembler.buffer().codeSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
      RELEASE_ASSERT(linkBuffer.isValid());
      linkBuffer.link(jump, target);
  
      FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccess: linking constant jump&quot;);
  }
<span class="line-new-header">--- 385,11 ---</span>
  
      auto jump = jit.jump();
  
      // We don&#39;t need a nop sled here because nobody should be jumping into the middle of an IC.
      bool needsBranchCompaction = false;
<span class="line-modified">!     LinkBuffer linkBuffer(jit, stubInfo.start, jit.m_assembler.buffer().codeSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
      RELEASE_ASSERT(linkBuffer.isValid());
      linkBuffer.link(jump, target);
  
      FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccess: linking constant jump&quot;);
  }
</pre>
<center><a href="InByIdVariant.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineCallFrame.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromise.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMOperationReturningPromise.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMPromise.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromise.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 36,57 ***</span>
  
  using namespace JSC;
  
  namespace WebCore {
  
<span class="line-removed">- static inline JSC::JSValue callFunction(JSC::ExecState&amp; state, JSC::JSValue jsFunction, JSC::JSValue thisValue, const JSC::ArgList&amp; arguments)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = state.vm();</span>
<span class="line-removed">-     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">-     JSC::CallData callData;</span>
<span class="line-removed">-     auto callType = JSC::getCallData(vm, jsFunction, callData);</span>
<span class="line-removed">-     ASSERT(callType != JSC::CallType::None);</span>
<span class="line-removed">-     auto result = call(&amp;state, jsFunction, callType, callData, thisValue, arguments);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     EXCEPTION_ASSERT_UNUSED(scope, !scope.exception() || isTerminatedExecutionException(state.vm(), scope.exception()));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void DOMPromise::whenSettled(std::function&lt;void()&gt;&amp;&amp; callback)
  {
      whenPromiseIsSettled(globalObject(), promise(), WTFMove(callback));
  }
  
<span class="line-modified">! void DOMPromise::whenPromiseIsSettled(JSDOMGlobalObject* globalObject, JSC::JSObject* promise, std::function&lt;void()&gt;&amp;&amp; callback)</span>
  {
<span class="line-modified">!     auto&amp; state = *globalObject-&gt;globalExec();</span>
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     auto* handler = JSC::JSNativeStdFunction::create(vm, globalObject, 1, String { }, [callback = WTFMove(callback)] (ExecState*) mutable {</span>
          callback();
          return JSC::JSValue::encode(JSC::jsUndefined());
      });
  
      const JSC::Identifier&amp; privateName = vm.propertyNames-&gt;builtinNames().thenPrivateName();
<span class="line-modified">!     auto thenFunction = promise-&gt;get(&amp;state, privateName);</span>
      ASSERT(thenFunction.isFunction(vm));
  
      JSC::MarkedArgumentBuffer arguments;
      arguments.append(handler);
      arguments.append(handler);
<span class="line-modified">!     callFunction(state, thenFunction, promise, arguments);</span>
  }
  
  JSC::JSValue DOMPromise::result() const
  {
<span class="line-modified">!     return promise()-&gt;result(m_globalObject-&gt;globalExec()-&gt;vm());</span>
  }
  
  DOMPromise::Status DOMPromise::status() const
  {
<span class="line-modified">!     switch (promise()-&gt;status(m_globalObject-&gt;globalExec()-&gt;vm())) {</span>
      case JSC::JSPromise::Status::Pending:
          return Status::Pending;
      case JSC::JSPromise::Status::Fulfilled:
          return Status::Fulfilled;
      case JSC::JSPromise::Status::Rejected:
<span class="line-new-header">--- 36,55 ---</span>
  
  using namespace JSC;
  
  namespace WebCore {
  
  void DOMPromise::whenSettled(std::function&lt;void()&gt;&amp;&amp; callback)
  {
      whenPromiseIsSettled(globalObject(), promise(), WTFMove(callback));
  }
  
<span class="line-modified">! void DOMPromise::whenPromiseIsSettled(JSDOMGlobalObject* globalObject, JSC::JSObject* promise, Function&lt;void()&gt;&amp;&amp; callback)</span>
  {
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *globalObject;</span>
<span class="line-modified">!     auto&amp; vm = lexicalGlobalObject.vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     auto* handler = JSC::JSNativeStdFunction::create(vm, globalObject, 1, String { }, [callback = WTFMove(callback)] (JSGlobalObject*, CallFrame*) mutable {</span>
          callback();
          return JSC::JSValue::encode(JSC::jsUndefined());
      });
  
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
      const JSC::Identifier&amp; privateName = vm.propertyNames-&gt;builtinNames().thenPrivateName();
<span class="line-modified">!     auto thenFunction = promise-&gt;get(&amp;lexicalGlobalObject, privateName);</span>
<span class="line-added">+ </span>
<span class="line-added">+     EXCEPTION_ASSERT(!scope.exception() || isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));</span>
<span class="line-added">+     if (scope.exception())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      ASSERT(thenFunction.isFunction(vm));
  
      JSC::MarkedArgumentBuffer arguments;
      arguments.append(handler);
      arguments.append(handler);
<span class="line-modified">! </span>
<span class="line-added">+     JSC::CallData callData;</span>
<span class="line-added">+     auto callType = JSC::getCallData(vm, thenFunction, callData);</span>
<span class="line-added">+     ASSERT(callType != JSC::CallType::None);</span>
<span class="line-added">+     call(&amp;lexicalGlobalObject, thenFunction, callType, callData, promise, arguments);</span>
<span class="line-added">+ </span>
<span class="line-added">+     EXCEPTION_ASSERT(!scope.exception() || isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));</span>
  }
  
  JSC::JSValue DOMPromise::result() const
  {
<span class="line-modified">!     return promise()-&gt;result(m_globalObject-&gt;vm());</span>
  }
  
  DOMPromise::Status DOMPromise::status() const
  {
<span class="line-modified">!     switch (promise()-&gt;status(m_globalObject-&gt;vm())) {</span>
      case JSC::JSPromise::Status::Pending:
          return Status::Pending;
      case JSC::JSPromise::Status::Fulfilled:
          return Status::Fulfilled;
      case JSC::JSPromise::Status::Rejected:
</pre>
<center><a href="JSDOMOperationReturningPromise.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMPromise.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
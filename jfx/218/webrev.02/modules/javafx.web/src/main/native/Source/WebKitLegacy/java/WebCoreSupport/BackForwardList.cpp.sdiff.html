<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebKitLegacy/java/WebCoreSupport/BackForwardList.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../DOM/JavaXPathExpression.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ChromeClientJava.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebKitLegacy/java/WebCoreSupport/BackForwardList.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;BackForwardList.h&quot;
 28 

 29 #include &lt;WebCore/BackForwardController.h&gt;
 30 #include &lt;WebCore/Frame.h&gt;
 31 #include &lt;WebCore/FrameLoader.h&gt;
 32 #include &lt;WebCore/FrameLoaderClient.h&gt;
 33 #include &lt;WebCore/HistoryItem.h&gt;
 34 #include &lt;WebCore/Logging.h&gt;
 35 #include &lt;WebCore/Page.h&gt;
<span class="line-removed"> 36 #include &lt;WebCore/PageCache.h&gt;</span>
 37 #include &lt;WebCore/SerializedScriptValue.h&gt;
 38 
 39 #include &quot;BackForwardList.h&quot;
 40 #include &quot;WebPage.h&quot;
 41 #include &quot;PlatformJavaClasses.h&quot;
 42 
 43 static const unsigned DefaultCapacity = 100;
 44 static const unsigned NoCurrentItemIndex = UINT_MAX;
 45 
 46 using namespace WebCore;
 47 
 48 extern &quot;C&quot; {
 49 
 50 namespace {
 51 
 52 Page* getPage(jlong jpage)
 53 {
 54     return WebPage::pageFromJLong(jpage);
 55 }
 56 
</pre>
<hr />
<pre>
356     , m_enabled(true)
357 {
358 }
359 
360 BackForwardList::~BackForwardList()
361 {
362     ASSERT(m_closed);
363 }
364 
365 void BackForwardList::addItem(Ref&lt;HistoryItem&gt;&amp;&amp; newItem)
366 {
367     if (!m_capacity || !m_enabled)
368         return;
369 
370     // Toss anything in the forward list
371     if (m_current != NoCurrentItemIndex) {
372         unsigned targetSize = m_current + 1;
373         while (m_entries.size() &gt; targetSize) {
374             Ref&lt;HistoryItem&gt; item = m_entries.takeLast();
375             m_entryHash.remove(item.ptr());
<span class="line-modified">376             PageCache::singleton().remove(item);</span>
377         }
378     }
379 
380     // Toss the first item if the list is getting too big, as long as we&#39;re not using it
381     // (or even if we are, if we only want 1 entry).
382     if (m_entries.size() == m_capacity &amp;&amp; (m_current || m_capacity == 1)) {
383         Ref&lt;HistoryItem&gt; item = WTFMove(m_entries[0]);
384         m_entries.remove(0);
385         m_entryHash.remove(item.ptr());
<span class="line-modified">386         PageCache::singleton().remove(item);</span>
387         --m_current;
388     }
389 
390     m_entryHash.add(newItem.ptr());
391     m_entries.insert(m_current + 1, WTFMove(newItem));
392     ++m_current;
393 
394     notifyBackForwardListChanged(m_hostObject);
395 }
396 
397 void BackForwardList::goBack()
398 {
399     ASSERT(m_current &gt; 0);
400     if (m_current &gt; 0) {
401         m_current--;
402     }
403 }
404 
405 void BackForwardList::goForward()
406 {
</pre>
<hr />
<pre>
466 
467     unsigned lastEntry = m_entries.size() - 1;
468     if (m_current &lt; lastEntry) {
469         int last = std::min(m_current + limit, lastEntry);
470         limit = m_current + 1;
471         for (; limit &lt;= last; ++limit)
472             list.append(m_entries[limit].get());
473     }
474 }
475 
476 int BackForwardList::capacity()
477 {
478     return m_capacity;
479 }
480 
481 void BackForwardList::setCapacity(int size)
482 {
483     while (size &lt; static_cast&lt;int&gt;(m_entries.size())) {
484         Ref&lt;HistoryItem&gt; item = m_entries.takeLast();
485         m_entryHash.remove(item.ptr());
<span class="line-modified">486         PageCache::singleton().remove(item);</span>
487     }
488 
489     if (!size)
490         m_current = NoCurrentItemIndex;
491     else if (m_current &gt; m_entries.size() - 1) {
492         m_current = m_entries.size() - 1;
493     }
494     m_capacity = size;
495 
496     notifyBackForwardListChanged(m_hostObject);
497 }
498 
499 bool BackForwardList::enabled()
500 {
501     return m_enabled;
502 }
503 
504 void BackForwardList::setEnabled(bool enabled)
505 {
506     m_enabled = enabled;
</pre>
</td>
<td>
<hr />
<pre>
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;BackForwardList.h&quot;
 28 
<span class="line-added"> 29 #include &lt;WebCore/BackForwardCache.h&gt;</span>
 30 #include &lt;WebCore/BackForwardController.h&gt;
 31 #include &lt;WebCore/Frame.h&gt;
 32 #include &lt;WebCore/FrameLoader.h&gt;
 33 #include &lt;WebCore/FrameLoaderClient.h&gt;
 34 #include &lt;WebCore/HistoryItem.h&gt;
 35 #include &lt;WebCore/Logging.h&gt;
 36 #include &lt;WebCore/Page.h&gt;

 37 #include &lt;WebCore/SerializedScriptValue.h&gt;
 38 
 39 #include &quot;BackForwardList.h&quot;
 40 #include &quot;WebPage.h&quot;
 41 #include &quot;PlatformJavaClasses.h&quot;
 42 
 43 static const unsigned DefaultCapacity = 100;
 44 static const unsigned NoCurrentItemIndex = UINT_MAX;
 45 
 46 using namespace WebCore;
 47 
 48 extern &quot;C&quot; {
 49 
 50 namespace {
 51 
 52 Page* getPage(jlong jpage)
 53 {
 54     return WebPage::pageFromJLong(jpage);
 55 }
 56 
</pre>
<hr />
<pre>
356     , m_enabled(true)
357 {
358 }
359 
360 BackForwardList::~BackForwardList()
361 {
362     ASSERT(m_closed);
363 }
364 
365 void BackForwardList::addItem(Ref&lt;HistoryItem&gt;&amp;&amp; newItem)
366 {
367     if (!m_capacity || !m_enabled)
368         return;
369 
370     // Toss anything in the forward list
371     if (m_current != NoCurrentItemIndex) {
372         unsigned targetSize = m_current + 1;
373         while (m_entries.size() &gt; targetSize) {
374             Ref&lt;HistoryItem&gt; item = m_entries.takeLast();
375             m_entryHash.remove(item.ptr());
<span class="line-modified">376             BackForwardCache::singleton().remove(item);</span>
377         }
378     }
379 
380     // Toss the first item if the list is getting too big, as long as we&#39;re not using it
381     // (or even if we are, if we only want 1 entry).
382     if (m_entries.size() == m_capacity &amp;&amp; (m_current || m_capacity == 1)) {
383         Ref&lt;HistoryItem&gt; item = WTFMove(m_entries[0]);
384         m_entries.remove(0);
385         m_entryHash.remove(item.ptr());
<span class="line-modified">386         BackForwardCache::singleton().remove(item);</span>
387         --m_current;
388     }
389 
390     m_entryHash.add(newItem.ptr());
391     m_entries.insert(m_current + 1, WTFMove(newItem));
392     ++m_current;
393 
394     notifyBackForwardListChanged(m_hostObject);
395 }
396 
397 void BackForwardList::goBack()
398 {
399     ASSERT(m_current &gt; 0);
400     if (m_current &gt; 0) {
401         m_current--;
402     }
403 }
404 
405 void BackForwardList::goForward()
406 {
</pre>
<hr />
<pre>
466 
467     unsigned lastEntry = m_entries.size() - 1;
468     if (m_current &lt; lastEntry) {
469         int last = std::min(m_current + limit, lastEntry);
470         limit = m_current + 1;
471         for (; limit &lt;= last; ++limit)
472             list.append(m_entries[limit].get());
473     }
474 }
475 
476 int BackForwardList::capacity()
477 {
478     return m_capacity;
479 }
480 
481 void BackForwardList::setCapacity(int size)
482 {
483     while (size &lt; static_cast&lt;int&gt;(m_entries.size())) {
484         Ref&lt;HistoryItem&gt; item = m_entries.takeLast();
485         m_entryHash.remove(item.ptr());
<span class="line-modified">486         BackForwardCache::singleton().remove(item);</span>
487     }
488 
489     if (!size)
490         m_current = NoCurrentItemIndex;
491     else if (m_current &gt; m_entries.size() - 1) {
492         m_current = m_entries.size() - 1;
493     }
494     m_capacity = size;
495 
496     notifyBackForwardListChanged(m_hostObject);
497 }
498 
499 bool BackForwardList::enabled()
500 {
501     return m_enabled;
502 }
503 
504 void BackForwardList::setEnabled(bool enabled)
505 {
506     m_enabled = enabled;
</pre>
</td>
</tr>
</table>
<center><a href="../DOM/JavaXPathExpression.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ChromeClientJava.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp
@@ -24,10 +24,11 @@
 #include "BridgeJSC.h"
 #include "CachedScriptFetcher.h"
 #include "CommonVM.h"
 #include "ContentSecurityPolicy.h"
 #include "CustomHeaderFields.h"
+#include "DOMWrapperWorld.h"
 #include "DocumentLoader.h"
 #include "Event.h"
 #include "Frame.h"
 #include "FrameLoader.h"
 #include "FrameLoaderClient.h"
@@ -45,31 +46,35 @@
 #include "Page.h"
 #include "PageConsoleClient.h"
 #include "PageGroup.h"
 #include "PaymentCoordinator.h"
 #include "PluginViewBase.h"
+#include "RunJavaScriptParameters.h"
 #include "RuntimeApplicationChecks.h"
 #include "ScriptDisallowedScope.h"
 #include "ScriptSourceCode.h"
 #include "ScriptableDocumentParser.h"
 #include "Settings.h"
 #include "UserGestureIndicator.h"
 #include "WebCoreJSClientData.h"
 #include "npruntime_impl.h"
 #include "runtime_root.h"
 #include <JavaScriptCore/Debugger.h>
+#include <JavaScriptCore/Heap.h>
 #include <JavaScriptCore/InitializeThreading.h>
 #include <JavaScriptCore/JSFunction.h>
 #include <JavaScriptCore/JSInternalPromise.h>
 #include <JavaScriptCore/JSLock.h>
 #include <JavaScriptCore/JSModuleRecord.h>
 #include <JavaScriptCore/JSNativeStdFunction.h>
 #include <JavaScriptCore/JSScriptFetchParameters.h>
 #include <JavaScriptCore/JSScriptFetcher.h>
 #include <JavaScriptCore/ScriptCallStack.h>
 #include <JavaScriptCore/StrongInlines.h>
+#include <JavaScriptCore/WeakGCMapInlines.h>
 #include <wtf/SetForScope.h>
+#include <wtf/SharedTask.h>
 #include <wtf/Threading.h>
 #include <wtf/text/TextPosition.h>
 
 namespace WebCore {
 using namespace JSC;
@@ -104,11 +109,17 @@
         m_cacheableBindingRootObject->invalidate();
         m_cacheableBindingRootObject = nullptr;
     }
 }
 
-JSValue ScriptController::evaluateInWorld(const ScriptSourceCode& sourceCode, DOMWrapperWorld& world, ExceptionDetails* exceptionDetails)
+JSC::JSValue ScriptController::evaluateInWorldIgnoringException(const ScriptSourceCode& sourceCode, DOMWrapperWorld& world)
+{
+    auto result = evaluateInWorld(sourceCode, world);
+    return result ? result.value() : JSC::JSValue { };
+}
+
+ValueOrException ScriptController::evaluateInWorld(const ScriptSourceCode& sourceCode, DOMWrapperWorld& world)
 {
     JSLockHolder lock(world.vm());
 
     const SourceCode& jsSourceCode = sourceCode.jsSourceCode();
     String sourceURL = jsSourceCode.provider()->url();
@@ -119,46 +130,50 @@
     // inlineCode is true for <a href="javascript:doSomething()">
     // and false for <script>doSomething()</script>. Check if it has the
     // expected value in all cases.
     // See smart window.open policy for where this is used.
     auto& proxy = jsWindowProxy(world);
-    auto& exec = *proxy.window()->globalExec();
+    auto& globalObject = *proxy.window();
     const String* savedSourceURL = m_sourceURL;
     m_sourceURL = &sourceURL;
 
     Ref<Frame> protector(m_frame);
 
-    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());
+    InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());
 
     NakedPtr<JSC::Exception> evaluationException;
-    JSValue returnValue = JSExecState::profiledEvaluate(&exec, JSC::ProfilingReason::Other, jsSourceCode, &proxy, evaluationException);
+    JSValue returnValue = JSExecState::profiledEvaluate(&globalObject, JSC::ProfilingReason::Other, jsSourceCode, &proxy, evaluationException);
 
-    InspectorInstrumentation::didEvaluateScript(cookie, m_frame);
+    InspectorInstrumentation::didEvaluateScript(m_frame);
 
+    Optional<ExceptionDetails> optionalDetails;
     if (evaluationException) {
-        reportException(&exec, evaluationException, sourceCode.cachedScript(), exceptionDetails);
-        m_sourceURL = savedSourceURL;
-        return { };
+        ExceptionDetails details;
+        reportException(&globalObject, evaluationException, sourceCode.cachedScript(), &details);
+        optionalDetails = WTFMove(details);
     }
 
     m_sourceURL = savedSourceURL;
+    if (optionalDetails)
+        return makeUnexpected(*optionalDetails);
+
     return returnValue;
 }
 
-JSValue ScriptController::evaluate(const ScriptSourceCode& sourceCode, ExceptionDetails* exceptionDetails)
+JSC::JSValue ScriptController::evaluateIgnoringException(const ScriptSourceCode& sourceCode)
 {
-    return evaluateInWorld(sourceCode, mainThreadNormalWorld(), exceptionDetails);
+    return evaluateInWorldIgnoringException(sourceCode, mainThreadNormalWorld());
 }
 
 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript& moduleScript, const String& moduleName, Ref<ModuleFetchParameters>&& topLevelFetchParameters, DOMWrapperWorld& world)
 {
     JSLockHolder lock(world.vm());
 
     auto& proxy = jsWindowProxy(world);
-    auto& state = *proxy.window()->globalExec();
+    auto& lexicalGlobalObject = *proxy.window();
 
-    auto& promise = JSExecState::loadModule(state, moduleName, JSC::JSScriptFetchParameters::create(state.vm(), WTFMove(topLevelFetchParameters)), JSC::JSScriptFetcher::create(state.vm(), { &moduleScript }));
+    auto& promise = JSExecState::loadModule(lexicalGlobalObject, moduleName, JSC::JSScriptFetchParameters::create(lexicalGlobalObject.vm(), WTFMove(topLevelFetchParameters)), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &moduleScript }));
     setupModuleScriptHandlers(moduleScript, promise, world);
 }
 
 void ScriptController::loadModuleScript(LoadableModuleScript& moduleScript, const String& moduleName, Ref<ModuleFetchParameters>&& topLevelFetchParameters)
 {
@@ -168,13 +183,13 @@
 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript& moduleScript, const ScriptSourceCode& sourceCode, DOMWrapperWorld& world)
 {
     JSLockHolder lock(world.vm());
 
     auto& proxy = jsWindowProxy(world);
-    auto& state = *proxy.window()->globalExec();
+    auto& lexicalGlobalObject = *proxy.window();
 
-    auto& promise = JSExecState::loadModule(state, sourceCode.jsSourceCode(), JSC::JSScriptFetcher::create(state.vm(), { &moduleScript }));
+    auto& promise = JSExecState::loadModule(lexicalGlobalObject, sourceCode.jsSourceCode(), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &moduleScript }));
     setupModuleScriptHandlers(moduleScript, promise, world);
 }
 
 void ScriptController::loadModuleScript(LoadableModuleScript& moduleScript, const ScriptSourceCode& sourceCode)
 {
@@ -185,22 +200,22 @@
 {
     JSC::VM& vm = world.vm();
     JSLockHolder lock(vm);
 
     auto& proxy = jsWindowProxy(world);
-    auto& state = *proxy.window()->globalExec();
+    auto& lexicalGlobalObject = *proxy.window();
 
     // FIXME: Preventing Frame from being destroyed is essentially unnecessary.
     // https://bugs.webkit.org/show_bug.cgi?id=164763
     Ref<Frame> protector(m_frame);
 
     NakedPtr<JSC::Exception> evaluationException;
-    auto returnValue = JSExecState::linkAndEvaluateModule(state, Identifier::fromUid(vm, moduleScript.moduleKey()), jsUndefined(), evaluationException);
+    auto returnValue = JSExecState::linkAndEvaluateModule(lexicalGlobalObject, Identifier::fromUid(vm, moduleScript.moduleKey()), jsUndefined(), evaluationException);
     if (evaluationException) {
         // FIXME: Give a chance to dump the stack trace if the "crossorigin" attribute allows.
         // https://bugs.webkit.org/show_bug.cgi?id=164539
-        reportException(&state, evaluationException, nullptr);
+        reportException(&lexicalGlobalObject, evaluationException, nullptr);
         return jsUndefined();
     }
     return returnValue;
 }
 
@@ -214,31 +229,30 @@
     JSLockHolder lock(world.vm());
 
     const auto& jsSourceCode = moduleRecord.sourceCode();
 
     auto& proxy = jsWindowProxy(world);
-    auto& state = *proxy.window()->globalExec();
+    auto& lexicalGlobalObject = *proxy.window();
     SetForScope<const String*> sourceURLScope(m_sourceURL, &sourceURL.string());
 
     Ref<Frame> protector(m_frame);
 
-    auto cookie = InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, jsSourceCode.firstLine().oneBasedInt(), jsSourceCode.startColumn().oneBasedInt());
-
-    auto returnValue = moduleRecord.evaluate(&state);
-    InspectorInstrumentation::didEvaluateScript(cookie, m_frame);
+    InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, jsSourceCode.firstLine().oneBasedInt(), jsSourceCode.startColumn().oneBasedInt());
+    auto returnValue = moduleRecord.evaluate(&lexicalGlobalObject);
+    InspectorInstrumentation::didEvaluateScript(m_frame);
 
     return returnValue;
 }
 
 JSC::JSValue ScriptController::evaluateModule(const URL& sourceURL, JSModuleRecord& moduleRecord)
 {
     return evaluateModule(sourceURL, moduleRecord, mainThreadNormalWorld());
 }
 
-Ref<DOMWrapperWorld> ScriptController::createWorld()
+Ref<DOMWrapperWorld> ScriptController::createWorld(const String& name, WorldType type)
 {
-    return DOMWrapperWorld::create(commonVM());
+    return DOMWrapperWorld::create(commonVM(), type == WorldType::User ? DOMWrapperWorld::Type::User : DOMWrapperWorld::Type::Internal, name);
 }
 
 void ScriptController::getAllWorlds(Vector<Ref<DOMWrapperWorld>>& worlds)
 {
     static_cast<JSVMClientData*>(commonVM().clientData)->getAllWorlds(worlds);
@@ -260,41 +274,41 @@
     }
 
     m_frame.loader().dispatchDidClearWindowObjectInWorld(world);
 }
 
-static Identifier jsValueToModuleKey(ExecState* exec, JSValue value)
+static Identifier jsValueToModuleKey(JSGlobalObject* lexicalGlobalObject, JSValue value)
 {
     if (value.isSymbol())
         return Identifier::fromUid(jsCast<Symbol*>(value)->privateName());
     ASSERT(value.isString());
-    return asString(value)->toIdentifier(exec);
+    return asString(value)->toIdentifier(lexicalGlobalObject);
 }
 
 void ScriptController::setupModuleScriptHandlers(LoadableModuleScript& moduleScriptRef, JSInternalPromise& promise, DOMWrapperWorld& world)
 {
     auto& proxy = jsWindowProxy(world);
-    auto& state = *proxy.window()->globalExec();
+    auto& lexicalGlobalObject = *proxy.window();
 
     // It is not guaranteed that either fulfillHandler or rejectHandler is eventually called.
     // For example, if the page load is canceled, the DeferredPromise used in the module loader pipeline will stop executing JS code.
     // Thus the promise returned from this function could remain unresolved.
 
     RefPtr<LoadableModuleScript> moduleScript(&moduleScriptRef);
 
-    auto& fulfillHandler = *JSNativeStdFunction::create(state.vm(), proxy.window(), 1, String(), [moduleScript](ExecState* exec) -> JSC::EncodedJSValue {
-        VM& vm = exec->vm();
+    auto& fulfillHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) -> JSC::EncodedJSValue {
+        VM& vm = globalObject->vm();
         auto scope = DECLARE_THROW_SCOPE(vm);
-        Identifier moduleKey = jsValueToModuleKey(exec, exec->argument(0));
+        Identifier moduleKey = jsValueToModuleKey(globalObject, callFrame->argument(0));
         RETURN_IF_EXCEPTION(scope, { });
         moduleScript->notifyLoadCompleted(*moduleKey.impl());
         return JSValue::encode(jsUndefined());
     });
 
-    auto& rejectHandler = *JSNativeStdFunction::create(state.vm(), proxy.window(), 1, String(), [moduleScript](ExecState* exec) {
-        VM& vm = exec->vm();
-        JSValue errorValue = exec->argument(0);
+    auto& rejectHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) {
+        VM& vm = globalObject->vm();
+        JSValue errorValue = callFrame->argument(0);
         if (errorValue.isObject()) {
             auto* object = JSC::asObject(errorValue);
             if (JSValue failureKindValue = object->getDirect(vm, static_cast<JSVMClientData&>(*vm.clientData).builtinNames().failureKindPrivateName())) {
                 // This is host propagated error in the module loader pipeline.
                 switch (static_cast<ModuleFetchFailureKind>(failureKindValue.asInt32())) {
@@ -316,17 +330,17 @@
         moduleScript->notifyLoadFailed(LoadableScript::Error {
             LoadableScript::ErrorType::CachedScript,
             LoadableScript::ConsoleMessage {
                 MessageSource::JS,
                 MessageLevel::Error,
-                retrieveErrorMessage(*exec, vm, errorValue, scope),
+                retrieveErrorMessage(*globalObject, vm, errorValue, scope),
             }
         });
         return JSValue::encode(jsUndefined());
     });
 
-    promise.then(&state, &fulfillHandler, &rejectHandler);
+    promise.then(&lexicalGlobalObject, &fulfillHandler, &rejectHandler);
 }
 
 WindowProxy& ScriptController::windowProxy()
 {
     return m_frame.windowProxy();
@@ -384,19 +398,19 @@
     jsWindowProxy->window()->setWebAssemblyEnabled(false, errorMessage);
 }
 
 bool ScriptController::canAccessFromCurrentOrigin(Frame* frame, Document& accessingDocument)
 {
-    auto* state = JSExecState::currentState();
+    auto* lexicalGlobalObject = JSExecState::currentState();
 
-    // If the current state is null we should use the accessing document for the security check.
-    if (!state) {
+    // If the current lexicalGlobalObject is null we should use the accessing document for the security check.
+    if (!lexicalGlobalObject) {
         auto* targetDocument = frame ? frame->document() : nullptr;
         return targetDocument && accessingDocument.securityOrigin().canAccess(targetDocument->securityOrigin());
     }
 
-    return BindingSecurity::shouldAllowAccessToFrame(state, frame);
+    return BindingSecurity::shouldAllowAccessToFrame(lexicalGlobalObject, frame);
 }
 
 void ScriptController::updateDocument()
 {
     for (auto& jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
@@ -439,16 +453,16 @@
 
     m_rootObjects.set(nativeHandle, rootObject.copyRef());
     return rootObject;
 }
 
-void ScriptController::collectIsolatedContexts(Vector<std::pair<JSC::ExecState*, SecurityOrigin*>>& result)
+void ScriptController::collectIsolatedContexts(Vector<std::pair<JSC::JSGlobalObject*, SecurityOrigin*>>& result)
 {
     for (auto& jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
-        auto* exec = jsWindowProxy->window()->globalExec();
+        auto* lexicalGlobalObject = jsWindowProxy->window();
         auto* origin = &downcast<DOMWindow>(jsWindowProxy->wrapped()).document()->securityOrigin();
-        result.append(std::make_pair(exec, origin));
+        result.append(std::make_pair(lexicalGlobalObject, origin));
     }
 }
 
 #if ENABLE(NETSCAPE_PLUGIN_API)
 NPObject* ScriptController::windowScriptNPObject()
@@ -492,11 +506,11 @@
     JSLockHolder lock(commonVM());
 
     // Create a JSObject bound to this element
     auto* globalObj = globalObject(pluginWorld());
     // FIXME: is normal okay? - used for NP plugins?
-    JSValue jsElementValue = toJS(globalObj->globalExec(), globalObj, plugin);
+    JSValue jsElementValue = toJS(globalObj, globalObj, plugin);
     if (!jsElementValue || !jsElementValue.isObject())
         return nullptr;
 
     return jsElementValue.getObject();
 }
@@ -546,40 +560,221 @@
         m_windowScriptNPObject = nullptr;
     }
 #endif
 }
 
-JSValue ScriptController::executeScriptInWorld(DOMWrapperWorld& world, const String& script, bool forceUserGesture, ExceptionDetails* exceptionDetails)
+JSC::JSValue ScriptController::executeScriptIgnoringException(const String& script, bool forceUserGesture)
+{
+    return executeScriptInWorldIgnoringException(mainThreadNormalWorld(), script, forceUserGesture);
+}
+
+JSC::JSValue ScriptController::executeScriptInWorldIgnoringException(DOMWrapperWorld& world, const String& script, bool forceUserGesture)
+{
+    auto result = executeScriptInWorld(world, RunJavaScriptParameters { script, false, WTF::nullopt, forceUserGesture });
+    return result ? result.value() : JSC::JSValue { };
+}
+
+ValueOrException ScriptController::executeScriptInWorld(DOMWrapperWorld& world, RunJavaScriptParameters&& parameters)
 {
-    UserGestureIndicator gestureIndicator(forceUserGesture ? Optional<ProcessingUserGestureState>(ProcessingUserGesture) : WTF::nullopt);
-    ScriptSourceCode sourceCode(script, URL(m_frame.document()->url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()->charset()));
+    UserGestureIndicator gestureIndicator(parameters.forceUserGesture == ForceUserGesture::Yes ? Optional<ProcessingUserGestureState>(ProcessingUserGesture) : WTF::nullopt);
 
     if (!canExecuteScripts(AboutToExecuteScript) || isPaused())
-        return { };
+        return makeUnexpected(ExceptionDetails { "Cannot execute JavaScript in this document"_s });
+
+    switch (parameters.runAsAsyncFunction) {
+    case RunAsAsyncFunction::No: {
+        ScriptSourceCode sourceCode(parameters.source, URL(m_frame.document()->url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()->charset()));
+        return evaluateInWorld(sourceCode, world);
+    }
+    case RunAsAsyncFunction::Yes:
+        return callInWorld(WTFMove(parameters), world);
+    default:
+        RELEASE_ASSERT_NOT_REACHED();
+    }
+}
+
+ValueOrException ScriptController::callInWorld(RunJavaScriptParameters&& parameters, DOMWrapperWorld& world)
+{
+    ASSERT(parameters.runAsAsyncFunction == RunAsAsyncFunction::Yes);
+    ASSERT(parameters.arguments);
+
+    auto& proxy = jsWindowProxy(world);
+    auto& globalObject = *proxy.window();
+    MarkedArgumentBuffer markedArguments;
+    StringBuilder functionStringBuilder;
+    String errorMessage;
+
+    // Build up a new script string that is an async function with arguments, and deserialize those arguments.
+    functionStringBuilder.append("(async function(");
+    for (auto argument = parameters.arguments->begin(); argument != parameters.arguments->end();) {
+        functionStringBuilder.append(argument->key);
+        auto serializedArgument = SerializedScriptValue::createFromWireBytes(WTFMove(argument->value));
+
+        auto scope = DECLARE_CATCH_SCOPE(globalObject.vm());
+        auto jsArgument = serializedArgument->deserialize(globalObject, &globalObject);
+        if (UNLIKELY(scope.exception())) {
+            errorMessage = "Unable to deserialize argument to execute asynchronous JavaScript function";
+            break;
+        }
+
+        markedArguments.append(jsArgument);
+
+        ++argument;
+        if (argument != parameters.arguments->end())
+            functionStringBuilder.append(',');
+    }
+
+    if (!errorMessage.isEmpty())
+        return makeUnexpected(ExceptionDetails { errorMessage });
+
+    functionStringBuilder.append("){", parameters.source, "})");
+
+    auto sourceCode = ScriptSourceCode { functionStringBuilder.toString(), URL(m_frame.document()->url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()->charset()) };
+    const auto& jsSourceCode = sourceCode.jsSourceCode();
+
+    String sourceURL = jsSourceCode.provider()->url();
+    const String* savedSourceURL = m_sourceURL;
+    m_sourceURL = &sourceURL;
+
+    Ref<Frame> protector(m_frame);
+
+    InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());
+
+    NakedPtr<JSC::Exception> evaluationException;
+    Optional<ExceptionDetails> optionalDetails;
+    JSValue returnValue;
+    do {
+        JSValue functionObject = JSExecState::profiledEvaluate(&globalObject, JSC::ProfilingReason::Other, jsSourceCode, &proxy, evaluationException);
+
+        if (evaluationException)
+            break;
+
+        if (!functionObject || !functionObject.isFunction(world.vm())) {
+            optionalDetails = { { "Unable to create JavaScript async function to call"_s } };
+            break;
+        }
+
+        // FIXME: https://bugs.webkit.org/show_bug.cgi?id=205562
+        // Getting CallData/CallType shouldn't be required to call into JS.
+        CallData callData;
+        CallType callType = getCallData(world.vm(), functionObject, callData);
+        if (callType == CallType::None) {
+            optionalDetails = { { "Unable to prepare JavaScript async function to be called"_s } };
+            break;
+        }
+
+        returnValue = JSExecState::profiledCall(&globalObject, JSC::ProfilingReason::Other, functionObject, callType, callData, &proxy, markedArguments, evaluationException);
+    } while (false);
+
+    InspectorInstrumentation::didEvaluateScript(m_frame);
+
+    if (evaluationException && !optionalDetails) {
+        ExceptionDetails details;
+        reportException(&globalObject, evaluationException, sourceCode.cachedScript(), &details);
+        optionalDetails = WTFMove(details);
+    }
+
+    m_sourceURL = savedSourceURL;
+
+    if (optionalDetails)
+        return makeUnexpected(*optionalDetails);
+    return returnValue;
+}
 
-    return evaluateInWorld(sourceCode, world, exceptionDetails);
+JSC::JSValue ScriptController::executeUserAgentScriptInWorldIgnoringException(DOMWrapperWorld& world, const String& script, bool forceUserGesture)
+{
+    auto result = executeUserAgentScriptInWorld(world, script, forceUserGesture);
+    return result ? result.value() : JSC::JSValue { };
+}
+ValueOrException ScriptController::executeUserAgentScriptInWorld(DOMWrapperWorld& world, const String& script, bool forceUserGesture)
+{
+    return executeUserAgentScriptInWorldInternal(world, { script, false, WTF::nullopt, forceUserGesture });
 }
 
-JSValue ScriptController::executeUserAgentScriptInWorld(DOMWrapperWorld& world, const String& script, bool forceUserGesture, ExceptionDetails* exceptionDetails)
+ValueOrException ScriptController::executeUserAgentScriptInWorldInternal(DOMWrapperWorld& world, RunJavaScriptParameters&& parameters)
 {
     auto& document = *m_frame.document();
-    if (!shouldAllowUserAgentScripts(document))
-        return { };
+    auto allowed = shouldAllowUserAgentScripts(document);
+    if (!allowed)
+        return makeUnexpected(allowed.error());
 
     document.setHasEvaluatedUserAgentScripts();
-    return executeScriptInWorld(world, script, forceUserGesture, exceptionDetails);
+    return executeScriptInWorld(world, WTFMove(parameters));
 }
 
-bool ScriptController::shouldAllowUserAgentScripts(Document& document) const
+void ScriptController::executeAsynchronousUserAgentScriptInWorld(DOMWrapperWorld& world, RunJavaScriptParameters&& parameters, ResolveFunction&& resolveCompletionHandler)
+{
+    auto result = executeUserAgentScriptInWorldInternal(world, WTFMove(parameters));
+
+    if (parameters.runAsAsyncFunction == RunAsAsyncFunction::No || !result || !result.value().isObject()) {
+        resolveCompletionHandler(result);
+        return;
+    }
+
+    // When running JavaScript as an async function, any "thenable" object gets promise-like behavior of deferred completion.
+    auto thenIdentifier = world.vm().propertyNames->then;
+    auto& proxy = jsWindowProxy(world);
+    auto& globalObject = *proxy.window();
+
+    auto thenFunction = result.value().get(&globalObject, thenIdentifier);
+    if (!thenFunction.isObject()) {
+        resolveCompletionHandler(result);
+        return;
+    }
+
+    CallData callData;
+    CallType callType = asObject(thenFunction)->methodTable(world.vm())->getCallData(asObject(thenFunction), callData);
+    if (callType == CallType::None) {
+        resolveCompletionHandler(result);
+        return;
+    }
+
+    auto sharedResolveFunction = createSharedTask<void(ValueOrException)>([resolveCompletionHandler = WTFMove(resolveCompletionHandler)](ValueOrException result) mutable {
+        if (resolveCompletionHandler)
+            resolveCompletionHandler(result);
+        resolveCompletionHandler = nullptr;
+    });
+
+    auto* fulfillHandler = JSC::JSNativeStdFunction::create(world.vm(), &globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject*, CallFrame* callFrame) mutable {
+        sharedResolveFunction->run(callFrame->argument(0));
+        return JSValue::encode(jsUndefined());
+    });
+
+    auto* rejectHandler = JSC::JSNativeStdFunction::create(world.vm(), &globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject* globalObject, CallFrame* callFrame) mutable {
+        sharedResolveFunction->run(makeUnexpected(ExceptionDetails { callFrame->argument(0).toWTFString(globalObject) }));
+        return JSValue::encode(jsUndefined());
+    });
+
+    auto finalizeCount = makeUniqueWithoutFastMallocCheck<unsigned>(0);
+    auto finalizeGuard = createSharedTask<void()>([sharedResolveFunction = WTFMove(sharedResolveFunction), finalizeCount = WTFMove(finalizeCount)]() {
+        if (++(*finalizeCount) == 2)
+            sharedResolveFunction->run(makeUnexpected(ExceptionDetails { "Completion handler for function call is no longer reachable"_s }));
+    });
+
+    world.vm().heap.addFinalizer(fulfillHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {
+        finalizeGuard->run();
+    });
+    world.vm().heap.addFinalizer(rejectHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {
+        finalizeGuard->run();
+    });
+
+    JSC::MarkedArgumentBuffer arguments;
+    arguments.append(fulfillHandler);
+    arguments.append(rejectHandler);
+
+    call(&globalObject, thenFunction, callType, callData, result.value(), arguments);
+}
+
+Expected<void, ExceptionDetails> ScriptController::shouldAllowUserAgentScripts(Document& document) const
 {
 #if ENABLE(APPLE_PAY)
     if (auto page = m_frame.page())
         return page->paymentCoordinator().shouldAllowUserAgentScripts(document);
 #else
     UNUSED_PARAM(document);
 #endif
-    return true;
+    return { };
 }
 
 bool ScriptController::canExecuteScripts(ReasonForCallingCanExecuteScripts reason)
 {
     if (reason == AboutToExecuteScript)
@@ -596,33 +791,18 @@
         return false;
 
     return m_frame.loader().client().allowScript(m_frame.settings().isScriptEnabled());
 }
 
-JSValue ScriptController::executeScript(const String& script, bool forceUserGesture, ExceptionDetails* exceptionDetails)
-{
-    UserGestureIndicator gestureIndicator(forceUserGesture ? Optional<ProcessingUserGestureState>(ProcessingUserGesture) : WTF::nullopt);
-    return executeScript(ScriptSourceCode(script, URL(m_frame.document()->url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()->charset())), exceptionDetails);
-}
-
-JSValue ScriptController::executeScript(const ScriptSourceCode& sourceCode, ExceptionDetails* exceptionDetails)
-{
-    if (!canExecuteScripts(AboutToExecuteScript) || isPaused())
-        return { }; // FIXME: Would jsNull be better?
-
-    // FIXME: Preventing Frame from being destroyed is essentially unnecessary.
-    // https://bugs.webkit.org/show_bug.cgi?id=164763
-    Ref<Frame> protector(m_frame); // Script execution can destroy the frame, and thus the ScriptController.
-
-    return evaluate(sourceCode, exceptionDetails);
-}
-
-bool ScriptController::executeIfJavaScriptURL(const URL& url, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL)
+bool ScriptController::executeIfJavaScriptURL(const URL& url, RefPtr<SecurityOrigin> requesterSecurityOrigin, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL)
 {
     if (!WTF::protocolIsJavaScript(url))
         return false;
 
+    if (requesterSecurityOrigin && !requesterSecurityOrigin->canAccess(m_frame.document()->securityOrigin()))
+        return true;
+
     if (!m_frame.page() || !m_frame.document()->contentSecurityPolicy()->allowJavaScriptURLs(m_frame.document()->url(), eventHandlerPosition().m_line))
         return true;
 
     // We need to hold onto the Frame here because executing script can
     // destroy the frame.
@@ -630,19 +810,19 @@
     RefPtr<Document> ownerDocument(m_frame.document());
 
     const int javascriptSchemeLength = sizeof("javascript:") - 1;
 
     String decodedURL = decodeURLEscapeSequences(url.string());
-    auto result = executeScript(decodedURL.substring(javascriptSchemeLength));
+    auto result = executeScriptIgnoringException(decodedURL.substring(javascriptSchemeLength));
 
     // If executing script caused this frame to be removed from the page, we
     // don't want to try to replace its document!
     if (!m_frame.page())
         return true;
 
     String scriptResult;
-    if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window()->globalExec(), scriptResult))
+    if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window(), scriptResult))
         return true;
 
     // FIXME: We should always replace the document, but doing so
     //        synchronously can cause crashes:
     //        http://bugs.webkit.org/show_bug.cgi?id=16782

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/style/GridArea.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Google Inc. All rights reserved.
  3  * Copyright (C) 2013-2017 Igalia S.L.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #pragma once
 33 
 34 #include &quot;GridPosition.h&quot;
 35 #include &lt;wtf/HashMap.h&gt;
 36 #include &lt;wtf/text/WTFString.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 // A span in a single direction (either rows or columns). Note that |startLine|
 41 // and |endLine| are grid lines&#39; indexes.
 42 // Despite line numbers in the spec start in &quot;1&quot;, the indexes here start in &quot;0&quot;.
 43 class GridSpan {
 44 public:
 45 
 46     static GridSpan untranslatedDefiniteGridSpan(int startLine, int endLine)
 47     {
 48         return GridSpan(startLine, endLine, UntranslatedDefinite);
 49     }
 50 
 51     static GridSpan translatedDefiniteGridSpan(unsigned startLine, unsigned endLine)
 52     {
 53         return GridSpan(startLine, endLine, TranslatedDefinite);
 54     }
 55 
 56     static GridSpan indefiniteGridSpan()
 57     {
 58         return GridSpan(0, 1, Indefinite);
 59     }
 60 
 61     bool operator==(const GridSpan&amp; o) const
 62     {
 63         return m_type == o.m_type &amp;&amp; m_startLine == o.m_startLine &amp;&amp; m_endLine == o.m_endLine;
 64     }
 65 
 66     unsigned integerSpan() const
 67     {
 68         ASSERT(isTranslatedDefinite());
 69         return m_endLine - m_startLine;
 70     }
 71 
 72     int untranslatedStartLine() const
 73     {
 74         ASSERT(m_type == UntranslatedDefinite);
 75         return m_startLine;
 76     }
 77 
 78     int untranslatedEndLine() const
 79     {
 80         ASSERT(m_type == UntranslatedDefinite);
 81         return m_endLine;
 82     }
 83 
 84     unsigned startLine() const
 85     {
 86         ASSERT(isTranslatedDefinite());
 87         ASSERT(m_endLine &gt;= 0);
 88         return m_startLine;
 89     }
 90 
 91     unsigned endLine() const
 92     {
 93         ASSERT(isTranslatedDefinite());
 94         ASSERT(m_endLine &gt; 0);
 95         return m_endLine;
 96     }
 97 
 98     struct GridSpanIterator {
 99         GridSpanIterator(unsigned value)
100             : value(value)
101         {
102         }
103 
104         operator unsigned&amp;() { return value; }
105         unsigned operator*() const { return value; }
106 
107         unsigned value;
108     };
109 
110     GridSpanIterator begin() const
111     {
112         ASSERT(isTranslatedDefinite());
113         return m_startLine;
114     }
115 
116     GridSpanIterator end() const
117     {
118         ASSERT(isTranslatedDefinite());
119         return m_endLine;
120     }
121 
122     bool isTranslatedDefinite() const
123     {
124         return m_type == TranslatedDefinite;
125     }
126 
127     bool isIndefinite() const
128     {
129         return m_type == Indefinite;
130     }
131 
132     void translate(unsigned offset)
133     {
134         ASSERT(m_type == UntranslatedDefinite);
135 
136         m_type = TranslatedDefinite;
137         m_startLine += offset;
138         m_endLine += offset;
139 
140         ASSERT(m_startLine &gt;= 0);
141         ASSERT(m_endLine &gt; 0);
142     }
143 
144 private:
145 
146     enum GridSpanType {UntranslatedDefinite, TranslatedDefinite, Indefinite};
147 
148     GridSpan(int startLine, int endLine, GridSpanType type)
149         : m_type(type)
150     {
<a name="1" id="anc1"></a><span class="line-modified">151 #if !ASSERT_DISABLED</span>
152         ASSERT(startLine &lt; endLine);
153         if (type == TranslatedDefinite) {
154             ASSERT(startLine &gt;= 0);
155             ASSERT(endLine &gt; 0);
156         }
157 #endif
158 
159         m_startLine = std::max(GridPosition::min(), std::min(startLine, GridPosition::max() - 1));
160         m_endLine = std::max(GridPosition::min() + 1, std::min(endLine, GridPosition::max()));
161     }
162 
163     int m_startLine;
164     int m_endLine;
165     GridSpanType m_type;
166 
167 
168 };
169 
170 // This represents a grid area that spans in both rows&#39; and columns&#39; direction.
171 class GridArea {
172     WTF_MAKE_FAST_ALLOCATED;
173 public:
174     // HashMap requires a default constuctor.
175     GridArea()
176         : columns(GridSpan::indefiniteGridSpan())
177         , rows(GridSpan::indefiniteGridSpan())
178     {
179     }
180 
181     GridArea(const GridSpan&amp; r, const GridSpan&amp; c)
182         : columns(c)
183         , rows(r)
184     {
185     }
186 
187     bool operator==(const GridArea&amp; o) const
188     {
189         return columns == o.columns &amp;&amp; rows == o.rows;
190     }
191 
192     bool operator!=(const GridArea&amp; o) const
193     {
194         return !(*this == o);
195     }
196 
197     GridSpan columns;
198     GridSpan rows;
199 };
200 
201 typedef HashMap&lt;String, GridArea&gt; NamedGridAreaMap;
202 
203 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
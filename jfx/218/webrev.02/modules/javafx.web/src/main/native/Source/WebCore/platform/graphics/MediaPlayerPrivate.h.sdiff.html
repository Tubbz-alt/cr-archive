<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayerPrivate.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaPlayerEnums.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NativeImage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayerPrivate.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;MediaPlayer.h&quot;
 31 #include &quot;PlatformTimeRanges.h&quot;
 32 
 33 namespace WebCore {
 34 
 35 class MediaPlayerPrivateInterface {
 36     WTF_MAKE_NONCOPYABLE(MediaPlayerPrivateInterface); WTF_MAKE_FAST_ALLOCATED;
 37 public:
 38     MediaPlayerPrivateInterface() = default;
 39     virtual ~MediaPlayerPrivateInterface() = default;
 40 
<span class="line-modified"> 41     virtual void load(const String&amp; url) = 0;</span>


 42 #if ENABLE(MEDIA_SOURCE)
 43     virtual void load(const String&amp; url, MediaSourcePrivateClient*) = 0;
 44 #endif
 45 #if ENABLE(MEDIA_STREAM)
 46     virtual void load(MediaStreamPrivate&amp;) = 0;
 47 #endif
 48     virtual void cancelLoad() = 0;
 49 









 50     virtual void prepareToPlay() { }
<span class="line-modified"> 51     virtual PlatformLayer* platformLayer() const { return 0; }</span>
 52 
 53 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 54     virtual void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler) { completionHandler(); }
 55     virtual void updateVideoFullscreenInlineImage() { }
 56     virtual void setVideoFullscreenFrame(FloatRect) { }
 57     virtual void setVideoFullscreenGravity(MediaPlayer::VideoGravity) { }
 58     virtual void setVideoFullscreenMode(MediaPlayer::VideoFullscreenMode) { }
 59     virtual void videoFullscreenStandbyChanged() { }
 60 #endif
 61 
 62 #if PLATFORM(IOS_FAMILY)
<span class="line-modified"> 63     virtual NSArray *timedMetadata() const { return 0; }</span>
 64     virtual String accessLog() const { return emptyString(); }
 65     virtual String errorLog() const { return emptyString(); }
 66 #endif
 67     virtual long platformErrorCode() const { return 0; }
 68 
 69     virtual void play() = 0;
 70     virtual void pause() = 0;
 71     virtual void setBufferingPolicy(MediaPlayer::BufferingPolicy) { }
 72 
 73     virtual bool supportsPictureInPicture() const { return false; }
 74     virtual bool supportsFullscreen() const { return false; }
 75     virtual bool supportsScanning() const { return false; }
 76     virtual bool requiresImmediateCompositing() const { return false; }
 77 
 78     virtual bool canSaveMediaData() const { return false; }
 79 
 80     virtual FloatSize naturalSize() const = 0;
 81 
 82     virtual bool hasVideo() const = 0;
 83     virtual bool hasAudio() const = 0;
</pre>
<hr />
<pre>
124     virtual void setClosedCaptionsVisible(bool) { }
125 
126     virtual double maxFastForwardRate() const { return std::numeric_limits&lt;double&gt;::infinity(); }
127     virtual double minFastReverseRate() const { return -std::numeric_limits&lt;double&gt;::infinity(); }
128 
129     virtual MediaPlayer::NetworkState networkState() const = 0;
130     virtual MediaPlayer::ReadyState readyState() const = 0;
131 
132     virtual std::unique_ptr&lt;PlatformTimeRanges&gt; seekable() const { return maxMediaTimeSeekable() == MediaTime::zeroTime() ? makeUnique&lt;PlatformTimeRanges&gt;() : makeUnique&lt;PlatformTimeRanges&gt;(minMediaTimeSeekable(), maxMediaTimeSeekable()); }
133     virtual float maxTimeSeekable() const { return 0; }
134     virtual MediaTime maxMediaTimeSeekable() const { return MediaTime::createWithDouble(maxTimeSeekable()); }
135     virtual double minTimeSeekable() const { return 0; }
136     virtual MediaTime minMediaTimeSeekable() const { return MediaTime::createWithDouble(minTimeSeekable()); }
137     virtual std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const = 0;
138     virtual double seekableTimeRangesLastModifiedTime() const { return 0; }
139     virtual double liveUpdateInterval() const { return 0; }
140 
141     virtual unsigned long long totalBytes() const { return 0; }
142     virtual bool didLoadingProgress() const = 0;
143 
<span class="line-modified">144     virtual void setSize(const IntSize&amp;) = 0;</span>
145 
146     virtual void paint(GraphicsContext&amp;, const FloatRect&amp;) = 0;
147 
148     virtual void paintCurrentFrameInContext(GraphicsContext&amp; c, const FloatRect&amp; r) { paint(c, r); }
<span class="line-modified">149     virtual bool copyVideoTextureToPlatformTexture(GraphicsContext3D*, Platform3DObject, GC3Denum, GC3Dint, GC3Denum, GC3Denum, GC3Denum, bool, bool) { return false; }</span>
150     virtual NativeImagePtr nativeImageForCurrentTime() { return nullptr; }
151 
152     virtual void setPreload(MediaPlayer::Preload) { }
153 
<span class="line-modified">154     virtual bool hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::HaveCurrentData; }</span>
<span class="line-removed">155 </span>
<span class="line-removed">156     virtual bool canLoadPoster() const { return false; }</span>
<span class="line-removed">157     virtual void setPoster(const String&amp;) { }</span>
158 
159 #if USE(NATIVE_FULLSCREEN_VIDEO)
160     virtual void enterFullscreen() { }
161     virtual void exitFullscreen() { }
162 #endif
163 
164 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
165 
166     virtual String wirelessPlaybackTargetName() const { return emptyString(); }
167     virtual MediaPlayer::WirelessPlaybackTargetType wirelessPlaybackTargetType() const { return MediaPlayer::TargetTypeNone; }
168 
169     virtual bool wirelessVideoPlaybackDisabled() const { return true; }
170     virtual void setWirelessVideoPlaybackDisabled(bool) { }
171 
172     virtual bool canPlayToWirelessPlaybackTarget() const { return false; }
173     virtual bool isCurrentPlaybackTargetWireless() const { return false; }
174     virtual void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) { }
175 
176     virtual void setShouldPlayToPlaybackTarget(bool) { }
177 #endif
178 
179 #if USE(NATIVE_FULLSCREEN_VIDEO)
180     virtual bool canEnterFullscreen() const { return false; }
181 #endif
182 
183     // whether accelerated rendering is supported by the media engine for the current media.
184     virtual bool supportsAcceleratedRendering() const { return false; }
185     // called when the rendering system flips the into or out of accelerated rendering mode.
186     virtual void acceleratedRenderingStateChanged() { }
187 
188     virtual bool shouldMaintainAspectRatio() const { return true; }
189     virtual void setShouldMaintainAspectRatio(bool) { }
190 
191     virtual bool hasSingleSecurityOrigin() const { return false; }
192     virtual bool didPassCORSAccessCheck() const { return false; }
193     virtual Optional&lt;bool&gt; wouldTaintOrigin(const SecurityOrigin&amp;) const { return WTF::nullopt; }
194 
<span class="line-modified">195     virtual MediaPlayer::MovieLoadType movieLoadType() const { return MediaPlayer::Unknown; }</span>
196 
197     virtual void prepareForRendering() { }
198 
199     // Time value in the movie&#39;s time scale. It is only necessary to override this if the media
200     // engine uses rational numbers to represent media time.
201     virtual MediaTime mediaTimeForTimeValue(const MediaTime&amp; timeValue) const { return timeValue; }
202 
203     // Overide this if it is safe for HTMLMediaElement to cache movie time and report
204     // &#39;currentTime&#39; as [cached time + elapsed wall time]. Returns the maximum wall time
205     // it is OK to calculate movie time before refreshing the cached time.
206     virtual double maximumDurationToCacheMediaTime() const { return 0; }
207 
208     virtual unsigned decodedFrameCount() const { return 0; }
209     virtual unsigned droppedFrameCount() const { return 0; }
210     virtual unsigned audioDecodedByteCount() const { return 0; }
211     virtual unsigned videoDecodedByteCount() const { return 0; }
212 
213     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;) { return { }; }
214     void clearMediaCache(const String&amp;, WallTime) { }
215     void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;) { }
</pre>
</td>
<td>
<hr />
<pre>
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;MediaPlayer.h&quot;
 31 #include &quot;PlatformTimeRanges.h&quot;
 32 
 33 namespace WebCore {
 34 
 35 class MediaPlayerPrivateInterface {
 36     WTF_MAKE_NONCOPYABLE(MediaPlayerPrivateInterface); WTF_MAKE_FAST_ALLOCATED;
 37 public:
 38     MediaPlayerPrivateInterface() = default;
 39     virtual ~MediaPlayerPrivateInterface() = default;
 40 
<span class="line-modified"> 41     virtual void load(const String&amp;) { }</span>
<span class="line-added"> 42     virtual void load(const URL&amp; url, const ContentType&amp;, const String&amp;) { load(url.string()); }</span>
<span class="line-added"> 43 </span>
 44 #if ENABLE(MEDIA_SOURCE)
 45     virtual void load(const String&amp; url, MediaSourcePrivateClient*) = 0;
 46 #endif
 47 #if ENABLE(MEDIA_STREAM)
 48     virtual void load(MediaStreamPrivate&amp;) = 0;
 49 #endif
 50     virtual void cancelLoad() = 0;
 51 
<span class="line-added"> 52     virtual void prepareForPlayback(bool privateMode, MediaPlayer::Preload preload, bool preservesPitch, bool prepare)</span>
<span class="line-added"> 53     {</span>
<span class="line-added"> 54         setPrivateBrowsingMode(privateMode);</span>
<span class="line-added"> 55         setPreload(preload);</span>
<span class="line-added"> 56         setPreservesPitch(preservesPitch);</span>
<span class="line-added"> 57         if (prepare)</span>
<span class="line-added"> 58             prepareForRendering();</span>
<span class="line-added"> 59     }</span>
<span class="line-added"> 60 </span>
 61     virtual void prepareToPlay() { }
<span class="line-modified"> 62     virtual PlatformLayer* platformLayer() const { return nullptr; }</span>
 63 
 64 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 65     virtual void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler) { completionHandler(); }
 66     virtual void updateVideoFullscreenInlineImage() { }
 67     virtual void setVideoFullscreenFrame(FloatRect) { }
 68     virtual void setVideoFullscreenGravity(MediaPlayer::VideoGravity) { }
 69     virtual void setVideoFullscreenMode(MediaPlayer::VideoFullscreenMode) { }
 70     virtual void videoFullscreenStandbyChanged() { }
 71 #endif
 72 
 73 #if PLATFORM(IOS_FAMILY)
<span class="line-modified"> 74     virtual NSArray *timedMetadata() const { return nil; }</span>
 75     virtual String accessLog() const { return emptyString(); }
 76     virtual String errorLog() const { return emptyString(); }
 77 #endif
 78     virtual long platformErrorCode() const { return 0; }
 79 
 80     virtual void play() = 0;
 81     virtual void pause() = 0;
 82     virtual void setBufferingPolicy(MediaPlayer::BufferingPolicy) { }
 83 
 84     virtual bool supportsPictureInPicture() const { return false; }
 85     virtual bool supportsFullscreen() const { return false; }
 86     virtual bool supportsScanning() const { return false; }
 87     virtual bool requiresImmediateCompositing() const { return false; }
 88 
 89     virtual bool canSaveMediaData() const { return false; }
 90 
 91     virtual FloatSize naturalSize() const = 0;
 92 
 93     virtual bool hasVideo() const = 0;
 94     virtual bool hasAudio() const = 0;
</pre>
<hr />
<pre>
135     virtual void setClosedCaptionsVisible(bool) { }
136 
137     virtual double maxFastForwardRate() const { return std::numeric_limits&lt;double&gt;::infinity(); }
138     virtual double minFastReverseRate() const { return -std::numeric_limits&lt;double&gt;::infinity(); }
139 
140     virtual MediaPlayer::NetworkState networkState() const = 0;
141     virtual MediaPlayer::ReadyState readyState() const = 0;
142 
143     virtual std::unique_ptr&lt;PlatformTimeRanges&gt; seekable() const { return maxMediaTimeSeekable() == MediaTime::zeroTime() ? makeUnique&lt;PlatformTimeRanges&gt;() : makeUnique&lt;PlatformTimeRanges&gt;(minMediaTimeSeekable(), maxMediaTimeSeekable()); }
144     virtual float maxTimeSeekable() const { return 0; }
145     virtual MediaTime maxMediaTimeSeekable() const { return MediaTime::createWithDouble(maxTimeSeekable()); }
146     virtual double minTimeSeekable() const { return 0; }
147     virtual MediaTime minMediaTimeSeekable() const { return MediaTime::createWithDouble(minTimeSeekable()); }
148     virtual std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const = 0;
149     virtual double seekableTimeRangesLastModifiedTime() const { return 0; }
150     virtual double liveUpdateInterval() const { return 0; }
151 
152     virtual unsigned long long totalBytes() const { return 0; }
153     virtual bool didLoadingProgress() const = 0;
154 
<span class="line-modified">155     virtual void setSize(const IntSize&amp;) { }</span>
156 
157     virtual void paint(GraphicsContext&amp;, const FloatRect&amp;) = 0;
158 
159     virtual void paintCurrentFrameInContext(GraphicsContext&amp; c, const FloatRect&amp; r) { paint(c, r); }
<span class="line-modified">160     virtual bool copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL*, PlatformGLObject, GCGLenum, GCGLint, GCGLenum, GCGLenum, GCGLenum, bool, bool) { return false; }</span>
161     virtual NativeImagePtr nativeImageForCurrentTime() { return nullptr; }
162 
163     virtual void setPreload(MediaPlayer::Preload) { }
164 
<span class="line-modified">165     virtual bool hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::ReadyState::HaveCurrentData; }</span>



166 
167 #if USE(NATIVE_FULLSCREEN_VIDEO)
168     virtual void enterFullscreen() { }
169     virtual void exitFullscreen() { }
170 #endif
171 
172 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
173 
174     virtual String wirelessPlaybackTargetName() const { return emptyString(); }
175     virtual MediaPlayer::WirelessPlaybackTargetType wirelessPlaybackTargetType() const { return MediaPlayer::TargetTypeNone; }
176 
177     virtual bool wirelessVideoPlaybackDisabled() const { return true; }
178     virtual void setWirelessVideoPlaybackDisabled(bool) { }
179 
180     virtual bool canPlayToWirelessPlaybackTarget() const { return false; }
181     virtual bool isCurrentPlaybackTargetWireless() const { return false; }
182     virtual void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) { }
183 
184     virtual void setShouldPlayToPlaybackTarget(bool) { }
185 #endif
186 
187 #if USE(NATIVE_FULLSCREEN_VIDEO)
188     virtual bool canEnterFullscreen() const { return false; }
189 #endif
190 
191     // whether accelerated rendering is supported by the media engine for the current media.
192     virtual bool supportsAcceleratedRendering() const { return false; }
193     // called when the rendering system flips the into or out of accelerated rendering mode.
194     virtual void acceleratedRenderingStateChanged() { }
195 
196     virtual bool shouldMaintainAspectRatio() const { return true; }
197     virtual void setShouldMaintainAspectRatio(bool) { }
198 
199     virtual bool hasSingleSecurityOrigin() const { return false; }
200     virtual bool didPassCORSAccessCheck() const { return false; }
201     virtual Optional&lt;bool&gt; wouldTaintOrigin(const SecurityOrigin&amp;) const { return WTF::nullopt; }
202 
<span class="line-modified">203     virtual MediaPlayer::MovieLoadType movieLoadType() const { return MediaPlayer::MovieLoadType::Unknown; }</span>
204 
205     virtual void prepareForRendering() { }
206 
207     // Time value in the movie&#39;s time scale. It is only necessary to override this if the media
208     // engine uses rational numbers to represent media time.
209     virtual MediaTime mediaTimeForTimeValue(const MediaTime&amp; timeValue) const { return timeValue; }
210 
211     // Overide this if it is safe for HTMLMediaElement to cache movie time and report
212     // &#39;currentTime&#39; as [cached time + elapsed wall time]. Returns the maximum wall time
213     // it is OK to calculate movie time before refreshing the cached time.
214     virtual double maximumDurationToCacheMediaTime() const { return 0; }
215 
216     virtual unsigned decodedFrameCount() const { return 0; }
217     virtual unsigned droppedFrameCount() const { return 0; }
218     virtual unsigned audioDecodedByteCount() const { return 0; }
219     virtual unsigned videoDecodedByteCount() const { return 0; }
220 
221     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;) { return { }; }
222     void clearMediaCache(const String&amp;, WallTime) { }
223     void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;) { }
</pre>
</td>
</tr>
</table>
<center><a href="MediaPlayerEnums.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NativeImage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
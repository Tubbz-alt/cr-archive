<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2004, 2005, 2006, 2009, 2013 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Position.h&quot;
  28 
  29 #include &quot;CSSComputedStyleDeclaration.h&quot;
  30 #include &quot;Editing.h&quot;
  31 #include &quot;HTMLBRElement.h&quot;
  32 #include &quot;HTMLBodyElement.h&quot;
  33 #include &quot;HTMLHtmlElement.h&quot;
  34 #include &quot;HTMLNames.h&quot;
  35 #include &quot;HTMLParserIdioms.h&quot;
  36 #include &quot;HTMLTableElement.h&quot;
  37 #include &quot;InlineElementBox.h&quot;
  38 #include &quot;InlineIterator.h&quot;
  39 #include &quot;InlineTextBox.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  40 #include &quot;LineLayoutTraversal.h&quot;</span>
  41 #include &quot;Logging.h&quot;
  42 #include &quot;NodeTraversal.h&quot;
  43 #include &quot;PositionIterator.h&quot;
  44 #include &quot;RenderBlock.h&quot;
  45 #include &quot;RenderFlexibleBox.h&quot;
  46 #include &quot;RenderGrid.h&quot;
  47 #include &quot;RenderInline.h&quot;
  48 #include &quot;RenderIterator.h&quot;
  49 #include &quot;RenderLineBreak.h&quot;
  50 #include &quot;RenderText.h&quot;
<a name="2" id="anc2"></a>
  51 #include &quot;Text.h&quot;
  52 #include &quot;TextIterator.h&quot;
  53 #include &quot;VisiblePosition.h&quot;
  54 #include &quot;VisibleUnits.h&quot;
  55 #include &lt;stdio.h&gt;
  56 #include &lt;wtf/text/CString.h&gt;
  57 #include &lt;wtf/text/TextStream.h&gt;
  58 #include &lt;wtf/unicode/CharacterNames.h&gt;
  59 
  60 #if ENABLE(TREE_DEBUGGING)
  61 #include &lt;wtf/text/StringBuilder.h&gt;
  62 #endif
  63 
  64 namespace WebCore {
  65 
  66 using namespace HTMLNames;
  67 
  68 static bool hasInlineBoxWrapper(RenderObject&amp; renderer)
  69 {
  70     if (is&lt;RenderBox&gt;(renderer) &amp;&amp; downcast&lt;RenderBox&gt;(renderer).inlineBoxWrapper())
  71         return true;
  72     if (is&lt;RenderText&gt;(renderer) &amp;&amp; downcast&lt;RenderText&gt;(renderer).firstTextBox())
  73         return true;
  74     if (is&lt;RenderLineBreak&gt;(renderer) &amp;&amp; downcast&lt;RenderLineBreak&gt;(renderer).inlineBoxWrapper())
  75         return true;
  76     return false;
  77 }
  78 
  79 static Node* nextRenderedEditable(Node* node)
  80 {
  81     while ((node = nextLeafNode(node))) {
  82         RenderObject* renderer = node-&gt;renderer();
  83         if (!renderer || !node-&gt;hasEditableStyle())
  84             continue;
  85         if (hasInlineBoxWrapper(*renderer))
  86             return node;
  87     }
  88     return nullptr;
  89 }
  90 
  91 static Node* previousRenderedEditable(Node* node)
  92 {
  93     while ((node = previousLeafNode(node))) {
  94         RenderObject* renderer = node-&gt;renderer();
  95         if (!renderer || !node-&gt;hasEditableStyle())
  96             continue;
  97         if (hasInlineBoxWrapper(*renderer))
  98             return node;
  99     }
 100     return nullptr;
 101 }
 102 
 103 Position::Position(Node* anchorNode, unsigned offset, LegacyEditingPositionFlag)
 104     : m_anchorNode(anchorNode)
 105     , m_offset(offset)
 106     , m_anchorType(anchorTypeForLegacyEditingPosition(m_anchorNode.get(), m_offset))
 107     , m_isLegacyEditingPosition(true)
 108 {
 109     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isShadowRoot() || m_anchorNode == containerNode());
 110     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isPseudoElement());
 111 }
 112 
 113 Position::Position(Node* anchorNode, AnchorType anchorType)
 114     : m_anchorNode(anchorNode)
 115     , m_offset(0)
 116     , m_anchorType(anchorType)
 117     , m_isLegacyEditingPosition(false)
 118 {
 119     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isShadowRoot() || m_anchorNode == containerNode());
 120     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isPseudoElement());
 121     ASSERT(anchorType != PositionIsOffsetInAnchor);
 122     ASSERT(!((anchorType == PositionIsBeforeChildren || anchorType == PositionIsAfterChildren)
 123         &amp;&amp; (is&lt;Text&gt;(*m_anchorNode) || editingIgnoresContent(*m_anchorNode))));
 124 }
 125 
 126 Position::Position(Node* anchorNode, int offset, AnchorType anchorType)
 127     : m_anchorNode(anchorNode)
 128     , m_offset(offset)
 129     , m_anchorType(anchorType)
 130     , m_isLegacyEditingPosition(false)
 131 {
 132     ASSERT(!m_anchorNode || !editingIgnoresContent(*m_anchorNode));
 133     ASSERT(!m_anchorNode || !m_anchorNode-&gt;isPseudoElement());
 134     ASSERT(anchorType == PositionIsOffsetInAnchor);
 135 }
 136 
 137 Position::Position(Text* textNode, unsigned offset)
 138     : m_anchorNode(textNode)
 139     , m_offset(offset)
 140     , m_anchorType(PositionIsOffsetInAnchor)
 141     , m_isLegacyEditingPosition(false)
 142 {
 143     ASSERT(m_anchorNode);
 144 }
 145 
 146 void Position::moveToPosition(Node* node, int offset)
 147 {
 148     ASSERT(!editingIgnoresContent(*node));
 149     ASSERT(anchorType() == PositionIsOffsetInAnchor || m_isLegacyEditingPosition);
 150     m_anchorNode = node;
 151     m_offset = offset;
 152     if (m_isLegacyEditingPosition)
 153         m_anchorType = anchorTypeForLegacyEditingPosition(m_anchorNode.get(), m_offset);
 154 }
 155 void Position::moveToOffset(int offset)
 156 {
 157     ASSERT(anchorType() == PositionIsOffsetInAnchor || m_isLegacyEditingPosition);
 158     m_offset = offset;
 159     if (m_isLegacyEditingPosition)
 160         m_anchorType = anchorTypeForLegacyEditingPosition(m_anchorNode.get(), m_offset);
 161 }
 162 
 163 Node* Position::containerNode() const
 164 {
 165     if (!m_anchorNode)
 166         return nullptr;
 167 
 168     switch (anchorType()) {
 169     case PositionIsBeforeChildren:
 170     case PositionIsAfterChildren:
 171     case PositionIsOffsetInAnchor:
 172         return m_anchorNode.get();
 173     case PositionIsBeforeAnchor:
 174     case PositionIsAfterAnchor:
 175         return m_anchorNode-&gt;parentNode();
 176     }
 177     ASSERT_NOT_REACHED();
 178     return nullptr;
 179 }
 180 
 181 Text* Position::containerText() const
 182 {
 183     switch (anchorType()) {
 184     case PositionIsOffsetInAnchor:
 185         return m_anchorNode &amp;&amp; is&lt;Text&gt;(*m_anchorNode) ? downcast&lt;Text&gt;(m_anchorNode.get()) : nullptr;
 186     case PositionIsBeforeAnchor:
 187     case PositionIsAfterAnchor:
 188         return nullptr;
 189     case PositionIsBeforeChildren:
 190     case PositionIsAfterChildren:
 191         ASSERT(!m_anchorNode || !is&lt;Text&gt;(*m_anchorNode));
 192         return nullptr;
 193     }
 194     ASSERT_NOT_REACHED();
 195     return nullptr;
 196 }
 197 
 198 int Position::computeOffsetInContainerNode() const
 199 {
 200     if (!m_anchorNode)
 201         return 0;
 202 
 203     switch (anchorType()) {
 204     case PositionIsBeforeChildren:
 205         return 0;
 206     case PositionIsAfterChildren:
 207         return lastOffsetInNode(m_anchorNode.get());
 208     case PositionIsOffsetInAnchor:
 209         return minOffsetForNode(m_anchorNode.get(), m_offset);
 210     case PositionIsBeforeAnchor:
 211         return m_anchorNode-&gt;computeNodeIndex();
 212     case PositionIsAfterAnchor:
 213         return m_anchorNode-&gt;computeNodeIndex() + 1;
 214     }
 215     ASSERT_NOT_REACHED();
 216     return 0;
 217 }
 218 
 219 int Position::offsetForPositionAfterAnchor() const
 220 {
 221     ASSERT(m_anchorType == PositionIsAfterAnchor || m_anchorType == PositionIsAfterChildren);
 222     ASSERT(!m_isLegacyEditingPosition);
 223     ASSERT(m_anchorNode);
 224     return m_anchorNode ? lastOffsetForEditing(*m_anchorNode) : 0;
 225 }
 226 
 227 // Neighbor-anchored positions are invalid DOM positions, so they need to be
 228 // fixed up before handing them off to the Range object.
 229 Position Position::parentAnchoredEquivalent() const
 230 {
 231     if (!m_anchorNode)
 232         return { };
 233 
 234     // FIXME: This should only be necessary for legacy positions, but is also needed for positions before and after Tables
 235     if (m_offset &lt;= 0 &amp;&amp; (m_anchorType != PositionIsAfterAnchor &amp;&amp; m_anchorType != PositionIsAfterChildren)) {
 236         if (m_anchorNode-&gt;parentNode() &amp;&amp; (editingIgnoresContent(*m_anchorNode) || isRenderedTable(m_anchorNode.get())))
 237             return positionInParentBeforeNode(m_anchorNode.get());
 238         return Position(m_anchorNode.get(), 0, PositionIsOffsetInAnchor);
 239     }
 240 
 241     if (!m_anchorNode-&gt;isCharacterDataNode()
 242         &amp;&amp; (m_anchorType == PositionIsAfterAnchor || m_anchorType == PositionIsAfterChildren || static_cast&lt;unsigned&gt;(m_offset) == m_anchorNode-&gt;countChildNodes())
 243         &amp;&amp; (editingIgnoresContent(*m_anchorNode) || isRenderedTable(m_anchorNode.get()))
 244         &amp;&amp; containerNode()) {
 245         return positionInParentAfterNode(m_anchorNode.get());
 246     }
 247 
 248     return { containerNode(), computeOffsetInContainerNode(), PositionIsOffsetInAnchor };
 249 }
 250 
 251 RefPtr&lt;Node&gt; Position::firstNode() const
 252 {
 253     auto container = makeRefPtr(containerNode());
 254     if (!container)
 255         return nullptr;
 256     if (is&lt;CharacterData&gt;(*container))
 257         return container;
 258     if (auto* node = computeNodeAfterPosition())
 259         return node;
 260     if (!computeOffsetInContainerNode())
 261         return container;
 262     return NodeTraversal::nextSkippingChildren(*container);
 263 }
 264 
 265 Node* Position::computeNodeBeforePosition() const
 266 {
 267     if (!m_anchorNode)
 268         return nullptr;
 269 
 270     switch (anchorType()) {
 271     case PositionIsBeforeChildren:
 272         return nullptr;
 273     case PositionIsAfterChildren:
 274         return m_anchorNode-&gt;lastChild();
 275     case PositionIsOffsetInAnchor:
 276         return m_offset ? m_anchorNode-&gt;traverseToChildAt(m_offset - 1) : nullptr;
 277     case PositionIsBeforeAnchor:
 278         return m_anchorNode-&gt;previousSibling();
 279     case PositionIsAfterAnchor:
 280         return m_anchorNode.get();
 281     }
 282     ASSERT_NOT_REACHED();
 283     return nullptr;
 284 }
 285 
 286 Node* Position::computeNodeAfterPosition() const
 287 {
 288     if (!m_anchorNode)
 289         return nullptr;
 290 
 291     switch (anchorType()) {
 292     case PositionIsBeforeChildren:
 293         return m_anchorNode-&gt;firstChild();
 294     case PositionIsAfterChildren:
 295         return nullptr;
 296     case PositionIsOffsetInAnchor:
 297         return m_anchorNode-&gt;traverseToChildAt(m_offset);
 298     case PositionIsBeforeAnchor:
 299         return m_anchorNode.get();
 300     case PositionIsAfterAnchor:
 301         return m_anchorNode-&gt;nextSibling();
 302     }
 303     ASSERT_NOT_REACHED();
 304     return nullptr;
 305 }
 306 
 307 Position::AnchorType Position::anchorTypeForLegacyEditingPosition(Node* anchorNode, int offset)
 308 {
 309     if (anchorNode &amp;&amp; editingIgnoresContent(*anchorNode)) {
 310         if (offset == 0)
 311             return Position::PositionIsBeforeAnchor;
 312         return Position::PositionIsAfterAnchor;
 313     }
 314     return Position::PositionIsOffsetInAnchor;
 315 }
 316 
 317 // FIXME: This method is confusing (does it return anchorNode() or containerNode()?) and should be renamed or removed
 318 Element* Position::element() const
 319 {
 320     Node* node = anchorNode();
 321     while (node &amp;&amp; !is&lt;Element&gt;(*node))
 322         node = node-&gt;parentNode();
 323     return downcast&lt;Element&gt;(node);
 324 }
 325 
 326 Position Position::previous(PositionMoveType moveType) const
 327 {
 328     Node* node = deprecatedNode();
 329     if (!node)
 330         return *this;
 331 
 332     int offset = deprecatedEditingOffset();
 333     // FIXME: Negative offsets shouldn&#39;t be allowed. We should catch this earlier.
 334     ASSERT(offset &gt;= 0);
 335 
 336     if (anchorType() == PositionIsBeforeAnchor) {
 337         node = containerNode();
 338         if (!node)
 339             return *this;
 340 
 341         offset = computeOffsetInContainerNode();
 342     }
 343 
 344     if (offset &gt; 0) {
 345         if (Node* child = node-&gt;traverseToChildAt(offset - 1))
 346             return lastPositionInOrAfterNode(child);
 347 
 348         // There are two reasons child might be 0:
 349         //   1) The node is node like a text node that is not an element, and therefore has no children.
 350         //      Going backward one character at a time is correct.
 351         //   2) The old offset was a bogus offset like (&lt;br&gt;, 1), and there is no child.
 352         //      Going from 1 to 0 is correct.
 353         switch (moveType) {
 354         case CodePoint:
 355             return createLegacyEditingPosition(node, offset - 1);
 356         case Character:
 357             return createLegacyEditingPosition(node, uncheckedPreviousOffset(node, offset));
 358         case BackwardDeletion:
 359             return createLegacyEditingPosition(node, uncheckedPreviousOffsetForBackwardDeletion(node, offset));
 360         }
 361     }
 362 
 363     ContainerNode* parent = node-&gt;parentNode();
 364     if (!parent)
 365         return *this;
 366 
 367     if (positionBeforeOrAfterNodeIsCandidate(*node))
 368         return positionBeforeNode(node);
 369 
 370     Node* previousSibling = node-&gt;previousSibling();
 371     if (previousSibling &amp;&amp; positionBeforeOrAfterNodeIsCandidate(*previousSibling))
 372         return positionAfterNode(previousSibling);
 373 
 374     return createLegacyEditingPosition(parent, node-&gt;computeNodeIndex());
 375 }
 376 
 377 Position Position::next(PositionMoveType moveType) const
 378 {
 379     ASSERT(moveType != BackwardDeletion);
 380 
 381     Node* node = deprecatedNode();
 382     if (!node)
 383         return *this;
 384 
 385     int offset = deprecatedEditingOffset();
 386     // FIXME: Negative offsets shouldn&#39;t be allowed. We should catch this earlier.
 387     ASSERT(offset &gt;= 0);
 388 
 389     if (anchorType() == PositionIsAfterAnchor) {
 390         node = containerNode();
 391         if (!node)
 392             return *this;
 393 
 394         offset = computeOffsetInContainerNode();
 395     }
 396 
 397     Node* child = node-&gt;traverseToChildAt(offset);
 398     if (child || (!node-&gt;hasChildNodes() &amp;&amp; offset &lt; lastOffsetForEditing(*node))) {
 399         if (child)
 400             return firstPositionInOrBeforeNode(child);
 401 
 402         // There are two reasons child might be 0:
 403         //   1) The node is node like a text node that is not an element, and therefore has no children.
 404         //      Going forward one character at a time is correct.
 405         //   2) The new offset is a bogus offset like (&lt;br&gt;, 1), and there is no child.
 406         //      Going from 0 to 1 is correct.
 407         return createLegacyEditingPosition(node, (moveType == Character) ? uncheckedNextOffset(node, offset) : offset + 1);
 408     }
 409 
 410     ContainerNode* parent = node-&gt;parentNode();
 411     if (!parent)
 412         return *this;
 413 
 414     if (isRenderedTable(node) || editingIgnoresContent(*node))
 415         return positionAfterNode(node);
 416 
 417     Node* nextSibling = node-&gt;nextSibling();
 418     if (nextSibling &amp;&amp; positionBeforeOrAfterNodeIsCandidate(*nextSibling))
 419         return positionBeforeNode(nextSibling);
 420 
 421     return createLegacyEditingPosition(parent, node-&gt;computeNodeIndex() + 1);
 422 }
 423 
 424 int Position::uncheckedPreviousOffset(const Node* n, int current)
 425 {
 426     return n-&gt;renderer() ? n-&gt;renderer()-&gt;previousOffset(current) : current - 1;
 427 }
 428 
 429 int Position::uncheckedPreviousOffsetForBackwardDeletion(const Node* n, int current)
 430 {
 431     return n-&gt;renderer() ? n-&gt;renderer()-&gt;previousOffsetForBackwardDeletion(current) : current - 1;
 432 }
 433 
 434 int Position::uncheckedNextOffset(const Node* n, int current)
 435 {
 436     return n-&gt;renderer() ? n-&gt;renderer()-&gt;nextOffset(current) : current + 1;
 437 }
 438 
 439 bool Position::atFirstEditingPositionForNode() const
 440 {
 441     if (isNull())
 442         return true;
 443     // FIXME: Position before anchor shouldn&#39;t be considered as at the first editing position for node
 444     // since that position resides outside of the node.
 445     switch (m_anchorType) {
 446     case PositionIsOffsetInAnchor:
 447         return m_offset &lt;= 0;
 448     case PositionIsBeforeChildren:
 449     case PositionIsBeforeAnchor:
 450         return true;
 451     case PositionIsAfterChildren:
 452     case PositionIsAfterAnchor:
 453         return !lastOffsetForEditing(*deprecatedNode());
 454     }
 455     ASSERT_NOT_REACHED();
 456     return false;
 457 }
 458 
 459 bool Position::atLastEditingPositionForNode() const
 460 {
 461     if (isNull())
 462         return true;
 463     // FIXME: Position after anchor shouldn&#39;t be considered as at the first editing position for node
 464     // since that position resides outside of the node.
 465     return m_anchorType == PositionIsAfterAnchor || m_anchorType == PositionIsAfterChildren || m_offset &gt;= lastOffsetForEditing(*deprecatedNode());
 466 }
 467 
 468 // A position is considered at editing boundary if one of the following is true:
 469 // 1. It is the first position in the node and the next visually equivalent position
 470 //    is non editable.
 471 // 2. It is the last position in the node and the previous visually equivalent position
 472 //    is non editable.
 473 // 3. It is an editable position and both the next and previous visually equivalent
 474 //    positions are both non editable.
 475 bool Position::atEditingBoundary() const
 476 {
 477     Position nextPosition = downstream(CanCrossEditingBoundary);
 478     if (atFirstEditingPositionForNode() &amp;&amp; nextPosition.isNotNull() &amp;&amp; !nextPosition.deprecatedNode()-&gt;hasEditableStyle())
 479         return true;
 480 
 481     Position prevPosition = upstream(CanCrossEditingBoundary);
 482     if (atLastEditingPositionForNode() &amp;&amp; prevPosition.isNotNull() &amp;&amp; !prevPosition.deprecatedNode()-&gt;hasEditableStyle())
 483         return true;
 484 
 485     return nextPosition.isNotNull() &amp;&amp; !nextPosition.deprecatedNode()-&gt;hasEditableStyle()
 486         &amp;&amp; prevPosition.isNotNull() &amp;&amp; !prevPosition.deprecatedNode()-&gt;hasEditableStyle();
 487 }
 488 
 489 Node* Position::parentEditingBoundary() const
 490 {
 491     if (!m_anchorNode)
 492         return nullptr;
 493 
 494     Node* documentElement = m_anchorNode-&gt;document().documentElement();
 495     if (!documentElement)
 496         return nullptr;
 497 
 498     Node* boundary = m_anchorNode.get();
 499     while (boundary != documentElement &amp;&amp; boundary-&gt;nonShadowBoundaryParentNode() &amp;&amp; m_anchorNode-&gt;hasEditableStyle() == boundary-&gt;parentNode()-&gt;hasEditableStyle())
 500         boundary = boundary-&gt;nonShadowBoundaryParentNode();
 501 
 502     return boundary;
 503 }
 504 
 505 
 506 bool Position::atStartOfTree() const
 507 {
 508     if (isNull())
 509         return true;
 510 
 511     Node* container = containerNode();
 512     if (container &amp;&amp; container-&gt;parentNode())
 513         return false;
 514 
 515     switch (m_anchorType) {
 516     case PositionIsOffsetInAnchor:
 517         return m_offset &lt;= 0;
 518     case PositionIsBeforeAnchor:
 519         return !m_anchorNode-&gt;previousSibling();
 520     case PositionIsAfterAnchor:
 521         return false;
 522     case PositionIsBeforeChildren:
 523         return true;
 524     case PositionIsAfterChildren:
 525         return !lastOffsetForEditing(*m_anchorNode);
 526     }
 527     ASSERT_NOT_REACHED();
 528     return false;
 529 }
 530 
 531 bool Position::atEndOfTree() const
 532 {
 533     if (isNull())
 534         return true;
 535 
 536     Node* container = containerNode();
 537     if (container &amp;&amp; container-&gt;parentNode())
 538         return false;
 539 
 540     switch (m_anchorType) {
 541     case PositionIsOffsetInAnchor:
 542         return m_offset &gt;= lastOffsetForEditing(*m_anchorNode);
 543     case PositionIsBeforeAnchor:
 544         return false;
 545     case PositionIsAfterAnchor:
 546         return !m_anchorNode-&gt;nextSibling();
 547     case PositionIsBeforeChildren:
 548         return !lastOffsetForEditing(*m_anchorNode);
 549     case PositionIsAfterChildren:
 550         return true;
 551     }
 552     ASSERT_NOT_REACHED();
 553     return false;
 554 }
 555 
 556 // return first preceding DOM position rendered at a different location, or &quot;this&quot;
 557 Position Position::previousCharacterPosition(EAffinity affinity) const
 558 {
 559     if (isNull())
 560         return { };
 561 
 562     Node* fromRootEditableElement = deprecatedNode()-&gt;rootEditableElement();
 563 
 564     bool atStartOfLine = isStartOfLine(VisiblePosition(*this, affinity));
 565     bool rendered = isCandidate();
 566 
 567     Position currentPosition = *this;
 568     while (!currentPosition.atStartOfTree()) {
 569         currentPosition = currentPosition.previous();
 570 
 571         if (currentPosition.deprecatedNode()-&gt;rootEditableElement() != fromRootEditableElement)
 572             return *this;
 573 
 574         if (atStartOfLine || !rendered) {
 575             if (currentPosition.isCandidate())
 576                 return currentPosition;
 577         } else if (rendersInDifferentPosition(currentPosition))
 578             return currentPosition;
 579     }
 580 
 581     return *this;
 582 }
 583 
 584 // return first following position rendered at a different location, or &quot;this&quot;
 585 Position Position::nextCharacterPosition(EAffinity affinity) const
 586 {
 587     if (isNull())
 588         return { };
 589 
 590     Node* fromRootEditableElement = deprecatedNode()-&gt;rootEditableElement();
 591 
 592     bool atEndOfLine = isEndOfLine({ *this, affinity });
 593     bool rendered = isCandidate();
 594 
 595     Position currentPosition = *this;
 596     while (!currentPosition.atEndOfTree()) {
 597         currentPosition = currentPosition.next();
 598 
 599         if (currentPosition.deprecatedNode()-&gt;rootEditableElement() != fromRootEditableElement)
 600             return *this;
 601 
 602         if (atEndOfLine || !rendered) {
 603             if (currentPosition.isCandidate())
 604                 return currentPosition;
 605         } else if (rendersInDifferentPosition(currentPosition))
 606             return currentPosition;
 607     }
 608 
 609     return *this;
 610 }
 611 
 612 // Whether or not [node, 0] and [node, lastOffsetForEditing(node)] are their own VisiblePositions.
 613 // If true, adjacent candidates are visually distinct.
 614 // FIXME: Disregard nodes with renderers that have no height, as we do in isCandidate.
 615 // FIXME: Share code with isCandidate, if possible.
 616 static bool endsOfNodeAreVisuallyDistinctPositions(Node* node)
 617 {
 618     if (!node || !node-&gt;renderer())
 619         return false;
 620 
 621     if (!node-&gt;renderer()-&gt;isInline())
 622         return true;
 623 
 624     // Don&#39;t include inline tables.
 625     if (is&lt;HTMLTableElement&gt;(*node))
 626         return false;
 627 
 628     if (!node-&gt;renderer()-&gt;isReplaced() || !canHaveChildrenForEditing(*node) || !downcast&lt;RenderBox&gt;(*node-&gt;renderer()).height())
 629         return false;
 630 
 631     // There is a VisiblePosition inside an empty inline-block container.
 632     if (!node-&gt;hasChildNodes())
 633         return true;
 634 
 635     return !Position::hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderElement&gt;(*node-&gt;renderer()));
 636 }
 637 
 638 static Node* enclosingVisualBoundary(Node* node)
 639 {
 640     while (node &amp;&amp; !endsOfNodeAreVisuallyDistinctPositions(node))
 641         node = node-&gt;parentNode();
 642 
 643     return node;
 644 }
 645 
 646 // upstream() and downstream() want to return positions that are either in a
 647 // text node or at just before a non-text node.  This method checks for that.
 648 static bool isStreamer(const PositionIterator&amp; pos)
 649 {
 650     if (!pos.node())
 651         return true;
 652 
 653     if (isAtomicNode(pos.node()))
 654         return true;
 655 
 656     return pos.atStartOfNode();
 657 }
 658 
<a name="3" id="anc3"></a>






 659 // This function and downstream() are used for moving back and forth between visually equivalent candidates.
 660 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 661 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the left candidate
 662 // and downstream() will return the right one.
 663 // Also, upstream() will return [boundary, 0] for any of the positions from [boundary, 0] to the first candidate
 664 // in boundary, where endsOfNodeAreVisuallyDistinctPositions(boundary) is true.
 665 Position Position::upstream(EditingBoundaryCrossingRule rule) const
 666 {
 667     Node* startNode = deprecatedNode();
 668     if (!startNode)
 669         return { };
 670 
 671     // iterate backward from there, looking for a qualified position
 672     Node* boundary = enclosingVisualBoundary(startNode);
 673     // FIXME: PositionIterator should respect Before and After positions.
 674     PositionIterator lastVisible = m_anchorType == PositionIsAfterAnchor ? createLegacyEditingPosition(m_anchorNode.get(), caretMaxOffset(*m_anchorNode)) : *this;
 675     PositionIterator currentPosition = lastVisible;
 676     bool startEditable = startNode-&gt;hasEditableStyle();
 677     Node* lastNode = startNode;
 678     bool boundaryCrossed = false;
 679     for (; !currentPosition.atStart(); currentPosition.decrement()) {
 680         auto&amp; currentNode = *currentPosition.node();
 681 
 682         // Don&#39;t check for an editability change if we haven&#39;t moved to a different node,
 683         // to avoid the expense of computing hasEditableStyle().
 684         if (&amp;currentNode != lastNode) {
 685             // Don&#39;t change editability.
 686             bool currentEditable = currentNode.hasEditableStyle();
 687             if (startEditable != currentEditable) {
 688                 if (rule == CannotCrossEditingBoundary)
 689                     break;
 690                 boundaryCrossed = true;
 691             }
 692             lastNode = &amp;currentNode;
 693         }
 694 
 695         // If we&#39;ve moved to a position that is visually distinct, return the last saved position. There
 696         // is code below that terminates early if we&#39;re *about* to move to a visually distinct position.
 697         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 698             return lastVisible;
 699 
 700         // skip position in unrendered or invisible node
 701         RenderObject* renderer = currentNode.renderer();
 702         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 703             continue;
<a name="4" id="anc4"></a><span class="line-modified"> 704 </span>
 705         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 706             lastVisible = currentPosition;
 707             break;
 708         }
 709 
 710         // track last visible streamer position
 711         if (isStreamer(currentPosition))
 712             lastVisible = currentPosition;
 713 
 714         // Don&#39;t move past a position that is visually distinct.  We could rely on code above to terminate and
 715         // return lastVisible on the next iteration, but we terminate early to avoid doing a computeNodeIndex() call.
 716         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; currentPosition.atStartOfNode())
 717             return lastVisible;
 718 
 719         // Return position after tables and nodes which have content that can be ignored.
 720         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 721             if (currentPosition.atEndOfNode())
 722                 return positionAfterNode(&amp;currentNode);
 723             continue;
 724         }
 725 
 726         // return current position if it is in rendered text
 727         if (is&lt;RenderText&gt;(*renderer)) {
 728             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
<a name="5" id="anc5"></a><span class="line-modified"> 729 </span>
<span class="line-added"> 730             auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(textRenderer);</span>
<span class="line-added"> 731             if (!firstTextBox)</span>
 732                 continue;
<a name="6" id="anc6"></a><span class="line-added"> 733 </span>
 734             if (&amp;currentNode != startNode) {
 735                 // This assertion fires in layout tests in the case-transform.html test because
 736                 // of a mix-up between offsets in the text in the DOM tree with text in the
 737                 // render tree which can have a different length due to case transformation.
 738                 // Until we resolve that, disable this so we can run the layout tests!
 739                 //ASSERT(currentOffset &gt;= renderer-&gt;caretMaxOffset());
 740                 return createLegacyEditingPosition(&amp;currentNode, renderer-&gt;caretMaxOffset());
 741             }
 742 
 743             unsigned textOffset = currentPosition.offsetInLeafNode();
<a name="7" id="anc7"></a><span class="line-modified"> 744             for (auto box = firstTextBox; box; box.traverseNextInTextOrder()) {</span>
<span class="line-modified"> 745                 if (textOffset &lt;= box-&gt;localEndOffset()) {</span>
<span class="line-modified"> 746                     if (textOffset &gt; box-&gt;localStartOffset())</span>

 747                         return currentPosition;
 748                     continue;
 749                 }
 750 
<a name="8" id="anc8"></a><span class="line-modified"> 751                 if (textOffset == box-&gt;localEndOffset() + 1 &amp;&amp; box-&gt;isLastOnLine() &amp;&amp; !box-&gt;isLast())</span>

























 752                     return currentPosition;
 753             }
 754         }
 755     }
 756 
 757     return lastVisible;
 758 }
 759 
 760 // This function and upstream() are used for moving back and forth between visually equivalent candidates.
 761 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 762 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the right candidate
 763 // and upstream() will return the left one.
 764 // Also, downstream() will return the last position in the last atomic node in boundary for all of the positions
 765 // in boundary after the last candidate, where endsOfNodeAreVisuallyDistinctPositions(boundary).
 766 // FIXME: This function should never be called when the line box tree is dirty. See https://bugs.webkit.org/show_bug.cgi?id=97264
 767 Position Position::downstream(EditingBoundaryCrossingRule rule) const
 768 {
 769     Node* startNode = deprecatedNode();
 770     if (!startNode)
 771         return { };
 772 
 773     // iterate forward from there, looking for a qualified position
 774     Node* boundary = enclosingVisualBoundary(startNode);
 775     // FIXME: PositionIterator should respect Before and After positions.
 776     PositionIterator lastVisible = m_anchorType == PositionIsAfterAnchor ? createLegacyEditingPosition(m_anchorNode.get(), caretMaxOffset(*m_anchorNode)) : *this;
 777     PositionIterator currentPosition = lastVisible;
 778     bool startEditable = startNode-&gt;hasEditableStyle();
 779     Node* lastNode = startNode;
 780     bool boundaryCrossed = false;
 781     for (; !currentPosition.atEnd(); currentPosition.increment()) {
 782         auto&amp; currentNode = *currentPosition.node();
 783 
 784         // Don&#39;t check for an editability change if we haven&#39;t moved to a different node,
 785         // to avoid the expense of computing hasEditableStyle().
 786         if (&amp;currentNode != lastNode) {
 787             // Don&#39;t change editability.
 788             bool currentEditable = currentNode.hasEditableStyle();
 789             if (startEditable != currentEditable) {
 790                 if (rule == CannotCrossEditingBoundary)
 791                     break;
 792                 boundaryCrossed = true;
 793             }
 794 
 795             lastNode = &amp;currentNode;
 796         }
 797 
 798         // stop before going above the body, up into the head
 799         // return the last visible streamer position
 800         if (is&lt;HTMLBodyElement&gt;(currentNode) &amp;&amp; currentPosition.atEndOfNode())
 801             break;
 802 
 803         // Do not move to a visually distinct position.
 804         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 805             return lastVisible;
 806         // Do not move past a visually disinct position.
 807         // Note: The first position after the last in a node whose ends are visually distinct
 808         // positions will be [boundary-&gt;parentNode(), originalBlock-&gt;computeNodeIndex() + 1].
 809         if (boundary &amp;&amp; boundary-&gt;parentNode() == &amp;currentNode)
 810             return lastVisible;
 811 
 812         // skip position in unrendered or invisible node
 813         auto* renderer = currentNode.renderer();
 814         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 815             continue;
<a name="9" id="anc9"></a><span class="line-modified"> 816 </span>
 817         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 818             lastVisible = currentPosition;
 819             break;
 820         }
 821 
 822         // track last visible streamer position
 823         if (isStreamer(currentPosition))
 824             lastVisible = currentPosition;
 825 
 826         // Return position before tables and nodes which have content that can be ignored.
 827         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 828             if (currentPosition.atStartOfNode())
 829                 return positionBeforeNode(&amp;currentNode);
 830             continue;
 831         }
 832 
 833         // return current position if it is in rendered text
 834         if (is&lt;RenderText&gt;(*renderer)) {
 835             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
<a name="10" id="anc10"></a><span class="line-modified"> 836 </span>
<span class="line-added"> 837             auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(textRenderer);</span>
<span class="line-added"> 838             if (!firstTextBox)</span>
 839                 continue;
<a name="11" id="anc11"></a><span class="line-added"> 840 </span>
 841             if (&amp;currentNode != startNode) {
 842                 ASSERT(currentPosition.atStartOfNode());
<a name="12" id="anc12"></a><span class="line-modified"> 843                 return createLegacyEditingPosition(&amp;currentNode, textRenderer.caretMinOffset());</span>
 844             }
 845 
 846             unsigned textOffset = currentPosition.offsetInLeafNode();
<a name="13" id="anc13"></a><span class="line-modified"> 847             for (auto box = firstTextBox; box; box.traverseNextInTextOrder()) {</span>
<span class="line-modified"> 848                 if (!box-&gt;length() &amp;&amp; textOffset == box-&gt;localStartOffset())</span>
<span class="line-modified"> 849                     return currentPosition;</span>




 850 
<a name="14" id="anc14"></a><span class="line-modified"> 851                 if (textOffset &lt; box-&gt;localEndOffset()) {</span>
<span class="line-added"> 852                     if (textOffset &gt;= box-&gt;localStartOffset())</span>
<span class="line-added"> 853                         return currentPosition;</span>
 854                     continue;
<a name="15" id="anc15"></a>




















 855                 }
 856 
<a name="16" id="anc16"></a><span class="line-modified"> 857                 if (textOffset == box-&gt;localEndOffset() &amp;&amp; box-&gt;isLastOnLine() &amp;&amp; !box-&gt;isLast())</span>
 858                     return currentPosition;
 859             }
 860         }
 861     }
 862 
 863     return lastVisible;
 864 }
 865 
 866 unsigned Position::positionCountBetweenPositions(const Position&amp; a, const Position&amp; b)
 867 {
 868     if (a.isNull() || b.isNull())
 869         return UINT_MAX;
 870 
 871     Position endPos;
 872     Position pos;
 873     if (a &gt; b) {
 874         endPos = a;
 875         pos = b;
 876     } else if (a &lt; b) {
 877         endPos = b;
 878         pos = a;
 879     } else
 880         return 0;
 881 
 882     unsigned posCount = 0;
 883     while (!pos.atEndOfTree() &amp;&amp; pos != endPos) {
 884         pos = pos.next();
 885         ++posCount;
 886     }
 887     return posCount;
 888 }
 889 
 890 static int boundingBoxLogicalHeight(RenderObject *o, const IntRect &amp;rect)
 891 {
 892     return o-&gt;style().isHorizontalWritingMode() ? rect.height() : rect.width();
 893 }
 894 
 895 bool Position::hasRenderedNonAnonymousDescendantsWithHeight(const RenderElement&amp; renderer)
 896 {
 897     RenderObject* stop = renderer.nextInPreOrderAfterChildren();
 898     for (RenderObject* o = renderer.firstChild(); o &amp;&amp; o != stop; o = o-&gt;nextInPreOrder()) {
 899         if (!o-&gt;nonPseudoNode())
 900             continue;
 901         if (is&lt;RenderText&gt;(*o)) {
 902             if (boundingBoxLogicalHeight(o, downcast&lt;RenderText&gt;(*o).linesBoundingBox()))
 903                 return true;
 904             continue;
 905         }
 906         if (is&lt;RenderLineBreak&gt;(*o)) {
 907             if (boundingBoxLogicalHeight(o, downcast&lt;RenderLineBreak&gt;(*o).linesBoundingBox()))
 908                 return true;
 909             continue;
 910         }
 911         if (is&lt;RenderBox&gt;(*o)) {
 912             if (roundToInt(downcast&lt;RenderBox&gt;(*o).logicalHeight()))
 913                 return true;
 914             continue;
 915         }
 916         if (is&lt;RenderInline&gt;(*o)) {
 917             const RenderInline&amp; renderInline = downcast&lt;RenderInline&gt;(*o);
 918             if (isEmptyInline(renderInline) &amp;&amp; boundingBoxLogicalHeight(o, renderInline.linesBoundingBox()))
 919                 return true;
 920             continue;
 921         }
 922     }
 923     return false;
 924 }
 925 
 926 bool Position::nodeIsUserSelectNone(Node* node)
 927 {
 928     return node &amp;&amp; node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;style().userSelect() == UserSelect::None;
 929 }
 930 
 931 #if ENABLE(USERSELECT_ALL)
 932 bool Position::nodeIsUserSelectAll(const Node* node)
 933 {
 934     return node &amp;&amp; node-&gt;renderer() &amp;&amp; node-&gt;renderer()-&gt;style().userSelect() == UserSelect::All;
 935 }
 936 
 937 Node* Position::rootUserSelectAllForNode(Node* node)
 938 {
 939     if (!node || !nodeIsUserSelectAll(node))
 940         return nullptr;
 941     Node* parent = node-&gt;parentNode();
 942     if (!parent)
 943         return node;
 944 
 945     Node* candidateRoot = node;
 946     while (parent) {
 947         if (!parent-&gt;renderer()) {
 948             parent = parent-&gt;parentNode();
 949             continue;
 950         }
 951         if (!nodeIsUserSelectAll(parent))
 952             break;
 953         candidateRoot = parent;
 954         parent = candidateRoot-&gt;parentNode();
 955     }
 956     return candidateRoot;
 957 }
 958 #endif
 959 
 960 bool Position::isCandidate() const
 961 {
 962     if (isNull())
 963         return false;
 964 
 965     auto* renderer = deprecatedNode()-&gt;renderer();
 966     if (!renderer)
 967         return false;
 968 
 969     if (renderer-&gt;style().visibility() != Visibility::Visible)
 970         return false;
 971 
 972     if (renderer-&gt;isBR()) {
 973         // FIXME: The condition should be m_anchorType == PositionIsBeforeAnchor, but for now we still need to support legacy positions.
 974         return !m_offset &amp;&amp; m_anchorType != PositionIsAfterAnchor &amp;&amp; !nodeIsUserSelectNone(deprecatedNode()-&gt;parentNode());
 975     }
 976 
 977     if (is&lt;RenderText&gt;(*renderer))
 978         return !nodeIsUserSelectNone(deprecatedNode()) &amp;&amp; downcast&lt;RenderText&gt;(*renderer).containsCaretOffset(m_offset);
 979 
 980     if (positionBeforeOrAfterNodeIsCandidate(*deprecatedNode())) {
 981         return ((atFirstEditingPositionForNode() &amp;&amp; m_anchorType == PositionIsBeforeAnchor)
 982             || (atLastEditingPositionForNode() &amp;&amp; m_anchorType == PositionIsAfterAnchor))
 983             &amp;&amp; !nodeIsUserSelectNone(deprecatedNode()-&gt;parentNode());
 984     }
 985 
 986     if (is&lt;HTMLHtmlElement&gt;(*m_anchorNode))
 987         return false;
 988 
 989     if (is&lt;RenderBlockFlow&gt;(*renderer) || is&lt;RenderGrid&gt;(*renderer) || is&lt;RenderFlexibleBox&gt;(*renderer)) {
 990         RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(*renderer);
 991         if (block.logicalHeight() || is&lt;HTMLBodyElement&gt;(*m_anchorNode) || m_anchorNode-&gt;isRootEditableElement()) {
 992             if (!Position::hasRenderedNonAnonymousDescendantsWithHeight(block))
 993                 return atFirstEditingPositionForNode() &amp;&amp; !Position::nodeIsUserSelectNone(deprecatedNode());
 994             return m_anchorNode-&gt;hasEditableStyle() &amp;&amp; !Position::nodeIsUserSelectNone(deprecatedNode()) &amp;&amp; atEditingBoundary();
 995         }
 996         return false;
 997     }
 998 
 999     return m_anchorNode-&gt;hasEditableStyle() &amp;&amp; !Position::nodeIsUserSelectNone(deprecatedNode()) &amp;&amp; atEditingBoundary();
1000 }
1001 
1002 bool Position::isRenderedCharacter() const
1003 {
1004     if (!is&lt;Text&gt;(deprecatedNode()))
1005         return false;
1006 
1007     RenderText* renderer = downcast&lt;Text&gt;(*deprecatedNode()).renderer();
1008     if (!renderer)
1009         return false;
1010 
1011     return renderer-&gt;containsRenderedCharacterOffset(m_offset);
1012 }
1013 
1014 static bool inSameEnclosingBlockFlowElement(Node* a, Node* b)
1015 {
1016     return a &amp;&amp; b &amp;&amp; deprecatedEnclosingBlockFlowElement(a) == deprecatedEnclosingBlockFlowElement(b);
1017 }
1018 
1019 bool Position::rendersInDifferentPosition(const Position&amp; position) const
1020 {
1021     if (isNull() || position.isNull())
1022         return false;
1023 
1024     auto* renderer = deprecatedNode()-&gt;renderer();
1025     if (!renderer)
1026         return false;
1027 
1028     auto* positionRenderer = position.deprecatedNode()-&gt;renderer();
1029     if (!positionRenderer)
1030         return false;
1031 
1032     if (renderer-&gt;style().visibility() != Visibility::Visible || positionRenderer-&gt;style().visibility() != Visibility::Visible)
1033         return false;
1034 
1035     if (deprecatedNode() == position.deprecatedNode()) {
1036         if (is&lt;HTMLBRElement&gt;(*deprecatedNode()))
1037             return false;
1038 
1039         if (m_offset == position.deprecatedEditingOffset())
1040             return false;
1041 
1042         if (!is&lt;Text&gt;(*deprecatedNode()) &amp;&amp; !is&lt;Text&gt;(*position.deprecatedNode())) {
1043             if (m_offset != position.deprecatedEditingOffset())
1044                 return true;
1045         }
1046     }
1047 
1048     if (is&lt;HTMLBRElement&gt;(*deprecatedNode()) &amp;&amp; position.isCandidate())
1049         return true;
1050 
1051     if (is&lt;HTMLBRElement&gt;(*position.deprecatedNode()) &amp;&amp; isCandidate())
1052         return true;
1053 
1054     if (!inSameEnclosingBlockFlowElement(deprecatedNode(), position.deprecatedNode()))
1055         return true;
1056 
1057     if (is&lt;RenderText&gt;(*renderer) &amp;&amp; !downcast&lt;RenderText&gt;(*renderer).containsCaretOffset(m_offset))
1058         return false;
1059 
1060     if (is&lt;RenderText&gt;(*positionRenderer) &amp;&amp; !downcast&lt;RenderText&gt;(*positionRenderer).containsCaretOffset(position.m_offset))
1061         return false;
1062 
1063     int thisRenderedOffset = is&lt;RenderText&gt;(*renderer) ? downcast&lt;RenderText&gt;(*renderer).countRenderedCharacterOffsetsUntil(m_offset) : m_offset;
1064     int positionRenderedOffset = is&lt;RenderText&gt;(*positionRenderer) ? downcast&lt;RenderText&gt;(*positionRenderer).countRenderedCharacterOffsetsUntil(position.m_offset) : position.m_offset;
1065 
1066     if (renderer == positionRenderer &amp;&amp; thisRenderedOffset == positionRenderedOffset)
1067         return false;
1068 
1069     int ignoredCaretOffset;
1070     InlineBox* b1;
1071     getInlineBoxAndOffset(DOWNSTREAM, b1, ignoredCaretOffset);
1072     InlineBox* b2;
1073     position.getInlineBoxAndOffset(DOWNSTREAM, b2, ignoredCaretOffset);
1074 
1075     LOG(Editing, &quot;renderer:               %p [%p]\n&quot;, renderer, b1);
1076     LOG(Editing, &quot;thisRenderedOffset:         %d\n&quot;, thisRenderedOffset);
1077     LOG(Editing, &quot;posRenderer:            %p [%p]\n&quot;, positionRenderer, b2);
1078     LOG(Editing, &quot;posRenderedOffset:      %d\n&quot;, positionRenderedOffset);
1079     LOG(Editing, &quot;node min/max:           %d:%d\n&quot;, caretMinOffset(*deprecatedNode()), caretMaxOffset(*deprecatedNode()));
1080     LOG(Editing, &quot;pos node min/max:       %d:%d\n&quot;, caretMinOffset(*position.deprecatedNode()), caretMaxOffset(*position.deprecatedNode()));
1081     LOG(Editing, &quot;----------------------------------------------------------------------\n&quot;);
1082 
1083     if (!b1 || !b2) {
1084         return false;
1085     }
1086 
1087     if (&amp;b1-&gt;root() != &amp;b2-&gt;root()) {
1088         return true;
1089     }
1090 
1091     if (nextRenderedEditable(deprecatedNode()) == position.deprecatedNode()
1092         &amp;&amp; thisRenderedOffset == caretMaxOffset(*deprecatedNode()) &amp;&amp; !positionRenderedOffset) {
1093         return false;
1094     }
1095 
1096     if (previousRenderedEditable(deprecatedNode()) == position.deprecatedNode()
1097         &amp;&amp; !thisRenderedOffset &amp;&amp; positionRenderedOffset == caretMaxOffset(*position.deprecatedNode())) {
1098         return false;
1099     }
1100 
1101     return true;
1102 }
1103 
1104 // This assumes that it starts in editable content.
1105 Position Position::leadingWhitespacePosition(EAffinity affinity, bool considerNonCollapsibleWhitespace) const
1106 {
1107     ASSERT(isEditablePosition(*this));
1108     if (isNull())
1109         return { };
1110 
1111     if (is&lt;HTMLBRElement&gt;(*upstream().deprecatedNode()))
1112         return { };
1113 
1114     Position prev = previousCharacterPosition(affinity);
1115     if (prev != *this &amp;&amp; inSameEnclosingBlockFlowElement(deprecatedNode(), prev.deprecatedNode()) &amp;&amp; is&lt;Text&gt;(*prev.deprecatedNode())) {
1116         UChar c = downcast&lt;Text&gt;(*prev.deprecatedNode()).data()[prev.deprecatedEditingOffset()];
1117         if (considerNonCollapsibleWhitespace ? (isHTMLSpace(c) || c == noBreakSpace) : deprecatedIsCollapsibleWhitespace(c)) {
1118             if (isEditablePosition(prev))
1119                 return prev;
1120         }
1121     }
1122 
1123     return { };
1124 }
1125 
1126 // This assumes that it starts in editable content.
1127 Position Position::trailingWhitespacePosition(EAffinity, bool considerNonCollapsibleWhitespace) const
1128 {
1129     ASSERT(isEditablePosition(*this));
1130     if (isNull())
1131         return { };
1132 
1133     VisiblePosition v(*this);
1134     UChar c = v.characterAfter();
1135     // The space must not be in another paragraph and it must be editable.
1136     if (!isEndOfParagraph(v) &amp;&amp; v.next(CannotCrossEditingBoundary).isNotNull())
1137         if (considerNonCollapsibleWhitespace ? (isHTMLSpace(c) || c == noBreakSpace) : deprecatedIsCollapsibleWhitespace(c))
1138             return *this;
1139 
1140     return { };
1141 }
1142 
1143 void Position::getInlineBoxAndOffset(EAffinity affinity, InlineBox*&amp; inlineBox, int&amp; caretOffset) const
1144 {
1145     getInlineBoxAndOffset(affinity, primaryDirection(), inlineBox, caretOffset);
1146 }
1147 
1148 static bool isNonTextLeafChild(RenderObject&amp; object)
1149 {
1150     if (is&lt;RenderText&gt;(object))
1151         return false;
1152     return !downcast&lt;RenderElement&gt;(object).firstChild();
1153 }
1154 
1155 static InlineTextBox* searchAheadForBetterMatch(RenderObject* renderer)
1156 {
1157     RenderBlock* container = renderer-&gt;containingBlock();
1158     RenderObject* next = renderer;
1159     while ((next = next-&gt;nextInPreOrder(container))) {
1160         if (is&lt;RenderBlock&gt;(*next))
1161             return nullptr;
1162         if (next-&gt;isBR())
1163             return nullptr;
1164         if (isNonTextLeafChild(*next))
1165             return nullptr;
1166         if (is&lt;RenderText&gt;(*next)) {
1167             InlineTextBox* match = nullptr;
1168             int minOffset = INT_MAX;
1169             for (InlineTextBox* box = downcast&lt;RenderText&gt;(*next).firstTextBox(); box; box = box-&gt;nextTextBox()) {
1170                 int caretMinOffset = box-&gt;caretMinOffset();
1171                 if (caretMinOffset &lt; minOffset) {
1172                     match = box;
1173                     minOffset = caretMinOffset;
1174                 }
1175             }
1176             if (match)
1177                 return match;
1178         }
1179     }
1180     return nullptr;
1181 }
1182 
1183 static Position downstreamIgnoringEditingBoundaries(Position position)
1184 {
1185     Position lastPosition;
1186     while (position != lastPosition) {
1187         lastPosition = position;
1188         position = position.downstream(CanCrossEditingBoundary);
1189     }
1190     return position;
1191 }
1192 
1193 static Position upstreamIgnoringEditingBoundaries(Position position)
1194 {
1195     Position lastPosition;
1196     while (position != lastPosition) {
1197         lastPosition = position;
1198         position = position.upstream(CanCrossEditingBoundary);
1199     }
1200     return position;
1201 }
1202 
1203 void Position::getInlineBoxAndOffset(EAffinity affinity, TextDirection primaryDirection, InlineBox*&amp; inlineBox, int&amp; caretOffset) const
1204 {
1205     caretOffset = deprecatedEditingOffset();
1206     RenderObject* renderer = deprecatedNode()-&gt;renderer();
1207 
1208     if (renderer-&gt;isBR()) {
1209         auto&amp; lineBreakRenderer = downcast&lt;RenderLineBreak&gt;(*renderer);
1210         lineBreakRenderer.ensureLineBoxes();
1211         inlineBox = !caretOffset ? lineBreakRenderer.inlineBoxWrapper() : nullptr;
1212     } else if (is&lt;RenderText&gt;(*renderer)) {
1213         auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
1214         textRenderer.ensureLineBoxes();
1215 
1216         InlineTextBox* box;
1217         InlineTextBox* candidate = nullptr;
1218 
1219         for (box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {
1220             int caretMinOffset = box-&gt;caretMinOffset();
1221             int caretMaxOffset = box-&gt;caretMaxOffset();
1222 
1223             if (caretOffset &lt; caretMinOffset || caretOffset &gt; caretMaxOffset || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;isLineBreak()))
1224                 continue;
1225 
1226             if (caretOffset &gt; caretMinOffset &amp;&amp; caretOffset &lt; caretMaxOffset) {
1227                 inlineBox = box;
1228                 return;
1229             }
1230 
1231             if (((caretOffset == caretMaxOffset) ^ (affinity == DOWNSTREAM))
1232                 || ((caretOffset == caretMinOffset) ^ (affinity == UPSTREAM))
<a name="17" id="anc17"></a><span class="line-modified">1233                 || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;nextLeafOnLine() &amp;&amp; box-&gt;nextLeafOnLine()-&gt;isLineBreak()))</span>
1234                 break;
1235 
1236             candidate = box;
1237         }
1238         if (candidate &amp;&amp; candidate == textRenderer.lastTextBox() &amp;&amp; affinity == DOWNSTREAM) {
1239             box = searchAheadForBetterMatch(&amp;textRenderer);
1240             if (box)
1241                 caretOffset = box-&gt;caretMinOffset();
1242         }
1243         inlineBox = box ? box : candidate;
1244     } else {
1245         inlineBox = nullptr;
1246         if (canHaveChildrenForEditing(*deprecatedNode()) &amp;&amp; is&lt;RenderBlockFlow&gt;(*renderer) &amp;&amp; hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderBlockFlow&gt;(*renderer))) {
1247             // Try a visually equivalent position with possibly opposite editability. This helps in case |this| is in
1248             // an editable block but surrounded by non-editable positions. It acts to negate the logic at the beginning
1249             // of RenderObject::createVisiblePosition().
1250             Position equivalent = downstreamIgnoringEditingBoundaries(*this);
1251             if (equivalent == *this) {
1252                 equivalent = upstreamIgnoringEditingBoundaries(*this);
1253                 if (equivalent == *this || downstreamIgnoringEditingBoundaries(equivalent) == *this)
1254                     return;
1255             }
1256 
1257             equivalent.getInlineBoxAndOffset(UPSTREAM, primaryDirection, inlineBox, caretOffset);
1258             return;
1259         }
1260         if (is&lt;RenderBox&gt;(*renderer)) {
1261             inlineBox = downcast&lt;RenderBox&gt;(*renderer).inlineBoxWrapper();
1262             if (!inlineBox || (caretOffset &gt; inlineBox-&gt;caretMinOffset() &amp;&amp; caretOffset &lt; inlineBox-&gt;caretMaxOffset()))
1263                 return;
1264         }
1265     }
1266 
1267     if (!inlineBox)
1268         return;
1269 
1270     unsigned char level = inlineBox-&gt;bidiLevel();
1271 
1272     if (inlineBox-&gt;direction() == primaryDirection) {
1273         if (caretOffset == inlineBox-&gt;caretRightmostOffset()) {
<a name="18" id="anc18"></a><span class="line-modified">1274             InlineBox* nextBox = inlineBox-&gt;nextLeafOnLine();</span>
1275             if (!nextBox || nextBox-&gt;bidiLevel() &gt;= level)
1276                 return;
1277 
1278             level = nextBox-&gt;bidiLevel();
1279             InlineBox* prevBox = inlineBox;
1280             do {
<a name="19" id="anc19"></a><span class="line-modified">1281                 prevBox = prevBox-&gt;previousLeafOnLine();</span>
1282             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
1283 
1284             if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() == level)   // For example, abc FED 123 ^ CBA
1285                 return;
1286 
1287             // For example, abc 123 ^ CBA
<a name="20" id="anc20"></a><span class="line-modified">1288             while (InlineBox* nextBox = inlineBox-&gt;nextLeafOnLine()) {</span>
1289                 if (nextBox-&gt;bidiLevel() &lt; level)
1290                     break;
1291                 inlineBox = nextBox;
1292             }
1293             caretOffset = inlineBox-&gt;caretRightmostOffset();
1294         } else {
<a name="21" id="anc21"></a><span class="line-modified">1295             InlineBox* prevBox = inlineBox-&gt;previousLeafOnLine();</span>
1296             if (!prevBox || prevBox-&gt;bidiLevel() &gt;= level)
1297                 return;
1298 
1299             level = prevBox-&gt;bidiLevel();
1300             InlineBox* nextBox = inlineBox;
1301             do {
<a name="22" id="anc22"></a><span class="line-modified">1302                 nextBox = nextBox-&gt;nextLeafOnLine();</span>
1303             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
1304 
1305             if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() == level)
1306                 return;
1307 
<a name="23" id="anc23"></a><span class="line-modified">1308             while (InlineBox* prevBox = inlineBox-&gt;previousLeafOnLine()) {</span>
1309                 if (prevBox-&gt;bidiLevel() &lt; level)
1310                     break;
1311                 inlineBox = prevBox;
1312             }
1313             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1314         }
1315         return;
1316     }
1317 
1318     if (caretOffset == inlineBox-&gt;caretLeftmostOffset()) {
<a name="24" id="anc24"></a><span class="line-modified">1319         InlineBox* prevBox = inlineBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
1320         if (!prevBox || prevBox-&gt;bidiLevel() &lt; level) {
1321             // Left edge of a secondary run. Set to the right edge of the entire run.
<a name="25" id="anc25"></a><span class="line-modified">1322             while (InlineBox* nextBox = inlineBox-&gt;nextLeafOnLineIgnoringLineBreak()) {</span>
1323                 if (nextBox-&gt;bidiLevel() &lt; level)
1324                     break;
1325                 inlineBox = nextBox;
1326             }
1327             caretOffset = inlineBox-&gt;caretRightmostOffset();
1328         } else if (prevBox-&gt;bidiLevel() &gt; level) {
1329             // Right edge of a &quot;tertiary&quot; run. Set to the left edge of that run.
<a name="26" id="anc26"></a><span class="line-modified">1330             while (InlineBox* tertiaryBox = inlineBox-&gt;previousLeafOnLineIgnoringLineBreak()) {</span>
1331                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1332                     break;
1333                 inlineBox = tertiaryBox;
1334             }
1335             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1336         }
1337     } else {
<a name="27" id="anc27"></a><span class="line-modified">1338         InlineBox* nextBox = inlineBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
1339         if (!nextBox || nextBox-&gt;bidiLevel() &lt; level) {
1340             // Right edge of a secondary run. Set to the left edge of the entire run.
<a name="28" id="anc28"></a><span class="line-modified">1341             while (InlineBox* prevBox = inlineBox-&gt;previousLeafOnLineIgnoringLineBreak()) {</span>
1342                 if (prevBox-&gt;bidiLevel() &lt; level)
1343                     break;
1344                 inlineBox = prevBox;
1345             }
1346             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1347         } else if (nextBox-&gt;bidiLevel() &gt; level) {
1348             // Left edge of a &quot;tertiary&quot; run. Set to the right edge of that run.
<a name="29" id="anc29"></a><span class="line-modified">1349             while (InlineBox* tertiaryBox = inlineBox-&gt;nextLeafOnLineIgnoringLineBreak()) {</span>
1350                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1351                     break;
1352                 inlineBox = tertiaryBox;
1353             }
1354             caretOffset = inlineBox-&gt;caretRightmostOffset();
1355         }
1356     }
1357 }
1358 
1359 TextDirection Position::primaryDirection() const
1360 {
1361     if (!m_anchorNode-&gt;renderer())
1362         return TextDirection::LTR;
1363     if (auto* blockFlow = lineageOfType&lt;RenderBlockFlow&gt;(*m_anchorNode-&gt;renderer()).first())
1364         return blockFlow-&gt;style().direction();
1365     return TextDirection::LTR;
1366 }
1367 
1368 #if ENABLE(TREE_DEBUGGING)
1369 
1370 void Position::debugPosition(const char* msg) const
1371 {
1372     if (isNull())
1373         fprintf(stderr, &quot;Position [%s]: null\n&quot;, msg);
1374     else
1375         fprintf(stderr, &quot;Position [%s]: %s [%p] at %d\n&quot;, msg, deprecatedNode()-&gt;nodeName().utf8().data(), deprecatedNode(), m_offset);
1376 }
1377 
1378 void Position::formatForDebugger(char* buffer, unsigned length) const
1379 {
1380     StringBuilder result;
1381 
1382     if (isNull())
1383         result.appendLiteral(&quot;&lt;null&gt;&quot;);
1384     else {
1385         char s[1024];
1386         result.appendLiteral(&quot;offset &quot;);
1387         result.appendNumber(m_offset);
1388         result.appendLiteral(&quot; of &quot;);
1389         deprecatedNode()-&gt;formatForDebugger(s, sizeof(s));
1390         result.append(s);
1391     }
1392 
1393     strncpy(buffer, result.toString().utf8().data(), length - 1);
1394 }
1395 
1396 void Position::showAnchorTypeAndOffset() const
1397 {
1398     if (m_isLegacyEditingPosition)
1399         fputs(&quot;legacy, &quot;, stderr);
1400     switch (anchorType()) {
1401     case PositionIsOffsetInAnchor:
1402         fputs(&quot;offset&quot;, stderr);
1403         break;
1404     case PositionIsBeforeChildren:
1405         fputs(&quot;beforeChildren&quot;, stderr);
1406         break;
1407     case PositionIsAfterChildren:
1408         fputs(&quot;afterChildren&quot;, stderr);
1409         break;
1410     case PositionIsBeforeAnchor:
1411         fputs(&quot;before&quot;, stderr);
1412         break;
1413     case PositionIsAfterAnchor:
1414         fputs(&quot;after&quot;, stderr);
1415         break;
1416     }
1417     fprintf(stderr, &quot;, offset:%d\n&quot;, m_offset);
1418 }
1419 
1420 void Position::showTreeForThis() const
1421 {
1422     if (anchorNode()) {
1423         anchorNode()-&gt;showTreeForThis();
1424         showAnchorTypeAndOffset();
1425     }
1426 }
1427 
1428 #endif
1429 
1430 bool Position::equals(const Position&amp; other) const
1431 {
1432     if (!m_anchorNode)
1433         return !m_anchorNode == !other.m_anchorNode;
1434     if (!other.m_anchorNode)
1435         return false;
1436 
1437     switch (anchorType()) {
1438     case PositionIsBeforeChildren:
1439         ASSERT(!is&lt;Text&gt;(*m_anchorNode));
1440         switch (other.anchorType()) {
1441         case PositionIsBeforeChildren:
1442             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1443             return m_anchorNode == other.m_anchorNode;
1444         case PositionIsAfterChildren:
1445             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1446             return m_anchorNode == other.m_anchorNode &amp;&amp; !m_anchorNode-&gt;hasChildNodes();
1447         case PositionIsOffsetInAnchor:
1448             return m_anchorNode == other.m_anchorNode &amp;&amp; !other.m_offset;
1449         case PositionIsBeforeAnchor:
1450             return m_anchorNode-&gt;firstChild() == other.m_anchorNode;
1451         case PositionIsAfterAnchor:
1452             return false;
1453         }
1454         break;
1455     case PositionIsAfterChildren:
1456         ASSERT(!is&lt;Text&gt;(*m_anchorNode));
1457         switch (other.anchorType()) {
1458         case PositionIsBeforeChildren:
1459             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1460             return m_anchorNode == other.m_anchorNode &amp;&amp; !m_anchorNode-&gt;hasChildNodes();
1461         case PositionIsAfterChildren:
1462             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1463             return m_anchorNode == other.m_anchorNode;
1464         case PositionIsOffsetInAnchor:
1465             return m_anchorNode == other.m_anchorNode &amp;&amp; m_anchorNode-&gt;countChildNodes() == static_cast&lt;unsigned&gt;(m_offset);
1466         case PositionIsBeforeAnchor:
1467             return false;
1468         case PositionIsAfterAnchor:
1469             return m_anchorNode-&gt;lastChild() == other.m_anchorNode;
1470         }
1471         break;
1472     case PositionIsOffsetInAnchor:
1473         switch (other.anchorType()) {
1474         case PositionIsBeforeChildren:
1475             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1476             return m_anchorNode == other.m_anchorNode &amp;&amp; !m_offset;
1477         case PositionIsAfterChildren:
1478             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1479             return m_anchorNode == other.m_anchorNode &amp;&amp; m_offset == static_cast&lt;int&gt;(other.m_anchorNode-&gt;countChildNodes());
1480         case PositionIsOffsetInAnchor:
1481             return m_anchorNode == other.m_anchorNode &amp;&amp; m_offset == other.m_offset;
1482         case PositionIsBeforeAnchor:
1483             return m_anchorNode-&gt;traverseToChildAt(m_offset) == other.m_anchorNode;
1484         case PositionIsAfterAnchor:
1485             return m_offset &amp;&amp; m_anchorNode-&gt;traverseToChildAt(m_offset - 1) == other.m_anchorNode;
1486         }
1487         break;
1488     case PositionIsBeforeAnchor:
1489         switch (other.anchorType()) {
1490         case PositionIsBeforeChildren:
1491             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1492             return m_anchorNode == other.m_anchorNode-&gt;firstChild();
1493         case PositionIsAfterChildren:
1494             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1495             return false;
1496         case PositionIsOffsetInAnchor:
1497             return m_anchorNode == other.m_anchorNode-&gt;traverseToChildAt(other.m_offset);
1498         case PositionIsBeforeAnchor:
1499             return m_anchorNode == other.m_anchorNode;
1500         case PositionIsAfterAnchor:
1501             return m_anchorNode-&gt;previousSibling() == other.m_anchorNode;
1502         }
1503         break;
1504     case PositionIsAfterAnchor:
1505         switch (other.anchorType()) {
1506         case PositionIsBeforeChildren:
1507             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1508             return false;
1509         case PositionIsAfterChildren:
1510             ASSERT(!is&lt;Text&gt;(*other.m_anchorNode));
1511             return m_anchorNode == other.m_anchorNode-&gt;lastChild();
1512         case PositionIsOffsetInAnchor:
1513             return other.m_offset &amp;&amp; m_anchorNode == other.m_anchorNode-&gt;traverseToChildAt(other.m_offset - 1);
1514         case PositionIsBeforeAnchor:
1515             return m_anchorNode-&gt;nextSibling() == other.m_anchorNode;
1516         case PositionIsAfterAnchor:
1517             return m_anchorNode == other.m_anchorNode;
1518         }
1519         break;
1520     }
1521 
1522     ASSERT_NOT_REACHED();
1523     return false;
1524 }
1525 
1526 static TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, Position::AnchorType anchorType)
1527 {
1528     switch (anchorType) {
1529     case Position::PositionIsOffsetInAnchor:
1530         stream &lt;&lt; &quot;offset in anchor&quot;;
1531         break;
1532     case Position::PositionIsBeforeAnchor:
1533         stream &lt;&lt; &quot;before anchor&quot;;
1534         break;
1535     case Position::PositionIsAfterAnchor:
1536         stream &lt;&lt; &quot;after anchor&quot;;
1537         break;
1538     case Position::PositionIsBeforeChildren:
1539         stream &lt;&lt; &quot;before children&quot;;
1540         break;
1541     case Position::PositionIsAfterChildren:
1542         stream &lt;&lt; &quot;after children&quot;;
1543         break;
1544     }
1545     return stream;
1546 }
1547 
1548 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const Position&amp; position)
1549 {
1550     TextStream::GroupScope scope(stream);
1551     stream &lt;&lt; &quot;Position &quot; &lt;&lt; &amp;position;
1552 
1553     stream.dumpProperty(&quot;anchor node&quot;, position.anchorNode());
1554     stream.dumpProperty(&quot;offset&quot;, position.offsetInContainerNode());
1555     stream.dumpProperty(&quot;anchor type&quot;, position.anchorType());
1556 
1557     return stream;
1558 }
1559 
1560 RefPtr&lt;Node&gt; commonShadowIncludingAncestor(const Position&amp; a, const Position&amp; b)
1561 {
1562     auto* commonScope = commonTreeScope(a.containerNode(), b.containerNode());
1563     if (!commonScope)
1564         return nullptr;
1565     auto* nodeA = commonScope-&gt;ancestorNodeInThisScope(a.containerNode());
1566     ASSERT(nodeA);
1567     auto* nodeB = commonScope-&gt;ancestorNodeInThisScope(b.containerNode());
1568     ASSERT(nodeB);
1569     return Range::commonAncestorContainer(nodeA, nodeB);
1570 }
1571 
<a name="30" id="anc30"></a><span class="line-added">1572 Position positionInParentBeforeNode(Node* node)</span>
<span class="line-added">1573 {</span>
<span class="line-added">1574     auto* ancestor = node-&gt;parentNode();</span>
<span class="line-added">1575     while (ancestor &amp;&amp; editingIgnoresContent(*ancestor)) {</span>
<span class="line-added">1576         node = ancestor;</span>
<span class="line-added">1577         ancestor = ancestor-&gt;parentNode();</span>
<span class="line-added">1578     }</span>
<span class="line-added">1579     ASSERT(ancestor);</span>
<span class="line-added">1580     return Position(ancestor, node-&gt;computeNodeIndex(), Position::PositionIsOffsetInAnchor);</span>
<span class="line-added">1581 }</span>
<span class="line-added">1582 </span>
<span class="line-added">1583 Position positionInParentAfterNode(Node* node)</span>
<span class="line-added">1584 {</span>
<span class="line-added">1585     auto* ancestor = node-&gt;parentNode();</span>
<span class="line-added">1586     while (ancestor &amp;&amp; editingIgnoresContent(*ancestor)) {</span>
<span class="line-added">1587         node = ancestor;</span>
<span class="line-added">1588         ancestor = ancestor-&gt;parentNode();</span>
<span class="line-added">1589     }</span>
<span class="line-added">1590     ASSERT(ancestor);</span>
<span class="line-added">1591     return Position(ancestor, node-&gt;computeNodeIndex() + 1, Position::PositionIsOffsetInAnchor);</span>
<span class="line-added">1592 }</span>
<span class="line-added">1593 </span>
1594 } // namespace WebCore
1595 
1596 #if ENABLE(TREE_DEBUGGING)
1597 
1598 void showTree(const WebCore::Position&amp; pos)
1599 {
1600     pos.showTreeForThis();
1601 }
1602 
1603 void showTree(const WebCore::Position* pos)
1604 {
1605     if (pos)
1606         pos-&gt;showTreeForThis();
1607 }
1608 
1609 #endif
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
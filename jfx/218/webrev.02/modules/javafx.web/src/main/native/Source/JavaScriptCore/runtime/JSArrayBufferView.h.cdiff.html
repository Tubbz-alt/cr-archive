<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSArrayBufferView.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBufferViewInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 93,17 ***</span>
  // implementation of those has no need to even exist - we could at any time sink
  // code into JSGenericTypedArrayView if it was convenient.
  
  class JSArrayBufferView : public JSNonFinalObject {
  public:
<span class="line-modified">!     typedef JSNonFinalObject Base;</span>
<span class="line-modified">!     static const unsigned fastSizeLimit = 1000;</span>
      using VectorPtr = CagedBarrierPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
  
      static size_t sizeOf(uint32_t length, uint32_t elementSize)
      {
<span class="line-modified">!         return (length * elementSize + sizeof(EncodedJSValue) - 1)</span>
              &amp; ~(sizeof(EncodedJSValue) - 1);
      }
  
      static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
      {
<span class="line-new-header">--- 93,24 ---</span>
  // implementation of those has no need to even exist - we could at any time sink
  // code into JSGenericTypedArrayView if it was convenient.
  
  class JSArrayBufferView : public JSNonFinalObject {
  public:
<span class="line-modified">!     using Base = JSNonFinalObject;</span>
<span class="line-modified">! </span>
<span class="line-added">+     template&lt;typename, SubspaceAccess&gt;</span>
<span class="line-added">+     static void subspaceFor(VM&amp;)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static constexpr unsigned fastSizeLimit = 1000;</span>
      using VectorPtr = CagedBarrierPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
  
      static size_t sizeOf(uint32_t length, uint32_t elementSize)
      {
<span class="line-modified">!         return (static_cast&lt;size_t&gt;(length) * elementSize + sizeof(EncodedJSValue) - 1)</span>
              &amp; ~(sizeof(EncodedJSValue) - 1);
      }
  
      static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,32 ***</span>
      };
  
      JS_EXPORT_PRIVATE JSArrayBufferView(VM&amp;, ConstructionContext&amp;);
      JS_EXPORT_PRIVATE void finishCreation(VM&amp;);
  
<span class="line-modified">!     static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
  public:
      TypedArrayMode mode() const { return m_mode; }
      bool hasArrayBuffer() const { return JSC::hasArrayBuffer(mode()); }
  
      bool isShared();
      JS_EXPORT_PRIVATE ArrayBuffer* unsharedBuffer();
<span class="line-modified">!     ArrayBuffer* possiblySharedBuffer();</span>
<span class="line-modified">!     JSArrayBuffer* unsharedJSBuffer(ExecState* exec);</span>
<span class="line-modified">!     JSArrayBuffer* possiblySharedJSBuffer(ExecState* exec);</span>
      RefPtr&lt;ArrayBufferView&gt; unsharedImpl();
      JS_EXPORT_PRIVATE RefPtr&lt;ArrayBufferView&gt; possiblySharedImpl();
      bool isNeutered() { return hasArrayBuffer() &amp;&amp; !hasVector(); }
      void neuter();
  
      bool hasVector() const { return !!m_vector; }
      void* vector() const { return m_vector.getMayBeNull(length()); }
  
<span class="line-modified">!     unsigned byteOffset();</span>
      unsigned length() const { return m_length; }
  
      DECLARE_EXPORT_INFO;
  
      static ptrdiff_t offsetOfVector() { return OBJECT_OFFSETOF(JSArrayBufferView, m_vector); }
<span class="line-new-header">--- 157,34 ---</span>
      };
  
      JS_EXPORT_PRIVATE JSArrayBufferView(VM&amp;, ConstructionContext&amp;);
      JS_EXPORT_PRIVATE void finishCreation(VM&amp;);
  
<span class="line-modified">!     static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
  public:
      TypedArrayMode mode() const { return m_mode; }
      bool hasArrayBuffer() const { return JSC::hasArrayBuffer(mode()); }
  
      bool isShared();
      JS_EXPORT_PRIVATE ArrayBuffer* unsharedBuffer();
<span class="line-modified">!     inline ArrayBuffer* possiblySharedBuffer();</span>
<span class="line-modified">!     JSArrayBuffer* unsharedJSBuffer(JSGlobalObject* globalObject);</span>
<span class="line-modified">!     JSArrayBuffer* possiblySharedJSBuffer(JSGlobalObject* globalObject);</span>
      RefPtr&lt;ArrayBufferView&gt; unsharedImpl();
      JS_EXPORT_PRIVATE RefPtr&lt;ArrayBufferView&gt; possiblySharedImpl();
      bool isNeutered() { return hasArrayBuffer() &amp;&amp; !hasVector(); }
      void neuter();
  
      bool hasVector() const { return !!m_vector; }
      void* vector() const { return m_vector.getMayBeNull(length()); }
  
<span class="line-modified">!     inline unsigned byteOffset();</span>
<span class="line-added">+     inline Optional&lt;unsigned&gt; byteOffsetConcurrently();</span>
<span class="line-added">+ </span>
      unsigned length() const { return m_length; }
  
      DECLARE_EXPORT_INFO;
  
      static ptrdiff_t offsetOfVector() { return OBJECT_OFFSETOF(JSArrayBufferView, m_vector); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,19 ***</span>
      static ptrdiff_t offsetOfMode() { return OBJECT_OFFSETOF(JSArrayBufferView, m_mode); }
  
      static RefPtr&lt;ArrayBufferView&gt; toWrapped(VM&amp;, JSValue);
  
  private:
      JS_EXPORT_PRIVATE ArrayBuffer* slowDownAndWasteMemory();
      static void finalize(JSCell*);
  
  protected:
      friend class LLIntOffsetsExtractor;
  
      ArrayBuffer* existingBufferInButterfly();
  
<span class="line-modified">!     static String toStringName(const JSObject*, ExecState*);</span>
  
      VectorPtr m_vector;
      uint32_t m_length;
      TypedArrayMode m_mode;
  };
<span class="line-new-header">--- 192,23 ---</span>
      static ptrdiff_t offsetOfMode() { return OBJECT_OFFSETOF(JSArrayBufferView, m_mode); }
  
      static RefPtr&lt;ArrayBufferView&gt; toWrapped(VM&amp;, JSValue);
  
  private:
<span class="line-added">+     enum Requester { Mutator, ConcurrentThread };</span>
<span class="line-added">+     template&lt;Requester, typename ResultType&gt; ResultType byteOffsetImpl();</span>
<span class="line-added">+     template&lt;Requester&gt; ArrayBuffer* possiblySharedBufferImpl();</span>
<span class="line-added">+ </span>
      JS_EXPORT_PRIVATE ArrayBuffer* slowDownAndWasteMemory();
      static void finalize(JSCell*);
  
  protected:
      friend class LLIntOffsetsExtractor;
  
      ArrayBuffer* existingBufferInButterfly();
  
<span class="line-modified">!     static String toStringName(const JSObject*, JSGlobalObject*);</span>
  
      VectorPtr m_vector;
      uint32_t m_length;
      TypedArrayMode m_mode;
  };
</pre>
<center><a href="JSArrayBufferView.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBufferViewInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimationElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGAnimateMotionElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimationElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimationElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &quot;Document.h&quot;
 33 #include &quot;FloatConversion.h&quot;
 34 #include &quot;RenderObject.h&quot;
 35 #include &quot;SVGAnimateColorElement.h&quot;
 36 #include &quot;SVGAnimateElement.h&quot;
 37 #include &quot;SVGElement.h&quot;
 38 #include &quot;SVGNames.h&quot;
 39 #include &quot;SVGParserUtilities.h&quot;
 40 #include &quot;SVGStringList.h&quot;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 #include &lt;wtf/MathExtras.h&gt;
 43 #include &lt;wtf/NeverDestroyed.h&gt;
 44 #include &lt;wtf/text/StringView.h&gt;
 45 
 46 namespace WebCore {
 47 
 48 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGAnimationElement);
 49 
 50 SVGAnimationElement::SVGAnimationElement(const QualifiedName&amp; tagName, Document&amp; document)
 51     : SVGSMILElement(tagName, document)
<span class="line-removed"> 52     , SVGExternalResourcesRequired(this)</span>
 53     , SVGTests(this)
 54 {
 55 }
 56 
 57 static void parseKeyTimes(const String&amp; parse, Vector&lt;float&gt;&amp; result, bool verifyOrder)
 58 {
 59     result.clear();
 60     bool isFirst = true;
 61     for (StringView timeString : StringView(parse).split(&#39;;&#39;)) {
 62         bool ok;
 63         float time = timeString.toFloat(ok);
 64         if (!ok || time &lt; 0 || time &gt; 1)
 65             goto fail;
 66         if (verifyOrder) {
 67             if (isFirst) {
 68                 if (time)
 69                     goto fail;
 70                 isFirst = false;
 71             } else if (time &lt; result.last())
 72                 goto fail;
</pre>
<hr />
<pre>
119 
120         skipOptionalSVGSpaces(cur, end);
121 
122         if (cur &lt; end &amp;&amp; *cur == &#39;;&#39;) {
123             delimParsed = true;
124             cur++;
125         }
126         skipOptionalSVGSpaces(cur, end);
127 
128         result.append(UnitBezier(posA, posB, posC, posD));
129     }
130     if (!(cur == end &amp;&amp; !delimParsed))
131         result.clear();
132 }
133 
134 bool SVGAnimationElement::isSupportedAttribute(const QualifiedName&amp; attrName)
135 {
136     static const auto supportedAttributes = makeNeverDestroyed([] {
137         HashSet&lt;QualifiedName&gt; set;
138         SVGTests::addSupportedAttributes(set);
<span class="line-removed">139         SVGExternalResourcesRequired::addSupportedAttributes(set);</span>
140         set.add({
141             SVGNames::valuesAttr.get(),
142             SVGNames::keyTimesAttr.get(),
143             SVGNames::keyPointsAttr.get(),
144             SVGNames::keySplinesAttr.get(),
145             SVGNames::attributeTypeAttr.get(),
146             SVGNames::calcModeAttr.get(),
147             SVGNames::fromAttr.get(),
148             SVGNames::toAttr.get(),
149             SVGNames::byAttr.get(),
150         });
151         return set;
152     }());
153     return supportedAttributes.get().contains&lt;SVGAttributeHashTranslator&gt;(attrName);
154 }
155 
156 void SVGAnimationElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
157 {
158     if (name == SVGNames::valuesAttr) {
159         // Per the SMIL specification, leading and trailing white space,
</pre>
<hr />
<pre>
186         return;
187     }
188 
189     if (name == SVGNames::attributeTypeAttr) {
190         setAttributeType(value);
191         return;
192     }
193 
194     if (name == SVGNames::calcModeAttr) {
195         setCalcMode(value);
196         return;
197     }
198 
199     if (name == SVGNames::fromAttr || name == SVGNames::toAttr || name == SVGNames::byAttr) {
200         updateAnimationMode();
201         return;
202     }
203 
204     SVGSMILElement::parseAttribute(name, value);
205     SVGTests::parseAttribute(name, value);
<span class="line-removed">206     SVGExternalResourcesRequired::parseAttribute(name, value);</span>
207 }
208 
209 void SVGAnimationElement::svgAttributeChanged(const QualifiedName&amp; attrName)
210 {
211     if (!isSupportedAttribute(attrName)) {
212         SVGSMILElement::svgAttributeChanged(attrName);
213         return;
214     }
215 
216     animationAttributeChanged();
217 }
218 
219 void SVGAnimationElement::animationAttributeChanged()
220 {
221     // Assumptions may not hold after an attribute change.
222     m_animationValid = false;
223     setInactive();
224 }
225 
226 float SVGAnimationElement::getStartTime() const
</pre>
<hr />
<pre>
548         // The value is not static and is determined during the animation.
549         m_animationValid = calculateFromAndToValues(emptyString(), to);
550     } else if (animationMode == AnimationMode::FromBy)
551         m_animationValid = calculateFromAndByValues(from, by);
552     else if (animationMode == AnimationMode::By)
553         m_animationValid = calculateFromAndByValues(emptyString(), by);
554     else if (animationMode == AnimationMode::Values) {
555         m_animationValid = m_values.size() &gt;= 1
556             &amp;&amp; (calcMode == CalcMode::Paced || !hasAttributeWithoutSynchronization(SVGNames::keyTimesAttr) || hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_values.size() == m_keyTimes.size()))
557             &amp;&amp; (calcMode == CalcMode::Discrete || !m_keyTimes.size() || m_keyTimes.last() == 1)
558             &amp;&amp; (calcMode != CalcMode::Spline || ((m_keySplines.size() &amp;&amp; (m_keySplines.size() == m_values.size() - 1)) || m_keySplines.size() == m_keyPoints.size() - 1))
559             &amp;&amp; (!hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_keyTimes.size() &gt; 1 &amp;&amp; m_keyTimes.size() == m_keyPoints.size()));
560         if (m_animationValid)
561             m_animationValid = calculateToAtEndOfDurationValue(m_values.last());
562         if (calcMode == CalcMode::Paced &amp;&amp; m_animationValid)
563             calculateKeyTimesForCalcModePaced();
564     } else if (animationMode == AnimationMode::Path)
565         m_animationValid = calcMode == CalcMode::Paced || !hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_keyTimes.size() &gt; 1 &amp;&amp; m_keyTimes.size() == m_keyPoints.size());
566 }
567 
<span class="line-modified">568 void SVGAnimationElement::updateAnimation(float percent, unsigned repeatCount, SVGSMILElement* resultElement)</span>
569 {
570     if (!m_animationValid)
571         return;
572 
573     float effectivePercent;
574     CalcMode calcMode = this-&gt;calcMode();
575     AnimationMode animationMode = this-&gt;animationMode();
576     if (animationMode == AnimationMode::Values) {
577         String from;
578         String to;
579         currentValuesForValuesAnimation(percent, effectivePercent, from, to);
580         if (from != m_lastValuesAnimationFrom || to != m_lastValuesAnimationTo) {
581             m_animationValid = calculateFromAndToValues(from, to);
582             if (!m_animationValid)
583                 return;
584             m_lastValuesAnimationFrom = from;
585             m_lastValuesAnimationTo = to;
586         }
587     } else if (!m_keyPoints.isEmpty() &amp;&amp; calcMode != CalcMode::Paced)
588         effectivePercent = calculatePercentFromKeyPoints(percent);
589     else if (m_keyPoints.isEmpty() &amp;&amp; calcMode == CalcMode::Spline &amp;&amp; m_keyTimes.size() &gt; 1)
590         effectivePercent = calculatePercentForSpline(percent, calculateKeyTimesIndex(percent));
591     else if (animationMode == AnimationMode::FromTo || animationMode == AnimationMode::To)
592         effectivePercent = calculatePercentForFromTo(percent);
593     else
594         effectivePercent = percent;
595 
<span class="line-modified">596     calculateAnimatedValue(effectivePercent, repeatCount, resultElement);</span>
597 }
598 
599 void SVGAnimationElement::computeCSSPropertyValue(SVGElement* element, CSSPropertyID id, String&amp; valueString)
600 {
601     ASSERT(element);
602 
603     // Don&#39;t include any properties resulting from CSS Transitions/Animations or SMIL animations, as we want to retrieve the &quot;base value&quot;.
604     element-&gt;setUseOverrideComputedStyle(true);
605     RefPtr&lt;CSSValue&gt; value = ComputedStyleExtractor(element).propertyValue(id);
606     valueString = value ? value-&gt;cssText() : String();
607     element-&gt;setUseOverrideComputedStyle(false);
608 }
609 
610 static bool inheritsFromProperty(SVGElement* targetElement, const QualifiedName&amp; attributeName, const String&amp; value)
611 {
612     static NeverDestroyed&lt;const AtomString&gt; inherit(&quot;inherit&quot;, AtomString::ConstructFromLiteral);
613 
614     if (value.isEmpty() || value != inherit)
615         return false;
616     return targetElement-&gt;isAnimatedStyleAttribute(attributeName);
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &quot;Document.h&quot;
 33 #include &quot;FloatConversion.h&quot;
 34 #include &quot;RenderObject.h&quot;
 35 #include &quot;SVGAnimateColorElement.h&quot;
 36 #include &quot;SVGAnimateElement.h&quot;
 37 #include &quot;SVGElement.h&quot;
 38 #include &quot;SVGNames.h&quot;
 39 #include &quot;SVGParserUtilities.h&quot;
 40 #include &quot;SVGStringList.h&quot;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 #include &lt;wtf/MathExtras.h&gt;
 43 #include &lt;wtf/NeverDestroyed.h&gt;
 44 #include &lt;wtf/text/StringView.h&gt;
 45 
 46 namespace WebCore {
 47 
 48 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGAnimationElement);
 49 
 50 SVGAnimationElement::SVGAnimationElement(const QualifiedName&amp; tagName, Document&amp; document)
 51     : SVGSMILElement(tagName, document)

 52     , SVGTests(this)
 53 {
 54 }
 55 
 56 static void parseKeyTimes(const String&amp; parse, Vector&lt;float&gt;&amp; result, bool verifyOrder)
 57 {
 58     result.clear();
 59     bool isFirst = true;
 60     for (StringView timeString : StringView(parse).split(&#39;;&#39;)) {
 61         bool ok;
 62         float time = timeString.toFloat(ok);
 63         if (!ok || time &lt; 0 || time &gt; 1)
 64             goto fail;
 65         if (verifyOrder) {
 66             if (isFirst) {
 67                 if (time)
 68                     goto fail;
 69                 isFirst = false;
 70             } else if (time &lt; result.last())
 71                 goto fail;
</pre>
<hr />
<pre>
118 
119         skipOptionalSVGSpaces(cur, end);
120 
121         if (cur &lt; end &amp;&amp; *cur == &#39;;&#39;) {
122             delimParsed = true;
123             cur++;
124         }
125         skipOptionalSVGSpaces(cur, end);
126 
127         result.append(UnitBezier(posA, posB, posC, posD));
128     }
129     if (!(cur == end &amp;&amp; !delimParsed))
130         result.clear();
131 }
132 
133 bool SVGAnimationElement::isSupportedAttribute(const QualifiedName&amp; attrName)
134 {
135     static const auto supportedAttributes = makeNeverDestroyed([] {
136         HashSet&lt;QualifiedName&gt; set;
137         SVGTests::addSupportedAttributes(set);

138         set.add({
139             SVGNames::valuesAttr.get(),
140             SVGNames::keyTimesAttr.get(),
141             SVGNames::keyPointsAttr.get(),
142             SVGNames::keySplinesAttr.get(),
143             SVGNames::attributeTypeAttr.get(),
144             SVGNames::calcModeAttr.get(),
145             SVGNames::fromAttr.get(),
146             SVGNames::toAttr.get(),
147             SVGNames::byAttr.get(),
148         });
149         return set;
150     }());
151     return supportedAttributes.get().contains&lt;SVGAttributeHashTranslator&gt;(attrName);
152 }
153 
154 void SVGAnimationElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
155 {
156     if (name == SVGNames::valuesAttr) {
157         // Per the SMIL specification, leading and trailing white space,
</pre>
<hr />
<pre>
184         return;
185     }
186 
187     if (name == SVGNames::attributeTypeAttr) {
188         setAttributeType(value);
189         return;
190     }
191 
192     if (name == SVGNames::calcModeAttr) {
193         setCalcMode(value);
194         return;
195     }
196 
197     if (name == SVGNames::fromAttr || name == SVGNames::toAttr || name == SVGNames::byAttr) {
198         updateAnimationMode();
199         return;
200     }
201 
202     SVGSMILElement::parseAttribute(name, value);
203     SVGTests::parseAttribute(name, value);

204 }
205 
206 void SVGAnimationElement::svgAttributeChanged(const QualifiedName&amp; attrName)
207 {
208     if (!isSupportedAttribute(attrName)) {
209         SVGSMILElement::svgAttributeChanged(attrName);
210         return;
211     }
212 
213     animationAttributeChanged();
214 }
215 
216 void SVGAnimationElement::animationAttributeChanged()
217 {
218     // Assumptions may not hold after an attribute change.
219     m_animationValid = false;
220     setInactive();
221 }
222 
223 float SVGAnimationElement::getStartTime() const
</pre>
<hr />
<pre>
545         // The value is not static and is determined during the animation.
546         m_animationValid = calculateFromAndToValues(emptyString(), to);
547     } else if (animationMode == AnimationMode::FromBy)
548         m_animationValid = calculateFromAndByValues(from, by);
549     else if (animationMode == AnimationMode::By)
550         m_animationValid = calculateFromAndByValues(emptyString(), by);
551     else if (animationMode == AnimationMode::Values) {
552         m_animationValid = m_values.size() &gt;= 1
553             &amp;&amp; (calcMode == CalcMode::Paced || !hasAttributeWithoutSynchronization(SVGNames::keyTimesAttr) || hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_values.size() == m_keyTimes.size()))
554             &amp;&amp; (calcMode == CalcMode::Discrete || !m_keyTimes.size() || m_keyTimes.last() == 1)
555             &amp;&amp; (calcMode != CalcMode::Spline || ((m_keySplines.size() &amp;&amp; (m_keySplines.size() == m_values.size() - 1)) || m_keySplines.size() == m_keyPoints.size() - 1))
556             &amp;&amp; (!hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_keyTimes.size() &gt; 1 &amp;&amp; m_keyTimes.size() == m_keyPoints.size()));
557         if (m_animationValid)
558             m_animationValid = calculateToAtEndOfDurationValue(m_values.last());
559         if (calcMode == CalcMode::Paced &amp;&amp; m_animationValid)
560             calculateKeyTimesForCalcModePaced();
561     } else if (animationMode == AnimationMode::Path)
562         m_animationValid = calcMode == CalcMode::Paced || !hasAttributeWithoutSynchronization(SVGNames::keyPointsAttr) || (m_keyTimes.size() &gt; 1 &amp;&amp; m_keyTimes.size() == m_keyPoints.size());
563 }
564 
<span class="line-modified">565 void SVGAnimationElement::updateAnimation(float percent, unsigned repeatCount)</span>
566 {
567     if (!m_animationValid)
568         return;
569 
570     float effectivePercent;
571     CalcMode calcMode = this-&gt;calcMode();
572     AnimationMode animationMode = this-&gt;animationMode();
573     if (animationMode == AnimationMode::Values) {
574         String from;
575         String to;
576         currentValuesForValuesAnimation(percent, effectivePercent, from, to);
577         if (from != m_lastValuesAnimationFrom || to != m_lastValuesAnimationTo) {
578             m_animationValid = calculateFromAndToValues(from, to);
579             if (!m_animationValid)
580                 return;
581             m_lastValuesAnimationFrom = from;
582             m_lastValuesAnimationTo = to;
583         }
584     } else if (!m_keyPoints.isEmpty() &amp;&amp; calcMode != CalcMode::Paced)
585         effectivePercent = calculatePercentFromKeyPoints(percent);
586     else if (m_keyPoints.isEmpty() &amp;&amp; calcMode == CalcMode::Spline &amp;&amp; m_keyTimes.size() &gt; 1)
587         effectivePercent = calculatePercentForSpline(percent, calculateKeyTimesIndex(percent));
588     else if (animationMode == AnimationMode::FromTo || animationMode == AnimationMode::To)
589         effectivePercent = calculatePercentForFromTo(percent);
590     else
591         effectivePercent = percent;
592 
<span class="line-modified">593     calculateAnimatedValue(effectivePercent, repeatCount);</span>
594 }
595 
596 void SVGAnimationElement::computeCSSPropertyValue(SVGElement* element, CSSPropertyID id, String&amp; valueString)
597 {
598     ASSERT(element);
599 
600     // Don&#39;t include any properties resulting from CSS Transitions/Animations or SMIL animations, as we want to retrieve the &quot;base value&quot;.
601     element-&gt;setUseOverrideComputedStyle(true);
602     RefPtr&lt;CSSValue&gt; value = ComputedStyleExtractor(element).propertyValue(id);
603     valueString = value ? value-&gt;cssText() : String();
604     element-&gt;setUseOverrideComputedStyle(false);
605 }
606 
607 static bool inheritsFromProperty(SVGElement* targetElement, const QualifiedName&amp; attributeName, const String&amp; value)
608 {
609     static NeverDestroyed&lt;const AtomString&gt; inherit(&quot;inherit&quot;, AtomString::ConstructFromLiteral);
610 
611     if (value.isEmpty() || value != inherit)
612         return false;
613     return targetElement-&gt;isAnimatedStyleAttribute(attributeName);
</pre>
</td>
</tr>
</table>
<center><a href="SVGAnimateMotionElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGAnimationElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
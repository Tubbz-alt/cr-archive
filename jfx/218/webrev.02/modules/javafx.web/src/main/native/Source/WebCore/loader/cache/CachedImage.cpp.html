<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller (mueller@kde.org)
  4     Copyright (C) 2002 Waldo Bastian (bastian@kde.org)
  5     Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  6     Copyright (C) 2004, 2005, 2006, 2007 Apple Inc. All rights reserved.
  7 
  8     This library is free software; you can redistribute it and/or
  9     modify it under the terms of the GNU Library General Public
 10     License as published by the Free Software Foundation; either
 11     version 2 of the License, or (at your option) any later version.
 12 
 13     This library is distributed in the hope that it will be useful,
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;CachedImage.h&quot;
 26 
 27 #include &quot;BitmapImage.h&quot;
 28 #include &quot;CachedImageClient.h&quot;
 29 #include &quot;CachedResourceClient.h&quot;
 30 #include &quot;CachedResourceClientWalker.h&quot;
 31 #include &quot;CachedResourceLoader.h&quot;
 32 #include &quot;Frame.h&quot;
 33 #include &quot;FrameLoader.h&quot;
 34 #include &quot;FrameLoaderClient.h&quot;
 35 #include &quot;FrameLoaderTypes.h&quot;
 36 #include &quot;FrameView.h&quot;
 37 #include &quot;MIMETypeRegistry.h&quot;
 38 #include &quot;MemoryCache.h&quot;
 39 #include &quot;RenderElement.h&quot;
 40 #include &quot;SVGImage.h&quot;
 41 #include &quot;SecurityOrigin.h&quot;
 42 #include &quot;Settings.h&quot;
 43 #include &quot;SharedBuffer.h&quot;
 44 #include &quot;SubresourceLoader.h&quot;
 45 #include &lt;wtf/NeverDestroyed.h&gt;
 46 #include &lt;wtf/StdLibExtras.h&gt;
 47 
 48 #if PLATFORM(IOS_FAMILY)
 49 #include &quot;SystemMemory.h&quot;
 50 #endif
 51 
 52 #if USE(CG)
 53 #include &quot;PDFDocumentImage.h&quot;
 54 #endif
 55 
 56 namespace WebCore {
 57 
 58 CachedImage::CachedImage(CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 59     : CachedResource(WTFMove(request), Type::ImageResource, sessionID, cookieJar)
 60     , m_updateImageDataCount(0)
 61     , m_isManuallyCached(false)
 62     , m_shouldPaintBrokenImage(true)
 63     , m_forceUpdateImageDataEnabledForTesting(false)
 64 {
 65     setStatus(Unknown);
 66 }
 67 
 68 CachedImage::CachedImage(Image* image, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 69     : CachedResource(URL(), Type::ImageResource, sessionID, cookieJar)
 70     , m_image(image)
 71     , m_updateImageDataCount(0)
 72     , m_isManuallyCached(false)
 73     , m_shouldPaintBrokenImage(true)
 74     , m_forceUpdateImageDataEnabledForTesting(false)
 75 {
 76 }
 77 
 78 CachedImage::CachedImage(const URL&amp; url, Image* image, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar, const String&amp; domainForCachePartition)
 79     : CachedResource(url, Type::ImageResource, sessionID, cookieJar)
 80     , m_image(image)
 81     , m_updateImageDataCount(0)
 82     , m_isManuallyCached(true)
 83     , m_shouldPaintBrokenImage(true)
 84     , m_forceUpdateImageDataEnabledForTesting(false)
 85 {
 86     m_resourceRequest.setDomainForCachePartition(domainForCachePartition);
 87 
 88     // Use the incoming URL in the response field. This ensures that code using the response directly,
 89     // such as origin checks for security, actually see something.
 90     m_response.setURL(url);
 91 }
 92 
 93 CachedImage::~CachedImage()
 94 {
 95     clearImage();
 96 }
 97 
 98 void CachedImage::load(CachedResourceLoader&amp; loader)
 99 {
100     if (loader.shouldPerformImageLoad(url()))
101         CachedResource::load(loader);
102     else
103         setLoading(false);
104 }
105 
106 void CachedImage::setBodyDataFrom(const CachedResource&amp; resource)
107 {
108     ASSERT(resource.type() == type());
109     const CachedImage&amp; image = static_cast&lt;const CachedImage&amp;&gt;(resource);
110 
111     CachedResource::setBodyDataFrom(resource);
112 
113     m_image = image.m_image;
114     m_imageObserver = image.m_imageObserver;
115     if (m_imageObserver)
116         m_imageObserver-&gt;cachedImages().add(this);
117 
118     if (m_image &amp;&amp; is&lt;SVGImage&gt;(*m_image))
119         m_svgImageCache = makeUnique&lt;SVGImageCache&gt;(&amp;downcast&lt;SVGImage&gt;(*m_image));
120 }
121 
122 void CachedImage::didAddClient(CachedResourceClient&amp; client)
123 {
124     if (m_data &amp;&amp; !m_image &amp;&amp; !errorOccurred()) {
125         createImage();
126         m_image-&gt;setData(m_data.copyRef(), true);
127     }
128 
129     ASSERT(client.resourceClientType() == CachedImageClient::expectedType());
130     if (m_image &amp;&amp; !m_image-&gt;isNull())
131         static_cast&lt;CachedImageClient&amp;&gt;(client).imageChanged(this);
132 
133     if (m_image)
134         m_image-&gt;startAnimationAsynchronously();
135 
136     CachedResource::didAddClient(client);
137 }
138 
139 void CachedImage::didRemoveClient(CachedResourceClient&amp; client)
140 {
141     ASSERT(client.resourceClientType() == CachedImageClient::expectedType());
142 
143     m_pendingContainerContextRequests.remove(&amp;static_cast&lt;CachedImageClient&amp;&gt;(client));
144     m_clientsWaitingForAsyncDecoding.remove(&amp;static_cast&lt;CachedImageClient&amp;&gt;(client));
145 
146     if (m_svgImageCache)
147         m_svgImageCache-&gt;removeClientFromCache(&amp;static_cast&lt;CachedImageClient&amp;&gt;(client));
148 
149     CachedResource::didRemoveClient(client);
150 
151     static_cast&lt;CachedImageClient&amp;&gt;(client).didRemoveCachedImageClient(*this);
152 }
153 
154 bool CachedImage::isClientWaitingForAsyncDecoding(CachedImageClient&amp; client) const
155 {
156     return m_clientsWaitingForAsyncDecoding.contains(&amp;client);
157 }
158 
159 void CachedImage::addClientWaitingForAsyncDecoding(CachedImageClient&amp; client)
160 {
161     ASSERT(client.resourceClientType() == CachedImageClient::expectedType());
162     if (m_clientsWaitingForAsyncDecoding.contains(&amp;client))
163         return;
164     if (!m_clients.contains(&amp;client)) {
165         // If the &lt;html&gt; element does not have its own background specified, painting the root box
166         // renderer uses the style of the &lt;body&gt; element, see RenderView::rendererForRootBackground().
167         // In this case, the client we are asked to add is the root box renderer. Since we can&#39;t add
168         // a client to m_clientsWaitingForAsyncDecoding unless it is one of the m_clients, we are going
169         // to cancel the repaint optimization we do in CachedImage::imageFrameAvailable() by adding
170         // all the m_clients to m_clientsWaitingForAsyncDecoding.
171         CachedResourceClientWalker&lt;CachedImageClient&gt; walker(m_clients);
172         while (auto* client = walker.next())
173             m_clientsWaitingForAsyncDecoding.add(client);
174     } else
175         m_clientsWaitingForAsyncDecoding.add(&amp;client);
176 }
177 
178 void CachedImage::removeAllClientsWaitingForAsyncDecoding()
179 {
180     if (m_clientsWaitingForAsyncDecoding.isEmpty() || !hasImage() || !is&lt;BitmapImage&gt;(image()))
181         return;
182     downcast&lt;BitmapImage&gt;(image())-&gt;stopAsyncDecodingQueue();
183     for (auto* client : m_clientsWaitingForAsyncDecoding)
184         client-&gt;imageChanged(this);
185     m_clientsWaitingForAsyncDecoding.clear();
186 }
187 
188 void CachedImage::switchClientsToRevalidatedResource()
189 {
190     ASSERT(is&lt;CachedImage&gt;(resourceToRevalidate()));
191     // Pending container size requests need to be transferred to the revalidated resource.
192     if (!m_pendingContainerContextRequests.isEmpty()) {
193         // A copy of pending size requests is needed as they are deleted during CachedResource::switchClientsToRevalidateResouce().
194         ContainerContextRequests switchContainerContextRequests;
195         for (auto&amp; request : m_pendingContainerContextRequests)
196             switchContainerContextRequests.set(request.key, request.value);
197         CachedResource::switchClientsToRevalidatedResource();
198         CachedImage&amp; revalidatedCachedImage = downcast&lt;CachedImage&gt;(*resourceToRevalidate());
199         for (auto&amp; request : switchContainerContextRequests)
200             revalidatedCachedImage.setContainerContextForClient(*request.key, request.value.containerSize, request.value.containerZoom, request.value.imageURL);
201         return;
202     }
203 
204     CachedResource::switchClientsToRevalidatedResource();
205 }
206 
207 void CachedImage::allClientsRemoved()
208 {
209     m_pendingContainerContextRequests.clear();
210     m_clientsWaitingForAsyncDecoding.clear();
211     if (m_image &amp;&amp; !errorOccurred())
212         m_image-&gt;resetAnimation();
213 }
214 
215 std::pair&lt;Image*, float&gt; CachedImage::brokenImage(float deviceScaleFactor) const
216 {
217     if (deviceScaleFactor &gt;= 3) {
218         static NeverDestroyed&lt;Image*&gt; brokenImageVeryHiRes(&amp;Image::loadPlatformResource(&quot;missingImage@3x&quot;).leakRef());
219         return std::make_pair(brokenImageVeryHiRes, 3);
220     }
221 
222     if (deviceScaleFactor &gt;= 2) {
223         static NeverDestroyed&lt;Image*&gt; brokenImageHiRes(&amp;Image::loadPlatformResource(&quot;missingImage@2x&quot;).leakRef());
224         return std::make_pair(brokenImageHiRes, 2);
225     }
226 
227     static NeverDestroyed&lt;Image*&gt; brokenImageLoRes(&amp;Image::loadPlatformResource(&quot;missingImage&quot;).leakRef());
228     return std::make_pair(brokenImageLoRes, 1);
229 }
230 
231 bool CachedImage::willPaintBrokenImage() const
232 {
233     return errorOccurred() &amp;&amp; m_shouldPaintBrokenImage;
234 }
235 
236 Image* CachedImage::image()
237 {
238     if (errorOccurred() &amp;&amp; m_shouldPaintBrokenImage) {
239         // Returning the 1x broken image is non-ideal, but we cannot reliably access the appropriate
240         // deviceScaleFactor from here. It is critical that callers use CachedImage::brokenImage()
241         // when they need the real, deviceScaleFactor-appropriate broken image icon.
242         return brokenImage(1).first;
243     }
244 
245     if (m_image)
246         return m_image.get();
247 
248     return &amp;Image::nullImage();
249 }
250 
251 Image* CachedImage::imageForRenderer(const RenderObject* renderer)
252 {
253     if (errorOccurred() &amp;&amp; m_shouldPaintBrokenImage) {
254         // Returning the 1x broken image is non-ideal, but we cannot reliably access the appropriate
255         // deviceScaleFactor from here. It is critical that callers use CachedImage::brokenImage()
256         // when they need the real, deviceScaleFactor-appropriate broken image icon.
257         return brokenImage(1).first;
258     }
259 
260     if (!m_image)
261         return &amp;Image::nullImage();
262 
263     if (m_image-&gt;isSVGImage()) {
264         Image* image = m_svgImageCache-&gt;imageForRenderer(renderer);
265         if (image != &amp;Image::nullImage())
266             return image;
267     }
268     return m_image.get();
269 }
270 
271 void CachedImage::setContainerContextForClient(const CachedImageClient&amp; client, const LayoutSize&amp; containerSize, float containerZoom, const URL&amp; imageURL)
272 {
273     if (containerSize.isEmpty())
274         return;
275     ASSERT(containerZoom);
276     if (!m_image) {
277         m_pendingContainerContextRequests.set(&amp;client, ContainerContext { containerSize, containerZoom, imageURL });
278         return;
279     }
280 
281     if (!m_image-&gt;isSVGImage()) {
282         m_image-&gt;setContainerSize(containerSize);
283         return;
284     }
285 
286     m_svgImageCache-&gt;setContainerContextForClient(client, containerSize, containerZoom, imageURL);
287 }
288 
289 FloatSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, SizeType sizeType) const
290 {
291     if (!m_image)
292         return { };
293 
294     if (is&lt;SVGImage&gt;(*m_image) &amp;&amp; sizeType == UsedSize)
295         return m_svgImageCache-&gt;imageSizeForRenderer(renderer);
296 
297     return m_image-&gt;size(renderer ? renderer-&gt;imageOrientation() : ImageOrientation(ImageOrientation::FromImage));
298 }
299 
300 
301 LayoutSize CachedImage::unclampedImageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const
302 {
303     LayoutSize imageSize = LayoutSize(imageSizeForRenderer(renderer, sizeType));
304     if (imageSize.isEmpty() || multiplier == 1.0f)
305         return imageSize;
306 
307     float widthScale = m_image-&gt;hasRelativeWidth() ? 1.0f : multiplier;
308     float heightScale = m_image-&gt;hasRelativeHeight() ? 1.0f : multiplier;
309     imageSize.scale(widthScale, heightScale);
310     return imageSize;
311 }
312 
313 LayoutSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const
314 {
315     auto imageSize = unclampedImageSizeForRenderer(renderer, multiplier, sizeType);
316     if (imageSize.isEmpty() || multiplier == 1.0f)
317         return imageSize;
318 
319     // Don&#39;t let images that have a width/height &gt;= 1 shrink below 1 when zoomed.
320     LayoutSize minimumSize(imageSize.width() &gt; 0 ? 1 : 0, imageSize.height() &gt; 0 ? 1 : 0);
321     imageSize.clampToMinimumSize(minimumSize);
322 
323     ASSERT(multiplier != 1.0f || (imageSize.width().fraction() == 0.0f &amp;&amp; imageSize.height().fraction() == 0.0f));
324     return imageSize;
325 }
326 
327 void CachedImage::computeIntrinsicDimensions(Length&amp; intrinsicWidth, Length&amp; intrinsicHeight, FloatSize&amp; intrinsicRatio)
328 {
329     if (m_image)
330         m_image-&gt;computeIntrinsicDimensions(intrinsicWidth, intrinsicHeight, intrinsicRatio);
331 }
332 
333 void CachedImage::notifyObservers(const IntRect* changeRect)
334 {
335     CachedResourceClientWalker&lt;CachedImageClient&gt; w(m_clients);
336     while (CachedImageClient* c = w.next())
337         c-&gt;imageChanged(this, changeRect);
338 }
339 
340 void CachedImage::checkShouldPaintBrokenImage()
341 {
342     if (!m_loader || m_loader-&gt;reachedTerminalState())
343         return;
344 
345     m_shouldPaintBrokenImage = m_loader-&gt;frameLoader()-&gt;client().shouldPaintBrokenImage(url());
346 }
347 
348 bool CachedImage::isPDFResource() const
349 {
350     return Image::isPDFResource(m_response.mimeType(), url());
351 }
352 
353 bool CachedImage::isPostScriptResource() const
354 {
355     return Image::isPostScriptResource(m_response.mimeType(), url());
356 }
357 
358 void CachedImage::clear()
359 {
360     destroyDecodedData();
361     clearImage();
362     m_pendingContainerContextRequests.clear();
363     m_clientsWaitingForAsyncDecoding.clear();
364     setEncodedSize(0);
365 }
366 
367 inline void CachedImage::createImage()
368 {
369     // Create the image if it doesn&#39;t yet exist.
370     if (m_image)
371         return;
372 
373     m_imageObserver = CachedImageObserver::create(*this);
374 
375     m_image = Image::create(*m_imageObserver);
376 
377     if (m_image) {
378         if (is&lt;SVGImage&gt;(*m_image))
379             m_svgImageCache = makeUnique&lt;SVGImageCache&gt;(&amp;downcast&lt;SVGImage&gt;(*m_image));
380 
381         // Send queued container size requests.
382         if (m_image-&gt;usesContainerSize()) {
383             for (auto&amp; request : m_pendingContainerContextRequests)
384                 setContainerContextForClient(*request.key, request.value.containerSize, request.value.containerZoom, request.value.imageURL);
385         }
386         m_pendingContainerContextRequests.clear();
387         m_clientsWaitingForAsyncDecoding.clear();
388     }
389 }
390 
391 CachedImage::CachedImageObserver::CachedImageObserver(CachedImage&amp; image)
392 {
393     m_cachedImages.add(&amp;image);
394 }
395 
396 void CachedImage::CachedImageObserver::encodedDataStatusChanged(const Image&amp; image, EncodedDataStatus status)
397 {
398     for (auto cachedImage : m_cachedImages)
399         cachedImage-&gt;encodedDataStatusChanged(image, status);
400 }
401 
402 void CachedImage::CachedImageObserver::decodedSizeChanged(const Image&amp; image, long long delta)
403 {
404     for (auto cachedImage : m_cachedImages)
405         cachedImage-&gt;decodedSizeChanged(image, delta);
406 }
407 
408 void CachedImage::CachedImageObserver::didDraw(const Image&amp; image)
409 {
410     for (auto cachedImage : m_cachedImages)
411         cachedImage-&gt;didDraw(image);
412 }
413 
414 bool CachedImage::CachedImageObserver::canDestroyDecodedData(const Image&amp; image)
415 {
416     for (auto cachedImage : m_cachedImages) {
417         if (&amp;image != cachedImage-&gt;image())
418             continue;
419         if (!cachedImage-&gt;canDestroyDecodedData(image))
420             return false;
421     }
422     return true;
423 }
424 
425 void CachedImage::CachedImageObserver::imageFrameAvailable(const Image&amp; image, ImageAnimatingState animatingState, const IntRect* changeRect, DecodingStatus decodingStatus)
426 {
427     for (auto cachedImage : m_cachedImages)
428         cachedImage-&gt;imageFrameAvailable(image, animatingState, changeRect, decodingStatus);
429 }
430 
431 void CachedImage::CachedImageObserver::changedInRect(const Image&amp; image, const IntRect* rect)
432 {
433     for (auto cachedImage : m_cachedImages)
434         cachedImage-&gt;changedInRect(image, rect);
435 }
436 
437 inline void CachedImage::clearImage()
438 {
439     if (!m_image)
440         return;
441 
442     if (m_imageObserver) {
443         m_imageObserver-&gt;cachedImages().remove(this);
444 
445         if (m_imageObserver-&gt;cachedImages().isEmpty()) {
446             ASSERT(m_imageObserver-&gt;hasOneRef());
447             m_image-&gt;setImageObserver(nullptr);
448         }
449 
450         m_imageObserver = nullptr;
451     }
452 
453     m_image = nullptr;
454     m_lastUpdateImageDataTime = { };
455     m_updateImageDataCount = 0;
456 }
457 
458 void CachedImage::updateBufferInternal(SharedBuffer&amp; data)
459 {
460     m_data = &amp;data;
461     setEncodedSize(m_data-&gt;size());
462     createImage();
463 
464     // Don&#39;t update the image with the new buffer very often. Changing the decoder
465     // internal data and repainting the observers sometimes are very expensive operations.
466     if (!m_forceUpdateImageDataEnabledForTesting &amp;&amp; shouldDeferUpdateImageData())
467         return;
468 
469     EncodedDataStatus encodedDataStatus = EncodedDataStatus::Unknown;
470 
471     if (isPostScriptResource()) {
472 #if PLATFORM(MAC) &amp;&amp; !USE(WEBKIT_IMAGE_DECODERS)
473         // Delay updating the image with the PostScript data till all the data
474         // is received so it can be converted to PDF data.
475         return;
476 #else
477         // Set the encodedDataStatus to Error so loading this image will be canceled.
478         encodedDataStatus = EncodedDataStatus::Error;
479 #endif
480     } else {
481         // Have the image update its data from its internal buffer. Decoding the image data
482         // will be delayed until info (like size or specific image frames) are queried which
483         // usually happens when the observers are repainted.
484         encodedDataStatus = updateImageData(false);
485     }
486 
487     if (encodedDataStatus &gt; EncodedDataStatus::Error &amp;&amp; encodedDataStatus &lt; EncodedDataStatus::SizeAvailable)
488         return;
489 
490     if (encodedDataStatus == EncodedDataStatus::Error || m_image-&gt;isNull()) {
491         // Image decoding failed. Either we need more image data or the image data is malformed.
492         error(errorOccurred() ? status() : DecodeError);
493         if (m_loader &amp;&amp; encodedDataStatus == EncodedDataStatus::Error)
494             m_loader-&gt;cancel();
495         if (inCache())
496             MemoryCache::singleton().remove(*this);
497         return;
498     }
499 
500     // Tell our observers to try to draw.
501     notifyObservers();
502 }
503 
504 bool CachedImage::shouldDeferUpdateImageData() const
505 {
506     static const double updateImageDataBackoffIntervals[] = { 0, 1, 3, 6, 15 };
507     unsigned interval = m_updateImageDataCount;
508 
509     // The first time through, the chunk time will be 0 and the image will get an update.
510     return (MonotonicTime::now() - m_lastUpdateImageDataTime).seconds() &lt; updateImageDataBackoffIntervals[interval];
511 }
512 
513 RefPtr&lt;SharedBuffer&gt; CachedImage::convertedDataIfNeeded(SharedBuffer* data) const
514 {
515     if (!data || !isPostScriptResource())
516         return data;
517 #if PLATFORM(MAC) &amp;&amp; !USE(WEBKIT_IMAGE_DECODERS)
518     return SharedBuffer::create(PDFDocumentImage::convertPostScriptDataToPDF(data-&gt;createCFData()).get());
519 #else
520     // Loading the image should have been canceled if the system does not support converting PostScript to PDF.
521     ASSERT_NOT_REACHED();
522     return nullptr;
523 #endif
524 }
525 
526 void CachedImage::didUpdateImageData()
527 {
528     m_lastUpdateImageDataTime = MonotonicTime::now();
529     unsigned previous = m_updateImageDataCount;
530     if (previous != maxUpdateImageDataCount)
531         m_updateImageDataCount += 1;
532 }
533 
534 EncodedDataStatus CachedImage::updateImageData(bool allDataReceived)
535 {
536     if (!m_image || !m_data)
537         return EncodedDataStatus::Error;
538     EncodedDataStatus result = m_image-&gt;setData(m_data.get(), allDataReceived);
539     didUpdateImageData();
540     return result;
541 }
542 
543 void CachedImage::updateBuffer(SharedBuffer&amp; data)
544 {
545     ASSERT(dataBufferingPolicy() == DataBufferingPolicy::BufferData);
546     updateBufferInternal(data);
547     CachedResource::updateBuffer(data);
548 }
549 
550 void CachedImage::updateData(const char* data, unsigned length)
551 {
552     ASSERT(dataBufferingPolicy() == DataBufferingPolicy::DoNotBufferData);
553     updateBufferInternal(SharedBuffer::create(data, length));
554     CachedResource::updateData(data, length);
555 }
556 
557 void CachedImage::finishLoading(SharedBuffer* data)
558 {
559     m_data = convertedDataIfNeeded(data);
560     if (m_data) {
561         setEncodedSize(m_data-&gt;size());
562         createImage();
563     }
564 
565     EncodedDataStatus encodedDataStatus = updateImageData(true);
566 
567     if (encodedDataStatus == EncodedDataStatus::Error || m_image-&gt;isNull()) {
568         // Image decoding failed; the image data is malformed.
569         error(errorOccurred() ? status() : DecodeError);
570         if (inCache())
571             MemoryCache::singleton().remove(*this);
572         return;
573     }
574 
575     notifyObservers();
576     CachedResource::finishLoading(data);
577 }
578 
579 void CachedImage::didReplaceSharedBufferContents()
580 {
581     if (m_image) {
582         // Let the Image know that the SharedBuffer has been rejigged, so it can let go of any references to the heap-allocated resource buffer.
583         // FIXME(rdar://problem/24275617): It would be better if we could somehow tell the Image&#39;s decoder to swap in the new contents without destroying anything.
584         m_image-&gt;destroyDecodedData(true);
585     }
586     CachedResource::didReplaceSharedBufferContents();
587 }
588 
589 void CachedImage::error(CachedResource::Status status)
590 {
591     checkShouldPaintBrokenImage();
592     clear();
593     CachedResource::error(status);
594     notifyObservers();
595 }
596 
597 void CachedImage::responseReceived(const ResourceResponse&amp; response)
598 {
599     if (!m_response.isNull())
600         clear();
601     CachedResource::responseReceived(response);
602 }
603 
604 void CachedImage::destroyDecodedData()
605 {
606     bool canDeleteImage = !m_image || (m_image-&gt;hasOneRef() &amp;&amp; m_image-&gt;isBitmapImage());
607     if (canDeleteImage &amp;&amp; !isLoading() &amp;&amp; !hasClients()) {
608         m_image = nullptr;
609         setDecodedSize(0);
610     } else if (m_image &amp;&amp; !errorOccurred())
611         m_image-&gt;destroyDecodedData();
612 }
613 
614 void CachedImage::encodedDataStatusChanged(const Image&amp; image, EncodedDataStatus)
615 {
616     if (&amp;image != m_image)
617         return;
618 
619     notifyObservers();
620 }
621 
622 void CachedImage::decodedSizeChanged(const Image&amp; image, long long delta)
623 {
624     if (&amp;image != m_image)
625         return;
626 
627     ASSERT(delta &gt;= 0 || decodedSize() + delta &gt;= 0);
628     setDecodedSize(static_cast&lt;unsigned&gt;(decodedSize() + delta));
629 }
630 
631 void CachedImage::didDraw(const Image&amp; image)
632 {
633     if (&amp;image != m_image)
634         return;
635 
636     MonotonicTime timeStamp = FrameView::currentPaintTimeStamp();
637     if (!timeStamp) // If didDraw is called outside of a Frame paint.
638         timeStamp = MonotonicTime::now();
639 
640     CachedResource::didAccessDecodedData(timeStamp);
641 }
642 
643 bool CachedImage::canDestroyDecodedData(const Image&amp; image)
644 {
645     if (&amp;image != m_image)
646         return false;
647 
648     CachedResourceClientWalker&lt;CachedImageClient&gt; clientWalker(m_clients);
649     while (CachedImageClient* client = clientWalker.next()) {
650         if (!client-&gt;canDestroyDecodedData())
651             return false;
652     }
653 
654     return true;
655 }
656 
657 void CachedImage::imageFrameAvailable(const Image&amp; image, ImageAnimatingState animatingState, const IntRect* changeRect, DecodingStatus decodingStatus)
658 {
659     if (&amp;image != m_image)
660         return;
661 
662     CachedResourceClientWalker&lt;CachedImageClient&gt; clientWalker(m_clients);
663     VisibleInViewportState visibleState = VisibleInViewportState::No;
664 
665     while (CachedImageClient* client = clientWalker.next()) {
666         // All the clients of animated images have to be notified. The new frame has to be drawn in all of them.
667         if (animatingState == ImageAnimatingState::No &amp;&amp; !m_clientsWaitingForAsyncDecoding.contains(client))
668             continue;
669         if (client-&gt;imageFrameAvailable(*this, animatingState, changeRect) == VisibleInViewportState::Yes)
670             visibleState = VisibleInViewportState::Yes;
671     }
672 
673     if (visibleState == VisibleInViewportState::No &amp;&amp; animatingState == ImageAnimatingState::Yes)
674         m_image-&gt;stopAnimation();
675 
676     if (decodingStatus != DecodingStatus::Partial)
677         m_clientsWaitingForAsyncDecoding.clear();
678 }
679 
680 void CachedImage::changedInRect(const Image&amp; image, const IntRect* rect)
681 {
682     if (&amp;image != m_image)
683         return;
684     notifyObservers(rect);
685 }
686 
687 bool CachedImage::currentFrameKnownToBeOpaque(const RenderElement* renderer)
688 {
689     Image* image = imageForRenderer(renderer);
690     return image-&gt;currentFrameKnownToBeOpaque();
691 }
692 
693 bool CachedImage::isOriginClean(SecurityOrigin* origin)
694 {
695     ASSERT_UNUSED(origin, origin);
696     ASSERT(this-&gt;origin());
697     ASSERT(origin-&gt;toString() == this-&gt;origin()-&gt;toString());
698     return !loadFailedOrCanceled() &amp;&amp; isCORSSameOrigin();
699 }
700 
701 CachedResource::RevalidationDecision CachedImage::makeRevalidationDecision(CachePolicy cachePolicy) const
702 {
703     if (UNLIKELY(isManuallyCached())) {
704         // Do not revalidate manually cached images. This mechanism is used as a
705         // way to efficiently share an image from the client to content and
706         // the URL for that image may not represent a resource that can be
707         // retrieved by standard means. If the manual caching SPI is used, it is
708         // incumbent on the client to only use valid resources.
709         return RevalidationDecision::No;
710     }
711     return CachedResource::makeRevalidationDecision(cachePolicy);
712 }
713 
714 } // namespace WebCore
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.cpp b/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.cpp
@@ -55,24 +55,35 @@
 
 namespace WebCore {
 
 CachedImage::CachedImage(CachedResourceRequest&& request, const PAL::SessionID& sessionID, const CookieJar* cookieJar)
     : CachedResource(WTFMove(request), Type::ImageResource, sessionID, cookieJar)
+    , m_updateImageDataCount(0)
+    , m_isManuallyCached(false)
+    , m_shouldPaintBrokenImage(true)
+    , m_forceUpdateImageDataEnabledForTesting(false)
 {
     setStatus(Unknown);
 }
 
 CachedImage::CachedImage(Image* image, const PAL::SessionID& sessionID, const CookieJar* cookieJar)
     : CachedResource(URL(), Type::ImageResource, sessionID, cookieJar)
     , m_image(image)
+    , m_updateImageDataCount(0)
+    , m_isManuallyCached(false)
+    , m_shouldPaintBrokenImage(true)
+    , m_forceUpdateImageDataEnabledForTesting(false)
 {
 }
 
 CachedImage::CachedImage(const URL& url, Image* image, const PAL::SessionID& sessionID, const CookieJar* cookieJar, const String& domainForCachePartition)
     : CachedResource(url, Type::ImageResource, sessionID, cookieJar)
     , m_image(image)
+    , m_updateImageDataCount(0)
     , m_isManuallyCached(true)
+    , m_shouldPaintBrokenImage(true)
+    , m_forceUpdateImageDataEnabledForTesting(false)
 {
     m_resourceRequest.setDomainForCachePartition(domainForCachePartition);
 
     // Use the incoming URL in the response field. This ensures that code using the response directly,
     // such as origin checks for security, actually see something.
@@ -278,31 +289,39 @@
 FloatSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, SizeType sizeType) const
 {
     if (!m_image)
         return { };
 
-    if (is<BitmapImage>(*m_image) && renderer && renderer->imageOrientation() == ImageOrientation::FromImage)
-        return downcast<BitmapImage>(*m_image).sizeRespectingOrientation();
-
     if (is<SVGImage>(*m_image) && sizeType == UsedSize)
         return m_svgImageCache->imageSizeForRenderer(renderer);
 
-    return m_image->size();
+    return m_image->size(renderer ? renderer->imageOrientation() : ImageOrientation(ImageOrientation::FromImage));
 }
 
-LayoutSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const
+
+LayoutSize CachedImage::unclampedImageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const
 {
     LayoutSize imageSize = LayoutSize(imageSizeForRenderer(renderer, sizeType));
     if (imageSize.isEmpty() || multiplier == 1.0f)
         return imageSize;
 
-    // Don't let images that have a width/height >= 1 shrink below 1 when zoomed.
     float widthScale = m_image->hasRelativeWidth() ? 1.0f : multiplier;
     float heightScale = m_image->hasRelativeHeight() ? 1.0f : multiplier;
-    LayoutSize minimumSize(imageSize.width() > 0 ? 1 : 0, imageSize.height() > 0 ? 1 : 0);
     imageSize.scale(widthScale, heightScale);
+    return imageSize;
+}
+
+LayoutSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const
+{
+    auto imageSize = unclampedImageSizeForRenderer(renderer, multiplier, sizeType);
+    if (imageSize.isEmpty() || multiplier == 1.0f)
+        return imageSize;
+
+    // Don't let images that have a width/height >= 1 shrink below 1 when zoomed.
+    LayoutSize minimumSize(imageSize.width() > 0 ? 1 : 0, imageSize.height() > 0 ? 1 : 0);
     imageSize.clampToMinimumSize(minimumSize);
+
     ASSERT(multiplier != 1.0f || (imageSize.width().fraction() == 0.0f && imageSize.height().fraction() == 0.0f));
     return imageSize;
 }
 
 void CachedImage::computeIntrinsicDimensions(Length& intrinsicWidth, Length& intrinsicHeight, FloatSize& intrinsicRatio)
@@ -483,11 +502,11 @@
 }
 
 bool CachedImage::shouldDeferUpdateImageData() const
 {
     static const double updateImageDataBackoffIntervals[] = { 0, 1, 3, 6, 15 };
-    unsigned interval = std::min<unsigned>(m_updateImageDataCount, 4);
+    unsigned interval = m_updateImageDataCount;
 
     // The first time through, the chunk time will be 0 and the image will get an update.
     return (MonotonicTime::now() - m_lastUpdateImageDataTime).seconds() < updateImageDataBackoffIntervals[interval];
 }
 
@@ -505,12 +524,13 @@
 }
 
 void CachedImage::didUpdateImageData()
 {
     m_lastUpdateImageDataTime = MonotonicTime::now();
-    ASSERT(m_updateImageDataCount < std::numeric_limits<unsigned>::max());
-    ++m_updateImageDataCount;
+    unsigned previous = m_updateImageDataCount;
+    if (previous != maxUpdateImageDataCount)
+        m_updateImageDataCount += 1;
 }
 
 EncodedDataStatus CachedImage::updateImageData(bool allDataReceived)
 {
     if (!m_image || !m_data)

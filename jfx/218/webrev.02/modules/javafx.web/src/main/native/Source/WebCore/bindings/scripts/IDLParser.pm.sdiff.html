<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDLAttributes.json.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="generate-bindings-all.pl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  52     isUnion =&gt;      &#39;$&#39;, # Is the type a union (T or U)
  53     subtypes =&gt;     &#39;@&#39;, # Array of subtypes, only valid if isUnion or sequence
  54     extendedAttributes =&gt; &#39;%&#39;,
  55 });
  56 
  57 # Used to represent &#39;interface&#39; blocks
  58 struct( IDLInterface =&gt; {
  59     type =&gt; &#39;IDLType&#39;,
  60     parentType =&gt; &#39;IDLType&#39;,
  61     constants =&gt; &#39;@&#39;,    # List of &#39;IDLConstant&#39;
  62     operations =&gt; &#39;@&#39;,    # List of &#39;IDLOperation&#39;
  63     anonymousOperations =&gt; &#39;@&#39;, # List of &#39;IDLOperation&#39;
  64     attributes =&gt; &#39;@&#39;,    # List of &#39;IDLAttribute&#39;
  65     constructors =&gt; &#39;@&#39;, # Constructors, list of &#39;IDLOperation&#39;
  66     customConstructors =&gt; &#39;@&#39;, # Custom constructors, list of &#39;IDLOperation&#39;
  67     isException =&gt; &#39;$&#39;, # Used for exception interfaces
  68     isCallback =&gt; &#39;$&#39;, # Used for callback interfaces
  69     isPartial =&gt; &#39;$&#39;, # Used for partial interfaces
  70     iterable =&gt; &#39;$&#39;, # Used for iterable interfaces
  71     mapLike =&gt; &#39;$&#39;, # Used for mapLike interfaces

  72     serializable =&gt; &#39;$&#39;, # Used for serializable interfaces
  73     extendedAttributes =&gt; &#39;$&#39;,
  74 });
  75 
  76 # Used to represent an argument to a IDLOperation.
  77 struct( IDLArgument =&gt; {
  78     name =&gt; &#39;$&#39;,
  79     type =&gt; &#39;IDLType&#39;,
  80     isVariadic =&gt; &#39;$&#39;,
  81     isOptional =&gt; &#39;$&#39;,
  82     default =&gt; &#39;$&#39;,
  83     extendedAttributes =&gt; &#39;%&#39;,
  84 });
  85 
  86 # https://heycam.github.io/webidl/#idl-operations
  87 struct( IDLOperation =&gt; {
  88     name =&gt; &#39;$&#39;,
  89     type =&gt; &#39;IDLType&#39;, # Return type
  90     arguments =&gt; &#39;@&#39;, # List of &#39;IDLArgument&#39;
  91     isStatic =&gt; &#39;$&#39;,
  92     isIterable =&gt; &#39;$&#39;,
  93     isSerializer =&gt; &#39;$&#39;,
  94     isStringifier =&gt; &#39;$&#39;,
  95     isMapLike =&gt; &#39;$&#39;,

  96     specials =&gt; &#39;@&#39;,
  97     extendedAttributes =&gt; &#39;%&#39;,
  98 });
  99 
 100 
 101 # https://heycam.github.io/webidl/#idl-attributes
 102 struct( IDLAttribute =&gt; {
 103     name =&gt; &#39;$&#39;,
 104     type =&gt; &#39;IDLType&#39;,
 105     isStatic =&gt; &#39;$&#39;,
 106     isMapLike =&gt; &#39;$&#39;,

 107     isStringifier =&gt; &#39;$&#39;,
 108     isReadOnly =&gt; &#39;$&#39;,
 109     isInherit =&gt; &#39;$&#39;,
 110     extendedAttributes =&gt; &#39;$&#39;,
 111 });
 112 
 113 # https://heycam.github.io/webidl/#idl-iterable
 114 struct( IDLIterable =&gt; {
 115     isKeyValue =&gt; &#39;$&#39;,
 116     keyType =&gt; &#39;IDLType&#39;,
 117     valueType =&gt; &#39;IDLType&#39;,
 118     operations =&gt; &#39;@&#39;, # Iterable operations (entries, keys, values, [Symbol.Iterator], forEach)
 119     extendedAttributes =&gt; &#39;$&#39;,
 120 });
 121 
 122 # https://heycam.github.io/webidl/#es-maplike
 123 struct( IDLMapLike =&gt; {
 124     isReadOnly =&gt; &#39;$&#39;,
 125     keyType =&gt; &#39;IDLType&#39;,
 126     valueType =&gt; &#39;IDLType&#39;,
 127     attributes =&gt; &#39;@&#39;, # MapLike attributes (size)
 128     operations =&gt; &#39;@&#39;, # MapLike operations (entries, keys, values, forEach, get, has and if not readonly, delete, set and clear)
 129     extendedAttributes =&gt; &#39;$&#39;,
 130 });
 131 









 132 # https://heycam.github.io/webidl/#idl-serializers
 133 struct( IDLSerializable =&gt; {
 134     attributes =&gt; &#39;@&#39;, # List of attributes to serialize
 135     hasAttribute =&gt; &#39;$&#39;, # serializer = { attribute }
 136     hasInherit =&gt; &#39;$&#39;, # serializer = { inherit }
 137     hasGetter =&gt; &#39;$&#39;, # serializer = { getter }
 138     operations =&gt; &#39;@&#39;, # toJSON operation
 139 });
 140 
 141 # https://heycam.github.io/webidl/#idl-constants
 142 struct( IDLConstant =&gt; {
 143     name =&gt; &#39;$&#39;,
 144     type =&gt; &#39;IDLType&#39;,
 145     value =&gt; &#39;$&#39;,
 146     extendedAttributes =&gt; &#39;$&#39;,
 147 });
 148 
 149 # https://heycam.github.io/webidl/#idl-enums
 150 struct( IDLEnum =&gt; {
 151     name =&gt; &#39;$&#39;,
</pre>
<hr />
<pre>
 566     return $clonedArgument;
 567 }
 568 
 569 sub cloneOperation
 570 {
 571     my $operation = shift;
 572 
 573     my $clonedOperation = IDLOperation-&gt;new();
 574     $clonedOperation-&gt;name($operation-&gt;name);
 575     $clonedOperation-&gt;type(cloneType($operation-&gt;type));
 576     
 577     foreach my $argument (@{$operation-&gt;arguments}) {
 578         push(@{$clonedOperation-&gt;arguments}, cloneArgument($argument));
 579     }
 580 
 581     $clonedOperation-&gt;isStatic($operation-&gt;isStatic);
 582     $clonedOperation-&gt;isIterable($operation-&gt;isIterable);
 583     $clonedOperation-&gt;isSerializer($operation-&gt;isSerializer);
 584     $clonedOperation-&gt;isStringifier($operation-&gt;isStringifier);
 585     $clonedOperation-&gt;isMapLike($operation-&gt;isMapLike);

 586     $clonedOperation-&gt;specials($operation-&gt;specials);
 587 
 588     copyExtendedAttributes($clonedOperation-&gt;extendedAttributes, $operation-&gt;extendedAttributes);
 589 
 590     return $clonedOperation;
 591 }
 592 
 593 sub makeSimpleType
 594 {
 595     my $typeName = shift;
 596 
 597     return IDLType-&gt;new(name =&gt; $typeName);
 598 }
 599 
 600 sub addBuiltinTypedefs()
 601 {
 602     # NOTE: This leaves out the ArrayBufferView definition as it is
 603     # treated as its own type, and not a union, to allow us to utilize
 604     # the shared base class all the members of the union have.
 605 
</pre>
<hr />
<pre>
 693                     $definition-&gt;iterable-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;valueType));
 694                 }
 695                 foreach my $operation (@{$definition-&gt;iterable-&gt;operations}) {
 696                     $self-&gt;applyTypedefsToOperation($operation);
 697                 }
 698             }
 699             if ($definition-&gt;mapLike) {
 700                 if ($definition-&gt;mapLike-&gt;keyType) {
 701                     $definition-&gt;mapLike-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;keyType));
 702                 }
 703                 if ($definition-&gt;mapLike-&gt;valueType) {
 704                     $definition-&gt;mapLike-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;valueType));
 705                 }
 706                 foreach my $attribute (@{$definition-&gt;mapLike-&gt;attributes}) {
 707                     $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 708                 }
 709                 foreach my $operation (@{$definition-&gt;mapLike-&gt;operations}) {
 710                     $self-&gt;applyTypedefsToOperation($operation);
 711                 }
 712             }











 713         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 714             foreach my $member (@{$definition-&gt;members}) {
 715                 $member-&gt;type($self-&gt;typeByApplyingTypedefs($member-&gt;type));
 716             }
 717         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 718             $self-&gt;applyTypedefsToOperation($definition-&gt;operation);
 719         }
 720     }
 721 }
 722 
 723 sub applyTypedefsToOperation
 724 {
 725     my $self = shift;
 726     my $operation = shift;
 727 
 728     if ($operation-&gt;type) {
 729         $operation-&gt;type($self-&gt;typeByApplyingTypedefs($operation-&gt;type));
 730     }
 731 
 732     foreach my $argument (@{$operation-&gt;arguments}) {
</pre>
<hr />
<pre>
1360         return &quot;NaN&quot;;
1361     }
1362     if ($next-&gt;type() == FloatToken) {
1363         return $self-&gt;getToken()-&gt;value();
1364     }
1365     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1366 }
1367 
1368 sub parseOperationOrReadWriteAttributeOrMaplike
1369 {
1370     my $self = shift;
1371     my $extendedAttributeList = shift;
1372 
1373     my $next = $self-&gt;nextToken();
1374     if ($next-&gt;value() =~ /$nextAttribute_1/) {
1375         return $self-&gt;parseReadWriteAttribute($extendedAttributeList);
1376     }
1377     if ($next-&gt;value() eq &quot;maplike&quot;) {
1378         return $self-&gt;parseMapLikeRest($extendedAttributeList, 0);
1379     }



1380     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperation_1/) {
1381         return $self-&gt;parseOperation($extendedAttributeList);
1382     }
1383     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1384 }
1385 
1386 sub parseReadOnlyMember
1387 {
1388     my $self = shift;
1389     my $extendedAttributeList = shift;
1390 
1391     my $next = $self-&gt;nextToken();
1392     if ($next-&gt;value() eq &quot;readonly&quot;) {
1393         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1394 
1395         my $next = $self-&gt;nextToken();
1396         if ($next-&gt;value() eq &quot;attribute&quot;) {
1397             my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1398             $attribute-&gt;isReadOnly(1);
1399             return $attribute;
1400         }
1401         if ($next-&gt;value() eq &quot;maplike&quot;) {
1402             return $self-&gt;parseMapLikeRest($extendedAttributeList, 1);
1403         }



1404     }
1405     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1406 }
1407 
1408 sub parseSerializer
1409 {
1410     my $self = shift;
1411     my $extendedAttributeList = shift;
1412 
1413     my $next = $self-&gt;nextToken();
1414     if ($next-&gt;value() eq &quot;serializer&quot;) {
1415         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;serializer&quot;, __LINE__);
1416         my $next = $self-&gt;nextToken();
1417         my $newDataNode;
1418         if ($next-&gt;value() ne &quot;;&quot;) {
1419             $newDataNode = $self-&gt;parseSerializerRest($extendedAttributeList);
1420             my $next = $self-&gt;nextToken();
1421         } else {
1422             $newDataNode = IDLSerializable-&gt;new();
1423         }
</pre>
<hr />
<pre>
1680         return 1;
1681     }
1682     return 0;
1683 }
1684 
1685 sub parseReadOnly
1686 {
1687     my $self = shift;
1688     my $next = $self-&gt;nextToken();
1689     if ($next-&gt;value() eq &quot;readonly&quot;) {
1690         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1691         return 1;
1692     }
1693     return 0;
1694 }
1695 
1696 sub parseOperation
1697 {
1698     my $self = shift;
1699     my $extendedAttributeList = shift;

1700 
1701     my $next = $self-&gt;nextToken();
1702     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1703         return $self-&gt;parseSpecialOperation($extendedAttributeList);
1704     }
1705     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1706         my $returnType = $self-&gt;parseReturnType();
1707 
1708         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1709         # extended attributes with a return type.
1710         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1711 
1712         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1713         $operation-&gt;type($returnType);
1714 
1715         return $operation;
1716     }
1717     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1718 }
1719 
</pre>
<hr />
<pre>
1949     my $forEachOperation = IDLOperation-&gt;new();
1950     $forEachOperation-&gt;name(&quot;forEach&quot;);
1951     $forEachOperation-&gt;isMapLike(1);
1952     $forEachOperation-&gt;extendedAttributes({});
1953     $forEachOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1954     my $forEachArgument = IDLArgument-&gt;new();
1955     $forEachArgument-&gt;name(&quot;callback&quot;);
1956     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1957     $forEachArgument-&gt;extendedAttributes($extendedAttributeList);
1958     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1959 
1960     push(@{$maplike-&gt;operations}, $getOperation);
1961     push(@{$maplike-&gt;operations}, $hasOperation);
1962     push(@{$maplike-&gt;operations}, $entriesOperation);
1963     push(@{$maplike-&gt;operations}, $keysOperation);
1964     push(@{$maplike-&gt;operations}, $valuesOperation);
1965     push(@{$maplike-&gt;operations}, $forEachOperation);
1966 
1967     return $maplike if $isReadOnly;
1968 





































































































































1969     my $addOperation = IDLOperation-&gt;new();
1970     $addOperation-&gt;name(&quot;add&quot;);
<span class="line-modified">1971     $addOperation-&gt;isMapLike(1);</span>
1972     my $addArgument = IDLArgument-&gt;new();
1973     $addArgument-&gt;name(&quot;key&quot;);
<span class="line-modified">1974     $addArgument-&gt;type($maplike-&gt;keyType);</span>
1975     $addArgument-&gt;extendedAttributes($extendedAttributeList);
1976     push(@{$addOperation-&gt;arguments}, ($addArgument));
1977     $addOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1978     $addOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1979 
1980     my $clearOperation = IDLOperation-&gt;new();
1981     $clearOperation-&gt;name(&quot;clear&quot;);
<span class="line-modified">1982     $clearOperation-&gt;isMapLike(1);</span>
1983     $clearOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1984     $clearOperation-&gt;type(makeSimpleType(&quot;void&quot;));
1985 
1986     my $deleteOperation = IDLOperation-&gt;new();
1987     $deleteOperation-&gt;name(&quot;delete&quot;);
<span class="line-modified">1988     $deleteOperation-&gt;isMapLike(1);</span>
1989     my $deleteArgument = IDLArgument-&gt;new();
1990     $deleteArgument-&gt;name(&quot;key&quot;);
<span class="line-modified">1991     $deleteArgument-&gt;type($maplike-&gt;keyType);</span>
1992     $deleteArgument-&gt;extendedAttributes($extendedAttributeList);
1993     push(@{$deleteOperation-&gt;arguments}, ($deleteArgument));
1994     $deleteOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1995     $deleteOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1996 
<span class="line-modified">1997     push(@{$maplike-&gt;operations}, $addOperation);</span>
<span class="line-modified">1998     push(@{$maplike-&gt;operations}, $clearOperation);</span>
<span class="line-modified">1999     push(@{$maplike-&gt;operations}, $deleteOperation);</span>
2000 
<span class="line-modified">2001     return $maplike;</span>
2002 }
2003 
2004 sub parseOperationRest
2005 {
2006     my $self = shift;
2007     my $extendedAttributeList = shift;
2008 
2009     my $next = $self-&gt;nextToken();
2010     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
2011         my $operation = IDLOperation-&gt;new();
2012 
2013         my $name = $self-&gt;parseOptionalIdentifier();
2014         $operation-&gt;name(identifierRemoveNullablePrefix($name));
2015 
2016         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, $name, __LINE__);
2017 
2018         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
2019 
2020         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2021         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
</pre>
<hr />
<pre>
2834     my $interface = shift;
2835     my $members = shift;
2836 
2837     for my $item (@{$members}) {
2838         if (ref($item) eq &quot;IDLAttribute&quot;) {
2839             push(@{$interface-&gt;attributes}, $item);
2840             next;
2841         }
2842         if (ref($item) eq &quot;IDLConstant&quot;) {
2843             push(@{$interface-&gt;constants}, $item);
2844             next;
2845         }
2846         if (ref($item) eq &quot;IDLIterable&quot;) {
2847             $interface-&gt;iterable($item);
2848             next;
2849         }
2850         if (ref($item) eq &quot;IDLMapLike&quot;) {
2851             $interface-&gt;mapLike($item);
2852             next;
2853         }




2854         if (ref($item) eq &quot;IDLOperation&quot;) {
2855             if ($item-&gt;name eq &quot;&quot;) {
2856                 push(@{$interface-&gt;anonymousOperations}, $item);
2857             } else {
2858                 push(@{$interface-&gt;operations}, $item);
2859             }
2860             next;
2861         }
2862         if (ref($item) eq &quot;IDLSerializable&quot;) {
2863             $interface-&gt;serializable($item);
2864             next;
2865         }
2866     }
2867 
2868     if ($interface-&gt;serializable) {
2869         my $numSerializerAttributes = @{$interface-&gt;serializable-&gt;attributes};
2870         if ($interface-&gt;serializable-&gt;hasAttribute) {
2871             foreach my $attribute (@{$interface-&gt;attributes}) {
2872                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
2873             }
</pre>
</td>
<td>
<hr />
<pre>
  52     isUnion =&gt;      &#39;$&#39;, # Is the type a union (T or U)
  53     subtypes =&gt;     &#39;@&#39;, # Array of subtypes, only valid if isUnion or sequence
  54     extendedAttributes =&gt; &#39;%&#39;,
  55 });
  56 
  57 # Used to represent &#39;interface&#39; blocks
  58 struct( IDLInterface =&gt; {
  59     type =&gt; &#39;IDLType&#39;,
  60     parentType =&gt; &#39;IDLType&#39;,
  61     constants =&gt; &#39;@&#39;,    # List of &#39;IDLConstant&#39;
  62     operations =&gt; &#39;@&#39;,    # List of &#39;IDLOperation&#39;
  63     anonymousOperations =&gt; &#39;@&#39;, # List of &#39;IDLOperation&#39;
  64     attributes =&gt; &#39;@&#39;,    # List of &#39;IDLAttribute&#39;
  65     constructors =&gt; &#39;@&#39;, # Constructors, list of &#39;IDLOperation&#39;
  66     customConstructors =&gt; &#39;@&#39;, # Custom constructors, list of &#39;IDLOperation&#39;
  67     isException =&gt; &#39;$&#39;, # Used for exception interfaces
  68     isCallback =&gt; &#39;$&#39;, # Used for callback interfaces
  69     isPartial =&gt; &#39;$&#39;, # Used for partial interfaces
  70     iterable =&gt; &#39;$&#39;, # Used for iterable interfaces
  71     mapLike =&gt; &#39;$&#39;, # Used for mapLike interfaces
<span class="line-added">  72     setLike =&gt; &#39;$&#39;, # Used for setLike interfaces</span>
  73     serializable =&gt; &#39;$&#39;, # Used for serializable interfaces
  74     extendedAttributes =&gt; &#39;$&#39;,
  75 });
  76 
  77 # Used to represent an argument to a IDLOperation.
  78 struct( IDLArgument =&gt; {
  79     name =&gt; &#39;$&#39;,
  80     type =&gt; &#39;IDLType&#39;,
  81     isVariadic =&gt; &#39;$&#39;,
  82     isOptional =&gt; &#39;$&#39;,
  83     default =&gt; &#39;$&#39;,
  84     extendedAttributes =&gt; &#39;%&#39;,
  85 });
  86 
  87 # https://heycam.github.io/webidl/#idl-operations
  88 struct( IDLOperation =&gt; {
  89     name =&gt; &#39;$&#39;,
  90     type =&gt; &#39;IDLType&#39;, # Return type
  91     arguments =&gt; &#39;@&#39;, # List of &#39;IDLArgument&#39;
  92     isStatic =&gt; &#39;$&#39;,
  93     isIterable =&gt; &#39;$&#39;,
  94     isSerializer =&gt; &#39;$&#39;,
  95     isStringifier =&gt; &#39;$&#39;,
  96     isMapLike =&gt; &#39;$&#39;,
<span class="line-added">  97     isSetLike =&gt; &#39;$&#39;,</span>
  98     specials =&gt; &#39;@&#39;,
  99     extendedAttributes =&gt; &#39;%&#39;,
 100 });
 101 
 102 
 103 # https://heycam.github.io/webidl/#idl-attributes
 104 struct( IDLAttribute =&gt; {
 105     name =&gt; &#39;$&#39;,
 106     type =&gt; &#39;IDLType&#39;,
 107     isStatic =&gt; &#39;$&#39;,
 108     isMapLike =&gt; &#39;$&#39;,
<span class="line-added"> 109     isSetLike =&gt; &#39;$&#39;,</span>
 110     isStringifier =&gt; &#39;$&#39;,
 111     isReadOnly =&gt; &#39;$&#39;,
 112     isInherit =&gt; &#39;$&#39;,
 113     extendedAttributes =&gt; &#39;$&#39;,
 114 });
 115 
 116 # https://heycam.github.io/webidl/#idl-iterable
 117 struct( IDLIterable =&gt; {
 118     isKeyValue =&gt; &#39;$&#39;,
 119     keyType =&gt; &#39;IDLType&#39;,
 120     valueType =&gt; &#39;IDLType&#39;,
 121     operations =&gt; &#39;@&#39;, # Iterable operations (entries, keys, values, [Symbol.Iterator], forEach)
 122     extendedAttributes =&gt; &#39;$&#39;,
 123 });
 124 
 125 # https://heycam.github.io/webidl/#es-maplike
 126 struct( IDLMapLike =&gt; {
 127     isReadOnly =&gt; &#39;$&#39;,
 128     keyType =&gt; &#39;IDLType&#39;,
 129     valueType =&gt; &#39;IDLType&#39;,
 130     attributes =&gt; &#39;@&#39;, # MapLike attributes (size)
 131     operations =&gt; &#39;@&#39;, # MapLike operations (entries, keys, values, forEach, get, has and if not readonly, delete, set and clear)
 132     extendedAttributes =&gt; &#39;$&#39;,
 133 });
 134 
<span class="line-added"> 135 # https://heycam.github.io/webidl/#es-setlike</span>
<span class="line-added"> 136 struct( IDLSetLike =&gt; {</span>
<span class="line-added"> 137     isReadOnly =&gt; &#39;$&#39;,</span>
<span class="line-added"> 138     itemType =&gt; &#39;IDLType&#39;,</span>
<span class="line-added"> 139     attributes =&gt; &#39;@&#39;, # SetLike attributes (size)</span>
<span class="line-added"> 140     operations =&gt; &#39;@&#39;, # SetLike operations (entries, keys, values, forEach, has and if not readonly, delete, set and clear)</span>
<span class="line-added"> 141     extendedAttributes =&gt; &#39;$&#39;,</span>
<span class="line-added"> 142 });</span>
<span class="line-added"> 143 </span>
 144 # https://heycam.github.io/webidl/#idl-serializers
 145 struct( IDLSerializable =&gt; {
 146     attributes =&gt; &#39;@&#39;, # List of attributes to serialize
 147     hasAttribute =&gt; &#39;$&#39;, # serializer = { attribute }
 148     hasInherit =&gt; &#39;$&#39;, # serializer = { inherit }
 149     hasGetter =&gt; &#39;$&#39;, # serializer = { getter }
 150     operations =&gt; &#39;@&#39;, # toJSON operation
 151 });
 152 
 153 # https://heycam.github.io/webidl/#idl-constants
 154 struct( IDLConstant =&gt; {
 155     name =&gt; &#39;$&#39;,
 156     type =&gt; &#39;IDLType&#39;,
 157     value =&gt; &#39;$&#39;,
 158     extendedAttributes =&gt; &#39;$&#39;,
 159 });
 160 
 161 # https://heycam.github.io/webidl/#idl-enums
 162 struct( IDLEnum =&gt; {
 163     name =&gt; &#39;$&#39;,
</pre>
<hr />
<pre>
 578     return $clonedArgument;
 579 }
 580 
 581 sub cloneOperation
 582 {
 583     my $operation = shift;
 584 
 585     my $clonedOperation = IDLOperation-&gt;new();
 586     $clonedOperation-&gt;name($operation-&gt;name);
 587     $clonedOperation-&gt;type(cloneType($operation-&gt;type));
 588     
 589     foreach my $argument (@{$operation-&gt;arguments}) {
 590         push(@{$clonedOperation-&gt;arguments}, cloneArgument($argument));
 591     }
 592 
 593     $clonedOperation-&gt;isStatic($operation-&gt;isStatic);
 594     $clonedOperation-&gt;isIterable($operation-&gt;isIterable);
 595     $clonedOperation-&gt;isSerializer($operation-&gt;isSerializer);
 596     $clonedOperation-&gt;isStringifier($operation-&gt;isStringifier);
 597     $clonedOperation-&gt;isMapLike($operation-&gt;isMapLike);
<span class="line-added"> 598     $clonedOperation-&gt;isSetLike($operation-&gt;isSetLike);</span>
 599     $clonedOperation-&gt;specials($operation-&gt;specials);
 600 
 601     copyExtendedAttributes($clonedOperation-&gt;extendedAttributes, $operation-&gt;extendedAttributes);
 602 
 603     return $clonedOperation;
 604 }
 605 
 606 sub makeSimpleType
 607 {
 608     my $typeName = shift;
 609 
 610     return IDLType-&gt;new(name =&gt; $typeName);
 611 }
 612 
 613 sub addBuiltinTypedefs()
 614 {
 615     # NOTE: This leaves out the ArrayBufferView definition as it is
 616     # treated as its own type, and not a union, to allow us to utilize
 617     # the shared base class all the members of the union have.
 618 
</pre>
<hr />
<pre>
 706                     $definition-&gt;iterable-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;valueType));
 707                 }
 708                 foreach my $operation (@{$definition-&gt;iterable-&gt;operations}) {
 709                     $self-&gt;applyTypedefsToOperation($operation);
 710                 }
 711             }
 712             if ($definition-&gt;mapLike) {
 713                 if ($definition-&gt;mapLike-&gt;keyType) {
 714                     $definition-&gt;mapLike-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;keyType));
 715                 }
 716                 if ($definition-&gt;mapLike-&gt;valueType) {
 717                     $definition-&gt;mapLike-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;valueType));
 718                 }
 719                 foreach my $attribute (@{$definition-&gt;mapLike-&gt;attributes}) {
 720                     $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 721                 }
 722                 foreach my $operation (@{$definition-&gt;mapLike-&gt;operations}) {
 723                     $self-&gt;applyTypedefsToOperation($operation);
 724                 }
 725             }
<span class="line-added"> 726             if ($definition-&gt;setLike) {</span>
<span class="line-added"> 727                 if ($definition-&gt;setLike-&gt;itemType) {</span>
<span class="line-added"> 728                     $definition-&gt;setLike-&gt;itemType($self-&gt;typeByApplyingTypedefs($definition-&gt;setLike-&gt;itemType));</span>
<span class="line-added"> 729                 }</span>
<span class="line-added"> 730                 foreach my $attribute (@{$definition-&gt;setLike-&gt;attributes}) {</span>
<span class="line-added"> 731                     $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));</span>
<span class="line-added"> 732                 }</span>
<span class="line-added"> 733                 foreach my $operation (@{$definition-&gt;setLike-&gt;operations}) {</span>
<span class="line-added"> 734                     $self-&gt;applyTypedefsToOperation($operation);</span>
<span class="line-added"> 735                 }</span>
<span class="line-added"> 736             }</span>
 737         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 738             foreach my $member (@{$definition-&gt;members}) {
 739                 $member-&gt;type($self-&gt;typeByApplyingTypedefs($member-&gt;type));
 740             }
 741         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 742             $self-&gt;applyTypedefsToOperation($definition-&gt;operation);
 743         }
 744     }
 745 }
 746 
 747 sub applyTypedefsToOperation
 748 {
 749     my $self = shift;
 750     my $operation = shift;
 751 
 752     if ($operation-&gt;type) {
 753         $operation-&gt;type($self-&gt;typeByApplyingTypedefs($operation-&gt;type));
 754     }
 755 
 756     foreach my $argument (@{$operation-&gt;arguments}) {
</pre>
<hr />
<pre>
1384         return &quot;NaN&quot;;
1385     }
1386     if ($next-&gt;type() == FloatToken) {
1387         return $self-&gt;getToken()-&gt;value();
1388     }
1389     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1390 }
1391 
1392 sub parseOperationOrReadWriteAttributeOrMaplike
1393 {
1394     my $self = shift;
1395     my $extendedAttributeList = shift;
1396 
1397     my $next = $self-&gt;nextToken();
1398     if ($next-&gt;value() =~ /$nextAttribute_1/) {
1399         return $self-&gt;parseReadWriteAttribute($extendedAttributeList);
1400     }
1401     if ($next-&gt;value() eq &quot;maplike&quot;) {
1402         return $self-&gt;parseMapLikeRest($extendedAttributeList, 0);
1403     }
<span class="line-added">1404     if ($next-&gt;value() eq &quot;setlike&quot;) {</span>
<span class="line-added">1405         return $self-&gt;parseSetLikeRest($extendedAttributeList, 0);</span>
<span class="line-added">1406     }</span>
1407     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperation_1/) {
1408         return $self-&gt;parseOperation($extendedAttributeList);
1409     }
1410     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1411 }
1412 
1413 sub parseReadOnlyMember
1414 {
1415     my $self = shift;
1416     my $extendedAttributeList = shift;
1417 
1418     my $next = $self-&gt;nextToken();
1419     if ($next-&gt;value() eq &quot;readonly&quot;) {
1420         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1421 
1422         my $next = $self-&gt;nextToken();
1423         if ($next-&gt;value() eq &quot;attribute&quot;) {
1424             my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1425             $attribute-&gt;isReadOnly(1);
1426             return $attribute;
1427         }
1428         if ($next-&gt;value() eq &quot;maplike&quot;) {
1429             return $self-&gt;parseMapLikeRest($extendedAttributeList, 1);
1430         }
<span class="line-added">1431         if ($next-&gt;value() eq &quot;setlike&quot;) {</span>
<span class="line-added">1432             return $self-&gt;parseSetLikeRest($extendedAttributeList, 1);</span>
<span class="line-added">1433         }</span>
1434     }
1435     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1436 }
1437 
1438 sub parseSerializer
1439 {
1440     my $self = shift;
1441     my $extendedAttributeList = shift;
1442 
1443     my $next = $self-&gt;nextToken();
1444     if ($next-&gt;value() eq &quot;serializer&quot;) {
1445         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;serializer&quot;, __LINE__);
1446         my $next = $self-&gt;nextToken();
1447         my $newDataNode;
1448         if ($next-&gt;value() ne &quot;;&quot;) {
1449             $newDataNode = $self-&gt;parseSerializerRest($extendedAttributeList);
1450             my $next = $self-&gt;nextToken();
1451         } else {
1452             $newDataNode = IDLSerializable-&gt;new();
1453         }
</pre>
<hr />
<pre>
1710         return 1;
1711     }
1712     return 0;
1713 }
1714 
1715 sub parseReadOnly
1716 {
1717     my $self = shift;
1718     my $next = $self-&gt;nextToken();
1719     if ($next-&gt;value() eq &quot;readonly&quot;) {
1720         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1721         return 1;
1722     }
1723     return 0;
1724 }
1725 
1726 sub parseOperation
1727 {
1728     my $self = shift;
1729     my $extendedAttributeList = shift;
<span class="line-added">1730     my $isReadOnly = shift;</span>
1731 
1732     my $next = $self-&gt;nextToken();
1733     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1734         return $self-&gt;parseSpecialOperation($extendedAttributeList);
1735     }
1736     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1737         my $returnType = $self-&gt;parseReturnType();
1738 
1739         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1740         # extended attributes with a return type.
1741         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1742 
1743         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1744         $operation-&gt;type($returnType);
1745 
1746         return $operation;
1747     }
1748     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1749 }
1750 
</pre>
<hr />
<pre>
1980     my $forEachOperation = IDLOperation-&gt;new();
1981     $forEachOperation-&gt;name(&quot;forEach&quot;);
1982     $forEachOperation-&gt;isMapLike(1);
1983     $forEachOperation-&gt;extendedAttributes({});
1984     $forEachOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1985     my $forEachArgument = IDLArgument-&gt;new();
1986     $forEachArgument-&gt;name(&quot;callback&quot;);
1987     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1988     $forEachArgument-&gt;extendedAttributes($extendedAttributeList);
1989     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1990 
1991     push(@{$maplike-&gt;operations}, $getOperation);
1992     push(@{$maplike-&gt;operations}, $hasOperation);
1993     push(@{$maplike-&gt;operations}, $entriesOperation);
1994     push(@{$maplike-&gt;operations}, $keysOperation);
1995     push(@{$maplike-&gt;operations}, $valuesOperation);
1996     push(@{$maplike-&gt;operations}, $forEachOperation);
1997 
1998     return $maplike if $isReadOnly;
1999 
<span class="line-added">2000     my $setOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2001     $setOperation-&gt;name(&quot;set&quot;);</span>
<span class="line-added">2002     $setOperation-&gt;isMapLike(1);</span>
<span class="line-added">2003     my $setKeyArgument = IDLArgument-&gt;new();</span>
<span class="line-added">2004     $setKeyArgument-&gt;name(&quot;key&quot;);</span>
<span class="line-added">2005     $setKeyArgument-&gt;type($maplike-&gt;keyType);</span>
<span class="line-added">2006     $setKeyArgument-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2007     my $setValueArgument = IDLArgument-&gt;new();</span>
<span class="line-added">2008     $setValueArgument-&gt;name(&quot;value&quot;);</span>
<span class="line-added">2009     $setValueArgument-&gt;type($maplike-&gt;valueType);</span>
<span class="line-added">2010     $setValueArgument-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2011     push(@{$setOperation-&gt;arguments}, ($setKeyArgument));</span>
<span class="line-added">2012     push(@{$setOperation-&gt;arguments}, ($setValueArgument));</span>
<span class="line-added">2013     $setOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);</span>
<span class="line-added">2014     $setOperation-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2015 </span>
<span class="line-added">2016     my $clearOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2017     $clearOperation-&gt;name(&quot;clear&quot;);</span>
<span class="line-added">2018     $clearOperation-&gt;isMapLike(1);</span>
<span class="line-added">2019     $clearOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);</span>
<span class="line-added">2020     $clearOperation-&gt;type(makeSimpleType(&quot;void&quot;));</span>
<span class="line-added">2021 </span>
<span class="line-added">2022     my $deleteOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2023     $deleteOperation-&gt;name(&quot;delete&quot;);</span>
<span class="line-added">2024     $deleteOperation-&gt;isMapLike(1);</span>
<span class="line-added">2025     my $deleteArgument = IDLArgument-&gt;new();</span>
<span class="line-added">2026     $deleteArgument-&gt;name(&quot;key&quot;);</span>
<span class="line-added">2027     $deleteArgument-&gt;type($maplike-&gt;keyType);</span>
<span class="line-added">2028     $deleteArgument-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2029     push(@{$deleteOperation-&gt;arguments}, ($deleteArgument));</span>
<span class="line-added">2030     $deleteOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);</span>
<span class="line-added">2031     $deleteOperation-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2032 </span>
<span class="line-added">2033     push(@{$maplike-&gt;operations}, $setOperation);</span>
<span class="line-added">2034     push(@{$maplike-&gt;operations}, $clearOperation);</span>
<span class="line-added">2035     push(@{$maplike-&gt;operations}, $deleteOperation);</span>
<span class="line-added">2036 </span>
<span class="line-added">2037     return $maplike;</span>
<span class="line-added">2038 }</span>
<span class="line-added">2039 </span>
<span class="line-added">2040 sub parseSetLikeRest</span>
<span class="line-added">2041 {</span>
<span class="line-added">2042     my $self = shift;</span>
<span class="line-added">2043     my $extendedAttributeList = shift;</span>
<span class="line-added">2044     my $isReadOnly = shift;</span>
<span class="line-added">2045 </span>
<span class="line-added">2046     my $next = $self-&gt;nextToken();</span>
<span class="line-added">2047     if ($next-&gt;value() eq &quot;setlike&quot;) {</span>
<span class="line-added">2048         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;setlike&quot;, __LINE__);</span>
<span class="line-added">2049         my $setLikeNode = $self-&gt;parseSetLikeProperties($extendedAttributeList, $isReadOnly);</span>
<span class="line-added">2050         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);</span>
<span class="line-added">2051         return $setLikeNode;</span>
<span class="line-added">2052     }</span>
<span class="line-added">2053     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);</span>
<span class="line-added">2054 }</span>
<span class="line-added">2055 </span>
<span class="line-added">2056 sub parseSetLikeProperties</span>
<span class="line-added">2057 {</span>
<span class="line-added">2058     my $self = shift;</span>
<span class="line-added">2059     my $extendedAttributeList = shift;</span>
<span class="line-added">2060     my $isReadOnly = shift;</span>
<span class="line-added">2061 </span>
<span class="line-added">2062     my $setlike = IDLSetLike-&gt;new();</span>
<span class="line-added">2063     $setlike-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2064 </span>
<span class="line-added">2065     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);</span>
<span class="line-added">2066     $setlike-&gt;itemType($self-&gt;parseTypeWithExtendedAttributes());</span>
<span class="line-added">2067     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);</span>
<span class="line-added">2068 </span>
<span class="line-added">2069     # FIXME: Synthetic operations should not be added during parsing. Instead, the CodeGenerator</span>
<span class="line-added">2070     # should be responsible for them.</span>
<span class="line-added">2071 </span>
<span class="line-added">2072     my $notEnumerableExtendedAttributeList = $extendedAttributeList;</span>
<span class="line-added">2073     $notEnumerableExtendedAttributeList-&gt;{NotEnumerable} = 1;</span>
<span class="line-added">2074 </span>
<span class="line-added">2075     my $sizeAttribute = IDLAttribute-&gt;new();</span>
<span class="line-added">2076     $sizeAttribute-&gt;name(&quot;size&quot;);</span>
<span class="line-added">2077     $sizeAttribute-&gt;isSetLike(1);</span>
<span class="line-added">2078     $sizeAttribute-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2079     $sizeAttribute-&gt;isReadOnly(1);</span>
<span class="line-added">2080     $sizeAttribute-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2081     push(@{$setlike-&gt;attributes}, $sizeAttribute);</span>
<span class="line-added">2082 </span>
<span class="line-added">2083     my $hasOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2084     $hasOperation-&gt;name(&quot;has&quot;);</span>
<span class="line-added">2085     $hasOperation-&gt;isSetLike(1);</span>
<span class="line-added">2086     my $hasArgument = IDLArgument-&gt;new();</span>
<span class="line-added">2087     $hasArgument-&gt;name(&quot;key&quot;);</span>
<span class="line-added">2088     $hasArgument-&gt;type($setlike-&gt;itemType);</span>
<span class="line-added">2089     $hasArgument-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2090     push(@{$hasOperation-&gt;arguments}, ($hasArgument));</span>
<span class="line-added">2091     $hasOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);</span>
<span class="line-added">2092     $hasOperation-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2093 </span>
<span class="line-added">2094     my $entriesOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2095     $entriesOperation-&gt;name(&quot;entries&quot;);</span>
<span class="line-added">2096     $entriesOperation-&gt;isSetLike(1);</span>
<span class="line-added">2097     $entriesOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);</span>
<span class="line-added">2098     $entriesOperation-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2099 </span>
<span class="line-added">2100     my $keysOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2101     $keysOperation-&gt;name(&quot;keys&quot;);</span>
<span class="line-added">2102     $keysOperation-&gt;isSetLike(1);</span>
<span class="line-added">2103     $keysOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);</span>
<span class="line-added">2104     $keysOperation-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2105 </span>
<span class="line-added">2106     my $valuesOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2107     $valuesOperation-&gt;name(&quot;values&quot;);</span>
<span class="line-added">2108     $valuesOperation-&gt;isSetLike(1);</span>
<span class="line-added">2109     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2110     $valuesOperation-&gt;extendedAttributes-&gt;{NotEnumerable} = 1;</span>
<span class="line-added">2111     $valuesOperation-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2112 </span>
<span class="line-added">2113     my $forEachOperation = IDLOperation-&gt;new();</span>
<span class="line-added">2114     $forEachOperation-&gt;name(&quot;forEach&quot;);</span>
<span class="line-added">2115     $forEachOperation-&gt;isSetLike(1);</span>
<span class="line-added">2116     my $forEachArgument = IDLArgument-&gt;new();</span>
<span class="line-added">2117     $forEachArgument-&gt;name(&quot;callback&quot;);</span>
<span class="line-added">2118     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2119     $forEachArgument-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2120     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));</span>
<span class="line-added">2121     $forEachOperation-&gt;extendedAttributes($extendedAttributeList);</span>
<span class="line-added">2122     $forEachOperation-&gt;extendedAttributes-&gt;{Enumerable} = 1;</span>
<span class="line-added">2123     $forEachOperation-&gt;type(makeSimpleType(&quot;any&quot;));</span>
<span class="line-added">2124 </span>
<span class="line-added">2125     push(@{$setlike-&gt;operations}, $hasOperation);</span>
<span class="line-added">2126     push(@{$setlike-&gt;operations}, $entriesOperation);</span>
<span class="line-added">2127     push(@{$setlike-&gt;operations}, $keysOperation);</span>
<span class="line-added">2128     push(@{$setlike-&gt;operations}, $valuesOperation);</span>
<span class="line-added">2129     push(@{$setlike-&gt;operations}, $forEachOperation);</span>
<span class="line-added">2130 </span>
<span class="line-added">2131     return $setlike if $isReadOnly;</span>
<span class="line-added">2132 </span>
2133     my $addOperation = IDLOperation-&gt;new();
2134     $addOperation-&gt;name(&quot;add&quot;);
<span class="line-modified">2135     $addOperation-&gt;isSetLike(1);</span>
2136     my $addArgument = IDLArgument-&gt;new();
2137     $addArgument-&gt;name(&quot;key&quot;);
<span class="line-modified">2138     $addArgument-&gt;type($setlike-&gt;itemType);</span>
2139     $addArgument-&gt;extendedAttributes($extendedAttributeList);
2140     push(@{$addOperation-&gt;arguments}, ($addArgument));
2141     $addOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2142     $addOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2143 
2144     my $clearOperation = IDLOperation-&gt;new();
2145     $clearOperation-&gt;name(&quot;clear&quot;);
<span class="line-modified">2146     $clearOperation-&gt;isSetLike(1);</span>
2147     $clearOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2148     $clearOperation-&gt;type(makeSimpleType(&quot;void&quot;));
2149 
2150     my $deleteOperation = IDLOperation-&gt;new();
2151     $deleteOperation-&gt;name(&quot;delete&quot;);
<span class="line-modified">2152     $deleteOperation-&gt;isSetLike(1);</span>
2153     my $deleteArgument = IDLArgument-&gt;new();
2154     $deleteArgument-&gt;name(&quot;key&quot;);
<span class="line-modified">2155     $deleteArgument-&gt;type($setlike-&gt;itemType);</span>
2156     $deleteArgument-&gt;extendedAttributes($extendedAttributeList);
2157     push(@{$deleteOperation-&gt;arguments}, ($deleteArgument));
2158     $deleteOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2159     $deleteOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2160 
<span class="line-modified">2161     push(@{$setlike-&gt;operations}, $addOperation);</span>
<span class="line-modified">2162     push(@{$setlike-&gt;operations}, $clearOperation);</span>
<span class="line-modified">2163     push(@{$setlike-&gt;operations}, $deleteOperation);</span>
2164 
<span class="line-modified">2165     return $setlike;</span>
2166 }
2167 
2168 sub parseOperationRest
2169 {
2170     my $self = shift;
2171     my $extendedAttributeList = shift;
2172 
2173     my $next = $self-&gt;nextToken();
2174     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
2175         my $operation = IDLOperation-&gt;new();
2176 
2177         my $name = $self-&gt;parseOptionalIdentifier();
2178         $operation-&gt;name(identifierRemoveNullablePrefix($name));
2179 
2180         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, $name, __LINE__);
2181 
2182         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
2183 
2184         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2185         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
</pre>
<hr />
<pre>
2998     my $interface = shift;
2999     my $members = shift;
3000 
3001     for my $item (@{$members}) {
3002         if (ref($item) eq &quot;IDLAttribute&quot;) {
3003             push(@{$interface-&gt;attributes}, $item);
3004             next;
3005         }
3006         if (ref($item) eq &quot;IDLConstant&quot;) {
3007             push(@{$interface-&gt;constants}, $item);
3008             next;
3009         }
3010         if (ref($item) eq &quot;IDLIterable&quot;) {
3011             $interface-&gt;iterable($item);
3012             next;
3013         }
3014         if (ref($item) eq &quot;IDLMapLike&quot;) {
3015             $interface-&gt;mapLike($item);
3016             next;
3017         }
<span class="line-added">3018         if (ref($item) eq &quot;IDLSetLike&quot;) {</span>
<span class="line-added">3019             $interface-&gt;setLike($item);</span>
<span class="line-added">3020             next;</span>
<span class="line-added">3021         }</span>
3022         if (ref($item) eq &quot;IDLOperation&quot;) {
3023             if ($item-&gt;name eq &quot;&quot;) {
3024                 push(@{$interface-&gt;anonymousOperations}, $item);
3025             } else {
3026                 push(@{$interface-&gt;operations}, $item);
3027             }
3028             next;
3029         }
3030         if (ref($item) eq &quot;IDLSerializable&quot;) {
3031             $interface-&gt;serializable($item);
3032             next;
3033         }
3034     }
3035 
3036     if ($interface-&gt;serializable) {
3037         my $numSerializerAttributes = @{$interface-&gt;serializable-&gt;attributes};
3038         if ($interface-&gt;serializable-&gt;hasAttribute) {
3039             foreach my $attribute (@{$interface-&gt;attributes}) {
3040                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
3041             }
</pre>
</td>
</tr>
</table>
<center><a href="IDLAttributes.json.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="generate-bindings-all.pl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
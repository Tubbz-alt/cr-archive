<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ResourceRequestBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceResponseBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 77 }
 78 
 79 ResourceResponseBase::CrossThreadData ResourceResponseBase::crossThreadData() const
 80 {
 81     CrossThreadData data;
 82 
 83     data.url = url().isolatedCopy();
 84     data.mimeType = mimeType().isolatedCopy();
 85     data.expectedContentLength = expectedContentLength();
 86     data.textEncodingName = textEncodingName().isolatedCopy();
 87 
 88     data.httpStatusCode = httpStatusCode();
 89     data.httpStatusText = httpStatusText().isolatedCopy();
 90     data.httpVersion = httpVersion().isolatedCopy();
 91 
 92     data.httpHeaderFields = httpHeaderFields().isolatedCopy();
 93     data.networkLoadMetrics = m_networkLoadMetrics.isolatedCopy();
 94     data.type = m_type;
 95     data.tainting = m_tainting;
 96     data.isRedirected = m_isRedirected;

 97 
 98     return data;
 99 }
100 
101 ResourceResponse ResourceResponseBase::fromCrossThreadData(CrossThreadData&amp;&amp; data)
102 {
103     ResourceResponse response;
104 
105     response.setURL(data.url);
106     response.setMimeType(data.mimeType);
107     response.setExpectedContentLength(data.expectedContentLength);
108     response.setTextEncodingName(data.textEncodingName);
109 
110     response.setHTTPStatusCode(data.httpStatusCode);
111     response.setHTTPStatusText(data.httpStatusText);
112     response.setHTTPVersion(data.httpVersion);
113 
114     response.m_httpHeaderFields = WTFMove(data.httpHeaderFields);
115     response.m_networkLoadMetrics = data.networkLoadMetrics;
116     response.m_type = data.type;
117     response.m_tainting = data.tainting;
118     response.m_isRedirected = data.isRedirected;

119 
120     return response;
121 }
122 
123 ResourceResponse ResourceResponseBase::syntheticRedirectResponse(const URL&amp; fromURL, const URL&amp; toURL)
124 {
125     ResourceResponse redirectResponse;
126     redirectResponse.setURL(fromURL);
127     redirectResponse.setHTTPStatusCode(302);
128     redirectResponse.setHTTPVersion(&quot;HTTP/1.1&quot;_s);
129     redirectResponse.setHTTPHeaderField(HTTPHeaderName::Location, toURL.string());
130     redirectResponse.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;no-store&quot;_s);
131 
132     return redirectResponse;
133 }
134 
135 ResourceResponse ResourceResponseBase::filter(const ResourceResponse&amp; response)
136 {
137     if (response.tainting() == Tainting::Opaque) {
138         ResourceResponse opaqueResponse;
</pre>
<hr />
<pre>
242     return m_textEncodingName;
243 }
244 
245 void ResourceResponseBase::setTextEncodingName(const String&amp; encodingName)
246 {
247     lazyInit(CommonFieldsOnly);
248     m_isNull = false;
249 
250     // FIXME: Text encoding is determined by HTTP Content-Type header. We should update the header, so that it doesn&#39;t disagree with m_textEncodingName.
251     m_textEncodingName = encodingName;
252 
253     // FIXME: Should invalidate or update platform response if present.
254 }
255 
256 void ResourceResponseBase::setType(Type type)
257 {
258     m_isNull = false;
259     m_type = type;
260 }
261 
<span class="line-modified">262 void ResourceResponseBase::includeCertificateInfo() const</span>
263 {
264     if (m_certificateInfo)
265         return;
266     m_certificateInfo = static_cast&lt;const ResourceResponse*&gt;(this)-&gt;platformCertificateInfo();

267 }
268 
269 String ResourceResponseBase::suggestedFilename() const
270 {
271     return static_cast&lt;const ResourceResponse*&gt;(this)-&gt;platformSuggestedFilename();
272 }
273 
274 String ResourceResponseBase::sanitizeSuggestedFilename(const String&amp; suggestedFilename)
275 {
276     if (suggestedFilename.isEmpty())
277         return suggestedFilename;
278 
279     ResourceResponse response(URL({ }, &quot;http://example.com/&quot;), String(), -1, String());
280     response.setHTTPStatusCode(200);
281     String escapedSuggestedFilename = String(suggestedFilename).replace(&#39;\\&#39;, &quot;\\\\&quot;).replace(&#39;&quot;&#39;, &quot;\\\&quot;&quot;);
282     String value = makeString(&quot;attachment; filename=\&quot;&quot;, escapedSuggestedFilename, &#39;&quot;&#39;);
283     response.setHTTPHeaderField(HTTPHeaderName::ContentDisposition, value);
284     return response.suggestedFilename();
285 }
286 
</pre>
<hr />
<pre>
638 {
639     if (!m_haveParsedCacheControlHeader)
640         parseCacheControlDirectives();
641     return m_cacheControlDirectives.immutable;
642 }
643 
644 bool ResourceResponseBase::hasCacheValidatorFields() const
645 {
646     lazyInit(CommonFieldsOnly);
647 
648     return !m_httpHeaderFields.get(HTTPHeaderName::LastModified).isEmpty() || !m_httpHeaderFields.get(HTTPHeaderName::ETag).isEmpty();
649 }
650 
651 Optional&lt;Seconds&gt; ResourceResponseBase::cacheControlMaxAge() const
652 {
653     if (!m_haveParsedCacheControlHeader)
654         parseCacheControlDirectives();
655     return m_cacheControlDirectives.maxAge;
656 }
657 







658 static Optional&lt;WallTime&gt; parseDateValueInHeader(const HTTPHeaderMap&amp; headers, HTTPHeaderName headerName)
659 {
660     String headerValue = headers.get(headerName);
661     if (headerValue.isEmpty())
662         return WTF::nullopt;
663     // This handles all date formats required by RFC2616:
664     // Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
665     // Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
666     // Sun Nov  6 08:49:37 1994       ; ANSI C&#39;s asctime() format
667     return parseHTTPDate(headerValue);
668 }
669 
670 Optional&lt;WallTime&gt; ResourceResponseBase::date() const
671 {
672     lazyInit(CommonFieldsOnly);
673 
674     if (!m_haveParsedDateHeader) {
675         m_date = parseDateValueInHeader(m_httpHeaderFields, HTTPHeaderName::Date);
676         m_haveParsedDateHeader = true;
677     }
</pre>
</td>
<td>
<hr />
<pre>
 77 }
 78 
 79 ResourceResponseBase::CrossThreadData ResourceResponseBase::crossThreadData() const
 80 {
 81     CrossThreadData data;
 82 
 83     data.url = url().isolatedCopy();
 84     data.mimeType = mimeType().isolatedCopy();
 85     data.expectedContentLength = expectedContentLength();
 86     data.textEncodingName = textEncodingName().isolatedCopy();
 87 
 88     data.httpStatusCode = httpStatusCode();
 89     data.httpStatusText = httpStatusText().isolatedCopy();
 90     data.httpVersion = httpVersion().isolatedCopy();
 91 
 92     data.httpHeaderFields = httpHeaderFields().isolatedCopy();
 93     data.networkLoadMetrics = m_networkLoadMetrics.isolatedCopy();
 94     data.type = m_type;
 95     data.tainting = m_tainting;
 96     data.isRedirected = m_isRedirected;
<span class="line-added"> 97     data.isRangeRequested = m_isRangeRequested;</span>
 98 
 99     return data;
100 }
101 
102 ResourceResponse ResourceResponseBase::fromCrossThreadData(CrossThreadData&amp;&amp; data)
103 {
104     ResourceResponse response;
105 
106     response.setURL(data.url);
107     response.setMimeType(data.mimeType);
108     response.setExpectedContentLength(data.expectedContentLength);
109     response.setTextEncodingName(data.textEncodingName);
110 
111     response.setHTTPStatusCode(data.httpStatusCode);
112     response.setHTTPStatusText(data.httpStatusText);
113     response.setHTTPVersion(data.httpVersion);
114 
115     response.m_httpHeaderFields = WTFMove(data.httpHeaderFields);
116     response.m_networkLoadMetrics = data.networkLoadMetrics;
117     response.m_type = data.type;
118     response.m_tainting = data.tainting;
119     response.m_isRedirected = data.isRedirected;
<span class="line-added">120     response.m_isRangeRequested = data.isRangeRequested;</span>
121 
122     return response;
123 }
124 
125 ResourceResponse ResourceResponseBase::syntheticRedirectResponse(const URL&amp; fromURL, const URL&amp; toURL)
126 {
127     ResourceResponse redirectResponse;
128     redirectResponse.setURL(fromURL);
129     redirectResponse.setHTTPStatusCode(302);
130     redirectResponse.setHTTPVersion(&quot;HTTP/1.1&quot;_s);
131     redirectResponse.setHTTPHeaderField(HTTPHeaderName::Location, toURL.string());
132     redirectResponse.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;no-store&quot;_s);
133 
134     return redirectResponse;
135 }
136 
137 ResourceResponse ResourceResponseBase::filter(const ResourceResponse&amp; response)
138 {
139     if (response.tainting() == Tainting::Opaque) {
140         ResourceResponse opaqueResponse;
</pre>
<hr />
<pre>
244     return m_textEncodingName;
245 }
246 
247 void ResourceResponseBase::setTextEncodingName(const String&amp; encodingName)
248 {
249     lazyInit(CommonFieldsOnly);
250     m_isNull = false;
251 
252     // FIXME: Text encoding is determined by HTTP Content-Type header. We should update the header, so that it doesn&#39;t disagree with m_textEncodingName.
253     m_textEncodingName = encodingName;
254 
255     // FIXME: Should invalidate or update platform response if present.
256 }
257 
258 void ResourceResponseBase::setType(Type type)
259 {
260     m_isNull = false;
261     m_type = type;
262 }
263 
<span class="line-modified">264 void ResourceResponseBase::includeCertificateInfo(UsedLegacyTLS usedLegacyTLS) const</span>
265 {
266     if (m_certificateInfo)
267         return;
268     m_certificateInfo = static_cast&lt;const ResourceResponse*&gt;(this)-&gt;platformCertificateInfo();
<span class="line-added">269     m_usedLegacyTLS = usedLegacyTLS;</span>
270 }
271 
272 String ResourceResponseBase::suggestedFilename() const
273 {
274     return static_cast&lt;const ResourceResponse*&gt;(this)-&gt;platformSuggestedFilename();
275 }
276 
277 String ResourceResponseBase::sanitizeSuggestedFilename(const String&amp; suggestedFilename)
278 {
279     if (suggestedFilename.isEmpty())
280         return suggestedFilename;
281 
282     ResourceResponse response(URL({ }, &quot;http://example.com/&quot;), String(), -1, String());
283     response.setHTTPStatusCode(200);
284     String escapedSuggestedFilename = String(suggestedFilename).replace(&#39;\\&#39;, &quot;\\\\&quot;).replace(&#39;&quot;&#39;, &quot;\\\&quot;&quot;);
285     String value = makeString(&quot;attachment; filename=\&quot;&quot;, escapedSuggestedFilename, &#39;&quot;&#39;);
286     response.setHTTPHeaderField(HTTPHeaderName::ContentDisposition, value);
287     return response.suggestedFilename();
288 }
289 
</pre>
<hr />
<pre>
641 {
642     if (!m_haveParsedCacheControlHeader)
643         parseCacheControlDirectives();
644     return m_cacheControlDirectives.immutable;
645 }
646 
647 bool ResourceResponseBase::hasCacheValidatorFields() const
648 {
649     lazyInit(CommonFieldsOnly);
650 
651     return !m_httpHeaderFields.get(HTTPHeaderName::LastModified).isEmpty() || !m_httpHeaderFields.get(HTTPHeaderName::ETag).isEmpty();
652 }
653 
654 Optional&lt;Seconds&gt; ResourceResponseBase::cacheControlMaxAge() const
655 {
656     if (!m_haveParsedCacheControlHeader)
657         parseCacheControlDirectives();
658     return m_cacheControlDirectives.maxAge;
659 }
660 
<span class="line-added">661 Optional&lt;Seconds&gt; ResourceResponseBase::cacheControlStaleWhileRevalidate() const</span>
<span class="line-added">662 {</span>
<span class="line-added">663     if (!m_haveParsedCacheControlHeader)</span>
<span class="line-added">664         parseCacheControlDirectives();</span>
<span class="line-added">665     return m_cacheControlDirectives.staleWhileRevalidate;</span>
<span class="line-added">666 }</span>
<span class="line-added">667 </span>
668 static Optional&lt;WallTime&gt; parseDateValueInHeader(const HTTPHeaderMap&amp; headers, HTTPHeaderName headerName)
669 {
670     String headerValue = headers.get(headerName);
671     if (headerValue.isEmpty())
672         return WTF::nullopt;
673     // This handles all date formats required by RFC2616:
674     // Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123
675     // Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036
676     // Sun Nov  6 08:49:37 1994       ; ANSI C&#39;s asctime() format
677     return parseHTTPDate(headerValue);
678 }
679 
680 Optional&lt;WallTime&gt; ResourceResponseBase::date() const
681 {
682     lazyInit(CommonFieldsOnly);
683 
684     if (!m_haveParsedDateHeader) {
685         m_date = parseDateValueInHeader(m_httpHeaderFields, HTTPHeaderName::Date);
686         m_haveParsedDateHeader = true;
687     }
</pre>
</td>
</tr>
</table>
<center><a href="ResourceRequestBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceResponseBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
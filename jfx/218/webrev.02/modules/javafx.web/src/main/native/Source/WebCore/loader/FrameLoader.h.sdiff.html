<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameLoaderClient.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/FrameLoader.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 21  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 22  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 23  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 24  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 25  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 26  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 27  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 29  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #pragma once
 33 
 34 #include &quot;AdClickAttribution.h&quot;
 35 #include &quot;CachePolicy.h&quot;
 36 #include &quot;FrameLoaderStateMachine.h&quot;
 37 #include &quot;FrameLoaderTypes.h&quot;
 38 #include &quot;LayoutMilestone.h&quot;
 39 #include &quot;MixedContentChecker.h&quot;

 40 #include &quot;ReferrerPolicy.h&quot;
 41 #include &quot;ResourceLoadNotifier.h&quot;
 42 #include &quot;ResourceLoaderOptions.h&quot;
 43 #include &quot;ResourceRequestBase.h&quot;
 44 #include &quot;SecurityContext.h&quot;
 45 #include &quot;StoredCredentialsPolicy.h&quot;
 46 #include &quot;Timer.h&quot;
 47 #include &lt;wtf/CompletionHandler.h&gt;
 48 #include &lt;wtf/Forward.h&gt;
 49 #include &lt;wtf/HashSet.h&gt;
 50 #include &lt;wtf/OptionSet.h&gt;
 51 #include &lt;wtf/Optional.h&gt;
 52 #include &lt;wtf/WallTime.h&gt;
 53 
 54 namespace WebCore {
 55 
 56 class Archive;
 57 class CachedFrame;
 58 class CachedFrameBase;
 59 class CachedPage;
</pre>
<hr />
<pre>
 67 class FormSubmission;
 68 class FrameLoadRequest;
 69 class FrameLoaderClient;
 70 class FrameNetworkingContext;
 71 class HistoryController;
 72 class HistoryItem;
 73 class NavigationAction;
 74 class NetworkingContext;
 75 class Node;
 76 class Page;
 77 class PolicyChecker;
 78 class ResourceError;
 79 class ResourceRequest;
 80 class ResourceResponse;
 81 class SerializedScriptValue;
 82 class SharedBuffer;
 83 class SubframeLoader;
 84 class SubstituteData;
 85 
 86 enum class NewLoadInProgress : bool;
<span class="line-removed"> 87 enum class ShouldContinue;</span>
 88 enum class NavigationPolicyDecision : uint8_t;
 89 enum class ShouldTreatAsContinuingLoad : bool;
 90 
 91 struct WindowFeatures;
 92 
 93 WEBCORE_EXPORT bool isBackForwardLoadType(FrameLoadType);
 94 WEBCORE_EXPORT bool isReload(FrameLoadType);
 95 
 96 using ContentPolicyDecisionFunction = WTF::Function&lt;void(PolicyAction, PolicyCheckIdentifier)&gt;;
 97 
 98 class FrameLoader final {
 99     WTF_MAKE_FAST_ALLOCATED;
100     WTF_MAKE_NONCOPYABLE(FrameLoader);
101 public:
102     FrameLoader(Frame&amp;, FrameLoaderClient&amp;);
103     ~FrameLoader();
104 
105     WEBCORE_EXPORT void init();
106     void initForSynthesizedDocument(const URL&amp;);
107 
</pre>
<hr />
<pre>
130     WEBCORE_EXPORT void urlSelected(const URL&amp;, const String&amp; target, Event*, LockHistory, LockBackForwardList, ShouldSendReferrer, ShouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; = WTF::nullopt, const AtomString&amp; downloadAttribute = nullAtom(), const SystemPreviewInfo&amp; = { }, Optional&lt;AdClickAttribution&gt;&amp;&amp; = WTF::nullopt);
131     void submitForm(Ref&lt;FormSubmission&gt;&amp;&amp;);
132 
133     WEBCORE_EXPORT void reload(OptionSet&lt;ReloadOption&gt; = { });
134     WEBCORE_EXPORT void reloadWithOverrideEncoding(const String&amp; overrideEncoding);
135 
136     void open(CachedFrameBase&amp;);
137     void loadItem(HistoryItem&amp;, HistoryItem* fromItem, FrameLoadType, ShouldTreatAsContinuingLoad);
138     HistoryItem* requestedHistoryItem() const { return m_requestedHistoryItem.get(); }
139 
140     void retryAfterFailedCacheOnlyMainResourceLoad();
141 
142     static void reportLocalLoadFailed(Frame*, const String&amp; url);
143     static void reportBlockedPortFailed(Frame*, const String&amp; url);
144     static void reportAuthenticationChallengeBlocked(Frame*, const URL&amp;, const String&amp; reason);
145 
146     // FIXME: These are all functions which stop loads. We have too many.
147     void stopAllLoadersAndCheckCompleteness();
148     WEBCORE_EXPORT void stopAllLoaders(ClearProvisionalItemPolicy = ShouldClearProvisionalItem, StopLoadingPolicy = StopLoadingPolicy::PreventDuringUnloadEvents);
149     WEBCORE_EXPORT void stopForUserCancel(bool deferCheckLoadComplete = false);

150     void stop();
151     void stopLoading(UnloadEventPolicy);
152     bool closeURL();
153     void cancelAndClear();
154     void clearProvisionalLoadForPolicyCheck();
155     // FIXME: clear() is trying to do too many things. We should break it down into smaller functions (ideally with fewer raw Boolean parameters).
156     void clear(Document* newDocument, bool clearWindowProperties = true, bool clearScriptObjects = true, bool clearFrameView = true, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation = nullptr);
157 
158     bool isLoading() const;
159     WEBCORE_EXPORT bool frameHasLoaded() const;
160 
161     WEBCORE_EXPORT int numPendingOrLoadingRequests(bool recurse) const;
162 
163     ReferrerPolicy effectiveReferrerPolicy() const;
164     String referrer() const;
165     WEBCORE_EXPORT String outgoingReferrer() const;
166     String outgoingOrigin() const;
167 
168     WEBCORE_EXPORT DocumentLoader* activeDocumentLoader() const;
169     DocumentLoader* documentLoader() const { return m_documentLoader.get(); }
</pre>
<hr />
<pre>
214     void checkLoadComplete();
215     WEBCORE_EXPORT void detachFromParent();
216     void detachViewsAndDocumentLoader();
217 
218     void addExtraFieldsToSubresourceRequest(ResourceRequest&amp;);
219     void addExtraFieldsToMainResourceRequest(ResourceRequest&amp;);
220 
221     static void addHTTPOriginIfNeeded(ResourceRequest&amp;, const String&amp; origin);
222     static void addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp;);
223     static void addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp;, const Document* initiator = nullptr);
224 
225     FrameLoaderClient&amp; client() const { return m_client; }
226 
227     void setDefersLoading(bool);
228 
229     void checkContentPolicy(const ResourceResponse&amp;, PolicyCheckIdentifier, ContentPolicyDecisionFunction&amp;&amp;);
230 
231     void didExplicitOpen();
232 
233     // Callbacks from DocumentWriter
<span class="line-modified">234     void didBeginDocument(bool dispatchWindowObjectAvailable, ContentSecurityPolicy* previousPolicy);</span>
235 
236     void receivedFirstData();
237 
238     void dispatchOnloadEvents();
239     String userAgent(const URL&amp;) const;
<span class="line-removed">240     String userAgentForJavaScript(const URL&amp;) const;</span>
241     String navigatorPlatform() const;
242 
243     void dispatchDidClearWindowObjectInWorld(DOMWrapperWorld&amp;);
244     void dispatchDidClearWindowObjectsInAllWorlds();
245 
246     // The following sandbox flags will be forced, regardless of changes to
247     // the sandbox attribute of any parent frames.
248     void forceSandboxFlags(SandboxFlags flags) { m_forcedSandboxFlags |= flags; }
249     SandboxFlags effectiveSandboxFlags() const;
250 
251     bool checkIfFormActionAllowedByCSP(const URL&amp;, bool didReceiveRedirectResponse) const;
252 
253     WEBCORE_EXPORT Frame* opener();
254     WEBCORE_EXPORT void setOpener(Frame*);

255     bool hasOpenedFrames() const { return !m_openedFrames.isEmpty(); }
256 
257     void resetMultipleFormSubmissionProtection();
258 
259     void checkCallImplicitClose();
260 
261     void frameDetached();
262 
263     void setOutgoingReferrer(const URL&amp;);
264 
265     void loadDone(LoadCompletionType);
266     void subresourceLoadDone(LoadCompletionType);
267     void finishedParsing();
268     void checkCompleted();
269 
270     WEBCORE_EXPORT bool isComplete() const;
271 
272     void commitProvisionalLoad();
273 
274     void setLoadsSynchronously(bool loadsSynchronously) { m_loadsSynchronously = loadsSynchronously; }
</pre>
<hr />
<pre>
339     void loadDifferentDocumentItem(HistoryItem&amp;, HistoryItem* fromItem, FrameLoadType, FormSubmissionCacheLoadPolicy, ShouldTreatAsContinuingLoad);
340 
341     void loadProvisionalItemFromCachedPage();
342 
343     void updateFirstPartyForCookies();
344     void setFirstPartyForCookies(const URL&amp;);
345 
346     void addExtraFieldsToRequest(ResourceRequest&amp;, FrameLoadType, bool isMainResource);
347     ResourceRequestCachePolicy defaultRequestCachingPolicy(const ResourceRequest&amp;, FrameLoadType, bool isMainResource);
348 
349     void clearProvisionalLoad();
350     void transitionToCommitted(CachedPage*);
351     void frameLoadCompleted();
352 
353     SubstituteData defaultSubstituteDataForURL(const URL&amp;);
354 
355     bool dispatchBeforeUnloadEvent(Chrome&amp;, FrameLoader* frameLoaderBeingNavigated);
356     void dispatchUnloadEvents(UnloadEventPolicy);
357 
358     void continueLoadAfterNavigationPolicy(const ResourceRequest&amp;, FormState*, NavigationPolicyDecision, AllowNavigationToInvalidURL);
<span class="line-modified">359     void continueLoadAfterNewWindowPolicy(const ResourceRequest&amp;, FormState*, const String&amp; frameName, const NavigationAction&amp;, ShouldContinue, AllowNavigationToInvalidURL, NewFrameOpenerPolicy);</span>
360     void continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp;, bool shouldContinue);
361 
362     bool shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType, const URL&amp;);
363     void scrollToFragmentWithParentBoundary(const URL&amp;, bool isNewNavigation = true);
364 
365     void dispatchDidFailProvisionalLoad(DocumentLoader&amp; provisionalDocumentLoader, const ResourceError&amp;);
366     void checkLoadCompleteForThisFrame();
367 
368     void setDocumentLoader(DocumentLoader*);
369     void setPolicyDocumentLoader(DocumentLoader*);
370     void setProvisionalDocumentLoader(DocumentLoader*);
371 
372     void setState(FrameState);
373 
374     void closeOldDataSources();
375     void willRestoreFromCachedPage();
376 
377     bool shouldReloadToHandleUnreachableURL(DocumentLoader&amp;);
378 
379     void dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt; initialHasInsecureContent);
</pre>
</td>
<td>
<hr />
<pre>
 20  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 21  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 22  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 23  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 24  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 25  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 26  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 27  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 29  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #pragma once
 33 
 34 #include &quot;AdClickAttribution.h&quot;
 35 #include &quot;CachePolicy.h&quot;
 36 #include &quot;FrameLoaderStateMachine.h&quot;
 37 #include &quot;FrameLoaderTypes.h&quot;
 38 #include &quot;LayoutMilestone.h&quot;
 39 #include &quot;MixedContentChecker.h&quot;
<span class="line-added"> 40 #include &quot;PolicyChecker.h&quot;</span>
 41 #include &quot;ReferrerPolicy.h&quot;
 42 #include &quot;ResourceLoadNotifier.h&quot;
 43 #include &quot;ResourceLoaderOptions.h&quot;
 44 #include &quot;ResourceRequestBase.h&quot;
 45 #include &quot;SecurityContext.h&quot;
 46 #include &quot;StoredCredentialsPolicy.h&quot;
 47 #include &quot;Timer.h&quot;
 48 #include &lt;wtf/CompletionHandler.h&gt;
 49 #include &lt;wtf/Forward.h&gt;
 50 #include &lt;wtf/HashSet.h&gt;
 51 #include &lt;wtf/OptionSet.h&gt;
 52 #include &lt;wtf/Optional.h&gt;
 53 #include &lt;wtf/WallTime.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 class Archive;
 58 class CachedFrame;
 59 class CachedFrameBase;
 60 class CachedPage;
</pre>
<hr />
<pre>
 68 class FormSubmission;
 69 class FrameLoadRequest;
 70 class FrameLoaderClient;
 71 class FrameNetworkingContext;
 72 class HistoryController;
 73 class HistoryItem;
 74 class NavigationAction;
 75 class NetworkingContext;
 76 class Node;
 77 class Page;
 78 class PolicyChecker;
 79 class ResourceError;
 80 class ResourceRequest;
 81 class ResourceResponse;
 82 class SerializedScriptValue;
 83 class SharedBuffer;
 84 class SubframeLoader;
 85 class SubstituteData;
 86 
 87 enum class NewLoadInProgress : bool;

 88 enum class NavigationPolicyDecision : uint8_t;
 89 enum class ShouldTreatAsContinuingLoad : bool;
 90 
 91 struct WindowFeatures;
 92 
 93 WEBCORE_EXPORT bool isBackForwardLoadType(FrameLoadType);
 94 WEBCORE_EXPORT bool isReload(FrameLoadType);
 95 
 96 using ContentPolicyDecisionFunction = WTF::Function&lt;void(PolicyAction, PolicyCheckIdentifier)&gt;;
 97 
 98 class FrameLoader final {
 99     WTF_MAKE_FAST_ALLOCATED;
100     WTF_MAKE_NONCOPYABLE(FrameLoader);
101 public:
102     FrameLoader(Frame&amp;, FrameLoaderClient&amp;);
103     ~FrameLoader();
104 
105     WEBCORE_EXPORT void init();
106     void initForSynthesizedDocument(const URL&amp;);
107 
</pre>
<hr />
<pre>
130     WEBCORE_EXPORT void urlSelected(const URL&amp;, const String&amp; target, Event*, LockHistory, LockBackForwardList, ShouldSendReferrer, ShouldOpenExternalURLsPolicy, Optional&lt;NewFrameOpenerPolicy&gt; = WTF::nullopt, const AtomString&amp; downloadAttribute = nullAtom(), const SystemPreviewInfo&amp; = { }, Optional&lt;AdClickAttribution&gt;&amp;&amp; = WTF::nullopt);
131     void submitForm(Ref&lt;FormSubmission&gt;&amp;&amp;);
132 
133     WEBCORE_EXPORT void reload(OptionSet&lt;ReloadOption&gt; = { });
134     WEBCORE_EXPORT void reloadWithOverrideEncoding(const String&amp; overrideEncoding);
135 
136     void open(CachedFrameBase&amp;);
137     void loadItem(HistoryItem&amp;, HistoryItem* fromItem, FrameLoadType, ShouldTreatAsContinuingLoad);
138     HistoryItem* requestedHistoryItem() const { return m_requestedHistoryItem.get(); }
139 
140     void retryAfterFailedCacheOnlyMainResourceLoad();
141 
142     static void reportLocalLoadFailed(Frame*, const String&amp; url);
143     static void reportBlockedPortFailed(Frame*, const String&amp; url);
144     static void reportAuthenticationChallengeBlocked(Frame*, const URL&amp;, const String&amp; reason);
145 
146     // FIXME: These are all functions which stop loads. We have too many.
147     void stopAllLoadersAndCheckCompleteness();
148     WEBCORE_EXPORT void stopAllLoaders(ClearProvisionalItemPolicy = ShouldClearProvisionalItem, StopLoadingPolicy = StopLoadingPolicy::PreventDuringUnloadEvents);
149     WEBCORE_EXPORT void stopForUserCancel(bool deferCheckLoadComplete = false);
<span class="line-added">150     void stopForBackForwardCache();</span>
151     void stop();
152     void stopLoading(UnloadEventPolicy);
153     bool closeURL();
154     void cancelAndClear();
155     void clearProvisionalLoadForPolicyCheck();
156     // FIXME: clear() is trying to do too many things. We should break it down into smaller functions (ideally with fewer raw Boolean parameters).
157     void clear(Document* newDocument, bool clearWindowProperties = true, bool clearScriptObjects = true, bool clearFrameView = true, WTF::Function&lt;void()&gt;&amp;&amp; handleDOMWindowCreation = nullptr);
158 
159     bool isLoading() const;
160     WEBCORE_EXPORT bool frameHasLoaded() const;
161 
162     WEBCORE_EXPORT int numPendingOrLoadingRequests(bool recurse) const;
163 
164     ReferrerPolicy effectiveReferrerPolicy() const;
165     String referrer() const;
166     WEBCORE_EXPORT String outgoingReferrer() const;
167     String outgoingOrigin() const;
168 
169     WEBCORE_EXPORT DocumentLoader* activeDocumentLoader() const;
170     DocumentLoader* documentLoader() const { return m_documentLoader.get(); }
</pre>
<hr />
<pre>
215     void checkLoadComplete();
216     WEBCORE_EXPORT void detachFromParent();
217     void detachViewsAndDocumentLoader();
218 
219     void addExtraFieldsToSubresourceRequest(ResourceRequest&amp;);
220     void addExtraFieldsToMainResourceRequest(ResourceRequest&amp;);
221 
222     static void addHTTPOriginIfNeeded(ResourceRequest&amp;, const String&amp; origin);
223     static void addHTTPUpgradeInsecureRequestsIfNeeded(ResourceRequest&amp;);
224     static void addSameSiteInfoToRequestIfNeeded(ResourceRequest&amp;, const Document* initiator = nullptr);
225 
226     FrameLoaderClient&amp; client() const { return m_client; }
227 
228     void setDefersLoading(bool);
229 
230     void checkContentPolicy(const ResourceResponse&amp;, PolicyCheckIdentifier, ContentPolicyDecisionFunction&amp;&amp;);
231 
232     void didExplicitOpen();
233 
234     // Callbacks from DocumentWriter
<span class="line-modified">235     void didBeginDocument(bool dispatchWindowObjectAvailable);</span>
236 
237     void receivedFirstData();
238 
239     void dispatchOnloadEvents();
240     String userAgent(const URL&amp;) const;

241     String navigatorPlatform() const;
242 
243     void dispatchDidClearWindowObjectInWorld(DOMWrapperWorld&amp;);
244     void dispatchDidClearWindowObjectsInAllWorlds();
245 
246     // The following sandbox flags will be forced, regardless of changes to
247     // the sandbox attribute of any parent frames.
248     void forceSandboxFlags(SandboxFlags flags) { m_forcedSandboxFlags |= flags; }
249     SandboxFlags effectiveSandboxFlags() const;
250 
251     bool checkIfFormActionAllowedByCSP(const URL&amp;, bool didReceiveRedirectResponse) const;
252 
253     WEBCORE_EXPORT Frame* opener();
254     WEBCORE_EXPORT void setOpener(Frame*);
<span class="line-added">255     WEBCORE_EXPORT void detachFromAllOpenedFrames();</span>
256     bool hasOpenedFrames() const { return !m_openedFrames.isEmpty(); }
257 
258     void resetMultipleFormSubmissionProtection();
259 
260     void checkCallImplicitClose();
261 
262     void frameDetached();
263 
264     void setOutgoingReferrer(const URL&amp;);
265 
266     void loadDone(LoadCompletionType);
267     void subresourceLoadDone(LoadCompletionType);
268     void finishedParsing();
269     void checkCompleted();
270 
271     WEBCORE_EXPORT bool isComplete() const;
272 
273     void commitProvisionalLoad();
274 
275     void setLoadsSynchronously(bool loadsSynchronously) { m_loadsSynchronously = loadsSynchronously; }
</pre>
<hr />
<pre>
340     void loadDifferentDocumentItem(HistoryItem&amp;, HistoryItem* fromItem, FrameLoadType, FormSubmissionCacheLoadPolicy, ShouldTreatAsContinuingLoad);
341 
342     void loadProvisionalItemFromCachedPage();
343 
344     void updateFirstPartyForCookies();
345     void setFirstPartyForCookies(const URL&amp;);
346 
347     void addExtraFieldsToRequest(ResourceRequest&amp;, FrameLoadType, bool isMainResource);
348     ResourceRequestCachePolicy defaultRequestCachingPolicy(const ResourceRequest&amp;, FrameLoadType, bool isMainResource);
349 
350     void clearProvisionalLoad();
351     void transitionToCommitted(CachedPage*);
352     void frameLoadCompleted();
353 
354     SubstituteData defaultSubstituteDataForURL(const URL&amp;);
355 
356     bool dispatchBeforeUnloadEvent(Chrome&amp;, FrameLoader* frameLoaderBeingNavigated);
357     void dispatchUnloadEvents(UnloadEventPolicy);
358 
359     void continueLoadAfterNavigationPolicy(const ResourceRequest&amp;, FormState*, NavigationPolicyDecision, AllowNavigationToInvalidURL);
<span class="line-modified">360     void continueLoadAfterNewWindowPolicy(const ResourceRequest&amp;, FormState*, const String&amp; frameName, const NavigationAction&amp;, PolicyChecker::ShouldContinue, AllowNavigationToInvalidURL, NewFrameOpenerPolicy);</span>
361     void continueFragmentScrollAfterNavigationPolicy(const ResourceRequest&amp;, bool shouldContinue);
362 
363     bool shouldPerformFragmentNavigation(bool isFormSubmission, const String&amp; httpMethod, FrameLoadType, const URL&amp;);
364     void scrollToFragmentWithParentBoundary(const URL&amp;, bool isNewNavigation = true);
365 
366     void dispatchDidFailProvisionalLoad(DocumentLoader&amp; provisionalDocumentLoader, const ResourceError&amp;);
367     void checkLoadCompleteForThisFrame();
368 
369     void setDocumentLoader(DocumentLoader*);
370     void setPolicyDocumentLoader(DocumentLoader*);
371     void setProvisionalDocumentLoader(DocumentLoader*);
372 
373     void setState(FrameState);
374 
375     void closeOldDataSources();
376     void willRestoreFromCachedPage();
377 
378     bool shouldReloadToHandleUnreachableURL(DocumentLoader&amp;);
379 
380     void dispatchDidCommitLoad(Optional&lt;HasInsecureContent&gt; initialHasInsecureContent);
</pre>
</td>
</tr>
</table>
<center><a href="FrameLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameLoaderClient.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGStackLayoutPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGGraph.h&quot;
 32 #include &quot;DFGPhase.h&quot;
 33 #include &quot;DFGValueSource.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 class StackLayoutPhase : public Phase {
<a name="2" id="anc2"></a><span class="line-modified"> 39     static const bool verbose = false;</span>
 40 
 41 public:
 42     StackLayoutPhase(Graph&amp; graph)
 43         : Phase(graph, &quot;stack layout&quot;)
 44     {
 45     }
 46 
 47     bool run()
 48     {
 49         // This enumerates the locals that we actually care about and packs them. So for example
 50         // if we use local 1, 3, 4, 5, 7, then we remap them: 1-&gt;0, 3-&gt;1, 4-&gt;2, 5-&gt;3, 7-&gt;4. We
 51         // treat a variable as being &quot;used&quot; if there exists an access to it (SetLocal, GetLocal,
 52         // Flush, PhantomLocal).
 53 
<a name="3" id="anc3"></a><span class="line-modified"> 54         BitVector usedLocals;</span>
 55 
 56         // Collect those variables that are used from IR.
 57         bool hasNodesThatNeedFixup = false;
 58         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 59             BasicBlock* block = m_graph.block(blockIndex);
 60             if (!block)
 61                 continue;
 62             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
 63                 Node* node = block-&gt;at(nodeIndex);
 64                 switch (node-&gt;op()) {
 65                 case GetLocal:
 66                 case SetLocal:
 67                 case Flush:
 68                 case PhantomLocal: {
 69                     VariableAccessData* variable = node-&gt;variableAccessData();
<a name="4" id="anc4"></a><span class="line-modified"> 70                     if (variable-&gt;local().isArgument())</span>
 71                         break;
<a name="5" id="anc5"></a><span class="line-modified"> 72                     usedLocals.set(variable-&gt;local().toLocal());</span>
 73                     break;
 74                 }
 75 
 76                 case LoadVarargs:
 77                 case ForwardVarargs: {
 78                     LoadVarargsData* data = node-&gt;loadVarargsData();
<a name="6" id="anc6"></a><span class="line-modified"> 79                     if (data-&gt;count.isLocal())</span>
<span class="line-removed"> 80                         usedLocals.set(data-&gt;count.toLocal());</span>
 81                     if (data-&gt;start.isLocal()) {
 82                         // This part really relies on the contiguity of stack layout
 83                         // assignments.
 84                         ASSERT(VirtualRegister(data-&gt;start.offset() + data-&gt;limit - 1).isLocal());
 85                         for (unsigned i = data-&gt;limit; i--;)
<a name="7" id="anc7"></a><span class="line-modified"> 86                             usedLocals.set(VirtualRegister(data-&gt;start.offset() + i).toLocal());</span>
 87                     } // the else case shouldn&#39;t happen.
 88                     hasNodesThatNeedFixup = true;
 89                     break;
 90                 }
 91 
 92                 case PutStack:
 93                 case GetStack: {
 94                     StackAccessData* stack = node-&gt;stackAccessData();
<a name="8" id="anc8"></a><span class="line-modified"> 95                     if (stack-&gt;local.isArgument())</span>
 96                         break;
<a name="9" id="anc9"></a><span class="line-modified"> 97                     usedLocals.set(stack-&gt;local.toLocal());</span>
 98                     break;
 99                 }
100 
101                 default:
102                     break;
103                 }
104             }
105         }
106 
107         for (InlineCallFrameSet::iterator iter = m_graph.m_plan.inlineCallFrames()-&gt;begin(); !!iter; ++iter) {
108             InlineCallFrame* inlineCallFrame = *iter;
109 
110             if (inlineCallFrame-&gt;isVarargs()) {
<a name="10" id="anc10"></a><span class="line-modified">111                 usedLocals.set(VirtualRegister(</span>
<span class="line-modified">112                     CallFrameSlot::argumentCount + inlineCallFrame-&gt;stackOffset).toLocal());</span>
113             }
114 
115             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
<a name="11" id="anc11"></a><span class="line-modified">116                 usedLocals.set(VirtualRegister(</span>
<span class="line-modified">117                     virtualRegisterForArgument(argument).offset() +</span>
<span class="line-modified">118                     inlineCallFrame-&gt;stackOffset).toLocal());</span>
119             }
120         }
121 
<a name="12" id="anc12"></a><span class="line-modified">122         Vector&lt;unsigned&gt; allocation(usedLocals.size());</span>
123         m_graph.m_nextMachineLocal = codeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters();
<a name="13" id="anc13"></a><span class="line-modified">124         for (unsigned i = 0; i &lt; usedLocals.size(); ++i) {</span>
<span class="line-modified">125             if (!usedLocals.get(i)) {</span>
126                 allocation[i] = UINT_MAX;
127                 continue;
128             }
129 
130             allocation[i] = m_graph.m_nextMachineLocal++;
131         }
132 
133         for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
134             VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
135             if (!variable-&gt;isRoot())
136                 continue;
137 
<a name="14" id="anc14"></a><span class="line-modified">138             if (variable-&gt;local().isArgument()) {</span>
<span class="line-modified">139                 variable-&gt;machineLocal() = variable-&gt;local();</span>
140                 continue;
141             }
142 
<a name="15" id="anc15"></a><span class="line-modified">143             size_t local = variable-&gt;local().toLocal();</span>
<span class="line-modified">144             if (local &gt;= allocation.size())</span>

145                 continue;
146 
<a name="16" id="anc16"></a><span class="line-modified">147             if (allocation[local] == UINT_MAX)</span>
148                 continue;
149 
<a name="17" id="anc17"></a><span class="line-modified">150             variable-&gt;machineLocal() = assign(allocation, variable-&gt;local());</span>
151         }
152 
153         for (StackAccessData* data : m_graph.m_stackAccessData) {
<a name="18" id="anc18"></a><span class="line-modified">154             if (!data-&gt;local.isLocal()) {</span>
<span class="line-modified">155                 data-&gt;machineLocal = data-&gt;local;</span>
156                 continue;
157             }
158 
<a name="19" id="anc19"></a><span class="line-modified">159             if (static_cast&lt;size_t&gt;(data-&gt;local.toLocal()) &gt;= allocation.size())</span>
<span class="line-modified">160                 continue;</span>
<span class="line-modified">161             if (allocation[data-&gt;local.toLocal()] == UINT_MAX)</span>
<span class="line-modified">162                 continue;</span>


163 
<a name="20" id="anc20"></a><span class="line-modified">164             data-&gt;machineLocal = assign(allocation, data-&gt;local);</span>
165         }
166 
167         if (!m_graph.needsScopeRegister())
168             codeBlock()-&gt;setScopeRegister(VirtualRegister());
169         else
<a name="21" id="anc21"></a><span class="line-modified">170             codeBlock()-&gt;setScopeRegister(assign(allocation, codeBlock()-&gt;scopeRegister()));</span>
171 
172         for (unsigned i = m_graph.m_inlineVariableData.size(); i--;) {
173             InlineVariableData data = m_graph.m_inlineVariableData[i];
174             InlineCallFrame* inlineCallFrame = data.inlineCallFrame;
175 
<a name="22" id="anc22"></a><span class="line-modified">176             if (inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified">177                 inlineCallFrame-&gt;argumentCountRegister = assign(</span>
<span class="line-removed">178                     allocation, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
<span class="line-removed">179             }</span>
180 
181             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
182                 ArgumentPosition&amp; position = m_graph.m_argumentPositions[
183                     data.argumentPositionStart + argument];
184                 VariableAccessData* variable = position.someVariable();
185                 ValueSource source;
186                 if (!variable)
187                     source = ValueSource(SourceIsDead);
188                 else {
189                     source = ValueSource::forFlushFormat(
190                         variable-&gt;machineLocal(), variable-&gt;flushFormat());
191                 }
192                 inlineCallFrame-&gt;argumentsWithFixup[argument] = source.valueRecovery();
193             }
194 
195             RELEASE_ASSERT(inlineCallFrame-&gt;isClosureCall == !!data.calleeVariable);
196             if (inlineCallFrame-&gt;isClosureCall) {
197                 VariableAccessData* variable = data.calleeVariable-&gt;find();
198                 ValueSource source = ValueSource::forFlushFormat(
199                     variable-&gt;machineLocal(),
200                     variable-&gt;flushFormat());
201                 inlineCallFrame-&gt;calleeRecovery = source.valueRecovery();
202             } else
203                 RELEASE_ASSERT(inlineCallFrame-&gt;calleeRecovery.isConstant());
204         }
205 
206         // Fix Varargs&#39; variable references.
207         if (hasNodesThatNeedFixup) {
208             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
209                 BasicBlock* block = m_graph.block(blockIndex);
210                 if (!block)
211                     continue;
212                 for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
213                     Node* node = block-&gt;at(nodeIndex);
214                     switch (node-&gt;op()) {
215                     case LoadVarargs:
216                     case ForwardVarargs: {
217                         LoadVarargsData* data = node-&gt;loadVarargsData();
<a name="23" id="anc23"></a><span class="line-modified">218                         data-&gt;machineCount = assign(allocation, data-&gt;count);</span>
<span class="line-modified">219                         data-&gt;machineStart = assign(allocation, data-&gt;start);</span>
220                         break;
221                     }
222 
223                     default:
224                         break;
225                     }
226                 }
227             }
228         }
229 
230         return true;
231     }
232 
233 private:
<a name="24" id="anc24"></a><span class="line-modified">234     VirtualRegister assign(const Vector&lt;unsigned&gt;&amp; allocation, VirtualRegister src)</span>
235     {
<a name="25" id="anc25"></a><span class="line-modified">236         VirtualRegister result = src;</span>
<span class="line-modified">237         if (result.isLocal()) {</span>
<span class="line-modified">238             unsigned myAllocation = allocation[result.toLocal()];</span>
<span class="line-modified">239             if (myAllocation == UINT_MAX)</span>
<span class="line-modified">240                 result = VirtualRegister();</span>
<span class="line-modified">241             else</span>
<span class="line-modified">242                 result = virtualRegisterForLocal(myAllocation);</span>
<span class="line-modified">243         }</span>
<span class="line-removed">244         return result;</span>
245     }
246 };
247 
248 bool performStackLayout(Graph&amp; graph)
249 {
250     return runPhase&lt;StackLayoutPhase&gt;(graph);
251 }
252 
253 } } // namespace JSC::DFG
254 
255 #endif // ENABLE(DFG_JIT)
256 
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
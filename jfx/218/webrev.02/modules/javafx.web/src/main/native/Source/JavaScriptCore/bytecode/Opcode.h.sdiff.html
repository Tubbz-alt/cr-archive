<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Opcode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Opcode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Operands.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Opcode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;Bytecodes.h&quot;
 33 #include &quot;LLIntOpcode.h&quot;
 34 
 35 #include &lt;algorithm&gt;
 36 #include &lt;string.h&gt;
 37 
 38 #include &lt;wtf/Assertions.h&gt;

 39 
 40 namespace JSC {
 41 
 42 #define FOR_EACH_CORE_OPCODE_ID_WITH_EXTENSION(macro, extension__) \
 43     FOR_EACH_BYTECODE_ID(macro) \
 44     extension__
 45 
 46 #define FOR_EACH_CORE_OPCODE_ID(macro) \
 47     FOR_EACH_CORE_OPCODE_ID_WITH_EXTENSION(macro, /* No extension */ )
 48 
 49 #define FOR_EACH_OPCODE_ID(macro) \
 50     FOR_EACH_CORE_OPCODE_ID_WITH_EXTENSION( \
 51         macro, \
 52         FOR_EACH_LLINT_OPCODE_EXTENSION(macro) \
 53     )
 54 
 55 
<span class="line-removed"> 56 const int maxOpcodeLength = 40;</span>
 57 #if ENABLE(C_LOOP)
 58 const int numOpcodeIDs = NUMBER_OF_BYTECODE_IDS + NUMBER_OF_CLOOP_BYTECODE_HELPER_IDS + NUMBER_OF_BYTECODE_HELPER_IDS;
 59 #else
 60 const int numOpcodeIDs = NUMBER_OF_BYTECODE_IDS + NUMBER_OF_BYTECODE_HELPER_IDS;
 61 #endif
 62 


 63 #define OPCODE_ID_ENUM(opcode, length) opcode,
 64     enum OpcodeID : unsigned { FOR_EACH_OPCODE_ID(OPCODE_ID_ENUM) };

 65 #undef OPCODE_ID_ENUM
 66 
 67 #if ENABLE(C_LOOP) &amp;&amp; !HAVE(COMPUTED_GOTO)
 68 
 69 #define OPCODE_ID_ENUM(opcode, length) opcode##_wide16 = numOpcodeIDs + opcode,
 70     enum OpcodeIDWide16 : unsigned { FOR_EACH_OPCODE_ID(OPCODE_ID_ENUM) };

 71 #undef OPCODE_ID_ENUM
 72 
 73 #define OPCODE_ID_ENUM(opcode, length) opcode##_wide32 = numOpcodeIDs * 2 + opcode,
 74     enum OpcodeIDWide32 : unsigned { FOR_EACH_OPCODE_ID(OPCODE_ID_ENUM) };

 75 #undef OPCODE_ID_ENUM
 76 #endif
 77 
 78 extern const unsigned opcodeLengths[];

 79 
 80 #define OPCODE_ID_LENGTHS(id, length) const int id##_length = length;
 81     FOR_EACH_OPCODE_ID(OPCODE_ID_LENGTHS);

 82 #undef OPCODE_ID_LENGTHS
 83 





 84 #define FOR_EACH_OPCODE_WITH_VALUE_PROFILE(macro) \
 85     macro(OpCallVarargs) \
 86     macro(OpTailCallVarargs) \
 87     macro(OpTailCallForwardArguments) \
 88     macro(OpConstructVarargs) \
 89     macro(OpGetByVal) \
 90     macro(OpGetDirectPname) \
 91     macro(OpGetById) \
 92     macro(OpGetByIdWithThis) \
 93     macro(OpTryGetById) \
 94     macro(OpGetByIdDirect) \
 95     macro(OpGetByValWithThis) \
 96     macro(OpGetFromArguments) \
 97     macro(OpToNumber) \

 98     macro(OpToObject) \
 99     macro(OpGetArgument) \

100     macro(OpToThis) \
101     macro(OpCall) \
102     macro(OpTailCall) \
103     macro(OpCallEval) \
104     macro(OpConstruct) \
105     macro(OpGetFromScope) \
106     macro(OpBitand) \
107     macro(OpBitor) \
108     macro(OpBitnot) \
109     macro(OpBitxor) \
110     macro(OpLshift) \

111 
112 #define FOR_EACH_OPCODE_WITH_ARRAY_PROFILE(macro) \
113     macro(OpHasIndexedProperty) \
114     macro(OpCallVarargs) \
115     macro(OpTailCallVarargs) \
116     macro(OpTailCallForwardArguments) \
117     macro(OpConstructVarargs) \
118     macro(OpGetByVal) \
119     macro(OpInByVal) \
120     macro(OpPutByVal) \
121     macro(OpPutByValDirect) \
122 
123 #define FOR_EACH_OPCODE_WITH_ARRAY_ALLOCATION_PROFILE(macro) \
124     macro(OpNewArray) \
125     macro(OpNewArrayWithSize) \
126     macro(OpNewArrayBuffer) \
127 
128 #define FOR_EACH_OPCODE_WITH_OBJECT_ALLOCATION_PROFILE(macro) \
129     macro(OpNewObject) \
130 
</pre>
<hr />
<pre>
132     macro(OpCall) \
133     macro(OpTailCall) \
134     macro(OpCallEval) \
135     macro(OpConstruct) \
136 
137 IGNORE_WARNINGS_BEGIN(&quot;type-limits&quot;)
138 
139 #define VERIFY_OPCODE_ID(id, size) COMPILE_ASSERT(id &lt;= numOpcodeIDs, ASSERT_THAT_JS_OPCODE_IDS_ARE_VALID);
140     FOR_EACH_OPCODE_ID(VERIFY_OPCODE_ID);
141 #undef VERIFY_OPCODE_ID
142 
143 IGNORE_WARNINGS_END
144 
145 #if ENABLE(COMPUTED_GOTO_OPCODES)
146 typedef void* Opcode;
147 #else
148 typedef OpcodeID Opcode;
149 #endif
150 
151 extern const char* const opcodeNames[];

152 
153 #if ENABLE(OPCODE_STATS)
154 
155 struct OpcodeStats {
156     OpcodeStats();
157     ~OpcodeStats();
158     static long long opcodeCounts[numOpcodeIDs];
159     static long long opcodePairCounts[numOpcodeIDs][numOpcodeIDs];
160     static int lastOpcode;
161 
162     static void recordInstruction(int opcode);
163     static void resetLastInstruction();
164 };
165 
166 #endif
167 
168 inline bool isBranch(OpcodeID opcodeID)
169 {
170     switch (opcodeID) {
171     case op_jmp:
</pre>
</td>
<td>
<hr />
<pre>
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;Bytecodes.h&quot;
 33 #include &quot;LLIntOpcode.h&quot;
 34 
 35 #include &lt;algorithm&gt;
 36 #include &lt;string.h&gt;
 37 
 38 #include &lt;wtf/Assertions.h&gt;
<span class="line-added"> 39 #include &lt;wtf/MathExtras.h&gt;</span>
 40 
 41 namespace JSC {
 42 
 43 #define FOR_EACH_CORE_OPCODE_ID_WITH_EXTENSION(macro, extension__) \
 44     FOR_EACH_BYTECODE_ID(macro) \
 45     extension__
 46 
 47 #define FOR_EACH_CORE_OPCODE_ID(macro) \
 48     FOR_EACH_CORE_OPCODE_ID_WITH_EXTENSION(macro, /* No extension */ )
 49 
 50 #define FOR_EACH_OPCODE_ID(macro) \
 51     FOR_EACH_CORE_OPCODE_ID_WITH_EXTENSION( \
 52         macro, \
 53         FOR_EACH_LLINT_OPCODE_EXTENSION(macro) \
 54     )
 55 
 56 

 57 #if ENABLE(C_LOOP)
 58 const int numOpcodeIDs = NUMBER_OF_BYTECODE_IDS + NUMBER_OF_CLOOP_BYTECODE_HELPER_IDS + NUMBER_OF_BYTECODE_HELPER_IDS;
 59 #else
 60 const int numOpcodeIDs = NUMBER_OF_BYTECODE_IDS + NUMBER_OF_BYTECODE_HELPER_IDS;
 61 #endif
 62 
<span class="line-added"> 63 constexpr int numWasmOpcodeIDs = NUMBER_OF_WASM_IDS + NUMBER_OF_BYTECODE_HELPER_IDS;</span>
<span class="line-added"> 64 </span>
 65 #define OPCODE_ID_ENUM(opcode, length) opcode,
 66     enum OpcodeID : unsigned { FOR_EACH_OPCODE_ID(OPCODE_ID_ENUM) };
<span class="line-added"> 67     enum WasmOpcodeID : unsigned { FOR_EACH_WASM_ID(OPCODE_ID_ENUM) };</span>
 68 #undef OPCODE_ID_ENUM
 69 
 70 #if ENABLE(C_LOOP) &amp;&amp; !HAVE(COMPUTED_GOTO)
 71 
 72 #define OPCODE_ID_ENUM(opcode, length) opcode##_wide16 = numOpcodeIDs + opcode,
 73     enum OpcodeIDWide16 : unsigned { FOR_EACH_OPCODE_ID(OPCODE_ID_ENUM) };
<span class="line-added"> 74     enum WasmOpcodeIDWide16 : unsigned { FOR_EACH_WASM_ID(OPCODE_ID_ENUM) };</span>
 75 #undef OPCODE_ID_ENUM
 76 
 77 #define OPCODE_ID_ENUM(opcode, length) opcode##_wide32 = numOpcodeIDs * 2 + opcode,
 78     enum OpcodeIDWide32 : unsigned { FOR_EACH_OPCODE_ID(OPCODE_ID_ENUM) };
<span class="line-added"> 79     enum WasmOpcodeIDWide32 : unsigned { FOR_EACH_WASM_ID(OPCODE_ID_ENUM) };</span>
 80 #undef OPCODE_ID_ENUM
 81 #endif
 82 
 83 extern const unsigned opcodeLengths[];
<span class="line-added"> 84 extern const unsigned wasmOpcodeLengths[];</span>
 85 
 86 #define OPCODE_ID_LENGTHS(id, length) const int id##_length = length;
 87     FOR_EACH_OPCODE_ID(OPCODE_ID_LENGTHS);
<span class="line-added"> 88     FOR_EACH_WASM_ID(OPCODE_ID_LENGTHS);</span>
 89 #undef OPCODE_ID_LENGTHS
 90 
<span class="line-added"> 91 static constexpr unsigned maxJSOpcodeLength = /* Opcode */ 1 + /* Wide32 Opcode */ 1 + /* Operands */ (MAX_LENGTH_OF_BYTECODE_IDS - 1) * 4;</span>
<span class="line-added"> 92 static constexpr unsigned maxWasmOpcodeLength = /* Opcode */ 1 + /* Wide32 Opcode */ 1 + /* Operands */ (MAX_LENGTH_OF_WASM_IDS - 1) * 4;</span>
<span class="line-added"> 93 static constexpr unsigned maxOpcodeLength = std::max(maxJSOpcodeLength, maxWasmOpcodeLength);</span>
<span class="line-added"> 94 static constexpr unsigned bitWidthForMaxOpcodeLength = WTF::getMSBSetConstexpr(maxOpcodeLength) + 1;</span>
<span class="line-added"> 95 </span>
 96 #define FOR_EACH_OPCODE_WITH_VALUE_PROFILE(macro) \
 97     macro(OpCallVarargs) \
 98     macro(OpTailCallVarargs) \
 99     macro(OpTailCallForwardArguments) \
100     macro(OpConstructVarargs) \
101     macro(OpGetByVal) \
102     macro(OpGetDirectPname) \
103     macro(OpGetById) \
104     macro(OpGetByIdWithThis) \
105     macro(OpTryGetById) \
106     macro(OpGetByIdDirect) \
107     macro(OpGetByValWithThis) \
108     macro(OpGetFromArguments) \
109     macro(OpToNumber) \
<span class="line-added">110     macro(OpToNumeric) \</span>
111     macro(OpToObject) \
112     macro(OpGetArgument) \
<span class="line-added">113     macro(OpGetInternalField) \</span>
114     macro(OpToThis) \
115     macro(OpCall) \
116     macro(OpTailCall) \
117     macro(OpCallEval) \
118     macro(OpConstruct) \
119     macro(OpGetFromScope) \
120     macro(OpBitand) \
121     macro(OpBitor) \
122     macro(OpBitnot) \
123     macro(OpBitxor) \
124     macro(OpLshift) \
<span class="line-added">125     macro(OpRshift) \</span>
126 
127 #define FOR_EACH_OPCODE_WITH_ARRAY_PROFILE(macro) \
128     macro(OpHasIndexedProperty) \
129     macro(OpCallVarargs) \
130     macro(OpTailCallVarargs) \
131     macro(OpTailCallForwardArguments) \
132     macro(OpConstructVarargs) \
133     macro(OpGetByVal) \
134     macro(OpInByVal) \
135     macro(OpPutByVal) \
136     macro(OpPutByValDirect) \
137 
138 #define FOR_EACH_OPCODE_WITH_ARRAY_ALLOCATION_PROFILE(macro) \
139     macro(OpNewArray) \
140     macro(OpNewArrayWithSize) \
141     macro(OpNewArrayBuffer) \
142 
143 #define FOR_EACH_OPCODE_WITH_OBJECT_ALLOCATION_PROFILE(macro) \
144     macro(OpNewObject) \
145 
</pre>
<hr />
<pre>
147     macro(OpCall) \
148     macro(OpTailCall) \
149     macro(OpCallEval) \
150     macro(OpConstruct) \
151 
152 IGNORE_WARNINGS_BEGIN(&quot;type-limits&quot;)
153 
154 #define VERIFY_OPCODE_ID(id, size) COMPILE_ASSERT(id &lt;= numOpcodeIDs, ASSERT_THAT_JS_OPCODE_IDS_ARE_VALID);
155     FOR_EACH_OPCODE_ID(VERIFY_OPCODE_ID);
156 #undef VERIFY_OPCODE_ID
157 
158 IGNORE_WARNINGS_END
159 
160 #if ENABLE(COMPUTED_GOTO_OPCODES)
161 typedef void* Opcode;
162 #else
163 typedef OpcodeID Opcode;
164 #endif
165 
166 extern const char* const opcodeNames[];
<span class="line-added">167 extern const char* const wasmOpcodeNames[];</span>
168 
169 #if ENABLE(OPCODE_STATS)
170 
171 struct OpcodeStats {
172     OpcodeStats();
173     ~OpcodeStats();
174     static long long opcodeCounts[numOpcodeIDs];
175     static long long opcodePairCounts[numOpcodeIDs][numOpcodeIDs];
176     static int lastOpcode;
177 
178     static void recordInstruction(int opcode);
179     static void resetLastInstruction();
180 };
181 
182 #endif
183 
184 inline bool isBranch(OpcodeID opcodeID)
185 {
186     switch (opcodeID) {
187     case op_jmp:
</pre>
</td>
</tr>
</table>
<center><a href="Opcode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Operands.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
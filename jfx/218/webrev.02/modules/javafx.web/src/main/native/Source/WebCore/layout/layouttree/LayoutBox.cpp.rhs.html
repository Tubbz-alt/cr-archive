<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutBox.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;DisplayBox.h&quot;</span>
 32 #include &quot;LayoutContainer.h&quot;
 33 #include &quot;LayoutPhase.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 34 #include &quot;LayoutState.h&quot;</span>
 35 #include &quot;RenderStyle.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 namespace WebCore {
 39 namespace Layout {
 40 
 41 WTF_MAKE_ISO_ALLOCATED_IMPL(Box);
 42 
<a name="3" id="anc3"></a><span class="line-modified"> 43 Box::Box(Optional&lt;ElementAttributes&gt; attributes, Optional&lt;TextContext&gt; textContext, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)</span>
 44     : m_style(WTFMove(style))
 45     , m_elementAttributes(attributes)
<a name="4" id="anc4"></a><span class="line-added"> 46     , m_textContext(textContext)</span>
 47     , m_baseTypeFlags(baseTypeFlags)
 48     , m_hasRareData(false)
 49     , m_isAnonymous(false)
 50 {
 51     if (isReplaced())
 52         ensureRareData().replaced = makeUnique&lt;Replaced&gt;(*this);
 53 }
 54 
 55 Box::Box(Optional&lt;ElementAttributes&gt; attributes, RenderStyle&amp;&amp; style)
<a name="5" id="anc5"></a><span class="line-modified"> 56     : Box(attributes, { }, WTFMove(style), BaseTypeFlag::BoxFlag)</span>
 57 {
 58 }
 59 
<a name="6" id="anc6"></a><span class="line-modified"> 60 Box::Box(TextContext&amp;&amp; textContext, RenderStyle&amp;&amp; style)</span>
<span class="line-modified"> 61     : Box({ }, WTFMove(textContext), WTFMove(style), BaseTypeFlag::BoxFlag)</span>
 62 {
<a name="7" id="anc7"></a><span class="line-modified"> 63     ASSERT(isInlineLevelBox());</span>
 64 }
 65 
 66 Box::~Box()
 67 {
<a name="8" id="anc8"></a><span class="line-modified"> 68     if (UNLIKELY(m_hasRareData))</span>
<span class="line-added"> 69         removeRareData();</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 void Box::updateStyle(const RenderStyle&amp; newStyle)</span>
<span class="line-added"> 73 {</span>
<span class="line-added"> 74     m_style = RenderStyle::clone(newStyle);</span>
 75 }
 76 
 77 bool Box::establishesFormattingContext() const
 78 {
 79     // We need the final tree structure to tell whether a box establishes a certain formatting context.
 80     ASSERT(!Phase::isInTreeBuilding());
<a name="9" id="anc9"></a><span class="line-modified"> 81     return establishesBlockFormattingContext() || establishesInlineFormattingContext() || establishesTableFormattingContext() || establishesIndependentFormattingContext();</span>
 82 }
 83 
 84 bool Box::establishesBlockFormattingContext() const
 85 {
 86     // Initial Containing Block always creates a new (inital) block formatting context.
 87     if (!parent())
 88         return true;
 89 
 90     // 9.4.1 Block formatting contexts
 91     // Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions)
 92     // that are not block boxes, and block boxes with &#39;overflow&#39; other than &#39;visible&#39; (except when that value has been propagated to the viewport)
 93     // establish new block formatting contexts for their contents.
 94     if (isFloatingPositioned() || isAbsolutelyPositioned())
 95         return true;
 96 
 97     if (isBlockContainerBox() &amp;&amp; !isBlockLevelBox())
 98         return true;
 99 
100     if (isBlockLevelBox() &amp;&amp; !isOverflowVisible())
101         return true;
102 
<a name="10" id="anc10"></a><span class="line-added">103     if (isTableWrapperBox())</span>
<span class="line-added">104         return true;</span>
<span class="line-added">105 </span>
106     return false;
107 }
108 
109 bool Box::establishesInlineFormattingContext() const
110 {
111     // 9.4.2 Inline formatting contexts
112     // An inline formatting context is established by a block container box that contains no block-level boxes.
113     if (!isBlockContainerBox())
114         return false;
115 
116     if (!isContainer())
117         return false;
118 
119     // FIXME ???
120     if (!downcast&lt;Container&gt;(*this).firstInFlowChild())
121         return false;
122 
123     // It&#39;s enough to check the first in-flow child since we can&#39;t have both block and inline level sibling boxes.
124     return downcast&lt;Container&gt;(*this).firstInFlowChild()-&gt;isInlineLevelBox();
125 }
126 
<a name="11" id="anc11"></a>




127 bool Box::establishesTableFormattingContext() const
128 {
129     return isTableBox();
130 }
131 
<a name="12" id="anc12"></a><span class="line-modified">132 bool Box::establishesIndependentFormattingContext() const</span>
133 {
<a name="13" id="anc13"></a><span class="line-modified">134     // FIXME: This is where we would check for &#39;contain&#39; property.</span>
<span class="line-added">135     return isAbsolutelyPositioned();</span>
136 }
137 
138 bool Box::isRelativelyPositioned() const
139 {
140     return m_style.position() == PositionType::Relative;
141 }
142 
143 bool Box::isStickyPositioned() const
144 {
145     return m_style.position() == PositionType::Sticky;
146 }
147 
148 bool Box::isAbsolutelyPositioned() const
149 {
150     return m_style.position() == PositionType::Absolute || isFixedPositioned();
151 }
152 
153 bool Box::isFixedPositioned() const
154 {
155     return m_style.position() == PositionType::Fixed;
156 }
157 
158 bool Box::isFloatingPositioned() const
159 {
160     // FIXME: Rendering code caches values like this. (style=&quot;position: absolute; float: left&quot;)
161     if (isOutOfFlowPositioned())
162         return false;
163     return m_style.floating() != Float::No;
164 }
165 
166 bool Box::isLeftFloatingPositioned() const
167 {
168     if (!isFloatingPositioned())
169         return false;
170     return m_style.floating() == Float::Left;
171 }
172 
173 bool Box::isRightFloatingPositioned() const
174 {
175     if (!isFloatingPositioned())
176         return false;
177     return m_style.floating() == Float::Right;
178 }
179 
180 bool Box::hasFloatClear() const
181 {
182     return m_style.clear() != Clear::None;
183 }
184 
185 bool Box::isFloatAvoider() const
186 {
<a name="14" id="anc14"></a><span class="line-modified">187     return (establishesBlockFormattingContext() &amp;&amp; !establishesInlineFormattingContext())</span>
<span class="line-added">188         || establishesTableFormattingContext() || establishesIndependentFormattingContext() || hasFloatClear();</span>
189 }
190 
191 const Container* Box::containingBlock() const
192 {
193     // Finding the containing block by traversing the tree during tree construction could provide incorrect result.
194     ASSERT(!Phase::isInTreeBuilding());
195     // The containing block in which the root element lives is a rectangle called the initial containing block.
196     // For other elements, if the element&#39;s position is &#39;relative&#39; or &#39;static&#39;, the containing block is formed by the
<a name="15" id="anc15"></a><span class="line-modified">197     // content edge of the nearest block container ancestor box or which establishes a formatting context.</span>
198     // If the element has &#39;position: fixed&#39;, the containing block is established by the viewport
199     // If the element has &#39;position: absolute&#39;, the containing block is established by the nearest ancestor with a
200     // &#39;position&#39; of &#39;absolute&#39;, &#39;relative&#39; or &#39;fixed&#39;.
201     if (!parent())
202         return nullptr;
203 
204     if (!isPositioned() || isInFlowPositioned()) {
<a name="16" id="anc16"></a><span class="line-modified">205         for (auto* nearestBlockContainerOrFormattingContextRoot = parent(); nearestBlockContainerOrFormattingContextRoot; nearestBlockContainerOrFormattingContextRoot = nearestBlockContainerOrFormattingContextRoot-&gt;parent()) {</span>
<span class="line-modified">206             if (nearestBlockContainerOrFormattingContextRoot-&gt;isBlockContainerBox() || nearestBlockContainerOrFormattingContextRoot-&gt;establishesFormattingContext())</span>
<span class="line-modified">207                 return nearestBlockContainerOrFormattingContextRoot;</span>
<span class="line-added">208         }</span>
<span class="line-added">209         // We should always manage to find the ICB.</span>
<span class="line-added">210         ASSERT_NOT_REACHED();</span>
<span class="line-added">211         return nullptr;</span>
212     }
213 
214     if (isFixedPositioned()) {
215         auto* ancestor = parent();
216         for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
217         return ancestor;
218     }
219 
220     if (isOutOfFlowPositioned()) {
221         auto* ancestor = parent();
222         for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;isPositioned() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
223         return ancestor;
224     }
225 
226     ASSERT_NOT_REACHED();
227     return nullptr;
228 }
229 
230 const Container&amp; Box::formattingContextRoot() const
231 {
232     // Finding the context root by traversing the tree during tree construction could provide incorrect result.
233     ASSERT(!Phase::isInTreeBuilding());
234     // We should never need to ask this question on the ICB.
235     ASSERT(!isInitialContainingBlock());
236     // A box lives in the same formatting context as its containing block unless the containing block establishes a formatting context.
237     // However relatively positioned (inflow) inline container lives in the formatting context where its parent lives unless
238     // the parent establishes a formatting context.
239     //
240     // &lt;div id=outer style=&quot;position: absolute&quot;&gt;&lt;div id=inner&gt;&lt;span style=&quot;position: relative&quot;&gt;content&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;
241     // While the relatively positioned inline container (span) is placed relative to its containing block &quot;outer&quot;, it lives in the inline
242     // formatting context established by &quot;inner&quot;.
243     const Container* ancestor = nullptr;
244     if (isInlineLevelBox() &amp;&amp; isInFlowPositioned())
245         ancestor = parent();
246     else
247         ancestor = containingBlock();
248     ASSERT(ancestor);
249     if (ancestor-&gt;establishesFormattingContext())
250         return *ancestor;
251     return ancestor-&gt;formattingContextRoot();
252 }
253 
254 const Container&amp; Box::initialContainingBlock() const
255 {
256     if (isInitialContainingBlock())
257         return downcast&lt;Container&gt;(*this);
258 
259     auto* parent = this-&gt;parent();
260     for (; parent-&gt;parent(); parent = parent-&gt;parent()) { }
261 
262     return *parent;
263 }
264 
265 bool Box::isDescendantOf(const Container&amp; ancestorCandidate) const
266 {
267     for (auto* ancestor = parent(); ancestor; ancestor = ancestor-&gt;parent()) {
268         if (ancestor == &amp;ancestorCandidate)
269             return true;
270     }
271     return false;
272 }
273 
274 bool Box::isContainingBlockDescendantOf(const Container&amp; ancestorCandidate) const
275 {
276     for (auto* ancestor = containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
277         if (ancestor == &amp;ancestorCandidate)
278             return true;
279     }
280     return false;
281 }
282 
283 bool Box::isInlineBlockBox() const
284 {
285     return m_style.display() == DisplayType::InlineBlock;
286 }
287 
<a name="17" id="anc17"></a><span class="line-added">288 bool Box::isInlineTableBox() const</span>
<span class="line-added">289 {</span>
<span class="line-added">290     return m_style.display() == DisplayType::InlineTable;</span>
<span class="line-added">291 }</span>
<span class="line-added">292 </span>
293 bool Box::isBlockLevelBox() const
294 {
295     // Block level elements generate block level boxes.
296     auto display = m_style.display();
<a name="18" id="anc18"></a><span class="line-modified">297     return display == DisplayType::Block || display == DisplayType::ListItem || display == DisplayType::Table;</span>
298 }
299 
300 bool Box::isInlineLevelBox() const
301 {
302     // Inline level elements generate inline level boxes.
303     auto display = m_style.display();
<a name="19" id="anc19"></a><span class="line-modified">304     return display == DisplayType::Inline || isInlineBlockBox() || isInlineTableBox();</span>
<span class="line-added">305 }</span>
<span class="line-added">306 </span>
<span class="line-added">307 bool Box::isInlineBox() const</span>
<span class="line-added">308 {</span>
<span class="line-added">309     // An inline box is one that is both inline-level and whose contents participate in its containing inline formatting context.</span>
<span class="line-added">310     // A non-replaced element with a &#39;display&#39; value of &#39;inline&#39; generates an inline box.</span>
<span class="line-added">311     return m_style.display() == DisplayType::Inline &amp;&amp; !isReplaced();</span>
<span class="line-added">312 }</span>
<span class="line-added">313 </span>
<span class="line-added">314 bool Box::isAtomicInlineLevelBox() const</span>
<span class="line-added">315 {</span>
<span class="line-added">316     // Inline-level boxes that are not inline boxes (such as replaced inline-level elements, inline-block elements, and inline-table elements)</span>
<span class="line-added">317     // are called atomic inline-level boxes because they participate in their inline formatting context as a single opaque box.</span>
<span class="line-added">318     return isInlineLevelBox() &amp;&amp; !isInlineBox();</span>
319 }
320 
321 bool Box::isBlockContainerBox() const
322 {
323     auto display = m_style.display();
324     return display == DisplayType::Block || display == DisplayType::ListItem || isInlineBlockBox() || isTableWrapperBox() || isTableCell() || isTableCaption(); // TODO &amp;&amp; !replaced element
325 }
326 
327 bool Box::isInitialContainingBlock() const
328 {
329     return !parent();
330 }
331 
332 const Box* Box::nextInFlowSibling() const
333 {
334     auto* nextSibling = this-&gt;nextSibling();
335     while (nextSibling &amp;&amp; !nextSibling-&gt;isInFlow())
336         nextSibling = nextSibling-&gt;nextSibling();
337     return nextSibling;
338 }
339 
340 const Box* Box::nextInFlowOrFloatingSibling() const
341 {
342     auto* nextSibling = this-&gt;nextSibling();
343     while (nextSibling &amp;&amp; !(nextSibling-&gt;isInFlow() || nextSibling-&gt;isFloatingPositioned()))
344         nextSibling = nextSibling-&gt;nextSibling();
345     return nextSibling;
346 }
347 
348 const Box* Box::previousInFlowSibling() const
349 {
350     auto* previousSibling = this-&gt;previousSibling();
351     while (previousSibling &amp;&amp; !previousSibling-&gt;isInFlow())
352         previousSibling = previousSibling-&gt;previousSibling();
353     return previousSibling;
354 }
355 
356 const Box* Box::previousInFlowOrFloatingSibling() const
357 {
358     auto* previousSibling = this-&gt;previousSibling();
359     while (previousSibling &amp;&amp; !(previousSibling-&gt;isInFlow() || previousSibling-&gt;isFloatingPositioned()))
360         previousSibling = previousSibling-&gt;previousSibling();
361     return previousSibling;
362 }
363 
364 bool Box::isOverflowVisible() const
365 {
366     auto isOverflowVisible = m_style.overflowX() == Overflow::Visible || m_style.overflowY() == Overflow::Visible;
367     // UAs must apply the &#39;overflow&#39; property set on the root element to the viewport. When the root element is an HTML &quot;HTML&quot; element
368     // or an XHTML &quot;html&quot; element, and that element has an HTML &quot;BODY&quot; element or an XHTML &quot;body&quot; element as a child,
369     // user agents must instead apply the &#39;overflow&#39; property from the first such child element to the viewport,
370     // if the value on the root element is &#39;visible&#39;. The &#39;visible&#39; value when used for the viewport must be interpreted as &#39;auto&#39;.
371     // The element from which the value is propagated must have a used value for &#39;overflow&#39; of &#39;visible&#39;.
372     if (isBodyBox()) {
373         auto* documentBox = parent();
374         ASSERT(documentBox);
375         if (!documentBox-&gt;isDocumentBox())
376             return isOverflowVisible;
377         if (!documentBox-&gt;isOverflowVisible())
378             return isOverflowVisible;
379         return true;
380     }
381     if (isInitialContainingBlock()) {
382         auto* documentBox = downcast&lt;Container&gt;(*this).firstChild();
383         if (!documentBox || !documentBox-&gt;isDocumentBox() || !is&lt;Container&gt;(documentBox))
384             return isOverflowVisible;
385         auto* bodyBox = downcast&lt;Container&gt;(documentBox)-&gt;firstChild();
386         if (!bodyBox || !bodyBox-&gt;isBodyBox())
387             return isOverflowVisible;
388         auto&amp; bodyBoxStyle = bodyBox-&gt;style();
389         return bodyBoxStyle.overflowX() == Overflow::Visible || bodyBoxStyle.overflowY() == Overflow::Visible;
390     }
391     return isOverflowVisible;
392 }
393 
394 bool Box::isPaddingApplicable() const
395 {
396     // 8.4 Padding properties:
397     // Applies to: all elements except table-row-group, table-header-group, table-footer-group, table-row, table-column-group and table-column
398     if (isAnonymous())
399         return false;
400 
<a name="20" id="anc20"></a><span class="line-modified">401     return !isTableHeader()</span>
<span class="line-modified">402         &amp;&amp; !isTableBody()</span>
<span class="line-modified">403         &amp;&amp; !isTableFooter()</span>
<span class="line-modified">404         &amp;&amp; !isTableRow()</span>
<span class="line-modified">405         &amp;&amp; !isTableColumnGroup()</span>
<span class="line-modified">406         &amp;&amp; !isTableColumn();</span>




















407 }
408 
409 const Replaced* Box::replaced() const
410 {
411     return const_cast&lt;Box*&gt;(this)-&gt;replaced();
412 }
413 
414 Replaced* Box::replaced()
415 {
416     if (!isReplaced()) {
417         ASSERT(!hasRareData() || !rareData().replaced.get());
418         return nullptr;
419     }
420     ASSERT(hasRareData() &amp;&amp; rareData().replaced.get());
421     return rareData().replaced.get();
422 }
423 
424 void Box::setRowSpan(unsigned rowSpan)
425 {
426     ensureRareData().rowSpan = rowSpan;
427 }
428 
429 void Box::setColumnSpan(unsigned columnSpan)
430 {
431     ensureRareData().columnSpan = columnSpan;
432 }
433 
434 unsigned Box::rowSpan() const
435 {
436     if (!hasRareData())
437         return 1;
438     return rareData().rowSpan;
439 }
440 
441 unsigned Box::columnSpan() const
442 {
443     if (!hasRareData())
444         return 1;
445     return rareData().columnSpan;
446 }
447 
<a name="21" id="anc21"></a><span class="line-added">448 void Box::setColumnWidth(LayoutUnit columnWidth)</span>
<span class="line-added">449 {</span>
<span class="line-added">450     ensureRareData().columnWidth = columnWidth;</span>
<span class="line-added">451 }</span>
<span class="line-added">452 </span>
<span class="line-added">453 Optional&lt;LayoutUnit&gt; Box::columnWidth() const</span>
<span class="line-added">454 {</span>
<span class="line-added">455     if (!hasRareData())</span>
<span class="line-added">456         return { };</span>
<span class="line-added">457     return rareData().columnWidth;</span>
<span class="line-added">458 }</span>
<span class="line-added">459 </span>
<span class="line-added">460 void Box::setCachedDisplayBoxForLayoutState(LayoutState&amp; layoutState, std::unique_ptr&lt;Display::Box&gt; box) const</span>
<span class="line-added">461 {</span>
<span class="line-added">462     ASSERT(!m_cachedLayoutState);</span>
<span class="line-added">463     m_cachedLayoutState = makeWeakPtr(layoutState);</span>
<span class="line-added">464     m_cachedDisplayBoxForLayoutState = WTFMove(box);</span>
<span class="line-added">465 }</span>
<span class="line-added">466 </span>
467 Box::RareDataMap&amp; Box::rareDataMap()
468 {
469     static NeverDestroyed&lt;RareDataMap&gt; map;
470     return map;
471 }
472 
473 const Box::BoxRareData&amp; Box::rareData() const
474 {
475     ASSERT(hasRareData());
476     return *rareDataMap().get(this);
477 }
478 
479 Box::BoxRareData&amp; Box::ensureRareData()
480 {
481     setHasRareData(true);
482     return *rareDataMap().ensure(this, [] { return makeUnique&lt;BoxRareData&gt;(); }).iterator-&gt;value;
483 }
484 
485 void Box::removeRareData()
486 {
487     rareDataMap().remove(this);
488     setHasRareData(false);
489 }
490 
491 }
492 }
493 
494 #endif
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
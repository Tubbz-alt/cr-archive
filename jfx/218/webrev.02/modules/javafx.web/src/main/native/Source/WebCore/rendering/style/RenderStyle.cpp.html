<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Antti Koivisto (koivisto@kde.org)
   3  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   4  * Copyright (C) 2011 Adobe Systems Incorporated. All rights reserved.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;RenderStyle.h&quot;
  25 
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 #include &quot;CSSCustomPropertyValue.h&quot;
  28 #include &quot;CSSParser.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSPropertyParser.h&quot;
  31 #include &quot;ContentData.h&quot;
  32 #include &quot;CursorList.h&quot;
  33 #include &quot;FloatRoundedRect.h&quot;
  34 #include &quot;FontCascade.h&quot;
  35 #include &quot;FontSelector.h&quot;
  36 #include &quot;InlineTextBoxStyle.h&quot;
  37 #include &quot;Pagination.h&quot;
  38 #include &quot;QuotesData.h&quot;
  39 #include &quot;RenderObject.h&quot;
  40 #include &quot;RenderTheme.h&quot;
  41 #include &quot;ScaleTransformOperation.h&quot;
  42 #include &quot;ShadowData.h&quot;
  43 #include &quot;StyleBuilderConverter.h&quot;
  44 #include &quot;StyleImage.h&quot;
  45 #include &quot;StyleInheritedData.h&quot;
  46 #include &quot;StyleResolver.h&quot;
  47 #include &quot;StyleScrollSnapPoints.h&quot;
  48 #include &quot;StyleSelfAlignmentData.h&quot;
  49 #include &quot;StyleTreeResolver.h&quot;
  50 #include &quot;WillChangeData.h&quot;
  51 #include &lt;wtf/MathExtras.h&gt;
  52 #include &lt;wtf/PointerComparison.h&gt;
  53 #include &lt;wtf/StdLibExtras.h&gt;
  54 #include &lt;algorithm&gt;
  55 
  56 #if ENABLE(TEXT_AUTOSIZING)
  57 #include &lt;wtf/text/StringHash.h&gt;
  58 #endif
  59 
  60 namespace WebCore {
  61 
  62 struct SameSizeAsBorderValue {
  63     Color m_color;
  64     float m_width;
  65     int m_restBits;
  66 };
  67 
  68 COMPILE_ASSERT(sizeof(BorderValue) == sizeof(SameSizeAsBorderValue), BorderValue_should_not_grow);
  69 
  70 struct SameSizeAsRenderStyle {
  71     void* dataRefs[7];
  72     void* ownPtrs[1];
  73     void* dataRefSvgStyle;
  74     struct InheritedFlags {
  75         unsigned m_bitfields[2];
  76     } m_inheritedFlags;
  77 
  78     struct NonInheritedFlags {
  79         unsigned m_bitfields[2];
  80     } m_nonInheritedFlags;
  81 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)
  82     bool deletionCheck;
  83 #endif
  84 };
  85 
  86 static_assert(sizeof(RenderStyle) == sizeof(SameSizeAsRenderStyle), &quot;RenderStyle should stay small&quot;);
  87 
  88 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderStyle);
  89 
  90 RenderStyle&amp; RenderStyle::defaultStyle()
  91 {
  92     static NeverDestroyed&lt;RenderStyle&gt; style { CreateDefaultStyle };
  93     return style;
  94 }
  95 
  96 RenderStyle RenderStyle::create()
  97 {
  98     return clone(defaultStyle());
  99 }
 100 
 101 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::createPtr()
 102 {
 103     return clonePtr(defaultStyle());
 104 }
 105 
 106 RenderStyle RenderStyle::clone(const RenderStyle&amp; style)
 107 {
 108     return RenderStyle(style, Clone);
 109 }
 110 
 111 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::clonePtr(const RenderStyle&amp; style)
 112 {
 113     return makeUnique&lt;RenderStyle&gt;(style, Clone);
 114 }
 115 
 116 RenderStyle RenderStyle::createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType display)
 117 {
 118     auto newStyle = create();
 119     newStyle.inheritFrom(parentStyle);
 120     newStyle.inheritUnicodeBidiFrom(&amp;parentStyle);
 121     newStyle.setDisplay(display);
 122     return newStyle;
 123 }
 124 
 125 RenderStyle RenderStyle::createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle)
 126 {
 127     ASSERT(pseudoStyle.styleType() == PseudoId::Before || pseudoStyle.styleType() == PseudoId::After);
 128 
 129     auto style = create();
 130     style.inheritFrom(pseudoStyle);
 131     return style;
 132 }
 133 
 134 RenderStyle::RenderStyle(RenderStyle&amp;&amp;) = default;
 135 RenderStyle&amp; RenderStyle::operator=(RenderStyle&amp;&amp;) = default;
 136 
 137 RenderStyle::RenderStyle(CreateDefaultStyleTag)
 138     : m_boxData(StyleBoxData::create())
 139     , m_visualData(StyleVisualData::create())
 140     , m_backgroundData(StyleBackgroundData::create())
 141     , m_surroundData(StyleSurroundData::create())
 142     , m_rareNonInheritedData(StyleRareNonInheritedData::create())
 143     , m_rareInheritedData(StyleRareInheritedData::create())
 144     , m_inheritedData(StyleInheritedData::create())
 145     , m_svgStyle(SVGRenderStyle::create())
 146 {
 147     m_inheritedFlags.emptyCells = static_cast&lt;unsigned&gt;(initialEmptyCells());
 148     m_inheritedFlags.captionSide = static_cast&lt;unsigned&gt;(initialCaptionSide());
 149     m_inheritedFlags.listStyleType = static_cast&lt;unsigned&gt;(initialListStyleType());
 150     m_inheritedFlags.listStylePosition = static_cast&lt;unsigned&gt;(initialListStylePosition());
 151     m_inheritedFlags.visibility = static_cast&lt;unsigned&gt;(initialVisibility());
 152     m_inheritedFlags.textAlign = static_cast&lt;unsigned&gt;(initialTextAlign());
 153     m_inheritedFlags.textTransform = static_cast&lt;unsigned&gt;(initialTextTransform());
 154     m_inheritedFlags.textDecorations = initialTextDecoration().toRaw();
 155     m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(initialCursor());
 156 #if ENABLE(CURSOR_VISIBILITY)
 157     m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(initialCursorVisibility());
 158 #endif
 159     m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(initialDirection());
 160     m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(initialWhiteSpace());
 161     m_inheritedFlags.borderCollapse = static_cast&lt;unsigned&gt;(initialBorderCollapse());
 162     m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(initialRTLOrdering());
 163     m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(initialBoxDirection());
 164     m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(initialPrintColorAdjust());
 165     m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(initialPointerEvents());
 166     m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(InsideLink::NotInside);
 167     m_inheritedFlags.insideDefaultButton = false;
 168     m_inheritedFlags.writingMode = initialWritingMode();
 169 #if ENABLE(TEXT_AUTOSIZING)
 170     m_inheritedFlags.autosizeStatus = 0;
 171 #endif
 172 
 173     m_nonInheritedFlags.effectiveDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 174     m_nonInheritedFlags.originalDisplay = static_cast&lt;unsigned&gt;(initialDisplay());
 175     m_nonInheritedFlags.overflowX = static_cast&lt;unsigned&gt;(initialOverflowX());
 176     m_nonInheritedFlags.overflowY = static_cast&lt;unsigned&gt;(initialOverflowY());
 177     m_nonInheritedFlags.verticalAlign = static_cast&lt;unsigned&gt;(initialVerticalAlign());
 178     m_nonInheritedFlags.clear = static_cast&lt;unsigned&gt;(initialClear());
 179     m_nonInheritedFlags.position = static_cast&lt;unsigned&gt;(initialPosition());
 180     m_nonInheritedFlags.unicodeBidi = initialUnicodeBidi();
 181     m_nonInheritedFlags.floating = static_cast&lt;unsigned&gt;(initialFloating());
 182     m_nonInheritedFlags.tableLayout = static_cast&lt;unsigned&gt;(initialTableLayout());
 183     m_nonInheritedFlags.hasExplicitlySetDirection = false;
 184     m_nonInheritedFlags.hasExplicitlySetWritingMode = false;
 185     m_nonInheritedFlags.hasExplicitlySetTextAlign = false;
 186     m_nonInheritedFlags.hasViewportUnits = false;
 187     m_nonInheritedFlags.hasExplicitlyInheritedProperties = false;
 188     m_nonInheritedFlags.isUnique = false;
 189     m_nonInheritedFlags.emptyState = false;
 190     m_nonInheritedFlags.firstChildState = false;
 191     m_nonInheritedFlags.lastChildState = false;
 192     m_nonInheritedFlags.affectedByHover = false;
 193     m_nonInheritedFlags.affectedByActive = false;
 194     m_nonInheritedFlags.affectedByDrag = false;
 195     m_nonInheritedFlags.isLink = false;
 196     m_nonInheritedFlags.styleType = static_cast&lt;unsigned&gt;(PseudoId::None);
 197     m_nonInheritedFlags.pseudoBits = static_cast&lt;unsigned&gt;(PseudoId::None);
 198 
 199     static_assert((sizeof(InheritedFlags) &lt;= 8), &quot;InheritedFlags does not grow&quot;);
 200     static_assert((sizeof(NonInheritedFlags) &lt;= 8), &quot;NonInheritedFlags does not grow&quot;);
 201 }
 202 
 203 inline RenderStyle::RenderStyle(const RenderStyle&amp; other, CloneTag)
 204     : m_boxData(other.m_boxData)
 205     , m_visualData(other.m_visualData)
 206     , m_backgroundData(other.m_backgroundData)
 207     , m_surroundData(other.m_surroundData)
 208     , m_rareNonInheritedData(other.m_rareNonInheritedData)
 209     , m_nonInheritedFlags(other.m_nonInheritedFlags)
 210     , m_rareInheritedData(other.m_rareInheritedData)
 211     , m_inheritedData(other.m_inheritedData)
 212     , m_inheritedFlags(other.m_inheritedFlags)
 213     , m_svgStyle(other.m_svgStyle)
 214 {
 215 }
 216 
 217 inline RenderStyle::RenderStyle(RenderStyle&amp; a, RenderStyle&amp;&amp; b)
 218     : m_boxData(a.m_boxData.replace(WTFMove(b.m_boxData)))
 219     , m_visualData(a.m_visualData.replace(WTFMove(b.m_visualData)))
 220     , m_backgroundData(a.m_backgroundData.replace(WTFMove(b.m_backgroundData)))
 221     , m_surroundData(a.m_surroundData.replace(WTFMove(b.m_surroundData)))
 222     , m_rareNonInheritedData(a.m_rareNonInheritedData.replace(WTFMove(b.m_rareNonInheritedData)))
 223     , m_nonInheritedFlags(std::exchange(a.m_nonInheritedFlags, b.m_nonInheritedFlags))
 224     , m_rareInheritedData(a.m_rareInheritedData.replace(WTFMove(b.m_rareInheritedData)))
 225     , m_inheritedData(a.m_inheritedData.replace(WTFMove(b.m_inheritedData)))
 226     , m_inheritedFlags(std::exchange(a.m_inheritedFlags, b.m_inheritedFlags))
 227     , m_cachedPseudoStyles(std::exchange(a.m_cachedPseudoStyles, WTFMove(b.m_cachedPseudoStyles)))
 228     , m_svgStyle(a.m_svgStyle.replace(WTFMove(b.m_svgStyle)))
 229 {
 230 }
 231 
 232 RenderStyle::~RenderStyle()
 233 {
 234 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)
 235     ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 236     m_deletionHasBegun = true;
 237 #endif
 238 }
 239 
 240 RenderStyle RenderStyle::replace(RenderStyle&amp;&amp; newStyle)
 241 {
 242     return RenderStyle { *this, WTFMove(newStyle) };
 243 }
 244 
 245 static StyleSelfAlignmentData resolvedSelfAlignment(const StyleSelfAlignmentData&amp; value, ItemPosition normalValueBehavior)
 246 {
 247     if (value.position() == ItemPosition::Legacy || value.position() == ItemPosition::Normal || value.position() == ItemPosition::Auto)
 248         return { normalValueBehavior, OverflowAlignment::Default };
 249     return value;
 250 }
 251 
 252 StyleSelfAlignmentData RenderStyle::resolvedAlignItems(ItemPosition normalValueBehaviour) const
 253 {
 254     return resolvedSelfAlignment(alignItems(), normalValueBehaviour);
 255 }
 256 
 257 StyleSelfAlignmentData RenderStyle::resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const
 258 {
 259     // The auto keyword computes to the parent&#39;s align-items computed value.
 260     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 261     if (!parentStyle || alignSelf().position() != ItemPosition::Auto)
 262         return resolvedSelfAlignment(alignSelf(), normalValueBehaviour);
 263     return parentStyle-&gt;resolvedAlignItems(normalValueBehaviour);
 264 }
 265 
 266 StyleSelfAlignmentData RenderStyle::resolvedJustifyItems(ItemPosition normalValueBehaviour) const
 267 {
 268     return resolvedSelfAlignment(justifyItems(), normalValueBehaviour);
 269 }
 270 
 271 StyleSelfAlignmentData RenderStyle::resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const
 272 {
 273     // The auto keyword computes to the parent&#39;s justify-items computed value.
 274     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 275     if (!parentStyle || justifySelf().position() != ItemPosition::Auto)
 276         return resolvedSelfAlignment(justifySelf(), normalValueBehaviour);
 277     return parentStyle-&gt;resolvedJustifyItems(normalValueBehaviour);
 278 }
 279 
 280 static inline StyleContentAlignmentData resolvedContentAlignment(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 281 {
 282     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior : value;
 283 }
 284 
 285 StyleContentAlignmentData RenderStyle::resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehavior) const
 286 {
 287     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 288     return resolvedContentAlignment(alignContent(), normalValueBehavior);
 289 }
 290 
 291 StyleContentAlignmentData RenderStyle::resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehavior) const
 292 {
 293     // We will return the behaviour of &#39;normal&#39; value if needed, which is specific of each layout model.
 294     return resolvedContentAlignment(justifyContent(), normalValueBehavior);
 295 }
 296 
 297 static inline ContentPosition resolvedContentAlignmentPosition(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 298 {
 299     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior.position() : value.position();
 300 }
 301 
 302 static inline ContentDistribution resolvedContentAlignmentDistribution(const StyleContentAlignmentData&amp; value, const StyleContentAlignmentData&amp; normalValueBehavior)
 303 {
 304     return (value.position() == ContentPosition::Normal &amp;&amp; value.distribution() == ContentDistribution::Default) ? normalValueBehavior.distribution() : value.distribution();
 305 }
 306 
 307 ContentPosition RenderStyle::resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const
 308 {
 309     return resolvedContentAlignmentPosition(justifyContent(), normalValueBehavior);
 310 }
 311 
 312 ContentDistribution RenderStyle::resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const
 313 {
 314     return resolvedContentAlignmentDistribution(justifyContent(), normalValueBehavior);
 315 }
 316 
 317 ContentPosition RenderStyle::resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const
 318 {
 319     return resolvedContentAlignmentPosition(alignContent(), normalValueBehavior);
 320 }
 321 
 322 ContentDistribution RenderStyle::resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const
 323 {
 324     return resolvedContentAlignmentDistribution(alignContent(), normalValueBehavior);
 325 }
 326 
 327 void RenderStyle::inheritFrom(const RenderStyle&amp; inheritParent)
 328 {
 329     m_rareInheritedData = inheritParent.m_rareInheritedData;
 330     m_inheritedData = inheritParent.m_inheritedData;
 331     m_inheritedFlags = inheritParent.m_inheritedFlags;
 332 
 333     if (m_svgStyle != inheritParent.m_svgStyle)
 334         m_svgStyle.access().inheritFrom(inheritParent.m_svgStyle.get());
 335 }
 336 
 337 void RenderStyle::copyNonInheritedFrom(const RenderStyle&amp; other)
 338 {
 339     m_boxData = other.m_boxData;
 340     m_visualData = other.m_visualData;
 341     m_backgroundData = other.m_backgroundData;
 342     m_surroundData = other.m_surroundData;
 343     m_rareNonInheritedData = other.m_rareNonInheritedData;
 344     m_nonInheritedFlags.copyNonInheritedFrom(other.m_nonInheritedFlags);
 345 
 346     if (m_svgStyle != other.m_svgStyle)
 347         m_svgStyle.access().copyNonInheritedFrom(other.m_svgStyle.get());
 348 
 349     ASSERT(zoom() == initialZoom());
 350 }
 351 
 352 void RenderStyle::copyContentFrom(const RenderStyle&amp; other)
 353 {
 354     if (!other.m_rareNonInheritedData-&gt;content)
 355         return;
 356     m_rareNonInheritedData.access().content = other.m_rareNonInheritedData-&gt;content-&gt;clone();
 357 }
 358 
 359 bool RenderStyle::operator==(const RenderStyle&amp; other) const
 360 {
 361     // compare everything except the pseudoStyle pointer
 362     return m_inheritedFlags == other.m_inheritedFlags
 363         &amp;&amp; m_nonInheritedFlags == other.m_nonInheritedFlags
 364         &amp;&amp; m_boxData == other.m_boxData
 365         &amp;&amp; m_visualData == other.m_visualData
 366         &amp;&amp; m_backgroundData == other.m_backgroundData
 367         &amp;&amp; m_surroundData == other.m_surroundData
 368         &amp;&amp; m_rareNonInheritedData == other.m_rareNonInheritedData
 369         &amp;&amp; m_rareInheritedData == other.m_rareInheritedData
 370         &amp;&amp; m_inheritedData == other.m_inheritedData
 371         &amp;&amp; m_svgStyle == other.m_svgStyle;
 372 }
 373 
 374 bool RenderStyle::hasUniquePseudoStyle() const
 375 {
 376     if (!m_cachedPseudoStyles || styleType() != PseudoId::None)
 377         return false;
 378 
 379     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 380         if (pseudoStyle-&gt;unique())
 381             return true;
 382     }
 383 
 384     return false;
 385 }
 386 
 387 RenderStyle* RenderStyle::getCachedPseudoStyle(PseudoId pid) const
 388 {
 389     if (!m_cachedPseudoStyles || !m_cachedPseudoStyles-&gt;size())
 390         return nullptr;
 391 
 392     if (styleType() != PseudoId::None)
 393         return nullptr;
 394 
 395     for (auto&amp; pseudoStyle : *m_cachedPseudoStyles) {
 396         if (pseudoStyle-&gt;styleType() == pid)
 397             return pseudoStyle.get();
 398     }
 399 
 400     return nullptr;
 401 }
 402 
 403 RenderStyle* RenderStyle::addCachedPseudoStyle(std::unique_ptr&lt;RenderStyle&gt; pseudo)
 404 {
 405     if (!pseudo)
 406         return nullptr;
 407 
 408     ASSERT(pseudo-&gt;styleType() &gt; PseudoId::None);
 409 
 410     RenderStyle* result = pseudo.get();
 411 
 412     if (!m_cachedPseudoStyles)
 413         m_cachedPseudoStyles = makeUnique&lt;PseudoStyleCache&gt;();
 414 
 415     m_cachedPseudoStyles-&gt;append(WTFMove(pseudo));
 416 
 417     return result;
 418 }
 419 
 420 void RenderStyle::removeCachedPseudoStyle(PseudoId pid)
 421 {
 422     if (!m_cachedPseudoStyles)
 423         return;
 424     for (size_t i = 0; i &lt; m_cachedPseudoStyles-&gt;size(); ++i) {
 425         RenderStyle* pseudoStyle = m_cachedPseudoStyles-&gt;at(i).get();
 426         if (pseudoStyle-&gt;styleType() == pid) {
 427             m_cachedPseudoStyles-&gt;remove(i);
 428             return;
 429         }
 430     }
 431 }
 432 
 433 bool RenderStyle::inheritedEqual(const RenderStyle&amp; other) const
 434 {
 435     return m_inheritedFlags == other.m_inheritedFlags
 436         &amp;&amp; m_inheritedData == other.m_inheritedData
 437         &amp;&amp; (m_svgStyle.ptr() == other.m_svgStyle.ptr() || m_svgStyle-&gt;inheritedEqual(other.m_svgStyle))
 438         &amp;&amp; m_rareInheritedData == other.m_rareInheritedData;
 439 }
 440 
 441 bool RenderStyle::descendantAffectingNonInheritedPropertiesEqual(const RenderStyle&amp; other) const
 442 {
 443     if (m_rareNonInheritedData.ptr() == other.m_rareNonInheritedData.ptr())
 444         return true;
 445 
 446     return m_rareNonInheritedData-&gt;alignItems == other.m_rareNonInheritedData-&gt;alignItems
 447         &amp;&amp; m_rareNonInheritedData-&gt;justifyItems == other.m_rareNonInheritedData-&gt;justifyItems;
 448 }
 449 
 450 #if ENABLE(TEXT_AUTOSIZING)
 451 
 452 static inline unsigned computeFontHash(const FontCascade&amp; font)
 453 {
 454     IntegerHasher hasher;
 455     hasher.add(ASCIICaseInsensitiveHash::hash(font.fontDescription().firstFamily()));
 456     hasher.add(font.fontDescription().specifiedSize());
 457     return hasher.hash();
 458 }
 459 
 460 unsigned RenderStyle::hashForTextAutosizing() const
 461 {
 462     // FIXME: Not a very smart hash. Could be improved upon. See &lt;https://bugs.webkit.org/show_bug.cgi?id=121131&gt;.
 463     unsigned hash = m_rareNonInheritedData-&gt;appearance;
 464     hash ^= m_rareNonInheritedData-&gt;marginBeforeCollapse;
 465     hash ^= m_rareNonInheritedData-&gt;marginAfterCollapse;
 466     hash ^= m_rareNonInheritedData-&gt;lineClamp.value();
 467     hash ^= m_rareInheritedData-&gt;overflowWrap;
 468     hash ^= m_rareInheritedData-&gt;nbspMode;
 469     hash ^= m_rareInheritedData-&gt;lineBreak;
 470     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;specifiedLineHeight.value());
 471     hash ^= computeFontHash(m_inheritedData-&gt;fontCascade);
 472     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;horizontalBorderSpacing);
 473     hash ^= WTF::FloatHash&lt;float&gt;::hash(m_inheritedData-&gt;verticalBorderSpacing);
 474     hash ^= m_inheritedFlags.boxDirection;
 475     hash ^= m_inheritedFlags.rtlOrdering;
 476     hash ^= m_nonInheritedFlags.position;
 477     hash ^= m_nonInheritedFlags.floating;
 478     hash ^= m_rareNonInheritedData-&gt;textOverflow;
 479     hash ^= m_rareInheritedData-&gt;textSecurity;
 480     return hash;
 481 }
 482 
 483 bool RenderStyle::equalForTextAutosizing(const RenderStyle&amp; other) const
 484 {
 485     return m_rareNonInheritedData-&gt;appearance == other.m_rareNonInheritedData-&gt;appearance
 486         &amp;&amp; m_rareNonInheritedData-&gt;marginBeforeCollapse == other.m_rareNonInheritedData-&gt;marginBeforeCollapse
 487         &amp;&amp; m_rareNonInheritedData-&gt;marginAfterCollapse == other.m_rareNonInheritedData-&gt;marginAfterCollapse
 488         &amp;&amp; m_rareNonInheritedData-&gt;lineClamp == other.m_rareNonInheritedData-&gt;lineClamp
 489         &amp;&amp; m_rareInheritedData-&gt;textSizeAdjust == other.m_rareInheritedData-&gt;textSizeAdjust
 490         &amp;&amp; m_rareInheritedData-&gt;overflowWrap == other.m_rareInheritedData-&gt;overflowWrap
 491         &amp;&amp; m_rareInheritedData-&gt;nbspMode == other.m_rareInheritedData-&gt;nbspMode
 492         &amp;&amp; m_rareInheritedData-&gt;lineBreak == other.m_rareInheritedData-&gt;lineBreak
 493         &amp;&amp; m_rareInheritedData-&gt;textSecurity == other.m_rareInheritedData-&gt;textSecurity
 494         &amp;&amp; m_inheritedData-&gt;specifiedLineHeight == other.m_inheritedData-&gt;specifiedLineHeight
 495         &amp;&amp; m_inheritedData-&gt;fontCascade.equalForTextAutoSizing(other.m_inheritedData-&gt;fontCascade)
 496         &amp;&amp; m_inheritedData-&gt;horizontalBorderSpacing == other.m_inheritedData-&gt;horizontalBorderSpacing
 497         &amp;&amp; m_inheritedData-&gt;verticalBorderSpacing == other.m_inheritedData-&gt;verticalBorderSpacing
 498         &amp;&amp; m_inheritedFlags.boxDirection == other.m_inheritedFlags.boxDirection
 499         &amp;&amp; m_inheritedFlags.rtlOrdering == other.m_inheritedFlags.rtlOrdering
 500         &amp;&amp; m_nonInheritedFlags.position == other.m_nonInheritedFlags.position
 501         &amp;&amp; m_nonInheritedFlags.floating == other.m_nonInheritedFlags.floating
 502         &amp;&amp; m_rareNonInheritedData-&gt;textOverflow == other.m_rareNonInheritedData-&gt;textOverflow;
 503 }
 504 
 505 bool RenderStyle::isIdempotentTextAutosizingCandidate() const
 506 {
 507     // Refer to &lt;rdar://problem/51826266&gt; for more information regarding how this function was generated.
 508     auto fields = OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);
 509     if (fields.contains(AutosizeStatus::Fields::AvoidSubtree))
 510         return false;
 511 
 512     const float smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText = 5;
 513     const float largeMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText = 25;
 514 
 515     if (fields.contains(AutosizeStatus::Fields::FixedHeight)) {
 516         if (fields.contains(AutosizeStatus::Fields::FixedWidth)) {
 517             if (whiteSpace() == WhiteSpace::NoWrap) {
 518                 if (width().isFixed())
 519                     return false;
 520 
 521                 if (height().isFixed() &amp;&amp; specifiedLineHeight().isFixed()) {
 522                     float specifiedSize = specifiedFontSize();
 523                     if (height().value() == specifiedSize &amp;&amp; specifiedLineHeight().value() == specifiedSize)
 524                         return false;
 525                 }
 526 
 527                 return true;
 528             }
 529 
 530             if (fields.contains(AutosizeStatus::Fields::Floating)) {
 531                 if (specifiedLineHeight().isFixed() &amp;&amp; height().isFixed()) {
 532                     float specifiedSize = specifiedFontSize();
 533                     if (specifiedLineHeight().value() - specifiedSize &gt; smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText
 534                         &amp;&amp; height().value() - specifiedSize &gt; smallMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText) {
 535                         return true;
 536                     }
 537                 }
 538                 return false;
 539             }
 540 
 541             if (fields.contains(AutosizeStatus::Fields::OverflowXHidden))
 542                 return false;
 543 
 544             return true;
 545         }
 546 
 547         if (fields.contains(AutosizeStatus::Fields::OverflowXHidden)) {
 548             if (fields.contains(AutosizeStatus::Fields::Floating))
 549                 return false;
 550 
 551             return true;
 552         }
 553 
 554         return true;
 555     }
 556 
 557     if (width().isFixed()) {
 558         if (breakWords())
 559             return true;
 560 
 561         return false;
 562     }
 563 
 564     if (textSizeAdjust().isPercentage() &amp;&amp; textSizeAdjust().percentage() == 100) {
 565         if (fields.contains(AutosizeStatus::Fields::Floating))
 566             return true;
 567 
 568         if (fields.contains(AutosizeStatus::Fields::FixedWidth))
 569             return true;
 570 
 571         if (specifiedLineHeight().isFixed() &amp;&amp; specifiedLineHeight().value() - specifiedFontSize() &gt; largeMinimumDifferenceThresholdBetweenLineHeightAndSpecifiedFontSizeForBoostingText)
 572             return true;
 573 
 574         return false;
 575     }
 576 
 577     if (hasBackgroundImage() &amp;&amp; backgroundRepeatX() == FillRepeat::NoRepeat &amp;&amp; backgroundRepeatY() == FillRepeat::NoRepeat)
 578         return false;
 579 
 580     return true;
 581 }
 582 
 583 AutosizeStatus RenderStyle::autosizeStatus() const
 584 {
 585     return OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);
 586 }
 587 
 588 void RenderStyle::setAutosizeStatus(AutosizeStatus autosizeStatus)
 589 {
 590     m_inheritedFlags.autosizeStatus = autosizeStatus.fields().toRaw();
 591 }
 592 
 593 #endif // ENABLE(TEXT_AUTOSIZING)
 594 
 595 static bool positionChangeIsMovementOnly(const LengthBox&amp; a, const LengthBox&amp; b, const Length&amp; width)
 596 {
 597     // If any unit types are different, then we can&#39;t guarantee
 598     // that this was just a movement.
 599     if (a.left().type() != b.left().type()
 600         || a.right().type() != b.right().type()
 601         || a.top().type() != b.top().type()
 602         || a.bottom().type() != b.bottom().type())
 603         return false;
 604 
 605     // Only one unit can be non-auto in the horizontal direction and
 606     // in the vertical direction.  Otherwise the adjustment of values
 607     // is changing the size of the box.
 608     if (!a.left().isIntrinsicOrAuto() &amp;&amp; !a.right().isIntrinsicOrAuto())
 609         return false;
 610     if (!a.top().isIntrinsicOrAuto() &amp;&amp; !a.bottom().isIntrinsicOrAuto())
 611         return false;
 612     // If our width is auto and left or right is specified then this
 613     // is not just a movement - we need to resize to our container.
 614     if ((!a.left().isIntrinsicOrAuto() || !a.right().isIntrinsicOrAuto()) &amp;&amp; width.isIntrinsicOrAuto())
 615         return false;
 616 
 617     // One of the units is fixed or percent in both directions and stayed
 618     // that way in the new style.  Therefore all we are doing is moving.
 619     return true;
 620 }
 621 
 622 inline bool RenderStyle::changeAffectsVisualOverflow(const RenderStyle&amp; other) const
 623 {
 624     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 625         &amp;&amp; !arePointingToEqualData(m_rareNonInheritedData-&gt;boxShadow, other.m_rareNonInheritedData-&gt;boxShadow))
 626         return true;
 627 
 628     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 629         &amp;&amp; !arePointingToEqualData(m_rareInheritedData-&gt;textShadow, other.m_rareInheritedData-&gt;textShadow))
 630         return true;
 631 
 632     if (m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
 633         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
 634         || m_rareInheritedData-&gt;textDecorationThickness != other.m_rareInheritedData-&gt;textDecorationThickness
 635         || m_rareInheritedData-&gt;textUnderlineOffset != other.m_rareInheritedData-&gt;textUnderlineOffset
 636         || m_rareInheritedData-&gt;textUnderlinePosition != other.m_rareInheritedData-&gt;textUnderlinePosition) {
 637         // Underlines are always drawn outside of their textbox bounds when text-underline-position: under;
 638         // is specified. We can take an early out here.
 639         if (textUnderlinePosition() == TextUnderlinePosition::Under || other.textUnderlinePosition() == TextUnderlinePosition::Under)
 640             return true;
 641         return visualOverflowForDecorations(*this, nullptr) != visualOverflowForDecorations(other, nullptr);
 642     }
 643 
 644     if (hasOutlineInVisualOverflow() != other.hasOutlineInVisualOverflow())
 645         return true;
 646     return false;
 647 }
 648 
 649 static bool rareNonInheritedDataChangeRequiresLayout(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 650 {
 651     ASSERT(&amp;first != &amp;second);
 652 
 653     if (first.appearance != second.appearance
 654         || first.marginBeforeCollapse != second.marginBeforeCollapse
 655         || first.marginAfterCollapse != second.marginAfterCollapse
 656         || first.lineClamp != second.lineClamp
 657         || first.initialLetter != second.initialLetter
 658         || first.textOverflow != second.textOverflow)
 659         return true;
 660 
 661     if (first.shapeMargin != second.shapeMargin)
 662         return true;
 663 
 664     if (first.deprecatedFlexibleBox != second.deprecatedFlexibleBox)
 665         return true;
 666 
 667     if (first.flexibleBox != second.flexibleBox)
 668         return true;
 669 
 670     if (first.order != second.order
 671         || first.alignContent != second.alignContent
 672         || first.alignItems != second.alignItems
 673         || first.alignSelf != second.alignSelf
 674         || first.justifyContent != second.justifyContent
 675         || first.justifyItems != second.justifyItems
 676         || first.justifySelf != second.justifySelf)
 677         return true;
 678 
 679     if (!arePointingToEqualData(first.boxReflect, second.boxReflect))
 680         return true;
 681 
 682     if (first.multiCol != second.multiCol)
 683         return true;
 684 
 685     if (first.transform.ptr() != second.transform.ptr()) {
 686         if (first.transform-&gt;hasTransform() != second.transform-&gt;hasTransform())
 687             return true;
 688         if (*first.transform != *second.transform) {
 689             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Transform);
 690             // Don&#39;t return; keep looking for another change
 691         }
 692     }
 693 
 694     if (first.grid != second.grid
 695         || first.gridItem != second.gridItem)
 696         return true;
 697 
 698     if (!arePointingToEqualData(first.willChange, second.willChange)) {
 699         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::WillChange);
 700         // Don&#39;t return; keep looking for another change
 701     }
 702 
 703     if (first.textCombine != second.textCombine)
 704         return true;
 705 
 706     if (first.breakBefore != second.breakBefore
 707         || first.breakAfter != second.breakAfter
 708         || first.breakInside != second.breakInside)
 709         return true;
 710 
 711     if (first.hasOpacity() != second.hasOpacity()) {
 712         // FIXME: We would like to use SimplifiedLayout here, but we can&#39;t quite do that yet.
 713         // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 714         // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 715         // In addition we need to solve the floating object issue when layers come and go. Right now
 716         // a full layout is necessary to keep floating object lists sane.
 717         return true;
 718     }
 719 
 720 #if ENABLE(CSS_COMPOSITING)
 721     if (first.isolation != second.isolation) {
 722         // Ideally this would trigger a cheaper layout that just updates layer z-order trees (webit.org/b/190088).
 723         return true;
 724     }
 725 #endif
 726 
 727     if (first.hasFilters() != second.hasFilters())
 728         return true;
 729 
 730 #if ENABLE(FILTERS_LEVEL_2)
 731     if (first.hasBackdropFilters() != second.hasBackdropFilters())
 732         return true;
 733 #endif
 734 
 735     return false;
 736 }
 737 
 738 static bool rareInheritedDataChangeRequiresLayout(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
 739 {
 740     ASSERT(&amp;first != &amp;second);
 741 
 742     if (first.indent != second.indent
 743 #if ENABLE(CSS3_TEXT)
 744         || first.textAlignLast != second.textAlignLast
 745         || first.textJustify != second.textJustify
 746         || first.textIndentLine != second.textIndentLine
 747 #endif
 748         || first.effectiveZoom != second.effectiveZoom
 749         || first.textZoom != second.textZoom
 750 #if ENABLE(TEXT_AUTOSIZING)
 751         || first.textSizeAdjust != second.textSizeAdjust
 752 #endif
 753         || first.wordBreak != second.wordBreak
 754         || first.overflowWrap != second.overflowWrap
 755         || first.nbspMode != second.nbspMode
 756         || first.lineBreak != second.lineBreak
 757         || first.textSecurity != second.textSecurity
 758         || first.hyphens != second.hyphens
 759         || first.hyphenationLimitBefore != second.hyphenationLimitBefore
 760         || first.hyphenationLimitAfter != second.hyphenationLimitAfter
 761         || first.hyphenationString != second.hyphenationString
 762         || first.rubyPosition != second.rubyPosition
 763         || first.textEmphasisMark != second.textEmphasisMark
 764         || first.textEmphasisPosition != second.textEmphasisPosition
 765         || first.textEmphasisCustomMark != second.textEmphasisCustomMark
 766         || first.textOrientation != second.textOrientation
 767         || first.tabSize != second.tabSize
 768         || first.lineBoxContain != second.lineBoxContain
 769         || first.lineGrid != second.lineGrid
 770         || first.imageOrientation != second.imageOrientation
 771 #if ENABLE(CSS_IMAGE_RESOLUTION)
 772         || first.imageResolutionSource != second.imageResolutionSource
 773         || first.imageResolutionSnap != second.imageResolutionSnap
 774         || first.imageResolution != second.imageResolution
 775 #endif
 776         || first.lineSnap != second.lineSnap
 777         || first.lineAlign != second.lineAlign
 778         || first.hangingPunctuation != second.hangingPunctuation
 779 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 780         || first.useTouchOverflowScrolling != second.useTouchOverflowScrolling
 781 #endif
 782         || first.listStyleImage != second.listStyleImage) // FIXME: needs arePointingToEqualData()?
 783         return true;
 784 
 785     if (first.textStrokeWidth != second.textStrokeWidth)
 786         return true;
 787 
 788     // These properties affect the cached stroke bounding box rects.
 789     if (first.capStyle != second.capStyle
 790         || first.joinStyle != second.joinStyle
 791         || first.strokeWidth != second.strokeWidth
 792         || first.miterLimit != second.miterLimit)
 793         return true;
 794 
 795     if (!arePointingToEqualData(first.quotes, second.quotes))
 796         return true;
 797 
 798     return false;
 799 }
 800 
 801 bool RenderStyle::changeRequiresLayout(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 802 {
 803     if (m_boxData.ptr() != other.m_boxData.ptr()) {
 804         if (m_boxData-&gt;width() != other.m_boxData-&gt;width()
 805             || m_boxData-&gt;minWidth() != other.m_boxData-&gt;minWidth()
 806             || m_boxData-&gt;maxWidth() != other.m_boxData-&gt;maxWidth()
 807             || m_boxData-&gt;height() != other.m_boxData-&gt;height()
 808             || m_boxData-&gt;minHeight() != other.m_boxData-&gt;minHeight()
 809             || m_boxData-&gt;maxHeight() != other.m_boxData-&gt;maxHeight())
 810             return true;
 811 
 812         if (m_boxData-&gt;verticalAlign() != other.m_boxData-&gt;verticalAlign())
 813             return true;
 814 
 815         if (m_boxData-&gt;boxSizing() != other.m_boxData-&gt;boxSizing())
 816             return true;
 817     }
 818 
 819     if (m_surroundData-&gt;margin != other.m_surroundData-&gt;margin)
 820         return true;
 821 
 822     if (m_surroundData-&gt;padding != other.m_surroundData-&gt;padding)
 823         return true;
 824 
 825     // FIXME: We should add an optimized form of layout that just recomputes visual overflow.
 826     if (changeAffectsVisualOverflow(other))
 827         return true;
 828 
 829     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
 830         &amp;&amp; rareNonInheritedDataChangeRequiresLayout(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
 831         return true;
 832 
 833     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
 834         &amp;&amp; rareInheritedDataChangeRequiresLayout(*m_rareInheritedData, *other.m_rareInheritedData))
 835         return true;
 836 
 837     if (m_inheritedData.ptr() != other.m_inheritedData.ptr()) {
 838         if (m_inheritedData-&gt;lineHeight != other.m_inheritedData-&gt;lineHeight
 839 #if ENABLE(TEXT_AUTOSIZING)
 840             || m_inheritedData-&gt;specifiedLineHeight != other.m_inheritedData-&gt;specifiedLineHeight
 841 #endif
 842             || m_inheritedData-&gt;fontCascade != other.m_inheritedData-&gt;fontCascade
 843             || m_inheritedData-&gt;horizontalBorderSpacing != other.m_inheritedData-&gt;horizontalBorderSpacing
 844             || m_inheritedData-&gt;verticalBorderSpacing != other.m_inheritedData-&gt;verticalBorderSpacing)
 845             return true;
 846     }
 847 
 848     if (m_inheritedFlags.boxDirection != other.m_inheritedFlags.boxDirection
 849         || m_inheritedFlags.rtlOrdering != other.m_inheritedFlags.rtlOrdering
 850         || m_nonInheritedFlags.position != other.m_nonInheritedFlags.position
 851         || m_nonInheritedFlags.floating != other.m_nonInheritedFlags.floating
 852         || m_nonInheritedFlags.originalDisplay != other.m_nonInheritedFlags.originalDisplay
 853         || m_nonInheritedFlags.verticalAlign != other.m_nonInheritedFlags.verticalAlign)
 854         return true;
 855 
 856     if (static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay) &gt;= DisplayType::Table) {
 857         if (m_inheritedFlags.borderCollapse != other.m_inheritedFlags.borderCollapse
 858             || m_inheritedFlags.emptyCells != other.m_inheritedFlags.emptyCells
 859             || m_inheritedFlags.captionSide != other.m_inheritedFlags.captionSide
 860             || m_nonInheritedFlags.tableLayout != other.m_nonInheritedFlags.tableLayout)
 861             return true;
 862 
 863         // In the collapsing border model, &#39;hidden&#39; suppresses other borders, while &#39;none&#39;
 864         // does not, so these style differences can be width differences.
 865         if (m_inheritedFlags.borderCollapse
 866             &amp;&amp; ((borderTopStyle() == BorderStyle::Hidden &amp;&amp; other.borderTopStyle() == BorderStyle::None)
 867                 || (borderTopStyle() == BorderStyle::None &amp;&amp; other.borderTopStyle() == BorderStyle::Hidden)
 868                 || (borderBottomStyle() == BorderStyle::Hidden &amp;&amp; other.borderBottomStyle() == BorderStyle::None)
 869                 || (borderBottomStyle() == BorderStyle::None &amp;&amp; other.borderBottomStyle() == BorderStyle::Hidden)
 870                 || (borderLeftStyle() == BorderStyle::Hidden &amp;&amp; other.borderLeftStyle() == BorderStyle::None)
 871                 || (borderLeftStyle() == BorderStyle::None &amp;&amp; other.borderLeftStyle() == BorderStyle::Hidden)
 872                 || (borderRightStyle() == BorderStyle::Hidden &amp;&amp; other.borderRightStyle() == BorderStyle::None)
 873                 || (borderRightStyle() == BorderStyle::None &amp;&amp; other.borderRightStyle() == BorderStyle::Hidden)))
 874             return true;
 875     }
 876 
 877     if (static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay) == DisplayType::ListItem) {
 878         if (m_inheritedFlags.listStyleType != other.m_inheritedFlags.listStyleType
 879             || m_inheritedFlags.listStylePosition != other.m_inheritedFlags.listStylePosition)
 880             return true;
 881     }
 882 
 883     if (m_inheritedFlags.textAlign != other.m_inheritedFlags.textAlign
 884         || m_inheritedFlags.textTransform != other.m_inheritedFlags.textTransform
 885         || m_inheritedFlags.direction != other.m_inheritedFlags.direction
 886         || m_inheritedFlags.whiteSpace != other.m_inheritedFlags.whiteSpace
 887         || m_nonInheritedFlags.clear != other.m_nonInheritedFlags.clear
 888         || m_nonInheritedFlags.unicodeBidi != other.m_nonInheritedFlags.unicodeBidi)
 889         return true;
 890 
 891     // Check block flow direction.
 892     if (m_inheritedFlags.writingMode != other.m_inheritedFlags.writingMode)
 893         return true;
 894 
 895     // Overflow returns a layout hint.
 896     if (m_nonInheritedFlags.overflowX != other.m_nonInheritedFlags.overflowX
 897         || m_nonInheritedFlags.overflowY != other.m_nonInheritedFlags.overflowY)
 898         return true;
 899 
 900     // If our border widths change, then we need to layout.  Other changes to borders
 901     // only necessitate a repaint.
 902     if (borderLeftWidth() != other.borderLeftWidth()
 903         || borderTopWidth() != other.borderTopWidth()
 904         || borderBottomWidth() != other.borderBottomWidth()
 905         || borderRightWidth() != other.borderRightWidth())
 906         return true;
 907 
 908     // If the counter directives change, trigger a relayout to re-calculate counter values and rebuild the counter node tree.
 909     if (!arePointingToEqualData(m_rareNonInheritedData-&gt;counterDirectives, other.m_rareNonInheritedData-&gt;counterDirectives))
 910         return true;
 911 
 912     if ((visibility() == Visibility::Collapse) != (other.visibility() == Visibility::Collapse))
 913         return true;
 914 
 915     if (position() != PositionType::Static) {
 916         if (m_surroundData-&gt;offset != other.m_surroundData-&gt;offset) {
 917             // FIXME: We would like to use SimplifiedLayout for relative positioning, but we can&#39;t quite do that yet.
 918             // We need to make sure SimplifiedLayout can operate correctly on RenderInlines (we will need
 919             // to add a selfNeedsSimplifiedLayout bit in order to not get confused and taint every line).
 920             if (position() != PositionType::Absolute)
 921                 return true;
 922 
 923             // Optimize for the case where a positioned layer is moving but not changing size.
 924             if (!positionChangeIsMovementOnly(m_surroundData-&gt;offset, other.m_surroundData-&gt;offset, m_boxData-&gt;width()))
 925                 return true;
 926         }
 927     }
 928 
 929     bool hasFirstLineStyle = hasPseudoStyle(PseudoId::FirstLine);
 930     if (hasFirstLineStyle != other.hasPseudoStyle(PseudoId::FirstLine))
 931         return true;
 932     if (hasFirstLineStyle) {
 933         auto* firstLineStyle = getCachedPseudoStyle(PseudoId::FirstLine);
 934         if (!firstLineStyle)
 935             return true;
 936         auto* otherFirstLineStyle = other.getCachedPseudoStyle(PseudoId::FirstLine);
 937         if (!otherFirstLineStyle)
 938             return true;
 939         // FIXME: Not all first line style changes actually need layout.
 940         if (*firstLineStyle != *otherFirstLineStyle)
 941             return true;
 942     }
 943 
 944     return false;
 945 }
 946 
 947 bool RenderStyle::changeRequiresPositionedLayoutOnly(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
 948 {
 949     if (position() == PositionType::Static)
 950         return false;
 951 
 952     if (m_surroundData-&gt;offset != other.m_surroundData-&gt;offset) {
 953         // Optimize for the case where a positioned layer is moving but not changing size.
 954         if (position() == PositionType::Absolute &amp;&amp; positionChangeIsMovementOnly(m_surroundData-&gt;offset, other.m_surroundData-&gt;offset, m_boxData-&gt;width()))
 955             return true;
 956     }
 957 
 958     return false;
 959 }
 960 
 961 static bool rareNonInheritedDataChangeRequiresLayerRepaint(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
 962 {
 963 #if ENABLE(CSS_COMPOSITING)
 964     if (first.effectiveBlendMode != second.effectiveBlendMode)
 965         return true;
 966 #endif
 967 
 968     if (first.opacity != second.opacity) {
 969         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Opacity);
 970         // Don&#39;t return true; keep looking for another change.
 971     }
 972 
 973     if (first.filter != second.filter) {
 974         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 975         // Don&#39;t return true; keep looking for another change.
 976     }
 977 
 978 #if ENABLE(FILTERS_LEVEL_2)
 979     if (first.backdropFilter != second.backdropFilter) {
 980         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 981         // Don&#39;t return true; keep looking for another change.
 982     }
 983 #endif
 984 
 985     if (first.mask != second.mask || first.maskBoxImage != second.maskBoxImage)
 986         return true;
 987 
 988     return false;
 989 }
 990 
 991 bool RenderStyle::changeRequiresLayerRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 992 {
 993     // Style::Resolver has ensured that zIndex is non-auto only if it&#39;s applicable.
 994     if (m_boxData-&gt;usedZIndex() != other.m_boxData-&gt;usedZIndex() || m_boxData-&gt;hasAutoUsedZIndex() != other.m_boxData-&gt;hasAutoUsedZIndex())
 995         return true;
 996 
 997     if (position() != PositionType::Static) {
 998         if (m_visualData-&gt;clip != other.m_visualData-&gt;clip || m_visualData-&gt;hasClip != other.m_visualData-&gt;hasClip) {
 999             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipRect);
1000             return true;
1001         }
1002     }
1003 
1004     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
1005         &amp;&amp; rareNonInheritedDataChangeRequiresLayerRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
1006         return true;
1007 
1008     return false;
1009 }
1010 
1011 static bool requiresPainting(const RenderStyle&amp; style)
1012 {
1013     if (style.visibility() == Visibility::Hidden)
1014         return false;
1015     if (!style.opacity())
1016         return false;
1017     return true;
1018 }
1019 
1020 static bool rareNonInheritedDataChangeRequiresRepaint(const StyleRareNonInheritedData&amp; first, const StyleRareNonInheritedData&amp; second, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties)
1021 {
1022     if (first.userDrag != second.userDrag
1023         || first.borderFit != second.borderFit
1024         || first.objectFit != second.objectFit
1025         || first.objectPosition != second.objectPosition)
1026         return true;
1027 
1028     if (first.isNotFinal != second.isNotFinal)
1029         return true;
1030 
1031     if (first.shapeOutside != second.shapeOutside)
1032         return true;
1033 
1034     // FIXME: this should probably be moved to changeRequiresLayerRepaint().
1035     if (first.clipPath != second.clipPath) {
1036         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipPath);
1037         // Don&#39;t return true; keep looking for another change.
1038     }
1039 
1040     return false;
1041 }
1042 
1043 static bool rareInheritedDataChangeRequiresRepaint(const StyleRareInheritedData&amp; first, const StyleRareInheritedData&amp; second)
1044 {
1045     return first.userModify != second.userModify
1046         || first.userSelect != second.userSelect
1047         || first.appleColorFilter != second.appleColorFilter
1048         || first.imageRendering != second.imageRendering
1049 #if ENABLE(DARK_MODE_CSS)
1050         || first.colorScheme != second.colorScheme
1051 #endif
1052     ;
1053 }
1054 
1055 #if ENABLE(CSS_PAINTING_API)
1056 void RenderStyle::addCustomPaintWatchProperty(const String&amp; name)
1057 {
1058     auto&amp; data = m_rareNonInheritedData.access();
1059     if (!data.customPaintWatchedProperties)
1060         data.customPaintWatchedProperties = makeUnique&lt;HashSet&lt;String&gt;&gt;();
1061     data.customPaintWatchedProperties-&gt;add(name);
1062 }
1063 
1064 inline static bool changedCustomPaintWatchedProperty(const RenderStyle&amp; a, const StyleRareNonInheritedData&amp; aData, const RenderStyle&amp; b, const StyleRareNonInheritedData&amp; bData)
1065 {
1066     auto* propertiesA = aData.customPaintWatchedProperties.get();
1067     auto* propertiesB = bData.customPaintWatchedProperties.get();
1068 
1069     if (UNLIKELY(propertiesA || propertiesB)) {
1070         // FIXME: We should not need to use ComputedStyleExtractor here.
1071         ComputedStyleExtractor extractor((Element*) nullptr);
1072 
1073         for (auto* watchPropertiesMap : { propertiesA, propertiesB }) {
1074             if (!watchPropertiesMap)
1075                 continue;
1076 
1077             for (auto&amp; name : *watchPropertiesMap) {
1078                 RefPtr&lt;CSSValue&gt; valueA;
1079                 RefPtr&lt;CSSValue&gt; valueB;
1080                 if (isCustomPropertyName(name)) {
1081                     if (a.getCustomProperty(name))
1082                         valueA = CSSCustomPropertyValue::create(*a.getCustomProperty(name));
1083                     if (b.getCustomProperty(name))
1084                         valueB = CSSCustomPropertyValue::create(*b.getCustomProperty(name));
1085                 } else {
1086                     CSSPropertyID propertyID = cssPropertyID(name);
1087                     if (!propertyID)
1088                         continue;
1089                     valueA = extractor.valueForPropertyInStyle(a, propertyID);
1090                     valueB = extractor.valueForPropertyInStyle(b, propertyID);
1091                 }
1092 
1093                 if ((valueA &amp;&amp; !valueB) || (!valueA &amp;&amp; valueB))
1094                     return true;
1095 
1096                 if (!valueA)
1097                     continue;
1098 
1099                 if (!(*valueA == *valueB))
1100                     return true;
1101             }
1102         }
1103     }
1104 
1105     return false;
1106 }
1107 #endif
1108 
1109 bool RenderStyle::changeRequiresRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1110 {
1111     if (!requiresPainting(*this) &amp;&amp; !requiresPainting(other))
1112         return false;
1113 
1114     if (m_inheritedFlags.visibility != other.m_inheritedFlags.visibility
1115         || m_inheritedFlags.printColorAdjust != other.m_inheritedFlags.printColorAdjust
1116         || m_inheritedFlags.insideLink != other.m_inheritedFlags.insideLink
1117         || m_inheritedFlags.insideDefaultButton != other.m_inheritedFlags.insideDefaultButton
1118         || m_surroundData-&gt;border != other.m_surroundData-&gt;border
1119         || !m_backgroundData-&gt;isEquivalentForPainting(*other.m_backgroundData))
1120         return true;
1121 
1122     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
1123         &amp;&amp; rareNonInheritedDataChangeRequiresRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
1124         return true;
1125 
1126     if (m_rareInheritedData.ptr() != other.m_rareInheritedData.ptr()
1127         &amp;&amp; rareInheritedDataChangeRequiresRepaint(*m_rareInheritedData, *other.m_rareInheritedData))
1128         return true;
1129 
1130 #if ENABLE(CSS_PAINTING_API)
1131     if (changedCustomPaintWatchedProperty(*this, *m_rareNonInheritedData, other, *other.m_rareNonInheritedData))
1132         return true;
1133 #endif
1134 
1135     return false;
1136 }
1137 
1138 bool RenderStyle::changeRequiresRepaintIfTextOrBorderOrOutline(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
1139 {
1140     if (m_inheritedData-&gt;color != other.m_inheritedData-&gt;color
1141         || m_inheritedFlags.textDecorations != other.m_inheritedFlags.textDecorations
1142         || m_visualData-&gt;textDecoration != other.m_visualData-&gt;textDecoration
1143         || m_rareNonInheritedData-&gt;textDecorationStyle != other.m_rareNonInheritedData-&gt;textDecorationStyle
1144         || m_rareNonInheritedData-&gt;textDecorationColor != other.m_rareNonInheritedData-&gt;textDecorationColor
1145         || m_rareInheritedData-&gt;textDecorationSkip != other.m_rareInheritedData-&gt;textDecorationSkip
1146         || m_rareInheritedData-&gt;textFillColor != other.m_rareInheritedData-&gt;textFillColor
1147         || m_rareInheritedData-&gt;textStrokeColor != other.m_rareInheritedData-&gt;textStrokeColor
1148         || m_rareInheritedData-&gt;textEmphasisColor != other.m_rareInheritedData-&gt;textEmphasisColor
1149         || m_rareInheritedData-&gt;textEmphasisFill != other.m_rareInheritedData-&gt;textEmphasisFill
1150         || m_rareInheritedData-&gt;strokeColor != other.m_rareInheritedData-&gt;strokeColor
1151         || m_rareInheritedData-&gt;caretColor != other.m_rareInheritedData-&gt;caretColor)
1152         return true;
1153 
1154     return false;
1155 }
1156 
1157 bool RenderStyle::changeRequiresRecompositeLayer(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp;) const
1158 {
1159     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()) {
1160         if (m_rareNonInheritedData-&gt;transformStyle3D != other.m_rareNonInheritedData-&gt;transformStyle3D
1161             || m_rareNonInheritedData-&gt;backfaceVisibility != other.m_rareNonInheritedData-&gt;backfaceVisibility
1162             || m_rareNonInheritedData-&gt;perspective != other.m_rareNonInheritedData-&gt;perspective
1163             || m_rareNonInheritedData-&gt;perspectiveOriginX != other.m_rareNonInheritedData-&gt;perspectiveOriginX
1164             || m_rareNonInheritedData-&gt;perspectiveOriginY != other.m_rareNonInheritedData-&gt;perspectiveOriginY)
1165             return true;
1166     }
1167 
1168     return false;
1169 }
1170 
1171 StyleDifference RenderStyle::diff(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
1172 {
1173     changedContextSensitiveProperties = OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;();
1174 
1175     StyleDifference svgChange = StyleDifference::Equal;
1176     if (m_svgStyle != other.m_svgStyle) {
1177         svgChange = m_svgStyle-&gt;diff(other.m_svgStyle.get());
1178         if (svgChange == StyleDifference::Layout)
1179             return svgChange;
1180     }
1181 
1182     if (changeRequiresLayout(other, changedContextSensitiveProperties))
1183         return StyleDifference::Layout;
1184 
1185     // SVGRenderStyle::diff() might have returned StyleDifference::Repaint, eg. if fill changes.
1186     // If eg. the font-size changed at the same time, we&#39;re not allowed to return StyleDifference::Repaint,
1187     // but have to return StyleDifference::Layout, that&#39;s why  this if branch comes after all branches
1188     // that are relevant for SVG and might return StyleDifference::Layout.
1189     if (svgChange != StyleDifference::Equal)
1190         return svgChange;
1191 
1192     if (changeRequiresPositionedLayoutOnly(other, changedContextSensitiveProperties))
1193         return StyleDifference::LayoutPositionedMovementOnly;
1194 
1195     if (changeRequiresLayerRepaint(other, changedContextSensitiveProperties))
1196         return StyleDifference::RepaintLayer;
1197 
1198     if (changeRequiresRepaint(other, changedContextSensitiveProperties))
1199         return StyleDifference::Repaint;
1200 
1201     if (changeRequiresRecompositeLayer(other, changedContextSensitiveProperties))
1202         return StyleDifference::RecompositeLayer;
1203 
1204     if (changeRequiresRepaintIfTextOrBorderOrOutline(other, changedContextSensitiveProperties))
1205         return StyleDifference::RepaintIfTextOrBorderOrOutline;
1206 
1207     // Cursors are not checked, since they will be set appropriately in response to mouse events,
1208     // so they don&#39;t need to cause any repaint or layout.
1209 
1210     // Animations don&#39;t need to be checked either.  We always set the new style on the RenderObject, so we will get a chance to fire off
1211     // the resulting transition properly.
1212     return StyleDifference::Equal;
1213 }
1214 
1215 bool RenderStyle::diffRequiresLayerRepaint(const RenderStyle&amp; style, bool isComposited) const
1216 {
1217     OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt; changedContextSensitiveProperties;
1218 
1219     if (changeRequiresRepaint(style, changedContextSensitiveProperties))
1220         return true;
1221 
1222     if (isComposited &amp;&amp; changeRequiresLayerRepaint(style, changedContextSensitiveProperties))
1223         return changedContextSensitiveProperties.contains(StyleDifferenceContextSensitiveProperty::ClipRect);
1224 
1225     return false;
1226 }
1227 
1228 void RenderStyle::setClip(Length&amp;&amp; top, Length&amp;&amp; right, Length&amp;&amp; bottom, Length&amp;&amp; left)
1229 {
1230     auto&amp; data = m_visualData.access();
1231     data.clip.top() = WTFMove(top);
1232     data.clip.right() = WTFMove(right);
1233     data.clip.bottom() = WTFMove(bottom);
1234     data.clip.left() = WTFMove(left);
1235 }
1236 
1237 void RenderStyle::addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp; image, const IntPoint&amp; hotSpot)
1238 {
1239     auto&amp; cursorData = m_rareInheritedData.access().cursorData;
1240     if (!cursorData)
1241         cursorData = CursorList::create();
1242     cursorData-&gt;append(CursorData(WTFMove(image), hotSpot));
1243 }
1244 
1245 void RenderStyle::setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp; list)
1246 {
1247     m_rareInheritedData.access().cursorData = WTFMove(list);
1248 }
1249 
1250 void RenderStyle::setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp; q)
1251 {
1252     if (m_rareInheritedData-&gt;quotes == q || (m_rareInheritedData-&gt;quotes &amp;&amp; q &amp;&amp; *m_rareInheritedData-&gt;quotes == *q))
1253         return;
1254 
1255     m_rareInheritedData.access().quotes = WTFMove(q);
1256 }
1257 
1258 void RenderStyle::setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp; willChangeData)
1259 {
1260     if (arePointingToEqualData(m_rareNonInheritedData-&gt;willChange.get(), willChangeData.get()))
1261         return;
1262 
1263     m_rareNonInheritedData.access().willChange = WTFMove(willChangeData);
1264 }
1265 
1266 void RenderStyle::clearCursorList()
1267 {
1268     if (m_rareInheritedData-&gt;cursorData)
1269         m_rareInheritedData.access().cursorData = nullptr;
1270 }
1271 
1272 void RenderStyle::clearContent()
1273 {
1274     if (m_rareNonInheritedData-&gt;content)
1275         m_rareNonInheritedData.access().content = nullptr;
1276 }
1277 
1278 static inline ContentData&amp; lastContent(ContentData&amp; firstContent)
1279 {
1280     auto* lastContent = &amp;firstContent;
1281     for (auto* content = &amp;firstContent; content; content = content-&gt;next())
1282         lastContent = content;
1283     return *lastContent;
1284 }
1285 
1286 void RenderStyle::setContent(std::unique_ptr&lt;ContentData&gt; contentData, bool add)
1287 {
1288     auto&amp; data = m_rareNonInheritedData.access();
1289     if (add &amp;&amp; data.content)
1290         lastContent(*data.content).setNext(WTFMove(contentData));
1291     else {
1292         data.content = WTFMove(contentData);
1293         auto&amp; altText = data.altText;
1294         if (!altText.isNull())
1295             data.content-&gt;setAltText(altText);
1296     }
1297 }
1298 
1299 void RenderStyle::setContent(RefPtr&lt;StyleImage&gt;&amp;&amp; image, bool add)
1300 {
1301     if (!image)
1302         return;
1303     setContent(makeUnique&lt;ImageContentData&gt;(image.releaseNonNull()), add);
1304 }
1305 
1306 void RenderStyle::setContent(const String&amp; string, bool add)
1307 {
1308     auto&amp; data = m_rareNonInheritedData.access();
1309     if (add &amp;&amp; data.content) {
1310         auto&amp; last = lastContent(*data.content);
1311         if (!is&lt;TextContentData&gt;(last))
1312             last.setNext(makeUnique&lt;TextContentData&gt;(string));
1313         else {
1314             auto&amp; textContent = downcast&lt;TextContentData&gt;(last);
1315             textContent.setText(textContent.text() + string);
1316         }
1317     } else {
1318         data.content = makeUnique&lt;TextContentData&gt;(string);
1319         auto&amp; altText = data.altText;
1320         if (!altText.isNull())
1321             data.content-&gt;setAltText(altText);
1322     }
1323 }
1324 
1325 void RenderStyle::setContent(std::unique_ptr&lt;CounterContent&gt; counter, bool add)
1326 {
1327     if (!counter)
1328         return;
1329     setContent(makeUnique&lt;CounterContentData&gt;(WTFMove(counter)), add);
1330 }
1331 
1332 void RenderStyle::setContent(QuoteType quote, bool add)
1333 {
1334     setContent(makeUnique&lt;QuoteContentData&gt;(quote), add);
1335 }
1336 
1337 void RenderStyle::setContentAltText(const String&amp; string)
1338 {
1339     auto&amp; data = m_rareNonInheritedData.access();
1340     data.altText = string;
1341     if (data.content)
1342         data.content-&gt;setAltText(string);
1343 }
1344 
1345 const String&amp; RenderStyle::contentAltText() const
1346 {
1347     return m_rareNonInheritedData-&gt;altText;
1348 }
1349 
1350 void RenderStyle::setHasAttrContent()
1351 {
1352     setUnique();
1353     SET_VAR(m_rareNonInheritedData, hasAttrContent, true);
1354 }
1355 
1356 static inline bool requireTransformOrigin(const Vector&lt;RefPtr&lt;TransformOperation&gt;&gt;&amp; transformOperations, RenderStyle::ApplyTransformOrigin applyOrigin)
1357 {
1358     // The transform-origin property brackets the transform with translate operations.
1359     // When the only transform is a translation, the transform-origin is irrelevant.
1360 
1361     if (applyOrigin != RenderStyle::IncludeTransformOrigin)
1362         return false;
1363 
1364     for (auto&amp; operation : transformOperations) {
1365         // FIXME: Use affectedByTransformOrigin().
1366         auto type = operation-&gt;type();
1367         if (type != TransformOperation::TRANSLATE
1368             &amp;&amp; type != TransformOperation::TRANSLATE_3D
1369             &amp;&amp; type != TransformOperation::TRANSLATE_X
1370             &amp;&amp; type != TransformOperation::TRANSLATE_Y
1371             &amp;&amp; type != TransformOperation::TRANSLATE_Z)
1372             return true;
1373     }
1374 
1375     return false;
1376 }
1377 
1378 void RenderStyle::applyTransform(TransformationMatrix&amp; transform, const FloatRect&amp; boundingBox, ApplyTransformOrigin applyOrigin) const
1379 {
1380     auto&amp; operations = m_rareNonInheritedData-&gt;transform-&gt;operations.operations();
1381     bool applyTransformOrigin = requireTransformOrigin(operations, applyOrigin);
1382 
1383     FloatPoint3D originTranslate;
1384     if (applyTransformOrigin) {
1385         originTranslate.setX(boundingBox.x() + floatValueForLength(transformOriginX(), boundingBox.width()));
1386         originTranslate.setY(boundingBox.y() + floatValueForLength(transformOriginY(), boundingBox.height()));
1387         originTranslate.setZ(transformOriginZ());
1388         transform.translate3d(originTranslate.x(), originTranslate.y(), originTranslate.z());
1389     }
1390 
1391     for (auto&amp; operation : operations)
1392         operation-&gt;apply(transform, boundingBox.size());
1393 
1394     if (applyTransformOrigin)
1395         transform.translate3d(-originTranslate.x(), -originTranslate.y(), -originTranslate.z());
1396 }
1397 
1398 void RenderStyle::setPageScaleTransform(float scale)
1399 {
1400     if (scale == 1)
1401         return;
1402     TransformOperations transform;
1403     transform.operations().append(ScaleTransformOperation::create(scale, scale, ScaleTransformOperation::SCALE));
1404     setTransform(transform);
1405     setTransformOriginX(Length(0, Fixed));
1406     setTransformOriginY(Length(0, Fixed));
1407 }
1408 
1409 void RenderStyle::setTextShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1410 {
1411     ASSERT(!shadowData || (!shadowData-&gt;spread() &amp;&amp; shadowData-&gt;style() == ShadowStyle::Normal));
1412 
1413     auto&amp; rareData = m_rareInheritedData.access();
1414     if (!add) {
1415         rareData.textShadow = WTFMove(shadowData);
1416         return;
1417     }
1418 
1419     shadowData-&gt;setNext(WTFMove(rareData.textShadow));
1420     rareData.textShadow = WTFMove(shadowData);
1421 }
1422 
1423 void RenderStyle::setBoxShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1424 {
1425     auto&amp; rareData = m_rareNonInheritedData.access();
1426     if (!add) {
1427         rareData.boxShadow = WTFMove(shadowData);
1428         return;
1429     }
1430 
1431     shadowData-&gt;setNext(WTFMove(rareData.boxShadow));
1432     rareData.boxShadow = WTFMove(shadowData);
1433 }
1434 
1435 static RoundedRect::Radii calcRadiiFor(const BorderData&amp; border, const LayoutSize&amp; size)
1436 {
1437     return {
1438         sizeForLengthSize(border.topLeftRadius(), size),
1439         sizeForLengthSize(border.topRightRadius(), size),
1440         sizeForLengthSize(border.bottomLeftRadius(), size),
1441         sizeForLengthSize(border.bottomRightRadius(), size)
1442     };
1443 }
1444 
1445 StyleImage* RenderStyle::listStyleImage() const
1446 {
1447     return m_rareInheritedData-&gt;listStyleImage.get();
1448 }
1449 
1450 void RenderStyle::setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v)
1451 {
1452     if (m_rareInheritedData-&gt;listStyleImage != v)
1453         m_rareInheritedData.access().listStyleImage = WTFMove(v);
1454 }
1455 
1456 const Color&amp; RenderStyle::color() const
1457 {
1458     return m_inheritedData-&gt;color;
1459 }
1460 
1461 const Color&amp; RenderStyle::visitedLinkColor() const
1462 {
1463     return m_inheritedData-&gt;visitedLinkColor;
1464 }
1465 
1466 void RenderStyle::setColor(const Color&amp; v)
1467 {
1468     SET_VAR(m_inheritedData, color, v);
1469 }
1470 
1471 void RenderStyle::setVisitedLinkColor(const Color&amp; v)
1472 {
1473     SET_VAR(m_inheritedData, visitedLinkColor, v);
1474 }
1475 
1476 float RenderStyle::horizontalBorderSpacing() const
1477 {
1478     return m_inheritedData-&gt;horizontalBorderSpacing;
1479 }
1480 
1481 float RenderStyle::verticalBorderSpacing() const
1482 {
1483     return m_inheritedData-&gt;verticalBorderSpacing;
1484 }
1485 
1486 void RenderStyle::setHorizontalBorderSpacing(float v)
1487 {
1488     SET_VAR(m_inheritedData, horizontalBorderSpacing, v);
1489 }
1490 
1491 void RenderStyle::setVerticalBorderSpacing(float v)
1492 {
1493     SET_VAR(m_inheritedData, verticalBorderSpacing, v);
1494 }
1495 
1496 RoundedRect RenderStyle::getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1497 {
1498     RoundedRect roundedRect(borderRect);
1499     if (hasBorderRadius()) {
1500         RoundedRect::Radii radii = calcRadiiFor(m_surroundData-&gt;border, borderRect.size());
1501         radii.scale(calcBorderRadiiConstraintScaleFor(borderRect, radii));
1502         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1503     }
1504     return roundedRect;
1505 }
1506 
1507 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1508 {
1509     bool horizontal = isHorizontalWritingMode();
1510     LayoutUnit leftWidth { (!horizontal || includeLogicalLeftEdge) ? borderLeftWidth() : 0 };
1511     LayoutUnit rightWidth { (!horizontal || includeLogicalRightEdge) ? borderRightWidth() : 0 };
1512     LayoutUnit topWidth { (horizontal || includeLogicalLeftEdge) ? borderTopWidth() : 0 };
1513     LayoutUnit bottomWidth { (horizontal || includeLogicalRightEdge) ? borderBottomWidth() : 0 };
1514     return getRoundedInnerBorderFor(borderRect, topWidth, bottomWidth, leftWidth, rightWidth, includeLogicalLeftEdge, includeLogicalRightEdge);
1515 }
1516 
1517 RoundedRect RenderStyle::getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
1518     LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge, bool includeLogicalRightEdge) const
1519 {
1520     RoundedRect roundedRect { { borderRect.x() + leftWidth, borderRect.y() + topWidth,
1521         borderRect.width() - leftWidth - rightWidth, borderRect.height() - topWidth - bottomWidth } };
1522     if (hasBorderRadius()) {
1523         auto radii = getRoundedBorderFor(borderRect).radii();
1524         radii.shrink(topWidth, bottomWidth, leftWidth, rightWidth);
1525         roundedRect.includeLogicalEdges(radii, isHorizontalWritingMode(), includeLogicalLeftEdge, includeLogicalRightEdge);
1526     }
1527     return roundedRect;
1528 }
1529 
1530 static bool allLayersAreFixed(const FillLayer&amp; layers)
1531 {
1532     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1533         if (!(layer-&gt;image() &amp;&amp; layer-&gt;attachment() == FillAttachment::FixedBackground))
1534             return false;
1535     }
1536     return true;
1537 }
1538 
1539 bool RenderStyle::hasEntirelyFixedBackground() const
1540 {
1541     return allLayersAreFixed(backgroundLayers());
1542 }
1543 
1544 const CounterDirectiveMap* RenderStyle::counterDirectives() const
1545 {
1546     return m_rareNonInheritedData-&gt;counterDirectives.get();
1547 }
1548 
1549 CounterDirectiveMap&amp; RenderStyle::accessCounterDirectives()
1550 {
1551     auto&amp; map = m_rareNonInheritedData.access().counterDirectives;
1552     if (!map)
1553         map = makeUnique&lt;CounterDirectiveMap&gt;();
1554     return *map;
1555 }
1556 
1557 const AtomString&amp; RenderStyle::hyphenString() const
1558 {
1559     ASSERT(hyphens() != Hyphens::None);
1560 
1561     auto&amp; hyphenationString = m_rareInheritedData-&gt;hyphenationString;
1562     if (!hyphenationString.isNull())
1563         return hyphenationString;
1564 
1565     // FIXME: This should depend on locale.
1566     static NeverDestroyed&lt;AtomString&gt; hyphenMinusString(&amp;hyphenMinus, 1);
1567     static NeverDestroyed&lt;AtomString&gt; hyphenString(&amp;hyphen, 1);
1568     return fontCascade().primaryFont().glyphForCharacter(hyphen) ? hyphenString : hyphenMinusString;
1569 }
1570 
1571 const AtomString&amp; RenderStyle::textEmphasisMarkString() const
1572 {
1573     switch (textEmphasisMark()) {
1574     case TextEmphasisMark::None:
1575         return nullAtom();
1576     case TextEmphasisMark::Custom:
1577         return textEmphasisCustomMark();
1578     case TextEmphasisMark::Dot: {
1579         static NeverDestroyed&lt;AtomString&gt; filledDotString(&amp;bullet, 1);
1580         static NeverDestroyed&lt;AtomString&gt; openDotString(&amp;whiteBullet, 1);
1581         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDotString : openDotString;
1582     }
1583     case TextEmphasisMark::Circle: {
1584         static NeverDestroyed&lt;AtomString&gt; filledCircleString(&amp;blackCircle, 1);
1585         static NeverDestroyed&lt;AtomString&gt; openCircleString(&amp;whiteCircle, 1);
1586         return textEmphasisFill() == TextEmphasisFill::Filled ? filledCircleString : openCircleString;
1587     }
1588     case TextEmphasisMark::DoubleCircle: {
1589         static NeverDestroyed&lt;AtomString&gt; filledDoubleCircleString(&amp;fisheye, 1);
1590         static NeverDestroyed&lt;AtomString&gt; openDoubleCircleString(&amp;bullseye, 1);
1591         return textEmphasisFill() == TextEmphasisFill::Filled ? filledDoubleCircleString : openDoubleCircleString;
1592     }
1593     case TextEmphasisMark::Triangle: {
1594         static NeverDestroyed&lt;AtomString&gt; filledTriangleString(&amp;blackUpPointingTriangle, 1);
1595         static NeverDestroyed&lt;AtomString&gt; openTriangleString(&amp;whiteUpPointingTriangle, 1);
1596         return textEmphasisFill() == TextEmphasisFill::Filled ? filledTriangleString : openTriangleString;
1597     }
1598     case TextEmphasisMark::Sesame: {
1599         static NeverDestroyed&lt;AtomString&gt; filledSesameString(&amp;sesameDot, 1);
1600         static NeverDestroyed&lt;AtomString&gt; openSesameString(&amp;whiteSesameDot, 1);
1601         return textEmphasisFill() == TextEmphasisFill::Filled ? filledSesameString : openSesameString;
1602     }
1603     case TextEmphasisMark::Auto:
1604         ASSERT_NOT_REACHED();
1605         return nullAtom();
1606     }
1607 
1608     ASSERT_NOT_REACHED();
1609     return nullAtom();
1610 }
1611 
1612 void RenderStyle::adjustAnimations()
1613 {
1614     auto* animationList = m_rareNonInheritedData-&gt;animations.get();
1615     if (!animationList)
1616         return;
1617 
1618     // Get rid of empty animations and anything beyond them
1619     for (size_t i = 0, size = animationList-&gt;size(); i &lt; size; ++i) {
1620         if (animationList-&gt;animation(i).isEmpty()) {
1621             animationList-&gt;resize(i);
1622             break;
1623         }
1624     }
1625 
1626     if (animationList-&gt;isEmpty()) {
1627         clearAnimations();
1628         return;
1629     }
1630 
1631     // Repeat patterns into layers that don&#39;t have some properties set.
1632     animationList-&gt;fillUnsetProperties();
1633 }
1634 
1635 void RenderStyle::adjustTransitions()
1636 {
1637     auto* transitionList = m_rareNonInheritedData-&gt;transitions.get();
1638     if (!transitionList)
1639         return;
1640 
1641     // Get rid of empty transitions and anything beyond them
1642     for (size_t i = 0, size = transitionList-&gt;size(); i &lt; size; ++i) {
1643         if (transitionList-&gt;animation(i).isEmpty()) {
1644             transitionList-&gt;resize(i);
1645             break;
1646         }
1647     }
1648 
1649     if (transitionList-&gt;isEmpty()) {
1650         clearTransitions();
1651         return;
1652     }
1653 
1654     // Repeat patterns into layers that don&#39;t have some properties set.
1655     transitionList-&gt;fillUnsetProperties();
1656 
1657     // Make sure there are no duplicate properties.
1658     // This is an O(n^2) algorithm but the lists tend to be short, so it is probably OK.
1659     for (size_t i = 0; i &lt; transitionList-&gt;size(); ++i) {
1660         for (size_t j = i + 1; j &lt; transitionList-&gt;size(); ++j) {
1661             if (transitionList-&gt;animation(i).property() == transitionList-&gt;animation(j).property()) {
1662                 // toss i
1663                 transitionList-&gt;remove(i);
1664                 j = i;
1665             }
1666         }
1667     }
1668 }
1669 
1670 AnimationList&amp; RenderStyle::ensureAnimations()
1671 {
1672     if (!m_rareNonInheritedData.access().animations)
1673         m_rareNonInheritedData.access().animations = AnimationList::create();
1674     return *m_rareNonInheritedData-&gt;animations;
1675 }
1676 
1677 AnimationList&amp; RenderStyle::ensureTransitions()
1678 {
1679     if (!m_rareNonInheritedData.access().transitions)
1680         m_rareNonInheritedData.access().transitions = AnimationList::create();
1681     return *m_rareNonInheritedData-&gt;transitions;
1682 }
1683 
1684 const Animation* RenderStyle::transitionForProperty(CSSPropertyID property) const
1685 {
1686     auto* transitions = this-&gt;transitions();
1687     if (!transitions)
1688         return nullptr;
1689     for (size_t i = 0, size = transitions-&gt;size(); i &lt; size; ++i) {
1690         auto&amp; animation = transitions-&gt;animation(i);
1691         if (animation.animationMode() == Animation::AnimateAll || animation.property() == property)
1692             return &amp;animation;
1693     }
1694     return nullptr;
1695 }
1696 
1697 const FontCascade&amp; RenderStyle::fontCascade() const
1698 {
1699     return m_inheritedData-&gt;fontCascade;
1700 }
1701 
1702 const FontMetrics&amp; RenderStyle::fontMetrics() const
1703 {
1704     return m_inheritedData-&gt;fontCascade.fontMetrics();
1705 }
1706 
1707 const FontCascadeDescription&amp; RenderStyle::fontDescription() const
1708 {
1709     return m_inheritedData-&gt;fontCascade.fontDescription();
1710 }
1711 
1712 float RenderStyle::specifiedFontSize() const
1713 {
1714     return fontDescription().specifiedSize();
1715 }
1716 
1717 float RenderStyle::computedFontSize() const
1718 {
1719     return fontDescription().computedSize();
1720 }
1721 
1722 unsigned RenderStyle::computedFontPixelSize() const
1723 {
1724     return fontDescription().computedPixelSize();
1725 }
1726 
1727 const Length&amp; RenderStyle::wordSpacing() const
1728 {
1729     return m_rareInheritedData-&gt;wordSpacing;
1730 }
1731 
1732 float RenderStyle::letterSpacing() const
1733 {
1734     return m_inheritedData-&gt;fontCascade.letterSpacing();
1735 }
1736 
1737 bool RenderStyle::setFontDescription(FontCascadeDescription&amp;&amp; description)
1738 {
1739     if (m_inheritedData-&gt;fontCascade.fontDescription() == description)
1740         return false;
1741     auto&amp; cascade = m_inheritedData.access().fontCascade;
1742     cascade = { WTFMove(description), cascade.letterSpacing(), cascade.wordSpacing() };
1743     return true;
1744 }
1745 
1746 const Length&amp; RenderStyle::specifiedLineHeight() const
1747 {
1748 #if ENABLE(TEXT_AUTOSIZING)
1749     return m_inheritedData-&gt;specifiedLineHeight;
1750 #else
1751     return m_inheritedData-&gt;lineHeight;
1752 #endif
1753 }
1754 
1755 #if ENABLE(TEXT_AUTOSIZING)
1756 
1757 void RenderStyle::setSpecifiedLineHeight(Length&amp;&amp; height)
1758 {
1759     SET_VAR(m_inheritedData, specifiedLineHeight, WTFMove(height));
1760 }
1761 
1762 #endif
1763 
1764 const Length&amp; RenderStyle::lineHeight() const
1765 {
1766     return m_inheritedData-&gt;lineHeight;
1767 }
1768 
1769 void RenderStyle::setLineHeight(Length&amp;&amp; height)
1770 {
1771     SET_VAR(m_inheritedData, lineHeight, WTFMove(height));
1772 }
1773 
1774 int RenderStyle::computedLineHeight() const
1775 {
1776     const Length&amp; lh = lineHeight();
1777 
1778     // Negative value means the line height is not set. Use the font&#39;s built-in spacing.
1779     if (lh.isNegative())
1780         return fontMetrics().lineSpacing();
1781 
1782     if (lh.isPercentOrCalculated())
1783         return minimumValueForLength(lh, computedFontPixelSize());
1784 
1785     return clampTo&lt;int&gt;(lh.value());
1786 }
1787 
1788 void RenderStyle::setWordSpacing(Length&amp;&amp; value)
1789 {
1790     float fontWordSpacing;
1791     switch (value.type()) {
1792     case Auto:
1793         fontWordSpacing = 0;
1794         break;
1795     case Percent:
1796         fontWordSpacing = value.percent() * fontCascade().spaceWidth() / 100;
1797         break;
1798     case Fixed:
1799         fontWordSpacing = value.value();
1800         break;
1801     case Calculated:
1802         fontWordSpacing = value.nonNanCalculatedValue(maxValueForCssLength);
1803         break;
1804     default:
1805         ASSERT_NOT_REACHED();
1806         fontWordSpacing = 0;
1807         break;
1808     }
1809     m_inheritedData.access().fontCascade.setWordSpacing(fontWordSpacing);
1810     m_rareInheritedData.access().wordSpacing = WTFMove(value);
1811 }
1812 
1813 void RenderStyle::setLetterSpacing(float v) { m_inheritedData.access().fontCascade.setLetterSpacing(v); }
1814 
1815 void RenderStyle::setFontSize(float size)
1816 {
1817     // size must be specifiedSize if Text Autosizing is enabled, but computedSize if text
1818     // zoom is enabled (if neither is enabled it&#39;s irrelevant as they&#39;re probably the same).
1819 
1820     ASSERT(std::isfinite(size));
1821     if (!std::isfinite(size) || size &lt; 0)
1822         size = 0;
1823     else
1824         size = std::min(maximumAllowedFontSize, size);
1825 
1826     FontSelector* currentFontSelector = fontCascade().fontSelector();
1827     auto description = fontDescription();
1828     description.setSpecifiedSize(size);
1829     description.setComputedSize(size);
1830 
1831     setFontDescription(WTFMove(description));
1832     fontCascade().update(currentFontSelector);
1833 }
1834 
1835 #if ENABLE(VARIATION_FONTS)
1836 void RenderStyle::setFontVariationSettings(FontVariationSettings settings)
1837 {
1838     FontSelector* currentFontSelector = fontCascade().fontSelector();
1839     auto description = fontDescription();
1840     description.setVariationSettings(WTFMove(settings));
1841 
1842     setFontDescription(WTFMove(description));
1843     fontCascade().update(currentFontSelector);
1844 }
1845 #endif
1846 
1847 void RenderStyle::setFontWeight(FontSelectionValue value)
1848 {
1849     FontSelector* currentFontSelector = fontCascade().fontSelector();
1850     auto description = fontDescription();
1851     description.setWeight(value);
1852 
1853     setFontDescription(WTFMove(description));
1854     fontCascade().update(currentFontSelector);
1855 }
1856 
1857 void RenderStyle::setFontStretch(FontSelectionValue value)
1858 {
1859     FontSelector* currentFontSelector = fontCascade().fontSelector();
1860     auto description = fontDescription();
1861     description.setStretch(value);
1862 
1863     setFontDescription(WTFMove(description));
1864     fontCascade().update(currentFontSelector);
1865 }
1866 
1867 void RenderStyle::setFontItalic(Optional&lt;FontSelectionValue&gt; value)
1868 {
1869     FontSelector* currentFontSelector = fontCascade().fontSelector();
1870     auto description = fontDescription();
1871     description.setItalic(value);
1872 
1873     setFontDescription(WTFMove(description));
1874     fontCascade().update(currentFontSelector);
1875 }
1876 
1877 void RenderStyle::getShadowExtent(const ShadowData* shadow, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const
1878 {
1879     top = 0;
1880     right = 0;
1881     bottom = 0;
1882     left = 0;
1883 
1884     for ( ; shadow; shadow = shadow-&gt;next()) {
1885         if (shadow-&gt;style() == ShadowStyle::Inset)
1886             continue;
1887 
1888         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1889         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1890         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1891         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1892         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1893     }
1894 }
1895 
1896 LayoutBoxExtent RenderStyle::getShadowInsetExtent(const ShadowData* shadow) const
1897 {
1898     LayoutUnit top;
1899     LayoutUnit right;
1900     LayoutUnit bottom;
1901     LayoutUnit left;
1902 
1903     for ( ; shadow; shadow = shadow-&gt;next()) {
1904         if (shadow-&gt;style() == ShadowStyle::Normal)
1905             continue;
1906 
1907         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1908         top = std::max&lt;LayoutUnit&gt;(top, shadow-&gt;y() + extentAndSpread);
1909         right = std::min&lt;LayoutUnit&gt;(right, shadow-&gt;x() - extentAndSpread);
1910         bottom = std::min&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() - extentAndSpread);
1911         left = std::max&lt;LayoutUnit&gt;(left, shadow-&gt;x() + extentAndSpread);
1912     }
1913 
1914     return LayoutBoxExtent(WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left));
1915 }
1916 
1917 void RenderStyle::getShadowHorizontalExtent(const ShadowData* shadow, LayoutUnit &amp;left, LayoutUnit &amp;right) const
1918 {
1919     left = 0;
1920     right = 0;
1921 
1922     for ( ; shadow; shadow = shadow-&gt;next()) {
1923         if (shadow-&gt;style() == ShadowStyle::Inset)
1924             continue;
1925 
1926         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1927         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1928         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1929     }
1930 }
1931 
1932 void RenderStyle::getShadowVerticalExtent(const ShadowData* shadow, LayoutUnit &amp;top, LayoutUnit &amp;bottom) const
1933 {
1934     top = 0;
1935     bottom = 0;
1936 
1937     for ( ; shadow; shadow = shadow-&gt;next()) {
1938         if (shadow-&gt;style() == ShadowStyle::Inset)
1939             continue;
1940 
1941         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();
1942         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1943         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1944     }
1945 }
1946 
1947 Color RenderStyle::colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const
1948 {
1949     Color result;
1950     BorderStyle borderStyle = BorderStyle::None;
1951     switch (colorProperty) {
1952     case CSSPropertyBackgroundColor:
1953         return visitedLink ? visitedLinkBackgroundColor() : backgroundColor(); // Background color doesn&#39;t fall back.
1954     case CSSPropertyBorderLeftColor:
1955         result = visitedLink ? visitedLinkBorderLeftColor() : borderLeftColor();
1956         borderStyle = borderLeftStyle();
1957         break;
1958     case CSSPropertyBorderRightColor:
1959         result = visitedLink ? visitedLinkBorderRightColor() : borderRightColor();
1960         borderStyle = borderRightStyle();
1961         break;
1962     case CSSPropertyBorderTopColor:
1963         result = visitedLink ? visitedLinkBorderTopColor() : borderTopColor();
1964         borderStyle = borderTopStyle();
1965         break;
1966     case CSSPropertyBorderBottomColor:
1967         result = visitedLink ? visitedLinkBorderBottomColor() : borderBottomColor();
1968         borderStyle = borderBottomStyle();
1969         break;
1970     case CSSPropertyCaretColor:
1971         result = visitedLink ? visitedLinkCaretColor() : caretColor();
1972         break;
1973     case CSSPropertyColor:
1974         result = visitedLink ? visitedLinkColor() : color();
1975         break;
1976     case CSSPropertyOutlineColor:
1977         result = visitedLink ? visitedLinkOutlineColor() : outlineColor();
1978         break;
1979     case CSSPropertyColumnRuleColor:
1980         result = visitedLink ? visitedLinkColumnRuleColor() : columnRuleColor();
1981         break;
1982     case CSSPropertyTextDecorationColor:
1983         // Text decoration color fallback is handled in RenderObject::decorationColor.
1984         return visitedLink ? visitedLinkTextDecorationColor() : textDecorationColor();
1985     case CSSPropertyWebkitTextEmphasisColor:
1986         result = visitedLink ? visitedLinkTextEmphasisColor() : textEmphasisColor();
1987         break;
1988     case CSSPropertyWebkitTextFillColor:
1989         result = visitedLink ? visitedLinkTextFillColor() : textFillColor();
1990         break;
1991     case CSSPropertyWebkitTextStrokeColor:
1992         result = visitedLink ? visitedLinkTextStrokeColor() : textStrokeColor();
1993         break;
1994     case CSSPropertyStrokeColor:
1995         result = visitedLink ? visitedLinkStrokeColor() : strokeColor();
1996         break;
1997     default:
1998         ASSERT_NOT_REACHED();
1999         break;
2000     }
2001 
2002     if (!result.isValid()) {
2003         if (!visitedLink &amp;&amp; (borderStyle == BorderStyle::Inset || borderStyle == BorderStyle::Outset || borderStyle == BorderStyle::Ridge || borderStyle == BorderStyle::Groove))
2004             result = Color(238, 238, 238);
2005         else
2006             result = visitedLink ? visitedLinkColor() : color();
2007     }
2008     return result;
2009 }
2010 
2011 Color RenderStyle::visitedDependentColor(CSSPropertyID colorProperty) const
2012 {
2013     Color unvisitedColor = colorIncludingFallback(colorProperty, false);
2014     if (insideLink() != InsideLink::InsideVisited)
2015         return unvisitedColor;
2016 
2017     Color visitedColor = colorIncludingFallback(colorProperty, true);
2018 
2019     // Text decoration color validity is preserved (checked in RenderObject::decorationColor).
2020     if (colorProperty == CSSPropertyTextDecorationColor)
2021         return visitedColor;
2022 
2023     // FIXME: Technically someone could explicitly specify the color transparent, but for now we&#39;ll just
2024     // assume that if the background color is transparent that it wasn&#39;t set. Note that it&#39;s weird that
2025     // we&#39;re returning unvisited info for a visited link, but given our restriction that the alpha values
2026     // have to match, it makes more sense to return the unvisited background color if specified than it
2027     // does to return black. This behavior matches what Firefox 4 does as well.
2028     if (colorProperty == CSSPropertyBackgroundColor &amp;&amp; visitedColor == Color::transparent)
2029         return unvisitedColor;
2030 
2031     // Take the alpha from the unvisited color, but get the RGB values from the visited color.
2032     return visitedColor.colorWithAlpha(unvisitedColor.alphaAsFloat());
2033 }
2034 
2035 Color RenderStyle::visitedDependentColorWithColorFilter(CSSPropertyID colorProperty) const
2036 {
2037     if (!hasAppleColorFilter())
2038         return visitedDependentColor(colorProperty);
2039 
2040     return colorByApplyingColorFilter(visitedDependentColor(colorProperty));
2041 }
2042 
2043 Color RenderStyle::colorByApplyingColorFilter(const Color&amp; color) const
2044 {
2045     Color transformedColor = color;
2046     appleColorFilter().transformColor(transformedColor);
2047     return transformedColor;
2048 }
2049 
2050 const BorderValue&amp; RenderStyle::borderBefore() const
2051 {
2052     switch (writingMode()) {
2053     case TopToBottomWritingMode:
2054         return borderTop();
2055     case BottomToTopWritingMode:
2056         return borderBottom();
2057     case LeftToRightWritingMode:
2058         return borderLeft();
2059     case RightToLeftWritingMode:
2060         return borderRight();
2061     }
2062     ASSERT_NOT_REACHED();
2063     return borderTop();
2064 }
2065 
2066 const BorderValue&amp; RenderStyle::borderAfter() const
2067 {
2068     switch (writingMode()) {
2069     case TopToBottomWritingMode:
2070         return borderBottom();
2071     case BottomToTopWritingMode:
2072         return borderTop();
2073     case LeftToRightWritingMode:
2074         return borderRight();
2075     case RightToLeftWritingMode:
2076         return borderLeft();
2077     }
2078     ASSERT_NOT_REACHED();
2079     return borderBottom();
2080 }
2081 
2082 const BorderValue&amp; RenderStyle::borderStart() const
2083 {
2084     if (isHorizontalWritingMode())
2085         return isLeftToRightDirection() ? borderLeft() : borderRight();
2086     return isLeftToRightDirection() ? borderTop() : borderBottom();
2087 }
2088 
2089 const BorderValue&amp; RenderStyle::borderEnd() const
2090 {
2091     if (isHorizontalWritingMode())
2092         return isLeftToRightDirection() ? borderRight() : borderLeft();
2093     return isLeftToRightDirection() ? borderBottom() : borderTop();
2094 }
2095 
2096 float RenderStyle::borderBeforeWidth() const
2097 {
2098     switch (writingMode()) {
2099     case TopToBottomWritingMode:
2100         return borderTopWidth();
2101     case BottomToTopWritingMode:
2102         return borderBottomWidth();
2103     case LeftToRightWritingMode:
2104         return borderLeftWidth();
2105     case RightToLeftWritingMode:
2106         return borderRightWidth();
2107     }
2108     ASSERT_NOT_REACHED();
2109     return borderTopWidth();
2110 }
2111 
2112 float RenderStyle::borderAfterWidth() const
2113 {
2114     switch (writingMode()) {
2115     case TopToBottomWritingMode:
2116         return borderBottomWidth();
2117     case BottomToTopWritingMode:
2118         return borderTopWidth();
2119     case LeftToRightWritingMode:
2120         return borderRightWidth();
2121     case RightToLeftWritingMode:
2122         return borderLeftWidth();
2123     }
2124     ASSERT_NOT_REACHED();
2125     return borderBottomWidth();
2126 }
2127 
2128 float RenderStyle::borderStartWidth() const
2129 {
2130     if (isHorizontalWritingMode())
2131         return isLeftToRightDirection() ? borderLeftWidth() : borderRightWidth();
2132     return isLeftToRightDirection() ? borderTopWidth() : borderBottomWidth();
2133 }
2134 
2135 float RenderStyle::borderEndWidth() const
2136 {
2137     if (isHorizontalWritingMode())
2138         return isLeftToRightDirection() ? borderRightWidth() : borderLeftWidth();
2139     return isLeftToRightDirection() ? borderBottomWidth() : borderTopWidth();
2140 }
2141 
2142 void RenderStyle::setMarginStart(Length&amp;&amp; margin)
2143 {
2144     if (isHorizontalWritingMode()) {
2145         if (isLeftToRightDirection())
2146             setMarginLeft(WTFMove(margin));
2147         else
2148             setMarginRight(WTFMove(margin));
2149     } else {
2150         if (isLeftToRightDirection())
2151             setMarginTop(WTFMove(margin));
2152         else
2153             setMarginBottom(WTFMove(margin));
2154     }
2155 }
2156 
2157 void RenderStyle::setMarginEnd(Length&amp;&amp; margin)
2158 {
2159     if (isHorizontalWritingMode()) {
2160         if (isLeftToRightDirection())
2161             setMarginRight(WTFMove(margin));
2162         else
2163             setMarginLeft(WTFMove(margin));
2164     } else {
2165         if (isLeftToRightDirection())
2166             setMarginBottom(WTFMove(margin));
2167         else
2168             setMarginTop(WTFMove(margin));
2169     }
2170 }
2171 
2172 TextEmphasisMark RenderStyle::textEmphasisMark() const
2173 {
2174     auto mark = static_cast&lt;TextEmphasisMark&gt;(m_rareInheritedData-&gt;textEmphasisMark);
2175     if (mark != TextEmphasisMark::Auto)
2176         return mark;
2177     if (isHorizontalWritingMode())
2178         return TextEmphasisMark::Dot;
2179     return TextEmphasisMark::Sesame;
2180 }
2181 
2182 #if ENABLE(TOUCH_EVENTS)
2183 
2184 Color RenderStyle::initialTapHighlightColor()
2185 {
2186     return RenderTheme::tapHighlightColor();
2187 }
2188 
2189 #endif
2190 
2191 LayoutBoxExtent RenderStyle::imageOutsets(const NinePieceImage&amp; image) const
2192 {
2193     return {
2194         NinePieceImage::computeOutset(image.outset().top(), LayoutUnit(borderTopWidth())),
2195         NinePieceImage::computeOutset(image.outset().right(), LayoutUnit(borderRightWidth())),
2196         NinePieceImage::computeOutset(image.outset().bottom(), LayoutUnit(borderBottomWidth())),
2197         NinePieceImage::computeOutset(image.outset().left(), LayoutUnit(borderLeftWidth()))
2198     };
2199 }
2200 
2201 std::pair&lt;FontOrientation, NonCJKGlyphOrientation&gt; RenderStyle::fontAndGlyphOrientation()
2202 {
2203     // FIXME: TextOrientationSideways should map to sideways-left in vertical-lr, which is not supported yet.
2204 
2205     if (isHorizontalWritingMode())
2206         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2207 
2208     switch (textOrientation()) {
2209     case TextOrientation::Mixed:
2210         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Mixed };
2211     case TextOrientation::Upright:
2212         return { FontOrientation::Vertical, NonCJKGlyphOrientation::Upright };
2213     case TextOrientation::Sideways:
2214         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2215     default:
2216         ASSERT_NOT_REACHED();
2217         return { FontOrientation::Horizontal, NonCJKGlyphOrientation::Mixed };
2218     }
2219 }
2220 
2221 void RenderStyle::setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp; image)
2222 {
2223     if (m_surroundData-&gt;border.m_image.image() == image.get())
2224         return;
2225     m_surroundData.access().border.m_image.setImage(WTFMove(image));
2226 }
2227 
2228 void RenderStyle::setBorderImageSlices(LengthBox&amp;&amp; slices)
2229 {
2230     if (m_surroundData-&gt;border.m_image.imageSlices() == slices)
2231         return;
2232     m_surroundData.access().border.m_image.setImageSlices(WTFMove(slices));
2233 }
2234 
2235 void RenderStyle::setBorderImageWidth(LengthBox&amp;&amp; slices)
2236 {
2237     if (m_surroundData-&gt;border.m_image.borderSlices() == slices)
2238         return;
2239     m_surroundData.access().border.m_image.setBorderSlices(WTFMove(slices));
2240 }
2241 
2242 void RenderStyle::setBorderImageOutset(LengthBox&amp;&amp; outset)
2243 {
2244     if (m_surroundData-&gt;border.m_image.outset() == outset)
2245         return;
2246     m_surroundData.access().border.m_image.setOutset(WTFMove(outset));
2247 }
2248 
2249 void RenderStyle::setColumnStylesFromPaginationMode(const Pagination::Mode&amp; paginationMode)
2250 {
2251     if (paginationMode == Pagination::Unpaginated)
2252         return;
2253 
2254     setColumnFill(ColumnFill::Auto);
2255 
2256     switch (paginationMode) {
2257     case Pagination::LeftToRightPaginated:
2258         setColumnAxis(ColumnAxis::Horizontal);
2259         if (isHorizontalWritingMode())
2260             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2261         else
2262             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2263         break;
2264     case Pagination::RightToLeftPaginated:
2265         setColumnAxis(ColumnAxis::Horizontal);
2266         if (isHorizontalWritingMode())
2267             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2268         else
2269             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2270         break;
2271     case Pagination::TopToBottomPaginated:
2272         setColumnAxis(ColumnAxis::Vertical);
2273         if (isHorizontalWritingMode())
2274             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2275         else
2276             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2277         break;
2278     case Pagination::BottomToTopPaginated:
2279         setColumnAxis(ColumnAxis::Vertical);
2280         if (isHorizontalWritingMode())
2281             setColumnProgression(isFlippedBlocksWritingMode() ? ColumnProgression::Normal : ColumnProgression::Reverse);
2282         else
2283             setColumnProgression(isLeftToRightDirection() ? ColumnProgression::Reverse : ColumnProgression::Normal);
2284         break;
2285     case Pagination::Unpaginated:
2286         ASSERT_NOT_REACHED();
2287         break;
2288     }
2289 }
2290 
2291 #if ENABLE(CSS_SCROLL_SNAP)
2292 
2293 ScrollSnapType RenderStyle::initialScrollSnapType()
2294 {
2295     return { };
2296 }
2297 
2298 ScrollSnapAlign RenderStyle::initialScrollSnapAlign()
2299 {
2300     return { };
2301 }
2302 
2303 const StyleScrollSnapArea&amp; RenderStyle::scrollSnapArea() const
2304 {
2305     return *m_rareNonInheritedData-&gt;scrollSnapArea;
2306 }
2307 
2308 const StyleScrollSnapPort&amp; RenderStyle::scrollSnapPort() const
2309 {
2310     return *m_rareNonInheritedData-&gt;scrollSnapPort;
2311 }
2312 
2313 const ScrollSnapType&amp; RenderStyle::scrollSnapType() const
2314 {
2315     return m_rareNonInheritedData-&gt;scrollSnapPort-&gt;type;
2316 }
2317 
2318 const LengthBox&amp; RenderStyle::scrollPadding() const
2319 {
2320     return m_rareNonInheritedData-&gt;scrollSnapPort-&gt;scrollPadding;
2321 }
2322 
2323 const Length&amp; RenderStyle::scrollPaddingTop() const
2324 {
2325     return scrollPadding().top();
2326 }
2327 
2328 const Length&amp; RenderStyle::scrollPaddingBottom() const
2329 {
2330     return scrollPadding().bottom();
2331 }
2332 
2333 const Length&amp; RenderStyle::scrollPaddingLeft() const
2334 {
2335     return scrollPadding().left();
2336 }
2337 
2338 const Length&amp; RenderStyle::scrollPaddingRight() const
2339 {
2340     return scrollPadding().right();
2341 }
2342 
2343 const ScrollSnapAlign&amp; RenderStyle::scrollSnapAlign() const
2344 {
2345     return m_rareNonInheritedData-&gt;scrollSnapArea-&gt;alignment;
2346 }
2347 
2348 const LengthBox&amp; RenderStyle::scrollSnapMargin() const
2349 {
2350     return m_rareNonInheritedData-&gt;scrollSnapArea-&gt;scrollSnapMargin;
2351 }
2352 
2353 const Length&amp; RenderStyle::scrollSnapMarginTop() const
2354 {
2355     return scrollSnapMargin().top();
2356 }
2357 
2358 const Length&amp; RenderStyle::scrollSnapMarginBottom() const
2359 {
2360     return scrollSnapMargin().bottom();
2361 }
2362 
2363 const Length&amp; RenderStyle::scrollSnapMarginLeft() const
2364 {
2365     return scrollSnapMargin().left();
2366 }
2367 
2368 const Length&amp; RenderStyle::scrollSnapMarginRight() const
2369 {
2370     return scrollSnapMargin().right();
2371 }
2372 
2373 void RenderStyle::setScrollSnapType(const ScrollSnapType&amp; type)
2374 {
2375     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, type, type);
2376 }
2377 
2378 void RenderStyle::setScrollPaddingTop(Length&amp;&amp; length)
2379 {
2380     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.top(), WTFMove(length));
2381 }
2382 
2383 void RenderStyle::setScrollPaddingBottom(Length&amp;&amp; length)
2384 {
2385     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.bottom(), WTFMove(length));
2386 }
2387 
2388 void RenderStyle::setScrollPaddingLeft(Length&amp;&amp; length)
2389 {
2390     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.left(), WTFMove(length));
2391 }
2392 
2393 void RenderStyle::setScrollPaddingRight(Length&amp;&amp; length)
2394 {
2395     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapPort, scrollPadding.right(), WTFMove(length));
2396 }
2397 
2398 void RenderStyle::setScrollSnapAlign(const ScrollSnapAlign&amp; alignment)
2399 {
2400     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, alignment, alignment);
2401 }
2402 
2403 void RenderStyle::setScrollSnapMarginTop(Length&amp;&amp; length)
2404 {
2405     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.top(), WTFMove(length));
2406 }
2407 
2408 void RenderStyle::setScrollSnapMarginBottom(Length&amp;&amp; length)
2409 {
2410     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.bottom(), WTFMove(length));
2411 }
2412 
2413 void RenderStyle::setScrollSnapMarginLeft(Length&amp;&amp; length)
2414 {
2415     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.left(), WTFMove(length));
2416 }
2417 
2418 void RenderStyle::setScrollSnapMarginRight(Length&amp;&amp; length)
2419 {
2420     SET_NESTED_VAR(m_rareNonInheritedData, scrollSnapArea, scrollSnapMargin.right(), WTFMove(length));
2421 }
2422 
2423 #endif
2424 
2425 bool RenderStyle::hasReferenceFilterOnly() const
2426 {
2427     if (!hasFilter())
2428         return false;
2429     auto&amp; filterOperations = m_rareNonInheritedData-&gt;filter-&gt;operations;
2430     return filterOperations.size() == 1 &amp;&amp; filterOperations.at(0)-&gt;type() == FilterOperation::REFERENCE;
2431 }
2432 
2433 float RenderStyle::outlineWidth() const
2434 {
2435     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2436         return 0;
2437     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2438         return std::max(m_backgroundData-&gt;outline.width(), RenderTheme::platformFocusRingWidth());
2439     return m_backgroundData-&gt;outline.width();
2440 }
2441 
2442 float RenderStyle::outlineOffset() const
2443 {
2444     if (m_backgroundData-&gt;outline.style() == BorderStyle::None)
2445         return 0;
2446     if (outlineStyleIsAuto() == OutlineIsAuto::On)
2447         return (m_backgroundData-&gt;outline.offset() + RenderTheme::platformFocusRingOffset(outlineWidth()));
2448     return m_backgroundData-&gt;outline.offset();
2449 }
2450 
2451 bool RenderStyle::shouldPlaceBlockDirectionScrollbarOnLeft() const
2452 {
2453     return !isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode();
2454 }
2455 
2456 Vector&lt;PaintType, 3&gt; RenderStyle::paintTypesForPaintOrder(PaintOrder order)
2457 {
2458     Vector&lt;PaintType, 3&gt; paintOrder;
2459     switch (order) {
2460     case PaintOrder::Normal:
2461         FALLTHROUGH;
2462     case PaintOrder::Fill:
2463         paintOrder.append(PaintType::Fill);
2464         paintOrder.append(PaintType::Stroke);
2465         paintOrder.append(PaintType::Markers);
2466         break;
2467     case PaintOrder::FillMarkers:
2468         paintOrder.append(PaintType::Fill);
2469         paintOrder.append(PaintType::Markers);
2470         paintOrder.append(PaintType::Stroke);
2471         break;
2472     case PaintOrder::Stroke:
2473         paintOrder.append(PaintType::Stroke);
2474         paintOrder.append(PaintType::Fill);
2475         paintOrder.append(PaintType::Markers);
2476         break;
2477     case PaintOrder::StrokeMarkers:
2478         paintOrder.append(PaintType::Stroke);
2479         paintOrder.append(PaintType::Markers);
2480         paintOrder.append(PaintType::Fill);
2481         break;
2482     case PaintOrder::Markers:
2483         paintOrder.append(PaintType::Markers);
2484         paintOrder.append(PaintType::Fill);
2485         paintOrder.append(PaintType::Stroke);
2486         break;
2487     case PaintOrder::MarkersStroke:
2488         paintOrder.append(PaintType::Markers);
2489         paintOrder.append(PaintType::Stroke);
2490         paintOrder.append(PaintType::Fill);
2491         break;
2492     };
2493     return paintOrder;
2494 }
2495 
2496 float RenderStyle::computedStrokeWidth(const IntSize&amp; viewportSize) const
2497 {
2498     // Use the stroke-width and stroke-color value combination only if stroke-color has been explicitly specified.
2499     // Since there will be no visible stroke when stroke-color is not specified (transparent by default), we fall
2500     // back to the legacy Webkit text stroke combination in that case.
2501     if (!hasExplicitlySetStrokeColor())
2502         return textStrokeWidth();
2503 
2504     const Length&amp; length = strokeWidth();
2505 
2506     if (length.isPercent()) {
2507         // According to the spec, https://drafts.fxtf.org/paint/#stroke-width, the percentage is relative to the scaled viewport size.
2508         // The scaled viewport size is the geometric mean of the viewport width and height.
2509         ExceptionOr&lt;float&gt; result = length.value() * (viewportSize.width() + viewportSize.height()) / 200.0f;
2510         if (result.hasException())
2511             return 0;
2512         return result.releaseReturnValue();
2513     }
2514 
2515     if (length.isAuto() || !length.isSpecified())
2516         return 0;
2517 
2518     return floatValueForLength(length, viewportSize.width());
2519 }
2520 
2521 bool RenderStyle::hasPositiveStrokeWidth() const
2522 {
2523     if (!hasExplicitlySetStrokeWidth())
2524         return textStrokeWidth() &gt; 0;
2525 
2526     return strokeWidth().isPositive();
2527 }
2528 
2529 Color RenderStyle::computedStrokeColor() const
2530 {
2531     CSSPropertyID propertyID = CSSPropertyStrokeColor;
2532     if (!hasExplicitlySetStrokeColor())
2533         propertyID = CSSPropertyWebkitTextStrokeColor;
2534     return visitedDependentColor(propertyID);
2535 }
2536 
2537 } // namespace WebCore
    </pre>
  </body>
</html>
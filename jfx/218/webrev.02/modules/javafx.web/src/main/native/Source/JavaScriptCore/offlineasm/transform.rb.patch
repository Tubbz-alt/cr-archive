diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb b/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb
@@ -203,12 +203,15 @@
 
     def substitute(mapping)
         if @name =~ $concatenation
             name = @name.gsub($concatenation) { |match|
                 var = Variable.forName(codeOrigin, match[1...-1])
-                raise "Unknown variable `#{var.originalName}` in substitution at #{codeOrigin} - #{mapping} " unless mapping[var]
-                mapping[var].name
+                if mapping[var]
+                    mapping[var].name
+                else
+                    match
+                end
             }
             Variable.forName(codeOrigin, name)
         elsif mapping[self]
             mapping[self]
         else
@@ -236,12 +239,15 @@
 
     def substitute(mapping)
         if dump =~ $concatenation
             names = dump.gsub($concatenation) { |match|
                 var = Variable.forName(codeOrigin, match[1...-1])
-                raise "Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}" unless mapping[var]
-                mapping[var].name
+                if mapping[var]
+                    mapping[var].name
+                else
+                    match
+                end
             }.split('::')
             StructOffset.forField(codeOrigin, names[0..-2].join('::'), names[-1])
         else
             self
         end
@@ -257,24 +263,33 @@
                     "%#{mapping[var].name}%"
                 else
                     match
                 end
             }
-            Label.forName(codeOrigin, name, @definedInFile)
+            result = Label.forName(codeOrigin, name, @definedInFile)
+            result.setGlobal() if global?
+            result.clearExtern unless extern?
+            result
         else
             self
         end
     end
 
     def substitute(mapping)
         if @name =~ $concatenation
             name = @name.gsub($concatenation) { |match|
                 var = Variable.forName(codeOrigin, match[1...-1])
-                raise "Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}" unless mapping[var]
-                mapping[var].name
+                if mapping[var]
+                    mapping[var].name
+                else
+                    match
+                end
             }
-            Label.forName(codeOrigin, name, @definedInFile)
+            result = Label.forName(codeOrigin, name, @definedInFile)
+            result.setGlobal() if global?
+            result.clearExtern unless extern?
+            result
         else
             self
         end
     end
 end
@@ -298,12 +313,15 @@
 
     def substitute(mapping)
         if @value =~ $concatenation
             value = @value.gsub($concatenation) { |match|
                 var = Variable.forName(codeOrigin, match[1...-1])
-                raise "Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}" unless mapping[var]
-                mapping[var].name
+                if mapping[var]
+                    mapping[var].name
+                else
+                    match
+                end
             }
             ConstExpr.forName(codeOrigin, value)
         else
             self
         end
@@ -329,12 +347,15 @@
 
     def substitute(mapping)
         if struct =~ $concatenation
             value = struct.gsub($concatenation) { |match|
                 var = Variable.forName(codeOrigin, match[1...-1])
-                raise "Unknown variable `#{var.originalName}` in substitution at #{codeOrigin}" unless mapping[var]
-                mapping[var].name
+                if mapping[var]
+                    mapping[var].name
+                else
+                    match
+                end
             }
             Sizeof.forName(codeOrigin, value)
         else
             self
         end
@@ -349,17 +370,11 @@
             self
         end
     end
 end
 
-class MacroError < RuntimeError
-    attr_reader :message
-    attr_reader :backtrace
-    def initialize(message, backtrace)
-        @message = message
-        @backtrace = backtrace
-    end
+class MacroError < StandardError
 end
 
 class Sequence
     def substitute(constants)
         newList = []
@@ -391,26 +406,27 @@
     @@demacroifyStack = []
     def macroError(msg)
         backtrace = @@demacroifyStack.reverse.map { |macroCall|
             "#{macroCall.codeOrigin} in call to #{macroCall.originalName}"
         }
-        raise MacroError.new(msg, backtrace)
+        raise MacroError, msg, backtrace
     end
 
     def demacroify(macros)
         myMacros = macros.dup
+        # We do an initial pass looking for all macros in order to allow forward references
         @list.each {
             | item |
             if item.is_a? Macro
                 myMacros[item.name] = item.freshVariables
             end
         }
         newList = []
         @list.each {
             | item |
             if item.is_a? Macro
-                # Ignore.
+                # Ignore. We already looked for macros above and they should not be part of the final output
             elsif item.is_a? MacroCall
                 @@demacroifyStack << item
                 mapping = {}
                 myMyMacros = myMacros.dup
                 macro = myMacros[item.name]
@@ -431,10 +447,11 @@
                 }
                 if item.annotation
                     newList << Instruction.new(item.codeOrigin, "localAnnotation", [], item.annotation)
                 end
                 newList += macro.body.substitute(mapping).demacroify(myMyMacros).renameLabels(item.originalName).list
+
                 @@demacroifyStack.pop
             else
                 newList << item.demacroify(myMacros)
             end
         }

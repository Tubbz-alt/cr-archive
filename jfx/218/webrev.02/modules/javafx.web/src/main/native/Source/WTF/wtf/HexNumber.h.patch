diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/HexNumber.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/HexNumber.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/HexNumber.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/HexNumber.h
@@ -45,60 +45,25 @@
     return appendHex(&buffer.front(), buffer.size(), static_cast<typename std::make_unsigned<NumberType>::type>(number), minimumDigits, mode);
 }
 
 } // namespace Internal
 
-template<typename T>
-inline void appendByteAsHex(unsigned char byte, T& destination, HexConversionMode mode = Uppercase)
-{
-    auto* hexDigits = Internal::hexDigitsForMode(mode);
-    destination.append(hexDigits[byte >> 4]);
-    destination.append(hexDigits[byte & 0xF]);
-}
-
-// FIXME: Consider renaming to appendHex.
-template<typename NumberType, typename DestinationType>
-inline void appendUnsignedAsHex(NumberType number, DestinationType& destination, HexConversionMode mode = Uppercase)
-{
-    appendUnsignedAsHexFixedSize(number, destination, 0, mode);
-}
-
-// FIXME: Consider renaming to appendHex.
-// Same as appendUnsignedAsHex, but zero-padding to get at least the desired number of digits.
-template<typename NumberType, typename DestinationType>
-inline void appendUnsignedAsHexFixedSize(NumberType number, DestinationType& destination, unsigned minimumDigits, HexConversionMode mode = Uppercase)
-{
-    // Each byte can generate up to two digits.
-    std::array<LChar, sizeof(NumberType) * 2> buffer;
-    auto result = Internal::appendHex(buffer, number, minimumDigits, mode);
-    destination.append(result.first, result.second);
-}
-
-// FIXME: Consider renaming to appendHex.
-// Same as appendUnsignedAsHex, but zero-padding to get at least the desired number of digits.
-template<typename NumberType>
-inline void appendUnsignedAsHexFixedSize(NumberType number, StringBuilder& destination, unsigned minimumDigits, HexConversionMode mode = Uppercase)
-{
-    // Each byte can generate up to two digits.
-    std::array<LChar, sizeof(NumberType) * 2> buffer;
-    auto result = Internal::appendHex(buffer, number, minimumDigits, mode);
-    destination.appendCharacters(result.first, result.second);
-}
-
 struct HexNumberBuffer {
     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 
-    std::array<LChar, 16> characters;
+    std::array<LChar, 16> buffer;
     unsigned length;
+
+    const LChar* characters() const { return &*(buffer.end() - length); }
 };
 
 template<typename NumberType> HexNumberBuffer hex(NumberType number, unsigned minimumDigits = 0, HexConversionMode mode = Uppercase)
 {
     // Each byte can generate up to two digits.
     HexNumberBuffer buffer;
-    static_assert(sizeof(buffer.characters) >= sizeof(NumberType) * 2, "number too large for hexNumber");
-    auto result = Internal::appendHex(buffer.characters, number, minimumDigits, mode);
+    static_assert(sizeof(buffer.buffer) >= sizeof(NumberType) * 2, "number too large for hexNumber");
+    auto result = Internal::appendHex(buffer.buffer, number, minimumDigits, mode);
     buffer.length = result.second;
     return buffer;
 }
 
 template<typename NumberType> HexNumberBuffer hex(NumberType number, HexConversionMode mode)
@@ -116,17 +81,14 @@
     unsigned length() const { return m_buffer.length; }
     bool is8Bit() const { return true; }
     template<typename CharacterType> void writeTo(CharacterType* destination) const { StringImpl::copyCharacters(destination, characters(), length()); }
 
 private:
-    const LChar* characters() const { return &*(m_buffer.characters.end() - length()); }
+    const LChar* characters() const { return m_buffer.characters(); }
 
     const HexNumberBuffer& m_buffer;
 };
 
 } // namespace WTF
 
-using WTF::appendByteAsHex;
-using WTF::appendUnsignedAsHex;
-using WTF::appendUnsignedAsHexFixedSize;
 using WTF::hex;
 using WTF::Lowercase;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/gesture-recognizers/gesture-recognizer.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 class GestureRecognizer
  2 {
  3 
  4     constructor(target = null, delegate = null)
  5     {
  6         this._targetPointers = new Map;
  7 
  8         this.modifierKeys = {
  9             alt : false,
 10             ctrl : false,
 11             meta : false,
 12             shift : false
 13         };
 14 
 15         this._state = GestureRecognizer.States.Possible;
 16         this._enabled = true;
 17 
 18         this.target = target;
 19         this.delegate = delegate;
 20     }
 21 
 22     // Public
 23 
 24     get state()
 25     {
 26         return this._state;
 27     }
 28 
 29     set state(state)
 30     {
 31         if (this._state === state &amp;&amp; state !== GestureRecognizer.States.Changed)
 32             return;
 33 
 34         this._state = state;
 35         if (this.delegate &amp;&amp; typeof this.delegate.gestureRecognizerStateDidChange === &quot;function&quot;)
 36             this.delegate.gestureRecognizerStateDidChange(this);
 37     }
 38 
 39     get target()
 40     {
 41         return this._target;
 42     }
 43 
 44     set target(target)
 45     {
 46         if (!target || this._target === target)
 47             return;
 48 
 49         this._target = target;
 50         this._initRecognizer();
 51     }
 52 
 53     get numberOfTouches()
 54     {
 55         return this._targetPointers.size;
 56     }
 57 
 58     get enabled()
 59     {
 60         return this._enabled;
 61     }
 62 
 63     set enabled(enabled)
 64     {
 65         if (this._enabled === enabled)
 66             return;
 67 
 68         this._enabled = enabled;
 69 
 70         if (!enabled) {
 71             if (this.numberOfTouches === 0) {
 72                 this._removeTrackingListeners();
 73                 this.reset();
 74             } else
 75                 this.enterCancelledState();
 76         }
 77 
 78         this._updateBaseListeners();
 79     }
 80 
 81     reset()
 82     {
 83         // Implemented by subclasses.
 84     }
 85 
 86     locationInElement(element)
 87     {
 88         const p = new DOMPoint;
 89         const count = this._targetPointers.size;
 90         if (!count)
 91             return p;
 92         this._targetPointers.forEach(function (pointer) {
 93             p.x += pointer.pageX;
 94             p.y += pointer.pageY;
 95         });
 96         p.x /= count;
 97         p.y /= count;
 98 
 99         if (!element)
100             return p;
101 
102         // FIXME: are WebKitPoint and DOMPoint interchangeable?
103         const wkPoint = window.webkitConvertPointFromPageToNode(element, new WebKitPoint(p.x, p.y));
104         return new DOMPoint(wkPoint.x, wkPoint.y);
105     }
106 
107     locationInClient()
108     {
109         const p = new DOMPoint;
110         const count = this._targetPointers.size;
111         if (!count)
112             return p;
113         this._targetPointers.forEach(function (pointer) {
114             p.x += pointer.clientX;
115             p.y += pointer.clientY;
116         });
117         p.x /= count;
118         p.y /= count;
119 
120         return p;
121     }
122 
123     touchesBegan(event)
124     {
125         if (event.currentTarget !== this._target)
126             return;
127 
128         window.addEventListener(GestureRecognizer.Events.PointerMove, this, true);
129         window.addEventListener(GestureRecognizer.Events.PointerUp, this, true);
130         window.addEventListener(GestureRecognizer.Events.PointerCancel, this, true);
131         this.enterPossibleState();
132     }
133 
134     touchesMoved(event)
135     {
136         // Implemented by subclasses.
137     }
138 
139     touchesEnded(event)
140     {
141         // Implemented by subclasses.
142     }
143 
144     touchesCancelled(event)
145     {
146         // Implemented by subclasses.
147     }
148 
149     gestureBegan(event)
150     {
151         if (event.currentTarget !== this._target)
152             return;
153 
154         this._target.addEventListener(GestureRecognizer.Events.GestureChange, this, true);
155         this._target.addEventListener(GestureRecognizer.Events.GestureEnd, this, true);
156         this.enterPossibleState();
157     }
158 
159     gestureChanged(event)
160     {
161         // Implemented by subclasses.
162     }
163 
164     gestureEnded(event)
165     {
166         // Implemented by subclasses.
167     }
168 
169     enterPossibleState()
170     {
171         this.state = GestureRecognizer.States.Possible;
172     }
173 
174     enterBeganState()
175     {
176         if (this.delegate &amp;&amp; typeof this.delegate.gestureRecognizerShouldBegin === &quot;function&quot; &amp;&amp; !this.delegate.gestureRecognizerShouldBegin(this)) {
177             this.enterFailedState();
178             return;
179         }
180         this.state = GestureRecognizer.States.Began;
181     }
182 
183     enterEndedState()
184     {
185         this.state = GestureRecognizer.States.Ended;
186         this._removeTrackingListeners();
187         this.reset();
188     }
189 
190     enterCancelledState()
191     {
192         this.state = GestureRecognizer.States.Cancelled;
193         this._removeTrackingListeners();
194         this.reset();
195     }
196 
197     enterFailedState()
198     {
199         this.state = GestureRecognizer.States.Failed;
200         this._removeTrackingListeners();
201         this.reset();
202     }
203 
204     enterChangedState()
205     {
206         this.state = GestureRecognizer.States.Changed;
207     }
208 
209     enterRecognizedState()
210     {
211         this.state = GestureRecognizer.States.Recognized;
212     }
213 
214     // Protected
215 
216     handleEvent(event)
217     {
218         this._updateTargetTouches(event);
219         this._updateKeyboardModifiers(event);
220 
221         switch (event.type) {
222         case GestureRecognizer.Events.PointerDown:
223             this.touchesBegan(event);
224             break;
225         case GestureRecognizer.Events.PointerMove:
226             this.touchesMoved(event);
227             break;
228         case GestureRecognizer.Events.PointerUp:
229             this.touchesEnded(event);
230             break;
231         case GestureRecognizer.Events.PointerCancel:
232             this.touchesCancelled(event);
233             break;
234         case GestureRecognizer.Events.GestureStart:
235             this.gestureBegan(event);
236             break;
237         case GestureRecognizer.Events.GestureChange:
238             this.gestureChanged(event);
239             break;
240         case GestureRecognizer.Events.GestureEnd:
241             this.gestureEnded(event);
242             break;
243         }
244     }
245 
246     // Private
247 
248     _initRecognizer()
249     {
250         this.reset();
251         this.state = GestureRecognizer.States.Possible;
252 
253         this._updateBaseListeners();
254     }
255 
256     _updateBaseListeners()
257     {
258         if (!this._target)
259             return;
260 
261         if (this._enabled) {
262             this._target.addEventListener(GestureRecognizer.Events.PointerDown, this);
263             if (GestureRecognizer.SupportsGestures)
264                 this._target.addEventListener(GestureRecognizer.Events.GestureStart, this);
265         } else {
266             this._target.removeEventListener(GestureRecognizer.Events.PointerDown, this);
267             if (GestureRecognizer.SupportsGestures)
268                 this._target.removeEventListener(GestureRecognizer.Events.GestureStart, this);
269         }
270     }
271 
272     _removeTrackingListeners()
273     {
274         window.removeEventListener(GestureRecognizer.Events.PointerMove, this, true);
275         window.removeEventListener(GestureRecognizer.Events.PointerUp, this, true);
276         window.removeEventListener(GestureRecognizer.Events.PointerCancel, this, true);
277         this._target.removeEventListener(GestureRecognizer.Events.GestureChange, this, true);
278         this._target.removeEventListener(GestureRecognizer.Events.GestureEnd, this, true);
279 
280         this._targetPointers = new Map;
281     }
282 
283     _updateTargetTouches(event)
284     {
285         if (!(event instanceof PointerEvent))
286             return;
287 
288         if (event.type === GestureRecognizer.Events.PointerDown) {
289             this._targetPointers.set(event.pointerId, event);
290             return;
291         }
292 
293         if (event.type === GestureRecognizer.Events.PointerMove) {
294             this._targetPointers.set(event.pointerId, event);
295             return;
296         }
297 
298         this._targetPointers.delete(event.pointerId);
299     }
300 
301     _updateKeyboardModifiers(event)
302     {
303         this.modifierKeys.alt = event.altKey;
304         this.modifierKeys.ctrl = event.ctrlKey;
305         this.modifierKeys.meta = event.metaKey;
306         this.modifierKeys.shift = event.shiftKey;
307     }
308 
309 }
310 
311 GestureRecognizer.SupportsTouches = &quot;createTouch&quot; in document;
312 GestureRecognizer.SupportsGestures = !!window.GestureEvent;
313 
314 GestureRecognizer.States = {
315     Possible   : &quot;possible&quot;,
316     Began      : &quot;began&quot;,
317     Changed    : &quot;changed&quot;,
318     Ended      : &quot;ended&quot;,
319     Cancelled  : &quot;cancelled&quot;,
320     Failed     : &quot;failed&quot;,
321     Recognized : &quot;ended&quot;
322 };
323 
324 GestureRecognizer.Events = {
325     PointerDown    : &quot;pointerdown&quot;,
326     PointerMove    : &quot;pointermove&quot;,
327     PointerUp      : &quot;pointerup&quot;,
328     PointerCancel  : &quot;pointercancel&quot;,
329     GestureStart   : &quot;gesturestart&quot;,
330     GestureChange  : &quot;gesturechange&quot;,
331     GestureEnd     : &quot;gestureend&quot;
332 };
    </pre>
  </body>
</html>
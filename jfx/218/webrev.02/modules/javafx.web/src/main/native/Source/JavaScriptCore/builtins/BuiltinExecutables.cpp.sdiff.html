<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinExecutables.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BuiltinExecutableCreator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BuiltinExecutables.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinExecutables.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;config.h&quot;
 28 #include &quot;BuiltinExecutables.h&quot;
 29 
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;Parser.h&quot;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 
 35 namespace JSC {
 36 
 37 BuiltinExecutables::BuiltinExecutables(VM&amp; vm)
 38     : m_vm(vm)
 39     , m_combinedSourceProvider(StringSourceProvider::create(StringImpl::createFromLiteral(s_JSCCombinedCode, s_JSCCombinedCodeLength), { }, URL()))
 40 {
 41 }
 42 
 43 SourceCode BuiltinExecutables::defaultConstructorSourceCode(ConstructorKind constructorKind)
 44 {
 45     switch (constructorKind) {
 46     case ConstructorKind::None:

 47         break;
 48     case ConstructorKind::Base: {
 49         static NeverDestroyed&lt;const String&gt; baseConstructorCode(MAKE_STATIC_STRING_IMPL(&quot;(function () { })&quot;));
 50         return makeSource(baseConstructorCode, { });
 51     }
 52     case ConstructorKind::Extends: {
 53         static NeverDestroyed&lt;const String&gt; derivedConstructorCode(MAKE_STATIC_STRING_IMPL(&quot;(function (...args) { super(...args); })&quot;));
 54         return makeSource(derivedConstructorCode, { });
 55     }
 56     }
 57     RELEASE_ASSERT_NOT_REACHED();
 58     return SourceCode();
 59 }
 60 
<span class="line-modified"> 61 UnlinkedFunctionExecutable* BuiltinExecutables::createDefaultConstructor(ConstructorKind constructorKind, const Identifier&amp; name)</span>
 62 {
 63     switch (constructorKind) {
 64     case ConstructorKind::None:

 65         break;
 66     case ConstructorKind::Base:
 67     case ConstructorKind::Extends:
<span class="line-modified"> 68         return createExecutable(m_vm, defaultConstructorSourceCode(constructorKind), name, constructorKind, ConstructAbility::CanConstruct);</span>
 69     }
 70     ASSERT_NOT_REACHED();
 71     return nullptr;
 72 }
 73 
<span class="line-modified"> 74 UnlinkedFunctionExecutable* BuiltinExecutables::createBuiltinExecutable(const SourceCode&amp; code, const Identifier&amp; name, ConstructAbility constructAbility)</span>
 75 {
<span class="line-modified"> 76     return createExecutable(m_vm, code, name, ConstructorKind::None, constructAbility);</span>
 77 }
 78 
<span class="line-modified"> 79 UnlinkedFunctionExecutable* createBuiltinExecutable(VM&amp; vm, const SourceCode&amp; code, const Identifier&amp; name, ConstructAbility constructAbility)</span>
<span class="line-removed"> 80 {</span>
<span class="line-removed"> 81     return BuiltinExecutables::createExecutable(vm, code, name, ConstructorKind::None, constructAbility);</span>
<span class="line-removed"> 82 }</span>
<span class="line-removed"> 83 </span>
<span class="line-removed"> 84 UnlinkedFunctionExecutable* BuiltinExecutables::createExecutable(VM&amp; vm, const SourceCode&amp; source, const Identifier&amp; name, ConstructorKind constructorKind, ConstructAbility constructAbility)</span>
 85 {
 86     // FIXME: Can we just make MetaData computation be constexpr and have the compiler do this for us?
 87     // https://bugs.webkit.org/show_bug.cgi?id=193272
 88     // Someone should get mad at me for writing this code. But, it prevents us from recursing into
 89     // the parser, and hence, from throwing stack overflow when parsing a builtin.
 90     StringView view = source.view();
 91     RELEASE_ASSERT(!view.isNull());
 92     RELEASE_ASSERT(view.is8Bit());
 93     auto* characters = view.characters8();
 94     const char* regularFunctionBegin = &quot;(function (&quot;;
 95     const char* asyncFunctionBegin = &quot;(async function (&quot;;
 96     RELEASE_ASSERT(view.length() &gt;= strlen(&quot;(function (){})&quot;));
 97     bool isAsyncFunction = view.length() &gt;= strlen(&quot;(async function (){})&quot;) &amp;&amp; !memcmp(characters, asyncFunctionBegin, strlen(asyncFunctionBegin));
 98     RELEASE_ASSERT(isAsyncFunction || !memcmp(characters, regularFunctionBegin, strlen(regularFunctionBegin)));
 99 
100     unsigned asyncOffset = isAsyncFunction ? strlen(&quot;async &quot;) : 0;
101     unsigned parametersStart = strlen(&quot;function (&quot;) + asyncOffset;
102     unsigned startColumn = parametersStart;
103     int functionKeywordStart = strlen(&quot;(&quot;) + asyncOffset;
104     int functionNameStart = parametersStart;
</pre>
<hr />
<pre>
165                 }
166             }
167         }
168     }
169 
170     unsigned positionBeforeLastNewlineLineStartOffset = offsetOfSecondToLastNewline ? *offsetOfSecondToLastNewline + 1 : 0;
171 
172     int closeBraceOffsetFromEnd = 1;
173     while (true) {
174         if (characters[view.length() - closeBraceOffsetFromEnd] == &#39;}&#39;)
175             break;
176         ++closeBraceOffsetFromEnd;
177     }
178 
179     JSTextPosition positionBeforeLastNewline;
180     positionBeforeLastNewline.line = lineCount;
181     positionBeforeLastNewline.offset = source.startOffset() + offsetOfLastNewline;
182     positionBeforeLastNewline.lineStartOffset = source.startOffset() + positionBeforeLastNewlineLineStartOffset;
183 
184     SourceCode newSource = source.subExpression(source.startOffset() + parametersStart, source.startOffset() + (view.length() - closeBraceOffsetFromEnd), 0, parametersStart);
<span class="line-modified">185     bool isBuiltinDefaultClassConstructor = constructorKind != ConstructorKind::None;</span>
186     UnlinkedFunctionKind kind = isBuiltinDefaultClassConstructor ? UnlinkedNormalFunction : UnlinkedBuiltinFunction;
187 
188     SourceParseMode parseMode = isAsyncFunction ? SourceParseMode::AsyncFunctionMode : SourceParseMode::NormalFunctionMode;
189 
190     JSTokenLocation start;
191     start.line = -1;
192     start.lineStartOffset = std::numeric_limits&lt;unsigned&gt;::max();
193     start.startOffset = source.startOffset() + parametersStart;
194     start.endOffset = std::numeric_limits&lt;unsigned&gt;::max();
195 
196     JSTokenLocation end;
197     end.line = 1;
198     end.lineStartOffset = source.startOffset();
199     end.startOffset = source.startOffset() + strlen(&quot;(&quot;) + asyncOffset;
200     end.endOffset = std::numeric_limits&lt;unsigned&gt;::max();
201 
202     FunctionMetadataNode metadata(
203         start, end, startColumn, endColumn, source.startOffset() + functionKeywordStart, source.startOffset() + functionNameStart, source.startOffset() + parametersStart,
204         isInStrictContext, constructorKind, constructorKind == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded,
205         parameterCount, parseMode, isArrowFunctionBodyExpression);
206 
207     metadata.finishParsing(newSource, Identifier(), FunctionMode::FunctionExpression);
208     metadata.overrideName(name);
209     metadata.setEndPosition(positionBeforeLastNewline);
210 
<span class="line-modified">211     if (!ASSERT_DISABLED || Options::validateBytecode()) {</span>
212         JSTextPosition positionBeforeLastNewlineFromParser;
213         ParserError error;
214         JSParserBuiltinMode builtinMode = isBuiltinDefaultClassConstructor ? JSParserBuiltinMode::NotBuiltin : JSParserBuiltinMode::Builtin;
215         std::unique_ptr&lt;ProgramNode&gt; program = parse&lt;ProgramNode&gt;(
216             vm, source, Identifier(), builtinMode,
217             JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, error,
218             &amp;positionBeforeLastNewlineFromParser, constructorKind);
219 
220         if (program) {
221             StatementNode* exprStatement = program-&gt;singleStatement();
222             RELEASE_ASSERT(exprStatement);
223             RELEASE_ASSERT(exprStatement-&gt;isExprStatement());
224             ExpressionNode* funcExpr = static_cast&lt;ExprStatementNode*&gt;(exprStatement)-&gt;expr();
225             RELEASE_ASSERT(funcExpr);
226             RELEASE_ASSERT(funcExpr-&gt;isFuncExprNode());
227             FunctionMetadataNode* metadataFromParser = static_cast&lt;FuncExprNode*&gt;(funcExpr)-&gt;metadata();
228             RELEASE_ASSERT(!program-&gt;hasCapturedVariables());
229 
230             metadataFromParser-&gt;setEndPosition(positionBeforeLastNewlineFromParser);
231             RELEASE_ASSERT(metadataFromParser);
</pre>
<hr />
<pre>
237             metadataFromParser-&gt;overrideName(name);
238             metadataFromParser-&gt;setEndPosition(positionBeforeLastNewlineFromParser);
239             if (metadata != *metadataFromParser || positionBeforeLastNewlineFromParser != positionBeforeLastNewline) {
240                 dataLogLn(&quot;Expected Metadata:\n&quot;, metadata);
241                 dataLogLn(&quot;Metadata from parser:\n&quot;, *metadataFromParser);
242                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.line &quot;, positionBeforeLastNewlineFromParser.line);
243                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.offset &quot;, positionBeforeLastNewlineFromParser.offset);
244                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.lineStartOffset &quot;, positionBeforeLastNewlineFromParser.lineStartOffset);
245                 dataLogLn(&quot;positionBeforeLastNewline.line &quot;, positionBeforeLastNewline.line);
246                 dataLogLn(&quot;positionBeforeLastNewline.offset &quot;, positionBeforeLastNewline.offset);
247                 dataLogLn(&quot;positionBeforeLastNewline.lineStartOffset &quot;, positionBeforeLastNewline.lineStartOffset);
248                 WTFLogAlways(&quot;Metadata of parser and hand rolled parser don&#39;t match\n&quot;);
249                 CRASH();
250             }
251         } else {
252             RELEASE_ASSERT(error.isValid());
253             RELEASE_ASSERT(error.type() == ParserError::StackOverflow);
254         }
255     }
256 
<span class="line-modified">257     UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, &amp;metadata, kind, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None, isBuiltinDefaultClassConstructor);</span>
258     return functionExecutable;
259 }
260 
261 void BuiltinExecutables::finalizeUnconditionally()
262 {
263     for (auto*&amp; unlinkedExecutable : m_unlinkedExecutables) {
264         if (unlinkedExecutable &amp;&amp; !m_vm.heap.isMarked(unlinkedExecutable))
265             unlinkedExecutable = nullptr;
266     }
267 }
268 
269 #define DEFINE_BUILTIN_EXECUTABLES(name, functionName, overrideName, length) \
270 SourceCode BuiltinExecutables::name##Source() \
271 {\
272     return SourceCode { m_combinedSourceProvider.copyRef(), static_cast&lt;int&gt;(s_##name - s_JSCCombinedCode), static_cast&lt;int&gt;((s_##name - s_JSCCombinedCode) + length), 1, 1 };\
273 }\
274 \
275 UnlinkedFunctionExecutable* BuiltinExecutables::name##Executable() \
276 {\
277     unsigned index = static_cast&lt;unsigned&gt;(BuiltinCodeIndex::name);\
278     if (!m_unlinkedExecutables[index]) {\
279         Identifier executableName = m_vm.propertyNames-&gt;builtinNames().functionName##PublicName();\
280         if (overrideName)\
281             executableName = Identifier::fromString(m_vm, overrideName);\
<span class="line-modified">282         m_unlinkedExecutables[index] = createBuiltinExecutable(name##Source(), executableName, s_##name##ConstructAbility);\</span>
283     }\
284     return m_unlinkedExecutables[index];\
285 }
286 JSC_FOREACH_BUILTIN_CODE(DEFINE_BUILTIN_EXECUTABLES)
287 #undef DEFINE_BUILTIN_EXECUTABLES
288 
289 }
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;config.h&quot;
 28 #include &quot;BuiltinExecutables.h&quot;
 29 
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;Parser.h&quot;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 
 35 namespace JSC {
 36 
 37 BuiltinExecutables::BuiltinExecutables(VM&amp; vm)
 38     : m_vm(vm)
 39     , m_combinedSourceProvider(StringSourceProvider::create(StringImpl::createFromLiteral(s_JSCCombinedCode, s_JSCCombinedCodeLength), { }, URL()))
 40 {
 41 }
 42 
 43 SourceCode BuiltinExecutables::defaultConstructorSourceCode(ConstructorKind constructorKind)
 44 {
 45     switch (constructorKind) {
 46     case ConstructorKind::None:
<span class="line-added"> 47     case ConstructorKind::Naked:</span>
 48         break;
 49     case ConstructorKind::Base: {
 50         static NeverDestroyed&lt;const String&gt; baseConstructorCode(MAKE_STATIC_STRING_IMPL(&quot;(function () { })&quot;));
 51         return makeSource(baseConstructorCode, { });
 52     }
 53     case ConstructorKind::Extends: {
 54         static NeverDestroyed&lt;const String&gt; derivedConstructorCode(MAKE_STATIC_STRING_IMPL(&quot;(function (...args) { super(...args); })&quot;));
 55         return makeSource(derivedConstructorCode, { });
 56     }
 57     }
 58     RELEASE_ASSERT_NOT_REACHED();
 59     return SourceCode();
 60 }
 61 
<span class="line-modified"> 62 UnlinkedFunctionExecutable* BuiltinExecutables::createDefaultConstructor(ConstructorKind constructorKind, const Identifier&amp; name, NeedsClassFieldInitializer needsClassFieldInitializer)</span>
 63 {
 64     switch (constructorKind) {
 65     case ConstructorKind::None:
<span class="line-added"> 66     case ConstructorKind::Naked:</span>
 67         break;
 68     case ConstructorKind::Base:
 69     case ConstructorKind::Extends:
<span class="line-modified"> 70         return createExecutable(m_vm, defaultConstructorSourceCode(constructorKind), name, constructorKind, ConstructAbility::CanConstruct, needsClassFieldInitializer);</span>
 71     }
 72     ASSERT_NOT_REACHED();
 73     return nullptr;
 74 }
 75 
<span class="line-modified"> 76 UnlinkedFunctionExecutable* BuiltinExecutables::createBuiltinExecutable(const SourceCode&amp; code, const Identifier&amp; name, ConstructorKind constructorKind, ConstructAbility constructAbility)</span>
 77 {
<span class="line-modified"> 78     return createExecutable(m_vm, code, name, constructorKind, constructAbility, NeedsClassFieldInitializer::No);</span>
 79 }
 80 
<span class="line-modified"> 81 UnlinkedFunctionExecutable* BuiltinExecutables::createExecutable(VM&amp; vm, const SourceCode&amp; source, const Identifier&amp; name, ConstructorKind constructorKind, ConstructAbility constructAbility, NeedsClassFieldInitializer needsClassFieldInitializer)</span>





 82 {
 83     // FIXME: Can we just make MetaData computation be constexpr and have the compiler do this for us?
 84     // https://bugs.webkit.org/show_bug.cgi?id=193272
 85     // Someone should get mad at me for writing this code. But, it prevents us from recursing into
 86     // the parser, and hence, from throwing stack overflow when parsing a builtin.
 87     StringView view = source.view();
 88     RELEASE_ASSERT(!view.isNull());
 89     RELEASE_ASSERT(view.is8Bit());
 90     auto* characters = view.characters8();
 91     const char* regularFunctionBegin = &quot;(function (&quot;;
 92     const char* asyncFunctionBegin = &quot;(async function (&quot;;
 93     RELEASE_ASSERT(view.length() &gt;= strlen(&quot;(function (){})&quot;));
 94     bool isAsyncFunction = view.length() &gt;= strlen(&quot;(async function (){})&quot;) &amp;&amp; !memcmp(characters, asyncFunctionBegin, strlen(asyncFunctionBegin));
 95     RELEASE_ASSERT(isAsyncFunction || !memcmp(characters, regularFunctionBegin, strlen(regularFunctionBegin)));
 96 
 97     unsigned asyncOffset = isAsyncFunction ? strlen(&quot;async &quot;) : 0;
 98     unsigned parametersStart = strlen(&quot;function (&quot;) + asyncOffset;
 99     unsigned startColumn = parametersStart;
100     int functionKeywordStart = strlen(&quot;(&quot;) + asyncOffset;
101     int functionNameStart = parametersStart;
</pre>
<hr />
<pre>
162                 }
163             }
164         }
165     }
166 
167     unsigned positionBeforeLastNewlineLineStartOffset = offsetOfSecondToLastNewline ? *offsetOfSecondToLastNewline + 1 : 0;
168 
169     int closeBraceOffsetFromEnd = 1;
170     while (true) {
171         if (characters[view.length() - closeBraceOffsetFromEnd] == &#39;}&#39;)
172             break;
173         ++closeBraceOffsetFromEnd;
174     }
175 
176     JSTextPosition positionBeforeLastNewline;
177     positionBeforeLastNewline.line = lineCount;
178     positionBeforeLastNewline.offset = source.startOffset() + offsetOfLastNewline;
179     positionBeforeLastNewline.lineStartOffset = source.startOffset() + positionBeforeLastNewlineLineStartOffset;
180 
181     SourceCode newSource = source.subExpression(source.startOffset() + parametersStart, source.startOffset() + (view.length() - closeBraceOffsetFromEnd), 0, parametersStart);
<span class="line-modified">182     bool isBuiltinDefaultClassConstructor = constructorKind != ConstructorKind::None &amp;&amp; constructorKind != ConstructorKind::Naked;</span>
183     UnlinkedFunctionKind kind = isBuiltinDefaultClassConstructor ? UnlinkedNormalFunction : UnlinkedBuiltinFunction;
184 
185     SourceParseMode parseMode = isAsyncFunction ? SourceParseMode::AsyncFunctionMode : SourceParseMode::NormalFunctionMode;
186 
187     JSTokenLocation start;
188     start.line = -1;
189     start.lineStartOffset = std::numeric_limits&lt;unsigned&gt;::max();
190     start.startOffset = source.startOffset() + parametersStart;
191     start.endOffset = std::numeric_limits&lt;unsigned&gt;::max();
192 
193     JSTokenLocation end;
194     end.line = 1;
195     end.lineStartOffset = source.startOffset();
196     end.startOffset = source.startOffset() + strlen(&quot;(&quot;) + asyncOffset;
197     end.endOffset = std::numeric_limits&lt;unsigned&gt;::max();
198 
199     FunctionMetadataNode metadata(
200         start, end, startColumn, endColumn, source.startOffset() + functionKeywordStart, source.startOffset() + functionNameStart, source.startOffset() + parametersStart,
201         isInStrictContext, constructorKind, constructorKind == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded,
202         parameterCount, parseMode, isArrowFunctionBodyExpression);
203 
204     metadata.finishParsing(newSource, Identifier(), FunctionMode::FunctionExpression);
205     metadata.overrideName(name);
206     metadata.setEndPosition(positionBeforeLastNewline);
207 
<span class="line-modified">208     if (UNLIKELY(ASSERT_ENABLED || Options::validateBytecode())) {</span>
209         JSTextPosition positionBeforeLastNewlineFromParser;
210         ParserError error;
211         JSParserBuiltinMode builtinMode = isBuiltinDefaultClassConstructor ? JSParserBuiltinMode::NotBuiltin : JSParserBuiltinMode::Builtin;
212         std::unique_ptr&lt;ProgramNode&gt; program = parse&lt;ProgramNode&gt;(
213             vm, source, Identifier(), builtinMode,
214             JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, error,
215             &amp;positionBeforeLastNewlineFromParser, constructorKind);
216 
217         if (program) {
218             StatementNode* exprStatement = program-&gt;singleStatement();
219             RELEASE_ASSERT(exprStatement);
220             RELEASE_ASSERT(exprStatement-&gt;isExprStatement());
221             ExpressionNode* funcExpr = static_cast&lt;ExprStatementNode*&gt;(exprStatement)-&gt;expr();
222             RELEASE_ASSERT(funcExpr);
223             RELEASE_ASSERT(funcExpr-&gt;isFuncExprNode());
224             FunctionMetadataNode* metadataFromParser = static_cast&lt;FuncExprNode*&gt;(funcExpr)-&gt;metadata();
225             RELEASE_ASSERT(!program-&gt;hasCapturedVariables());
226 
227             metadataFromParser-&gt;setEndPosition(positionBeforeLastNewlineFromParser);
228             RELEASE_ASSERT(metadataFromParser);
</pre>
<hr />
<pre>
234             metadataFromParser-&gt;overrideName(name);
235             metadataFromParser-&gt;setEndPosition(positionBeforeLastNewlineFromParser);
236             if (metadata != *metadataFromParser || positionBeforeLastNewlineFromParser != positionBeforeLastNewline) {
237                 dataLogLn(&quot;Expected Metadata:\n&quot;, metadata);
238                 dataLogLn(&quot;Metadata from parser:\n&quot;, *metadataFromParser);
239                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.line &quot;, positionBeforeLastNewlineFromParser.line);
240                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.offset &quot;, positionBeforeLastNewlineFromParser.offset);
241                 dataLogLn(&quot;positionBeforeLastNewlineFromParser.lineStartOffset &quot;, positionBeforeLastNewlineFromParser.lineStartOffset);
242                 dataLogLn(&quot;positionBeforeLastNewline.line &quot;, positionBeforeLastNewline.line);
243                 dataLogLn(&quot;positionBeforeLastNewline.offset &quot;, positionBeforeLastNewline.offset);
244                 dataLogLn(&quot;positionBeforeLastNewline.lineStartOffset &quot;, positionBeforeLastNewline.lineStartOffset);
245                 WTFLogAlways(&quot;Metadata of parser and hand rolled parser don&#39;t match\n&quot;);
246                 CRASH();
247             }
248         } else {
249             RELEASE_ASSERT(error.isValid());
250             RELEASE_ASSERT(error.type() == ParserError::StackOverflow);
251         }
252     }
253 
<span class="line-modified">254     UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, &amp;metadata, kind, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None, needsClassFieldInitializer, isBuiltinDefaultClassConstructor);</span>
255     return functionExecutable;
256 }
257 
258 void BuiltinExecutables::finalizeUnconditionally()
259 {
260     for (auto*&amp; unlinkedExecutable : m_unlinkedExecutables) {
261         if (unlinkedExecutable &amp;&amp; !m_vm.heap.isMarked(unlinkedExecutable))
262             unlinkedExecutable = nullptr;
263     }
264 }
265 
266 #define DEFINE_BUILTIN_EXECUTABLES(name, functionName, overrideName, length) \
267 SourceCode BuiltinExecutables::name##Source() \
268 {\
269     return SourceCode { m_combinedSourceProvider.copyRef(), static_cast&lt;int&gt;(s_##name - s_JSCCombinedCode), static_cast&lt;int&gt;((s_##name - s_JSCCombinedCode) + length), 1, 1 };\
270 }\
271 \
272 UnlinkedFunctionExecutable* BuiltinExecutables::name##Executable() \
273 {\
274     unsigned index = static_cast&lt;unsigned&gt;(BuiltinCodeIndex::name);\
275     if (!m_unlinkedExecutables[index]) {\
276         Identifier executableName = m_vm.propertyNames-&gt;builtinNames().functionName##PublicName();\
277         if (overrideName)\
278             executableName = Identifier::fromString(m_vm, overrideName);\
<span class="line-modified">279         m_unlinkedExecutables[index] = createBuiltinExecutable(name##Source(), executableName, s_##name##ConstructorKind, s_##name##ConstructAbility);\</span>
280     }\
281     return m_unlinkedExecutables[index];\
282 }
283 JSC_FOREACH_BUILTIN_CODE(DEFINE_BUILTIN_EXECUTABLES)
284 #undef DEFINE_BUILTIN_EXECUTABLES
285 
286 }
</pre>
</td>
</tr>
</table>
<center><a href="BuiltinExecutableCreator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BuiltinExecutables.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
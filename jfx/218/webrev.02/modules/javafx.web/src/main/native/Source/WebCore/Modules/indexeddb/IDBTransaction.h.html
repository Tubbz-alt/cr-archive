<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(INDEXED_DATABASE)
 29 
 30 #include &quot;EventTarget.h&quot;
 31 #include &quot;IDBActiveDOMObject.h&quot;
 32 #include &quot;IDBError.h&quot;
 33 #include &quot;IDBGetAllRecordsData.h&quot;
 34 #include &quot;IDBGetRecordData.h&quot;
 35 #include &quot;IDBKeyRangeData.h&quot;
 36 #include &quot;IDBOpenDBRequest.h&quot;
 37 #include &quot;IDBTransactionInfo.h&quot;
 38 #include &quot;IDBTransactionMode.h&quot;
 39 #include &quot;IndexedDB.h&quot;
 40 #include &quot;Timer.h&quot;
 41 #include &lt;wtf/Deque.h&gt;
 42 #include &lt;wtf/HashMap.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 class DOMException;
 47 class DOMStringList;
 48 class IDBCursor;
 49 class IDBCursorInfo;
 50 class IDBDatabase;
 51 class IDBIndex;
 52 class IDBIndexInfo;
 53 class IDBKey;
 54 class IDBKeyData;
 55 class IDBObjectStore;
 56 class IDBObjectStoreInfo;
 57 class IDBResultData;
 58 class SerializedScriptValue;
 59 
 60 struct IDBIterateCursorData;
 61 struct IDBKeyRangeData;
 62 
 63 namespace IDBClient {
 64 class IDBConnectionProxy;
 65 class TransactionOperation;
 66 }
 67 
 68 class IDBTransaction final : public ThreadSafeRefCounted&lt;IDBTransaction&gt;, public EventTargetWithInlineData, public IDBActiveDOMObject {
 69     WTF_MAKE_ISO_ALLOCATED_EXPORT(IDBTransaction, WEBCORE_EXPORT);
 70 public:
 71     static Ref&lt;IDBTransaction&gt; create(IDBDatabase&amp;, const IDBTransactionInfo&amp;);
 72     static Ref&lt;IDBTransaction&gt; create(IDBDatabase&amp;, const IDBTransactionInfo&amp;, IDBOpenDBRequest&amp;);
 73 
 74     static uint64_t generateOperationID();
 75 
 76     WEBCORE_EXPORT ~IDBTransaction() final;
 77 
 78     // IDBTransaction IDL
 79     Ref&lt;DOMStringList&gt; objectStoreNames() const;
 80     IDBTransactionMode mode() const { return m_info.mode(); }
 81     IDBDatabase* db();
 82     DOMException* error() const;
 83     ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; objectStore(const String&amp; name);
 84     ExceptionOr&lt;void&gt; abort();
 85 
 86     EventTargetInterface eventTargetInterface() const final { return IDBTransactionEventTargetInterfaceType; }
 87     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
 88     void refEventTarget() final { ThreadSafeRefCounted::ref(); }
 89     void derefEventTarget() final { ThreadSafeRefCounted::deref(); }
 90     using EventTarget::dispatchEvent;
 91     void dispatchEvent(Event&amp;) final;
 92 
 93     using ThreadSafeRefCounted&lt;IDBTransaction&gt;::ref;
 94     using ThreadSafeRefCounted&lt;IDBTransaction&gt;::deref;
 95 
 96     const char* activeDOMObjectName() const final;
 97     bool hasPendingActivity() const final;
 98     void stop() final;
 99 
100     const IDBTransactionInfo&amp; info() const { return m_info; }
101     IDBDatabase&amp; database() { return m_database.get(); }
102     const IDBDatabase&amp; database() const { return m_database.get(); }
103     IDBDatabaseInfo* originalDatabaseInfo() const { return m_info.originalDatabaseInfo(); }
104 
105     void didStart(const IDBError&amp;);
106     void didAbort(const IDBError&amp;);
107     void didCommit(const IDBError&amp;);
108 
109     bool isVersionChange() const { return mode() == IDBTransactionMode::Versionchange; }
110     bool isReadOnly() const { return mode() == IDBTransactionMode::Readonly; }
111     bool isActive() const;
112 
113     Ref&lt;IDBObjectStore&gt; createObjectStore(const IDBObjectStoreInfo&amp;);
114     void renameObjectStore(IDBObjectStore&amp;, const String&amp; newName);
115     std::unique_ptr&lt;IDBIndex&gt; createIndex(IDBObjectStore&amp;, const IDBIndexInfo&amp;);
116     void renameIndex(IDBIndex&amp;, const String&amp; newName);
117 
118     Ref&lt;IDBRequest&gt; requestPutOrAdd(JSC::JSGlobalObject&amp;, IDBObjectStore&amp;, RefPtr&lt;IDBKey&gt;&amp;&amp;, SerializedScriptValue&amp;, IndexedDB::ObjectStoreOverwriteMode);
119     Ref&lt;IDBRequest&gt; requestGetRecord(JSC::JSGlobalObject&amp;, IDBObjectStore&amp;, const IDBGetRecordData&amp;);
120     Ref&lt;IDBRequest&gt; requestGetAllObjectStoreRecords(JSC::JSGlobalObject&amp;, IDBObjectStore&amp;, const IDBKeyRangeData&amp;, IndexedDB::GetAllType, Optional&lt;uint32_t&gt; count);
121     Ref&lt;IDBRequest&gt; requestGetAllIndexRecords(JSC::JSGlobalObject&amp;, IDBIndex&amp;, const IDBKeyRangeData&amp;, IndexedDB::GetAllType, Optional&lt;uint32_t&gt; count);
122     Ref&lt;IDBRequest&gt; requestDeleteRecord(JSC::JSGlobalObject&amp;, IDBObjectStore&amp;, const IDBKeyRangeData&amp;);
123     Ref&lt;IDBRequest&gt; requestClearObjectStore(JSC::JSGlobalObject&amp;, IDBObjectStore&amp;);
124     Ref&lt;IDBRequest&gt; requestCount(JSC::JSGlobalObject&amp;, IDBObjectStore&amp;, const IDBKeyRangeData&amp;);
125     Ref&lt;IDBRequest&gt; requestCount(JSC::JSGlobalObject&amp;, IDBIndex&amp;, const IDBKeyRangeData&amp;);
126     Ref&lt;IDBRequest&gt; requestGetValue(JSC::JSGlobalObject&amp;, IDBIndex&amp;, const IDBKeyRangeData&amp;);
127     Ref&lt;IDBRequest&gt; requestGetKey(JSC::JSGlobalObject&amp;, IDBIndex&amp;, const IDBKeyRangeData&amp;);
128     Ref&lt;IDBRequest&gt; requestOpenCursor(JSC::JSGlobalObject&amp;, IDBObjectStore&amp;, const IDBCursorInfo&amp;);
129     Ref&lt;IDBRequest&gt; requestOpenCursor(JSC::JSGlobalObject&amp;, IDBIndex&amp;, const IDBCursorInfo&amp;);
130     void iterateCursor(IDBCursor&amp;, const IDBIterateCursorData&amp;);
131 
132     void deleteObjectStore(const String&amp; objectStoreName);
133     void deleteIndex(uint64_t objectStoreIdentifier, const String&amp; indexName);
134 
135     void addRequest(IDBRequest&amp;);
136     void removeRequest(IDBRequest&amp;);
137 
138     void abortDueToFailedRequest(DOMException&amp;);
139 
140     void activate();
141     void deactivate();
142 
143     void operationCompletedOnServer(const IDBResultData&amp;, IDBClient::TransactionOperation&amp;);
144     void operationCompletedOnClient(IDBClient::TransactionOperation&amp;);
145 
146     void finishedDispatchEventForRequest(IDBRequest&amp;);
147 
148     bool isFinishedOrFinishing() const;
149     bool isFinished() const { return m_state == IndexedDB::TransactionState::Finished; }
150     bool didDispatchAbortOrCommit() const { return m_didDispatchAbortOrCommit; }
151 
152     IDBClient::IDBConnectionProxy&amp; connectionProxy();
153 
154     void connectionClosedFromServer(const IDBError&amp;);
155 
156     void visitReferencedObjectStores(JSC::SlotVisitor&amp;) const;
157 
158     WEBCORE_EXPORT static std::atomic&lt;unsigned&gt; numberOfIDBTransactions;
159 
160 private:
161     IDBTransaction(IDBDatabase&amp;, const IDBTransactionInfo&amp;, IDBOpenDBRequest*);
162 
163     void commit();
164 
165     void internalAbort();
166     void notifyDidAbort(const IDBError&amp;);
167     void finishAbortOrCommit();
168     void abortInProgressOperations(const IDBError&amp;);
169 
170     enum class IsWriteOperation : bool { No, Yes };
171     void scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp;, IsWriteOperation = IsWriteOperation::No);
172     void handleOperationsCompletedOnServer();
173     void handlePendingOperations();
174     void autoCommit();
175 
176     void fireOnComplete();
177     void fireOnAbort();
178     void enqueueEvent(Ref&lt;Event&gt;&amp;&amp;);
179 
180     Ref&lt;IDBRequest&gt; requestIndexRecord(JSC::JSGlobalObject&amp;, IDBIndex&amp;, IndexedDB::IndexRecordType, const IDBKeyRangeData&amp;);
181 
182     void commitOnServer(IDBClient::TransactionOperation&amp;);
183     void abortOnServerAndCancelRequests(IDBClient::TransactionOperation&amp;);
184 
185     void createObjectStoreOnServer(IDBClient::TransactionOperation&amp;, const IDBObjectStoreInfo&amp;);
186     void didCreateObjectStoreOnServer(const IDBResultData&amp;);
187 
188     void renameObjectStoreOnServer(IDBClient::TransactionOperation&amp;, const uint64_t&amp; objectStoreIdentifier, const String&amp; newName);
189     void didRenameObjectStoreOnServer(const IDBResultData&amp;);
190 
191     void createIndexOnServer(IDBClient::TransactionOperation&amp;, const IDBIndexInfo&amp;);
192     void didCreateIndexOnServer(const IDBResultData&amp;);
193 
194     void renameIndexOnServer(IDBClient::TransactionOperation&amp;, const uint64_t&amp; objectStoreIdentifier, const uint64_t&amp; indexIdentifier, const String&amp; newName);
195     void didRenameIndexOnServer(const IDBResultData&amp;);
196 
197     void clearObjectStoreOnServer(IDBClient::TransactionOperation&amp;, const uint64_t&amp; objectStoreIdentifier);
198     void didClearObjectStoreOnServer(IDBRequest&amp;, const IDBResultData&amp;);
199 
200     void putOrAddOnServer(IDBClient::TransactionOperation&amp;, RefPtr&lt;IDBKey&gt;, RefPtr&lt;SerializedScriptValue&gt;, const IndexedDB::ObjectStoreOverwriteMode&amp;);
201     void didPutOrAddOnServer(IDBRequest&amp;, const IDBResultData&amp;);
202 
203     void getRecordOnServer(IDBClient::TransactionOperation&amp;, const IDBGetRecordData&amp;);
204     void didGetRecordOnServer(IDBRequest&amp;, const IDBResultData&amp;);
205 
206     void getAllRecordsOnServer(IDBClient::TransactionOperation&amp;, const IDBGetAllRecordsData&amp;);
207     void didGetAllRecordsOnServer(IDBRequest&amp;, const IDBResultData&amp;);
208 
209     void getCountOnServer(IDBClient::TransactionOperation&amp;, const IDBKeyRangeData&amp;);
210     void didGetCountOnServer(IDBRequest&amp;, const IDBResultData&amp;);
211 
212     void deleteRecordOnServer(IDBClient::TransactionOperation&amp;, const IDBKeyRangeData&amp;);
213     void didDeleteRecordOnServer(IDBRequest&amp;, const IDBResultData&amp;);
214 
215     void deleteObjectStoreOnServer(IDBClient::TransactionOperation&amp;, const String&amp; objectStoreName);
216     void didDeleteObjectStoreOnServer(const IDBResultData&amp;);
217 
218     void deleteIndexOnServer(IDBClient::TransactionOperation&amp;, const uint64_t&amp; objectStoreIdentifier, const String&amp; indexName);
219     void didDeleteIndexOnServer(const IDBResultData&amp;);
220 
221     Ref&lt;IDBRequest&gt; doRequestOpenCursor(JSC::JSGlobalObject&amp;, Ref&lt;IDBCursor&gt;&amp;&amp;);
222     void openCursorOnServer(IDBClient::TransactionOperation&amp;, const IDBCursorInfo&amp;);
223     void didOpenCursorOnServer(IDBRequest&amp;, const IDBResultData&amp;);
224 
225     void iterateCursorOnServer(IDBClient::TransactionOperation&amp;, const IDBIterateCursorData&amp;);
226     void didIterateCursorOnServer(IDBRequest&amp;, const IDBResultData&amp;);
227 
228     void transitionedToFinishing(IndexedDB::TransactionState);
229 
230     void establishOnServer();
231 
232     void completeNoncursorRequest(IDBRequest&amp;, const IDBResultData&amp;);
233     void completeCursorRequest(IDBRequest&amp;, const IDBResultData&amp;);
234 
235     void trySchedulePendingOperationTimer();
236 
237     Ref&lt;IDBDatabase&gt; m_database;
238     IDBTransactionInfo m_info;
239 
240     IndexedDB::TransactionState m_state { IndexedDB::TransactionState::Inactive };
241     bool m_startedOnServer { false };
242 
243     IDBError m_idbError;
244     RefPtr&lt;DOMException&gt; m_domError;
245 
246     RefPtr&lt;IDBOpenDBRequest&gt; m_openDBRequest;
247 
248     Deque&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; m_pendingTransactionOperationQueue;
249     Deque&lt;IDBClient::TransactionOperation*&gt; m_transactionOperationsInProgressQueue;
250     Deque&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; m_abortQueue;
251     HashMap&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;, IDBResultData&gt; m_transactionOperationResultMap;
252 
253     HashMap&lt;IDBResourceIdentifier, RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; m_transactionOperationMap;
254 
255     mutable Lock m_referencedObjectStoreLock;
256     HashMap&lt;String, std::unique_ptr&lt;IDBObjectStore&gt;&gt; m_referencedObjectStores;
257     HashMap&lt;uint64_t, std::unique_ptr&lt;IDBObjectStore&gt;&gt; m_deletedObjectStores;
258 
259     HashSet&lt;RefPtr&lt;IDBRequest&gt;&gt; m_openRequests;
260     RefPtr&lt;IDBRequest&gt; m_currentlyCompletingRequest;
261 
262     bool m_contextStopped { false };
263     bool m_didDispatchAbortOrCommit { false };
264 
265     uint64_t m_lastWriteOperationID { 0 };
266 };
267 
268 class TransactionActivator {
269     WTF_MAKE_NONCOPYABLE(TransactionActivator);
270 public:
271     TransactionActivator(IDBTransaction* transaction)
272         : m_transaction(transaction)
273     {
274         if (m_transaction)
275             m_transaction-&gt;activate();
276     }
277 
278     ~TransactionActivator()
279     {
280         if (m_transaction)
281             m_transaction-&gt;deactivate();
282     }
283 
284 private:
285     IDBTransaction* m_transaction;
286 };
287 
288 } // namespace WebCore
289 
290 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
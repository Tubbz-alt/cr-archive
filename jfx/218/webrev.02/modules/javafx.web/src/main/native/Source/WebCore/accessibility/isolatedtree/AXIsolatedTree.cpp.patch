diff a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/isolatedtree/AXIsolatedTree.cpp b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/isolatedtree/AXIsolatedTree.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/isolatedtree/AXIsolatedTree.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/isolatedtree/AXIsolatedTree.cpp
@@ -26,11 +26,11 @@
 #include "config.h"
 
 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 #include "AXIsolatedTree.h"
 
-#include "AXIsolatedTreeNode.h"
+#include "AXIsolatedObject.h"
 #include "Page.h"
 #include <wtf/NeverDestroyed.h>
 
 namespace WebCore {
 
@@ -40,13 +40,13 @@
 {
     static unsigned s_currentTreeID = 0;
     return ++s_currentTreeID;
 }
 
-HashMap<uint64_t, Ref<AXIsolatedTree>>& AXIsolatedTree::treePageCache()
+HashMap<PageIdentifier, Ref<AXIsolatedTree>>& AXIsolatedTree::treePageCache()
 {
-    static NeverDestroyed<HashMap<uint64_t, Ref<AXIsolatedTree>>> map;
+    static NeverDestroyed<HashMap<PageIdentifier, Ref<AXIsolatedTree>>> map;
     return map;
 }
 
 HashMap<AXIsolatedTreeID, Ref<AXIsolatedTree>>& AXIsolatedTree::treeIDCache()
 {
@@ -65,21 +65,11 @@
 {
     ASSERT(isMainThread());
     return adoptRef(*new AXIsolatedTree());
 }
 
-Ref<AXIsolatedTree> AXIsolatedTree::initializePageTreeForID(PageIdentifier pageID, AXObjectCache& cache)
-{
-    RELEASE_ASSERT(isMainThread());
-    auto tree = cache->generateIsolatedAccessibilityTree();
-    tree->setInitialRequestInProgress(true);
-    tree->applyPendingChanges();
-    tree->setInitialRequestInProgress(false);
-    return tree;
-}
-
-RefPtr<AXIsolatedTreeNode> AXIsolatedTree::nodeInTreeForID(AXIsolatedTreeID treeID, AXID axID)
+RefPtr<AXIsolatedObject> AXIsolatedTree::nodeInTreeForID(AXIsolatedTreeID treeID, AXID axID)
 {
     return treeForID(treeID)->nodeForID(axID);
 }
 
 RefPtr<AXIsolatedTree> AXIsolatedTree::treeForID(AXIsolatedTreeID treeID)
@@ -88,49 +78,71 @@
 }
 
 Ref<AXIsolatedTree> AXIsolatedTree::createTreeForPageID(PageIdentifier pageID)
 {
     LockHolder locker(s_cacheLock);
+    ASSERT(!treePageCache().contains(pageID));
 
     auto newTree = AXIsolatedTree::create();
     treePageCache().set(pageID, newTree.copyRef());
     treeIDCache().set(newTree->treeIdentifier(), newTree.copyRef());
     return newTree;
 }
 
+void AXIsolatedTree::removeTreeForPageID(PageIdentifier pageID)
+{
+    LockHolder locker(s_cacheLock);
+
+    if (auto optionalTree = treePageCache().take(pageID)) {
+        auto& tree { *optionalTree };
+        LockHolder treeLocker { tree->m_changeLogLock };
+        for (const auto& axID : tree->m_readerThreadNodeMap.keys()) {
+            if (auto object = tree->nodeForID(axID))
+                object->detach(AccessibilityDetachmentType::CacheDestroyed);
+        }
+        tree->m_pendingAppends.clear();
+        tree->m_pendingRemovals.clear();
+        tree->m_readerThreadNodeMap.clear();
+        treeLocker.unlockEarly();
+
+        treeIDCache().remove(tree->treeIdentifier());
+    }
+}
+
 RefPtr<AXIsolatedTree> AXIsolatedTree::treeForPageID(PageIdentifier pageID)
 {
     LockHolder locker(s_cacheLock);
 
     if (auto tree = treePageCache().get(pageID))
         return makeRefPtr(tree);
 
     return nullptr;
 }
 
-RefPtr<AXIsolatedTreeNode> AXIsolatedTree::nodeForID(AXID axID) const
+RefPtr<AXIsolatedObject> AXIsolatedTree::nodeForID(AXID axID) const
 {
-    RELEASE_ASSERT(!isMainThread() || initialRequest);
     if (!axID)
         return nullptr;
     return m_readerThreadNodeMap.get(axID);
 }
 
-RefPtr<AXIsolatedTreeNode> AXIsolatedTree::focusedUIElement()
+RefPtr<AXIsolatedObject> AXIsolatedTree::focusedUIElement()
 {
+    m_focusedNodeID = m_pendingFocusedNodeID;
     return nodeForID(m_focusedNodeID);
 }
 
-RefPtr<AXIsolatedTreeNode> AXIsolatedTree::rootNode()
+RefPtr<AXIsolatedObject> AXIsolatedTree::rootNode()
 {
     return nodeForID(m_rootNodeID);
 }
 
-void AXIsolatedTree::setRootNodeID(AXID axID)
+void AXIsolatedTree::setRootNode(Ref<AXIsolatedObject>& root)
 {
     LockHolder locker { m_changeLogLock };
-    m_pendingRootNodeID = axID;
+    m_rootNodeID = root->objectID();
+    m_readerThreadNodeMap.add(root->objectID(), WTFMove(root));
 }
 
 void AXIsolatedTree::setFocusedNodeID(AXID axID)
 {
     LockHolder locker { m_changeLogLock };
@@ -141,43 +153,36 @@
 {
     LockHolder locker { m_changeLogLock };
     m_pendingRemovals.append(axID);
 }
 
-void AXIsolatedTree::appendNodeChanges(Vector<Ref<AXIsolatedTreeNode>>& log)
+void AXIsolatedTree::appendNodeChanges(Vector<Ref<AXIsolatedObject>>& log)
 {
     LockHolder locker { m_changeLogLock };
     for (auto& node : log)
         m_pendingAppends.append(node.copyRef());
 }
 
-void AXIsolatedTree::setInitialRequestInProgress(bool initialRequestInProgress)
-{
-    m_initialRequestInProgress = initialRequestInProgress;
-}
-
 void AXIsolatedTree::applyPendingChanges()
 {
-    RELEASE_ASSERT(!isMainThread() || initialRequest);
+    RELEASE_ASSERT(!isMainThread());
     LockHolder locker { m_changeLogLock };
-    Vector<Ref<AXIsolatedTreeNode>> appendCopy;
-    std::swap(appendCopy, m_pendingAppends);
-    Vector<AXID> removeCopy({ WTFMove(m_pendingRemovals) });
-    locker.unlockEarly();
 
     // We don't clear the pending IDs beacause if the next round of updates does not modify them, then they stay the same
     // value without extra bookkeeping.
-    m_rootNodeID = m_pendingRootNodeID;
     m_focusedNodeID = m_pendingFocusedNodeID;
 
-    for (auto& item : appendCopy) {
-        item->setTreeIdentifier(m_treeID);
-        m_readerThreadNodeMap.add(item->identifier(), WTFMove(item));
-    }
+    for (auto& item : m_pendingAppends)
+        m_readerThreadNodeMap.add(item->objectID(), WTFMove(item));
+    m_pendingAppends.clear();
 
-    for (auto item : removeCopy)
+    for (auto& item : m_pendingRemovals) {
+        if (auto object = nodeForID(item))
+            object->detach(AccessibilityDetachmentType::ElementDestroyed);
         m_readerThreadNodeMap.remove(item);
+    }
+    m_pendingRemovals.clear();
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(ACCESSIBILITY_ISOLATED_TREE)

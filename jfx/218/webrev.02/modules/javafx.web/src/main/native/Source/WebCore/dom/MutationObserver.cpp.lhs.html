<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/MutationObserver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 
 34 #include &quot;MutationObserver.h&quot;
 35 
 36 #include &quot;Document.h&quot;
 37 #include &quot;GCReachableRef.h&quot;
 38 #include &quot;HTMLSlotElement.h&quot;
 39 #include &quot;InspectorInstrumentation.h&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 40 #include &quot;Microtasks.h&quot;</span>
 41 #include &quot;MutationCallback.h&quot;
 42 #include &quot;MutationObserverRegistration.h&quot;
 43 #include &quot;MutationRecord.h&quot;
<a name="2" id="anc2"></a>
 44 #include &lt;algorithm&gt;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/MainThread.h&gt;
 47 #include &lt;wtf/NeverDestroyed.h&gt;
 48 
 49 namespace WebCore {
 50 
 51 WTF_MAKE_ISO_ALLOCATED_IMPL(MutationObserver);
 52 
 53 static unsigned s_observerPriority = 0;
 54 
 55 Ref&lt;MutationObserver&gt; MutationObserver::create(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 56 {
 57     ASSERT(isMainThread());
 58     return adoptRef(*new MutationObserver(WTFMove(callback)));
 59 }
 60 
 61 MutationObserver::MutationObserver(Ref&lt;MutationCallback&gt;&amp;&amp; callback)
 62     : m_callback(WTFMove(callback))
 63     , m_priority(s_observerPriority++)
 64 {
 65 }
 66 
 67 MutationObserver::~MutationObserver()
 68 {
 69     ASSERT(m_registrations.isEmpty());
 70 }
 71 
 72 bool MutationObserver::validateOptions(MutationObserverOptions options)
 73 {
 74     return (options &amp; (Attributes | CharacterData | ChildList))
 75         &amp;&amp; ((options &amp; Attributes) || !(options &amp; AttributeOldValue))
 76         &amp;&amp; ((options &amp; Attributes) || !(options &amp; AttributeFilter))
 77         &amp;&amp; ((options &amp; CharacterData) || !(options &amp; CharacterDataOldValue));
 78 }
 79 
 80 ExceptionOr&lt;void&gt; MutationObserver::observe(Node&amp; node, const Init&amp; init)
 81 {
 82     MutationObserverOptions options = 0;
 83 
 84     if (init.childList)
 85         options |= ChildList;
 86     if (init.subtree)
 87         options |= Subtree;
 88     if (init.attributeOldValue.valueOr(false))
 89         options |= AttributeOldValue;
 90     if (init.characterDataOldValue.valueOr(false))
 91         options |= CharacterDataOldValue;
 92 
 93     HashSet&lt;AtomString&gt; attributeFilter;
 94     if (init.attributeFilter) {
 95         for (auto&amp; value : init.attributeFilter.value())
 96             attributeFilter.add(value);
 97         options |= AttributeFilter;
 98     }
 99 
100     if (init.attributes ? init.attributes.value() : (options &amp; (AttributeFilter | AttributeOldValue)))
101         options |= Attributes;
102 
103     if (init.characterData ? init.characterData.value() : (options &amp; CharacterDataOldValue))
104         options |= CharacterData;
105 
106     if (!validateOptions(options))
107         return Exception { TypeError };
108 
109     node.registerMutationObserver(*this, options, attributeFilter);
110 
111     return { };
112 }
113 
114 auto MutationObserver::takeRecords() -&gt; TakenRecords
115 {
116     return { WTFMove(m_records), WTFMove(m_pendingTargets) };
117 }
118 
119 void MutationObserver::disconnect()
120 {
121     m_pendingTargets.clear();
122     m_records.clear();
123     HashSet&lt;MutationObserverRegistration*&gt; registrations(m_registrations);
124     for (auto* registration : registrations)
125         registration-&gt;node().unregisterMutationObserver(*registration);
126 }
127 
128 void MutationObserver::observationStarted(MutationObserverRegistration&amp; registration)
129 {
130     ASSERT(!m_registrations.contains(&amp;registration));
131     m_registrations.add(&amp;registration);
132 }
133 
134 void MutationObserver::observationEnded(MutationObserverRegistration&amp; registration)
135 {
136     ASSERT(m_registrations.contains(&amp;registration));
137     m_registrations.remove(&amp;registration);
138 }
139 
<a name="3" id="anc3"></a><span class="line-removed">140 typedef HashSet&lt;RefPtr&lt;MutationObserver&gt;&gt; MutationObserverSet;</span>
<span class="line-removed">141 </span>
<span class="line-removed">142 static MutationObserverSet&amp; activeMutationObservers()</span>
<span class="line-removed">143 {</span>
<span class="line-removed">144     static NeverDestroyed&lt;MutationObserverSet&gt; activeObservers;</span>
<span class="line-removed">145     return activeObservers;</span>
<span class="line-removed">146 }</span>
<span class="line-removed">147 </span>
<span class="line-removed">148 static MutationObserverSet&amp; suspendedMutationObservers()</span>
<span class="line-removed">149 {</span>
<span class="line-removed">150     static NeverDestroyed&lt;MutationObserverSet&gt; suspendedObservers;</span>
<span class="line-removed">151     return suspendedObservers;</span>
<span class="line-removed">152 }</span>
<span class="line-removed">153 </span>
<span class="line-removed">154 // https://dom.spec.whatwg.org/#signal-slot-list</span>
<span class="line-removed">155 static Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt;&amp; signalSlotList()</span>
<span class="line-removed">156 {</span>
<span class="line-removed">157     static NeverDestroyed&lt;Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt;&gt; list;</span>
<span class="line-removed">158     return list;</span>
<span class="line-removed">159 }</span>
<span class="line-removed">160 </span>
<span class="line-removed">161 static bool mutationObserverCompoundMicrotaskQueuedFlag;</span>
<span class="line-removed">162 </span>
<span class="line-removed">163 class MutationObserverMicrotask final : public Microtask {</span>
<span class="line-removed">164     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed">165 private:</span>
<span class="line-removed">166     Result run() final</span>
<span class="line-removed">167     {</span>
<span class="line-removed">168         MutationObserver::notifyMutationObservers();</span>
<span class="line-removed">169         return Result::Done;</span>
<span class="line-removed">170     }</span>
<span class="line-removed">171 };</span>
<span class="line-removed">172 </span>
<span class="line-removed">173 static void queueMutationObserverCompoundMicrotask()</span>
<span class="line-removed">174 {</span>
<span class="line-removed">175     if (mutationObserverCompoundMicrotaskQueuedFlag)</span>
<span class="line-removed">176         return;</span>
<span class="line-removed">177     mutationObserverCompoundMicrotaskQueuedFlag = true;</span>
<span class="line-removed">178     MicrotaskQueue::mainThreadQueue().append(makeUnique&lt;MutationObserverMicrotask&gt;());</span>
<span class="line-removed">179 }</span>
<span class="line-removed">180 </span>
181 void MutationObserver::enqueueMutationRecord(Ref&lt;MutationRecord&gt;&amp;&amp; mutation)
182 {
183     ASSERT(isMainThread());
184     ASSERT(mutation-&gt;target());
<a name="4" id="anc4"></a>

185     m_pendingTargets.add(*mutation-&gt;target());
186     m_records.append(WTFMove(mutation));
<a name="5" id="anc5"></a><span class="line-removed">187     activeMutationObservers().add(this);</span>
188 
<a name="6" id="anc6"></a><span class="line-modified">189     queueMutationObserverCompoundMicrotask();</span>


190 }
191 
192 void MutationObserver::enqueueSlotChangeEvent(HTMLSlotElement&amp; slot)
193 {
194     ASSERT(isMainThread());
<a name="7" id="anc7"></a><span class="line-modified">195     ASSERT(signalSlotList().findMatching([&amp;slot](auto&amp; entry) { return entry.ptr() == &amp;slot; }) == notFound);</span>
<span class="line-modified">196     signalSlotList().append(slot);</span>


197 
<a name="8" id="anc8"></a><span class="line-modified">198     queueMutationObserverCompoundMicrotask();</span>
199 }
200 
<a name="9" id="anc9"></a><span class="line-modified">201 void MutationObserver::setHasTransientRegistration()</span>
202 {
<a name="10" id="anc10"></a><span class="line-modified">203     ASSERT(isMainThread());</span>
<span class="line-modified">204     activeMutationObservers().add(this);</span>
<span class="line-modified">205 </span>
<span class="line-removed">206     queueMutationObserverCompoundMicrotask();</span>
207 }
208 
209 HashSet&lt;Node*&gt; MutationObserver::observedNodes() const
210 {
211     HashSet&lt;Node*&gt; observedNodes;
212     for (auto* registration : m_registrations)
213         registration-&gt;addRegistrationNodesToSet(observedNodes);
214     return observedNodes;
215 }
216 
217 bool MutationObserver::canDeliver()
218 {
219     return m_callback-&gt;canInvokeCallback();
220 }
221 
222 void MutationObserver::deliver()
223 {
224     ASSERT(canDeliver());
225 
226     // Calling takeTransientRegistrations() can modify m_registrations, so it&#39;s necessary
227     // to make a copy of the transient registrations before operating on them.
228     Vector&lt;MutationObserverRegistration*, 1&gt; transientRegistrations;
229     Vector&lt;std::unique_ptr&lt;HashSet&lt;GCReachableRef&lt;Node&gt;&gt;&gt;, 1&gt; nodesToKeepAlive;
230     HashSet&lt;GCReachableRef&lt;Node&gt;&gt; pendingTargets;
231     pendingTargets.swap(m_pendingTargets);
232     for (auto* registration : m_registrations) {
233         if (registration-&gt;hasTransientRegistrations())
234             transientRegistrations.append(registration);
235     }
236     for (auto&amp; registration : transientRegistrations)
237         nodesToKeepAlive.append(registration-&gt;takeTransientRegistrations());
238 
239     if (m_records.isEmpty()) {
240         ASSERT(m_pendingTargets.isEmpty());
241         return;
242     }
243 
244     Vector&lt;Ref&lt;MutationRecord&gt;&gt; records;
245     records.swap(m_records);
246 
247     // FIXME: Keep mutation observer callback as long as its observed nodes are alive. See https://webkit.org/b/179224.
248     if (m_callback-&gt;hasCallback()) {
249         auto* context = m_callback-&gt;scriptExecutionContext();
250         if (!context)
251             return;
252 
<a name="11" id="anc11"></a><span class="line-modified">253         InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireObserverCallback(*context, &quot;MutationObserver&quot;_s);</span>
254         m_callback-&gt;handleEvent(*this, records, *this);
<a name="12" id="anc12"></a><span class="line-modified">255         InspectorInstrumentation::didFireObserverCallback(cookie);</span>
256     }
257 }
258 
<a name="13" id="anc13"></a><span class="line-modified">259 void MutationObserver::notifyMutationObservers()</span>

260 {
<a name="14" id="anc14"></a><span class="line-modified">261     // https://dom.spec.whatwg.org/#notify-mutation-observers</span>
<span class="line-modified">262     // 1. Unset mutation observer compound microtask queued flag.</span>
<span class="line-removed">263     mutationObserverCompoundMicrotaskQueuedFlag = false;</span>
<span class="line-removed">264 </span>
<span class="line-removed">265     ASSERT(isMainThread());</span>
<span class="line-removed">266     static bool deliveryInProgress = false;</span>
<span class="line-removed">267     if (deliveryInProgress)</span>
<span class="line-removed">268         return;</span>
<span class="line-removed">269     deliveryInProgress = true;</span>
<span class="line-removed">270 </span>
<span class="line-removed">271     if (!suspendedMutationObservers().isEmpty()) {</span>
<span class="line-removed">272         for (auto&amp; observer : copyToVector(suspendedMutationObservers())) {</span>
273             if (!observer-&gt;canDeliver())
274                 continue;
275 
<a name="15" id="anc15"></a><span class="line-modified">276             suspendedMutationObservers().remove(observer);</span>
<span class="line-modified">277             activeMutationObservers().add(observer);</span>
278         }
279     }
280 
<a name="16" id="anc16"></a><span class="line-modified">281     while (!activeMutationObservers().isEmpty() || !signalSlotList().isEmpty()) {</span>
282         // 2. Let notify list be a copy of unit of related similar-origin browsing contexts&#39; list of MutationObserver objects.
<a name="17" id="anc17"></a><span class="line-modified">283         auto notifyList = copyToVector(activeMutationObservers());</span>
<span class="line-modified">284         activeMutationObservers().clear();</span>
285         std::sort(notifyList.begin(), notifyList.end(), [](auto&amp; lhs, auto&amp; rhs) {
286             return lhs-&gt;m_priority &lt; rhs-&gt;m_priority;
287         });
288 
289         // 3. Let signalList be a copy of unit of related similar-origin browsing contexts&#39; signal slot list.
290         // 4. Empty unit of related similar-origin browsing contexts&#39; signal slot list.
291         Vector&lt;GCReachableRef&lt;HTMLSlotElement&gt;&gt; slotList;
<a name="18" id="anc18"></a><span class="line-modified">292         if (!signalSlotList().isEmpty()) {</span>
<span class="line-modified">293             slotList.swap(signalSlotList());</span>
294             for (auto&amp; slot : slotList)
295                 slot-&gt;didRemoveFromSignalSlotList();
296         }
297 
298         // 5. For each MutationObserver object mo in notify list, execute a compound microtask subtask
299         for (auto&amp; observer : notifyList) {
300             if (observer-&gt;canDeliver())
301                 observer-&gt;deliver();
302             else
<a name="19" id="anc19"></a><span class="line-modified">303                 suspendedMutationObservers().add(observer);</span>
304         }
305 
306         // 6. For each slot slot in signalList, in order, fire an event named slotchange, with its bubbles attribute set to true, at slot.
307         for (auto&amp; slot : slotList)
308             slot-&gt;dispatchSlotChangeEvent();
309     }
<a name="20" id="anc20"></a><span class="line-removed">310 </span>
<span class="line-removed">311     deliveryInProgress = false;</span>
312 }
313 
314 } // namespace WebCore
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
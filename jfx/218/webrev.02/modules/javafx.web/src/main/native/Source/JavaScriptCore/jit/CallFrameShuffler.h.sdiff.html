<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallFrameShuffler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffler64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 88     }
 89 
 90     // You can only take a snapshot if the recovery has not started
 91     // yet. The only operations that are valid before taking a
 92     // snapshot are lockGPR(), acquireGPR() and releaseGPR().
 93     //
 94     // Locking status is *NOT* preserved by the snapshot: it only
 95     // contains information about where the
 96     // arguments/callee/callee-save registers are by taking into
 97     // account any spilling that acquireGPR() could have done.
 98     CallFrameShuffleData snapshot() const
 99     {
100         ASSERT(isUndecided());
101 
102         CallFrameShuffleData data;
103         data.numLocals = numLocals();
104         data.numPassedArgs = m_numPassedArgs;
105         data.callee = getNew(VirtualRegister { CallFrameSlot::callee })-&gt;recovery();
106         data.args.resize(argCount());
107         for (size_t i = 0; i &lt; argCount(); ++i)
<span class="line-modified">108             data.args[i] = getNew(virtualRegisterForArgument(i))-&gt;recovery();</span>
109         for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
110             CachedRecovery* cachedRecovery { m_newRegisters[reg] };
111             if (!cachedRecovery)
112                 continue;
113 
114 #if USE(JSVALUE64)
115             data.registers[reg] = cachedRecovery-&gt;recovery();
116 #else
117             RELEASE_ASSERT_NOT_REACHED();
118 #endif
119         }
120         return data;
121     }
122 
123     // Ask the shuffler to put the callee into some registers once the
124     // shuffling is done. You should call this before any of the
125     // prepare() methods, and must not take a snapshot afterwards, as
126     // this would crash 32bits platforms.
127     void setCalleeJSValueRegs(JSValueRegs jsValueRegs)
128     {
129         ASSERT(isUndecided());
130         ASSERT(!getNew(jsValueRegs));
<span class="line-modified">131         CachedRecovery* cachedRecovery { getNew(VirtualRegister(CallFrameSlot::callee)) };</span>
132         ASSERT(cachedRecovery);
133         addNew(jsValueRegs, cachedRecovery-&gt;recovery());
134     }
135 
136     // Ask the suhffler to assume the callee has already be checked to
137     // be a cell. This is a no-op on 64bit platforms, but allows to
138     // free up a GPR on 32bit platforms.
139     // You obviously must have ensured that this is the case before
140     // running any of the prepare methods.
141     void assumeCalleeIsCell()
142     {
143 #if USE(JSVALUE32_64)
<span class="line-modified">144         CachedRecovery&amp; calleeCachedRecovery = *getNew(VirtualRegister(CallFrameSlot::callee));</span>
145         switch (calleeCachedRecovery.recovery().technique()) {
146         case InPair:
147             updateRecovery(
148                 calleeCachedRecovery,
149                 ValueRecovery::inGPR(
150                     calleeCachedRecovery.recovery().payloadGPR(),
151                     DataFormatCell));
152             break;
153         case DisplacedInJSStack:
154             updateRecovery(
155                 calleeCachedRecovery,
156                 ValueRecovery::displacedInJSStack(
157                     calleeCachedRecovery.recovery().virtualRegister(),
158                     DataFormatCell));
159             break;
160         case InFPR:
161         case UnboxedCellInGPR:
162         case CellDisplacedInJSStack:
163             break;
164         case Constant:
</pre>
<hr />
<pre>
168             RELEASE_ASSERT_NOT_REACHED();
169             break;
170         }
171 #endif
172     }
173 
174     // This will emit code to build the new frame over the old one.
175     void prepareForTailCall();
176 
177     // This will emit code to build the new frame as if performing a
178     // regular call. However, the callee save registers will be
179     // restored, and any locals (not the header or arguments) of the
180     // current frame can be overwritten.
181     //
182     // A frame built using prepareForSlowPath() should be used either
183     // to throw an exception in, or destroyed using
184     // CCallHelpers::prepareForTailCallSlow() followed by a tail call.
185     void prepareForSlowPath();
186 
187 private:
<span class="line-modified">188     static const bool verbose = false;</span>
189 
190     CCallHelpers&amp; m_jit;
191 
192     void prepareAny();
193 
194     void spill(CachedRecovery&amp;);
195 
196     // &quot;box&quot; is arguably a bad name here. The meaning is that after
197     // calling emitBox(), your ensure that subsequently calling
198     // emitStore() will be able to store the value without additional
199     // transformation. In particular, this is a no-op for constants,
200     // and is a complete no-op on 32bits since any unboxed value can
201     // still be stored by storing the payload and a statically known
202     // tag.
203     void emitBox(CachedRecovery&amp;);
204 
205     bool canBox(CachedRecovery&amp; cachedRecovery)
206     {
207         if (cachedRecovery.boxingRequiresGPR() &amp;&amp; getFreeGPR() == InvalidGPRReg)
208             return false;
</pre>
<hr />
<pre>
395 
396     // This stores the set of locked registers, i.e. registers for
397     // which we have an implicit requirement that they are not changed.
398     //
399     // This will usually contains the link register on architectures
400     // that have one, any scratch register used by the macro assembler
401     // (e.g. r11 on X86_64), as well as any register that we use for
402     // addressing (see m_oldFrameBase and m_newFrameBase).
403     //
404     // We also use this to lock registers temporarily, for instance to
405     // ensure that we have at least 2 available registers for loading
406     // a pair on 32bits.
407     mutable RegisterSet m_lockedRegisters;
408 
409     // This stores the current recoveries present in registers. A null
410     // CachedRecovery means we can trash the current value as we don&#39;t
411     // care about it.
412     RegisterMap&lt;CachedRecovery*&gt; m_registers;
413 
414 #if USE(JSVALUE64)
<span class="line-modified">415     mutable GPRReg m_tagTypeNumber;</span>
416 
<span class="line-modified">417     bool tryAcquireTagTypeNumber();</span>
418 #endif
419 
420     // This stores, for each register, information about the recovery
421     // for the value that should eventually go into that register. The
422     // only registers that have a target recovery will be callee-save
423     // registers, as well as possibly one JSValueRegs for holding the
424     // callee.
425     //
426     // Once the correct value has been put into the registers, and
427     // contrary to what we do with m_newFrame, we keep the entry in
428     // m_newRegisters to simplify spilling.
429     RegisterMap&lt;CachedRecovery*&gt; m_newRegisters;
430 
431     template&lt;typename CheckFunctor&gt;
432     Reg getFreeRegister(const CheckFunctor&amp; check) const
433     {
434         Reg nonTemp { };
435         for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
436             if (m_lockedRegisters.get(reg))
437                 continue;
438 
439             if (!check(reg))
440                 continue;
441 
442             if (!m_registers[reg]) {
443                 if (!m_newRegisters[reg])
444                     return reg;
445                 if (!nonTemp)
446                     nonTemp = reg;
447             }
448         }
449 
450 #if USE(JSVALUE64)
<span class="line-modified">451         if (!nonTemp &amp;&amp; m_tagTypeNumber != InvalidGPRReg &amp;&amp; check(Reg { m_tagTypeNumber })) {</span>
<span class="line-modified">452             ASSERT(m_lockedRegisters.get(m_tagTypeNumber));</span>
<span class="line-modified">453             m_lockedRegisters.clear(m_tagTypeNumber);</span>
<span class="line-modified">454             nonTemp = Reg { m_tagTypeNumber };</span>
<span class="line-modified">455             m_tagTypeNumber = InvalidGPRReg;</span>
456         }
457 #endif
458         return nonTemp;
459     }
460 
461     GPRReg getFreeTempGPR() const
462     {
463         Reg freeTempGPR { getFreeRegister([this] (Reg reg) { return reg.isGPR() &amp;&amp; !m_newRegisters[reg]; }) };
464         if (!freeTempGPR)
465             return InvalidGPRReg;
466         return freeTempGPR.gpr();
467     }
468 
469     GPRReg getFreeGPR() const
470     {
471         Reg freeGPR { getFreeRegister([] (Reg reg) { return reg.isGPR(); }) };
472         if (!freeGPR)
473             return InvalidGPRReg;
474         return freeGPR.gpr();
475     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 88     }
 89 
 90     // You can only take a snapshot if the recovery has not started
 91     // yet. The only operations that are valid before taking a
 92     // snapshot are lockGPR(), acquireGPR() and releaseGPR().
 93     //
 94     // Locking status is *NOT* preserved by the snapshot: it only
 95     // contains information about where the
 96     // arguments/callee/callee-save registers are by taking into
 97     // account any spilling that acquireGPR() could have done.
 98     CallFrameShuffleData snapshot() const
 99     {
100         ASSERT(isUndecided());
101 
102         CallFrameShuffleData data;
103         data.numLocals = numLocals();
104         data.numPassedArgs = m_numPassedArgs;
105         data.callee = getNew(VirtualRegister { CallFrameSlot::callee })-&gt;recovery();
106         data.args.resize(argCount());
107         for (size_t i = 0; i &lt; argCount(); ++i)
<span class="line-modified">108             data.args[i] = getNew(virtualRegisterForArgumentIncludingThis(i))-&gt;recovery();</span>
109         for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
110             CachedRecovery* cachedRecovery { m_newRegisters[reg] };
111             if (!cachedRecovery)
112                 continue;
113 
114 #if USE(JSVALUE64)
115             data.registers[reg] = cachedRecovery-&gt;recovery();
116 #else
117             RELEASE_ASSERT_NOT_REACHED();
118 #endif
119         }
120         return data;
121     }
122 
123     // Ask the shuffler to put the callee into some registers once the
124     // shuffling is done. You should call this before any of the
125     // prepare() methods, and must not take a snapshot afterwards, as
126     // this would crash 32bits platforms.
127     void setCalleeJSValueRegs(JSValueRegs jsValueRegs)
128     {
129         ASSERT(isUndecided());
130         ASSERT(!getNew(jsValueRegs));
<span class="line-modified">131         CachedRecovery* cachedRecovery { getNew(CallFrameSlot::callee) };</span>
132         ASSERT(cachedRecovery);
133         addNew(jsValueRegs, cachedRecovery-&gt;recovery());
134     }
135 
136     // Ask the suhffler to assume the callee has already be checked to
137     // be a cell. This is a no-op on 64bit platforms, but allows to
138     // free up a GPR on 32bit platforms.
139     // You obviously must have ensured that this is the case before
140     // running any of the prepare methods.
141     void assumeCalleeIsCell()
142     {
143 #if USE(JSVALUE32_64)
<span class="line-modified">144         CachedRecovery&amp; calleeCachedRecovery = *getNew(CallFrameSlot::callee);</span>
145         switch (calleeCachedRecovery.recovery().technique()) {
146         case InPair:
147             updateRecovery(
148                 calleeCachedRecovery,
149                 ValueRecovery::inGPR(
150                     calleeCachedRecovery.recovery().payloadGPR(),
151                     DataFormatCell));
152             break;
153         case DisplacedInJSStack:
154             updateRecovery(
155                 calleeCachedRecovery,
156                 ValueRecovery::displacedInJSStack(
157                     calleeCachedRecovery.recovery().virtualRegister(),
158                     DataFormatCell));
159             break;
160         case InFPR:
161         case UnboxedCellInGPR:
162         case CellDisplacedInJSStack:
163             break;
164         case Constant:
</pre>
<hr />
<pre>
168             RELEASE_ASSERT_NOT_REACHED();
169             break;
170         }
171 #endif
172     }
173 
174     // This will emit code to build the new frame over the old one.
175     void prepareForTailCall();
176 
177     // This will emit code to build the new frame as if performing a
178     // regular call. However, the callee save registers will be
179     // restored, and any locals (not the header or arguments) of the
180     // current frame can be overwritten.
181     //
182     // A frame built using prepareForSlowPath() should be used either
183     // to throw an exception in, or destroyed using
184     // CCallHelpers::prepareForTailCallSlow() followed by a tail call.
185     void prepareForSlowPath();
186 
187 private:
<span class="line-modified">188     static constexpr bool verbose = false;</span>
189 
190     CCallHelpers&amp; m_jit;
191 
192     void prepareAny();
193 
194     void spill(CachedRecovery&amp;);
195 
196     // &quot;box&quot; is arguably a bad name here. The meaning is that after
197     // calling emitBox(), your ensure that subsequently calling
198     // emitStore() will be able to store the value without additional
199     // transformation. In particular, this is a no-op for constants,
200     // and is a complete no-op on 32bits since any unboxed value can
201     // still be stored by storing the payload and a statically known
202     // tag.
203     void emitBox(CachedRecovery&amp;);
204 
205     bool canBox(CachedRecovery&amp; cachedRecovery)
206     {
207         if (cachedRecovery.boxingRequiresGPR() &amp;&amp; getFreeGPR() == InvalidGPRReg)
208             return false;
</pre>
<hr />
<pre>
395 
396     // This stores the set of locked registers, i.e. registers for
397     // which we have an implicit requirement that they are not changed.
398     //
399     // This will usually contains the link register on architectures
400     // that have one, any scratch register used by the macro assembler
401     // (e.g. r11 on X86_64), as well as any register that we use for
402     // addressing (see m_oldFrameBase and m_newFrameBase).
403     //
404     // We also use this to lock registers temporarily, for instance to
405     // ensure that we have at least 2 available registers for loading
406     // a pair on 32bits.
407     mutable RegisterSet m_lockedRegisters;
408 
409     // This stores the current recoveries present in registers. A null
410     // CachedRecovery means we can trash the current value as we don&#39;t
411     // care about it.
412     RegisterMap&lt;CachedRecovery*&gt; m_registers;
413 
414 #if USE(JSVALUE64)
<span class="line-modified">415     mutable GPRReg m_numberTagRegister;</span>
416 
<span class="line-modified">417     bool tryAcquireNumberTagRegister();</span>
418 #endif
419 
420     // This stores, for each register, information about the recovery
421     // for the value that should eventually go into that register. The
422     // only registers that have a target recovery will be callee-save
423     // registers, as well as possibly one JSValueRegs for holding the
424     // callee.
425     //
426     // Once the correct value has been put into the registers, and
427     // contrary to what we do with m_newFrame, we keep the entry in
428     // m_newRegisters to simplify spilling.
429     RegisterMap&lt;CachedRecovery*&gt; m_newRegisters;
430 
431     template&lt;typename CheckFunctor&gt;
432     Reg getFreeRegister(const CheckFunctor&amp; check) const
433     {
434         Reg nonTemp { };
435         for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
436             if (m_lockedRegisters.get(reg))
437                 continue;
438 
439             if (!check(reg))
440                 continue;
441 
442             if (!m_registers[reg]) {
443                 if (!m_newRegisters[reg])
444                     return reg;
445                 if (!nonTemp)
446                     nonTemp = reg;
447             }
448         }
449 
450 #if USE(JSVALUE64)
<span class="line-modified">451         if (!nonTemp &amp;&amp; m_numberTagRegister != InvalidGPRReg &amp;&amp; check(Reg { m_numberTagRegister })) {</span>
<span class="line-modified">452             ASSERT(m_lockedRegisters.get(m_numberTagRegister));</span>
<span class="line-modified">453             m_lockedRegisters.clear(m_numberTagRegister);</span>
<span class="line-modified">454             nonTemp = Reg { m_numberTagRegister };</span>
<span class="line-modified">455             m_numberTagRegister = InvalidGPRReg;</span>
456         }
457 #endif
458         return nonTemp;
459     }
460 
461     GPRReg getFreeTempGPR() const
462     {
463         Reg freeTempGPR { getFreeRegister([this] (Reg reg) { return reg.isGPR() &amp;&amp; !m_newRegisters[reg]; }) };
464         if (!freeTempGPR)
465             return InvalidGPRReg;
466         return freeTempGPR.gpr();
467     }
468 
469     GPRReg getFreeGPR() const
470     {
471         Reg freeGPR { getFreeRegister([] (Reg reg) { return reg.isGPR(); }) };
472         if (!freeGPR)
473             return InvalidGPRReg;
474         return freeGPR.gpr();
475     }
</pre>
</td>
</tr>
</table>
<center><a href="CallFrameShuffler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffler64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
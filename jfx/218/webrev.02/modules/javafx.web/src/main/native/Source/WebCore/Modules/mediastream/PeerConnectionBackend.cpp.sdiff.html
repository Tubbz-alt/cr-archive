<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="OverconstrainedErrorEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PeerConnectionBackend.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;PeerConnectionBackend.h&quot;
 34 
 35 #if ENABLE(WEB_RTC)
 36 
 37 #include &quot;EventNames.h&quot;

 38 #include &quot;JSRTCSessionDescription.h&quot;
 39 #include &quot;LibWebRTCCertificateGenerator.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;Page.h&quot;
 42 #include &quot;RTCIceCandidate.h&quot;
 43 #include &quot;RTCPeerConnection.h&quot;
 44 #include &quot;RTCPeerConnectionIceEvent.h&quot;
 45 #include &quot;RTCRtpCapabilities.h&quot;
 46 #include &quot;RTCTrackEvent.h&quot;
 47 #include &quot;RuntimeEnabledFeatures.h&quot;
 48 #include &lt;wtf/text/StringBuilder.h&gt;
 49 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 50 
 51 namespace WebCore {
 52 
 53 using namespace PAL;
 54 
 55 #if !USE(LIBWEBRTC)
 56 static std::unique_ptr&lt;PeerConnectionBackend&gt; createNoPeerConnectionBackend(RTCPeerConnection&amp;)
 57 {
</pre>
<hr />
<pre>
 65     ASSERT_NOT_REACHED();
 66     return { };
 67 }
 68 
 69 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::senderCapabilities(ScriptExecutionContext&amp;, const String&amp;)
 70 {
 71     ASSERT_NOT_REACHED();
 72     return { };
 73 }
 74 #endif
 75 
 76 PeerConnectionBackend::PeerConnectionBackend(RTCPeerConnection&amp; peerConnection)
 77     : m_peerConnection(peerConnection)
 78 #if !RELEASE_LOG_DISABLED
 79     , m_logger(peerConnection.logger())
 80     , m_logIdentifier(peerConnection.logIdentifier())
 81 #endif
 82 {
 83 }
 84 


 85 void PeerConnectionBackend::createOffer(RTCOfferOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
 86 {
 87     ASSERT(!m_offerAnswerPromise);
 88     ASSERT(!m_peerConnection.isClosed());
 89 
<span class="line-modified"> 90     m_offerAnswerPromise = WTFMove(promise);</span>
 91     doCreateOffer(WTFMove(options));
 92 }
 93 
 94 void PeerConnectionBackend::createOfferSucceeded(String&amp;&amp; sdp)
 95 {
 96     ASSERT(isMainThread());
 97     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer succeeded:\n&quot;, sdp);
 98 
<span class="line-removed"> 99     if (m_peerConnection.isClosed())</span>
<span class="line-removed">100         return;</span>
<span class="line-removed">101 </span>
102     ASSERT(m_offerAnswerPromise);
<span class="line-modified">103     m_offerAnswerPromise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Offer, filterSDP(WTFMove(sdp)) });</span>
<span class="line-modified">104     m_offerAnswerPromise = WTF::nullopt;</span>




105 }
106 
107 void PeerConnectionBackend::createOfferFailed(Exception&amp;&amp; exception)
108 {
109     ASSERT(isMainThread());
110     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer failed:&quot;, exception.message());
111 
<span class="line-removed">112     if (m_peerConnection.isClosed())</span>
<span class="line-removed">113         return;</span>
<span class="line-removed">114 </span>
115     ASSERT(m_offerAnswerPromise);
<span class="line-modified">116     m_offerAnswerPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">117     m_offerAnswerPromise = WTF::nullopt;</span>




118 }
119 
120 void PeerConnectionBackend::createAnswer(RTCAnswerOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
121 {
122     ASSERT(!m_offerAnswerPromise);
123     ASSERT(!m_peerConnection.isClosed());
124 
<span class="line-modified">125     m_offerAnswerPromise = WTFMove(promise);</span>
126     doCreateAnswer(WTFMove(options));
127 }
128 
129 void PeerConnectionBackend::createAnswerSucceeded(String&amp;&amp; sdp)
130 {
131     ASSERT(isMainThread());
132     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer succeeded:\n&quot;, sdp);
133 
<span class="line-removed">134     if (m_peerConnection.isClosed())</span>
<span class="line-removed">135         return;</span>
<span class="line-removed">136 </span>
137     ASSERT(m_offerAnswerPromise);
<span class="line-modified">138     m_offerAnswerPromise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Answer, WTFMove(sdp) });</span>
<span class="line-modified">139     m_offerAnswerPromise = WTF::nullopt;</span>




140 }
141 
142 void PeerConnectionBackend::createAnswerFailed(Exception&amp;&amp; exception)
143 {
144     ASSERT(isMainThread());
145     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer failed:&quot;, exception.message());
146 
<span class="line-removed">147     if (m_peerConnection.isClosed())</span>
<span class="line-removed">148         return;</span>
<span class="line-removed">149 </span>
150     ASSERT(m_offerAnswerPromise);
<span class="line-modified">151     m_offerAnswerPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">152     m_offerAnswerPromise = WTF::nullopt;</span>




153 }
154 
155 static inline bool isLocalDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
156 {
157     switch (state) {
158     case RTCSignalingState::Stable:
159         return type == RTCSdpType::Offer;
160     case RTCSignalingState::HaveLocalOffer:
161         return type == RTCSdpType::Offer;
162     case RTCSignalingState::HaveRemoteOffer:
163         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
164     case RTCSignalingState::HaveLocalPranswer:
165         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
166     default:
167         return false;
168     };
169 
170     ASSERT_NOT_REACHED();
171     return false;
172 }
173 
174 void PeerConnectionBackend::setLocalDescription(RTCSessionDescription&amp; sessionDescription, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
175 {
176     ASSERT(!m_peerConnection.isClosed());
177 
178     if (!isLocalDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
179         promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
180         return;
181     }
182 
<span class="line-modified">183     m_setDescriptionPromise = WTFMove(promise);</span>
184     doSetLocalDescription(sessionDescription);
185 }
186 
187 void PeerConnectionBackend::setLocalDescriptionSucceeded()
188 {
189     ASSERT(isMainThread());
190     ALWAYS_LOG(LOGIDENTIFIER);
191 
<span class="line-removed">192     if (m_peerConnection.isClosed())</span>
<span class="line-removed">193         return;</span>
<span class="line-removed">194 </span>
195     ASSERT(m_setDescriptionPromise);



196 
<span class="line-modified">197     m_setDescriptionPromise-&gt;resolve();</span>
<span class="line-modified">198     m_setDescriptionPromise = WTF::nullopt;</span>
199 }
200 
201 void PeerConnectionBackend::setLocalDescriptionFailed(Exception&amp;&amp; exception)
202 {
203     ASSERT(isMainThread());
204     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set local description failed:&quot;, exception.message());
205 
<span class="line-removed">206     if (m_peerConnection.isClosed())</span>
<span class="line-removed">207         return;</span>
<span class="line-removed">208 </span>
209     ASSERT(m_setDescriptionPromise);



210 
<span class="line-modified">211     m_setDescriptionPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">212     m_setDescriptionPromise = WTF::nullopt;</span>
213 }
214 
215 static inline bool isRemoteDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
216 {
217     switch (state) {
218     case RTCSignalingState::Stable:
219         return type == RTCSdpType::Offer;
220     case RTCSignalingState::HaveLocalOffer:
221         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
222     case RTCSignalingState::HaveRemoteOffer:
223         return type == RTCSdpType::Offer;
224     case RTCSignalingState::HaveRemotePranswer:
225         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
226     default:
227         return false;
228     };
229 
230     ASSERT_NOT_REACHED();
231     return false;
232 }
233 
234 void PeerConnectionBackend::setRemoteDescription(RTCSessionDescription&amp; sessionDescription, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
235 {
236     ASSERT(!m_peerConnection.isClosed());
237 
238     if (!isRemoteDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
239         promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
240         return;
241     }
242 
<span class="line-modified">243     m_setDescriptionPromise = WTFMove(promise);</span>
244     doSetRemoteDescription(sessionDescription);
245 }
246 
247 void PeerConnectionBackend::setRemoteDescriptionSucceeded()
248 {
249     ASSERT(isMainThread());
250     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description succeeded&quot;);

251 
<span class="line-modified">252     ASSERT(!m_peerConnection.isClosed());</span>
<span class="line-removed">253 </span>
254     auto events = WTFMove(m_pendingTrackEvents);
255     for (auto&amp; event : events) {
256         auto&amp; track = event.track.get();
257 
<span class="line-modified">258         m_peerConnection.fireEvent(RTCTrackEvent::create(eventNames().trackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(event.receiver), WTFMove(event.track), WTFMove(event.streams), WTFMove(event.transceiver)));</span>
259 
260         if (m_peerConnection.isClosed())
261             return;
262 
263         // FIXME: As per spec, we should set muted to &#39;false&#39; when starting to receive the content from network.
264         track.source().setMuted(false);
265     }
266 
<span class="line-modified">267     if (m_peerConnection.isClosed())</span>
<span class="line-modified">268         return;</span>
<span class="line-modified">269 </span>
<span class="line-removed">270     ASSERT(m_setDescriptionPromise);</span>
271 
<span class="line-modified">272     m_setDescriptionPromise-&gt;resolve();</span>
<span class="line-modified">273     m_setDescriptionPromise = WTF::nullopt;</span>
274 }
275 
276 void PeerConnectionBackend::setRemoteDescriptionFailed(Exception&amp;&amp; exception)
277 {
278     ASSERT(isMainThread());
279     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description failed:&quot;, exception.message());
280 
281     ASSERT(m_pendingTrackEvents.isEmpty());
282     m_pendingTrackEvents.clear();
283 
<span class="line-removed">284     ASSERT(!m_peerConnection.isClosed());</span>
285     ASSERT(m_setDescriptionPromise);



286 
<span class="line-modified">287     m_setDescriptionPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">288     m_setDescriptionPromise = WTF::nullopt;</span>
289 }
290 
291 void PeerConnectionBackend::addPendingTrackEvent(PendingTrackEvent&amp;&amp; event)
292 {
293     ASSERT(!m_peerConnection.isClosed());
294     m_pendingTrackEvents.append(WTFMove(event));
295 }
296 
297 static String extractIPAddres(const String&amp; sdp)
298 {
299     ASSERT(sdp.contains(&quot; host &quot;));
300     unsigned counter = 0;
301     for (auto item : StringView { sdp }.split(&#39; &#39;)) {
302         if (++counter == 5)
303             return item.toString();
304     }
305     return { };
306 }
307 
308 void PeerConnectionBackend::addIceCandidate(RTCIceCandidate* iceCandidate, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
309 {
310     ASSERT(!m_peerConnection.isClosed());
311 
312     if (!iceCandidate) {
313         endOfIceCandidates(WTFMove(promise));
314         return;
315     }
316 
317     // FIXME: As per https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addicecandidate(), this check should be done before enqueuing the task.
318     if (iceCandidate-&gt;sdpMid().isNull() &amp;&amp; !iceCandidate-&gt;sdpMLineIndex()) {
319         promise.reject(Exception { TypeError, &quot;Trying to add a candidate that is missing both sdpMid and sdpMLineIndex&quot;_s });
320         return;
321     }
<span class="line-modified">322     m_addIceCandidatePromise = WTFMove(promise);</span>
323     doAddIceCandidate(*iceCandidate);
324 }
325 
326 void PeerConnectionBackend::addIceCandidateSucceeded()
327 {
328     ASSERT(isMainThread());
329     ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate succeeded&quot;);
330 
<span class="line-removed">331     if (m_peerConnection.isClosed())</span>
<span class="line-removed">332         return;</span>
<span class="line-removed">333 </span>
334     ASSERT(m_addIceCandidatePromise);



335 
<span class="line-modified">336     m_addIceCandidatePromise-&gt;resolve();</span>
<span class="line-modified">337     m_addIceCandidatePromise = WTF::nullopt;</span>
338 }
339 
340 void PeerConnectionBackend::addIceCandidateFailed(Exception&amp;&amp; exception)
341 {
342     ASSERT(isMainThread());
343     ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate failed:&quot;, exception.message());
344 
<span class="line-removed">345     if (m_peerConnection.isClosed())</span>
<span class="line-removed">346         return;</span>
<span class="line-removed">347 </span>
348     ASSERT(m_addIceCandidatePromise);



349 
<span class="line-modified">350     m_addIceCandidatePromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">351     m_addIceCandidatePromise = WTF::nullopt;</span>
352 }
353 
354 void PeerConnectionBackend::fireICECandidateEvent(RefPtr&lt;RTCIceCandidate&gt;&amp;&amp; candidate, String&amp;&amp; serverURL)
355 {
356     ASSERT(isMainThread());
357 
<span class="line-modified">358     m_peerConnection.fireEvent(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, WTFMove(candidate), WTFMove(serverURL)));</span>
359 }
360 
361 void PeerConnectionBackend::enableICECandidateFiltering()
362 {
363     m_shouldFilterICECandidates = true;
364 }
365 
366 void PeerConnectionBackend::disableICECandidateFiltering()
367 {
368     m_shouldFilterICECandidates = false;
369     for (auto&amp; pendingICECandidate : m_pendingICECandidates)
370         fireICECandidateEvent(RTCIceCandidate::create(WTFMove(pendingICECandidate.sdp), WTFMove(pendingICECandidate.mid), pendingICECandidate.sdpMLineIndex), WTFMove(pendingICECandidate.serverURL));
371     m_pendingICECandidates.clear();
372 }
373 
374 static String filterICECandidate(String&amp;&amp; sdp)
375 {
376     ASSERT(!sdp.contains(&quot; host &quot;));
377 
378     if (!sdp.contains(&quot; raddr &quot;))
</pre>
<hr />
<pre>
396             skipNextItem = true;
397             return;
398         }
399         if (isFirst)
400             isFirst = false;
401         else
402             filteredSDP.append(&#39; &#39;);
403         filteredSDP.append(item);
404     });
405     return filteredSDP.toString();
406 }
407 
408 String PeerConnectionBackend::filterSDP(String&amp;&amp; sdp) const
409 {
410     if (!m_shouldFilterICECandidates)
411         return WTFMove(sdp);
412 
413     StringBuilder filteredSDP;
414     sdp.split(&#39;\n&#39;, [&amp;filteredSDP](StringView line) {
415         if (line.startsWith(&quot;c=IN IP4&quot;))
<span class="line-modified">416             filteredSDP.append(&quot;c=IN IP4 0.0.0.0&quot;);</span>
417         else if (line.startsWith(&quot;c=IN IP6&quot;))
<span class="line-modified">418             filteredSDP.append(&quot;c=IN IP6 ::&quot;);</span>
419         else if (!line.startsWith(&quot;a=candidate&quot;))
420             filteredSDP.append(line);
421         else if (line.find(&quot; host &quot;, 11) == notFound)
422             filteredSDP.append(filterICECandidate(line.toString()));
423         else
424             return;
425         filteredSDP.append(&#39;\n&#39;);
426     });
427     return filteredSDP.toString();
428 }
429 
430 void PeerConnectionBackend::newICECandidate(String&amp;&amp; sdp, String&amp;&amp; mid, unsigned short sdpMLineIndex, String&amp;&amp; serverURL)
431 {
432     ALWAYS_LOG(LOGIDENTIFIER, &quot;Gathered ice candidate:&quot;, sdp);
433     m_finishedGatheringCandidates = false;
434 
435     if (!m_shouldFilterICECandidates) {
436         fireICECandidateEvent(RTCIceCandidate::create(WTFMove(sdp), WTFMove(mid), sdpMLineIndex), WTFMove(serverURL));
437         return;
438     }
</pre>
<hr />
<pre>
442         if (RuntimeEnabledFeatures::sharedFeatures().webRTCMDNSICECandidatesEnabled()) {
443             auto ipAddress = extractIPAddres(sdp);
444             // We restrict to IPv4 candidates for now.
445             if (ipAddress.contains(&#39;.&#39;))
446                 registerMDNSName(ipAddress);
447         }
448         return;
449     }
450     fireICECandidateEvent(RTCIceCandidate::create(filterICECandidate(WTFMove(sdp)), WTFMove(mid), sdpMLineIndex), WTFMove(serverURL));
451 }
452 
453 void PeerConnectionBackend::doneGatheringCandidates()
454 {
455     ASSERT(isMainThread());
456     ALWAYS_LOG(LOGIDENTIFIER, &quot;Finished ice candidate gathering&quot;);
457     m_finishedGatheringCandidates = true;
458 
459     if (m_waitingForMDNSRegistration)
460         return;
461 
<span class="line-modified">462     m_peerConnection.fireEvent(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, nullptr, { }));</span>
463     m_peerConnection.updateIceGatheringState(RTCIceGatheringState::Complete);
464     m_pendingICECandidates.clear();
465 }
466 





467 void PeerConnectionBackend::registerMDNSName(const String&amp; ipAddress)
468 {
469     ++m_waitingForMDNSRegistration;
470     auto&amp; document = downcast&lt;Document&gt;(*m_peerConnection.scriptExecutionContext());
471     auto&amp; provider = document.page()-&gt;libWebRTCProvider();
<span class="line-modified">472     provider.registerMDNSName(document.sessionID(), document.identifier().toUInt64(), ipAddress, [peerConnection = makeRef(m_peerConnection), this, ipAddress] (LibWebRTCProvider::MDNSNameOrError&amp;&amp; result) {</span>
473         if (peerConnection-&gt;isStopped())
474             return;
475 
476         --m_waitingForMDNSRegistration;
477         if (!result.has_value()) {
<span class="line-modified">478             m_peerConnection.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, makeString(&quot;MDNS registration of a host candidate failed with error&quot;, (unsigned)result.error()));</span>
479             return;
480         }
481 
482         this-&gt;finishedRegisteringMDNSName(ipAddress, result.value());
483     });
484 }
485 
486 void PeerConnectionBackend::finishedRegisteringMDNSName(const String&amp; ipAddress, const String&amp; name)
487 {
488     Vector&lt;PendingICECandidate*&gt; candidates;
489     for (auto&amp; candidate : m_pendingICECandidates) {
490         if (candidate.sdp.find(ipAddress) != notFound) {
491             auto sdp = candidate.sdp;
492             sdp.replace(ipAddress, name);
493             fireICECandidateEvent(RTCIceCandidate::create(WTFMove(sdp), WTFMove(candidate.mid), candidate.sdpMLineIndex), WTFMove(candidate.serverURL));
494             candidates.append(&amp;candidate);
495         }
496     }
497     m_pendingICECandidates.removeAllMatching([&amp;] (const auto&amp; candidate) {
498         return candidates.contains(&amp;candidate);
499     });
500 
501     if (!m_waitingForMDNSRegistration &amp;&amp; m_finishedGatheringCandidates)
502         doneGatheringCandidates();
503 }
504 
505 void PeerConnectionBackend::updateSignalingState(RTCSignalingState newSignalingState)
506 {
507     ASSERT(isMainThread());
508 
509     if (newSignalingState != m_peerConnection.signalingState()) {
510         m_peerConnection.setSignalingState(newSignalingState);
<span class="line-modified">511         m_peerConnection.fireEvent(Event::create(eventNames().signalingstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
512     }
513 }
514 
515 void PeerConnectionBackend::stop()
516 {
<span class="line-modified">517     m_offerAnswerPromise = WTF::nullopt;</span>
<span class="line-modified">518     m_setDescriptionPromise = WTF::nullopt;</span>
<span class="line-modified">519     m_addIceCandidatePromise = WTF::nullopt;</span>
520 
521     m_pendingTrackEvents.clear();
522 
523     doStop();
524 }
525 
526 void PeerConnectionBackend::markAsNeedingNegotiation()
527 {
528     if (m_negotiationNeeded)
529         return;
530 
531     m_negotiationNeeded = true;
532 
533     if (m_peerConnection.signalingState() == RTCSignalingState::Stable)
534         m_peerConnection.scheduleNegotiationNeededEvent();
535 }
536 
537 ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; PeerConnectionBackend::addTrack(MediaStreamTrack&amp;, Vector&lt;String&gt;&amp;&amp;)
538 {
539     return Exception { NotSupportedError, &quot;Not implemented&quot;_s };
</pre>
</td>
<td>
<hr />
<pre>
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;PeerConnectionBackend.h&quot;
 34 
 35 #if ENABLE(WEB_RTC)
 36 
 37 #include &quot;EventNames.h&quot;
<span class="line-added"> 38 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 39 #include &quot;JSRTCSessionDescription.h&quot;
 40 #include &quot;LibWebRTCCertificateGenerator.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;RTCIceCandidate.h&quot;
 44 #include &quot;RTCPeerConnection.h&quot;
 45 #include &quot;RTCPeerConnectionIceEvent.h&quot;
 46 #include &quot;RTCRtpCapabilities.h&quot;
 47 #include &quot;RTCTrackEvent.h&quot;
 48 #include &quot;RuntimeEnabledFeatures.h&quot;
 49 #include &lt;wtf/text/StringBuilder.h&gt;
 50 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 51 
 52 namespace WebCore {
 53 
 54 using namespace PAL;
 55 
 56 #if !USE(LIBWEBRTC)
 57 static std::unique_ptr&lt;PeerConnectionBackend&gt; createNoPeerConnectionBackend(RTCPeerConnection&amp;)
 58 {
</pre>
<hr />
<pre>
 66     ASSERT_NOT_REACHED();
 67     return { };
 68 }
 69 
 70 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::senderCapabilities(ScriptExecutionContext&amp;, const String&amp;)
 71 {
 72     ASSERT_NOT_REACHED();
 73     return { };
 74 }
 75 #endif
 76 
 77 PeerConnectionBackend::PeerConnectionBackend(RTCPeerConnection&amp; peerConnection)
 78     : m_peerConnection(peerConnection)
 79 #if !RELEASE_LOG_DISABLED
 80     , m_logger(peerConnection.logger())
 81     , m_logIdentifier(peerConnection.logIdentifier())
 82 #endif
 83 {
 84 }
 85 
<span class="line-added"> 86 PeerConnectionBackend::~PeerConnectionBackend() = default;</span>
<span class="line-added"> 87 </span>
 88 void PeerConnectionBackend::createOffer(RTCOfferOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
 89 {
 90     ASSERT(!m_offerAnswerPromise);
 91     ASSERT(!m_peerConnection.isClosed());
 92 
<span class="line-modified"> 93     m_offerAnswerPromise = WTF::makeUnique&lt;PeerConnection::SessionDescriptionPromise&gt;(WTFMove(promise));</span>
 94     doCreateOffer(WTFMove(options));
 95 }
 96 
 97 void PeerConnectionBackend::createOfferSucceeded(String&amp;&amp; sdp)
 98 {
 99     ASSERT(isMainThread());
100     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer succeeded:\n&quot;, sdp);
101 



102     ASSERT(m_offerAnswerPromise);
<span class="line-modified">103     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = filterSDP(WTFMove(sdp))]() mutable {</span>
<span class="line-modified">104         if (m_peerConnection.isClosed())</span>
<span class="line-added">105             return;</span>
<span class="line-added">106 </span>
<span class="line-added">107         promise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Offer, sdp });</span>
<span class="line-added">108     });</span>
109 }
110 
111 void PeerConnectionBackend::createOfferFailed(Exception&amp;&amp; exception)
112 {
113     ASSERT(isMainThread());
114     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer failed:&quot;, exception.message());
115 



116     ASSERT(m_offerAnswerPromise);
<span class="line-modified">117     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-modified">118         if (m_peerConnection.isClosed())</span>
<span class="line-added">119             return;</span>
<span class="line-added">120 </span>
<span class="line-added">121         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-added">122     });</span>
123 }
124 
125 void PeerConnectionBackend::createAnswer(RTCAnswerOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
126 {
127     ASSERT(!m_offerAnswerPromise);
128     ASSERT(!m_peerConnection.isClosed());
129 
<span class="line-modified">130     m_offerAnswerPromise = WTF::makeUnique&lt;PeerConnection::SessionDescriptionPromise&gt;(WTFMove(promise));</span>
131     doCreateAnswer(WTFMove(options));
132 }
133 
134 void PeerConnectionBackend::createAnswerSucceeded(String&amp;&amp; sdp)
135 {
136     ASSERT(isMainThread());
137     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer succeeded:\n&quot;, sdp);
138 



139     ASSERT(m_offerAnswerPromise);
<span class="line-modified">140     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = WTFMove(sdp)]() mutable {</span>
<span class="line-modified">141         if (m_peerConnection.isClosed())</span>
<span class="line-added">142             return;</span>
<span class="line-added">143 </span>
<span class="line-added">144         promise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Answer, sdp });</span>
<span class="line-added">145     });</span>
146 }
147 
148 void PeerConnectionBackend::createAnswerFailed(Exception&amp;&amp; exception)
149 {
150     ASSERT(isMainThread());
151     ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer failed:&quot;, exception.message());
152 



153     ASSERT(m_offerAnswerPromise);
<span class="line-modified">154     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-modified">155         if (m_peerConnection.isClosed())</span>
<span class="line-added">156             return;</span>
<span class="line-added">157 </span>
<span class="line-added">158         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-added">159     });</span>
160 }
161 
162 static inline bool isLocalDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
163 {
164     switch (state) {
165     case RTCSignalingState::Stable:
166         return type == RTCSdpType::Offer;
167     case RTCSignalingState::HaveLocalOffer:
168         return type == RTCSdpType::Offer;
169     case RTCSignalingState::HaveRemoteOffer:
170         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
171     case RTCSignalingState::HaveLocalPranswer:
172         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
173     default:
174         return false;
175     };
176 
177     ASSERT_NOT_REACHED();
178     return false;
179 }
180 
181 void PeerConnectionBackend::setLocalDescription(RTCSessionDescription&amp; sessionDescription, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
182 {
183     ASSERT(!m_peerConnection.isClosed());
184 
185     if (!isLocalDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
186         promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
187         return;
188     }
189 
<span class="line-modified">190     m_setDescriptionPromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));</span>
191     doSetLocalDescription(sessionDescription);
192 }
193 
194 void PeerConnectionBackend::setLocalDescriptionSucceeded()
195 {
196     ASSERT(isMainThread());
197     ALWAYS_LOG(LOGIDENTIFIER);
198 



199     ASSERT(m_setDescriptionPromise);
<span class="line-added">200     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise)]() mutable {</span>
<span class="line-added">201         if (m_peerConnection.isClosed())</span>
<span class="line-added">202             return;</span>
203 
<span class="line-modified">204         promise-&gt;resolve();</span>
<span class="line-modified">205     });</span>
206 }
207 
208 void PeerConnectionBackend::setLocalDescriptionFailed(Exception&amp;&amp; exception)
209 {
210     ASSERT(isMainThread());
211     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set local description failed:&quot;, exception.message());
212 



213     ASSERT(m_setDescriptionPromise);
<span class="line-added">214     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">215         if (m_peerConnection.isClosed())</span>
<span class="line-added">216             return;</span>
217 
<span class="line-modified">218         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">219     });</span>
220 }
221 
222 static inline bool isRemoteDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
223 {
224     switch (state) {
225     case RTCSignalingState::Stable:
226         return type == RTCSdpType::Offer;
227     case RTCSignalingState::HaveLocalOffer:
228         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
229     case RTCSignalingState::HaveRemoteOffer:
230         return type == RTCSdpType::Offer;
231     case RTCSignalingState::HaveRemotePranswer:
232         return type == RTCSdpType::Answer || type == RTCSdpType::Pranswer;
233     default:
234         return false;
235     };
236 
237     ASSERT_NOT_REACHED();
238     return false;
239 }
240 
241 void PeerConnectionBackend::setRemoteDescription(RTCSessionDescription&amp; sessionDescription, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
242 {
243     ASSERT(!m_peerConnection.isClosed());
244 
245     if (!isRemoteDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
246         promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
247         return;
248     }
249 
<span class="line-modified">250     m_setDescriptionPromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));</span>
251     doSetRemoteDescription(sessionDescription);
252 }
253 
254 void PeerConnectionBackend::setRemoteDescriptionSucceeded()
255 {
256     ASSERT(isMainThread());
257     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description succeeded&quot;);
<span class="line-added">258     ASSERT(m_setDescriptionPromise);</span>
259 
<span class="line-modified">260     auto promise = WTFMove(m_setDescriptionPromise);</span>

261     auto events = WTFMove(m_pendingTrackEvents);
262     for (auto&amp; event : events) {
263         auto&amp; track = event.track.get();
264 
<span class="line-modified">265         m_peerConnection.dispatchEventWhenFeasible(RTCTrackEvent::create(eventNames().trackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(event.receiver), WTFMove(event.track), WTFMove(event.streams), WTFMove(event.transceiver)));</span>
266 
267         if (m_peerConnection.isClosed())
268             return;
269 
270         // FIXME: As per spec, we should set muted to &#39;false&#39; when starting to receive the content from network.
271         track.source().setMuted(false);
272     }
273 
<span class="line-modified">274     m_peerConnection.doTask([this, promise = WTFMove(promise)]() mutable {</span>
<span class="line-modified">275         if (m_peerConnection.isClosed())</span>
<span class="line-modified">276             return;</span>

277 
<span class="line-modified">278         promise-&gt;resolve();</span>
<span class="line-modified">279     });</span>
280 }
281 
282 void PeerConnectionBackend::setRemoteDescriptionFailed(Exception&amp;&amp; exception)
283 {
284     ASSERT(isMainThread());
285     ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description failed:&quot;, exception.message());
286 
287     ASSERT(m_pendingTrackEvents.isEmpty());
288     m_pendingTrackEvents.clear();
289 

290     ASSERT(m_setDescriptionPromise);
<span class="line-added">291     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">292         if (m_peerConnection.isClosed())</span>
<span class="line-added">293             return;</span>
294 
<span class="line-modified">295         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">296     });</span>
297 }
298 
299 void PeerConnectionBackend::addPendingTrackEvent(PendingTrackEvent&amp;&amp; event)
300 {
301     ASSERT(!m_peerConnection.isClosed());
302     m_pendingTrackEvents.append(WTFMove(event));
303 }
304 
305 static String extractIPAddres(const String&amp; sdp)
306 {
307     ASSERT(sdp.contains(&quot; host &quot;));
308     unsigned counter = 0;
309     for (auto item : StringView { sdp }.split(&#39; &#39;)) {
310         if (++counter == 5)
311             return item.toString();
312     }
313     return { };
314 }
315 
316 void PeerConnectionBackend::addIceCandidate(RTCIceCandidate* iceCandidate, DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
317 {
318     ASSERT(!m_peerConnection.isClosed());
319 
320     if (!iceCandidate) {
321         endOfIceCandidates(WTFMove(promise));
322         return;
323     }
324 
325     // FIXME: As per https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addicecandidate(), this check should be done before enqueuing the task.
326     if (iceCandidate-&gt;sdpMid().isNull() &amp;&amp; !iceCandidate-&gt;sdpMLineIndex()) {
327         promise.reject(Exception { TypeError, &quot;Trying to add a candidate that is missing both sdpMid and sdpMLineIndex&quot;_s });
328         return;
329     }
<span class="line-modified">330     m_addIceCandidatePromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));</span>
331     doAddIceCandidate(*iceCandidate);
332 }
333 
334 void PeerConnectionBackend::addIceCandidateSucceeded()
335 {
336     ASSERT(isMainThread());
337     ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate succeeded&quot;);
338 



339     ASSERT(m_addIceCandidatePromise);
<span class="line-added">340     m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise)]() mutable {</span>
<span class="line-added">341         if (m_peerConnection.isClosed())</span>
<span class="line-added">342             return;</span>
343 
<span class="line-modified">344         promise-&gt;resolve();</span>
<span class="line-modified">345     });</span>
346 }
347 
348 void PeerConnectionBackend::addIceCandidateFailed(Exception&amp;&amp; exception)
349 {
350     ASSERT(isMainThread());
351     ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate failed:&quot;, exception.message());
352 



353     ASSERT(m_addIceCandidatePromise);
<span class="line-added">354     m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">355         if (m_peerConnection.isClosed())</span>
<span class="line-added">356             return;</span>
357 
<span class="line-modified">358         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">359     });</span>
360 }
361 
362 void PeerConnectionBackend::fireICECandidateEvent(RefPtr&lt;RTCIceCandidate&gt;&amp;&amp; candidate, String&amp;&amp; serverURL)
363 {
364     ASSERT(isMainThread());
365 
<span class="line-modified">366     m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, WTFMove(candidate), WTFMove(serverURL)));</span>
367 }
368 
369 void PeerConnectionBackend::enableICECandidateFiltering()
370 {
371     m_shouldFilterICECandidates = true;
372 }
373 
374 void PeerConnectionBackend::disableICECandidateFiltering()
375 {
376     m_shouldFilterICECandidates = false;
377     for (auto&amp; pendingICECandidate : m_pendingICECandidates)
378         fireICECandidateEvent(RTCIceCandidate::create(WTFMove(pendingICECandidate.sdp), WTFMove(pendingICECandidate.mid), pendingICECandidate.sdpMLineIndex), WTFMove(pendingICECandidate.serverURL));
379     m_pendingICECandidates.clear();
380 }
381 
382 static String filterICECandidate(String&amp;&amp; sdp)
383 {
384     ASSERT(!sdp.contains(&quot; host &quot;));
385 
386     if (!sdp.contains(&quot; raddr &quot;))
</pre>
<hr />
<pre>
404             skipNextItem = true;
405             return;
406         }
407         if (isFirst)
408             isFirst = false;
409         else
410             filteredSDP.append(&#39; &#39;);
411         filteredSDP.append(item);
412     });
413     return filteredSDP.toString();
414 }
415 
416 String PeerConnectionBackend::filterSDP(String&amp;&amp; sdp) const
417 {
418     if (!m_shouldFilterICECandidates)
419         return WTFMove(sdp);
420 
421     StringBuilder filteredSDP;
422     sdp.split(&#39;\n&#39;, [&amp;filteredSDP](StringView line) {
423         if (line.startsWith(&quot;c=IN IP4&quot;))
<span class="line-modified">424             filteredSDP.append(&quot;c=IN IP4 0.0.0.0\r&quot;);</span>
425         else if (line.startsWith(&quot;c=IN IP6&quot;))
<span class="line-modified">426             filteredSDP.append(&quot;c=IN IP6 ::\r&quot;);</span>
427         else if (!line.startsWith(&quot;a=candidate&quot;))
428             filteredSDP.append(line);
429         else if (line.find(&quot; host &quot;, 11) == notFound)
430             filteredSDP.append(filterICECandidate(line.toString()));
431         else
432             return;
433         filteredSDP.append(&#39;\n&#39;);
434     });
435     return filteredSDP.toString();
436 }
437 
438 void PeerConnectionBackend::newICECandidate(String&amp;&amp; sdp, String&amp;&amp; mid, unsigned short sdpMLineIndex, String&amp;&amp; serverURL)
439 {
440     ALWAYS_LOG(LOGIDENTIFIER, &quot;Gathered ice candidate:&quot;, sdp);
441     m_finishedGatheringCandidates = false;
442 
443     if (!m_shouldFilterICECandidates) {
444         fireICECandidateEvent(RTCIceCandidate::create(WTFMove(sdp), WTFMove(mid), sdpMLineIndex), WTFMove(serverURL));
445         return;
446     }
</pre>
<hr />
<pre>
450         if (RuntimeEnabledFeatures::sharedFeatures().webRTCMDNSICECandidatesEnabled()) {
451             auto ipAddress = extractIPAddres(sdp);
452             // We restrict to IPv4 candidates for now.
453             if (ipAddress.contains(&#39;.&#39;))
454                 registerMDNSName(ipAddress);
455         }
456         return;
457     }
458     fireICECandidateEvent(RTCIceCandidate::create(filterICECandidate(WTFMove(sdp)), WTFMove(mid), sdpMLineIndex), WTFMove(serverURL));
459 }
460 
461 void PeerConnectionBackend::doneGatheringCandidates()
462 {
463     ASSERT(isMainThread());
464     ALWAYS_LOG(LOGIDENTIFIER, &quot;Finished ice candidate gathering&quot;);
465     m_finishedGatheringCandidates = true;
466 
467     if (m_waitingForMDNSRegistration)
468         return;
469 
<span class="line-modified">470     m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, nullptr, { }));</span>
471     m_peerConnection.updateIceGatheringState(RTCIceGatheringState::Complete);
472     m_pendingICECandidates.clear();
473 }
474 
<span class="line-added">475 void PeerConnectionBackend::endOfIceCandidates(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)</span>
<span class="line-added">476 {</span>
<span class="line-added">477     promise.resolve();</span>
<span class="line-added">478 }</span>
<span class="line-added">479 </span>
480 void PeerConnectionBackend::registerMDNSName(const String&amp; ipAddress)
481 {
482     ++m_waitingForMDNSRegistration;
483     auto&amp; document = downcast&lt;Document&gt;(*m_peerConnection.scriptExecutionContext());
484     auto&amp; provider = document.page()-&gt;libWebRTCProvider();
<span class="line-modified">485     provider.registerMDNSName(document.identifier().toUInt64(), ipAddress, [peerConnection = makeRef(m_peerConnection), this, ipAddress] (LibWebRTCProvider::MDNSNameOrError&amp;&amp; result) {</span>
486         if (peerConnection-&gt;isStopped())
487             return;
488 
489         --m_waitingForMDNSRegistration;
490         if (!result.has_value()) {
<span class="line-modified">491             m_peerConnection.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, makeString(&quot;MDNS registration of a host candidate failed with error &quot;, (unsigned)result.error()));</span>
492             return;
493         }
494 
495         this-&gt;finishedRegisteringMDNSName(ipAddress, result.value());
496     });
497 }
498 
499 void PeerConnectionBackend::finishedRegisteringMDNSName(const String&amp; ipAddress, const String&amp; name)
500 {
501     Vector&lt;PendingICECandidate*&gt; candidates;
502     for (auto&amp; candidate : m_pendingICECandidates) {
503         if (candidate.sdp.find(ipAddress) != notFound) {
504             auto sdp = candidate.sdp;
505             sdp.replace(ipAddress, name);
506             fireICECandidateEvent(RTCIceCandidate::create(WTFMove(sdp), WTFMove(candidate.mid), candidate.sdpMLineIndex), WTFMove(candidate.serverURL));
507             candidates.append(&amp;candidate);
508         }
509     }
510     m_pendingICECandidates.removeAllMatching([&amp;] (const auto&amp; candidate) {
511         return candidates.contains(&amp;candidate);
512     });
513 
514     if (!m_waitingForMDNSRegistration &amp;&amp; m_finishedGatheringCandidates)
515         doneGatheringCandidates();
516 }
517 
518 void PeerConnectionBackend::updateSignalingState(RTCSignalingState newSignalingState)
519 {
520     ASSERT(isMainThread());
521 
522     if (newSignalingState != m_peerConnection.signalingState()) {
523         m_peerConnection.setSignalingState(newSignalingState);
<span class="line-modified">524         m_peerConnection.dispatchEventWhenFeasible(Event::create(eventNames().signalingstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
525     }
526 }
527 
528 void PeerConnectionBackend::stop()
529 {
<span class="line-modified">530     m_offerAnswerPromise = nullptr;</span>
<span class="line-modified">531     m_setDescriptionPromise = nullptr;</span>
<span class="line-modified">532     m_addIceCandidatePromise = nullptr;</span>
533 
534     m_pendingTrackEvents.clear();
535 
536     doStop();
537 }
538 
539 void PeerConnectionBackend::markAsNeedingNegotiation()
540 {
541     if (m_negotiationNeeded)
542         return;
543 
544     m_negotiationNeeded = true;
545 
546     if (m_peerConnection.signalingState() == RTCSignalingState::Stable)
547         m_peerConnection.scheduleNegotiationNeededEvent();
548 }
549 
550 ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; PeerConnectionBackend::addTrack(MediaStreamTrack&amp;, Vector&lt;String&gt;&amp;&amp;)
551 {
552     return Exception { NotSupportedError, &quot;Not implemented&quot;_s };
</pre>
</td>
</tr>
</table>
<center><a href="OverconstrainedErrorEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PeerConnectionBackend.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
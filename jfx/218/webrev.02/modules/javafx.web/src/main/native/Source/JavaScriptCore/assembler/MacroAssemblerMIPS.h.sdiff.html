<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerMIPS.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroAssemblerMIPS.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerX86.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerMIPS.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2010 MIPS Technologies, Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
  30 
  31 #include &quot;MIPSAssembler.h&quot;
  32 #include &quot;AbstractMacroAssembler.h&quot;
  33 
  34 namespace JSC {
  35 
  36 using Assembler = TARGET_ASSEMBLER;
  37 
  38 class MacroAssemblerMIPS : public AbstractMacroAssembler&lt;Assembler&gt; {
  39 public:
  40     typedef MIPSRegisters::FPRegisterID FPRegisterID;
<span class="line-modified">  41     static const unsigned numGPRs = 32;</span>
<span class="line-modified">  42     static const unsigned numFPRs = 32;</span>
  43 
  44     MacroAssemblerMIPS()
  45         : m_fixedWidth(false)
  46     {
  47     }
  48 
  49     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  50     {
  51         return value &gt;= -2147483647 - 1 &amp;&amp; value &lt;= 2147483647;
  52     }
  53 
  54     inline bool isPowerOf2(int32_t v)
  55     {
  56         return hasOneBitSet(v);
  57     }
  58 
  59     inline int bitPosition(int32_t v)
  60     {
  61         return getLSBSet(v);
  62     }
  63 
<span class="line-modified">  64     static const Scale ScalePtr = TimesFour;</span>
  65 
  66     // For storing immediate number
<span class="line-modified">  67     static const RegisterID immTempRegister = MIPSRegisters::t0;</span>
  68     // For storing data loaded from the memory
<span class="line-modified">  69     static const RegisterID dataTempRegister = MIPSRegisters::t1;</span>
  70     // For storing address base
<span class="line-modified">  71     static const RegisterID addrTempRegister = MIPSRegisters::t7;</span>
  72     // For storing compare result
<span class="line-modified">  73     static const RegisterID cmpTempRegister = MIPSRegisters::t8;</span>
  74 
  75     // FP temp register
<span class="line-modified">  76     static const FPRegisterID fpTempRegister = MIPSRegisters::f16;</span>
  77 
<span class="line-modified">  78     static const int MaximumCompactPtrAlignedAddressOffset = 0x7FFFFFFF;</span>
  79 
  80     enum RelationalCondition {
  81         Equal,
  82         NotEqual,
  83         Above,
  84         AboveOrEqual,
  85         Below,
  86         BelowOrEqual,
  87         GreaterThan,
  88         GreaterThanOrEqual,
  89         LessThan,
  90         LessThanOrEqual
  91     };
  92 
  93     enum ResultCondition {
  94         Overflow,
  95         Signed,
  96         PositiveOrZero,
  97         Zero,
  98         NonZero
</pre>
<hr />
<pre>
 101     enum DoubleCondition {
 102         DoubleEqual,
 103         DoubleNotEqual,
 104         DoubleGreaterThan,
 105         DoubleGreaterThanOrEqual,
 106         DoubleLessThan,
 107         DoubleLessThanOrEqual,
 108         DoubleEqualOrUnordered,
 109         DoubleNotEqualOrUnordered,
 110         DoubleGreaterThanOrUnordered,
 111         DoubleGreaterThanOrEqualOrUnordered,
 112         DoubleLessThanOrUnordered,
 113         DoubleLessThanOrEqualOrUnordered
 114     };
 115 
 116     enum class LoadAddressMode {
 117         ScaleAndAddOffsetIfOffsetIsOutOfBounds,
 118         Scale
 119     };
 120 
<span class="line-modified"> 121     static const RegisterID stackPointerRegister = MIPSRegisters::sp;</span>
<span class="line-modified"> 122     static const RegisterID framePointerRegister = MIPSRegisters::fp;</span>
<span class="line-modified"> 123     static const RegisterID returnAddressRegister = MIPSRegisters::ra;</span>
 124 
 125     // Integer arithmetic operations:
 126     //
 127     // Operations are typically two operand - operation(source, srcDst)
 128     // For many operations the source may be an TrustedImm32, the srcDst operand
 129     // may often be a memory location (explictly described using an Address
 130     // object).
 131 
 132     void add32(RegisterID src, RegisterID dest)
 133     {
 134         m_assembler.addu(dest, dest, src);
 135     }
 136 
 137     void add32(RegisterID op1, RegisterID op2, RegisterID dest)
 138     {
 139         m_assembler.addu(dest, op1, op2);
 140     }
 141 
 142     void add32(TrustedImm32 imm, RegisterID dest)
 143     {
</pre>
<hr />
<pre>
 458         else {
 459             /*
 460                 li      dataTemp, imm
 461                 mul     dest, src, dataTemp
 462             */
 463             move(imm, dataTempRegister);
 464             m_assembler.mul(dest, src, dataTempRegister);
 465         }
 466     }
 467 
 468     void neg32(RegisterID srcDest)
 469     {
 470         m_assembler.subu(srcDest, MIPSRegisters::zero, srcDest);
 471     }
 472 
 473     void neg32(RegisterID src, RegisterID dest)
 474     {
 475         m_assembler.subu(dest, MIPSRegisters::zero, src);
 476     }
 477 



















 478     void or32(RegisterID src, RegisterID dest)
 479     {
 480         m_assembler.orInsn(dest, dest, src);
 481     }
 482 
 483     void or32(RegisterID op1, RegisterID op2, RegisterID dest)
 484     {
 485         m_assembler.orInsn(dest, op1, op2);
 486     }
 487 
 488     void or32(TrustedImm32 imm, AbsoluteAddress dest)
 489     {
 490         if (!imm.m_value &amp;&amp; !m_fixedWidth)
 491             return;
 492 
 493         if (m_fixedWidth) {
 494             // TODO: Swap dataTempRegister and immTempRegister usage
 495             load32(dest.m_ptr, immTempRegister);
 496             or32(imm, immTempRegister);
 497             store32(immTempRegister, dest.m_ptr);
</pre>
<hr />
<pre>
1155             lui addrTemp, address.offset &gt;&gt; 16
1156             ori addrTemp, addrTemp, address.offset &amp; 0xffff
1157             addu        addrTemp, addrTemp, address.base
1158             lw  dest, 0(addrTemp)
1159         */
1160         DataLabel32 dataLabel(this);
1161         move(TrustedImm32(address.offset), addrTempRegister);
1162         m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1163         m_assembler.lw(dest, addrTempRegister, 0);
1164         m_fixedWidth = false;
1165         return dataLabel;
1166     }
1167 
1168     DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
1169     {
1170         DataLabelCompact dataLabel(this);
1171         load32WithAddressOffsetPatch(address, dest);
1172         return dataLabel;
1173     }
1174 
















1175     /* Need to use zero-extened load half-word for load16.  */
1176     void load16(ImplicitAddress address, RegisterID dest)
1177     {
1178         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1179             &amp;&amp; !m_fixedWidth)
1180             m_assembler.lhu(dest, address.base, address.offset);
1181         else {
1182             /*
1183                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1184                 addu    addrTemp, addrTemp, base
1185                 lhu     dest, (offset &amp; 0xffff)(addrTemp)
1186               */
1187             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1188             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1189             m_assembler.lhu(dest, addrTempRegister, address.offset);
1190         }
1191     }
1192 
1193     /* Need to use zero-extened load half-word for load16.  */
1194     void load16(BaseIndex address, RegisterID dest)
</pre>
<hr />
<pre>
1323                 move(imm8, immTempRegister);
1324                 m_assembler.sb(immTempRegister, address.base, address.offset);
1325             }
1326         } else {
1327             /*
1328                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1329                 addu    addrTemp, addrTemp, base
1330                 sb      immTemp, (offset &amp; 0xffff)(addrTemp)
1331               */
1332             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1333             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1334             if (!imm8.m_value &amp;&amp; !m_fixedWidth)
1335                 m_assembler.sb(MIPSRegisters::zero, addrTempRegister, address.offset);
1336             else {
1337                 move(imm8, immTempRegister);
1338                 m_assembler.sb(immTempRegister, addrTempRegister, address.offset);
1339             }
1340         }
1341     }
1342 
















1343     void store16(RegisterID src, ImplicitAddress address)
1344     {
1345         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1346             &amp;&amp; !m_fixedWidth) {
1347             m_assembler.sh(src, address.base, address.offset);
1348         } else {
1349             /*
1350                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1351                 addu    addrTemp, addrTemp, base
1352                 sh      src, (offset &amp; 0xffff)(addrTemp)
1353               */
1354             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1355             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1356             m_assembler.sh(src, addrTempRegister, address.offset);
1357         }
1358     }
1359 
1360     void store16(RegisterID src, BaseIndex address)
1361     {
1362         if (!m_fixedWidth) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2010 MIPS Technologies, Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
  30 
  31 #include &quot;MIPSAssembler.h&quot;
  32 #include &quot;AbstractMacroAssembler.h&quot;
  33 
  34 namespace JSC {
  35 
  36 using Assembler = TARGET_ASSEMBLER;
  37 
  38 class MacroAssemblerMIPS : public AbstractMacroAssembler&lt;Assembler&gt; {
  39 public:
  40     typedef MIPSRegisters::FPRegisterID FPRegisterID;
<span class="line-modified">  41     static constexpr unsigned numGPRs = 32;</span>
<span class="line-modified">  42     static constexpr unsigned numFPRs = 32;</span>
  43 
  44     MacroAssemblerMIPS()
  45         : m_fixedWidth(false)
  46     {
  47     }
  48 
  49     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  50     {
  51         return value &gt;= -2147483647 - 1 &amp;&amp; value &lt;= 2147483647;
  52     }
  53 
  54     inline bool isPowerOf2(int32_t v)
  55     {
  56         return hasOneBitSet(v);
  57     }
  58 
  59     inline int bitPosition(int32_t v)
  60     {
  61         return getLSBSet(v);
  62     }
  63 
<span class="line-modified">  64     static constexpr Scale ScalePtr = TimesFour;</span>
  65 
  66     // For storing immediate number
<span class="line-modified">  67     static constexpr RegisterID immTempRegister = MIPSRegisters::t0;</span>
  68     // For storing data loaded from the memory
<span class="line-modified">  69     static constexpr RegisterID dataTempRegister = MIPSRegisters::t1;</span>
  70     // For storing address base
<span class="line-modified">  71     static constexpr RegisterID addrTempRegister = MIPSRegisters::t7;</span>
  72     // For storing compare result
<span class="line-modified">  73     static constexpr RegisterID cmpTempRegister = MIPSRegisters::t8;</span>
  74 
  75     // FP temp register
<span class="line-modified">  76     static constexpr FPRegisterID fpTempRegister = MIPSRegisters::f16;</span>
  77 
<span class="line-modified">  78     static constexpr int MaximumCompactPtrAlignedAddressOffset = 0x7FFFFFFF;</span>
  79 
  80     enum RelationalCondition {
  81         Equal,
  82         NotEqual,
  83         Above,
  84         AboveOrEqual,
  85         Below,
  86         BelowOrEqual,
  87         GreaterThan,
  88         GreaterThanOrEqual,
  89         LessThan,
  90         LessThanOrEqual
  91     };
  92 
  93     enum ResultCondition {
  94         Overflow,
  95         Signed,
  96         PositiveOrZero,
  97         Zero,
  98         NonZero
</pre>
<hr />
<pre>
 101     enum DoubleCondition {
 102         DoubleEqual,
 103         DoubleNotEqual,
 104         DoubleGreaterThan,
 105         DoubleGreaterThanOrEqual,
 106         DoubleLessThan,
 107         DoubleLessThanOrEqual,
 108         DoubleEqualOrUnordered,
 109         DoubleNotEqualOrUnordered,
 110         DoubleGreaterThanOrUnordered,
 111         DoubleGreaterThanOrEqualOrUnordered,
 112         DoubleLessThanOrUnordered,
 113         DoubleLessThanOrEqualOrUnordered
 114     };
 115 
 116     enum class LoadAddressMode {
 117         ScaleAndAddOffsetIfOffsetIsOutOfBounds,
 118         Scale
 119     };
 120 
<span class="line-modified"> 121     static constexpr RegisterID stackPointerRegister = MIPSRegisters::sp;</span>
<span class="line-modified"> 122     static constexpr RegisterID framePointerRegister = MIPSRegisters::fp;</span>
<span class="line-modified"> 123     static constexpr RegisterID returnAddressRegister = MIPSRegisters::ra;</span>
 124 
 125     // Integer arithmetic operations:
 126     //
 127     // Operations are typically two operand - operation(source, srcDst)
 128     // For many operations the source may be an TrustedImm32, the srcDst operand
 129     // may often be a memory location (explictly described using an Address
 130     // object).
 131 
 132     void add32(RegisterID src, RegisterID dest)
 133     {
 134         m_assembler.addu(dest, dest, src);
 135     }
 136 
 137     void add32(RegisterID op1, RegisterID op2, RegisterID dest)
 138     {
 139         m_assembler.addu(dest, op1, op2);
 140     }
 141 
 142     void add32(TrustedImm32 imm, RegisterID dest)
 143     {
</pre>
<hr />
<pre>
 458         else {
 459             /*
 460                 li      dataTemp, imm
 461                 mul     dest, src, dataTemp
 462             */
 463             move(imm, dataTempRegister);
 464             m_assembler.mul(dest, src, dataTempRegister);
 465         }
 466     }
 467 
 468     void neg32(RegisterID srcDest)
 469     {
 470         m_assembler.subu(srcDest, MIPSRegisters::zero, srcDest);
 471     }
 472 
 473     void neg32(RegisterID src, RegisterID dest)
 474     {
 475         m_assembler.subu(dest, MIPSRegisters::zero, src);
 476     }
 477 
<span class="line-added"> 478     void or16(TrustedImm32 imm, AbsoluteAddress dest)</span>
<span class="line-added"> 479     {</span>
<span class="line-added"> 480         if (!imm.m_value &amp;&amp; !m_fixedWidth)</span>
<span class="line-added"> 481             return;</span>
<span class="line-added"> 482 </span>
<span class="line-added"> 483         if (m_fixedWidth) {</span>
<span class="line-added"> 484             // TODO: Swap dataTempRegister and immTempRegister usage</span>
<span class="line-added"> 485             load16(dest.m_ptr, immTempRegister);</span>
<span class="line-added"> 486             or32(imm, immTempRegister);</span>
<span class="line-added"> 487             store16(immTempRegister, dest.m_ptr);</span>
<span class="line-added"> 488         } else {</span>
<span class="line-added"> 489             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(dest.m_ptr);</span>
<span class="line-added"> 490             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);</span>
<span class="line-added"> 491             m_assembler.lhu(immTempRegister, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added"> 492             or32(imm, immTempRegister);</span>
<span class="line-added"> 493             m_assembler.sh(immTempRegister, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added"> 494         }</span>
<span class="line-added"> 495     }</span>
<span class="line-added"> 496 </span>
 497     void or32(RegisterID src, RegisterID dest)
 498     {
 499         m_assembler.orInsn(dest, dest, src);
 500     }
 501 
 502     void or32(RegisterID op1, RegisterID op2, RegisterID dest)
 503     {
 504         m_assembler.orInsn(dest, op1, op2);
 505     }
 506 
 507     void or32(TrustedImm32 imm, AbsoluteAddress dest)
 508     {
 509         if (!imm.m_value &amp;&amp; !m_fixedWidth)
 510             return;
 511 
 512         if (m_fixedWidth) {
 513             // TODO: Swap dataTempRegister and immTempRegister usage
 514             load32(dest.m_ptr, immTempRegister);
 515             or32(imm, immTempRegister);
 516             store32(immTempRegister, dest.m_ptr);
</pre>
<hr />
<pre>
1174             lui addrTemp, address.offset &gt;&gt; 16
1175             ori addrTemp, addrTemp, address.offset &amp; 0xffff
1176             addu        addrTemp, addrTemp, address.base
1177             lw  dest, 0(addrTemp)
1178         */
1179         DataLabel32 dataLabel(this);
1180         move(TrustedImm32(address.offset), addrTempRegister);
1181         m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1182         m_assembler.lw(dest, addrTempRegister, 0);
1183         m_fixedWidth = false;
1184         return dataLabel;
1185     }
1186 
1187     DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
1188     {
1189         DataLabelCompact dataLabel(this);
1190         load32WithAddressOffsetPatch(address, dest);
1191         return dataLabel;
1192     }
1193 
<span class="line-added">1194     void load16(const void* address, RegisterID dest)</span>
<span class="line-added">1195     {</span>
<span class="line-added">1196         if (m_fixedWidth) {</span>
<span class="line-added">1197             /*</span>
<span class="line-added">1198                 li  addrTemp, address</span>
<span class="line-added">1199                 lhu  dest, 0(addrTemp)</span>
<span class="line-added">1200             */</span>
<span class="line-added">1201             move(TrustedImmPtr(address), addrTempRegister);</span>
<span class="line-added">1202             m_assembler.lhu(dest, addrTempRegister, 0);</span>
<span class="line-added">1203         } else {</span>
<span class="line-added">1204             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
<span class="line-added">1205             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);</span>
<span class="line-added">1206             m_assembler.lhu(dest, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added">1207         }</span>
<span class="line-added">1208     }</span>
<span class="line-added">1209 </span>
1210     /* Need to use zero-extened load half-word for load16.  */
1211     void load16(ImplicitAddress address, RegisterID dest)
1212     {
1213         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1214             &amp;&amp; !m_fixedWidth)
1215             m_assembler.lhu(dest, address.base, address.offset);
1216         else {
1217             /*
1218                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1219                 addu    addrTemp, addrTemp, base
1220                 lhu     dest, (offset &amp; 0xffff)(addrTemp)
1221               */
1222             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1223             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1224             m_assembler.lhu(dest, addrTempRegister, address.offset);
1225         }
1226     }
1227 
1228     /* Need to use zero-extened load half-word for load16.  */
1229     void load16(BaseIndex address, RegisterID dest)
</pre>
<hr />
<pre>
1358                 move(imm8, immTempRegister);
1359                 m_assembler.sb(immTempRegister, address.base, address.offset);
1360             }
1361         } else {
1362             /*
1363                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1364                 addu    addrTemp, addrTemp, base
1365                 sb      immTemp, (offset &amp; 0xffff)(addrTemp)
1366               */
1367             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1368             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1369             if (!imm8.m_value &amp;&amp; !m_fixedWidth)
1370                 m_assembler.sb(MIPSRegisters::zero, addrTempRegister, address.offset);
1371             else {
1372                 move(imm8, immTempRegister);
1373                 m_assembler.sb(immTempRegister, addrTempRegister, address.offset);
1374             }
1375         }
1376     }
1377 
<span class="line-added">1378     void store16(RegisterID src, const void* address)</span>
<span class="line-added">1379     {</span>
<span class="line-added">1380         if (m_fixedWidth) {</span>
<span class="line-added">1381             /*</span>
<span class="line-added">1382                 li  addrTemp, address</span>
<span class="line-added">1383                 sh  src, 0(addrTemp)</span>
<span class="line-added">1384             */</span>
<span class="line-added">1385             move(TrustedImmPtr(address), addrTempRegister);</span>
<span class="line-added">1386             m_assembler.sh(src, addrTempRegister, 0);</span>
<span class="line-added">1387         } else {</span>
<span class="line-added">1388             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
<span class="line-added">1389             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);</span>
<span class="line-added">1390             m_assembler.sh(src, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added">1391         }</span>
<span class="line-added">1392     }</span>
<span class="line-added">1393 </span>
1394     void store16(RegisterID src, ImplicitAddress address)
1395     {
1396         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1397             &amp;&amp; !m_fixedWidth) {
1398             m_assembler.sh(src, address.base, address.offset);
1399         } else {
1400             /*
1401                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1402                 addu    addrTemp, addrTemp, base
1403                 sh      src, (offset &amp; 0xffff)(addrTemp)
1404               */
1405             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1406             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1407             m_assembler.sh(src, addrTempRegister, address.offset);
1408         }
1409     }
1410 
1411     void store16(RegisterID src, BaseIndex address)
1412     {
1413         if (!m_fixedWidth) {
</pre>
</td>
</tr>
</table>
<center><a href="MacroAssemblerMIPS.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerX86.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
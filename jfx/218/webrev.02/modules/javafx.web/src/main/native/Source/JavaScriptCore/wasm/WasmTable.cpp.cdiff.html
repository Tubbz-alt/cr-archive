<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmStreamingParser.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmTable.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 57,11 ***</span>
      ASSERT(!m_maximum || *m_maximum &gt;= m_length);
  
      // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
      // But for now, we&#39;re not doing that.
      // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified">!     m_jsValues = MallocPtr&lt;WriteBarrier&lt;Unknown&gt;&gt;::malloc((sizeof(WriteBarrier&lt;Unknown&gt;) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
      for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
          new (&amp;m_jsValues.get()[i]) WriteBarrier&lt;Unknown&gt;();
          m_jsValues.get()[i].setStartingValue(jsNull());
      }
  }
<span class="line-new-header">--- 57,11 ---</span>
      ASSERT(!m_maximum || *m_maximum &gt;= m_length);
  
      // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
      // But for now, we&#39;re not doing that.
      // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified">!     m_jsValues = MallocPtr&lt;WriteBarrier&lt;Unknown&gt;, VMMalloc&gt;::malloc((sizeof(WriteBarrier&lt;Unknown&gt;) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
      for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
          new (&amp;m_jsValues.get()[i]) WriteBarrier&lt;Unknown&gt;();
          m_jsValues.get()[i].setStartingValue(jsNull());
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,13 ***</span>
  FuncRefTable::FuncRefTable(uint32_t initial, Optional&lt;uint32_t&gt; maximum)
      : Table(initial, maximum, TableElementType::Funcref)
  {
      // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
      // But for now, we&#39;re not doing that.
<span class="line-modified">!     m_importableFunctions = MallocPtr&lt;WasmToWasmImportableFunction&gt;::malloc((sizeof(WasmToWasmImportableFunction) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
      // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified">!     m_instances = MallocPtr&lt;Instance*&gt;::malloc((sizeof(Instance*) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
      for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
          new (&amp;m_importableFunctions.get()[i]) WasmToWasmImportableFunction();
          ASSERT(m_importableFunctions.get()[i].signatureIndex == Wasm::Signature::invalidIndex); // We rely on this in compiled code.
          m_instances.get()[i] = nullptr;
      }
<span class="line-new-header">--- 175,13 ---</span>
  FuncRefTable::FuncRefTable(uint32_t initial, Optional&lt;uint32_t&gt; maximum)
      : Table(initial, maximum, TableElementType::Funcref)
  {
      // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
      // But for now, we&#39;re not doing that.
<span class="line-modified">!     m_importableFunctions = MallocPtr&lt;WasmToWasmImportableFunction, VMMalloc&gt;::malloc((sizeof(WasmToWasmImportableFunction) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
      // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified">!     m_instances = MallocPtr&lt;Instance*, VMMalloc&gt;::malloc((sizeof(Instance*) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
      for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
          new (&amp;m_importableFunctions.get()[i]) WasmToWasmImportableFunction();
          ASSERT(m_importableFunctions.get()[i].signatureIndex == Wasm::Signature::invalidIndex); // We rely on this in compiled code.
          m_instances.get()[i] = nullptr;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 196,8 ***</span>
<span class="line-new-header">--- 196,18 ---</span>
          m_jsValues.get()[index &amp; m_mask].set(m_owner-&gt;vm(), m_owner, optionalWrapper);
      m_importableFunctions.get()[index &amp; m_mask] = function;
      m_instances.get()[index &amp; m_mask] = instance;
  }
  
<span class="line-added">+ const WasmToWasmImportableFunction&amp; FuncRefTable::function(uint32_t index) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_importableFunctions.get()[index &amp; m_mask];</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Instance* FuncRefTable::instance(uint32_t index) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_instances.get()[index &amp; m_mask];</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } } // namespace JSC::Table
  
  #endif // ENABLE(WEBASSEMBLY)
</pre>
<center><a href="WasmStreamingParser.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmTable.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
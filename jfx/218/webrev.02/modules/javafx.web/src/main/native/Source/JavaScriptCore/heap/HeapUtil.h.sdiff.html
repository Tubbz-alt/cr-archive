<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapSnapshotBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IncrementalSweeper.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 35 //
 36 // This ends up being an issue because Heap exposes a lot of methods that ought to be inline for
 37 // performance or that must be inline because they are templates.  This class ought to contain
 38 // methods that are used for the implementation of the collector, or for unusual clients that need
 39 // to reach deep into the collector for some reason.  Don&#39;t put things in here that would cause you
 40 // to have to include it from more than a handful of places, since that would defeat the purpose.
 41 // This class isn&#39;t here to look pretty.  It&#39;s to let us hack the GC more easily!
 42 
 43 class HeapUtil {
 44 public:
 45     // This function must be run after stopAllocation() is called and
 46     // before liveness data is cleared to be accurate.
 47     template&lt;typename Func&gt;
 48     static void findGCObjectPointersForMarking(
 49         Heap&amp; heap, HeapVersion markingVersion, HeapVersion newlyAllocatedVersion, TinyBloomFilter filter,
 50         void* passedPointer, const Func&amp; func)
 51     {
 52         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
 53 
 54         ASSERT(heap.objectSpace().isMarking());
<span class="line-modified"> 55         static const bool isMarking = true;</span>
 56 
 57         char* pointer = static_cast&lt;char*&gt;(passedPointer);
 58 
 59         // It could point to a large allocation.
<span class="line-modified"> 60         if (heap.objectSpace().largeAllocationsForThisCollectionSize()) {</span>
<span class="line-modified"> 61             if (heap.objectSpace().largeAllocationsForThisCollectionBegin()[0]-&gt;aboveLowerBound(pointer)</span>
<span class="line-modified"> 62                 &amp;&amp; heap.objectSpace().largeAllocationsForThisCollectionEnd()[-1]-&gt;belowUpperBound(pointer)) {</span>
<span class="line-modified"> 63                 LargeAllocation** result = approximateBinarySearch&lt;LargeAllocation*&gt;(</span>
<span class="line-modified"> 64                     heap.objectSpace().largeAllocationsForThisCollectionBegin(),</span>
<span class="line-modified"> 65                     heap.objectSpace().largeAllocationsForThisCollectionSize(),</span>
<span class="line-modified"> 66                     LargeAllocation::fromCell(pointer),</span>
<span class="line-modified"> 67                     [] (LargeAllocation** ptr) -&gt; LargeAllocation* { return *ptr; });</span>
 68                 if (result) {
<span class="line-modified"> 69                     auto attemptLarge = [&amp;] (LargeAllocation* allocation) {</span>
<span class="line-modified"> 70                         if (allocation-&gt;contains(pointer))</span>
 71                             func(allocation-&gt;cell(), allocation-&gt;attributes().cellKind);
 72                     };
 73 
<span class="line-modified"> 74                     if (result &gt; heap.objectSpace().largeAllocationsForThisCollectionBegin())</span>
 75                         attemptLarge(result[-1]);
 76                     attemptLarge(result[0]);
<span class="line-modified"> 77                     if (result + 1 &lt; heap.objectSpace().largeAllocationsForThisCollectionEnd())</span>
 78                         attemptLarge(result[1]);
 79                 }
 80             }
 81         }
 82 
 83         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
 84         // It&#39;s possible for a butterfly pointer to point past the end of a butterfly. Check this now.
 85         if (pointer &lt;= bitwise_cast&lt;char*&gt;(candidate) + sizeof(IndexingHeader)) {
 86             // We may be interested in the last cell of the previous MarkedBlock.
 87             char* previousPointer = bitwise_cast&lt;char*&gt;(bitwise_cast&lt;uintptr_t&gt;(pointer) - sizeof(IndexingHeader) - 1);
 88             MarkedBlock* previousCandidate = MarkedBlock::blockFor(previousPointer);
 89             if (!filter.ruleOut(bitwise_cast&lt;Bits&gt;(previousCandidate))
 90                 &amp;&amp; set.contains(previousCandidate)
 91                 &amp;&amp; hasInteriorPointers(previousCandidate-&gt;handle().cellKind())) {
 92                 previousPointer = static_cast&lt;char*&gt;(previousCandidate-&gt;handle().cellAlign(previousPointer));
 93                 if (previousCandidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, previousPointer))
 94                     func(previousPointer, previousCandidate-&gt;handle().cellKind());
 95             }
 96         }
 97 
</pre>
<hr />
<pre>
106         HeapCell::Kind cellKind = candidate-&gt;handle().cellKind();
107 
108         auto tryPointer = [&amp;] (void* pointer) {
109             if (candidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, pointer))
110                 func(pointer, cellKind);
111         };
112 
113         if (isJSCellKind(cellKind)) {
114             if (MarkedBlock::isAtomAligned(pointer))
115                 tryPointer(pointer);
116             if (!hasInteriorPointers(cellKind))
117                 return;
118         }
119 
120         // A butterfly could point into the middle of an object.
121         char* alignedPointer = static_cast&lt;char*&gt;(candidate-&gt;handle().cellAlign(pointer));
122         tryPointer(alignedPointer);
123 
124         // Also, a butterfly could point at the end of an object plus sizeof(IndexingHeader). In that
125         // case, this is pointing to the object to the right of the one we should be marking.
<span class="line-modified">126         if (candidate-&gt;atomNumber(alignedPointer) &gt; 0</span>
127             &amp;&amp; pointer &lt;= alignedPointer + sizeof(IndexingHeader))
128             tryPointer(alignedPointer - candidate-&gt;cellSize());
129     }
130 
<span class="line-modified">131     static bool isPointerGCObjectJSCell(</span>
<span class="line-removed">132         Heap&amp; heap, TinyBloomFilter filter, const void* pointer)</span>
133     {
134         // It could point to a large allocation.
<span class="line-modified">135         const Vector&lt;LargeAllocation*&gt;&amp; largeAllocations = heap.objectSpace().largeAllocations();</span>
<span class="line-modified">136         if (!largeAllocations.isEmpty()) {</span>
<span class="line-modified">137             if (largeAllocations[0]-&gt;aboveLowerBound(pointer)</span>
<span class="line-modified">138                 &amp;&amp; largeAllocations.last()-&gt;belowUpperBound(pointer)) {</span>
<span class="line-modified">139                 LargeAllocation*const* result = approximateBinarySearch&lt;LargeAllocation*const&gt;(</span>
<span class="line-modified">140                     largeAllocations.begin(), largeAllocations.size(),</span>
<span class="line-removed">141                     LargeAllocation::fromCell(pointer),</span>
<span class="line-removed">142                     [] (LargeAllocation*const* ptr) -&gt; LargeAllocation* { return *ptr; });</span>
<span class="line-removed">143                 if (result) {</span>
<span class="line-removed">144                     if (result &gt; largeAllocations.begin()</span>
<span class="line-removed">145                         &amp;&amp; result[-1]-&gt;cell() == pointer</span>
<span class="line-removed">146                         &amp;&amp; isJSCellKind(result[-1]-&gt;attributes().cellKind))</span>
<span class="line-removed">147                         return true;</span>
<span class="line-removed">148                     if (result[0]-&gt;cell() == pointer</span>
<span class="line-removed">149                         &amp;&amp; isJSCellKind(result[0]-&gt;attributes().cellKind))</span>
<span class="line-removed">150                         return true;</span>
<span class="line-removed">151                     if (result + 1 &lt; largeAllocations.end()</span>
<span class="line-removed">152                         &amp;&amp; result[1]-&gt;cell() == pointer</span>
<span class="line-removed">153                         &amp;&amp; isJSCellKind(result[1]-&gt;attributes().cellKind))</span>
<span class="line-removed">154                         return true;</span>
<span class="line-removed">155                 }</span>
<span class="line-removed">156             }</span>
157         }
158 
159         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
160 
161         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
162         if (filter.ruleOut(bitwise_cast&lt;Bits&gt;(candidate))) {
163             ASSERT(!candidate || !set.contains(candidate));
164             return false;
165         }
166 
167         if (!MarkedBlock::isAtomAligned(pointer))
168             return false;
169 
170         if (!set.contains(candidate))
171             return false;
172 
173         if (candidate-&gt;handle().cellKind() != HeapCell::JSCell)
174             return false;
175 
176         if (!candidate-&gt;handle().isLiveCell(pointer))
177             return false;
178 
179         return true;
180     }
181 

182     static bool isValueGCObject(
183         Heap&amp; heap, TinyBloomFilter filter, JSValue value)
184     {

185         if (!value.isCell())
186             return false;
<span class="line-modified">187         return isPointerGCObjectJSCell(heap, filter, static_cast&lt;void*&gt;(value.asCell()));</span>
188     }
189 };
190 
191 } // namespace JSC
192 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 35 //
 36 // This ends up being an issue because Heap exposes a lot of methods that ought to be inline for
 37 // performance or that must be inline because they are templates.  This class ought to contain
 38 // methods that are used for the implementation of the collector, or for unusual clients that need
 39 // to reach deep into the collector for some reason.  Don&#39;t put things in here that would cause you
 40 // to have to include it from more than a handful of places, since that would defeat the purpose.
 41 // This class isn&#39;t here to look pretty.  It&#39;s to let us hack the GC more easily!
 42 
 43 class HeapUtil {
 44 public:
 45     // This function must be run after stopAllocation() is called and
 46     // before liveness data is cleared to be accurate.
 47     template&lt;typename Func&gt;
 48     static void findGCObjectPointersForMarking(
 49         Heap&amp; heap, HeapVersion markingVersion, HeapVersion newlyAllocatedVersion, TinyBloomFilter filter,
 50         void* passedPointer, const Func&amp; func)
 51     {
 52         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
 53 
 54         ASSERT(heap.objectSpace().isMarking());
<span class="line-modified"> 55         static constexpr bool isMarking = true;</span>
 56 
 57         char* pointer = static_cast&lt;char*&gt;(passedPointer);
 58 
 59         // It could point to a large allocation.
<span class="line-modified"> 60         if (heap.objectSpace().preciseAllocationsForThisCollectionSize()) {</span>
<span class="line-modified"> 61             if (heap.objectSpace().preciseAllocationsForThisCollectionBegin()[0]-&gt;aboveLowerBound(pointer)</span>
<span class="line-modified"> 62                 &amp;&amp; heap.objectSpace().preciseAllocationsForThisCollectionEnd()[-1]-&gt;belowUpperBound(pointer)) {</span>
<span class="line-modified"> 63                 PreciseAllocation** result = approximateBinarySearch&lt;PreciseAllocation*&gt;(</span>
<span class="line-modified"> 64                     heap.objectSpace().preciseAllocationsForThisCollectionBegin(),</span>
<span class="line-modified"> 65                     heap.objectSpace().preciseAllocationsForThisCollectionSize(),</span>
<span class="line-modified"> 66                     PreciseAllocation::fromCell(pointer),</span>
<span class="line-modified"> 67                     [] (PreciseAllocation** ptr) -&gt; PreciseAllocation* { return *ptr; });</span>
 68                 if (result) {
<span class="line-modified"> 69                     auto attemptLarge = [&amp;] (PreciseAllocation* allocation) {</span>
<span class="line-modified"> 70                         if (allocation-&gt;contains(pointer) &amp;&amp; allocation-&gt;hasValidCell())</span>
 71                             func(allocation-&gt;cell(), allocation-&gt;attributes().cellKind);
 72                     };
 73 
<span class="line-modified"> 74                     if (result &gt; heap.objectSpace().preciseAllocationsForThisCollectionBegin())</span>
 75                         attemptLarge(result[-1]);
 76                     attemptLarge(result[0]);
<span class="line-modified"> 77                     if (result + 1 &lt; heap.objectSpace().preciseAllocationsForThisCollectionEnd())</span>
 78                         attemptLarge(result[1]);
 79                 }
 80             }
 81         }
 82 
 83         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
 84         // It&#39;s possible for a butterfly pointer to point past the end of a butterfly. Check this now.
 85         if (pointer &lt;= bitwise_cast&lt;char*&gt;(candidate) + sizeof(IndexingHeader)) {
 86             // We may be interested in the last cell of the previous MarkedBlock.
 87             char* previousPointer = bitwise_cast&lt;char*&gt;(bitwise_cast&lt;uintptr_t&gt;(pointer) - sizeof(IndexingHeader) - 1);
 88             MarkedBlock* previousCandidate = MarkedBlock::blockFor(previousPointer);
 89             if (!filter.ruleOut(bitwise_cast&lt;Bits&gt;(previousCandidate))
 90                 &amp;&amp; set.contains(previousCandidate)
 91                 &amp;&amp; hasInteriorPointers(previousCandidate-&gt;handle().cellKind())) {
 92                 previousPointer = static_cast&lt;char*&gt;(previousCandidate-&gt;handle().cellAlign(previousPointer));
 93                 if (previousCandidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, previousPointer))
 94                     func(previousPointer, previousCandidate-&gt;handle().cellKind());
 95             }
 96         }
 97 
</pre>
<hr />
<pre>
106         HeapCell::Kind cellKind = candidate-&gt;handle().cellKind();
107 
108         auto tryPointer = [&amp;] (void* pointer) {
109             if (candidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, pointer))
110                 func(pointer, cellKind);
111         };
112 
113         if (isJSCellKind(cellKind)) {
114             if (MarkedBlock::isAtomAligned(pointer))
115                 tryPointer(pointer);
116             if (!hasInteriorPointers(cellKind))
117                 return;
118         }
119 
120         // A butterfly could point into the middle of an object.
121         char* alignedPointer = static_cast&lt;char*&gt;(candidate-&gt;handle().cellAlign(pointer));
122         tryPointer(alignedPointer);
123 
124         // Also, a butterfly could point at the end of an object plus sizeof(IndexingHeader). In that
125         // case, this is pointing to the object to the right of the one we should be marking.
<span class="line-modified">126         if (candidate-&gt;candidateAtomNumber(alignedPointer) &gt; 0</span>
127             &amp;&amp; pointer &lt;= alignedPointer + sizeof(IndexingHeader))
128             tryPointer(alignedPointer - candidate-&gt;cellSize());
129     }
130 
<span class="line-modified">131     static bool isPointerGCObjectJSCell(Heap&amp; heap, TinyBloomFilter filter, JSCell* pointer)</span>

132     {
133         // It could point to a large allocation.
<span class="line-modified">134         if (pointer-&gt;isPreciseAllocation()) {</span>
<span class="line-modified">135             auto* set = heap.objectSpace().preciseAllocationSet();</span>
<span class="line-modified">136             ASSERT(set);</span>
<span class="line-modified">137             if (set-&gt;isEmpty())</span>
<span class="line-modified">138                 return false;</span>
<span class="line-modified">139             return set-&gt;contains(pointer);</span>
















140         }
141 
142         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
143 
144         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
145         if (filter.ruleOut(bitwise_cast&lt;Bits&gt;(candidate))) {
146             ASSERT(!candidate || !set.contains(candidate));
147             return false;
148         }
149 
150         if (!MarkedBlock::isAtomAligned(pointer))
151             return false;
152 
153         if (!set.contains(candidate))
154             return false;
155 
156         if (candidate-&gt;handle().cellKind() != HeapCell::JSCell)
157             return false;
158 
159         if (!candidate-&gt;handle().isLiveCell(pointer))
160             return false;
161 
162         return true;
163     }
164 
<span class="line-added">165     // This does not find the cell if the pointer is pointing at the middle of a JSCell.</span>
166     static bool isValueGCObject(
167         Heap&amp; heap, TinyBloomFilter filter, JSValue value)
168     {
<span class="line-added">169         ASSERT(heap.objectSpace().preciseAllocationSet());</span>
170         if (!value.isCell())
171             return false;
<span class="line-modified">172         return isPointerGCObjectJSCell(heap, filter, value.asCell());</span>
173     }
174 };
175 
176 } // namespace JSC
177 
</pre>
</td>
</tr>
</table>
<center><a href="HeapSnapshotBuilder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IncrementalSweeper.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/RefCounted.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RefCounted.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RefCountedArray.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/RefCounted.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;wtf/Assertions.h&gt;
 24 #include &lt;wtf/FastMalloc.h&gt;
 25 #include &lt;wtf/MainThread.h&gt;
 26 #include &lt;wtf/Noncopyable.h&gt;
 27 
 28 namespace WTF {
 29 
<span class="line-modified"> 30 #if defined(NDEBUG) &amp;&amp; !ENABLE(SECURITY_ASSERTIONS)</span>
<span class="line-removed"> 31 #define CHECK_REF_COUNTED_LIFECYCLE 0</span>
<span class="line-removed"> 32 #else</span>
 33 #define CHECK_REF_COUNTED_LIFECYCLE 1


 34 #endif
 35 
 36 // This base class holds the non-template methods and attributes.
 37 // The RefCounted class inherits from it reducing the template bloat
 38 // generated by the compiler (technique called template hoisting).
 39 class RefCountedBase {
 40 public:
 41     void ref() const
 42     {
 43         applyRefDerefThreadingCheck();
 44 
 45 #if CHECK_REF_COUNTED_LIFECYCLE
 46         ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 47         ASSERT(!m_adoptionIsRequired);
 48 #endif
 49         ++m_refCount;
 50     }
 51 
 52     bool hasOneRef() const
 53     {
</pre>
<hr />
<pre>
 58     }
 59 
 60     unsigned refCount() const
 61     {
 62         return m_refCount;
 63     }
 64 
 65     void relaxAdoptionRequirement()
 66     {
 67 #if CHECK_REF_COUNTED_LIFECYCLE
 68         ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 69         ASSERT(m_adoptionIsRequired);
 70         m_adoptionIsRequired = false;
 71 #endif
 72     }
 73 
 74     // Please only call this method if you really know that what you&#39;re doing is safe (e.g.
 75     // locking at call sites).
 76     void disableThreadingChecks()
 77     {
<span class="line-modified"> 78 #if !ASSERT_DISABLED</span>
 79         m_areThreadingChecksEnabled = false;
 80 #endif
 81     }
 82 
 83     static void enableThreadingChecksGlobally()
 84     {
<span class="line-modified"> 85 #if !ASSERT_DISABLED</span>
 86         areThreadingChecksEnabledGlobally = true;
 87 #endif
 88     }
 89 
 90 protected:
 91     RefCountedBase()
 92         : m_refCount(1)
<span class="line-modified"> 93 #if !ASSERT_DISABLED</span>
<span class="line-modified"> 94         , m_isOwnedByMainThread(isMainThreadIfInitialized())</span>
<span class="line-removed"> 95         , m_areThreadingChecksEnabled(isMainThreadInitialized())</span>
 96 #endif
 97 #if CHECK_REF_COUNTED_LIFECYCLE
 98         , m_deletionHasBegun(false)
 99         , m_adoptionIsRequired(true)
100 #endif
101     {
102     }
103 
104     void applyRefDerefThreadingCheck() const
105     {
<span class="line-modified">106 #if !ASSERT_DISABLED</span>
107         if (hasOneRef()) {
108             // Likely an ownership transfer across threads that may be safe.
<span class="line-modified">109             m_isOwnedByMainThread = isMainThreadIfInitialized();</span>
110         } else if (areThreadingChecksEnabledGlobally &amp;&amp; m_areThreadingChecksEnabled) {
111             // If you hit this assertion, it means that the RefCounted object was ref/deref&#39;d
112             // from both the main thread and another in a way that is likely concurrent and unsafe.
113             // Derive from ThreadSafeRefCounted and make sure the destructor is safe on threads
114             // that call deref, or ref/deref from a single thread.
115             ASSERT_WITH_MESSAGE(m_isOwnedByMainThread == isMainThread(), &quot;Unsafe to ref/deref from different threads&quot;);
116         }
117 #endif
118     }
119 
120     ~RefCountedBase()
121     {
122 #if CHECK_REF_COUNTED_LIFECYCLE
123         ASSERT(m_deletionHasBegun);
124         ASSERT(!m_adoptionIsRequired);
125 #endif
126     }
127 
128     // Returns whether the pointer should be freed or not.
129     bool derefBase() const
</pre>
<hr />
<pre>
144             return true;
145         }
146         m_refCount = tempRefCount;
147         return false;
148     }
149 
150 #if CHECK_REF_COUNTED_LIFECYCLE
151     bool deletionHasBegun() const
152     {
153         return m_deletionHasBegun;
154     }
155 #endif
156 
157 private:
158 
159 #if CHECK_REF_COUNTED_LIFECYCLE
160     friend void adopted(RefCountedBase*);
161 #endif
162 
163     mutable unsigned m_refCount;
<span class="line-modified">164 #if !ASSERT_DISABLED</span>
165     mutable bool m_isOwnedByMainThread;
166     bool m_areThreadingChecksEnabled { true };
<span class="line-removed">167     WTF_EXPORT_PRIVATE static bool areThreadingChecksEnabledGlobally;</span>
168 #endif

169 #if CHECK_REF_COUNTED_LIFECYCLE
170     mutable bool m_deletionHasBegun;
171     mutable bool m_adoptionIsRequired;
172 #endif
173 };
174 
175 #if CHECK_REF_COUNTED_LIFECYCLE
176 inline void adopted(RefCountedBase* object)
177 {
178     if (!object)
179         return;
180     ASSERT_WITH_SECURITY_IMPLICATION(!object-&gt;m_deletionHasBegun);
181     object-&gt;m_adoptionIsRequired = false;
182 }
183 #endif
184 
185 template&lt;typename T, typename Deleter = std::default_delete&lt;T&gt;&gt; class RefCounted : public RefCountedBase {
186     WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;
187 public:
188     void deref() const
</pre>
</td>
<td>
<hr />
<pre>
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;wtf/Assertions.h&gt;
 24 #include &lt;wtf/FastMalloc.h&gt;
 25 #include &lt;wtf/MainThread.h&gt;
 26 #include &lt;wtf/Noncopyable.h&gt;
 27 
 28 namespace WTF {
 29 
<span class="line-modified"> 30 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>


 31 #define CHECK_REF_COUNTED_LIFECYCLE 1
<span class="line-added"> 32 #else</span>
<span class="line-added"> 33 #define CHECK_REF_COUNTED_LIFECYCLE 0</span>
 34 #endif
 35 
 36 // This base class holds the non-template methods and attributes.
 37 // The RefCounted class inherits from it reducing the template bloat
 38 // generated by the compiler (technique called template hoisting).
 39 class RefCountedBase {
 40 public:
 41     void ref() const
 42     {
 43         applyRefDerefThreadingCheck();
 44 
 45 #if CHECK_REF_COUNTED_LIFECYCLE
 46         ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 47         ASSERT(!m_adoptionIsRequired);
 48 #endif
 49         ++m_refCount;
 50     }
 51 
 52     bool hasOneRef() const
 53     {
</pre>
<hr />
<pre>
 58     }
 59 
 60     unsigned refCount() const
 61     {
 62         return m_refCount;
 63     }
 64 
 65     void relaxAdoptionRequirement()
 66     {
 67 #if CHECK_REF_COUNTED_LIFECYCLE
 68         ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 69         ASSERT(m_adoptionIsRequired);
 70         m_adoptionIsRequired = false;
 71 #endif
 72     }
 73 
 74     // Please only call this method if you really know that what you&#39;re doing is safe (e.g.
 75     // locking at call sites).
 76     void disableThreadingChecks()
 77     {
<span class="line-modified"> 78 #if ASSERT_ENABLED</span>
 79         m_areThreadingChecksEnabled = false;
 80 #endif
 81     }
 82 
 83     static void enableThreadingChecksGlobally()
 84     {
<span class="line-modified"> 85 #if ASSERT_ENABLED</span>
 86         areThreadingChecksEnabledGlobally = true;
 87 #endif
 88     }
 89 
 90 protected:
 91     RefCountedBase()
 92         : m_refCount(1)
<span class="line-modified"> 93 #if ASSERT_ENABLED</span>
<span class="line-modified"> 94         , m_isOwnedByMainThread(isMainThread())</span>

 95 #endif
 96 #if CHECK_REF_COUNTED_LIFECYCLE
 97         , m_deletionHasBegun(false)
 98         , m_adoptionIsRequired(true)
 99 #endif
100     {
101     }
102 
103     void applyRefDerefThreadingCheck() const
104     {
<span class="line-modified">105 #if ASSERT_ENABLED</span>
106         if (hasOneRef()) {
107             // Likely an ownership transfer across threads that may be safe.
<span class="line-modified">108             m_isOwnedByMainThread = isMainThread();</span>
109         } else if (areThreadingChecksEnabledGlobally &amp;&amp; m_areThreadingChecksEnabled) {
110             // If you hit this assertion, it means that the RefCounted object was ref/deref&#39;d
111             // from both the main thread and another in a way that is likely concurrent and unsafe.
112             // Derive from ThreadSafeRefCounted and make sure the destructor is safe on threads
113             // that call deref, or ref/deref from a single thread.
114             ASSERT_WITH_MESSAGE(m_isOwnedByMainThread == isMainThread(), &quot;Unsafe to ref/deref from different threads&quot;);
115         }
116 #endif
117     }
118 
119     ~RefCountedBase()
120     {
121 #if CHECK_REF_COUNTED_LIFECYCLE
122         ASSERT(m_deletionHasBegun);
123         ASSERT(!m_adoptionIsRequired);
124 #endif
125     }
126 
127     // Returns whether the pointer should be freed or not.
128     bool derefBase() const
</pre>
<hr />
<pre>
143             return true;
144         }
145         m_refCount = tempRefCount;
146         return false;
147     }
148 
149 #if CHECK_REF_COUNTED_LIFECYCLE
150     bool deletionHasBegun() const
151     {
152         return m_deletionHasBegun;
153     }
154 #endif
155 
156 private:
157 
158 #if CHECK_REF_COUNTED_LIFECYCLE
159     friend void adopted(RefCountedBase*);
160 #endif
161 
162     mutable unsigned m_refCount;
<span class="line-modified">163 #if ASSERT_ENABLED</span>
164     mutable bool m_isOwnedByMainThread;
165     bool m_areThreadingChecksEnabled { true };

166 #endif
<span class="line-added">167     WTF_EXPORT_PRIVATE static bool areThreadingChecksEnabledGlobally;</span>
168 #if CHECK_REF_COUNTED_LIFECYCLE
169     mutable bool m_deletionHasBegun;
170     mutable bool m_adoptionIsRequired;
171 #endif
172 };
173 
174 #if CHECK_REF_COUNTED_LIFECYCLE
175 inline void adopted(RefCountedBase* object)
176 {
177     if (!object)
178         return;
179     ASSERT_WITH_SECURITY_IMPLICATION(!object-&gt;m_deletionHasBegun);
180     object-&gt;m_adoptionIsRequired = false;
181 }
182 #endif
183 
184 template&lt;typename T, typename Deleter = std::default_delete&lt;T&gt;&gt; class RefCounted : public RefCountedBase {
185     WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;
186 public:
187     void deref() const
</pre>
</td>
</tr>
</table>
<center><a href="RefCounted.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RefCountedArray.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
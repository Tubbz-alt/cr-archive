<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SimpleLineLayoutResolver.h&quot;
 28 
 29 #include &quot;InlineTextBoxStyle.h&quot;
 30 #include &quot;RenderBlockFlow.h&quot;
 31 #include &quot;RenderObject.h&quot;
 32 #include &quot;SimpleLineLayoutFunctions.h&quot;
 33 
 34 namespace WebCore {
 35 namespace SimpleLineLayout {
 36 
 37 static FloatPoint linePosition(float logicalLeft, float logicalTop)
 38 {
 39     return FloatPoint(logicalLeft, roundf(logicalTop));
 40 }
 41 
 42 static FloatSize lineSize(float logicalLeft, float logicalRight, float height)
 43 {
 44     return FloatSize(logicalRight - logicalLeft, height);
 45 }
 46 
 47 RunResolver::Run::Run(const Iterator&amp; iterator)
 48     : m_iterator(iterator)
 49 {
 50 }
 51 
 52 String RunResolver::Run::textWithHyphen() const
 53 {
 54     auto&amp; run = m_iterator.simpleRun();
 55     ASSERT(run.hasHyphen);
 56     // Empty runs should not have hyphen.
 57     ASSERT(run.start &lt; run.end);
 58     auto&amp; segment = m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end);
 59     auto text = StringView(segment.text).substring(segment.toSegmentPosition(run.start), run.end - run.start);
 60     return makeString(text, m_iterator.resolver().flow().style().hyphenString());
 61 }
 62 
 63 FloatRect RunResolver::Run::rect() const
 64 {
 65     auto&amp; run = m_iterator.simpleRun();
 66     auto&amp; resolver = m_iterator.resolver();
 67     float baseline = computeBaselinePosition();
 68     FloatPoint position = linePosition(run.logicalLeft, baseline - resolver.m_ascent);
 69     FloatSize size = lineSize(run.logicalLeft, run.logicalRight, resolver.m_ascent + resolver.m_descent + resolver.m_visualOverflowOffset);
 70 
 71     return FloatRect(position, size);
 72 }
 73 
 74 StringView RunResolver::Run::text() const
 75 {
 76     auto&amp; run = m_iterator.simpleRun();
 77     ASSERT(run.start &lt; run.end);
 78     auto&amp; segment = m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end);
 79     // We currently split runs on segment boundaries (different RenderObject).
 80     ASSERT(run.end &lt;= segment.end);
 81     return StringView(segment.text).substring(segment.toSegmentPosition(run.start), run.end - run.start);
 82 }
 83 
 84 const RenderObject&amp; RunResolver::Run::renderer() const
 85 {
 86     auto&amp; run = m_iterator.simpleRun();
 87     // FlowContents cannot differentiate empty runs.
 88     ASSERT(run.start != run.end);
 89     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).renderer;
 90 }
 91 
 92 unsigned RunResolver::Run::localStart() const
 93 {
 94     auto&amp; run = m_iterator.simpleRun();
 95     // FlowContents cannot differentiate empty runs.
 96     ASSERT(run.start != run.end);
 97     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.start);
 98 }
 99 
100 unsigned RunResolver::Run::localEnd() const
101 {
102     auto&amp; run = m_iterator.simpleRun();
103     // FlowContents cannot differentiate empty runs.
104     ASSERT(run.start != run.end);
105     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.end);
106 }
107 
108 RunResolver::Iterator::Iterator(const RunResolver&amp; resolver, unsigned runIndex, unsigned lineIndex)
109     : m_layout(&amp;resolver.m_layout)
110     , m_resolver(&amp;resolver)
111     , m_runIndex(runIndex)
112     , m_lineIndex(lineIndex)
113 {
114     ASSERT(&amp;resolver == &amp;m_layout-&gt;runResolver());
115 }
116 
117 RunResolver::Iterator&amp; RunResolver::Iterator::advance()
118 {
119     if (simpleRun().isEndOfLine)
120         ++m_lineIndex;
121     ++m_runIndex;
122     return *this;
123 }
124 
125 RunResolver::Iterator&amp; RunResolver::Iterator::advanceLines(unsigned lineCount)
126 {
127     unsigned runCount = layout().runCount();
128     if (runCount == layout().lineCount()) {
129         m_runIndex = std::min(runCount, m_runIndex + lineCount);
130         m_lineIndex = m_runIndex;
131         return *this;
132     }
133     unsigned target = m_lineIndex + lineCount;
134     while (m_lineIndex &lt; target &amp;&amp; m_runIndex &lt; runCount)
135         advance();
136 
137     return *this;
138 }
139 
140 RunResolver::RunResolver(const RenderBlockFlow&amp; flow, const Layout&amp; layout)
141     : m_flowRenderer(flow)
142     , m_layout(layout)
143     , m_flowContents(flow)
144     , m_lineHeight(lineHeightFromFlow(flow))
145     , m_baseline(baselineFromFlow(flow))
146     , m_borderAndPaddingBefore(flow.borderAndPaddingBefore())
147     , m_ascent(flow.style().fontCascade().fontMetrics().ascent())
148     , m_descent(flow.style().fontCascade().fontMetrics().descent())
149     , m_visualOverflowOffset(visualOverflowForDecorations(flow.style(), nullptr).bottom)
150 {
151 }
152 
153 unsigned RunResolver::adjustLineIndexForStruts(LayoutUnit y, IndexType type, unsigned lineIndexCandidate) const
154 {
155     auto&amp; struts = m_layout.struts();
156     // We need to offset the lineIndex with line struts when there&#39;s an actual strut before the candidate.
157     auto&amp; strut = struts.first();
158     if (strut.lineBreak &gt;= lineIndexCandidate)
159         return lineIndexCandidate;
160     unsigned strutIndex = 0;
161     Optional&lt;unsigned&gt; lastIndexCandidate;
162     auto top = strut.lineBreak * m_lineHeight;
163     auto lineHeightWithOverflow = m_lineHeight;
164     // If font is larger than the line height (glyphs overflow), use the font size when checking line boundaries.
165     if (m_ascent + m_descent &gt; m_lineHeight) {
166         lineHeightWithOverflow = m_ascent + m_descent;
167         top += m_baseline - m_ascent;
168     }
169     auto bottom = top + lineHeightWithOverflow;
170     for (auto lineIndex = strut.lineBreak; lineIndex &lt; m_layout.lineCount(); ++lineIndex) {
171         float strutOffset = 0;
172         if (strutIndex &lt; struts.size() &amp;&amp; struts.at(strutIndex).lineBreak == lineIndex)
173             strutOffset = struts.at(strutIndex++).offset;
174         bottom = top + strutOffset + lineHeightWithOverflow;
175         if (y &gt;= top &amp;&amp; y &lt; bottom) {
176             if (type == IndexType::First)
177                 return lineIndex;
178             lastIndexCandidate = lineIndex;
179         } else if (lastIndexCandidate)
180             return *lastIndexCandidate;
181         top += m_lineHeight + strutOffset;
182     }
183     if (lastIndexCandidate || y &gt;= bottom)
184         return m_layout.lineCount() - 1;
185     // We missed the line.
186     ASSERT_NOT_REACHED();
187     return lineIndexCandidate;
188 }
189 
190 unsigned RunResolver::lineIndexForHeight(LayoutUnit height, IndexType type) const
191 {
192     ASSERT(m_lineHeight);
193     float y = height - m_borderAndPaddingBefore;
194     // Lines may overlap, adjust to get the first or last line at this height.
195     auto adjustedY = y;
196     if (type == IndexType::First)
197         adjustedY += m_lineHeight - (m_baseline + m_descent);
198     else
199         adjustedY -= m_baseline - m_ascent;
200     adjustedY = std::max&lt;float&gt;(adjustedY, 0);
201     auto lineIndexCandidate =  std::min&lt;unsigned&gt;(adjustedY / m_lineHeight, m_layout.lineCount() - 1);
202     if (m_layout.hasLineStruts())
203         return adjustLineIndexForStruts(LayoutUnit(y), type, lineIndexCandidate);
204     return lineIndexCandidate;
205 }
206 
207 WTF::IteratorRange&lt;RunResolver::Iterator&gt; RunResolver::rangeForRect(const LayoutRect&amp; rect) const
208 {
209     if (!m_lineHeight)
210         return { begin(), end() };
211 
212     unsigned firstLine = lineIndexForHeight(rect.y(), IndexType::First);
213     unsigned lastLine = std::max(firstLine, lineIndexForHeight(rect.maxY(), IndexType::Last));
214     auto rangeBegin = begin().advanceLines(firstLine);
215     if (rangeBegin == end())
216         return { end(), end() };
217     auto rangeEnd = rangeBegin;
218     ASSERT(lastLine &gt;= firstLine);
219     rangeEnd.advanceLines(lastLine - firstLine + 1);
220     return { rangeBegin, rangeEnd };
221 }
222 
223 WTF::IteratorRange&lt;RunResolver::Iterator&gt; RunResolver::rangeForLine(unsigned lineIndex) const
224 {
225     auto rangeBegin = begin().advanceLines(lineIndex);
226     if (rangeBegin == end())
227         return { end(), end() };
228     auto rangeEnd = rangeBegin;
229     rangeEnd.advanceLines(1);
230     return { rangeBegin, rangeEnd };
231 }
232 
233 WTF::IteratorRange&lt;RunResolver::Iterator&gt; RunResolver::rangeForRenderer(const RenderObject&amp; renderer) const
234 {
235     if (begin() == end())
236         return { end(), end() };
237     FlowContents::Iterator segment = m_flowContents.begin();
238     auto run = begin();
239     ASSERT(segment-&gt;start &lt;= (*run).start());
240     // Move run to the beginning of the segment.
241     while (&amp;segment-&gt;renderer != &amp;renderer &amp;&amp; run != end()) {
242         if ((*run).start() == segment-&gt;start &amp;&amp; (*run).end() == segment-&gt;end) {
243             ++run;
244             ++segment;
245         } else if ((*run).start() &lt; segment-&gt;end)
246             ++run;
247         else
248             ++segment;
249         ASSERT(segment != m_flowContents.end());
250     }
251     // Do we actually have a run for this renderer?
252     // Collapsed whitespace with dedicated renderer could end up with no run at all.
253     if (run == end() || (segment-&gt;start != segment-&gt;end &amp;&amp; segment-&gt;end &lt;= (*run).start()))
254         return { end(), end() };
255 
256     auto rangeBegin = run;
257     // Move beyond the end of the segment.
258     while (run != end() &amp;&amp; (*run).start() &lt; segment-&gt;end)
259         ++run;
260     // Special case when segment == run.
261     if (run == rangeBegin)
262         ++run;
263     return { rangeBegin, run };
264 }
265 
266 RunResolver::Iterator RunResolver::runForPoint(const LayoutPoint&amp; point) const
267 {
268     if (!m_lineHeight)
269         return end();
270     if (begin() == end())
271         return end();
272     unsigned lineIndex = lineIndexForHeight(point.y(), IndexType::Last);
273     auto x = point.x() - m_borderAndPaddingBefore;
274     auto it = begin();
275     it.advanceLines(lineIndex);
276     // Point is at the left side of the first run on this line.
277     if ((*it).logicalLeft() &gt; x)
278         return it;
279     // Advance to the first candidate run on this line.
280     while (it != end() &amp;&amp; (*it).logicalRight() &lt; x &amp;&amp; lineIndex == it.lineIndex())
281         ++it;
282     // We jumped to the next line so the point is at the right side of the previous line.
283     if (it.lineIndex() &gt; lineIndex)
284         return --it;
285     // Now we have a candidate run.
286     // Find the last run that still contains this point (taking overlapping runs with odd word spacing values into account).
287     while (it != end() &amp;&amp; (*it).logicalLeft() &lt;= x &amp;&amp; lineIndex == it.lineIndex())
288         ++it;
289     return --it;
290 }
291 
292 WTF::IteratorRange&lt;RunResolver::Iterator&gt; RunResolver::rangeForRendererWithOffsets(const RenderObject&amp; renderer, unsigned startOffset, unsigned endOffset) const
293 {
294     ASSERT(startOffset &lt;= endOffset);
295     auto range = rangeForRenderer(renderer);
296     if (range.begin() == range.end())
297         return { end(), end() };
298     auto it = range.begin();
299     auto localEnd = (*it).start() + endOffset;
300     // Advance to the first run before the start offset. Only the first node in a range can have a startOffset.
301     // Note that the start offset may coincide with the end of a run. The run is still considered so that we
302     // can return an empty rect, which conforms to the behavior of Element.getClientRects().
303     while (it != range.end() &amp;&amp; (*it).end() &lt; startOffset)
304         ++it;
305     if (it == range.end())
306         return { end(), end() };
307     auto rangeBegin = it;
308     // Special case empty ranges that start at the edge of the run. Apparently normal line layout include those.
309     if (localEnd == startOffset &amp;&amp; (*it).start() == localEnd)
310         return { rangeBegin, ++it };
311     // Advance beyond the last run with the end offset.
312     while (it != range.end() &amp;&amp; (*it).start() &lt; localEnd)
313         ++it;
314     return { rangeBegin, it };
315 }
316 
317 LineResolver::Iterator::Iterator(RunResolver::Iterator runIterator)
318     : m_runIterator(runIterator)
319 {
320 }
321 
322 FloatRect LineResolver::Iterator::operator*() const
323 {
324     unsigned currentLine = m_runIterator.lineIndex();
325     auto it = m_runIterator;
326     FloatRect rect = (*it).rect();
327     while (it.advance().lineIndex() == currentLine)
328         rect.unite((*it).rect());
329     return rect;
330 }
331 
332 const RenderObject&amp; LineResolver::Iterator::renderer() const
333 {
334     // FIXME: This works as long as we&#39;ve got only one renderer per line.
335     auto run = *m_runIterator;
336     return m_runIterator.resolver().flowContents().segmentForRun(run.start(), run.end()).renderer;
337 }
338 
339 LineResolver::LineResolver(const RunResolver&amp; runResolver)
340     : m_runResolver(runResolver)
341 {
342 }
343 
344 }
345 }
    </pre>
  </body>
</html>
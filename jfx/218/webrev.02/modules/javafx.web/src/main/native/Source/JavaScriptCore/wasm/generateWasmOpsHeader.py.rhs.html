<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/generateWasmOpsHeader.py</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #! /usr/bin/env python
  2 
  3 # Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  4 #
  5 # Redistribution and use in source and binary forms, with or without
  6 # modification, are permitted provided that the following conditions
  7 # are met:
  8 #
  9 # 1.  Redistributions of source code must retain the above copyright
 10 #     notice, this list of conditions and the following disclaimer.
 11 # 2.  Redistributions in binary form must reproduce the above copyright
 12 #     notice, this list of conditions and the following disclaimer in the
 13 #     documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16 # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17 # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18 # DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19 # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20 # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21 # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22 # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25 
 26 # This tool has a couple of helpful macros to process Wasm files from the wasm.json.
 27 
 28 from generateWasm import *
 29 import optparse
 30 import sys
 31 
 32 parser = optparse.OptionParser(usage=&quot;usage: %prog &lt;wasm.json&gt; &lt;WasmOps.h&gt;&quot;)
 33 (options, args) = parser.parse_args(sys.argv[0:])
 34 if len(args) != 3:
 35     parser.error(parser.usage)
 36 
 37 wasm = Wasm(args[0], args[1])
 38 types = wasm.types
 39 opcodes = wasm.opcodes
 40 wasmOpsHFile = open(args[2], &quot;w&quot;)
 41 
 42 
<a name="1" id="anc1"></a><span class="line-modified"> 43 def cppType(type):</span>
<span class="line-modified"> 44     if type == &quot;bool&quot;:</span>
<span class="line-added"> 45         return &quot;I32&quot;</span>
<span class="line-added"> 46     return type.capitalize()</span>
 47 
 48 
<a name="2" id="anc2"></a><span class="line-added"> 49 def cppMacro(wasmOpcode, value, b3, inc, *extraArgs):</span>
<span class="line-added"> 50     extraArgsStr = &quot;, &quot; + &quot;, &quot;.join(extraArgs) if len(extraArgs) else &quot;&quot;</span>
<span class="line-added"> 51     return &quot; \\\n    macro(&quot; + wasm.toCpp(wasmOpcode) + &quot;, &quot; + hex(int(value)) + &quot;, &quot; + b3 + &quot;, &quot; + str(inc) + extraArgsStr + &quot;)&quot;</span>
<span class="line-added"> 52 </span>
 53 def typeMacroizer():
 54     inc = 0
 55     for ty in wasm.types:
 56         yield cppMacro(ty, wasm.types[ty][&quot;value&quot;], wasm.types[ty][&quot;b3type&quot;], inc)
 57         inc += 1
 58 
 59 type_definitions = [&quot;#define FOR_EACH_WASM_TYPE(macro)&quot;]
 60 type_definitions.extend([t for t in typeMacroizer()])
 61 type_definitions = &quot;&quot;.join(type_definitions)
 62 
 63 
<a name="3" id="anc3"></a><span class="line-modified"> 64 def opcodeMacroizer(filter, opcodeField=&quot;value&quot;, modifier=None):</span>
 65     inc = 0
 66     for op in wasm.opcodeIterator(filter):
 67         b3op = &quot;Oops&quot;
 68         if isSimple(op[&quot;opcode&quot;]):
 69             b3op = op[&quot;opcode&quot;][&quot;b3op&quot;]
<a name="4" id="anc4"></a><span class="line-modified"> 70         extraArgs = []</span>
<span class="line-added"> 71         if modifier:</span>
<span class="line-added"> 72             extraArgs = modifier(op[&quot;opcode&quot;])</span>
<span class="line-added"> 73         yield cppMacro(op[&quot;name&quot;], op[&quot;opcode&quot;][opcodeField], b3op, inc, *extraArgs)</span>
 74         inc += 1
 75 
<a name="5" id="anc5"></a><span class="line-added"> 76 </span>
<span class="line-added"> 77 def opcodeWithTypesMacroizer(filter):</span>
<span class="line-added"> 78     def modifier(op):</span>
<span class="line-added"> 79         return [cppType(type) for type in op[&quot;parameter&quot;] + op[&quot;return&quot;]]</span>
<span class="line-added"> 80     return opcodeMacroizer(filter, modifier=modifier)</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83 def memoryLoadMacroizer():</span>
<span class="line-added"> 84     def modifier(op):</span>
<span class="line-added"> 85         return [cppType(op[&quot;return&quot;][0])]</span>
<span class="line-added"> 86     return opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1), modifier=modifier)</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89 def memoryStoreMacroizer():</span>
<span class="line-added"> 90     def modifier(op):</span>
<span class="line-added"> 91         return [cppType(op[&quot;parameter&quot;][1])]</span>
<span class="line-added"> 92     return opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0), modifier=modifier)</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94 </span>
 95 defines = [&quot;#define FOR_EACH_WASM_SPECIAL_OP(macro)&quot;]
 96 defines.extend([op for op in opcodeMacroizer(lambda op: not (isUnary(op) or isBinary(op) or op[&quot;category&quot;] == &quot;control&quot; or op[&quot;category&quot;] == &quot;memory&quot; or op[&quot;category&quot;] == &quot;exttable&quot;))])
 97 defines.append(&quot;\n\n#define FOR_EACH_WASM_CONTROL_FLOW_OP(macro)&quot;)
 98 defines.extend([op for op in opcodeMacroizer(lambda op: op[&quot;category&quot;] == &quot;control&quot;)])
 99 defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<a name="6" id="anc6"></a><span class="line-modified">100 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isUnary(op) and isSimple(op))])</span>
101 defines.append(&quot;\n\n#define FOR_EACH_WASM_UNARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_UNARY_OP(macro)&quot;)
<a name="7" id="anc7"></a><span class="line-modified">102 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isUnary(op) and not (isSimple(op)))])</span>
103 defines.append(&quot;\n\n#define FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<a name="8" id="anc8"></a><span class="line-modified">104 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isBinary(op) and isSimple(op))])</span>
105 defines.append(&quot;\n\n#define FOR_EACH_WASM_BINARY_OP(macro) \\\n    FOR_EACH_WASM_SIMPLE_BINARY_OP(macro)&quot;)
<a name="9" id="anc9"></a><span class="line-modified">106 defines.extend([op for op in opcodeWithTypesMacroizer(lambda op: isBinary(op) and not (isSimple(op)))])</span>
107 defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_LOAD_OP(macro)&quot;)
<a name="10" id="anc10"></a><span class="line-modified">108 defines.extend([op for op in memoryLoadMacroizer()])</span>
109 defines.append(&quot;\n\n#define FOR_EACH_WASM_MEMORY_STORE_OP(macro)&quot;)
<a name="11" id="anc11"></a><span class="line-modified">110 defines.extend([op for op in memoryStoreMacroizer()])</span>
111 defines.append(&quot;\n\n#define FOR_EACH_WASM_EXT_TABLE_OP(macro)&quot;)
<a name="12" id="anc12"></a><span class="line-modified">112 defines.extend([op for op in opcodeMacroizer(lambda op: (op[&quot;category&quot;] == &quot;exttable&quot;), opcodeField=&quot;extendedOp&quot;)])</span>
113 defines.append(&quot;\n\n&quot;)
114 
115 defines = &quot;&quot;.join(defines)
116 
117 opValueSet = set([op for op in wasm.opcodeIterator(lambda op: True, lambda op: opcodes[op][&quot;value&quot;])])
118 maxOpValue = max(opValueSet)
119 
120 
121 # Luckily, python does floor division rather than trunc division so this works.
122 def ceilDiv(a, b):
123     return -(-a // b)
124 
125 
126 def bitSet():
127     v = &quot;&quot;
128     for i in range(ceilDiv(maxOpValue + 1, 8)):
129         entry = 0
130         for j in range(8):
131             if i * 8 + j in opValueSet:
132                 entry |= 1 &lt;&lt; j
133         v += (&quot;, &quot; if i else &quot;&quot;) + hex(entry)
134     return v
135 
136 validOps = bitSet()
137 
138 
139 def memoryLog2AlignmentGenerator(filter):
140     result = []
141     for op in wasm.opcodeIterator(filter):
142         result.append(&quot;    case &quot; + wasm.toCpp(op[&quot;name&quot;]) + &quot;: return &quot; + memoryLog2Alignment(op) + &quot;;&quot;)
143     return &quot;\n&quot;.join(result)
144 
145 memoryLog2AlignmentLoads = memoryLog2AlignmentGenerator(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 1))
146 memoryLog2AlignmentStores = memoryLog2AlignmentGenerator(lambda op: (op[&quot;category&quot;] == &quot;memory&quot; and len(op[&quot;return&quot;]) == 0))
147 
148 
149 contents = wasm.header + &quot;&quot;&quot;
150 
151 #pragma once
152 
153 #if ENABLE(WEBASSEMBLY)
154 
155 #include &lt;cstdint&gt;
156 
157 namespace JSC { namespace Wasm {
158 
159 static constexpr unsigned expectedVersionNumber = &quot;&quot;&quot; + wasm.expectedVersionNumber + &quot;&quot;&quot;;
160 
161 static constexpr unsigned numTypes = &quot;&quot;&quot; + str(len(types)) + &quot;&quot;&quot;;
162 
163 &quot;&quot;&quot; + type_definitions + &quot;&quot;&quot;
<a name="13" id="anc13"></a><span class="line-modified">164 #define CREATE_ENUM_VALUE(name, id, ...) name = id,</span>
165 enum Type : int8_t {
166     FOR_EACH_WASM_TYPE(CREATE_ENUM_VALUE)
167 };
168 #undef CREATE_ENUM_VALUE
169 
<a name="14" id="anc14"></a><span class="line-modified">170 #define CREATE_CASE(name, id, ...) case id: return true;</span>
171 template &lt;typename Int&gt;
172 inline bool isValidType(Int i)
173 {
174     switch (i) {
175     default: return false;
176     FOR_EACH_WASM_TYPE(CREATE_CASE)
177     }
178     RELEASE_ASSERT_NOT_REACHED();
179     return false;
180 }
181 #undef CREATE_CASE
182 
<a name="15" id="anc15"></a><span class="line-modified">183 #define CREATE_CASE(name, id, b3type, ...) case name: return b3type;</span>
184 inline B3::Type toB3Type(Type type)
185 {
186     switch (type) {
187     FOR_EACH_WASM_TYPE(CREATE_CASE)
188     }
189     RELEASE_ASSERT_NOT_REACHED();
190     return B3::Void;
191 }
192 #undef CREATE_CASE
193 
<a name="16" id="anc16"></a><span class="line-modified">194 #define CREATE_CASE(name, ...) case name: return #name;</span>
195 inline const char* makeString(Type type)
196 {
197     switch (type) {
198     FOR_EACH_WASM_TYPE(CREATE_CASE)
199     }
200     RELEASE_ASSERT_NOT_REACHED();
201     return nullptr;
202 }
203 #undef CREATE_CASE
204 
<a name="17" id="anc17"></a><span class="line-modified">205 #define CREATE_CASE(name, id, b3type, inc, ...) case id: return inc;</span>
206 inline int linearizeType(Type type)
207 {
208     switch (type) {
209     FOR_EACH_WASM_TYPE(CREATE_CASE)
210     }
211     RELEASE_ASSERT_NOT_REACHED();
212     return 0;
213 }
214 #undef CREATE_CASE
215 
<a name="18" id="anc18"></a><span class="line-modified">216 #define CREATE_CASE(name, id, b3type, inc, ...) case inc: return name;</span>
217 inline Type linearizedToType(int i)
218 {
219     switch (i) {
220     FOR_EACH_WASM_TYPE(CREATE_CASE)
221     }
222     RELEASE_ASSERT_NOT_REACHED();
223     return Void;
224 }
225 #undef CREATE_CASE
226 
227 
228 &quot;&quot;&quot; + defines + &quot;&quot;&quot;
229 #define FOR_EACH_WASM_OP(macro) \\
230     FOR_EACH_WASM_SPECIAL_OP(macro) \\
231     FOR_EACH_WASM_CONTROL_FLOW_OP(macro) \\
232     FOR_EACH_WASM_UNARY_OP(macro) \\
233     FOR_EACH_WASM_BINARY_OP(macro) \\
234     FOR_EACH_WASM_MEMORY_LOAD_OP(macro) \\
235     FOR_EACH_WASM_MEMORY_STORE_OP(macro) \\
236     macro(ExtTable, 0xFC, Oops, 0)
237 
<a name="19" id="anc19"></a><span class="line-modified">238 #define CREATE_ENUM_VALUE(name, id, ...) name = id,</span>
239 
240 enum OpType : uint8_t {
241     FOR_EACH_WASM_OP(CREATE_ENUM_VALUE)
242 };
243 
244 template&lt;typename Int&gt;
245 inline bool isValidOpType(Int i)
246 {
247     // Bitset of valid ops.
248     static const uint8_t valid[] = { &quot;&quot;&quot; + validOps + &quot;&quot;&quot; };
249     return 0 &lt;= i &amp;&amp; i &lt;= &quot;&quot;&quot; + str(maxOpValue) + &quot;&quot;&quot; &amp;&amp; (valid[i / 8] &amp; (1 &lt;&lt; (i % 8)));
250 }
251 
252 enum class BinaryOpType : uint8_t {
253     FOR_EACH_WASM_BINARY_OP(CREATE_ENUM_VALUE)
254 };
255 
256 enum class UnaryOpType : uint8_t {
257     FOR_EACH_WASM_UNARY_OP(CREATE_ENUM_VALUE)
258 };
259 
260 enum class LoadOpType : uint8_t {
261     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_ENUM_VALUE)
262 };
263 
264 enum class StoreOpType : uint8_t {
265     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_ENUM_VALUE)
266 };
267 
268 enum class ExtTableOpType : uint8_t {
269     FOR_EACH_WASM_EXT_TABLE_OP(CREATE_ENUM_VALUE)
270 };
271 
272 #undef CREATE_ENUM_VALUE
273 
274 inline bool isControlOp(OpType op)
275 {
276     switch (op) {
<a name="20" id="anc20"></a><span class="line-modified">277 #define CREATE_CASE(name, ...) case OpType::name:</span>
278     FOR_EACH_WASM_CONTROL_FLOW_OP(CREATE_CASE)
279         return true;
280 #undef CREATE_CASE
281     default:
282         break;
283     }
284     return false;
285 }
286 
287 inline bool isSimple(UnaryOpType op)
288 {
289     switch (op) {
<a name="21" id="anc21"></a><span class="line-modified">290 #define CREATE_CASE(name, ...) case UnaryOpType::name:</span>
291     FOR_EACH_WASM_SIMPLE_UNARY_OP(CREATE_CASE)
292         return true;
293 #undef CREATE_CASE
294     default:
295         break;
296     }
297     return false;
298 }
299 
300 inline bool isSimple(BinaryOpType op)
301 {
302     switch (op) {
<a name="22" id="anc22"></a><span class="line-modified">303 #define CREATE_CASE(name, ...) case BinaryOpType::name:</span>
304     FOR_EACH_WASM_SIMPLE_BINARY_OP(CREATE_CASE)
305         return true;
306 #undef CREATE_CASE
307     default:
308         break;
309     }
310     return false;
311 }
312 
313 inline uint32_t memoryLog2Alignment(OpType op)
314 {
315     switch (op) {
316 &quot;&quot;&quot; + memoryLog2AlignmentLoads + &quot;&quot;&quot;
317 &quot;&quot;&quot; + memoryLog2AlignmentStores + &quot;&quot;&quot;
318     default:
319         break;
320     }
321     RELEASE_ASSERT_NOT_REACHED();
322     return 0;
323 }
324 
<a name="23" id="anc23"></a><span class="line-modified">325 #define CREATE_CASE(name, ...) case name: return #name;</span>
326 inline const char* makeString(OpType op)
327 {
328     switch (op) {
329     FOR_EACH_WASM_OP(CREATE_CASE)
330     }
331     RELEASE_ASSERT_NOT_REACHED();
332     return nullptr;
333 }
334 #undef CREATE_CASE
335 
336 } } // namespace JSC::Wasm
337 
<a name="24" id="anc24"></a><span class="line-added">338 namespace WTF {</span>
<span class="line-added">339 </span>
<span class="line-added">340 inline void printInternal(PrintStream&amp; out, JSC::Wasm::Type type)</span>
<span class="line-added">341 {</span>
<span class="line-added">342     out.print(JSC::Wasm::makeString(type));</span>
<span class="line-added">343 }</span>
<span class="line-added">344 </span>
<span class="line-added">345 inline void printInternal(PrintStream&amp; out, JSC::Wasm::OpType op)</span>
<span class="line-added">346 {</span>
<span class="line-added">347     out.print(JSC::Wasm::makeString(op));</span>
<span class="line-added">348 }</span>
<span class="line-added">349 </span>
<span class="line-added">350 } // namespace WTF</span>
<span class="line-added">351 </span>
352 #endif // ENABLE(WEBASSEMBLY)
353 
354 &quot;&quot;&quot;
355 
356 wasmOpsHFile.write(contents)
357 wasmOpsHFile.close()
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
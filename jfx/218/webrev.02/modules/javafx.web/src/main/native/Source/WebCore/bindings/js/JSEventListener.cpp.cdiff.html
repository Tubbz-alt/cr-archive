<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSEventCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSEventListener.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSEventListener.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 128,37 ***</span>
          ScriptController&amp; script = window-&gt;wrapped().frame()-&gt;script();
          if (!script.canExecuteScripts(AboutToExecuteScript) || script.isPaused())
              return;
      }
  
<span class="line-modified">!     ExecState* exec = globalObject-&gt;globalExec();</span>
  
      JSValue handleEventFunction = jsFunction;
  
      CallData callData;
      CallType callType = getCallData(vm, handleEventFunction, callData);
  
<span class="line-modified">!     // If jsFunction is not actually a function, see if it implements the EventListener interface and use that</span>
      if (callType == CallType::None) {
<span class="line-modified">!         handleEventFunction = jsFunction-&gt;get(exec, Identifier::fromString(vm, &quot;handleEvent&quot;));</span>
          if (UNLIKELY(scope.exception())) {
              auto* exception = scope.exception();
              scope.clearException();
              event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">!             reportException(exec, exception);</span>
              return;
          }
          callType = getCallData(vm, handleEventFunction, callData);
      }
  
<span class="line-removed">-     if (callType == CallType::None)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      Ref&lt;JSEventListener&gt; protectedThis(*this);
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(toJS(exec, globalObject, &amp;event));</span>
      ASSERT(!args.hasOverflowed());
  
      Event* savedEvent = globalObject-&gt;currentEvent();
  
      // window.event should not be set when the target is inside a shadow tree, as per the DOM specification.
<span class="line-new-header">--- 128,42 ---</span>
          ScriptController&amp; script = window-&gt;wrapped().frame()-&gt;script();
          if (!script.canExecuteScripts(AboutToExecuteScript) || script.isPaused())
              return;
      }
  
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
  
      JSValue handleEventFunction = jsFunction;
  
      CallData callData;
      CallType callType = getCallData(vm, handleEventFunction, callData);
  
<span class="line-modified">!     // If jsFunction is not actually a function and this is an EventListener, see if it implements callback interface.</span>
      if (callType == CallType::None) {
<span class="line-modified">!         if (m_isAttribute)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         handleEventFunction = jsFunction-&gt;get(lexicalGlobalObject, Identifier::fromString(vm, &quot;handleEvent&quot;));</span>
          if (UNLIKELY(scope.exception())) {
              auto* exception = scope.exception();
              scope.clearException();
              event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">!             reportException(lexicalGlobalObject, exception);</span>
              return;
          }
          callType = getCallData(vm, handleEventFunction, callData);
<span class="line-added">+         if (callType == CallType::None) {</span>
<span class="line-added">+             event.target()-&gt;uncaughtExceptionInEventHandler();</span>
<span class="line-added">+             reportException(lexicalGlobalObject, createTypeError(lexicalGlobalObject, &quot;&#39;handleEvent&#39; property of event listener should be callable&quot;_s));</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
      }
  
      Ref&lt;JSEventListener&gt; protectedThis(*this);
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(toJS(lexicalGlobalObject, globalObject, &amp;event));</span>
      ASSERT(!args.hasOverflowed());
  
      Event* savedEvent = globalObject-&gt;currentEvent();
  
      // window.event should not be set when the target is inside a shadow tree, as per the DOM specification.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,17 ***</span>
      if (!isTargetInsideShadowTree)
          globalObject-&gt;setCurrentEvent(&amp;event);
  
      VMEntryScope entryScope(vm, vm.entryScope ? vm.entryScope-&gt;globalObject() : globalObject);
  
<span class="line-modified">!     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionCall(&amp;scriptExecutionContext, callType, callData);</span>
  
<span class="line-modified">!     JSValue thisValue = handleEventFunction == jsFunction ? toJS(exec, globalObject, event.currentTarget()) : jsFunction;</span>
      NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">!     JSValue retval = JSExecState::profiledCall(exec, JSC::ProfilingReason::Other, handleEventFunction, callType, callData, thisValue, args, exception);</span>
  
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(cookie, &amp;scriptExecutionContext);</span>
  
      globalObject-&gt;setCurrentEvent(savedEvent);
  
      if (is&lt;WorkerGlobalScope&gt;(scriptExecutionContext)) {
          auto&amp; scriptController = *downcast&lt;WorkerGlobalScope&gt;(scriptExecutionContext).script();
<span class="line-new-header">--- 171,17 ---</span>
      if (!isTargetInsideShadowTree)
          globalObject-&gt;setCurrentEvent(&amp;event);
  
      VMEntryScope entryScope(vm, vm.entryScope ? vm.entryScope-&gt;globalObject() : globalObject);
  
<span class="line-modified">!     JSExecState::instrumentFunctionCall(&amp;scriptExecutionContext, callType, callData);</span>
  
<span class="line-modified">!     JSValue thisValue = handleEventFunction == jsFunction ? toJS(lexicalGlobalObject, globalObject, event.currentTarget()) : jsFunction;</span>
      NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">!     JSValue retval = JSExecState::profiledCall(lexicalGlobalObject, JSC::ProfilingReason::Other, handleEventFunction, callType, callData, thisValue, args, exception);</span>
  
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(&amp;scriptExecutionContext);</span>
  
      globalObject-&gt;setCurrentEvent(savedEvent);
  
      if (is&lt;WorkerGlobalScope&gt;(scriptExecutionContext)) {
          auto&amp; scriptController = *downcast&lt;WorkerGlobalScope&gt;(scriptExecutionContext).script();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,11 ***</span>
              scriptController.forbidExecution();
      }
  
      if (exception) {
          event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">!         reportException(exec, exception);</span>
          return;
      }
  
      if (!m_isAttribute) {
          // This is an EventListener and there is therefore no need for any return value handling.
<span class="line-new-header">--- 190,11 ---</span>
              scriptController.forbidExecution();
      }
  
      if (exception) {
          event.target()-&gt;uncaughtExceptionInEventHandler();
<span class="line-modified">!         reportException(lexicalGlobalObject, exception);</span>
          return;
      }
  
      if (!m_isAttribute) {
          // This is an EventListener and there is therefore no need for any return value handling.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,11 ***</span>
      // Do return value handling for event handlers (https://html.spec.whatwg.org/#the-event-handler-processing-algorithm).
  
      if (event.type() == eventNames().beforeunloadEvent) {
          // This is a OnBeforeUnloadEventHandler, and therefore the return value must be coerced into a String.
          if (is&lt;BeforeUnloadEvent&gt;(event))
<span class="line-modified">!             handleBeforeUnloadEventReturnValue(downcast&lt;BeforeUnloadEvent&gt;(event), convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*exec, retval));</span>
          return;
      }
  
      if (retval.isFalse())
          event.preventDefault();
<span class="line-new-header">--- 204,11 ---</span>
      // Do return value handling for event handlers (https://html.spec.whatwg.org/#the-event-handler-processing-algorithm).
  
      if (event.type() == eventNames().beforeunloadEvent) {
          // This is a OnBeforeUnloadEventHandler, and therefore the return value must be coerced into a String.
          if (is&lt;BeforeUnloadEvent&gt;(event))
<span class="line-modified">!             handleBeforeUnloadEventReturnValue(downcast&lt;BeforeUnloadEvent&gt;(event), convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, retval));</span>
          return;
      }
  
      if (retval.isFalse())
          event.preventDefault();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,10 ***</span>
<span class="line-new-header">--- 220,25 ---</span>
          return false;
      auto&amp; other = downcast&lt;JSEventListener&gt;(listener);
      return m_jsFunction == other.m_jsFunction &amp;&amp; m_isAttribute == other.m_isAttribute;
  }
  
<span class="line-added">+ String JSEventListener::functionName() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_wrapper || !m_jsFunction)</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; vm = isolatedWorld().vm();</span>
<span class="line-added">+     JSC::JSLockHolder lock(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, m_jsFunction.get());</span>
<span class="line-added">+     if (!handlerFunction)</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
<span class="line-added">+     return handlerFunction-&gt;name(vm);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static inline JSC::JSValue eventHandlerAttribute(EventListener* abstractListener, ScriptExecutionContext&amp; context)
  {
      if (!is&lt;JSEventListener&gt;(abstractListener))
          return jsNull();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,70 ***</span>
          return jsNull();
  
      return function;
  }
  
<span class="line-modified">! static inline RefPtr&lt;JSEventListener&gt; createEventListenerForEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSValue listener, JSC::JSObject&amp; wrapper)</span>
  {
      if (!listener.isObject())
          return nullptr;
<span class="line-modified">!     return JSEventListener::create(asObject(listener), &amp;wrapper, true, currentWorld(state));</span>
  }
  
  JSC::JSValue eventHandlerAttribute(EventTarget&amp; target, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      return eventHandlerAttribute(target.attributeEventListener(eventType, isolatedWorld), *target.scriptExecutionContext());
  }
  
<span class="line-modified">! void setEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, EventTarget&amp; target, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
<span class="line-modified">!     target.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, wrapper), currentWorld(state));</span>
  }
  
  JSC::JSValue windowEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      auto&amp; document = element.document();
      return eventHandlerAttribute(document.getWindowAttributeEventListener(eventType, isolatedWorld), document);
  }
  
<span class="line-modified">! void setWindowEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
      ASSERT(wrapper.globalObject());
<span class="line-modified">!     element.document().setWindowAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, *wrapper.globalObject()), currentWorld(state));</span>
  }
  
  JSC::JSValue windowEventHandlerAttribute(DOMWindow&amp; window, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      return eventHandlerAttribute(window, eventType, isolatedWorld);
  }
  
<span class="line-modified">! void setWindowEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, DOMWindow&amp; window, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
<span class="line-modified">!     setEventHandlerAttribute(state, wrapper, window, eventType, value);</span>
  }
  
  JSC::JSValue documentEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      auto&amp; document = element.document();
      return eventHandlerAttribute(document.attributeEventListener(eventType, isolatedWorld), document);
  }
  
<span class="line-modified">! void setDocumentEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
      ASSERT(wrapper.globalObject());
      auto&amp; document = element.document();
<span class="line-modified">!     auto* documentWrapper = JSC::jsCast&lt;JSDocument*&gt;(toJS(&amp;state, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(wrapper.globalObject()), document));</span>
      ASSERT(documentWrapper);
<span class="line-modified">!     document.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(state, value, *documentWrapper), currentWorld(state));</span>
  }
  
  JSC::JSValue documentEventHandlerAttribute(Document&amp; document, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      return eventHandlerAttribute(document, eventType, isolatedWorld);
  }
  
<span class="line-modified">! void setDocumentEventHandlerAttribute(JSC::ExecState&amp; state, JSC::JSObject&amp; wrapper, Document&amp; document, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
<span class="line-modified">!     setEventHandlerAttribute(state, wrapper, document, eventType, value);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 247,70 ---</span>
          return jsNull();
  
      return function;
  }
  
<span class="line-modified">! static inline RefPtr&lt;JSEventListener&gt; createEventListenerForEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue listener, JSC::JSObject&amp; wrapper)</span>
  {
      if (!listener.isObject())
          return nullptr;
<span class="line-modified">!     return JSEventListener::create(asObject(listener), &amp;wrapper, true, currentWorld(lexicalGlobalObject));</span>
  }
  
  JSC::JSValue eventHandlerAttribute(EventTarget&amp; target, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      return eventHandlerAttribute(target.attributeEventListener(eventType, isolatedWorld), *target.scriptExecutionContext());
  }
  
<span class="line-modified">! void setEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, EventTarget&amp; target, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
<span class="line-modified">!     target.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, wrapper), currentWorld(lexicalGlobalObject));</span>
  }
  
  JSC::JSValue windowEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      auto&amp; document = element.document();
      return eventHandlerAttribute(document.getWindowAttributeEventListener(eventType, isolatedWorld), document);
  }
  
<span class="line-modified">! void setWindowEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
      ASSERT(wrapper.globalObject());
<span class="line-modified">!     element.document().setWindowAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *wrapper.globalObject()), currentWorld(lexicalGlobalObject));</span>
  }
  
  JSC::JSValue windowEventHandlerAttribute(DOMWindow&amp; window, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      return eventHandlerAttribute(window, eventType, isolatedWorld);
  }
  
<span class="line-modified">! void setWindowEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, DOMWindow&amp; window, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
<span class="line-modified">!     setEventHandlerAttribute(lexicalGlobalObject, wrapper, window, eventType, value);</span>
  }
  
  JSC::JSValue documentEventHandlerAttribute(HTMLElement&amp; element, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      auto&amp; document = element.document();
      return eventHandlerAttribute(document.attributeEventListener(eventType, isolatedWorld), document);
  }
  
<span class="line-modified">! void setDocumentEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, HTMLElement&amp; element, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
      ASSERT(wrapper.globalObject());
      auto&amp; document = element.document();
<span class="line-modified">!     auto* documentWrapper = JSC::jsCast&lt;JSDocument*&gt;(toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(wrapper.globalObject()), document));</span>
      ASSERT(documentWrapper);
<span class="line-modified">!     document.setAttributeEventListener(eventType, createEventListenerForEventHandlerAttribute(lexicalGlobalObject, value, *documentWrapper), currentWorld(lexicalGlobalObject));</span>
  }
  
  JSC::JSValue documentEventHandlerAttribute(Document&amp; document, const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
  {
      return eventHandlerAttribute(document, eventType, isolatedWorld);
  }
  
<span class="line-modified">! void setDocumentEventHandlerAttribute(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; wrapper, Document&amp; document, const AtomString&amp; eventType, JSC::JSValue value)</span>
  {
<span class="line-modified">!     setEventHandlerAttribute(lexicalGlobalObject, wrapper, document, eventType, value);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="JSEventCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSEventListener.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateMotionElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateMotionElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateMotionElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGAnimateMotionElement.cpp
@@ -137,27 +137,28 @@
         m_animationPath = m_path;
 
     updateAnimationMode();
 }
 
-void SVGAnimateMotionElement::resetAnimatedType()
+void SVGAnimateMotionElement::startAnimation()
 {
     if (!hasValidAttributeType())
         return;
     auto targetElement = makeRefPtr(this->targetElement());
     if (!targetElement)
         return;
     if (AffineTransform* transform = targetElement->supplementalTransform())
         transform->makeIdentity();
 }
 
-void SVGAnimateMotionElement::clearAnimatedType(SVGElement* targetElement)
+void SVGAnimateMotionElement::stopAnimation(SVGElement* targetElement)
 {
     if (!targetElement)
         return;
     if (AffineTransform* transform = targetElement->supplementalTransform())
         transform->makeIdentity();
+    applyResultsToTarget();
 }
 
 bool SVGAnimateMotionElement::calculateToAtEndOfDurationValue(const String& toAtEndOfDurationString)
 {
     parsePoint(toAtEndOfDurationString, m_toPointAtEndOfDuration);
@@ -187,14 +188,13 @@
 
 void SVGAnimateMotionElement::buildTransformForProgress(AffineTransform* transform, float percentage)
 {
     ASSERT(!m_animationPath.isEmpty());
 
-    bool success = false;
     float positionOnPath = m_animationPath.length() * percentage;
-    auto traversalState(m_animationPath.traversalStateAtLength(positionOnPath, success));
-    if (!success)
+    auto traversalState(m_animationPath.traversalStateAtLength(positionOnPath));
+    if (!traversalState.success())
         return;
 
     FloatPoint position = traversalState.current();
     float angle = traversalState.normalAngle();
 
@@ -205,22 +205,20 @@
     if (rotateMode == RotateAutoReverse)
         angle += 180;
     transform->rotate(angle);
 }
 
-void SVGAnimateMotionElement::calculateAnimatedValue(float percentage, unsigned repeatCount, SVGSMILElement*)
+void SVGAnimateMotionElement::calculateAnimatedValue(float percentage, unsigned repeatCount)
 {
     auto targetElement = makeRefPtr(this->targetElement());
     if (!targetElement)
         return;
+
     AffineTransform* transform = targetElement->supplementalTransform();
     if (!transform)
         return;
 
-    if (RenderObject* targetRenderer = targetElement->renderer())
-        targetRenderer->setNeedsTransformUpdate();
-
     if (!isAdditive())
         transform->makeIdentity();
 
     if (animationMode() != AnimationMode::Path) {
         FloatPoint toPointAtEndOfDuration = m_toPoint;
@@ -251,12 +249,14 @@
     // We accumulate to the target element transform list so there is not much to do here.
     auto targetElement = makeRefPtr(this->targetElement());
     if (!targetElement)
         return;
 
-    if (RenderElement* renderer = targetElement->renderer())
+    if (RenderElement* renderer = targetElement->renderer()) {
+        renderer->setNeedsTransformUpdate();
         RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
+    }
 
     AffineTransform* targetSupplementalTransform = targetElement->supplementalTransform();
     if (!targetSupplementalTransform)
         return;
 
@@ -280,11 +280,11 @@
     if (!parsePoint(fromString, from))
         return { };
     if (!parsePoint(toString, to))
         return { };
     FloatSize diff = to - from;
-    return sqrtf(diff.width() * diff.width() + diff.height() * diff.height());
+    return std::hypot(diff.width(), diff.height());
 }
 
 void SVGAnimateMotionElement::updateAnimationMode()
 {
     if (!m_animationPath.isEmpty())

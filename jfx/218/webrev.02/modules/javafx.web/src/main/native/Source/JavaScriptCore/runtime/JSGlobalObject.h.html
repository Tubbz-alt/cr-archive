<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   3  *  Copyright (C) 2007-2019 Apple Inc. All rights reserved.
   4  *
   5  *  This library is free software; you can redistribute it and/or
   6  *  modify it under the terms of the GNU Library General Public
   7  *  License as published by the Free Software Foundation; either
   8  *  version 2 of the License, or (at your option) any later version.
   9  *
  10  *  This library is distributed in the hope that it will be useful,
  11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  *  Library General Public License for more details.
  14  *
  15  *  You should have received a copy of the GNU Library General Public License
  16  *  along with this library; see the file COPYING.LIB.  If not, write to
  17  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  *  Boston, MA 02110-1301, USA.
  19  *
  20  */
  21 
  22 #pragma once
  23 
  24 #include &quot;ArrayAllocationProfile.h&quot;
  25 #include &quot;ArrayBufferSharingMode.h&quot;
  26 #include &quot;BigIntPrototype.h&quot;
  27 #include &quot;BooleanPrototype.h&quot;
  28 #include &quot;ErrorType.h&quot;
  29 #include &quot;ExceptionHelpers.h&quot;
  30 #include &quot;GetVM.h&quot;
  31 #include &quot;InternalFunction.h&quot;
  32 #include &quot;JSArray.h&quot;
  33 #include &quot;JSArrayBufferPrototype.h&quot;
  34 #include &quot;JSClassRef.h&quot;
  35 #include &quot;JSGlobalLexicalEnvironment.h&quot;
  36 #include &quot;JSPromise.h&quot;
  37 #include &quot;JSSegmentedVariableObject.h&quot;
  38 #include &quot;JSWeakObjectMapRefInternal.h&quot;
  39 #include &quot;LazyProperty.h&quot;
  40 #include &quot;LazyClassStructure.h&quot;
  41 #include &quot;NumberPrototype.h&quot;
  42 #include &quot;ParserModes.h&quot;
  43 #include &quot;RegExpGlobalData.h&quot;
  44 #include &quot;RuntimeFlags.h&quot;
  45 #include &quot;StringPrototype.h&quot;
  46 #include &quot;SymbolPrototype.h&quot;
  47 #include &quot;VM.h&quot;
  48 #include &quot;Watchpoint.h&quot;
  49 #include &lt;JavaScriptCore/JSBase.h&gt;
  50 #include &lt;array&gt;
  51 #include &lt;wtf/HashSet.h&gt;
  52 #include &lt;wtf/RetainPtr.h&gt;
  53 
  54 struct OpaqueJSClass;
  55 struct OpaqueJSClassContextData;
  56 OBJC_CLASS JSWrapperMap;
  57 
  58 namespace Inspector {
  59 class JSGlobalObjectInspectorController;
  60 }
  61 
  62 namespace JSC {
  63 class ArrayConstructor;
  64 class ArrayPrototype;
  65 class ArrayIteratorPrototype;
  66 class AsyncIteratorPrototype;
  67 class AsyncFunctionPrototype;
  68 class AsyncGeneratorPrototype;
  69 class AsyncGeneratorFunctionPrototype;
  70 class BooleanPrototype;
  71 class ConsoleClient;
  72 class Debugger;
  73 class ErrorConstructor;
  74 class ErrorPrototype;
  75 class EvalCodeBlock;
  76 class EvalExecutable;
  77 class FunctionConstructor;
  78 class FunctionPrototype;
  79 class GeneratorPrototype;
  80 class GeneratorFunctionPrototype;
  81 class GetterSetter;
  82 class GlobalCodeBlock;
  83 class IndirectEvalExecutable;
  84 class InputCursor;
  85 class IntlObject;
  86 class IntlCollator;
  87 class JSArrayBuffer;
  88 class JSArrayBufferPrototype;
  89 class JSCallee;
  90 class JSGlobalObjectDebuggable;
  91 class JSInternalPromise;
  92 class JSModuleLoader;
  93 class JSModuleRecord;
  94 class JSPromise;
  95 class JSPromiseConstructor;
  96 class JSPromisePrototype;
  97 class JSSharedArrayBuffer;
  98 class JSSharedArrayBufferPrototype;
  99 class JSTypedArrayViewConstructor;
 100 class JSTypedArrayViewPrototype;
 101 class DirectEvalExecutable;
 102 class LLIntOffsetsExtractor;
 103 class MapPrototype;
 104 class Microtask;
 105 class ModuleLoader;
 106 class ModuleProgramExecutable;
 107 class NativeErrorConstructorBase;
 108 class NullGetterFunction;
 109 class NullSetterFunction;
 110 class ObjectConstructor;
 111 class ProgramCodeBlock;
 112 class ProgramExecutable;
 113 class RegExpConstructor;
 114 class RegExpPrototype;
 115 class SetPrototype;
 116 class SourceCode;
 117 class SourceOrigin;
 118 class UnlinkedModuleProgramCodeBlock;
 119 class VariableEnvironment;
 120 struct ActivationStackNode;
 121 struct HashTable;
 122 enum class LinkTimeConstant : int32_t;
 123 
 124 #ifdef JSC_GLIB_API_ENABLED
 125 class WrapperMap;
 126 #endif
 127 
 128 template&lt;typename Watchpoint&gt; class ObjectPropertyChangeAdaptiveWatchpoint;
 129 
 130 constexpr bool typeExposedByDefault = true;
 131 
 132 #define DEFINE_STANDARD_BUILTIN(macro, upperName, lowerName) macro(upperName, lowerName, lowerName, JS ## upperName, upperName, object, typeExposedByDefault)
 133 
 134 #define FOR_EACH_SIMPLE_BUILTIN_TYPE_WITH_CONSTRUCTOR(macro) \
 135     macro(String, string, stringObject, StringObject, String, object, typeExposedByDefault) \
 136     macro(JSPromise, promise, promise, JSPromise, Promise, object, typeExposedByDefault) \
 137     macro(BigInt, bigInt, bigIntObject, BigIntObject, BigInt, object, Options::useBigInt()) \
 138     macro(WeakObjectRef, weakObjectRef, weakObjectRef, JSWeakObjectRef, WeakRef, object, Options::useWeakRefs()) \
 139 
 140 #define FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(macro) \
 141     macro(StringIterator, stringIterator, stringIterator, JSStringIterator, StringIterator, iterator, typeExposedByDefault) \
 142 
 143 #define FOR_EACH_SIMPLE_BUILTIN_TYPE(macro) \
 144     FOR_EACH_SIMPLE_BUILTIN_TYPE_WITH_CONSTRUCTOR(macro) \
 145     macro(JSInternalPromise, internalPromise, internalPromise, JSInternalPromise, InternalPromise, object, typeExposedByDefault) \
 146 
 147 #define FOR_EACH_LAZY_BUILTIN_TYPE_WITH_DECLARATION(macro) \
 148     macro(Boolean, boolean, booleanObject, BooleanObject, Boolean, object, typeExposedByDefault) \
 149     macro(Date, date, date, DateInstance, Date, object, typeExposedByDefault) \
 150     macro(Error, error, error, ErrorInstance, Error, object, typeExposedByDefault) \
 151     macro(Map, map, map, JSMap, Map, object, typeExposedByDefault) \
 152     macro(Number, number, numberObject, NumberObject, Number, object, typeExposedByDefault) \
 153     macro(Set, set, set, JSSet, Set, object, typeExposedByDefault) \
 154     macro(Symbol, symbol, symbolObject, SymbolObject, Symbol, object, typeExposedByDefault) \
 155     DEFINE_STANDARD_BUILTIN(macro, WeakMap, weakMap) \
 156     DEFINE_STANDARD_BUILTIN(macro, WeakSet, weakSet) \
 157 
 158 #define FOR_EACH_LAZY_BUILTIN_TYPE(macro) \
 159     FOR_EACH_LAZY_BUILTIN_TYPE_WITH_DECLARATION(macro) \
 160     macro(JSArrayBuffer, arrayBuffer, arrayBuffer, JSArrayBuffer, ArrayBuffer, object, typeExposedByDefault) \
 161 
 162 #if ENABLE(WEBASSEMBLY)
 163 #define FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(macro) \
 164     macro(WebAssemblyCompileError, webAssemblyCompileError, webAssemblyCompileError, JSWebAssemblyCompileError, CompileError, error, typeExposedByDefault) \
 165     macro(WebAssemblyGlobal,       webAssemblyGlobal,       webAssemblyGlobal,       JSWebAssemblyGlobal,       Global,       object, typeExposedByDefault) \
 166     macro(WebAssemblyInstance,     webAssemblyInstance,     webAssemblyInstance,     JSWebAssemblyInstance,     Instance,     object, typeExposedByDefault) \
 167     macro(WebAssemblyLinkError,    webAssemblyLinkError,    webAssemblyLinkError,    JSWebAssemblyLinkError,    LinkError,    error, typeExposedByDefault) \
 168     macro(WebAssemblyMemory,       webAssemblyMemory,       webAssemblyMemory,       JSWebAssemblyMemory,       Memory,       object, typeExposedByDefault) \
 169     macro(WebAssemblyModule,       webAssemblyModule,       webAssemblyModule,       JSWebAssemblyModule,       Module,       object, typeExposedByDefault) \
 170     macro(WebAssemblyRuntimeError, webAssemblyRuntimeError, webAssemblyRuntimeError, JSWebAssemblyRuntimeError, RuntimeError, error, typeExposedByDefault) \
 171     macro(WebAssemblyTable,        webAssemblyTable,        webAssemblyTable,        JSWebAssemblyTable,        Table,        object, typeExposedByDefault)
 172 #else
 173 #define FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(macro)
 174 #endif // ENABLE(WEBASSEMBLY)
 175 
 176 #define DECLARE_SIMPLE_BUILTIN_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase, featureFlag) \
 177     class JS ## capitalName; \
 178     class capitalName ## Prototype; \
 179     class capitalName ## Constructor;
 180 
 181 class IteratorPrototype;
 182 FOR_EACH_SIMPLE_BUILTIN_TYPE(DECLARE_SIMPLE_BUILTIN_TYPE)
 183 FOR_EACH_LAZY_BUILTIN_TYPE_WITH_DECLARATION(DECLARE_SIMPLE_BUILTIN_TYPE)
 184 FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(DECLARE_SIMPLE_BUILTIN_TYPE)
 185 FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DECLARE_SIMPLE_BUILTIN_TYPE)
 186 
 187 #undef DECLARE_SIMPLE_BUILTIN_TYPE
 188 
 189 enum class JSPromiseRejectionOperation : unsigned {
 190     Reject, // When a promise is rejected without any handlers.
 191     Handle, // When a handler is added to a rejected promise for the first time.
 192 };
 193 
 194 struct GlobalObjectMethodTable {
 195     typedef bool (*SupportsRichSourceInfoFunctionPtr)(const JSGlobalObject*);
 196     SupportsRichSourceInfoFunctionPtr supportsRichSourceInfo;
 197 
 198     typedef bool (*ShouldInterruptScriptFunctionPtr)(const JSGlobalObject*);
 199     ShouldInterruptScriptFunctionPtr shouldInterruptScript;
 200 
 201     typedef RuntimeFlags (*JavaScriptRuntimeFlagsFunctionPtr)(const JSGlobalObject*);
 202     JavaScriptRuntimeFlagsFunctionPtr javaScriptRuntimeFlags;
 203 
 204     typedef void (*QueueTaskToEventLoopFunctionPtr)(JSGlobalObject&amp;, Ref&lt;Microtask&gt;&amp;&amp;);
 205     QueueTaskToEventLoopFunctionPtr queueTaskToEventLoop;
 206 
 207     typedef bool (*ShouldInterruptScriptBeforeTimeoutPtr)(const JSGlobalObject*);
 208     ShouldInterruptScriptBeforeTimeoutPtr shouldInterruptScriptBeforeTimeout;
 209 
 210     typedef JSInternalPromise* (*ModuleLoaderImportModulePtr)(JSGlobalObject*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);
 211     ModuleLoaderImportModulePtr moduleLoaderImportModule;
 212 
 213     typedef Identifier (*ModuleLoaderResolvePtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);
 214     ModuleLoaderResolvePtr moduleLoaderResolve;
 215 
 216     typedef JSInternalPromise* (*ModuleLoaderFetchPtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);
 217     ModuleLoaderFetchPtr moduleLoaderFetch;
 218 
 219     typedef JSObject* (*ModuleLoaderCreateImportMetaPropertiesPtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 220     ModuleLoaderCreateImportMetaPropertiesPtr moduleLoaderCreateImportMetaProperties;
 221 
 222     typedef JSValue (*ModuleLoaderEvaluatePtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);
 223     ModuleLoaderEvaluatePtr moduleLoaderEvaluate;
 224 
 225     typedef void (*PromiseRejectionTrackerPtr)(JSGlobalObject*, JSPromise*, JSPromiseRejectionOperation);
 226     PromiseRejectionTrackerPtr promiseRejectionTracker;
 227 
 228     typedef String (*DefaultLanguageFunctionPtr)();
 229     DefaultLanguageFunctionPtr defaultLanguage;
 230 
 231     typedef void (*CompileStreamingPtr)(JSGlobalObject*, JSPromise*, JSValue);
 232     CompileStreamingPtr compileStreaming;
 233 
 234     typedef void (*InstantiateStreamingPtr)(JSGlobalObject*, JSPromise*, JSValue, JSObject*);
 235     InstantiateStreamingPtr instantiateStreaming;
 236 };
 237 
 238 class JSGlobalObject : public JSSegmentedVariableObject {
 239 private:
 240     typedef HashSet&lt;RefPtr&lt;OpaqueJSWeakObjectMap&gt;&gt; WeakMapSet;
 241     typedef HashMap&lt;OpaqueJSClass*, std::unique_ptr&lt;OpaqueJSClassContextData&gt;&gt; OpaqueJSClassDataMap;
 242 
 243     struct JSGlobalObjectRareData {
 244         WTF_MAKE_FAST_ALLOCATED;
 245     public:
 246         JSGlobalObjectRareData()
 247             : profileGroup(0)
 248         {
 249         }
 250 
 251         WeakMapSet weakMaps;
 252         unsigned profileGroup;
 253 
 254         OpaqueJSClassDataMap opaqueJSClassData;
 255     };
 256 
 257     // m_vm must be a pointer (instead of a reference) because the JSCLLIntOffsetsExtractor
 258     // cannot handle it being a reference.
 259     VM* m_vm;
 260 
 261 // Our hashtable code-generator tries to access these properties, so we make them public.
 262 // However, we&#39;d like it better if they could be protected.
 263 public:
 264     template&lt;typename T&gt; using Initializer = typename LazyProperty&lt;JSGlobalObject, T&gt;::Initializer;
 265 
 266     Register m_deprecatedCallFrameForDebugger[CallFrame::headerSizeInRegisters];
 267 
 268     WriteBarrier&lt;JSObject&gt; m_globalThis;
 269 
 270     WriteBarrier&lt;JSGlobalLexicalEnvironment&gt; m_globalLexicalEnvironment;
 271     WriteBarrier&lt;JSScope&gt; m_globalScopeExtension;
 272     WriteBarrier&lt;JSCallee&gt; m_globalCallee;
 273     WriteBarrier&lt;JSCallee&gt; m_stackOverflowFrameCallee;
 274 
 275     LazyClassStructure m_evalErrorStructure;
 276     LazyClassStructure m_rangeErrorStructure;
 277     LazyClassStructure m_referenceErrorStructure;
 278     LazyClassStructure m_syntaxErrorStructure;
 279     LazyClassStructure m_typeErrorStructure;
 280     LazyClassStructure m_URIErrorStructure;
 281 
 282     WriteBarrier&lt;ObjectConstructor&gt; m_objectConstructor;
 283     WriteBarrier&lt;ArrayConstructor&gt; m_arrayConstructor;
 284     WriteBarrier&lt;RegExpConstructor&gt; m_regExpConstructor;
 285     WriteBarrier&lt;FunctionConstructor&gt; m_functionConstructor;
 286     WriteBarrier&lt;JSPromiseConstructor&gt; m_promiseConstructor;
 287     WriteBarrier&lt;JSInternalPromiseConstructor&gt; m_internalPromiseConstructor;
 288 
 289 #if ENABLE(INTL)
 290     LazyProperty&lt;JSGlobalObject, IntlCollator&gt; m_defaultCollator;
 291     LazyProperty&lt;JSGlobalObject, Structure&gt; m_collatorStructure;
 292     LazyProperty&lt;JSGlobalObject, Structure&gt; m_numberFormatStructure;
 293     LazyProperty&lt;JSGlobalObject, Structure&gt; m_dateTimeFormatStructure;
 294     LazyProperty&lt;JSGlobalObject, Structure&gt; m_pluralRulesStructure;
 295 #endif
 296     WriteBarrier&lt;NullGetterFunction&gt; m_nullGetterFunction;
 297     WriteBarrier&lt;NullSetterFunction&gt; m_nullSetterFunction;
 298 
 299     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_parseIntFunction;
 300     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_parseFloatFunction;
 301 
 302     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoToStringFunction;
 303     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoValuesFunction;
 304     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_evalFunction;
 305     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_iteratorProtocolFunction;
 306     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_promiseResolveFunction;
 307     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_numberProtoToStringFunction;
 308     WriteBarrier&lt;JSFunction&gt; m_objectProtoValueOfFunction;
 309     WriteBarrier&lt;JSFunction&gt; m_functionProtoHasInstanceSymbolFunction;
 310     LazyProperty&lt;JSGlobalObject, GetterSetter&gt; m_throwTypeErrorGetterSetter;
 311     WriteBarrier&lt;JSObject&gt; m_regExpProtoSymbolReplace;
 312     WriteBarrier&lt;GetterSetter&gt; m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter;
 313 
 314     LazyProperty&lt;JSGlobalObject, JSModuleLoader&gt; m_moduleLoader;
 315 
 316     WriteBarrier&lt;ObjectPrototype&gt; m_objectPrototype;
 317     WriteBarrier&lt;FunctionPrototype&gt; m_functionPrototype;
 318     WriteBarrier&lt;ArrayPrototype&gt; m_arrayPrototype;
 319     WriteBarrier&lt;RegExpPrototype&gt; m_regExpPrototype;
 320     WriteBarrier&lt;IteratorPrototype&gt; m_iteratorPrototype;
 321     WriteBarrier&lt;AsyncIteratorPrototype&gt; m_asyncIteratorPrototype;
 322     WriteBarrier&lt;GeneratorFunctionPrototype&gt; m_generatorFunctionPrototype;
 323     WriteBarrier&lt;GeneratorPrototype&gt; m_generatorPrototype;
 324     WriteBarrier&lt;AsyncGeneratorPrototype&gt; m_asyncGeneratorPrototype;
 325     WriteBarrier&lt;ArrayIteratorPrototype&gt; m_arrayIteratorPrototype;
 326 
 327     LazyProperty&lt;JSGlobalObject, Structure&gt; m_debuggerScopeStructure;
 328     LazyProperty&lt;JSGlobalObject, Structure&gt; m_withScopeStructure;
 329     LazyProperty&lt;JSGlobalObject, Structure&gt; m_strictEvalActivationStructure;
 330     WriteBarrier&lt;Structure&gt; m_lexicalEnvironmentStructure;
 331     LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleEnvironmentStructure;
 332     WriteBarrier&lt;Structure&gt; m_directArgumentsStructure;
 333     WriteBarrier&lt;Structure&gt; m_scopedArgumentsStructure;
 334     WriteBarrier&lt;Structure&gt; m_clonedArgumentsStructure;
 335 
 336     WriteBarrier&lt;Structure&gt; m_objectStructureForObjectConstructor;
 337 
 338     // Lists the actual structures used for having these particular indexing shapes.
 339     WriteBarrier&lt;Structure&gt; m_originalArrayStructureForIndexingShape[NumberOfArrayIndexingModes];
 340     // Lists the structures we should use during allocation for these particular indexing shapes.
 341     // These structures will differ from the originals list above when we are having a bad time.
 342     WriteBarrier&lt;Structure&gt; m_arrayStructureForIndexingShapeDuringAllocation[NumberOfArrayIndexingModes];
 343 
 344     LazyProperty&lt;JSGlobalObject, Structure&gt; m_callbackConstructorStructure;
 345     LazyProperty&lt;JSGlobalObject, Structure&gt; m_callbackFunctionStructure;
 346     LazyProperty&lt;JSGlobalObject, Structure&gt; m_callbackObjectStructure;
 347 #if JSC_OBJC_API_ENABLED
 348     LazyProperty&lt;JSGlobalObject, Structure&gt; m_objcCallbackFunctionStructure;
 349     LazyProperty&lt;JSGlobalObject, Structure&gt; m_objcWrapperObjectStructure;
 350 #endif
 351 #ifdef JSC_GLIB_API_ENABLED
 352     LazyProperty&lt;JSGlobalObject, Structure&gt; m_glibCallbackFunctionStructure;
 353     LazyProperty&lt;JSGlobalObject, Structure&gt; m_glibWrapperObjectStructure;
 354 #endif
 355     WriteBarrier&lt;Structure&gt; m_nullPrototypeObjectStructure;
 356     WriteBarrier&lt;Structure&gt; m_calleeStructure;
 357 
 358     WriteBarrier&lt;Structure&gt; m_hostFunctionStructure;
 359 
 360     struct FunctionStructures {
 361         WriteBarrier&lt;Structure&gt; arrowFunctionStructure;
 362         WriteBarrier&lt;Structure&gt; sloppyFunctionStructure;
 363         WriteBarrier&lt;Structure&gt; strictFunctionStructure;
 364     };
 365     FunctionStructures m_builtinFunctions;
 366     FunctionStructures m_ordinaryFunctions;
 367 
 368     LazyProperty&lt;JSGlobalObject, Structure&gt; m_boundFunctionStructure;
 369     LazyProperty&lt;JSGlobalObject, Structure&gt; m_customGetterSetterFunctionStructure;
 370     LazyProperty&lt;JSGlobalObject, Structure&gt; m_nativeStdFunctionStructure;
 371     PropertyOffset m_functionNameOffset;
 372     WriteBarrier&lt;Structure&gt; m_regExpStructure;
 373     WriteBarrier&lt;AsyncFunctionPrototype&gt; m_asyncFunctionPrototype;
 374     WriteBarrier&lt;AsyncGeneratorFunctionPrototype&gt; m_asyncGeneratorFunctionPrototype;
 375     WriteBarrier&lt;Structure&gt; m_asyncFunctionStructure;
 376     WriteBarrier&lt;Structure&gt; m_asyncGeneratorFunctionStructure;
 377     WriteBarrier&lt;Structure&gt; m_generatorFunctionStructure;
 378     WriteBarrier&lt;Structure&gt; m_generatorStructure;
 379     WriteBarrier&lt;Structure&gt; m_asyncGeneratorStructure;
 380     WriteBarrier&lt;Structure&gt; m_arrayIteratorStructure;
 381     LazyProperty&lt;JSGlobalObject, Structure&gt; m_iteratorResultObjectStructure;
 382     WriteBarrier&lt;Structure&gt; m_regExpMatchesArrayStructure;
 383     LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleRecordStructure;
 384     LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleNamespaceObjectStructure;
 385     LazyProperty&lt;JSGlobalObject, Structure&gt; m_proxyObjectStructure;
 386     LazyProperty&lt;JSGlobalObject, Structure&gt; m_callableProxyObjectStructure;
 387     LazyProperty&lt;JSGlobalObject, Structure&gt; m_proxyRevokeStructure;
 388 #if ENABLE(SHARED_ARRAY_BUFFER)
 389     WriteBarrier&lt;JSArrayBufferPrototype&gt; m_sharedArrayBufferPrototype;
 390     WriteBarrier&lt;Structure&gt; m_sharedArrayBufferStructure;
 391 #endif
 392 
 393 #define DEFINE_STORAGE_FOR_SIMPLE_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase, featureFlag) \
 394     WriteBarrier&lt;capitalName ## Prototype&gt; m_ ## lowerName ## Prototype; \
 395     WriteBarrier&lt;Structure&gt; m_ ## properName ## Structure;
 396 
 397 #define DEFINE_STORAGE_FOR_LAZY_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase, featureFlag) \
 398     LazyClassStructure m_ ## properName ## Structure;
 399 
 400     FOR_EACH_SIMPLE_BUILTIN_TYPE(DEFINE_STORAGE_FOR_SIMPLE_TYPE)
 401     FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(DEFINE_STORAGE_FOR_SIMPLE_TYPE)
 402 
 403 #if ENABLE(WEBASSEMBLY)
 404     LazyProperty&lt;JSGlobalObject, Structure&gt; m_webAssemblyModuleRecordStructure;
 405     LazyProperty&lt;JSGlobalObject, Structure&gt; m_webAssemblyFunctionStructure;
 406     LazyProperty&lt;JSGlobalObject, Structure&gt; m_jsToWasmICCalleeStructure;
 407     LazyProperty&lt;JSGlobalObject, Structure&gt; m_webAssemblyWrapperFunctionStructure;
 408     FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DEFINE_STORAGE_FOR_LAZY_TYPE)
 409 #endif // ENABLE(WEBASSEMBLY)
 410 
 411     FOR_EACH_LAZY_BUILTIN_TYPE(DEFINE_STORAGE_FOR_LAZY_TYPE)
 412 
 413 #undef DEFINE_STORAGE_FOR_SIMPLE_TYPE
 414 #undef DEFINE_STORAGE_FOR_LAZY_TYPE
 415 
 416     WriteBarrier&lt;GetterSetter&gt; m_speciesGetterSetter;
 417 
 418     LazyProperty&lt;JSGlobalObject, JSTypedArrayViewPrototype&gt; m_typedArrayProto;
 419     LazyProperty&lt;JSGlobalObject, JSTypedArrayViewConstructor&gt; m_typedArraySuperConstructor;
 420 
 421 #define DECLARE_TYPED_ARRAY_TYPE_STRUCTURE(name) LazyClassStructure m_typedArray ## name;
 422     FOR_EACH_TYPED_ARRAY_TYPE(DECLARE_TYPED_ARRAY_TYPE_STRUCTURE)
 423 #undef DECLARE_TYPED_ARRAY_TYPE_STRUCTURE
 424 
 425     Vector&lt;LazyProperty&lt;JSGlobalObject, JSCell&gt;&gt; m_linkTimeConstants;
 426 
 427     String m_name;
 428 
 429     Strong&lt;JSObject&gt; m_unhandledRejectionCallback;
 430 
 431     Debugger* m_debugger;
 432 
 433 #if ENABLE(REMOTE_INSPECTOR)
 434     std::unique_ptr&lt;Inspector::JSGlobalObjectInspectorController&gt; m_inspectorController;
 435     std::unique_ptr&lt;JSGlobalObjectDebuggable&gt; m_inspectorDebuggable;
 436 #endif
 437 
 438     RefPtr&lt;WatchpointSet&gt; m_masqueradesAsUndefinedWatchpoint;
 439     RefPtr&lt;WatchpointSet&gt; m_havingABadTimeWatchpoint;
 440     RefPtr&lt;WatchpointSet&gt; m_varInjectionWatchpoint;
 441 
 442     std::unique_ptr&lt;JSGlobalObjectRareData&gt; m_rareData;
 443 
 444     WeakRandom m_weakRandom;
 445     RegExpGlobalData m_regExpGlobalData;
 446 
 447     JSCallee* stackOverflowFrameCallee() const { return m_stackOverflowFrameCallee.get(); }
 448 
 449     InlineWatchpointSet&amp; arrayIteratorProtocolWatchpointSet() { return m_arrayIteratorProtocolWatchpointSet; }
 450     InlineWatchpointSet&amp; mapIteratorProtocolWatchpointSet() { return m_mapIteratorProtocolWatchpointSet; }
 451     InlineWatchpointSet&amp; setIteratorProtocolWatchpointSet() { return m_setIteratorProtocolWatchpointSet; }
 452     InlineWatchpointSet&amp; stringIteratorProtocolWatchpointSet() { return m_stringIteratorProtocolWatchpointSet; }
 453     InlineWatchpointSet&amp; mapSetWatchpointSet() { return m_mapSetWatchpointSet; }
 454     InlineWatchpointSet&amp; setAddWatchpointSet() { return m_setAddWatchpointSet; }
 455     InlineWatchpointSet&amp; arraySpeciesWatchpointSet() { return m_arraySpeciesWatchpointSet; }
 456     InlineWatchpointSet&amp; arrayJoinWatchpointSet() { return m_arrayJoinWatchpointSet; }
 457     InlineWatchpointSet&amp; numberToStringWatchpointSet()
 458     {
 459         RELEASE_ASSERT(VM::canUseJIT());
 460         return m_numberToStringWatchpointSet;
 461     }
 462     // If this hasn&#39;t been invalidated, it means the array iterator protocol
 463     // is not observable to user code yet.
 464     InlineWatchpointSet m_arrayIteratorProtocolWatchpointSet;
 465     InlineWatchpointSet m_mapIteratorProtocolWatchpointSet;
 466     InlineWatchpointSet m_setIteratorProtocolWatchpointSet;
 467     InlineWatchpointSet m_stringIteratorProtocolWatchpointSet;
 468     InlineWatchpointSet m_mapSetWatchpointSet;
 469     InlineWatchpointSet m_setAddWatchpointSet;
 470     InlineWatchpointSet m_arraySpeciesWatchpointSet;
 471     InlineWatchpointSet m_arrayJoinWatchpointSet;
 472     InlineWatchpointSet m_numberToStringWatchpointSet;
 473     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_arrayConstructorSpeciesWatchpoint;
 474     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_arrayPrototypeConstructorWatchpoint;
 475     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_arrayPrototypeSymbolIteratorWatchpoint;
 476     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_arrayPrototypeJoinWatchpoint;
 477     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_arrayIteratorPrototypeNext;
 478     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_mapPrototypeSymbolIteratorWatchpoint;
 479     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_mapIteratorPrototypeNextWatchpoint;
 480     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_setPrototypeSymbolIteratorWatchpoint;
 481     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_setIteratorPrototypeNextWatchpoint;
 482     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_stringPrototypeSymbolIteratorWatchpoint;
 483     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_stringIteratorPrototypeNextWatchpoint;
 484     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_mapPrototypeSetWatchpoint;
 485     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_setPrototypeAddWatchpoint;
 486     std::unique_ptr&lt;ObjectPropertyChangeAdaptiveWatchpoint&lt;InlineWatchpointSet&gt;&gt; m_numberPrototypeToStringWatchpoint;
 487 
 488     bool isArrayPrototypeIteratorProtocolFastAndNonObservable();
 489     bool isMapPrototypeIteratorProtocolFastAndNonObservable();
 490     bool isSetPrototypeIteratorProtocolFastAndNonObservable();
 491     bool isStringPrototypeIteratorProtocolFastAndNonObservable();
 492     bool isMapPrototypeSetFastAndNonObservable();
 493     bool isSetPrototypeAddFastAndNonObservable();
 494 
 495 #if ENABLE(DFG_JIT)
 496     using ReferencedGlobalPropertyWatchpointSets = HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, Ref&lt;WatchpointSet&gt;, IdentifierRepHash&gt;;
 497     ReferencedGlobalPropertyWatchpointSets m_referencedGlobalPropertyWatchpointSets;
 498     ConcurrentJSLock m_referencedGlobalPropertyWatchpointSetsLock;
 499 #endif
 500 
 501     bool m_evalEnabled { true };
 502     bool m_webAssemblyEnabled { true };
 503     unsigned m_globalLexicalBindingEpoch { 1 };
 504     String m_evalDisabledErrorMessage;
 505     String m_webAssemblyDisabledErrorMessage;
 506     RuntimeFlags m_runtimeFlags;
 507     ConsoleClient* m_consoleClient { nullptr };
 508     Optional&lt;unsigned&gt; m_stackTraceLimit;
 509 
 510 #if ASSERT_ENABLED
 511     const JSGlobalObject* m_globalObjectAtDebuggerEntry { nullptr };
 512 #endif
 513 
 514     static JS_EXPORT_PRIVATE const GlobalObjectMethodTable s_globalObjectMethodTable;
 515     const GlobalObjectMethodTable* m_globalObjectMethodTable;
 516 
 517     void createRareDataIfNeeded()
 518     {
 519         if (m_rareData)
 520             return;
 521         m_rareData = makeUnique&lt;JSGlobalObjectRareData&gt;();
 522     }
 523 
 524 public:
 525     using Base = JSSegmentedVariableObject;
 526     static constexpr unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable | OverridesGetOwnPropertySlot | OverridesGetPropertyNames | IsImmutablePrototypeExoticObject;
 527 
 528     static constexpr bool needsDestruction = true;
 529     template&lt;typename CellType, SubspaceAccess mode&gt;
 530     static IsoSubspace* subspaceFor(VM&amp; vm)
 531     {
 532         return vm.globalObjectSpace&lt;mode&gt;();
 533     }
 534 
 535     JS_EXPORT_PRIVATE static JSGlobalObject* create(VM&amp;, Structure*);
 536 
 537     DECLARE_EXPORT_INFO;
 538 
 539     bool hasDebugger() const;
 540     bool hasInteractiveDebugger() const;
 541     const RuntimeFlags&amp; runtimeFlags() const { return m_runtimeFlags; }
 542 
 543 #if ENABLE(DFG_JIT)
 544     WatchpointSet* getReferencedPropertyWatchpointSet(UniquedStringImpl*);
 545     WatchpointSet&amp; ensureReferencedPropertyWatchpointSet(UniquedStringImpl*);
 546 #endif
 547 
 548     Optional&lt;unsigned&gt; stackTraceLimit() const { return m_stackTraceLimit; }
 549     void setStackTraceLimit(Optional&lt;unsigned&gt; value) { m_stackTraceLimit = value; }
 550 
 551 protected:
 552     JS_EXPORT_PRIVATE explicit JSGlobalObject(VM&amp;, Structure*, const GlobalObjectMethodTable* = nullptr);
 553 
 554     JS_EXPORT_PRIVATE void finishCreation(VM&amp;);
 555 
 556     JS_EXPORT_PRIVATE void finishCreation(VM&amp;, JSObject*);
 557 
 558     void addGlobalVar(const Identifier&amp;);
 559 
 560 public:
 561     JS_EXPORT_PRIVATE ~JSGlobalObject();
 562     JS_EXPORT_PRIVATE static void destroy(JSCell*);
 563 
 564     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
 565 
 566     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);
 567     JS_EXPORT_PRIVATE static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);
 568 
 569     JS_EXPORT_PRIVATE static void defineGetter(JSObject*, JSGlobalObject*, PropertyName, JSObject* getterFunc, unsigned attributes);
 570     JS_EXPORT_PRIVATE static void defineSetter(JSObject*, JSGlobalObject*, PropertyName, JSObject* setterFunc, unsigned attributes);
 571     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);
 572 
 573     void addVar(JSGlobalObject* globalObject, const Identifier&amp; propertyName)
 574     {
 575         if (!hasOwnProperty(globalObject, propertyName))
 576             addGlobalVar(propertyName);
 577     }
 578     void addFunction(JSGlobalObject*, const Identifier&amp;);
 579 
 580     JSScope* globalScope() { return m_globalLexicalEnvironment.get(); }
 581     JSGlobalLexicalEnvironment* globalLexicalEnvironment() { return m_globalLexicalEnvironment.get(); }
 582 
 583     JSScope* globalScopeExtension() { return m_globalScopeExtension.get(); }
 584     void setGlobalScopeExtension(JSScope*);
 585     void clearGlobalScopeExtension();
 586 
 587     JSCallee* globalCallee() { return m_globalCallee.get(); }
 588 
 589     // The following accessors return pristine values, even if a script
 590     // replaces the global object&#39;s associated property.
 591 
 592     GetterSetter* speciesGetterSetter() const { return m_speciesGetterSetter.get(); }
 593 
 594     ArrayConstructor* arrayConstructor() const { return m_arrayConstructor.get(); }
 595     RegExpConstructor* regExpConstructor() const { return m_regExpConstructor.get(); }
 596     ObjectConstructor* objectConstructor() const { return m_objectConstructor.get(); }
 597     FunctionConstructor* functionConstructor() const { return m_functionConstructor.get(); }
 598     JSPromiseConstructor* promiseConstructor() const { return m_promiseConstructor.get(); }
 599     JSInternalPromiseConstructor* internalPromiseConstructor() const { return m_internalPromiseConstructor.get(); }
 600 
 601 #if ENABLE(INTL)
 602     IntlCollator* defaultCollator() const { return m_defaultCollator.get(this); }
 603 #endif
 604 
 605     NullGetterFunction* nullGetterFunction() const { return m_nullGetterFunction.get(); }
 606     NullSetterFunction* nullSetterFunction() const { return m_nullSetterFunction.get(); }
 607 
 608     JSFunction* parseIntFunction() const { return m_parseIntFunction.get(this); }
 609     JSFunction* parseFloatFunction() const { return m_parseFloatFunction.get(this); }
 610 
 611     JSFunction* evalFunction() const { return m_evalFunction.get(this); }
 612     JSFunction* throwTypeErrorFunction() const;
 613     JSFunction* arrayProtoToStringFunction() const { return m_arrayProtoToStringFunction.get(this); }
 614     JSFunction* arrayProtoValuesFunction() const { return m_arrayProtoValuesFunction.get(this); }
 615     JSFunction* iteratorProtocolFunction() const { return m_iteratorProtocolFunction.get(this); }
 616     JSFunction* newPromiseCapabilityFunction() const;
 617     JSFunction* promiseResolveFunction() const { return m_promiseResolveFunction.get(this); }
 618     JSFunction* resolvePromiseFunction() const;
 619     JSFunction* rejectPromiseFunction() const;
 620     JSFunction* promiseProtoThenFunction() const;
 621     JSFunction* objectProtoValueOfFunction() const { return m_objectProtoValueOfFunction.get(); }
 622     JSFunction* numberProtoToStringFunction() const { return m_numberProtoToStringFunction.getInitializedOnMainThread(this); }
 623     JSFunction* functionProtoHasInstanceSymbolFunction() const { return m_functionProtoHasInstanceSymbolFunction.get(); }
 624     JSFunction* regExpProtoExecFunction() const;
 625     JSObject* regExpProtoSymbolReplaceFunction() const { return m_regExpProtoSymbolReplace.get(); }
 626     GetterSetter* regExpProtoGlobalGetter() const;
 627     GetterSetter* regExpProtoUnicodeGetter() const;
 628     GetterSetter* throwTypeErrorArgumentsCalleeAndCallerGetterSetter()
 629     {
 630         return m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter.get();
 631     }
 632 
 633     JSModuleLoader* moduleLoader() const { return m_moduleLoader.get(this); }
 634 
 635     ObjectPrototype* objectPrototype() const { return m_objectPrototype.get(); }
 636     FunctionPrototype* functionPrototype() const { return m_functionPrototype.get(); }
 637     ArrayPrototype* arrayPrototype() const { return m_arrayPrototype.get(); }
 638     JSObject* booleanPrototype() const { return m_booleanObjectStructure.prototypeInitializedOnMainThread(this); }
 639     StringPrototype* stringPrototype() const { return m_stringPrototype.get(); }
 640     JSObject* numberPrototype() const { return m_numberObjectStructure.prototypeInitializedOnMainThread(this); }
 641     BigIntPrototype* bigIntPrototype() const { return m_bigIntPrototype.get(); }
 642     JSObject* datePrototype() const { return m_dateStructure.prototype(this); }
 643     JSObject* symbolPrototype() const { return m_symbolObjectStructure.prototypeInitializedOnMainThread(this); }
 644     RegExpPrototype* regExpPrototype() const { return m_regExpPrototype.get(); }
 645     JSObject* errorPrototype() const { return m_errorStructure.prototype(this); }
 646     IteratorPrototype* iteratorPrototype() const { return m_iteratorPrototype.get(); }
 647     AsyncIteratorPrototype* asyncIteratorPrototype() const { return m_asyncIteratorPrototype.get(); }
 648     GeneratorFunctionPrototype* generatorFunctionPrototype() const { return m_generatorFunctionPrototype.get(); }
 649     GeneratorPrototype* generatorPrototype() const { return m_generatorPrototype.get(); }
 650     AsyncFunctionPrototype* asyncFunctionPrototype() const { return m_asyncFunctionPrototype.get(); }
 651     ArrayIteratorPrototype* arrayIteratorPrototype() const { return m_arrayIteratorPrototype.get(); }
 652     JSObject* mapPrototype() const { return m_mapStructure.prototype(this); }
 653     // Workaround for the name conflict between JSCell::setPrototype.
 654     JSObject* jsSetPrototype() const { return m_setStructure.prototype(this); }
 655     JSPromisePrototype* promisePrototype() const { return m_promisePrototype.get(); }
 656     AsyncGeneratorPrototype* asyncGeneratorPrototype() const { return m_asyncGeneratorPrototype.get(); }
 657     AsyncGeneratorFunctionPrototype* asyncGeneratorFunctionPrototype() const { return m_asyncGeneratorFunctionPrototype.get(); }
 658 
 659     Structure* debuggerScopeStructure() const { return m_debuggerScopeStructure.get(this); }
 660     Structure* withScopeStructure() const { return m_withScopeStructure.get(this); }
 661     Structure* strictEvalActivationStructure() const { return m_strictEvalActivationStructure.get(this); }
 662     Structure* activationStructure() const { return m_lexicalEnvironmentStructure.get(); }
 663     Structure* moduleEnvironmentStructure() const { return m_moduleEnvironmentStructure.get(this); }
 664     Structure* directArgumentsStructure() const { return m_directArgumentsStructure.get(); }
 665     Structure* scopedArgumentsStructure() const { return m_scopedArgumentsStructure.get(); }
 666     Structure* clonedArgumentsStructure() const { return m_clonedArgumentsStructure.get(); }
 667     Structure* objectStructureForObjectConstructor() const { return m_objectStructureForObjectConstructor.get(); }
 668     Structure* originalArrayStructureForIndexingType(IndexingType indexingType) const
 669     {
 670         ASSERT(indexingType &amp; IsArray);
 671         return m_originalArrayStructureForIndexingShape[arrayIndexFromIndexingType(indexingType)].get();
 672     }
 673     Structure* arrayStructureForIndexingTypeDuringAllocation(IndexingType indexingType) const
 674     {
 675         ASSERT(indexingType &amp; IsArray);
 676         return m_arrayStructureForIndexingShapeDuringAllocation[arrayIndexFromIndexingType(indexingType)].get();
 677     }
 678     Structure* arrayStructureForIndexingTypeDuringAllocation(JSGlobalObject* globalObject, IndexingType indexingType, JSValue newTarget) const;
 679     Structure* arrayStructureForProfileDuringAllocation(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, JSValue newTarget) const
 680     {
 681         return arrayStructureForIndexingTypeDuringAllocation(globalObject, ArrayAllocationProfile::selectIndexingTypeFor(profile), newTarget);
 682     }
 683 
 684     bool isOriginalArrayStructure(Structure* structure)
 685     {
 686         return originalArrayStructureForIndexingType(structure-&gt;indexingMode() | IsArray) == structure;
 687     }
 688 
 689     Structure* booleanObjectStructure() const { return m_booleanObjectStructure.get(this); }
 690     Structure* callbackConstructorStructure() const { return m_callbackConstructorStructure.get(this); }
 691     Structure* callbackFunctionStructure() const { return m_callbackFunctionStructure.get(this); }
 692     Structure* callbackObjectStructure() const { return m_callbackObjectStructure.get(this); }
 693 #if JSC_OBJC_API_ENABLED
 694     Structure* objcCallbackFunctionStructure() const { return m_objcCallbackFunctionStructure.get(this); }
 695     Structure* objcWrapperObjectStructure() const { return m_objcWrapperObjectStructure.get(this); }
 696 #endif
 697 #ifdef JSC_GLIB_API_ENABLED
 698     Structure* glibCallbackFunctionStructure() const { return m_glibCallbackFunctionStructure.get(this); }
 699     Structure* glibWrapperObjectStructure() const { return m_glibWrapperObjectStructure.get(this); }
 700 #endif
 701     Structure* dateStructure() const { return m_dateStructure.get(this); }
 702     Structure* symbolObjectStructure() const { return m_symbolObjectStructure.get(this); }
 703     Structure* nullPrototypeObjectStructure() const { return m_nullPrototypeObjectStructure.get(); }
 704     Structure* errorStructure() const { return m_errorStructure.get(this); }
 705     Structure* errorStructure(ErrorType errorType) const
 706     {
 707         switch (errorType) {
 708         case ErrorType::Error:
 709             return errorStructure();
 710         case ErrorType::EvalError:
 711             return m_evalErrorStructure.get(this);
 712         case ErrorType::RangeError:
 713             return m_rangeErrorStructure.get(this);
 714         case ErrorType::ReferenceError:
 715             return m_referenceErrorStructure.get(this);
 716         case ErrorType::SyntaxError:
 717             return m_syntaxErrorStructure.get(this);
 718         case ErrorType::TypeError:
 719             return m_typeErrorStructure.get(this);
 720         case ErrorType::URIError:
 721             return m_URIErrorStructure.get(this);
 722         }
 723         ASSERT_NOT_REACHED();
 724         return nullptr;
 725     }
 726     Structure* calleeStructure() const { return m_calleeStructure.get(); }
 727     Structure* hostFunctionStructure() const { return m_hostFunctionStructure.get(); }
 728 
 729     Structure* arrowFunctionStructure(bool isBuiltin) const
 730     {
 731         if (isBuiltin)
 732             return m_builtinFunctions.arrowFunctionStructure.get();
 733         return m_ordinaryFunctions.arrowFunctionStructure.get();
 734     }
 735     Structure* sloppyFunctionStructure(bool isBuiltin) const
 736     {
 737         if (isBuiltin)
 738             return m_builtinFunctions.sloppyFunctionStructure.get();
 739         return m_ordinaryFunctions.sloppyFunctionStructure.get();
 740     }
 741     Structure* strictFunctionStructure(bool isBuiltin) const
 742     {
 743         if (isBuiltin)
 744             return m_builtinFunctions.strictFunctionStructure.get();
 745         return m_ordinaryFunctions.strictFunctionStructure.get();
 746     }
 747 
 748     Structure* boundFunctionStructure() const { return m_boundFunctionStructure.get(this); }
 749     Structure* customGetterSetterFunctionStructure() const { return m_customGetterSetterFunctionStructure.get(this); }
 750     Structure* nativeStdFunctionStructure() const { return m_nativeStdFunctionStructure.get(this); }
 751     PropertyOffset functionNameOffset() const { return m_functionNameOffset; }
 752     Structure* numberObjectStructure() const { return m_numberObjectStructure.get(this); }
 753     Structure* regExpStructure() const { return m_regExpStructure.get(); }
 754     Structure* generatorStructure() const { return m_generatorStructure.get(); }
 755     Structure* asyncGeneratorStructure() const { return m_asyncGeneratorStructure.get(); }
 756     Structure* generatorFunctionStructure() const { return m_generatorFunctionStructure.get(); }
 757     Structure* asyncFunctionStructure() const { return m_asyncFunctionStructure.get(); }
 758     Structure* asyncGeneratorFunctionStructure() const { return m_asyncGeneratorFunctionStructure.get(); }
 759     Structure* arrayIteratorStructure() const { return m_arrayIteratorStructure.get(); }
 760     Structure* stringObjectStructure() const { return m_stringObjectStructure.get(); }
 761     Structure* iteratorResultObjectStructure() const { return m_iteratorResultObjectStructure.get(this); }
 762     Structure* regExpMatchesArrayStructure() const { return m_regExpMatchesArrayStructure.get(); }
 763     Structure* moduleRecordStructure() const { return m_moduleRecordStructure.get(this); }
 764     Structure* moduleNamespaceObjectStructure() const { return m_moduleNamespaceObjectStructure.get(this); }
 765     Structure* proxyObjectStructure() const { return m_proxyObjectStructure.get(this); }
 766     Structure* callableProxyObjectStructure() const { return m_callableProxyObjectStructure.get(this); }
 767     Structure* proxyRevokeStructure() const { return m_proxyRevokeStructure.get(this); }
 768     Structure* restParameterStructure() const { return arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous); }
 769     Structure* originalRestParameterStructure() const { return originalArrayStructureForIndexingType(ArrayWithContiguous); }
 770 #if ENABLE(WEBASSEMBLY)
 771     Structure* webAssemblyModuleRecordStructure() const { return m_webAssemblyModuleRecordStructure.get(this); }
 772     Structure* webAssemblyFunctionStructure() const { return m_webAssemblyFunctionStructure.get(this); }
 773     Structure* jsToWasmICCalleeStructure() const { return m_jsToWasmICCalleeStructure.get(this); }
 774     Structure* webAssemblyWrapperFunctionStructure() const { return m_webAssemblyWrapperFunctionStructure.get(this); }
 775 #endif // ENABLE(WEBASSEMBLY)
 776 #if ENABLE(INTL)
 777     Structure* collatorStructure() { return m_collatorStructure.get(this); }
 778     Structure* numberFormatStructure() { return m_numberFormatStructure.get(this); }
 779     Structure* dateTimeFormatStructure() { return m_dateTimeFormatStructure.get(this); }
 780     Structure* pluralRulesStructure() { return m_pluralRulesStructure.get(this); }
 781 #endif // ENABLE(INTL)
 782 
 783     JS_EXPORT_PRIVATE void setRemoteDebuggingEnabled(bool);
 784     JS_EXPORT_PRIVATE bool remoteDebuggingEnabled() const;
 785 
 786     RegExpGlobalData&amp; regExpGlobalData() { return m_regExpGlobalData; }
 787     static ptrdiff_t regExpGlobalDataOffset() { return OBJECT_OFFSETOF(JSGlobalObject, m_regExpGlobalData); }
 788 
 789 #if ENABLE(REMOTE_INSPECTOR)
 790     Inspector::JSGlobalObjectInspectorController&amp; inspectorController() const { return *m_inspectorController.get(); }
 791     JSGlobalObjectDebuggable&amp; inspectorDebuggable() { return *m_inspectorDebuggable.get(); }
 792 #endif
 793 
 794     void bumpGlobalLexicalBindingEpoch(VM&amp;);
 795     unsigned globalLexicalBindingEpoch() const { return m_globalLexicalBindingEpoch; }
 796     static ptrdiff_t globalLexicalBindingEpochOffset() { return OBJECT_OFFSETOF(JSGlobalObject, m_globalLexicalBindingEpoch); }
 797     unsigned* addressOfGlobalLexicalBindingEpoch() { return &amp;m_globalLexicalBindingEpoch; }
 798 
 799     void setConsoleClient(ConsoleClient* consoleClient) { m_consoleClient = consoleClient; }
 800     ConsoleClient* consoleClient() const { return m_consoleClient; }
 801 
 802     void setName(const String&amp;);
 803     const String&amp; name() const { return m_name; }
 804 
 805     void setUnhandledRejectionCallback(VM&amp; vm, JSObject* function) { m_unhandledRejectionCallback.set(vm, function); }
 806     JSObject* unhandledRejectionCallback() const { return m_unhandledRejectionCallback.get(); }
 807 
 808     JSObject* arrayBufferConstructor() const { return m_arrayBufferStructure.constructor(this); }
 809 
 810     JSObject* arrayBufferPrototype(ArrayBufferSharingMode sharingMode) const
 811     {
 812         switch (sharingMode) {
 813         case ArrayBufferSharingMode::Default:
 814             return m_arrayBufferStructure.prototype(this);
 815 #if ENABLE(SHARED_ARRAY_BUFFER)
 816         case ArrayBufferSharingMode::Shared:
 817             return m_sharedArrayBufferPrototype.get();
 818 #else
 819         default:
 820             return m_arrayBufferStructure.prototype(this);
 821 #endif
 822         }
 823     }
 824     Structure* arrayBufferStructure(ArrayBufferSharingMode sharingMode) const
 825     {
 826         switch (sharingMode) {
 827         case ArrayBufferSharingMode::Default:
 828             return m_arrayBufferStructure.get(this);
 829 #if ENABLE(SHARED_ARRAY_BUFFER)
 830         case ArrayBufferSharingMode::Shared:
 831             return m_sharedArrayBufferStructure.get();
 832 #else
 833         default:
 834             return m_arrayBufferStructure.get(this);
 835 #endif
 836         }
 837         RELEASE_ASSERT_NOT_REACHED();
 838         return nullptr;
 839     }
 840 
 841 #define DEFINE_ACCESSORS_FOR_SIMPLE_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase, featureFlag) \
 842     Structure* properName ## Structure() { return m_ ## properName ## Structure.get(); }
 843 
 844     FOR_EACH_SIMPLE_BUILTIN_TYPE(DEFINE_ACCESSORS_FOR_SIMPLE_TYPE)
 845     FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(DEFINE_ACCESSORS_FOR_SIMPLE_TYPE)
 846 
 847 #undef DEFINE_ACCESSORS_FOR_SIMPLE_TYPE
 848 
 849 #define DEFINE_ACCESSORS_FOR_LAZY_TYPE(capitalName, lowerName, properName, instanceType, jsName, prototypeBase, featureFlag) \
 850     Structure* properName ## Structure() { return m_ ## properName ## Structure.get(this); } \
 851     JSObject* properName ## Constructor() { return m_ ## properName ## Structure.constructor(this); }
 852 
 853     FOR_EACH_LAZY_BUILTIN_TYPE(DEFINE_ACCESSORS_FOR_LAZY_TYPE)
 854     FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DEFINE_ACCESSORS_FOR_LAZY_TYPE)
 855 
 856 #undef DEFINE_ACCESSORS_FOR_LAZY_TYPE
 857 
 858     LazyClassStructure&amp; lazyTypedArrayStructure(TypedArrayType type)
 859     {
 860         switch (type) {
 861         case NotTypedArray:
 862             RELEASE_ASSERT_NOT_REACHED();
 863             return m_typedArrayInt8;
 864 #define TYPED_ARRAY_TYPE_CASE(name) case Type ## name: return m_typedArray ## name;
 865             FOR_EACH_TYPED_ARRAY_TYPE(TYPED_ARRAY_TYPE_CASE)
 866 #undef TYPED_ARRAY_TYPE_CASE
 867         }
 868         RELEASE_ASSERT_NOT_REACHED();
 869         return m_typedArrayInt8;
 870     }
 871     const LazyClassStructure&amp; lazyTypedArrayStructure(TypedArrayType type) const
 872     {
 873         return const_cast&lt;const LazyClassStructure&amp;&gt;(const_cast&lt;JSGlobalObject*&gt;(this)-&gt;lazyTypedArrayStructure(type));
 874     }
 875 
 876     Structure* typedArrayStructure(TypedArrayType type) const
 877     {
 878         return lazyTypedArrayStructure(type).get(this);
 879     }
 880     Structure* typedArrayStructureConcurrently(TypedArrayType type) const
 881     {
 882         return lazyTypedArrayStructure(type).getConcurrently();
 883     }
 884     bool isOriginalTypedArrayStructure(Structure* structure)
 885     {
 886         TypedArrayType type = structure-&gt;classInfo()-&gt;typedArrayStorageType;
 887         if (type == NotTypedArray)
 888             return false;
 889         return typedArrayStructureConcurrently(type) == structure;
 890     }
 891 
 892     JSObject* typedArrayConstructor(TypedArrayType type) const
 893     {
 894         return lazyTypedArrayStructure(type).constructor(this);
 895     }
 896 
 897     JSCell* linkTimeConstant(LinkTimeConstant value) const
 898     {
 899         JSCell* result = m_linkTimeConstants[static_cast&lt;unsigned&gt;(value)].getInitializedOnMainThread(this);
 900         ASSERT(result);
 901         return result;
 902     }
 903 
 904     WatchpointSet* masqueradesAsUndefinedWatchpoint() { return m_masqueradesAsUndefinedWatchpoint.get(); }
 905     WatchpointSet* havingABadTimeWatchpoint() { return m_havingABadTimeWatchpoint.get(); }
 906     WatchpointSet* varInjectionWatchpoint() { return m_varInjectionWatchpoint.get(); }
 907 
 908     bool isHavingABadTime() const
 909     {
 910         return m_havingABadTimeWatchpoint-&gt;hasBeenInvalidated();
 911     }
 912 
 913     void haveABadTime(VM&amp;);
 914 
 915     bool objectPrototypeIsSane();
 916     bool arrayPrototypeChainIsSane();
 917     bool stringPrototypeChainIsSane();
 918 
 919     void setProfileGroup(unsigned value) { createRareDataIfNeeded(); m_rareData-&gt;profileGroup = value; }
 920     unsigned profileGroup() const
 921     {
 922         if (!m_rareData)
 923             return 0;
 924         return m_rareData-&gt;profileGroup;
 925     }
 926 
 927     Debugger* debugger() const { return m_debugger; }
 928     void setDebugger(Debugger*);
 929 
 930     const GlobalObjectMethodTable* globalObjectMethodTable() const { return m_globalObjectMethodTable; }
 931 
 932     JS_EXPORT_PRIVATE CallFrame* deprecatedCallFrameForDebugger();
 933 
 934     static bool supportsRichSourceInfo(const JSGlobalObject*) { return true; }
 935 
 936     static bool shouldInterruptScript(const JSGlobalObject*) { return true; }
 937     static bool shouldInterruptScriptBeforeTimeout(const JSGlobalObject*) { return false; }
 938     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags(); }
 939 
 940     JS_EXPORT_PRIVATE void queueMicrotask(Ref&lt;Microtask&gt;&amp;&amp;);
 941 
 942     bool evalEnabled() const { return m_evalEnabled; }
 943     bool webAssemblyEnabled() const { return m_webAssemblyEnabled; }
 944     const String&amp; evalDisabledErrorMessage() const { return m_evalDisabledErrorMessage; }
 945     const String&amp; webAssemblyDisabledErrorMessage() const { return m_webAssemblyDisabledErrorMessage; }
 946     void setEvalEnabled(bool enabled, const String&amp; errorMessage = String())
 947     {
 948         m_evalEnabled = enabled;
 949         m_evalDisabledErrorMessage = errorMessage;
 950     }
 951     void setWebAssemblyEnabled(bool enabled, const String&amp; errorMessage = String())
 952     {
 953         m_webAssemblyEnabled = enabled;
 954         m_webAssemblyDisabledErrorMessage = errorMessage;
 955     }
 956 
 957 #if ASSERT_ENABLED
 958     const JSGlobalObject* globalObjectAtDebuggerEntry() const { return m_globalObjectAtDebuggerEntry; }
 959     void setGlobalObjectAtDebuggerEntry(const JSGlobalObject* globalObject) { m_globalObjectAtDebuggerEntry = globalObject; }
 960 #endif
 961 
 962     void resetPrototype(VM&amp;, JSValue prototype);
 963 
 964     VM&amp; vm() const { return *m_vm; }
 965     JSObject* globalThis() const;
 966     WriteBarrier&lt;JSObject&gt;* addressOfGlobalThis() { return &amp;m_globalThis; }
 967     OptionSet&lt;CodeGenerationMode&gt; defaultCodeGenerationMode() const;
 968 
 969     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 970     {
 971         Structure* result = Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 972         result-&gt;setTransitionWatchpointIsLikelyToBeFired(true);
 973         return result;
 974     }
 975 
 976     void registerWeakMap(OpaqueJSWeakObjectMap* map)
 977     {
 978         createRareDataIfNeeded();
 979         m_rareData-&gt;weakMaps.add(map);
 980     }
 981 
 982     void unregisterWeakMap(OpaqueJSWeakObjectMap* map)
 983     {
 984         if (m_rareData)
 985             m_rareData-&gt;weakMaps.remove(map);
 986     }
 987 
 988     OpaqueJSClassDataMap&amp; opaqueJSClassData()
 989     {
 990         createRareDataIfNeeded();
 991         return m_rareData-&gt;opaqueJSClassData;
 992     }
 993 
 994     static ptrdiff_t weakRandomOffset() { return OBJECT_OFFSETOF(JSGlobalObject, m_weakRandom); }
 995     double weakRandomNumber() { return m_weakRandom.get(); }
 996     unsigned weakRandomInteger() { return m_weakRandom.getUint32(); }
 997     WeakRandom&amp; weakRandom() { return m_weakRandom; }
 998 
 999     bool needsSiteSpecificQuirks() const { return m_needsSiteSpecificQuirks; }
1000     JS_EXPORT_PRIVATE void exposeDollarVM(VM&amp;);
1001 
1002 #if JSC_OBJC_API_ENABLED
1003     JSWrapperMap* wrapperMap() const { return m_wrapperMap.get(); }
1004     void setWrapperMap(JSWrapperMap* map) { m_wrapperMap = map; }
1005 #endif
1006 #ifdef JSC_GLIB_API_ENABLED
1007     WrapperMap* wrapperMap() const { return m_wrapperMap.get(); }
1008     void setWrapperMap(std::unique_ptr&lt;WrapperMap&gt;&amp;&amp;);
1009 #endif
1010 
1011     void tryInstallArraySpeciesWatchpoint();
1012     void installNumberPrototypeWatchpoint(NumberPrototype*);
1013     void installMapPrototypeWatchpoint(MapPrototype*);
1014     void installSetPrototypeWatchpoint(SetPrototype*);
1015 
1016 protected:
1017     struct GlobalPropertyInfo {
1018         GlobalPropertyInfo(const Identifier&amp; i, JSValue v, unsigned a)
1019             : identifier(i)
1020             , value(v)
1021             , attributes(a)
1022         {
1023         }
1024 
1025         const Identifier identifier;
1026         JSValue value;
1027         unsigned attributes;
1028     };
1029     JS_EXPORT_PRIVATE void addStaticGlobals(GlobalPropertyInfo*, int count);
1030 
1031     void setNeedsSiteSpecificQuirks(bool needQuirks) { m_needsSiteSpecificQuirks = needQuirks; }
1032 
1033 private:
1034     friend class LLIntOffsetsExtractor;
1035 
1036     void fireWatchpointAndMakeAllArrayStructuresSlowPut(VM&amp;);
1037     void setGlobalThis(VM&amp;, JSObject* globalThis);
1038 
1039     template&lt;ErrorType errorType&gt;
1040     void initializeErrorConstructor(LazyClassStructure::Initializer&amp;);
1041 
1042     JS_EXPORT_PRIVATE void init(VM&amp;);
1043     void fixupPrototypeChainWithObjectPrototype(VM&amp;);
1044 
1045     JS_EXPORT_PRIVATE static void clearRareData(JSCell*);
1046 
1047     bool m_needsSiteSpecificQuirks { false };
1048 #if JSC_OBJC_API_ENABLED
1049     RetainPtr&lt;JSWrapperMap&gt; m_wrapperMap;
1050 #endif
1051 #ifdef JSC_GLIB_API_ENABLED
1052     std::unique_ptr&lt;WrapperMap&gt; m_wrapperMap;
1053 #endif
1054 };
1055 
1056 inline JSArray* constructEmptyArray(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, unsigned initialLength = 0, JSValue newTarget = JSValue())
1057 {
1058     VM&amp; vm = getVM(globalObject);
1059     auto scope = DECLARE_THROW_SCOPE(vm);
1060     Structure* structure;
1061     if (initialLength &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)
1062         structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(globalObject, ArrayWithArrayStorage, newTarget);
1063     else
1064         structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);
1065     RETURN_IF_EXCEPTION(scope, nullptr);
1066 
1067     JSArray* result = JSArray::tryCreate(vm, structure, initialLength);
1068     if (UNLIKELY(!result)) {
1069         throwOutOfMemoryError(globalObject, scope);
1070         return nullptr;
1071     }
1072     return ArrayAllocationProfile::updateLastAllocationFor(profile, result);
1073 }
1074 
1075 inline JSArray* constructArray(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, const ArgList&amp; values, JSValue newTarget = JSValue())
1076 {
1077     VM&amp; vm = getVM(globalObject);
1078     auto scope = DECLARE_THROW_SCOPE(vm);
1079     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);
1080     RETURN_IF_EXCEPTION(scope, nullptr);
1081     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(globalObject, structure, values));
1082 }
1083 
1084 inline JSArray* constructArray(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())
1085 {
1086     VM&amp; vm = getVM(globalObject);
1087     auto scope = DECLARE_THROW_SCOPE(vm);
1088     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);
1089     RETURN_IF_EXCEPTION(scope, nullptr);
1090     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(globalObject, structure, values, length));
1091 }
1092 
1093 inline JSArray* constructArrayNegativeIndexed(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())
1094 {
1095     VM&amp; vm = getVM(globalObject);
1096     auto scope = DECLARE_THROW_SCOPE(vm);
1097     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);
1098     RETURN_IF_EXCEPTION(scope, nullptr);
1099     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArrayNegativeIndexed(globalObject, structure, values, length));
1100 }
1101 
1102 inline JSObject* JSScope::globalThis()
1103 {
1104     return globalObject()-&gt;globalThis();
1105 }
1106 
1107 inline JSObject* JSGlobalObject::globalThis() const
1108 {
1109     return m_globalThis.get();
1110 }
1111 
1112 inline OptionSet&lt;CodeGenerationMode&gt; JSGlobalObject::defaultCodeGenerationMode() const
1113 {
1114     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode;
1115     if (hasInteractiveDebugger() || Options::forceDebuggerBytecodeGeneration())
1116         codeGenerationMode.add(CodeGenerationMode::Debugger);
1117     if (vm().typeProfiler())
1118         codeGenerationMode.add(CodeGenerationMode::TypeProfiler);
1119     if (vm().controlFlowProfiler())
1120         codeGenerationMode.add(CodeGenerationMode::ControlFlowProfiler);
1121     return codeGenerationMode;
1122 }
1123 
1124 } // namespace JSC
    </pre>
  </body>
</html>
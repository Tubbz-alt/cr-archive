<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFontVariationValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSGradientValue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
  #include &quot;GradientImage.h&quot;
  #include &quot;NodeRenderStyle.h&quot;
  #include &quot;Pair.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;RenderView.h&quot;
<span class="line-modified">! #include &quot;StyleResolver.h&quot;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  static inline Ref&lt;Gradient&gt; createGradient(CSSGradientValue&amp; value, RenderElement&amp; renderer, FloatSize size)
<span class="line-new-header">--- 34,11 ---</span>
  #include &quot;GradientImage.h&quot;
  #include &quot;NodeRenderStyle.h&quot;
  #include &quot;Pair.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;RenderView.h&quot;
<span class="line-modified">! #include &quot;StyleBuilderState.h&quot;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  static inline Ref&lt;Gradient&gt; createGradient(CSSGradientValue&amp; value, RenderElement&amp; renderer, FloatSize size)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,12 ***</span>
  }
  
  // Should only ever be called for deprecated gradients.
  static inline bool compareStops(const CSSGradientColorStop&amp; a, const CSSGradientColorStop&amp; b)
  {
<span class="line-modified">!     double aVal = a.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-modified">!     double bVal = b.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
  
      return aVal &lt; bVal;
  }
  
  void CSSGradientValue::sortStopsIfNeeded()
<span class="line-new-header">--- 68,12 ---</span>
  }
  
  // Should only ever be called for deprecated gradients.
  static inline bool compareStops(const CSSGradientColorStop&amp; a, const CSSGradientColorStop&amp; b)
  {
<span class="line-modified">!     double aVal = a.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
<span class="line-modified">!     double bVal = b.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
  
      return aVal &lt; bVal;
  }
  
  void CSSGradientValue::sortStopsIfNeeded()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,28 ***</span>
          return downcast&lt;CSSRadialGradientValue&gt;(value).clone();
      ASSERT(is&lt;CSSConicGradientValue&gt;(value));
      return downcast&lt;CSSConicGradientValue&gt;(value).clone();
  }
  
<span class="line-modified">! Ref&lt;CSSGradientValue&gt; CSSGradientValue::gradientWithStylesResolved(const StyleResolver&amp; styleResolver)</span>
  {
      bool colorIsDerivedFromElement = false;
      for (auto&amp; stop : m_stops) {
<span class="line-modified">!         if (!stop.isMidpoint &amp;&amp; styleResolver.colorFromPrimitiveValueIsDerivedFromElement(*stop.m_color)) {</span>
              stop.m_colorIsDerivedFromElement = true;
              colorIsDerivedFromElement = true;
              break;
          }
      }
      auto result = colorIsDerivedFromElement ? clone(*this) : makeRef(*this);
<span class="line-modified">!     for (auto&amp; stop : result-&gt;m_stops) {</span>
<span class="line-modified">!         if (!stop.isMidpoint)</span>
<span class="line-modified">!             stop.m_resolvedColor = styleResolver.colorFromPrimitiveValue(*stop.m_color);</span>
<span class="line-removed">-     }</span>
      return result;
  }
  
  class LinearGradientAdapter {
  public:
      explicit LinearGradientAdapter(Gradient::LinearData&amp; data)
          : m_data(data)
      {
<span class="line-new-header">--- 101,53 ---</span>
          return downcast&lt;CSSRadialGradientValue&gt;(value).clone();
      ASSERT(is&lt;CSSConicGradientValue&gt;(value));
      return downcast&lt;CSSConicGradientValue&gt;(value).clone();
  }
  
<span class="line-modified">! template&lt;typename Function&gt;</span>
<span class="line-added">+ void resolveStopColors(Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops, Function&amp;&amp; colorResolveFunction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (size_t i = 0; i &lt; stops.size(); ++i) {</span>
<span class="line-added">+         auto&amp; stop = stops[i];</span>
<span class="line-added">+         if (stop.isMidpoint)</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         if (stop.m_color)</span>
<span class="line-added">+             stop.m_resolvedColor = colorResolveFunction(*stop.m_color);</span>
<span class="line-added">+         else if (i) {</span>
<span class="line-added">+             auto&amp; previousStop = stops[i - 1];</span>
<span class="line-added">+             ASSERT(previousStop.m_color);</span>
<span class="line-added">+             stop.m_color = previousStop.m_color;</span>
<span class="line-added">+             stop.m_resolvedColor = previousStop.m_resolvedColor;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Ref&lt;CSSGradientValue&gt; CSSGradientValue::gradientWithStylesResolved(Style::BuilderState&amp; builderState)</span>
  {
      bool colorIsDerivedFromElement = false;
      for (auto&amp; stop : m_stops) {
<span class="line-modified">!         if (!stop.isMidpoint &amp;&amp; stop.m_color &amp;&amp; Style::BuilderState::isColorFromPrimitiveValueDerivedFromElement(*stop.m_color)) {</span>
              stop.m_colorIsDerivedFromElement = true;
              colorIsDerivedFromElement = true;
              break;
          }
      }
      auto result = colorIsDerivedFromElement ? clone(*this) : makeRef(*this);
<span class="line-modified">!     resolveStopColors(result-&gt;m_stops, [&amp;](const CSSPrimitiveValue&amp; colorValue) {</span>
<span class="line-modified">!         return builderState.colorFromPrimitiveValue(colorValue);</span>
<span class="line-modified">!     });</span>
      return result;
  }
  
<span class="line-added">+ void CSSGradientValue::resolveRGBColors()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     resolveStopColors(m_stops, [&amp;](const CSSPrimitiveValue&amp; colorValue) {</span>
<span class="line-added">+         ASSERT(colorValue.isRGBColor());</span>
<span class="line-added">+         return colorValue.color();</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  class LinearGradientAdapter {
  public:
      explicit LinearGradientAdapter(Gradient::LinearData&amp; data)
          : m_data(data)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 307,13 ***</span>
          result.reserveInitialCapacity(m_stops.size());
  
          for (auto&amp; stop : m_stops) {
              float offset;
              if (stop.m_position-&gt;isPercentage())
<span class="line-modified">!                 offset = stop.m_position-&gt;floatValue(CSSPrimitiveValue::CSS_PERCENTAGE) / 100;</span>
              else
<span class="line-modified">!                 offset = stop.m_position-&gt;floatValue(CSSPrimitiveValue::CSS_NUMBER);</span>
  
              Color color = stop.m_resolvedColor;
              if (style.hasAppleColorFilter())
                  style.appleColorFilter().transformColor(color);
              result.uncheckedAppend({ offset, color });
<span class="line-new-header">--- 332,13 ---</span>
          result.reserveInitialCapacity(m_stops.size());
  
          for (auto&amp; stop : m_stops) {
              float offset;
              if (stop.m_position-&gt;isPercentage())
<span class="line-modified">!                 offset = stop.m_position-&gt;floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;</span>
              else
<span class="line-modified">!                 offset = stop.m_position-&gt;floatValue(CSSUnitType::CSS_NUMBER);</span>
  
              Color color = stop.m_resolvedColor;
              if (style.hasAppleColorFilter())
                  style.appleColorFilter().transformColor(color);
              result.uncheckedAppend({ offset, color });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,22 ***</span>
          stops[i].color = color;
  
          if (stop.m_position) {
              auto&amp; positionValue = *stop.m_position;
              if (positionValue.isPercentage())
<span class="line-modified">!                 stops[i].offset = positionValue.floatValue(CSSPrimitiveValue::CSS_PERCENTAGE) / 100;</span>
              else if (positionValue.isLength() || positionValue.isViewportPercentageLength() || positionValue.isCalculatedPercentageWithLength()) {
                  float length;
                  if (positionValue.isLength())
                      length = positionValue.computeLength&lt;float&gt;(conversionData);
                  else {
                      Ref&lt;CalculationValue&gt; calculationValue { positionValue.cssCalcValue()-&gt;createCalculationValue(conversionData) };
                      length = calculationValue-&gt;evaluate(gradientLength);
                  }
                  stops[i].offset = (gradientLength &gt; 0) ? length / gradientLength : 0;
              } else if (positionValue.isAngle())
<span class="line-modified">!                 stops[i].offset = positionValue.floatValue(CSSPrimitiveValue::CSS_DEG) / 360;</span>
              else {
                  ASSERT_NOT_REACHED();
                  stops[i].offset = 0;
              }
              stops[i].specified = true;
<span class="line-new-header">--- 364,22 ---</span>
          stops[i].color = color;
  
          if (stop.m_position) {
              auto&amp; positionValue = *stop.m_position;
              if (positionValue.isPercentage())
<span class="line-modified">!                 stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;</span>
              else if (positionValue.isLength() || positionValue.isViewportPercentageLength() || positionValue.isCalculatedPercentageWithLength()) {
                  float length;
                  if (positionValue.isLength())
                      length = positionValue.computeLength&lt;float&gt;(conversionData);
                  else {
                      Ref&lt;CalculationValue&gt; calculationValue { positionValue.cssCalcValue()-&gt;createCalculationValue(conversionData) };
                      length = calculationValue-&gt;evaluate(gradientLength);
                  }
                  stops[i].offset = (gradientLength &gt; 0) ? length / gradientLength : 0;
              } else if (positionValue.isAngle())
<span class="line-modified">!                 stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_DEG) / 360;</span>
              else {
                  ASSERT_NOT_REACHED();
                  stops[i].offset = 0;
              }
              stops[i].specified = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,17 ***</span>
  }
  
  static void appendGradientStops(StringBuilder&amp; builder, const Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops)
  {
      for (auto&amp; stop : stops) {
<span class="line-modified">!         double position = stop.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
          if (!position)
              builder.append(&quot;, from(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
          else if (position == 1)
              builder.append(&quot;, to(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
          else
<span class="line-modified">!             builder.append(&quot;, color-stop(&quot;, FormattedNumber::fixedPrecision(position), &quot;, &quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);</span>
      }
  }
  
  String CSSLinearGradientValue::customCSSText() const
  {
<span class="line-new-header">--- 692,29 ---</span>
  }
  
  static void appendGradientStops(StringBuilder&amp; builder, const Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops)
  {
      for (auto&amp; stop : stops) {
<span class="line-modified">!         double position = stop.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
          if (!position)
              builder.append(&quot;, from(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
          else if (position == 1)
              builder.append(&quot;, to(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
          else
<span class="line-modified">!             builder.append(&quot;, color-stop(&quot;, position, &quot;, &quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void CSSGradientValue::writeColorStop(StringBuilder&amp; builder, const CSSGradientColorStop&amp; stop) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!stop.isMidpoint &amp;&amp; stop.m_color)</span>
<span class="line-added">+         builder.append(stop.m_color-&gt;cssText());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (stop.m_position) {</span>
<span class="line-added">+         if (!stop.isMidpoint)</span>
<span class="line-added">+             builder.append(&#39; &#39;);</span>
<span class="line-added">+         builder.append(stop.m_position-&gt;cssText());</span>
      }
  }
  
  String CSSLinearGradientValue::customCSSText() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,13 ***</span>
              else if (m_firstY)
                  result.append(m_firstY-&gt;cssText());
          }
  
          for (auto&amp; stop : m_stops) {
<span class="line-modified">!             result.append(&quot;, &quot;, stop.m_color-&gt;cssText());</span>
<span class="line-modified">!             if (stop.m_position)</span>
<span class="line-removed">-                 result.append(&#39; &#39;, stop.m_position-&gt;cssText());</span>
          }
      } else {
          if (m_repeating)
              result.appendLiteral(&quot;repeating-linear-gradient(&quot;);
          else
<span class="line-new-header">--- 738,12 ---</span>
              else if (m_firstY)
                  result.append(m_firstY-&gt;cssText());
          }
  
          for (auto&amp; stop : m_stops) {
<span class="line-modified">!             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-modified">!             writeColorStop(result, stop);</span>
          }
      } else {
          if (m_repeating)
              result.appendLiteral(&quot;repeating-linear-gradient(&quot;);
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,17 ***</span>
          bool wroteFirstStop = false;
          for (auto&amp; stop : m_stops) {
              if (wroteFirstStop)
                  result.appendLiteral(&quot;, &quot;);
              wroteFirstStop = true;
<span class="line-modified">!             if (!stop.isMidpoint)</span>
<span class="line-removed">-                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed">-             if (stop.m_position) {</span>
<span class="line-removed">-                 if (!stop.isMidpoint)</span>
<span class="line-removed">-                     result.append(&#39; &#39;);</span>
<span class="line-removed">-                 result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed">-             }</span>
          }
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
<span class="line-new-header">--- 771,11 ---</span>
          bool wroteFirstStop = false;
          for (auto&amp; stop : m_stops) {
              if (wroteFirstStop)
                  result.appendLiteral(&quot;, &quot;);
              wroteFirstStop = true;
<span class="line-modified">!             writeColorStop(result, stop);</span>
          }
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 826,11 ***</span>
      CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
  
      FloatPoint firstPoint;
      FloatPoint secondPoint;
      if (m_angle) {
<span class="line-modified">!         float angle = m_angle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG);</span>
          endPointsFromAngle(angle, size, firstPoint, secondPoint, m_gradientType);
      } else {
          switch (m_gradientType) {
          case CSSDeprecatedLinearGradient:
              firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
<span class="line-new-header">--- 856,11 ---</span>
      CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
  
      FloatPoint firstPoint;
      FloatPoint secondPoint;
      if (m_angle) {
<span class="line-modified">!         float angle = m_angle-&gt;floatValue(CSSUnitType::CSS_DEG);</span>
          endPointsFromAngle(angle, size, firstPoint, secondPoint, m_gradientType);
      } else {
          switch (m_gradientType) {
          case CSSDeprecatedLinearGradient:
              firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 893,10 ***</span>
<span class="line-new-header">--- 923,13 ---</span>
              &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY)
              &amp;&amp; compareCSSValuePtr(m_secondX, other.m_secondX)
              &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
              &amp;&amp; m_stops == other.m_stops;
  
<span class="line-added">+     if (m_gradientType != other.m_gradientType)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (m_repeating != other.m_repeating)
          return false;
  
      if (m_angle)
          return compareCSSValuePtr(m_angle, other.m_angle) &amp;&amp; m_stops == other.m_stops;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 952,13 ***</span>
                  result.appendLiteral(&quot;cover&quot;);
          } else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize)
              result.append(&quot;, &quot;, m_endHorizontalSize-&gt;cssText(), &#39; &#39;, m_endVerticalSize-&gt;cssText());
  
          for (auto&amp; stop : m_stops) {
<span class="line-modified">!             result.append(&quot;, &quot;, stop.m_color-&gt;cssText());</span>
<span class="line-modified">!             if (stop.m_position)</span>
<span class="line-removed">-                 result.append(&#39; &#39;, stop.m_position-&gt;cssText());</span>
          }
      } else {
          if (m_repeating)
              result.appendLiteral(&quot;repeating-radial-gradient(&quot;);
          else
<span class="line-new-header">--- 985,12 ---</span>
                  result.appendLiteral(&quot;cover&quot;);
          } else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize)
              result.append(&quot;, &quot;, m_endHorizontalSize-&gt;cssText(), &#39; &#39;, m_endVerticalSize-&gt;cssText());
  
          for (auto&amp; stop : m_stops) {
<span class="line-modified">!             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-modified">!             writeColorStop(result, stop);</span>
          }
      } else {
          if (m_repeating)
              result.appendLiteral(&quot;repeating-radial-gradient(&quot;);
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1001,23 ***</span>
          }
  
          if (wroteSomething)
              result.appendLiteral(&quot;, &quot;);
  
<span class="line-modified">!         for (unsigned i = 0; i &lt; m_stops.size(); i++) {</span>
<span class="line-modified">!             const CSSGradientColorStop&amp; stop = m_stops[i];</span>
<span class="line-modified">!             if (i)</span>
                  result.appendLiteral(&quot;, &quot;);
<span class="line-modified">!             if (!stop.isMidpoint)</span>
<span class="line-modified">!                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed">-             if (stop.m_position) {</span>
<span class="line-removed">-                 if (!stop.isMidpoint)</span>
<span class="line-removed">-                     result.append(&#39; &#39;);</span>
<span class="line-removed">-                 result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed">-             }</span>
          }
<span class="line-removed">- </span>
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
  }
<span class="line-new-header">--- 1033,17 ---</span>
          }
  
          if (wroteSomething)
              result.appendLiteral(&quot;, &quot;);
  
<span class="line-modified">!         bool wroteFirstStop = false;</span>
<span class="line-modified">!         for (auto&amp; stop : m_stops) {</span>
<span class="line-modified">!             if (wroteFirstStop)</span>
                  result.appendLiteral(&quot;, &quot;);
<span class="line-modified">!             wroteFirstStop = true;</span>
<span class="line-modified">!             writeColorStop(result, stop);</span>
          }
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1105,11 ***</span>
  static inline float horizontalEllipseRadius(const FloatSize&amp; p, float aspectRatio)
  {
      // x^2/a^2 + y^2/b^2 = 1
      // a/b = aspectRatio, b = a/aspectRatio
      // a = sqrt(x^2 + y^2/(1/r^2))
<span class="line-modified">!     return sqrtf(p.width() * p.width() + (p.height() * p.height()) / (1 / (aspectRatio * aspectRatio)));</span>
  }
  
  // FIXME: share code with the linear version
  Ref&lt;Gradient&gt; CSSRadialGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
  {
<span class="line-new-header">--- 1131,11 ---</span>
  static inline float horizontalEllipseRadius(const FloatSize&amp; p, float aspectRatio)
  {
      // x^2/a^2 + y^2/b^2 = 1
      // a/b = aspectRatio, b = a/aspectRatio
      // a = sqrt(x^2 + y^2/(1/r^2))
<span class="line-modified">!     return std::hypot(p.width(), p.height() * aspectRatio);</span>
  }
  
  // FIXME: share code with the linear version
  Ref&lt;Gradient&gt; CSSRadialGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1264,10 ***</span>
<span class="line-new-header">--- 1290,13 ---</span>
              &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
              &amp;&amp; compareCSSValuePtr(m_firstRadius, other.m_firstRadius)
              &amp;&amp; compareCSSValuePtr(m_secondRadius, other.m_secondRadius)
              &amp;&amp; m_stops == other.m_stops;
  
<span class="line-added">+     if (m_gradientType != other.m_gradientType)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
      if (m_repeating != other.m_repeating)
          return false;
  
      bool equalXandY = false;
      if (m_firstX &amp;&amp; m_firstY)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,17 ***</span>
      bool wroteFirstStop = false;
      for (auto&amp; stop : m_stops) {
          if (wroteFirstStop)
              result.appendLiteral(&quot;, &quot;);
          wroteFirstStop = true;
<span class="line-modified">!         if (!stop.isMidpoint)</span>
<span class="line-removed">-             result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed">-         if (stop.m_position) {</span>
<span class="line-removed">-             if (!stop.isMidpoint)</span>
<span class="line-removed">-                 result.append(&#39; &#39;);</span>
<span class="line-removed">-             result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed">-         }</span>
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
  }
<span class="line-new-header">--- 1359,11 ---</span>
      bool wroteFirstStop = false;
      for (auto&amp; stop : m_stops) {
          if (wroteFirstStop)
              result.appendLiteral(&quot;, &quot;);
          wroteFirstStop = true;
<span class="line-modified">!         writeColorStop(result, stop);</span>
      }
  
      result.append(&#39;)&#39;);
      return result.toString();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1357,11 ***</span>
      if (!m_firstY)
          centerPoint.setY(size.height() / 2);
  
      float angleRadians = 0;
      if (m_angle)
<span class="line-modified">!         angleRadians = m_angle-&gt;floatValue(CSSPrimitiveValue::CSS_RAD);</span>
  
      Gradient::ConicData data { centerPoint, angleRadians };
      ConicGradientAdapter adapter;
      auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
  
<span class="line-new-header">--- 1380,11 ---</span>
      if (!m_firstY)
          centerPoint.setY(size.height() / 2);
  
      float angleRadians = 0;
      if (m_angle)
<span class="line-modified">!         angleRadians = m_angle-&gt;floatValue(CSSUnitType::CSS_RAD);</span>
  
      Gradient::ConicData data { centerPoint, angleRadians };
      ConicGradientAdapter adapter;
      auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
  
</pre>
<center><a href="CSSFontVariationValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSGradientValue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/AsyncFromSyncIteratorPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayPrototype.js.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFunctionPrototype.js.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/AsyncFromSyncIteratorPrototype.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /*
   * Copyright (C) 2017 Oleksandr Skachkov &lt;gskachkov@gmail.com&gt;.
<span class="udiff-line-added">+  * Copyright (C) 2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,129 +26,125 @@</span>
  
  function next(value)
  {
      &quot;use strict&quot;;
  
<span class="udiff-line-modified-removed">-     const promiseCapability = @newPromiseCapability(@Promise);</span>
<span class="udiff-line-modified-added">+     var promise = @newPromise();</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="udiff-line-modified-removed">-         return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="udiff-line-modified-added">+         return promise;</span>
      }
  
<span class="udiff-line-modified-removed">-     const syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
<span class="udiff-line-modified-added">+     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
      try {
<span class="udiff-line-modified-removed">-         const { value: nextValue, done: nextDone } = @getByIdDirectPrivate(this, &quot;nextMethod&quot;).@call(syncIterator, value);</span>
<span class="udiff-line-modified-removed">-         const valueWrapperCapability = @newPromiseCapability(@Promise);</span>
<span class="udiff-line-modified-removed">-         valueWrapperCapability.@resolve.@call(@undefined, nextValue);</span>
<span class="udiff-line-modified-removed">-         valueWrapperCapability.@promise.@then(</span>
<span class="udiff-line-modified-removed">-             function (result) { promiseCapability.@resolve.@call(@undefined, { value: result, done: !!nextDone }); },</span>
<span class="udiff-line-modified-removed">-             function (error) { promiseCapability.@reject.@call(@undefined, error); });</span>
<span class="udiff-line-modified-removed">-      } catch(e) {</span>
<span class="udiff-line-modified-removed">-          promiseCapability.@reject.@call(@undefined, e);</span>
<span class="udiff-line-modified-removed">-      }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         var nextResult = @getByIdDirectPrivate(this, &quot;nextMethod&quot;).@call(syncIterator, value);</span>
<span class="udiff-line-modified-added">+         var nextDone = !!nextResult.done;</span>
<span class="udiff-line-modified-added">+         var nextValue = nextResult.value;</span>
<span class="udiff-line-modified-added">+         @resolveWithoutPromise(nextValue,</span>
<span class="udiff-line-modified-added">+             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: nextDone }); },</span>
<span class="udiff-line-modified-added">+             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });</span>
<span class="udiff-line-modified-added">+     } catch (e) {</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     return promise;</span>
  }
  
  function return(value)
  {
      &quot;use strict&quot;;
  
<span class="udiff-line-modified-removed">-     const promiseCapability = @newPromiseCapability(@Promise);</span>
<span class="udiff-line-modified-added">+     var promise = @newPromise();</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="udiff-line-modified-removed">-         return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="udiff-line-modified-added">+         return promise;</span>
      }
  
<span class="udiff-line-modified-removed">-     const syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
<span class="udiff-line-modified-added">+     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
<span class="udiff-line-modified-removed">-     let returnMethod;</span>
<span class="udiff-line-modified-added">+     var returnMethod;</span>
  
      try {
          returnMethod = syncIterator.return;
      } catch (e) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, e);</span>
<span class="udiff-line-modified-removed">-         return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
<span class="udiff-line-modified-added">+         return promise;</span>
      }
  
      if (returnMethod === @undefined) {
<span class="udiff-line-modified-removed">-         promiseCapability.@resolve.@call(@undefined, { value, done: true });</span>
<span class="udiff-line-modified-removed">-         return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value, done: true });</span>
<span class="udiff-line-modified-added">+         return promise;</span>
      }
      
      try {
<span class="udiff-line-modified-removed">-         const returnResult = returnMethod.@call(syncIterator, value);</span>
<span class="udiff-line-modified-added">+         var returnResult = returnMethod.@call(syncIterator, value);</span>
  
          if (!@isObject(returnResult)) {
<span class="udiff-line-modified-removed">-             promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="udiff-line-modified-removed">-             return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+             @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="udiff-line-modified-added">+             return promise;</span>
          }
  
<span class="udiff-line-modified-removed">-         const { value: resultValue, done: resultDone } = returnResult;</span>
<span class="udiff-line-modified-removed">-         const valueWrapperCapability = @newPromiseCapability(@Promise);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         valueWrapperCapability.@resolve.@call(@undefined, resultValue);</span>
<span class="udiff-line-modified-removed">-         valueWrapperCapability.@promise.@then(</span>
<span class="udiff-line-removed">-             function (result) { promiseCapability.@resolve.@call(@undefined, { value: result, done: resultDone }); },</span>
<span class="udiff-line-removed">-             function (error) { promiseCapability.@reject.@call(@undefined, error); });</span>
<span class="udiff-line-modified-added">+         var resultDone = !!returnResult.done;</span>
<span class="udiff-line-modified-added">+         var resultValue = returnResult.value;</span>
<span class="udiff-line-modified-added">+         @resolveWithoutPromise(resultValue,</span>
<span class="udiff-line-modified-added">+             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: resultDone }); },</span>
<span class="udiff-line-modified-added">+             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });</span>
      } catch (e) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, e);</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
      }
  
<span class="udiff-line-modified-removed">-     return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+     return promise;</span>
  }
  
  function throw(exception)
  {
      &quot;use strict&quot;;
  
<span class="udiff-line-modified-removed">-     const promiseCapability = @newPromiseCapability(@Promise);</span>
<span class="udiff-line-modified-added">+     var promise = @newPromise();</span>
  
      if (!@isObject(this) || !@isObject(@getByIdDirectPrivate(this, &quot;syncIterator&quot;))) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="udiff-line-modified-removed">-         return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator is not an object.&#39;));</span>
<span class="udiff-line-modified-added">+         return promise;</span>
      }
  
<span class="udiff-line-modified-removed">-     const syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
<span class="udiff-line-modified-added">+     var syncIterator = @getByIdDirectPrivate(this, &quot;syncIterator&quot;);</span>
  
<span class="udiff-line-modified-removed">-     let throwMethod;</span>
<span class="udiff-line-modified-added">+     var throwMethod;</span>
  
      try {
          throwMethod = syncIterator.throw;
      } catch (e) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, e);</span>
<span class="udiff-line-modified-removed">-         return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
<span class="udiff-line-modified-added">+         return promise;</span>
      }
  
      if (throwMethod === @undefined) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, exception);</span>
<span class="udiff-line-modified-removed">-         return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, exception);</span>
<span class="udiff-line-modified-added">+         return promise;</span>
      }
      
      try {
<span class="udiff-line-modified-removed">-         const throwResult = throwMethod.@call(syncIterator, exception);</span>
<span class="udiff-line-modified-added">+         var throwResult = throwMethod.@call(syncIterator, exception);</span>
          
          if (!@isObject(throwResult)) {
<span class="udiff-line-modified-removed">-             promiseCapability.@reject.@call(@undefined, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="udiff-line-modified-removed">-             return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+             @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, @makeTypeError(&#39;Iterator result interface is not an object.&#39;));</span>
<span class="udiff-line-modified-added">+             return promise;</span>
          }
          
<span class="udiff-line-modified-removed">-         const { value: throwValue, done: throwDone } = throwResult;</span>
<span class="udiff-line-modified-removed">-         const valueWrapperCapability = @newPromiseCapability(@Promise);</span>
<span class="udiff-line-modified-removed">-         </span>
<span class="udiff-line-modified-removed">-         valueWrapperCapability.@resolve.@call(@undefined, throwValue);</span>
<span class="udiff-line-modified-removed">-         valueWrapperCapability.@promise.@then(</span>
<span class="udiff-line-removed">-             function (result) { promiseCapability.@resolve.@call(@undefined, { value: result, done: throwDone }); },</span>
<span class="udiff-line-removed">-             function (error) { promiseCapability.@reject.@call(@undefined, error); });</span>
<span class="udiff-line-modified-added">+         var throwDone = !!throwResult.done;</span>
<span class="udiff-line-modified-added">+         var throwValue = throwResult.value;</span>
<span class="udiff-line-modified-added">+         @resolveWithoutPromise(throwValue,</span>
<span class="udiff-line-modified-added">+             function (result) { @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, { value: result, done: throwDone }); },</span>
<span class="udiff-line-modified-added">+             function (error) { @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error); });</span>
      } catch (e) {
<span class="udiff-line-modified-removed">-         promiseCapability.@reject.@call(@undefined, e);</span>
<span class="udiff-line-modified-added">+         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, e);</span>
      }
      
<span class="udiff-line-modified-removed">-     return promiseCapability.@promise;</span>
<span class="udiff-line-modified-added">+     return promise;</span>
  }
  
  @globalPrivate
  function createAsyncFromSyncIterator(syncIterator, nextMethod)
  {
</pre>
<center><a href="ArrayPrototype.js.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFunctionPrototype.js.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
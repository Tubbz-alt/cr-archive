<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObjectInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpPrototype.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObjectInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,50 ***</span>
  #include &quot;RegExpObject.h&quot;
  
  namespace JSC {
  
  ALWAYS_INLINE unsigned getRegExpObjectLastIndexAsUnsigned(
<span class="line-modified">!     ExecState* exec, RegExpObject* regExpObject, const String&amp; input)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue jsLastIndex = regExpObject-&gt;getLastIndex();
      unsigned lastIndex;
      if (LIKELY(jsLastIndex.isUInt32())) {
          lastIndex = jsLastIndex.asUInt32();
          if (lastIndex &gt; input.length()) {
              scope.release();
<span class="line-modified">!             regExpObject-&gt;setLastIndex(exec, 0);</span>
              return UINT_MAX;
          }
      } else {
<span class="line-modified">!         double doubleLastIndex = jsLastIndex.toInteger(exec);</span>
          RETURN_IF_EXCEPTION(scope, UINT_MAX);
          if (doubleLastIndex &lt; 0 || doubleLastIndex &gt; input.length()) {
              scope.release();
<span class="line-modified">!             regExpObject-&gt;setLastIndex(exec, 0);</span>
              return UINT_MAX;
          }
          lastIndex = static_cast&lt;unsigned&gt;(doubleLastIndex);
      }
      return lastIndex;
  }
  
<span class="line-modified">! inline JSValue RegExpObject::execInline(ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RegExp* regExp = this-&gt;regExp();
<span class="line-modified">!     String input = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      bool globalOrSticky = regExp-&gt;globalOrSticky();
  
      unsigned lastIndex;
      if (globalOrSticky) {
<span class="line-modified">!         lastIndex = getRegExpObjectLastIndexAsUnsigned(exec, this, input);</span>
          EXCEPTION_ASSERT(!scope.exception() || lastIndex == UINT_MAX);
          if (lastIndex == UINT_MAX)
              return jsNull();
      } else
          lastIndex = 0;
<span class="line-new-header">--- 32,50 ---</span>
  #include &quot;RegExpObject.h&quot;
  
  namespace JSC {
  
  ALWAYS_INLINE unsigned getRegExpObjectLastIndexAsUnsigned(
<span class="line-modified">!     JSGlobalObject* globalObject, RegExpObject* regExpObject, const String&amp; input)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSValue jsLastIndex = regExpObject-&gt;getLastIndex();
      unsigned lastIndex;
      if (LIKELY(jsLastIndex.isUInt32())) {
          lastIndex = jsLastIndex.asUInt32();
          if (lastIndex &gt; input.length()) {
              scope.release();
<span class="line-modified">!             regExpObject-&gt;setLastIndex(globalObject, 0);</span>
              return UINT_MAX;
          }
      } else {
<span class="line-modified">!         double doubleLastIndex = jsLastIndex.toInteger(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, UINT_MAX);
          if (doubleLastIndex &lt; 0 || doubleLastIndex &gt; input.length()) {
              scope.release();
<span class="line-modified">!             regExpObject-&gt;setLastIndex(globalObject, 0);</span>
              return UINT_MAX;
          }
          lastIndex = static_cast&lt;unsigned&gt;(doubleLastIndex);
      }
      return lastIndex;
  }
  
<span class="line-modified">! inline JSValue RegExpObject::execInline(JSGlobalObject* globalObject, JSString* string)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RegExp* regExp = this-&gt;regExp();
<span class="line-modified">!     String input = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      bool globalOrSticky = regExp-&gt;globalOrSticky();
  
      unsigned lastIndex;
      if (globalOrSticky) {
<span class="line-modified">!         lastIndex = getRegExpObjectLastIndexAsUnsigned(globalObject, this, input);</span>
          EXCEPTION_ASSERT(!scope.exception() || lastIndex == UINT_MAX);
          if (lastIndex == UINT_MAX)
              return jsNull();
      } else
          lastIndex = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,46 ***</span>
          createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
      if (!array) {
          RETURN_IF_EXCEPTION(scope, { });
          scope.release();
          if (globalOrSticky)
<span class="line-modified">!             setLastIndex(exec, 0);</span>
          return jsNull();
      }
  
      if (globalOrSticky)
<span class="line-modified">!         setLastIndex(exec, result.end);</span>
      RETURN_IF_EXCEPTION(scope, { });
      globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
      return array;
  }
  
  // Shared implementation used by test and exec.
  inline MatchResult RegExpObject::matchInline(
<span class="line-modified">!     ExecState* exec, JSGlobalObject* globalObject, JSString* string)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RegExp* regExp = this-&gt;regExp();
<span class="line-modified">!     String input = string-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!regExp-&gt;global() &amp;&amp; !regExp-&gt;sticky()) {
          scope.release();
          return globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, input, 0);
      }
  
<span class="line-modified">!     unsigned lastIndex = getRegExpObjectLastIndexAsUnsigned(exec, this, input);</span>
      EXCEPTION_ASSERT(!scope.exception() || (lastIndex == UINT_MAX));
      if (lastIndex == UINT_MAX)
          return MatchResult::failed();
  
      MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, input, lastIndex);
      RETURN_IF_EXCEPTION(scope, { });
      scope.release();
<span class="line-modified">!     setLastIndex(exec, result.end);</span>
      return result;
  }
  
  inline unsigned advanceStringUnicode(String s, unsigned length, unsigned currentIndex)
  {
<span class="line-new-header">--- 85,46 ---</span>
          createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
      if (!array) {
          RETURN_IF_EXCEPTION(scope, { });
          scope.release();
          if (globalOrSticky)
<span class="line-modified">!             setLastIndex(globalObject, 0);</span>
          return jsNull();
      }
  
      if (globalOrSticky)
<span class="line-modified">!         setLastIndex(globalObject, result.end);</span>
      RETURN_IF_EXCEPTION(scope, { });
      globalObject-&gt;regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
      return array;
  }
  
  // Shared implementation used by test and exec.
  inline MatchResult RegExpObject::matchInline(
<span class="line-modified">!     JSGlobalObject* globalObject, JSString* string)</span>
  {
      VM&amp; vm = globalObject-&gt;vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RegExp* regExp = this-&gt;regExp();
<span class="line-modified">!     String input = string-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!regExp-&gt;global() &amp;&amp; !regExp-&gt;sticky()) {
          scope.release();
          return globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, input, 0);
      }
  
<span class="line-modified">!     unsigned lastIndex = getRegExpObjectLastIndexAsUnsigned(globalObject, this, input);</span>
      EXCEPTION_ASSERT(!scope.exception() || (lastIndex == UINT_MAX));
      if (lastIndex == UINT_MAX)
          return MatchResult::failed();
  
      MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, input, lastIndex);
      RETURN_IF_EXCEPTION(scope, { });
      scope.release();
<span class="line-modified">!     setLastIndex(globalObject, result.end);</span>
      return result;
  }
  
  inline unsigned advanceStringUnicode(String s, unsigned length, unsigned currentIndex)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,30 ***</span>
  
      return currentIndex + 2;
  }
  
  template&lt;typename FixEndFunc&gt;
<span class="line-modified">! JSValue collectMatches(VM&amp; vm, ExecState* exec, JSString* string, const String&amp; s, JSGlobalObject* globalObject, RegExp* regExp, const FixEndFunc&amp; fixEnd)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, s, 0);
      RETURN_IF_EXCEPTION(scope, { });
      if (!result)
          return jsNull();
  
      static unsigned maxSizeForDirectPath = 100000;
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      bool hasException = false;
      unsigned arrayIndex = 0;
      auto iterate = [&amp;] () {
          size_t end = result.end;
          size_t length = end - result.start;
<span class="line-modified">!         array-&gt;putDirectIndex(exec, arrayIndex++, jsSubstringOfResolved(vm, string, result.start, length));</span>
          if (UNLIKELY(scope.exception())) {
              hasException = true;
              return;
          }
          if (!length)
<span class="line-new-header">--- 141,30 ---</span>
  
      return currentIndex + 2;
  }
  
  template&lt;typename FixEndFunc&gt;
<span class="line-modified">! JSValue collectMatches(VM&amp; vm, JSGlobalObject* globalObject, JSString* string, const String&amp; s, RegExp* regExp, const FixEndFunc&amp; fixEnd)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      MatchResult result = globalObject-&gt;regExpGlobalData().performMatch(vm, globalObject, regExp, string, s, 0);
      RETURN_IF_EXCEPTION(scope, { });
      if (!result)
          return jsNull();
  
      static unsigned maxSizeForDirectPath = 100000;
  
<span class="line-modified">!     JSArray* array = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      bool hasException = false;
      unsigned arrayIndex = 0;
      auto iterate = [&amp;] () {
          size_t end = result.end;
          size_t length = end - result.start;
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, arrayIndex++, jsSubstringOfResolved(vm, string, result.start, length));</span>
          if (UNLIKELY(scope.exception())) {
              hasException = true;
              return;
          }
          if (!length)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,11 ***</span>
              // First do a throw-away match to see how many matches we&#39;ll get.
              unsigned matchCount = 0;
              MatchResult savedResult = result;
              do {
                  if (array-&gt;length() + matchCount &gt; MAX_STORAGE_VECTOR_LENGTH) {
<span class="line-modified">!                     throwOutOfMemoryError(exec, scope);</span>
                      return jsUndefined();
                  }
  
                  size_t end = result.end;
                  matchCount++;
<span class="line-new-header">--- 181,11 ---</span>
              // First do a throw-away match to see how many matches we&#39;ll get.
              unsigned matchCount = 0;
              MatchResult savedResult = result;
              do {
                  if (array-&gt;length() + matchCount &gt; MAX_STORAGE_VECTOR_LENGTH) {
<span class="line-modified">!                     throwOutOfMemoryError(globalObject, scope);</span>
                      return jsUndefined();
                  }
  
                  size_t end = result.end;
                  matchCount++;
</pre>
<center><a href="RegExpObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegExpPrototype.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
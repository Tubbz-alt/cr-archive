<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/double-conversion.cc</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../dtoa.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/dtoa/double-conversion.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
188   }
189 
190   int exponent = decimal_point - 1;
191   if ((decimal_in_shortest_low_ &lt;= exponent) &amp;&amp;
192       (exponent &lt; decimal_in_shortest_high_)) {
193     CreateDecimalRepresentation(decimal_rep, decimal_rep_length,
194                                 decimal_point,
195                                 Max(0, decimal_rep_length - decimal_point),
196                                 result_builder);
197   } else {
198     CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,
199                                     result_builder);
200   }
201   return true;
202 }
203 
204 
205 bool DoubleToStringConverter::ToFixed(double value,
206                                       int requested_digits,
207                                       StringBuilder* result_builder) const {
<span class="line-modified">208   ASSERT(kMaxFixedDigitsBeforePoint == 60);</span>
<span class="line-modified">209   const double kFirstNonFixed = 1e60;</span>
210 
211   if (Double(value).IsSpecial()) {
212     return HandleSpecialValues(value, result_builder);
213   }
214 
215   if (requested_digits &gt; kMaxFixedDigitsAfterPoint) return false;
216   if (value &gt;= kFirstNonFixed || value &lt;= -kFirstNonFixed) return false;
217 
218   // Find a sufficiently precise decimal representation of n.
219   int decimal_point;
220   bool sign;
221   // Add space for the &#39;\0&#39; byte.
222   const int kDecimalRepCapacity =
223       kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;
224   char decimal_rep[kDecimalRepCapacity];
225   int decimal_rep_length;
226   DoubleToAscii(value, FIXED, requested_digits,
227                 decimal_rep, kDecimalRepCapacity,
228                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
229 
</pre>
<hr />
<pre>
250   if (requested_digits &gt; kMaxExponentialDigits) return false;
251 
252   int decimal_point;
253   bool sign;
254   // Add space for digit before the decimal point and the &#39;\0&#39; character.
255   const int kDecimalRepCapacity = kMaxExponentialDigits + 2;
256   ASSERT(kDecimalRepCapacity &gt; kBase10MaximalLength);
257   char decimal_rep[kDecimalRepCapacity];
258   int decimal_rep_length;
259 
260   if (requested_digits == -1) {
261     DoubleToAscii(value, SHORTEST, 0,
262                   decimal_rep, kDecimalRepCapacity,
263                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
264   } else {
265     DoubleToAscii(value, PRECISION, requested_digits + 1,
266                   decimal_rep, kDecimalRepCapacity,
267                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
268     ASSERT(decimal_rep_length &lt;= requested_digits + 1);
269 
<span class="line-modified">270     for (int i = decimal_rep_length; i &lt; requested_digits + 1; ++i) {</span>
<span class="line-modified">271       decimal_rep[i] = &#39;0&#39;;</span>



272     }
<span class="line-removed">273     decimal_rep_length = requested_digits + 1;</span>
274   }
275 
276   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
277   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
278     result_builder-&gt;AddCharacter(&#39;-&#39;);
279   }
280 
281   int exponent = decimal_point - 1;
282   CreateExponentialRepresentation(decimal_rep,
283                                   decimal_rep_length,
284                                   exponent,
285                                   result_builder);
286   return true;
287 }
288 
289 
290 bool DoubleToStringConverter::ToPrecision(double value,
291                                           int precision,
292                                           StringBuilder* result_builder) const {
293   if (Double(value).IsSpecial()) {
</pre>
</td>
<td>
<hr />
<pre>
188   }
189 
190   int exponent = decimal_point - 1;
191   if ((decimal_in_shortest_low_ &lt;= exponent) &amp;&amp;
192       (exponent &lt; decimal_in_shortest_high_)) {
193     CreateDecimalRepresentation(decimal_rep, decimal_rep_length,
194                                 decimal_point,
195                                 Max(0, decimal_rep_length - decimal_point),
196                                 result_builder);
197   } else {
198     CreateExponentialRepresentation(decimal_rep, decimal_rep_length, exponent,
199                                     result_builder);
200   }
201   return true;
202 }
203 
204 
205 bool DoubleToStringConverter::ToFixed(double value,
206                                       int requested_digits,
207                                       StringBuilder* result_builder) const {
<span class="line-modified">208   ASSERT(kMaxFixedDigitsBeforePoint == 21);</span>
<span class="line-modified">209   const double kFirstNonFixed = 1e21;</span>
210 
211   if (Double(value).IsSpecial()) {
212     return HandleSpecialValues(value, result_builder);
213   }
214 
215   if (requested_digits &gt; kMaxFixedDigitsAfterPoint) return false;
216   if (value &gt;= kFirstNonFixed || value &lt;= -kFirstNonFixed) return false;
217 
218   // Find a sufficiently precise decimal representation of n.
219   int decimal_point;
220   bool sign;
221   // Add space for the &#39;\0&#39; byte.
222   const int kDecimalRepCapacity =
223       kMaxFixedDigitsBeforePoint + kMaxFixedDigitsAfterPoint + 1;
224   char decimal_rep[kDecimalRepCapacity];
225   int decimal_rep_length;
226   DoubleToAscii(value, FIXED, requested_digits,
227                 decimal_rep, kDecimalRepCapacity,
228                 &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
229 
</pre>
<hr />
<pre>
250   if (requested_digits &gt; kMaxExponentialDigits) return false;
251 
252   int decimal_point;
253   bool sign;
254   // Add space for digit before the decimal point and the &#39;\0&#39; character.
255   const int kDecimalRepCapacity = kMaxExponentialDigits + 2;
256   ASSERT(kDecimalRepCapacity &gt; kBase10MaximalLength);
257   char decimal_rep[kDecimalRepCapacity];
258   int decimal_rep_length;
259 
260   if (requested_digits == -1) {
261     DoubleToAscii(value, SHORTEST, 0,
262                   decimal_rep, kDecimalRepCapacity,
263                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
264   } else {
265     DoubleToAscii(value, PRECISION, requested_digits + 1,
266                   decimal_rep, kDecimalRepCapacity,
267                   &amp;sign, &amp;decimal_rep_length, &amp;decimal_point);
268     ASSERT(decimal_rep_length &lt;= requested_digits + 1);
269 
<span class="line-modified">270     if (decimal_rep_length &lt; requested_digits + 1) {</span>
<span class="line-modified">271       for (int i = decimal_rep_length; i &lt; requested_digits + 1; ++i)</span>
<span class="line-added">272         decimal_rep[i] = &#39;0&#39;;</span>
<span class="line-added">273       decimal_rep_length = requested_digits + 1;</span>
<span class="line-added">274       decimal_rep[decimal_rep_length] = &#39;\0&#39;;</span>
275     }

276   }
277 
278   bool unique_zero = ((flags_ &amp; UNIQUE_ZERO) != 0);
279   if (sign &amp;&amp; (value != 0.0 || !unique_zero)) {
280     result_builder-&gt;AddCharacter(&#39;-&#39;);
281   }
282 
283   int exponent = decimal_point - 1;
284   CreateExponentialRepresentation(decimal_rep,
285                                   decimal_rep_length,
286                                   exponent,
287                                   result_builder);
288   return true;
289 }
290 
291 
292 bool DoubleToStringConverter::ToPrecision(double value,
293                                           int precision,
294                                           StringBuilder* result_builder) const {
295   if (Double(value).IsSpecial()) {
</pre>
</td>
</tr>
</table>
<center><a href="../dtoa.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="double-conversion.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeviceOrientationOrMotionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Document.h&quot;
  30 
  31 #include &quot;AXObjectCache.h&quot;
<span class="line-removed">  32 #include &quot;ApplicationStateChangeListener.h&quot;</span>
  33 #include &quot;Attr.h&quot;
  34 #include &quot;BeforeUnloadEvent.h&quot;
  35 #include &quot;CDATASection.h&quot;
  36 #include &quot;CSSAnimationController.h&quot;
  37 #include &quot;CSSFontSelector.h&quot;
  38 #include &quot;CSSStyleDeclaration.h&quot;
  39 #include &quot;CSSStyleSheet.h&quot;
  40 #include &quot;CachedCSSStyleSheet.h&quot;
  41 #include &quot;CachedFrame.h&quot;
  42 #include &quot;CachedResourceLoader.h&quot;
  43 #include &quot;CanvasRenderingContext2D.h&quot;
  44 #include &quot;Chrome.h&quot;
  45 #include &quot;ChromeClient.h&quot;
  46 #include &quot;Comment.h&quot;
  47 #include &quot;CommonVM.h&quot;
  48 #include &quot;ComposedTreeIterator.h&quot;
  49 #include &quot;CompositionEvent.h&quot;
  50 #include &quot;ConstantPropertyMap.h&quot;
  51 #include &quot;ContentSecurityPolicy.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;CustomElementReactionQueue.h&quot;
  54 #include &quot;CustomElementRegistry.h&quot;
  55 #include &quot;CustomEvent.h&quot;
  56 #include &quot;CustomHeaderFields.h&quot;
  57 #include &quot;DOMImplementation.h&quot;
  58 #include &quot;DOMWindow.h&quot;
  59 #include &quot;DateComponents.h&quot;
  60 #include &quot;DebugPageOverlays.h&quot;

  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;

  66 #include &quot;Editing.h&quot;
  67 #include &quot;Editor.h&quot;
  68 #include &quot;ElementIterator.h&quot;
  69 #include &quot;EventHandler.h&quot;
  70 #include &quot;ExtensionStyleSheets.h&quot;
  71 #include &quot;FocusController.h&quot;
  72 #include &quot;FocusEvent.h&quot;
  73 #include &quot;FontFaceSet.h&quot;
  74 #include &quot;FormController.h&quot;
  75 #include &quot;Frame.h&quot;
  76 #include &quot;FrameLoader.h&quot;
  77 #include &quot;FrameLoaderClient.h&quot;
  78 #include &quot;FrameView.h&quot;
  79 #include &quot;FullscreenManager.h&quot;

  80 #include &quot;GenericCachedHTMLCollection.h&quot;
  81 #include &quot;HTMLAllCollection.h&quot;
  82 #include &quot;HTMLAnchorElement.h&quot;
  83 #include &quot;HTMLAttachmentElement.h&quot;
  84 #include &quot;HTMLBaseElement.h&quot;
  85 #include &quot;HTMLBodyElement.h&quot;
  86 #include &quot;HTMLCanvasElement.h&quot;
  87 #include &quot;HTMLDocument.h&quot;
  88 #include &quot;HTMLElementFactory.h&quot;
  89 #include &quot;HTMLFormControlElement.h&quot;
  90 #include &quot;HTMLFrameOwnerElement.h&quot;
  91 #include &quot;HTMLFrameSetElement.h&quot;
  92 #include &quot;HTMLHeadElement.h&quot;
  93 #include &quot;HTMLHtmlElement.h&quot;
  94 #include &quot;HTMLImageElement.h&quot;
  95 #include &quot;HTMLInputElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #include &quot;HTMLMediaElement.h&quot;
  98 #include &quot;HTMLNameCollection.h&quot;
  99 #include &quot;HTMLParserIdioms.h&quot;
 100 #include &quot;HTMLPictureElement.h&quot;
 101 #include &quot;HTMLPlugInElement.h&quot;
 102 #include &quot;HTMLScriptElement.h&quot;
 103 #include &quot;HTMLStyleElement.h&quot;
 104 #include &quot;HTMLTitleElement.h&quot;
 105 #include &quot;HTMLUnknownElement.h&quot;
 106 #include &quot;HTTPHeaderNames.h&quot;
 107 #include &quot;HTTPParsers.h&quot;
 108 #include &quot;HashChangeEvent.h&quot;

 109 #include &quot;History.h&quot;
 110 #include &quot;HitTestResult.h&quot;

 111 #include &quot;ImageBitmapRenderingContext.h&quot;
 112 #include &quot;ImageLoader.h&quot;
 113 #include &quot;InspectorInstrumentation.h&quot;
 114 #include &quot;IntersectionObserver.h&quot;
 115 #include &quot;JSCustomElementInterface.h&quot;
 116 #include &quot;JSLazyEventListener.h&quot;
 117 #include &quot;KeyboardEvent.h&quot;
 118 #include &quot;KeyframeEffect.h&quot;
 119 #include &quot;LayoutDisallowedScope.h&quot;

 120 #include &quot;LibWebRTCProvider.h&quot;
 121 #include &quot;LoaderStrategy.h&quot;
 122 #include &quot;Logging.h&quot;
 123 #include &quot;MediaCanStartListener.h&quot;
 124 #include &quot;MediaProducer.h&quot;
 125 #include &quot;MediaQueryList.h&quot;
 126 #include &quot;MediaQueryMatcher.h&quot;
 127 #include &quot;MediaStream.h&quot;
 128 #include &quot;MessageEvent.h&quot;
<span class="line-removed"> 129 #include &quot;Microtasks.h&quot;</span>
 130 #include &quot;MouseEventWithHitTestResults.h&quot;
 131 #include &quot;MutationEvent.h&quot;
 132 #include &quot;NameNodeList.h&quot;
 133 #include &quot;NavigationDisabler.h&quot;
 134 #include &quot;NavigationScheduler.h&quot;
 135 #include &quot;NestingLevelIncrementer.h&quot;
 136 #include &quot;NodeIterator.h&quot;
 137 #include &quot;NodeRareData.h&quot;
 138 #include &quot;NodeWithIndex.h&quot;
 139 #include &quot;OverflowEvent.h&quot;
 140 #include &quot;PageConsoleClient.h&quot;
 141 #include &quot;PageGroup.h&quot;
 142 #include &quot;PageTransitionEvent.h&quot;
 143 #include &quot;PaintWorkletGlobalScope.h&quot;
 144 #include &quot;PlatformLocale.h&quot;
 145 #include &quot;PlatformMediaSessionManager.h&quot;
 146 #include &quot;PlatformScreen.h&quot;
 147 #include &quot;PlatformStrategies.h&quot;
 148 #include &quot;PlugInsResources.h&quot;
 149 #include &quot;PluginDocument.h&quot;
</pre>
<hr />
<pre>
 158 #include &quot;RenderInline.h&quot;
 159 #include &quot;RenderLayerCompositor.h&quot;
 160 #include &quot;RenderLineBreak.h&quot;
 161 #include &quot;RenderTreeUpdater.h&quot;
 162 #include &quot;RenderView.h&quot;
 163 #include &quot;RenderWidget.h&quot;
 164 #include &quot;RequestAnimationFrameCallback.h&quot;
 165 #include &quot;ResizeObserver.h&quot;
 166 #include &quot;ResourceLoadObserver.h&quot;
 167 #include &quot;RuntimeApplicationChecks.h&quot;
 168 #include &quot;RuntimeEnabledFeatures.h&quot;
 169 #include &quot;SVGDocumentExtensions.h&quot;
 170 #include &quot;SVGElement.h&quot;
 171 #include &quot;SVGElementFactory.h&quot;
 172 #include &quot;SVGNames.h&quot;
 173 #include &quot;SVGSVGElement.h&quot;
 174 #include &quot;SVGTitleElement.h&quot;
 175 #include &quot;SVGUseElement.h&quot;
 176 #include &quot;SVGZoomEvent.h&quot;
 177 #include &quot;SWClientConnection.h&quot;
<span class="line-removed"> 178 #include &quot;SchemeRegistry.h&quot;</span>
 179 #include &quot;ScopedEventQueue.h&quot;
 180 #include &quot;ScriptController.h&quot;
 181 #include &quot;ScriptDisallowedScope.h&quot;
 182 #include &quot;ScriptModuleLoader.h&quot;
 183 #include &quot;ScriptRunner.h&quot;
 184 #include &quot;ScriptSourceCode.h&quot;
 185 #include &quot;ScriptState.h&quot;
 186 #include &quot;ScriptedAnimationController.h&quot;
 187 #include &quot;ScrollbarTheme.h&quot;
 188 #include &quot;ScrollingCoordinator.h&quot;
 189 #include &quot;SecurityOrigin.h&quot;
 190 #include &quot;SecurityOriginData.h&quot;
 191 #include &quot;SecurityOriginPolicy.h&quot;
 192 #include &quot;SecurityPolicy.h&quot;
 193 #include &quot;SegmentedString.h&quot;
 194 #include &quot;SelectorQuery.h&quot;
 195 #include &quot;ServiceWorkerClientData.h&quot;

 196 #include &quot;ServiceWorkerProvider.h&quot;
 197 #include &quot;Settings.h&quot;
 198 #include &quot;ShadowRoot.h&quot;
 199 #include &quot;SocketProvider.h&quot;
 200 #include &quot;StorageEvent.h&quot;
 201 #include &quot;StringCallback.h&quot;
 202 #include &quot;StyleColor.h&quot;
 203 #include &quot;StyleProperties.h&quot;
 204 #include &quot;StyleResolveForDocument.h&quot;
 205 #include &quot;StyleResolver.h&quot;
 206 #include &quot;StyleScope.h&quot;
 207 #include &quot;StyleSheetContents.h&quot;
 208 #include &quot;StyleSheetList.h&quot;
 209 #include &quot;StyleTreeResolver.h&quot;
 210 #include &quot;SubresourceLoader.h&quot;
 211 #include &quot;TextAutoSizing.h&quot;
 212 #include &quot;TextEvent.h&quot;

 213 #include &quot;TextNodeTraversal.h&quot;
 214 #include &quot;TouchAction.h&quot;
 215 #include &quot;TransformSource.h&quot;
 216 #include &quot;TreeWalker.h&quot;
 217 #include &quot;UndoManager.h&quot;
 218 #include &quot;UserGestureIndicator.h&quot;
 219 #include &quot;ValidationMessageClient.h&quot;
 220 #include &quot;VisibilityChangeClient.h&quot;
 221 #include &quot;VisitedLinkState.h&quot;

 222 #include &quot;WebAnimation.h&quot;
 223 #include &quot;WheelEvent.h&quot;

 224 #include &quot;WindowFeatures.h&quot;
 225 #include &quot;Worklet.h&quot;
 226 #include &quot;XMLDocument.h&quot;
 227 #include &quot;XMLDocumentParser.h&quot;
 228 #include &quot;XMLNSNames.h&quot;
 229 #include &quot;XMLNames.h&quot;
 230 #include &quot;XPathEvaluator.h&quot;
 231 #include &quot;XPathExpression.h&quot;
 232 #include &quot;XPathNSResolver.h&quot;
 233 #include &quot;XPathResult.h&quot;
 234 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 235 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 236 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 237 #include &lt;JavaScriptCore/VM.h&gt;
 238 #include &lt;ctime&gt;
 239 #include &lt;wtf/IsoMallocInlines.h&gt;
 240 #include &lt;wtf/Language.h&gt;
 241 #include &lt;wtf/NeverDestroyed.h&gt;
 242 #include &lt;wtf/SetForScope.h&gt;
 243 #include &lt;wtf/SystemTracing.h&gt;
</pre>
<hr />
<pre>
 308 #endif
 309 
 310 #if ENABLE(XSLT)
 311 #include &quot;XSLTProcessor.h&quot;
 312 #endif
 313 
 314 #if ENABLE(WEBGL)
 315 #include &quot;WebGLRenderingContext.h&quot;
 316 #endif
 317 #if ENABLE(WEBGL2)
 318 #include &quot;WebGL2RenderingContext.h&quot;
 319 #endif
 320 #if ENABLE(WEBGPU)
 321 #include &quot;GPUCanvasContext.h&quot;
 322 #endif
 323 
 324 #if ENABLE(POINTER_EVENTS)
 325 #include &quot;PointerCaptureController.h&quot;
 326 #endif
 327 




 328 namespace WebCore {
 329 
 330 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 331 
 332 using namespace HTMLNames;
 333 using namespace PAL;
 334 using namespace WTF::Unicode;
 335 
 336 static const unsigned cMaxWriteRecursionDepth = 21;
 337 bool Document::hasEverCreatedAnAXObjectCache = false;
 338 static const Seconds maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying { 1_s };
 339 
 340 struct FrameFlatteningLayoutDisallower {
 341     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 342         : m_frameView(frameView)
 343         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 344     {
 345         if (m_disallowLayout)
 346             m_frameView.startDisallowingLayout();
 347     }
 348 
 349     ~FrameFlatteningLayoutDisallower()
 350     {
 351         if (m_disallowLayout)
 352             m_frameView.endDisallowingLayout();
 353     }
 354 
 355 private:
 356     FrameView&amp; m_frameView;
 357     bool m_disallowLayout { false };
 358 };
 359 








 360 #if ENABLE(INTERSECTION_OBSERVER)
 361 static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };
 362 #endif
 363 
 364 // DOM Level 2 says (letters added):
 365 //
 366 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 367 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 368 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 369 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 370 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 371 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 372 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 373 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 374 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 375 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 376 //
 377 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 378 
 379 static inline bool isValidNameStart(UChar32 c)
</pre>
<hr />
<pre>
 509     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 510     return documents;
 511 }
 512 
 513 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 514 {
 515     return allDocumentsMap().values();
 516 }
 517 
 518 static inline int currentOrientation(Frame* frame)
 519 {
 520 #if ENABLE(ORIENTATION_EVENTS)
 521     if (frame)
 522         return frame-&gt;orientation();
 523 #else
 524     UNUSED_PARAM(frame);
 525 #endif
 526     return 0;
 527 }
 528 
<span class="line-modified"> 529 Document::Document(PAL::SessionID sessionID, Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
 530     : ContainerNode(*this, CreateDocument)
 531     , TreeScope(*this)
 532     , FrameDestructionObserver(frame)
 533 #if ENABLE(IOS_TOUCH_EVENTS)
 534     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 535 #endif
 536     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 537     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 538     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 539     , m_domTreeVersion(++s_globalTreeVersion)
 540     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 541     , m_extensionStyleSheets(makeUnique&lt;ExtensionStyleSheets&gt;(*this))
 542     , m_visitedLinkState(makeUnique&lt;VisitedLinkState&gt;(*this))
 543     , m_markers(makeUnique&lt;DocumentMarkerController&gt;(*this))
 544     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 545     , m_documentCreationTime(MonotonicTime::now())
 546     , m_scriptRunner(makeUnique&lt;ScriptRunner&gt;(*this))
 547     , m_moduleLoader(makeUnique&lt;ScriptModuleLoader&gt;(*this))
 548 #if ENABLE(XSLT)
 549     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 550 #endif
 551     , m_xmlVersion(&quot;1.0&quot;_s)
 552     , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))
 553     , m_documentClasses(documentClasses)
<span class="line-removed"> 554     , m_eventQueue(*this)</span>
 555 #if ENABLE(FULLSCREEN_API)
 556     , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }
 557 #endif
 558 #if ENABLE(INTERSECTION_OBSERVER)
 559     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
 560     , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)
 561 #endif
 562     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 563 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified"> 564     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;())</span>
 565     , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
<span class="line-modified"> 566     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;())</span>
 567     , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
 568 #endif
 569     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 570     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 571     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 572     , m_fontSelector(CSSFontSelector::create(*this))
 573     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 574     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 575     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 576     , m_isSynthesized(constructionFlags &amp; Synthesized)
 577     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 578     , m_orientationNotifier(currentOrientation(frame))
<span class="line-removed"> 579     , m_sessionID(sessionID)</span>
 580     , m_identifier(DocumentIdentifier::generate())
 581     , m_undoManager(UndoManager::create(*this))
 582 {
<span class="line-removed"> 583     ASSERT(!frame || frame-&gt;sessionID() == m_sessionID);</span>
<span class="line-removed"> 584 </span>
 585     auto addResult = allDocumentsMap().add(m_identifier, this);
 586     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 587 
 588     // We depend on the url getting immediately set in subframes, but we
 589     // also depend on the url NOT getting immediately set in opened windows.
 590     // See fast/dom/early-frame-url.html
 591     // and fast/dom/location-new-window-no-crash.html, respectively.
 592     // FIXME: Can/should we unify this behavior?
 593     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 594         setURL(url);
 595 
 596     m_cachedResourceLoader-&gt;setDocument(this);
 597 
 598     resetLinkColor();
 599     resetVisitedLinkColor();
 600     resetActiveLinkColor();
 601 
 602     initSecurityContext();
 603     initDNSPrefetch();
 604 
 605     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 606 
 607     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 608         nodeListAndCollectionCount = 0;
 609 
 610     InspectorInstrumentation::addEventListenersToNode(*this);



 611 }
 612 
 613 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 614 {
<span class="line-modified"> 615     auto document = adoptRef(*new Document(contextDocument.sessionID(), nullptr, URL()));</span>
 616     document-&gt;setContextDocument(contextDocument);
 617     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 618     return document;
 619 }
 620 
 621 Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)
 622 {
<span class="line-modified"> 623     return adoptRef(*new Document(frame.sessionID(), &amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
 624 }
 625 
 626 Document::~Document()
 627 {


 628     if (m_logger)
 629         m_logger-&gt;removeObserver(*this);
 630 
 631     ASSERT(allDocumentsMap().contains(m_identifier));
 632     allDocumentsMap().remove(m_identifier);
 633     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 634     removeFromContextsMap();
 635 
 636     ASSERT(!renderView());
<span class="line-modified"> 637     ASSERT(m_pageCacheState != InPageCache);</span>
 638     ASSERT(m_ranges.isEmpty());
 639     ASSERT(!m_parentTreeScope);
 640     ASSERT(!m_disabledFieldsetElementsCount);
 641     ASSERT(m_inDocumentShadowRoots.isEmpty());
 642 
 643 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 644     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 645     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
 646 #endif
 647 
 648     if (m_templateDocument)
 649         m_templateDocument-&gt;setTemplateDocumentHost(nullptr); // balanced in templateDocument().
 650 
 651     // FIXME: Should we reset m_domWindow when we detach from the Frame?
 652     if (m_domWindow)
 653         m_domWindow-&gt;resetUnlessSuspendedForDocumentSuspension();
 654 
 655     m_scriptRunner = nullptr;
 656     m_moduleLoader = nullptr;
 657 
</pre>
<hr />
<pre>
 737         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 738         // so tear down scope information up front to avoid having
 739         // stale references in the map.
 740 
 741         destroyTreeScopeData();
 742         removeDetachedChildren();
 743         m_formController = nullptr;
 744 
 745         m_markers-&gt;detach();
 746 
 747         m_cssCanvasElements.clear();
 748 
 749         commonTeardown();
 750 
 751 #ifndef NDEBUG
 752         // We need to do this right now since selfOnlyDeref() can delete this.
 753         m_inRemovedLastRefFunction = false;
 754 #endif
 755         decrementReferencingNodeCount();
 756     } else {

 757 #ifndef NDEBUG
 758         m_inRemovedLastRefFunction = false;
 759         m_deletionHasBegun = true;
 760 #endif
 761         delete this;
 762     }
 763 }
 764 
 765 void Document::commonTeardown()
 766 {






 767     if (svgExtensions())
 768         accessSVGExtensions().pauseAnimations();
 769 
 770     clearScriptedAnimationController();





 771 }
 772 
 773 Element* Document::elementForAccessKey(const String&amp; key)
 774 {
 775     if (key.isEmpty())
 776         return nullptr;
 777     if (!m_accessKeyCache)
 778         buildAccessKeyCache();
 779     return m_accessKeyCache-&gt;get(key);
 780 }
 781 
 782 void Document::buildAccessKeyCache()
 783 {
 784     m_accessKeyCache = makeUnique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {
 785         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 786         for (auto&amp; node : composedTreeDescendants(*this)) {
 787             if (!is&lt;Element&gt;(node))
 788                 continue;
 789             auto&amp; element = downcast&lt;Element&gt;(node);
 790             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
</pre>
<hr />
<pre>
1133 #endif
1134 
1135     if (element)
1136         m_sawElementsInKnownNamespaces = true;
1137     else
1138         element = Element::create(name, document());
1139 
1140     // &lt;image&gt; uses imgTag so we need a special rule.
1141     ASSERT((name.matches(imageTag) &amp;&amp; element-&gt;tagQName().matches(imgTag) &amp;&amp; element-&gt;tagQName().prefix() == name.prefix()) || name == element-&gt;tagQName());
1142 
1143     return element.releaseNonNull();
1144 }
1145 
1146 // https://html.spec.whatwg.org/#valid-custom-element-name
1147 
1148 struct UnicodeCodePointRange {
1149     UChar32 minimum;
1150     UChar32 maximum;
1151 };
1152 
<span class="line-modified">1153 #if !ASSERT_DISABLED</span>
1154 
1155 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
1156 {
1157     ASSERT(a.minimum &lt;= a.maximum);
1158     ASSERT(b.minimum &lt;= b.maximum);
1159     return a.maximum &lt; b.minimum;
1160 }
1161 
<span class="line-modified">1162 #endif</span>
1163 
1164 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
1165 {
1166     ASSERT(a.minimum &lt;= a.maximum);
1167     return a.maximum &lt; b;
1168 }
1169 
1170 static inline bool operator&lt;(UChar32 a, const UnicodeCodePointRange&amp; b)
1171 {
1172     ASSERT(b.minimum &lt;= b.maximum);
1173     return a &lt; b.minimum;
1174 }
1175 
1176 static inline bool isPotentialCustomElementNameCharacter(UChar32 character)
1177 {
1178     static const UnicodeCodePointRange ranges[] = {
1179         { &#39;-&#39;, &#39;.&#39; },
1180         { &#39;0&#39;, &#39;9&#39; },
1181         { &#39;_&#39;, &#39;_&#39; },
1182         { &#39;a&#39;, &#39;z&#39; },
</pre>
<hr />
<pre>
1590         updateTitle({ });
1591         return;
1592     }
1593 
1594     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1595         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1596     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1597         // FIXME: Does the SVG title element have a text direction?
1598         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1599     }
1600 }
1601 
1602 void Document::setTitle(const String&amp; title)
1603 {
1604     auto* element = documentElement();
1605     if (is&lt;SVGSVGElement&gt;(element)) {
1606         if (!m_titleElement) {
1607             m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
1608             element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
1609         }
<span class="line-modified">1610         m_titleElement-&gt;setTextContent(title);</span>


1611     } else if (is&lt;HTMLElement&gt;(element)) {
1612         if (!m_titleElement) {
1613             auto* headElement = head();
1614             if (!headElement)
1615                 return;
1616             m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
1617             headElement-&gt;appendChild(*m_titleElement);
1618         }
<span class="line-modified">1619         m_titleElement-&gt;setTextContent(title);</span>


1620     }
1621 }
1622 
1623 template&lt;typename&gt; struct TitleTraits;
1624 
1625 template&lt;&gt; struct TitleTraits&lt;HTMLTitleElement&gt; {
1626     static bool isInEligibleLocation(HTMLTitleElement&amp; element) { return element.isConnected() &amp;&amp; !element.isInShadowTree(); }
1627     static HTMLTitleElement* findTitleElement(Document&amp; document) { return descendantsOfType&lt;HTMLTitleElement&gt;(document).first(); }
1628 };
1629 
1630 template&lt;&gt; struct TitleTraits&lt;SVGTitleElement&gt; {
1631     static bool isInEligibleLocation(SVGTitleElement&amp; element) { return element.parentNode() == element.document().documentElement(); }
1632     static SVGTitleElement* findTitleElement(Document&amp; document) { return childrenOfType&lt;SVGTitleElement&gt;(*document.documentElement()).first(); }
1633 };
1634 
1635 template&lt;typename TitleElement&gt; Element* selectNewTitleElement(Document&amp; document, Element* oldTitleElement, Element&amp; changingTitleElement)
1636 {
1637     using Traits = TitleTraits&lt;TitleElement&gt;;
1638 
1639     if (!is&lt;TitleElement&gt;(changingTitleElement)) {
</pre>
<hr />
<pre>
1684 void Document::titleElementTextChanged(Element&amp; titleElement)
1685 {
1686     if (m_titleElement != &amp;titleElement)
1687         return;
1688 
1689     updateTitleFromTitleElement();
1690 }
1691 
1692 void Document::registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1693 {
1694     m_visibilityStateCallbackClients.add(&amp;client);
1695 }
1696 
1697 void Document::unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1698 {
1699     m_visibilityStateCallbackClients.remove(&amp;client);
1700 }
1701 
1702 void Document::visibilityStateChanged()
1703 {
<span class="line-modified">1704     enqueueDocumentEvent(Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>

1705     for (auto* client : m_visibilityStateCallbackClients)
1706         client-&gt;visibilityStateChanged();
1707 
<span class="line-modified">1708     notifyMediaCaptureOfVisibilityChanged();</span>



1709 }
1710 
1711 VisibilityState Document::visibilityState() const
1712 {
1713     // The visibility of the document is inherited from the visibility of the
1714     // page. If there is no page associated with the document, we will assume
1715     // that the page is hidden, as specified by the spec:
1716     // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#dom-document-hidden
1717     if (!m_frame || !m_frame-&gt;page())
1718         return VisibilityState::Hidden;
1719     return m_frame-&gt;page()-&gt;visibilityState();
1720 }
1721 
1722 bool Document::hidden() const
1723 {
1724     return visibilityState() != VisibilityState::Visible;
1725 }
1726 
1727 #if ENABLE(VIDEO)
1728 
<span class="line-modified">1729 void Document::registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)</span>
1730 {
<span class="line-modified">1731     m_allowsMediaDocumentInlinePlaybackElements.add(&amp;element);</span>
1732 }
1733 
<span class="line-modified">1734 void Document::unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp; element)</span>
1735 {
<span class="line-modified">1736     m_allowsMediaDocumentInlinePlaybackElements.remove(&amp;element);</span>
1737 }
1738 
<span class="line-modified">1739 void Document::allowsMediaDocumentInlinePlaybackChanged()</span>
1740 {
<span class="line-modified">1741     for (auto* element : m_allowsMediaDocumentInlinePlaybackElements)</span>
<span class="line-modified">1742         element-&gt;allowsMediaDocumentInlinePlaybackChanged();</span>



1743 }
1744 
1745 void Document::stopAllMediaPlayback()
1746 {
1747     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1748         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(*this);
1749 }
1750 
1751 void Document::suspendAllMediaPlayback()
1752 {
1753     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1754         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1755 }
1756 
1757 void Document::resumeAllMediaPlayback()
1758 {
1759     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1760         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1761 }
1762 
1763 void Document::suspendAllMediaBuffering()
1764 {
1765     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1766         platformMediaSessionManager-&gt;suspendAllMediaBufferingForDocument(*this);
1767 }
1768 
1769 void Document::resumeAllMediaBuffering()
1770 {
1771     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1772         platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);
1773 }

1774 #endif
1775 
1776 String Document::nodeName() const
1777 {
1778     return &quot;#document&quot;_s;
1779 }
1780 
1781 Node::NodeType Document::nodeType() const
1782 {
1783     return DOCUMENT_NODE;
1784 }
1785 
1786 FormController&amp; Document::formController()
1787 {
1788     if (!m_formController)
1789         m_formController = makeUnique&lt;FormController&gt;();
1790     return *m_formController;
1791 }
1792 
1793 Vector&lt;String&gt; Document::formElementsState() const
</pre>
<hr />
<pre>
1822 Ref&lt;NodeIterator&gt; Document::createNodeIterator(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1823 {
1824     return NodeIterator::create(root, whatToShow, WTFMove(filter));
1825 }
1826 
1827 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1828 {
1829     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1830 }
1831 
1832 void Document::scheduleFullStyleRebuild()
1833 {
1834     m_needsFullStyleRebuild = true;
1835     scheduleStyleRecalc();
1836 }
1837 
1838 void Document::scheduleStyleRecalc()
1839 {
1840     ASSERT(!m_renderView || !inHitTesting());
1841 
<span class="line-modified">1842     if (m_styleRecalcTimer.isActive() || pageCacheState() != NotInPageCache)</span>
1843         return;
1844 
1845     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
1846     auto shouldThrottleStyleRecalc = [&amp;] {
1847         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1848             return false;
1849         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1850             return false;
1851         return true;
1852     };
1853 
1854     if (shouldThrottleStyleRecalc())
1855         return;
1856 
1857     m_styleRecalcTimer.startOneShot(0_s);
1858 
1859     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1860 }
1861 
1862 void Document::unscheduleStyleRecalc()
</pre>
<hr />
<pre>
1899     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1900 
1901     // FIXME: Do this update per tree scope.
1902     {
1903         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1904         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1905         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1906         for (auto&amp; element : elements)
1907             element-&gt;updateShadowTree();
1908     }
1909 
1910     // FIXME: We should update style on our ancestor chain before proceeding, however doing so at
1911     // the time this comment was originally written caused several tests to crash.
1912 
1913     {
1914         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1915         styleScope().flushPendingUpdate();
1916         frameView.willRecalcStyle();
1917     }
1918 
<span class="line-modified">1919     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willRecalculateStyle(*this);</span>
1920 
1921     bool updatedCompositingLayers = false;
1922     {
1923         Style::PostResolutionCallbackDisabler disabler(*this);
1924         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1925         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1926 
1927         m_inStyleRecalc = true;
1928 
1929         if (m_needsFullStyleRebuild)
1930             type = ResolveStyleType::Rebuild;
1931 
1932         if (type == ResolveStyleType::Rebuild) {
1933             // This may get set again during style resolve.
1934             m_hasNodesWithNonFinalStyle = false;
1935             m_hasNodesWithMissingStyle = false;
1936 
1937             auto documentStyle = Style::resolveForDocument(*this);
1938 
1939             // Inserting the pictograph font at the end of the font fallback list is done by the
</pre>
<hr />
<pre>
1971 
1972         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
1973 
1974         if (m_renderView-&gt;needsLayout())
1975             frameView.layoutContext().scheduleLayout();
1976 
1977         // Usually this is handled by post-layout.
1978         if (!frameView.needsLayout())
1979             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
1980 
1981         // As a result of the style recalculation, the currently hovered element might have been
1982         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
1983         // to check if any other elements ended up under the mouse pointer due to re-layout.
1984         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
1985             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
1986 
1987         ++m_styleRecalcCount;
1988         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
1989     }
1990 
<span class="line-modified">1991     // If we wanted to call implicitClose() during recalcStyle, do so now that we&#39;re finished.</span>
<span class="line-removed">1992     if (m_closeAfterStyleRecalc) {</span>
<span class="line-removed">1993         m_closeAfterStyleRecalc = false;</span>
<span class="line-removed">1994         implicitClose();</span>
<span class="line-removed">1995     }</span>
<span class="line-removed">1996 </span>
<span class="line-removed">1997     InspectorInstrumentation::didRecalculateStyle(cookie);</span>
1998 
1999     // Some animated images may now be inside the viewport due to style recalc,
2000     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2001     // check if they need to be resumed after layout.
2002     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2003         frameView.viewportContentsChanged();
<span class="line-removed">2004 </span>
<span class="line-removed">2005     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())</span>
<span class="line-removed">2006         frameView.scrollToFragment(m_url);</span>
2007 }
2008 
2009 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2010 {
2011     ASSERT(!m_inRenderTreeUpdate);
2012     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2013 
2014     auto textUpdate = makeUnique&lt;Style::Update&gt;(*this);
2015     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2016 
2017     RenderTreeUpdater renderTreeUpdater(*this);
2018     renderTreeUpdater.commit(WTFMove(textUpdate));
2019 }
2020 
2021 bool Document::needsStyleRecalc() const
2022 {
<span class="line-modified">2023     if (pageCacheState() != NotInPageCache)</span>
2024         return false;
2025 
2026     if (m_needsFullStyleRebuild)
2027         return true;
2028 
2029     if (childNeedsStyleRecalc())
2030         return true;
2031 
2032     if (styleScope().hasPendingUpdate())
2033         return true;
2034 
<span class="line-removed">2035     // Ensure this happens eventually as it is currently in resolveStyle. This can be removed if the code moves.</span>
<span class="line-removed">2036     if (m_gotoAnchorNeededAfterStylesheetsLoad &amp;&amp; !styleScope().hasPendingSheets())</span>
<span class="line-removed">2037         return true;</span>
<span class="line-removed">2038 </span>
2039     return false;
2040 }
2041 
2042 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2043 {
2044     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2045     auto* frameView = document.view();
2046     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
2047     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess();
2048 }
2049 
2050 bool Document::updateStyleIfNeeded()
2051 {
2052     RefPtr&lt;FrameView&gt; frameView = view();
2053     {
2054         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2055         ASSERT(isMainThread());
2056         ASSERT(!frameView || !frameView-&gt;isPainting());
2057 
2058         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
</pre>
<hr />
<pre>
2114 
2115     if (runPostLayoutTasks == RunPostLayoutTasks::Synchronously &amp;&amp; view())
2116         view()-&gt;flushAnyPendingPostLayoutTasks();
2117 
2118     m_ignorePendingStylesheets = oldIgnore;
2119 }
2120 
2121 std::unique_ptr&lt;RenderStyle&gt; Document::styleForElementIgnoringPendingStylesheets(Element&amp; element, const RenderStyle* parentStyle, PseudoId pseudoElementSpecifier)
2122 {
2123     ASSERT(&amp;element.document() == this);
2124     ASSERT(!element.isPseudoElement() || pseudoElementSpecifier == PseudoId::None);
2125     ASSERT(pseudoElementSpecifier == PseudoId::None || parentStyle);
2126 
2127     // On iOS request delegates called during styleForElement may result in re-entering WebKit and killing the style resolver.
2128     Style::PostResolutionCallbackDisabler disabler(*this, Style::PostResolutionCallbackDisabler::DrainCallbacks::No);
2129 
2130     SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
2131     auto&amp; resolver = element.styleResolver();
2132 
2133     if (pseudoElementSpecifier != PseudoId::None)
<span class="line-modified">2134         return resolver.pseudoStyleForElement(element, PseudoStyleRequest(pseudoElementSpecifier), *parentStyle);</span>
2135 
2136     auto elementStyle = resolver.styleForElement(element, parentStyle);
2137     if (elementStyle.relations) {
2138         Style::Update emptyUpdate(*this);
2139         Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
2140     }
2141 
2142     return WTFMove(elementStyle.renderStyle);
2143 }
2144 
2145 bool Document::updateLayoutIfDimensionsOutOfDate(Element&amp; element, DimensionsCheck dimensionsCheck)
2146 {
2147     ASSERT(isMainThread());
2148 
2149     // If the stylesheets haven&#39;t loaded, just give up and do a full layout ignoring pending stylesheets.
2150     if (!haveStylesheetsLoaded()) {
2151         updateLayoutIgnorePendingStylesheets();
2152         return true;
2153     }
2154 
</pre>
<hr />
<pre>
2273         auto&amp; size = style-&gt;pageSize();
2274         ASSERT(size.width.isFixed());
2275         ASSERT(size.height.isFixed());
2276         width = valueForLength(size.width, 0);
2277         height = valueForLength(size.height, 0);
2278         break;
2279     }
2280     default:
2281         ASSERT_NOT_REACHED();
2282     }
2283     pageSize = IntSize(width, height);
2284 
2285     // The percentage is calculated with respect to the width even for margin top and bottom.
2286     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2287     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2288     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2289     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2290     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2291 }
2292 
<span class="line-modified">2293 StyleResolver&amp; Document::userAgentShadowTreeStyleResolver()</span>
2294 {
2295     if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">2296         m_userAgentShadowTreeStyleResolver = makeUnique&lt;StyleResolver&gt;(*this);</span>
2297     return *m_userAgentShadowTreeStyleResolver;
2298 }
2299 
2300 void Document::fontsNeedUpdate(FontSelector&amp;)
2301 {
2302     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2303 }
2304 
2305 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2306 {
<span class="line-modified">2307     if (auto* resolver = styleScope().resolverIfExists())</span>
<span class="line-modified">2308         resolver-&gt;invalidateMatchedPropertiesCache();</span>
<span class="line-modified">2309     if (pageCacheState() != NotInPageCache || !renderView())</span>
2310         return;
2311     scheduleFullStyleRebuild();
2312 }
2313 
2314 void Document::didClearStyleResolver()
2315 {
2316     m_userAgentShadowTreeStyleResolver = nullptr;
2317 }
2318 
2319 void Document::setIsResolvingTreeStyle(bool value)
2320 {
2321     RELEASE_ASSERT(value != m_isResolvingTreeStyle);
2322     m_isResolvingTreeStyle = value;
2323 }
2324 
2325 void Document::createRenderTree()
2326 {
2327     ASSERT(!renderView());
<span class="line-modified">2328     ASSERT(m_pageCacheState != InPageCache);</span>
2329     ASSERT(!m_axObjectCache || this != &amp;topDocument());
2330 
2331     if (m_isNonRenderedPlaceholder)
2332         return;
2333 
2334     // FIXME: It would be better if we could pass the resolved document style directly here.
2335     m_renderView = createRenderer&lt;RenderView&gt;(*this, RenderStyle::create());
2336     Node::setRenderer(m_renderView.get());
2337 
2338     renderView()-&gt;setIsInWindow(true);
2339 
2340     resolveStyle(ResolveStyleType::Rebuild);
2341 }
2342 
2343 void Document::didBecomeCurrentDocumentInFrame()
2344 {
2345     // FIXME: Are there cases where the document can be dislodged from the frame during the event handling below?
2346     // If so, then m_frame could become 0, and we need to do something about that.
2347 
2348     m_frame-&gt;script().updateDocument();
2349 
2350     if (!hasLivingRenderTree())
2351         createRenderTree();
2352 
2353     dispatchDisabledAdaptationsDidChangeForMainFrame();
2354     updateViewportArguments();
2355 
2356     // FIXME: Doing this only for the main frame is insufficient.
2357     // Changing a subframe can also change the wheel event handler count.
2358     // FIXME: Doing this only when a document goes into the frame is insufficient.
2359     // Removing a document can also change the wheel event handler count.
2360     // FIXME: Doing this every time is a waste. If the current document and its
2361     // subframes&#39; documents have no wheel event handlers, then the count did not change,
2362     // unless the documents they are replacing had wheel event handlers.
2363     if (page() &amp;&amp; m_frame-&gt;isMainFrame())
2364         wheelEventHandlersChanged();
2365 
2366     // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
2367     // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
<span class="line-modified">2368     // page cache, or simply newly created).</span>
2369     if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
2370         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2371             if (auto* timeline = existingTimeline())
2372                 timeline-&gt;suspendAnimations();
2373         } else
2374             m_frame-&gt;animation().suspendAnimationsForDocument(this);
2375         suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2376     } else {
2377         resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2378         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2379             if (auto* timeline = existingTimeline())
2380                 timeline-&gt;resumeAnimations();
2381         } else
2382             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2383     }
2384 }
2385 
2386 void Document::frameDestroyed()
2387 {
2388     // detachFromFrame() must be called before destroying the Frame.
</pre>
<hr />
<pre>
2391     if (auto* window = domWindow())
2392         window-&gt;frameDestroyed();
2393 
2394     FrameDestructionObserver::frameDestroyed();
2395 }
2396 
2397 void Document::willDetachPage()
2398 {
2399     FrameDestructionObserver::willDetachPage();
2400 #if PLATFORM(IOS_FAMILY)
2401     contentChangeObserver().willDetachPage();
2402 #endif
2403     if (domWindow() &amp;&amp; frame())
2404         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2405 }
2406 
2407 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2408 {
2409     RELEASE_ASSERT(cachedFrame.document() == this);
2410     ASSERT(cachedFrame.view());
<span class="line-modified">2411     ASSERT(m_pageCacheState == Document::InPageCache);</span>
2412     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2413 }
2414 
2415 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2416 {
2417     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2418     RELEASE_ASSERT(cachedFrame.document() == this);
2419     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
<span class="line-modified">2420     ASSERT(m_pageCacheState == Document::InPageCache);</span>
2421     detachFromFrame();
2422 }
2423 
2424 void Document::destroyRenderTree()
2425 {
2426     ASSERT(hasLivingRenderTree());
2427     ASSERT(frame());
2428     ASSERT(frame()-&gt;document() == this);
2429     ASSERT(page());
2430 
2431     // Prevent Widget tree changes from committing until the RenderView is dead and gone.
2432     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2433 
2434     SetForScope&lt;bool&gt; change(m_renderTreeBeingDestroyed, true);
2435 
2436     if (this == &amp;topDocument())
2437         clearAXObjectCache();
2438 
2439     documentWillBecomeInactive();
2440 
</pre>
<hr />
<pre>
2478 
2479 #if USE(LIBWEBRTC)
2480     // FIXME: This should be moved to Modules/mediastream.
2481     if (LibWebRTCProvider::webRTCAvailable()) {
2482         if (auto* page = this-&gt;page())
2483             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2484     }
2485 #endif
2486 
2487 #if ENABLE(SERVICE_WORKER)
2488     setActiveServiceWorker(nullptr);
2489     setServiceWorkerConnection(nullptr);
2490 #endif
2491 
2492 #if ENABLE(IOS_TOUCH_EVENTS)
2493     clearTouchEventHandlersAndListeners();
2494 #endif
2495 
2496     m_undoManager-&gt;removeAllItems();
2497 


2498 #if ENABLE(ACCESSIBILITY)
2499     if (this != &amp;topDocument()) {
2500         // Let the ax cache know that this subframe goes out of scope.
2501         if (auto* cache = existingAXObjectCache())
2502             cache-&gt;prepareForDocumentDestruction(*this);
2503     }
2504 #endif
2505 
2506     {
2507         NavigationDisabler navigationDisabler(m_frame);
2508         disconnectDescendantFrames();
2509     }
2510     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_frame || !m_frame-&gt;tree().childCount());
2511 
2512     if (m_domWindow &amp;&amp; m_frame)
2513         m_domWindow-&gt;willDetachDocumentFromFrame();
2514 
2515     styleScope().clearResolver();
2516 
2517     if (hasLivingRenderTree())
2518         destroyRenderTree();
2519 
2520     if (is&lt;PluginDocument&gt;(*this))
2521         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2522 
2523 #if ENABLE(POINTER_LOCK)
2524     if (page())
2525         page()-&gt;pointerLockController().documentDetached(*this);
2526 #endif
2527 
2528     if (auto* page = this-&gt;page()) {
2529         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2530             validationMessageClient-&gt;documentDetached(*this);
2531     }
2532 
2533     InspectorInstrumentation::documentDetached(*this);
2534 
<span class="line-removed">2535     stopActiveDOMObjects();</span>
<span class="line-removed">2536     m_eventQueue.close();</span>
<span class="line-removed">2537 #if ENABLE(FULLSCREEN_API)</span>
<span class="line-removed">2538     m_fullscreenManager-&gt;emptyEventQueue();</span>
<span class="line-removed">2539 #endif</span>
<span class="line-removed">2540 </span>
2541     commonTeardown();
2542 
2543 #if ENABLE(TOUCH_EVENTS)
2544     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2545         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2546 #endif
2547 
2548     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2549         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2550 
2551     if (m_mediaQueryMatcher)
2552         m_mediaQueryMatcher-&gt;documentDestroyed();
2553 
2554 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2555     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2556         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2557             removePlaybackTargetPickerClient(*client);
2558     }
2559 #endif
2560 
2561     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2562 
2563     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2564         m_mediaState = MediaProducer::IsNotPlaying;
2565         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2566     }
2567 
2568     detachFromFrame();
2569 
<span class="line-modified">2570     if (m_timeline) {</span>
<span class="line-modified">2571         m_timeline-&gt;detachFromDocument();</span>
<span class="line-modified">2572         m_timeline = nullptr;</span>
<span class="line-removed">2573     }</span>
2574 
2575 #if ENABLE(CSS_PAINTING_API)
2576     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2577         scope-&gt;prepareForDestruction();
2578     m_paintWorkletGlobalScopes.clear();
2579 #endif
2580 
2581     m_hasPreparedForDestruction = true;
2582 
<span class="line-modified">2583     // Note that m_pageCacheState can be Document::AboutToEnterPageCache if our frame</span>
2584     // was removed in an onpagehide event handler fired when the top-level frame is
<span class="line-modified">2585     // about to enter the page cache.</span>
<span class="line-modified">2586     RELEASE_ASSERT(m_pageCacheState != Document::InPageCache);</span>
2587 }
2588 
2589 void Document::removeAllEventListeners()
2590 {
2591     EventTarget::removeAllEventListeners();
2592 
2593     if (m_domWindow)
2594         m_domWindow-&gt;removeAllEventListeners();
2595 
2596 #if ENABLE(IOS_TOUCH_EVENTS)
2597     clearTouchEventHandlersAndListeners();
2598 #endif
2599     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
2600         node-&gt;removeAllEventListeners();
2601 
2602 #if ENABLE(TOUCH_EVENTS)
2603     m_touchEventTargets = nullptr;
2604 #endif
2605     m_wheelEventTargets = nullptr;
2606 }
</pre>
<hr />
<pre>
2617         m_deviceOrientationController-&gt;suspendUpdates();
2618 #endif
2619 }
2620 
2621 void Document::resumeDeviceMotionAndOrientationUpdates()
2622 {
2623     if (!m_areDeviceMotionAndOrientationUpdatesSuspended)
2624         return;
2625     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2626 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2627     if (m_deviceMotionController)
2628         m_deviceMotionController-&gt;resumeUpdates();
2629     if (m_deviceOrientationController)
2630         m_deviceOrientationController-&gt;resumeUpdates();
2631 #endif
2632 }
2633 
2634 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2635 {
2636     // Bypass this policy when the world is known, and it not the normal world.
<span class="line-modified">2637     auto&amp; callFrame = *commonVM().topCallFrame;</span>
<span class="line-modified">2638     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(callFrame).isNormal();</span>

2639 }
2640 
2641 void Document::platformSuspendOrStopActiveDOMObjects()
2642 {
2643 #if PLATFORM(IOS_FAMILY)
2644     contentChangeObserver().didSuspendActiveDOMObjects();
2645 #endif
2646 }
2647 
2648 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2649 {


2650     ScriptExecutionContext::suspendActiveDOMObjects(why);
2651     suspendDeviceMotionAndOrientationUpdates();
2652     platformSuspendOrStopActiveDOMObjects();
2653 }
2654 
2655 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2656 {


2657     ScriptExecutionContext::resumeActiveDOMObjects(why);
2658     resumeDeviceMotionAndOrientationUpdates();
2659     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2660 }
2661 
2662 void Document::stopActiveDOMObjects()
2663 {


2664     ScriptExecutionContext::stopActiveDOMObjects();
2665     platformSuspendOrStopActiveDOMObjects();
2666 }
2667 
2668 void Document::clearAXObjectCache()
2669 {
2670     ASSERT(&amp;topDocument() == this);
2671     // Clear the cache member variable before calling delete because attempts
2672     // are made to access it during destruction.
2673     m_axObjectCache = nullptr;
2674 }
2675 
2676 AXObjectCache* Document::existingAXObjectCacheSlow() const
2677 {
2678     ASSERT(hasEverCreatedAnAXObjectCache);
2679     return topDocument().m_axObjectCache.get();
2680 }
2681 
2682 AXObjectCache* Document::axObjectCache() const
2683 {
</pre>
<hr />
<pre>
2698     if (!topDocument.m_axObjectCache) {
2699         topDocument.m_axObjectCache = makeUnique&lt;AXObjectCache&gt;(topDocument);
2700         hasEverCreatedAnAXObjectCache = true;
2701     }
2702     return topDocument.m_axObjectCache.get();
2703 }
2704 
2705 void Document::setVisuallyOrdered()
2706 {
2707     m_visuallyOrdered = true;
2708     if (renderView())
2709         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2710 }
2711 
2712 Ref&lt;DocumentParser&gt; Document::createParser()
2713 {
2714     // FIXME: this should probably pass the frame instead
2715     return XMLDocumentParser::create(*this, view());
2716 }
2717 








































2718 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2719 {
2720     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2721 }
2722 
2723 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features)
2724 {
2725     if (!m_domWindow)
2726         return Exception { InvalidAccessError };
2727 
2728     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2729 }
2730 
2731 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2732 {
2733     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2734         return Exception { InvalidStateError };
2735 
2736     auto result = open(responsibleDocument);
2737     if (UNLIKELY(result.hasException()))
2738         return result.releaseException();
2739 
2740     return *this;
2741 }
2742 
2743 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
2744 {
2745     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2746         return Exception { SecurityError };
2747 
2748     if (m_ignoreOpensDuringUnloadCount)
2749         return { };
2750 



2751     if (m_frame) {
2752         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2753             if (parser-&gt;isParsing()) {
2754                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2755                 if (parser-&gt;isExecutingScript())
2756                     return { };
2757 
2758                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2759                     return { };
2760             }
2761         }
2762 
2763         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2764             m_frame-&gt;loader().policyChecker().stopCheck();
2765         if (m_frame &amp;&amp; m_frame-&gt;loader().state() == FrameStateProvisional)
2766             m_frame-&gt;loader().stopAllLoaders();
2767     }
2768 
2769     removeAllEventListeners();
2770 
</pre>
<hr />
<pre>
2800     if (frame-&gt;isMainFrame())
2801         return true;
2802 
2803     auto* parentFrame = frame-&gt;tree().parent();
2804     return parentFrame &amp;&amp; parentFrame-&gt;document() &amp;&amp; parentFrame-&gt;document()-&gt;isFullyActive();
2805 }
2806 
2807 void Document::detachParser()
2808 {
2809     if (!m_parser)
2810         return;
2811     m_parser-&gt;detach();
2812     m_parser = nullptr;
2813 }
2814 
2815 void Document::cancelParsing()
2816 {
2817     if (!m_parser)
2818         return;
2819 



2820     // We have to clear the parser to avoid possibly triggering
2821     // the onload handler when closing as a side effect of a cancel-style
2822     // change, such as opening a new document or closing the window while
2823     // still parsing
2824     detachParser();
2825     explicitClose();
2826 }
2827 
2828 void Document::implicitOpen()
2829 {
2830     removeChildren();
2831 
2832     setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
2833 
<span class="line-modified">2834     cancelParsing();</span>
2835     m_parser = createParser();
2836 
2837     if (hasActiveParserYieldToken())
2838         m_parser-&gt;didBeginYieldingParser();
2839 
2840     setParsing(true);
2841     setReadyState(Loading);
2842 }
2843 
2844 HTMLBodyElement* Document::body() const
2845 {
2846     auto* element = documentElement();
2847     if (!is&lt;HTMLHtmlElement&gt;(element))
2848         return nullptr;
2849     return childrenOfType&lt;HTMLBodyElement&gt;(*element).first();
2850 }
2851 
2852 HTMLElement* Document::bodyOrFrameset() const
2853 {
2854     // Return the first body or frameset child of the html element.
</pre>
<hr />
<pre>
2913 }
2914 
2915 void Document::explicitClose()
2916 {
2917     if (RefPtr&lt;DocumentParser&gt; parser = m_parser)
2918         parser-&gt;finish();
2919 
2920     if (!m_frame) {
2921         // Because we have no frame, we don&#39;t know if all loading has completed,
2922         // so we just call implicitClose() immediately. FIXME: This might fire
2923         // the load event prematurely &lt;http://bugs.webkit.org/show_bug.cgi?id=14568&gt;.
2924         implicitClose();
2925         return;
2926     }
2927 
2928     checkCompleted();
2929 }
2930 
2931 void Document::implicitClose()
2932 {
<span class="line-modified">2933     // If we&#39;re in the middle of recalcStyle, we need to defer the close until the style information is accurate and all elements are re-attached.</span>
<span class="line-removed">2934     if (m_inStyleRecalc) {</span>
<span class="line-removed">2935         m_closeAfterStyleRecalc = true;</span>
<span class="line-removed">2936         return;</span>
<span class="line-removed">2937     }</span>
<span class="line-removed">2938 </span>
2939     bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
2940     bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
2941 
2942     if (!doload)
2943         return;
2944 
2945     // Call to dispatchWindowLoadEvent can blow us from underneath.
2946     Ref&lt;Document&gt; protectedThis(*this);
2947 
2948     m_processingLoadEvent = true;
2949 
2950     ScriptableDocumentParser* parser = scriptableDocumentParser();
2951     m_wellFormed = parser &amp;&amp; parser-&gt;wellFormed();
2952 
2953     // We have to clear the parser, in case someone document.write()s from the
2954     // onLoad event handler, as in Radar 3206524.
2955     detachParser();
2956 
2957     // FIXME: We kick off the icon loader when the Document is done parsing.
2958     // There are earlier opportunities we could start it:
</pre>
<hr />
<pre>
2964     if (f) {
2965 #if ENABLE(XSLT)
2966         // Apply XSL transforms before load events so that event handlers can access the transformed DOM tree.
2967         applyPendingXSLTransformsNowIfScheduled();
2968 #endif
2969 
2970         if (auto* documentLoader = loader())
2971             documentLoader-&gt;startIconLoading();
2972 
2973         f-&gt;animation().startAnimationsIfNotSuspended(this);
2974 
2975         // FIXME: We shouldn&#39;t be dispatching pending events globally on all Documents here.
2976         // For now, only do this when there is a Frame, otherwise this could cause JS reentrancy
2977         // below SVG font parsing, for example. &lt;https://webkit.org/b/136269&gt;
2978         ImageLoader::dispatchPendingBeforeLoadEvents();
2979         ImageLoader::dispatchPendingLoadEvents();
2980         ImageLoader::dispatchPendingErrorEvents();
2981         HTMLLinkElement::dispatchPendingLoadEvents();
2982         HTMLStyleElement::dispatchPendingLoadEvents();
2983 
<span class="line-removed">2984         // To align the HTML load event and the SVGLoad event for the outermost &lt;svg&gt; element, fire it from</span>
<span class="line-removed">2985         // here, instead of doing it from SVGElement::finishedParsingChildren (if externalResourcesRequired=&quot;false&quot;,</span>
<span class="line-removed">2986         // which is the default, for =&#39;true&#39; its fired at a later time, once all external resources finished loading).</span>
2987         if (svgExtensions())
<span class="line-modified">2988             accessSVGExtensions().dispatchSVGLoadEventToOutermostSVGElements();</span>
2989     }
2990 
2991     dispatchWindowLoadEvent();
2992     dispatchPageshowEvent(PageshowEventNotPersisted);
2993     if (m_pendingStateObject)
2994         dispatchPopstateEvent(WTFMove(m_pendingStateObject));
2995 
2996     if (f)
2997         f-&gt;loader().dispatchOnloadEvents();
2998 
2999     // An event handler may have removed the frame
3000     if (!frame()) {
3001         m_processingLoadEvent = false;
3002         return;
3003     }
3004 
3005     // Make sure both the initial layout and reflow happen after the onload
3006     // fires. This will improve onload scores, and other browsers do it.
3007     // If they wanna cheat, we can too. -dwh
3008 
</pre>
<hr />
<pre>
3013         view()-&gt;layoutContext().unscheduleLayout();
3014         return;
3015     }
3016 
3017     frame()-&gt;loader().checkCallImplicitClose();
3018 
3019     // We used to force a synchronous display and flush here.  This really isn&#39;t
3020     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3021     // (if your platform is syncing flushes and limiting them to 60fps).
3022     m_overMinimumLayoutThreshold = true;
3023     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3024         updateStyleIfNeeded();
3025 
3026         // Always do a layout after loading if needed.
3027         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3028             view()-&gt;layoutContext().layout();
3029     }
3030 
3031     m_processingLoadEvent = false;
3032 
<span class="line-modified">3033     if (auto* fontFaceSet = fontSelector().optionalFontFaceSet())</span>
<span class="line-modified">3034         fontFaceSet-&gt;didFirstLayout();</span>
3035 
3036 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3037     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3038         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3039         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3040         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3041         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3042         //
3043         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3044         // catch new AND page history loads, and that uses AXLoadComplete
3045 
3046         axObjectCache()-&gt;getOrCreate(renderView());
3047         if (this == &amp;topDocument())
3048             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3049         else {
3050             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3051             // in an iframe that just finished loading, post AXLayoutComplete instead.
3052             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3053         }
3054     }
</pre>
<hr />
<pre>
3092 
3093 Seconds Document::minimumLayoutDelay()
3094 {
3095     if (m_overMinimumLayoutThreshold)
3096         return 0_s;
3097 
3098     auto elapsed = timeSinceDocumentCreation();
3099     m_overMinimumLayoutThreshold = elapsed &gt; settings().layoutInterval();
3100 
3101     // We&#39;ll want to schedule the timer to fire at the minimum layout threshold.
3102     return std::max(0_s, settings().layoutInterval() - elapsed);
3103 }
3104 
3105 Seconds Document::timeSinceDocumentCreation() const
3106 {
3107     return MonotonicTime::now() - m_documentCreationTime;
3108 }
3109 
3110 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, SegmentedString&amp;&amp; text)
3111 {



3112     NestingLevelIncrementer nestingLevelIncrementer(m_writeRecursionDepth);
3113 
3114     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; 1) &amp;&amp; m_writeRecursionIsTooDeep;
3115     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; cMaxWriteRecursionDepth) || m_writeRecursionIsTooDeep;
3116 
3117     if (m_writeRecursionIsTooDeep)
3118         return { };
3119 
3120     bool hasInsertionPoint = m_parser &amp;&amp; m_parser-&gt;hasInsertionPoint();
3121     if (!hasInsertionPoint &amp;&amp; (m_ignoreOpensDuringUnloadCount || m_ignoreDestructiveWriteCount))
3122         return { };
3123 
3124     if (!hasInsertionPoint) {
3125         auto result = open(responsibleDocument);
3126         if (UNLIKELY(result.hasException()))
3127             return result.releaseException();
3128     }
3129 
3130     ASSERT(m_parser);
3131     m_parser-&gt;insert(WTFMove(text));
</pre>
<hr />
<pre>
3193     return alignmentInterval;
3194 }
3195 
3196 EventTarget* Document::errorEventTarget()
3197 {
3198     return m_domWindow.get();
3199 }
3200 
3201 void Document::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)
3202 {
3203     addMessage(MessageSource::JS, MessageLevel::Error, errorMessage, sourceURL, lineNumber, columnNumber, WTFMove(callStack));
3204 }
3205 
3206 void Document::setURL(const URL&amp; url)
3207 {
3208     const URL&amp; newURL = url.isEmpty() ? WTF::blankURL() : url;
3209     if (newURL == m_url)
3210         return;
3211 
3212     m_url = newURL;



3213     m_documentURI = m_url.string();
3214     updateBaseURL();
3215 }
3216 
3217 void Document::updateBaseURL()
3218 {
3219     URL oldBaseURL = m_baseURL;
3220     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3221     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3222     // from the Document interface otherwise.
3223     if (!m_baseElementURL.isEmpty())
3224         m_baseURL = m_baseElementURL;
3225     else if (!m_baseURLOverride.isEmpty())
3226         m_baseURL = m_baseURLOverride;
3227     else {
3228         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3229         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3230         // and DOM 3 Core does not specify how it should be resolved.
3231         m_baseURL = URL({ }, documentURI());
3232     }
</pre>
<hr />
<pre>
3259             }
3260         }
3261         if (!target) {
3262             const AtomString&amp; value = base.attributeWithoutSynchronization(targetAttr);
3263             if (!value.isNull()) {
3264                 target = &amp;value;
3265                 if (href)
3266                     break;
3267             }
3268         }
3269     }
3270 
3271     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3272     URL baseElementURL;
3273     if (href) {
3274         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3275         if (!strippedHref.isEmpty())
3276             baseElementURL = URL(url(), strippedHref);
3277     }
3278     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
<span class="line-modified">3279         m_baseElementURL = baseElementURL;</span>
<span class="line-modified">3280         updateBaseURL();</span>




3281     }
3282 
3283     m_baseTarget = target ? *target : nullAtom();
3284 }
3285 
3286 String Document::userAgent(const URL&amp; url) const
3287 {
3288     return frame() ? frame()-&gt;loader().userAgent(url) : String();
3289 }
3290 
3291 void Document::disableEval(const String&amp; errorMessage)
3292 {
3293     if (!frame())
3294         return;
3295 
3296     frame()-&gt;script().disableEval(errorMessage);
3297 }
3298 
3299 void Document::disableWebAssembly(const String&amp; errorMessage)
3300 {
</pre>
<hr />
<pre>
3320 SocketProvider* Document::socketProvider()
3321 {
3322     return m_socketProvider.get();
3323 }
3324 
3325 bool Document::canNavigate(Frame* targetFrame, const URL&amp; destinationURL)
3326 {
3327     if (!m_frame)
3328         return false;
3329 
3330     // FIXME: We shouldn&#39;t call this function without a target frame, but
3331     // fast/forms/submit-to-blank-multiple-times.html depends on this function
3332     // returning true when supplied with a 0 targetFrame.
3333     if (!targetFrame)
3334         return true;
3335 
3336     if (!canNavigateInternal(*targetFrame))
3337         return false;
3338 
3339     if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
<span class="line-modified">3340         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin and the user has never interacted with the frame.&quot;_s);</span>
3341         return false;
3342     }
3343 
3344     return true;
3345 }
3346 
3347 bool Document::canNavigateInternal(Frame&amp; targetFrame)
3348 {
3349     ASSERT(m_frame);
3350 
3351     // Cases (i), (ii) and (iii) pass the tests from the specifications but might not pass the &quot;security origin&quot; tests.
3352 
3353     // i. A frame can navigate its top ancestor when its &#39;allow-top-navigation&#39; flag is set (sometimes known as &#39;frame-busting&#39;).
3354     if (!isSandboxed(SandboxTopNavigation) &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3355         return true;
3356 
3357     // ii. A frame can navigate its top ancestor when its &#39;allow-top-navigation-by-user-activation&#39; flag is set and navigation is triggered by user activation.
3358     if (!isSandboxed(SandboxTopNavigationByUserActivation) &amp;&amp; UserGestureIndicator::processingUserGesture() &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3359         return true;
3360 
</pre>
<hr />
<pre>
3410     // Specifically, a document can navigate a top-level frame if that frame
3411     // opened the document or if the document is the same-origin with any of
3412     // the top-level frame&#39;s opener&#39;s ancestors (in the frame hierarchy).
3413     //
3414     // In both of these cases, the document performing the navigation is in
3415     // some way related to the frame being navigate (e.g., by the &quot;opener&quot;
3416     // and/or &quot;parent&quot; relation). Requiring some sort of relation prevents a
3417     // document from navigating arbitrary, unrelated top-level frames.
3418     if (!targetFrame.tree().parent()) {
3419         if (&amp;targetFrame == m_frame-&gt;loader().opener())
3420             return true;
3421 
3422         if (canAccessAncestor(securityOrigin(), targetFrame.loader().opener()))
3423             return true;
3424     }
3425 
3426     printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is neither same-origin with the target, nor is it the target&#39;s parent or opener.&quot;);
3427     return false;
3428 }
3429 










3430 // Prevent cross-site top-level redirects from third-party iframes unless the user has ever interacted with the frame.
3431 bool Document::isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL)
3432 {
3433     if (!settings().thirdPartyIframeRedirectBlockingEnabled())
3434         return false;
3435 
3436     // Only prevent top frame navigations by subframes.
3437     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3438         return false;
3439 
3440     // Only prevent navigations by subframes that the user has not interacted with.
3441     if (m_frame-&gt;hasHadUserInteraction())
3442         return false;
3443 
3444     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3445     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3446     if (sandboxFlags() != SandboxNone)
3447         return false;
3448 
<span class="line-modified">3449     // Only prevent navigations by third-party iframes.</span>
<span class="line-modified">3450     if (canAccessAncestor(securityOrigin(), &amp;targetFrame))</span>

3451         return false;
3452 
3453     // Only prevent cross-site navigations.
3454     auto* targetDocument = targetFrame.document();
3455     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))
3456         return false;
3457 
3458     return true;
3459 }
3460 
3461 void Document::didRemoveAllPendingStylesheet()
3462 {
3463     if (auto* parser = scriptableDocumentParser())
3464         parser-&gt;executeScriptsWaitingForStylesheetsSoon();














3465 }
3466 
3467 bool Document::usesStyleBasedEditability() const
3468 {
3469     if (m_hasElementUsingStyleBasedEditability)
3470         return true;
3471 
3472     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3473     ASSERT(!m_inStyleRecalc);
3474 
3475     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
3476     styleScope.flushPendingUpdate();
3477     return styleScope.usesStyleBasedEditability();
3478 }
3479 
3480 void Document::setHasElementUsingStyleBasedEditability()
3481 {
3482     m_hasElementUsingStyleBasedEditability = true;
3483 }
3484 
</pre>
<hr />
<pre>
3509     Frame* frame = this-&gt;frame();
3510     auto* documentLoader = frame ? frame-&gt;loader().documentLoader() : nullptr;
3511     auto httpStatusCode = documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0;
3512 
3513     HTTPHeaderName headerName;
3514     if (!findHTTPHeaderName(equiv, headerName))
3515         return;
3516 
3517     switch (headerName) {
3518     case HTTPHeaderName::DefaultStyle:
3519         // The preferred style set has been overridden as per section
3520         // 14.3.2 of the HTML4.0 specification.  We need to update the
3521         // sheet used variable and then update our style selector.
3522         // For more info, see the test at:
3523         // http://www.hixie.ch/tests/evil/css/import/main/preferred.html
3524         // -dwh
3525         styleScope().setPreferredStylesheetSetName(content);
3526         break;
3527 
3528     case HTTPHeaderName::Refresh: {
<span class="line-modified">3529         double delay;</span>
3530         String urlString;
3531         if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
3532             URL completedURL;
3533             if (urlString.isEmpty())
3534                 completedURL = m_url;
3535             else
3536                 completedURL = completeURL(urlString);
3537             if (!WTF::protocolIsJavaScript(completedURL))
3538                 frame-&gt;navigationScheduler().scheduleRedirect(*this, delay, completedURL);
3539             else {
3540                 String message = &quot;Refused to refresh &quot; + m_url.stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
3541                 addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3542             }
3543         }
3544 
3545         break;
3546     }
3547 
3548     case HTTPHeaderName::SetCookie:
3549         if (isHTMLDocument())
</pre>
<hr />
<pre>
3620     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3621 
3622     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3623         setViewportFeature(m_viewportArguments, *this, key, value);
3624     });
3625 
3626     updateViewportArguments();
3627 }
3628 
3629 ViewportArguments Document::viewportArguments() const
3630 {
3631     auto* page = this-&gt;page();
3632     if (!page)
3633         return m_viewportArguments;
3634     return page-&gt;overrideViewportArguments().valueOr(m_viewportArguments);
3635 }
3636 
3637 void Document::updateViewportArguments()
3638 {
3639     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
<span class="line-modified">3640 #ifndef NDEBUG</span>
3641         m_didDispatchViewportPropertiesChanged = true;
3642 #endif
3643         page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());
3644         page()-&gt;chrome().didReceiveDocType(*frame());
3645     }
3646 }
3647 
3648 #if ENABLE(DARK_MODE_CSS)
3649 static void processColorSchemeString(StringView colorScheme, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)
3650 {
3651     unsigned length = colorScheme.length();
3652     for (unsigned i = 0; i &lt; length; ) {
3653         // Skip to first non-separator.
3654         while (i &lt; length &amp;&amp; isHTMLSpace(colorScheme[i]))
3655             ++i;
3656         unsigned keyBegin = i;
3657 
3658         // Skip to first separator.
3659         while (i &lt; length &amp;&amp; !isHTMLSpace(colorScheme[i]))
3660             ++i;
3661         unsigned keyEnd = i;
3662 
3663         if (keyBegin == keyEnd)
3664             continue;
3665 
3666         callback(colorScheme.substring(keyBegin, keyEnd - keyBegin));
3667     }
3668 }
3669 
3670 void Document::processColorScheme(const String&amp; colorSchemeString)
3671 {
3672     OptionSet&lt;ColorScheme&gt; colorScheme;
3673     bool allowsTransformations = true;
3674     bool autoEncountered = false;
3675 
<span class="line-modified">3676     processColorSchemeString(colorSchemeString, [&amp;](StringView key) {</span>
3677         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
3678             colorScheme = { };
3679             allowsTransformations = true;
3680             autoEncountered = true;
3681             return;
3682         }
3683 
3684         if (autoEncountered)
3685             return;
3686 
3687         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
3688             colorScheme.add(ColorScheme::Light);
3689         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
3690             colorScheme.add(ColorScheme::Dark);
3691         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3692             allowsTransformations = false;
3693     });
3694 
3695     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
3696     if (colorScheme.isEmpty() &amp;&amp; !allowsTransformations)
</pre>
<hr />
<pre>
3879 
3880 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3881 {
3882     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3883     clone-&gt;cloneDataFromDocument(*this);
3884     switch (type) {
3885     case CloningOperation::OnlySelf:
3886     case CloningOperation::SelfWithTemplateContent:
3887         break;
3888     case CloningOperation::Everything:
3889         cloneChildNodes(clone);
3890         break;
3891     }
3892     return clone;
3893 }
3894 
3895 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
3896 {
3897     if (isXMLDocument()) {
3898         if (isXHTMLDocument())
<span class="line-modified">3899             return XMLDocument::createXHTML(sessionID(), nullptr, url());</span>
<span class="line-modified">3900         return XMLDocument::create(sessionID(), nullptr, url());</span>
3901     }
<span class="line-modified">3902     return create(sessionID(), url());</span>
3903 }
3904 
3905 void Document::cloneDataFromDocument(const Document&amp; other)
3906 {
3907     ASSERT(m_url == other.url());
3908     m_baseURL = other.baseURL();
3909     m_baseURLOverride = other.baseURLOverride();
3910     m_documentURI = other.documentURI();
3911 
3912     setCompatibilityMode(other.m_compatibilityMode);
3913     setContextDocument(other.contextDocument());
3914     setSecurityOriginPolicy(other.securityOriginPolicy());
3915     overrideMIMEType(other.contentType());
3916     setDecoder(other.decoder());
3917 }
3918 
3919 StyleSheetList&amp; Document::styleSheets()
3920 {
3921     if (!m_styleSheetList)
3922         m_styleSheetList = StyleSheetList::create(*this);
3923     return *m_styleSheetList;
3924 }
3925 
<span class="line-modified">3926 void Document::evaluateMediaQueryList()</span>
3927 {
<span class="line-modified">3928     if (m_mediaQueryMatcher)</span>
<span class="line-removed">3929         m_mediaQueryMatcher-&gt;styleResolverChanged();</span>
3930 
<span class="line-modified">3931     checkViewportDependentPictures();</span>
<span class="line-modified">3932     checkAppearanceDependentPictures();</span>
<span class="line-modified">3933 }</span>


3934 
<span class="line-modified">3935 void Document::checkViewportDependentPictures()</span>
<span class="line-modified">3936 {</span>
<span class="line-removed">3937     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;</span>
<span class="line-removed">3938     HashSet&lt;HTMLPictureElement*&gt;::iterator end = m_viewportDependentPictures.end();</span>
<span class="line-removed">3939     for (HashSet&lt;HTMLPictureElement*&gt;::iterator it = m_viewportDependentPictures.begin(); it != end; ++it) {</span>
<span class="line-removed">3940         if ((*it)-&gt;viewportChangeAffectedPicture())</span>
<span class="line-removed">3941             changedPictures.append(*it);</span>
<span class="line-removed">3942     }</span>
<span class="line-removed">3943     for (auto* picture : changedPictures)</span>
<span class="line-removed">3944         picture-&gt;sourcesChanged();</span>
3945 }
3946 
<span class="line-modified">3947 void Document::checkAppearanceDependentPictures()</span>
3948 {
<span class="line-modified">3949     Vector&lt;HTMLPictureElement*, 16&gt; changedPictures;</span>
<span class="line-modified">3950     for (auto* picture : m_appearanceDependentPictures) {</span>
<span class="line-removed">3951         if (picture-&gt;appearanceChangeAffectedPicture())</span>
<span class="line-removed">3952             changedPictures.append(picture);</span>
<span class="line-removed">3953     }</span>
3954 
<span class="line-modified">3955     for (auto* picture : changedPictures)</span>
<span class="line-removed">3956         picture-&gt;sourcesChanged();</span>
3957 }
3958 
3959 void Document::updateViewportUnitsOnResize()
3960 {
3961     if (!hasStyleWithViewportUnits())
3962         return;
3963 
<span class="line-modified">3964     styleScope().resolver().clearCachedPropertiesAffectedByViewportUnits();</span>
3965 
3966     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
3967     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
3968         auto* renderer = element-&gt;renderer();
3969         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
3970             element-&gt;invalidateStyle();
3971     }
3972 }
3973 







































































3974 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
3975 {
3976     m_audioProducers.add(audioProducer);
3977     updateIsPlayingMedia();
3978 }
3979 
3980 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
3981 {
3982     RELEASE_ASSERT(isMainThread());
3983     m_audioProducers.remove(audioProducer);
3984     updateIsPlayingMedia();
3985 }
3986 
3987 void Document::noteUserInteractionWithMediaElement()
3988 {
3989     if (m_userHasInteractedWithMediaElement)
3990         return;
3991 
3992     if (!topDocument().userDidInteractWithPage())
3993         return;
3994 
3995     m_userHasInteractedWithMediaElement = true;
3996     updateIsPlayingMedia();
3997 }
3998 
3999 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4000 {
4001     ASSERT(!m_audioProducers.hasNullReferences());
4002     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
4003     for (auto&amp; audioProducer : m_audioProducers)
4004         state |= audioProducer.mediaState();
4005 
<span class="line-modified">4006 #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">4007     state |= MediaStreamTrack::captureState();</span>
4008 #endif
4009 
4010 #if ENABLE(MEDIA_SESSION)
4011     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4012         if (sourceElement-&gt;isPlaying())
4013             state |= MediaProducer::IsSourceElementPlaying;
4014 
4015         if (auto* session = sourceElement-&gt;session()) {
4016             if (auto* controls = session-&gt;controls()) {
4017                 if (controls-&gt;previousTrackEnabled())
4018                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4019                 if (controls-&gt;nextTrackEnabled())
4020                     state |= MediaProducer::IsNextTrackControlEnabled;
4021             }
4022         }
4023     }
4024 #endif
4025 
4026     if (m_userHasInteractedWithMediaElement)
4027         state |= MediaProducer::HasUserInteractedWithMediaElement;
</pre>
<hr />
<pre>
4032 #if ENABLE(MEDIA_STREAM)
4033     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4034 #endif
4035 
4036     m_mediaState = state;
4037 
4038     if (page())
4039         page()-&gt;updateIsPlayingMedia(sourceElementID);
4040 
4041 #if ENABLE(MEDIA_STREAM)
4042     if (captureStateChanged)
4043         mediaStreamCaptureStateChanged();
4044 #endif
4045 }
4046 
4047 void Document::pageMutedStateDidChange()
4048 {
4049     for (auto&amp; audioProducer : m_audioProducers)
4050         audioProducer.pageMutedStateDidChange();
4051 
<span class="line-modified">4052 #if ENABLE(MEDIA_STREAM) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">4053     MediaStreamTrack::muteCapture();</span>
4054 #endif
4055 }
4056 
4057 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4058 {
4059     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4060         return node.isDescendantOf(container);
4061 
4062     return &amp;node == &amp;container || node.isDescendantOf(container);
4063 }
4064 
4065 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4066 {
<span class="line-modified">4067     if (!m_focusedElement || pageCacheState() != NotInPageCache) // If the document is in the page cache, then we don&#39;t need to clear out the focused node.</span>
4068         return;
4069 
4070     Element* focusedElement = node.treeScope().focusedElementInScope();
4071     if (!focusedElement)
4072         return;
4073 
4074     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
4075         // FIXME: We should avoid synchronously updating the style inside setFocusedElement.
4076         // FIXME: Object elements should avoid loading a frame synchronously in a post style recalc callback.
4077         SubframeLoadingDisabler disabler(is&lt;ContainerNode&gt;(node) ? &amp;downcast&lt;ContainerNode&gt;(node) : nullptr);
4078         setFocusedElement(nullptr, FocusDirectionNone, FocusRemovalEventsMode::DoNotDispatch);
4079         // Set the focus navigation starting node to the previous focused element so that
4080         // we can fallback to the siblings or parent node for the next search.
4081         // Also we need to call removeFocusNavigationNodeOfSubtree after this function because
4082         // setFocusedElement(nullptr) will reset m_focusNavigationStartingNode.
4083         setFocusNavigationStartingNode(focusedElement);
4084     }
4085 }
4086 
4087 void Document::hoveredElementDidDetach(Element&amp; element)
</pre>
<hr />
<pre>
4115 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
4116     if (auto* page = this-&gt;page()) {
4117         if (auto* frameView = view()) {
4118             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4119                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4120         }
4121     }
4122 #endif
4123 }
4124 
4125 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4126 {
4127     RefPtr&lt;Element&gt; newFocusedElement = element;
4128     // Make sure newFocusedElement is actually in this document
4129     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4130         return true;
4131 
4132     if (m_focusedElement == newFocusedElement)
4133         return true;
4134 
<span class="line-modified">4135     if (pageCacheState() != NotInPageCache)</span>
4136         return false;
4137 
4138     bool focusChangeBlocked = false;
4139     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4140 
4141     // Remove focus from the existing focus node (if any)
4142     if (oldFocusedElement) {
4143         oldFocusedElement-&gt;setFocus(false);
4144         setFocusNavigationStartingNode(nullptr);
4145 
4146         if (eventsMode == FocusRemovalEventsMode::Dispatch) {
4147             // Dispatch a change event for form control elements that have been edited.
4148             if (is&lt;HTMLFormControlElement&gt;(*oldFocusedElement)) {
4149                 HTMLFormControlElement&amp; formControlElement = downcast&lt;HTMLFormControlElement&gt;(*oldFocusedElement);
4150                 if (formControlElement.wasChangedSinceLastFormControlChangeEvent())
4151                     formControlElement.dispatchFormControlChangeEvent();
4152             }
4153 
4154             // Dispatch the blur event and let the node do any other blur related activities (important for text fields)
4155             oldFocusedElement-&gt;dispatchBlurEvent(newFocusedElement.copyRef());
</pre>
<hr />
<pre>
4183             frame()-&gt;editor().didEndEditing();
4184 
4185         if (view()) {
4186             if (Widget* oldWidget = widgetForElement(oldFocusedElement.get()))
4187                 oldWidget-&gt;setFocus(false);
4188             else
4189                 view()-&gt;setFocus(false);
4190         }
4191 
4192         if (is&lt;HTMLInputElement&gt;(oldFocusedElement)) {
4193             // HTMLInputElement::didBlur just scrolls text fields back to the beginning.
4194             // FIXME: This could be done asynchronusly.
4195             // Updating style may dispatch events due to PostResolutionCallback
4196             if (eventsMode == FocusRemovalEventsMode::Dispatch)
4197                 updateStyleIfNeeded();
4198             downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).didBlur();
4199         }
4200     }
4201 
4202     if (newFocusedElement &amp;&amp; newFocusedElement-&gt;isFocusable()) {





4203         if (newFocusedElement-&gt;isRootEditableElement() &amp;&amp; !acceptsEditingFocus(*newFocusedElement)) {
4204             // delegate blocks focus change
4205             focusChangeBlocked = true;
4206             goto SetFocusedNodeDone;
4207         }
4208         // Set focus on the new node
4209         m_focusedElement = newFocusedElement;
4210         setFocusNavigationStartingNode(m_focusedElement.get());
4211 
4212         // Dispatch the focus event and let the node do any other focus related activities (important for text fields)
4213         m_focusedElement-&gt;dispatchFocusEvent(oldFocusedElement.copyRef(), direction);
4214 
4215         if (m_focusedElement != newFocusedElement) {
4216             // handler shifted focus
4217             focusChangeBlocked = true;
4218             goto SetFocusedNodeDone;
4219         }
4220 
4221         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().focusinEvent, oldFocusedElement.copyRef()); // DOM level 3 bubbling focus event.
4222 
</pre>
<hr />
<pre>
4555 
4556 void Document::createDOMWindow()
4557 {
4558     ASSERT(m_frame);
4559     ASSERT(!m_domWindow);
4560 
4561     m_domWindow = DOMWindow::create(*this);
4562 
4563     ASSERT(m_domWindow-&gt;document() == this);
4564     ASSERT(m_domWindow-&gt;frame() == m_frame);
4565 
4566     m_frame-&gt;loader().client().didCreateWindow(*m_domWindow);
4567 }
4568 
4569 void Document::takeDOMWindowFrom(Document&amp; document)
4570 {
4571     ASSERT(m_frame);
4572     ASSERT(!m_domWindow);
4573     ASSERT(document.m_domWindow);
4574     // A valid DOMWindow is needed by CachedFrame for its documents.
<span class="line-modified">4575     ASSERT(pageCacheState() == NotInPageCache);</span>
4576 
4577     m_domWindow = WTFMove(document.m_domWindow);
4578     m_domWindow-&gt;didSecureTransitionTo(*this);
4579 
4580     ASSERT(m_domWindow-&gt;document() == this);
4581     ASSERT(m_domWindow-&gt;frame() == m_frame);
4582 }
4583 
4584 WindowProxy* Document::windowProxy() const
4585 {
4586     if (!m_frame)
4587         return nullptr;
4588     return &amp;m_frame-&gt;windowProxy();
4589 }
4590 
4591 Document&amp; Document::contextDocument() const
4592 {
4593     if (m_contextDocument)
4594         return *m_contextDocument.get();
4595     return const_cast&lt;Document&amp;&gt;(*this);
4596 }
4597 
4598 void Document::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4599 {
4600     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4601 }
4602 
4603 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)
4604 {
4605     if (!m_domWindow)
4606         return;
4607     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4608 }
4609 
4610 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4611 {
4612     if (!m_domWindow)
4613         return;


4614     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4615 }
4616 
4617 EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
4618 {
4619     if (!m_domWindow)
4620         return nullptr;
4621     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4622 }
4623 
4624 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4625 {
4626     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4627     if (!m_domWindow)
4628         return;
4629     m_domWindow-&gt;dispatchEvent(event, target);
4630 }
4631 
4632 void Document::dispatchWindowLoadEvent()
4633 {
4634     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4635     if (!m_domWindow)
4636         return;
4637     m_domWindow-&gt;dispatchLoadEvent();
4638     m_loadEventFinished = true;
4639     m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
4640 }
4641 
<span class="line-modified">4642 void Document::enqueueWindowEvent(Ref&lt;Event&gt;&amp;&amp; event)</span>
4643 {
<span class="line-modified">4644     event-&gt;setTarget(m_domWindow.get());</span>
<span class="line-modified">4645     m_eventQueue.enqueueEvent(WTFMove(event));</span>

4646 }
4647 
<span class="line-modified">4648 void Document::enqueueDocumentEvent(Ref&lt;Event&gt;&amp;&amp; event)</span>
4649 {
<span class="line-modified">4650     event-&gt;setTarget(this);</span>
<span class="line-modified">4651     m_eventQueue.enqueueEvent(WTFMove(event));</span>



4652 }
4653 
4654 void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4655 {
<span class="line-modified">4656     m_eventQueue.enqueueEvent(WTFMove(event));</span>







4657 }
4658 
4659 ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
4660 {
4661     // Please do *not* add new event classes to this function unless they are required
4662     // for compatibility with the DOM specification or some actual legacy web content.
4663 
4664     // This mechanism is superceded by use of event constructors.
4665     // That is what we should use for any new event classes.
4666 
4667     // The following strings are the ones from the DOM specification
4668     // &lt;https://dom.spec.whatwg.org/#dom-document-createevent&gt;.
4669 
4670     if (equalLettersIgnoringASCIICase(type, &quot;beforeunloadevent&quot;))
4671         return Ref&lt;Event&gt; { BeforeUnloadEvent::createForBindings() };
4672     if (equalLettersIgnoringASCIICase(type, &quot;compositionevent&quot;))
4673         return Ref&lt;Event&gt; { CompositionEvent::createForBindings() };
4674     if (equalLettersIgnoringASCIICase(type, &quot;customevent&quot;))
4675         return Ref&lt;Event&gt; { CustomEvent::create() };


4676     if (equalLettersIgnoringASCIICase(type, &quot;event&quot;) || equalLettersIgnoringASCIICase(type, &quot;events&quot;) || equalLettersIgnoringASCIICase(type, &quot;htmlevents&quot;) || equalLettersIgnoringASCIICase(type, &quot;svgevents&quot;))
4677         return Event::createForBindings();
4678     if (equalLettersIgnoringASCIICase(type, &quot;focusevent&quot;))
4679         return Ref&lt;Event&gt; { FocusEvent::createForBindings() };
4680     if (equalLettersIgnoringASCIICase(type, &quot;hashchangeevent&quot;))
4681         return Ref&lt;Event&gt; { HashChangeEvent::createForBindings() };
4682     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevent&quot;))
4683         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4684     if (equalLettersIgnoringASCIICase(type, &quot;messageevent&quot;))
4685         return Ref&lt;Event&gt; { MessageEvent::createForBindings() };
4686     if (equalLettersIgnoringASCIICase(type, &quot;storageevent&quot;))
4687         return Ref&lt;Event&gt; { StorageEvent::createForBindings() };
4688     if (equalLettersIgnoringASCIICase(type, &quot;mouseevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mouseevents&quot;))
4689         return Ref&lt;Event&gt; { MouseEvent::createForBindings() };
4690     if (equalLettersIgnoringASCIICase(type, &quot;textevent&quot;))
4691         return Ref&lt;Event&gt; { TextEvent::createForBindings() }; // FIXME: HTML specification says this should create a CompositionEvent, not a TextEvent.
4692     if (equalLettersIgnoringASCIICase(type, &quot;uievent&quot;) || equalLettersIgnoringASCIICase(type, &quot;uievents&quot;))
4693         return Ref&lt;Event&gt; { UIEvent::createForBindings() };
4694 
4695     // FIXME: Consider including support for these event classes even when device orientation
</pre>
<hr />
<pre>
4843 {
4844     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
4845         return { };
4846 
4847     if (isCookieAverse())
4848         return { };
4849 
4850     if (!securityOrigin().canAccessCookies())
4851         return Exception { SecurityError };
4852 
4853     URL cookieURL = this-&gt;cookieURL();
4854     if (cookieURL.isEmpty())
4855         return { };
4856 
4857     invalidateDOMCookieCache();
4858     if (page())
4859         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
4860     return { };
4861 }
4862 
<span class="line-modified">4863 String Document::referrer() const</span>
4864 {
4865 #if ENABLE(RESOURCE_LOAD_STATISTICS)
4866     if (!m_referrerOverride.isEmpty())
4867         return m_referrerOverride;











4868 #endif
4869     if (frame())
4870         return frame()-&gt;loader().referrer();
4871     return String();
4872 }
4873 
<span class="line-removed">4874 String Document::origin() const</span>
<span class="line-removed">4875 {</span>
<span class="line-removed">4876     return securityOrigin().toString();</span>
<span class="line-removed">4877 }</span>
<span class="line-removed">4878 </span>
4879 String Document::domain() const
4880 {
4881     return securityOrigin().domain();
4882 }
4883 
4884 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
4885 {
4886     if (!frame())
4887         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
4888 
4889     if (isSandboxed(SandboxDocumentDomain))
4890         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
4891 
<span class="line-modified">4892     if (SchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))</span>
4893         return Exception { SecurityError };
4894 
4895     // FIXME: We should add logging indicating why a domain was not allowed.
4896 
4897     const String&amp; effectiveDomain = domain();
4898     if (effectiveDomain.isEmpty())
4899         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
4900 
4901     if (!securityOrigin().isMatchingRegistrableDomainSuffix(newDomain, settings().treatIPAddressAsDomain()))
4902         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
4903 
4904     securityOrigin().setDomainFromDOM(newDomain);
4905     return { };
4906 }
4907 
4908 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
4909 {
4910     m_overrideLastModified = lastModified;
4911 }
4912 
</pre>
<hr />
<pre>
5048     if (!colonPosition || length - colonPosition &lt;= 1)
5049         return Exception { InvalidCharacterError };
5050 
5051     return std::pair&lt;AtomString, AtomString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomString() };
5052 }
5053 
5054 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
5055 {
5056     auto parseResult = parseQualifiedName(qualifiedName);
5057     if (parseResult.hasException())
5058         return parseResult.releaseException();
5059     auto parsedPieces = parseResult.releaseReturnValue();
5060     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5061 }
5062 
5063 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5064 {
5065     m_decoder = WTFMove(decoder);
5066 }
5067 
<span class="line-modified">5068 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride) const</span>
5069 {
5070     // Always return a null URL when passed a null string.
5071     // FIXME: Should we change the URL constructor to have this behavior?
5072     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5073     if (url.isNull())
5074         return URL();
5075     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
<span class="line-modified">5076     if (!m_decoder)</span>
5077         return URL(baseURL, url);
5078     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5079 }
5080 
<span class="line-modified">5081 URL Document::completeURL(const String&amp; url) const</span>
<span class="line-removed">5082 {</span>
<span class="line-removed">5083     return completeURL(url, m_baseURL);</span>
<span class="line-removed">5084 }</span>
<span class="line-removed">5085 </span>
<span class="line-removed">5086 PAL::SessionID Document::sessionID() const</span>
5087 {
<span class="line-modified">5088     return m_sessionID;</span>
5089 }
5090 
<span class="line-modified">5091 void Document::setPageCacheState(PageCacheState state)</span>
5092 {
<span class="line-modified">5093     if (m_pageCacheState == state)</span>
5094         return;
5095 
<span class="line-modified">5096     m_pageCacheState = state;</span>
5097 
5098     FrameView* v = view();
5099     Page* page = this-&gt;page();
5100 
5101     switch (state) {
<span class="line-modified">5102     case InPageCache:</span>
5103         if (v) {
5104             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
<span class="line-modified">5105             // page cache and similar work that needs to occur when it comes out. This is where we do the work</span>
5106             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5107             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
5108             // called too early on in the process of a page exiting the cache for that work to be possible in this
5109             // function. It would be nice if there was more symmetry here.
5110             // https://bugs.webkit.org/show_bug.cgi?id=98698
5111             v-&gt;cacheCurrentScrollPosition();
5112             if (page &amp;&amp; m_frame-&gt;isMainFrame()) {
5113                 v-&gt;resetScrollbarsAndClearContentsSize();
5114                 if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
5115                     scrollingCoordinator-&gt;clearAllNodes();
5116             }
5117         }
5118 
5119 #if ENABLE(POINTER_LOCK)
5120         exitPointerLock();
5121 #endif
5122 
5123         styleScope().clearResolver();
5124         clearSelectorQueryCache();
5125         m_styleRecalcTimer.stop();
5126 
5127         clearSharedObjectPool();





5128         break;
<span class="line-modified">5129     case NotInPageCache:</span>
5130         if (childNeedsStyleRecalc())
5131             scheduleStyleRecalc();




5132         break;
<span class="line-modified">5133     case AboutToEnterPageCache:</span>
5134         break;
5135     }
5136 }
5137 
5138 void Document::documentWillBecomeInactive()
5139 {
5140     if (renderView())
5141         renderView()-&gt;setIsInWindow(false);
5142 }
5143 
5144 void Document::suspend(ReasonForSuspension reason)
5145 {
5146     if (m_isSuspended)
5147         return;
5148 
5149     documentWillBecomeInactive();
5150 
5151     for (auto* element : m_documentSuspensionCallbackElements)
5152         element-&gt;prepareForDocumentSuspension();
5153 
<span class="line-modified">5154 #ifndef NDEBUG</span>
5155     // Clear the update flag to be able to check if the viewport arguments update
<span class="line-modified">5156     // is dispatched, after the document is restored from the page cache.</span>
5157     m_didDispatchViewportPropertiesChanged = false;
5158 #endif
5159 
5160     ASSERT(page());
5161     page()-&gt;lockAllOverlayScrollbarsToHidden(true);
5162 
5163     if (RenderView* view = renderView()) {
5164         if (view-&gt;usesCompositing())
5165             view-&gt;compositor().cancelCompositingLayerUpdate();
5166     }
5167 
5168 #if USE(LIBWEBRTC)
5169     // FIXME: This should be moved to Modules/mediastream.
5170     if (LibWebRTCProvider::webRTCAvailable()) {
5171         if (auto* page = this-&gt;page())
5172             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
5173     }
5174 #endif
5175 
5176 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">5177     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {</span>
<span class="line-removed">5178         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);</span>
5179         setServiceWorkerConnection(nullptr);
<span class="line-removed">5180     }</span>
5181 #endif
5182 
5183     suspendScheduledTasks(reason);
5184 
5185     ASSERT(m_frame);
5186     m_frame-&gt;clearTimers();
5187 
5188     m_visualUpdatesAllowed = false;
5189     m_visualUpdatesSuppressionTimer.stop();
5190 
5191     m_isSuspended = true;
5192 }
5193 
5194 void Document::resume(ReasonForSuspension reason)
5195 {
5196     if (!m_isSuspended)
5197         return;
5198 
5199     for (auto* element : copyToVector(m_documentSuspensionCallbackElements))
5200         element-&gt;resumeFromDocumentSuspension();
</pre>
<hr />
<pre>
5204 
5205     ASSERT(page());
5206     page()-&gt;lockAllOverlayScrollbarsToHidden(false);
5207 
5208     ASSERT(m_frame);
5209     m_frame-&gt;loader().client().dispatchDidBecomeFrameset(isFrameSet());
5210 
5211     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5212         if (auto* timeline = existingTimeline())
5213             timeline-&gt;resumeAnimations();
5214     } else
5215         m_frame-&gt;animation().resumeAnimationsForDocument(this);
5216 
5217     resumeScheduledTasks(reason);
5218 
5219     m_visualUpdatesAllowed = true;
5220 
5221     m_isSuspended = false;
5222 
5223 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">5224     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::PageCache) {</span>
<span class="line-modified">5225         ASSERT_WITH_MESSAGE(!activeServiceWorker(), &quot;Documents with an active service worker should not go into PageCache in the first place&quot;);</span>
<span class="line-removed">5226         setServiceWorkerConnection(ServiceWorkerProvider::singleton().existingServiceWorkerConnectionForSession(sessionID()));</span>
<span class="line-removed">5227     }</span>
5228 #endif
5229 }
5230 
5231 void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
5232 {
5233     m_documentSuspensionCallbackElements.add(&amp;element);
5234 }
5235 
5236 void Document::unregisterForDocumentSuspensionCallbacks(Element&amp; element)
5237 {
5238     m_documentSuspensionCallbackElements.remove(&amp;element);
5239 }
5240 
<span class="line-removed">5241 void Document::mediaVolumeDidChange()</span>
<span class="line-removed">5242 {</span>
<span class="line-removed">5243     for (auto* element : m_mediaVolumeCallbackElements)</span>
<span class="line-removed">5244         element-&gt;mediaVolumeDidChange();</span>
<span class="line-removed">5245 }</span>
<span class="line-removed">5246 </span>
<span class="line-removed">5247 void Document::registerForMediaVolumeCallbacks(Element&amp; element)</span>
<span class="line-removed">5248 {</span>
<span class="line-removed">5249     m_mediaVolumeCallbackElements.add(&amp;element);</span>
<span class="line-removed">5250 }</span>
<span class="line-removed">5251 </span>
<span class="line-removed">5252 void Document::unregisterForMediaVolumeCallbacks(Element&amp; element)</span>
<span class="line-removed">5253 {</span>
<span class="line-removed">5254     m_mediaVolumeCallbackElements.remove(&amp;element);</span>
<span class="line-removed">5255 }</span>
<span class="line-removed">5256 </span>
5257 bool Document::audioPlaybackRequiresUserGesture() const
5258 {
5259     if (DocumentLoader* loader = this-&gt;loader()) {
5260         // If an audio playback policy was set during navigation, use it. If not, use the global settings.
5261         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5262         if (policy != AutoplayPolicy::Default)
5263             return policy == AutoplayPolicy::AllowWithoutSound || policy == AutoplayPolicy::Deny;
5264     }
5265 
5266     return settings().audioPlaybackRequiresUserGesture();
5267 }
5268 
5269 bool Document::videoPlaybackRequiresUserGesture() const
5270 {
5271     if (DocumentLoader* loader = this-&gt;loader()) {
5272         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5273         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5274         if (policy != AutoplayPolicy::Default)
5275             return policy == AutoplayPolicy::Deny;
5276     }
5277 
5278     return settings().videoPlaybackRequiresUserGesture();
5279 }
5280 











5281 void Document::storageBlockingStateDidChange()
5282 {
5283     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5284 }
5285 

5286 void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)
5287 {
<span class="line-removed">5288     m_sessionID = sessionID;</span>
5289     if (m_logger)
5290         m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());
5291 
<span class="line-modified">5292     for (auto* element : m_privateBrowsingStateChangedElements)</span>
<span class="line-modified">5293         element-&gt;privateBrowsingStateDidChange(sessionID);</span>
<span class="line-modified">5294 </span>
<span class="line-modified">5295 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-removed">5296     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; m_serviceWorkerConnection)</span>
<span class="line-removed">5297         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID));</span>
5298 #endif
5299 }
5300 
<span class="line-removed">5301 void Document::registerForPrivateBrowsingStateChangedCallbacks(Element&amp; element)</span>
<span class="line-removed">5302 {</span>
<span class="line-removed">5303     m_privateBrowsingStateChangedElements.add(&amp;element);</span>
<span class="line-removed">5304 }</span>
<span class="line-removed">5305 </span>
<span class="line-removed">5306 void Document::unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp; element)</span>
<span class="line-removed">5307 {</span>
<span class="line-removed">5308     m_privateBrowsingStateChangedElements.remove(&amp;element);</span>
<span class="line-removed">5309 }</span>
<span class="line-removed">5310 </span>
5311 #if ENABLE(VIDEO_TRACK)
5312 
<span class="line-modified">5313 void Document::registerForCaptionPreferencesChangedCallbacks(Element&amp; element)</span>
5314 {
5315     if (page())
5316         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5317 
5318     m_captionPreferencesChangedElements.add(&amp;element);
5319 }
5320 
<span class="line-modified">5321 void Document::unregisterForCaptionPreferencesChangedCallbacks(Element&amp; element)</span>
5322 {
5323     m_captionPreferencesChangedElements.remove(&amp;element);
5324 }
5325 
5326 void Document::captionPreferencesChanged()
5327 {
5328     for (auto* element : m_captionPreferencesChangedElements)
5329         element-&gt;captionPreferencesChanged();
5330 }
5331 
5332 #endif
5333 
<span class="line-removed">5334 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed">5335 </span>
<span class="line-removed">5336 void Document::registerForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">5337 {</span>
<span class="line-removed">5338     m_pageScaleFactorChangedElements.add(&amp;element);</span>
<span class="line-removed">5339 }</span>
<span class="line-removed">5340 </span>
<span class="line-removed">5341 void Document::unregisterForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">5342 {</span>
<span class="line-removed">5343     m_pageScaleFactorChangedElements.remove(&amp;element);</span>
<span class="line-removed">5344 }</span>
<span class="line-removed">5345 </span>
<span class="line-removed">5346 void Document::pageScaleFactorChangedAndStable()</span>
<span class="line-removed">5347 {</span>
<span class="line-removed">5348     for (HTMLMediaElement* mediaElement : m_pageScaleFactorChangedElements)</span>
<span class="line-removed">5349         mediaElement-&gt;pageScaleFactorChanged();</span>
<span class="line-removed">5350 }</span>
<span class="line-removed">5351 </span>
<span class="line-removed">5352 void Document::registerForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">5353 {</span>
<span class="line-removed">5354     m_userInterfaceLayoutDirectionChangedElements.add(&amp;element);</span>
<span class="line-removed">5355 }</span>
<span class="line-removed">5356 </span>
<span class="line-removed">5357 void Document::unregisterForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">5358 {</span>
<span class="line-removed">5359     m_userInterfaceLayoutDirectionChangedElements.remove(&amp;element);</span>
<span class="line-removed">5360 }</span>
<span class="line-removed">5361 </span>
<span class="line-removed">5362 void Document::userInterfaceLayoutDirectionChanged()</span>
<span class="line-removed">5363 {</span>
<span class="line-removed">5364     for (auto* mediaElement : m_userInterfaceLayoutDirectionChangedElements)</span>
<span class="line-removed">5365         mediaElement-&gt;userInterfaceLayoutDirectionChanged();</span>
<span class="line-removed">5366 }</span>
<span class="line-removed">5367 </span>
<span class="line-removed">5368 #endif</span>
<span class="line-removed">5369 </span>
5370 void Document::setShouldCreateRenderers(bool f)
5371 {
5372     m_createRenderers = f;
5373 }
5374 
5375 bool Document::shouldCreateRenderers()
5376 {
5377     return m_createRenderers;
5378 }
5379 
5380 // Support for Javascript execCommand, and related methods
5381 
5382 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5383 {
5384     auto protectedDocument = makeRef(*document);
5385 
5386     document-&gt;updateStyleIfNeeded();
5387 
5388     auto frame = makeRefPtr(document-&gt;frame());
5389 
</pre>
<hr />
<pre>
5531         if (d-&gt;m_designMode != inherit)
5532             return d-&gt;m_designMode;
5533     }
5534     return false;
5535 }
5536 
5537 Document* Document::parentDocument() const
5538 {
5539     if (!m_frame)
5540         return nullptr;
5541     Frame* parent = m_frame-&gt;tree().parent();
5542     if (!parent)
5543         return nullptr;
5544     return parent-&gt;document();
5545 }
5546 
5547 Document&amp; Document::topDocument() const
5548 {
5549     // FIXME: This special-casing avoids incorrectly determined top documents during the process
5550     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
<span class="line-modified">5551     if (pageCacheState() == NotInPageCache &amp;&amp; !m_renderTreeBeingDestroyed) {</span>
5552         if (!m_frame)
5553             return const_cast&lt;Document&amp;&gt;(*this);
5554         // This should always be non-null.
5555         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5556         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5557     }
5558 
5559     Document* document = const_cast&lt;Document*&gt;(this);
5560     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5561         document = &amp;element-&gt;document();
5562     return *document;
5563 }
5564 
<span class="line-modified">5565 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; name)</span>
5566 {
<span class="line-modified">5567     return createAttributeNS({ }, isHTMLDocument() ? name.convertToASCIILowercase() : name, true);</span>


5568 }
5569 
5570 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
5571 {
5572     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5573     if (parseResult.hasException())
5574         return parseResult.releaseException();
5575     QualifiedName parsedName { parseResult.releaseReturnValue() };
5576     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5577         return Exception { NamespaceError };
5578     return Attr::create(*this, parsedName, emptyString());
5579 }
5580 
5581 const SVGDocumentExtensions* Document::svgExtensions()
5582 {
5583     return m_svgExtensions.get();
5584 }
5585 
5586 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5587 {
</pre>
<hr />
<pre>
5670 }
5671 
5672 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomString&amp; name)
5673 {
5674     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5675 }
5676 
5677 void Document::finishedParsing()
5678 {
5679     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5680     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5681     setParsing(false);
5682 
5683     Ref&lt;Document&gt; protectedThis(*this);
5684 
5685     scriptRunner().documentFinishedParsing();
5686 
5687     if (!m_documentTiming.domContentLoadedEventStart)
5688         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5689 
<span class="line-modified">5690     if (!page() || !page()-&gt;isForSanitizingWebContent()) {</span>
<span class="line-modified">5691         // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-removed">5692         MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
<span class="line-removed">5693     }</span>
<span class="line-removed">5694 </span>
5695     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5696 
5697     if (!m_documentTiming.domContentLoadedEventEnd)
5698         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5699 
5700     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5701 #if ENABLE(XSLT)
5702         applyPendingXSLTransformsNowIfScheduled();
5703 #endif
5704 
5705         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5706         // resource loads are complete. HTMLObjectElements can start loading their resources from
5707         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5708         // tag and then reach the end of the document without updating styles, we might not have yet
5709         // started the resource load and might fire the window load event too early. To avoid this
5710         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5711         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5712         updateStyleIfNeeded();
5713 
5714         frame-&gt;loader().finishedParsing();
5715         InspectorInstrumentation::domContentLoadedEventFired(*frame);
5716     }
5717 
5718     // Schedule dropping of the DocumentSharedObjectPool. We keep it alive for a while after parsing finishes
5719     // so that dynamically inserted content can also benefit from sharing optimizations.
5720     // Note that we don&#39;t refresh the timer on pool access since that could lead to huge caches being kept
5721     // alive indefinitely by something innocuous like JS setting .innerHTML repeatedly on a timer.
5722     static const Seconds timeToKeepSharedObjectPoolAliveAfterParsingFinished { 10_s };
5723     m_sharedObjectPoolClearTimer.startOneShot(timeToKeepSharedObjectPoolAliveAfterParsingFinished);
5724 
5725     // Parser should have picked up all speculative preloads by now
5726     m_cachedResourceLoader-&gt;clearPreloads(CachedResourceLoader::ClearPreloadsMode::ClearSpeculativePreloads);








5727 }
5728 
5729 void Document::clearSharedObjectPool()
5730 {
5731     m_sharedObjectPool = nullptr;
5732     m_sharedObjectPoolClearTimer.stop();
5733 }
5734 
5735 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5736 
5737 // FIXME: Find a better place for this code.
5738 
5739 bool Document::isTelephoneNumberParsingEnabled() const
5740 {
5741     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5742 }
5743 
5744 bool Document::isTelephoneNumberParsingAllowed() const
5745 {
5746     return m_isTelephoneNumberParsingAllowed;
</pre>
<hr />
<pre>
5748 
5749 #endif
5750 
5751 String Document::originIdentifierForPasteboard() const
5752 {
5753     auto origin = securityOrigin().toString();
5754     if (origin != &quot;null&quot;)
5755         return origin;
5756     if (!m_uniqueIdentifier)
5757         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5758     return m_uniqueIdentifier;
5759 }
5760 
5761 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5762 {
5763     if (!m_xpathEvaluator)
5764         m_xpathEvaluator = XPathEvaluator::create();
5765     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5766 }
5767 
<span class="line-modified">5768 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node* nodeResolver)</span>
5769 {
5770     if (!m_xpathEvaluator)
5771         m_xpathEvaluator = XPathEvaluator::create();
5772     return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
5773 }
5774 
<span class="line-modified">5775 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)</span>
5776 {
5777     if (!m_xpathEvaluator)
5778         m_xpathEvaluator = XPathEvaluator::create();
5779     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5780 }
5781 
5782 void Document::initSecurityContext()
5783 {
5784     if (haveInitializedSecurityOrigin()) {
5785         ASSERT(SecurityContext::securityOrigin());
5786         return;
5787     }
5788 
5789     if (!m_frame) {
5790         // No source for a security context.
5791         // This can occur via document.implementation.createDocument().
5792         setCookieURL(URL({ }, emptyString()));
5793         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
5794         setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));
5795         return;
5796     }
5797 
5798     // In the common case, create the security context from the currently
5799     // loading URL with a fresh content security policy.
5800     setCookieURL(m_url);
5801     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5802     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5803 
5804     if (shouldEnforceContentDispositionAttachmentSandbox())
5805         applyContentDispositionAttachmentSandbox();
5806 
5807     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5808     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5809     if (!isSecurityOriginUnique)
5810         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5811 
5812     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
5813     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
5814 















5815     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5816     if (!overrideContentSecurityPolicy.isNull())
5817         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5818 
5819 #if USE(QUICK_LOOK)
5820     if (shouldEnforceQuickLookSandbox())
5821         applyQuickLookSandbox();
5822 #endif
5823 
5824     if (shouldEnforceHTTP09Sandbox()) {
5825         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
5826         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
5827         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
5828     }
5829 
5830     if (settings().needsStorageAccessFromFileURLsQuirk())
5831         securityOrigin().grantStorageAccessFromFileURLsQuirk();
5832     if (!settings().webSecurityEnabled()) {
5833         // Web security is turned off. We should let this document access every other document. This is used primary by testing
5834         // harnesses for web sites.
</pre>
<hr />
<pre>
5854     if (parentDocument)
5855         setStrictMixedContentMode(parentDocument-&gt;isStrictMixedContentMode());
5856 
5857     if (!SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
5858         return;
5859 
5860     // If we do not obtain a meaningful origin from the URL, then we try to
5861     // find one via the frame hierarchy.
5862     Frame* parentFrame = m_frame-&gt;tree().parent();
5863     Frame* openerFrame = m_frame-&gt;loader().opener();
5864 
5865     Frame* ownerFrame = parentFrame;
5866     if (!ownerFrame)
5867         ownerFrame = openerFrame;
5868 
5869     if (!ownerFrame) {
5870         didFailToInitializeSecurityOrigin();
5871         return;
5872     }
5873 
<span class="line-modified">5874     Document* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr;</span>

5875 
5876     // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
5877     // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
5878     // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
<span class="line-modified">5879     if (openerDocument)</span>
5880         contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
5881 
5882     if (isSandboxed(SandboxOrigin)) {
5883         // If we&#39;re supposed to inherit our security origin from our owner,
5884         // but we&#39;re also sandboxed, the only thing we inherit is the ability
5885         // to load local resources. This lets about:blank iframes in file://
5886         // URL documents load images and other resources from the file system.
5887         if (ownerFrame-&gt;document()-&gt;securityOrigin().canLoadLocalResources())
5888             securityOrigin().grantLoadLocalResources();
5889         return;
5890     }
5891 
5892     setCookieURL(ownerFrame-&gt;document()-&gt;cookieURL());
5893     // We alias the SecurityOrigins to match Firefox, see Bug 15313
5894     // https://bugs.webkit.org/show_bug.cgi?id=15313
5895     setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
5896 }
5897 
<span class="line-modified">5898 // FIXME: The current criterion is stricter than &lt;https://www.w3.org/TR/CSP3/#security-inherit-csp&gt; (Editor&#39;s Draft, 28 February 2019).</span>
<span class="line-removed">5899 bool Document::shouldInheritContentSecurityPolicy() const</span>
5900 {
<span class="line-modified">5901     ASSERT(m_frame);</span>
<span class="line-removed">5902     if (SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))</span>
<span class="line-removed">5903         return true;</span>
<span class="line-removed">5904     if (m_url.protocolIsData() || m_url.protocolIsBlob())</span>
<span class="line-removed">5905         return true;</span>
<span class="line-removed">5906     if (!isPluginDocument())</span>
<span class="line-removed">5907         return false;</span>
<span class="line-removed">5908     if (m_frame-&gt;tree().parent())</span>
<span class="line-removed">5909         return true;</span>
<span class="line-removed">5910     Frame* openerFrame = m_frame-&gt;loader().opener();</span>
<span class="line-removed">5911     if (!openerFrame)</span>
<span class="line-removed">5912         return false;</span>
<span class="line-removed">5913     return openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin());</span>
<span class="line-removed">5914 }</span>
<span class="line-removed">5915 </span>
<span class="line-removed">5916 void Document::initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy)</span>
<span class="line-removed">5917 {</span>
<span class="line-removed">5918     // 1. Inherit Upgrade Insecure Requests</span>
<span class="line-removed">5919     Frame* parentFrame = m_frame-&gt;tree().parent();</span>
5920     if (parentFrame)
5921         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
5922 
<span class="line-modified">5923     // 2. Inherit Content Security Policy (without copying Upgrade Insecure Requests state).</span>
<span class="line-modified">5924     if (!shouldInheritContentSecurityPolicy())</span>
<span class="line-modified">5925         return;</span>
<span class="line-modified">5926     ContentSecurityPolicy* ownerPolicy = nullptr;</span>
<span class="line-modified">5927     if (previousPolicy &amp;&amp; (m_url.protocolIsData() || m_url.protocolIsBlob()))</span>
<span class="line-modified">5928         ownerPolicy = previousPolicy;</span>
<span class="line-modified">5929     if (!ownerPolicy) {</span>
<span class="line-modified">5930         Frame* ownerFrame = parentFrame;</span>
<span class="line-modified">5931         if (!ownerFrame)</span>
<span class="line-modified">5932             ownerFrame = m_frame-&gt;loader().opener();</span>
<span class="line-modified">5933         if (ownerFrame)</span>
<span class="line-modified">5934             ownerPolicy = ownerFrame-&gt;document()-&gt;contentSecurityPolicy();</span>
<span class="line-removed">5935     }</span>
<span class="line-removed">5936     if (!ownerPolicy)</span>
<span class="line-removed">5937         return;</span>
<span class="line-removed">5938     // FIXME: We are stricter than the CSP 3 spec. with regards to plugins: we prefer to inherit the full policy unless the plugin</span>
<span class="line-removed">5939     // document is opened in a new window. The CSP 3 spec. implies that only plugin documents delivered with a local scheme (e.g. blob,</span>
<span class="line-removed">5940     // file, data) should inherit a policy.</span>
<span class="line-removed">5941     if (isPluginDocument() &amp;&amp; m_frame-&gt;loader().opener())</span>
<span class="line-removed">5942         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*ownerPolicy);</span>
5943     else
<span class="line-modified">5944         contentSecurityPolicy()-&gt;copyStateFrom(ownerPolicy);</span>
5945 }
5946 
5947 bool Document::isContextThread() const
5948 {
5949     return isMainThread();
5950 }
5951 
5952 bool Document::isSecureContext() const
5953 {
5954     if (!m_frame)
5955         return true;
5956     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
5957         return true;
5958     if (!securityOrigin().isPotentiallyTrustworthy())
5959         return false;
<span class="line-modified">5960     for (Frame* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {</span>
5961         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
5962             return false;
5963     }


5964     return true;
5965 }
5966 
5967 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
5968 {
5969     Frame* f = frame();
5970     if (!f)
5971         return;
5972 
5973     setURL(url);
5974     f-&gt;loader().setOutgoingReferrer(url);
5975 
5976     if (DocumentLoader* documentLoader = loader())
5977         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
5978 }
5979 
5980 void Document::statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
5981 {
5982     if (!frame())
5983         return;
</pre>
<hr />
<pre>
6109     }
6110 
6111     if (Page* page = this-&gt;page())
6112         page-&gt;console().addMessage(WTFMove(consoleMessage));
6113 }
6114 
6115 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6116 {
6117     if (!isContextThread()) {
6118         postTask(AddConsoleMessageTask(source, level, message));
6119         return;
6120     }
6121 
6122     if (Page* page = this-&gt;page())
6123         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6124 
6125     if (m_consoleMessageListener)
6126         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6127 }
6128 
<span class="line-modified">6129 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)</span>
6130 {
6131     if (!isContextThread()) {
6132         postTask(AddConsoleMessageTask(source, level, message));
6133         return;
6134     }
6135 
6136     if (Page* page = this-&gt;page())
6137         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6138 }
6139 
6140 void Document::postTask(Task&amp;&amp; task)
6141 {
6142     callOnMainThread([documentID = identifier(), task = WTFMove(task)]() mutable {
6143         ASSERT(isMainThread());
6144 
6145         auto* document = allDocumentsMap().get(documentID);
6146         if (!document)
6147             return;
6148 
6149         Page* page = document-&gt;page();
6150         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6151             document-&gt;m_pendingTasks.append(WTFMove(task));
6152         else
6153             task.performTask(*document);
6154     });
6155 }
6156 
6157 void Document::pendingTasksTimerFired()
6158 {
6159     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6160     for (auto&amp; task : pendingTasks)
6161         task.performTask(*this);
6162 }
6163 





















6164 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6165 {
6166     if (m_scheduledTasksAreSuspended) {
6167         // A page may subsequently suspend DOM objects, say as part of handling a scroll or zoom gesture, after the
6168         // embedding client requested the page be suspended. We ignore such requests so long as the embedding client
6169         // requested the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
6170         ASSERT(reasonForSuspendingActiveDOMObjects() == ReasonForSuspension::PageWillBeSuspended);
6171         return;
6172     }
6173 
6174     suspendScriptedAnimationControllerCallbacks();
6175     suspendActiveDOMObjects(reason);
6176     scriptRunner().suspend();
6177     m_pendingTasksTimer.stop();
6178 
6179 #if ENABLE(XSLT)
6180     m_applyPendingXSLTransformsTimer.stop();
6181 #endif
6182 
6183     // Deferring loading and suspending parser is necessary when we need to prevent re-entrant JavaScript execution
</pre>
<hr />
<pre>
6211     resumeActiveDOMObjects(reason);
6212     resumeScriptedAnimationControllerCallbacks();
6213 
6214     m_scheduledTasksAreSuspended = false;
6215 }
6216 
6217 void Document::suspendScriptedAnimationControllerCallbacks()
6218 {
6219     if (m_scriptedAnimationController)
6220         m_scriptedAnimationController-&gt;suspend();
6221 }
6222 
6223 void Document::resumeScriptedAnimationControllerCallbacks()
6224 {
6225     if (m_scriptedAnimationController)
6226         m_scriptedAnimationController-&gt;resume();
6227 }
6228 
6229 void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)
6230 {
<span class="line-modified">6231     if (m_timeline)</span>
<span class="line-modified">6232         m_timeline-&gt;updateAnimationsAndSendEvents(timestamp);</span>














6233 }
6234 
6235 void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)
6236 {
6237     if (m_scriptedAnimationController)
6238         m_scriptedAnimationController-&gt;serviceRequestAnimationFrameCallbacks(timestamp);
6239 }
6240 
6241 void Document::windowScreenDidChange(PlatformDisplayID displayID)
6242 {
6243     if (RenderView* view = renderView()) {
6244         if (view-&gt;usesCompositing())
6245             view-&gt;compositor().windowScreenDidChange(displayID);
6246     }
6247 }
6248 
6249 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6250 {
6251     if (!m_decoder)
6252         return string;
6253     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6254 }
6255 
6256 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6257 {
6258     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6259     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6260 }
6261 
6262 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
6263 {
<span class="line-modified">6264     enqueueDocumentEvent(SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));</span>
6265 }
6266 
6267 void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
6268 {
<span class="line-modified">6269     enqueueWindowEvent(HashChangeEvent::create(oldURL, newURL));</span>

6270 }
6271 
6272 void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6273 {
6274     dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
6275 }
6276 
6277 void Document::addMediaCanStartListener(MediaCanStartListener&amp; listener)
6278 {
6279     ASSERT(!m_mediaCanStartListeners.contains(&amp;listener));
6280     m_mediaCanStartListeners.add(&amp;listener);
6281 }
6282 
6283 void Document::removeMediaCanStartListener(MediaCanStartListener&amp; listener)
6284 {
6285     ASSERT(m_mediaCanStartListeners.contains(&amp;listener));
6286     m_mediaCanStartListeners.remove(&amp;listener);
6287 }
6288 
6289 MediaCanStartListener* Document::takeAnyMediaCanStartListener()
</pre>
<hr />
<pre>
6382     }
6383 
6384     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
6385 }
6386 
6387 void Document::cancelAnimationFrame(int id)
6388 {
6389     if (!m_scriptedAnimationController)
6390         return;
6391     m_scriptedAnimationController-&gt;cancelCallback(id);
6392 }
6393 
6394 void Document::clearScriptedAnimationController()
6395 {
6396     // FIXME: consider using ActiveDOMObject.
6397     if (m_scriptedAnimationController)
6398         m_scriptedAnimationController-&gt;clearDocumentPointer();
6399     m_scriptedAnimationController = nullptr;
6400 }
6401 














6402 void Document::wheelEventHandlersChanged()
6403 {
6404     Page* page = this-&gt;page();
6405     if (!page)
6406         return;
6407 
6408     if (FrameView* frameView = view()) {
6409         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
6410             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
6411     }
6412 
6413     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
6414     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
6415 }
6416 
6417 void Document::didAddWheelEventHandler(Node&amp; node)
6418 {
6419     if (!m_wheelEventTargets)
6420         m_wheelEventTargets = makeUnique&lt;EventTargetSet&gt;();
6421 
</pre>
<hr />
<pre>
6888     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
6889 }
6890 
6891 Locale&amp; Document::getCachedLocale(const AtomString&amp; locale)
6892 {
6893     AtomString localeKey = locale;
6894     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
6895         localeKey = defaultLanguage();
6896     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
6897     if (result.isNewEntry)
6898         result.iterator-&gt;value = Locale::create(localeKey);
6899     return *(result.iterator-&gt;value);
6900 }
6901 
6902 Document&amp; Document::ensureTemplateDocument()
6903 {
6904     if (const Document* document = templateDocument())
6905         return const_cast&lt;Document&amp;&gt;(*document);
6906 
6907     if (isHTMLDocument())
<span class="line-modified">6908         m_templateDocument = HTMLDocument::create(sessionID(), nullptr, WTF::blankURL());</span>
6909     else
<span class="line-modified">6910         m_templateDocument = create(sessionID(), WTF::blankURL());</span>
6911 
6912     m_templateDocument-&gt;setContextDocument(contextDocument());
6913     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
6914 
6915     return *m_templateDocument;
6916 }
6917 
6918 Ref&lt;FontFaceSet&gt; Document::fonts()
6919 {
6920     updateStyleIfNeeded();
6921     return fontSelector().fontFaceSet();
6922 }
6923 
6924 EditingBehavior Document::editingBehavior() const
6925 {
6926     return EditingBehavior { settings().editingBehaviorType() };
6927 }
6928 
6929 float Document::deviceScaleFactor() const
6930 {
</pre>
<hr />
<pre>
6980     if (auto* documentPage = page())
6981         return documentPage-&gt;useElevatedUserInterfaceLevel();
6982     return false;
6983 }
6984 
6985 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
6986 {
6987     OptionSet&lt;StyleColor::Options&gt; options;
6988     if (useSystemAppearance())
6989         options.add(StyleColor::Options::UseSystemAppearance);
6990     if (useDarkAppearance(style))
6991         options.add(StyleColor::Options::UseDarkAppearance);
6992     if (useElevatedUserInterfaceLevel())
6993         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
6994     return options;
6995 }
6996 
6997 CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const
6998 {
6999     if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))
<span class="line-modified">7000         return CompositeSourceOver;</span>
7001 
7002     auto* frameView = view();
7003     if (!frameView)
<span class="line-modified">7004         return CompositeSourceOver;</span>
7005 
7006     // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to
7007     // use different composite modes to get the right results in this case.
<span class="line-modified">7008     return frameView-&gt;isTransparent() ? CompositeDestinationOut : CompositeDestinationIn;</span>
7009 }
7010 
7011 void Document::didAssociateFormControl(Element&amp; element)
7012 {
7013     auto* page = this-&gt;page();
7014     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7015         return;
7016     m_associatedFormControls.add(&amp;element);
7017     if (!m_didAssociateFormControlsTimer.isActive())
7018         m_didAssociateFormControlsTimer.startOneShot(0_s);
7019 }
7020 
7021 void Document::didAssociateFormControlsTimerFired()
7022 {
7023     auto vector = copyToVector(m_associatedFormControls);
7024     m_associatedFormControls.clear();
7025     if (auto* page = this-&gt;page()) {
7026         ASSERT(m_frame);
7027         page-&gt;chrome().client().didAssociateFormControls(vector, *m_frame);
7028     }
</pre>
<hr />
<pre>
7045 void Document::didLoadResourceSynchronously()
7046 {
7047     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7048     // in this case, to be safe.
7049     invalidateDOMCookieCache();
7050 }
7051 
7052 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7053 {
7054     if (m_hasInjectedPlugInsScript)
7055         return;
7056 
7057     auto&amp; scriptController = frame()-&gt;script();
7058 
7059     // Use the JS file provided by the Chrome client, or fallback to the default one.
7060     String jsString = page()-&gt;chrome().client().plugInExtraScript();
7061     if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))
7062         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7063 
7064     setHasEvaluatedUserAgentScripts();
<span class="line-modified">7065     scriptController.evaluateInWorld(ScriptSourceCode(jsString), world);</span>
7066 
7067     m_hasInjectedPlugInsScript = true;
7068 }
7069 
7070 #if ENABLE(WEB_CRYPTO)
7071 
7072 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7073 {
7074     Page* page = this-&gt;page();
7075     if (!page)
7076         return false;
7077     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7078 }
7079 
7080 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7081 {
7082     Page* page = this-&gt;page();
7083     if (!page)
7084         return false;
7085     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
</pre>
<hr />
<pre>
7182 }
7183 
7184 void Document::setPlaybackTarget(uint64_t clientId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
7185 {
7186     auto it = m_idToClientMap.find(clientId);
7187     if (it == m_idToClientMap.end())
7188         return;
7189 
7190     it-&gt;value-&gt;setPlaybackTarget(target.copyRef());
7191 }
7192 
7193 void Document::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
7194 {
7195     auto it = m_idToClientMap.find(clientId);
7196     if (it == m_idToClientMap.end())
7197         return;
7198 
7199     it-&gt;value-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
7200 }
7201 









7202 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
7203 
7204 #if ENABLE(MEDIA_SESSION)
7205 
7206 MediaSession&amp; Document::defaultMediaSession()
7207 {
7208     if (!m_defaultMediaSession)
7209         m_defaultMediaSession = MediaSession::create(*scriptExecutionContext());
7210     return *m_defaultMediaSession;
7211 }
7212 
7213 #endif
7214 
7215 ShouldOpenExternalURLsPolicy Document::shouldOpenExternalURLsPolicyToPropagate() const
7216 {
7217     if (DocumentLoader* documentLoader = loader())
7218         return documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate();
7219 
7220     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
7221 }
7222 
7223 bool Document::shouldEnforceHTTP09Sandbox() const
7224 {
7225     if (m_isSynthesized || !m_frame)
7226         return false;
7227     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7228     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7229 }
7230 
7231 #if USE(QUICK_LOOK)

7232 bool Document::shouldEnforceQuickLookSandbox() const
7233 {
7234     if (m_isSynthesized || !m_frame)
7235         return false;
7236     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7237     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7238 }
7239 
7240 void Document::applyQuickLookSandbox()
7241 {
7242     auto&amp; documentLoader = *m_frame-&gt;loader().activeDocumentLoader();
7243     auto documentURL = documentLoader.documentURL();
7244     auto&amp; responseURL = documentLoader.responseURL();
7245     ASSERT(!documentURL.protocolIs(QLPreviewProtocol));
7246     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7247 
7248     auto securityOrigin = SecurityOrigin::createNonLocalWithAllowedFilePath(responseURL, documentURL.fileSystemPath());
7249     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7250     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7251 
7252     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7253     RELEASE_ASSERT(contentSecurityPolicy());
7254     // The sandbox directive is only allowed if the policy is from an HTTP header.
7255     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7256 
7257     disableSandboxFlags(SandboxNavigation);
7258 
7259     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7260 }

7261 #endif
7262 
7263 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7264 {
7265     if (!settings().contentDispositionAttachmentSandboxEnabled())
7266         return false;
7267 
7268     if (m_isSynthesized)
7269         return false;
7270 
7271     if (auto* documentLoader = m_frame ? m_frame-&gt;loader().activeDocumentLoader() : nullptr)
7272         return documentLoader-&gt;response().isAttachment();
7273     return false;
7274 }
7275 
7276 void Document::applyContentDispositionAttachmentSandbox()
7277 {
7278     ASSERT(shouldEnforceContentDispositionAttachmentSandbox());
7279 
7280     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7281     if (!isMediaDocument())
7282         enforceSandboxFlags(SandboxAll);
7283     else
7284         enforceSandboxFlags(SandboxOrigin);
7285 }
7286 
<span class="line-modified">7287 void Document::addViewportDependentPicture(HTMLPictureElement&amp; picture)</span>
<span class="line-removed">7288 {</span>
<span class="line-removed">7289     m_viewportDependentPictures.add(&amp;picture);</span>
<span class="line-removed">7290 }</span>
<span class="line-removed">7291 </span>
<span class="line-removed">7292 void Document::removeViewportDependentPicture(HTMLPictureElement&amp; picture)</span>
7293 {
<span class="line-modified">7294     m_viewportDependentPictures.remove(&amp;picture);</span>
7295 }
7296 
<span class="line-modified">7297 void Document::addAppearanceDependentPicture(HTMLPictureElement&amp; picture)</span>
7298 {
<span class="line-modified">7299     m_appearanceDependentPictures.add(&amp;picture);</span>
<span class="line-removed">7300 }</span>
<span class="line-removed">7301 </span>
<span class="line-removed">7302 void Document::removeAppearanceDependentPicture(HTMLPictureElement&amp; picture)</span>
<span class="line-removed">7303 {</span>
<span class="line-removed">7304     m_appearanceDependentPictures.remove(&amp;picture);</span>
7305 }
7306 
7307 void Document::scheduleTimedRenderingUpdate()
7308 {
7309 #if ENABLE(INTERSECTION_OBSERVER)
7310     m_intersectionObserversInitialUpdateTimer.stop();
7311 #endif
7312     if (auto page = this-&gt;page())
7313         page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
7314 }
7315 
7316 #if ENABLE(INTERSECTION_OBSERVER)

7317 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7318 {
7319     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7320     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7321 }
7322 
7323 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7324 {
7325     m_intersectionObservers.removeFirst(&amp;observer);
7326 }
7327 
7328 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7329 {
7330     FloatBoxExtent rootMarginFloatBox(
7331         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7332         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7333         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7334         floatValueForLength(rootMargin.left(), localRootBounds.width())
7335     );
7336 
</pre>
<hr />
<pre>
7405     else if (is&lt;RenderInline&gt;(targetRenderer)) {
7406         auto pair = target.boundingAbsoluteRectWithoutLayout();
7407         if (pair) {
7408             FloatRect absoluteTargetBounds = pair-&gt;second;
7409             localTargetBounds = enclosingLayoutRect(targetRenderer-&gt;absoluteToLocalQuad(absoluteTargetBounds).boundingBox());
7410         }
7411     } else if (is&lt;RenderLineBreak&gt;(targetRenderer))
7412         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7413 
7414     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7415     if (observer.root()) {
7416         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7417         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7418     } else
7419         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7420 
7421     FloatRect rootLocalIntersectionRect = localRootBounds;
7422 
7423     IntersectionObservationState intersectionState;
7424     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);


7425 
7426     if (intersectionState.isIntersecting) {
7427         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
7428         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
7429             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
7430         else {
7431             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
7432             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
7433         }

7434     }
7435 
<span class="line-removed">7436     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();</span>
<span class="line-removed">7437     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();</span>
7438     return intersectionState;
7439 }
7440 
7441 void Document::updateIntersectionObservations()
7442 {
7443     auto* frameView = view();
7444     if (!frameView)
7445         return;
7446 
7447     m_intersectionObserversInitialUpdateTimer.stop();
7448 
7449     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
7450     if (needsLayout || hasPendingStyleRecalc())
7451         return;
7452 
7453     for (const auto&amp; observer : m_intersectionObservers) {
7454         bool needNotify = false;
7455         DOMHighResTimeStamp timestamp;
7456         if (!observer-&gt;createTimestamp(timestamp))
7457             continue;
</pre>
<hr />
<pre>
7525     if (m_intersectionObserversWithPendingNotifications.size())
7526         m_intersectionObserversNotifyTimer.startOneShot(0_s);
7527 }
7528 
7529 void Document::notifyIntersectionObserversTimerFired()
7530 {
7531     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
7532         if (observer)
7533             observer-&gt;notify();
7534     }
7535     m_intersectionObserversWithPendingNotifications.clear();
7536 }
7537 
7538 void Document::scheduleInitialIntersectionObservationUpdate()
7539 {
7540     if (m_readyState == Complete)
7541         scheduleTimedRenderingUpdate();
7542     else if (!m_intersectionObserversInitialUpdateTimer.isActive())
7543         m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);
7544 }

7545 #endif
7546 
7547 #if ENABLE(RESIZE_OBSERVER)

7548 void Document::addResizeObserver(ResizeObserver&amp; observer)
7549 {
7550     if (!m_resizeObservers.contains(&amp;observer))
7551         m_resizeObservers.append(makeWeakPtr(&amp;observer));
7552 }
7553 
7554 void Document::removeResizeObserver(ResizeObserver&amp; observer)
7555 {
7556     m_resizeObservers.removeFirst(&amp;observer);
7557 }
7558 
7559 bool Document::hasResizeObservers()
7560 {
7561     return !m_resizeObservers.isEmpty();
7562 }
7563 
7564 size_t Document::gatherResizeObservations(size_t deeperThan)
7565 {
7566     size_t minDepth = ResizeObserver::maxElementDepth();
7567     for (const auto&amp; observer : m_resizeObservers) {
</pre>
<hr />
<pre>
7607     // and it could change other frame in deliverResizeObservations().
7608     page.layoutIfNeeded();
7609 
7610     // Start check resize obervers;
7611     for (size_t depth = gatherResizeObservations(0); depth != ResizeObserver::maxElementDepth(); depth = gatherResizeObservations(depth)) {
7612         deliverResizeObservations();
7613         page.layoutIfNeeded();
7614     }
7615 
7616     if (hasSkippedResizeObservations()) {
7617         setHasSkippedResizeObservations(false);
7618         String url;
7619         unsigned line = 0;
7620         unsigned column = 0;
7621         getParserLocation(url, line, column);
7622         reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);
7623         // Starting a new schedule the next round of notify.
7624         scheduleTimedRenderingUpdate();
7625     }
7626 }

7627 #endif
7628 
7629 const AtomString&amp; Document::dir() const
7630 {
7631     auto* documentElement = this-&gt;documentElement();
7632     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
7633         return nullAtom();
7634     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
7635 }
7636 
7637 void Document::setDir(const AtomString&amp; value)
7638 {
7639     auto* documentElement = this-&gt;documentElement();
7640     if (is&lt;HTMLHtmlElement&gt;(documentElement))
7641         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
7642 }
7643 
7644 DOMSelection* Document::getSelection()
7645 {
7646     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
</pre>
<hr />
<pre>
7649 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7650 {
7651     ASSERT(shadowRoot.isConnected());
7652     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7653     m_inDocumentShadowRoots.add(&amp;shadowRoot);
7654 }
7655 
7656 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7657 {
7658     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7659     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
7660 }
7661 
7662 void Document::orientationChanged(int orientation)
7663 {
7664     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
7665     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
7666     m_orientationNotifier.orientationChanged(orientation);
7667 }
7668 
<span class="line-removed">7669 void Document::notifyMediaCaptureOfVisibilityChanged()</span>
<span class="line-removed">7670 {</span>
7671 #if ENABLE(MEDIA_STREAM)
<span class="line-removed">7672     if (!page())</span>
<span class="line-removed">7673         return;</span>
7674 
<span class="line-removed">7675     RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page()-&gt;isMediaCaptureMuted());</span>
<span class="line-removed">7676 #endif</span>
<span class="line-removed">7677 }</span>
<span class="line-removed">7678 </span>
<span class="line-removed">7679 #if ENABLE(MEDIA_STREAM)</span>
7680 void Document::stopMediaCapture()
7681 {
7682     MediaStreamTrack::endCapture(*this);
7683 }
7684 
<span class="line-removed">7685 void Document::registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">7686 {</span>
<span class="line-removed">7687     m_mediaStreamStateChangeElements.add(&amp;element);</span>
<span class="line-removed">7688 }</span>
<span class="line-removed">7689 </span>
<span class="line-removed">7690 void Document::unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp; element)</span>
<span class="line-removed">7691 {</span>
<span class="line-removed">7692     m_mediaStreamStateChangeElements.remove(&amp;element);</span>
<span class="line-removed">7693 }</span>
<span class="line-removed">7694 </span>
7695 void Document::mediaStreamCaptureStateChanged()
7696 {
7697     if (!MediaProducer::isCapturing(m_mediaState))
7698         return;
7699 
<span class="line-modified">7700     for (auto* mediaElement : m_mediaStreamStateChangeElements)</span>
<span class="line-modified">7701         mediaElement-&gt;mediaStreamCaptureStarted();</span>

7702 }
7703 
7704 void Document::setDeviceIDHashSalt(const String&amp; salt)
7705 {
7706     ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
7707     m_idHashSalt = salt;
7708 }
7709 
7710 #endif
7711 
<span class="line-removed">7712 void Document::addApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)</span>
<span class="line-removed">7713 {</span>
<span class="line-removed">7714     m_applicationStateChangeListeners.add(&amp;listener);</span>
<span class="line-removed">7715 }</span>
<span class="line-removed">7716 </span>
<span class="line-removed">7717 void Document::removeApplicationStateChangeListener(ApplicationStateChangeListener&amp; listener)</span>
<span class="line-removed">7718 {</span>
<span class="line-removed">7719     m_applicationStateChangeListeners.remove(&amp;listener);</span>
<span class="line-removed">7720 }</span>
<span class="line-removed">7721 </span>
<span class="line-removed">7722 void Document::forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp; functor)</span>
<span class="line-removed">7723 {</span>
<span class="line-removed">7724     for (auto* listener : m_applicationStateChangeListeners)</span>
<span class="line-removed">7725         functor(*listener);</span>
<span class="line-removed">7726 }</span>
<span class="line-removed">7727 </span>
7728 const AtomString&amp; Document::bgColor() const
7729 {
7730     auto* bodyElement = body();
7731     if (!bodyElement)
7732         return emptyAtom();
7733     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
7734 }
7735 
7736 void Document::setBgColor(const String&amp; value)
7737 {
7738     if (auto* bodyElement = body())
7739         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
7740 }
7741 
7742 const AtomString&amp; Document::fgColor() const
7743 {
7744     auto* bodyElement = body();
7745     if (!bodyElement)
7746         return emptyAtom();
7747     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
</pre>
<hr />
<pre>
7782 }
7783 
7784 const AtomString&amp; Document::vlinkColor() const
7785 {
7786     auto* bodyElement = body();
7787     if (!bodyElement)
7788         return emptyAtom();
7789     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
7790 }
7791 
7792 void Document::setVlinkColor(const String&amp; value)
7793 {
7794     if (auto* bodyElement = body())
7795         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
7796 }
7797 
7798 Logger&amp; Document::logger()
7799 {
7800     if (!m_logger) {
7801         m_logger = Logger::create(this);
<span class="line-modified">7802         m_logger-&gt;setEnabled(this, sessionID().isAlwaysOnLoggingAllowed());</span>

7803         m_logger-&gt;addObserver(*this);
7804     }
7805 
7806     return *m_logger;
7807 }
7808 
7809 Optional&lt;PageIdentifier&gt; Document::pageID() const
7810 {
7811     return m_frame-&gt;loader().client().pageID();
7812 }
7813 
7814 void Document::registerArticleElement(Element&amp; article)
7815 {
7816     m_articleElements.add(&amp;article);
7817 }
7818 
7819 void Document::unregisterArticleElement(Element&amp; article)
7820 {
7821     m_articleElements.remove(&amp;article);
7822     if (m_mainArticleElement == &amp;article)
</pre>
<hr />
<pre>
7908 
7909     StringBuilder builder;
7910     builder.append(referrerURL.protocol());
7911     builder.appendLiteral(&quot;://&quot;);
7912     builder.append(referrerRegistrableDomainStr);
7913     if (referrerPort) {
7914         builder.append(&#39;:&#39;);
7915         builder.appendNumber(*referrerPort);
7916     }
7917     builder.append(&#39;/&#39;);
7918 
7919     m_referrerOverride = builder.toString();
7920 }
7921 #endif
7922 
7923 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
7924 {
7925     m_consoleMessageListener = listener;
7926 }
7927 










7928 DocumentTimeline&amp; Document::timeline()
7929 {
7930     if (!m_timeline)
7931         m_timeline = DocumentTimeline::create(*this);
7932 
7933     return *m_timeline;
7934 }
7935 
7936 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
7937 {
7938     // For the list of animations to be current, we need to account for any pending CSS changes,
7939     // such as updates to CSS Animations and CSS Transitions.
7940     updateStyleIfNeeded();
7941 
7942     if (m_timeline)
7943         return m_timeline-&gt;getAnimations();
7944     return { };
7945 }
7946 
7947 #if ENABLE(ATTACHMENT_ELEMENT)
</pre>
<hr />
<pre>
8031     ASSERT_NOT_REACHED();
8032     return MessageLevel::Log;
8033 }
8034 
8035 static inline Vector&lt;JSONLogValue&gt; crossThreadCopy(Vector&lt;JSONLogValue&gt;&amp;&amp; source)
8036 {
8037     auto values = WTFMove(source);
8038     for (auto&amp; value : values)
8039         value.value = crossThreadCopy(WTFMove(value.value));
8040     return values;
8041 }
8042 
8043 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8044 {
8045     if (!isMainThread()) {
8046         postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {
8047             didLogMessage(channel, level, WTFMove(logMessages));
8048         });
8049         return;
8050     }
<span class="line-modified">8051     if (!page())</span>

8052         return;
8053 
<span class="line-modified">8054     ASSERT(sessionID().isAlwaysOnLoggingAllowed());</span>
8055 
8056     auto messageSource = messageSourceForWTFLogChannel(channel);
8057     if (messageSource == MessageSource::Other)
8058         return;
8059 
8060     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
<span class="line-modified">8061         if (!page())</span>
8062             return;
8063 
8064         auto messageLevel = messageLevelFromWTFLogLevel(level);
8065         auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
8066 
8067         addConsoleMessage(WTFMove(message));
8068     });
8069 }
8070 
8071 #if ENABLE(SERVICE_WORKER)
8072 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8073 {
8074     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8075         return;
8076 
8077     if (m_serviceWorkerConnection)
8078         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8079 
8080     m_serviceWorkerConnection = serviceWorkerConnection;
8081 
</pre>
<hr />
<pre>
8115         return;
8116 
8117     if (auto* window = domWindow())
8118         window-&gt;willDetachDocumentFromFrame();
8119 
8120     detachFromFrame();
8121 }
8122 
8123 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8124 {
8125     return hitTest(request, result.hitTestLocation(), result);
8126 }
8127 
8128 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
8129 {
8130     Ref&lt;Document&gt; protectedThis(*this);
8131     updateLayout();
8132     if (!renderView())
8133         return false;
8134 
<span class="line-modified">8135 #if !ASSERT_DISABLED</span>
8136     SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
8137 #endif
8138 
8139     auto&amp; frameView = renderView()-&gt;frameView();
8140     Ref&lt;FrameView&gt; protector(frameView);
8141 
8142     FrameFlatteningLayoutDisallower disallower(frameView);
8143 
8144     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8145 
8146     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8147     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8148     // will always work so we need to check the ScrollView scrollbars in that case too.
8149     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8150         // FIXME: Consider if this test should be done unconditionally.
8151         if (request.allowsFrameScrollbars()) {
8152             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8153             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8154                 result.setScrollbar(frameScrollbar);
8155                 return true;
</pre>
<hr />
<pre>
8249 }
8250 
8251 void Document::setAsRunningUserScripts()
8252 {
8253     auto&amp; top = topDocument();
8254     if (this == &amp;top)
8255         m_isRunningUserScripts = true;
8256     else
8257         top.setAsRunningUserScripts();
8258 }
8259 
8260 void Document::setHasEvaluatedUserAgentScripts()
8261 {
8262     auto&amp; top = topDocument();
8263     if (this == &amp;top)
8264         m_hasEvaluatedUserAgentScripts = true;
8265     else
8266         top.setHasEvaluatedUserAgentScripts();
8267 }
8268 


















8269 #if ENABLE(APPLE_PAY)
8270 
8271 bool Document::isApplePayActive() const
8272 {
8273     auto&amp; top = topDocument();
8274     return this == &amp;top ? m_hasStartedApplePaySession : top.isApplePayActive();
8275 }
8276 
8277 void Document::setApplePayIsActive()
8278 {
8279     auto&amp; top = topDocument();
8280     if (this == &amp;top)
8281         m_hasStartedApplePaySession = true;
8282     else
8283         top.setApplePayIsActive();
8284 }
8285 
8286 #endif
8287 








































8288 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  12  * This library is free software; you can redistribute it and/or
  13  * modify it under the terms of the GNU Library General Public
  14  * License as published by the Free Software Foundation; either
  15  * version 2 of the License, or (at your option) any later version.
  16  *
  17  * This library is distributed in the hope that it will be useful,
  18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  20  * Library General Public License for more details.
  21  *
  22  * You should have received a copy of the GNU Library General Public License
  23  * along with this library; see the file COPYING.LIB.  If not, write to
  24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25  * Boston, MA 02110-1301, USA.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Document.h&quot;
  30 
  31 #include &quot;AXObjectCache.h&quot;

  32 #include &quot;Attr.h&quot;
  33 #include &quot;BeforeUnloadEvent.h&quot;
  34 #include &quot;CDATASection.h&quot;
  35 #include &quot;CSSAnimationController.h&quot;
  36 #include &quot;CSSFontSelector.h&quot;
  37 #include &quot;CSSStyleDeclaration.h&quot;
  38 #include &quot;CSSStyleSheet.h&quot;
  39 #include &quot;CachedCSSStyleSheet.h&quot;
  40 #include &quot;CachedFrame.h&quot;
  41 #include &quot;CachedResourceLoader.h&quot;
  42 #include &quot;CanvasRenderingContext2D.h&quot;
  43 #include &quot;Chrome.h&quot;
  44 #include &quot;ChromeClient.h&quot;
  45 #include &quot;Comment.h&quot;
  46 #include &quot;CommonVM.h&quot;
  47 #include &quot;ComposedTreeIterator.h&quot;
  48 #include &quot;CompositionEvent.h&quot;
  49 #include &quot;ConstantPropertyMap.h&quot;
  50 #include &quot;ContentSecurityPolicy.h&quot;
  51 #include &quot;CookieJar.h&quot;
  52 #include &quot;CustomElementReactionQueue.h&quot;
  53 #include &quot;CustomElementRegistry.h&quot;
  54 #include &quot;CustomEvent.h&quot;
  55 #include &quot;CustomHeaderFields.h&quot;
  56 #include &quot;DOMImplementation.h&quot;
  57 #include &quot;DOMWindow.h&quot;
  58 #include &quot;DateComponents.h&quot;
  59 #include &quot;DebugPageOverlays.h&quot;
<span class="line-added">  60 #include &quot;DeprecatedGlobalSettings.h&quot;</span>
  61 #include &quot;DocumentLoader.h&quot;
  62 #include &quot;DocumentMarkerController.h&quot;
  63 #include &quot;DocumentSharedObjectPool.h&quot;
  64 #include &quot;DocumentTimeline.h&quot;
  65 #include &quot;DocumentType.h&quot;
<span class="line-added">  66 #include &quot;DragEvent.h&quot;</span>
  67 #include &quot;Editing.h&quot;
  68 #include &quot;Editor.h&quot;
  69 #include &quot;ElementIterator.h&quot;
  70 #include &quot;EventHandler.h&quot;
  71 #include &quot;ExtensionStyleSheets.h&quot;
  72 #include &quot;FocusController.h&quot;
  73 #include &quot;FocusEvent.h&quot;
  74 #include &quot;FontFaceSet.h&quot;
  75 #include &quot;FormController.h&quot;
  76 #include &quot;Frame.h&quot;
  77 #include &quot;FrameLoader.h&quot;
  78 #include &quot;FrameLoaderClient.h&quot;
  79 #include &quot;FrameView.h&quot;
  80 #include &quot;FullscreenManager.h&quot;
<span class="line-added">  81 #include &quot;GCReachableRef.h&quot;</span>
  82 #include &quot;GenericCachedHTMLCollection.h&quot;
  83 #include &quot;HTMLAllCollection.h&quot;
  84 #include &quot;HTMLAnchorElement.h&quot;
  85 #include &quot;HTMLAttachmentElement.h&quot;
  86 #include &quot;HTMLBaseElement.h&quot;
  87 #include &quot;HTMLBodyElement.h&quot;
  88 #include &quot;HTMLCanvasElement.h&quot;
  89 #include &quot;HTMLDocument.h&quot;
  90 #include &quot;HTMLElementFactory.h&quot;
  91 #include &quot;HTMLFormControlElement.h&quot;
  92 #include &quot;HTMLFrameOwnerElement.h&quot;
  93 #include &quot;HTMLFrameSetElement.h&quot;
  94 #include &quot;HTMLHeadElement.h&quot;
  95 #include &quot;HTMLHtmlElement.h&quot;
  96 #include &quot;HTMLImageElement.h&quot;
  97 #include &quot;HTMLInputElement.h&quot;
  98 #include &quot;HTMLLinkElement.h&quot;
  99 #include &quot;HTMLMediaElement.h&quot;
 100 #include &quot;HTMLNameCollection.h&quot;
 101 #include &quot;HTMLParserIdioms.h&quot;
 102 #include &quot;HTMLPictureElement.h&quot;
 103 #include &quot;HTMLPlugInElement.h&quot;
 104 #include &quot;HTMLScriptElement.h&quot;
 105 #include &quot;HTMLStyleElement.h&quot;
 106 #include &quot;HTMLTitleElement.h&quot;
 107 #include &quot;HTMLUnknownElement.h&quot;
 108 #include &quot;HTTPHeaderNames.h&quot;
 109 #include &quot;HTTPParsers.h&quot;
 110 #include &quot;HashChangeEvent.h&quot;
<span class="line-added"> 111 #include &quot;HighlightMap.h&quot;</span>
 112 #include &quot;History.h&quot;
 113 #include &quot;HitTestResult.h&quot;
<span class="line-added"> 114 #include &quot;IdleCallbackController.h&quot;</span>
 115 #include &quot;ImageBitmapRenderingContext.h&quot;
 116 #include &quot;ImageLoader.h&quot;
 117 #include &quot;InspectorInstrumentation.h&quot;
 118 #include &quot;IntersectionObserver.h&quot;
 119 #include &quot;JSCustomElementInterface.h&quot;
 120 #include &quot;JSLazyEventListener.h&quot;
 121 #include &quot;KeyboardEvent.h&quot;
 122 #include &quot;KeyframeEffect.h&quot;
 123 #include &quot;LayoutDisallowedScope.h&quot;
<span class="line-added"> 124 #include &quot;LegacySchemeRegistry.h&quot;</span>
 125 #include &quot;LibWebRTCProvider.h&quot;
 126 #include &quot;LoaderStrategy.h&quot;
 127 #include &quot;Logging.h&quot;
 128 #include &quot;MediaCanStartListener.h&quot;
 129 #include &quot;MediaProducer.h&quot;
 130 #include &quot;MediaQueryList.h&quot;
 131 #include &quot;MediaQueryMatcher.h&quot;
 132 #include &quot;MediaStream.h&quot;
 133 #include &quot;MessageEvent.h&quot;

 134 #include &quot;MouseEventWithHitTestResults.h&quot;
 135 #include &quot;MutationEvent.h&quot;
 136 #include &quot;NameNodeList.h&quot;
 137 #include &quot;NavigationDisabler.h&quot;
 138 #include &quot;NavigationScheduler.h&quot;
 139 #include &quot;NestingLevelIncrementer.h&quot;
 140 #include &quot;NodeIterator.h&quot;
 141 #include &quot;NodeRareData.h&quot;
 142 #include &quot;NodeWithIndex.h&quot;
 143 #include &quot;OverflowEvent.h&quot;
 144 #include &quot;PageConsoleClient.h&quot;
 145 #include &quot;PageGroup.h&quot;
 146 #include &quot;PageTransitionEvent.h&quot;
 147 #include &quot;PaintWorkletGlobalScope.h&quot;
 148 #include &quot;PlatformLocale.h&quot;
 149 #include &quot;PlatformMediaSessionManager.h&quot;
 150 #include &quot;PlatformScreen.h&quot;
 151 #include &quot;PlatformStrategies.h&quot;
 152 #include &quot;PlugInsResources.h&quot;
 153 #include &quot;PluginDocument.h&quot;
</pre>
<hr />
<pre>
 162 #include &quot;RenderInline.h&quot;
 163 #include &quot;RenderLayerCompositor.h&quot;
 164 #include &quot;RenderLineBreak.h&quot;
 165 #include &quot;RenderTreeUpdater.h&quot;
 166 #include &quot;RenderView.h&quot;
 167 #include &quot;RenderWidget.h&quot;
 168 #include &quot;RequestAnimationFrameCallback.h&quot;
 169 #include &quot;ResizeObserver.h&quot;
 170 #include &quot;ResourceLoadObserver.h&quot;
 171 #include &quot;RuntimeApplicationChecks.h&quot;
 172 #include &quot;RuntimeEnabledFeatures.h&quot;
 173 #include &quot;SVGDocumentExtensions.h&quot;
 174 #include &quot;SVGElement.h&quot;
 175 #include &quot;SVGElementFactory.h&quot;
 176 #include &quot;SVGNames.h&quot;
 177 #include &quot;SVGSVGElement.h&quot;
 178 #include &quot;SVGTitleElement.h&quot;
 179 #include &quot;SVGUseElement.h&quot;
 180 #include &quot;SVGZoomEvent.h&quot;
 181 #include &quot;SWClientConnection.h&quot;

 182 #include &quot;ScopedEventQueue.h&quot;
 183 #include &quot;ScriptController.h&quot;
 184 #include &quot;ScriptDisallowedScope.h&quot;
 185 #include &quot;ScriptModuleLoader.h&quot;
 186 #include &quot;ScriptRunner.h&quot;
 187 #include &quot;ScriptSourceCode.h&quot;
 188 #include &quot;ScriptState.h&quot;
 189 #include &quot;ScriptedAnimationController.h&quot;
 190 #include &quot;ScrollbarTheme.h&quot;
 191 #include &quot;ScrollingCoordinator.h&quot;
 192 #include &quot;SecurityOrigin.h&quot;
 193 #include &quot;SecurityOriginData.h&quot;
 194 #include &quot;SecurityOriginPolicy.h&quot;
 195 #include &quot;SecurityPolicy.h&quot;
 196 #include &quot;SegmentedString.h&quot;
 197 #include &quot;SelectorQuery.h&quot;
 198 #include &quot;ServiceWorkerClientData.h&quot;
<span class="line-added"> 199 #include &quot;ServiceWorkerContainer.h&quot;</span>
 200 #include &quot;ServiceWorkerProvider.h&quot;
 201 #include &quot;Settings.h&quot;
 202 #include &quot;ShadowRoot.h&quot;
 203 #include &quot;SocketProvider.h&quot;
 204 #include &quot;StorageEvent.h&quot;
 205 #include &quot;StringCallback.h&quot;
 206 #include &quot;StyleColor.h&quot;
 207 #include &quot;StyleProperties.h&quot;
 208 #include &quot;StyleResolveForDocument.h&quot;
 209 #include &quot;StyleResolver.h&quot;
 210 #include &quot;StyleScope.h&quot;
 211 #include &quot;StyleSheetContents.h&quot;
 212 #include &quot;StyleSheetList.h&quot;
 213 #include &quot;StyleTreeResolver.h&quot;
 214 #include &quot;SubresourceLoader.h&quot;
 215 #include &quot;TextAutoSizing.h&quot;
 216 #include &quot;TextEvent.h&quot;
<span class="line-added"> 217 #include &quot;TextManipulationController.h&quot;</span>
 218 #include &quot;TextNodeTraversal.h&quot;
 219 #include &quot;TouchAction.h&quot;
 220 #include &quot;TransformSource.h&quot;
 221 #include &quot;TreeWalker.h&quot;
 222 #include &quot;UndoManager.h&quot;
 223 #include &quot;UserGestureIndicator.h&quot;
 224 #include &quot;ValidationMessageClient.h&quot;
 225 #include &quot;VisibilityChangeClient.h&quot;
 226 #include &quot;VisitedLinkState.h&quot;
<span class="line-added"> 227 #include &quot;VisualViewport.h&quot;</span>
 228 #include &quot;WebAnimation.h&quot;
 229 #include &quot;WheelEvent.h&quot;
<span class="line-added"> 230 #include &quot;WindowEventLoop.h&quot;</span>
 231 #include &quot;WindowFeatures.h&quot;
 232 #include &quot;Worklet.h&quot;
 233 #include &quot;XMLDocument.h&quot;
 234 #include &quot;XMLDocumentParser.h&quot;
 235 #include &quot;XMLNSNames.h&quot;
 236 #include &quot;XMLNames.h&quot;
 237 #include &quot;XPathEvaluator.h&quot;
 238 #include &quot;XPathExpression.h&quot;
 239 #include &quot;XPathNSResolver.h&quot;
 240 #include &quot;XPathResult.h&quot;
 241 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 242 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 243 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 244 #include &lt;JavaScriptCore/VM.h&gt;
 245 #include &lt;ctime&gt;
 246 #include &lt;wtf/IsoMallocInlines.h&gt;
 247 #include &lt;wtf/Language.h&gt;
 248 #include &lt;wtf/NeverDestroyed.h&gt;
 249 #include &lt;wtf/SetForScope.h&gt;
 250 #include &lt;wtf/SystemTracing.h&gt;
</pre>
<hr />
<pre>
 315 #endif
 316 
 317 #if ENABLE(XSLT)
 318 #include &quot;XSLTProcessor.h&quot;
 319 #endif
 320 
 321 #if ENABLE(WEBGL)
 322 #include &quot;WebGLRenderingContext.h&quot;
 323 #endif
 324 #if ENABLE(WEBGL2)
 325 #include &quot;WebGL2RenderingContext.h&quot;
 326 #endif
 327 #if ENABLE(WEBGPU)
 328 #include &quot;GPUCanvasContext.h&quot;
 329 #endif
 330 
 331 #if ENABLE(POINTER_EVENTS)
 332 #include &quot;PointerCaptureController.h&quot;
 333 #endif
 334 
<span class="line-added"> 335 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 336 #include &quot;HTMLVideoElement.h&quot;</span>
<span class="line-added"> 337 #endif</span>
<span class="line-added"> 338 </span>
 339 namespace WebCore {
 340 
 341 WTF_MAKE_ISO_ALLOCATED_IMPL(Document);
 342 
 343 using namespace HTMLNames;
 344 using namespace PAL;
 345 using namespace WTF::Unicode;
 346 
 347 static const unsigned cMaxWriteRecursionDepth = 21;
 348 bool Document::hasEverCreatedAnAXObjectCache = false;
 349 static const Seconds maxIntervalForUserGestureForwardingAfterMediaFinishesPlaying { 1_s };
 350 
 351 struct FrameFlatteningLayoutDisallower {
 352     FrameFlatteningLayoutDisallower(FrameView&amp; frameView)
 353         : m_frameView(frameView)
 354         , m_disallowLayout(frameView.effectiveFrameFlattening() != FrameFlattening::Disabled)
 355     {
 356         if (m_disallowLayout)
 357             m_frameView.startDisallowingLayout();
 358     }
 359 
 360     ~FrameFlatteningLayoutDisallower()
 361     {
 362         if (m_disallowLayout)
 363             m_frameView.endDisallowingLayout();
 364     }
 365 
 366 private:
 367     FrameView&amp; m_frameView;
 368     bool m_disallowLayout { false };
 369 };
 370 
<span class="line-added"> 371 // Defined here to avoid including GCReachableRef.h in Document.h</span>
<span class="line-added"> 372 struct Document::PendingScrollEventTargetList {</span>
<span class="line-added"> 373     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added"> 374 </span>
<span class="line-added"> 375 public:</span>
<span class="line-added"> 376     Vector&lt;GCReachableRef&lt;ContainerNode&gt;&gt; targets;</span>
<span class="line-added"> 377 };</span>
<span class="line-added"> 378 </span>
 379 #if ENABLE(INTERSECTION_OBSERVER)
 380 static const Seconds intersectionObserversInitialUpdateDelay { 2000_ms };
 381 #endif
 382 
 383 // DOM Level 2 says (letters added):
 384 //
 385 // a) Name start characters must have one of the categories Ll, Lu, Lo, Lt, Nl.
 386 // b) Name characters other than Name-start characters must have one of the categories Mc, Me, Mn, Lm, or Nd.
 387 // c) Characters in the compatibility area (i.e. with character code greater than #xF900 and less than #xFFFE) are not allowed in XML names.
 388 // d) Characters which have a font or compatibility decomposition (i.e. those with a &quot;compatibility formatting tag&quot; in field 5 of the database -- marked by field 5 beginning with a &quot;&lt;&quot;) are not allowed.
 389 // e) The following characters are treated as name-start characters rather than name characters, because the property file classifies them as Alphabetic: [#x02BB-#x02C1], #x0559, #x06E5, #x06E6.
 390 // f) Characters #x20DD-#x20E0 are excluded (in accordance with Unicode, section 5.14).
 391 // g) Character #x00B7 is classified as an extender, because the property list so identifies it.
 392 // h) Character #x0387 is added as a name character, because #x00B7 is its canonical equivalent.
 393 // i) Characters &#39;:&#39; and &#39;_&#39; are allowed as name-start characters.
 394 // j) Characters &#39;-&#39; and &#39;.&#39; are allowed as name characters.
 395 //
 396 // It also contains complete tables. If we decide it&#39;s better, we could include those instead of the following code.
 397 
 398 static inline bool isValidNameStart(UChar32 c)
</pre>
<hr />
<pre>
 528     static NeverDestroyed&lt;DocumentsMap&gt; documents;
 529     return documents;
 530 }
 531 
 532 auto Document::allDocuments() -&gt; DocumentsMap::ValuesIteratorRange
 533 {
 534     return allDocumentsMap().values();
 535 }
 536 
 537 static inline int currentOrientation(Frame* frame)
 538 {
 539 #if ENABLE(ORIENTATION_EVENTS)
 540     if (frame)
 541         return frame-&gt;orientation();
 542 #else
 543     UNUSED_PARAM(frame);
 544 #endif
 545     return 0;
 546 }
 547 
<span class="line-modified"> 548 Document::Document(Frame* frame, const URL&amp; url, unsigned documentClasses, unsigned constructionFlags)</span>
 549     : ContainerNode(*this, CreateDocument)
 550     , TreeScope(*this)
 551     , FrameDestructionObserver(frame)
 552 #if ENABLE(IOS_TOUCH_EVENTS)
 553     , m_touchEventsChangedTimer(*this, &amp;Document::touchEventsChangedTimerFired)
 554 #endif
 555     , m_settings(frame ? Ref&lt;Settings&gt;(frame-&gt;settings()) : Settings::create(nullptr))
 556     , m_quirks(makeUniqueRef&lt;Quirks&gt;(*this))
 557     , m_cachedResourceLoader(m_frame ? Ref&lt;CachedResourceLoader&gt;(m_frame-&gt;loader().activeDocumentLoader()-&gt;cachedResourceLoader()) : CachedResourceLoader::create(nullptr))
 558     , m_domTreeVersion(++s_globalTreeVersion)
 559     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 560     , m_extensionStyleSheets(makeUnique&lt;ExtensionStyleSheets&gt;(*this))
 561     , m_visitedLinkState(makeUnique&lt;VisitedLinkState&gt;(*this))
 562     , m_markers(makeUnique&lt;DocumentMarkerController&gt;(*this))
 563     , m_styleRecalcTimer([this] { updateStyleIfNeeded(); })
 564     , m_documentCreationTime(MonotonicTime::now())
 565     , m_scriptRunner(makeUnique&lt;ScriptRunner&gt;(*this))
 566     , m_moduleLoader(makeUnique&lt;ScriptModuleLoader&gt;(*this))
 567 #if ENABLE(XSLT)
 568     , m_applyPendingXSLTransformsTimer(*this, &amp;Document::applyPendingXSLTransformsTimerFired)
 569 #endif
 570     , m_xmlVersion(&quot;1.0&quot;_s)
 571     , m_constantPropertyMap(makeUnique&lt;ConstantPropertyMap&gt;(*this))
 572     , m_documentClasses(documentClasses)

 573 #if ENABLE(FULLSCREEN_API)
 574     , m_fullscreenManager { makeUniqueRef&lt;FullscreenManager&gt;(*this) }
 575 #endif
 576 #if ENABLE(INTERSECTION_OBSERVER)
 577     , m_intersectionObserversNotifyTimer(*this, &amp;Document::notifyIntersectionObserversTimerFired)
 578     , m_intersectionObserversInitialUpdateTimer(*this, &amp;Document::scheduleTimedRenderingUpdate)
 579 #endif
 580     , m_loadEventDelayTimer(*this, &amp;Document::loadEventDelayTimerFired)
 581 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DEVICE_ORIENTATION)
<span class="line-modified"> 582     , m_deviceMotionClient(makeUnique&lt;DeviceMotionClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))</span>
 583     , m_deviceMotionController(makeUnique&lt;DeviceMotionController&gt;(*m_deviceMotionClient))
<span class="line-modified"> 584     , m_deviceOrientationClient(makeUnique&lt;DeviceOrientationClientIOS&gt;(page() ? page()-&gt;deviceOrientationUpdateProvider() : nullptr))</span>
 585     , m_deviceOrientationController(makeUnique&lt;DeviceOrientationController&gt;(*m_deviceOrientationClient))
 586 #endif
 587     , m_pendingTasksTimer(*this, &amp;Document::pendingTasksTimerFired)
 588     , m_visualUpdatesSuppressionTimer(*this, &amp;Document::visualUpdatesSuppressionTimerFired)
 589     , m_sharedObjectPoolClearTimer(*this, &amp;Document::clearSharedObjectPool)
 590     , m_fontSelector(CSSFontSelector::create(*this))
 591     , m_didAssociateFormControlsTimer(*this, &amp;Document::didAssociateFormControlsTimerFired)
 592     , m_cookieCacheExpiryTimer(*this, &amp;Document::invalidateDOMCookieCache)
 593     , m_socketProvider(page() ? &amp;page()-&gt;socketProvider() : nullptr)
 594     , m_isSynthesized(constructionFlags &amp; Synthesized)
 595     , m_isNonRenderedPlaceholder(constructionFlags &amp; NonRenderedPlaceholder)
 596     , m_orientationNotifier(currentOrientation(frame))

 597     , m_identifier(DocumentIdentifier::generate())
 598     , m_undoManager(UndoManager::create(*this))
 599 {


 600     auto addResult = allDocumentsMap().add(m_identifier, this);
 601     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 602 
 603     // We depend on the url getting immediately set in subframes, but we
 604     // also depend on the url NOT getting immediately set in opened windows.
 605     // See fast/dom/early-frame-url.html
 606     // and fast/dom/location-new-window-no-crash.html, respectively.
 607     // FIXME: Can/should we unify this behavior?
 608     if ((frame &amp;&amp; frame-&gt;ownerElement()) || !url.isEmpty())
 609         setURL(url);
 610 
 611     m_cachedResourceLoader-&gt;setDocument(this);
 612 
 613     resetLinkColor();
 614     resetVisitedLinkColor();
 615     resetActiveLinkColor();
 616 
 617     initSecurityContext();
 618     initDNSPrefetch();
 619 
 620     m_fontSelector-&gt;registerForInvalidationCallbacks(*this);
 621 
 622     for (auto&amp; nodeListAndCollectionCount : m_nodeListAndCollectionCounts)
 623         nodeListAndCollectionCount = 0;
 624 
 625     InspectorInstrumentation::addEventListenersToNode(*this);
<span class="line-added"> 626 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added"> 627     m_settings-&gt;setLegacyGetUserMediaEnabled(quirks().shouldEnableLegacyGetUserMedia());</span>
<span class="line-added"> 628 #endif</span>
 629 }
 630 
 631 Ref&lt;Document&gt; Document::create(Document&amp; contextDocument)
 632 {
<span class="line-modified"> 633     auto document = adoptRef(*new Document(nullptr, URL()));</span>
 634     document-&gt;setContextDocument(contextDocument);
 635     document-&gt;setSecurityOriginPolicy(contextDocument.securityOriginPolicy());
 636     return document;
 637 }
 638 
 639 Ref&lt;Document&gt; Document::createNonRenderedPlaceholder(Frame&amp; frame, const URL&amp; url)
 640 {
<span class="line-modified"> 641     return adoptRef(*new Document(&amp;frame, url, DefaultDocumentClass, NonRenderedPlaceholder));</span>
 642 }
 643 
 644 Document::~Document()
 645 {
<span class="line-added"> 646     ASSERT(activeDOMObjectsAreStopped());</span>
<span class="line-added"> 647 </span>
 648     if (m_logger)
 649         m_logger-&gt;removeObserver(*this);
 650 
 651     ASSERT(allDocumentsMap().contains(m_identifier));
 652     allDocumentsMap().remove(m_identifier);
 653     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this Document from another thread is safe.
 654     removeFromContextsMap();
 655 
 656     ASSERT(!renderView());
<span class="line-modified"> 657     ASSERT(m_backForwardCacheState != InBackForwardCache);</span>
 658     ASSERT(m_ranges.isEmpty());
 659     ASSERT(!m_parentTreeScope);
 660     ASSERT(!m_disabledFieldsetElementsCount);
 661     ASSERT(m_inDocumentShadowRoots.isEmpty());
 662 
 663 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 664     m_deviceMotionClient-&gt;deviceMotionControllerDestroyed();
 665     m_deviceOrientationClient-&gt;deviceOrientationControllerDestroyed();
 666 #endif
 667 
 668     if (m_templateDocument)
 669         m_templateDocument-&gt;setTemplateDocumentHost(nullptr); // balanced in templateDocument().
 670 
 671     // FIXME: Should we reset m_domWindow when we detach from the Frame?
 672     if (m_domWindow)
 673         m_domWindow-&gt;resetUnlessSuspendedForDocumentSuspension();
 674 
 675     m_scriptRunner = nullptr;
 676     m_moduleLoader = nullptr;
 677 
</pre>
<hr />
<pre>
 757         // removeDetachedChildren() doesn&#39;t always unregister IDs,
 758         // so tear down scope information up front to avoid having
 759         // stale references in the map.
 760 
 761         destroyTreeScopeData();
 762         removeDetachedChildren();
 763         m_formController = nullptr;
 764 
 765         m_markers-&gt;detach();
 766 
 767         m_cssCanvasElements.clear();
 768 
 769         commonTeardown();
 770 
 771 #ifndef NDEBUG
 772         // We need to do this right now since selfOnlyDeref() can delete this.
 773         m_inRemovedLastRefFunction = false;
 774 #endif
 775         decrementReferencingNodeCount();
 776     } else {
<span class="line-added"> 777         stopActiveDOMObjects();</span>
 778 #ifndef NDEBUG
 779         m_inRemovedLastRefFunction = false;
 780         m_deletionHasBegun = true;
 781 #endif
 782         delete this;
 783     }
 784 }
 785 
 786 void Document::commonTeardown()
 787 {
<span class="line-added"> 788     stopActiveDOMObjects();</span>
<span class="line-added"> 789 </span>
<span class="line-added"> 790 #if ENABLE(FULLSCREEN_API)</span>
<span class="line-added"> 791     m_fullscreenManager-&gt;emptyEventQueue();</span>
<span class="line-added"> 792 #endif</span>
<span class="line-added"> 793 </span>
 794     if (svgExtensions())
 795         accessSVGExtensions().pauseAnimations();
 796 
 797     clearScriptedAnimationController();
<span class="line-added"> 798 </span>
<span class="line-added"> 799     if (m_highlightMap)</span>
<span class="line-added"> 800         m_highlightMap-&gt;clear();</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802     m_pendingScrollEventTargetList = nullptr;</span>
 803 }
 804 
 805 Element* Document::elementForAccessKey(const String&amp; key)
 806 {
 807     if (key.isEmpty())
 808         return nullptr;
 809     if (!m_accessKeyCache)
 810         buildAccessKeyCache();
 811     return m_accessKeyCache-&gt;get(key);
 812 }
 813 
 814 void Document::buildAccessKeyCache()
 815 {
 816     m_accessKeyCache = makeUnique&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt;([this] {
 817         HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt; map;
 818         for (auto&amp; node : composedTreeDescendants(*this)) {
 819             if (!is&lt;Element&gt;(node))
 820                 continue;
 821             auto&amp; element = downcast&lt;Element&gt;(node);
 822             auto&amp; key = element.attributeWithoutSynchronization(accesskeyAttr);
</pre>
<hr />
<pre>
1165 #endif
1166 
1167     if (element)
1168         m_sawElementsInKnownNamespaces = true;
1169     else
1170         element = Element::create(name, document());
1171 
1172     // &lt;image&gt; uses imgTag so we need a special rule.
1173     ASSERT((name.matches(imageTag) &amp;&amp; element-&gt;tagQName().matches(imgTag) &amp;&amp; element-&gt;tagQName().prefix() == name.prefix()) || name == element-&gt;tagQName());
1174 
1175     return element.releaseNonNull();
1176 }
1177 
1178 // https://html.spec.whatwg.org/#valid-custom-element-name
1179 
1180 struct UnicodeCodePointRange {
1181     UChar32 minimum;
1182     UChar32 maximum;
1183 };
1184 
<span class="line-modified">1185 #if ASSERT_ENABLED</span>
1186 
1187 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, const UnicodeCodePointRange&amp; b)
1188 {
1189     ASSERT(a.minimum &lt;= a.maximum);
1190     ASSERT(b.minimum &lt;= b.maximum);
1191     return a.maximum &lt; b.minimum;
1192 }
1193 
<span class="line-modified">1194 #endif // ASSERT_ENABLED</span>
1195 
1196 static inline bool operator&lt;(const UnicodeCodePointRange&amp; a, UChar32 b)
1197 {
1198     ASSERT(a.minimum &lt;= a.maximum);
1199     return a.maximum &lt; b;
1200 }
1201 
1202 static inline bool operator&lt;(UChar32 a, const UnicodeCodePointRange&amp; b)
1203 {
1204     ASSERT(b.minimum &lt;= b.maximum);
1205     return a &lt; b.minimum;
1206 }
1207 
1208 static inline bool isPotentialCustomElementNameCharacter(UChar32 character)
1209 {
1210     static const UnicodeCodePointRange ranges[] = {
1211         { &#39;-&#39;, &#39;.&#39; },
1212         { &#39;0&#39;, &#39;9&#39; },
1213         { &#39;_&#39;, &#39;_&#39; },
1214         { &#39;a&#39;, &#39;z&#39; },
</pre>
<hr />
<pre>
1622         updateTitle({ });
1623         return;
1624     }
1625 
1626     if (is&lt;HTMLTitleElement&gt;(*m_titleElement))
1627         updateTitle(downcast&lt;HTMLTitleElement&gt;(*m_titleElement).textWithDirection());
1628     else if (is&lt;SVGTitleElement&gt;(*m_titleElement)) {
1629         // FIXME: Does the SVG title element have a text direction?
1630         updateTitle({ downcast&lt;SVGTitleElement&gt;(*m_titleElement).textContent(), TextDirection::LTR });
1631     }
1632 }
1633 
1634 void Document::setTitle(const String&amp; title)
1635 {
1636     auto* element = documentElement();
1637     if (is&lt;SVGSVGElement&gt;(element)) {
1638         if (!m_titleElement) {
1639             m_titleElement = SVGTitleElement::create(SVGNames::titleTag, *this);
1640             element-&gt;insertBefore(*m_titleElement, element-&gt;firstChild());
1641         }
<span class="line-modified">1642         // insertBefore above may have ran scripts which removed m_titleElement.</span>
<span class="line-added">1643         if (m_titleElement)</span>
<span class="line-added">1644             m_titleElement-&gt;setTextContent(title);</span>
1645     } else if (is&lt;HTMLElement&gt;(element)) {
1646         if (!m_titleElement) {
1647             auto* headElement = head();
1648             if (!headElement)
1649                 return;
1650             m_titleElement = HTMLTitleElement::create(HTMLNames::titleTag, *this);
1651             headElement-&gt;appendChild(*m_titleElement);
1652         }
<span class="line-modified">1653         // appendChild above may have ran scripts which removed m_titleElement.</span>
<span class="line-added">1654         if (m_titleElement)</span>
<span class="line-added">1655             m_titleElement-&gt;setTextContent(title);</span>
1656     }
1657 }
1658 
1659 template&lt;typename&gt; struct TitleTraits;
1660 
1661 template&lt;&gt; struct TitleTraits&lt;HTMLTitleElement&gt; {
1662     static bool isInEligibleLocation(HTMLTitleElement&amp; element) { return element.isConnected() &amp;&amp; !element.isInShadowTree(); }
1663     static HTMLTitleElement* findTitleElement(Document&amp; document) { return descendantsOfType&lt;HTMLTitleElement&gt;(document).first(); }
1664 };
1665 
1666 template&lt;&gt; struct TitleTraits&lt;SVGTitleElement&gt; {
1667     static bool isInEligibleLocation(SVGTitleElement&amp; element) { return element.parentNode() == element.document().documentElement(); }
1668     static SVGTitleElement* findTitleElement(Document&amp; document) { return childrenOfType&lt;SVGTitleElement&gt;(*document.documentElement()).first(); }
1669 };
1670 
1671 template&lt;typename TitleElement&gt; Element* selectNewTitleElement(Document&amp; document, Element* oldTitleElement, Element&amp; changingTitleElement)
1672 {
1673     using Traits = TitleTraits&lt;TitleElement&gt;;
1674 
1675     if (!is&lt;TitleElement&gt;(changingTitleElement)) {
</pre>
<hr />
<pre>
1720 void Document::titleElementTextChanged(Element&amp; titleElement)
1721 {
1722     if (m_titleElement != &amp;titleElement)
1723         return;
1724 
1725     updateTitleFromTitleElement();
1726 }
1727 
1728 void Document::registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1729 {
1730     m_visibilityStateCallbackClients.add(&amp;client);
1731 }
1732 
1733 void Document::unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp; client)
1734 {
1735     m_visibilityStateCallbackClients.remove(&amp;client);
1736 }
1737 
1738 void Document::visibilityStateChanged()
1739 {
<span class="line-modified">1740     // // https://w3c.github.io/page-visibility/#reacting-to-visibilitychange-changes</span>
<span class="line-added">1741     queueTaskToDispatchEvent(TaskSource::UserInteraction, Event::create(eventNames().visibilitychangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
1742     for (auto* client : m_visibilityStateCallbackClients)
1743         client-&gt;visibilityStateChanged();
1744 
<span class="line-modified">1745 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">1746     if (auto* page = this-&gt;page())</span>
<span class="line-added">1747         RealtimeMediaSourceCenter::singleton().setCapturePageState(hidden(), page-&gt;isMediaCaptureMuted());</span>
<span class="line-added">1748 #endif</span>
1749 }
1750 
1751 VisibilityState Document::visibilityState() const
1752 {
1753     // The visibility of the document is inherited from the visibility of the
1754     // page. If there is no page associated with the document, we will assume
1755     // that the page is hidden, as specified by the spec:
1756     // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#dom-document-hidden
1757     if (!m_frame || !m_frame-&gt;page())
1758         return VisibilityState::Hidden;
1759     return m_frame-&gt;page()-&gt;visibilityState();
1760 }
1761 
1762 bool Document::hidden() const
1763 {
1764     return visibilityState() != VisibilityState::Visible;
1765 }
1766 
1767 #if ENABLE(VIDEO)
1768 
<span class="line-modified">1769 void Document::registerMediaElement(HTMLMediaElement&amp; element)</span>
1770 {
<span class="line-modified">1771     m_mediaElements.add(&amp;element);</span>
1772 }
1773 
<span class="line-modified">1774 void Document::unregisterMediaElement(HTMLMediaElement&amp; element)</span>
1775 {
<span class="line-modified">1776     m_mediaElements.remove(&amp;element);</span>
1777 }
1778 
<span class="line-modified">1779 void Document::forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp; function)</span>
1780 {
<span class="line-modified">1781     Vector&lt;Ref&lt;HTMLMediaElement&gt;&gt; elements;</span>
<span class="line-modified">1782     for (auto* element : m_mediaElements)</span>
<span class="line-added">1783         elements.append(*element);</span>
<span class="line-added">1784     for (auto&amp; element : elements)</span>
<span class="line-added">1785         function(element);</span>
1786 }
1787 
1788 void Document::stopAllMediaPlayback()
1789 {
1790     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1791         platformMediaSessionManager-&gt;stopAllMediaPlaybackForDocument(*this);
1792 }
1793 
1794 void Document::suspendAllMediaPlayback()
1795 {
1796     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1797         platformMediaSessionManager-&gt;suspendAllMediaPlaybackForDocument(*this);
1798 }
1799 
1800 void Document::resumeAllMediaPlayback()
1801 {
1802     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1803         platformMediaSessionManager-&gt;resumeAllMediaPlaybackForDocument(*this);
1804 }
1805 
1806 void Document::suspendAllMediaBuffering()
1807 {
1808     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1809         platformMediaSessionManager-&gt;suspendAllMediaBufferingForDocument(*this);
1810 }
1811 
1812 void Document::resumeAllMediaBuffering()
1813 {
1814     if (auto* platformMediaSessionManager = PlatformMediaSessionManager::sharedManagerIfExists())
1815         platformMediaSessionManager-&gt;resumeAllMediaBufferingForDocument(*this);
1816 }
<span class="line-added">1817 </span>
1818 #endif
1819 
1820 String Document::nodeName() const
1821 {
1822     return &quot;#document&quot;_s;
1823 }
1824 
1825 Node::NodeType Document::nodeType() const
1826 {
1827     return DOCUMENT_NODE;
1828 }
1829 
1830 FormController&amp; Document::formController()
1831 {
1832     if (!m_formController)
1833         m_formController = makeUnique&lt;FormController&gt;();
1834     return *m_formController;
1835 }
1836 
1837 Vector&lt;String&gt; Document::formElementsState() const
</pre>
<hr />
<pre>
1866 Ref&lt;NodeIterator&gt; Document::createNodeIterator(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1867 {
1868     return NodeIterator::create(root, whatToShow, WTFMove(filter));
1869 }
1870 
1871 Ref&lt;TreeWalker&gt; Document::createTreeWalker(Node&amp; root, unsigned long whatToShow, RefPtr&lt;NodeFilter&gt;&amp;&amp; filter, bool)
1872 {
1873     return TreeWalker::create(root, whatToShow, WTFMove(filter));
1874 }
1875 
1876 void Document::scheduleFullStyleRebuild()
1877 {
1878     m_needsFullStyleRebuild = true;
1879     scheduleStyleRecalc();
1880 }
1881 
1882 void Document::scheduleStyleRecalc()
1883 {
1884     ASSERT(!m_renderView || !inHitTesting());
1885 
<span class="line-modified">1886     if (m_styleRecalcTimer.isActive() || backForwardCacheState() != NotInBackForwardCache)</span>
1887         return;
1888 
1889     ASSERT(childNeedsStyleRecalc() || m_needsFullStyleRebuild);
1890     auto shouldThrottleStyleRecalc = [&amp;] {
1891         if (!view() || !view()-&gt;isVisuallyNonEmpty())
1892             return false;
1893         if (!page() || !page()-&gt;chrome().client().layerFlushThrottlingIsActive())
1894             return false;
1895         return true;
1896     };
1897 
1898     if (shouldThrottleStyleRecalc())
1899         return;
1900 
1901     m_styleRecalcTimer.startOneShot(0_s);
1902 
1903     InspectorInstrumentation::didScheduleStyleRecalculation(*this);
1904 }
1905 
1906 void Document::unscheduleStyleRecalc()
</pre>
<hr />
<pre>
1943     AnimationUpdateBlock animationUpdateBlock(&amp;m_frame-&gt;animation());
1944 
1945     // FIXME: Do this update per tree scope.
1946     {
1947         auto elements = copyToVectorOf&lt;RefPtr&lt;SVGUseElement&gt;&gt;(m_svgUseElements);
1948         // We can&#39;t clear m_svgUseElements here because updateShadowTree may end up executing arbitrary scripts
1949         // which may insert new SVG use elements or remove existing ones inside sync IPC via ImageLoader::updateFromElement.
1950         for (auto&amp; element : elements)
1951             element-&gt;updateShadowTree();
1952     }
1953 
1954     // FIXME: We should update style on our ancestor chain before proceeding, however doing so at
1955     // the time this comment was originally written caused several tests to crash.
1956 
1957     {
1958         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1959         styleScope().flushPendingUpdate();
1960         frameView.willRecalcStyle();
1961     }
1962 
<span class="line-modified">1963     InspectorInstrumentation::willRecalculateStyle(*this);</span>
1964 
1965     bool updatedCompositingLayers = false;
1966     {
1967         Style::PostResolutionCallbackDisabler disabler(*this);
1968         WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
1969         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
1970 
1971         m_inStyleRecalc = true;
1972 
1973         if (m_needsFullStyleRebuild)
1974             type = ResolveStyleType::Rebuild;
1975 
1976         if (type == ResolveStyleType::Rebuild) {
1977             // This may get set again during style resolve.
1978             m_hasNodesWithNonFinalStyle = false;
1979             m_hasNodesWithMissingStyle = false;
1980 
1981             auto documentStyle = Style::resolveForDocument(*this);
1982 
1983             // Inserting the pictograph font at the end of the font fallback list is done by the
</pre>
<hr />
<pre>
2015 
2016         updatedCompositingLayers = frameView.updateCompositingLayersAfterStyleChange();
2017 
2018         if (m_renderView-&gt;needsLayout())
2019             frameView.layoutContext().scheduleLayout();
2020 
2021         // Usually this is handled by post-layout.
2022         if (!frameView.needsLayout())
2023             frameView.frame().selection().scheduleAppearanceUpdateAfterStyleChange();
2024 
2025         // As a result of the style recalculation, the currently hovered element might have been
2026         // detached (for example, by setting display:none in the :hover style), schedule another mouseMove event
2027         // to check if any other elements ended up under the mouse pointer due to re-layout.
2028         if (m_hoveredElement &amp;&amp; !m_hoveredElement-&gt;renderer())
2029             frameView.frame().mainFrame().eventHandler().dispatchFakeMouseMoveEventSoon();
2030 
2031         ++m_styleRecalcCount;
2032         // FIXME: Assert ASSERT(!needsStyleRecalc()) here. Do we still have some cases where it&#39;s not true?
2033     }
2034 
<span class="line-modified">2035     InspectorInstrumentation::didRecalculateStyle(*this);</span>






2036 
2037     // Some animated images may now be inside the viewport due to style recalc,
2038     // resume them if necessary if there is no layout pending. Otherwise, we&#39;ll
2039     // check if they need to be resumed after layout.
2040     if (updatedCompositingLayers &amp;&amp; !frameView.needsLayout())
2041         frameView.viewportContentsChanged();



2042 }
2043 
2044 void Document::updateTextRenderer(Text&amp; text, unsigned offsetOfReplacedText, unsigned lengthOfReplacedText)
2045 {
2046     ASSERT(!m_inRenderTreeUpdate);
2047     SetForScope&lt;bool&gt; inRenderTreeUpdate(m_inRenderTreeUpdate, true);
2048 
2049     auto textUpdate = makeUnique&lt;Style::Update&gt;(*this);
2050     textUpdate-&gt;addText(text, { offsetOfReplacedText, lengthOfReplacedText, WTF::nullopt });
2051 
2052     RenderTreeUpdater renderTreeUpdater(*this);
2053     renderTreeUpdater.commit(WTFMove(textUpdate));
2054 }
2055 
2056 bool Document::needsStyleRecalc() const
2057 {
<span class="line-modified">2058     if (backForwardCacheState() != NotInBackForwardCache)</span>
2059         return false;
2060 
2061     if (m_needsFullStyleRebuild)
2062         return true;
2063 
2064     if (childNeedsStyleRecalc())
2065         return true;
2066 
2067     if (styleScope().hasPendingUpdate())
2068         return true;
2069 




2070     return false;
2071 }
2072 
2073 static bool isSafeToUpdateStyleOrLayout(const Document&amp; document)
2074 {
2075     bool isSafeToExecuteScript = ScriptDisallowedScope::InMainThread::isScriptAllowed();
2076     auto* frameView = document.view();
2077     bool isInFrameFlattening = frameView &amp;&amp; frameView-&gt;isInChildFrameWithFrameFlattening();
2078     return isSafeToExecuteScript || isInFrameFlattening || !isInWebProcess();
2079 }
2080 
2081 bool Document::updateStyleIfNeeded()
2082 {
2083     RefPtr&lt;FrameView&gt; frameView = view();
2084     {
2085         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2086         ASSERT(isMainThread());
2087         ASSERT(!frameView || !frameView-&gt;isPainting());
2088 
2089         if (!frameView || frameView-&gt;layoutContext().isInRenderTreeLayout())
</pre>
<hr />
<pre>
2145 
2146     if (runPostLayoutTasks == RunPostLayoutTasks::Synchronously &amp;&amp; view())
2147         view()-&gt;flushAnyPendingPostLayoutTasks();
2148 
2149     m_ignorePendingStylesheets = oldIgnore;
2150 }
2151 
2152 std::unique_ptr&lt;RenderStyle&gt; Document::styleForElementIgnoringPendingStylesheets(Element&amp; element, const RenderStyle* parentStyle, PseudoId pseudoElementSpecifier)
2153 {
2154     ASSERT(&amp;element.document() == this);
2155     ASSERT(!element.isPseudoElement() || pseudoElementSpecifier == PseudoId::None);
2156     ASSERT(pseudoElementSpecifier == PseudoId::None || parentStyle);
2157 
2158     // On iOS request delegates called during styleForElement may result in re-entering WebKit and killing the style resolver.
2159     Style::PostResolutionCallbackDisabler disabler(*this, Style::PostResolutionCallbackDisabler::DrainCallbacks::No);
2160 
2161     SetForScope&lt;bool&gt; change(m_ignorePendingStylesheets, true);
2162     auto&amp; resolver = element.styleResolver();
2163 
2164     if (pseudoElementSpecifier != PseudoId::None)
<span class="line-modified">2165         return resolver.pseudoStyleForElement(element, { pseudoElementSpecifier }, *parentStyle);</span>
2166 
2167     auto elementStyle = resolver.styleForElement(element, parentStyle);
2168     if (elementStyle.relations) {
2169         Style::Update emptyUpdate(*this);
2170         Style::commitRelations(WTFMove(elementStyle.relations), emptyUpdate);
2171     }
2172 
2173     return WTFMove(elementStyle.renderStyle);
2174 }
2175 
2176 bool Document::updateLayoutIfDimensionsOutOfDate(Element&amp; element, DimensionsCheck dimensionsCheck)
2177 {
2178     ASSERT(isMainThread());
2179 
2180     // If the stylesheets haven&#39;t loaded, just give up and do a full layout ignoring pending stylesheets.
2181     if (!haveStylesheetsLoaded()) {
2182         updateLayoutIgnorePendingStylesheets();
2183         return true;
2184     }
2185 
</pre>
<hr />
<pre>
2304         auto&amp; size = style-&gt;pageSize();
2305         ASSERT(size.width.isFixed());
2306         ASSERT(size.height.isFixed());
2307         width = valueForLength(size.width, 0);
2308         height = valueForLength(size.height, 0);
2309         break;
2310     }
2311     default:
2312         ASSERT_NOT_REACHED();
2313     }
2314     pageSize = IntSize(width, height);
2315 
2316     // The percentage is calculated with respect to the width even for margin top and bottom.
2317     // http://www.w3.org/TR/CSS2/box.html#margin-properties
2318     marginTop = style-&gt;marginTop().isAuto() ? marginTop : intValueForLength(style-&gt;marginTop(), width);
2319     marginRight = style-&gt;marginRight().isAuto() ? marginRight : intValueForLength(style-&gt;marginRight(), width);
2320     marginBottom = style-&gt;marginBottom().isAuto() ? marginBottom : intValueForLength(style-&gt;marginBottom(), width);
2321     marginLeft = style-&gt;marginLeft().isAuto() ? marginLeft : intValueForLength(style-&gt;marginLeft(), width);
2322 }
2323 
<span class="line-modified">2324 Style::Resolver&amp; Document::userAgentShadowTreeStyleResolver()</span>
2325 {
2326     if (!m_userAgentShadowTreeStyleResolver)
<span class="line-modified">2327         m_userAgentShadowTreeStyleResolver = makeUnique&lt;Style::Resolver&gt;(*this);</span>
2328     return *m_userAgentShadowTreeStyleResolver;
2329 }
2330 
2331 void Document::fontsNeedUpdate(FontSelector&amp;)
2332 {
2333     invalidateMatchedPropertiesCacheAndForceStyleRecalc();
2334 }
2335 
2336 void Document::invalidateMatchedPropertiesCacheAndForceStyleRecalc()
2337 {
<span class="line-modified">2338     styleScope().invalidateMatchedDeclarationsCache();</span>
<span class="line-modified">2339 </span>
<span class="line-modified">2340     if (backForwardCacheState() != NotInBackForwardCache || !renderView())</span>
2341         return;
2342     scheduleFullStyleRebuild();
2343 }
2344 
2345 void Document::didClearStyleResolver()
2346 {
2347     m_userAgentShadowTreeStyleResolver = nullptr;
2348 }
2349 
2350 void Document::setIsResolvingTreeStyle(bool value)
2351 {
2352     RELEASE_ASSERT(value != m_isResolvingTreeStyle);
2353     m_isResolvingTreeStyle = value;
2354 }
2355 
2356 void Document::createRenderTree()
2357 {
2358     ASSERT(!renderView());
<span class="line-modified">2359     ASSERT(m_backForwardCacheState != InBackForwardCache);</span>
2360     ASSERT(!m_axObjectCache || this != &amp;topDocument());
2361 
2362     if (m_isNonRenderedPlaceholder)
2363         return;
2364 
2365     // FIXME: It would be better if we could pass the resolved document style directly here.
2366     m_renderView = createRenderer&lt;RenderView&gt;(*this, RenderStyle::create());
2367     Node::setRenderer(m_renderView.get());
2368 
2369     renderView()-&gt;setIsInWindow(true);
2370 
2371     resolveStyle(ResolveStyleType::Rebuild);
2372 }
2373 
2374 void Document::didBecomeCurrentDocumentInFrame()
2375 {
2376     // FIXME: Are there cases where the document can be dislodged from the frame during the event handling below?
2377     // If so, then m_frame could become 0, and we need to do something about that.
2378 
2379     m_frame-&gt;script().updateDocument();
2380 
2381     if (!hasLivingRenderTree())
2382         createRenderTree();
2383 
2384     dispatchDisabledAdaptationsDidChangeForMainFrame();
2385     updateViewportArguments();
2386 
2387     // FIXME: Doing this only for the main frame is insufficient.
2388     // Changing a subframe can also change the wheel event handler count.
2389     // FIXME: Doing this only when a document goes into the frame is insufficient.
2390     // Removing a document can also change the wheel event handler count.
2391     // FIXME: Doing this every time is a waste. If the current document and its
2392     // subframes&#39; documents have no wheel event handlers, then the count did not change,
2393     // unless the documents they are replacing had wheel event handlers.
2394     if (page() &amp;&amp; m_frame-&gt;isMainFrame())
2395         wheelEventHandlersChanged();
2396 
2397     // Ensure that the scheduled task state of the document matches the DOM suspension state of the frame. It can
2398     // be out of sync if the DOM suspension state changed while the document was not in the frame (possibly in the
<span class="line-modified">2399     // back/forward cache, or simply newly created).</span>
2400     if (m_frame-&gt;activeDOMObjectsAndAnimationsSuspended()) {
2401         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2402             if (auto* timeline = existingTimeline())
2403                 timeline-&gt;suspendAnimations();
2404         } else
2405             m_frame-&gt;animation().suspendAnimationsForDocument(this);
2406         suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2407     } else {
2408         resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
2409         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2410             if (auto* timeline = existingTimeline())
2411                 timeline-&gt;resumeAnimations();
2412         } else
2413             m_frame-&gt;animation().resumeAnimationsForDocument(this);
2414     }
2415 }
2416 
2417 void Document::frameDestroyed()
2418 {
2419     // detachFromFrame() must be called before destroying the Frame.
</pre>
<hr />
<pre>
2422     if (auto* window = domWindow())
2423         window-&gt;frameDestroyed();
2424 
2425     FrameDestructionObserver::frameDestroyed();
2426 }
2427 
2428 void Document::willDetachPage()
2429 {
2430     FrameDestructionObserver::willDetachPage();
2431 #if PLATFORM(IOS_FAMILY)
2432     contentChangeObserver().willDetachPage();
2433 #endif
2434     if (domWindow() &amp;&amp; frame())
2435         InspectorInstrumentation::frameWindowDiscarded(*frame(), domWindow());
2436 }
2437 
2438 void Document::attachToCachedFrame(CachedFrameBase&amp; cachedFrame)
2439 {
2440     RELEASE_ASSERT(cachedFrame.document() == this);
2441     ASSERT(cachedFrame.view());
<span class="line-modified">2442     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);</span>
2443     observeFrame(&amp;cachedFrame.view()-&gt;frame());
2444 }
2445 
2446 void Document::detachFromCachedFrame(CachedFrameBase&amp; cachedFrame)
2447 {
2448     ASSERT_UNUSED(cachedFrame, cachedFrame.view());
2449     RELEASE_ASSERT(cachedFrame.document() == this);
2450     ASSERT(m_frame == &amp;cachedFrame.view()-&gt;frame());
<span class="line-modified">2451     ASSERT(m_backForwardCacheState == Document::InBackForwardCache);</span>
2452     detachFromFrame();
2453 }
2454 
2455 void Document::destroyRenderTree()
2456 {
2457     ASSERT(hasLivingRenderTree());
2458     ASSERT(frame());
2459     ASSERT(frame()-&gt;document() == this);
2460     ASSERT(page());
2461 
2462     // Prevent Widget tree changes from committing until the RenderView is dead and gone.
2463     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
2464 
2465     SetForScope&lt;bool&gt; change(m_renderTreeBeingDestroyed, true);
2466 
2467     if (this == &amp;topDocument())
2468         clearAXObjectCache();
2469 
2470     documentWillBecomeInactive();
2471 
</pre>
<hr />
<pre>
2509 
2510 #if USE(LIBWEBRTC)
2511     // FIXME: This should be moved to Modules/mediastream.
2512     if (LibWebRTCProvider::webRTCAvailable()) {
2513         if (auto* page = this-&gt;page())
2514             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
2515     }
2516 #endif
2517 
2518 #if ENABLE(SERVICE_WORKER)
2519     setActiveServiceWorker(nullptr);
2520     setServiceWorkerConnection(nullptr);
2521 #endif
2522 
2523 #if ENABLE(IOS_TOUCH_EVENTS)
2524     clearTouchEventHandlersAndListeners();
2525 #endif
2526 
2527     m_undoManager-&gt;removeAllItems();
2528 
<span class="line-added">2529     m_textManipulationController = nullptr; // Free nodes kept alive by TextManipulationController.</span>
<span class="line-added">2530 </span>
2531 #if ENABLE(ACCESSIBILITY)
2532     if (this != &amp;topDocument()) {
2533         // Let the ax cache know that this subframe goes out of scope.
2534         if (auto* cache = existingAXObjectCache())
2535             cache-&gt;prepareForDocumentDestruction(*this);
2536     }
2537 #endif
2538 
2539     {
2540         NavigationDisabler navigationDisabler(m_frame);
2541         disconnectDescendantFrames();
2542     }
2543     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!m_frame || !m_frame-&gt;tree().childCount());
2544 
2545     if (m_domWindow &amp;&amp; m_frame)
2546         m_domWindow-&gt;willDetachDocumentFromFrame();
2547 
2548     styleScope().clearResolver();
2549 
2550     if (hasLivingRenderTree())
2551         destroyRenderTree();
2552 
2553     if (is&lt;PluginDocument&gt;(*this))
2554         downcast&lt;PluginDocument&gt;(*this).detachFromPluginElement();
2555 
2556 #if ENABLE(POINTER_LOCK)
2557     if (page())
2558         page()-&gt;pointerLockController().documentDetached(*this);
2559 #endif
2560 
2561     if (auto* page = this-&gt;page()) {
2562         if (auto* validationMessageClient = page-&gt;validationMessageClient())
2563             validationMessageClient-&gt;documentDetached(*this);
2564     }
2565 
2566     InspectorInstrumentation::documentDetached(*this);
2567 






2568     commonTeardown();
2569 
2570 #if ENABLE(TOUCH_EVENTS)
2571     if (m_touchEventTargets &amp;&amp; m_touchEventTargets-&gt;size() &amp;&amp; parentDocument())
2572         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2573 #endif
2574 
2575     if (m_wheelEventTargets &amp;&amp; m_wheelEventTargets-&gt;size() &amp;&amp; parentDocument())
2576         parentDocument()-&gt;didRemoveEventTargetNode(*this);
2577 
2578     if (m_mediaQueryMatcher)
2579         m_mediaQueryMatcher-&gt;documentDestroyed();
2580 
2581 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2582     if (!m_clientToIDMap.isEmpty() &amp;&amp; page()) {
2583         for (auto* client : copyToVector(m_clientToIDMap.keys()))
2584             removePlaybackTargetPickerClient(*client);
2585     }
2586 #endif
2587 
2588     m_cachedResourceLoader-&gt;stopUnusedPreloadsTimer();
2589 
2590     if (page() &amp;&amp; m_mediaState != MediaProducer::IsNotPlaying) {
2591         m_mediaState = MediaProducer::IsNotPlaying;
2592         page()-&gt;updateIsPlayingMedia(HTMLMediaElementInvalidID);
2593     }
2594 
2595     detachFromFrame();
2596 
<span class="line-modified">2597     while (!m_timelines.computesEmpty())</span>
<span class="line-modified">2598         m_timelines.begin()-&gt;detachFromDocument();</span>
<span class="line-modified">2599     m_timeline = nullptr;</span>

2600 
2601 #if ENABLE(CSS_PAINTING_API)
2602     for (auto&amp; scope : m_paintWorkletGlobalScopes.values())
2603         scope-&gt;prepareForDestruction();
2604     m_paintWorkletGlobalScopes.clear();
2605 #endif
2606 
2607     m_hasPreparedForDestruction = true;
2608 
<span class="line-modified">2609     // Note that m_backForwardCacheState can be Document::AboutToEnterBackForwardCache if our frame</span>
2610     // was removed in an onpagehide event handler fired when the top-level frame is
<span class="line-modified">2611     // about to enter the back/forward cache.</span>
<span class="line-modified">2612     RELEASE_ASSERT(m_backForwardCacheState != Document::InBackForwardCache);</span>
2613 }
2614 
2615 void Document::removeAllEventListeners()
2616 {
2617     EventTarget::removeAllEventListeners();
2618 
2619     if (m_domWindow)
2620         m_domWindow-&gt;removeAllEventListeners();
2621 
2622 #if ENABLE(IOS_TOUCH_EVENTS)
2623     clearTouchEventHandlersAndListeners();
2624 #endif
2625     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
2626         node-&gt;removeAllEventListeners();
2627 
2628 #if ENABLE(TOUCH_EVENTS)
2629     m_touchEventTargets = nullptr;
2630 #endif
2631     m_wheelEventTargets = nullptr;
2632 }
</pre>
<hr />
<pre>
2643         m_deviceOrientationController-&gt;suspendUpdates();
2644 #endif
2645 }
2646 
2647 void Document::resumeDeviceMotionAndOrientationUpdates()
2648 {
2649     if (!m_areDeviceMotionAndOrientationUpdatesSuspended)
2650         return;
2651     m_areDeviceMotionAndOrientationUpdatesSuspended = false;
2652 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
2653     if (m_deviceMotionController)
2654         m_deviceMotionController-&gt;resumeUpdates();
2655     if (m_deviceOrientationController)
2656         m_deviceOrientationController-&gt;resumeUpdates();
2657 #endif
2658 }
2659 
2660 bool Document::shouldBypassMainWorldContentSecurityPolicy() const
2661 {
2662     // Bypass this policy when the world is known, and it not the normal world.
<span class="line-modified">2663     JSC::VM&amp; vm = commonVM();</span>
<span class="line-modified">2664     auto&amp; callFrame = *vm.topCallFrame;</span>
<span class="line-added">2665     return &amp;callFrame != JSC::CallFrame::noCaller() &amp;&amp; !currentWorld(*callFrame.lexicalGlobalObject(vm)).isNormal();</span>
2666 }
2667 
2668 void Document::platformSuspendOrStopActiveDOMObjects()
2669 {
2670 #if PLATFORM(IOS_FAMILY)
2671     contentChangeObserver().didSuspendActiveDOMObjects();
2672 #endif
2673 }
2674 
2675 void Document::suspendActiveDOMObjects(ReasonForSuspension why)
2676 {
<span class="line-added">2677     if (m_documentTaskGroup)</span>
<span class="line-added">2678         m_documentTaskGroup-&gt;suspend();</span>
2679     ScriptExecutionContext::suspendActiveDOMObjects(why);
2680     suspendDeviceMotionAndOrientationUpdates();
2681     platformSuspendOrStopActiveDOMObjects();
2682 }
2683 
2684 void Document::resumeActiveDOMObjects(ReasonForSuspension why)
2685 {
<span class="line-added">2686     if (m_documentTaskGroup)</span>
<span class="line-added">2687         m_documentTaskGroup-&gt;resume();</span>
2688     ScriptExecutionContext::resumeActiveDOMObjects(why);
2689     resumeDeviceMotionAndOrientationUpdates();
2690     // FIXME: For iOS, do we need to add content change observers that were removed in Document::suspendActiveDOMObjects()?
2691 }
2692 
2693 void Document::stopActiveDOMObjects()
2694 {
<span class="line-added">2695     if (m_documentTaskGroup)</span>
<span class="line-added">2696         m_documentTaskGroup-&gt;stopAndDiscardAllTasks();</span>
2697     ScriptExecutionContext::stopActiveDOMObjects();
2698     platformSuspendOrStopActiveDOMObjects();
2699 }
2700 
2701 void Document::clearAXObjectCache()
2702 {
2703     ASSERT(&amp;topDocument() == this);
2704     // Clear the cache member variable before calling delete because attempts
2705     // are made to access it during destruction.
2706     m_axObjectCache = nullptr;
2707 }
2708 
2709 AXObjectCache* Document::existingAXObjectCacheSlow() const
2710 {
2711     ASSERT(hasEverCreatedAnAXObjectCache);
2712     return topDocument().m_axObjectCache.get();
2713 }
2714 
2715 AXObjectCache* Document::axObjectCache() const
2716 {
</pre>
<hr />
<pre>
2731     if (!topDocument.m_axObjectCache) {
2732         topDocument.m_axObjectCache = makeUnique&lt;AXObjectCache&gt;(topDocument);
2733         hasEverCreatedAnAXObjectCache = true;
2734     }
2735     return topDocument.m_axObjectCache.get();
2736 }
2737 
2738 void Document::setVisuallyOrdered()
2739 {
2740     m_visuallyOrdered = true;
2741     if (renderView())
2742         renderView()-&gt;mutableStyle().setRTLOrdering(Order::Visual);
2743 }
2744 
2745 Ref&lt;DocumentParser&gt; Document::createParser()
2746 {
2747     // FIXME: this should probably pass the frame instead
2748     return XMLDocumentParser::create(*this, view());
2749 }
2750 
<span class="line-added">2751 HighlightMap&amp; Document::highlightMap()</span>
<span class="line-added">2752 {</span>
<span class="line-added">2753     if (!m_highlightMap)</span>
<span class="line-added">2754         m_highlightMap = HighlightMap::create();</span>
<span class="line-added">2755     return *m_highlightMap;</span>
<span class="line-added">2756 }</span>
<span class="line-added">2757 </span>
<span class="line-added">2758 void Document::updateHighlightPositions()</span>
<span class="line-added">2759 {</span>
<span class="line-added">2760     Vector&lt;WeakPtr&lt;HighlightRangeData&gt;&gt; rangesData;</span>
<span class="line-added">2761     if (m_highlightMap) {</span>
<span class="line-added">2762         for (auto&amp; highlight : m_highlightMap-&gt;map()) {</span>
<span class="line-added">2763             for (auto&amp; rangeData : highlight.value-&gt;rangesData()) {</span>
<span class="line-added">2764                 if (rangeData-&gt;startPosition &amp;&amp; rangeData-&gt;endPosition)</span>
<span class="line-added">2765                     continue;</span>
<span class="line-added">2766                 if (&amp;rangeData-&gt;range-&gt;startContainer()-&gt;treeScope() != &amp;rangeData-&gt;range-&gt;endContainer()-&gt;treeScope())</span>
<span class="line-added">2767                     continue;</span>
<span class="line-added">2768                 rangesData.append(makeWeakPtr(rangeData.ptr()));</span>
<span class="line-added">2769             }</span>
<span class="line-added">2770         }</span>
<span class="line-added">2771     }</span>
<span class="line-added">2772 </span>
<span class="line-added">2773     for (auto&amp; weakRangeData : rangesData) {</span>
<span class="line-added">2774         if (auto* rangeData = weakRangeData.get()) {</span>
<span class="line-added">2775             VisibleSelection visibleSelection(rangeData-&gt;range);</span>
<span class="line-added">2776             Position startPosition;</span>
<span class="line-added">2777             Position endPosition;</span>
<span class="line-added">2778             if (!rangeData-&gt;startPosition.hasValue())</span>
<span class="line-added">2779                 startPosition = visibleSelection.visibleStart().deepEquivalent();</span>
<span class="line-added">2780             if (!rangeData-&gt;endPosition.hasValue())</span>
<span class="line-added">2781                 endPosition = visibleSelection.visibleEnd().deepEquivalent(); // &lt;MMG&gt; switch to END</span>
<span class="line-added">2782             if (!weakRangeData.get())</span>
<span class="line-added">2783                 continue;</span>
<span class="line-added">2784 </span>
<span class="line-added">2785             rangeData-&gt;startPosition = startPosition;</span>
<span class="line-added">2786             rangeData-&gt;endPosition = endPosition;</span>
<span class="line-added">2787         }</span>
<span class="line-added">2788     }</span>
<span class="line-added">2789 }</span>
<span class="line-added">2790 </span>
2791 ScriptableDocumentParser* Document::scriptableDocumentParser() const
2792 {
2793     return parser() ? parser()-&gt;asScriptableDocumentParser() : nullptr;
2794 }
2795 
2796 ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; Document::openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features)
2797 {
2798     if (!m_domWindow)
2799         return Exception { InvalidAccessError };
2800 
2801     return m_domWindow-&gt;open(activeWindow, firstWindow, url, name, features);
2802 }
2803 
2804 ExceptionOr&lt;Document&amp;&gt; Document::openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;)
2805 {
2806     if (!isHTMLDocument() || m_throwOnDynamicMarkupInsertionCount)
2807         return Exception { InvalidStateError };
2808 
2809     auto result = open(responsibleDocument);
2810     if (UNLIKELY(result.hasException()))
2811         return result.releaseException();
2812 
2813     return *this;
2814 }
2815 
2816 ExceptionOr&lt;void&gt; Document::open(Document* responsibleDocument)
2817 {
2818     if (responsibleDocument &amp;&amp; !responsibleDocument-&gt;securityOrigin().isSameOriginAs(securityOrigin()))
2819         return Exception { SecurityError };
2820 
2821     if (m_ignoreOpensDuringUnloadCount)
2822         return { };
2823 
<span class="line-added">2824     if (m_activeParserWasAborted)</span>
<span class="line-added">2825         return { };</span>
<span class="line-added">2826 </span>
2827     if (m_frame) {
2828         if (ScriptableDocumentParser* parser = scriptableDocumentParser()) {
2829             if (parser-&gt;isParsing()) {
2830                 // FIXME: HTML5 doesn&#39;t tell us to check this, it might not be correct.
2831                 if (parser-&gt;isExecutingScript())
2832                     return { };
2833 
2834                 if (!parser-&gt;wasCreatedByScript() &amp;&amp; parser-&gt;hasInsertionPoint())
2835                     return { };
2836             }
2837         }
2838 
2839         if (m_frame-&gt;loader().policyChecker().delegateIsDecidingNavigationPolicy())
2840             m_frame-&gt;loader().policyChecker().stopCheck();
2841         if (m_frame &amp;&amp; m_frame-&gt;loader().state() == FrameStateProvisional)
2842             m_frame-&gt;loader().stopAllLoaders();
2843     }
2844 
2845     removeAllEventListeners();
2846 
</pre>
<hr />
<pre>
2876     if (frame-&gt;isMainFrame())
2877         return true;
2878 
2879     auto* parentFrame = frame-&gt;tree().parent();
2880     return parentFrame &amp;&amp; parentFrame-&gt;document() &amp;&amp; parentFrame-&gt;document()-&gt;isFullyActive();
2881 }
2882 
2883 void Document::detachParser()
2884 {
2885     if (!m_parser)
2886         return;
2887     m_parser-&gt;detach();
2888     m_parser = nullptr;
2889 }
2890 
2891 void Document::cancelParsing()
2892 {
2893     if (!m_parser)
2894         return;
2895 
<span class="line-added">2896     if (m_parser-&gt;processingData())</span>
<span class="line-added">2897         m_activeParserWasAborted = true;</span>
<span class="line-added">2898 </span>
2899     // We have to clear the parser to avoid possibly triggering
2900     // the onload handler when closing as a side effect of a cancel-style
2901     // change, such as opening a new document or closing the window while
2902     // still parsing
2903     detachParser();
2904     explicitClose();
2905 }
2906 
2907 void Document::implicitOpen()
2908 {
2909     removeChildren();
2910 
2911     setCompatibilityMode(DocumentCompatibilityMode::NoQuirksMode);
2912 
<span class="line-modified">2913     detachParser();</span>
2914     m_parser = createParser();
2915 
2916     if (hasActiveParserYieldToken())
2917         m_parser-&gt;didBeginYieldingParser();
2918 
2919     setParsing(true);
2920     setReadyState(Loading);
2921 }
2922 
2923 HTMLBodyElement* Document::body() const
2924 {
2925     auto* element = documentElement();
2926     if (!is&lt;HTMLHtmlElement&gt;(element))
2927         return nullptr;
2928     return childrenOfType&lt;HTMLBodyElement&gt;(*element).first();
2929 }
2930 
2931 HTMLElement* Document::bodyOrFrameset() const
2932 {
2933     // Return the first body or frameset child of the html element.
</pre>
<hr />
<pre>
2992 }
2993 
2994 void Document::explicitClose()
2995 {
2996     if (RefPtr&lt;DocumentParser&gt; parser = m_parser)
2997         parser-&gt;finish();
2998 
2999     if (!m_frame) {
3000         // Because we have no frame, we don&#39;t know if all loading has completed,
3001         // so we just call implicitClose() immediately. FIXME: This might fire
3002         // the load event prematurely &lt;http://bugs.webkit.org/show_bug.cgi?id=14568&gt;.
3003         implicitClose();
3004         return;
3005     }
3006 
3007     checkCompleted();
3008 }
3009 
3010 void Document::implicitClose()
3011 {
<span class="line-modified">3012     RELEASE_ASSERT(!m_inStyleRecalc);</span>





3013     bool wasLocationChangePending = frame() &amp;&amp; frame()-&gt;navigationScheduler().locationChangePending();
3014     bool doload = !parsing() &amp;&amp; m_parser &amp;&amp; !m_processingLoadEvent &amp;&amp; !wasLocationChangePending;
3015 
3016     if (!doload)
3017         return;
3018 
3019     // Call to dispatchWindowLoadEvent can blow us from underneath.
3020     Ref&lt;Document&gt; protectedThis(*this);
3021 
3022     m_processingLoadEvent = true;
3023 
3024     ScriptableDocumentParser* parser = scriptableDocumentParser();
3025     m_wellFormed = parser &amp;&amp; parser-&gt;wellFormed();
3026 
3027     // We have to clear the parser, in case someone document.write()s from the
3028     // onLoad event handler, as in Radar 3206524.
3029     detachParser();
3030 
3031     // FIXME: We kick off the icon loader when the Document is done parsing.
3032     // There are earlier opportunities we could start it:
</pre>
<hr />
<pre>
3038     if (f) {
3039 #if ENABLE(XSLT)
3040         // Apply XSL transforms before load events so that event handlers can access the transformed DOM tree.
3041         applyPendingXSLTransformsNowIfScheduled();
3042 #endif
3043 
3044         if (auto* documentLoader = loader())
3045             documentLoader-&gt;startIconLoading();
3046 
3047         f-&gt;animation().startAnimationsIfNotSuspended(this);
3048 
3049         // FIXME: We shouldn&#39;t be dispatching pending events globally on all Documents here.
3050         // For now, only do this when there is a Frame, otherwise this could cause JS reentrancy
3051         // below SVG font parsing, for example. &lt;https://webkit.org/b/136269&gt;
3052         ImageLoader::dispatchPendingBeforeLoadEvents();
3053         ImageLoader::dispatchPendingLoadEvents();
3054         ImageLoader::dispatchPendingErrorEvents();
3055         HTMLLinkElement::dispatchPendingLoadEvents();
3056         HTMLStyleElement::dispatchPendingLoadEvents();
3057 



3058         if (svgExtensions())
<span class="line-modified">3059             accessSVGExtensions().dispatchLoadEventToOutermostSVGElements();</span>
3060     }
3061 
3062     dispatchWindowLoadEvent();
3063     dispatchPageshowEvent(PageshowEventNotPersisted);
3064     if (m_pendingStateObject)
3065         dispatchPopstateEvent(WTFMove(m_pendingStateObject));
3066 
3067     if (f)
3068         f-&gt;loader().dispatchOnloadEvents();
3069 
3070     // An event handler may have removed the frame
3071     if (!frame()) {
3072         m_processingLoadEvent = false;
3073         return;
3074     }
3075 
3076     // Make sure both the initial layout and reflow happen after the onload
3077     // fires. This will improve onload scores, and other browsers do it.
3078     // If they wanna cheat, we can too. -dwh
3079 
</pre>
<hr />
<pre>
3084         view()-&gt;layoutContext().unscheduleLayout();
3085         return;
3086     }
3087 
3088     frame()-&gt;loader().checkCallImplicitClose();
3089 
3090     // We used to force a synchronous display and flush here.  This really isn&#39;t
3091     // necessary and can in fact be actively harmful if pages are loading at a rate of &gt; 60fps
3092     // (if your platform is syncing flushes and limiting them to 60fps).
3093     m_overMinimumLayoutThreshold = true;
3094     if (!ownerElement() || (ownerElement()-&gt;renderer() &amp;&amp; !ownerElement()-&gt;renderer()-&gt;needsLayout())) {
3095         updateStyleIfNeeded();
3096 
3097         // Always do a layout after loading if needed.
3098         if (view() &amp;&amp; renderView() &amp;&amp; (!renderView()-&gt;firstChild() || renderView()-&gt;needsLayout()))
3099             view()-&gt;layoutContext().layout();
3100     }
3101 
3102     m_processingLoadEvent = false;
3103 
<span class="line-modified">3104     if (auto fontFaceSet = makeRefPtr(fontSelector().fontFaceSetIfExists()))</span>
<span class="line-modified">3105         fontFaceSet-&gt;documentDidFinishLoading();</span>
3106 
3107 #if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
3108     if (f &amp;&amp; hasLivingRenderTree() &amp;&amp; AXObjectCache::accessibilityEnabled()) {
3109         // The AX cache may have been cleared at this point, but we need to make sure it contains an
3110         // AX object to send the notification to. getOrCreate will make sure that an valid AX object
3111         // exists in the cache (we ignore the return value because we don&#39;t need it here). This is
3112         // only safe to call when a layout is not in progress, so it can not be used in postNotification.
3113         //
3114         // This notification is now called AXNewDocumentLoadComplete because there are other handlers that will
3115         // catch new AND page history loads, and that uses AXLoadComplete
3116 
3117         axObjectCache()-&gt;getOrCreate(renderView());
3118         if (this == &amp;topDocument())
3119             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXNewDocumentLoadComplete);
3120         else {
3121             // AXLoadComplete can only be posted on the top document, so if it&#39;s a document
3122             // in an iframe that just finished loading, post AXLayoutComplete instead.
3123             axObjectCache()-&gt;postNotification(renderView(), AXObjectCache::AXLayoutComplete);
3124         }
3125     }
</pre>
<hr />
<pre>
3163 
3164 Seconds Document::minimumLayoutDelay()
3165 {
3166     if (m_overMinimumLayoutThreshold)
3167         return 0_s;
3168 
3169     auto elapsed = timeSinceDocumentCreation();
3170     m_overMinimumLayoutThreshold = elapsed &gt; settings().layoutInterval();
3171 
3172     // We&#39;ll want to schedule the timer to fire at the minimum layout threshold.
3173     return std::max(0_s, settings().layoutInterval() - elapsed);
3174 }
3175 
3176 Seconds Document::timeSinceDocumentCreation() const
3177 {
3178     return MonotonicTime::now() - m_documentCreationTime;
3179 }
3180 
3181 ExceptionOr&lt;void&gt; Document::write(Document* responsibleDocument, SegmentedString&amp;&amp; text)
3182 {
<span class="line-added">3183     if (m_activeParserWasAborted)</span>
<span class="line-added">3184         return { };</span>
<span class="line-added">3185 </span>
3186     NestingLevelIncrementer nestingLevelIncrementer(m_writeRecursionDepth);
3187 
3188     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; 1) &amp;&amp; m_writeRecursionIsTooDeep;
3189     m_writeRecursionIsTooDeep = (m_writeRecursionDepth &gt; cMaxWriteRecursionDepth) || m_writeRecursionIsTooDeep;
3190 
3191     if (m_writeRecursionIsTooDeep)
3192         return { };
3193 
3194     bool hasInsertionPoint = m_parser &amp;&amp; m_parser-&gt;hasInsertionPoint();
3195     if (!hasInsertionPoint &amp;&amp; (m_ignoreOpensDuringUnloadCount || m_ignoreDestructiveWriteCount))
3196         return { };
3197 
3198     if (!hasInsertionPoint) {
3199         auto result = open(responsibleDocument);
3200         if (UNLIKELY(result.hasException()))
3201             return result.releaseException();
3202     }
3203 
3204     ASSERT(m_parser);
3205     m_parser-&gt;insert(WTFMove(text));
</pre>
<hr />
<pre>
3267     return alignmentInterval;
3268 }
3269 
3270 EventTarget* Document::errorEventTarget()
3271 {
3272     return m_domWindow.get();
3273 }
3274 
3275 void Document::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)
3276 {
3277     addMessage(MessageSource::JS, MessageLevel::Error, errorMessage, sourceURL, lineNumber, columnNumber, WTFMove(callStack));
3278 }
3279 
3280 void Document::setURL(const URL&amp; url)
3281 {
3282     const URL&amp; newURL = url.isEmpty() ? WTF::blankURL() : url;
3283     if (newURL == m_url)
3284         return;
3285 
3286     m_url = newURL;
<span class="line-added">3287     if (SecurityOrigin::shouldIgnoreHost(m_url))</span>
<span class="line-added">3288         m_url.removeHostAndPort();</span>
<span class="line-added">3289 </span>
3290     m_documentURI = m_url.string();
3291     updateBaseURL();
3292 }
3293 
3294 void Document::updateBaseURL()
3295 {
3296     URL oldBaseURL = m_baseURL;
3297     // DOM 3 Core: When the Document supports the feature &quot;HTML&quot; [DOM Level 2 HTML], the base URI is computed using
3298     // first the value of the href attribute of the HTML BASE element if any, and the value of the documentURI attribute
3299     // from the Document interface otherwise.
3300     if (!m_baseElementURL.isEmpty())
3301         m_baseURL = m_baseElementURL;
3302     else if (!m_baseURLOverride.isEmpty())
3303         m_baseURL = m_baseURLOverride;
3304     else {
3305         // The documentURI attribute is read-only from JavaScript, but writable from Objective C, so we need to retain
3306         // this fallback behavior. We use a null base URL, since the documentURI attribute is an arbitrary string
3307         // and DOM 3 Core does not specify how it should be resolved.
3308         m_baseURL = URL({ }, documentURI());
3309     }
</pre>
<hr />
<pre>
3336             }
3337         }
3338         if (!target) {
3339             const AtomString&amp; value = base.attributeWithoutSynchronization(targetAttr);
3340             if (!value.isNull()) {
3341                 target = &amp;value;
3342                 if (href)
3343                     break;
3344             }
3345         }
3346     }
3347 
3348     // FIXME: Since this doesn&#39;t share code with completeURL it may not handle encodings correctly.
3349     URL baseElementURL;
3350     if (href) {
3351         String strippedHref = stripLeadingAndTrailingHTMLSpaces(*href);
3352         if (!strippedHref.isEmpty())
3353             baseElementURL = URL(url(), strippedHref);
3354     }
3355     if (m_baseElementURL != baseElementURL &amp;&amp; contentSecurityPolicy()-&gt;allowBaseURI(baseElementURL)) {
<span class="line-modified">3356         if (settings().shouldRestrictBaseURLSchemes() &amp;&amp; !SecurityPolicy::isBaseURLSchemeAllowed(baseElementURL))</span>
<span class="line-modified">3357             addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked setting &quot; + baseElementURL.stringCenterEllipsizedToLength() + &quot; as the base URL because it does not have an allowed scheme.&quot;);</span>
<span class="line-added">3358         else {</span>
<span class="line-added">3359             m_baseElementURL = baseElementURL;</span>
<span class="line-added">3360             updateBaseURL();</span>
<span class="line-added">3361         }</span>
3362     }
3363 
3364     m_baseTarget = target ? *target : nullAtom();
3365 }
3366 
3367 String Document::userAgent(const URL&amp; url) const
3368 {
3369     return frame() ? frame()-&gt;loader().userAgent(url) : String();
3370 }
3371 
3372 void Document::disableEval(const String&amp; errorMessage)
3373 {
3374     if (!frame())
3375         return;
3376 
3377     frame()-&gt;script().disableEval(errorMessage);
3378 }
3379 
3380 void Document::disableWebAssembly(const String&amp; errorMessage)
3381 {
</pre>
<hr />
<pre>
3401 SocketProvider* Document::socketProvider()
3402 {
3403     return m_socketProvider.get();
3404 }
3405 
3406 bool Document::canNavigate(Frame* targetFrame, const URL&amp; destinationURL)
3407 {
3408     if (!m_frame)
3409         return false;
3410 
3411     // FIXME: We shouldn&#39;t call this function without a target frame, but
3412     // fast/forms/submit-to-blank-multiple-times.html depends on this function
3413     // returning true when supplied with a 0 targetFrame.
3414     if (!targetFrame)
3415         return true;
3416 
3417     if (!canNavigateInternal(*targetFrame))
3418         return false;
3419 
3420     if (isNavigationBlockedByThirdPartyIFrameRedirectBlocking(*targetFrame, destinationURL)) {
<span class="line-modified">3421         printNavigationErrorMessage(*targetFrame, url(), &quot;The frame attempting navigation of the top-level window is cross-origin or untrusted and the user has never interacted with the frame.&quot;_s);</span>
3422         return false;
3423     }
3424 
3425     return true;
3426 }
3427 
3428 bool Document::canNavigateInternal(Frame&amp; targetFrame)
3429 {
3430     ASSERT(m_frame);
3431 
3432     // Cases (i), (ii) and (iii) pass the tests from the specifications but might not pass the &quot;security origin&quot; tests.
3433 
3434     // i. A frame can navigate its top ancestor when its &#39;allow-top-navigation&#39; flag is set (sometimes known as &#39;frame-busting&#39;).
3435     if (!isSandboxed(SandboxTopNavigation) &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3436         return true;
3437 
3438     // ii. A frame can navigate its top ancestor when its &#39;allow-top-navigation-by-user-activation&#39; flag is set and navigation is triggered by user activation.
3439     if (!isSandboxed(SandboxTopNavigationByUserActivation) &amp;&amp; UserGestureIndicator::processingUserGesture() &amp;&amp; &amp;targetFrame == &amp;m_frame-&gt;tree().top())
3440         return true;
3441 
</pre>
<hr />
<pre>
3491     // Specifically, a document can navigate a top-level frame if that frame
3492     // opened the document or if the document is the same-origin with any of
3493     // the top-level frame&#39;s opener&#39;s ancestors (in the frame hierarchy).
3494     //
3495     // In both of these cases, the document performing the navigation is in
3496     // some way related to the frame being navigate (e.g., by the &quot;opener&quot;
3497     // and/or &quot;parent&quot; relation). Requiring some sort of relation prevents a
3498     // document from navigating arbitrary, unrelated top-level frames.
3499     if (!targetFrame.tree().parent()) {
3500         if (&amp;targetFrame == m_frame-&gt;loader().opener())
3501             return true;
3502 
3503         if (canAccessAncestor(securityOrigin(), targetFrame.loader().opener()))
3504             return true;
3505     }
3506 
3507     printNavigationErrorMessage(targetFrame, url(), &quot;The frame attempting navigation is neither same-origin with the target, nor is it the target&#39;s parent or opener.&quot;);
3508     return false;
3509 }
3510 
<span class="line-added">3511 void Document::willLoadScriptElement(const URL&amp; scriptURL)</span>
<span class="line-added">3512 {</span>
<span class="line-added">3513     m_hasLoadedThirdPartyScript = m_hasLoadedThirdPartyScript || !securityOrigin().isSameOriginAs(SecurityOrigin::create(scriptURL));</span>
<span class="line-added">3514 }</span>
<span class="line-added">3515 </span>
<span class="line-added">3516 void Document::willLoadFrameElement(const URL&amp; frameURL)</span>
<span class="line-added">3517 {</span>
<span class="line-added">3518     m_hasLoadedThirdPartyFrame = m_hasLoadedThirdPartyFrame || !securityOrigin().isSameOriginAs(SecurityOrigin::create(frameURL));</span>
<span class="line-added">3519 }</span>
<span class="line-added">3520 </span>
3521 // Prevent cross-site top-level redirects from third-party iframes unless the user has ever interacted with the frame.
3522 bool Document::isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL)
3523 {
3524     if (!settings().thirdPartyIframeRedirectBlockingEnabled())
3525         return false;
3526 
3527     // Only prevent top frame navigations by subframes.
3528     if (m_frame == &amp;targetFrame || &amp;targetFrame != &amp;m_frame-&gt;tree().top())
3529         return false;
3530 
3531     // Only prevent navigations by subframes that the user has not interacted with.
3532     if (m_frame-&gt;hasHadUserInteraction())
3533         return false;
3534 
3535     // Only prevent navigations by unsandboxed iframes. Such navigations by unsandboxed iframes would have already been blocked unless
3536     // &quot;allow-top-navigation&quot; / &quot;allow-top-navigation-by-user-activation&quot; was explicitly specified.
3537     if (sandboxFlags() != SandboxNone)
3538         return false;
3539 
<span class="line-modified">3540     // Only prevent navigations by third-party iframes or untrusted first-party iframes.</span>
<span class="line-modified">3541     bool isUntrustedIframe = m_hasLoadedThirdPartyScript &amp;&amp; m_hasLoadedThirdPartyFrame;</span>
<span class="line-added">3542     if (canAccessAncestor(securityOrigin(), &amp;targetFrame) &amp;&amp; !isUntrustedIframe)</span>
3543         return false;
3544 
3545     // Only prevent cross-site navigations.
3546     auto* targetDocument = targetFrame.document();
3547     if (targetDocument &amp;&amp; (targetDocument-&gt;securityOrigin().canAccess(SecurityOrigin::create(destinationURL)) || areRegistrableDomainsEqual(targetDocument-&gt;url(), destinationURL)))
3548         return false;
3549 
3550     return true;
3551 }
3552 
3553 void Document::didRemoveAllPendingStylesheet()
3554 {
3555     if (auto* parser = scriptableDocumentParser())
3556         parser-&gt;executeScriptsWaitingForStylesheetsSoon();
<span class="line-added">3557 </span>
<span class="line-added">3558     if (m_gotoAnchorNeededAfterStylesheetsLoad) {</span>
<span class="line-added">3559         // https://html.spec.whatwg.org/multipage/browsing-the-web.html#try-to-scroll-to-the-fragment</span>
<span class="line-added">3560         eventLoop().queueTask(TaskSource::Networking, [protectedThis = makeRef(*this), this] {</span>
<span class="line-added">3561             auto frameView = makeRefPtr(view());</span>
<span class="line-added">3562             if (!frameView)</span>
<span class="line-added">3563                 return;</span>
<span class="line-added">3564             if (!haveStylesheetsLoaded()) {</span>
<span class="line-added">3565                 m_gotoAnchorNeededAfterStylesheetsLoad = true;</span>
<span class="line-added">3566                 return;</span>
<span class="line-added">3567             }</span>
<span class="line-added">3568             frameView-&gt;scrollToFragment(m_url);</span>
<span class="line-added">3569         });</span>
<span class="line-added">3570     }</span>
3571 }
3572 
3573 bool Document::usesStyleBasedEditability() const
3574 {
3575     if (m_hasElementUsingStyleBasedEditability)
3576         return true;
3577 
3578     ASSERT(!m_renderView || !m_renderView-&gt;frameView().isPainting());
3579     ASSERT(!m_inStyleRecalc);
3580 
3581     auto&amp; styleScope = const_cast&lt;Style::Scope&amp;&gt;(this-&gt;styleScope());
3582     styleScope.flushPendingUpdate();
3583     return styleScope.usesStyleBasedEditability();
3584 }
3585 
3586 void Document::setHasElementUsingStyleBasedEditability()
3587 {
3588     m_hasElementUsingStyleBasedEditability = true;
3589 }
3590 
</pre>
<hr />
<pre>
3615     Frame* frame = this-&gt;frame();
3616     auto* documentLoader = frame ? frame-&gt;loader().documentLoader() : nullptr;
3617     auto httpStatusCode = documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0;
3618 
3619     HTTPHeaderName headerName;
3620     if (!findHTTPHeaderName(equiv, headerName))
3621         return;
3622 
3623     switch (headerName) {
3624     case HTTPHeaderName::DefaultStyle:
3625         // The preferred style set has been overridden as per section
3626         // 14.3.2 of the HTML4.0 specification.  We need to update the
3627         // sheet used variable and then update our style selector.
3628         // For more info, see the test at:
3629         // http://www.hixie.ch/tests/evil/css/import/main/preferred.html
3630         // -dwh
3631         styleScope().setPreferredStylesheetSetName(content);
3632         break;
3633 
3634     case HTTPHeaderName::Refresh: {
<span class="line-modified">3635         double delay = 0;</span>
3636         String urlString;
3637         if (frame &amp;&amp; parseMetaHTTPEquivRefresh(content, delay, urlString)) {
3638             URL completedURL;
3639             if (urlString.isEmpty())
3640                 completedURL = m_url;
3641             else
3642                 completedURL = completeURL(urlString);
3643             if (!WTF::protocolIsJavaScript(completedURL))
3644                 frame-&gt;navigationScheduler().scheduleRedirect(*this, delay, completedURL);
3645             else {
3646                 String message = &quot;Refused to refresh &quot; + m_url.stringCenterEllipsizedToLength() + &quot; to a javascript: URL&quot;;
3647                 addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
3648             }
3649         }
3650 
3651         break;
3652     }
3653 
3654     case HTTPHeaderName::SetCookie:
3655         if (isHTMLDocument())
</pre>
<hr />
<pre>
3726     LOG_WITH_STREAM(Viewports, stream  &lt;&lt; &quot; resolved to &quot; &lt;&lt; m_viewportArguments);
3727 
3728     processFeaturesString(features, FeatureMode::Viewport, [this](StringView key, StringView value) {
3729         setViewportFeature(m_viewportArguments, *this, key, value);
3730     });
3731 
3732     updateViewportArguments();
3733 }
3734 
3735 ViewportArguments Document::viewportArguments() const
3736 {
3737     auto* page = this-&gt;page();
3738     if (!page)
3739         return m_viewportArguments;
3740     return page-&gt;overrideViewportArguments().valueOr(m_viewportArguments);
3741 }
3742 
3743 void Document::updateViewportArguments()
3744 {
3745     if (page() &amp;&amp; frame()-&gt;isMainFrame()) {
<span class="line-modified">3746 #if ASSERT_ENABLED</span>
3747         m_didDispatchViewportPropertiesChanged = true;
3748 #endif
3749         page()-&gt;chrome().dispatchViewportPropertiesDidChange(viewportArguments());
3750         page()-&gt;chrome().didReceiveDocType(*frame());
3751     }
3752 }
3753 
3754 #if ENABLE(DARK_MODE_CSS)
3755 static void processColorSchemeString(StringView colorScheme, const WTF::Function&lt;void(StringView key)&gt;&amp; callback)
3756 {
3757     unsigned length = colorScheme.length();
3758     for (unsigned i = 0; i &lt; length; ) {
3759         // Skip to first non-separator.
3760         while (i &lt; length &amp;&amp; isHTMLSpace(colorScheme[i]))
3761             ++i;
3762         unsigned keyBegin = i;
3763 
3764         // Skip to first separator.
3765         while (i &lt; length &amp;&amp; !isHTMLSpace(colorScheme[i]))
3766             ++i;
3767         unsigned keyEnd = i;
3768 
3769         if (keyBegin == keyEnd)
3770             continue;
3771 
3772         callback(colorScheme.substring(keyBegin, keyEnd - keyBegin));
3773     }
3774 }
3775 
3776 void Document::processColorScheme(const String&amp; colorSchemeString)
3777 {
3778     OptionSet&lt;ColorScheme&gt; colorScheme;
3779     bool allowsTransformations = true;
3780     bool autoEncountered = false;
3781 
<span class="line-modified">3782     processColorSchemeString(colorSchemeString, [&amp;] (StringView key) {</span>
3783         if (equalLettersIgnoringASCIICase(key, &quot;auto&quot;)) {
3784             colorScheme = { };
3785             allowsTransformations = true;
3786             autoEncountered = true;
3787             return;
3788         }
3789 
3790         if (autoEncountered)
3791             return;
3792 
3793         if (equalLettersIgnoringASCIICase(key, &quot;light&quot;))
3794             colorScheme.add(ColorScheme::Light);
3795         else if (equalLettersIgnoringASCIICase(key, &quot;dark&quot;))
3796             colorScheme.add(ColorScheme::Dark);
3797         else if (equalLettersIgnoringASCIICase(key, &quot;only&quot;))
3798             allowsTransformations = false;
3799     });
3800 
3801     // If the value was just &quot;only&quot;, that is synonymous for &quot;only light&quot;.
3802     if (colorScheme.isEmpty() &amp;&amp; !allowsTransformations)
</pre>
<hr />
<pre>
3985 
3986 Ref&lt;Node&gt; Document::cloneNodeInternal(Document&amp;, CloningOperation type)
3987 {
3988     Ref&lt;Document&gt; clone = cloneDocumentWithoutChildren();
3989     clone-&gt;cloneDataFromDocument(*this);
3990     switch (type) {
3991     case CloningOperation::OnlySelf:
3992     case CloningOperation::SelfWithTemplateContent:
3993         break;
3994     case CloningOperation::Everything:
3995         cloneChildNodes(clone);
3996         break;
3997     }
3998     return clone;
3999 }
4000 
4001 Ref&lt;Document&gt; Document::cloneDocumentWithoutChildren() const
4002 {
4003     if (isXMLDocument()) {
4004         if (isXHTMLDocument())
<span class="line-modified">4005             return XMLDocument::createXHTML(nullptr, url());</span>
<span class="line-modified">4006         return XMLDocument::create(nullptr, url());</span>
4007     }
<span class="line-modified">4008     return create(url());</span>
4009 }
4010 
4011 void Document::cloneDataFromDocument(const Document&amp; other)
4012 {
4013     ASSERT(m_url == other.url());
4014     m_baseURL = other.baseURL();
4015     m_baseURLOverride = other.baseURLOverride();
4016     m_documentURI = other.documentURI();
4017 
4018     setCompatibilityMode(other.m_compatibilityMode);
4019     setContextDocument(other.contextDocument());
4020     setSecurityOriginPolicy(other.securityOriginPolicy());
4021     overrideMIMEType(other.contentType());
4022     setDecoder(other.decoder());
4023 }
4024 
4025 StyleSheetList&amp; Document::styleSheets()
4026 {
4027     if (!m_styleSheetList)
4028         m_styleSheetList = StyleSheetList::create(*this);
4029     return *m_styleSheetList;
4030 }
4031 
<span class="line-modified">4032 void Document::updateElementsAffectedByMediaQueries()</span>
4033 {
<span class="line-modified">4034     ScriptDisallowedScope::InMainThread scriptDisallowedScope;</span>

4035 
<span class="line-modified">4036     // FIXME: copyToVector doesn&#39;t work with WeakHashSet</span>
<span class="line-modified">4037     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;</span>
<span class="line-modified">4038     images.reserveInitialCapacity(m_dynamicMediaQueryDependentImages.computeSize());</span>
<span class="line-added">4039     for (auto&amp; image : m_dynamicMediaQueryDependentImages)</span>
<span class="line-added">4040         images.append(image);</span>
4041 
<span class="line-modified">4042     for (auto&amp; image : images)</span>
<span class="line-modified">4043         image-&gt;evaluateDynamicMediaQueryDependencies();</span>








4044 }
4045 
<span class="line-modified">4046 void Document::evaluateMediaQueriesAndReportChanges()</span>
4047 {
<span class="line-modified">4048     if (!m_mediaQueryMatcher)</span>
<span class="line-modified">4049         return;</span>



4050 
<span class="line-modified">4051     m_mediaQueryMatcher-&gt;evaluateAll();</span>

4052 }
4053 
4054 void Document::updateViewportUnitsOnResize()
4055 {
4056     if (!hasStyleWithViewportUnits())
4057         return;
4058 
<span class="line-modified">4059     styleScope().resolver().clearCachedDeclarationsAffectedByViewportUnits();</span>
4060 
4061     // FIXME: Ideally, we should save the list of elements that have viewport units and only iterate over those.
4062     for (Element* element = ElementTraversal::firstWithin(rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
4063         auto* renderer = element-&gt;renderer();
4064         if (renderer &amp;&amp; renderer-&gt;style().hasViewportUnits())
4065             element-&gt;invalidateStyle();
4066     }
4067 }
4068 
<span class="line-added">4069 void Document::setNeedsDOMWindowResizeEvent()</span>
<span class="line-added">4070 {</span>
<span class="line-added">4071     m_needsDOMWindowResizeEvent = true;</span>
<span class="line-added">4072     scheduleTimedRenderingUpdate();</span>
<span class="line-added">4073 }</span>
<span class="line-added">4074 </span>
<span class="line-added">4075 void Document::setNeedsVisualViewportResize()</span>
<span class="line-added">4076 {</span>
<span class="line-added">4077     m_needsVisualViewportResizeEvent = true;</span>
<span class="line-added">4078     scheduleTimedRenderingUpdate();</span>
<span class="line-added">4079 }</span>
<span class="line-added">4080 </span>
<span class="line-added">4081 // https://drafts.csswg.org/cssom-view/#run-the-resize-steps</span>
<span class="line-added">4082 void Document::runResizeSteps()</span>
<span class="line-added">4083 {</span>
<span class="line-added">4084     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/65.</span>
<span class="line-added">4085     if (m_needsDOMWindowResizeEvent) {</span>
<span class="line-added">4086         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to window&quot;);</span>
<span class="line-added">4087         m_needsDOMWindowResizeEvent = false;</span>
<span class="line-added">4088         dispatchWindowEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">4089     }</span>
<span class="line-added">4090     if (m_needsVisualViewportResizeEvent) {</span>
<span class="line-added">4091         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending resize events to visualViewport&quot;);</span>
<span class="line-added">4092         m_needsVisualViewportResizeEvent = false;</span>
<span class="line-added">4093         if (auto* window = domWindow())</span>
<span class="line-added">4094             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">4095     }</span>
<span class="line-added">4096 }</span>
<span class="line-added">4097 </span>
<span class="line-added">4098 void Document::addPendingScrollEventTarget(ContainerNode&amp; target)</span>
<span class="line-added">4099 {</span>
<span class="line-added">4100     if (!m_pendingScrollEventTargetList)</span>
<span class="line-added">4101         m_pendingScrollEventTargetList = makeUnique&lt;PendingScrollEventTargetList&gt;();</span>
<span class="line-added">4102 </span>
<span class="line-added">4103     auto&amp; targets = m_pendingScrollEventTargetList-&gt;targets;</span>
<span class="line-added">4104     if (targets.findMatching([&amp;] (auto&amp; entry) { return entry.ptr() == &amp;target; }) != notFound)</span>
<span class="line-added">4105         return;</span>
<span class="line-added">4106 </span>
<span class="line-added">4107     if (targets.isEmpty())</span>
<span class="line-added">4108         scheduleTimedRenderingUpdate();</span>
<span class="line-added">4109 </span>
<span class="line-added">4110     targets.append(target);</span>
<span class="line-added">4111 }</span>
<span class="line-added">4112 </span>
<span class="line-added">4113 void Document::setNeedsVisualViewportScrollEvent()</span>
<span class="line-added">4114 {</span>
<span class="line-added">4115     if (!m_needsVisualViewportScrollEvent)</span>
<span class="line-added">4116         scheduleTimedRenderingUpdate();</span>
<span class="line-added">4117     m_needsVisualViewportScrollEvent = true;</span>
<span class="line-added">4118 }</span>
<span class="line-added">4119 </span>
<span class="line-added">4120 // https://drafts.csswg.org/cssom-view/#run-the-scroll-steps</span>
<span class="line-added">4121 void Document::runScrollSteps()</span>
<span class="line-added">4122 {</span>
<span class="line-added">4123     // FIXME: The order of dispatching is not specified: https://github.com/WICG/visual-viewport/issues/66.</span>
<span class="line-added">4124     if (m_pendingScrollEventTargetList &amp;&amp; !m_pendingScrollEventTargetList-&gt;targets.isEmpty()) {</span>
<span class="line-added">4125         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to pending scroll event targets&quot;);</span>
<span class="line-added">4126         auto currentTargets = WTFMove(m_pendingScrollEventTargetList-&gt;targets);</span>
<span class="line-added">4127         for (auto&amp; target : currentTargets) {</span>
<span class="line-added">4128             auto bubbles = target-&gt;isDocumentNode() ? Event::CanBubble::Yes : Event::CanBubble::No;</span>
<span class="line-added">4129             target-&gt;dispatchEvent(Event::create(eventNames().scrollEvent, bubbles, Event::IsCancelable::No));</span>
<span class="line-added">4130         }</span>
<span class="line-added">4131     }</span>
<span class="line-added">4132     if (m_needsVisualViewportScrollEvent) {</span>
<span class="line-added">4133         LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;Document&quot; &lt;&lt; this &lt;&lt; &quot;sending scroll events to visualViewport&quot;);</span>
<span class="line-added">4134         m_needsVisualViewportResizeEvent = false;</span>
<span class="line-added">4135         if (auto* window = domWindow())</span>
<span class="line-added">4136             window-&gt;visualViewport().dispatchEvent(Event::create(eventNames().scrollEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">4137     }</span>
<span class="line-added">4138 }</span>
<span class="line-added">4139 </span>
4140 void Document::addAudioProducer(MediaProducer&amp; audioProducer)
4141 {
4142     m_audioProducers.add(audioProducer);
4143     updateIsPlayingMedia();
4144 }
4145 
4146 void Document::removeAudioProducer(MediaProducer&amp; audioProducer)
4147 {
4148     RELEASE_ASSERT(isMainThread());
4149     m_audioProducers.remove(audioProducer);
4150     updateIsPlayingMedia();
4151 }
4152 
4153 void Document::noteUserInteractionWithMediaElement()
4154 {
4155     if (m_userHasInteractedWithMediaElement)
4156         return;
4157 
4158     if (!topDocument().userDidInteractWithPage())
4159         return;
4160 
4161     m_userHasInteractedWithMediaElement = true;
4162     updateIsPlayingMedia();
4163 }
4164 
4165 void Document::updateIsPlayingMedia(uint64_t sourceElementID)
4166 {
4167     ASSERT(!m_audioProducers.hasNullReferences());
4168     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
4169     for (auto&amp; audioProducer : m_audioProducers)
4170         state |= audioProducer.mediaState();
4171 
<span class="line-modified">4172 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-modified">4173     state |= MediaStreamTrack::captureState(*this);</span>
4174 #endif
4175 
4176 #if ENABLE(MEDIA_SESSION)
4177     if (HTMLMediaElement* sourceElement = HTMLMediaElement::elementWithID(sourceElementID)) {
4178         if (sourceElement-&gt;isPlaying())
4179             state |= MediaProducer::IsSourceElementPlaying;
4180 
4181         if (auto* session = sourceElement-&gt;session()) {
4182             if (auto* controls = session-&gt;controls()) {
4183                 if (controls-&gt;previousTrackEnabled())
4184                     state |= MediaProducer::IsPreviousTrackControlEnabled;
4185                 if (controls-&gt;nextTrackEnabled())
4186                     state |= MediaProducer::IsNextTrackControlEnabled;
4187             }
4188         }
4189     }
4190 #endif
4191 
4192     if (m_userHasInteractedWithMediaElement)
4193         state |= MediaProducer::HasUserInteractedWithMediaElement;
</pre>
<hr />
<pre>
4198 #if ENABLE(MEDIA_STREAM)
4199     bool captureStateChanged = MediaProducer::isCapturing(m_mediaState) != MediaProducer::isCapturing(state);
4200 #endif
4201 
4202     m_mediaState = state;
4203 
4204     if (page())
4205         page()-&gt;updateIsPlayingMedia(sourceElementID);
4206 
4207 #if ENABLE(MEDIA_STREAM)
4208     if (captureStateChanged)
4209         mediaStreamCaptureStateChanged();
4210 #endif
4211 }
4212 
4213 void Document::pageMutedStateDidChange()
4214 {
4215     for (auto&amp; audioProducer : m_audioProducers)
4216         audioProducer.pageMutedStateDidChange();
4217 
<span class="line-modified">4218 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-modified">4219     MediaStreamTrack::updateCaptureAccordingToMutedState(*this);</span>
4220 #endif
4221 }
4222 
4223 static bool isNodeInSubtree(Node&amp; node, Node&amp; container, Document::NodeRemoval nodeRemoval)
4224 {
4225     if (nodeRemoval == Document::NodeRemoval::ChildrenOfNode)
4226         return node.isDescendantOf(container);
4227 
4228     return &amp;node == &amp;container || node.isDescendantOf(container);
4229 }
4230 
4231 void Document::adjustFocusedNodeOnNodeRemoval(Node&amp; node, NodeRemoval nodeRemoval)
4232 {
<span class="line-modified">4233     if (!m_focusedElement || backForwardCacheState() != NotInBackForwardCache) // If the document is in the back/forward cache, then we don&#39;t need to clear out the focused node.</span>
4234         return;
4235 
4236     Element* focusedElement = node.treeScope().focusedElementInScope();
4237     if (!focusedElement)
4238         return;
4239 
4240     if (isNodeInSubtree(*focusedElement, node, nodeRemoval)) {
4241         // FIXME: We should avoid synchronously updating the style inside setFocusedElement.
4242         // FIXME: Object elements should avoid loading a frame synchronously in a post style recalc callback.
4243         SubframeLoadingDisabler disabler(is&lt;ContainerNode&gt;(node) ? &amp;downcast&lt;ContainerNode&gt;(node) : nullptr);
4244         setFocusedElement(nullptr, FocusDirectionNone, FocusRemovalEventsMode::DoNotDispatch);
4245         // Set the focus navigation starting node to the previous focused element so that
4246         // we can fallback to the siblings or parent node for the next search.
4247         // Also we need to call removeFocusNavigationNodeOfSubtree after this function because
4248         // setFocusedElement(nullptr) will reset m_focusNavigationStartingNode.
4249         setFocusNavigationStartingNode(focusedElement);
4250     }
4251 }
4252 
4253 void Document::hoveredElementDidDetach(Element&amp; element)
</pre>
<hr />
<pre>
4281 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
4282     if (auto* page = this-&gt;page()) {
4283         if (auto* frameView = view()) {
4284             if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
4285                 scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
4286         }
4287     }
4288 #endif
4289 }
4290 
4291 bool Document::setFocusedElement(Element* element, FocusDirection direction, FocusRemovalEventsMode eventsMode)
4292 {
4293     RefPtr&lt;Element&gt; newFocusedElement = element;
4294     // Make sure newFocusedElement is actually in this document
4295     if (newFocusedElement &amp;&amp; (&amp;newFocusedElement-&gt;document() != this))
4296         return true;
4297 
4298     if (m_focusedElement == newFocusedElement)
4299         return true;
4300 
<span class="line-modified">4301     if (backForwardCacheState() != NotInBackForwardCache)</span>
4302         return false;
4303 
4304     bool focusChangeBlocked = false;
4305     RefPtr&lt;Element&gt; oldFocusedElement = WTFMove(m_focusedElement);
4306 
4307     // Remove focus from the existing focus node (if any)
4308     if (oldFocusedElement) {
4309         oldFocusedElement-&gt;setFocus(false);
4310         setFocusNavigationStartingNode(nullptr);
4311 
4312         if (eventsMode == FocusRemovalEventsMode::Dispatch) {
4313             // Dispatch a change event for form control elements that have been edited.
4314             if (is&lt;HTMLFormControlElement&gt;(*oldFocusedElement)) {
4315                 HTMLFormControlElement&amp; formControlElement = downcast&lt;HTMLFormControlElement&gt;(*oldFocusedElement);
4316                 if (formControlElement.wasChangedSinceLastFormControlChangeEvent())
4317                     formControlElement.dispatchFormControlChangeEvent();
4318             }
4319 
4320             // Dispatch the blur event and let the node do any other blur related activities (important for text fields)
4321             oldFocusedElement-&gt;dispatchBlurEvent(newFocusedElement.copyRef());
</pre>
<hr />
<pre>
4349             frame()-&gt;editor().didEndEditing();
4350 
4351         if (view()) {
4352             if (Widget* oldWidget = widgetForElement(oldFocusedElement.get()))
4353                 oldWidget-&gt;setFocus(false);
4354             else
4355                 view()-&gt;setFocus(false);
4356         }
4357 
4358         if (is&lt;HTMLInputElement&gt;(oldFocusedElement)) {
4359             // HTMLInputElement::didBlur just scrolls text fields back to the beginning.
4360             // FIXME: This could be done asynchronusly.
4361             // Updating style may dispatch events due to PostResolutionCallback
4362             if (eventsMode == FocusRemovalEventsMode::Dispatch)
4363                 updateStyleIfNeeded();
4364             downcast&lt;HTMLInputElement&gt;(*oldFocusedElement).didBlur();
4365         }
4366     }
4367 
4368     if (newFocusedElement &amp;&amp; newFocusedElement-&gt;isFocusable()) {
<span class="line-added">4369         if (&amp;newFocusedElement-&gt;document() != this) {</span>
<span class="line-added">4370             // Bluring oldFocusedElement may have moved newFocusedElement across documents.</span>
<span class="line-added">4371             focusChangeBlocked = true;</span>
<span class="line-added">4372             goto SetFocusedNodeDone;</span>
<span class="line-added">4373         }</span>
4374         if (newFocusedElement-&gt;isRootEditableElement() &amp;&amp; !acceptsEditingFocus(*newFocusedElement)) {
4375             // delegate blocks focus change
4376             focusChangeBlocked = true;
4377             goto SetFocusedNodeDone;
4378         }
4379         // Set focus on the new node
4380         m_focusedElement = newFocusedElement;
4381         setFocusNavigationStartingNode(m_focusedElement.get());
4382 
4383         // Dispatch the focus event and let the node do any other focus related activities (important for text fields)
4384         m_focusedElement-&gt;dispatchFocusEvent(oldFocusedElement.copyRef(), direction);
4385 
4386         if (m_focusedElement != newFocusedElement) {
4387             // handler shifted focus
4388             focusChangeBlocked = true;
4389             goto SetFocusedNodeDone;
4390         }
4391 
4392         m_focusedElement-&gt;dispatchFocusInEvent(eventNames().focusinEvent, oldFocusedElement.copyRef()); // DOM level 3 bubbling focus event.
4393 
</pre>
<hr />
<pre>
4726 
4727 void Document::createDOMWindow()
4728 {
4729     ASSERT(m_frame);
4730     ASSERT(!m_domWindow);
4731 
4732     m_domWindow = DOMWindow::create(*this);
4733 
4734     ASSERT(m_domWindow-&gt;document() == this);
4735     ASSERT(m_domWindow-&gt;frame() == m_frame);
4736 
4737     m_frame-&gt;loader().client().didCreateWindow(*m_domWindow);
4738 }
4739 
4740 void Document::takeDOMWindowFrom(Document&amp; document)
4741 {
4742     ASSERT(m_frame);
4743     ASSERT(!m_domWindow);
4744     ASSERT(document.m_domWindow);
4745     // A valid DOMWindow is needed by CachedFrame for its documents.
<span class="line-modified">4746     ASSERT(backForwardCacheState() == NotInBackForwardCache);</span>
4747 
4748     m_domWindow = WTFMove(document.m_domWindow);
4749     m_domWindow-&gt;didSecureTransitionTo(*this);
4750 
4751     ASSERT(m_domWindow-&gt;document() == this);
4752     ASSERT(m_domWindow-&gt;frame() == m_frame);
4753 }
4754 
4755 WindowProxy* Document::windowProxy() const
4756 {
4757     if (!m_frame)
4758         return nullptr;
4759     return &amp;m_frame-&gt;windowProxy();
4760 }
4761 
4762 Document&amp; Document::contextDocument() const
4763 {
4764     if (m_contextDocument)
4765         return *m_contextDocument.get();
4766     return const_cast&lt;Document&amp;&gt;(*this);
4767 }
4768 
4769 void Document::setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4770 {
4771     setAttributeEventListener(eventType, JSLazyEventListener::create(*this, attributeName, attributeValue), isolatedWorld);
4772 }
4773 
4774 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, RefPtr&lt;EventListener&gt;&amp;&amp; listener, DOMWrapperWorld&amp; isolatedWorld)
4775 {
4776     if (!m_domWindow)
4777         return;
4778     m_domWindow-&gt;setAttributeEventListener(eventType, WTFMove(listener), isolatedWorld);
4779 }
4780 
4781 void Document::setWindowAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, DOMWrapperWorld&amp; isolatedWorld)
4782 {
4783     if (!m_domWindow)
4784         return;
<span class="line-added">4785     if (!m_domWindow-&gt;frame())</span>
<span class="line-added">4786         return;</span>
4787     setWindowAttributeEventListener(eventType, JSLazyEventListener::create(*m_domWindow, attributeName, attributeValue), isolatedWorld);
4788 }
4789 
4790 EventListener* Document::getWindowAttributeEventListener(const AtomString&amp; eventType, DOMWrapperWorld&amp; isolatedWorld)
4791 {
4792     if (!m_domWindow)
4793         return nullptr;
4794     return m_domWindow-&gt;attributeEventListener(eventType, isolatedWorld);
4795 }
4796 
4797 void Document::dispatchWindowEvent(Event&amp; event, EventTarget* target)
4798 {
4799     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4800     if (!m_domWindow)
4801         return;
4802     m_domWindow-&gt;dispatchEvent(event, target);
4803 }
4804 
4805 void Document::dispatchWindowLoadEvent()
4806 {
4807     ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed());
4808     if (!m_domWindow)
4809         return;
4810     m_domWindow-&gt;dispatchLoadEvent();
4811     m_loadEventFinished = true;
4812     m_cachedResourceLoader-&gt;documentDidFinishLoadEvent();
4813 }
4814 
<span class="line-modified">4815 void Document::queueTaskToDispatchEvent(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)</span>
4816 {
<span class="line-modified">4817     eventLoop().queueTask(source, [document = makeRef(*this), event = WTFMove(event)] {</span>
<span class="line-modified">4818         document-&gt;dispatchEvent(event);</span>
<span class="line-added">4819     });</span>
4820 }
4821 
<span class="line-modified">4822 void Document::queueTaskToDispatchEventOnWindow(TaskSource source, Ref&lt;Event&gt;&amp;&amp; event)</span>
4823 {
<span class="line-modified">4824     eventLoop().queueTask(source, [this, protectedThis = makeRef(*this), event = WTFMove(event)] {</span>
<span class="line-modified">4825         if (!m_domWindow)</span>
<span class="line-added">4826             return;</span>
<span class="line-added">4827         m_domWindow-&gt;dispatchEvent(event);</span>
<span class="line-added">4828     });</span>
4829 }
4830 
4831 void Document::enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp; event)
4832 {
<span class="line-modified">4833     // https://developer.mozilla.org/en-US/docs/Web/API/Element/overflow_event</span>
<span class="line-added">4834     // FIXME: This event is totally unspecified.</span>
<span class="line-added">4835     auto* target = event-&gt;target();</span>
<span class="line-added">4836     RELEASE_ASSERT(target);</span>
<span class="line-added">4837     RELEASE_ASSERT(is&lt;Node&gt;(target));</span>
<span class="line-added">4838     eventLoop().queueTask(TaskSource::DOMManipulation, [protectedTarget = GCReachableRef&lt;Node&gt;(downcast&lt;Node&gt;(*target)), event = WTFMove(event)] {</span>
<span class="line-added">4839         protectedTarget-&gt;dispatchEvent(event);</span>
<span class="line-added">4840     });</span>
4841 }
4842 
4843 ExceptionOr&lt;Ref&lt;Event&gt;&gt; Document::createEvent(const String&amp; type)
4844 {
4845     // Please do *not* add new event classes to this function unless they are required
4846     // for compatibility with the DOM specification or some actual legacy web content.
4847 
4848     // This mechanism is superceded by use of event constructors.
4849     // That is what we should use for any new event classes.
4850 
4851     // The following strings are the ones from the DOM specification
4852     // &lt;https://dom.spec.whatwg.org/#dom-document-createevent&gt;.
4853 
4854     if (equalLettersIgnoringASCIICase(type, &quot;beforeunloadevent&quot;))
4855         return Ref&lt;Event&gt; { BeforeUnloadEvent::createForBindings() };
4856     if (equalLettersIgnoringASCIICase(type, &quot;compositionevent&quot;))
4857         return Ref&lt;Event&gt; { CompositionEvent::createForBindings() };
4858     if (equalLettersIgnoringASCIICase(type, &quot;customevent&quot;))
4859         return Ref&lt;Event&gt; { CustomEvent::create() };
<span class="line-added">4860     if (equalLettersIgnoringASCIICase(type, &quot;dragevent&quot;))</span>
<span class="line-added">4861         return Ref&lt;Event&gt; { DragEvent::createForBindings() };</span>
4862     if (equalLettersIgnoringASCIICase(type, &quot;event&quot;) || equalLettersIgnoringASCIICase(type, &quot;events&quot;) || equalLettersIgnoringASCIICase(type, &quot;htmlevents&quot;) || equalLettersIgnoringASCIICase(type, &quot;svgevents&quot;))
4863         return Event::createForBindings();
4864     if (equalLettersIgnoringASCIICase(type, &quot;focusevent&quot;))
4865         return Ref&lt;Event&gt; { FocusEvent::createForBindings() };
4866     if (equalLettersIgnoringASCIICase(type, &quot;hashchangeevent&quot;))
4867         return Ref&lt;Event&gt; { HashChangeEvent::createForBindings() };
4868     if (equalLettersIgnoringASCIICase(type, &quot;keyboardevent&quot;))
4869         return Ref&lt;Event&gt; { KeyboardEvent::createForBindings() };
4870     if (equalLettersIgnoringASCIICase(type, &quot;messageevent&quot;))
4871         return Ref&lt;Event&gt; { MessageEvent::createForBindings() };
4872     if (equalLettersIgnoringASCIICase(type, &quot;storageevent&quot;))
4873         return Ref&lt;Event&gt; { StorageEvent::createForBindings() };
4874     if (equalLettersIgnoringASCIICase(type, &quot;mouseevent&quot;) || equalLettersIgnoringASCIICase(type, &quot;mouseevents&quot;))
4875         return Ref&lt;Event&gt; { MouseEvent::createForBindings() };
4876     if (equalLettersIgnoringASCIICase(type, &quot;textevent&quot;))
4877         return Ref&lt;Event&gt; { TextEvent::createForBindings() }; // FIXME: HTML specification says this should create a CompositionEvent, not a TextEvent.
4878     if (equalLettersIgnoringASCIICase(type, &quot;uievent&quot;) || equalLettersIgnoringASCIICase(type, &quot;uievents&quot;))
4879         return Ref&lt;Event&gt; { UIEvent::createForBindings() };
4880 
4881     // FIXME: Consider including support for these event classes even when device orientation
</pre>
<hr />
<pre>
5029 {
5030     if (page() &amp;&amp; !page()-&gt;settings().cookieEnabled())
5031         return { };
5032 
5033     if (isCookieAverse())
5034         return { };
5035 
5036     if (!securityOrigin().canAccessCookies())
5037         return Exception { SecurityError };
5038 
5039     URL cookieURL = this-&gt;cookieURL();
5040     if (cookieURL.isEmpty())
5041         return { };
5042 
5043     invalidateDOMCookieCache();
5044     if (page())
5045         page()-&gt;cookieJar().setCookies(*this, cookieURL, value);
5046     return { };
5047 }
5048 
<span class="line-modified">5049 String Document::referrer()</span>
5050 {
5051 #if ENABLE(RESOURCE_LOAD_STATISTICS)
5052     if (!m_referrerOverride.isEmpty())
5053         return m_referrerOverride;
<span class="line-added">5054     if (DeprecatedGlobalSettings::resourceLoadStatisticsEnabled() &amp;&amp; frame()) {</span>
<span class="line-added">5055         auto referrerStr = frame()-&gt;loader().referrer();</span>
<span class="line-added">5056         if (!referrerStr.isEmpty()) {</span>
<span class="line-added">5057             URL referrerURL { URL(), referrerStr };</span>
<span class="line-added">5058             RegistrableDomain referrerRegistrableDomain { referrerURL };</span>
<span class="line-added">5059             if (!referrerRegistrableDomain.matches(securityOrigin().data())) {</span>
<span class="line-added">5060                 m_referrerOverride = referrerURL.protocolHostAndPort();</span>
<span class="line-added">5061                 return m_referrerOverride;</span>
<span class="line-added">5062             }</span>
<span class="line-added">5063         }</span>
<span class="line-added">5064     }</span>
5065 #endif
5066     if (frame())
5067         return frame()-&gt;loader().referrer();
5068     return String();
5069 }
5070 





5071 String Document::domain() const
5072 {
5073     return securityOrigin().domain();
5074 }
5075 
5076 ExceptionOr&lt;void&gt; Document::setDomain(const String&amp; newDomain)
5077 {
5078     if (!frame())
5079         return Exception { SecurityError, &quot;A browsing context is required to set a domain.&quot; };
5080 
5081     if (isSandboxed(SandboxDocumentDomain))
5082         return Exception { SecurityError, &quot;Assignment is forbidden for sandboxed iframes.&quot; };
5083 
<span class="line-modified">5084     if (LegacySchemeRegistry::isDomainRelaxationForbiddenForURLScheme(securityOrigin().protocol()))</span>
5085         return Exception { SecurityError };
5086 
5087     // FIXME: We should add logging indicating why a domain was not allowed.
5088 
5089     const String&amp; effectiveDomain = domain();
5090     if (effectiveDomain.isEmpty())
5091         return Exception { SecurityError, &quot;The document has a null effectiveDomain.&quot; };
5092 
5093     if (!securityOrigin().isMatchingRegistrableDomainSuffix(newDomain, settings().treatIPAddressAsDomain()))
5094         return Exception { SecurityError, &quot;Attempted to use a non-registrable domain.&quot; };
5095 
5096     securityOrigin().setDomainFromDOM(newDomain);
5097     return { };
5098 }
5099 
5100 void Document::overrideLastModified(const Optional&lt;WallTime&gt;&amp; lastModified)
5101 {
5102     m_overrideLastModified = lastModified;
5103 }
5104 
</pre>
<hr />
<pre>
5240     if (!colonPosition || length - colonPosition &lt;= 1)
5241         return Exception { InvalidCharacterError };
5242 
5243     return std::pair&lt;AtomString, AtomString&gt; { StringView { qualifiedName }.substring(0, colonPosition).toAtomString(), StringView { qualifiedName }.substring(colonPosition + 1).toAtomString() };
5244 }
5245 
5246 ExceptionOr&lt;QualifiedName&gt; Document::parseQualifiedName(const AtomString&amp; namespaceURI, const String&amp; qualifiedName)
5247 {
5248     auto parseResult = parseQualifiedName(qualifiedName);
5249     if (parseResult.hasException())
5250         return parseResult.releaseException();
5251     auto parsedPieces = parseResult.releaseReturnValue();
5252     return QualifiedName { parsedPieces.first, parsedPieces.second, namespaceURI };
5253 }
5254 
5255 void Document::setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp; decoder)
5256 {
5257     m_decoder = WTFMove(decoder);
5258 }
5259 
<span class="line-modified">5260 URL Document::completeURL(const String&amp; url, const URL&amp; baseURLOverride, ForceUTF8 forceUTF8) const</span>
5261 {
5262     // Always return a null URL when passed a null string.
5263     // FIXME: Should we change the URL constructor to have this behavior?
5264     // See also [CSS]StyleSheet::completeURL(const String&amp;)
5265     if (url.isNull())
5266         return URL();
5267     const URL&amp; baseURL = ((baseURLOverride.isEmpty() || baseURLOverride == WTF::blankURL()) &amp;&amp; parentDocument()) ? parentDocument()-&gt;baseURL() : baseURLOverride;
<span class="line-modified">5268     if (!m_decoder || forceUTF8 == ForceUTF8::Yes)</span>
5269         return URL(baseURL, url);
5270     return URL(baseURL, url, m_decoder-&gt;encodingForURLParsing());
5271 }
5272 
<span class="line-modified">5273 URL Document::completeURL(const String&amp; url, ForceUTF8 forceUTF8) const</span>





5274 {
<span class="line-modified">5275     return completeURL(url, m_baseURL, forceUTF8);</span>
5276 }
5277 
<span class="line-modified">5278 void Document::setBackForwardCacheState(BackForwardCacheState state)</span>
5279 {
<span class="line-modified">5280     if (m_backForwardCacheState == state)</span>
5281         return;
5282 
<span class="line-modified">5283     m_backForwardCacheState = state;</span>
5284 
5285     FrameView* v = view();
5286     Page* page = this-&gt;page();
5287 
5288     switch (state) {
<span class="line-modified">5289     case InBackForwardCache:</span>
5290         if (v) {
5291             // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
<span class="line-modified">5292             // back/forward cache and similar work that needs to occur when it comes out. This is where we do the work</span>
5293             // that needs to happen when we enter, and the work that needs to happen when we exit is in
5294             // HistoryController::restoreScrollPositionAndViewState(). It can&#39;t be here because this function is
5295             // called too early on in the process of a page exiting the cache for that work to be possible in this
5296             // function. It would be nice if there was more symmetry here.
5297             // https://bugs.webkit.org/show_bug.cgi?id=98698
5298             v-&gt;cacheCurrentScrollPosition();
5299             if (page &amp;&amp; m_frame-&gt;isMainFrame()) {
5300                 v-&gt;resetScrollbarsAndClearContentsSize();
5301                 if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
5302                     scrollingCoordinator-&gt;clearAllNodes();
5303             }
5304         }
5305 
5306 #if ENABLE(POINTER_LOCK)
5307         exitPointerLock();
5308 #endif
5309 
5310         styleScope().clearResolver();
5311         clearSelectorQueryCache();
5312         m_styleRecalcTimer.stop();
5313 
5314         clearSharedObjectPool();
<span class="line-added">5315 </span>
<span class="line-added">5316 #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">5317         if (m_idbConnectionProxy)</span>
<span class="line-added">5318             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), true);</span>
<span class="line-added">5319 #endif</span>
5320         break;
<span class="line-modified">5321     case NotInBackForwardCache:</span>
5322         if (childNeedsStyleRecalc())
5323             scheduleStyleRecalc();
<span class="line-added">5324 #if ENABLE(INDEXED_DATABASE)</span>
<span class="line-added">5325         if (m_idbConnectionProxy)</span>
<span class="line-added">5326             m_idbConnectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), false);</span>
<span class="line-added">5327 #endif</span>
5328         break;
<span class="line-modified">5329     case AboutToEnterBackForwardCache:</span>
5330         break;
5331     }
5332 }
5333 
5334 void Document::documentWillBecomeInactive()
5335 {
5336     if (renderView())
5337         renderView()-&gt;setIsInWindow(false);
5338 }
5339 
5340 void Document::suspend(ReasonForSuspension reason)
5341 {
5342     if (m_isSuspended)
5343         return;
5344 
5345     documentWillBecomeInactive();
5346 
5347     for (auto* element : m_documentSuspensionCallbackElements)
5348         element-&gt;prepareForDocumentSuspension();
5349 
<span class="line-modified">5350 #if ASSERT_ENABLED</span>
5351     // Clear the update flag to be able to check if the viewport arguments update
<span class="line-modified">5352     // is dispatched, after the document is restored from the back/forward cache.</span>
5353     m_didDispatchViewportPropertiesChanged = false;
5354 #endif
5355 
5356     ASSERT(page());
5357     page()-&gt;lockAllOverlayScrollbarsToHidden(true);
5358 
5359     if (RenderView* view = renderView()) {
5360         if (view-&gt;usesCompositing())
5361             view-&gt;compositor().cancelCompositingLayerUpdate();
5362     }
5363 
5364 #if USE(LIBWEBRTC)
5365     // FIXME: This should be moved to Modules/mediastream.
5366     if (LibWebRTCProvider::webRTCAvailable()) {
5367         if (auto* page = this-&gt;page())
5368             page-&gt;libWebRTCProvider().unregisterMDNSNames(identifier().toUInt64());
5369     }
5370 #endif
5371 
5372 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">5373     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)</span>

5374         setServiceWorkerConnection(nullptr);

5375 #endif
5376 
5377     suspendScheduledTasks(reason);
5378 
5379     ASSERT(m_frame);
5380     m_frame-&gt;clearTimers();
5381 
5382     m_visualUpdatesAllowed = false;
5383     m_visualUpdatesSuppressionTimer.stop();
5384 
5385     m_isSuspended = true;
5386 }
5387 
5388 void Document::resume(ReasonForSuspension reason)
5389 {
5390     if (!m_isSuspended)
5391         return;
5392 
5393     for (auto* element : copyToVector(m_documentSuspensionCallbackElements))
5394         element-&gt;resumeFromDocumentSuspension();
</pre>
<hr />
<pre>
5398 
5399     ASSERT(page());
5400     page()-&gt;lockAllOverlayScrollbarsToHidden(false);
5401 
5402     ASSERT(m_frame);
5403     m_frame-&gt;loader().client().dispatchDidBecomeFrameset(isFrameSet());
5404 
5405     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
5406         if (auto* timeline = existingTimeline())
5407             timeline-&gt;resumeAnimations();
5408     } else
5409         m_frame-&gt;animation().resumeAnimationsForDocument(this);
5410 
5411     resumeScheduledTasks(reason);
5412 
5413     m_visualUpdatesAllowed = true;
5414 
5415     m_isSuspended = false;
5416 
5417 #if ENABLE(SERVICE_WORKER)
<span class="line-modified">5418     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; reason == ReasonForSuspension::BackForwardCache)</span>
<span class="line-modified">5419         setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnection());</span>


5420 #endif
5421 }
5422 
5423 void Document::registerForDocumentSuspensionCallbacks(Element&amp; element)
5424 {
5425     m_documentSuspensionCallbackElements.add(&amp;element);
5426 }
5427 
5428 void Document::unregisterForDocumentSuspensionCallbacks(Element&amp; element)
5429 {
5430     m_documentSuspensionCallbackElements.remove(&amp;element);
5431 }
5432 
















5433 bool Document::audioPlaybackRequiresUserGesture() const
5434 {
5435     if (DocumentLoader* loader = this-&gt;loader()) {
5436         // If an audio playback policy was set during navigation, use it. If not, use the global settings.
5437         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5438         if (policy != AutoplayPolicy::Default)
5439             return policy == AutoplayPolicy::AllowWithoutSound || policy == AutoplayPolicy::Deny;
5440     }
5441 
5442     return settings().audioPlaybackRequiresUserGesture();
5443 }
5444 
5445 bool Document::videoPlaybackRequiresUserGesture() const
5446 {
5447     if (DocumentLoader* loader = this-&gt;loader()) {
5448         // If a video playback policy was set during navigation, use it. If not, use the global settings.
5449         AutoplayPolicy policy = loader-&gt;autoplayPolicy();
5450         if (policy != AutoplayPolicy::Default)
5451             return policy == AutoplayPolicy::Deny;
5452     }
5453 
5454     return settings().videoPlaybackRequiresUserGesture();
5455 }
5456 
<span class="line-added">5457 bool Document::mediaDataLoadsAutomatically() const</span>
<span class="line-added">5458 {</span>
<span class="line-added">5459     if (auto* loader = this-&gt;loader()) {</span>
<span class="line-added">5460         AutoplayPolicy policy = loader-&gt;autoplayPolicy();</span>
<span class="line-added">5461         if (policy != AutoplayPolicy::Default)</span>
<span class="line-added">5462             return policy != AutoplayPolicy::Deny;</span>
<span class="line-added">5463     }</span>
<span class="line-added">5464 </span>
<span class="line-added">5465     return settings().mediaDataLoadsAutomatically();</span>
<span class="line-added">5466 }</span>
<span class="line-added">5467 </span>
5468 void Document::storageBlockingStateDidChange()
5469 {
5470     securityOrigin().setStorageBlockingPolicy(settings().storageBlockingPolicy());
5471 }
5472 
<span class="line-added">5473 // Used only by WebKitLegacy.</span>
5474 void Document::privateBrowsingStateDidChange(PAL::SessionID sessionID)
5475 {

5476     if (m_logger)
5477         m_logger-&gt;setEnabled(this, sessionID.isAlwaysOnLoggingAllowed());
5478 
<span class="line-modified">5479 #if ENABLE(VIDEO)</span>
<span class="line-modified">5480     forEachMediaElement([sessionID] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">5481         element.privateBrowsingStateDidChange(sessionID);</span>
<span class="line-modified">5482     });</span>


5483 #endif
5484 }
5485 










5486 #if ENABLE(VIDEO_TRACK)
5487 
<span class="line-modified">5488 void Document::registerForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)</span>
5489 {
5490     if (page())
5491         page()-&gt;group().captionPreferences().setInterestedInCaptionPreferenceChanges();
5492 
5493     m_captionPreferencesChangedElements.add(&amp;element);
5494 }
5495 
<span class="line-modified">5496 void Document::unregisterForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp; element)</span>
5497 {
5498     m_captionPreferencesChangedElements.remove(&amp;element);
5499 }
5500 
5501 void Document::captionPreferencesChanged()
5502 {
5503     for (auto* element : m_captionPreferencesChangedElements)
5504         element-&gt;captionPreferencesChanged();
5505 }
5506 
5507 #endif
5508 




































5509 void Document::setShouldCreateRenderers(bool f)
5510 {
5511     m_createRenderers = f;
5512 }
5513 
5514 bool Document::shouldCreateRenderers()
5515 {
5516     return m_createRenderers;
5517 }
5518 
5519 // Support for Javascript execCommand, and related methods
5520 
5521 static Editor::Command command(Document* document, const String&amp; commandName, bool userInterface = false)
5522 {
5523     auto protectedDocument = makeRef(*document);
5524 
5525     document-&gt;updateStyleIfNeeded();
5526 
5527     auto frame = makeRefPtr(document-&gt;frame());
5528 
</pre>
<hr />
<pre>
5670         if (d-&gt;m_designMode != inherit)
5671             return d-&gt;m_designMode;
5672     }
5673     return false;
5674 }
5675 
5676 Document* Document::parentDocument() const
5677 {
5678     if (!m_frame)
5679         return nullptr;
5680     Frame* parent = m_frame-&gt;tree().parent();
5681     if (!parent)
5682         return nullptr;
5683     return parent-&gt;document();
5684 }
5685 
5686 Document&amp; Document::topDocument() const
5687 {
5688     // FIXME: This special-casing avoids incorrectly determined top documents during the process
5689     // of AXObjectCache teardown or notification posting for cached or being-destroyed documents.
<span class="line-modified">5690     if (backForwardCacheState() == NotInBackForwardCache &amp;&amp; !m_renderTreeBeingDestroyed) {</span>
5691         if (!m_frame)
5692             return const_cast&lt;Document&amp;&gt;(*this);
5693         // This should always be non-null.
5694         Document* mainFrameDocument = m_frame-&gt;mainFrame().document();
5695         return mainFrameDocument ? *mainFrameDocument : const_cast&lt;Document&amp;&gt;(*this);
5696     }
5697 
5698     Document* document = const_cast&lt;Document*&gt;(this);
5699     while (HTMLFrameOwnerElement* element = document-&gt;ownerElement())
5700         document = &amp;element-&gt;document();
5701     return *document;
5702 }
5703 
<span class="line-modified">5704 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttribute(const String&amp; localName)</span>
5705 {
<span class="line-modified">5706     if (!isValidName(localName))</span>
<span class="line-added">5707         return Exception { InvalidCharacterError };</span>
<span class="line-added">5708     return Attr::create(*this, QualifiedName { nullAtom(), isHTMLDocument() ? localName.convertToASCIILowercase() : localName, nullAtom() }, emptyString());</span>
5709 }
5710 
5711 ExceptionOr&lt;Ref&lt;Attr&gt;&gt; Document::createAttributeNS(const AtomString&amp; namespaceURI, const String&amp; qualifiedName, bool shouldIgnoreNamespaceChecks)
5712 {
5713     auto parseResult = parseQualifiedName(namespaceURI, qualifiedName);
5714     if (parseResult.hasException())
5715         return parseResult.releaseException();
5716     QualifiedName parsedName { parseResult.releaseReturnValue() };
5717     if (!shouldIgnoreNamespaceChecks &amp;&amp; !hasValidNamespaceForAttributes(parsedName))
5718         return Exception { NamespaceError };
5719     return Attr::create(*this, parsedName, emptyString());
5720 }
5721 
5722 const SVGDocumentExtensions* Document::svgExtensions()
5723 {
5724     return m_svgExtensions.get();
5725 }
5726 
5727 SVGDocumentExtensions&amp; Document::accessSVGExtensions()
5728 {
</pre>
<hr />
<pre>
5811 }
5812 
5813 Ref&lt;HTMLCollection&gt; Document::documentNamedItems(const AtomString&amp; name)
5814 {
5815     return ensureRareData().ensureNodeLists().addCachedCollection&lt;DocumentNameCollection&gt;(*this, DocumentNamedItems, name);
5816 }
5817 
5818 void Document::finishedParsing()
5819 {
5820     ASSERT(!scriptableDocumentParser() || !m_parser-&gt;isParsing());
5821     ASSERT(!scriptableDocumentParser() || m_readyState != Loading);
5822     setParsing(false);
5823 
5824     Ref&lt;Document&gt; protectedThis(*this);
5825 
5826     scriptRunner().documentFinishedParsing();
5827 
5828     if (!m_documentTiming.domContentLoadedEventStart)
5829         m_documentTiming.domContentLoadedEventStart = MonotonicTime::now();
5830 
<span class="line-modified">5831     // FIXME: Schedule a task to fire DOMContentLoaded event instead. See webkit.org/b/82931</span>
<span class="line-modified">5832     eventLoop().performMicrotaskCheckpoint();</span>



5833     dispatchEvent(Event::create(eventNames().DOMContentLoadedEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
5834 
5835     if (!m_documentTiming.domContentLoadedEventEnd)
5836         m_documentTiming.domContentLoadedEventEnd = MonotonicTime::now();
5837 
5838     if (RefPtr&lt;Frame&gt; frame = this-&gt;frame()) {
5839 #if ENABLE(XSLT)
5840         applyPendingXSLTransformsNowIfScheduled();
5841 #endif
5842 
5843         // FrameLoader::finishedParsing() might end up calling Document::implicitClose() if all
5844         // resource loads are complete. HTMLObjectElements can start loading their resources from
5845         // post attach callbacks triggered by resolveStyle(). This means if we parse out an &lt;object&gt;
5846         // tag and then reach the end of the document without updating styles, we might not have yet
5847         // started the resource load and might fire the window load event too early. To avoid this
5848         // we force the styles to be up to date before calling FrameLoader::finishedParsing().
5849         // See https://bugs.webkit.org/show_bug.cgi?id=36864 starting around comment 35.
5850         updateStyleIfNeeded();
5851 
5852         frame-&gt;loader().finishedParsing();
5853         InspectorInstrumentation::domContentLoadedEventFired(*frame);
5854     }
5855 
5856     // Schedule dropping of the DocumentSharedObjectPool. We keep it alive for a while after parsing finishes
5857     // so that dynamically inserted content can also benefit from sharing optimizations.
5858     // Note that we don&#39;t refresh the timer on pool access since that could lead to huge caches being kept
5859     // alive indefinitely by something innocuous like JS setting .innerHTML repeatedly on a timer.
5860     static const Seconds timeToKeepSharedObjectPoolAliveAfterParsingFinished { 10_s };
5861     m_sharedObjectPoolClearTimer.startOneShot(timeToKeepSharedObjectPoolAliveAfterParsingFinished);
5862 
5863     // Parser should have picked up all speculative preloads by now
5864     m_cachedResourceLoader-&gt;clearPreloads(CachedResourceLoader::ClearPreloadsMode::ClearSpeculativePreloads);
<span class="line-added">5865 </span>
<span class="line-added">5866 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">5867     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {</span>
<span class="line-added">5868         // Stop queuing service worker client messages now that the DOMContentLoaded event has been fired.</span>
<span class="line-added">5869         if (auto* serviceWorkerContainer = this-&gt;serviceWorkerContainer())</span>
<span class="line-added">5870             serviceWorkerContainer-&gt;startMessages();</span>
<span class="line-added">5871     }</span>
<span class="line-added">5872 #endif</span>
5873 }
5874 
5875 void Document::clearSharedObjectPool()
5876 {
5877     m_sharedObjectPool = nullptr;
5878     m_sharedObjectPoolClearTimer.stop();
5879 }
5880 
5881 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
5882 
5883 // FIXME: Find a better place for this code.
5884 
5885 bool Document::isTelephoneNumberParsingEnabled() const
5886 {
5887     return settings().telephoneNumberParsingEnabled() &amp;&amp; m_isTelephoneNumberParsingAllowed;
5888 }
5889 
5890 bool Document::isTelephoneNumberParsingAllowed() const
5891 {
5892     return m_isTelephoneNumberParsingAllowed;
</pre>
<hr />
<pre>
5894 
5895 #endif
5896 
5897 String Document::originIdentifierForPasteboard() const
5898 {
5899     auto origin = securityOrigin().toString();
5900     if (origin != &quot;null&quot;)
5901         return origin;
5902     if (!m_uniqueIdentifier)
5903         m_uniqueIdentifier = &quot;null:&quot; + createCanonicalUUIDString();
5904     return m_uniqueIdentifier;
5905 }
5906 
5907 ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; Document::createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver)
5908 {
5909     if (!m_xpathEvaluator)
5910         m_xpathEvaluator = XPathEvaluator::create();
5911     return m_xpathEvaluator-&gt;createExpression(expression, WTFMove(resolver));
5912 }
5913 
<span class="line-modified">5914 Ref&lt;XPathNSResolver&gt; Document::createNSResolver(Node&amp; nodeResolver)</span>
5915 {
5916     if (!m_xpathEvaluator)
5917         m_xpathEvaluator = XPathEvaluator::create();
5918     return m_xpathEvaluator-&gt;createNSResolver(nodeResolver);
5919 }
5920 
<span class="line-modified">5921 ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; Document::evaluate(const String&amp; expression, Node&amp; contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp; resolver, unsigned short type, XPathResult* result)</span>
5922 {
5923     if (!m_xpathEvaluator)
5924         m_xpathEvaluator = XPathEvaluator::create();
5925     return m_xpathEvaluator-&gt;evaluate(expression, contextNode, WTFMove(resolver), type, result);
5926 }
5927 
5928 void Document::initSecurityContext()
5929 {
5930     if (haveInitializedSecurityOrigin()) {
5931         ASSERT(SecurityContext::securityOrigin());
5932         return;
5933     }
5934 
5935     if (!m_frame) {
5936         // No source for a security context.
5937         // This can occur via document.implementation.createDocument().
5938         setCookieURL(URL({ }, emptyString()));
5939         setSecurityOriginPolicy(SecurityOriginPolicy::create(SecurityOrigin::createUnique()));
5940         setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { { }, emptyString() }, *this));
5941         return;
5942     }
5943 
5944     // In the common case, create the security context from the currently
5945     // loading URL with a fresh content security policy.
5946     setCookieURL(m_url);
5947     enforceSandboxFlags(m_frame-&gt;loader().effectiveSandboxFlags());
5948     setReferrerPolicy(m_frame-&gt;loader().effectiveReferrerPolicy());
5949 
5950     if (shouldEnforceContentDispositionAttachmentSandbox())
5951         applyContentDispositionAttachmentSandbox();
5952 
5953     auto* documentLoader = m_frame-&gt;loader().documentLoader();
5954     bool isSecurityOriginUnique = isSandboxed(SandboxOrigin);
5955     if (!isSecurityOriginUnique)
5956         isSecurityOriginUnique = documentLoader &amp;&amp; documentLoader-&gt;response().tainting() == ResourceResponse::Tainting::Opaque;
5957 
5958     setSecurityOriginPolicy(SecurityOriginPolicy::create(isSecurityOriginUnique ? SecurityOrigin::createUnique() : SecurityOrigin::create(m_url)));
5959     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
5960 
<span class="line-added">5961     if (SecurityPolicy::allowSubstituteDataAccessToLocal()) {</span>
<span class="line-added">5962         // If this document was loaded with substituteData, then the document can</span>
<span class="line-added">5963         // load local resources.  See https://bugs.webkit.org/show_bug.cgi?id=16756</span>
<span class="line-added">5964         // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further</span>
<span class="line-added">5965         // discussion.</span>
<span class="line-added">5966 </span>
<span class="line-added">5967         // RT-17330: Need to use &quot;m_frame-&gt;loader()-&gt;documentLoader()&quot; instead</span>
<span class="line-added">5968         // of &quot;loader()&quot; as the latter returns NULL while the document is being</span>
<span class="line-added">5969         // constructed</span>
<span class="line-added">5970         // DocumentLoader* documentLoader = loader();</span>
<span class="line-added">5971         DocumentLoader* documentLoader = m_frame-&gt;loader().documentLoader();</span>
<span class="line-added">5972         if (documentLoader &amp;&amp; documentLoader-&gt;substituteData().isValid())</span>
<span class="line-added">5973             securityOrigin().grantLoadLocalResources();</span>
<span class="line-added">5974     }</span>
<span class="line-added">5975 </span>
5976     String overrideContentSecurityPolicy = m_frame-&gt;loader().client().overrideContentSecurityPolicy();
5977     if (!overrideContentSecurityPolicy.isNull())
5978         contentSecurityPolicy()-&gt;didReceiveHeader(overrideContentSecurityPolicy, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::API, referrer(), documentLoader ? documentLoader-&gt;response().httpStatusCode() : 0);
5979 
5980 #if USE(QUICK_LOOK)
5981     if (shouldEnforceQuickLookSandbox())
5982         applyQuickLookSandbox();
5983 #endif
5984 
5985     if (shouldEnforceHTTP09Sandbox()) {
5986         String message = makeString(&quot;Sandboxing &#39;&quot;, m_url.stringCenterEllipsizedToLength(), &quot;&#39; because it is using HTTP/0.9.&quot;);
5987         addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
5988         enforceSandboxFlags(SandboxScripts | SandboxPlugins);
5989     }
5990 
5991     if (settings().needsStorageAccessFromFileURLsQuirk())
5992         securityOrigin().grantStorageAccessFromFileURLsQuirk();
5993     if (!settings().webSecurityEnabled()) {
5994         // Web security is turned off. We should let this document access every other document. This is used primary by testing
5995         // harnesses for web sites.
</pre>
<hr />
<pre>
6015     if (parentDocument)
6016         setStrictMixedContentMode(parentDocument-&gt;isStrictMixedContentMode());
6017 
6018     if (!SecurityPolicy::shouldInheritSecurityOriginFromOwner(m_url))
6019         return;
6020 
6021     // If we do not obtain a meaningful origin from the URL, then we try to
6022     // find one via the frame hierarchy.
6023     Frame* parentFrame = m_frame-&gt;tree().parent();
6024     Frame* openerFrame = m_frame-&gt;loader().opener();
6025 
6026     Frame* ownerFrame = parentFrame;
6027     if (!ownerFrame)
6028         ownerFrame = openerFrame;
6029 
6030     if (!ownerFrame) {
6031         didFailToInitializeSecurityOrigin();
6032         return;
6033     }
6034 
<span class="line-modified">6035     contentSecurityPolicy()-&gt;copyStateFrom(ownerFrame-&gt;document()-&gt;contentSecurityPolicy());</span>
<span class="line-added">6036     contentSecurityPolicy()-&gt;updateSourceSelf(ownerFrame-&gt;document()-&gt;securityOrigin());</span>
6037 
6038     // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, new browsing contexts must inherit from an
6039     // ongoing set of upgraded requests. When opening a new browsing context, we need to capture its
6040     // existing upgrade request. Nested browsing contexts are handled during DocumentWriter::begin.
<span class="line-modified">6041     if (auto* openerDocument = openerFrame ? openerFrame-&gt;document() : nullptr)</span>
6042         contentSecurityPolicy()-&gt;inheritInsecureNavigationRequestsToUpgradeFromOpener(*openerDocument-&gt;contentSecurityPolicy());
6043 
6044     if (isSandboxed(SandboxOrigin)) {
6045         // If we&#39;re supposed to inherit our security origin from our owner,
6046         // but we&#39;re also sandboxed, the only thing we inherit is the ability
6047         // to load local resources. This lets about:blank iframes in file://
6048         // URL documents load images and other resources from the file system.
6049         if (ownerFrame-&gt;document()-&gt;securityOrigin().canLoadLocalResources())
6050             securityOrigin().grantLoadLocalResources();
6051         return;
6052     }
6053 
6054     setCookieURL(ownerFrame-&gt;document()-&gt;cookieURL());
6055     // We alias the SecurityOrigins to match Firefox, see Bug 15313
6056     // https://bugs.webkit.org/show_bug.cgi?id=15313
6057     setSecurityOriginPolicy(ownerFrame-&gt;document()-&gt;securityOriginPolicy());
6058 }
6059 
<span class="line-modified">6060 void Document::initContentSecurityPolicy()</span>

6061 {
<span class="line-modified">6062     auto* parentFrame = m_frame-&gt;tree().parent();</span>


















6063     if (parentFrame)
6064         contentSecurityPolicy()-&gt;copyUpgradeInsecureRequestStateFrom(*parentFrame-&gt;document()-&gt;contentSecurityPolicy());
6065 
<span class="line-modified">6066     // FIXME: Remove this special plugin document logic. We are stricter than the CSP 3 spec. with regards to plugins: we prefer to</span>
<span class="line-modified">6067     // inherit the full policy unless the plugin document is opened in a new window. The CSP 3 spec. implies that only plugin documents</span>
<span class="line-modified">6068     // delivered with a local scheme (e.g. blob, file, data) should inherit a policy.</span>
<span class="line-modified">6069     if (!isPluginDocument())</span>
<span class="line-modified">6070         return;</span>
<span class="line-modified">6071     auto* openerFrame = m_frame-&gt;loader().opener();</span>
<span class="line-modified">6072     bool shouldInhert = parentFrame || (openerFrame &amp;&amp; openerFrame-&gt;document()-&gt;securityOrigin().canAccess(securityOrigin()));</span>
<span class="line-modified">6073     if (!shouldInhert)</span>
<span class="line-modified">6074         return;</span>
<span class="line-modified">6075     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));</span>
<span class="line-modified">6076     if (openerFrame)</span>
<span class="line-modified">6077         contentSecurityPolicy()-&gt;createPolicyForPluginDocumentFrom(*openerFrame-&gt;document()-&gt;contentSecurityPolicy());</span>








6078     else
<span class="line-modified">6079         contentSecurityPolicy()-&gt;copyStateFrom(parentFrame-&gt;document()-&gt;contentSecurityPolicy());</span>
6080 }
6081 
6082 bool Document::isContextThread() const
6083 {
6084     return isMainThread();
6085 }
6086 
6087 bool Document::isSecureContext() const
6088 {
6089     if (!m_frame)
6090         return true;
6091     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
6092         return true;
6093     if (!securityOrigin().isPotentiallyTrustworthy())
6094         return false;
<span class="line-modified">6095     for (auto* frame = m_frame-&gt;tree().parent(); frame; frame = frame-&gt;tree().parent()) {</span>
6096         if (!frame-&gt;document()-&gt;securityOrigin().isPotentiallyTrustworthy())
6097             return false;
6098     }
<span class="line-added">6099     if (topOrigin().isUnique())</span>
<span class="line-added">6100         return false;</span>
6101     return true;
6102 }
6103 
6104 void Document::updateURLForPushOrReplaceState(const URL&amp; url)
6105 {
6106     Frame* f = frame();
6107     if (!f)
6108         return;
6109 
6110     setURL(url);
6111     f-&gt;loader().setOutgoingReferrer(url);
6112 
6113     if (DocumentLoader* documentLoader = loader())
6114         documentLoader-&gt;replaceRequestURLForSameDocumentNavigation(url);
6115 }
6116 
6117 void Document::statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6118 {
6119     if (!frame())
6120         return;
</pre>
<hr />
<pre>
6246     }
6247 
6248     if (Page* page = this-&gt;page())
6249         page-&gt;console().addMessage(WTFMove(consoleMessage));
6250 }
6251 
6252 void Document::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
6253 {
6254     if (!isContextThread()) {
6255         postTask(AddConsoleMessageTask(source, level, message));
6256         return;
6257     }
6258 
6259     if (Page* page = this-&gt;page())
6260         page-&gt;console().addMessage(source, level, message, requestIdentifier, this);
6261 
6262     if (m_consoleMessageListener)
6263         m_consoleMessageListener-&gt;scheduleCallback(*this, message);
6264 }
6265 
<span class="line-modified">6266 void Document::addMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)</span>
6267 {
6268     if (!isContextThread()) {
6269         postTask(AddConsoleMessageTask(source, level, message));
6270         return;
6271     }
6272 
6273     if (Page* page = this-&gt;page())
6274         page-&gt;console().addMessage(source, level, message, sourceURL, lineNumber, columnNumber, WTFMove(callStack), state, requestIdentifier);
6275 }
6276 
6277 void Document::postTask(Task&amp;&amp; task)
6278 {
6279     callOnMainThread([documentID = identifier(), task = WTFMove(task)]() mutable {
6280         ASSERT(isMainThread());
6281 
6282         auto* document = allDocumentsMap().get(documentID);
6283         if (!document)
6284             return;
6285 
6286         Page* page = document-&gt;page();
6287         if ((page &amp;&amp; page-&gt;defersLoading() &amp;&amp; document-&gt;activeDOMObjectsAreSuspended()) || !document-&gt;m_pendingTasks.isEmpty())
6288             document-&gt;m_pendingTasks.append(WTFMove(task));
6289         else
6290             task.performTask(*document);
6291     });
6292 }
6293 
6294 void Document::pendingTasksTimerFired()
6295 {
6296     Vector&lt;Task&gt; pendingTasks = WTFMove(m_pendingTasks);
6297     for (auto&amp; task : pendingTasks)
6298         task.performTask(*this);
6299 }
6300 
<span class="line-added">6301 EventLoopTaskGroup&amp; Document::eventLoop()</span>
<span class="line-added">6302 {</span>
<span class="line-added">6303     ASSERT(isMainThread());</span>
<span class="line-added">6304     if (UNLIKELY(!m_documentTaskGroup)) {</span>
<span class="line-added">6305         m_documentTaskGroup = makeUnique&lt;EventLoopTaskGroup&gt;(windowEventLoop());</span>
<span class="line-added">6306         if (activeDOMObjectsAreStopped())</span>
<span class="line-added">6307             m_documentTaskGroup-&gt;stopAndDiscardAllTasks();</span>
<span class="line-added">6308         else if (activeDOMObjectsAreSuspended())</span>
<span class="line-added">6309             m_documentTaskGroup-&gt;suspend();</span>
<span class="line-added">6310     }</span>
<span class="line-added">6311     return *m_documentTaskGroup;</span>
<span class="line-added">6312 }</span>
<span class="line-added">6313 </span>
<span class="line-added">6314 WindowEventLoop&amp; Document::windowEventLoop()</span>
<span class="line-added">6315 {</span>
<span class="line-added">6316     ASSERT(isMainThread());</span>
<span class="line-added">6317     if (UNLIKELY(!m_eventLoop))</span>
<span class="line-added">6318         m_eventLoop = WindowEventLoop::eventLoopForSecurityOrigin(securityOrigin());</span>
<span class="line-added">6319     return *m_eventLoop;</span>
<span class="line-added">6320 }</span>
<span class="line-added">6321 </span>
6322 void Document::suspendScheduledTasks(ReasonForSuspension reason)
6323 {
6324     if (m_scheduledTasksAreSuspended) {
6325         // A page may subsequently suspend DOM objects, say as part of handling a scroll or zoom gesture, after the
6326         // embedding client requested the page be suspended. We ignore such requests so long as the embedding client
6327         // requested the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
6328         ASSERT(reasonForSuspendingActiveDOMObjects() == ReasonForSuspension::PageWillBeSuspended);
6329         return;
6330     }
6331 
6332     suspendScriptedAnimationControllerCallbacks();
6333     suspendActiveDOMObjects(reason);
6334     scriptRunner().suspend();
6335     m_pendingTasksTimer.stop();
6336 
6337 #if ENABLE(XSLT)
6338     m_applyPendingXSLTransformsTimer.stop();
6339 #endif
6340 
6341     // Deferring loading and suspending parser is necessary when we need to prevent re-entrant JavaScript execution
</pre>
<hr />
<pre>
6369     resumeActiveDOMObjects(reason);
6370     resumeScriptedAnimationControllerCallbacks();
6371 
6372     m_scheduledTasksAreSuspended = false;
6373 }
6374 
6375 void Document::suspendScriptedAnimationControllerCallbacks()
6376 {
6377     if (m_scriptedAnimationController)
6378         m_scriptedAnimationController-&gt;suspend();
6379 }
6380 
6381 void Document::resumeScriptedAnimationControllerCallbacks()
6382 {
6383     if (m_scriptedAnimationController)
6384         m_scriptedAnimationController-&gt;resume();
6385 }
6386 
6387 void Document::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)
6388 {
<span class="line-modified">6389     ASSERT(!m_timelines.hasNullReferences());</span>
<span class="line-modified">6390 </span>
<span class="line-added">6391     // We need to copy m_timelines before iterating over its members since calling updateAnimationsAndSendEvents() may mutate m_timelines.</span>
<span class="line-added">6392     Vector&lt;RefPtr&lt;DocumentTimeline&gt;&gt; timelines;</span>
<span class="line-added">6393     bool shouldUpdateAnimations = false;</span>
<span class="line-added">6394     for (auto&amp; timeline : m_timelines) {</span>
<span class="line-added">6395         if (!shouldUpdateAnimations &amp;&amp; timeline.scheduledUpdate())</span>
<span class="line-added">6396             shouldUpdateAnimations = true;</span>
<span class="line-added">6397         timelines.append(&amp;timeline);</span>
<span class="line-added">6398     }</span>
<span class="line-added">6399 </span>
<span class="line-added">6400     for (auto&amp; timeline : timelines) {</span>
<span class="line-added">6401         timeline-&gt;updateCurrentTime(timestamp);</span>
<span class="line-added">6402         if (shouldUpdateAnimations)</span>
<span class="line-added">6403             timeline-&gt;updateAnimationsAndSendEvents();</span>
<span class="line-added">6404     }</span>
6405 }
6406 
6407 void Document::serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp)
6408 {
6409     if (m_scriptedAnimationController)
6410         m_scriptedAnimationController-&gt;serviceRequestAnimationFrameCallbacks(timestamp);
6411 }
6412 
6413 void Document::windowScreenDidChange(PlatformDisplayID displayID)
6414 {
6415     if (RenderView* view = renderView()) {
6416         if (view-&gt;usesCompositing())
6417             view-&gt;compositor().windowScreenDidChange(displayID);
6418     }
6419 }
6420 
6421 String Document::displayStringModifiedByEncoding(const String&amp; string) const
6422 {
6423     if (!m_decoder)
6424         return string;
6425     return String { string }.replace(&#39;\\&#39;, m_decoder-&gt;encoding().backslashAsCurrencySymbol());
6426 }
6427 
6428 void Document::dispatchPageshowEvent(PageshowEventPersistence persisted)
6429 {
6430     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=36334 Pageshow event needs to fire asynchronously.
6431     dispatchWindowEvent(PageTransitionEvent::create(eventNames().pageshowEvent, persisted), this);
6432 }
6433 
6434 void Document::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
6435 {
<span class="line-modified">6436     queueTaskToDispatchEvent(TaskSource::DOMManipulation, SecurityPolicyViolationEvent::create(eventNames().securitypolicyviolationEvent, WTFMove(eventInit), Event::IsTrusted::Yes));</span>
6437 }
6438 
6439 void Document::enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL)
6440 {
<span class="line-modified">6441     // FIXME: popstate event and hashchange event are supposed to fire in a single task.</span>
<span class="line-added">6442     queueTaskToDispatchEventOnWindow(TaskSource::DOMManipulation, HashChangeEvent::create(oldURL, newURL));</span>
6443 }
6444 
6445 void Document::dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject)
6446 {
6447     dispatchWindowEvent(PopStateEvent::create(WTFMove(stateObject), m_domWindow ? &amp;m_domWindow-&gt;history() : nullptr));
6448 }
6449 
6450 void Document::addMediaCanStartListener(MediaCanStartListener&amp; listener)
6451 {
6452     ASSERT(!m_mediaCanStartListeners.contains(&amp;listener));
6453     m_mediaCanStartListeners.add(&amp;listener);
6454 }
6455 
6456 void Document::removeMediaCanStartListener(MediaCanStartListener&amp; listener)
6457 {
6458     ASSERT(m_mediaCanStartListeners.contains(&amp;listener));
6459     m_mediaCanStartListeners.remove(&amp;listener);
6460 }
6461 
6462 MediaCanStartListener* Document::takeAnyMediaCanStartListener()
</pre>
<hr />
<pre>
6555     }
6556 
6557     return m_scriptedAnimationController-&gt;registerCallback(WTFMove(callback));
6558 }
6559 
6560 void Document::cancelAnimationFrame(int id)
6561 {
6562     if (!m_scriptedAnimationController)
6563         return;
6564     m_scriptedAnimationController-&gt;cancelCallback(id);
6565 }
6566 
6567 void Document::clearScriptedAnimationController()
6568 {
6569     // FIXME: consider using ActiveDOMObject.
6570     if (m_scriptedAnimationController)
6571         m_scriptedAnimationController-&gt;clearDocumentPointer();
6572     m_scriptedAnimationController = nullptr;
6573 }
6574 
<span class="line-added">6575 int Document::requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp; callback, Seconds timeout)</span>
<span class="line-added">6576 {</span>
<span class="line-added">6577     if (!m_idleCallbackController)</span>
<span class="line-added">6578         m_idleCallbackController = makeUnique&lt;IdleCallbackController&gt;(*this);</span>
<span class="line-added">6579     return m_idleCallbackController-&gt;queueIdleCallback(WTFMove(callback), timeout);</span>
<span class="line-added">6580 }</span>
<span class="line-added">6581 </span>
<span class="line-added">6582 void Document::cancelIdleCallback(int id)</span>
<span class="line-added">6583 {</span>
<span class="line-added">6584     if (!m_idleCallbackController)</span>
<span class="line-added">6585         return;</span>
<span class="line-added">6586     m_idleCallbackController-&gt;removeIdleCallback(id);</span>
<span class="line-added">6587 }</span>
<span class="line-added">6588 </span>
6589 void Document::wheelEventHandlersChanged()
6590 {
6591     Page* page = this-&gt;page();
6592     if (!page)
6593         return;
6594 
6595     if (FrameView* frameView = view()) {
6596         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
6597             scrollingCoordinator-&gt;frameViewEventTrackingRegionsChanged(*frameView);
6598     }
6599 
6600     bool haveHandlers = m_wheelEventTargets &amp;&amp; !m_wheelEventTargets-&gt;isEmpty();
6601     page-&gt;chrome().client().wheelEventHandlersChanged(haveHandlers);
6602 }
6603 
6604 void Document::didAddWheelEventHandler(Node&amp; node)
6605 {
6606     if (!m_wheelEventTargets)
6607         m_wheelEventTargets = makeUnique&lt;EventTargetSet&gt;();
6608 
</pre>
<hr />
<pre>
7075     return !styleScope().hasPendingSheets() || m_ignorePendingStylesheets;
7076 }
7077 
7078 Locale&amp; Document::getCachedLocale(const AtomString&amp; locale)
7079 {
7080     AtomString localeKey = locale;
7081     if (locale.isEmpty() || !settings().langAttributeAwareFormControlUIEnabled())
7082         localeKey = defaultLanguage();
7083     LocaleIdentifierToLocaleMap::AddResult result = m_localeCache.add(localeKey, nullptr);
7084     if (result.isNewEntry)
7085         result.iterator-&gt;value = Locale::create(localeKey);
7086     return *(result.iterator-&gt;value);
7087 }
7088 
7089 Document&amp; Document::ensureTemplateDocument()
7090 {
7091     if (const Document* document = templateDocument())
7092         return const_cast&lt;Document&amp;&gt;(*document);
7093 
7094     if (isHTMLDocument())
<span class="line-modified">7095         m_templateDocument = HTMLDocument::create(nullptr, WTF::blankURL());</span>
7096     else
<span class="line-modified">7097         m_templateDocument = create(WTF::blankURL());</span>
7098 
7099     m_templateDocument-&gt;setContextDocument(contextDocument());
7100     m_templateDocument-&gt;setTemplateDocumentHost(this); // balanced in dtor.
7101 
7102     return *m_templateDocument;
7103 }
7104 
7105 Ref&lt;FontFaceSet&gt; Document::fonts()
7106 {
7107     updateStyleIfNeeded();
7108     return fontSelector().fontFaceSet();
7109 }
7110 
7111 EditingBehavior Document::editingBehavior() const
7112 {
7113     return EditingBehavior { settings().editingBehaviorType() };
7114 }
7115 
7116 float Document::deviceScaleFactor() const
7117 {
</pre>
<hr />
<pre>
7167     if (auto* documentPage = page())
7168         return documentPage-&gt;useElevatedUserInterfaceLevel();
7169     return false;
7170 }
7171 
7172 OptionSet&lt;StyleColor::Options&gt; Document::styleColorOptions(const RenderStyle* style) const
7173 {
7174     OptionSet&lt;StyleColor::Options&gt; options;
7175     if (useSystemAppearance())
7176         options.add(StyleColor::Options::UseSystemAppearance);
7177     if (useDarkAppearance(style))
7178         options.add(StyleColor::Options::UseDarkAppearance);
7179     if (useElevatedUserInterfaceLevel())
7180         options.add(StyleColor::Options::UseElevatedUserInterfaceLevel);
7181     return options;
7182 }
7183 
7184 CompositeOperator Document::compositeOperatorForBackgroundColor(const Color&amp; color, const RenderObject&amp; renderer) const
7185 {
7186     if (LIKELY(!settings().punchOutWhiteBackgroundsInDarkMode() || !Color::isWhiteColor(color) || !renderer.useDarkAppearance()))
<span class="line-modified">7187         return CompositeOperator::SourceOver;</span>
7188 
7189     auto* frameView = view();
7190     if (!frameView)
<span class="line-modified">7191         return CompositeOperator::SourceOver;</span>
7192 
7193     // Mail on macOS uses a transparent view, and on iOS it is an opaque view. We need to
7194     // use different composite modes to get the right results in this case.
<span class="line-modified">7195     return frameView-&gt;isTransparent() ? CompositeOperator::DestinationOut : CompositeOperator::DestinationIn;</span>
7196 }
7197 
7198 void Document::didAssociateFormControl(Element&amp; element)
7199 {
7200     auto* page = this-&gt;page();
7201     if (!page || !page-&gt;chrome().client().shouldNotifyOnFormChanges())
7202         return;
7203     m_associatedFormControls.add(&amp;element);
7204     if (!m_didAssociateFormControlsTimer.isActive())
7205         m_didAssociateFormControlsTimer.startOneShot(0_s);
7206 }
7207 
7208 void Document::didAssociateFormControlsTimerFired()
7209 {
7210     auto vector = copyToVector(m_associatedFormControls);
7211     m_associatedFormControls.clear();
7212     if (auto* page = this-&gt;page()) {
7213         ASSERT(m_frame);
7214         page-&gt;chrome().client().didAssociateFormControls(vector, *m_frame);
7215     }
</pre>
<hr />
<pre>
7232 void Document::didLoadResourceSynchronously()
7233 {
7234     // Synchronous resources loading can set cookies so we invalidate the cookies cache
7235     // in this case, to be safe.
7236     invalidateDOMCookieCache();
7237 }
7238 
7239 void Document::ensurePlugInsInjectedScript(DOMWrapperWorld&amp; world)
7240 {
7241     if (m_hasInjectedPlugInsScript)
7242         return;
7243 
7244     auto&amp; scriptController = frame()-&gt;script();
7245 
7246     // Use the JS file provided by the Chrome client, or fallback to the default one.
7247     String jsString = page()-&gt;chrome().client().plugInExtraScript();
7248     if (!jsString || !scriptController.shouldAllowUserAgentScripts(*this))
7249         jsString = String(plugInsJavaScript, sizeof(plugInsJavaScript));
7250 
7251     setHasEvaluatedUserAgentScripts();
<span class="line-modified">7252     scriptController.evaluateInWorldIgnoringException(ScriptSourceCode(jsString), world);</span>
7253 
7254     m_hasInjectedPlugInsScript = true;
7255 }
7256 
7257 #if ENABLE(WEB_CRYPTO)
7258 
7259 bool Document::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
7260 {
7261     Page* page = this-&gt;page();
7262     if (!page)
7263         return false;
7264     return page-&gt;chrome().client().wrapCryptoKey(key, wrappedKey);
7265 }
7266 
7267 bool Document::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
7268 {
7269     Page* page = this-&gt;page();
7270     if (!page)
7271         return false;
7272     return page-&gt;chrome().client().unwrapCryptoKey(wrappedKey, key);
</pre>
<hr />
<pre>
7369 }
7370 
7371 void Document::setPlaybackTarget(uint64_t clientId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
7372 {
7373     auto it = m_idToClientMap.find(clientId);
7374     if (it == m_idToClientMap.end())
7375         return;
7376 
7377     it-&gt;value-&gt;setPlaybackTarget(target.copyRef());
7378 }
7379 
7380 void Document::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
7381 {
7382     auto it = m_idToClientMap.find(clientId);
7383     if (it == m_idToClientMap.end())
7384         return;
7385 
7386     it-&gt;value-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
7387 }
7388 
<span class="line-added">7389 void Document::playbackTargetPickerWasDismissed(uint64_t clientId)</span>
<span class="line-added">7390 {</span>
<span class="line-added">7391     auto it = m_idToClientMap.find(clientId);</span>
<span class="line-added">7392     if (it == m_idToClientMap.end())</span>
<span class="line-added">7393         return;</span>
<span class="line-added">7394 </span>
<span class="line-added">7395     it-&gt;value-&gt;playbackTargetPickerWasDismissed();</span>
<span class="line-added">7396 }</span>
<span class="line-added">7397 </span>
7398 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
7399 
7400 #if ENABLE(MEDIA_SESSION)
7401 
7402 MediaSession&amp; Document::defaultMediaSession()
7403 {
7404     if (!m_defaultMediaSession)
7405         m_defaultMediaSession = MediaSession::create(*scriptExecutionContext());
7406     return *m_defaultMediaSession;
7407 }
7408 
7409 #endif
7410 
7411 ShouldOpenExternalURLsPolicy Document::shouldOpenExternalURLsPolicyToPropagate() const
7412 {
7413     if (DocumentLoader* documentLoader = loader())
7414         return documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate();
7415 
7416     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
7417 }
7418 
7419 bool Document::shouldEnforceHTTP09Sandbox() const
7420 {
7421     if (m_isSynthesized || !m_frame)
7422         return false;
7423     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7424     return documentLoader &amp;&amp; documentLoader-&gt;response().isHTTP09();
7425 }
7426 
7427 #if USE(QUICK_LOOK)
<span class="line-added">7428 </span>
7429 bool Document::shouldEnforceQuickLookSandbox() const
7430 {
7431     if (m_isSynthesized || !m_frame)
7432         return false;
7433     DocumentLoader* documentLoader = m_frame-&gt;loader().activeDocumentLoader();
7434     return documentLoader &amp;&amp; documentLoader-&gt;response().isQuickLook();
7435 }
7436 
7437 void Document::applyQuickLookSandbox()
7438 {
7439     auto&amp; documentLoader = *m_frame-&gt;loader().activeDocumentLoader();
7440     auto documentURL = documentLoader.documentURL();
7441     auto&amp; responseURL = documentLoader.responseURL();
7442     ASSERT(!documentURL.protocolIs(QLPreviewProtocol));
7443     ASSERT(responseURL.protocolIs(QLPreviewProtocol));
7444 
7445     auto securityOrigin = SecurityOrigin::createNonLocalWithAllowedFilePath(responseURL, documentURL.fileSystemPath());
7446     securityOrigin-&gt;setStorageBlockingPolicy(SecurityOrigin::BlockAllStorage);
7447     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(securityOrigin)));
7448 
7449     static NeverDestroyed&lt;String&gt; quickLookCSP = makeString(&quot;default-src &quot;, QLPreviewProtocol, &quot;: &#39;unsafe-inline&#39;; base-uri &#39;none&#39;; sandbox allow-same-origin allow-scripts&quot;);
7450     RELEASE_ASSERT(contentSecurityPolicy());
7451     // The sandbox directive is only allowed if the policy is from an HTTP header.
7452     contentSecurityPolicy()-&gt;didReceiveHeader(quickLookCSP, ContentSecurityPolicyHeaderType::Enforce, ContentSecurityPolicy::PolicyFrom::HTTPHeader, referrer());
7453 
7454     disableSandboxFlags(SandboxNavigation);
7455 
7456     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7457 }
<span class="line-added">7458 </span>
7459 #endif
7460 
7461 bool Document::shouldEnforceContentDispositionAttachmentSandbox() const
7462 {
7463     if (!settings().contentDispositionAttachmentSandboxEnabled())
7464         return false;
7465 
7466     if (m_isSynthesized)
7467         return false;
7468 
7469     if (auto* documentLoader = m_frame ? m_frame-&gt;loader().activeDocumentLoader() : nullptr)
7470         return documentLoader-&gt;response().isAttachment();
7471     return false;
7472 }
7473 
7474 void Document::applyContentDispositionAttachmentSandbox()
7475 {
7476     ASSERT(shouldEnforceContentDispositionAttachmentSandbox());
7477 
7478     setReferrerPolicy(ReferrerPolicy::NoReferrer);
7479     if (!isMediaDocument())
7480         enforceSandboxFlags(SandboxAll);
7481     else
7482         enforceSandboxFlags(SandboxOrigin);
7483 }
7484 
<span class="line-modified">7485 void Document::addDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)</span>





7486 {
<span class="line-modified">7487     m_dynamicMediaQueryDependentImages.add(element);</span>
7488 }
7489 
<span class="line-modified">7490 void Document::removeDynamicMediaQueryDependentImage(HTMLImageElement&amp; element)</span>
7491 {
<span class="line-modified">7492     m_dynamicMediaQueryDependentImages.remove(element);</span>





7493 }
7494 
7495 void Document::scheduleTimedRenderingUpdate()
7496 {
7497 #if ENABLE(INTERSECTION_OBSERVER)
7498     m_intersectionObserversInitialUpdateTimer.stop();
7499 #endif
7500     if (auto page = this-&gt;page())
7501         page-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
7502 }
7503 
7504 #if ENABLE(INTERSECTION_OBSERVER)
<span class="line-added">7505 </span>
7506 void Document::addIntersectionObserver(IntersectionObserver&amp; observer)
7507 {
7508     ASSERT(m_intersectionObservers.find(&amp;observer) == notFound);
7509     m_intersectionObservers.append(makeWeakPtr(&amp;observer));
7510 }
7511 
7512 void Document::removeIntersectionObserver(IntersectionObserver&amp; observer)
7513 {
7514     m_intersectionObservers.removeFirst(&amp;observer);
7515 }
7516 
7517 static void expandRootBoundsWithRootMargin(FloatRect&amp; localRootBounds, const LengthBox&amp; rootMargin)
7518 {
7519     FloatBoxExtent rootMarginFloatBox(
7520         floatValueForLength(rootMargin.top(), localRootBounds.height()),
7521         floatValueForLength(rootMargin.right(), localRootBounds.width()),
7522         floatValueForLength(rootMargin.bottom(), localRootBounds.height()),
7523         floatValueForLength(rootMargin.left(), localRootBounds.width())
7524     );
7525 
</pre>
<hr />
<pre>
7594     else if (is&lt;RenderInline&gt;(targetRenderer)) {
7595         auto pair = target.boundingAbsoluteRectWithoutLayout();
7596         if (pair) {
7597             FloatRect absoluteTargetBounds = pair-&gt;second;
7598             localTargetBounds = enclosingLayoutRect(targetRenderer-&gt;absoluteToLocalQuad(absoluteTargetBounds).boundingBox());
7599         }
7600     } else if (is&lt;RenderLineBreak&gt;(targetRenderer))
7601         localTargetBounds = downcast&lt;RenderLineBreak&gt;(targetRenderer)-&gt;linesBoundingBox();
7602 
7603     Optional&lt;LayoutRect&gt; rootLocalTargetRect;
7604     if (observer.root()) {
7605         OptionSet&lt;RenderObject::VisibleRectContextOption&gt; visibleRectOptions = { RenderObject::VisibleRectContextOption::UseEdgeInclusiveIntersection, RenderObject::VisibleRectContextOption::ApplyCompositedClips, RenderObject::VisibleRectContextOption::ApplyCompositedContainerScrolls };
7606         rootLocalTargetRect = targetRenderer-&gt;computeVisibleRectInContainer(localTargetBounds, rootRenderer, { false /* hasPositionFixedDescendant */, false /* dirtyRectIsFlipped */, visibleRectOptions });
7607     } else
7608         rootLocalTargetRect = computeClippedRectInRootContentsSpace(localTargetBounds, targetRenderer);
7609 
7610     FloatRect rootLocalIntersectionRect = localRootBounds;
7611 
7612     IntersectionObservationState intersectionState;
7613     intersectionState.isIntersecting = rootLocalTargetRect &amp;&amp; rootLocalIntersectionRect.edgeInclusiveIntersect(*rootLocalTargetRect);
<span class="line-added">7614     intersectionState.absoluteTargetRect = targetRenderer-&gt;localToAbsoluteQuad(FloatRect(localTargetBounds)).boundingBox();</span>
<span class="line-added">7615     intersectionState.absoluteRootBounds = rootRenderer-&gt;localToAbsoluteQuad(localRootBounds).boundingBox();</span>
7616 
7617     if (intersectionState.isIntersecting) {
7618         FloatRect rootAbsoluteIntersectionRect = rootRenderer-&gt;localToAbsoluteQuad(rootLocalIntersectionRect).boundingBox();
7619         if (&amp;targetRenderer-&gt;frame() == &amp;rootRenderer-&gt;frame())
7620             intersectionState.absoluteIntersectionRect = rootAbsoluteIntersectionRect;
7621         else {
7622             FloatRect rootViewIntersectionRect = frameView.contentsToView(rootAbsoluteIntersectionRect);
7623             intersectionState.absoluteIntersectionRect = targetRenderer-&gt;view().frameView().rootViewToContents(rootViewIntersectionRect);
7624         }
<span class="line-added">7625         intersectionState.isIntersecting = intersectionState.absoluteIntersectionRect.edgeInclusiveIntersect(intersectionState.absoluteTargetRect);</span>
7626     }
7627 


7628     return intersectionState;
7629 }
7630 
7631 void Document::updateIntersectionObservations()
7632 {
7633     auto* frameView = view();
7634     if (!frameView)
7635         return;
7636 
7637     m_intersectionObserversInitialUpdateTimer.stop();
7638 
7639     bool needsLayout = frameView-&gt;layoutContext().isLayoutPending() || (renderView() &amp;&amp; renderView()-&gt;needsLayout());
7640     if (needsLayout || hasPendingStyleRecalc())
7641         return;
7642 
7643     for (const auto&amp; observer : m_intersectionObservers) {
7644         bool needNotify = false;
7645         DOMHighResTimeStamp timestamp;
7646         if (!observer-&gt;createTimestamp(timestamp))
7647             continue;
</pre>
<hr />
<pre>
7715     if (m_intersectionObserversWithPendingNotifications.size())
7716         m_intersectionObserversNotifyTimer.startOneShot(0_s);
7717 }
7718 
7719 void Document::notifyIntersectionObserversTimerFired()
7720 {
7721     for (const auto&amp; observer : m_intersectionObserversWithPendingNotifications) {
7722         if (observer)
7723             observer-&gt;notify();
7724     }
7725     m_intersectionObserversWithPendingNotifications.clear();
7726 }
7727 
7728 void Document::scheduleInitialIntersectionObservationUpdate()
7729 {
7730     if (m_readyState == Complete)
7731         scheduleTimedRenderingUpdate();
7732     else if (!m_intersectionObserversInitialUpdateTimer.isActive())
7733         m_intersectionObserversInitialUpdateTimer.startOneShot(intersectionObserversInitialUpdateDelay);
7734 }
<span class="line-added">7735 </span>
7736 #endif
7737 
7738 #if ENABLE(RESIZE_OBSERVER)
<span class="line-added">7739 </span>
7740 void Document::addResizeObserver(ResizeObserver&amp; observer)
7741 {
7742     if (!m_resizeObservers.contains(&amp;observer))
7743         m_resizeObservers.append(makeWeakPtr(&amp;observer));
7744 }
7745 
7746 void Document::removeResizeObserver(ResizeObserver&amp; observer)
7747 {
7748     m_resizeObservers.removeFirst(&amp;observer);
7749 }
7750 
7751 bool Document::hasResizeObservers()
7752 {
7753     return !m_resizeObservers.isEmpty();
7754 }
7755 
7756 size_t Document::gatherResizeObservations(size_t deeperThan)
7757 {
7758     size_t minDepth = ResizeObserver::maxElementDepth();
7759     for (const auto&amp; observer : m_resizeObservers) {
</pre>
<hr />
<pre>
7799     // and it could change other frame in deliverResizeObservations().
7800     page.layoutIfNeeded();
7801 
7802     // Start check resize obervers;
7803     for (size_t depth = gatherResizeObservations(0); depth != ResizeObserver::maxElementDepth(); depth = gatherResizeObservations(depth)) {
7804         deliverResizeObservations();
7805         page.layoutIfNeeded();
7806     }
7807 
7808     if (hasSkippedResizeObservations()) {
7809         setHasSkippedResizeObservations(false);
7810         String url;
7811         unsigned line = 0;
7812         unsigned column = 0;
7813         getParserLocation(url, line, column);
7814         reportException(&quot;ResizeObserver loop completed with undelivered notifications.&quot;, line, column, url, nullptr, nullptr);
7815         // Starting a new schedule the next round of notify.
7816         scheduleTimedRenderingUpdate();
7817     }
7818 }
<span class="line-added">7819 </span>
7820 #endif
7821 
7822 const AtomString&amp; Document::dir() const
7823 {
7824     auto* documentElement = this-&gt;documentElement();
7825     if (!is&lt;HTMLHtmlElement&gt;(documentElement))
7826         return nullAtom();
7827     return downcast&lt;HTMLHtmlElement&gt;(*documentElement).dir();
7828 }
7829 
7830 void Document::setDir(const AtomString&amp; value)
7831 {
7832     auto* documentElement = this-&gt;documentElement();
7833     if (is&lt;HTMLHtmlElement&gt;(documentElement))
7834         downcast&lt;HTMLHtmlElement&gt;(*documentElement).setDir(value);
7835 }
7836 
7837 DOMSelection* Document::getSelection()
7838 {
7839     return m_domWindow ? m_domWindow-&gt;getSelection() : nullptr;
</pre>
<hr />
<pre>
7842 void Document::didInsertInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7843 {
7844     ASSERT(shadowRoot.isConnected());
7845     ASSERT(!m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7846     m_inDocumentShadowRoots.add(&amp;shadowRoot);
7847 }
7848 
7849 void Document::didRemoveInDocumentShadowRoot(ShadowRoot&amp; shadowRoot)
7850 {
7851     ASSERT(m_inDocumentShadowRoots.contains(&amp;shadowRoot));
7852     m_inDocumentShadowRoots.remove(&amp;shadowRoot);
7853 }
7854 
7855 void Document::orientationChanged(int orientation)
7856 {
7857     LOG(Events, &quot;Document %p orientationChanged - orientation %d&quot;, this, orientation);
7858     dispatchWindowEvent(Event::create(eventNames().orientationchangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
7859     m_orientationNotifier.orientationChanged(orientation);
7860 }
7861 


7862 #if ENABLE(MEDIA_STREAM)


7863 





7864 void Document::stopMediaCapture()
7865 {
7866     MediaStreamTrack::endCapture(*this);
7867 }
7868 










7869 void Document::mediaStreamCaptureStateChanged()
7870 {
7871     if (!MediaProducer::isCapturing(m_mediaState))
7872         return;
7873 
<span class="line-modified">7874     forEachMediaElement([] (HTMLMediaElement&amp; element) {</span>
<span class="line-modified">7875         element.mediaStreamCaptureStarted();</span>
<span class="line-added">7876     });</span>
7877 }
7878 
7879 void Document::setDeviceIDHashSalt(const String&amp; salt)
7880 {
7881     ASSERT(m_idHashSalt.isEmpty() || m_idHashSalt == salt);
7882     m_idHashSalt = salt;
7883 }
7884 
7885 #endif
7886 
















7887 const AtomString&amp; Document::bgColor() const
7888 {
7889     auto* bodyElement = body();
7890     if (!bodyElement)
7891         return emptyAtom();
7892     return bodyElement-&gt;attributeWithoutSynchronization(bgcolorAttr);
7893 }
7894 
7895 void Document::setBgColor(const String&amp; value)
7896 {
7897     if (auto* bodyElement = body())
7898         bodyElement-&gt;setAttributeWithoutSynchronization(bgcolorAttr, value);
7899 }
7900 
7901 const AtomString&amp; Document::fgColor() const
7902 {
7903     auto* bodyElement = body();
7904     if (!bodyElement)
7905         return emptyAtom();
7906     return bodyElement-&gt;attributeWithoutSynchronization(textAttr);
</pre>
<hr />
<pre>
7941 }
7942 
7943 const AtomString&amp; Document::vlinkColor() const
7944 {
7945     auto* bodyElement = body();
7946     if (!bodyElement)
7947         return emptyAtom();
7948     return bodyElement-&gt;attributeWithoutSynchronization(vlinkAttr);
7949 }
7950 
7951 void Document::setVlinkColor(const String&amp; value)
7952 {
7953     if (auto* bodyElement = body())
7954         bodyElement-&gt;setAttributeWithoutSynchronization(vlinkAttr, value);
7955 }
7956 
7957 Logger&amp; Document::logger()
7958 {
7959     if (!m_logger) {
7960         m_logger = Logger::create(this);
<span class="line-modified">7961         auto* page = this-&gt;page();</span>
<span class="line-added">7962         m_logger-&gt;setEnabled(this, page &amp;&amp; page-&gt;sessionID().isAlwaysOnLoggingAllowed());</span>
7963         m_logger-&gt;addObserver(*this);
7964     }
7965 
7966     return *m_logger;
7967 }
7968 
7969 Optional&lt;PageIdentifier&gt; Document::pageID() const
7970 {
7971     return m_frame-&gt;loader().client().pageID();
7972 }
7973 
7974 void Document::registerArticleElement(Element&amp; article)
7975 {
7976     m_articleElements.add(&amp;article);
7977 }
7978 
7979 void Document::unregisterArticleElement(Element&amp; article)
7980 {
7981     m_articleElements.remove(&amp;article);
7982     if (m_mainArticleElement == &amp;article)
</pre>
<hr />
<pre>
8068 
8069     StringBuilder builder;
8070     builder.append(referrerURL.protocol());
8071     builder.appendLiteral(&quot;://&quot;);
8072     builder.append(referrerRegistrableDomainStr);
8073     if (referrerPort) {
8074         builder.append(&#39;:&#39;);
8075         builder.appendNumber(*referrerPort);
8076     }
8077     builder.append(&#39;/&#39;);
8078 
8079     m_referrerOverride = builder.toString();
8080 }
8081 #endif
8082 
8083 void Document::setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp; listener)
8084 {
8085     m_consoleMessageListener = listener;
8086 }
8087 
<span class="line-added">8088 void Document::addTimeline(DocumentTimeline&amp; timeline)</span>
<span class="line-added">8089 {</span>
<span class="line-added">8090     m_timelines.add(timeline);</span>
<span class="line-added">8091 }</span>
<span class="line-added">8092 </span>
<span class="line-added">8093 void Document::removeTimeline(DocumentTimeline&amp; timeline)</span>
<span class="line-added">8094 {</span>
<span class="line-added">8095     m_timelines.remove(timeline);</span>
<span class="line-added">8096 }</span>
<span class="line-added">8097 </span>
8098 DocumentTimeline&amp; Document::timeline()
8099 {
8100     if (!m_timeline)
8101         m_timeline = DocumentTimeline::create(*this);
8102 
8103     return *m_timeline;
8104 }
8105 
8106 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; Document::getAnimations()
8107 {
8108     // For the list of animations to be current, we need to account for any pending CSS changes,
8109     // such as updates to CSS Animations and CSS Transitions.
8110     updateStyleIfNeeded();
8111 
8112     if (m_timeline)
8113         return m_timeline-&gt;getAnimations();
8114     return { };
8115 }
8116 
8117 #if ENABLE(ATTACHMENT_ELEMENT)
</pre>
<hr />
<pre>
8201     ASSERT_NOT_REACHED();
8202     return MessageLevel::Log;
8203 }
8204 
8205 static inline Vector&lt;JSONLogValue&gt; crossThreadCopy(Vector&lt;JSONLogValue&gt;&amp;&amp; source)
8206 {
8207     auto values = WTFMove(source);
8208     for (auto&amp; value : values)
8209         value.value = crossThreadCopy(WTFMove(value.value));
8210     return values;
8211 }
8212 
8213 void Document::didLogMessage(const WTFLogChannel&amp; channel, WTFLogLevel level, Vector&lt;JSONLogValue&gt;&amp;&amp; logMessages)
8214 {
8215     if (!isMainThread()) {
8216         postTask([this, channel, level, logMessages = crossThreadCopy(WTFMove(logMessages))](auto&amp;) mutable {
8217             didLogMessage(channel, level, WTFMove(logMessages));
8218         });
8219         return;
8220     }
<span class="line-modified">8221     auto* page = this-&gt;page();</span>
<span class="line-added">8222     if (!page)</span>
8223         return;
8224 
<span class="line-modified">8225     ASSERT(page-&gt;sessionID().isAlwaysOnLoggingAllowed());</span>
8226 
8227     auto messageSource = messageSourceForWTFLogChannel(channel);
8228     if (messageSource == MessageSource::Other)
8229         return;
8230 
8231     m_logMessageTaskQueue.enqueueTask([this, level, messageSource, logMessages = WTFMove(logMessages)]() mutable {
<span class="line-modified">8232         if (!this-&gt;page())</span>
8233             return;
8234 
8235         auto messageLevel = messageLevelFromWTFLogLevel(level);
8236         auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(messageSource, MessageType::Log, messageLevel, WTFMove(logMessages), mainWorldExecState(frame()));
8237 
8238         addConsoleMessage(WTFMove(message));
8239     });
8240 }
8241 
8242 #if ENABLE(SERVICE_WORKER)
8243 void Document::setServiceWorkerConnection(SWClientConnection* serviceWorkerConnection)
8244 {
8245     if (m_serviceWorkerConnection == serviceWorkerConnection || m_hasPreparedForDestruction || m_isSuspended)
8246         return;
8247 
8248     if (m_serviceWorkerConnection)
8249         m_serviceWorkerConnection-&gt;unregisterServiceWorkerClient(identifier());
8250 
8251     m_serviceWorkerConnection = serviceWorkerConnection;
8252 
</pre>
<hr />
<pre>
8286         return;
8287 
8288     if (auto* window = domWindow())
8289         window-&gt;willDetachDocumentFromFrame();
8290 
8291     detachFromFrame();
8292 }
8293 
8294 bool Document::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
8295 {
8296     return hitTest(request, result.hitTestLocation(), result);
8297 }
8298 
8299 bool Document::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; location, HitTestResult&amp; result)
8300 {
8301     Ref&lt;Document&gt; protectedThis(*this);
8302     updateLayout();
8303     if (!renderView())
8304         return false;
8305 
<span class="line-modified">8306 #if ASSERT_ENABLED</span>
8307     SetForScope&lt;bool&gt; hitTestRestorer { m_inHitTesting, true };
8308 #endif
8309 
8310     auto&amp; frameView = renderView()-&gt;frameView();
8311     Ref&lt;FrameView&gt; protector(frameView);
8312 
8313     FrameFlatteningLayoutDisallower disallower(frameView);
8314 
8315     bool resultLayer = renderView()-&gt;layer()-&gt;hitTest(request, location, result);
8316 
8317     // ScrollView scrollbars are not the same as RenderLayer scrollbars tested by RenderLayer::hitTestOverflowControls,
8318     // so we need to test ScrollView scrollbars separately here. In case of using overlay scrollbars, the layer hit test
8319     // will always work so we need to check the ScrollView scrollbars in that case too.
8320     if (!resultLayer || ScrollbarTheme::theme().usesOverlayScrollbars()) {
8321         // FIXME: Consider if this test should be done unconditionally.
8322         if (request.allowsFrameScrollbars()) {
8323             IntPoint windowPoint = frameView.contentsToWindow(location.roundedPoint());
8324             if (auto* frameScrollbar = frameView.scrollbarAtPoint(windowPoint)) {
8325                 result.setScrollbar(frameScrollbar);
8326                 return true;
</pre>
<hr />
<pre>
8420 }
8421 
8422 void Document::setAsRunningUserScripts()
8423 {
8424     auto&amp; top = topDocument();
8425     if (this == &amp;top)
8426         m_isRunningUserScripts = true;
8427     else
8428         top.setAsRunningUserScripts();
8429 }
8430 
8431 void Document::setHasEvaluatedUserAgentScripts()
8432 {
8433     auto&amp; top = topDocument();
8434     if (this == &amp;top)
8435         m_hasEvaluatedUserAgentScripts = true;
8436     else
8437         top.setHasEvaluatedUserAgentScripts();
8438 }
8439 
<span class="line-added">8440 void Document::didRejectSyncXHRDuringPageDismissal()</span>
<span class="line-added">8441 {</span>
<span class="line-added">8442     ++m_numberOfRejectedSyncXHRs;</span>
<span class="line-added">8443     if (m_numberOfRejectedSyncXHRs &gt; 1)</span>
<span class="line-added">8444         return;</span>
<span class="line-added">8445 </span>
<span class="line-added">8446     postTask([this, weakThis = makeWeakPtr(*this)](auto&amp;) mutable {</span>
<span class="line-added">8447         if (weakThis)</span>
<span class="line-added">8448             m_numberOfRejectedSyncXHRs = 0;</span>
<span class="line-added">8449     });</span>
<span class="line-added">8450 }</span>
<span class="line-added">8451 </span>
<span class="line-added">8452 bool Document::shouldIgnoreSyncXHRs() const</span>
<span class="line-added">8453 {</span>
<span class="line-added">8454     const unsigned maxRejectedSyncXHRsPerEventLoopIteration = 5;</span>
<span class="line-added">8455     return m_numberOfRejectedSyncXHRs &gt; maxRejectedSyncXHRsPerEventLoopIteration;</span>
<span class="line-added">8456 }</span>
<span class="line-added">8457 </span>
8458 #if ENABLE(APPLE_PAY)
8459 
8460 bool Document::isApplePayActive() const
8461 {
8462     auto&amp; top = topDocument();
8463     return this == &amp;top ? m_hasStartedApplePaySession : top.isApplePayActive();
8464 }
8465 
8466 void Document::setApplePayIsActive()
8467 {
8468     auto&amp; top = topDocument();
8469     if (this == &amp;top)
8470         m_hasStartedApplePaySession = true;
8471     else
8472         top.setApplePayIsActive();
8473 }
8474 
8475 #endif
8476 
<span class="line-added">8477 MessagePortChannelProvider&amp; Document::messagePortChannelProvider()</span>
<span class="line-added">8478 {</span>
<span class="line-added">8479     return MessagePortChannelProvider::singleton();</span>
<span class="line-added">8480 }</span>
<span class="line-added">8481 </span>
<span class="line-added">8482 #if USE(SYSTEM_PREVIEW)</span>
<span class="line-added">8483 void Document::dispatchSystemPreviewActionEvent(const SystemPreviewInfo&amp; systemPreviewInfo, const String&amp; message)</span>
<span class="line-added">8484 {</span>
<span class="line-added">8485     auto* element = searchForElementByIdentifier(systemPreviewInfo.element.elementIdentifier);</span>
<span class="line-added">8486     if (!element)</span>
<span class="line-added">8487         return;</span>
<span class="line-added">8488 </span>
<span class="line-added">8489     if (!is&lt;HTMLAnchorElement&gt;(element))</span>
<span class="line-added">8490         return;</span>
<span class="line-added">8491 </span>
<span class="line-added">8492     auto event = MessageEvent::create(message, securityOrigin().toString());</span>
<span class="line-added">8493     UserGestureIndicator gestureIndicator(ProcessingUserGesture, this);</span>
<span class="line-added">8494     element-&gt;dispatchEvent(event);</span>
<span class="line-added">8495 }</span>
<span class="line-added">8496 #endif</span>
<span class="line-added">8497 </span>
<span class="line-added">8498 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">8499 HTMLVideoElement* Document::pictureInPictureElement() const</span>
<span class="line-added">8500 {</span>
<span class="line-added">8501     return m_pictureInPictureElement.get();</span>
<span class="line-added">8502 };</span>
<span class="line-added">8503 </span>
<span class="line-added">8504 void Document::setPictureInPictureElement(HTMLVideoElement* element)</span>
<span class="line-added">8505 {</span>
<span class="line-added">8506     m_pictureInPictureElement = makeWeakPtr(element);</span>
<span class="line-added">8507 }</span>
<span class="line-added">8508 #endif</span>
<span class="line-added">8509 </span>
<span class="line-added">8510 TextManipulationController&amp; Document::textManipulationController()</span>
<span class="line-added">8511 {</span>
<span class="line-added">8512     if (!m_textManipulationController)</span>
<span class="line-added">8513         m_textManipulationController = makeUnique&lt;TextManipulationController&gt;(*this);</span>
<span class="line-added">8514     return *m_textManipulationController;</span>
<span class="line-added">8515 }</span>
<span class="line-added">8516 </span>
8517 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DeviceOrientationOrMotionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
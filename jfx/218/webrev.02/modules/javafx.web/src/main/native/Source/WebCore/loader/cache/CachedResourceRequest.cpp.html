<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Google, Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CachedResourceRequest.h&quot;
 28 
 29 #include &quot;CachedResourceLoader.h&quot;
 30 #include &quot;ContentExtensionActions.h&quot;
 31 #include &quot;CrossOriginAccessControl.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;Element.h&quot;
 34 #include &quot;FrameLoader.h&quot;
 35 #include &quot;HTTPHeaderValues.h&quot;
 36 #include &quot;ImageDecoder.h&quot;
 37 #include &quot;MemoryCache.h&quot;
 38 #include &quot;ServiceWorkerRegistrationData.h&quot;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 CachedResourceRequest::CachedResourceRequest(ResourceRequest&amp;&amp; resourceRequest, const ResourceLoaderOptions&amp; options, Optional&lt;ResourceLoadPriority&gt; priority, String&amp;&amp; charset)
 44     : m_resourceRequest(WTFMove(resourceRequest))
 45     , m_charset(WTFMove(charset))
 46     , m_options(options)
 47     , m_priority(priority)
 48     , m_fragmentIdentifier(splitFragmentIdentifierFromRequestURL(m_resourceRequest))
 49 {
 50 }
 51 
 52 String CachedResourceRequest::splitFragmentIdentifierFromRequestURL(ResourceRequest&amp; request)
 53 {
 54     if (!MemoryCache::shouldRemoveFragmentIdentifier(request.url()))
 55         return { };
 56     URL url = request.url();
 57     String fragmentIdentifier = url.fragmentIdentifier();
 58     url.removeFragmentIdentifier();
 59     request.setURL(url);
 60     return fragmentIdentifier;
 61 }
 62 
 63 void CachedResourceRequest::setInitiator(Element&amp; element)
 64 {
 65     ASSERT(!m_initiatorElement);
 66     ASSERT(m_initiatorName.isEmpty());
 67     m_initiatorElement = &amp;element;
 68 }
 69 
 70 void CachedResourceRequest::setInitiator(const AtomString&amp; name)
 71 {
 72     ASSERT(!m_initiatorElement);
 73     ASSERT(m_initiatorName.isEmpty());
 74     m_initiatorName = name;
 75 }
 76 
 77 const AtomString&amp; CachedResourceRequest::initiatorName() const
 78 {
 79     if (m_initiatorElement)
 80         return m_initiatorElement-&gt;localName();
 81     if (!m_initiatorName.isEmpty())
 82         return m_initiatorName;
 83 
 84     static NeverDestroyed&lt;AtomString&gt; defaultName(&quot;other&quot;, AtomString::ConstructFromLiteral);
 85     return defaultName;
 86 }
 87 
 88 void CachedResourceRequest::updateForAccessControl(Document&amp; document)
 89 {
 90     ASSERT(m_options.mode == FetchOptions::Mode::Cors);
 91 
 92     m_origin = &amp;document.securityOrigin();
 93     updateRequestForAccessControl(m_resourceRequest, *m_origin, m_options.storedCredentialsPolicy);
 94 }
 95 
 96 void upgradeInsecureResourceRequestIfNeeded(ResourceRequest&amp; request, Document&amp; document)
 97 {
 98     URL url = request.url();
 99 
100     ASSERT(document.contentSecurityPolicy());
101     document.contentSecurityPolicy()-&gt;upgradeInsecureRequestIfNeeded(url, ContentSecurityPolicy::InsecureRequestType::Load);
102 
103     if (url == request.url())
104         return;
105 
106     request.setURL(url);
107 }
108 
109 void CachedResourceRequest::upgradeInsecureRequestIfNeeded(Document&amp; document)
110 {
111     upgradeInsecureResourceRequestIfNeeded(m_resourceRequest, document);
112 }
113 
114 void CachedResourceRequest::setDomainForCachePartition(Document&amp; document)
115 {
116     m_resourceRequest.setDomainForCachePartition(document.domainForCachePartition());
117 }
118 
119 void CachedResourceRequest::setDomainForCachePartition(const String&amp; domain)
120 {
121     m_resourceRequest.setDomainForCachePartition(domain);
122 }
123 
124 static inline String acceptHeaderValueFromType(CachedResource::Type type)
125 {
126     switch (type) {
127     case CachedResource::Type::MainResource:
128         return &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;_s;
129     case CachedResource::Type::ImageResource:
130         if (ImageDecoder::supportsMediaType(ImageDecoder::MediaType::Video))
131             return &quot;image/png,image/svg+xml,image/*;q=0.8,video/*;q=0.8,*/*;q=0.5&quot;_s;
132         return &quot;image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5&quot;_s;
133     case CachedResource::Type::CSSStyleSheet:
134         return &quot;text/css,*/*;q=0.1&quot;_s;
135     case CachedResource::Type::SVGDocumentResource:
136         return &quot;image/svg+xml&quot;_s;
137 #if ENABLE(XSLT)
138     case CachedResource::Type::XSLStyleSheet:
139         // FIXME: This should accept more general xml formats */*+xml, image/svg+xml for example.
140         return &quot;text/xml,application/xml,application/xhtml+xml,text/xsl,application/rss+xml,application/atom+xml&quot;_s;
141 #endif
142     default:
143         return &quot;*/*&quot;_s;
144     }
145 }
146 
147 void CachedResourceRequest::setAcceptHeaderIfNone(CachedResource::Type type)
148 {
149     if (!m_resourceRequest.hasHTTPHeader(HTTPHeaderName::Accept))
150         m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::Accept, acceptHeaderValueFromType(type));
151 }
152 
153 void CachedResourceRequest::updateAccordingCacheMode()
154 {
155     if (m_options.cache == FetchOptions::Cache::Default
156         &amp;&amp; (m_resourceRequest.hasHTTPHeaderField(HTTPHeaderName::IfModifiedSince)
157             || m_resourceRequest.hasHTTPHeaderField(HTTPHeaderName::IfNoneMatch)
158             || m_resourceRequest.hasHTTPHeaderField(HTTPHeaderName::IfUnmodifiedSince)
159             || m_resourceRequest.hasHTTPHeaderField(HTTPHeaderName::IfMatch)
160             || m_resourceRequest.hasHTTPHeaderField(HTTPHeaderName::IfRange)))
161         m_options.cache = FetchOptions::Cache::NoStore;
162 
163     switch (m_options.cache) {
164     case FetchOptions::Cache::NoCache:
165         m_resourceRequest.setCachePolicy(ResourceRequestCachePolicy::RefreshAnyCacheData);
166         m_resourceRequest.addHTTPHeaderFieldIfNotPresent(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());
167         break;
168     case FetchOptions::Cache::NoStore:
169         m_options.cachingPolicy = CachingPolicy::DisallowCaching;
170         m_resourceRequest.setCachePolicy(ResourceRequestCachePolicy::DoNotUseAnyCache);
171         m_resourceRequest.addHTTPHeaderFieldIfNotPresent(HTTPHeaderName::Pragma, HTTPHeaderValues::noCache());
172         m_resourceRequest.addHTTPHeaderFieldIfNotPresent(HTTPHeaderName::CacheControl, HTTPHeaderValues::noCache());
173         break;
174     case FetchOptions::Cache::Reload:
175         m_resourceRequest.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
176         m_resourceRequest.addHTTPHeaderFieldIfNotPresent(HTTPHeaderName::Pragma, HTTPHeaderValues::noCache());
177         m_resourceRequest.addHTTPHeaderFieldIfNotPresent(HTTPHeaderName::CacheControl, HTTPHeaderValues::noCache());
178         break;
179     case FetchOptions::Cache::Default:
180         break;
181     case FetchOptions::Cache::ForceCache:
182         m_resourceRequest.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataElseLoad);
183         break;
184     case FetchOptions::Cache::OnlyIfCached:
185         m_resourceRequest.setCachePolicy(ResourceRequestCachePolicy::ReturnCacheDataDontLoad);
186         break;
187     }
188 }
189 
190 void CachedResourceRequest::updateAcceptEncodingHeader()
191 {
192     if (!m_resourceRequest.hasHTTPHeaderField(HTTPHeaderName::Range))
193         return;
194 
195     // FIXME: rdar://problem/40879225. Media engines triggering the load should not set this Accept-Encoding header.
196     ASSERT(!m_resourceRequest.hasHTTPHeaderField(HTTPHeaderName::AcceptEncoding) || m_options.destination == FetchOptions::Destination::Audio || m_options.destination == FetchOptions::Destination::Video);
197 
198     m_resourceRequest.addHTTPHeaderFieldIfNotPresent(HTTPHeaderName::AcceptEncoding, &quot;identity&quot;_s);
199 }
200 
201 void CachedResourceRequest::removeFragmentIdentifierIfNeeded()
202 {
203     URL url = MemoryCache::removeFragmentIdentifierIfNeeded(m_resourceRequest.url());
204     if (url.string() != m_resourceRequest.url())
205         m_resourceRequest.setURL(url);
206 }
207 
208 #if ENABLE(CONTENT_EXTENSIONS)
209 
210 void CachedResourceRequest::applyResults(ContentRuleListResults&amp;&amp; results, Page* page)
211 {
212     ContentExtensions::applyResultsToRequest(WTFMove(results), page, m_resourceRequest);
213 }
214 
215 #endif
216 
217 void CachedResourceRequest::updateReferrerPolicy(ReferrerPolicy defaultPolicy)
218 {
219     if (m_options.referrerPolicy == ReferrerPolicy::EmptyString)
220         m_options.referrerPolicy = defaultPolicy;
221 }
222 
223 void CachedResourceRequest::updateReferrerOriginAndUserAgentHeaders(FrameLoader&amp; frameLoader)
224 {
225     // Implementing step 9 to 11 of https://fetch.spec.whatwg.org/#http-network-or-cache-fetch as of 16 March 2018
226     String outgoingReferrer = frameLoader.outgoingReferrer();
227     String outgoingOrigin = frameLoader.outgoingOrigin();
228     if (m_resourceRequest.hasHTTPReferrer()) {
229         outgoingReferrer = m_resourceRequest.httpReferrer();
230         outgoingOrigin = SecurityOrigin::createFromString(outgoingReferrer)-&gt;toString();
231     }
232     updateRequestReferrer(m_resourceRequest, m_options.referrerPolicy, outgoingReferrer);
233 
234     FrameLoader::addHTTPOriginIfNeeded(m_resourceRequest, outgoingOrigin);
235 
236     frameLoader.applyUserAgentIfNeeded(m_resourceRequest);
237 }
238 
239 bool isRequestCrossOrigin(SecurityOrigin* origin, const URL&amp; requestURL, const ResourceLoaderOptions&amp; options)
240 {
241     if (!origin)
242         return false;
243 
244     // Using same origin mode guarantees the loader will not do a cross-origin load, so we let it take care of it and just return false.
245     if (options.mode == FetchOptions::Mode::SameOrigin)
246         return false;
247 
248     // FIXME: We should remove options.sameOriginDataURLFlag once https://github.com/whatwg/fetch/issues/393 is fixed.
249     if (requestURL.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set)
250         return false;
251 
252     return !origin-&gt;canRequest(requestURL);
253 }
254 
255 void CachedResourceRequest::setDestinationIfNotSet(FetchOptions::Destination destination)
256 {
257     if (m_options.destination != FetchOptions::Destination::EmptyString)
258         return;
259     m_options.destination = destination;
260 }
261 
262 #if ENABLE(SERVICE_WORKER)
263 void CachedResourceRequest::setClientIdentifierIfNeeded(DocumentIdentifier clientIdentifier)
264 {
265     if (!m_options.clientIdentifier)
266         m_options.clientIdentifier = clientIdentifier;
267 }
268 
269 void CachedResourceRequest::setSelectedServiceWorkerRegistrationIdentifierIfNeeded(ServiceWorkerRegistrationIdentifier identifier)
270 {
271     if (isNonSubresourceRequest(m_options.destination))
272         return;
273     if (isPotentialNavigationOrSubresourceRequest(m_options.destination))
274         return;
275 
276     if (m_options.serviceWorkersMode == ServiceWorkersMode::None)
277         return;
278     if (m_options.serviceWorkerRegistrationIdentifier)
279         return;
280 
281     m_options.serviceWorkerRegistrationIdentifier = identifier;
282 }
283 
284 void CachedResourceRequest::setNavigationServiceWorkerRegistrationData(const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; data)
285 {
286     if (!data || !data-&gt;activeWorker) {
287         m_options.serviceWorkersMode = ServiceWorkersMode::None;
288         return;
289     }
290     m_options.serviceWorkerRegistrationIdentifier = data-&gt;identifier;
291 }
292 #endif
293 
294 } // namespace WebCore
    </pre>
  </body>
</html>
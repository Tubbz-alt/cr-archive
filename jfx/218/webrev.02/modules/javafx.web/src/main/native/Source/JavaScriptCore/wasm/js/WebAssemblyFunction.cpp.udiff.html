<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebAssemblyCompileErrorPrototype.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyFunction.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyFunction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,20 +27,22 @@</span>
  #include &quot;WebAssemblyFunction.h&quot;
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;B3Compilation.h&quot;
<span class="udiff-line-added">+ #include &quot;FrameTracers.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunctionInlines.h&quot;
  #include &quot;JSObject.h&quot;
<span class="udiff-line-added">+ #include &quot;JSToWasm.h&quot;</span>
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyMemory.h&quot;
  #include &quot;JSWebAssemblyRuntimeError.h&quot;
  #include &quot;LLIntThunks.h&quot;
  #include &quot;LinkBuffer.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;ProtoCallFrame.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;ProtoCallFrameInlines.h&quot;</span>
  #include &quot;VM.h&quot;
  #include &quot;WasmCallee.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
  #include &quot;WasmContextInlines.h&quot;
  #include &quot;WasmFormat.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -54,15 +56,15 @@</span>
  
  namespace JSC {
  
  const ClassInfo WebAssemblyFunction::s_info = { &quot;WebAssemblyFunction&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WebAssemblyFunction) };
  
<span class="udiff-line-modified-removed">- static EncodedJSValue JSC_HOST_CALL callWebAssemblyFunction(ExecState* exec)</span>
<span class="udiff-line-modified-added">+ static EncodedJSValue JSC_HOST_CALL callWebAssemblyFunction(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     WebAssemblyFunction* wasmFunction = jsCast&lt;WebAssemblyFunction*&gt;(exec-&gt;jsCallee());</span>
<span class="udiff-line-modified-added">+     WebAssemblyFunction* wasmFunction = jsCast&lt;WebAssemblyFunction*&gt;(callFrame-&gt;jsCallee());</span>
      Wasm::SignatureIndex signatureIndex = wasmFunction-&gt;signatureIndex();
      const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
  
      // Make sure that the memory we think we are going to run with matches the one we expect.
      ASSERT(wasmFunction-&gt;instance()-&gt;instance().codeBlock()-&gt;isSafeToRun(wasmFunction-&gt;instance()-&gt;memory()-&gt;memory().mode()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -72,71 +74,63 @@</span>
          traceScope.emplace(WebAssemblyExecuteStart, WebAssemblyExecuteEnd);
  
      Vector&lt;JSValue, MarkedArgumentBuffer::inlineCapacity&gt; boxedArgs;
      JSWebAssemblyInstance* instance = wasmFunction-&gt;instance();
      Wasm::Instance* wasmInstance = &amp;instance-&gt;instance();
<span class="udiff-line-removed">-     // When we don&#39;t use fast TLS to store the context, the JS</span>
<span class="udiff-line-removed">-     // entry wrapper expects a JSWebAssemblyInstance as the first argument.</span>
<span class="udiff-line-removed">-     if (!Wasm::Context::useFastTLS())</span>
<span class="udiff-line-removed">-         boxedArgs.append(instance);</span>
  
      for (unsigned argIndex = 0; argIndex &lt; signature.argumentCount(); ++argIndex) {
<span class="udiff-line-modified-removed">-         JSValue arg = exec-&gt;argument(argIndex);</span>
<span class="udiff-line-modified-added">+         JSValue arg = callFrame-&gt;argument(argIndex);</span>
          switch (signature.argument(argIndex)) {
          case Wasm::I32:
<span class="udiff-line-modified-removed">-             arg = JSValue::decode(arg.toInt32(exec));</span>
<span class="udiff-line-modified-added">+             arg = JSValue::decode(arg.toInt32(globalObject));</span>
              break;
          case Wasm::Funcref: {
              if (!isWebAssemblyHostFunction(vm, arg) &amp;&amp; !arg.isNull())
<span class="udiff-line-modified-removed">-                 return JSValue::encode(throwException(exec, scope, createJSWebAssemblyRuntimeError(exec, vm, &quot;Funcref must be an exported wasm function&quot;)));</span>
<span class="udiff-line-modified-added">+                 return JSValue::encode(throwException(globalObject, scope, createJSWebAssemblyRuntimeError(globalObject, vm, &quot;Funcref must be an exported wasm function&quot;)));</span>
              break;
          }
          case Wasm::Anyref:
              break;
          case Wasm::I64:
              arg = JSValue();
              break;
          case Wasm::F32:
<span class="udiff-line-modified-removed">-             arg = JSValue::decode(bitwise_cast&lt;uint32_t&gt;(arg.toFloat(exec)));</span>
<span class="udiff-line-modified-added">+             arg = JSValue::decode(bitwise_cast&lt;uint32_t&gt;(arg.toFloat(globalObject)));</span>
              break;
          case Wasm::F64:
<span class="udiff-line-modified-removed">-             arg = JSValue::decode(bitwise_cast&lt;uint64_t&gt;(arg.toNumber(exec)));</span>
<span class="udiff-line-modified-added">+             arg = JSValue::decode(bitwise_cast&lt;uint64_t&gt;(arg.toNumber(globalObject)));</span>
              break;
          case Wasm::Void:
          case Wasm::Func:
              RELEASE_ASSERT_NOT_REACHED();
          }
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          boxedArgs.append(arg);
      }
  
<span class="udiff-line-modified-removed">-     JSValue firstArgument = JSValue();</span>
<span class="udiff-line-modified-removed">-     int argCount = 1;</span>
<span class="udiff-line-modified-removed">-     JSValue* remainingArgs = nullptr;</span>
<span class="udiff-line-modified-removed">-     if (boxedArgs.size()) {</span>
<span class="udiff-line-modified-removed">-         remainingArgs = boxedArgs.data();</span>
<span class="udiff-line-removed">-         firstArgument = *remainingArgs;</span>
<span class="udiff-line-removed">-         remainingArgs++;</span>
<span class="udiff-line-removed">-         argCount = boxedArgs.size();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     // When we don&#39;t use fast TLS to store the context, the JS</span>
<span class="udiff-line-modified-added">+     // entry wrapper expects a JSWebAssemblyInstance as the |this| value argument.</span>
<span class="udiff-line-modified-added">+     JSValue context = Wasm::Context::useFastTLS() ? JSValue() : instance;</span>
<span class="udiff-line-modified-added">+     JSValue* args = boxedArgs.data();</span>
<span class="udiff-line-modified-added">+     int argCount = boxedArgs.size() + 1;</span>
  
      // Note: we specifically use the WebAssemblyFunction as the callee to begin with in the ProtoCallFrame.
      // The reason for this is that calling into the llint may stack overflow, and the stack overflow
      // handler might read the global object from the callee.
      ProtoCallFrame protoCallFrame;
<span class="udiff-line-modified-removed">-     protoCallFrame.init(nullptr, wasmFunction, firstArgument, argCount, remainingArgs);</span>
<span class="udiff-line-modified-added">+     protoCallFrame.init(nullptr, globalObject, wasmFunction, context, argCount, args);</span>
  
      // FIXME Do away with this entire function, and only use the entrypoint generated by B3. https://bugs.webkit.org/show_bug.cgi?id=166486
      Wasm::Instance* prevWasmInstance = vm.wasmContext.load();
      {
          // We do the stack check here for the wrapper function because we don&#39;t
          // want to emit a stack check inside every wrapper function.
          const intptr_t sp = bitwise_cast&lt;intptr_t&gt;(currentStackPointer());
          const intptr_t frameSize = (boxedArgs.size() + CallFrame::headerSizeInRegisters) * sizeof(Register);
          const intptr_t stackSpaceUsed = 2 * frameSize; // We&#39;re making two calls. One to the wrapper, and one to the actual wasm code.
          if (UNLIKELY((sp &lt; stackSpaceUsed) || ((sp - stackSpaceUsed) &lt; bitwise_cast&lt;intptr_t&gt;(vm.softStackLimit()))))
<span class="udiff-line-modified-removed">-             return JSValue::encode(throwException(exec, scope, createStackOverflowError(exec)));</span>
<span class="udiff-line-modified-added">+             return JSValue::encode(throwException(globalObject, scope, createStackOverflowError(globalObject)));</span>
      }
      vm.wasmContext.store(wasmInstance, vm.softStackLimit());
      ASSERT(wasmFunction-&gt;instance());
      ASSERT(&amp;wasmFunction-&gt;instance()-&gt;instance() == vm.wasmContext.load());
      EncodedJSValue rawResult = vmEntryToWasm(wasmFunction-&gt;jsEntrypoint(MustCheckArity).executableAddress(), &amp;vm, &amp;protoCallFrame);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160,26 +154,17 @@</span>
  }
  
  bool WebAssemblyFunction::useTagRegisters() const
  {
      const auto&amp; signature = Wasm::SignatureInformation::get(signatureIndex());
<span class="udiff-line-modified-removed">-     return signature.argumentCount() || signature.returnType() != Wasm::Void;</span>
<span class="udiff-line-modified-added">+     return signature.argumentCount() || !signature.returnsVoid();</span>
  }
  
  RegisterSet WebAssemblyFunction::calleeSaves() const
  {
<span class="udiff-line-modified-removed">-     RegisterSet toSave = Wasm::PinnedRegisterInfo::get().toSave(instance()-&gt;memoryMode());</span>
<span class="udiff-line-modified-removed">-     if (useTagRegisters()) {</span>
<span class="udiff-line-removed">-         RegisterSet tagRegisters = RegisterSet::runtimeTagRegisters();</span>
<span class="udiff-line-removed">-         // We rely on these being disjoint sets.</span>
<span class="udiff-line-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-removed">-         for (Reg reg : tagRegisters)</span>
<span class="udiff-line-removed">-             ASSERT(!toSave.contains(reg));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         toSave.merge(tagRegisters);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return toSave;</span>
<span class="udiff-line-modified-added">+     // Pessimistically save callee saves in BoundsChecking mode since the LLInt always bounds checks</span>
<span class="udiff-line-modified-added">+     return Wasm::PinnedRegisterInfo::get().toSave(Wasm::MemoryMode::BoundsChecking);</span>
  }
  
  RegisterAtOffsetList WebAssemblyFunction::usedCalleeSaveRegisters() const
  {
      return RegisterAtOffsetList { calleeSaves(), RegisterAtOffsetList::OffsetBaseType::FramePointerBased };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -187,11 +172,11 @@</span>
  
  ptrdiff_t WebAssemblyFunction::previousInstanceOffset() const
  {
      ptrdiff_t result = calleeSaves().numberOfSetRegisters() * sizeof(CPURegister);
      result = -result - sizeof(CPURegister);
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
      ptrdiff_t minOffset = 1;
      for (const RegisterAtOffset&amp; regAtOffset : usedCalleeSaveRegisters()) {
          ptrdiff_t offset = regAtOffset.offset();
          ASSERT(offset &lt; 0);
          minOffset = std::min(offset, minOffset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -217,42 +202,21 @@</span>
      const auto&amp; pinnedRegs = Wasm::PinnedRegisterInfo::get();
      RegisterAtOffsetList registersToSpill = usedCalleeSaveRegisters();
  
      auto&amp; moduleInformation = instance()-&gt;instance().module().moduleInformation();
  
<span class="udiff-line-added">+     const Wasm::WasmCallingConvention&amp; wasmCC = Wasm::wasmCallingConvention();</span>
<span class="udiff-line-added">+     Wasm::CallInformation wasmCallInfo = wasmCC.callInformationFor(signature);</span>
<span class="udiff-line-added">+     Wasm::CallInformation jsCallInfo = Wasm::jsCallingConvention().callInformationFor(signature, Wasm::CallRole::Callee);</span>
<span class="udiff-line-added">+     RegisterAtOffsetList savedResultRegisters = wasmCallInfo.computeResultsOffsetList();</span>
<span class="udiff-line-added">+ </span>
      unsigned totalFrameSize = registersToSpill.size() * sizeof(CPURegister);
      totalFrameSize += sizeof(CPURegister); // Slot for the VM&#39;s previous wasm instance.
<span class="udiff-line-modified-removed">-     totalFrameSize += Wasm::WasmCallingConvention::headerSizeInBytes();</span>
<span class="udiff-line-modified-removed">-     totalFrameSize -= sizeof(CallerFrameAndPC);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     unsigned numGPRs = 0;</span>
<span class="udiff-line-removed">-     unsigned numFPRs = 0;</span>
<span class="udiff-line-removed">-     bool argumentsIncludeI64 = false;</span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="udiff-line-removed">-         switch (signature.argument(i)) {</span>
<span class="udiff-line-removed">-         case Wasm::I64:</span>
<span class="udiff-line-removed">-             argumentsIncludeI64 = true;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         case Wasm::Anyref:</span>
<span class="udiff-line-removed">-         case Wasm::Funcref:</span>
<span class="udiff-line-removed">-         case Wasm::I32:</span>
<span class="udiff-line-removed">-             if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size())</span>
<span class="udiff-line-removed">-                 totalFrameSize += sizeof(CPURegister);</span>
<span class="udiff-line-removed">-             ++numGPRs;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         case Wasm::F32:</span>
<span class="udiff-line-removed">-         case Wasm::F64:</span>
<span class="udiff-line-removed">-             if (numFPRs &gt;= Wasm::wasmCallingConvention().m_fprArgs.size())</span>
<span class="udiff-line-removed">-                 totalFrameSize += sizeof(CPURegister);</span>
<span class="udiff-line-removed">-             ++numFPRs;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         default:</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     totalFrameSize += wasmCallInfo.headerAndArgumentStackSizeInBytes;</span>
<span class="udiff-line-modified-added">+     totalFrameSize += savedResultRegisters.size() * sizeof(CPURegister);</span>
  
<span class="udiff-line-modified-removed">-     if (argumentsIncludeI64)</span>
<span class="udiff-line-modified-added">+     if (wasmCallInfo.argumentsIncludeI64 || wasmCallInfo.resultsIncludeI64)</span>
          return nullptr;
  
      totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
  
      jit.emitFunctionPrologue();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -263,13 +227,13 @@</span>
          GPRReg reg = regAtOffset.reg().gpr();
          ptrdiff_t offset = regAtOffset.offset();
          jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
      }
  
<span class="udiff-line-modified-removed">-     GPRReg scratchGPR = Wasm::wasmCallingConventionAir().prologueScratch(1);</span>
<span class="udiff-line-modified-added">+     GPRReg scratchGPR = Wasm::wasmCallingConvention().prologueScratchGPRs[1];</span>
      bool stackLimitGPRIsClobbered = false;
<span class="udiff-line-modified-removed">-     GPRReg stackLimitGPR = Wasm::wasmCallingConventionAir().prologueScratch(0);</span>
<span class="udiff-line-modified-added">+     GPRReg stackLimitGPR = Wasm::wasmCallingConvention().prologueScratchGPRs[0];</span>
      jit.loadPtr(vm.addressOfSoftStackLimit(), stackLimitGPR);
  
      CCallHelpers::JumpList slowPath;
      slowPath.append(jit.branchPtr(CCallHelpers::Above, MacroAssembler::stackPointerRegister, GPRInfo::callFrameRegister));
      slowPath.append(jit.branchPtr(CCallHelpers::Below, MacroAssembler::stackPointerRegister, stackLimitGPR));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -278,143 +242,98 @@</span>
      // argCountPlusThis - 1 &gt;= signature.argumentCount()
      // argCountPlusThis &gt;= signature.argumentCount() + 1
      // FIXME: We should handle mismatched arity
      // https://bugs.webkit.org/show_bug.cgi?id=196564
      slowPath.append(jit.branch32(CCallHelpers::Below,
<span class="udiff-line-modified-removed">-         CCallHelpers::payloadFor(CallFrameSlot::argumentCount), CCallHelpers::TrustedImm32(signature.argumentCount() + 1)));</span>
<span class="udiff-line-modified-added">+         CCallHelpers::payloadFor(CallFrameSlot::argumentCountIncludingThis), CCallHelpers::TrustedImm32(signature.argumentCount() + 1)));</span>
  
      if (useTagRegisters())
          jit.emitMaterializeTagCheckRegisters();
  
<span class="udiff-line-modified-removed">-     // First we do stack slots for FPRs so we can use FPR argument registers as scratch.</span>
<span class="udiff-line-modified-removed">-     // After that, we handle FPR argument registers.</span>
<span class="udiff-line-modified-removed">-     // We also handle all GPR types here as we have GPR scratch registers.</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));</span>
<span class="udiff-line-modified-removed">-         numGPRs = 0;</span>
<span class="udiff-line-modified-removed">-         numFPRs = 0;</span>
<span class="udiff-line-modified-removed">-         FPRReg scratchFPR = Wasm::wasmCallingConvention().m_fprArgs[0].fpr();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         ptrdiff_t jsOffset = CallFrameSlot::firstArgument * sizeof(EncodedJSValue);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         ptrdiff_t wasmOffset = CallFrame::headerSizeInRegisters * sizeof(CPURegister);</span>
<span class="udiff-line-modified-removed">-         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="udiff-line-modified-removed">-             switch (signature.argument(i)) {</span>
<span class="udiff-line-modified-removed">-             case Wasm::I32:</span>
<span class="udiff-line-modified-removed">-                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="udiff-line-modified-removed">-                 slowPath.append(jit.branchIfNotInt32(scratchGPR));</span>
<span class="udiff-line-removed">-                 if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="udiff-line-removed">-                     jit.store32(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="udiff-line-removed">-                     wasmOffset += sizeof(CPURegister);</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     jit.zeroExtend32ToPtr(scratchGPR, Wasm::wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="udiff-line-removed">-                     ++numGPRs;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             case Wasm::Funcref: {</span>
<span class="udiff-line-removed">-                 // Ensure we have a WASM exported function.</span>
<span class="udiff-line-removed">-                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="udiff-line-removed">-                 auto isNull = jit.branchIfNull(scratchGPR);</span>
<span class="udiff-line-removed">-                 slowPath.append(jit.branchIfNotCell(scratchGPR));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 stackLimitGPRIsClobbered = true;</span>
<span class="udiff-line-removed">-                 jit.emitLoadStructure(vm, scratchGPR, scratchGPR, stackLimitGPR);</span>
<span class="udiff-line-removed">-                 jit.loadPtr(CCallHelpers::Address(scratchGPR, Structure::classInfoOffset()), scratchGPR);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 static_assert(std::is_final&lt;WebAssemblyFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="udiff-line-removed">-                 static_assert(std::is_final&lt;WebAssemblyWrapperFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 auto isWasmFunction = jit.branchPtr(CCallHelpers::Equal, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyFunction::info()));</span>
<span class="udiff-line-removed">-                 slowPath.append(jit.branchPtr(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyWrapperFunction::info())));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 isWasmFunction.link(&amp;jit);</span>
<span class="udiff-line-removed">-                 isNull.link(&amp;jit);</span>
<span class="udiff-line-removed">-                 FALLTHROUGH;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             case Wasm::Anyref: {</span>
<span class="udiff-line-removed">-                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="udiff-line-removed">-                     jit.store64(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="udiff-line-removed">-                     wasmOffset += sizeof(CPURegister);</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     jit.move(scratchGPR, Wasm::wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="udiff-line-removed">-                     ++numGPRs;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             case Wasm::F32:</span>
<span class="udiff-line-removed">-             case Wasm::F64:</span>
<span class="udiff-line-removed">-                 if (numFPRs &gt;= Wasm::wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="udiff-line-removed">-                     jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="udiff-line-removed">-                     slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="udiff-line-removed">-                     auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="udiff-line-removed">-                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="udiff-line-removed">-                         jit.unboxDouble(scratchGPR, scratchGPR, scratchFPR);</span>
<span class="udiff-line-removed">-                         jit.convertDoubleToFloat(scratchFPR, scratchFPR);</span>
<span class="udiff-line-removed">-                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         jit.add64(GPRInfo::tagTypeNumberRegister, scratchGPR, scratchGPR);</span>
<span class="udiff-line-removed">-                         jit.store64(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     auto done = jit.jump();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     isInt32.link(&amp;jit);</span>
<span class="udiff-line-removed">-                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="udiff-line-removed">-                         jit.convertInt32ToFloat(scratchGPR, scratchFPR);</span>
<span class="udiff-line-removed">-                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         jit.convertInt32ToDouble(scratchGPR, scratchFPR);</span>
<span class="udiff-line-removed">-                         jit.storeDouble(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     done.link(&amp;jit);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     wasmOffset += sizeof(CPURegister);</span>
<span class="udiff-line-removed">-                 } else</span>
<span class="udiff-line-removed">-                     ++numFPRs;</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             default:</span>
<span class="udiff-line-removed">-                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             jsOffset += sizeof(EncodedJSValue);</span>
<span class="udiff-line-modified-added">+     // Loop backwards so we can use the first floating point argument as a scratch.</span>
<span class="udiff-line-modified-added">+     FPRReg scratchFPR = Wasm::wasmCallingConvention().fprArgs[0].fpr();</span>
<span class="udiff-line-modified-added">+     for (unsigned i = signature.argumentCount(); i--;) {</span>
<span class="udiff-line-modified-added">+         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, 0);</span>
<span class="udiff-line-modified-added">+         CCallHelpers::Address jsParam(GPRInfo::callFrameRegister, jsCallInfo.params[i].offsetFromFP());</span>
<span class="udiff-line-modified-added">+         bool isStack = wasmCallInfo.params[i].isStackArgument();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         auto type = signature.argument(i);</span>
<span class="udiff-line-modified-added">+         switch (type) {</span>
<span class="udiff-line-modified-added">+         case Wasm::I32: {</span>
<span class="udiff-line-modified-added">+             jit.load64(jsParam, scratchGPR);</span>
<span class="udiff-line-modified-added">+             slowPath.append(jit.branchIfNotInt32(scratchGPR));</span>
<span class="udiff-line-modified-added">+             if (isStack)</span>
<span class="udiff-line-modified-added">+                 jit.store32(scratchGPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>
<span class="udiff-line-modified-added">+             else</span>
<span class="udiff-line-modified-added">+                 jit.zeroExtend32ToPtr(scratchGPR, wasmCallInfo.params[i].gpr());</span>
<span class="udiff-line-modified-added">+             break;</span>
          }
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         case Wasm::Funcref: {</span>
<span class="udiff-line-added">+             // Ensure we have a WASM exported function.</span>
<span class="udiff-line-added">+             jit.load64(jsParam, scratchGPR);</span>
<span class="udiff-line-added">+             auto isNull = jit.branchIfNull(scratchGPR);</span>
<span class="udiff-line-added">+             slowPath.append(jit.branchIfNotCell(scratchGPR));</span>
  
<span class="udiff-line-modified-removed">-     // Now handle FPR arguments in registers.</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         numFPRs = 0;</span>
<span class="udiff-line-modified-removed">-         ptrdiff_t jsOffset = CallFrameSlot::firstArgument * sizeof(EncodedJSValue);</span>
<span class="udiff-line-modified-removed">-         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="udiff-line-modified-removed">-             switch (signature.argument(i)) {</span>
<span class="udiff-line-modified-removed">-             case Wasm::F32:</span>
<span class="udiff-line-modified-removed">-             case Wasm::F64:</span>
<span class="udiff-line-modified-removed">-                 if (numFPRs &lt; Wasm::wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="udiff-line-removed">-                     FPRReg argFPR = Wasm::wasmCallingConvention().m_fprArgs[numFPRs].fpr();</span>
<span class="udiff-line-removed">-                     jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="udiff-line-removed">-                     slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="udiff-line-removed">-                     auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="udiff-line-removed">-                     jit.unboxDouble(scratchGPR, scratchGPR, argFPR);</span>
<span class="udiff-line-removed">-                     if (signature.argument(i) == Wasm::F32)</span>
<span class="udiff-line-removed">-                         jit.convertDoubleToFloat(argFPR, argFPR);</span>
<span class="udiff-line-removed">-                     auto done = jit.jump();</span>
<span class="udiff-line-modified-added">+             stackLimitGPRIsClobbered = true;</span>
<span class="udiff-line-modified-added">+             jit.emitLoadStructure(vm, scratchGPR, scratchGPR, stackLimitGPR);</span>
<span class="udiff-line-modified-added">+             jit.loadPtr(CCallHelpers::Address(scratchGPR, Structure::classInfoOffset()), scratchGPR);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             static_assert(std::is_final&lt;WebAssemblyFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="udiff-line-modified-added">+             static_assert(std::is_final&lt;WebAssemblyWrapperFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             auto isWasmFunction = jit.branchPtr(CCallHelpers::Equal, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyFunction::info()));</span>
<span class="udiff-line-modified-added">+             slowPath.append(jit.branchPtr(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyWrapperFunction::info())));</span>
  
<span class="udiff-line-modified-removed">-                     isInt32.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             isWasmFunction.link(&amp;jit);</span>
<span class="udiff-line-added">+             isNull.link(&amp;jit);</span>
<span class="udiff-line-added">+             FALLTHROUGH;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         case Wasm::Anyref: {</span>
<span class="udiff-line-added">+             if (isStack) {</span>
<span class="udiff-line-added">+                 jit.load64(jsParam, scratchGPR);</span>
<span class="udiff-line-added">+                 jit.store64(scratchGPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>
<span class="udiff-line-added">+             } else</span>
<span class="udiff-line-added">+                 jit.load64(jsParam, wasmCallInfo.params[i].gpr());</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         case Wasm::F32:</span>
<span class="udiff-line-added">+         case Wasm::F64: {</span>
<span class="udiff-line-added">+             if (!isStack)</span>
<span class="udiff-line-added">+                 scratchFPR = wasmCallInfo.params[i].fpr();</span>
<span class="udiff-line-added">+             auto moveToDestination = [&amp;] () {</span>
<span class="udiff-line-added">+                 if (isStack) {</span>
                      if (signature.argument(i) == Wasm::F32)
<span class="udiff-line-modified-removed">-                         jit.convertInt32ToFloat(scratchGPR, argFPR);</span>
<span class="udiff-line-modified-added">+                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>
                      else
<span class="udiff-line-modified-removed">-                         jit.convertInt32ToDouble(scratchGPR, argFPR);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                     done.link(&amp;jit);</span>
<span class="udiff-line-removed">-                     ++numFPRs;</span>
<span class="udiff-line-modified-added">+                         jit.storeDouble(scratchFPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>
                  }
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-removed">-             default:</span>
<span class="udiff-line-modified-removed">-                 break;</span>
<span class="udiff-line-modified-added">+             };</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.load64(jsParam, scratchGPR);</span>
<span class="udiff-line-added">+             slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="udiff-line-added">+             auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             jit.unboxDouble(scratchGPR, scratchGPR, scratchFPR);</span>
<span class="udiff-line-added">+             if (signature.argument(i) == Wasm::F32)</span>
<span class="udiff-line-added">+                 jit.convertDoubleToFloat(scratchFPR, scratchFPR);</span>
<span class="udiff-line-added">+             moveToDestination();</span>
<span class="udiff-line-added">+             auto done = jit.jump();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             isInt32.link(&amp;jit);</span>
<span class="udiff-line-added">+             if (signature.argument(i) == Wasm::F32) {</span>
<span class="udiff-line-added">+                 jit.convertInt32ToFloat(scratchGPR, scratchFPR);</span>
<span class="udiff-line-added">+                 moveToDestination();</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 jit.convertInt32ToDouble(scratchGPR, scratchFPR);</span>
<span class="udiff-line-added">+                 moveToDestination();</span>
              }
<span class="udiff-line-added">+             done.link(&amp;jit);</span>
  
<span class="udiff-line-modified-removed">-             jsOffset += sizeof(EncodedJSValue);</span>
<span class="udiff-line-modified-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         default:</span>
<span class="udiff-line-added">+             RELEASE_ASSERT_NOT_REACHED();</span>
          }
      }
  
      // At this point, we&#39;re committed to doing a fast call.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -467,45 +386,19 @@</span>
          // https://bugs.webkit.org/show_bug.cgi?id=196570
          jit.loadPtr(entrypointLoadLocation(), scratchGPR);
          jit.call(scratchGPR, WasmEntryPtrTag);
      }
  
<span class="udiff-line-added">+     marshallJSResult(jit, signature, wasmCallInfo, savedResultRegisters);</span>
<span class="udiff-line-added">+ </span>
      ASSERT(!RegisterSet::runtimeTagRegisters().contains(GPRInfo::nonPreservedNonReturnGPR));
      jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, previousInstanceOffset), GPRInfo::nonPreservedNonReturnGPR);
      if (Wasm::Context::useFastTLS())
          jit.storeWasmContextInstance(GPRInfo::nonPreservedNonReturnGPR);
      else
          jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, vm.wasmContext.pointerToInstance());
  
<span class="udiff-line-removed">-     switch (signature.returnType()) {</span>
<span class="udiff-line-removed">-     case Wasm::Void:</span>
<span class="udiff-line-removed">-         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     case Wasm::I32:</span>
<span class="udiff-line-removed">-         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-removed">-         jit.boxInt32(GPRInfo::returnValueGPR, JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     case Wasm::F32:</span>
<span class="udiff-line-removed">-         jit.convertFloatToDouble(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-removed">-         FALLTHROUGH;</span>
<span class="udiff-line-removed">-     case Wasm::F64: {</span>
<span class="udiff-line-removed">-         jit.moveTrustedValue(jsNumber(pureNaN()), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="udiff-line-removed">-         auto isNaN = jit.branchIfNaN(FPRInfo::returnValueFPR);</span>
<span class="udiff-line-removed">-         jit.boxDouble(FPRInfo::returnValueFPR, JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="udiff-line-removed">-         isNaN.link(&amp;jit);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     case Wasm::Funcref:</span>
<span class="udiff-line-removed">-     case Wasm::Anyref:</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     case Wasm::I64:</span>
<span class="udiff-line-removed">-     case Wasm::Func:</span>
<span class="udiff-line-removed">-         return nullptr;</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      auto emitRestoreCalleeSaves = [&amp;] {
          for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
              GPRReg reg = regAtOffset.reg().gpr();
              ASSERT(reg != GPRInfo::returnValueGPR);
              ptrdiff_t offset = regAtOffset.offset();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -530,31 +423,30 @@</span>
      LinkBuffer linkBuffer(jit, nullptr, JITCompilationCanFail);
      if (UNLIKELY(linkBuffer.didFailToAllocate()))
          return nullptr;
  
      linkBuffer.link(jumpToHostCallThunk, CodeLocationLabel&lt;JSEntryPtrTag&gt;(executable()-&gt;entrypointFor(CodeForCall, MustCheckArity).executableAddress()));
<span class="udiff-line-modified-removed">-     m_jsCallEntrypoint = FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;JS-&gt;Wasm IC&quot;);</span>
<span class="udiff-line-modified-added">+     m_jsCallEntrypoint = FINALIZE_WASM_CODE(linkBuffer, WasmEntryPtrTag, &quot;JS-&gt;Wasm IC&quot;);</span>
      return m_jsCallEntrypoint.code();
  }
  
  WebAssemblyFunction* WebAssemblyFunction::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, unsigned length, const String&amp; name, JSWebAssemblyInstance* instance, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)
  {
      NativeExecutable* executable = vm.getHostFunction(callWebAssemblyFunction, NoIntrinsic, callHostFunctionAsConstructor, nullptr, name);
<span class="udiff-line-modified-removed">-     WebAssemblyFunction* function = new (NotNull, allocateCell&lt;WebAssemblyFunction&gt;(vm.heap)) WebAssemblyFunction(vm, globalObject, structure, jsEntrypoint, wasmToWasmEntrypointLoadLocation, signatureIndex);</span>
<span class="udiff-line-modified-added">+     WebAssemblyFunction* function = new (NotNull, allocateCell&lt;WebAssemblyFunction&gt;(vm.heap)) WebAssemblyFunction(vm, executable, globalObject, structure, jsEntrypoint, wasmToWasmEntrypointLoadLocation, signatureIndex);</span>
      function-&gt;finishCreation(vm, executable, length, name, instance);
<span class="udiff-line-removed">-     ASSERT_WITH_MESSAGE(!function-&gt;isLargeAllocation(), &quot;WebAssemblyFunction should be allocated not in large allocation since it is JSCallee.&quot;);</span>
      return function;
  }
  
  Structure* WebAssemblyFunction::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
      ASSERT(globalObject);
      return Structure::create(vm, globalObject, prototype, TypeInfo(JSFunctionType, StructureFlags), info());
  }
  
<span class="udiff-line-modified-removed">- WebAssemblyFunction::WebAssemblyFunction(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)</span>
<span class="udiff-line-modified-removed">-     : Base { vm, globalObject, structure }</span>
<span class="udiff-line-modified-added">+ WebAssemblyFunction::WebAssemblyFunction(VM&amp; vm, NativeExecutable* executable, JSGlobalObject* globalObject, Structure* structure, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)</span>
<span class="udiff-line-modified-added">+     : Base { vm, executable, globalObject, structure }</span>
      , m_jsEntrypoint { jsEntrypoint.entrypoint() }
      , m_importableFunction { signatureIndex, wasmToWasmEntrypointLoadLocation }
  { }
  
  void WebAssemblyFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
</pre>
<center><a href="WebAssemblyCompileErrorPrototype.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyFunction.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSPropertyAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSAnimationController.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyAnimation.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSPropertyAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 105,14 ***</span>
  static inline ShadowStyle blendFunc(const CSSPropertyBlendingClient* anim, ShadowStyle from, ShadowStyle to, double progress)
  {
      if (from == to)
          return to;
  
<span class="line-modified">!     double fromVal = from == Normal ? 1 : 0;</span>
<span class="line-modified">!     double toVal = to == Normal ? 1 : 0;</span>
      double result = blendFunc(anim, fromVal, toVal, progress);
<span class="line-modified">!     return result &gt; 0 ? Normal : Inset;</span>
  }
  
  static inline std::unique_ptr&lt;ShadowData&gt; blendFunc(const CSSPropertyBlendingClient* anim, const ShadowData* from, const ShadowData* to, double progress)
  {
      ASSERT(from &amp;&amp; to);
<span class="line-new-header">--- 105,14 ---</span>
  static inline ShadowStyle blendFunc(const CSSPropertyBlendingClient* anim, ShadowStyle from, ShadowStyle to, double progress)
  {
      if (from == to)
          return to;
  
<span class="line-modified">!     double fromVal = from == ShadowStyle::Normal ? 1 : 0;</span>
<span class="line-modified">!     double toVal = to == ShadowStyle::Normal ? 1 : 0;</span>
      double result = blendFunc(anim, fromVal, toVal, progress);
<span class="line-modified">!     return result &gt; 0 ? ShadowStyle::Normal : ShadowStyle::Inset;</span>
  }
  
  static inline std::unique_ptr&lt;ShadowData&gt; blendFunc(const CSSPropertyBlendingClient* anim, const ShadowData* from, const ShadowData* to, double progress)
  {
      ASSERT(from &amp;&amp; to);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,11 ***</span>
      return result;
  }
  
  static inline SVGLengthValue blendFunc(const CSSPropertyBlendingClient*, const SVGLengthValue&amp; from, const SVGLengthValue&amp; to, double progress)
  {
<span class="line-modified">!     return to.blend(from, narrowPrecisionToFloat(progress));</span>
  }
  
  static inline Vector&lt;SVGLengthValue&gt; blendFunc(const CSSPropertyBlendingClient*, const Vector&lt;SVGLengthValue&gt;&amp; from, const Vector&lt;SVGLengthValue&gt;&amp; to, double progress)
  {
      size_t fromLength = from.size();
<span class="line-new-header">--- 283,11 ---</span>
      return result;
  }
  
  static inline SVGLengthValue blendFunc(const CSSPropertyBlendingClient*, const SVGLengthValue&amp; from, const SVGLengthValue&amp; to, double progress)
  {
<span class="line-modified">!     return SVGLengthValue::blend(from, to, narrowPrecisionToFloat(progress));</span>
  }
  
  static inline Vector&lt;SVGLengthValue&gt; blendFunc(const CSSPropertyBlendingClient*, const Vector&lt;SVGLengthValue&gt;&amp; from, const Vector&lt;SVGLengthValue&gt;&amp; to, double progress)
  {
      size_t fromLength = from.size();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 303,11 ***</span>
          else
              resultLength = fromLength * toLength;
      }
      Vector&lt;SVGLengthValue&gt; result(resultLength);
      for (size_t i = 0; i &lt; resultLength; ++i)
<span class="line-modified">!         result[i] = to[i % toLength].blend(from[i % fromLength], narrowPrecisionToFloat(progress));</span>
      return result;
  }
  
  static inline RefPtr&lt;StyleImage&gt; crossfadeBlend(const CSSPropertyBlendingClient*, StyleCachedImage* fromStyleImage, StyleCachedImage* toStyleImage, double progress)
  {
<span class="line-new-header">--- 303,11 ---</span>
          else
              resultLength = fromLength * toLength;
      }
      Vector&lt;SVGLengthValue&gt; result(resultLength);
      for (size_t i = 0; i &lt; resultLength; ++i)
<span class="line-modified">!         result[i] = SVGLengthValue::blend(from[i % fromLength], to[i % toLength], narrowPrecisionToFloat(progress));</span>
      return result;
  }
  
  static inline RefPtr&lt;StyleImage&gt; crossfadeBlend(const CSSPropertyBlendingClient*, StyleCachedImage* fromStyleImage, StyleCachedImage* toStyleImage, double progress)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,18 ***</span>
      if (!fromStyleImage-&gt;cachedImage() || !toStyleImage-&gt;cachedImage())
          return toStyleImage;
  
      auto fromImageValue = CSSImageValue::create(*fromStyleImage-&gt;cachedImage());
      auto toImageValue = CSSImageValue::create(*toStyleImage-&gt;cachedImage());
<span class="line-modified">!     auto percentageValue = CSSPrimitiveValue::create(progress, CSSPrimitiveValue::CSS_NUMBER);</span>
  
      auto crossfadeValue = CSSCrossfadeValue::create(WTFMove(fromImageValue), WTFMove(toImageValue), WTFMove(percentageValue));
      return StyleGeneratedImage::create(WTFMove(crossfadeValue));
  }
  
  static inline RefPtr&lt;StyleImage&gt; blendFunc(const CSSPropertyBlendingClient* anim, StyleImage* from, StyleImage* to, double progress)
  {
      if (!from || !to)
          return to;
  
      // Animation between two generated images. Cross fade for all other cases.
      if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
<span class="line-new-header">--- 320,24 ---</span>
      if (!fromStyleImage-&gt;cachedImage() || !toStyleImage-&gt;cachedImage())
          return toStyleImage;
  
      auto fromImageValue = CSSImageValue::create(*fromStyleImage-&gt;cachedImage());
      auto toImageValue = CSSImageValue::create(*toStyleImage-&gt;cachedImage());
<span class="line-modified">!     auto percentageValue = CSSPrimitiveValue::create(progress, CSSUnitType::CSS_NUMBER);</span>
  
      auto crossfadeValue = CSSCrossfadeValue::create(WTFMove(fromImageValue), WTFMove(toImageValue), WTFMove(percentageValue));
      return StyleGeneratedImage::create(WTFMove(crossfadeValue));
  }
  
  static inline RefPtr&lt;StyleImage&gt; blendFunc(const CSSPropertyBlendingClient* anim, StyleImage* from, StyleImage* to, double progress)
  {
<span class="line-added">+     if (!from || !to)</span>
<span class="line-added">+         return to;</span>
<span class="line-added">+ </span>
<span class="line-added">+     from = from-&gt;selectedImage();</span>
<span class="line-added">+     to = to-&gt;selectedImage();</span>
<span class="line-added">+ </span>
      if (!from || !to)
          return to;
  
      // Animation between two generated images. Cross fade for all other cases.
      if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 757,19 ***</span>
      return count;
  }
  
  static inline const ShadowData* shadowForBlending(const ShadowData* srcShadow, const ShadowData* otherShadow)
  {
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultShadowData(IntPoint(), 0, 0, Normal, false, Color::transparent);</span>
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultInsetShadowData(IntPoint(), 0, 0, Inset, false, Color::transparent);</span>
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultWebKitBoxShadowData(IntPoint(), 0, 0, Normal, true, Color::transparent);</span>
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultInsetWebKitBoxShadowData(IntPoint(), 0, 0, Inset, true, Color::transparent);</span>
  
      if (srcShadow)
          return srcShadow;
  
<span class="line-modified">!     if (otherShadow-&gt;style() == Inset)</span>
          return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultInsetWebKitBoxShadowData.get() : &amp;defaultInsetShadowData.get();
  
      return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultWebKitBoxShadowData.get() : &amp;defaultShadowData.get();
  }
  
<span class="line-new-header">--- 763,19 ---</span>
      return count;
  }
  
  static inline const ShadowData* shadowForBlending(const ShadowData* srcShadow, const ShadowData* otherShadow)
  {
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultShadowData(LayoutPoint(), 0, 0, ShadowStyle::Normal, false, Color::transparent);</span>
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultInsetShadowData(LayoutPoint(), 0, 0, ShadowStyle::Inset, false, Color::transparent);</span>
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultWebKitBoxShadowData(LayoutPoint(), 0, 0, ShadowStyle::Normal, true, Color::transparent);</span>
<span class="line-modified">!     static NeverDestroyed&lt;ShadowData&gt; defaultInsetWebKitBoxShadowData(LayoutPoint(), 0, 0, ShadowStyle::Inset, true, Color::transparent);</span>
  
      if (srcShadow)
          return srcShadow;
  
<span class="line-modified">!     if (otherShadow-&gt;style() == ShadowStyle::Inset)</span>
          return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultInsetWebKitBoxShadowData.get() : &amp;defaultInsetShadowData.get();
  
      return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultWebKitBoxShadowData.get() : &amp;defaultShadowData.get();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1610,11 ***</span>
          new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyRowGap, &amp;RenderStyle::rowGap, &amp;RenderStyle::setRowGap),
          new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnCount, &amp;RenderStyle::columnCount, &amp;RenderStyle::setColumnCount),
          new PropertyWrapper&lt;float&gt;(CSSPropertyColumnWidth, &amp;RenderStyle::columnWidth, &amp;RenderStyle::setColumnWidth),
          new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderHorizontalSpacing, &amp;RenderStyle::horizontalBorderSpacing, &amp;RenderStyle::setHorizontalBorderSpacing),
          new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderVerticalSpacing, &amp;RenderStyle::verticalBorderSpacing, &amp;RenderStyle::setVerticalBorderSpacing),
<span class="line-modified">!         new PropertyWrapper&lt;int&gt;(CSSPropertyZIndex, &amp;RenderStyle::zIndex, &amp;RenderStyle::setZIndex),</span>
          new PropertyWrapper&lt;short&gt;(CSSPropertyOrphans, &amp;RenderStyle::orphans, &amp;RenderStyle::setOrphans),
          new PropertyWrapper&lt;short&gt;(CSSPropertyWidows, &amp;RenderStyle::widows, &amp;RenderStyle::setWidows),
          new LengthPropertyWrapper(CSSPropertyLineHeight, &amp;RenderStyle::specifiedLineHeight, &amp;RenderStyle::setLineHeight),
          new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineOffset, &amp;RenderStyle::outlineOffset, &amp;RenderStyle::setOutlineOffset),
          new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineWidth, &amp;RenderStyle::outlineWidth, &amp;RenderStyle::setOutlineWidth),
<span class="line-new-header">--- 1616,11 ---</span>
          new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyRowGap, &amp;RenderStyle::rowGap, &amp;RenderStyle::setRowGap),
          new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnCount, &amp;RenderStyle::columnCount, &amp;RenderStyle::setColumnCount),
          new PropertyWrapper&lt;float&gt;(CSSPropertyColumnWidth, &amp;RenderStyle::columnWidth, &amp;RenderStyle::setColumnWidth),
          new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderHorizontalSpacing, &amp;RenderStyle::horizontalBorderSpacing, &amp;RenderStyle::setHorizontalBorderSpacing),
          new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderVerticalSpacing, &amp;RenderStyle::verticalBorderSpacing, &amp;RenderStyle::setVerticalBorderSpacing),
<span class="line-modified">!         new PropertyWrapper&lt;int&gt;(CSSPropertyZIndex, &amp;RenderStyle::specifiedZIndex, &amp;RenderStyle::setSpecifiedZIndex),</span>
          new PropertyWrapper&lt;short&gt;(CSSPropertyOrphans, &amp;RenderStyle::orphans, &amp;RenderStyle::setOrphans),
          new PropertyWrapper&lt;short&gt;(CSSPropertyWidows, &amp;RenderStyle::widows, &amp;RenderStyle::setWidows),
          new LengthPropertyWrapper(CSSPropertyLineHeight, &amp;RenderStyle::specifiedLineHeight, &amp;RenderStyle::setLineHeight),
          new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineOffset, &amp;RenderStyle::outlineOffset, &amp;RenderStyle::setOutlineOffset),
          new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineWidth, &amp;RenderStyle::outlineWidth, &amp;RenderStyle::setOutlineWidth),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1644,11 ***</span>
  #if ENABLE(FILTERS_LEVEL_2)
          new PropertyWrapperFilter(CSSPropertyWebkitBackdropFilter, &amp;RenderStyle::backdropFilter, &amp;RenderStyle::setBackdropFilter),
  #endif
          new PropertyWrapperFilter(CSSPropertyAppleColorFilter, &amp;RenderStyle::appleColorFilter, &amp;RenderStyle::setAppleColorFilter),
  
<span class="line-modified">!         new PropertyWrapperClipPath(CSSPropertyWebkitClipPath, &amp;RenderStyle::clipPath, &amp;RenderStyle::setClipPath),</span>
  
          new PropertyWrapperShape(CSSPropertyShapeOutside, &amp;RenderStyle::shapeOutside, &amp;RenderStyle::setShapeOutside),
          new LengthPropertyWrapper(CSSPropertyShapeMargin, &amp;RenderStyle::shapeMargin, &amp;RenderStyle::setShapeMargin),
          new PropertyWrapper&lt;float&gt;(CSSPropertyShapeImageThreshold, &amp;RenderStyle::shapeImageThreshold, &amp;RenderStyle::setShapeImageThreshold),
  
<span class="line-new-header">--- 1650,11 ---</span>
  #if ENABLE(FILTERS_LEVEL_2)
          new PropertyWrapperFilter(CSSPropertyWebkitBackdropFilter, &amp;RenderStyle::backdropFilter, &amp;RenderStyle::setBackdropFilter),
  #endif
          new PropertyWrapperFilter(CSSPropertyAppleColorFilter, &amp;RenderStyle::appleColorFilter, &amp;RenderStyle::setAppleColorFilter),
  
<span class="line-modified">!         new PropertyWrapperClipPath(CSSPropertyClipPath, &amp;RenderStyle::clipPath, &amp;RenderStyle::setClipPath),</span>
  
          new PropertyWrapperShape(CSSPropertyShapeOutside, &amp;RenderStyle::shapeOutside, &amp;RenderStyle::setShapeOutside),
          new LengthPropertyWrapper(CSSPropertyShapeMargin, &amp;RenderStyle::shapeMargin, &amp;RenderStyle::setShapeMargin),
          new PropertyWrapper&lt;float&gt;(CSSPropertyShapeImageThreshold, &amp;RenderStyle::shapeImageThreshold, &amp;RenderStyle::setShapeImageThreshold),
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1792,23 ***</span>
  
      return contained;
  }
  
  // Returns true if we need to start animation timers
<span class="line-modified">! bool CSSPropertyAnimation::blendProperties(const CSSPropertyBlendingClient* anim, CSSPropertyID prop, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress)</span>
  {
      ASSERT(prop != CSSPropertyInvalid);
  
      AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
      if (wrapper) {
          wrapper-&gt;blend(anim, dst, a, b, progress);
  #if !LOG_DISABLED
          wrapper-&gt;logBlend(a, b, dst, progress);
  #endif
<span class="line-removed">-         return !wrapper-&gt;animationIsAccelerated() || !anim-&gt;isAccelerated();</span>
      }
<span class="line-removed">-     return false;</span>
  }
  
  bool CSSPropertyAnimation::isPropertyAnimatable(CSSPropertyID prop)
  {
      return CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
<span class="line-new-header">--- 1798,21 ---</span>
  
      return contained;
  }
  
  // Returns true if we need to start animation timers
<span class="line-modified">! void CSSPropertyAnimation::blendProperties(const CSSPropertyBlendingClient* anim, CSSPropertyID prop, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress)</span>
  {
      ASSERT(prop != CSSPropertyInvalid);
  
      AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
      if (wrapper) {
          wrapper-&gt;blend(anim, dst, a, b, progress);
  #if !LOG_DISABLED
          wrapper-&gt;logBlend(a, b, dst, progress);
  #endif
      }
  }
  
  bool CSSPropertyAnimation::isPropertyAnimatable(CSSPropertyID prop)
  {
      return CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
</pre>
<center><a href="CSSAnimationController.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyAnimation.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
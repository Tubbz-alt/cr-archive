<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLAny.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLBuffer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  
  #if ENABLE(WEBGL)
  
  #include &quot;WebGLContextGroup.h&quot;
  #include &quot;WebGLRenderingContextBase.h&quot;
<span class="line-added">+ #include &lt;JavaScriptCore/ArrayBuffer.h&gt;</span>
  
  namespace WebCore {
  
  Ref&lt;WebGLBuffer&gt; WebGLBuffer::create(WebGLRenderingContextBase&amp; ctx)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,31 ***</span>
  }
  
  WebGLBuffer::WebGLBuffer(WebGLRenderingContextBase&amp; ctx)
      : WebGLSharedObject(ctx)
  {
<span class="line-modified">!     setObject(ctx.graphicsContext3D()-&gt;createBuffer());</span>
      clearCachedMaxIndices();
  }
  
  WebGLBuffer::~WebGLBuffer()
  {
      deleteObject(0);
  }
  
<span class="line-modified">! void WebGLBuffer::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)</span>
  {
      context3d-&gt;deleteBuffer(object);
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferDataImpl(const void* data, GC3Dsizeiptr byteLength)</span>
  {
      if (byteLength &lt; 0)
          return false;
  
      switch (m_target) {
<span class="line-modified">!     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
          if (byteLength &gt; std::numeric_limits&lt;unsigned&gt;::max())
              return false;
          m_byteLength = byteLength;
          clearCachedMaxIndices();
          if (byteLength) {
<span class="line-new-header">--- 40,31 ---</span>
  }
  
  WebGLBuffer::WebGLBuffer(WebGLRenderingContextBase&amp; ctx)
      : WebGLSharedObject(ctx)
  {
<span class="line-modified">!     setObject(ctx.graphicsContextGL()-&gt;createBuffer());</span>
      clearCachedMaxIndices();
  }
  
  WebGLBuffer::~WebGLBuffer()
  {
      deleteObject(0);
  }
  
<span class="line-modified">! void WebGLBuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
  {
      context3d-&gt;deleteBuffer(object);
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferDataImpl(const void* data, GCGLsizeiptr byteLength)</span>
  {
      if (byteLength &lt; 0)
          return false;
  
      switch (m_target) {
<span class="line-modified">!     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
          if (byteLength &gt; std::numeric_limits&lt;unsigned&gt;::max())
              return false;
          m_byteLength = byteLength;
          clearCachedMaxIndices();
          if (byteLength) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,31 ***</span>
                  memcpy(m_elementArrayBuffer-&gt;data(), data, byteLength);
              }
          } else
              m_elementArrayBuffer = nullptr;
          return true;
<span class="line-modified">!     case GraphicsContext3D::ARRAY_BUFFER:</span>
          m_byteLength = byteLength;
          return true;
      default:
  #if ENABLE(WEBGL2)
          switch (m_target) {
<span class="line-modified">!         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::UNIFORM_BUFFER:</span>
              m_byteLength = byteLength;
              return true;
          }
  #endif
          return false;
      }
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferData(GC3Dsizeiptr size)</span>
  {
      return associateBufferDataImpl(nullptr, size);
  }
  
  bool WebGLBuffer::associateBufferData(ArrayBuffer* array)
<span class="line-new-header">--- 80,31 ---</span>
                  memcpy(m_elementArrayBuffer-&gt;data(), data, byteLength);
              }
          } else
              m_elementArrayBuffer = nullptr;
          return true;
<span class="line-modified">!     case GraphicsContextGL::ARRAY_BUFFER:</span>
          m_byteLength = byteLength;
          return true;
      default:
  #if ENABLE(WEBGL2)
          switch (m_target) {
<span class="line-modified">!         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::UNIFORM_BUFFER:</span>
              m_byteLength = byteLength;
              return true;
          }
  #endif
          return false;
      }
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferData(GCGLsizeiptr size)</span>
  {
      return associateBufferDataImpl(nullptr, size);
  }
  
  bool WebGLBuffer::associateBufferData(ArrayBuffer* array)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,102 ***</span>
      if (!array)
          return false;
      return associateBufferDataImpl(array-&gt;baseAddress(), array-&gt;byteLength());
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferSubDataImpl(GC3Dintptr offset, const void* data, GC3Dsizeiptr byteLength)</span>
  {
      if (!data || offset &lt; 0 || byteLength &lt; 0)
          return false;
  
      if (byteLength) {
<span class="line-modified">!         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedBufferOffset(offset);</span>
<span class="line-modified">!         Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; checkedDataLength(byteLength);</span>
<span class="line-modified">!         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedBufferMax = checkedBufferOffset + checkedDataLength;</span>
          if (checkedBufferMax.hasOverflowed() || offset &gt; m_byteLength || checkedBufferMax.unsafeGet() &gt; m_byteLength)
              return false;
      }
  
      switch (m_target) {
<span class="line-modified">!     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
          clearCachedMaxIndices();
          if (byteLength) {
              if (!m_elementArrayBuffer)
                  return false;
              memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + offset, data, byteLength);
          }
          return true;
<span class="line-modified">!     case GraphicsContext3D::ARRAY_BUFFER:</span>
          return true;
      default:
  #if ENABLE(WEBGL2)
          switch (m_target) {
<span class="line-modified">!         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::UNIFORM_BUFFER:</span>
              return true;
          }
  #endif
          return false;
      }
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferSubData(GC3Dintptr offset, ArrayBuffer* array)</span>
  {
      if (!array)
          return false;
      return associateBufferSubDataImpl(offset, array-&gt;data(), array-&gt;byteLength());
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferSubData(GC3Dintptr offset, ArrayBufferView* array)</span>
  {
      if (!array)
          return false;
      return associateBufferSubDataImpl(offset, array-&gt;baseAddress(), array-&gt;byteLength());
  }
  
<span class="line-modified">! bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GC3Dintptr readOffset, GC3Dintptr writeOffset, GC3Dsizeiptr size)</span>
  {
      if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0)
          return false;
  
      if (size) {
<span class="line-modified">!         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedReadBufferOffset(readOffset);</span>
<span class="line-modified">!         Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; checkedDataLength(size);</span>
<span class="line-modified">!         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;</span>
          if (checkedReadBufferMax.hasOverflowed() || readOffset &gt; readBuffer.byteLength() || checkedReadBufferMax.unsafeGet() &gt; readBuffer.byteLength())
              return false;
  
<span class="line-modified">!         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedWriteBufferOffset(writeOffset);</span>
<span class="line-modified">!         Checked&lt;GC3Dintptr, RecordOverflow&gt; checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;</span>
          if (checkedWriteBufferMax.hasOverflowed() || writeOffset &gt; m_byteLength || checkedWriteBufferMax.unsafeGet() &gt; m_byteLength)
              return false;
      }
  
      switch (m_target) {
<span class="line-modified">!     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
          clearCachedMaxIndices();
          if (size) {
              if (!m_elementArrayBuffer)
                  return false;
              memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + writeOffset, static_cast&lt;const unsigned char*&gt;(readBuffer.elementArrayBuffer()-&gt;data()) + readOffset, size);
          }
          return true;
<span class="line-modified">!     case GraphicsContext3D::ARRAY_BUFFER:</span>
          return true;
      default:
  #if ENABLE(WEBGL2)
          switch (m_target) {
<span class="line-modified">!         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContext3D::UNIFORM_BUFFER:</span>
              return true;
          }
  #endif
          return false;
      }
<span class="line-new-header">--- 119,102 ---</span>
      if (!array)
          return false;
      return associateBufferDataImpl(array-&gt;baseAddress(), array-&gt;byteLength());
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferSubDataImpl(GCGLintptr offset, const void* data, GCGLsizeiptr byteLength)</span>
  {
      if (!data || offset &lt; 0 || byteLength &lt; 0)
          return false;
  
      if (byteLength) {
<span class="line-modified">!         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferOffset(offset);</span>
<span class="line-modified">!         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(byteLength);</span>
<span class="line-modified">!         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedBufferMax = checkedBufferOffset + checkedDataLength;</span>
          if (checkedBufferMax.hasOverflowed() || offset &gt; m_byteLength || checkedBufferMax.unsafeGet() &gt; m_byteLength)
              return false;
      }
  
      switch (m_target) {
<span class="line-modified">!     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
          clearCachedMaxIndices();
          if (byteLength) {
              if (!m_elementArrayBuffer)
                  return false;
              memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + offset, data, byteLength);
          }
          return true;
<span class="line-modified">!     case GraphicsContextGL::ARRAY_BUFFER:</span>
          return true;
      default:
  #if ENABLE(WEBGL2)
          switch (m_target) {
<span class="line-modified">!         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::UNIFORM_BUFFER:</span>
              return true;
          }
  #endif
          return false;
      }
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBuffer* array)</span>
  {
      if (!array)
          return false;
      return associateBufferSubDataImpl(offset, array-&gt;data(), array-&gt;byteLength());
  }
  
<span class="line-modified">! bool WebGLBuffer::associateBufferSubData(GCGLintptr offset, ArrayBufferView* array)</span>
  {
      if (!array)
          return false;
      return associateBufferSubDataImpl(offset, array-&gt;baseAddress(), array-&gt;byteLength());
  }
  
<span class="line-modified">! bool WebGLBuffer::associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)</span>
  {
      if (readOffset &lt; 0 || writeOffset &lt; 0 || size &lt; 0)
          return false;
  
      if (size) {
<span class="line-modified">!         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferOffset(readOffset);</span>
<span class="line-modified">!         Checked&lt;GCGLsizeiptr, RecordOverflow&gt; checkedDataLength(size);</span>
<span class="line-modified">!         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedReadBufferMax = checkedReadBufferOffset + checkedDataLength;</span>
          if (checkedReadBufferMax.hasOverflowed() || readOffset &gt; readBuffer.byteLength() || checkedReadBufferMax.unsafeGet() &gt; readBuffer.byteLength())
              return false;
  
<span class="line-modified">!         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferOffset(writeOffset);</span>
<span class="line-modified">!         Checked&lt;GCGLintptr, RecordOverflow&gt; checkedWriteBufferMax = checkedWriteBufferOffset + checkedDataLength;</span>
          if (checkedWriteBufferMax.hasOverflowed() || writeOffset &gt; m_byteLength || checkedWriteBufferMax.unsafeGet() &gt; m_byteLength)
              return false;
      }
  
      switch (m_target) {
<span class="line-modified">!     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
          clearCachedMaxIndices();
          if (size) {
              if (!m_elementArrayBuffer)
                  return false;
              memcpy(static_cast&lt;unsigned char*&gt;(m_elementArrayBuffer-&gt;data()) + writeOffset, static_cast&lt;const unsigned char*&gt;(readBuffer.elementArrayBuffer()-&gt;data()) + readOffset, size);
          }
          return true;
<span class="line-modified">!     case GraphicsContextGL::ARRAY_BUFFER:</span>
          return true;
      default:
  #if ENABLE(WEBGL2)
          switch (m_target) {
<span class="line-modified">!         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-modified">!         case GraphicsContextGL::UNIFORM_BUFFER:</span>
              return true;
          }
  #endif
          return false;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,25 ***</span>
  {
      m_byteLength = 0;
      clearCachedMaxIndices();
  }
  
<span class="line-modified">! GC3Dsizeiptr WebGLBuffer::byteLength() const</span>
  {
      return m_byteLength;
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; WebGLBuffer::getCachedMaxIndex(GC3Denum type)</span>
  {
      for (auto&amp; cache : m_maxIndexCache) {
          if (cache.type == type)
              return cache.maxIndex;
      }
      return WTF::nullopt;
  }
  
<span class="line-modified">! void WebGLBuffer::setCachedMaxIndex(GC3Denum type, unsigned value)</span>
  {
      for (auto&amp; cache : m_maxIndexCache) {
          if (cache.type == type) {
              cache.maxIndex = value;
              return;
<span class="line-new-header">--- 224,25 ---</span>
  {
      m_byteLength = 0;
      clearCachedMaxIndices();
  }
  
<span class="line-modified">! GCGLsizeiptr WebGLBuffer::byteLength() const</span>
  {
      return m_byteLength;
  }
  
<span class="line-modified">! Optional&lt;unsigned&gt; WebGLBuffer::getCachedMaxIndex(GCGLenum type)</span>
  {
      for (auto&amp; cache : m_maxIndexCache) {
          if (cache.type == type)
              return cache.maxIndex;
      }
      return WTF::nullopt;
  }
  
<span class="line-modified">! void WebGLBuffer::setCachedMaxIndex(GCGLenum type, unsigned value)</span>
  {
      for (auto&amp; cache : m_maxIndexCache) {
          if (cache.type == type) {
              cache.maxIndex = value;
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,29 ***</span>
      m_maxIndexCache[m_nextAvailableCacheEntry].type = type;
      m_maxIndexCache[m_nextAvailableCacheEntry].maxIndex = value;
      m_nextAvailableCacheEntry = (m_nextAvailableCacheEntry + 1) % WTF_ARRAY_LENGTH(m_maxIndexCache);
  }
  
<span class="line-modified">! void WebGLBuffer::setTarget(GC3Denum target, bool forWebGL2)</span>
  {
<span class="line-modified">!     // In WebGL, a buffer is bound to one target in its lifetime</span>
<span class="line-modified">!     if (m_target)</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     if (target == GraphicsContext3D::ARRAY_BUFFER || target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
<span class="line-modified">!         m_target = target;</span>
<span class="line-removed">-     else if (forWebGL2) {</span>
<span class="line-removed">- #if ENABLE(WEBGL2)</span>
<span class="line-removed">-         switch (target) {</span>
<span class="line-removed">-         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="line-removed">-         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="line-removed">-         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="line-removed">-         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="line-removed">-         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="line-removed">-         case GraphicsContext3D::UNIFORM_BUFFER:</span>
<span class="line-removed">-             m_target = target;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- #endif</span>
      }
  }
  
  void WebGLBuffer::clearCachedMaxIndices()
  {
<span class="line-new-header">--- 251,17 ---</span>
      m_maxIndexCache[m_nextAvailableCacheEntry].type = type;
      m_maxIndexCache[m_nextAvailableCacheEntry].maxIndex = value;
      m_nextAvailableCacheEntry = (m_nextAvailableCacheEntry + 1) % WTF_ARRAY_LENGTH(m_maxIndexCache);
  }
  
<span class="line-modified">! void WebGLBuffer::setTarget(GCGLenum target)</span>
  {
<span class="line-modified">!     m_target = target;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {</span>
<span class="line-modified">!         ASSERT(!m_arrayBufferOrElementArrayBuffer || target == m_arrayBufferOrElementArrayBuffer);</span>
<span class="line-modified">!         m_arrayBufferOrElementArrayBuffer = target;</span>
      }
  }
  
  void WebGLBuffer::clearCachedMaxIndices()
  {
</pre>
<center><a href="WebGLAny.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLBuffer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PointerEventsHitRules.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;GraphicsContext.h&quot;
  37 #include &quot;HTMLNames.h&quot;
  38 #include &quot;HitTestLocation.h&quot;
  39 #include &quot;HitTestResult.h&quot;
  40 #include &quot;InlineElementBox.h&quot;
  41 #include &quot;InlineIterator.h&quot;
  42 #include &quot;InlineTextBox.h&quot;
  43 #include &quot;LayoutRepainter.h&quot;
  44 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  45 #include &quot;OverflowEvent.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PaintInfo.h&quot;
  48 #include &quot;RenderBlockFlow.h&quot;
  49 #include &quot;RenderBoxFragmentInfo.h&quot;
  50 #include &quot;RenderButton.h&quot;
  51 #include &quot;RenderChildIterator.h&quot;
  52 #include &quot;RenderCombineText.h&quot;
  53 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  54 #include &quot;RenderFlexibleBox.h&quot;
<span class="line-modified">  55 #include &quot;RenderFragmentContainer.h&quot;</span>
  56 #include &quot;RenderInline.h&quot;
  57 #include &quot;RenderIterator.h&quot;
  58 #include &quot;RenderLayer.h&quot;
  59 #include &quot;RenderLayoutState.h&quot;
  60 #include &quot;RenderListMarker.h&quot;
  61 #include &quot;RenderMenuList.h&quot;
  62 #include &quot;RenderSVGResourceClipper.h&quot;
  63 #include &quot;RenderSVGRoot.h&quot;
  64 #include &quot;RenderTableCell.h&quot;
  65 #include &quot;RenderTextFragment.h&quot;
  66 #include &quot;RenderTheme.h&quot;
  67 #include &quot;RenderTreeBuilder.h&quot;
  68 #include &quot;RenderTreePosition.h&quot;
  69 #include &quot;RenderView.h&quot;
  70 #include &quot;SVGSVGElement.h&quot;
  71 #include &quot;Settings.h&quot;
  72 #include &quot;ShadowRoot.h&quot;
  73 #include &quot;ShapeOutsideInfo.h&quot;
  74 #include &quot;TransformState.h&quot;
  75 #include &lt;wtf/IsoMallocInlines.h&gt;
</pre>
<hr />
<pre>
 804     // an auto value. Add a method to determine this, so that we can avoid the relayout.
 805     if (relayoutChildren || (child.hasRelativeLogicalHeight() &amp;&amp; !isRenderView()))
 806         child.setChildNeedsLayout(MarkOnlyThis);
 807 
 808     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
 809     if (relayoutChildren &amp;&amp; child.needsPreferredWidthsRecalculation())
 810         child.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
 811 }
 812 
 813 void RenderBlock::dirtyForLayoutFromPercentageHeightDescendants()
 814 {
 815     if (!percentHeightDescendantsMap)
 816         return;
 817 
 818     TrackedRendererListHashSet* descendants = percentHeightDescendantsMap-&gt;get(this);
 819     if (!descendants)
 820         return;
 821 
 822     for (auto it = descendants-&gt;begin(), end = descendants-&gt;end(); it != end; ++it) {
 823         auto* box = *it;











 824         while (box != this) {
 825             if (box-&gt;normalChildNeedsLayout())
 826                 break;
 827             box-&gt;setChildNeedsLayout(MarkOnlyThis);
 828 
 829             // If the width of an image is affected by the height of a child (e.g., an image with an aspect ratio),
 830             // then we have to dirty preferred widths, since even enclosing blocks can become dirty as a result.
 831             // (A horizontal flexbox that contains an inline image wrapped in an anonymous block for example.)
 832             if (box-&gt;hasAspectRatio())
 833                 box-&gt;setPreferredLogicalWidthsDirty(true);
 834             auto* containingBlock = box-&gt;containingBlock();
 835             // Mark the svg ancestor chain dirty as we walk to the containing block. containingBlock() just skips them. See webkit.org/b/183874.
 836             if (is&lt;SVGElement&gt;(box-&gt;element()) &amp;&amp; containingBlock != box-&gt;parent()) {
 837                 auto* ancestor = box-&gt;parent();
 838                 ASSERT(ancestor-&gt;isDescendantOf(containingBlock));
 839                 while (ancestor != containingBlock) {
 840                     ancestor-&gt;setChildNeedsLayout(MarkOnlyThis);
 841                     // This is the topmost SVG root, no need to go any further.
 842                     if (is&lt;SVGSVGElement&gt;(ancestor-&gt;element()) &amp;&amp; !downcast&lt;SVGSVGElement&gt;(*ancestor-&gt;element()).ownerSVGElement())
 843                         break;
</pre>
<hr />
<pre>
1840         if (!hasPercentHeightDescendant(box))
1841             continue;
1842 
1843         removePercentHeightDescendant(box);
1844     }
1845 }
1846 
1847 bool RenderBlock::isContainingBlockAncestorFor(RenderObject&amp; renderer) const
1848 {
1849     for (const auto* ancestor = renderer.containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
1850         if (ancestor == this)
1851             return true;
1852     }
1853     return false;
1854 }
1855 
1856 LayoutUnit RenderBlock::textIndentOffset() const
1857 {
1858     LayoutUnit cw;
1859     if (style().textIndent().isPercentOrCalculated())
<span class="line-modified">1860         cw = containingBlock()-&gt;availableLogicalWidth();</span>
1861     return minimumValueForLength(style().textIndent(), cw);
1862 }
1863 
1864 LayoutUnit RenderBlock::logicalLeftOffsetForContent(RenderFragmentContainer* fragment) const
1865 {
1866     LayoutUnit logicalLeftOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1867     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1868         logicalLeftOffset += verticalScrollbarWidth();
1869     if (!fragment)
1870         return logicalLeftOffset;
1871     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1872     return logicalLeftOffset + (isHorizontalWritingMode() ? boxRect.x() : boxRect.y());
1873 }
1874 
1875 LayoutUnit RenderBlock::logicalRightOffsetForContent(RenderFragmentContainer* fragment) const
1876 {
1877     LayoutUnit logicalRightOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1878     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1879         logicalRightOffset += verticalScrollbarWidth();
1880     logicalRightOffset += availableLogicalWidth();
</pre>
<hr />
<pre>
1996             return false;
1997     }
1998 
1999     if ((hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) &amp;&amp; isPointInOverflowControl(result, locationInContainer.point(), adjustedLocation)) {
2000         updateHitTestResult(result, locationInContainer.point() - localOffset);
2001         // FIXME: isPointInOverflowControl() doesn&#39;t handle rect-based tests yet.
2002         if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer) == HitTestProgress::Stop)
2003            return true;
2004     }
2005 
2006     if (style().clipPath()) {
2007         switch (style().clipPath()-&gt;type()) {
2008         case ClipPathOperation::Shape: {
2009             auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style().clipPath());
2010 
2011             LayoutRect referenceBoxRect;
2012             switch (clipPath.referenceBox()) {
2013             case CSSBoxType::MarginBox:
2014                 referenceBoxRect = marginBoxRect();
2015                 break;
<span class="line-removed">2016             case CSSBoxType::BorderBox:</span>
<span class="line-removed">2017                 referenceBoxRect = borderBoxRect();</span>
<span class="line-removed">2018                 break;</span>
2019             case CSSBoxType::PaddingBox:
2020                 referenceBoxRect = paddingBoxRect();
2021                 break;

2022             case CSSBoxType::ContentBox:
2023                 referenceBoxRect = contentBoxRect();
2024                 break;
<span class="line-removed">2025             case CSSBoxType::BoxMissing:</span>
<span class="line-removed">2026             case CSSBoxType::FillBox:</span>
2027             case CSSBoxType::StrokeBox:
2028             case CSSBoxType::ViewBox:


2029                 referenceBoxRect = borderBoxRect();
2030             }
2031             if (!clipPath.pathForReferenceRect(referenceBoxRect).contains(locationInContainer.point() - localOffset, clipPath.windRule()))
2032                 return false;
2033             break;
2034         }
2035         case ClipPathOperation::Reference: {
2036             const auto&amp; referenceClipPathOperation = downcast&lt;ReferenceClipPathOperation&gt;(*style().clipPath());
2037             auto* element = document().getElementById(referenceClipPathOperation.fragment());
2038             if (!element || !element-&gt;renderer())
2039                 break;
2040             if (!is&lt;SVGClipPathElement&gt;(*element))
2041                 break;
2042             auto&amp; clipper = downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer());
2043             if (!clipper.hitTestClipContent(FloatRect(borderBoxRect()), FloatPoint(locationInContainer.point() - localOffset)))
2044                 return false;
2045             break;
2046         }
2047         case ClipPathOperation::Box:
2048             break;
</pre>
<hr />
<pre>
2497             if (baselinePos &amp;&amp; baselinePos.value() &gt; bottomOfContent)
2498                 baselinePos = Optional&lt;int&gt;();
2499         }
2500         if (baselinePos)
2501             return direction == HorizontalLine ? marginTop() + baselinePos.value() : marginRight() + baselinePos.value();
2502 
2503         return RenderBox::baselinePosition(baselineType, firstLine, direction, linePositionMode);
2504     }
2505 
2506     const RenderStyle&amp; style = firstLine ? firstLineStyle() : this-&gt;style();
2507     const FontMetrics&amp; fontMetrics = style.fontMetrics();
2508     return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;
2509 }
2510 
2511 LayoutUnit RenderBlock::minLineHeightForReplacedRenderer(bool isFirstLine, LayoutUnit replacedHeight) const
2512 {
2513     if (!document().inNoQuirksMode() &amp;&amp; replacedHeight)
2514         return replacedHeight;
2515 
2516     const RenderStyle&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
<span class="line-modified">2517     if (!(style.lineBoxContain() &amp; LineBoxContainBlock))</span>
2518         return 0;
2519 
2520     return std::max&lt;LayoutUnit&gt;(replacedHeight, lineHeight(isFirstLine, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
2521 }
2522 
2523 Optional&lt;int&gt; RenderBlock::firstLineBaseline() const
2524 {
2525     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2526         return Optional&lt;int&gt;();
2527 
2528     for (RenderBox* curr = firstChildBox(); curr; curr = curr-&gt;nextSiblingBox()) {
2529         if (!curr-&gt;isFloatingOrOutOfFlowPositioned()) {
2530             if (Optional&lt;int&gt; result = curr-&gt;firstLineBaseline())
2531                 return Optional&lt;int&gt;(curr-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2532         }
2533     }
2534 
2535     return Optional&lt;int&gt;();
2536 }
2537 
</pre>
<hr />
<pre>
2755         rareData = &amp;ensureBlockRareData(*this);
2756     }
2757     rareData-&gt;m_pageLogicalOffset = logicalOffset;
2758 }
2759 
2760 void RenderBlock::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
2761 {
2762     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2763     // above and below us (thus getting merged with them to form a single irregular shape).
2764     if (auto* continuation = this-&gt;continuation()) {
2765         // FIXME: This is wrong for block-flows that are horizontal.
2766         // https://bugs.webkit.org/show_bug.cgi?id=46781
2767         rects.append(snappedIntRect(accumulatedOffset.x(), accumulatedOffset.y() - collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter()));
2768         continuation-&gt;absoluteRects(rects, accumulatedOffset - toLayoutSize(location() + inlineContinuation()-&gt;containingBlock()-&gt;location()));
2769     } else
2770         rects.append(snappedIntRect(accumulatedOffset, size()));
2771 }
2772 
2773 void RenderBlock::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
2774 {




2775     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2776     // above and below us (thus getting merged with them to form a single irregular shape).
<span class="line-modified">2777     auto* continuation = this-&gt;continuation();</span>
<span class="line-modified">2778     FloatRect localRect = continuation</span>
<span class="line-modified">2779         ? FloatRect(0, -collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter())</span>
<span class="line-modified">2780         : FloatRect(0, 0, width(), height());</span>
2781 


2782     // FIXME: This is wrong for block-flows that are horizontal.
2783     // https://bugs.webkit.org/show_bug.cgi?id=46781
<span class="line-modified">2784     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();</span>
<span class="line-modified">2785     if (!fragmentedFlow || !fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))</span>
<span class="line-modified">2786         quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));</span>
<span class="line-removed">2787 </span>
<span class="line-removed">2788     if (continuation)</span>
<span class="line-removed">2789         continuation-&gt;absoluteQuads(quads, wasFixed);</span>
2790 }
2791 
2792 LayoutRect RenderBlock::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
2793 {
2794     LayoutRect r(RenderBox::rectWithOutlineForRepaint(repaintContainer, outlineWidth));
2795     if (isContinuation())
2796         r.inflateY(collapsedMarginBefore()); // FIXME: This is wrong for block-flows that are horizontal.
2797     return r;
2798 }
2799 
2800 void RenderBlock::updateDragState(bool dragOn)
2801 {
2802     RenderBox::updateDragState(dragOn);
2803     if (RenderBoxModelObject* continuation = this-&gt;continuation())
2804         continuation-&gt;updateDragState(dragOn);
2805 }
2806 
2807 const RenderStyle&amp; RenderBlock::outlineStyleForRepaint() const
2808 {
2809     if (auto* continuation = this-&gt;continuation())
</pre>
<hr />
<pre>
3139     return constructTextRun(text.stringView(), style, expansion);
3140 }
3141 
3142 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, unsigned offset, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3143 {
3144     unsigned stop = offset + length;
3145     ASSERT(stop &lt;= text.text().length());
3146     return constructTextRun(text.stringView(offset, stop), style, expansion);
3147 }
3148 
3149 TextRun RenderBlock::constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3150 {
3151     return constructTextRun(StringView(characters, length), style, expansion);
3152 }
3153 
3154 TextRun RenderBlock::constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3155 {
3156     return constructTextRun(StringView(characters, length), style, expansion);
3157 }
3158 
<span class="line-modified">3159 #ifndef NDEBUG</span>
3160 void RenderBlock::checkPositionedObjectsNeedLayout()
3161 {
3162     auto* positionedDescendants = positionedObjects();
3163     if (!positionedDescendants)
3164         return;
3165 
3166     for (auto* renderer : *positionedDescendants)
3167         ASSERT(!renderer-&gt;needsLayout());
3168 }
<span class="line-modified">3169 </span>
<span class="line-removed">3170 #endif</span>
3171 
3172 bool RenderBlock::hasDefiniteLogicalHeight() const
3173 {
3174     return (bool)availableLogicalHeightForPercentageComputation();
3175 }
3176 
3177 Optional&lt;LayoutUnit&gt; RenderBlock::availableLogicalHeightForPercentageComputation() const
3178 {
3179     Optional&lt;LayoutUnit&gt; availableHeight;
3180 
3181     // For anonymous blocks that are skipped during percentage height calculation,
3182     // we consider them to have an indefinite height.
3183     if (skipContainingBlockForPercentHeightCalculation(*this, false))
3184         return availableHeight;
3185 
3186     const auto&amp; styleToUse = style();
3187 
3188     // A positioned element that specified both top/bottom or that specifies
3189     // height should be treated as though it has a height explicitly specified
3190     // that can be used for any percentage computations.
</pre>
</td>
<td>
<hr />
<pre>
  35 #include &quot;FrameView.h&quot;
  36 #include &quot;GraphicsContext.h&quot;
  37 #include &quot;HTMLNames.h&quot;
  38 #include &quot;HitTestLocation.h&quot;
  39 #include &quot;HitTestResult.h&quot;
  40 #include &quot;InlineElementBox.h&quot;
  41 #include &quot;InlineIterator.h&quot;
  42 #include &quot;InlineTextBox.h&quot;
  43 #include &quot;LayoutRepainter.h&quot;
  44 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  45 #include &quot;OverflowEvent.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PaintInfo.h&quot;
  48 #include &quot;RenderBlockFlow.h&quot;
  49 #include &quot;RenderBoxFragmentInfo.h&quot;
  50 #include &quot;RenderButton.h&quot;
  51 #include &quot;RenderChildIterator.h&quot;
  52 #include &quot;RenderCombineText.h&quot;
  53 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  54 #include &quot;RenderFlexibleBox.h&quot;
<span class="line-modified">  55 #include &quot;RenderFragmentedFlow.h&quot;</span>
  56 #include &quot;RenderInline.h&quot;
  57 #include &quot;RenderIterator.h&quot;
  58 #include &quot;RenderLayer.h&quot;
  59 #include &quot;RenderLayoutState.h&quot;
  60 #include &quot;RenderListMarker.h&quot;
  61 #include &quot;RenderMenuList.h&quot;
  62 #include &quot;RenderSVGResourceClipper.h&quot;
  63 #include &quot;RenderSVGRoot.h&quot;
  64 #include &quot;RenderTableCell.h&quot;
  65 #include &quot;RenderTextFragment.h&quot;
  66 #include &quot;RenderTheme.h&quot;
  67 #include &quot;RenderTreeBuilder.h&quot;
  68 #include &quot;RenderTreePosition.h&quot;
  69 #include &quot;RenderView.h&quot;
  70 #include &quot;SVGSVGElement.h&quot;
  71 #include &quot;Settings.h&quot;
  72 #include &quot;ShadowRoot.h&quot;
  73 #include &quot;ShapeOutsideInfo.h&quot;
  74 #include &quot;TransformState.h&quot;
  75 #include &lt;wtf/IsoMallocInlines.h&gt;
</pre>
<hr />
<pre>
 804     // an auto value. Add a method to determine this, so that we can avoid the relayout.
 805     if (relayoutChildren || (child.hasRelativeLogicalHeight() &amp;&amp; !isRenderView()))
 806         child.setChildNeedsLayout(MarkOnlyThis);
 807 
 808     // If relayoutChildren is set and the child has percentage padding or an embedded content box, we also need to invalidate the childs pref widths.
 809     if (relayoutChildren &amp;&amp; child.needsPreferredWidthsRecalculation())
 810         child.setPreferredLogicalWidthsDirty(true, MarkOnlyThis);
 811 }
 812 
 813 void RenderBlock::dirtyForLayoutFromPercentageHeightDescendants()
 814 {
 815     if (!percentHeightDescendantsMap)
 816         return;
 817 
 818     TrackedRendererListHashSet* descendants = percentHeightDescendantsMap-&gt;get(this);
 819     if (!descendants)
 820         return;
 821 
 822     for (auto it = descendants-&gt;begin(), end = descendants-&gt;end(); it != end; ++it) {
 823         auto* box = *it;
<span class="line-added"> 824         // Let&#39;s not dirty the height perecentage descendant when it has an absolutely positioned containing block ancestor. We should be able to dirty such boxes through the regular invalidation logic.</span>
<span class="line-added"> 825         bool descendantNeedsLayout = true;</span>
<span class="line-added"> 826         for (auto* ancestor = box-&gt;containingBlock(); ancestor &amp;&amp; ancestor != this; ancestor = ancestor-&gt;containingBlock()) {</span>
<span class="line-added"> 827             if (ancestor-&gt;isOutOfFlowPositioned()) {</span>
<span class="line-added"> 828                 descendantNeedsLayout = false;</span>
<span class="line-added"> 829                 break;</span>
<span class="line-added"> 830             }</span>
<span class="line-added"> 831         }</span>
<span class="line-added"> 832         if (!descendantNeedsLayout)</span>
<span class="line-added"> 833             continue;</span>
<span class="line-added"> 834 </span>
 835         while (box != this) {
 836             if (box-&gt;normalChildNeedsLayout())
 837                 break;
 838             box-&gt;setChildNeedsLayout(MarkOnlyThis);
 839 
 840             // If the width of an image is affected by the height of a child (e.g., an image with an aspect ratio),
 841             // then we have to dirty preferred widths, since even enclosing blocks can become dirty as a result.
 842             // (A horizontal flexbox that contains an inline image wrapped in an anonymous block for example.)
 843             if (box-&gt;hasAspectRatio())
 844                 box-&gt;setPreferredLogicalWidthsDirty(true);
 845             auto* containingBlock = box-&gt;containingBlock();
 846             // Mark the svg ancestor chain dirty as we walk to the containing block. containingBlock() just skips them. See webkit.org/b/183874.
 847             if (is&lt;SVGElement&gt;(box-&gt;element()) &amp;&amp; containingBlock != box-&gt;parent()) {
 848                 auto* ancestor = box-&gt;parent();
 849                 ASSERT(ancestor-&gt;isDescendantOf(containingBlock));
 850                 while (ancestor != containingBlock) {
 851                     ancestor-&gt;setChildNeedsLayout(MarkOnlyThis);
 852                     // This is the topmost SVG root, no need to go any further.
 853                     if (is&lt;SVGSVGElement&gt;(ancestor-&gt;element()) &amp;&amp; !downcast&lt;SVGSVGElement&gt;(*ancestor-&gt;element()).ownerSVGElement())
 854                         break;
</pre>
<hr />
<pre>
1851         if (!hasPercentHeightDescendant(box))
1852             continue;
1853 
1854         removePercentHeightDescendant(box);
1855     }
1856 }
1857 
1858 bool RenderBlock::isContainingBlockAncestorFor(RenderObject&amp; renderer) const
1859 {
1860     for (const auto* ancestor = renderer.containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
1861         if (ancestor == this)
1862             return true;
1863     }
1864     return false;
1865 }
1866 
1867 LayoutUnit RenderBlock::textIndentOffset() const
1868 {
1869     LayoutUnit cw;
1870     if (style().textIndent().isPercentOrCalculated())
<span class="line-modified">1871         cw = availableLogicalWidth();</span>
1872     return minimumValueForLength(style().textIndent(), cw);
1873 }
1874 
1875 LayoutUnit RenderBlock::logicalLeftOffsetForContent(RenderFragmentContainer* fragment) const
1876 {
1877     LayoutUnit logicalLeftOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1878     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1879         logicalLeftOffset += verticalScrollbarWidth();
1880     if (!fragment)
1881         return logicalLeftOffset;
1882     LayoutRect boxRect = borderBoxRectInFragment(fragment);
1883     return logicalLeftOffset + (isHorizontalWritingMode() ? boxRect.x() : boxRect.y());
1884 }
1885 
1886 LayoutUnit RenderBlock::logicalRightOffsetForContent(RenderFragmentContainer* fragment) const
1887 {
1888     LayoutUnit logicalRightOffset = style().isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop();
1889     if (shouldPlaceBlockDirectionScrollbarOnLeft())
1890         logicalRightOffset += verticalScrollbarWidth();
1891     logicalRightOffset += availableLogicalWidth();
</pre>
<hr />
<pre>
2007             return false;
2008     }
2009 
2010     if ((hitTestAction == HitTestBlockBackground || hitTestAction == HitTestChildBlockBackground) &amp;&amp; isPointInOverflowControl(result, locationInContainer.point(), adjustedLocation)) {
2011         updateHitTestResult(result, locationInContainer.point() - localOffset);
2012         // FIXME: isPointInOverflowControl() doesn&#39;t handle rect-based tests yet.
2013         if (result.addNodeToListBasedTestResult(nodeForHitTest(), request, locationInContainer) == HitTestProgress::Stop)
2014            return true;
2015     }
2016 
2017     if (style().clipPath()) {
2018         switch (style().clipPath()-&gt;type()) {
2019         case ClipPathOperation::Shape: {
2020             auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style().clipPath());
2021 
2022             LayoutRect referenceBoxRect;
2023             switch (clipPath.referenceBox()) {
2024             case CSSBoxType::MarginBox:
2025                 referenceBoxRect = marginBoxRect();
2026                 break;



2027             case CSSBoxType::PaddingBox:
2028                 referenceBoxRect = paddingBoxRect();
2029                 break;
<span class="line-added">2030             case CSSBoxType::FillBox:</span>
2031             case CSSBoxType::ContentBox:
2032                 referenceBoxRect = contentBoxRect();
2033                 break;


2034             case CSSBoxType::StrokeBox:
2035             case CSSBoxType::ViewBox:
<span class="line-added">2036             case CSSBoxType::BorderBox:</span>
<span class="line-added">2037             case CSSBoxType::BoxMissing:</span>
2038                 referenceBoxRect = borderBoxRect();
2039             }
2040             if (!clipPath.pathForReferenceRect(referenceBoxRect).contains(locationInContainer.point() - localOffset, clipPath.windRule()))
2041                 return false;
2042             break;
2043         }
2044         case ClipPathOperation::Reference: {
2045             const auto&amp; referenceClipPathOperation = downcast&lt;ReferenceClipPathOperation&gt;(*style().clipPath());
2046             auto* element = document().getElementById(referenceClipPathOperation.fragment());
2047             if (!element || !element-&gt;renderer())
2048                 break;
2049             if (!is&lt;SVGClipPathElement&gt;(*element))
2050                 break;
2051             auto&amp; clipper = downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer());
2052             if (!clipper.hitTestClipContent(FloatRect(borderBoxRect()), FloatPoint(locationInContainer.point() - localOffset)))
2053                 return false;
2054             break;
2055         }
2056         case ClipPathOperation::Box:
2057             break;
</pre>
<hr />
<pre>
2506             if (baselinePos &amp;&amp; baselinePos.value() &gt; bottomOfContent)
2507                 baselinePos = Optional&lt;int&gt;();
2508         }
2509         if (baselinePos)
2510             return direction == HorizontalLine ? marginTop() + baselinePos.value() : marginRight() + baselinePos.value();
2511 
2512         return RenderBox::baselinePosition(baselineType, firstLine, direction, linePositionMode);
2513     }
2514 
2515     const RenderStyle&amp; style = firstLine ? firstLineStyle() : this-&gt;style();
2516     const FontMetrics&amp; fontMetrics = style.fontMetrics();
2517     return fontMetrics.ascent(baselineType) + (lineHeight(firstLine, direction, linePositionMode) - fontMetrics.height()) / 2;
2518 }
2519 
2520 LayoutUnit RenderBlock::minLineHeightForReplacedRenderer(bool isFirstLine, LayoutUnit replacedHeight) const
2521 {
2522     if (!document().inNoQuirksMode() &amp;&amp; replacedHeight)
2523         return replacedHeight;
2524 
2525     const RenderStyle&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
<span class="line-modified">2526     if (!(style.lineBoxContain().contains(LineBoxContain::Block)))</span>
2527         return 0;
2528 
2529     return std::max&lt;LayoutUnit&gt;(replacedHeight, lineHeight(isFirstLine, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
2530 }
2531 
2532 Optional&lt;int&gt; RenderBlock::firstLineBaseline() const
2533 {
2534     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
2535         return Optional&lt;int&gt;();
2536 
2537     for (RenderBox* curr = firstChildBox(); curr; curr = curr-&gt;nextSiblingBox()) {
2538         if (!curr-&gt;isFloatingOrOutOfFlowPositioned()) {
2539             if (Optional&lt;int&gt; result = curr-&gt;firstLineBaseline())
2540                 return Optional&lt;int&gt;(curr-&gt;logicalTop() + result.value()); // Translate to our coordinate space.
2541         }
2542     }
2543 
2544     return Optional&lt;int&gt;();
2545 }
2546 
</pre>
<hr />
<pre>
2764         rareData = &amp;ensureBlockRareData(*this);
2765     }
2766     rareData-&gt;m_pageLogicalOffset = logicalOffset;
2767 }
2768 
2769 void RenderBlock::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
2770 {
2771     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2772     // above and below us (thus getting merged with them to form a single irregular shape).
2773     if (auto* continuation = this-&gt;continuation()) {
2774         // FIXME: This is wrong for block-flows that are horizontal.
2775         // https://bugs.webkit.org/show_bug.cgi?id=46781
2776         rects.append(snappedIntRect(accumulatedOffset.x(), accumulatedOffset.y() - collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter()));
2777         continuation-&gt;absoluteRects(rects, accumulatedOffset - toLayoutSize(location() + inlineContinuation()-&gt;containingBlock()-&gt;location()));
2778     } else
2779         rects.append(snappedIntRect(accumulatedOffset, size()));
2780 }
2781 
2782 void RenderBlock::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
2783 {
<span class="line-added">2784     if (!continuation()) {</span>
<span class="line-added">2785         absoluteQuadsIgnoringContinuation({ { }, size() }, quads, wasFixed);</span>
<span class="line-added">2786         return;</span>
<span class="line-added">2787     }</span>
2788     // For blocks inside inlines, we include margins so that we run right up to the inline boxes
2789     // above and below us (thus getting merged with them to form a single irregular shape).
<span class="line-modified">2790     auto logicalRect = FloatRect { 0, -collapsedMarginBefore(), width(), height() + collapsedMarginBefore() + collapsedMarginAfter() };</span>
<span class="line-modified">2791     absoluteQuadsIgnoringContinuation(logicalRect, quads, wasFixed);</span>
<span class="line-modified">2792     collectAbsoluteQuadsForContinuation(quads, wasFixed);</span>
<span class="line-modified">2793 }</span>
2794 
<span class="line-added">2795 void RenderBlock::absoluteQuadsIgnoringContinuation(const FloatRect&amp; logicalRect, Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const</span>
<span class="line-added">2796 {</span>
2797     // FIXME: This is wrong for block-flows that are horizontal.
2798     // https://bugs.webkit.org/show_bug.cgi?id=46781
<span class="line-modified">2799     auto* fragmentedFlow = enclosingFragmentedFlow();</span>
<span class="line-modified">2800     if (!fragmentedFlow || !fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, logicalRect.y(), logicalRect.maxY()))</span>
<span class="line-modified">2801         quads.append(localToAbsoluteQuad(logicalRect, UseTransforms, wasFixed));</span>



2802 }
2803 
2804 LayoutRect RenderBlock::rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const
2805 {
2806     LayoutRect r(RenderBox::rectWithOutlineForRepaint(repaintContainer, outlineWidth));
2807     if (isContinuation())
2808         r.inflateY(collapsedMarginBefore()); // FIXME: This is wrong for block-flows that are horizontal.
2809     return r;
2810 }
2811 
2812 void RenderBlock::updateDragState(bool dragOn)
2813 {
2814     RenderBox::updateDragState(dragOn);
2815     if (RenderBoxModelObject* continuation = this-&gt;continuation())
2816         continuation-&gt;updateDragState(dragOn);
2817 }
2818 
2819 const RenderStyle&amp; RenderBlock::outlineStyleForRepaint() const
2820 {
2821     if (auto* continuation = this-&gt;continuation())
</pre>
<hr />
<pre>
3151     return constructTextRun(text.stringView(), style, expansion);
3152 }
3153 
3154 TextRun RenderBlock::constructTextRun(const RenderText&amp; text, unsigned offset, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3155 {
3156     unsigned stop = offset + length;
3157     ASSERT(stop &lt;= text.text().length());
3158     return constructTextRun(text.stringView(offset, stop), style, expansion);
3159 }
3160 
3161 TextRun RenderBlock::constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3162 {
3163     return constructTextRun(StringView(characters, length), style, expansion);
3164 }
3165 
3166 TextRun RenderBlock::constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp; style, ExpansionBehavior expansion)
3167 {
3168     return constructTextRun(StringView(characters, length), style, expansion);
3169 }
3170 
<span class="line-modified">3171 #if ASSERT_ENABLED</span>
3172 void RenderBlock::checkPositionedObjectsNeedLayout()
3173 {
3174     auto* positionedDescendants = positionedObjects();
3175     if (!positionedDescendants)
3176         return;
3177 
3178     for (auto* renderer : *positionedDescendants)
3179         ASSERT(!renderer-&gt;needsLayout());
3180 }
<span class="line-modified">3181 #endif // ASSERT_ENABLED</span>

3182 
3183 bool RenderBlock::hasDefiniteLogicalHeight() const
3184 {
3185     return (bool)availableLogicalHeightForPercentageComputation();
3186 }
3187 
3188 Optional&lt;LayoutUnit&gt; RenderBlock::availableLogicalHeightForPercentageComputation() const
3189 {
3190     Optional&lt;LayoutUnit&gt; availableHeight;
3191 
3192     // For anonymous blocks that are skipped during percentage height calculation,
3193     // we consider them to have an indefinite height.
3194     if (skipContainingBlockForPercentHeightCalculation(*this, false))
3195         return availableHeight;
3196 
3197     const auto&amp; styleToUse = style();
3198 
3199     // A positioned element that specified both top/bottom or that specifies
3200     // height should be treated as though it has a height explicitly specified
3201     // that can be used for any percentage computations.
</pre>
</td>
</tr>
</table>
<center><a href="PointerEventsHitRules.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
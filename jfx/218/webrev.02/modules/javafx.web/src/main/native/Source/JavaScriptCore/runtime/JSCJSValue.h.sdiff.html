<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValue.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCJSValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCJSValueInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValue.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 #include &quot;JSExportMacros.h&quot;
 26 #include &quot;PureNaN.h&quot;
 27 #include &lt;functional&gt;
 28 #include &lt;math.h&gt;
 29 #include &lt;stddef.h&gt;
 30 #include &lt;stdint.h&gt;
 31 #include &lt;wtf/Assertions.h&gt;
 32 #include &lt;wtf/Forward.h&gt;
 33 #include &lt;wtf/HashMap.h&gt;
 34 #include &lt;wtf/HashTraits.h&gt;
 35 #include &lt;wtf/MathExtras.h&gt;
 36 #include &lt;wtf/MediaTime.h&gt;
 37 #include &lt;wtf/StdLibExtras.h&gt;
 38 #include &lt;wtf/TriState.h&gt;
 39 
 40 namespace JSC {
 41 
 42 class AssemblyHelpers;
 43 class JSBigInt;
<span class="line-modified"> 44 class ExecState;</span>
 45 class JSCell;
 46 class JSValueSource;
 47 class VM;
 48 class JSGlobalObject;
 49 class JSObject;
 50 class JSString;
 51 class Identifier;
 52 class PropertyName;
 53 class PropertySlot;
 54 class PutPropertySlot;
 55 class Structure;
 56 #if ENABLE(DFG_JIT)
 57 namespace DFG {
 58 class JITCompiler;
 59 class OSRExitCompiler;
 60 class SpeculativeJIT;
 61 }
 62 #endif
 63 #if ENABLE(C_LOOP)
 64 namespace LLInt {
</pre>
<hr />
<pre>
112 #define TagOffset (offsetof(EncodedValueDescriptor, asBits.tag))
113 #define PayloadOffset (offsetof(EncodedValueDescriptor, asBits.payload))
114 
115 #if USE(JSVALUE64)
116 #define CellPayloadOffset 0
117 #else
118 #define CellPayloadOffset PayloadOffset
119 #endif
120 
121 enum WhichValueWord {
122     TagWord,
123     PayloadWord
124 };
125 
126 int64_t tryConvertToInt52(double);
127 bool isInt52(double);
128 
129 enum class SourceCodeRepresentation : uint8_t {
130     Other,
131     Integer,
<span class="line-modified">132     Double</span>

133 };
134 
135 class JSValue {
136     friend struct EncodedJSValueHashTraits;
137     friend struct EncodedJSValueWithRepresentationHashTraits;
138     friend class AssemblyHelpers;
139     friend class JIT;
140     friend class JITSlowPathCall;
141     friend class JITStubs;
142     friend class JITStubCall;
143     friend class JSInterfaceJIT;
144     friend class JSValueSource;
145     friend class SpecializedThunkJIT;
146 #if ENABLE(DFG_JIT)
147     friend class DFG::JITCompiler;
148     friend class DFG::OSRExitCompiler;
149     friend class DFG::SpeculativeJIT;
150 #endif
151 #if ENABLE(C_LOOP)
152     friend class LLInt::CLoop;
</pre>
<hr />
<pre>
228     bool isUndefined() const;
229     bool isNull() const;
230     bool isUndefinedOrNull() const;
231     bool isBoolean() const;
232     bool isAnyInt() const;
233     bool isUInt32AsAnyInt() const;
234     bool isInt32AsAnyInt() const;
235     bool isNumber() const;
236     bool isString() const;
237     bool isBigInt() const;
238     bool isSymbol() const;
239     bool isPrimitive() const;
240     bool isGetterSetter() const;
241     bool isCustomGetterSetter() const;
242     bool isObject() const;
243     bool inherits(VM&amp;, const ClassInfo*) const;
244     template&lt;typename Target&gt; bool inherits(VM&amp;) const;
245     const ClassInfo* classInfoOrNull(VM&amp;) const;
246 
247     // Extracting the value.
<span class="line-modified">248     bool getString(ExecState*, WTF::String&amp;) const;</span>
<span class="line-modified">249     WTF::String getString(ExecState*) const; // null string if not a string</span>
250     JSObject* getObject() const; // 0 if not an object
251 
252     // Extracting integer values.
253     bool getUInt32(uint32_t&amp;) const;
254 
255     // Basic conversions.
<span class="line-modified">256     JSValue toPrimitive(ExecState*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="line-modified">257     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;);</span>
258 
<span class="line-modified">259     bool toBoolean(ExecState*) const;</span>
260     TriState pureToBoolean() const;
261 
262     // toNumber conversion is expected to be side effect free if an exception has
<span class="line-modified">263     // been set in the ExecState already.</span>
<span class="line-modified">264     double toNumber(ExecState*) const;</span>
265 
<span class="line-modified">266     Variant&lt;JSBigInt*, double&gt; toNumeric(ExecState*) const;</span>
<span class="line-modified">267     Variant&lt;JSBigInt*, int32_t&gt; toBigIntOrInt32(ExecState*) const;</span>
268 
269     // toNumber conversion if it can be done without side effects.
270     Optional&lt;double&gt; toNumberFromPrimitive() const;
271 
<span class="line-modified">272     JSString* toString(ExecState*) const; // On exception, this returns the empty string.</span>
<span class="line-modified">273     JSString* toStringOrNull(ExecState*) const; // On exception, this returns null, to make exception checks faster.</span>
<span class="line-modified">274     Identifier toPropertyKey(ExecState*) const;</span>
<span class="line-modified">275     WTF::String toWTFString(ExecState*) const;</span>
<span class="line-modified">276     JSObject* toObject(ExecState*) const;</span>
<span class="line-modified">277     JSObject* toObject(ExecState*, JSGlobalObject*) const;</span>
278 
279     // Integer conversions.
<span class="line-modified">280     JS_EXPORT_PRIVATE double toInteger(ExecState*) const;</span>
<span class="line-modified">281     JS_EXPORT_PRIVATE double toIntegerPreserveNaN(ExecState*) const;</span>
<span class="line-modified">282     int32_t toInt32(ExecState*) const;</span>
<span class="line-modified">283     uint32_t toUInt32(ExecState*) const;</span>
<span class="line-modified">284     uint32_t toIndex(ExecState*, const char* errorName) const;</span>
<span class="line-modified">285     double toLength(ExecState*) const;</span>
286 
287     // Floating point conversions (this is a convenience function for WebCore;
288     // single precision float is not a representation used in JS or JSC).
<span class="line-modified">289     float toFloat(ExecState* exec) const { return static_cast&lt;float&gt;(toNumber(exec)); }</span>
290 
291     // Object operations, with the toObject operation included.
<span class="line-modified">292     JSValue get(ExecState*, PropertyName) const;</span>
<span class="line-modified">293     JSValue get(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">294     JSValue get(ExecState*, unsigned propertyName) const;</span>
<span class="line-modified">295     JSValue get(ExecState*, unsigned propertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">296     JSValue get(ExecState*, uint64_t propertyName) const;</span>
<span class="line-modified">297 </span>
<span class="line-modified">298     bool getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">299     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, CallbackWhenNoException) const;</span>
<span class="line-modified">300     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
<span class="line-modified">301 </span>
<span class="line-modified">302     bool getOwnPropertySlot(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">303 </span>
<span class="line-modified">304     bool put(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">305     bool putInline(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">306     JS_EXPORT_PRIVATE bool putToPrimitive(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">307     JS_EXPORT_PRIVATE bool putToPrimitiveByIndex(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">308     bool putByIndex(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">309 </span>
<span class="line-modified">310     JSValue toThis(ExecState*, ECMAMode) const;</span>
<span class="line-modified">311 </span>
<span class="line-modified">312     static bool equal(ExecState*, JSValue v1, JSValue v2);</span>
<span class="line-modified">313     static bool equalSlowCase(ExecState*, JSValue v1, JSValue v2);</span>
<span class="line-modified">314     static bool equalSlowCaseInline(ExecState*, JSValue v1, JSValue v2);</span>
<span class="line-modified">315     static bool strictEqual(ExecState*, JSValue v1, JSValue v2);</span>
<span class="line-modified">316     static bool strictEqualSlowCase(ExecState*, JSValue v1, JSValue v2);</span>
<span class="line-modified">317     static bool strictEqualSlowCaseInline(ExecState*, JSValue v1, JSValue v2);</span>
318     static TriState pureStrictEqual(JSValue v1, JSValue v2);
319 
320     bool isCell() const;
321     JSCell* asCell() const;
322     JS_EXPORT_PRIVATE bool isValidCallee();
323 
324     Structure* structureOrNull() const;
325     JSValue structureOrUndefined() const;
326 
327     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
328     void dumpInContext(PrintStream&amp;, DumpContext*) const;
329     void dumpInContextAssumingStructure(PrintStream&amp;, DumpContext*, Structure*) const;
330     void dumpForBacktrace(PrintStream&amp;) const;
331 
<span class="line-modified">332     JS_EXPORT_PRIVATE JSObject* synthesizePrototype(ExecState*) const;</span>
<span class="line-modified">333     bool requireObjectCoercible(ExecState*) const;</span>
334 
335     // Constants used for Int52. Int52 isn&#39;t part of JSValue right now, but JSValues may be
336     // converted to Int52s and back again.
337     static constexpr const unsigned numberOfInt52Bits = 52;
338     static constexpr const int64_t notInt52 = static_cast&lt;int64_t&gt;(1) &lt;&lt; numberOfInt52Bits;
339     static constexpr const unsigned int52ShiftAmount = 12;
340 
341     static ptrdiff_t offsetOfPayload() { return OBJECT_OFFSETOF(JSValue, u.asBits.payload); }
342     static ptrdiff_t offsetOfTag() { return OBJECT_OFFSETOF(JSValue, u.asBits.tag); }
343 
344 #if USE(JSVALUE32_64)
345     /*
346      * On 32-bit platforms USE(JSVALUE32_64) should be defined, and we use a NaN-encoded
347      * form for immediates.
348      *
349      * The encoding makes use of unused NaN space in the IEEE754 representation.  Any value
350      * with the top 13 bits set represents a QNaN (with the sign bit set).  QNaN values
351      * can encode a 51-bit payload.  Hardware produced and C-library payloads typically
352      * have a payload of zero.  We assume that non-zero payloads are available to encode
353      * pointer and integer values.  Since any 64-bit bit pattern where the top 15 bits are
</pre>
<hr />
<pre>
364     int32_t payload() const;
365 
366     // This should only be used by the LLInt C Loop interpreter and OSRExit code who needs
367     // synthesize JSValue from its &quot;register&quot;s holding tag and payload values.
368     explicit JSValue(int32_t tag, int32_t payload);
369 
370 #elif USE(JSVALUE64)
371     /*
372      * On 64-bit platforms USE(JSVALUE64) should be defined, and we use a NaN-encoded
373      * form for immediates.
374      *
375      * The encoding makes use of unused NaN space in the IEEE754 representation.  Any value
376      * with the top 13 bits set represents a QNaN (with the sign bit set).  QNaN values
377      * can encode a 51-bit payload.  Hardware produced and C-library payloads typically
378      * have a payload of zero.  We assume that non-zero payloads are available to encode
379      * pointer and integer values.  Since any 64-bit bit pattern where the top 15 bits are
380      * all set represents a NaN with a non-zero payload, we can use this space in the NaN
381      * ranges to encode other values (however there are also other ranges of NaN space that
382      * could have been selected).
383      *
<span class="line-modified">384      * This range of NaN space is represented by 64-bit numbers begining with the 16-bit</span>
<span class="line-modified">385      * hex patterns 0xFFFE and 0xFFFF - we rely on the fact that no valid double-precision</span>
386      * numbers will fall in these ranges.
387      *
<span class="line-modified">388      * The top 16-bits denote the type of the encoded JSValue:</span>
389      *
390      *     Pointer {  0000:PPPP:PPPP:PPPP
<span class="line-modified">391      *              / 0001:****:****:****</span>
392      *     Double  {         ...
<span class="line-modified">393      *              \ FFFE:****:****:****</span>
<span class="line-modified">394      *     Integer {  FFFF:0000:IIII:IIII</span>
395      *
396      * The scheme we have implemented encodes double precision values by performing a
<span class="line-modified">397      * 64-bit integer addition of the value 2^48 to the number. After this manipulation</span>
<span class="line-modified">398      * no encoded double-precision value will begin with the pattern 0x0000 or 0xFFFF.</span>
399      * Values must be decoded by reversing this operation before subsequent floating point
400      * operations may be peformed.
401      *
<span class="line-modified">402      * 32-bit signed integers are marked with the 16-bit tag 0xFFFF.</span>
403      *
404      * The tag 0x0000 denotes a pointer, or another form of tagged immediate. Boolean,
405      * null and undefined values are represented by specific, invalid pointer values:
406      *
407      *     False:     0x06
408      *     True:      0x07
409      *     Undefined: 0x0a
410      *     Null:      0x02
411      *
412      * These values have the following properties:
<span class="line-modified">413      * - Bit 1 (TagBitTypeOther) is set for all four values, allowing real pointers to be</span>
414      *   quickly distinguished from all immediate values, including these invalid pointers.
<span class="line-modified">415      * - With bit 3 is masked out (TagBitUndefined) Undefined and Null share the</span>
416      *   same value, allowing null &amp; undefined to be quickly detected.
417      *
418      * No valid JSValue will have the bit pattern 0x0, this is used to represent array
419      * holes, and as a C++ &#39;no value&#39; result (e.g. JSValue() has an internal value of 0).
420      */
421 
<span class="line-modified">422     // These values are #defines since using static const integers here is a ~1% regression!</span>
<span class="line-modified">423 </span>
<span class="line-modified">424     // This value is 2^48, used to encode doubles such that the encoded value will begin</span>
<span class="line-modified">425     // with a 16-bit pattern within the range 0x0001..0xFFFE.</span>
<span class="line-removed">426     #define DoubleEncodeOffset 0x1000000000000ll</span>
427     // If all bits in the mask are set, this indicates an integer number,
428     // if any but not all are set this value is a double precision number.
<span class="line-modified">429     #define TagTypeNumber 0xffff000000000000ll</span>
430 
431     // All non-numeric (bool, null, undefined) immediates have bit 2 set.
<span class="line-modified">432     #define TagBitTypeOther 0x2ll</span>
<span class="line-modified">433     #define TagBitBool      0x4ll</span>
<span class="line-modified">434     #define TagBitUndefined 0x8ll</span>
435     // Combined integer value for non-numeric immediates.
<span class="line-modified">436     #define ValueFalse     (TagBitTypeOther | TagBitBool | false)</span>
<span class="line-modified">437     #define ValueTrue      (TagBitTypeOther | TagBitBool | true)</span>
<span class="line-modified">438     #define ValueUndefined (TagBitTypeOther | TagBitUndefined)</span>
<span class="line-modified">439     #define ValueNull      (TagBitTypeOther)</span>


440 
<span class="line-modified">441     // TagMask is used to check for all types of immediate values (either number or &#39;other&#39;).</span>
<span class="line-modified">442     #define TagMask (TagTypeNumber | TagBitTypeOther)</span>
443 
444     // These special values are never visible to JavaScript code; Empty is used to represent
445     // Array holes, and for uninitialized JSValues. Deleted is used in hash table code.
446     // These values would map to cell types in the JSValue encoding, but not valid GC cell
447     // pointer should have either of these values (Empty is null, deleted is at an invalid
448     // alignment for a GC cell, and in the zero page).
<span class="line-modified">449     #define ValueEmpty   0x0ll</span>
<span class="line-modified">450     #define ValueDeleted 0x4ll</span>
451 
<span class="line-modified">452     #define TagBitsWasm (TagBitTypeOther | 0x1)</span>
<span class="line-modified">453     #define TagWasmMask (TagTypeNumber | 0x7)</span>
454     // We tag Wasm non-JSCell pointers with a 3 at the bottom. We can test if a 64-bit JSValue pattern
455     // is a Wasm callee by masking the upper 16 bits and the lower 3 bits, and seeing if
<span class="line-modified">456     // the resulting value is 3. The full test is: x &amp; TagWasmMask == TagBitsWasm</span>
457     // This works because the lower 3 bits of the non-number immediate values are as follows:
458     // undefined: 0b010
459     // null:      0b010
460     // true:      0b111
461     // false:     0b110
462     // The test rejects all of these because none have just the value 3 in their lower 3 bits.
463     // The test rejects all numbers because they have non-zero upper 16 bits.
464     // The test also rejects normal cells because they won&#39;t have the number 3 as
465     // their lower 3 bits. Note, this bit pattern also allows the normal JSValue isCell(), etc,
466     // predicates to work on a Wasm::Callee because the various tests will fail if you
467     // bit casted a boxed Wasm::Callee* to a JSValue. isCell() would fail since it sees
<span class="line-modified">468     // TagBitTypeOther. The other tests also trivially fail, since it won&#39;t be a number,</span>
469     // and it won&#39;t be equal to null, undefined, true, or false. The isBoolean() predicate
<span class="line-modified">470     // will fail because we won&#39;t have TagBitBool set.</span>
471 #endif
472 
473 private:
474     template &lt;class T&gt; JSValue(WriteBarrierBase&lt;T, WriteBarrierTraitsSelect&lt;T&gt;&gt;);
475 
476     enum HashTableDeletedValueTag { HashTableDeletedValue };
477     JSValue(HashTableDeletedValueTag);
478 
479     inline const JSValue asValue() const { return *this; }
<span class="line-modified">480     JS_EXPORT_PRIVATE double toNumberSlowCase(ExecState*) const;</span>
<span class="line-modified">481     JS_EXPORT_PRIVATE JSString* toStringSlowCase(ExecState*, bool returnEmptyStringOnError) const;</span>
<span class="line-modified">482     JS_EXPORT_PRIVATE WTF::String toWTFStringSlowCase(ExecState*) const;</span>
<span class="line-modified">483     JS_EXPORT_PRIVATE JSObject* toObjectSlowCase(ExecState*, JSGlobalObject*) const;</span>
<span class="line-modified">484     JS_EXPORT_PRIVATE JSValue toThisSlowCase(ExecState*, ECMAMode) const;</span>
485 
486     EncodedValueDescriptor u;
487 };
488 
489 typedef IntHash&lt;EncodedJSValue&gt; EncodedJSValueHash;
490 
491 #if USE(JSVALUE32_64)
492 struct EncodedJSValueHashTraits : HashTraits&lt;EncodedJSValue&gt; {
<span class="line-modified">493     static const bool emptyValueIsZero = false;</span>
494     static EncodedJSValue emptyValue() { return JSValue::encode(JSValue()); }
495     static void constructDeletedValue(EncodedJSValue&amp; slot) { slot = JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
496     static bool isDeletedValue(EncodedJSValue value) { return value == JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
497 };
498 #else
499 struct EncodedJSValueHashTraits : HashTraits&lt;EncodedJSValue&gt; {
500     static void constructDeletedValue(EncodedJSValue&amp; slot) { slot = JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
501     static bool isDeletedValue(EncodedJSValue value) { return value == JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
502 };
503 #endif
504 
505 typedef std::pair&lt;EncodedJSValue, SourceCodeRepresentation&gt; EncodedJSValueWithRepresentation;
506 
507 struct EncodedJSValueWithRepresentationHashTraits : HashTraits&lt;EncodedJSValueWithRepresentation&gt; {
<span class="line-modified">508     static const bool emptyValueIsZero = false;</span>
509     static EncodedJSValueWithRepresentation emptyValue() { return std::make_pair(JSValue::encode(JSValue()), SourceCodeRepresentation::Other); }
510     static void constructDeletedValue(EncodedJSValueWithRepresentation&amp; slot) { slot = std::make_pair(JSValue::encode(JSValue(JSValue::HashTableDeletedValue)), SourceCodeRepresentation::Other); }
511     static bool isDeletedValue(EncodedJSValueWithRepresentation value) { return value == std::make_pair(JSValue::encode(JSValue(JSValue::HashTableDeletedValue)), SourceCodeRepresentation::Other); }
512 };
513 
514 struct EncodedJSValueWithRepresentationHash {
515     static unsigned hash(const EncodedJSValueWithRepresentation&amp; value)
516     {
517         return WTF::pairIntHash(EncodedJSValueHash::hash(value.first), IntHash&lt;SourceCodeRepresentation&gt;::hash(value.second));
518     }
519     static bool equal(const EncodedJSValueWithRepresentation&amp; a, const EncodedJSValueWithRepresentation&amp; b)
520     {
521         return a == b;
522     }
<span class="line-modified">523     static const bool safeToCompareToEmptyOrDeleted = true;</span>
524 };
525 
526 // Stand-alone helper functions.
527 inline JSValue jsNull()
528 {
529     return JSValue(JSValue::JSNull);
530 }
531 
532 inline JSValue jsUndefined()
533 {
534     return JSValue(JSValue::JSUndefined);
535 }
536 
537 inline JSValue jsTDZValue()
538 {
539     return JSValue();
540 }
541 
542 inline JSValue jsBoolean(bool b)
543 {
</pre>
<hr />
<pre>
615 ALWAYS_INLINE EncodedJSValue encodedJSUndefined()
616 {
617     return JSValue::encode(jsUndefined());
618 }
619 
620 ALWAYS_INLINE EncodedJSValue encodedJSValue()
621 {
622     return JSValue::encode(JSValue());
623 }
624 
625 inline bool operator==(const JSValue a, const JSCell* b) { return a == JSValue(b); }
626 inline bool operator==(const JSCell* a, const JSValue b) { return JSValue(a) == b; }
627 
628 inline bool operator!=(const JSValue a, const JSCell* b) { return a != JSValue(b); }
629 inline bool operator!=(const JSCell* a, const JSValue b) { return JSValue(a) != b; }
630 
631 
632 bool isThisValueAltered(const PutPropertySlot&amp;, JSObject* baseObject);
633 
634 // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
<span class="line-modified">635 bool sameValue(ExecState*, JSValue a, JSValue b);</span>
636 
637 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 #include &quot;JSExportMacros.h&quot;
 26 #include &quot;PureNaN.h&quot;
 27 #include &lt;functional&gt;
 28 #include &lt;math.h&gt;
 29 #include &lt;stddef.h&gt;
 30 #include &lt;stdint.h&gt;
 31 #include &lt;wtf/Assertions.h&gt;
 32 #include &lt;wtf/Forward.h&gt;
 33 #include &lt;wtf/HashMap.h&gt;
 34 #include &lt;wtf/HashTraits.h&gt;
 35 #include &lt;wtf/MathExtras.h&gt;
 36 #include &lt;wtf/MediaTime.h&gt;
 37 #include &lt;wtf/StdLibExtras.h&gt;
 38 #include &lt;wtf/TriState.h&gt;
 39 
 40 namespace JSC {
 41 
 42 class AssemblyHelpers;
 43 class JSBigInt;
<span class="line-modified"> 44 class CallFrame;</span>
 45 class JSCell;
 46 class JSValueSource;
 47 class VM;
 48 class JSGlobalObject;
 49 class JSObject;
 50 class JSString;
 51 class Identifier;
 52 class PropertyName;
 53 class PropertySlot;
 54 class PutPropertySlot;
 55 class Structure;
 56 #if ENABLE(DFG_JIT)
 57 namespace DFG {
 58 class JITCompiler;
 59 class OSRExitCompiler;
 60 class SpeculativeJIT;
 61 }
 62 #endif
 63 #if ENABLE(C_LOOP)
 64 namespace LLInt {
</pre>
<hr />
<pre>
112 #define TagOffset (offsetof(EncodedValueDescriptor, asBits.tag))
113 #define PayloadOffset (offsetof(EncodedValueDescriptor, asBits.payload))
114 
115 #if USE(JSVALUE64)
116 #define CellPayloadOffset 0
117 #else
118 #define CellPayloadOffset PayloadOffset
119 #endif
120 
121 enum WhichValueWord {
122     TagWord,
123     PayloadWord
124 };
125 
126 int64_t tryConvertToInt52(double);
127 bool isInt52(double);
128 
129 enum class SourceCodeRepresentation : uint8_t {
130     Other,
131     Integer,
<span class="line-modified">132     Double,</span>
<span class="line-added">133     LinkTimeConstant,</span>
134 };
135 
136 class JSValue {
137     friend struct EncodedJSValueHashTraits;
138     friend struct EncodedJSValueWithRepresentationHashTraits;
139     friend class AssemblyHelpers;
140     friend class JIT;
141     friend class JITSlowPathCall;
142     friend class JITStubs;
143     friend class JITStubCall;
144     friend class JSInterfaceJIT;
145     friend class JSValueSource;
146     friend class SpecializedThunkJIT;
147 #if ENABLE(DFG_JIT)
148     friend class DFG::JITCompiler;
149     friend class DFG::OSRExitCompiler;
150     friend class DFG::SpeculativeJIT;
151 #endif
152 #if ENABLE(C_LOOP)
153     friend class LLInt::CLoop;
</pre>
<hr />
<pre>
229     bool isUndefined() const;
230     bool isNull() const;
231     bool isUndefinedOrNull() const;
232     bool isBoolean() const;
233     bool isAnyInt() const;
234     bool isUInt32AsAnyInt() const;
235     bool isInt32AsAnyInt() const;
236     bool isNumber() const;
237     bool isString() const;
238     bool isBigInt() const;
239     bool isSymbol() const;
240     bool isPrimitive() const;
241     bool isGetterSetter() const;
242     bool isCustomGetterSetter() const;
243     bool isObject() const;
244     bool inherits(VM&amp;, const ClassInfo*) const;
245     template&lt;typename Target&gt; bool inherits(VM&amp;) const;
246     const ClassInfo* classInfoOrNull(VM&amp;) const;
247 
248     // Extracting the value.
<span class="line-modified">249     bool getString(JSGlobalObject*, WTF::String&amp;) const;</span>
<span class="line-modified">250     WTF::String getString(JSGlobalObject*) const; // null string if not a string</span>
251     JSObject* getObject() const; // 0 if not an object
252 
253     // Extracting integer values.
254     bool getUInt32(uint32_t&amp;) const;
255 
256     // Basic conversions.
<span class="line-modified">257     JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="line-modified">258     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp;);</span>
259 
<span class="line-modified">260     bool toBoolean(JSGlobalObject*) const;</span>
261     TriState pureToBoolean() const;
262 
263     // toNumber conversion is expected to be side effect free if an exception has
<span class="line-modified">264     // been set in the CallFrame already.</span>
<span class="line-modified">265     double toNumber(JSGlobalObject*) const;</span>
266 
<span class="line-modified">267     Variant&lt;JSBigInt*, double&gt; toNumeric(JSGlobalObject*) const;</span>
<span class="line-modified">268     Variant&lt;JSBigInt*, int32_t&gt; toBigIntOrInt32(JSGlobalObject*) const;</span>
269 
270     // toNumber conversion if it can be done without side effects.
271     Optional&lt;double&gt; toNumberFromPrimitive() const;
272 
<span class="line-modified">273     JSString* toString(JSGlobalObject*) const; // On exception, this returns the empty string.</span>
<span class="line-modified">274     JSString* toStringOrNull(JSGlobalObject*) const; // On exception, this returns null, to make exception checks faster.</span>
<span class="line-modified">275     Identifier toPropertyKey(JSGlobalObject*) const;</span>
<span class="line-modified">276     JSValue toPropertyKeyValue(JSGlobalObject*) const;</span>
<span class="line-modified">277     WTF::String toWTFString(JSGlobalObject*) const;</span>
<span class="line-modified">278     JSObject* toObject(JSGlobalObject*) const;</span>
279 
280     // Integer conversions.
<span class="line-modified">281     JS_EXPORT_PRIVATE double toInteger(JSGlobalObject*) const;</span>
<span class="line-modified">282     JS_EXPORT_PRIVATE double toIntegerPreserveNaN(JSGlobalObject*) const;</span>
<span class="line-modified">283     int32_t toInt32(JSGlobalObject*) const;</span>
<span class="line-modified">284     uint32_t toUInt32(JSGlobalObject*) const;</span>
<span class="line-modified">285     uint32_t toIndex(JSGlobalObject*, const char* errorName) const;</span>
<span class="line-modified">286     double toLength(JSGlobalObject*) const;</span>
287 
288     // Floating point conversions (this is a convenience function for WebCore;
289     // single precision float is not a representation used in JS or JSC).
<span class="line-modified">290     float toFloat(JSGlobalObject* globalObject) const { return static_cast&lt;float&gt;(toNumber(globalObject)); }</span>
291 
292     // Object operations, with the toObject operation included.
<span class="line-modified">293     JSValue get(JSGlobalObject*, PropertyName) const;</span>
<span class="line-modified">294     JSValue get(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">295     JSValue get(JSGlobalObject*, unsigned propertyName) const;</span>
<span class="line-modified">296     JSValue get(JSGlobalObject*, unsigned propertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">297     JSValue get(JSGlobalObject*, uint64_t propertyName) const;</span>
<span class="line-modified">298 </span>
<span class="line-modified">299     bool getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">300     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, CallbackWhenNoException) const;</span>
<span class="line-modified">301     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
<span class="line-modified">302 </span>
<span class="line-modified">303     bool getOwnPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified">304 </span>
<span class="line-modified">305     bool put(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">306     bool putInline(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">307     JS_EXPORT_PRIVATE bool putToPrimitive(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">308     JS_EXPORT_PRIVATE bool putToPrimitiveByIndex(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">309     bool putByIndex(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">310 </span>
<span class="line-modified">311     JSValue toThis(JSGlobalObject*, ECMAMode) const;</span>
<span class="line-modified">312 </span>
<span class="line-modified">313     static bool equal(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="line-modified">314     static bool equalSlowCase(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="line-modified">315     static bool equalSlowCaseInline(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="line-modified">316     static bool strictEqual(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="line-modified">317     static bool strictEqualSlowCase(JSGlobalObject*, JSValue v1, JSValue v2);</span>
<span class="line-modified">318     static bool strictEqualSlowCaseInline(JSGlobalObject*, JSValue v1, JSValue v2);</span>
319     static TriState pureStrictEqual(JSValue v1, JSValue v2);
320 
321     bool isCell() const;
322     JSCell* asCell() const;
323     JS_EXPORT_PRIVATE bool isValidCallee();
324 
325     Structure* structureOrNull() const;
326     JSValue structureOrUndefined() const;
327 
328     JS_EXPORT_PRIVATE void dump(PrintStream&amp;) const;
329     void dumpInContext(PrintStream&amp;, DumpContext*) const;
330     void dumpInContextAssumingStructure(PrintStream&amp;, DumpContext*, Structure*) const;
331     void dumpForBacktrace(PrintStream&amp;) const;
332 
<span class="line-modified">333     JS_EXPORT_PRIVATE JSObject* synthesizePrototype(JSGlobalObject*) const;</span>
<span class="line-modified">334     bool requireObjectCoercible(JSGlobalObject*) const;</span>
335 
336     // Constants used for Int52. Int52 isn&#39;t part of JSValue right now, but JSValues may be
337     // converted to Int52s and back again.
338     static constexpr const unsigned numberOfInt52Bits = 52;
339     static constexpr const int64_t notInt52 = static_cast&lt;int64_t&gt;(1) &lt;&lt; numberOfInt52Bits;
340     static constexpr const unsigned int52ShiftAmount = 12;
341 
342     static ptrdiff_t offsetOfPayload() { return OBJECT_OFFSETOF(JSValue, u.asBits.payload); }
343     static ptrdiff_t offsetOfTag() { return OBJECT_OFFSETOF(JSValue, u.asBits.tag); }
344 
345 #if USE(JSVALUE32_64)
346     /*
347      * On 32-bit platforms USE(JSVALUE32_64) should be defined, and we use a NaN-encoded
348      * form for immediates.
349      *
350      * The encoding makes use of unused NaN space in the IEEE754 representation.  Any value
351      * with the top 13 bits set represents a QNaN (with the sign bit set).  QNaN values
352      * can encode a 51-bit payload.  Hardware produced and C-library payloads typically
353      * have a payload of zero.  We assume that non-zero payloads are available to encode
354      * pointer and integer values.  Since any 64-bit bit pattern where the top 15 bits are
</pre>
<hr />
<pre>
365     int32_t payload() const;
366 
367     // This should only be used by the LLInt C Loop interpreter and OSRExit code who needs
368     // synthesize JSValue from its &quot;register&quot;s holding tag and payload values.
369     explicit JSValue(int32_t tag, int32_t payload);
370 
371 #elif USE(JSVALUE64)
372     /*
373      * On 64-bit platforms USE(JSVALUE64) should be defined, and we use a NaN-encoded
374      * form for immediates.
375      *
376      * The encoding makes use of unused NaN space in the IEEE754 representation.  Any value
377      * with the top 13 bits set represents a QNaN (with the sign bit set).  QNaN values
378      * can encode a 51-bit payload.  Hardware produced and C-library payloads typically
379      * have a payload of zero.  We assume that non-zero payloads are available to encode
380      * pointer and integer values.  Since any 64-bit bit pattern where the top 15 bits are
381      * all set represents a NaN with a non-zero payload, we can use this space in the NaN
382      * ranges to encode other values (however there are also other ranges of NaN space that
383      * could have been selected).
384      *
<span class="line-modified">385      * This range of NaN space is represented by 64-bit numbers begining with the 15-bit</span>
<span class="line-modified">386      * hex patterns 0xFFFC and 0xFFFE - we rely on the fact that no valid double-precision</span>
387      * numbers will fall in these ranges.
388      *
<span class="line-modified">389      * The top 15-bits denote the type of the encoded JSValue:</span>
390      *
391      *     Pointer {  0000:PPPP:PPPP:PPPP
<span class="line-modified">392      *              / 0002:****:****:****</span>
393      *     Double  {         ...
<span class="line-modified">394      *              \ FFFC:****:****:****</span>
<span class="line-modified">395      *     Integer {  FFFE:0000:IIII:IIII</span>
396      *
397      * The scheme we have implemented encodes double precision values by performing a
<span class="line-modified">398      * 64-bit integer addition of the value 2^49 to the number. After this manipulation</span>
<span class="line-modified">399      * no encoded double-precision value will begin with the pattern 0x0000 or 0xFFFE.</span>
400      * Values must be decoded by reversing this operation before subsequent floating point
401      * operations may be peformed.
402      *
<span class="line-modified">403      * 32-bit signed integers are marked with the 16-bit tag 0xFFFE.</span>
404      *
405      * The tag 0x0000 denotes a pointer, or another form of tagged immediate. Boolean,
406      * null and undefined values are represented by specific, invalid pointer values:
407      *
408      *     False:     0x06
409      *     True:      0x07
410      *     Undefined: 0x0a
411      *     Null:      0x02
412      *
413      * These values have the following properties:
<span class="line-modified">414      * - Bit 1 (OtherTag) is set for all four values, allowing real pointers to be</span>
415      *   quickly distinguished from all immediate values, including these invalid pointers.
<span class="line-modified">416      * - With bit 3 is masked out (UndefinedTag) Undefined and Null share the</span>
417      *   same value, allowing null &amp; undefined to be quickly detected.
418      *
419      * No valid JSValue will have the bit pattern 0x0, this is used to represent array
420      * holes, and as a C++ &#39;no value&#39; result (e.g. JSValue() has an internal value of 0).
421      */
422 
<span class="line-modified">423     // This value is 2^49, used to encode doubles such that the encoded value will begin</span>
<span class="line-modified">424     // with a 15-bit pattern within the range 0x0002..0xFFFC.</span>
<span class="line-modified">425     static constexpr size_t DoubleEncodeOffsetBit = 49;</span>
<span class="line-modified">426     static constexpr int64_t DoubleEncodeOffset = 1ll &lt;&lt; DoubleEncodeOffsetBit;</span>

427     // If all bits in the mask are set, this indicates an integer number,
428     // if any but not all are set this value is a double precision number.
<span class="line-modified">429     static constexpr int64_t NumberTag = 0xfffe000000000000ll;</span>
430 
431     // All non-numeric (bool, null, undefined) immediates have bit 2 set.
<span class="line-modified">432     static constexpr int32_t OtherTag       = 0x2;</span>
<span class="line-modified">433     static constexpr int32_t BoolTag        = 0x4;</span>
<span class="line-modified">434     static constexpr int32_t UndefinedTag   = 0x8;</span>
435     // Combined integer value for non-numeric immediates.
<span class="line-modified">436     static constexpr int32_t ValueFalse     = OtherTag | BoolTag | false;</span>
<span class="line-modified">437     static constexpr int32_t ValueTrue      = OtherTag | BoolTag | true;</span>
<span class="line-modified">438     static constexpr int32_t ValueUndefined = OtherTag | UndefinedTag;</span>
<span class="line-modified">439     static constexpr int32_t ValueNull      = OtherTag;</span>
<span class="line-added">440 </span>
<span class="line-added">441     static constexpr int64_t MiscTag = OtherTag | BoolTag | UndefinedTag;</span>
442 
<span class="line-modified">443     // NotCellMask is used to check for all types of immediate values (either number or &#39;other&#39;).</span>
<span class="line-modified">444     static constexpr int64_t NotCellMask = NumberTag | OtherTag;</span>
445 
446     // These special values are never visible to JavaScript code; Empty is used to represent
447     // Array holes, and for uninitialized JSValues. Deleted is used in hash table code.
448     // These values would map to cell types in the JSValue encoding, but not valid GC cell
449     // pointer should have either of these values (Empty is null, deleted is at an invalid
450     // alignment for a GC cell, and in the zero page).
<span class="line-modified">451     static constexpr int32_t ValueEmpty   = 0x0;</span>
<span class="line-modified">452     static constexpr int32_t ValueDeleted = 0x4;</span>
453 
<span class="line-modified">454     static constexpr int64_t WasmTag = OtherTag | 0x1;</span>
<span class="line-modified">455     static constexpr int64_t WasmMask = NumberTag | 0x7;</span>
456     // We tag Wasm non-JSCell pointers with a 3 at the bottom. We can test if a 64-bit JSValue pattern
457     // is a Wasm callee by masking the upper 16 bits and the lower 3 bits, and seeing if
<span class="line-modified">458     // the resulting value is 3. The full test is: x &amp; WasmMask == WasmTag</span>
459     // This works because the lower 3 bits of the non-number immediate values are as follows:
460     // undefined: 0b010
461     // null:      0b010
462     // true:      0b111
463     // false:     0b110
464     // The test rejects all of these because none have just the value 3 in their lower 3 bits.
465     // The test rejects all numbers because they have non-zero upper 16 bits.
466     // The test also rejects normal cells because they won&#39;t have the number 3 as
467     // their lower 3 bits. Note, this bit pattern also allows the normal JSValue isCell(), etc,
468     // predicates to work on a Wasm::Callee because the various tests will fail if you
469     // bit casted a boxed Wasm::Callee* to a JSValue. isCell() would fail since it sees
<span class="line-modified">470     // OtherTag. The other tests also trivially fail, since it won&#39;t be a number,</span>
471     // and it won&#39;t be equal to null, undefined, true, or false. The isBoolean() predicate
<span class="line-modified">472     // will fail because we won&#39;t have BoolTag set.</span>
473 #endif
474 
475 private:
476     template &lt;class T&gt; JSValue(WriteBarrierBase&lt;T, WriteBarrierTraitsSelect&lt;T&gt;&gt;);
477 
478     enum HashTableDeletedValueTag { HashTableDeletedValue };
479     JSValue(HashTableDeletedValueTag);
480 
481     inline const JSValue asValue() const { return *this; }
<span class="line-modified">482     JS_EXPORT_PRIVATE double toNumberSlowCase(JSGlobalObject*) const;</span>
<span class="line-modified">483     JS_EXPORT_PRIVATE JSString* toStringSlowCase(JSGlobalObject*, bool returnEmptyStringOnError) const;</span>
<span class="line-modified">484     JS_EXPORT_PRIVATE WTF::String toWTFStringSlowCase(JSGlobalObject*) const;</span>
<span class="line-modified">485     JS_EXPORT_PRIVATE JSObject* toObjectSlowCase(JSGlobalObject*) const;</span>
<span class="line-modified">486     JS_EXPORT_PRIVATE JSValue toThisSlowCase(JSGlobalObject*, ECMAMode) const;</span>
487 
488     EncodedValueDescriptor u;
489 };
490 
491 typedef IntHash&lt;EncodedJSValue&gt; EncodedJSValueHash;
492 
493 #if USE(JSVALUE32_64)
494 struct EncodedJSValueHashTraits : HashTraits&lt;EncodedJSValue&gt; {
<span class="line-modified">495     static constexpr bool emptyValueIsZero = false;</span>
496     static EncodedJSValue emptyValue() { return JSValue::encode(JSValue()); }
497     static void constructDeletedValue(EncodedJSValue&amp; slot) { slot = JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
498     static bool isDeletedValue(EncodedJSValue value) { return value == JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
499 };
500 #else
501 struct EncodedJSValueHashTraits : HashTraits&lt;EncodedJSValue&gt; {
502     static void constructDeletedValue(EncodedJSValue&amp; slot) { slot = JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
503     static bool isDeletedValue(EncodedJSValue value) { return value == JSValue::encode(JSValue(JSValue::HashTableDeletedValue)); }
504 };
505 #endif
506 
507 typedef std::pair&lt;EncodedJSValue, SourceCodeRepresentation&gt; EncodedJSValueWithRepresentation;
508 
509 struct EncodedJSValueWithRepresentationHashTraits : HashTraits&lt;EncodedJSValueWithRepresentation&gt; {
<span class="line-modified">510     static constexpr bool emptyValueIsZero = false;</span>
511     static EncodedJSValueWithRepresentation emptyValue() { return std::make_pair(JSValue::encode(JSValue()), SourceCodeRepresentation::Other); }
512     static void constructDeletedValue(EncodedJSValueWithRepresentation&amp; slot) { slot = std::make_pair(JSValue::encode(JSValue(JSValue::HashTableDeletedValue)), SourceCodeRepresentation::Other); }
513     static bool isDeletedValue(EncodedJSValueWithRepresentation value) { return value == std::make_pair(JSValue::encode(JSValue(JSValue::HashTableDeletedValue)), SourceCodeRepresentation::Other); }
514 };
515 
516 struct EncodedJSValueWithRepresentationHash {
517     static unsigned hash(const EncodedJSValueWithRepresentation&amp; value)
518     {
519         return WTF::pairIntHash(EncodedJSValueHash::hash(value.first), IntHash&lt;SourceCodeRepresentation&gt;::hash(value.second));
520     }
521     static bool equal(const EncodedJSValueWithRepresentation&amp; a, const EncodedJSValueWithRepresentation&amp; b)
522     {
523         return a == b;
524     }
<span class="line-modified">525     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
526 };
527 
528 // Stand-alone helper functions.
529 inline JSValue jsNull()
530 {
531     return JSValue(JSValue::JSNull);
532 }
533 
534 inline JSValue jsUndefined()
535 {
536     return JSValue(JSValue::JSUndefined);
537 }
538 
539 inline JSValue jsTDZValue()
540 {
541     return JSValue();
542 }
543 
544 inline JSValue jsBoolean(bool b)
545 {
</pre>
<hr />
<pre>
617 ALWAYS_INLINE EncodedJSValue encodedJSUndefined()
618 {
619     return JSValue::encode(jsUndefined());
620 }
621 
622 ALWAYS_INLINE EncodedJSValue encodedJSValue()
623 {
624     return JSValue::encode(JSValue());
625 }
626 
627 inline bool operator==(const JSValue a, const JSCell* b) { return a == JSValue(b); }
628 inline bool operator==(const JSCell* a, const JSValue b) { return JSValue(a) == b; }
629 
630 inline bool operator!=(const JSValue a, const JSCell* b) { return a != JSValue(b); }
631 inline bool operator!=(const JSCell* a, const JSValue b) { return JSValue(a) != b; }
632 
633 
634 bool isThisValueAltered(const PutPropertySlot&amp;, JSObject* baseObject);
635 
636 // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
<span class="line-modified">637 bool sameValue(JSGlobalObject*, JSValue a, JSValue b);</span>
638 
639 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSCJSValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCJSValueInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
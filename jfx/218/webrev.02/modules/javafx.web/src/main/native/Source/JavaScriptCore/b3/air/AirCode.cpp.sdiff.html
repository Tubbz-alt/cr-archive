<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AirCCallingConvention.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirCode.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirCode.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirAllocateRegistersAndStackAndGenerateCode.h&quot;
 32 #include &quot;AirCCallSpecial.h&quot;
 33 #include &quot;AirCFG.h&quot;
 34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
 35 #include &quot;B3BasicBlockUtils.h&quot;
 36 #include &quot;B3Procedure.h&quot;
 37 #include &quot;B3StackSlot.h&quot;

 38 #include &lt;wtf/ListDump.h&gt;
 39 #include &lt;wtf/MathExtras.h&gt;
 40 
 41 namespace JSC { namespace B3 { namespace Air {
 42 


 43 static void defaultPrologueGenerator(CCallHelpers&amp; jit, Code&amp; code)
 44 {
 45     jit.emitFunctionPrologue();
 46     if (code.frameSize()) {
 47         AllowMacroScratchRegisterUsageIf allowScratch(jit, isARM64());
 48         jit.addPtr(MacroAssembler::TrustedImm32(-code.frameSize()), MacroAssembler::framePointerRegister,  MacroAssembler::stackPointerRegister);
<span class="line-removed"> 49         if (Options::zeroStackFrame())</span>
<span class="line-removed"> 50             jit.clearStackFrame(MacroAssembler::framePointerRegister, MacroAssembler::stackPointerRegister, GPRInfo::nonArgGPR0, code.frameSize());</span>
 51     }
 52 
 53     jit.emitSave(code.calleeSaveRegisterAtOffsetList());
 54 }
 55 
 56 Code::Code(Procedure&amp; proc)
 57     : m_proc(proc)
 58     , m_cfg(new CFG(*this))
 59     , m_lastPhaseName(&quot;initial&quot;)
 60     , m_defaultPrologueGenerator(createSharedTask&lt;PrologueGeneratorFunction&gt;(&amp;defaultPrologueGenerator))
 61 {
 62     // Come up with initial orderings of registers. The user may replace this with something else.
 63     forEachBank(
 64         [&amp;] (Bank bank) {
 65             Vector&lt;Reg&gt; volatileRegs;
 66             Vector&lt;Reg&gt; calleeSaveRegs;
 67             RegisterSet all = bank == GP ? RegisterSet::allGPRs() : RegisterSet::allFPRs();
 68             all.exclude(RegisterSet::stackRegisters());
 69             all.exclude(RegisterSet::reservedHardwareRegisters());
 70             RegisterSet calleeSave = RegisterSet::calleeSaveRegisters();
</pre>
<hr />
<pre>
233 
234 void Code::resetReachability()
235 {
236     clearPredecessors(m_blocks);
237     if (m_entrypoints.isEmpty())
238         updatePredecessorsAfter(m_blocks[0].get());
239     else {
240         for (const FrequentedBlock&amp; entrypoint : m_entrypoints)
241             updatePredecessorsAfter(entrypoint.block());
242     }
243 
244     for (auto&amp; block : m_blocks) {
245         if (isBlockDead(block.get()) &amp;&amp; !isEntrypoint(block.get()))
246             block = nullptr;
247     }
248 }
249 
250 void Code::dump(PrintStream&amp; out) const
251 {
252     if (!m_entrypoints.isEmpty())
<span class="line-modified">253         out.print(&quot;Entrypoints: &quot;, listDump(m_entrypoints), &quot;\n&quot;);</span>
254     for (BasicBlock* block : *this)
255         out.print(deepDump(block));
256     if (stackSlots().size()) {
<span class="line-modified">257         out.print(&quot;Stack slots:\n&quot;);</span>
258         for (StackSlot* slot : stackSlots())
<span class="line-modified">259             out.print(&quot;    &quot;, pointerDump(slot), &quot;: &quot;, deepDump(slot), &quot;\n&quot;);</span>
260     }
261     if (specials().size()) {
<span class="line-modified">262         out.print(&quot;Specials:\n&quot;);</span>
263         for (Special* special : specials())
<span class="line-modified">264             out.print(&quot;    &quot;, deepDump(special), &quot;\n&quot;);</span>
265     }
266     if (m_frameSize || m_stackIsAllocated)
<span class="line-modified">267         out.print(&quot;Frame size: &quot;, m_frameSize, m_stackIsAllocated ? &quot; (Allocated)&quot; : &quot;&quot;, &quot;\n&quot;);</span>
268     if (m_callArgAreaSize)
<span class="line-modified">269         out.print(&quot;Call arg area size: &quot;, m_callArgAreaSize, &quot;\n&quot;);</span>
270     RegisterAtOffsetList calleeSaveRegisters = this-&gt;calleeSaveRegisterAtOffsetList();
271     if (calleeSaveRegisters.size())
<span class="line-modified">272         out.print(&quot;Callee saves: &quot;, calleeSaveRegisters, &quot;\n&quot;);</span>
273 }
274 
275 unsigned Code::findFirstBlockIndex(unsigned index) const
276 {
277     while (index &lt; size() &amp;&amp; !at(index))
278         index++;
279     return index;
280 }
281 
282 unsigned Code::findNextBlockIndex(unsigned index) const
283 {
284     return findFirstBlockIndex(index + 1);
285 }
286 
287 BasicBlock* Code::findNextBlock(BasicBlock* block) const
288 {
289     unsigned index = findNextBlockIndex(block-&gt;index());
290     if (index &lt; size())
291         return at(index);
292     return nullptr;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirCode.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirAllocateRegistersAndStackAndGenerateCode.h&quot;
 32 #include &quot;AirCCallSpecial.h&quot;
 33 #include &quot;AirCFG.h&quot;
 34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
 35 #include &quot;B3BasicBlockUtils.h&quot;
 36 #include &quot;B3Procedure.h&quot;
 37 #include &quot;B3StackSlot.h&quot;
<span class="line-added"> 38 #include &quot;CCallHelpers.h&quot;</span>
 39 #include &lt;wtf/ListDump.h&gt;
 40 #include &lt;wtf/MathExtras.h&gt;
 41 
 42 namespace JSC { namespace B3 { namespace Air {
 43 
<span class="line-added"> 44 const char* const tierName = &quot;Air &quot;;</span>
<span class="line-added"> 45 </span>
 46 static void defaultPrologueGenerator(CCallHelpers&amp; jit, Code&amp; code)
 47 {
 48     jit.emitFunctionPrologue();
 49     if (code.frameSize()) {
 50         AllowMacroScratchRegisterUsageIf allowScratch(jit, isARM64());
 51         jit.addPtr(MacroAssembler::TrustedImm32(-code.frameSize()), MacroAssembler::framePointerRegister,  MacroAssembler::stackPointerRegister);


 52     }
 53 
 54     jit.emitSave(code.calleeSaveRegisterAtOffsetList());
 55 }
 56 
 57 Code::Code(Procedure&amp; proc)
 58     : m_proc(proc)
 59     , m_cfg(new CFG(*this))
 60     , m_lastPhaseName(&quot;initial&quot;)
 61     , m_defaultPrologueGenerator(createSharedTask&lt;PrologueGeneratorFunction&gt;(&amp;defaultPrologueGenerator))
 62 {
 63     // Come up with initial orderings of registers. The user may replace this with something else.
 64     forEachBank(
 65         [&amp;] (Bank bank) {
 66             Vector&lt;Reg&gt; volatileRegs;
 67             Vector&lt;Reg&gt; calleeSaveRegs;
 68             RegisterSet all = bank == GP ? RegisterSet::allGPRs() : RegisterSet::allFPRs();
 69             all.exclude(RegisterSet::stackRegisters());
 70             all.exclude(RegisterSet::reservedHardwareRegisters());
 71             RegisterSet calleeSave = RegisterSet::calleeSaveRegisters();
</pre>
<hr />
<pre>
234 
235 void Code::resetReachability()
236 {
237     clearPredecessors(m_blocks);
238     if (m_entrypoints.isEmpty())
239         updatePredecessorsAfter(m_blocks[0].get());
240     else {
241         for (const FrequentedBlock&amp; entrypoint : m_entrypoints)
242             updatePredecessorsAfter(entrypoint.block());
243     }
244 
245     for (auto&amp; block : m_blocks) {
246         if (isBlockDead(block.get()) &amp;&amp; !isEntrypoint(block.get()))
247             block = nullptr;
248     }
249 }
250 
251 void Code::dump(PrintStream&amp; out) const
252 {
253     if (!m_entrypoints.isEmpty())
<span class="line-modified">254         out.print(tierName, &quot;Entrypoints: &quot;, listDump(m_entrypoints), &quot;\n&quot;);</span>
255     for (BasicBlock* block : *this)
256         out.print(deepDump(block));
257     if (stackSlots().size()) {
<span class="line-modified">258         out.print(tierName, &quot;Stack slots:\n&quot;);</span>
259         for (StackSlot* slot : stackSlots())
<span class="line-modified">260             out.print(tierName, &quot;    &quot;, pointerDump(slot), &quot;: &quot;, deepDump(slot), &quot;\n&quot;);</span>
261     }
262     if (specials().size()) {
<span class="line-modified">263         out.print(tierName, &quot;Specials:\n&quot;);</span>
264         for (Special* special : specials())
<span class="line-modified">265             out.print(tierName, &quot;    &quot;, deepDump(special), &quot;\n&quot;);</span>
266     }
267     if (m_frameSize || m_stackIsAllocated)
<span class="line-modified">268         out.print(tierName, &quot;Frame size: &quot;, m_frameSize, m_stackIsAllocated ? &quot; (Allocated)&quot; : &quot;&quot;, &quot;\n&quot;);</span>
269     if (m_callArgAreaSize)
<span class="line-modified">270         out.print(tierName, &quot;Call arg area size: &quot;, m_callArgAreaSize, &quot;\n&quot;);</span>
271     RegisterAtOffsetList calleeSaveRegisters = this-&gt;calleeSaveRegisterAtOffsetList();
272     if (calleeSaveRegisters.size())
<span class="line-modified">273         out.print(tierName, &quot;Callee saves: &quot;, calleeSaveRegisters, &quot;\n&quot;);</span>
274 }
275 
276 unsigned Code::findFirstBlockIndex(unsigned index) const
277 {
278     while (index &lt; size() &amp;&amp; !at(index))
279         index++;
280     return index;
281 }
282 
283 unsigned Code::findNextBlockIndex(unsigned index) const
284 {
285     return findFirstBlockIndex(index + 1);
286 }
287 
288 BasicBlock* Code::findNextBlock(BasicBlock* block) const
289 {
290     unsigned index = findNextBlockIndex(block-&gt;index());
291     if (index &lt; size())
292         return at(index);
293     return nullptr;
</pre>
</td>
</tr>
</table>
<center><a href="AirCCallingConvention.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirCode.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
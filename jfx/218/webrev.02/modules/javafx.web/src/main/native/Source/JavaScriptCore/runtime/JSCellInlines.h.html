<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCellInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;AllocatorForMode.h&quot;
 29 #include &quot;AllocatorInlines.h&quot;
 30 #include &quot;CompleteSubspaceInlines.h&quot;
 31 #include &quot;CPU.h&quot;
 32 #include &quot;CallFrameInlines.h&quot;
 33 #include &quot;DeferGC.h&quot;
 34 #include &quot;FreeListInlines.h&quot;
 35 #include &quot;Handle.h&quot;
 36 #include &quot;HeapInlines.h&quot;
 37 #include &quot;IsoSubspaceInlines.h&quot;
 38 #include &quot;JSBigInt.h&quot;
 39 #include &quot;JSCast.h&quot;
 40 #include &quot;JSDestructibleObject.h&quot;
 41 #include &quot;JSObject.h&quot;
 42 #include &quot;JSString.h&quot;
 43 #include &quot;LocalAllocatorInlines.h&quot;
 44 #include &quot;MarkedBlock.h&quot;
 45 #include &quot;SlotVisitorInlines.h&quot;
 46 #include &quot;Structure.h&quot;
 47 #include &quot;Symbol.h&quot;
 48 #include &lt;wtf/CompilationThread.h&gt;
 49 
 50 namespace JSC {
 51 
 52 inline JSCell::JSCell(CreatingEarlyCellTag)
 53     : m_cellState(CellState::DefinitelyWhite)
 54 {
 55     ASSERT(!isCompilationThread());
 56 }
 57 
 58 inline JSCell::JSCell(VM&amp;, Structure* structure)
 59     : m_structureID(structure-&gt;id())
 60     , m_indexingTypeAndMisc(structure-&gt;indexingModeIncludingHistory())
 61     , m_type(structure-&gt;typeInfo().type())
 62     , m_flags(structure-&gt;typeInfo().inlineTypeFlags())
 63     , m_cellState(CellState::DefinitelyWhite)
 64 {
 65     ASSERT(!isCompilationThread());
 66 }
 67 
 68 inline void JSCell::finishCreation(VM&amp; vm)
 69 {
 70     // This object is ready to be escaped so the concurrent GC may see it at any time. We have
 71     // to make sure that none of our stores sink below here.
 72     vm.heap.mutatorFence();
 73 #if ENABLE(GC_VALIDATION)
 74     ASSERT(vm.isInitializingObject());
 75     vm.setInitializingObjectClass(0);
 76 #else
 77     UNUSED_PARAM(vm);
 78 #endif
 79     ASSERT(m_structureID);
 80 }
 81 
 82 inline void JSCell::finishCreation(VM&amp; vm, Structure* structure, CreatingEarlyCellTag)
 83 {
 84 #if ENABLE(GC_VALIDATION)
 85     ASSERT(vm.isInitializingObject());
 86     vm.setInitializingObjectClass(0);
 87     if (structure) {
 88 #endif
 89         m_structureID = structure-&gt;id();
 90         m_indexingTypeAndMisc = structure-&gt;indexingModeIncludingHistory();
 91         m_type = structure-&gt;typeInfo().type();
 92         m_flags = structure-&gt;typeInfo().inlineTypeFlags();
 93 #if ENABLE(GC_VALIDATION)
 94     }
 95 #else
 96     UNUSED_PARAM(vm);
 97 #endif
 98     // Very first set of allocations won&#39;t have a real structure.
 99     ASSERT(m_structureID || !vm.structureStructure);
100 }
101 
102 inline JSType JSCell::type() const
103 {
104     return m_type;
105 }
106 
107 inline IndexingType JSCell::indexingTypeAndMisc() const
108 {
109     return m_indexingTypeAndMisc;
110 }
111 
112 inline IndexingType JSCell::indexingType() const
113 {
114     return indexingTypeAndMisc() &amp; AllWritableArrayTypes;
115 }
116 
117 inline IndexingType JSCell::indexingMode() const
118 {
119     return indexingTypeAndMisc() &amp; AllArrayTypes;
120 }
121 
122 ALWAYS_INLINE Structure* JSCell::structure() const
123 {
124     return structure(vm());
125 }
126 
127 ALWAYS_INLINE Structure* JSCell::structure(VM&amp; vm) const
128 {
129     return vm.getStructure(m_structureID);
130 }
131 
132 inline void JSCell::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
133 {
134     visitor.appendUnbarriered(cell-&gt;structure(visitor.vm()));
135 }
136 
137 inline void JSCell::visitOutputConstraints(JSCell*, SlotVisitor&amp;)
138 {
139 }
140 
141 ALWAYS_INLINE VM&amp; CallFrame::deprecatedVM() const
142 {
143     JSCell* callee = this-&gt;callee().asCell();
144     ASSERT(callee);
145     ASSERT(&amp;callee-&gt;vm());
146     return callee-&gt;vm();
147 }
148 
149 template&lt;typename Type&gt;
150 inline Allocator allocatorForNonVirtualConcurrently(VM&amp; vm, size_t allocationSize, AllocatorForMode mode)
151 {
152     if (auto* subspace = subspaceForConcurrently&lt;Type&gt;(vm))
153         return subspace-&gt;allocatorForNonVirtual(allocationSize, mode);
154     return { };
155 }
156 
157 template&lt;typename T&gt;
158 ALWAYS_INLINE void* tryAllocateCellHelper(Heap&amp; heap, size_t size, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)
159 {
160     VM&amp; vm = heap.vm();
161     ASSERT(deferralContext || !DisallowGC::isInEffectOnCurrentThread());
162     ASSERT(size &gt;= sizeof(T));
163     JSCell* result = static_cast&lt;JSCell*&gt;(subspaceFor&lt;T&gt;(vm)-&gt;allocateNonVirtual(vm, size, deferralContext, failureMode));
164     if (failureMode == AllocationFailureMode::ReturnNull &amp;&amp; !result)
165         return nullptr;
166 #if ENABLE(GC_VALIDATION)
167     ASSERT(!vm.isInitializingObject());
168     vm.setInitializingObjectClass(T::info());
169 #endif
170     result-&gt;clearStructure();
171     return result;
172 }
173 
174 template&lt;typename T&gt;
175 void* allocateCell(Heap&amp; heap, size_t size)
176 {
177     return tryAllocateCellHelper&lt;T&gt;(heap, size, nullptr, AllocationFailureMode::Assert);
178 }
179 
180 template&lt;typename T&gt;
181 void* tryAllocateCell(Heap&amp; heap, size_t size)
182 {
183     return tryAllocateCellHelper&lt;T&gt;(heap, size, nullptr, AllocationFailureMode::ReturnNull);
184 }
185 
186 template&lt;typename T&gt;
187 void* allocateCell(Heap&amp; heap, GCDeferralContext* deferralContext, size_t size)
188 {
189     return tryAllocateCellHelper&lt;T&gt;(heap, size, deferralContext, AllocationFailureMode::Assert);
190 }
191 
192 template&lt;typename T&gt;
193 void* tryAllocateCell(Heap&amp; heap, GCDeferralContext* deferralContext, size_t size)
194 {
195     return tryAllocateCellHelper&lt;T&gt;(heap, size, deferralContext, AllocationFailureMode::ReturnNull);
196 }
197 
198 inline bool JSCell::isObject() const
199 {
200     return TypeInfo::isObject(m_type);
201 }
202 
203 inline bool JSCell::isString() const
204 {
205     return m_type == StringType;
206 }
207 
208 inline bool JSCell::isBigInt() const
209 {
210     return m_type == BigIntType;
211 }
212 
213 inline bool JSCell::isSymbol() const
214 {
215     return m_type == SymbolType;
216 }
217 
218 inline bool JSCell::isGetterSetter() const
219 {
220     return m_type == GetterSetterType;
221 }
222 
223 inline bool JSCell::isCustomGetterSetter() const
224 {
225     return m_type == CustomGetterSetterType;
226 }
227 
228 inline bool JSCell::isProxy() const
229 {
230     return m_type == ImpureProxyType || m_type == PureForwardingProxyType || m_type == ProxyObjectType;
231 }
232 
233 ALWAYS_INLINE bool JSCell::isFunction(VM&amp; vm)
234 {
235     if (type() == JSFunctionType)
236         return true;
237     if (inlineTypeFlags() &amp; OverridesGetCallData) {
238         CallData ignoredCallData;
239         return methodTable(vm)-&gt;getCallData(this, ignoredCallData) != CallType::None;
240     }
241     return false;
242 }
243 
244 inline bool JSCell::isCallable(VM&amp; vm, CallType&amp; callType, CallData&amp; callData)
245 {
246     if (type() != JSFunctionType &amp;&amp; !(inlineTypeFlags() &amp; OverridesGetCallData))
247         return false;
248     callType = methodTable(vm)-&gt;getCallData(this, callData);
249     return callType != CallType::None;
250 }
251 
252 inline bool JSCell::isConstructor(VM&amp; vm)
253 {
254     ConstructType constructType;
255     ConstructData constructData;
256     return isConstructor(vm, constructType, constructData);
257 }
258 
259 inline bool JSCell::isConstructor(VM&amp; vm, ConstructType&amp; constructType, ConstructData&amp; constructData)
260 {
261     constructType = methodTable(vm)-&gt;getConstructData(this, constructData);
262     return constructType != ConstructType::None;
263 }
264 
265 inline bool JSCell::isAPIValueWrapper() const
266 {
267     return m_type == APIValueWrapperType;
268 }
269 
270 ALWAYS_INLINE void JSCell::setStructure(VM&amp; vm, Structure* structure)
271 {
272     ASSERT(structure-&gt;classInfo() == this-&gt;structure(vm)-&gt;classInfo());
273     ASSERT(!this-&gt;structure(vm)
274         || this-&gt;structure(vm)-&gt;transitionWatchpointSetHasBeenInvalidated()
275         || Heap::heap(this)-&gt;structureIDTable().get(structure-&gt;id()) == structure);
276     m_structureID = structure-&gt;id();
277     m_flags = TypeInfo::mergeInlineTypeFlags(structure-&gt;typeInfo().inlineTypeFlags(), m_flags);
278     m_type = structure-&gt;typeInfo().type();
279     IndexingType newIndexingType = structure-&gt;indexingModeIncludingHistory();
280     if (m_indexingTypeAndMisc != newIndexingType) {
281         ASSERT(!(newIndexingType &amp; ~AllArrayTypesAndHistory));
282         for (;;) {
283             IndexingType oldValue = m_indexingTypeAndMisc;
284             IndexingType newValue = (oldValue &amp; ~AllArrayTypesAndHistory) | structure-&gt;indexingModeIncludingHistory();
285             if (WTF::atomicCompareExchangeWeakRelaxed(&amp;m_indexingTypeAndMisc, oldValue, newValue))
286                 break;
287         }
288     }
289     vm.heap.writeBarrier(this, structure);
290 }
291 
292 inline const MethodTable* JSCell::methodTable(VM&amp; vm) const
293 {
294     Structure* structure = this-&gt;structure(vm);
295 #if ASSERT_ENABLED
296     if (Structure* rootStructure = structure-&gt;structure(vm))
297         ASSERT(rootStructure == rootStructure-&gt;structure(vm));
298 #endif
299     return &amp;structure-&gt;classInfo()-&gt;methodTable;
300 }
301 
302 inline bool JSCell::inherits(VM&amp; vm, const ClassInfo* info) const
303 {
304     return classInfo(vm)-&gt;isSubClassOf(info);
305 }
306 
307 template&lt;typename Target&gt;
308 inline bool JSCell::inherits(VM&amp; vm) const
309 {
310     return JSCastingHelpers::inherits&lt;Target&gt;(vm, this);
311 }
312 
313 ALWAYS_INLINE JSValue JSCell::fastGetOwnProperty(VM&amp; vm, Structure&amp; structure, PropertyName name)
314 {
315     ASSERT(canUseFastGetOwnProperty(structure));
316     PropertyOffset offset = structure.get(vm, name);
317     if (offset != invalidOffset)
318         return asObject(this)-&gt;locationForOffset(offset)-&gt;get();
319     return JSValue();
320 }
321 
322 inline bool JSCell::canUseFastGetOwnProperty(const Structure&amp; structure)
323 {
324     return !structure.hasGetterSetterProperties()
325         &amp;&amp; !structure.hasCustomGetterSetterProperties()
326         &amp;&amp; !structure.typeInfo().overridesGetOwnPropertySlot();
327 }
328 
329 ALWAYS_INLINE const ClassInfo* JSCell::classInfo(VM&amp; vm) const
330 {
331     // What we really want to assert here is that we&#39;re not currently destructing this object (which makes its classInfo
332     // invalid). If mutatorState() == MutatorState::Running, then we&#39;re not currently sweeping, and therefore cannot be
333     // destructing the object. The GC thread or JIT threads, unlike the mutator thread, are able to access classInfo
334     // independent of whether the mutator thread is sweeping or not. Hence, we also check for !currentThreadIsHoldingAPILock()
335     // to allow the GC thread or JIT threads to pass this assertion.
336     ASSERT(vm.heap.mutatorState() != MutatorState::Sweeping || !vm.currentThreadIsHoldingAPILock());
337     return structure(vm)-&gt;classInfo();
338 }
339 
340 inline bool JSCell::toBoolean(JSGlobalObject* globalObject) const
341 {
342     if (isString())
343         return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean();
344     if (isBigInt())
345         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean();
346     return !structure(getVM(globalObject))-&gt;masqueradesAsUndefined(globalObject);
347 }
348 
349 inline TriState JSCell::pureToBoolean() const
350 {
351     if (isString())
352         return static_cast&lt;const JSString*&gt;(this)-&gt;toBoolean() ? TrueTriState : FalseTriState;
353     if (isBigInt())
354         return static_cast&lt;const JSBigInt*&gt;(this)-&gt;toBoolean() ? TrueTriState : FalseTriState;
355     if (isSymbol())
356         return TrueTriState;
357     return MixedTriState;
358 }
359 
360 inline void JSCellLock::lock()
361 {
362     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
363     if (UNLIKELY(!IndexingTypeLockAlgorithm::lockFast(*lock)))
364         lockSlow();
365 }
366 
367 inline bool JSCellLock::tryLock()
368 {
369     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
370     return IndexingTypeLockAlgorithm::tryLock(*lock);
371 }
372 
373 inline void JSCellLock::unlock()
374 {
375     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
376     if (UNLIKELY(!IndexingTypeLockAlgorithm::unlockFast(*lock)))
377         unlockSlow();
378 }
379 
380 inline bool JSCellLock::isLocked() const
381 {
382     Atomic&lt;IndexingType&gt;* lock = bitwise_cast&lt;Atomic&lt;IndexingType&gt;*&gt;(&amp;m_indexingTypeAndMisc);
383     return IndexingTypeLockAlgorithm::isLocked(*lock);
384 }
385 
386 inline bool JSCell::perCellBit() const
387 {
388     return TypeInfo::perCellBit(inlineTypeFlags());
389 }
390 
391 inline void JSCell::setPerCellBit(bool value)
392 {
393     if (value == perCellBit())
394         return;
395 
396     if (value)
397         m_flags |= static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
398     else
399         m_flags &amp;= ~static_cast&lt;TypeInfo::InlineTypeFlags&gt;(TypeInfoPerCellBit);
400 }
401 
402 inline JSObject* JSCell::toObject(JSGlobalObject* globalObject) const
403 {
404     if (isObject())
405         return jsCast&lt;JSObject*&gt;(const_cast&lt;JSCell*&gt;(this));
406     return toObjectSlow(globalObject);
407 }
408 
409 ALWAYS_INLINE bool JSCell::putInline(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
410 {
411     auto putMethod = methodTable(getVM(globalObject))-&gt;put;
412     if (LIKELY(putMethod == JSObject::put))
413         return JSObject::putInlineForJSObject(asObject(this), globalObject, propertyName, value, slot);
414     return putMethod(this, globalObject, propertyName, value, slot);
415 }
416 
417 inline bool isWebAssemblyModule(const JSCell* cell)
418 {
419     return cell-&gt;type() == WebAssemblyModuleType;
420 }
421 
422 } // namespace JSC
    </pre>
  </body>
</html>
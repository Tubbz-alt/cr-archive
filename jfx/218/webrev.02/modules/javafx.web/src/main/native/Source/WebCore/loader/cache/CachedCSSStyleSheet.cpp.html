<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedCSSStyleSheet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller (mueller@kde.org)
  4     Copyright (C) 2002 Waldo Bastian (bastian@kde.org)
  5     Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  6     Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  7 
  8     This library is free software; you can redistribute it and/or
  9     modify it under the terms of the GNU Library General Public
 10     License as published by the Free Software Foundation; either
 11     version 2 of the License, or (at your option) any later version.
 12 
 13     This library is distributed in the hope that it will be useful,
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;CachedCSSStyleSheet.h&quot;
 26 
 27 #include &quot;CSSStyleSheet.h&quot;
 28 #include &quot;CachedResourceClientWalker.h&quot;
 29 #include &quot;CachedResourceRequest.h&quot;
 30 #include &quot;CachedStyleSheetClient.h&quot;
 31 #include &quot;HTTPHeaderNames.h&quot;
 32 #include &quot;HTTPParsers.h&quot;
 33 #include &quot;MemoryCache.h&quot;
 34 #include &quot;ParsedContentType.h&quot;
 35 #include &quot;SharedBuffer.h&quot;
 36 #include &quot;StyleSheetContents.h&quot;
 37 #include &quot;TextResourceDecoder.h&quot;
 38 
 39 namespace WebCore {
 40 
 41 CachedCSSStyleSheet::CachedCSSStyleSheet(CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 42     : CachedResource(WTFMove(request), Type::CSSStyleSheet, sessionID, cookieJar)
 43     , m_decoder(TextResourceDecoder::create(&quot;text/css&quot;, request.charset()))
 44 {
 45 }
 46 
 47 CachedCSSStyleSheet::~CachedCSSStyleSheet()
 48 {
 49     if (m_parsedStyleSheetCache)
 50         m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
 51 }
 52 
 53 void CachedCSSStyleSheet::didAddClient(CachedResourceClient&amp; client)
 54 {
 55     ASSERT(client.resourceClientType() == CachedStyleSheetClient::expectedType());
 56     // CachedResource::didAddClient() must be before setCSSStyleSheet(),
 57     // because setCSSStyleSheet() may cause scripts to be executed, which could destroy &#39;c&#39; if it is an instance of HTMLLinkElement.
 58     // see the comment of HTMLLinkElement::setCSSStyleSheet.
 59     CachedResource::didAddClient(client);
 60 
 61     if (!isLoading())
 62         static_cast&lt;CachedStyleSheetClient&amp;&gt;(client).setCSSStyleSheet(m_resourceRequest.url(), m_response.url(), m_decoder-&gt;encoding().name(), this);
 63 }
 64 
 65 void CachedCSSStyleSheet::setEncoding(const String&amp; chs)
 66 {
 67     m_decoder-&gt;setEncoding(chs, TextResourceDecoder::EncodingFromHTTPHeader);
 68 }
 69 
 70 String CachedCSSStyleSheet::encoding() const
 71 {
 72     return m_decoder-&gt;encoding().name();
 73 }
 74 
 75 const String CachedCSSStyleSheet::sheetText(MIMETypeCheckHint mimeTypeCheckHint, bool* hasValidMIMEType) const
 76 {
 77     if (!m_data || m_data-&gt;isEmpty() || !canUseSheet(mimeTypeCheckHint, hasValidMIMEType))
 78         return String();
 79 
 80     if (!m_decodedSheetText.isNull())
 81         return m_decodedSheetText;
 82 
 83     // Don&#39;t cache the decoded text, regenerating is cheap and it can use quite a bit of memory
 84     return m_decoder-&gt;decodeAndFlush(m_data-&gt;data(), m_data-&gt;size());
 85 }
 86 
 87 void CachedCSSStyleSheet::setBodyDataFrom(const CachedResource&amp; resource)
 88 {
 89     ASSERT(resource.type() == type());
 90     const CachedCSSStyleSheet&amp; sheet = static_cast&lt;const CachedCSSStyleSheet&amp;&gt;(resource);
 91 
 92     CachedResource::setBodyDataFrom(resource);
 93 
 94     m_decoder = sheet.m_decoder;
 95     m_decodedSheetText = sheet.m_decodedSheetText;
 96     if (sheet.m_parsedStyleSheetCache)
 97         saveParsedStyleSheet(*sheet.m_parsedStyleSheetCache);
 98 }
 99 
100 void CachedCSSStyleSheet::finishLoading(SharedBuffer* data)
101 {
102     m_data = data;
103     setEncodedSize(data ? data-&gt;size() : 0);
104     // Decode the data to find out the encoding and keep the sheet text around during checkNotify()
105     if (data)
106         m_decodedSheetText = m_decoder-&gt;decodeAndFlush(data-&gt;data(), data-&gt;size());
107     setLoading(false);
108     checkNotify();
109     // Clear the decoded text as it is unlikely to be needed immediately again and is cheap to regenerate.
110     m_decodedSheetText = String();
111 }
112 
113 void CachedCSSStyleSheet::checkNotify()
114 {
115     if (isLoading())
116         return;
117 
118     CachedResourceClientWalker&lt;CachedStyleSheetClient&gt; w(m_clients);
119     while (CachedStyleSheetClient* c = w.next())
120         c-&gt;setCSSStyleSheet(m_resourceRequest.url(), m_response.url(), m_decoder-&gt;encoding().name(), this);
121 }
122 
123 String CachedCSSStyleSheet::responseMIMEType() const
124 {
125     return extractMIMETypeFromMediaType(m_response.httpHeaderField(HTTPHeaderName::ContentType));
126 }
127 
128 bool CachedCSSStyleSheet::mimeTypeAllowedByNosniff() const
129 {
130     return parseContentTypeOptionsHeader(m_response.httpHeaderField(HTTPHeaderName::XContentTypeOptions)) != ContentTypeOptionsNosniff || equalLettersIgnoringASCIICase(responseMIMEType(), &quot;text/css&quot;);
131 }
132 
133 bool CachedCSSStyleSheet::canUseSheet(MIMETypeCheckHint mimeTypeCheckHint, bool* hasValidMIMEType) const
134 {
135     if (errorOccurred())
136         return false;
137 
138     if (!mimeTypeAllowedByNosniff()) {
139         if (hasValidMIMEType)
140             *hasValidMIMEType = false;
141         return false;
142     }
143 
144     if (mimeTypeCheckHint == MIMETypeCheckHint::Lax)
145         return true;
146 
147     // This check exactly matches Firefox.  Note that we grab the Content-Type
148     // header directly because we want to see what the value is BEFORE content
149     // sniffing.  Firefox does this by setting a &quot;type hint&quot; on the channel.
150     // This implementation should be observationally equivalent.
151     //
152     // This code defaults to allowing the stylesheet for non-HTTP protocols so
153     // folks can use standards mode for local HTML documents.
154     String mimeType = responseMIMEType();
155     bool typeOK = mimeType.isEmpty() || equalLettersIgnoringASCIICase(mimeType, &quot;text/css&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;application/x-unknown-content-type&quot;) || !isValidContentType(mimeType);
156     if (hasValidMIMEType)
157         *hasValidMIMEType = typeOK;
158     return typeOK;
159 }
160 
161 void CachedCSSStyleSheet::destroyDecodedData()
162 {
163     if (!m_parsedStyleSheetCache)
164         return;
165 
166     m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
167     m_parsedStyleSheetCache = nullptr;
168 
169     setDecodedSize(0);
170 }
171 
172 RefPtr&lt;StyleSheetContents&gt; CachedCSSStyleSheet::restoreParsedStyleSheet(const CSSParserContext&amp; context, CachePolicy cachePolicy, FrameLoader&amp; loader)
173 {
174     if (!m_parsedStyleSheetCache)
175         return nullptr;
176     if (!m_parsedStyleSheetCache-&gt;subresourcesAllowReuse(cachePolicy, loader)) {
177         m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
178         m_parsedStyleSheetCache = nullptr;
179         return nullptr;
180     }
181 
182     ASSERT(m_parsedStyleSheetCache-&gt;isCacheable());
183     ASSERT(m_parsedStyleSheetCache-&gt;isInMemoryCache());
184 
185     // Contexts must be identical so we know we would get the same exact result if we parsed again.
186     if (m_parsedStyleSheetCache-&gt;parserContext() != context)
187         return nullptr;
188 
189     didAccessDecodedData(MonotonicTime::now());
190 
191     return m_parsedStyleSheetCache;
192 }
193 
194 void CachedCSSStyleSheet::saveParsedStyleSheet(Ref&lt;StyleSheetContents&gt;&amp;&amp; sheet)
195 {
196     ASSERT(sheet-&gt;isCacheable());
197 
198     if (m_parsedStyleSheetCache)
199         m_parsedStyleSheetCache-&gt;removedFromMemoryCache();
200     m_parsedStyleSheetCache = WTFMove(sheet);
201     m_parsedStyleSheetCache-&gt;addedToMemoryCache();
202 
203     setDecodedSize(m_parsedStyleSheetCache-&gt;estimatedSizeInBytes());
204 }
205 
206 }
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ArithProfile.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ArithProfile.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ArithProfile.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ArithProfile.h
@@ -64,183 +64,272 @@
 
 private:
     uint8_t m_bits { 0 };
 };
 
-struct ArithProfile {
-private:
-    static constexpr uint32_t numberOfFlagBits = 6;
-    static constexpr uint32_t rhsResultTypeShift = numberOfFlagBits;
-    static constexpr uint32_t lhsResultTypeShift = rhsResultTypeShift + ResultType::numBitsNeeded;
-    static constexpr uint32_t rhsObservedTypeShift = lhsResultTypeShift + ResultType::numBitsNeeded;
-    static constexpr uint32_t lhsObservedTypeShift = rhsObservedTypeShift + ObservedType::numBitsNeeded;
+class ObservedResults {
+public:
+    enum Tags : uint8_t {
+        NonNegZeroDouble = 1 << 0,
+        NegZeroDouble    = 1 << 1,
+        NonNumeric       = 1 << 2,
+        Int32Overflow    = 1 << 3,
+        Int52Overflow    = 1 << 4,
+        BigInt           = 1 << 5,
+    };
+    static constexpr uint32_t numBitsNeeded = 6;
 
-    static_assert(ObservedType::numBitsNeeded == 3, "We make a hard assumption about that here.");
-    static constexpr uint32_t clearRhsObservedTypeBitMask = static_cast<uint32_t>(~((1 << rhsObservedTypeShift) | (1 << (rhsObservedTypeShift + 1)) | (1 << (rhsObservedTypeShift + 2))));
-    static constexpr uint32_t clearLhsObservedTypeBitMask = static_cast<uint32_t>(~((1 << lhsObservedTypeShift) | (1 << (lhsObservedTypeShift + 1)) | (1 << (lhsObservedTypeShift + 2))));
+    ObservedResults() = default;
+    explicit ObservedResults(uint8_t bits)
+        : m_bits(bits)
+    { }
 
-    static constexpr uint32_t resultTypeMask = (1 << ResultType::numBitsNeeded) - 1;
-    static constexpr uint32_t observedTypeMask = (1 << ObservedType::numBitsNeeded) - 1;
+    bool didObserveNonInt32() { return m_bits & (NonNegZeroDouble | NegZeroDouble | NonNumeric | BigInt); }
+    bool didObserveDouble() { return m_bits & (NonNegZeroDouble | NegZeroDouble); }
+    bool didObserveNonNegZeroDouble() { return m_bits & NonNegZeroDouble; }
+    bool didObserveNegZeroDouble() { return m_bits & NegZeroDouble; }
+    bool didObserveNonNumeric() { return m_bits & NonNumeric; }
+    bool didObserveBigInt() { return m_bits & BigInt; }
+    bool didObserveInt32Overflow() { return m_bits & Int32Overflow; }
+    bool didObserveInt52Overflow() { return m_bits & Int52Overflow; }
 
-    enum class ConstantTag { Constant };
+private:
+    uint8_t m_bits { 0 };
+};
 
+template <typename BitfieldType>
+class ArithProfile {
 public:
-    static constexpr uint32_t specialFastPathBit = 1 << (lhsObservedTypeShift + ObservedType::numBitsNeeded);
-    static_assert((lhsObservedTypeShift + ObservedType::numBitsNeeded) <= (sizeof(uint32_t) * 8) - 1, "Should fit in a uint32_t.");
-    static_assert(!(specialFastPathBit & ~clearLhsObservedTypeBitMask), "These bits should not intersect.");
-    static_assert(specialFastPathBit & clearLhsObservedTypeBitMask, "These bits should intersect.");
-    static_assert(specialFastPathBit > ~clearLhsObservedTypeBitMask, "These bits should not intersect and specialFastPathBit should be a higher bit.");
-
-    ArithProfile(ResultType arg)
-        : ArithProfile(ConstantTag::Constant, arg)
+    ObservedResults observedResults() const
     {
-        ASSERT(lhsResultType().bits() == arg.bits());
-        ASSERT(lhsObservedType().isEmpty());
-        ASSERT(rhsObservedType().isEmpty());
+        return ObservedResults(m_bits & ((1 << ObservedResults::numBitsNeeded) - 1));
     }
+    bool didObserveNonInt32() const { return observedResults().didObserveNonInt32();}
+    bool didObserveDouble() const { return observedResults().didObserveDouble(); }
+    bool didObserveNonNegZeroDouble() const { return observedResults().didObserveNonNegZeroDouble(); }
+    bool didObserveNegZeroDouble() const { return observedResults().didObserveNegZeroDouble(); }
+    bool didObserveNonNumeric() const { return observedResults().didObserveNonNumeric(); }
+    bool didObserveBigInt() const { return observedResults().didObserveBigInt(); }
+    bool didObserveInt32Overflow() const { return observedResults().didObserveInt32Overflow(); }
+    bool didObserveInt52Overflow() const { return observedResults().didObserveInt52Overflow(); }
+
+    void setObservedNonNegZeroDouble() { setBit(ObservedResults::NonNegZeroDouble); }
+    void setObservedNegZeroDouble() { setBit(ObservedResults::NegZeroDouble); }
+    void setObservedNonNumeric() { setBit(ObservedResults::NonNumeric); }
+    void setObservedBigInt() { setBit(ObservedResults::BigInt); }
+    void setObservedInt32Overflow() { setBit(ObservedResults::Int32Overflow); }
+    void setObservedInt52Overflow() { setBit(ObservedResults::Int52Overflow); }
 
-    ArithProfile(ResultType lhs, ResultType rhs)
-        : ArithProfile(ConstantTag::Constant, lhs, rhs)
+    void observeResult(JSValue value)
     {
-        ASSERT(lhsResultType().bits() == lhs.bits() && rhsResultType().bits() == rhs.bits());
-        ASSERT(lhsObservedType().isEmpty());
-        ASSERT(rhsObservedType().isEmpty());
+        if (value.isInt32())
+            return;
+        if (value.isNumber()) {
+            m_bits |= ObservedResults::Int32Overflow | ObservedResults::Int52Overflow | ObservedResults::NonNegZeroDouble | ObservedResults::NegZeroDouble;
+            return;
+        }
+        if (value && value.isBigInt()) {
+            m_bits |= ObservedResults::BigInt;
+            return;
+        }
+        m_bits |= ObservedResults::NonNumeric;
     }
 
-    ArithProfile(OperandTypes types)
-        : ArithProfile(types.first(), types.second())
-    { }
+    const void* addressOfBits() const { return &m_bits; }
+
+#if ENABLE(JIT)
+    // Sets (Int32Overflow | Int52Overflow | NonNegZeroDouble | NegZeroDouble) if it sees a
+    // double. Sets NonNumeric if it sees a non-numeric.
+    void emitObserveResult(CCallHelpers&, JSValueRegs, TagRegistersMode = HaveTagRegisters);
 
+    // Sets (Int32Overflow | Int52Overflow | NonNegZeroDouble | NegZeroDouble).
+    bool shouldEmitSetDouble() const;
+    void emitSetDouble(CCallHelpers&) const;
+
+    // Sets NonNumeric
+    void emitSetNonNumeric(CCallHelpers&) const;
+    bool shouldEmitSetNonNumeric() const;
+
+    // Sets BigInt
+    void emitSetBigInt(CCallHelpers&) const;
+    bool shouldEmitSetBigInt() const;
+
+    void emitUnconditionalSet(CCallHelpers&, BitfieldType) const;
+#endif // ENABLE(JIT)
+
+    constexpr uint32_t bits() const { return m_bits; }
+
+protected:
     ArithProfile() = default;
 
-    static constexpr ArithProfile fromInt(uint32_t bits)
+    bool hasBits(int mask) const { return m_bits & mask; }
+    void setBit(int mask) { m_bits |= mask; }
+
+    BitfieldType m_bits { 0 }; // We take care to update m_bits only in a single operation. We don't ever store an inconsistent bit representation to it.
+};
+
+/* This class stores the following components in 16 bits:
+ * - ObservedResults
+ * - ObservedType for the argument
+ */
+using UnaryArithProfileBase = uint16_t;
+class UnaryArithProfile : public ArithProfile<UnaryArithProfileBase> {
+    static constexpr unsigned argObservedTypeShift = ObservedResults::numBitsNeeded;
+
+    static_assert(argObservedTypeShift + ObservedType::numBitsNeeded <= sizeof(UnaryArithProfileBase) * 8, "Should fit in a the type of the underlying bitfield.");
+
+    static constexpr UnaryArithProfileBase clearArgObservedTypeBitMask = static_cast<UnaryArithProfileBase>(~(0b111 << argObservedTypeShift));
+
+    static constexpr UnaryArithProfileBase observedTypeMask = (1 << ObservedType::numBitsNeeded) - 1;
+
+public:
+    UnaryArithProfile()
+        : ArithProfile<UnaryArithProfileBase>()
     {
-        return ArithProfile { ConstantTag::Constant, bits };
+        ASSERT(argObservedType().isEmpty());
+        ASSERT(argObservedType().isEmpty());
     }
 
-    static constexpr ArithProfile observedUnaryInt()
+    static constexpr UnaryArithProfileBase observedIntBits()
     {
         constexpr ObservedType observedInt32 { ObservedType().withInt32() };
-        constexpr uint32_t bits = observedInt32.bits() << lhsObservedTypeShift;
-        static_assert(bits == 0x800000, "");
-        return fromInt(bits);
+        constexpr UnaryArithProfileBase bits = observedInt32.bits() << argObservedTypeShift;
+        return bits;
     }
-    static constexpr ArithProfile observedUnaryNumber()
+    static constexpr UnaryArithProfileBase observedNumberBits()
     {
         constexpr ObservedType observedNumber { ObservedType().withNumber() };
-        constexpr uint32_t bits = observedNumber.bits() << lhsObservedTypeShift;
-        static_assert(bits == 0x1000000, "");
-        return fromInt(bits);
+        constexpr UnaryArithProfileBase bits = observedNumber.bits() << argObservedTypeShift;
+        return bits;
+    }
+
+    constexpr ObservedType argObservedType() const { return ObservedType((m_bits >> argObservedTypeShift) & observedTypeMask); }
+    void setArgObservedType(ObservedType type)
+    {
+        UnaryArithProfileBase bits = m_bits;
+        bits &= clearArgObservedTypeBitMask;
+        bits |= type.bits() << argObservedTypeShift;
+        m_bits = bits;
+        ASSERT(argObservedType() == type);
+    }
+
+    void argSawInt32() { setArgObservedType(argObservedType().withInt32()); }
+    void argSawNumber() { setArgObservedType(argObservedType().withNumber()); }
+    void argSawNonNumber() { setArgObservedType(argObservedType().withNonNumber()); }
+
+    void observeArg(JSValue arg)
+    {
+        UnaryArithProfile newProfile = *this;
+        if (arg.isNumber()) {
+            if (arg.isInt32())
+                newProfile.argSawInt32();
+            else
+                newProfile.argSawNumber();
+        } else
+            newProfile.argSawNonNumber();
+
+        m_bits = newProfile.bits();
     }
-    static constexpr ArithProfile observedBinaryIntInt()
+
+    bool isObservedTypeEmpty()
+    {
+        return argObservedType().isEmpty();
+    }
+
+    friend class JSC::LLIntOffsetsExtractor;
+};
+
+/* This class stores the following components in 16 bits:
+ * - ObservedResults
+ * - ObservedType for right-hand-side
+ * - ObservedType for left-hand-side
+ * - a bit used by division to indicate whether a special fast path was taken
+ */
+using BinaryArithProfileBase = uint16_t;
+class BinaryArithProfile : public ArithProfile<BinaryArithProfileBase> {
+    static constexpr uint32_t rhsObservedTypeShift = ObservedResults::numBitsNeeded;
+    static constexpr uint32_t lhsObservedTypeShift = rhsObservedTypeShift + ObservedType::numBitsNeeded;
+
+    static_assert(ObservedType::numBitsNeeded == 3, "We make a hard assumption about that here.");
+    static constexpr BinaryArithProfileBase clearRhsObservedTypeBitMask = static_cast<BinaryArithProfileBase>(~(0b111 << rhsObservedTypeShift));
+    static constexpr BinaryArithProfileBase clearLhsObservedTypeBitMask = static_cast<BinaryArithProfileBase>(~(0b111 << lhsObservedTypeShift));
+
+    static constexpr BinaryArithProfileBase observedTypeMask = (1 << ObservedType::numBitsNeeded) - 1;
+
+public:
+    static constexpr BinaryArithProfileBase specialFastPathBit = 1 << (lhsObservedTypeShift + ObservedType::numBitsNeeded);
+    static_assert((lhsObservedTypeShift + ObservedType::numBitsNeeded + 1) <= sizeof(BinaryArithProfileBase) * 8, "Should fit in a uint32_t.");
+    static_assert(!(specialFastPathBit & ~clearLhsObservedTypeBitMask), "These bits should not intersect.");
+    static_assert(specialFastPathBit & clearLhsObservedTypeBitMask, "These bits should intersect.");
+    static_assert(static_cast<unsigned>(specialFastPathBit) > static_cast<unsigned>(static_cast<BinaryArithProfileBase>(~clearLhsObservedTypeBitMask)), "These bits should not intersect and specialFastPathBit should be a higher bit.");
+
+    BinaryArithProfile()
+        : ArithProfile<BinaryArithProfileBase> ()
+    {
+        ASSERT(lhsObservedType().isEmpty());
+        ASSERT(rhsObservedType().isEmpty());
+    }
+
+    static constexpr BinaryArithProfileBase observedIntIntBits()
     {
         constexpr ObservedType observedInt32 { ObservedType().withInt32() };
-        constexpr uint32_t bits = (observedInt32.bits() << lhsObservedTypeShift) | (observedInt32.bits() << rhsObservedTypeShift);
-        static_assert(bits == 0x900000, "");
-        return fromInt(bits);
+        constexpr BinaryArithProfileBase bits = (observedInt32.bits() << lhsObservedTypeShift) | (observedInt32.bits() << rhsObservedTypeShift);
+        return bits;
     }
-    static constexpr ArithProfile observedBinaryNumberInt()
+    static constexpr BinaryArithProfileBase observedNumberIntBits()
     {
         constexpr ObservedType observedNumber { ObservedType().withNumber() };
         constexpr ObservedType observedInt32 { ObservedType().withInt32() };
-        constexpr uint32_t bits = (observedNumber.bits() << lhsObservedTypeShift) | (observedInt32.bits() << rhsObservedTypeShift);
-        static_assert(bits == 0x1100000, "");
-        return fromInt(bits);
+        constexpr BinaryArithProfileBase bits = (observedNumber.bits() << lhsObservedTypeShift) | (observedInt32.bits() << rhsObservedTypeShift);
+        return bits;
     }
-    static constexpr ArithProfile observedBinaryIntNumber()
+    static constexpr BinaryArithProfileBase observedIntNumberBits()
     {
         constexpr ObservedType observedNumber { ObservedType().withNumber() };
         constexpr ObservedType observedInt32 { ObservedType().withInt32() };
-        constexpr uint32_t bits = (observedInt32.bits() << lhsObservedTypeShift) | (observedNumber.bits() << rhsObservedTypeShift);
-        static_assert(bits == 0xa00000, "");
-        return fromInt(bits);
+        constexpr BinaryArithProfileBase bits = (observedInt32.bits() << lhsObservedTypeShift) | (observedNumber.bits() << rhsObservedTypeShift);
+        return bits;
     }
-    static constexpr ArithProfile observedBinaryNumberNumber()
+    static constexpr BinaryArithProfileBase observedNumberNumberBits()
     {
         constexpr ObservedType observedNumber { ObservedType().withNumber() };
-        constexpr uint32_t bits = (observedNumber.bits() << lhsObservedTypeShift) | (observedNumber.bits() << rhsObservedTypeShift);
-        static_assert(bits == 0x1200000, "");
-        return fromInt(bits);
+        constexpr BinaryArithProfileBase bits = (observedNumber.bits() << lhsObservedTypeShift) | (observedNumber.bits() << rhsObservedTypeShift);
+        return bits;
     }
 
-    enum ObservedResults {
-        NonNegZeroDouble = 1 << 0,
-        NegZeroDouble    = 1 << 1,
-        NonNumeric       = 1 << 2,
-        Int32Overflow    = 1 << 3,
-        Int52Overflow    = 1 << 4,
-        BigInt           = 1 << 5,
-    };
-
-    ResultType lhsResultType() const { return ResultType((m_bits >> lhsResultTypeShift) & resultTypeMask); }
-    ResultType rhsResultType() const { return ResultType((m_bits >> rhsResultTypeShift) & resultTypeMask); }
-
     constexpr ObservedType lhsObservedType() const { return ObservedType((m_bits >> lhsObservedTypeShift) & observedTypeMask); }
     constexpr ObservedType rhsObservedType() const { return ObservedType((m_bits >> rhsObservedTypeShift) & observedTypeMask); }
     void setLhsObservedType(ObservedType type)
     {
-        uint32_t bits = m_bits;
+        BinaryArithProfileBase bits = m_bits;
         bits &= clearLhsObservedTypeBitMask;
         bits |= type.bits() << lhsObservedTypeShift;
         m_bits = bits;
         ASSERT(lhsObservedType() == type);
     }
 
     void setRhsObservedType(ObservedType type)
     {
-        uint32_t bits = m_bits;
+        BinaryArithProfileBase bits = m_bits;
         bits &= clearRhsObservedTypeBitMask;
         bits |= type.bits() << rhsObservedTypeShift;
         m_bits = bits;
         ASSERT(rhsObservedType() == type);
     }
 
     bool tookSpecialFastPath() const { return m_bits & specialFastPathBit; }
 
-    bool didObserveNonInt32() const { return hasBits(NonNegZeroDouble | NegZeroDouble | NonNumeric | BigInt); }
-    bool didObserveDouble() const { return hasBits(NonNegZeroDouble | NegZeroDouble); }
-    bool didObserveNonNegZeroDouble() const { return hasBits(NonNegZeroDouble); }
-    bool didObserveNegZeroDouble() const { return hasBits(NegZeroDouble); }
-    bool didObserveNonNumeric() const { return hasBits(NonNumeric); }
-    bool didObserveBigInt() const { return hasBits(BigInt); }
-    bool didObserveInt32Overflow() const { return hasBits(Int32Overflow); }
-    bool didObserveInt52Overflow() const { return hasBits(Int52Overflow); }
-
-    void setObservedNonNegZeroDouble() { setBit(NonNegZeroDouble); }
-    void setObservedNegZeroDouble() { setBit(NegZeroDouble); }
-    void setObservedNonNumeric() { setBit(NonNumeric); }
-    void setObservedBigInt() { setBit(BigInt); }
-    void setObservedInt32Overflow() { setBit(Int32Overflow); }
-    void setObservedInt52Overflow() { setBit(Int52Overflow); }
-
-    const void* addressOfBits() const { return &m_bits; }
-
-    void observeResult(JSValue value)
-    {
-        if (value.isInt32())
-            return;
-        if (value.isNumber()) {
-            m_bits |= Int32Overflow | Int52Overflow | NonNegZeroDouble | NegZeroDouble;
-            return;
-        }
-        if (value && value.isBigInt()) {
-            m_bits |= BigInt;
-            return;
-        }
-        m_bits |= NonNumeric;
-    }
-
     void lhsSawInt32() { setLhsObservedType(lhsObservedType().withInt32()); }
     void lhsSawNumber() { setLhsObservedType(lhsObservedType().withNumber()); }
     void lhsSawNonNumber() { setLhsObservedType(lhsObservedType().withNonNumber()); }
     void rhsSawInt32() { setRhsObservedType(rhsObservedType().withInt32()); }
     void rhsSawNumber() { setRhsObservedType(rhsObservedType().withNumber()); }
     void rhsSawNonNumber() { setRhsObservedType(rhsObservedType().withNonNumber()); }
 
     void observeLHS(JSValue lhs)
     {
-        ArithProfile newProfile = *this;
+        BinaryArithProfile newProfile = *this;
         if (lhs.isNumber()) {
             if (lhs.isInt32())
                 newProfile.lhsSawInt32();
             else
                 newProfile.lhsSawNumber();
@@ -252,11 +341,11 @@
 
     void observeLHSAndRHS(JSValue lhs, JSValue rhs)
     {
         observeLHS(lhs);
 
-        ArithProfile newProfile = *this;
+        BinaryArithProfile newProfile = *this;
         if (rhs.isNumber()) {
             if (rhs.isInt32())
                 newProfile.rhsSawInt32();
             else
                 newProfile.rhsSawNumber();
@@ -264,57 +353,22 @@
             newProfile.rhsSawNonNumber();
 
         m_bits = newProfile.bits();
     }
 
-#if ENABLE(JIT)
-    // Sets (Int32Overflow | Int52Overflow | NonNegZeroDouble | NegZeroDouble) if it sees a
-    // double. Sets NonNumeric if it sees a non-numeric.
-    void emitObserveResult(CCallHelpers&, JSValueRegs, TagRegistersMode = HaveTagRegisters);
-
-    // Sets (Int32Overflow | Int52Overflow | NonNegZeroDouble | NegZeroDouble).
-    bool shouldEmitSetDouble() const;
-    void emitSetDouble(CCallHelpers&) const;
-
-    // Sets NonNumber.
-    void emitSetNonNumeric(CCallHelpers&) const;
-    bool shouldEmitSetNonNumeric() const;
-
-    // Sets BigInt
-    void emitSetBigInt(CCallHelpers&) const;
-    bool shouldEmitSetBigInt() const;
-#endif // ENABLE(JIT)
-
-    constexpr uint32_t bits() const { return m_bits; }
-
-private:
-    constexpr explicit ArithProfile(ConstantTag, uint32_t bits)
-        : m_bits(bits)
-    {
-    }
-
-    constexpr ArithProfile(ConstantTag, ResultType arg)
-        : m_bits(arg.bits() << lhsResultTypeShift)
-    {
-    }
-
-    constexpr ArithProfile(ConstantTag, ResultType lhs, ResultType rhs)
-        : m_bits((lhs.bits() << lhsResultTypeShift) | (rhs.bits() << rhsResultTypeShift))
+    bool isObservedTypeEmpty()
     {
+        return lhsObservedType().isEmpty() && rhsObservedType().isEmpty();
     }
 
-    bool hasBits(int mask) const { return m_bits & mask; }
-    void setBit(int mask) { m_bits |= mask; }
-
-    uint32_t m_bits { 0 }; // We take care to update m_bits only in a single operation. We don't ever store an inconsistent bit representation to it.
-
     friend class JSC::LLIntOffsetsExtractor;
 };
 
 } // namespace JSC
 
 namespace WTF {
 
-void printInternal(PrintStream&, const JSC::ArithProfile&);
+void printInternal(PrintStream&, const JSC::UnaryArithProfile&);
+void printInternal(PrintStream&, const JSC::BinaryArithProfile&);
 void printInternal(PrintStream&, const JSC::ObservedType&);
 
 } // namespace WTF

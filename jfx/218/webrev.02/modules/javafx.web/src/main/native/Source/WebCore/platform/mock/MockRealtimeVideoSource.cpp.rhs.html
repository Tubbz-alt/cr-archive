<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/mock/MockRealtimeVideoSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer
 12  *    in the documentation and/or other materials provided with the
 13  *    distribution.
 14  * 3. Neither the name of Google Inc. nor the names of its contributors
 15  *    may be used to endorse or promote products derived from this
 16  *    software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;MockRealtimeVideoSource.h&quot;
 33 
 34 #if ENABLE(MEDIA_STREAM)
 35 #include &quot;CaptureDevice.h&quot;
 36 #include &quot;GraphicsContext.h&quot;
 37 #include &quot;ImageBuffer.h&quot;
 38 #include &quot;IntRect.h&quot;
 39 #include &quot;Logging.h&quot;
 40 #include &quot;MediaConstraints.h&quot;
 41 #include &quot;MockRealtimeMediaSourceCenter.h&quot;
 42 #include &quot;NotImplemented.h&quot;
 43 #include &quot;PlatformLayer.h&quot;
 44 #include &quot;RealtimeMediaSourceSettings.h&quot;
 45 #include &quot;RealtimeVideoSource.h&quot;
 46 #include &lt;math.h&gt;
 47 #include &lt;wtf/UUID.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 #if !PLATFORM(MAC) &amp;&amp; !PLATFORM(IOS_FAMILY) &amp;&amp; !(USE(GSTREAMER) &amp;&amp; USE(LIBWEBRTC))
 53 CaptureSourceOrError MockRealtimeVideoSource::create(String&amp;&amp; deviceID, String&amp;&amp; name, String&amp;&amp; hashSalt, const MediaConstraints* constraints)
 54 {
 55 #ifndef NDEBUG
 56     auto device = MockRealtimeMediaSourceCenter::mockDeviceWithPersistentID(deviceID);
 57     ASSERT(device);
 58     if (!device)
<a name="1" id="anc1"></a><span class="line-modified"> 59         return { &quot;No mock camera device&quot;_s };</span>
 60 #endif
 61 
 62     auto source = adoptRef(*new MockRealtimeVideoSource(WTFMove(deviceID), WTFMove(name), WTFMove(hashSalt)));
 63     if (constraints &amp;&amp; source-&gt;applyConstraints(*constraints))
 64         return { };
 65 
 66     return CaptureSourceOrError(RealtimeVideoSource::create(WTFMove(source)));
 67 }
 68 #endif
 69 
 70 MockRealtimeVideoSource::MockRealtimeVideoSource(String&amp;&amp; deviceID, String&amp;&amp; name, String&amp;&amp; hashSalt)
 71     : RealtimeVideoCaptureSource(WTFMove(name), WTFMove(deviceID), WTFMove(hashSalt))
 72     , m_emitFrameTimer(RunLoop::current(), this, &amp;MockRealtimeVideoSource::generateFrame)
 73 {
 74     auto device = MockRealtimeMediaSourceCenter::mockDeviceWithPersistentID(persistentID());
 75     ASSERT(device);
 76     m_device = *device;
 77 
 78     m_dashWidths.reserveInitialCapacity(2);
 79     m_dashWidths.uncheckedAppend(6);
 80     m_dashWidths.uncheckedAppend(6);
 81 
 82     if (mockDisplay()) {
 83         auto&amp; properties = WTF::get&lt;MockDisplayProperties&gt;(m_device.properties);
 84         setIntrinsicSize(properties.defaultSize);
 85         setSize(properties.defaultSize);
 86         m_fillColor = properties.fillColor;
 87         return;
 88     }
 89 
 90     auto&amp; properties = WTF::get&lt;MockCameraProperties&gt;(m_device.properties);
 91     setFrameRate(properties.defaultFrameRate);
 92     setFacingMode(properties.facingMode);
 93     m_fillColor = properties.fillColor;
 94 }
 95 
 96 bool MockRealtimeVideoSource::supportsSizeAndFrameRate(Optional&lt;int&gt; width, Optional&lt;int&gt; height, Optional&lt;double&gt; rate)
 97 {
 98     // FIXME: consider splitting mock display into another class so we don&#39;t don&#39;t have to do this silly dance
 99     // because of the RealtimeVideoSource inheritance.
100     if (mockCamera())
101         return RealtimeVideoCaptureSource::supportsSizeAndFrameRate(width, height, rate);
102 
103     return RealtimeMediaSource::supportsSizeAndFrameRate(width, height, rate);
104 }
105 
106 void MockRealtimeVideoSource::setSizeAndFrameRate(Optional&lt;int&gt; width, Optional&lt;int&gt; height, Optional&lt;double&gt; rate)
107 {
108     // FIXME: consider splitting mock display into another class so we don&#39;t don&#39;t have to do this silly dance
109     // because of the RealtimeVideoSource inheritance.
110     if (mockCamera()) {
111         RealtimeVideoCaptureSource::setSizeAndFrameRate(width, height, rate);
112         return;
113     }
114 
115     RealtimeMediaSource::setSizeAndFrameRate(width, height, rate);
116 }
117 
118 void MockRealtimeVideoSource::generatePresets()
119 {
120     ASSERT(mockCamera());
121     setSupportedPresets(WTFMove(WTF::get&lt;MockCameraProperties&gt;(m_device.properties).presets));
122 }
123 
124 const RealtimeMediaSourceCapabilities&amp; MockRealtimeVideoSource::capabilities()
125 {
126     if (!m_capabilities) {
127         RealtimeMediaSourceCapabilities capabilities(settings().supportedConstraints());
128 
129         if (mockCamera()) {
130             capabilities.addFacingMode(WTF::get&lt;MockCameraProperties&gt;(m_device.properties).facingMode);
131             capabilities.setDeviceId(hashedId());
132             updateCapabilities(capabilities);
133             capabilities.setDeviceId(hashedId());
134         } else {
135             capabilities.setWidth(CapabilityValueOrRange(72, 2880));
136             capabilities.setHeight(CapabilityValueOrRange(45, 1800));
137             capabilities.setFrameRate(CapabilityValueOrRange(.01, 60.0));
138         }
139 
140         m_capabilities = WTFMove(capabilities);
141     }
142 
143     return m_capabilities.value();
144 }
145 
146 const RealtimeMediaSourceSettings&amp; MockRealtimeVideoSource::settings()
147 {
148     if (m_currentSettings)
149         return m_currentSettings.value();
150 
151     RealtimeMediaSourceSettings settings;
152     if (mockCamera()) {
153         settings.setFacingMode(facingMode());
154         settings.setDeviceId(hashedId());
155     } else {
156         settings.setDisplaySurface(mockScreen() ? RealtimeMediaSourceSettings::DisplaySurfaceType::Monitor : RealtimeMediaSourceSettings::DisplaySurfaceType::Window);
157         settings.setLogicalSurface(false);
158     }
159     settings.setFrameRate(frameRate());
160     auto size = this-&gt;size();
161     if (mockCamera()) {
162         if (m_deviceOrientation == MediaSample::VideoRotation::Left || m_deviceOrientation == MediaSample::VideoRotation::Right)
163             size = size.transposedSize();
164     }
165     settings.setWidth(size.width());
166     settings.setHeight(size.height());
167     if (aspectRatio())
168         settings.setAspectRatio(aspectRatio());
169 
170     RealtimeMediaSourceSupportedConstraints supportedConstraints;
171     supportedConstraints.setSupportsFrameRate(true);
172     supportedConstraints.setSupportsWidth(true);
173     supportedConstraints.setSupportsHeight(true);
174     supportedConstraints.setSupportsAspectRatio(true);
175     if (mockCamera()) {
176         supportedConstraints.setSupportsDeviceId(true);
177         supportedConstraints.setSupportsFacingMode(true);
178     } else {
179         supportedConstraints.setSupportsDisplaySurface(true);
180         supportedConstraints.setSupportsLogicalSurface(true);
181     }
182     settings.setSupportedConstraints(supportedConstraints);
183 
184     m_currentSettings = WTFMove(settings);
185 
186     return m_currentSettings.value();
187 }
188 
189 void MockRealtimeVideoSource::setFrameRateWithPreset(double, RefPtr&lt;VideoPreset&gt; preset)
190 {
191     m_preset = WTFMove(preset);
<a name="2" id="anc2"></a><span class="line-modified">192     if (m_preset)</span>
<span class="line-modified">193         setIntrinsicSize(m_preset-&gt;size);</span>
194 }
195 
196 IntSize MockRealtimeVideoSource::captureSize() const
197 {
198     return m_preset ? m_preset-&gt;size : this-&gt;size();
199 }
200 
201 void MockRealtimeVideoSource::settingsDidChange(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; settings)
202 {
203     m_currentSettings = WTF::nullopt;
204     if (settings.containsAny({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height })) {
205         m_baseFontSize = captureSize().height() * .08;
206         m_bipBopFontSize = m_baseFontSize * 2.5;
207         m_statsFontSize = m_baseFontSize * .5;
208         m_imageBuffer = nullptr;
209     }
210 }
211 
212 void MockRealtimeVideoSource::startCaptureTimer()
213 {
214     m_emitFrameTimer.startRepeating(1_s / frameRate());
215 }
216 
217 void MockRealtimeVideoSource::startProducingData()
218 {
219     prepareToProduceData();
220     startCaptureTimer();
221     m_startTime = MonotonicTime::now();
222 }
223 
224 void MockRealtimeVideoSource::stopProducingData()
225 {
226     m_emitFrameTimer.stop();
227     m_elapsedTime += MonotonicTime::now() - m_startTime;
228     m_startTime = MonotonicTime::nan();
229 }
230 
231 Seconds MockRealtimeVideoSource::elapsedTime()
232 {
233     if (std::isnan(m_startTime))
234         return m_elapsedTime;
235 
236     return m_elapsedTime + (MonotonicTime::now() - m_startTime);
237 }
238 
239 void MockRealtimeVideoSource::drawAnimation(GraphicsContext&amp; context)
240 {
241     auto size = captureSize();
242     float radius = size.width() * .09;
243     FloatPoint location(size.width() * .8, size.height() * .3);
244 
245     m_path.clear();
246     m_path.moveTo(location);
247     m_path.addArc(location, radius, 0, 2 * piFloat, false);
248     m_path.closeSubpath();
249     context.setFillColor(Color::white);
250     context.setFillRule(WindRule::NonZero);
251     context.fillPath(m_path);
252 
253     float endAngle = piFloat * (((fmod(m_frameNumber, frameRate()) + 0.5) * (2.0 / frameRate())) + 1);
254     m_path.clear();
255     m_path.moveTo(location);
256     m_path.addArc(location, radius, 1.5 * piFloat, endAngle, false);
257     m_path.closeSubpath();
258     context.setFillColor(Color::gray);
259     context.setFillRule(WindRule::NonZero);
260     context.fillPath(m_path);
261 }
262 
263 void MockRealtimeVideoSource::drawBoxes(GraphicsContext&amp; context)
264 {
<a name="3" id="anc3"></a><span class="line-modified">265     constexpr SimpleColor magenta { 0xffff00ff };</span>
<span class="line-modified">266     constexpr SimpleColor blue { 0xff0000ff };</span>
<span class="line-modified">267     constexpr SimpleColor red { 0xffff0000 };</span>
<span class="line-modified">268     constexpr SimpleColor darkGreen { 0xff008000 };</span>


269 
270     IntSize size = captureSize();
271     float boxSize = size.width() * .035;
272     float boxTop = size.height() * .6;
273 
274     m_path.clear();
275     FloatRect frameRect(2, 2, size.width() - 3, size.height() - 3);
276     context.setStrokeColor(Color::white);
277     context.setStrokeThickness(3);
278     context.setLineDash(m_dashWidths, 0);
279     m_path.addRect(frameRect);
280     m_path.closeSubpath();
281     context.strokePath(m_path);
282 
283     context.setLineDash(DashArray(), 0);
284     m_path.clear();
285     m_path.moveTo(FloatPoint(0, boxTop + boxSize));
286     m_path.addLineTo(FloatPoint(size.width(), boxTop + boxSize));
287     m_path.closeSubpath();
288     context.setStrokeColor(Color::white);
289     context.setStrokeThickness(2);
290     context.strokePath(m_path);
291 
292     context.setStrokeThickness(1);
293     float boxLeft = boxSize;
294     m_path.clear();
295     for (unsigned i = 0; i &lt; boxSize / 4; i++) {
296         m_path.moveTo(FloatPoint(boxLeft + 4 * i, boxTop));
297         m_path.addLineTo(FloatPoint(boxLeft + 4 * i, boxTop + boxSize));
298     }
299     boxLeft += boxSize + 2;
300     for (unsigned i = 0; i &lt; boxSize / 4; i++) {
301         m_path.moveTo(FloatPoint(boxLeft, boxTop + 4 * i));
302         m_path.addLineTo(FloatPoint(boxLeft + boxSize - 1, boxTop + 4 * i));
303     }
304     context.setStrokeThickness(3);
305     boxLeft += boxSize + 2;
306     for (unsigned i = 0; i &lt; boxSize / 8; i++) {
307         m_path.moveTo(FloatPoint(boxLeft + 8 * i, boxTop));
308         m_path.addLineTo(FloatPoint(boxLeft + 8 * i, boxTop + boxSize - 1));
309     }
310     boxLeft += boxSize + 2;
311     for (unsigned i = 0; i &lt; boxSize / 8; i++) {
312         m_path.moveTo(FloatPoint(boxLeft, boxTop + 8 * i));
313         m_path.addLineTo(FloatPoint(boxLeft + boxSize - 1, boxTop + 8 * i));
314     }
315 
316     boxTop += boxSize + 2;
317     boxLeft = boxSize;
<a name="4" id="anc4"></a><span class="line-modified">318     constexpr SimpleColor boxColors[] = { Color::white, Color::yellow, Color::cyan, darkGreen, magenta, red, blue };</span>
<span class="line-modified">319     for (auto&amp; boxColor : boxColors) {</span>
<span class="line-modified">320         context.fillRect(FloatRect(boxLeft, boxTop, boxSize + 1, boxSize + 1), boxColor);</span>
321         boxLeft += boxSize + 1;
322     }
323     context.strokePath(m_path);
324 }
325 
326 void MockRealtimeVideoSource::drawText(GraphicsContext&amp; context)
327 {
328     unsigned milliseconds = lround(elapsedTime().milliseconds());
329     unsigned seconds = milliseconds / 1000 % 60;
330     unsigned minutes = seconds / 60 % 60;
331     unsigned hours = minutes / 60 % 60;
332 
333     FontCascadeDescription fontDescription;
334     fontDescription.setOneFamily(&quot;Courier&quot;);
335     fontDescription.setWeight(FontSelectionValue(500));
336 
337     fontDescription.setSpecifiedSize(m_baseFontSize);
338     fontDescription.setComputedSize(m_baseFontSize);
339     FontCascade timeFont { FontCascadeDescription { fontDescription }, 0, 0 };
340     timeFont.update(nullptr);
341 
342     fontDescription.setSpecifiedSize(m_bipBopFontSize);
343     fontDescription.setComputedSize(m_bipBopFontSize);
344     FontCascade bipBopFont { FontCascadeDescription { fontDescription }, 0, 0 };
345     bipBopFont.update(nullptr);
346 
347     fontDescription.setSpecifiedSize(m_statsFontSize);
348     fontDescription.setComputedSize(m_statsFontSize);
349     FontCascade statsFont { WTFMove(fontDescription), 0, 0 };
350     statsFont.update(nullptr);
351 
352     IntSize captureSize = this-&gt;captureSize();
353     FloatPoint timeLocation(captureSize.width() * .05, captureSize.height() * .15);
354     context.setFillColor(Color::white);
355     context.setTextDrawingMode(TextModeFill);
356     String string = makeString(pad(&#39;0&#39;, 2, hours), &#39;:&#39;, pad(&#39;0&#39;, 2, minutes), &#39;:&#39;, pad(&#39;0&#39;, 2, seconds), &#39;.&#39;, pad(&#39;0&#39;, 3, milliseconds % 1000));
357     context.drawText(timeFont, TextRun((StringView(string))), timeLocation);
358 
359     string = makeString(pad(&#39;0&#39;, 6, m_frameNumber++));
360     timeLocation.move(0, m_baseFontSize);
361     context.drawText(timeFont, TextRun((StringView(string))), timeLocation);
362 
363     FloatPoint statsLocation(captureSize.width() * .45, captureSize.height() * .75);
364     string = makeString(&quot;Requested frame rate: &quot;, FormattedNumber::fixedWidth(frameRate(), 1), &quot; fps&quot;);
365     context.drawText(statsFont, TextRun((StringView(string))), statsLocation);
366 
367     statsLocation.move(0, m_statsFontSize);
368     string = makeString(&quot;Observed frame rate: &quot;, FormattedNumber::fixedWidth(observedFrameRate(), 1), &quot; fps&quot;);
369     context.drawText(statsFont, TextRun((StringView(string))), statsLocation);
370 
371     auto size = this-&gt;size();
372     statsLocation.move(0, m_statsFontSize);
373     string = makeString(&quot;Size: &quot;, size.width(), &quot; x &quot;, size.height());
374     context.drawText(statsFont, TextRun((StringView(string))), statsLocation);
375 
376     if (mockCamera()) {
377         statsLocation.move(0, m_statsFontSize);
378         string = makeString(&quot;Preset size: &quot;, captureSize.width(), &quot; x &quot;, captureSize.height());
379         context.drawText(statsFont, TextRun((StringView(string))), statsLocation);
380 
381         const char* camera;
382         switch (facingMode()) {
383         case RealtimeMediaSourceSettings::User:
384             camera = &quot;User facing&quot;;
385             break;
386         case RealtimeMediaSourceSettings::Environment:
387             camera = &quot;Environment facing&quot;;
388             break;
389         case RealtimeMediaSourceSettings::Left:
390             camera = &quot;Left facing&quot;;
391             break;
392         case RealtimeMediaSourceSettings::Right:
393             camera = &quot;Right facing&quot;;
394             break;
395         case RealtimeMediaSourceSettings::Unknown:
396             camera = &quot;Unknown&quot;;
397             break;
398         }
399         string = makeString(&quot;Camera: &quot;, camera);
400         statsLocation.move(0, m_statsFontSize);
401         context.drawText(statsFont, TextRun((StringView(string))), statsLocation);
402     } else if (!name().isNull()) {
403         statsLocation.move(0, m_statsFontSize);
404         context.drawText(statsFont, TextRun { name() }, statsLocation);
405     }
406 
407     FloatPoint bipBopLocation(captureSize.width() * .6, captureSize.height() * .6);
408     unsigned frameMod = m_frameNumber % 60;
409     if (frameMod &lt;= 15) {
410         context.setFillColor(Color::cyan);
411         String bip(&quot;Bip&quot;_s);
412         context.drawText(bipBopFont, TextRun(StringView(bip)), bipBopLocation);
413     } else if (frameMod &gt; 30 &amp;&amp; frameMod &lt;= 45) {
414         context.setFillColor(Color::yellow);
415         String bop(&quot;Bop&quot;_s);
416         context.drawText(bipBopFont, TextRun(StringView(bop)), bipBopLocation);
417     }
418 }
419 
420 void MockRealtimeVideoSource::delaySamples(Seconds delta)
421 {
422     m_delayUntil = MonotonicTime::now() + delta;
423 }
424 
425 void MockRealtimeVideoSource::generateFrame()
426 {
427     if (m_delayUntil) {
428         if (m_delayUntil &lt; MonotonicTime::now())
429             return;
430         m_delayUntil = MonotonicTime();
431     }
432 
433     ImageBuffer* buffer = imageBuffer();
434     if (!buffer)
435         return;
436 
437     GraphicsContext&amp; context = buffer-&gt;context();
438     GraphicsContextStateSaver stateSaver(context);
439 
440     auto size = captureSize();
441     FloatRect frameRect(FloatPoint(), size);
442 
443     context.fillRect(FloatRect(FloatPoint(), size), m_fillColor);
444 
445     if (!muted()) {
446         drawText(context);
447         drawAnimation(context);
448         drawBoxes(context);
449     }
450 
451     updateSampleBuffer();
452 }
453 
454 ImageBuffer* MockRealtimeVideoSource::imageBuffer() const
455 {
456     if (m_imageBuffer)
457         return m_imageBuffer.get();
458 
<a name="5" id="anc5"></a><span class="line-modified">459     m_imageBuffer = ImageBuffer::create(captureSize(), RenderingMode::Unaccelerated);</span>
460     if (!m_imageBuffer)
461         return nullptr;
462 
<a name="6" id="anc6"></a><span class="line-modified">463     m_imageBuffer-&gt;context().setImageInterpolationQuality(InterpolationQuality::Default);</span>
464     m_imageBuffer-&gt;context().setStrokeThickness(1);
465 
466     return m_imageBuffer.get();
467 }
468 
469 bool MockRealtimeVideoSource::mockDisplayType(CaptureDevice::DeviceType type) const
470 {
471     if (!WTF::holds_alternative&lt;MockDisplayProperties&gt;(m_device.properties))
472         return false;
473 
474     return WTF::get&lt;MockDisplayProperties&gt;(m_device.properties).type == type;
475 }
476 
477 void MockRealtimeVideoSource::orientationChanged(int orientation)
478 {
479     auto deviceOrientation = m_deviceOrientation;
480     switch (orientation) {
481     case 0:
482         m_deviceOrientation = MediaSample::VideoRotation::None;
483         break;
484     case 90:
485         m_deviceOrientation = MediaSample::VideoRotation::Right;
486         break;
487     case -90:
488         m_deviceOrientation = MediaSample::VideoRotation::Left;
489         break;
490     case 180:
491         m_deviceOrientation = MediaSample::VideoRotation::UpsideDown;
492         break;
493     default:
494         return;
495     }
496 
497     if (deviceOrientation == m_deviceOrientation)
498         return;
499 
500     notifySettingsDidChangeObservers({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height });
501 }
502 
503 void MockRealtimeVideoSource::monitorOrientation(OrientationNotifier&amp; notifier)
504 {
505     if (!mockCamera())
506         return;
507 
508     notifier.addObserver(*this);
509     orientationChanged(notifier.orientation());
510 }
511 
512 } // namespace WebCore
513 
514 #endif // ENABLE(MEDIA_STREAM)
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
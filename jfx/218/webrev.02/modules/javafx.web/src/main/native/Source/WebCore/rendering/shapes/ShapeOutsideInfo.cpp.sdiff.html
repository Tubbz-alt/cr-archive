<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/ShapeOutsideInfo.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Shape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeOutsideInfo.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/ShapeOutsideInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
147 
148 std::unique_ptr&lt;Shape&gt; ShapeOutsideInfo::createShapeForImage(StyleImage* styleImage, float shapeImageThreshold, WritingMode writingMode, float margin) const
149 {
150     LayoutSize imageSize = m_renderer.calculateImageIntrinsicDimensions(styleImage, m_referenceBoxLogicalSize, RenderImage::ScaleByEffectiveZoom);
151     styleImage-&gt;setContainerContextForRenderer(m_renderer, imageSize, m_renderer.style().effectiveZoom());
152 
153     const LayoutRect&amp; marginRect = getShapeImageMarginRect(m_renderer, m_referenceBoxLogicalSize);
154     const LayoutRect&amp; imageRect = is&lt;RenderImage&gt;(m_renderer)
155         ? downcast&lt;RenderImage&gt;(m_renderer).replacedContentRect()
156         : LayoutRect(LayoutPoint(), imageSize);
157 
158     ASSERT(!styleImage-&gt;isPending());
159     RefPtr&lt;Image&gt; image = styleImage-&gt;image(const_cast&lt;RenderBox*&gt;(&amp;m_renderer), imageSize);
160     return Shape::createRasterShape(image.get(), shapeImageThreshold, imageRect, marginRect, writingMode, margin);
161 }
162 
163 const Shape&amp; ShapeOutsideInfo::computedShape() const
164 {
165     if (Shape* shape = m_shape.get())
166         return *shape;

167 
168     const RenderStyle&amp; style = m_renderer.style();
169     ASSERT(m_renderer.containingBlock());
170     const RenderStyle&amp; containingBlockStyle = m_renderer.containingBlock()-&gt;style();
171 
172     WritingMode writingMode = containingBlockStyle.writingMode();
173     float margin = floatValueForLength(m_renderer.style().shapeMargin(), m_renderer.containingBlock() ? m_renderer.containingBlock()-&gt;contentWidth() : 0_lu);
174     float shapeImageThreshold = style.shapeImageThreshold();
175     const ShapeValue&amp; shapeValue = *style.shapeOutside();
176 
177     switch (shapeValue.type()) {
178     case ShapeValue::Type::Shape:
179         ASSERT(shapeValue.shape());
180         m_shape = Shape::createShape(*shapeValue.shape(), m_referenceBoxLogicalSize, writingMode, margin);
181         break;
182     case ShapeValue::Type::Image:
183         ASSERT(shapeValue.isImageValid());
184         m_shape = createShapeForImage(shapeValue.image(), shapeImageThreshold, writingMode, margin);
185         break;
186     case ShapeValue::Type::Box: {
</pre>
</td>
<td>
<hr />
<pre>
147 
148 std::unique_ptr&lt;Shape&gt; ShapeOutsideInfo::createShapeForImage(StyleImage* styleImage, float shapeImageThreshold, WritingMode writingMode, float margin) const
149 {
150     LayoutSize imageSize = m_renderer.calculateImageIntrinsicDimensions(styleImage, m_referenceBoxLogicalSize, RenderImage::ScaleByEffectiveZoom);
151     styleImage-&gt;setContainerContextForRenderer(m_renderer, imageSize, m_renderer.style().effectiveZoom());
152 
153     const LayoutRect&amp; marginRect = getShapeImageMarginRect(m_renderer, m_referenceBoxLogicalSize);
154     const LayoutRect&amp; imageRect = is&lt;RenderImage&gt;(m_renderer)
155         ? downcast&lt;RenderImage&gt;(m_renderer).replacedContentRect()
156         : LayoutRect(LayoutPoint(), imageSize);
157 
158     ASSERT(!styleImage-&gt;isPending());
159     RefPtr&lt;Image&gt; image = styleImage-&gt;image(const_cast&lt;RenderBox*&gt;(&amp;m_renderer), imageSize);
160     return Shape::createRasterShape(image.get(), shapeImageThreshold, imageRect, marginRect, writingMode, margin);
161 }
162 
163 const Shape&amp; ShapeOutsideInfo::computedShape() const
164 {
165     if (Shape* shape = m_shape.get())
166         return *shape;
<span class="line-added">167     SetForScope&lt;bool&gt; isInComputingShape(m_isComputingShape, true);</span>
168 
169     const RenderStyle&amp; style = m_renderer.style();
170     ASSERT(m_renderer.containingBlock());
171     const RenderStyle&amp; containingBlockStyle = m_renderer.containingBlock()-&gt;style();
172 
173     WritingMode writingMode = containingBlockStyle.writingMode();
174     float margin = floatValueForLength(m_renderer.style().shapeMargin(), m_renderer.containingBlock() ? m_renderer.containingBlock()-&gt;contentWidth() : 0_lu);
175     float shapeImageThreshold = style.shapeImageThreshold();
176     const ShapeValue&amp; shapeValue = *style.shapeOutside();
177 
178     switch (shapeValue.type()) {
179     case ShapeValue::Type::Shape:
180         ASSERT(shapeValue.shape());
181         m_shape = Shape::createShape(*shapeValue.shape(), m_referenceBoxLogicalSize, writingMode, margin);
182         break;
183     case ShapeValue::Type::Image:
184         ASSERT(shapeValue.isImageValid());
185         m_shape = createShapeForImage(shapeValue.image(), shapeImageThreshold, writingMode, margin);
186         break;
187     case ShapeValue::Type::Box: {
</pre>
</td>
</tr>
</table>
<center><a href="Shape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeOutsideInfo.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
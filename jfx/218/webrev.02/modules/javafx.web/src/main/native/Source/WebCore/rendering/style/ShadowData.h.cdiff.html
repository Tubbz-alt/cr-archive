<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/ShadowData.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ShadowData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeValue.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/ShadowData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,29 ***</span>
  #include &quot;FloatRect.h&quot;
  #include &quot;LayoutRect.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! enum ShadowStyle { Normal, Inset };</span>
  
  // This class holds information about shadows for the text-shadow and box-shadow properties.
  
  class ShadowData {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     ShadowData()</span>
<span class="line-removed">-         : m_radius(0)</span>
<span class="line-removed">-         , m_spread(0)</span>
<span class="line-removed">-         , m_style(Normal)</span>
<span class="line-removed">-         , m_isWebkitBoxShadow(false)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     ShadowData(const IntPoint&amp; location, int radius, int spread, ShadowStyle style, bool isWebkitBoxShadow, const Color&amp; color)</span>
          : m_location(location)
<span class="line-removed">-         , m_radius(radius)</span>
          , m_spread(spread)
          , m_color(color)
          , m_style(style)
          , m_isWebkitBoxShadow(isWebkitBoxShadow)
      {
      }
<span class="line-new-header">--- 28,23 ---</span>
  #include &quot;FloatRect.h&quot;
  #include &quot;LayoutRect.h&quot;
  
  namespace WebCore {
  
<span class="line-modified">! enum class ShadowStyle : uint8_t { Normal, Inset };</span>
  
  // This class holds information about shadows for the text-shadow and box-shadow properties.
  
  class ShadowData {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     ShadowData() = default;</span>
  
<span class="line-modified">!     ShadowData(const LayoutPoint&amp; location, int radius, LayoutUnit spread, ShadowStyle style, bool isWebkitBoxShadow, const Color&amp; color)</span>
          : m_location(location)
          , m_spread(spread)
<span class="line-added">+         , m_radius(radius)</span>
          , m_color(color)
          , m_style(style)
          , m_isWebkitBoxShadow(isWebkitBoxShadow)
      {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,23 ***</span>
      bool operator!=(const ShadowData&amp; o) const
      {
          return !(*this == o);
      }
  
<span class="line-modified">!     int x() const { return m_location.x(); }</span>
<span class="line-modified">!     int y() const { return m_location.y(); }</span>
<span class="line-modified">!     IntPoint location() const { return m_location; }</span>
      int radius() const { return m_radius; }
<span class="line-modified">!     int paintingExtent() const</span>
      {
          // Blurring uses a Gaussian function whose std. deviation is m_radius/2, and which in theory
          // extends to infinity. In 8-bit contexts, however, rounding causes the effect to become
          // undetectable at around 1.4x the radius.
          const float radiusExtentMultiplier = 1.4;
<span class="line-modified">!         return ceilf(m_radius * radiusExtentMultiplier);</span>
      }
<span class="line-modified">!     int spread() const { return m_spread; }</span>
      ShadowStyle style() const { return m_style; }
      const Color&amp; color() const { return m_color; }
      bool isWebkitBoxShadow() const { return m_isWebkitBoxShadow; }
  
      const ShadowData* next() const { return m_next.get(); }
<span class="line-new-header">--- 58,23 ---</span>
      bool operator!=(const ShadowData&amp; o) const
      {
          return !(*this == o);
      }
  
<span class="line-modified">!     LayoutUnit x() const { return m_location.x(); }</span>
<span class="line-modified">!     LayoutUnit y() const { return m_location.y(); }</span>
<span class="line-modified">!     LayoutPoint location() const { return m_location; }</span>
      int radius() const { return m_radius; }
<span class="line-modified">!     LayoutUnit paintingExtent() const</span>
      {
          // Blurring uses a Gaussian function whose std. deviation is m_radius/2, and which in theory
          // extends to infinity. In 8-bit contexts, however, rounding causes the effect to become
          // undetectable at around 1.4x the radius.
          const float radiusExtentMultiplier = 1.4;
<span class="line-modified">!         return LayoutUnit(ceilf(m_radius * radiusExtentMultiplier));</span>
      }
<span class="line-modified">!     LayoutUnit spread() const { return m_spread; }</span>
      ShadowStyle style() const { return m_style; }
      const Color&amp; color() const { return m_color; }
      bool isWebkitBoxShadow() const { return m_isWebkitBoxShadow; }
  
      const ShadowData* next() const { return m_next.get(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,15 ***</span>
  
      void adjustRectForShadow(LayoutRect&amp;, int additionalOutlineSize = 0) const;
      void adjustRectForShadow(FloatRect&amp;, int additionalOutlineSize = 0) const;
  
  private:
<span class="line-modified">!     IntPoint m_location;</span>
<span class="line-modified">!     int m_radius; // This is the &quot;blur radius&quot;, or twice the standard deviation of the Gaussian blur.</span>
<span class="line-modified">!     int m_spread;</span>
      Color m_color;
<span class="line-modified">!     ShadowStyle m_style;</span>
<span class="line-modified">!     bool m_isWebkitBoxShadow;</span>
      std::unique_ptr&lt;ShadowData&gt; m_next;
  };
  
  } // namespace WebCore
<span class="line-new-header">--- 82,17 ---</span>
  
      void adjustRectForShadow(LayoutRect&amp;, int additionalOutlineSize = 0) const;
      void adjustRectForShadow(FloatRect&amp;, int additionalOutlineSize = 0) const;
  
  private:
<span class="line-modified">!     LayoutPoint m_location;</span>
<span class="line-modified">!     LayoutUnit m_spread;</span>
<span class="line-modified">!     int m_radius { 0 }; // This is the &quot;blur radius&quot;, or twice the standard deviation of the Gaussian blur.</span>
      Color m_color;
<span class="line-modified">!     ShadowStyle m_style { ShadowStyle::Normal };</span>
<span class="line-modified">!     bool m_isWebkitBoxShadow { false };</span>
      std::unique_ptr&lt;ShadowData&gt; m_next;
  };
  
<span class="line-added">+ WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const ShadowData&amp;);</span>
<span class="line-added">+ </span>
  } // namespace WebCore
</pre>
<center><a href="ShadowData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeValue.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
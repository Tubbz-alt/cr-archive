<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/network/FormData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2006, 2008, 2011 Apple Inc. All rights reserved.
  3  * Copyright (C) 2009 Google Inc. All rights reserved.
  4  * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB. If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;FormData.h&quot;
 24 
 25 #include &quot;BlobRegistryImpl.h&quot;
 26 #include &quot;BlobURL.h&quot;
 27 #include &quot;Chrome.h&quot;
<a name="1" id="anc1"></a>
 28 #include &quot;DOMFormData.h&quot;
 29 #include &quot;File.h&quot;
 30 #include &quot;FormDataBuilder.h&quot;
 31 #include &quot;Page.h&quot;
 32 #include &quot;SharedBuffer.h&quot;
 33 #include &quot;TextEncoding.h&quot;
 34 #include &quot;ThreadableBlobRegistry.h&quot;
 35 #include &lt;wtf/FileSystem.h&gt;
 36 #include &lt;wtf/text/LineEnding.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 inline FormData::FormData()
 41 {
 42 }
 43 
 44 inline FormData::FormData(const FormData&amp; data)
 45     : RefCounted&lt;FormData&gt;()
 46     , m_elements(data.m_elements)
 47     , m_identifier(data.m_identifier)
 48     , m_alwaysStream(false)
 49     , m_containsPasswordData(data.m_containsPasswordData)
 50 {
 51 }
 52 
 53 FormData::~FormData()
 54 {
 55 }
 56 
 57 Ref&lt;FormData&gt; FormData::create()
 58 {
 59     return adoptRef(*new FormData);
 60 }
 61 
 62 Ref&lt;FormData&gt; FormData::create(const void* data, size_t size)
 63 {
 64     auto result = create();
 65     result-&gt;appendData(data, size);
 66     return result;
 67 }
 68 
 69 Ref&lt;FormData&gt; FormData::create(const CString&amp; string)
 70 {
 71     return create(string.data(), string.length());
 72 }
 73 
 74 Ref&lt;FormData&gt; FormData::create(const Vector&lt;char&gt;&amp; vector)
 75 {
 76     return create(vector.data(), vector.size());
 77 }
 78 
 79 Ref&lt;FormData&gt; FormData::create(Vector&lt;char&gt;&amp;&amp; vector)
 80 {
 81     auto data = create();
 82     data-&gt;m_elements.append(WTFMove(vector));
 83     return data;
 84 }
 85 
 86 Ref&lt;FormData&gt; FormData::create(const Vector&lt;uint8_t&gt;&amp; vector)
 87 {
 88     return create(vector.data(), vector.size());
 89 }
 90 
 91 Ref&lt;FormData&gt; FormData::create(const DOMFormData&amp; formData, EncodingType encodingType)
 92 {
 93     auto result = create();
 94     result-&gt;appendNonMultiPartKeyValuePairItems(formData, encodingType);
 95     return result;
 96 }
 97 
 98 Ref&lt;FormData&gt; FormData::createMultiPart(const DOMFormData&amp; formData)
 99 {
100     auto result = create();
101     result-&gt;appendMultiPartKeyValuePairItems(formData);
102     return result;
103 }
104 
105 Ref&lt;FormData&gt; FormData::copy() const
106 {
107     return adoptRef(*new FormData(*this));
108 }
109 
110 Ref&lt;FormData&gt; FormData::isolatedCopy() const
111 {
112     // FIXME: isolatedCopy() does not copy m_identifier, m_boundary, or m_containsPasswordData.
113     // Is all of that correct and intentional?
114 
115     auto formData = create();
116 
117     formData-&gt;m_alwaysStream = m_alwaysStream;
118 
119     formData-&gt;m_elements.reserveInitialCapacity(m_elements.size());
120     for (auto&amp; element : m_elements)
121         formData-&gt;m_elements.uncheckedAppend(element.isolatedCopy());
122 
123     return formData;
124 }
125 
<a name="2" id="anc2"></a><span class="line-modified">126 uint64_t FormDataElement::lengthInBytes(const Function&lt;uint64_t(const URL&amp;)&gt;&amp; blobSize) const</span>
127 {
<a name="3" id="anc3"></a><span class="line-modified">128     return switchOn(data,</span>
129         [] (const Vector&lt;char&gt;&amp; bytes) {
130             return static_cast&lt;uint64_t&gt;(bytes.size());
131         }, [] (const FormDataElement::EncodedFileData&amp; fileData) {
132             if (fileData.fileLength != BlobDataItem::toEndOfFile)
133                 return static_cast&lt;uint64_t&gt;(fileData.fileLength);
134             long long fileSize;
135             if (FileSystem::getFileSize(fileData.filename, fileSize))
136                 return static_cast&lt;uint64_t&gt;(fileSize);
137             return static_cast&lt;uint64_t&gt;(0);
138         }, [&amp;blobSize] (const FormDataElement::EncodedBlobData&amp; blobData) {
139             return blobSize(blobData.url);
140         }
141     );
142 }
143 
<a name="4" id="anc4"></a><span class="line-modified">144 uint64_t FormDataElement::lengthInBytes() const</span>







145 {
<a name="5" id="anc5"></a><span class="line-modified">146     return lengthInBytes([](auto&amp; url) {</span>
<span class="line-modified">147         return ThreadableBlobRegistry::blobSize(url);</span>
148     });
149 }
150 
151 FormDataElement FormDataElement::isolatedCopy() const
152 {
153     return switchOn(data,
154         [] (const Vector&lt;char&gt;&amp; bytes) {
155             Vector&lt;char&gt; copy;
156             copy.append(bytes.data(), bytes.size());
157             return FormDataElement(WTFMove(copy));
158         }, [] (const FormDataElement::EncodedFileData&amp; fileData) {
159             return FormDataElement(fileData.isolatedCopy());
160         }, [] (const FormDataElement::EncodedBlobData&amp; blobData) {
161             return FormDataElement(blobData.url.isolatedCopy());
162         }
163     );
164 }
165 
166 void FormData::appendData(const void* data, size_t size)
167 {
168     m_lengthInBytes = WTF::nullopt;
169     if (!m_elements.isEmpty()) {
170         if (auto* vector = WTF::get_if&lt;Vector&lt;char&gt;&gt;(m_elements.last().data)) {
171             vector-&gt;append(reinterpret_cast&lt;const char*&gt;(data), size);
172             return;
173         }
174     }
175     Vector&lt;char&gt; vector;
176     vector.append(reinterpret_cast&lt;const char*&gt;(data), size);
177     m_elements.append(WTFMove(vector));
178 }
179 
180 void FormData::appendFile(const String&amp; filename)
181 {
182     m_elements.append(FormDataElement(filename, 0, BlobDataItem::toEndOfFile, WTF::nullopt));
183     m_lengthInBytes = WTF::nullopt;
184 }
185 
186 void FormData::appendFileRange(const String&amp; filename, long long start, long long length, Optional&lt;WallTime&gt; expectedModificationTime)
187 {
188     m_elements.append(FormDataElement(filename, start, length, expectedModificationTime));
189     m_lengthInBytes = WTF::nullopt;
190 }
191 
192 void FormData::appendBlob(const URL&amp; blobURL)
193 {
194     m_elements.append(FormDataElement(blobURL));
195     m_lengthInBytes = WTF::nullopt;
196 }
197 
198 static Vector&lt;uint8_t&gt; normalizeStringData(TextEncoding&amp; encoding, const String&amp; value)
199 {
200     return normalizeLineEndingsToCRLF(encoding.encode(value, UnencodableHandling::Entities));
201 }
202 
203 void FormData::appendMultiPartFileValue(const File&amp; file, Vector&lt;char&gt;&amp; header, TextEncoding&amp; encoding)
204 {
205     auto name = file.name();
206 
207     // We have to include the filename=&quot;..&quot; part in the header, even if the filename is empty
208     FormDataBuilder::addFilenameToMultiPartHeader(header, encoding, name);
209 
210     // Add the content type if available, or &quot;application/octet-stream&quot; otherwise (RFC 1867).
211     auto contentType = file.type();
212     if (contentType.isEmpty())
213         contentType = &quot;application/octet-stream&quot;_s;
214     ASSERT(Blob::isNormalizedContentType(contentType));
215 
216     FormDataBuilder::addContentTypeToMultiPartHeader(header, contentType.ascii());
217 
218     FormDataBuilder::finishMultiPartHeader(header);
219     appendData(header.data(), header.size());
220 
221     if (!file.path().isEmpty())
222         appendFile(file.path());
223     else if (file.size())
224         appendBlob(file.url());
225 }
226 
227 void FormData::appendMultiPartStringValue(const String&amp; string, Vector&lt;char&gt;&amp; header, TextEncoding&amp; encoding)
228 {
229     FormDataBuilder::finishMultiPartHeader(header);
230     appendData(header.data(), header.size());
231 
232     auto normalizedStringData = normalizeStringData(encoding, string);
233     appendData(normalizedStringData.data(), normalizedStringData.size());
234 }
235 
236 void FormData::appendMultiPartKeyValuePairItems(const DOMFormData&amp; formData)
237 {
238     m_boundary = FormDataBuilder::generateUniqueBoundaryString();
239 
240     auto encoding = formData.encoding();
241 
242     Vector&lt;char&gt; encodedData;
243     for (auto&amp; item : formData.items()) {
244         auto normalizedName = normalizeStringData(encoding, item.name);
245 
246         Vector&lt;char&gt; header;
247         FormDataBuilder::beginMultiPartHeader(header, m_boundary.data(), normalizedName);
248 
249         if (WTF::holds_alternative&lt;RefPtr&lt;File&gt;&gt;(item.data))
250             appendMultiPartFileValue(*WTF::get&lt;RefPtr&lt;File&gt;&gt;(item.data), header, encoding);
251         else
252             appendMultiPartStringValue(WTF::get&lt;String&gt;(item.data), header, encoding);
253 
254         appendData(&quot;\r\n&quot;, 2);
255     }
256 
257     FormDataBuilder::addBoundaryToMultiPartHeader(encodedData, m_boundary.data(), true);
258 
259     appendData(encodedData.data(), encodedData.size());
260 }
261 
262 void FormData::appendNonMultiPartKeyValuePairItems(const DOMFormData&amp; formData, EncodingType encodingType)
263 {
264     auto encoding = formData.encoding();
265 
266     Vector&lt;char&gt; encodedData;
267     for (auto&amp; item : formData.items()) {
268         ASSERT(WTF::holds_alternative&lt;String&gt;(item.data));
269 
270         auto normalizedName = normalizeStringData(encoding, item.name);
271         auto normalizedStringData = normalizeStringData(encoding, WTF::get&lt;String&gt;(item.data));
272         FormDataBuilder::addKeyValuePairAsFormData(encodedData, normalizedName, normalizedStringData, encodingType);
273     }
274 
275     appendData(encodedData.data(), encodedData.size());
276 }
277 
278 Vector&lt;char&gt; FormData::flatten() const
279 {
280     // Concatenate all the byte arrays, but omit any files.
281     Vector&lt;char&gt; data;
282     for (auto&amp; element : m_elements) {
283         if (auto* vector = WTF::get_if&lt;Vector&lt;char&gt;&gt;(element.data))
284             data.append(vector-&gt;data(), vector-&gt;size());
285     }
286     return data;
287 }
288 
289 String FormData::flattenToString() const
290 {
291     auto bytes = flatten();
292     return Latin1Encoding().decode(reinterpret_cast&lt;const char*&gt;(bytes.data()), bytes.size());
293 }
294 
295 static void appendBlobResolved(BlobRegistryImpl* blobRegistry, FormData&amp; formData, const URL&amp; url)
296 {
297     if (!blobRegistry) {
298         LOG_ERROR(&quot;Tried to resolve a blob without a usable registry&quot;);
299         return;
300     }
301 
302     auto* blobData = blobRegistry-&gt;getBlobDataFromURL(url);
303     if (!blobData) {
304         LOG_ERROR(&quot;Could not get blob data from a registry&quot;);
305         return;
306     }
307 
308     for (const auto&amp; blobItem : blobData-&gt;items()) {
309         if (blobItem.type() == BlobDataItem::Type::Data) {
310             ASSERT(blobItem.data().data());
311             formData.appendData(blobItem.data().data()-&gt;data() + static_cast&lt;int&gt;(blobItem.offset()), static_cast&lt;int&gt;(blobItem.length()));
312         } else if (blobItem.type() == BlobDataItem::Type::File)
313             formData.appendFileRange(blobItem.file()-&gt;path(), blobItem.offset(), blobItem.length(), blobItem.file()-&gt;expectedModificationTime());
314         else
315             ASSERT_NOT_REACHED();
316     }
317 }
318 
<a name="6" id="anc6"></a><span class="line-modified">319 Ref&lt;FormData&gt; FormData::resolveBlobReferences(BlobRegistryImpl* blobRegistryImpl)</span>
320 {
321     // First check if any blobs needs to be resolved, or we can take the fast path.
322     bool hasBlob = false;
323     for (auto&amp; element : m_elements) {
324         if (WTF::holds_alternative&lt;FormDataElement::EncodedBlobData&gt;(element.data)) {
325             hasBlob = true;
326             break;
327         }
328     }
329 
330     if (!hasBlob)
331         return *this;
332 
333     // Create a copy to append the result into.
334     auto newFormData = FormData::create();
335     newFormData-&gt;setAlwaysStream(alwaysStream());
336     newFormData-&gt;setIdentifier(identifier());
337 
338     for (auto&amp; element : m_elements) {
339         switchOn(element.data,
340             [&amp;] (const Vector&lt;char&gt;&amp; bytes) {
341                 newFormData-&gt;appendData(bytes.data(), bytes.size());
342             }, [&amp;] (const FormDataElement::EncodedFileData&amp; fileData) {
343                 newFormData-&gt;appendFileRange(fileData.filename, fileData.fileStart, fileData.fileLength, fileData.expectedFileModificationTime);
344             }, [&amp;] (const FormDataElement::EncodedBlobData&amp; blobData) {
<a name="7" id="anc7"></a><span class="line-modified">345                 appendBlobResolved(blobRegistryImpl ? blobRegistryImpl : blobRegistry().blobRegistryImpl(), newFormData.get(), blobData.url);</span>
346             }
347         );
348     }
349     return newFormData;
350 }
351 
352 FormDataForUpload FormData::prepareForUpload()
353 {
354     Vector&lt;String&gt; generatedFiles;
355     for (auto&amp; element : m_elements) {
356         auto* fileData = WTF::get_if&lt;FormDataElement::EncodedFileData&gt;(element.data);
357         if (!fileData)
358             continue;
359         if (!FileSystem::fileIsDirectory(fileData-&gt;filename, FileSystem::ShouldFollowSymbolicLinks::Yes))
360             continue;
361         if (fileData-&gt;fileStart || fileData-&gt;fileLength != BlobDataItem::toEndOfFile)
362             continue;
363         if (!fileData-&gt;fileModificationTimeMatchesExpectation())
364             continue;
365 
366         auto generatedFilename = FileSystem::createTemporaryZipArchive(fileData-&gt;filename);
367         if (!generatedFilename)
368             continue;
369         fileData-&gt;filename = generatedFilename;
370         generatedFiles.append(WTFMove(generatedFilename));
371     }
372 
373     return { *this, WTFMove(generatedFiles) };
374 }
375 
376 FormDataForUpload::FormDataForUpload(FormData&amp; data, Vector&lt;String&gt;&amp;&amp; temporaryZipFiles)
377     : m_data(data)
378     , m_temporaryZipFiles(WTFMove(temporaryZipFiles))
379 {
380 }
381 
382 FormDataForUpload::~FormDataForUpload()
383 {
384     ASSERT(isMainThread());
385     for (auto&amp; file : m_temporaryZipFiles)
386         FileSystem::deleteFile(file);
387 }
388 
<a name="8" id="anc8"></a><span class="line-modified">389 uint64_t FormData::lengthInBytes() const</span>
390 {
391     if (!m_lengthInBytes) {
392         uint64_t length = 0;
393         for (auto&amp; element : m_elements)
<a name="9" id="anc9"></a><span class="line-modified">394             length += element.lengthInBytes();</span>
395         m_lengthInBytes = length;
396     }
397     return *m_lengthInBytes;
398 }
399 
400 RefPtr&lt;SharedBuffer&gt; FormData::asSharedBuffer() const
401 {
402     for (auto&amp; element : m_elements) {
403         if (!WTF::holds_alternative&lt;Vector&lt;char&gt;&gt;(element.data))
404             return nullptr;
405     }
406     return SharedBuffer::create(flatten());
407 }
408 
409 URL FormData::asBlobURL() const
410 {
411     if (m_elements.size() != 1)
412         return { };
413 
414     if (auto* blobData = WTF::get_if&lt;FormDataElement::EncodedBlobData&gt;(m_elements.first().data))
415         return blobData-&gt;url;
416     return { };
417 }
418 
419 bool FormDataElement::EncodedFileData::fileModificationTimeMatchesExpectation() const
420 {
421     if (!expectedFileModificationTime)
422         return true;
423 
424     auto fileModificationTime = FileSystem::getFileModificationTime(filename);
425     if (!fileModificationTime)
426         return false;
427 
428     if (fileModificationTime-&gt;secondsSinceEpoch().secondsAs&lt;time_t&gt;() != expectedFileModificationTime-&gt;secondsSinceEpoch().secondsAs&lt;time_t&gt;())
429         return false;
430 
431     return true;
432 }
433 
434 } // namespace WebCore
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
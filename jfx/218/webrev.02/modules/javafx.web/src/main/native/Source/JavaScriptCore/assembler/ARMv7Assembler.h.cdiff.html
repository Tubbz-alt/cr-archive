<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARMv7Assembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ARM64Registers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARMv7Registers.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARMv7Assembler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2010 University of Szeged
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2010 University of Szeged
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,13 ***</span>
  class ARMv7Assembler;
  class ARMThumbImmediate {
      friend class ARMv7Assembler;
  
      typedef uint8_t ThumbImmediateType;
<span class="line-modified">!     static const ThumbImmediateType TypeInvalid = 0;</span>
<span class="line-modified">!     static const ThumbImmediateType TypeEncoded = 1;</span>
<span class="line-modified">!     static const ThumbImmediateType TypeUInt16 = 2;</span>
  
      typedef union {
          int16_t asInt;
          struct {
              unsigned imm8 : 8;
<span class="line-new-header">--- 101,13 ---</span>
  class ARMv7Assembler;
  class ARMThumbImmediate {
      friend class ARMv7Assembler;
  
      typedef uint8_t ThumbImmediateType;
<span class="line-modified">!     static constexpr ThumbImmediateType TypeInvalid = 0;</span>
<span class="line-modified">!     static constexpr ThumbImmediateType TypeEncoded = 1;</span>
<span class="line-modified">!     static constexpr ThumbImmediateType TypeUInt16 = 2;</span>
  
      typedef union {
          int16_t asInt;
          struct {
              unsigned imm8 : 8;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1027,13 ***</span>
      ALWAYS_INLINE void ldr(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
      {
          ASSERT(rn != ARMRegisters::pc); // LDR (literal)
          ASSERT(imm.isUInt12());
  
<span class="line-modified">!         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt7())</span>
              m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDR_imm_T1, imm.getUInt7() &gt;&gt; 2, rn, rt);
<span class="line-modified">!         else if ((rn == ARMRegisters::sp) &amp;&amp; !(rt &amp; 8) &amp;&amp; imm.isUInt10())</span>
              m_formatter.oneWordOp5Reg3Imm8(OP_LDR_imm_T2, rt, static_cast&lt;uint8_t&gt;(imm.getUInt10() &gt;&gt; 2));
          else
              m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T3, rn, rt, imm.getUInt12());
      }
  
<span class="line-new-header">--- 1027,17 ---</span>
      ALWAYS_INLINE void ldr(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
      {
          ASSERT(rn != ARMRegisters::pc); // LDR (literal)
          ASSERT(imm.isUInt12());
  
<span class="line-modified">!         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt7() &amp;&amp; !(imm.getUInt7() % 4)) {</span>
<span class="line-added">+             // We can only use Encoding T1 when imm is a multiple of 4.</span>
<span class="line-added">+             // For details see A8.8.63 on ARM Architecture Reference</span>
<span class="line-added">+             // Manual ARMv7-A and ARMv7-R edition available on</span>
<span class="line-added">+             // https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf</span>
              m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDR_imm_T1, imm.getUInt7() &gt;&gt; 2, rn, rt);
<span class="line-modified">!         } else if ((rn == ARMRegisters::sp) &amp;&amp; !(rt &amp; 8) &amp;&amp; imm.isUInt10())</span>
              m_formatter.oneWordOp5Reg3Imm8(OP_LDR_imm_T2, rt, static_cast&lt;uint8_t&gt;(imm.getUInt10() &gt;&gt; 2));
          else
              m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T3, rn, rt, imm.getUInt12());
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1967,12 ***</span>
      static constexpr int32_t nopPseudo32()
      {
          return OP_NOP_T2a | (OP_NOP_T2b &lt;&lt; 16);
      }
  
<span class="line-modified">!     template &lt;typename CopyFunction&gt;</span>
<span class="line-modified">!     static void fillNops(void* base, size_t size, CopyFunction copy)</span>
      {
          RELEASE_ASSERT(!(size % sizeof(int16_t)));
  
          char* ptr = static_cast&lt;char*&gt;(base);
          const size_t num32s = size / sizeof(int32_t);
<span class="line-new-header">--- 1971,14 ---</span>
      static constexpr int32_t nopPseudo32()
      {
          return OP_NOP_T2a | (OP_NOP_T2b &lt;&lt; 16);
      }
  
<span class="line-modified">!     using CopyFunction = void*(&amp;)(void*, const void*, size_t);</span>
<span class="line-modified">! </span>
<span class="line-added">+     template &lt;CopyFunction copy&gt;</span>
<span class="line-added">+     static void fillNops(void* base, size_t size)</span>
      {
          RELEASE_ASSERT(!(size % sizeof(int16_t)));
  
          char* ptr = static_cast&lt;char*&gt;(base);
          const size_t num32s = size / sizeof(int32_t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2121,36 ***</span>
      {
          std::sort(m_jumpsToLink.begin(), m_jumpsToLink.end(), linkRecordSourceComparator);
          return m_jumpsToLink;
      }
  
<span class="line-modified">!     typedef void* (*CopyFunction)(void*, const void*, size_t);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to, CopyFunction copy)</span>
      {
          const uint16_t* fromInstruction = reinterpret_cast_ptr&lt;const uint16_t*&gt;(fromInstruction8);
          switch (record.linkType()) {
          case LinkJumpT1:
<span class="line-modified">!             linkJumpT1(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
              break;
          case LinkJumpT2:
<span class="line-modified">!             linkJumpT2(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
              break;
          case LinkJumpT3:
<span class="line-modified">!             linkJumpT3(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
              break;
          case LinkJumpT4:
<span class="line-modified">!             linkJumpT4(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
              break;
          case LinkConditionalJumpT4:
<span class="line-modified">!             linkConditionalJumpT4(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
              break;
          case LinkConditionalBX:
<span class="line-modified">!             linkConditionalBX(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
              break;
          case LinkBX:
<span class="line-modified">!             linkBX(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
<span class="line-new-header">--- 2127,35 ---</span>
      {
          std::sort(m_jumpsToLink.begin(), m_jumpsToLink.end(), linkRecordSourceComparator);
          return m_jumpsToLink;
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy&gt;</span>
<span class="line-modified">!     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to)</span>
      {
          const uint16_t* fromInstruction = reinterpret_cast_ptr&lt;const uint16_t*&gt;(fromInstruction8);
          switch (record.linkType()) {
          case LinkJumpT1:
<span class="line-modified">!             linkJumpT1&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpT2:
<span class="line-modified">!             linkJumpT2&lt;copy&gt;(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpT3:
<span class="line-modified">!             linkJumpT3&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpT4:
<span class="line-modified">!             linkJumpT4&lt;copy&gt;(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkConditionalJumpT4:
<span class="line-modified">!             linkConditionalJumpT4&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkConditionalBX:
<span class="line-modified">!             linkConditionalBX&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkBX:
<span class="line-modified">!             linkBX&lt;copy&gt;(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2373,11 ***</span>
      }
  #endif
  
      static void cacheFlush(void* code, size_t size)
      {
<span class="line-modified">! #if OS(IOS_FAMILY)</span>
          sys_cache_control(kCacheFunctionPrepareForExecution, code, size);
  #elif OS(LINUX)
          size_t page = pageSize();
          uintptr_t current = reinterpret_cast&lt;uintptr_t&gt;(code);
          uintptr_t end = current + size;
<span class="line-new-header">--- 2378,11 ---</span>
      }
  #endif
  
      static void cacheFlush(void* code, size_t size)
      {
<span class="line-modified">! #if OS(DARWIN)</span>
          sys_cache_control(kCacheFunctionPrepareForExecution, code, size);
  #elif OS(LINUX)
          size_t page = pageSize();
          uintptr_t current = reinterpret_cast&lt;uintptr_t&gt;(code);
          uintptr_t end = current + size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2597,11 ***</span>
  
          intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
          return ((relative &lt;&lt; 7) &gt;&gt; 7) == relative;
      }
  
<span class="line-modified">!     static void linkJumpT1(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT1(instruction, target));
<span class="line-new-header">--- 2602,12 ---</span>
  
          intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
          return ((relative &lt;&lt; 7) &gt;&gt; 7) == relative;
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="line-added">+     static void linkJumpT1(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT1(instruction, target));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2616,11 ***</span>
          ASSERT(!(relative &amp; 1));
          uint16_t newInstruction = OP_B_T1 | ((cond &amp; 0xf) &lt;&lt; 8) | ((relative &amp; 0x1fe) &gt;&gt; 1);
          copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
      }
  
<span class="line-modified">!     static void linkJumpT2(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT2(instruction, target));
<span class="line-new-header">--- 2622,12 ---</span>
          ASSERT(!(relative &amp; 1));
          uint16_t newInstruction = OP_B_T1 | ((cond &amp; 0xf) &lt;&lt; 8) | ((relative &amp; 0x1fe) &gt;&gt; 1);
          copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="line-added">+     static void linkJumpT2(uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT2(instruction, target));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2635,11 ***</span>
          ASSERT(!(relative &amp; 1));
          uint16_t newInstruction = OP_B_T2 | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
      }
  
<span class="line-modified">!     static void linkJumpT3(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT3(instruction, target));
<span class="line-new-header">--- 2642,12 ---</span>
          ASSERT(!(relative &amp; 1));
          uint16_t newInstruction = OP_B_T2 | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="line-added">+     static void linkJumpT3(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT3(instruction, target));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2652,11 ***</span>
          instructions[0] = OP_B_T3a | ((relative &amp; 0x100000) &gt;&gt; 10) | ((cond &amp; 0xf) &lt;&lt; 6) | ((relative &amp; 0x3f000) &gt;&gt; 12);
          instructions[1] = OP_B_T3b | ((relative &amp; 0x80000) &gt;&gt; 8) | ((relative &amp; 0x40000) &gt;&gt; 5) | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
      }
  
<span class="line-modified">!     static void linkJumpT4(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT4(instruction, target));
<span class="line-new-header">--- 2660,12 ---</span>
          instructions[0] = OP_B_T3a | ((relative &amp; 0x100000) &gt;&gt; 10) | ((cond &amp; 0xf) &lt;&lt; 6) | ((relative &amp; 0x3f000) &gt;&gt; 12);
          instructions[1] = OP_B_T3b | ((relative &amp; 0x80000) &gt;&gt; 8) | ((relative &amp; 0x40000) &gt;&gt; 5) | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="line-added">+     static void linkJumpT4(uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT4(instruction, target));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2672,22 ***</span>
          instructions[0] = OP_B_T4a | ((relative &amp; 0x1000000) &gt;&gt; 14) | ((relative &amp; 0x3ff000) &gt;&gt; 12);
          instructions[1] = OP_B_T4b | ((relative &amp; 0x800000) &gt;&gt; 10) | ((relative &amp; 0x400000) &gt;&gt; 11) | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
      }
  
<span class="line-modified">!     static void linkConditionalJumpT4(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
  
          uint16_t newInstruction = ifThenElse(cond) | OP_IT;
          copy(writeTarget - 3, &amp;newInstruction, sizeof(uint16_t));
<span class="line-modified">!         linkJumpT4(writeTarget, instruction, target, copy);</span>
      }
  
<span class="line-modified">!     static void linkBX(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT_UNUSED(instruction, !(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(writeTarget) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
<span class="line-new-header">--- 2681,24 ---</span>
          instructions[0] = OP_B_T4a | ((relative &amp; 0x1000000) &gt;&gt; 14) | ((relative &amp; 0x3ff000) &gt;&gt; 12);
          instructions[1] = OP_B_T4b | ((relative &amp; 0x800000) &gt;&gt; 10) | ((relative &amp; 0x400000) &gt;&gt; 11) | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="line-added">+     static void linkConditionalJumpT4(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
  
          uint16_t newInstruction = ifThenElse(cond) | OP_IT;
          copy(writeTarget - 3, &amp;newInstruction, sizeof(uint16_t));
<span class="line-modified">!         linkJumpT4&lt;copy&gt;(writeTarget, instruction, target);</span>
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="line-added">+     static void linkBX(uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT_UNUSED(instruction, !(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(writeTarget) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2703,11 ***</span>
          instructions[4] = OP_BX | (JUMP_TEMPORARY_REGISTER &lt;&lt; 3);
  
          copy(writeTarget - 5, instructions, 5 * sizeof(uint16_t));
      }
  
<span class="line-modified">!     static void linkConditionalBX(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
  
<span class="line-new-header">--- 2714,12 ---</span>
          instructions[4] = OP_BX | (JUMP_TEMPORARY_REGISTER &lt;&lt; 3);
  
          copy(writeTarget - 5, instructions, 5 * sizeof(uint16_t));
      }
  
<span class="line-modified">!     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="line-added">+     static void linkConditionalBX(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
  
</pre>
<center><a href="ARM64Registers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARMv7Registers.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
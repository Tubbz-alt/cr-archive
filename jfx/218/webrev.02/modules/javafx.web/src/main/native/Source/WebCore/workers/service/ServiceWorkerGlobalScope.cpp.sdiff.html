<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerGlobalScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerFetchResult.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerGlobalScope.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerGlobalScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerGlobalScope.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExtendableEvent.h&quot;

 32 #include &quot;SWContextManager.h&quot;
 33 #include &quot;ServiceWorkerClient.h&quot;
 34 #include &quot;ServiceWorkerClients.h&quot;
 35 #include &quot;ServiceWorkerContainer.h&quot;
 36 #include &quot;ServiceWorkerThread.h&quot;
 37 #include &quot;ServiceWorkerWindowClient.h&quot;
 38 #include &quot;WorkerNavigator.h&quot;
 39 #include &lt;wtf/IsoMallocInlines.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerGlobalScope);
 44 
<span class="line-modified"> 45 Ref&lt;ServiceWorkerGlobalScope&gt; ServiceWorkerGlobalScope::create(const ServiceWorkerContextData&amp; data, const URL&amp; url, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, const String&amp; identifier, const String&amp; userAgent, bool isOnline, ServiceWorkerThread&amp; thread, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, bool shouldBypassMainWorldContentSecurityPolicy, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, PAL::SessionID sessionID)</span>
 46 {
<span class="line-modified"> 47     auto scope = adoptRef(*new ServiceWorkerGlobalScope { data, url, WTFMove(origin), identifier, userAgent, isOnline, thread, shouldBypassMainWorldContentSecurityPolicy, WTFMove(topOrigin), timeOrigin, connectionProxy, socketProvider, sessionID });</span>
<span class="line-modified"> 48     scope-&gt;applyContentSecurityPolicyResponseHeaders(contentSecurityPolicy);</span>
 49     return scope;
 50 }
 51 
<span class="line-modified"> 52 ServiceWorkerGlobalScope::ServiceWorkerGlobalScope(const ServiceWorkerContextData&amp; data, const URL&amp; url, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, const String&amp; identifier, const String&amp; userAgent, bool isOnline, ServiceWorkerThread&amp; thread, bool shouldBypassMainWorldContentSecurityPolicy, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider, PAL::SessionID sessionID)</span>
<span class="line-modified"> 53     : WorkerGlobalScope(url, WTFMove(origin), identifier, userAgent, isOnline, thread, shouldBypassMainWorldContentSecurityPolicy, WTFMove(topOrigin), timeOrigin, connectionProxy, socketProvider, sessionID)</span>
 54     , m_contextData(crossThreadCopy(data))
 55     , m_registration(ServiceWorkerRegistration::getOrCreate(*this, navigator().serviceWorker(), WTFMove(m_contextData.registration)))
 56     , m_clients(ServiceWorkerClients::create())
 57 {
 58 }
 59 
 60 ServiceWorkerGlobalScope::~ServiceWorkerGlobalScope() = default;
 61 
 62 void ServiceWorkerGlobalScope::skipWaiting(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 63 {
 64     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
 65     m_pendingSkipWaitingPromises.add(requestIdentifier, WTFMove(promise));
 66 
 67     callOnMainThread([workerThread = makeRef(thread()), requestIdentifier]() mutable {
 68         if (auto* connection = SWContextManager::singleton().connection()) {
 69             auto identifier = workerThread-&gt;identifier();
 70             connection-&gt;skipWaiting(identifier, [workerThread = WTFMove(workerThread), requestIdentifier] {
 71                 workerThread-&gt;runLoop().postTask([requestIdentifier](auto&amp; context) {
 72                     auto&amp; scope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);
<span class="line-modified"> 73                     if (auto promise = scope.m_pendingSkipWaitingPromises.take(requestIdentifier))</span>
<span class="line-modified"> 74                         promise-&gt;resolve();</span>


 75                 });
 76             });
 77         }
 78     });
 79 }
 80 
 81 EventTargetInterface ServiceWorkerGlobalScope::eventTargetInterface() const
 82 {
 83     return ServiceWorkerGlobalScopeEventTargetInterfaceType;
 84 }
 85 
 86 ServiceWorkerThread&amp; ServiceWorkerGlobalScope::thread()
 87 {
 88     return static_cast&lt;ServiceWorkerThread&amp;&gt;(WorkerGlobalScope::thread());
 89 }
 90 
 91 ServiceWorkerClient* ServiceWorkerGlobalScope::serviceWorkerClient(ServiceWorkerClientIdentifier identifier)
 92 {
 93     return m_clientMap.get(identifier);
 94 }
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerGlobalScope.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;ExtendableEvent.h&quot;
<span class="line-added"> 32 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 33 #include &quot;SWContextManager.h&quot;
 34 #include &quot;ServiceWorkerClient.h&quot;
 35 #include &quot;ServiceWorkerClients.h&quot;
 36 #include &quot;ServiceWorkerContainer.h&quot;
 37 #include &quot;ServiceWorkerThread.h&quot;
 38 #include &quot;ServiceWorkerWindowClient.h&quot;
 39 #include &quot;WorkerNavigator.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerGlobalScope);
 45 
<span class="line-modified"> 46 Ref&lt;ServiceWorkerGlobalScope&gt; ServiceWorkerGlobalScope::create(const ServiceWorkerContextData&amp; data, const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, ServiceWorkerThread&amp; thread, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)</span>
 47 {
<span class="line-modified"> 48     auto scope = adoptRef(*new ServiceWorkerGlobalScope { data, params, WTFMove(origin), thread, WTFMove(topOrigin), connectionProxy, socketProvider });</span>
<span class="line-modified"> 49     scope-&gt;applyContentSecurityPolicyResponseHeaders(params.contentSecurityPolicyResponseHeaders);</span>
 50     return scope;
 51 }
 52 
<span class="line-modified"> 53 ServiceWorkerGlobalScope::ServiceWorkerGlobalScope(const ServiceWorkerContextData&amp; data, const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, ServiceWorkerThread&amp; thread, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)</span>
<span class="line-modified"> 54     : WorkerGlobalScope(params, WTFMove(origin), thread, WTFMove(topOrigin), connectionProxy, socketProvider)</span>
 55     , m_contextData(crossThreadCopy(data))
 56     , m_registration(ServiceWorkerRegistration::getOrCreate(*this, navigator().serviceWorker(), WTFMove(m_contextData.registration)))
 57     , m_clients(ServiceWorkerClients::create())
 58 {
 59 }
 60 
 61 ServiceWorkerGlobalScope::~ServiceWorkerGlobalScope() = default;
 62 
 63 void ServiceWorkerGlobalScope::skipWaiting(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 64 {
 65     uint64_t requestIdentifier = ++m_lastRequestIdentifier;
 66     m_pendingSkipWaitingPromises.add(requestIdentifier, WTFMove(promise));
 67 
 68     callOnMainThread([workerThread = makeRef(thread()), requestIdentifier]() mutable {
 69         if (auto* connection = SWContextManager::singleton().connection()) {
 70             auto identifier = workerThread-&gt;identifier();
 71             connection-&gt;skipWaiting(identifier, [workerThread = WTFMove(workerThread), requestIdentifier] {
 72                 workerThread-&gt;runLoop().postTask([requestIdentifier](auto&amp; context) {
 73                     auto&amp; scope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);
<span class="line-modified"> 74                     scope.eventLoop().queueTask(TaskSource::DOMManipulation, [scope = makeRef(scope), requestIdentifier]() mutable {</span>
<span class="line-modified"> 75                         if (auto promise = scope-&gt;m_pendingSkipWaitingPromises.take(requestIdentifier))</span>
<span class="line-added"> 76                             promise-&gt;resolve();</span>
<span class="line-added"> 77                     });</span>
 78                 });
 79             });
 80         }
 81     });
 82 }
 83 
 84 EventTargetInterface ServiceWorkerGlobalScope::eventTargetInterface() const
 85 {
 86     return ServiceWorkerGlobalScopeEventTargetInterfaceType;
 87 }
 88 
 89 ServiceWorkerThread&amp; ServiceWorkerGlobalScope::thread()
 90 {
 91     return static_cast&lt;ServiceWorkerThread&amp;&gt;(WorkerGlobalScope::thread());
 92 }
 93 
 94 ServiceWorkerClient* ServiceWorkerGlobalScope::serviceWorkerClient(ServiceWorkerClientIdentifier identifier)
 95 {
 96     return m_clientMap.get(identifier);
 97 }
</pre>
</td>
</tr>
</table>
<center><a href="ServiceWorkerFetchResult.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerGlobalScope.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
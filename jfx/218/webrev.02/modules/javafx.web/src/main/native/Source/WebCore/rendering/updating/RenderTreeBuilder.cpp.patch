diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp
@@ -36,10 +36,11 @@
 #include "RenderGrid.h"
 #include "RenderLineBreak.h"
 #include "RenderMathMLFenced.h"
 #include "RenderMenuList.h"
 #include "RenderMultiColumnFlow.h"
+#include "RenderMultiColumnSpannerPlaceholder.h"
 #include "RenderRuby.h"
 #include "RenderRubyBase.h"
 #include "RenderRubyRun.h"
 #include "RenderSVGContainer.h"
 #include "RenderSVGInline.h"
@@ -61,10 +62,17 @@
 #include "RenderTreeBuilderMathML.h"
 #include "RenderTreeBuilderMultiColumn.h"
 #include "RenderTreeBuilderRuby.h"
 #include "RenderTreeBuilderSVG.h"
 #include "RenderTreeBuilderTable.h"
+#include "RenderView.h"
+
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+#include "FrameView.h"
+#include "FrameViewLayoutContext.h"
+#include "RuntimeEnabledFeatures.h"
+#endif
 
 namespace WebCore {
 
 RenderTreeBuilder* RenderTreeBuilder::s_current;
 
@@ -183,10 +191,15 @@
 
 void RenderTreeBuilder::attach(RenderElement& parent, RenderPtr<RenderObject> child, RenderObject* beforeChild)
 {
     auto insertRecursiveIfNeeded = [&](RenderElement& parentCandidate) {
         if (&parent == &parentCandidate) {
+            // Parents inside multicols can't call internal attach directly.
+            if (is<RenderBlockFlow>(parent) && downcast<RenderBlockFlow>(parent).multiColumnFlow()) {
+                blockFlowBuilder().attach(downcast<RenderBlockFlow>(parent), WTFMove(child), beforeChild);
+                return;
+            }
             attachToRenderElement(parent, WTFMove(child), beforeChild);
             return;
         }
         attach(parentCandidate, WTFMove(child), beforeChild);
     };
@@ -194,10 +207,24 @@
     ASSERT(&parent.view() == &m_view);
 
     if (is<RenderText>(beforeChild)) {
         if (auto* wrapperInline = downcast<RenderText>(*beforeChild).inlineWrapperForDisplayContents())
             beforeChild = wrapperInline;
+    } else if (is<RenderBox>(beforeChild)) {
+        // Adjust the beforeChild if it happens to be a spanner and the its actual location is inside the fragmented flow.
+        auto& beforeChildBox = downcast<RenderBox>(*beforeChild);
+        if (auto* enclosingFragmentedFlow = parent.enclosingFragmentedFlow()) {
+            auto columnSpannerPlaceholderForBeforeChild = [&]() -> RenderMultiColumnSpannerPlaceholder* {
+                if (!is<RenderMultiColumnFlow>(enclosingFragmentedFlow))
+                    return nullptr;
+                auto& multiColumnFlow = downcast<RenderMultiColumnFlow>(*enclosingFragmentedFlow);
+                return multiColumnFlow.findColumnSpannerPlaceholder(&beforeChildBox);
+            };
+
+            if (auto* spannerPlaceholder = columnSpannerPlaceholderForBeforeChild())
+                beforeChild = spannerPlaceholder;
+        }
     }
 
     if (is<RenderTableRow>(parent)) {
         auto& parentCandidate = tableBuilder().findOrCreateParentForChild(downcast<RenderTableRow>(parent), *child, beforeChild);
         if (&parentCandidate == &parent) {
@@ -429,10 +456,17 @@
         cache->childrenChanged(&parent, newChild);
     if (is<RenderBlockFlow>(parent))
         downcast<RenderBlockFlow>(parent).invalidateLineLayoutPath();
     if (parent.hasOutlineAutoAncestor() || parent.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On)
         newChild->setHasOutlineAutoAncestor();
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+    if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {
+        if (parent.document().view())
+            parent.document().view()->layoutContext().invalidateLayoutTreeContent();
+
+    }
+#endif
 }
 
 void RenderTreeBuilder::move(RenderBoxModelObject& from, RenderBoxModelObject& to, RenderObject& child, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
 {
     // We assume that callers have cleared their positioned objects list for child moves so the
@@ -658,10 +692,16 @@
         // childBecameNonInline might have re-parented us.
         if (auto* newParent = child.parent()) {
             // We need to re-run the grid items placement if it had gained a new item.
             if (newParent != parent && is<RenderGrid>(*newParent))
                 downcast<RenderGrid>(*newParent).dirtyGrid();
+            else if (auto* enclosingFragmentedFlow = newParent->enclosingFragmentedFlow()) {
+                if (is<RenderMultiColumnFlow>(*enclosingFragmentedFlow)) {
+                    // Let the fragmented flow know that it has a new in-flow descendant.
+                    multiColumnBuilder().multiColumnDescendantInserted(downcast<RenderMultiColumnFlow>(*enclosingFragmentedFlow), child);
+                }
+            }
         }
     } else {
         // An anonymous block must be made to wrap this inline.
         auto newBlock = downcast<RenderBlock>(*parent).createAnonymousBlock();
         auto& block = *newBlock;
@@ -846,11 +886,17 @@
 
     if (!parent.renderTreeBeingDestroyed()) {
         if (AXObjectCache* cache = parent.document().existingAXObjectCache())
             cache->childrenChanged(&parent);
     }
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+    if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {
+        if (parent.document().view())
+            parent.document().view()->layoutContext().invalidateLayoutTreeContent();
 
+    }
+#endif
     return childToTake;
 }
 
 void RenderTreeBuilder::attachToRenderGrid(RenderGrid& parent, RenderPtr<RenderObject> child, RenderObject* beforeChild)
 {

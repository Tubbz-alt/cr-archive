<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/FastBitVector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012, 2013, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;string.h&gt;
 29 #include &lt;wtf/Atomics.h&gt;
 30 #include &lt;wtf/FastMalloc.h&gt;
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
 33 
 34 namespace WTF {
 35 
 36 class PrintStream;
 37 
<a name="1" id="anc1"></a><span class="line-modified"> 38 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(FastBitVector);</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 inline constexpr size_t fastBitVectorArrayLength(size_t numBits) { return (numBits + 31) / 32; }</span>
 41 
 42 class FastBitVectorWordView {
 43     WTF_MAKE_FAST_ALLOCATED;
 44 public:
 45     typedef FastBitVectorWordView ViewType;
 46 
 47     FastBitVectorWordView() { }
 48 
 49     FastBitVectorWordView(const uint32_t* array, size_t numBits)
 50         : m_words(array)
 51         , m_numBits(numBits)
 52     {
 53     }
 54 
 55     size_t numBits() const
 56     {
 57         return m_numBits;
 58     }
 59 
 60     uint32_t word(size_t index) const
 61     {
 62         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; fastBitVectorArrayLength(numBits()));
 63         return m_words[index];
 64     }
 65 
 66 private:
 67     const uint32_t* m_words { nullptr };
 68     size_t m_numBits { 0 };
 69 };
 70 
 71 class FastBitVectorWordOwner {
 72     WTF_MAKE_FAST_ALLOCATED;
 73 public:
 74     typedef FastBitVectorWordView ViewType;
 75 
 76     FastBitVectorWordOwner() = default;
 77 
 78     FastBitVectorWordOwner(FastBitVectorWordOwner&amp;&amp; other)
 79         : m_words(std::exchange(other.m_words, nullptr))
 80         , m_numBits(std::exchange(other.m_numBits, 0))
 81     {
 82     }
 83 
 84     FastBitVectorWordOwner(const FastBitVectorWordOwner&amp; other)
 85     {
 86         *this = other;
 87     }
 88 
 89     ~FastBitVectorWordOwner()
 90     {
 91         if (m_words)
<a name="2" id="anc2"></a><span class="line-modified"> 92             FastBitVectorMalloc::free(m_words);</span>
 93     }
 94 
 95     FastBitVectorWordView view() const { return FastBitVectorWordView(m_words, m_numBits); }
 96 
 97     FastBitVectorWordOwner&amp; operator=(const FastBitVectorWordOwner&amp; other)
 98     {
 99         if (arrayLength() != other.arrayLength())
100             setEqualsSlow(other);
101         else {
102             memcpy(m_words, other.m_words, arrayLength() * sizeof(uint32_t));
103             m_numBits = other.m_numBits;
104         }
105         return *this;
106     }
107 
108     FastBitVectorWordOwner&amp; operator=(FastBitVectorWordOwner&amp;&amp; other)
109     {
110         std::swap(m_words, other.m_words);
111         std::swap(m_numBits, other.m_numBits);
112         return *this;
113     }
114 
115     void setAll()
116     {
117         memset(m_words, 255, arrayLength() * sizeof(uint32_t));
118     }
119 
120     void clearAll()
121     {
122         memset(m_words, 0, arrayLength() * sizeof(uint32_t));
123     }
124 
125     void set(const FastBitVectorWordOwner&amp; other)
126     {
127         ASSERT_WITH_SECURITY_IMPLICATION(m_numBits == other.m_numBits);
128         memcpy(m_words, other.m_words, arrayLength() * sizeof(uint32_t));
129     }
130 
131     size_t numBits() const
132     {
133         return m_numBits;
134     }
135 
136     size_t arrayLength() const
137     {
138         return fastBitVectorArrayLength(numBits());
139     }
140 
141     void resize(size_t numBits)
142     {
143         if (arrayLength() != fastBitVectorArrayLength(numBits))
144             resizeSlow(numBits);
145         m_numBits = numBits;
146     }
147 
148     uint32_t word(size_t index) const
149     {
150         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; arrayLength());
151         return m_words[index];
152     }
153 
154     uint32_t&amp; word(size_t index)
155     {
156         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; arrayLength());
157         return m_words[index];
158     }
159 
160     const uint32_t* words() const { return m_words; }
161     uint32_t* words() { return m_words; }
162 
163 private:
164     WTF_EXPORT_PRIVATE void setEqualsSlow(const FastBitVectorWordOwner&amp; other);
165     WTF_EXPORT_PRIVATE void resizeSlow(size_t numBits);
166 
167     uint32_t* m_words { nullptr };
168     size_t m_numBits { 0 };
169 };
170 
171 template&lt;typename Left, typename Right&gt;
172 class FastBitVectorAndWords {
173     WTF_MAKE_FAST_ALLOCATED;
174 public:
175     typedef FastBitVectorAndWords ViewType;
176 
177     FastBitVectorAndWords(const Left&amp; left, const Right&amp; right)
178         : m_left(left)
179         , m_right(right)
180     {
181         ASSERT_WITH_SECURITY_IMPLICATION(m_left.numBits() == m_right.numBits());
182     }
183 
184     FastBitVectorAndWords view() const { return *this; }
185 
186     size_t numBits() const
187     {
188         return m_left.numBits();
189     }
190 
191     uint32_t word(size_t index) const
192     {
193         return m_left.word(index) &amp; m_right.word(index);
194     }
195 
196 private:
197     Left m_left;
198     Right m_right;
199 };
200 
201 template&lt;typename Left, typename Right&gt;
202 class FastBitVectorOrWords {
203     WTF_MAKE_FAST_ALLOCATED;
204 public:
205     typedef FastBitVectorOrWords ViewType;
206 
207     FastBitVectorOrWords(const Left&amp; left, const Right&amp; right)
208         : m_left(left)
209         , m_right(right)
210     {
211         ASSERT_WITH_SECURITY_IMPLICATION(m_left.numBits() == m_right.numBits());
212     }
213 
214     FastBitVectorOrWords view() const { return *this; }
215 
216     size_t numBits() const
217     {
218         return m_left.numBits();
219     }
220 
221     uint32_t word(size_t index) const
222     {
223         return m_left.word(index) | m_right.word(index);
224     }
225 
226 private:
227     Left m_left;
228     Right m_right;
229 };
230 
231 template&lt;typename View&gt;
232 class FastBitVectorNotWords {
233     WTF_MAKE_FAST_ALLOCATED;
234 public:
235     typedef FastBitVectorNotWords ViewType;
236 
237     FastBitVectorNotWords(const View&amp; view)
238         : m_view(view)
239     {
240     }
241 
242     FastBitVectorNotWords view() const { return *this; }
243 
244     size_t numBits() const
245     {
246         return m_view.numBits();
247     }
248 
249     uint32_t word(size_t index) const
250     {
251         return ~m_view.word(index);
252     }
253 
254 private:
255     View m_view;
256 };
257 
258 class FastBitVector;
259 
260 template&lt;typename Words&gt;
261 class FastBitVectorImpl {
262     WTF_MAKE_FAST_ALLOCATED;
263 public:
264     FastBitVectorImpl()
265         : m_words()
266     {
267     }
268 
269     FastBitVectorImpl(const Words&amp; words)
270         : m_words(words)
271     {
272     }
273 
274     FastBitVectorImpl(Words&amp;&amp; words)
275         : m_words(WTFMove(words))
276     {
277     }
278 
279     size_t numBits() const { return m_words.numBits(); }
280     size_t size() const { return numBits(); }
281 
282     size_t arrayLength() const { return fastBitVectorArrayLength(numBits()); }
283 
284     template&lt;typename Other&gt;
285     bool operator==(const Other&amp; other) const
286     {
287         if (numBits() != other.numBits())
288             return false;
289         for (size_t i = arrayLength(); i--;) {
290             if (m_words.word(i) != other.m_words.word(i))
291                 return false;
292         }
293         return true;
294     }
295 
296     template&lt;typename Other&gt;
297     bool operator!=(const Other&amp; other) const
298     {
299         return !(*this == other);
300     }
301 
302     bool at(size_t index) const
303     {
304         return atImpl(index);
305     }
306 
307     bool operator[](size_t index) const
308     {
309         return atImpl(index);
310     }
311 
312     size_t bitCount() const
313     {
314         size_t result = 0;
315         for (size_t index = arrayLength(); index--;)
316             result += WTF::bitCount(m_words.word(index));
317         return result;
318     }
319 
320     bool isEmpty() const
321     {
322         for (size_t index = arrayLength(); index--;) {
323             if (m_words.word(index))
324                 return false;
325         }
326         return true;
327     }
328 
329     template&lt;typename OtherWords&gt;
330     FastBitVectorImpl&lt;FastBitVectorAndWords&lt;typename Words::ViewType, typename OtherWords::ViewType&gt;&gt; operator&amp;(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other) const
331     {
332         return FastBitVectorImpl&lt;FastBitVectorAndWords&lt;typename Words::ViewType, typename OtherWords::ViewType&gt;&gt;(FastBitVectorAndWords&lt;typename Words::ViewType, typename OtherWords::ViewType&gt;(wordView(), other.wordView()));
333     }
334 
335     template&lt;typename OtherWords&gt;
336     FastBitVectorImpl&lt;FastBitVectorOrWords&lt;typename Words::ViewType, typename OtherWords::ViewType&gt;&gt; operator|(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other) const
337     {
338         return FastBitVectorImpl&lt;FastBitVectorOrWords&lt;typename Words::ViewType, typename OtherWords::ViewType&gt;&gt;(FastBitVectorOrWords&lt;typename Words::ViewType, typename OtherWords::ViewType&gt;(wordView(), other.wordView()));
339     }
340 
341     FastBitVectorImpl&lt;FastBitVectorNotWords&lt;typename Words::ViewType&gt;&gt; operator~() const
342     {
343         return FastBitVectorImpl&lt;FastBitVectorNotWords&lt;typename Words::ViewType&gt;&gt;(FastBitVectorNotWords&lt;typename Words::ViewType&gt;(wordView()));
344     }
345 
346     template&lt;typename Func&gt;
347     ALWAYS_INLINE void forEachSetBit(const Func&amp; func) const
348     {
349         size_t n = arrayLength();
350         for (size_t i = 0; i &lt; n; ++i) {
351             uint32_t word = m_words.word(i);
352             size_t j = i * 32;
353             while (word) {
354                 if (word &amp; 1)
355                     func(j);
356                 word &gt;&gt;= 1;
357                 j++;
358             }
359         }
360     }
361 
362     template&lt;typename Func&gt;
363     ALWAYS_INLINE void forEachClearBit(const Func&amp; func) const
364     {
365         (~*this).forEachSetBit(func);
366     }
367 
368     template&lt;typename Func&gt;
369     void forEachBit(bool value, const Func&amp; func) const
370     {
371         if (value)
372             forEachSetBit(func);
373         else
374             forEachClearBit(func);
375     }
376 
377     // Starts looking for bits at the index you pass. If that index contains the value you want,
378     // then it will return that index. Returns numBits when we get to the end. For example, you
379     // can write a loop to iterate over all set bits like this:
380     //
381     // for (size_t i = 0; i &lt; bits.numBits(); i = bits.findBit(i + 1, true))
382     //     ...
383     ALWAYS_INLINE size_t findBit(size_t startIndex, bool value) const
384     {
385         // If value is true, this produces 0. If value is false, this produces UINT_MAX. It&#39;s
386         // written this way so that it performs well regardless of whether value is a constant.
387         uint32_t skipValue = -(static_cast&lt;uint32_t&gt;(value) ^ 1);
388 
389         size_t numWords = fastBitVectorArrayLength(m_words.numBits());
390 
391         size_t wordIndex = startIndex / 32;
392         size_t startIndexInWord = startIndex - wordIndex * 32;
393 
394         while (wordIndex &lt; numWords) {
395             uint32_t word = m_words.word(wordIndex);
396             if (word != skipValue) {
397                 size_t index = startIndexInWord;
398                 if (findBitInWord(word, index, 32, value))
399                     return wordIndex * 32 + index;
400             }
401 
402             wordIndex++;
403             startIndexInWord = 0;
404         }
405 
406         return numBits();
407     }
408 
409     ALWAYS_INLINE size_t findSetBit(size_t index) const
410     {
411         return findBit(index, true);
412     }
413 
414     ALWAYS_INLINE size_t findClearBit(size_t index) const
415     {
416         return findBit(index, false);
417     }
418 
419     void dump(PrintStream&amp; out) const
420     {
421         for (size_t i = 0; i &lt; numBits(); ++i)
422             out.print((*this)[i] ? &quot;1&quot; : &quot;-&quot;);
423     }
424 
425     typename Words::ViewType wordView() const { return m_words.view(); }
426 
<a name="3" id="anc3"></a><span class="line-added">427     Words&amp; unsafeWords() { return m_words; }</span>
<span class="line-added">428     const Words&amp; unsafeWords() const { return m_words; }</span>
<span class="line-added">429 </span>
430 private:
431     // You&#39;d think that we could remove this friend if we used protected, but you&#39;d be wrong,
432     // because templates.
433     friend class FastBitVector;
434 
435     bool atImpl(size_t index) const
436     {
437         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
438         return !!(m_words.word(index &gt;&gt; 5) &amp; (1 &lt;&lt; (index &amp; 31)));
439     }
440 
441     Words m_words;
442 };
443 
<a name="4" id="anc4"></a><span class="line-added">444 class FastBitReference {</span>
<span class="line-added">445     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">446 public:</span>
<span class="line-added">447     FastBitReference() = default;</span>
<span class="line-added">448 </span>
<span class="line-added">449     FastBitReference(uint32_t* word, uint32_t mask)</span>
<span class="line-added">450         : m_word(word)</span>
<span class="line-added">451         , m_mask(mask)</span>
<span class="line-added">452     {</span>
<span class="line-added">453     }</span>
<span class="line-added">454 </span>
<span class="line-added">455     operator bool() const</span>
<span class="line-added">456     {</span>
<span class="line-added">457         return !!(*m_word &amp; m_mask);</span>
<span class="line-added">458     }</span>
<span class="line-added">459 </span>
<span class="line-added">460     FastBitReference&amp; operator=(bool value)</span>
<span class="line-added">461     {</span>
<span class="line-added">462         if (value)</span>
<span class="line-added">463             *m_word |= m_mask;</span>
<span class="line-added">464         else</span>
<span class="line-added">465             *m_word &amp;= ~m_mask;</span>
<span class="line-added">466         return *this;</span>
<span class="line-added">467     }</span>
<span class="line-added">468 </span>
<span class="line-added">469     FastBitReference&amp; operator|=(bool value) { return value ? *this = value : *this; }</span>
<span class="line-added">470     FastBitReference&amp; operator&amp;=(bool value) { return value ? *this : *this = value; }</span>
<span class="line-added">471 </span>
<span class="line-added">472 private:</span>
<span class="line-added">473     uint32_t* m_word { nullptr };</span>
<span class="line-added">474     uint32_t m_mask { 0 };</span>
<span class="line-added">475 };</span>
<span class="line-added">476 </span>
<span class="line-added">477 </span>
<span class="line-added">478 </span>
479 class FastBitVector : public FastBitVectorImpl&lt;FastBitVectorWordOwner&gt; {
480 public:
481     FastBitVector() { }
482 
483     FastBitVector(const FastBitVector&amp;) = default;
484     FastBitVector&amp; operator=(const FastBitVector&amp;) = default;
485 
486     template&lt;typename OtherWords&gt;
487     FastBitVector(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
488     {
489         *this = other;
490     }
491 
492     template&lt;typename OtherWords&gt;
493     FastBitVector&amp; operator=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
494     {
495         if (UNLIKELY(numBits() != other.numBits()))
496             resize(other.numBits());
497 
498         for (unsigned i = arrayLength(); i--;)
499             m_words.word(i) = other.m_words.word(i);
500         return *this;
501     }
502 
503     void resize(size_t numBits)
504     {
505         m_words.resize(numBits);
506     }
507 
508     void setAll()
509     {
510         m_words.setAll();
511     }
512 
513     void clearAll()
514     {
515         m_words.clearAll();
516     }
517 
<a name="5" id="anc5"></a><span class="line-added">518     // For templating as Vector&lt;bool&gt;</span>
<span class="line-added">519     void fill(bool value) { value ? setAll() : clearAll(); }</span>
<span class="line-added">520     void grow(size_t newSize) { resize(newSize); }</span>
<span class="line-added">521 </span>
522     WTF_EXPORT_PRIVATE void clearRange(size_t begin, size_t end);
523 
524     // Returns true if the contents of this bitvector changed.
525     template&lt;typename OtherWords&gt;
526     bool setAndCheck(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
527     {
528         bool changed = false;
529         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
530         for (unsigned i = arrayLength(); i--;) {
531             changed |= m_words.word(i) != other.m_words.word(i);
532             m_words.word(i) = other.m_words.word(i);
533         }
534         return changed;
535     }
536 
537     template&lt;typename OtherWords&gt;
538     FastBitVector&amp; operator|=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
539     {
540         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
541         for (unsigned i = arrayLength(); i--;)
542             m_words.word(i) |= other.m_words.word(i);
543         return *this;
544     }
545 
546     template&lt;typename OtherWords&gt;
547     FastBitVector&amp; operator&amp;=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
548     {
549         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
550         for (unsigned i = arrayLength(); i--;)
551             m_words.word(i) &amp;= other.m_words.word(i);
552         return *this;
553     }
554 
555     bool at(size_t index) const
556     {
557         return atImpl(index);
558     }
559 
560     bool operator[](size_t index) const
561     {
562         return atImpl(index);
563     }
564 
<a name="6" id="anc6"></a><span class="line-modified">565     FastBitReference at(size_t index)</span>





























566     {
567         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
<a name="7" id="anc7"></a><span class="line-modified">568         return FastBitReference(&amp;m_words.word(index &gt;&gt; 5), 1 &lt;&lt; (index &amp; 31));</span>
569     }
570 
<a name="8" id="anc8"></a><span class="line-modified">571     FastBitReference operator[](size_t index)</span>
572     {
573         return at(index);
574     }
575 
576     // Returns true if the contents changed.
577     ALWAYS_INLINE bool atomicSetAndCheck(size_t index, bool value)
578     {
579         uint32_t* pointer = &amp;m_words.word(index &gt;&gt; 5);
580         uint32_t mask = 1 &lt;&lt; (index &amp; 31);
581         for (;;) {
582             uint32_t oldValue = *pointer;
583             uint32_t newValue;
584             if (value) {
585                 if (oldValue &amp; mask)
586                     return false;
587                 newValue = oldValue | mask;
588             } else {
589                 if (!(oldValue &amp; mask))
590                     return false;
591                 newValue = oldValue &amp; ~mask;
592             }
593             if (atomicCompareExchangeWeakRelaxed(pointer, oldValue, newValue))
594                 return true;
595         }
596     }
597 };
598 
599 } // namespace WTF
600 
<a name="9" id="anc9"></a><span class="line-added">601 using WTF::FastBitReference;</span>
602 using WTF::FastBitVector;
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
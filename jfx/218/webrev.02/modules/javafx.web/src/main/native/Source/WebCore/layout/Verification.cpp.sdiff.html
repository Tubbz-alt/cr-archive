<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/Verification.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MarginTypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="blockformatting/BlockFormattingContext.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/Verification.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutState.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 

 31 #include &quot;DisplayBox.h&quot;

 32 #include &quot;InlineTextBox.h&quot;
 33 #include &quot;LayoutBox.h&quot;
 34 #include &quot;LayoutContainer.h&quot;

 35 #include &quot;LayoutTreeBuilder.h&quot;
 36 #include &quot;RenderBox.h&quot;
 37 #include &quot;RenderInline.h&quot;
 38 #include &quot;RenderLineBreak.h&quot;
 39 #include &quot;RenderView.h&quot;
 40 #include &lt;wtf/text/TextStream.h&gt;
 41 
 42 namespace WebCore {
 43 namespace Layout {
 44 
 45 static bool areEssentiallyEqual(LayoutUnit a, LayoutUnit b)
 46 {
 47     if (a == b)
 48         return true;
 49     // 1/4th CSS pixel.
 50     constexpr float epsilon = kFixedPointDenominator / 4;
 51     return abs(a.rawValue() - b.rawValue()) &lt;= epsilon;
 52 }
 53 
<span class="line-modified"> 54 static bool areEssentiallyEqual(float a, LayoutUnit b)</span>
 55 {
<span class="line-modified"> 56     return areEssentiallyEqual(LayoutUnit { a }, b);</span>
 57 }
 58 
 59 static bool areEssentiallyEqual(LayoutRect a, LayoutRect b)
 60 {
 61     return areEssentiallyEqual(a.x(), b.x())
 62         &amp;&amp; areEssentiallyEqual(a.y(), b.y())
 63         &amp;&amp; areEssentiallyEqual(a.width(), b.width())
 64         &amp;&amp; areEssentiallyEqual(a.height(), b.height());
 65 }
 66 
 67 static bool outputMismatchingSimpleLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
 68 {
 69     auto* lineLayoutData = blockFlow.simpleLineLayout();
 70     if (!lineLayoutData) {
 71         ASSERT_NOT_REACHED();
 72         return true;
 73     }
 74 
 75     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
<span class="line-modified"> 76     ASSERT(is&lt;InlineFormattingState&gt;(inlineFormattingState));</span>
<span class="line-modified"> 77     auto&amp; inlineRunList = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).inlineRuns();</span>



 78 
<span class="line-modified"> 79     if (inlineRunList.size() != lineLayoutData-&gt;runCount()) {</span>
<span class="line-modified"> 80         stream &lt;&lt; &quot;Mismatching number of runs: simple runs(&quot; &lt;&lt; lineLayoutData-&gt;runCount() &lt;&lt; &quot;) inline runs(&quot; &lt;&lt; inlineRunList.size() &lt;&lt; &quot;)&quot;;</span>


 81         stream.nextLine();
 82         return true;
 83     }
 84 
 85     auto mismatched = false;
 86     for (unsigned i = 0; i &lt; lineLayoutData-&gt;runCount(); ++i) {
 87         auto&amp; simpleRun = lineLayoutData-&gt;runAt(i);
<span class="line-modified"> 88         auto&amp; inlineRun = inlineRunList[i];</span>
 89 
<span class="line-modified"> 90         auto matchingRuns = areEssentiallyEqual(simpleRun.logicalLeft, inlineRun-&gt;logicalLeft()) &amp;&amp; areEssentiallyEqual(simpleRun.logicalRight, inlineRun-&gt;logicalRight());</span>
<span class="line-modified"> 91         if (matchingRuns &amp;&amp; inlineRun-&gt;textContext()) {</span>
<span class="line-modified"> 92             matchingRuns = simpleRun.start == inlineRun-&gt;textContext()-&gt;start() &amp;&amp; simpleRun.end == inlineRun-&gt;textContext()-&gt;end();</span>
 93             // SLL handles strings in a more concatenated format &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; -&gt; foo -&gt; 0,3 bar -&gt; 3,6 vs. 0,3 and 0,3
 94             if (!matchingRuns)
<span class="line-modified"> 95                 matchingRuns = (simpleRun.end - simpleRun.start) == (inlineRun-&gt;textContext()-&gt;end() - inlineRun-&gt;textContext()-&gt;start());</span>
 96         }
 97         if (matchingRuns)
 98             continue;
 99 
<span class="line-modified">100         stream &lt;&lt; &quot;Mismatching: simple run(&quot; &lt;&lt; simpleRun.start &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.end &lt;&lt; &quot;) (&quot; &lt;&lt; simpleRun.logicalLeft &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.logicalRight &lt;&lt; &quot;) layout run(&quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;end() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineRun-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;logicalRight() &lt;&lt; &quot;)&quot;;</span>




101         stream.nextLine();
102         mismatched = true;
103     }
104     return mismatched;
105 }
106 
107 static bool checkForMatchingNonTextRuns(const Display::Run&amp; inlineRun, const WebCore::InlineBox&amp; inlineBox)
108 {
<span class="line-modified">109     return areEssentiallyEqual(inlineBox.logicalLeft(), inlineRun.logicalLeft())</span>
<span class="line-modified">110         &amp;&amp; areEssentiallyEqual(inlineBox.logicalRight(), inlineRun.logicalRight())</span>
<span class="line-modified">111         &amp;&amp; areEssentiallyEqual(inlineBox.logicalTop(), inlineRun.logicalTop())</span>
<span class="line-modified">112         &amp;&amp; areEssentiallyEqual(inlineBox.logicalBottom(), inlineRun.logicalBottom());</span>
113 }
114 
115 
116 static bool checkForMatchingTextRuns(const Display::Run&amp; inlineRun, const InlineTextBox&amp; inlineTextBox)
117 {
<span class="line-modified">118     return areEssentiallyEqual(inlineTextBox.logicalLeft(), inlineRun.logicalLeft())</span>
<span class="line-modified">119         &amp;&amp; areEssentiallyEqual(inlineTextBox.logicalRight(), inlineRun.logicalRight())</span>
<span class="line-modified">120         &amp;&amp; areEssentiallyEqual(inlineTextBox.logicalTop(), inlineRun.logicalTop())</span>
<span class="line-modified">121         &amp;&amp; areEssentiallyEqual(inlineTextBox.logicalBottom(), inlineRun.logicalBottom())</span>
<span class="line-modified">122         &amp;&amp; inlineTextBox.start() == inlineRun.textContext()-&gt;start()</span>
<span class="line-removed">123         &amp;&amp; (inlineTextBox.end() + 1) == inlineRun.textContext()-&gt;end();</span>
124 }
125 
126 static void collectFlowBoxSubtree(const InlineFlowBox&amp; flowbox, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
127 {
<span class="line-modified">128     auto* inlineBox = flowbox.firstLeafChild();</span>
<span class="line-modified">129     auto* lastLeafChild = flowbox.lastLeafChild();</span>
130     while (inlineBox) {
131         inlineBoxes.append(inlineBox);
<span class="line-modified">132         if (inlineBox == lastLeafChild)</span>
133             break;
<span class="line-modified">134         inlineBox = inlineBox-&gt;nextLeafChild();</span>
135     }
136 }
137 
138 static void collectInlineBoxes(const RenderBlockFlow&amp; root, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
139 {
140     for (auto* rootLine = root.firstRootBox(); rootLine; rootLine = rootLine-&gt;nextRootBox()) {
141         for (auto* inlineBox = rootLine-&gt;firstChild(); inlineBox; inlineBox = inlineBox-&gt;nextOnLine()) {
142             if (!is&lt;InlineFlowBox&gt;(inlineBox)) {
143                 inlineBoxes.append(inlineBox);
144                 continue;
145             }
146             collectFlowBoxSubtree(downcast&lt;InlineFlowBox&gt;(*inlineBox), inlineBoxes);
147         }
148     }
149 }
150 
151 static bool outputMismatchingComplexLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
152 {
153     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
<span class="line-modified">154     ASSERT(is&lt;InlineFormattingState&gt;(inlineFormattingState));</span>
<span class="line-modified">155     auto&amp; inlineRunList = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).inlineRuns();</span>





156 
157     // Collect inlineboxes.
158     Vector&lt;WebCore::InlineBox*&gt; inlineBoxes;
159     collectInlineBoxes(blockFlow, inlineBoxes);
160 
161     auto mismatched = false;
162     unsigned runIndex = 0;
163 
<span class="line-modified">164     if (inlineBoxes.size() != inlineRunList.size()) {</span>
<span class="line-modified">165         stream &lt;&lt; &quot;Warning: mismatching number of runs: inlineboxes(&quot; &lt;&lt; inlineBoxes.size() &lt;&lt; &quot;) vs. inline runs(&quot; &lt;&lt; inlineRunList.size() &lt;&lt; &quot;)&quot;;</span>
166         stream.nextLine();
167     }
168 
<span class="line-modified">169     for (unsigned inlineBoxIndex = 0; inlineBoxIndex &lt; inlineBoxes.size() &amp;&amp; runIndex &lt; inlineRunList.size(); ++inlineBoxIndex) {</span>
<span class="line-modified">170         auto&amp; inlineRun = inlineRunList[runIndex];</span>
171         auto* inlineBox = inlineBoxes[inlineBoxIndex];
172         auto* inlineTextBox = is&lt;InlineTextBox&gt;(inlineBox) ? downcast&lt;InlineTextBox&gt;(inlineBox) : nullptr;
<span class="line-modified">173         bool matchingRuns = inlineTextBox ? checkForMatchingTextRuns(*inlineRun, *inlineTextBox) : matchingRuns = checkForMatchingNonTextRuns(*inlineRun, *inlineBox);</span>
174 
175         if (!matchingRuns) {
176 
177             if (is&lt;RenderLineBreak&gt;(inlineBox-&gt;renderer())) {
178                 // &lt;br&gt; positioning is weird at this point. It needs proper baseline.
179                 matchingRuns = true;
180                 ++runIndex;
181                 continue;
182             }
183 
184             stream &lt;&lt; &quot;Mismatching: run&quot;;
185 
186             if (inlineTextBox)
<span class="line-modified">187                 stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineTextBox-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineTextBox-&gt;end() + 1 &lt;&lt; &quot;)&quot;;</span>
188             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineBox-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineBox-&gt;logicalTop() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineBox-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineBox-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;
189 
190             stream &lt;&lt; &quot; inline run&quot;;
<span class="line-modified">191             if (inlineRun-&gt;textContext())</span>
<span class="line-modified">192                 stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;textContext()-&gt;end() &lt;&lt; &quot;)&quot;;</span>
<span class="line-modified">193             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineRun-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineRun-&gt;logicalTop() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineRun-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineRun-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;</span>
194             stream.nextLine();
195             mismatched = true;
196         }
197         ++runIndex;
198     }
199     return mismatched;
200 }
201 
202 static bool outputMismatchingBlockBoxInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
203 {
204     bool firstMismatchingRect = true;
205     auto outputRect = [&amp;] (const String&amp; prefix, const LayoutRect&amp; rendererRect, const LayoutRect&amp; layoutRect) {
206         if (firstMismatchingRect) {
207             stream &lt;&lt; (renderer.element() ? renderer.element()-&gt;nodeName().utf8().data() : &quot;&quot;) &lt;&lt; &quot; &quot; &lt;&lt; renderer.renderName() &lt;&lt; &quot;(&quot; &lt;&lt; &amp;renderer &lt;&lt; &quot;) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;;
208             stream.nextLine();
209             firstMismatchingRect = false;
210         }
211 
212         stream  &lt;&lt; prefix.utf8().data() &lt;&lt; &quot;\trenderer-&gt;(&quot; &lt;&lt; rendererRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; rendererRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; rendererRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; rendererRect.height() &lt;&lt; &quot;)&quot;
213             &lt;&lt; &quot;\tlayout-&gt;(&quot; &lt;&lt; layoutRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; layoutRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; layoutRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; layoutRect.height() &lt;&lt; &quot;)&quot;;
</pre>
<hr />
<pre>
255 
256     if (!areEssentiallyEqual(renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox))) {
257         // In certain cases, like out-of-flow boxes with margin auto, marginBoxRect() returns 0. It&#39;s clearly incorrect,
258         // so let&#39;s check the individual margin values instead (and at this point we know that all other boxes match).
259         auto marginsMatch = displayBox.marginBefore() == renderer.marginBefore()
260             &amp;&amp; displayBox.marginAfter() == renderer.marginAfter()
261             &amp;&amp; displayBox.marginStart() == renderer.marginStart()
262             &amp;&amp; displayBox.marginEnd() == renderer.marginEnd();
263 
264         if (!marginsMatch) {
265             outputRect(&quot;marginBox&quot;, renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox));
266             return true;
267         }
268     }
269 
270     return false;
271 }
272 
273 static bool verifyAndOutputSubtree(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
274 {




275     auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, renderer, layoutBox);
276 
277     if (!is&lt;Container&gt;(layoutBox))
278         return mismtachingGeometry;
279 
280     auto&amp; container = downcast&lt;Container&gt;(layoutBox);
281     auto* childLayoutBox = container.firstChild();
282     auto* childRenderer = renderer.firstChild();
283 
284     while (childRenderer) {
285         if (!is&lt;RenderBox&gt;(*childRenderer)) {
286             childRenderer = childRenderer-&gt;nextSibling();
287             continue;
288         }
289 
290         if (!childLayoutBox) {
291             stream  &lt;&lt; &quot;Trees are out of sync!&quot;;
292             stream.nextLine();
293             return true;
294         }
</pre>
<hr />
<pre>
297             ASSERT(childRenderer-&gt;childrenInline());
298             auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
299             if (mismtachingGeometry)
300                 return true;
301 
302             auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*childRenderer);
303             auto&amp; formattingRoot = downcast&lt;Container&gt;(*childLayoutBox);
304             mismtachingGeometry |= blockFlow.lineLayoutPath() == RenderBlockFlow::SimpleLinesPath ? outputMismatchingSimpleLineInformationIfNeeded(stream, context, blockFlow, formattingRoot) : outputMismatchingComplexLineInformationIfNeeded(stream, context, blockFlow, formattingRoot);
305         } else {
306             auto mismatchingSubtreeGeometry = verifyAndOutputSubtree(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
307             mismtachingGeometry |= mismatchingSubtreeGeometry;
308         }
309 
310         childLayoutBox = childLayoutBox-&gt;nextSibling();
311         childRenderer = childRenderer-&gt;nextSibling();
312     }
313 
314     return mismtachingGeometry;
315 }
316 
<span class="line-modified">317 void LayoutState::verifyAndOutputMismatchingLayoutTree(const RenderView&amp; renderView) const</span>
318 {
319     TextStream stream;
<span class="line-modified">320     auto mismatchingGeometry = verifyAndOutputSubtree(stream, *this, renderView, initialContainingBlock());</span>

321     if (!mismatchingGeometry)
322         return;
323 #if ENABLE(TREE_DEBUGGING)
<span class="line-modified">324     showRenderTree(&amp;renderView);</span>
<span class="line-modified">325     showLayoutTree(initialContainingBlock(), this);</span>
326 #endif
327     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
328     ASSERT_NOT_REACHED();
329 }
330 
331 }
332 }
333 
334 #endif


</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutState.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<span class="line-added"> 31 #ifndef NDEBUG</span>
 32 #include &quot;DisplayBox.h&quot;
<span class="line-added"> 33 #include &quot;InlineFormattingState.h&quot;</span>
 34 #include &quot;InlineTextBox.h&quot;
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;
<span class="line-added"> 37 #include &quot;LayoutContext.h&quot;</span>
 38 #include &quot;LayoutTreeBuilder.h&quot;
 39 #include &quot;RenderBox.h&quot;
 40 #include &quot;RenderInline.h&quot;
 41 #include &quot;RenderLineBreak.h&quot;
 42 #include &quot;RenderView.h&quot;
 43 #include &lt;wtf/text/TextStream.h&gt;
 44 
 45 namespace WebCore {
 46 namespace Layout {
 47 
 48 static bool areEssentiallyEqual(LayoutUnit a, LayoutUnit b)
 49 {
 50     if (a == b)
 51         return true;
 52     // 1/4th CSS pixel.
 53     constexpr float epsilon = kFixedPointDenominator / 4;
 54     return abs(a.rawValue() - b.rawValue()) &lt;= epsilon;
 55 }
 56 
<span class="line-modified"> 57 static bool areEssentiallyEqual(float a, InlineLayoutUnit b)</span>
 58 {
<span class="line-modified"> 59     return areEssentiallyEqual(LayoutUnit { a }, LayoutUnit { b });</span>
 60 }
 61 
 62 static bool areEssentiallyEqual(LayoutRect a, LayoutRect b)
 63 {
 64     return areEssentiallyEqual(a.x(), b.x())
 65         &amp;&amp; areEssentiallyEqual(a.y(), b.y())
 66         &amp;&amp; areEssentiallyEqual(a.width(), b.width())
 67         &amp;&amp; areEssentiallyEqual(a.height(), b.height());
 68 }
 69 
 70 static bool outputMismatchingSimpleLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
 71 {
 72     auto* lineLayoutData = blockFlow.simpleLineLayout();
 73     if (!lineLayoutData) {
 74         ASSERT_NOT_REACHED();
 75         return true;
 76     }
 77 
 78     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
<span class="line-modified"> 79     auto* displayInlineContent = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).displayInlineContent();</span>
<span class="line-modified"> 80     if (!displayInlineContent) {</span>
<span class="line-added"> 81         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 82         return true;</span>
<span class="line-added"> 83     }</span>
 84 
<span class="line-modified"> 85     auto&amp; displayRuns = displayInlineContent-&gt;runs;</span>
<span class="line-modified"> 86 </span>
<span class="line-added"> 87     if (displayRuns.size() != lineLayoutData-&gt;runCount()) {</span>
<span class="line-added"> 88         stream &lt;&lt; &quot;Mismatching number of runs: simple runs(&quot; &lt;&lt; lineLayoutData-&gt;runCount() &lt;&lt; &quot;) inline runs(&quot; &lt;&lt; displayRuns.size() &lt;&lt; &quot;)&quot;;</span>
 89         stream.nextLine();
 90         return true;
 91     }
 92 
 93     auto mismatched = false;
 94     for (unsigned i = 0; i &lt; lineLayoutData-&gt;runCount(); ++i) {
 95         auto&amp; simpleRun = lineLayoutData-&gt;runAt(i);
<span class="line-modified"> 96         auto&amp; displayRun = displayRuns[i];</span>
 97 
<span class="line-modified"> 98         auto matchingRuns = areEssentiallyEqual(simpleRun.logicalLeft, displayRun.left()) &amp;&amp; areEssentiallyEqual(simpleRun.logicalRight, displayRun.right());</span>
<span class="line-modified"> 99         if (matchingRuns &amp;&amp; displayRun.textContext()) {</span>
<span class="line-modified">100             matchingRuns = simpleRun.start == displayRun.textContext()-&gt;start() &amp;&amp; simpleRun.end == displayRun.textContext()-&gt;end();</span>
101             // SLL handles strings in a more concatenated format &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; -&gt; foo -&gt; 0,3 bar -&gt; 3,6 vs. 0,3 and 0,3
102             if (!matchingRuns)
<span class="line-modified">103                 matchingRuns = (simpleRun.end - simpleRun.start) == (displayRun.textContext()-&gt;end() - displayRun.textContext()-&gt;start());</span>
104         }
105         if (matchingRuns)
106             continue;
107 
<span class="line-modified">108         stream &lt;&lt; &quot;Mismatching: simple run(&quot; &lt;&lt; simpleRun.start &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.end &lt;&lt; &quot;) (&quot; &lt;&lt; simpleRun.logicalLeft &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.logicalRight &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">109         stream &lt;&lt; &quot; inline run&quot;;</span>
<span class="line-added">110         if (displayRun.textContext())</span>
<span class="line-added">111             stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.textContext()-&gt;end() &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">112         stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.left() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.top() &lt;&lt; &quot;) (&quot; &lt;&lt; displayRun.width() &lt;&lt; &quot;x&quot; &lt;&lt; displayRun.height() &lt;&lt; &quot;)&quot;;</span>
113         stream.nextLine();
114         mismatched = true;
115     }
116     return mismatched;
117 }
118 
119 static bool checkForMatchingNonTextRuns(const Display::Run&amp; inlineRun, const WebCore::InlineBox&amp; inlineBox)
120 {
<span class="line-modified">121     return areEssentiallyEqual(inlineBox.left(), inlineRun.left())</span>
<span class="line-modified">122         &amp;&amp; areEssentiallyEqual(inlineBox.right(), inlineRun.right())</span>
<span class="line-modified">123         &amp;&amp; areEssentiallyEqual(inlineBox.top(), inlineRun.top())</span>
<span class="line-modified">124         &amp;&amp; areEssentiallyEqual(inlineBox.bottom(), inlineRun.bottom());</span>
125 }
126 
127 
128 static bool checkForMatchingTextRuns(const Display::Run&amp; inlineRun, const InlineTextBox&amp; inlineTextBox)
129 {
<span class="line-modified">130     return areEssentiallyEqual(inlineTextBox.left(), inlineRun.left())</span>
<span class="line-modified">131         &amp;&amp; areEssentiallyEqual(inlineTextBox.right(), inlineRun.right())</span>
<span class="line-modified">132         &amp;&amp; areEssentiallyEqual(inlineTextBox.top(), inlineRun.top())</span>
<span class="line-modified">133         &amp;&amp; areEssentiallyEqual(inlineTextBox.bottom(), inlineRun.bottom())</span>
<span class="line-modified">134         &amp;&amp; (inlineTextBox.isLineBreak() || (inlineTextBox.start() == inlineRun.textContext()-&gt;start() &amp;&amp; inlineTextBox.end() == inlineRun.textContext()-&gt;end()));</span>

135 }
136 
137 static void collectFlowBoxSubtree(const InlineFlowBox&amp; flowbox, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
138 {
<span class="line-modified">139     auto* inlineBox = flowbox.firstLeafDescendant();</span>
<span class="line-modified">140     auto* lastLeafDescendant = flowbox.lastLeafDescendant();</span>
141     while (inlineBox) {
142         inlineBoxes.append(inlineBox);
<span class="line-modified">143         if (inlineBox == lastLeafDescendant)</span>
144             break;
<span class="line-modified">145         inlineBox = inlineBox-&gt;nextLeafOnLine();</span>
146     }
147 }
148 
149 static void collectInlineBoxes(const RenderBlockFlow&amp; root, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
150 {
151     for (auto* rootLine = root.firstRootBox(); rootLine; rootLine = rootLine-&gt;nextRootBox()) {
152         for (auto* inlineBox = rootLine-&gt;firstChild(); inlineBox; inlineBox = inlineBox-&gt;nextOnLine()) {
153             if (!is&lt;InlineFlowBox&gt;(inlineBox)) {
154                 inlineBoxes.append(inlineBox);
155                 continue;
156             }
157             collectFlowBoxSubtree(downcast&lt;InlineFlowBox&gt;(*inlineBox), inlineBoxes);
158         }
159     }
160 }
161 
162 static bool outputMismatchingComplexLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
163 {
164     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
<span class="line-modified">165 </span>
<span class="line-modified">166     auto* displayInlineContent = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).displayInlineContent();</span>
<span class="line-added">167     if (!displayInlineContent) {</span>
<span class="line-added">168         ASSERT_NOT_REACHED();</span>
<span class="line-added">169         return true;</span>
<span class="line-added">170     }</span>
<span class="line-added">171     auto&amp; displayRuns = displayInlineContent-&gt;runs;</span>
172 
173     // Collect inlineboxes.
174     Vector&lt;WebCore::InlineBox*&gt; inlineBoxes;
175     collectInlineBoxes(blockFlow, inlineBoxes);
176 
177     auto mismatched = false;
178     unsigned runIndex = 0;
179 
<span class="line-modified">180     if (inlineBoxes.size() != displayRuns.size()) {</span>
<span class="line-modified">181         stream &lt;&lt; &quot;Warning: mismatching number of runs: inlineboxes(&quot; &lt;&lt; inlineBoxes.size() &lt;&lt; &quot;) vs. inline runs(&quot; &lt;&lt; displayRuns.size() &lt;&lt; &quot;)&quot;;</span>
182         stream.nextLine();
183     }
184 
<span class="line-modified">185     for (unsigned inlineBoxIndex = 0; inlineBoxIndex &lt; inlineBoxes.size() &amp;&amp; runIndex &lt; displayRuns.size(); ++inlineBoxIndex) {</span>
<span class="line-modified">186         auto&amp; displayRun = displayRuns[runIndex];</span>
187         auto* inlineBox = inlineBoxes[inlineBoxIndex];
188         auto* inlineTextBox = is&lt;InlineTextBox&gt;(inlineBox) ? downcast&lt;InlineTextBox&gt;(inlineBox) : nullptr;
<span class="line-modified">189         bool matchingRuns = inlineTextBox ? checkForMatchingTextRuns(displayRun, *inlineTextBox) : matchingRuns = checkForMatchingNonTextRuns(displayRun, *inlineBox);</span>
190 
191         if (!matchingRuns) {
192 
193             if (is&lt;RenderLineBreak&gt;(inlineBox-&gt;renderer())) {
194                 // &lt;br&gt; positioning is weird at this point. It needs proper baseline.
195                 matchingRuns = true;
196                 ++runIndex;
197                 continue;
198             }
199 
200             stream &lt;&lt; &quot;Mismatching: run&quot;;
201 
202             if (inlineTextBox)
<span class="line-modified">203                 stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineTextBox-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineTextBox-&gt;end() &lt;&lt; &quot;)&quot;;</span>
204             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineBox-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineBox-&gt;logicalTop() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineBox-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineBox-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;
205 
206             stream &lt;&lt; &quot; inline run&quot;;
<span class="line-modified">207             if (displayRun.textContext())</span>
<span class="line-modified">208                 stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.textContext()-&gt;end() &lt;&lt; &quot;)&quot;;</span>
<span class="line-modified">209             stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.left() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.top() &lt;&lt; &quot;) (&quot; &lt;&lt; displayRun.width() &lt;&lt; &quot;x&quot; &lt;&lt; displayRun.height() &lt;&lt; &quot;)&quot;;</span>
210             stream.nextLine();
211             mismatched = true;
212         }
213         ++runIndex;
214     }
215     return mismatched;
216 }
217 
218 static bool outputMismatchingBlockBoxInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
219 {
220     bool firstMismatchingRect = true;
221     auto outputRect = [&amp;] (const String&amp; prefix, const LayoutRect&amp; rendererRect, const LayoutRect&amp; layoutRect) {
222         if (firstMismatchingRect) {
223             stream &lt;&lt; (renderer.element() ? renderer.element()-&gt;nodeName().utf8().data() : &quot;&quot;) &lt;&lt; &quot; &quot; &lt;&lt; renderer.renderName() &lt;&lt; &quot;(&quot; &lt;&lt; &amp;renderer &lt;&lt; &quot;) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;;
224             stream.nextLine();
225             firstMismatchingRect = false;
226         }
227 
228         stream  &lt;&lt; prefix.utf8().data() &lt;&lt; &quot;\trenderer-&gt;(&quot; &lt;&lt; rendererRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; rendererRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; rendererRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; rendererRect.height() &lt;&lt; &quot;)&quot;
229             &lt;&lt; &quot;\tlayout-&gt;(&quot; &lt;&lt; layoutRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; layoutRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; layoutRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; layoutRect.height() &lt;&lt; &quot;)&quot;;
</pre>
<hr />
<pre>
271 
272     if (!areEssentiallyEqual(renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox))) {
273         // In certain cases, like out-of-flow boxes with margin auto, marginBoxRect() returns 0. It&#39;s clearly incorrect,
274         // so let&#39;s check the individual margin values instead (and at this point we know that all other boxes match).
275         auto marginsMatch = displayBox.marginBefore() == renderer.marginBefore()
276             &amp;&amp; displayBox.marginAfter() == renderer.marginAfter()
277             &amp;&amp; displayBox.marginStart() == renderer.marginStart()
278             &amp;&amp; displayBox.marginEnd() == renderer.marginEnd();
279 
280         if (!marginsMatch) {
281             outputRect(&quot;marginBox&quot;, renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox));
282             return true;
283         }
284     }
285 
286     return false;
287 }
288 
289 static bool verifyAndOutputSubtree(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
290 {
<span class="line-added">291     // Rendering code does not have the concept of table wrapper box. Skip it by verifying the first child(table box) instead.</span>
<span class="line-added">292     if (layoutBox.isTableWrapperBox())</span>
<span class="line-added">293         return verifyAndOutputSubtree(stream, context, renderer, *downcast&lt;Container&gt;(layoutBox).firstChild());</span>
<span class="line-added">294 </span>
295     auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, renderer, layoutBox);
296 
297     if (!is&lt;Container&gt;(layoutBox))
298         return mismtachingGeometry;
299 
300     auto&amp; container = downcast&lt;Container&gt;(layoutBox);
301     auto* childLayoutBox = container.firstChild();
302     auto* childRenderer = renderer.firstChild();
303 
304     while (childRenderer) {
305         if (!is&lt;RenderBox&gt;(*childRenderer)) {
306             childRenderer = childRenderer-&gt;nextSibling();
307             continue;
308         }
309 
310         if (!childLayoutBox) {
311             stream  &lt;&lt; &quot;Trees are out of sync!&quot;;
312             stream.nextLine();
313             return true;
314         }
</pre>
<hr />
<pre>
317             ASSERT(childRenderer-&gt;childrenInline());
318             auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
319             if (mismtachingGeometry)
320                 return true;
321 
322             auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*childRenderer);
323             auto&amp; formattingRoot = downcast&lt;Container&gt;(*childLayoutBox);
324             mismtachingGeometry |= blockFlow.lineLayoutPath() == RenderBlockFlow::SimpleLinesPath ? outputMismatchingSimpleLineInformationIfNeeded(stream, context, blockFlow, formattingRoot) : outputMismatchingComplexLineInformationIfNeeded(stream, context, blockFlow, formattingRoot);
325         } else {
326             auto mismatchingSubtreeGeometry = verifyAndOutputSubtree(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
327             mismtachingGeometry |= mismatchingSubtreeGeometry;
328         }
329 
330         childLayoutBox = childLayoutBox-&gt;nextSibling();
331         childRenderer = childRenderer-&gt;nextSibling();
332     }
333 
334     return mismtachingGeometry;
335 }
336 
<span class="line-modified">337 void LayoutContext::verifyAndOutputMismatchingLayoutTree(const LayoutState&amp; layoutState, const RenderView&amp; rootRenderer)</span>
338 {
339     TextStream stream;
<span class="line-modified">340     auto&amp; layoutRoot = layoutState.root();</span>
<span class="line-added">341     auto mismatchingGeometry = verifyAndOutputSubtree(stream, layoutState, rootRenderer, layoutRoot);</span>
342     if (!mismatchingGeometry)
343         return;
344 #if ENABLE(TREE_DEBUGGING)
<span class="line-modified">345     showRenderTree(&amp;rootRenderer);</span>
<span class="line-modified">346     showLayoutTree(layoutRoot, &amp;layoutState);</span>
347 #endif
348     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
349     ASSERT_NOT_REACHED();
350 }
351 
352 }
353 }
354 
355 #endif
<span class="line-added">356 </span>
<span class="line-added">357 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="MarginTypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="blockformatting/BlockFormattingContext.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
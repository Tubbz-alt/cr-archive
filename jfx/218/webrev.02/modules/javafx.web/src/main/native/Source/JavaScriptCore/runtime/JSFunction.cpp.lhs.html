<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
  6  *  Copyright (C) 2007 Maks Orlovich
  7  *  Copyright (C) 2015 Canon Inc. All rights reserved.
  8  *
  9  *  This library is free software; you can redistribute it and/or
 10  *  modify it under the terms of the GNU Library General Public
 11  *  License as published by the Free Software Foundation; either
 12  *  version 2 of the License, or (at your option) any later version.
 13  *
 14  *  This library is distributed in the hope that it will be useful,
 15  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 16  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17  *  Library General Public License for more details.
 18  *
 19  *  You should have received a copy of the GNU Library General Public License
 20  *  along with this library; see the file COPYING.LIB.  If not, write to
 21  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22  *  Boston, MA 02110-1301, USA.
 23  *
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSFunction.h&quot;
 28 
 29 #include &quot;AsyncGeneratorPrototype.h&quot;
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;CatchScope.h&quot;
 32 #include &quot;ClonedArguments.h&quot;
 33 #include &quot;CodeBlock.h&quot;
 34 #include &quot;CommonIdentifiers.h&quot;
 35 #include &quot;CallFrame.h&quot;
 36 #include &quot;ExceptionHelpers.h&quot;
 37 #include &quot;FunctionPrototype.h&quot;
 38 #include &quot;GeneratorPrototype.h&quot;
 39 #include &quot;GetterSetter.h&quot;
 40 #include &quot;JSArray.h&quot;
 41 #include &quot;JSBoundFunction.h&quot;
 42 #include &quot;JSCInlines.h&quot;
 43 #include &quot;JSFunctionInlines.h&quot;
 44 #include &quot;JSGlobalObject.h&quot;
 45 #include &quot;Interpreter.h&quot;
 46 #include &quot;ObjectConstructor.h&quot;
 47 #include &quot;ObjectPrototype.h&quot;
 48 #include &quot;Parser.h&quot;
 49 #include &quot;PropertyNameArray.h&quot;
 50 #include &quot;StackVisitor.h&quot;
 51 #include &quot;WebAssemblyFunction.h&quot;
 52 
 53 namespace JSC {
 54 
<a name="1" id="anc1"></a><span class="line-modified"> 55 EncodedJSValue JSC_HOST_CALL callHostFunctionAsConstructor(ExecState* exec)</span>
 56 {
<a name="2" id="anc2"></a><span class="line-modified"> 57     VM&amp; vm = exec-&gt;vm();</span>
 58     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="3" id="anc3"></a><span class="line-modified"> 59     return throwVMError(exec, scope, createNotAConstructorError(exec, exec-&gt;jsCallee()));</span>
 60 }
 61 
 62 const ClassInfo JSFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSFunction) };
 63 const ClassInfo JSStrictFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSStrictFunction) };
 64 const ClassInfo JSSloppyFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSSloppyFunction) };
 65 const ClassInfo JSArrowFunction::s_info = { &quot;Function&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrowFunction) };
 66 
 67 bool JSFunction::isHostFunctionNonInline() const
 68 {
 69     return isHostFunction();
 70 }
 71 
 72 Structure* JSFunction::selectStructureForNewFuncExp(JSGlobalObject* globalObject, FunctionExecutable* executable)
 73 {
 74     ASSERT(!executable-&gt;isHostFunction());
 75     bool isBuiltin = executable-&gt;isBuiltinFunction();
 76     if (executable-&gt;isArrowFunction())
 77         return globalObject-&gt;arrowFunctionStructure(isBuiltin);
 78     if (executable-&gt;isStrictMode())
 79         return globalObject-&gt;strictFunctionStructure(isBuiltin);
 80     return globalObject-&gt;sloppyFunctionStructure(isBuiltin);
 81 }
 82 
 83 JSFunction* JSFunction::create(VM&amp; vm, FunctionExecutable* executable, JSScope* scope)
 84 {
 85     return create(vm, executable, scope, selectStructureForNewFuncExp(scope-&gt;globalObject(vm), executable));
 86 }
 87 
 88 JSFunction* JSFunction::create(VM&amp; vm, FunctionExecutable* executable, JSScope* scope, Structure* structure)
 89 {
 90     JSFunction* result = createImpl(vm, executable, scope, structure);
 91     executable-&gt;notifyCreation(vm, result, &quot;Allocating a function&quot;);
 92     return result;
 93 }
 94 
 95 JSFunction* JSFunction::create(VM&amp; vm, JSGlobalObject* globalObject, int length, const String&amp; name, NativeFunction nativeFunction, Intrinsic intrinsic, NativeFunction nativeConstructor, const DOMJIT::Signature* signature)
 96 {
 97     NativeExecutable* executable = vm.getHostFunction(nativeFunction, intrinsic, nativeConstructor, signature, name);
 98     Structure* structure = globalObject-&gt;hostFunctionStructure();
<a name="4" id="anc4"></a><span class="line-modified"> 99     JSFunction* function = new (NotNull, allocateCell&lt;JSFunction&gt;(vm.heap)) JSFunction(vm, globalObject, structure);</span>
100     // Can&#39;t do this during initialization because getHostFunction might do a GC allocation.
101     function-&gt;finishCreation(vm, executable, length, name);
102     return function;
103 }
104 
105 JSFunction* JSFunction::createFunctionThatMasqueradesAsUndefined(VM&amp; vm, JSGlobalObject* globalObject, int length, const String&amp; name, NativeFunction nativeFunction, Intrinsic intrinsic, NativeFunction nativeConstructor, const DOMJIT::Signature* signature)
106 {
107     NativeExecutable* executable = vm.getHostFunction(nativeFunction, intrinsic, nativeConstructor, signature, name);
108     Structure* structure = Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(JSFunctionType, JSFunction::StructureFlags | MasqueradesAsUndefined), JSFunction::info());
109     globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), &quot;Allocated masquerading object&quot;);
<a name="5" id="anc5"></a><span class="line-modified">110     JSFunction* function = new (NotNull, allocateCell&lt;JSFunction&gt;(vm.heap)) JSFunction(vm, globalObject, structure);</span>
111     function-&gt;finishCreation(vm, executable, length, name);
112     return function;
113 }
114 
<a name="6" id="anc6"></a><span class="line-modified">115 JSFunction::JSFunction(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)</span>
116     : Base(vm, globalObject, structure)
<a name="7" id="anc7"></a><span class="line-modified">117     , m_executable()</span>
118 {
119     assertTypeInfoFlagInvariants();
<a name="8" id="anc8"></a>
120 }
121 
122 
123 void JSFunction::finishCreation(VM&amp; vm)
124 {
125     Base::finishCreation(vm);
126     ASSERT(jsDynamicCast&lt;JSFunction*&gt;(vm, this));
127     ASSERT(type() == JSFunctionType);
<a name="9" id="anc9"></a><span class="line-modified">128     if (isAnonymousBuiltinFunction()) {</span>
<span class="line-modified">129         // This is anonymous builtin function.</span>
<span class="line-removed">130         rareData(vm)-&gt;setHasReifiedName();</span>
<span class="line-removed">131     }</span>
132 }
133 
<a name="10" id="anc10"></a><span class="line-modified">134 void JSFunction::finishCreation(VM&amp; vm, NativeExecutable* executable, int length, const String&amp; name)</span>
135 {
136     Base::finishCreation(vm);
137     ASSERT(inherits(vm, info()));
138     ASSERT(type() == JSFunctionType);
<a name="11" id="anc11"></a><span class="line-modified">139     m_executable.set(vm, this, executable);</span>
<span class="line-modified">140     // Some NativeExecutable functions, like JSBoundFunction, decide to lazily allocate their name string.</span>





141     if (!name.isNull())
142         putDirect(vm, vm.propertyNames-&gt;name, jsString(vm, name), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
143     putDirect(vm, vm.propertyNames-&gt;length, jsNumber(length), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
144 }
145 
146 FunctionRareData* JSFunction::allocateRareData(VM&amp; vm)
147 {
<a name="12" id="anc12"></a><span class="line-modified">148     ASSERT(!m_rareData);</span>
<span class="line-modified">149     FunctionRareData* rareData = FunctionRareData::create(vm);</span>


150 
151     // A DFG compilation thread may be trying to read the rare data
152     // We want to ensure that it sees it properly allocated
153     WTF::storeStoreFence();
154 
<a name="13" id="anc13"></a><span class="line-modified">155     m_rareData.set(vm, this, rareData);</span>
<span class="line-modified">156     return m_rareData.get();</span>


157 }
158 
<a name="14" id="anc14"></a><span class="line-modified">159 JSObject* JSFunction::prototypeForConstruction(VM&amp; vm, ExecState* exec)</span>
160 {
161     // This code assumes getting the prototype is not effectful. That&#39;s only
162     // true when we can use the allocation profile.
163     ASSERT(canUseAllocationProfile());
164     auto scope = DECLARE_CATCH_SCOPE(vm);
<a name="15" id="anc15"></a><span class="line-modified">165     JSValue prototype = get(exec, vm.propertyNames-&gt;prototype);</span>
166     scope.releaseAssertNoException();
167     if (LIKELY(prototype.isObject()))
168         return asObject(prototype);
169 
<a name="16" id="anc16"></a><span class="line-modified">170     JSGlobalObject* globalObject = this-&gt;globalObject(vm);</span>
171     if (!isHostOrBuiltinFunction()) {
172         // https://tc39.github.io/ecma262/#sec-generator-function-definitions-runtime-semantics-evaluatebody
173         if (isGeneratorWrapperParseMode(jsExecutable()-&gt;parseMode()))
<a name="17" id="anc17"></a><span class="line-modified">174             return globalObject-&gt;generatorPrototype();</span>
175 
176         // https://tc39.github.io/ecma262/#sec-asyncgenerator-definitions-evaluatebody
177         if (isAsyncGeneratorWrapperParseMode(jsExecutable()-&gt;parseMode()))
<a name="18" id="anc18"></a><span class="line-modified">178             return globalObject-&gt;asyncGeneratorPrototype();</span>
179     }
<a name="19" id="anc19"></a><span class="line-modified">180     return globalObject-&gt;objectPrototype();</span>
181 }
182 
<a name="20" id="anc20"></a><span class="line-modified">183 FunctionRareData* JSFunction::allocateAndInitializeRareData(ExecState* exec, size_t inlineCapacity)</span>
184 {
<a name="21" id="anc21"></a><span class="line-modified">185     ASSERT(!m_rareData);</span>

186     ASSERT(canUseAllocationProfile());
<a name="22" id="anc22"></a><span class="line-modified">187     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">188     JSObject* prototype = prototypeForConstruction(vm, exec);</span>
<span class="line-modified">189     FunctionRareData* rareData = FunctionRareData::create(vm);</span>
<span class="line-modified">190     rareData-&gt;initializeObjectAllocationProfile(vm, globalObject(vm), prototype, inlineCapacity, this);</span>

191 
192     // A DFG compilation thread may be trying to read the rare data
193     // We want to ensure that it sees it properly allocated
194     WTF::storeStoreFence();
195 
<a name="23" id="anc23"></a><span class="line-modified">196     m_rareData.set(vm, this, rareData);</span>
<span class="line-modified">197     return m_rareData.get();</span>


198 }
199 
<a name="24" id="anc24"></a><span class="line-modified">200 FunctionRareData* JSFunction::initializeRareData(ExecState* exec, size_t inlineCapacity)</span>
201 {
<a name="25" id="anc25"></a><span class="line-modified">202     ASSERT(!!m_rareData);</span>

203     ASSERT(canUseAllocationProfile());
<a name="26" id="anc26"></a><span class="line-modified">204     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">205     JSObject* prototype = prototypeForConstruction(vm, exec);</span>
<span class="line-modified">206     m_rareData-&gt;initializeObjectAllocationProfile(vm, globalObject(vm), prototype, inlineCapacity, this);</span>
<span class="line-modified">207     return m_rareData.get();</span>

208 }
209 
210 String JSFunction::name(VM&amp; vm)
211 {
212     if (isHostFunction()) {
<a name="27" id="anc27"></a>

213         NativeExecutable* executable = jsCast&lt;NativeExecutable*&gt;(this-&gt;executable());
214         return executable-&gt;name();
215     }
216     const Identifier identifier = jsExecutable()-&gt;name();
217     if (identifier == vm.propertyNames-&gt;builtinNames().starDefaultPrivateName())
218         return emptyString();
219     return identifier.string();
220 }
221 
222 String JSFunction::displayName(VM&amp; vm)
223 {
224     JSValue displayName = getDirect(vm, vm.propertyNames-&gt;displayName);
225 
226     if (displayName &amp;&amp; isJSString(displayName))
227         return asString(displayName)-&gt;tryGetValue();
228 
229     return String();
230 }
231 
232 const String JSFunction::calculatedDisplayName(VM&amp; vm)
233 {
234     const String explicitName = displayName(vm);
235 
236     if (!explicitName.isEmpty())
237         return explicitName;
238 
239     const String actualName = name(vm);
240     if (!actualName.isEmpty() || isHostOrBuiltinFunction())
241         return actualName;
242 
243     return jsExecutable()-&gt;ecmaName().string();
244 }
245 
246 const SourceCode* JSFunction::sourceCode() const
247 {
248     if (isHostOrBuiltinFunction())
249         return 0;
250     return &amp;jsExecutable()-&gt;source();
251 }
252 
253 void JSFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
254 {
255     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
256     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
257     Base::visitChildren(thisObject, visitor);
258 
<a name="28" id="anc28"></a><span class="line-modified">259     visitor.append(thisObject-&gt;m_executable);</span>
<span class="line-removed">260     visitor.append(thisObject-&gt;m_rareData);</span>
261 }
262 
263 CallType JSFunction::getCallData(JSCell* cell, CallData&amp; callData)
264 {
265     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
266     if (thisObject-&gt;isHostFunction()) {
267         callData.native.function = thisObject-&gt;nativeFunction();
268         return CallType::Host;
269     }
270     callData.js.functionExecutable = thisObject-&gt;jsExecutable();
271     callData.js.scope = thisObject-&gt;scope();
272     return CallType::JS;
273 }
274 
275 class RetrieveArgumentsFunctor {
276 public:
<a name="29" id="anc29"></a><span class="line-modified">277     RetrieveArgumentsFunctor(JSFunction* functionObj)</span>
<span class="line-modified">278         : m_targetCallee(functionObj)</span>

279         , m_result(jsNull())
280     {
281     }
282 
283     JSValue result() const { return m_result; }
284 
285     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
286     {
287         if (!visitor-&gt;callee().isCell())
288             return StackVisitor::Continue;
289 
290         JSCell* callee = visitor-&gt;callee().asCell();
291         if (callee != m_targetCallee)
292             return StackVisitor::Continue;
293 
<a name="30" id="anc30"></a><span class="line-modified">294         m_result = JSValue(visitor-&gt;createArguments());</span>
295         return StackVisitor::Done;
296     }
297 
298 private:
<a name="31" id="anc31"></a>
299     JSObject* m_targetCallee;
300     mutable JSValue m_result;
301 };
302 
<a name="32" id="anc32"></a><span class="line-modified">303 static JSValue retrieveArguments(ExecState* exec, JSFunction* functionObj)</span>
304 {
<a name="33" id="anc33"></a><span class="line-modified">305     RetrieveArgumentsFunctor functor(functionObj);</span>
<span class="line-modified">306     exec-&gt;iterate(functor);</span>

307     return functor.result();
308 }
309 
<a name="34" id="anc34"></a><span class="line-modified">310 EncodedJSValue JSFunction::argumentsGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
311 {
<a name="35" id="anc35"></a>
312     JSFunction* thisObj = jsCast&lt;JSFunction*&gt;(JSValue::decode(thisValue));
313     ASSERT(!thisObj-&gt;isHostFunction());
314 
<a name="36" id="anc36"></a><span class="line-modified">315     return JSValue::encode(retrieveArguments(exec, thisObj));</span>
316 }
317 
318 class RetrieveCallerFunctionFunctor {
319 public:
320     RetrieveCallerFunctionFunctor(JSFunction* functionObj)
321         : m_targetCallee(functionObj)
322         , m_hasFoundFrame(false)
323         , m_hasSkippedToCallerFrame(false)
324         , m_result(jsNull())
325     {
326     }
327 
328     JSValue result() const { return m_result; }
329 
330     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
331     {
332         if (!visitor-&gt;callee().isCell())
333             return StackVisitor::Continue;
334 
335         JSCell* callee = visitor-&gt;callee().asCell();
336 
337         if (callee &amp;&amp; callee-&gt;inherits&lt;JSBoundFunction&gt;(callee-&gt;vm()))
338             return StackVisitor::Continue;
339 
340         if (!m_hasFoundFrame &amp;&amp; (callee != m_targetCallee))
341             return StackVisitor::Continue;
342 
343         m_hasFoundFrame = true;
344         if (!m_hasSkippedToCallerFrame) {
345             m_hasSkippedToCallerFrame = true;
346             return StackVisitor::Continue;
347         }
348 
349         if (callee)
350             m_result = callee;
351         return StackVisitor::Done;
352     }
353 
354 private:
355     JSObject* m_targetCallee;
356     mutable bool m_hasFoundFrame;
357     mutable bool m_hasSkippedToCallerFrame;
358     mutable JSValue m_result;
359 };
360 
<a name="37" id="anc37"></a><span class="line-modified">361 static JSValue retrieveCallerFunction(ExecState* exec, JSFunction* functionObj)</span>
362 {
363     RetrieveCallerFunctionFunctor functor(functionObj);
<a name="38" id="anc38"></a><span class="line-modified">364     exec-&gt;iterate(functor);</span>

365     return functor.result();
366 }
367 
<a name="39" id="anc39"></a><span class="line-modified">368 EncodedJSValue JSFunction::callerGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
369 {
<a name="40" id="anc40"></a><span class="line-modified">370     VM&amp; vm = exec-&gt;vm();</span>
371     auto scope = DECLARE_THROW_SCOPE(vm);
372 
373     JSFunction* thisObj = jsCast&lt;JSFunction*&gt;(JSValue::decode(thisValue));
374     ASSERT(!thisObj-&gt;isHostFunction());
<a name="41" id="anc41"></a><span class="line-modified">375     JSValue caller = retrieveCallerFunction(exec, thisObj);</span>
376 
377     // See ES5.1 15.3.5.4 - Function.caller may not be used to retrieve a strict caller.
378     if (!caller.isObject() || !asObject(caller)-&gt;inherits&lt;JSFunction&gt;(vm)) {
379         // It isn&#39;t a JSFunction, but if it is a JSCallee from a program or eval call or an internal constructor, return null.
380         if (jsDynamicCast&lt;JSCallee*&gt;(vm, caller) || jsDynamicCast&lt;InternalFunction*&gt;(vm, caller))
381             return JSValue::encode(jsNull());
382         return JSValue::encode(caller);
383     }
384     JSFunction* function = jsCast&lt;JSFunction*&gt;(caller);
385 
386     // Firefox returns null for native code callers, so we match that behavior.
387     if (function-&gt;isHostOrBuiltinFunction())
388         return JSValue::encode(jsNull());
389     SourceParseMode parseMode = function-&gt;jsExecutable()-&gt;parseMode();
390     switch (parseMode) {
391     case SourceParseMode::GeneratorBodyMode:
392     case SourceParseMode::AsyncGeneratorBodyMode:
<a name="42" id="anc42"></a><span class="line-modified">393         return JSValue::encode(throwTypeError(exec, scope, &quot;Function.caller used to retrieve generator body&quot;_s));</span>
394     case SourceParseMode::AsyncFunctionBodyMode:
395     case SourceParseMode::AsyncArrowFunctionBodyMode:
<a name="43" id="anc43"></a><span class="line-modified">396         return JSValue::encode(throwTypeError(exec, scope, &quot;Function.caller used to retrieve async function body&quot;_s));</span>
397     case SourceParseMode::NormalFunctionMode:
398     case SourceParseMode::GeneratorWrapperFunctionMode:
399     case SourceParseMode::GetterMode:
400     case SourceParseMode::SetterMode:
401     case SourceParseMode::MethodMode:
402     case SourceParseMode::ArrowFunctionMode:
403     case SourceParseMode::AsyncFunctionMode:
404     case SourceParseMode::AsyncMethodMode:
405     case SourceParseMode::AsyncArrowFunctionMode:
406     case SourceParseMode::ProgramMode:
407     case SourceParseMode::ModuleAnalyzeMode:
408     case SourceParseMode::ModuleEvaluateMode:
409     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
410     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
411     case SourceParseMode::GeneratorWrapperMethodMode:
<a name="44" id="anc44"></a>
412         if (!function-&gt;jsExecutable()-&gt;isStrictMode())
413             return JSValue::encode(caller);
<a name="45" id="anc45"></a><span class="line-modified">414         return JSValue::encode(throwTypeError(exec, scope, &quot;Function.caller used to retrieve strict caller&quot;_s));</span>
415     }
416     RELEASE_ASSERT_NOT_REACHED();
417 }
418 
<a name="46" id="anc46"></a><span class="line-modified">419 bool JSFunction::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
420 {
<a name="47" id="anc47"></a><span class="line-modified">421     VM&amp; vm = exec-&gt;vm();</span>


422     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
423     if (thisObject-&gt;isHostOrBuiltinFunction()) {
<a name="48" id="anc48"></a><span class="line-modified">424         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">425         return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>

426     }
427 
428     if (propertyName == vm.propertyNames-&gt;prototype &amp;&amp; thisObject-&gt;jsExecutable()-&gt;hasPrototypeProperty() &amp;&amp; !thisObject-&gt;jsExecutable()-&gt;isClassConstructorFunction()) {
429         // NOTE: class constructors define the prototype property in bytecode using
430         // defineOwnProperty, which ends up calling into this code (see our defineOwnProperty
431         // implementation below). The bytecode will end up doing the proper definition
432         // with the property being non-writable/non-configurable. However, we must ignore
433         // the initial materialization of the property so that the defineOwnProperty call
434         // from bytecode succeeds. Otherwise, the materialization here would prevent the
435         // defineOwnProperty from being able to overwrite the property.
436         unsigned attributes;
437         PropertyOffset offset = thisObject-&gt;getDirectOffset(vm, propertyName, attributes);
438         if (!isValidOffset(offset)) {
439             JSObject* prototype = nullptr;
440             if (isGeneratorWrapperParseMode(thisObject-&gt;jsExecutable()-&gt;parseMode())) {
441                 // Unlike function instances, the object that is the value of the a GeneratorFunction&#39;s prototype
442                 // property does not have a constructor property whose value is the GeneratorFunction instance.
443                 // https://tc39.github.io/ecma262/#sec-generatorfunction-instances-prototype
<a name="49" id="anc49"></a><span class="line-modified">444                 prototype = constructEmptyObject(exec, thisObject-&gt;globalObject(vm)-&gt;generatorPrototype());</span>
445             } else if (isAsyncGeneratorWrapperParseMode(thisObject-&gt;jsExecutable()-&gt;parseMode()))
<a name="50" id="anc50"></a><span class="line-modified">446                 prototype = constructEmptyObject(exec, thisObject-&gt;globalObject(vm)-&gt;asyncGeneratorPrototype());</span>
447             else {
<a name="51" id="anc51"></a><span class="line-modified">448                 prototype = constructEmptyObject(exec);</span>
449                 prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
450             }
451 
452             thisObject-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, prototype, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum);
453             offset = thisObject-&gt;getDirectOffset(vm, vm.propertyNames-&gt;prototype, attributes);
454             ASSERT(isValidOffset(offset));
455         }
456         slot.setValue(thisObject, attributes, thisObject-&gt;getDirect(offset), offset);
457     }
458 
459     if (propertyName == vm.propertyNames-&gt;arguments) {
460         if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<a name="52" id="anc52"></a><span class="line-modified">461             return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
462 
463         slot.setCacheableCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete, argumentsGetter);
464         return true;
465 
466     } else if (propertyName == vm.propertyNames-&gt;caller) {
467         if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<a name="53" id="anc53"></a><span class="line-modified">468             return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
469 
470         slot.setCacheableCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete, callerGetter);
471         return true;
472     }
473 
<a name="54" id="anc54"></a><span class="line-modified">474     thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>

475 
<a name="55" id="anc55"></a><span class="line-modified">476     return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
477 }
478 
<a name="56" id="anc56"></a><span class="line-modified">479 void JSFunction::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
480 {
481     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
<a name="57" id="anc57"></a><span class="line-modified">482     VM&amp; vm = exec-&gt;vm();</span>


483     if (mode.includeDontEnumProperties()) {
484         if (!thisObject-&gt;isHostOrBuiltinFunction()) {
485             // Make sure prototype has been reified.
486             PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<a name="58" id="anc58"></a><span class="line-modified">487             thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, vm.propertyNames-&gt;prototype, slot);</span>

488 
489             if (thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties()) {
490                 propertyNames.add(vm.propertyNames-&gt;arguments);
491                 propertyNames.add(vm.propertyNames-&gt;caller);
492             }
493             if (!thisObject-&gt;hasReifiedLength())
494                 propertyNames.add(vm.propertyNames-&gt;length);
495             if (!thisObject-&gt;hasReifiedName())
496                 propertyNames.add(vm.propertyNames-&gt;name);
497         } else {
<a name="59" id="anc59"></a><span class="line-modified">498             if (thisObject-&gt;isBuiltinFunction() &amp;&amp; !thisObject-&gt;hasReifiedLength())</span>
<span class="line-modified">499                 propertyNames.add(vm.propertyNames-&gt;length);</span>
<span class="line-modified">500             if ((thisObject-&gt;isBuiltinFunction() || thisObject-&gt;inherits&lt;JSBoundFunction&gt;(vm)) &amp;&amp; !thisObject-&gt;hasReifiedName())</span>
<span class="line-modified">501                 propertyNames.add(vm.propertyNames-&gt;name);</span>


502         }
503     }
<a name="60" id="anc60"></a><span class="line-modified">504     Base::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);</span>
505 }
506 
<a name="61" id="anc61"></a><span class="line-modified">507 bool JSFunction::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
508 {
<a name="62" id="anc62"></a><span class="line-modified">509     VM&amp; vm = exec-&gt;vm();</span>
510     auto scope = DECLARE_THROW_SCOPE(vm);
511 
512     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
513 
<a name="63" id="anc63"></a>







514     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<a name="64" id="anc64"></a><span class="line-modified">515         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
516 
517 
518     if (thisObject-&gt;isHostOrBuiltinFunction()) {
<a name="65" id="anc65"></a><span class="line-modified">519         PropertyStatus propertyType = thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>

520         if (isLazy(propertyType))
521             slot.disableCaching();
<a name="66" id="anc66"></a><span class="line-modified">522         RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
523     }
524 
525     if (propertyName == vm.propertyNames-&gt;prototype) {
526         slot.disableCaching();
527         // Make sure prototype has been reified, such that it can only be overwritten
528         // following the rules set out in ECMA-262 8.12.9.
529         PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<a name="67" id="anc67"></a><span class="line-modified">530         thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, propertyName, getSlot);</span>
<span class="line-modified">531         if (thisObject-&gt;m_rareData)</span>
<span class="line-modified">532             thisObject-&gt;m_rareData-&gt;clear(&quot;Store to prototype property of a function&quot;);</span>
<span class="line-modified">533         RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>

534     }
535 
536     if (propertyName == vm.propertyNames-&gt;arguments || propertyName == vm.propertyNames-&gt;caller) {
537         if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<a name="68" id="anc68"></a><span class="line-modified">538             RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
539 
540         slot.disableCaching();
<a name="69" id="anc69"></a><span class="line-modified">541         return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);</span>
542     }
<a name="70" id="anc70"></a><span class="line-modified">543     PropertyStatus propertyType = thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
544     if (isLazy(propertyType))
545         slot.disableCaching();
<a name="71" id="anc71"></a><span class="line-modified">546     RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
547 }
548 
<a name="72" id="anc72"></a><span class="line-modified">549 bool JSFunction::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
550 {
<a name="73" id="anc73"></a><span class="line-modified">551     VM&amp; vm = exec-&gt;vm();</span>

552     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
<a name="74" id="anc74"></a><span class="line-modified">553     if (thisObject-&gt;isHostOrBuiltinFunction())</span>
<span class="line-modified">554         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">555     else if (vm.deletePropertyMode() != VM::DeletePropertyMode::IgnoreConfigurable) {</span>










556         // For non-host functions, don&#39;t let these properties by deleted - except by DefineOwnProperty.
557         FunctionExecutable* executable = thisObject-&gt;jsExecutable();
558 
559         if ((propertyName == vm.propertyNames-&gt;caller || propertyName == vm.propertyNames-&gt;arguments) &amp;&amp; executable-&gt;hasCallerAndArgumentsProperties())
560             return false;
561 
562         if (propertyName == vm.propertyNames-&gt;prototype &amp;&amp; !executable-&gt;isArrowFunction())
563             return false;
564 
<a name="75" id="anc75"></a><span class="line-modified">565         thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>

566     }
567 
<a name="76" id="anc76"></a><span class="line-modified">568     return Base::deleteProperty(thisObject, exec, propertyName);</span>
569 }
570 
<a name="77" id="anc77"></a><span class="line-modified">571 bool JSFunction::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
572 {
<a name="78" id="anc78"></a><span class="line-modified">573     VM&amp; vm = exec-&gt;vm();</span>
574     auto scope = DECLARE_THROW_SCOPE(vm);
575 
576     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(object);
<a name="79" id="anc79"></a>








577     if (thisObject-&gt;isHostOrBuiltinFunction()) {
<a name="80" id="anc80"></a><span class="line-modified">578         thisObject-&gt;reifyLazyPropertyForHostOrBuiltinIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">579         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>

580     }
581 
582     if (propertyName == vm.propertyNames-&gt;prototype) {
583         // Make sure prototype has been reified, such that it can only be overwritten
584         // following the rules set out in ECMA-262 8.12.9.
585         PropertySlot slot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<a name="81" id="anc81"></a><span class="line-modified">586         thisObject-&gt;methodTable(vm)-&gt;getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
<span class="line-modified">587         if (thisObject-&gt;m_rareData)</span>
<span class="line-modified">588             thisObject-&gt;m_rareData-&gt;clear(&quot;Store to prototype property of a function&quot;);</span>
<span class="line-modified">589         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>

590     }
591 
592     bool valueCheck;
593     if (propertyName == vm.propertyNames-&gt;arguments) {
594         if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<a name="82" id="anc82"></a><span class="line-modified">595             RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>
596 
<a name="83" id="anc83"></a><span class="line-modified">597         valueCheck = !descriptor.value() || sameValue(exec, descriptor.value(), retrieveArguments(exec, thisObject));</span>




598     } else if (propertyName == vm.propertyNames-&gt;caller) {
599         if (!thisObject-&gt;jsExecutable()-&gt;hasCallerAndArgumentsProperties())
<a name="84" id="anc84"></a><span class="line-modified">600             RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>
601 
<a name="85" id="anc85"></a><span class="line-modified">602         valueCheck = !descriptor.value() || sameValue(exec, descriptor.value(), retrieveCallerFunction(exec, thisObject));</span>




603     } else {
<a name="86" id="anc86"></a><span class="line-modified">604         thisObject-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
<span class="line-modified">605         RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));</span>

606     }
607 
608     if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<a name="87" id="anc87"></a><span class="line-modified">609         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
610     if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<a name="88" id="anc88"></a><span class="line-modified">611         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
612     if (descriptor.isAccessorDescriptor())
<a name="89" id="anc89"></a><span class="line-modified">613         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
614     if (descriptor.writablePresent() &amp;&amp; descriptor.writable())
<a name="90" id="anc90"></a><span class="line-modified">615         return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
616     if (!valueCheck)
<a name="91" id="anc91"></a><span class="line-modified">617         return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>
618     return true;
619 }
620 
621 // ECMA 13.2.2 [[Construct]]
622 ConstructType JSFunction::getConstructData(JSCell* cell, ConstructData&amp; constructData)
623 {
624     JSFunction* thisObject = jsCast&lt;JSFunction*&gt;(cell);
625 
626     if (thisObject-&gt;isHostFunction()) {
627         if (thisObject-&gt;nativeConstructor() == callHostFunctionAsConstructor)
628             return ConstructType::None;
629         constructData.native.function = thisObject-&gt;nativeConstructor();
630         return ConstructType::Host;
631     }
632 
633     FunctionExecutable* functionExecutable = thisObject-&gt;jsExecutable();
634     if (functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
635         return ConstructType::None;
636 
637     constructData.js.functionExecutable = functionExecutable;
638     constructData.js.scope = thisObject-&gt;scope();
639     return ConstructType::JS;
640 }
641 
642 String getCalculatedDisplayName(VM&amp; vm, JSObject* object)
643 {
644 #if ENABLE(WEBASSEMBLY)
645     if (jsDynamicCast&lt;JSToWasmICCallee*&gt;(vm, object))
646         return &quot;wasm-stub&quot;_s;
647 #endif
648 
649     if (!jsDynamicCast&lt;JSFunction*&gt;(vm, object) &amp;&amp; !jsDynamicCast&lt;InternalFunction*&gt;(vm, object))
650         return emptyString();
651 
652     Structure* structure = object-&gt;structure(vm);
653     unsigned attributes;
654     // This function may be called when the mutator isn&#39;t running and we are lazily generating a stack trace.
655     PropertyOffset offset = structure-&gt;getConcurrently(vm.propertyNames-&gt;displayName.impl(), attributes);
656     if (offset != invalidOffset &amp;&amp; !(attributes &amp; (PropertyAttribute::Accessor | PropertyAttribute::CustomAccessorOrValue))) {
657         JSValue displayName = object-&gt;getDirect(offset);
658         if (displayName &amp;&amp; displayName.isString())
659             return asString(displayName)-&gt;tryGetValue();
660     }
661 
662     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(vm, object)) {
663         const String actualName = function-&gt;name(vm);
664         if (!actualName.isEmpty() || function-&gt;isHostOrBuiltinFunction())
665             return actualName;
666 
667         return function-&gt;jsExecutable()-&gt;ecmaName().string();
668     }
669     if (auto* function = jsDynamicCast&lt;InternalFunction*&gt;(vm, object))
670         return function-&gt;name();
671 
672 
673     return emptyString();
674 }
675 
<a name="92" id="anc92"></a><span class="line-modified">676 void JSFunction::setFunctionName(ExecState* exec, JSValue value)</span>
677 {
<a name="93" id="anc93"></a><span class="line-modified">678     VM&amp; vm = exec-&gt;vm();</span>
679     auto scope = DECLARE_THROW_SCOPE(vm);
680 
681     // The &quot;name&quot; property may have been already been defined as part of a property list in an
682     // object literal (and therefore reified).
683     if (hasReifiedName())
684         return;
685 
686     ASSERT(!isHostFunction());
687     ASSERT(jsExecutable()-&gt;ecmaName().isNull());
688     String name;
689     if (value.isSymbol()) {
690         PrivateName privateName = asSymbol(value)-&gt;privateName();
691         SymbolImpl&amp; uid = privateName.uid();
692         if (uid.isNullSymbol())
693             name = emptyString();
694         else
695             name = makeString(&#39;[&#39;, String(&amp;uid), &#39;]&#39;);
696     } else {
<a name="94" id="anc94"></a><span class="line-modified">697         JSString* jsStr = value.toString(exec);</span>
698         RETURN_IF_EXCEPTION(scope, void());
<a name="95" id="anc95"></a><span class="line-modified">699         name = jsStr-&gt;value(exec);</span>
700         RETURN_IF_EXCEPTION(scope, void());
701     }
<a name="96" id="anc96"></a><span class="line-modified">702     reifyName(vm, exec, name);</span>
703 }
704 
705 void JSFunction::reifyLength(VM&amp; vm)
706 {
<a name="97" id="anc97"></a><span class="line-modified">707     FunctionRareData* rareData = this-&gt;rareData(vm);</span>
708 
709     ASSERT(!hasReifiedLength());
<a name="98" id="anc98"></a><span class="line-modified">710     ASSERT(!isHostFunction());</span>
<span class="line-modified">711     JSValue initialValue = jsNumber(jsExecutable()-&gt;parameterCount());</span>






712     unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
713     const Identifier&amp; identifier = vm.propertyNames-&gt;length;
714     rareData-&gt;setHasReifiedLength();
715     putDirect(vm, identifier, initialValue, initialAttributes);
716 }
717 
<a name="99" id="anc99"></a><span class="line-modified">718 void JSFunction::reifyName(VM&amp; vm, ExecState* exec)</span>
719 {
720     const Identifier&amp; ecmaName = jsExecutable()-&gt;ecmaName();
721     String name;
722     // https://tc39.github.io/ecma262/#sec-exports-runtime-semantics-evaluation
723     // When the ident is &quot;*default*&quot;, we need to set &quot;default&quot; for the ecma name.
724     // This &quot;*default*&quot; name is never shown to users.
725     if (ecmaName == vm.propertyNames-&gt;builtinNames().starDefaultPrivateName())
726         name = vm.propertyNames-&gt;defaultKeyword.string();
727     else
728         name = ecmaName.string();
<a name="100" id="anc100"></a><span class="line-modified">729     reifyName(vm, exec, name);</span>
730 }
731 
<a name="101" id="anc101"></a><span class="line-modified">732 void JSFunction::reifyName(VM&amp; vm, ExecState* exec, String name)</span>
733 {
<a name="102" id="anc102"></a><span class="line-modified">734     FunctionRareData* rareData = this-&gt;rareData(vm);</span>
735 
736     ASSERT(!hasReifiedName());
737     ASSERT(!isHostFunction());
738     unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
739     const Identifier&amp; propID = vm.propertyNames-&gt;name;
740 
<a name="103" id="anc103"></a><span class="line-modified">741     if (exec-&gt;lexicalGlobalObject()-&gt;needsSiteSpecificQuirks()) {</span>
742         auto illegalCharMatcher = [] (UChar ch) -&gt; bool {
743             return ch == &#39; &#39; || ch == &#39;|&#39;;
744         };
745         if (name.find(illegalCharMatcher) != notFound)
746             name = String();
747     }
748 
749     if (jsExecutable()-&gt;isGetter())
750         name = makeString(&quot;get &quot;, name);
751     else if (jsExecutable()-&gt;isSetter())
752         name = makeString(&quot;set &quot;, name);
753 
754     rareData-&gt;setHasReifiedName();
755     putDirect(vm, propID, jsString(vm, name), initialAttributes);
756 }
757 
<a name="104" id="anc104"></a><span class="line-modified">758 JSFunction::PropertyStatus JSFunction::reifyLazyPropertyIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
759 {
<a name="105" id="anc105"></a><span class="line-modified">760     if (isHostOrBuiltinFunction())</span>
761         return PropertyStatus::Eager;
<a name="106" id="anc106"></a><span class="line-modified">762     PropertyStatus lazyLength = reifyLazyLengthIfNeeded(vm, exec, propertyName);</span>
763     if (isLazy(lazyLength))
764         return lazyLength;
<a name="107" id="anc107"></a><span class="line-modified">765     PropertyStatus lazyName = reifyLazyNameIfNeeded(vm, exec, propertyName);</span>
766     if (isLazy(lazyName))
767         return lazyName;
768     return PropertyStatus::Eager;
769 }
770 
<a name="108" id="anc108"></a><span class="line-modified">771 JSFunction::PropertyStatus JSFunction::reifyLazyPropertyForHostOrBuiltinIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
772 {
773     ASSERT(isHostOrBuiltinFunction());
<a name="109" id="anc109"></a><span class="line-modified">774     if (isBuiltinFunction()) {</span>
<span class="line-modified">775         PropertyStatus lazyLength = reifyLazyLengthIfNeeded(vm, exec, propertyName);</span>
776         if (isLazy(lazyLength))
777             return lazyLength;
778     }
<a name="110" id="anc110"></a><span class="line-modified">779     return reifyLazyBoundNameIfNeeded(vm, exec, propertyName);</span>
780 }
781 
<a name="111" id="anc111"></a><span class="line-modified">782 JSFunction::PropertyStatus JSFunction::reifyLazyLengthIfNeeded(VM&amp; vm, ExecState*, PropertyName propertyName)</span>
783 {
784     if (propertyName == vm.propertyNames-&gt;length) {
785         if (!hasReifiedLength()) {
786             reifyLength(vm);
787             return PropertyStatus::Reified;
788         }
789         return PropertyStatus::Lazy;
790     }
791     return PropertyStatus::Eager;
792 }
793 
<a name="112" id="anc112"></a><span class="line-modified">794 JSFunction::PropertyStatus JSFunction::reifyLazyNameIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
795 {
796     if (propertyName == vm.propertyNames-&gt;name) {
797         if (!hasReifiedName()) {
<a name="113" id="anc113"></a><span class="line-modified">798             reifyName(vm, exec);</span>
799             return PropertyStatus::Reified;
800         }
801         return PropertyStatus::Lazy;
802     }
803     return PropertyStatus::Eager;
804 }
805 
<a name="114" id="anc114"></a><span class="line-modified">806 JSFunction::PropertyStatus JSFunction::reifyLazyBoundNameIfNeeded(VM&amp; vm, ExecState* exec, PropertyName propertyName)</span>
807 {
<a name="115" id="anc115"></a>

808     const Identifier&amp; nameIdent = vm.propertyNames-&gt;name;
809     if (propertyName != nameIdent)
810         return PropertyStatus::Eager;
811 
812     if (hasReifiedName())
813         return PropertyStatus::Lazy;
814 
815     if (isBuiltinFunction())
<a name="116" id="anc116"></a><span class="line-modified">816         reifyName(vm, exec);</span>
817     else if (this-&gt;inherits&lt;JSBoundFunction&gt;(vm)) {
<a name="117" id="anc117"></a><span class="line-modified">818         FunctionRareData* rareData = this-&gt;rareData(vm);</span>
<span class="line-modified">819         String name = makeString(&quot;bound &quot;, static_cast&lt;NativeExecutable*&gt;(m_executable.get())-&gt;name());</span>






820         unsigned initialAttributes = PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
821         rareData-&gt;setHasReifiedName();
<a name="118" id="anc118"></a><span class="line-modified">822         putDirect(vm, nameIdent, jsString(vm, name), initialAttributes);</span>
823     }
824     return PropertyStatus::Reified;
825 }
826 
<a name="119" id="anc119"></a><span class="line-modified">827 #if !ASSERT_DISABLED</span>
828 void JSFunction::assertTypeInfoFlagInvariants()
829 {
830     // If you change this, you&#39;ll need to update speculationFromClassInfo.
831     const ClassInfo* info = classInfo(vm());
832     if (!(inlineTypeFlags() &amp; ImplementsDefaultHasInstance))
833         RELEASE_ASSERT(info == JSBoundFunction::info());
834     else
835         RELEASE_ASSERT(info != JSBoundFunction::info());
836 }
<a name="120" id="anc120"></a><span class="line-modified">837 #endif</span>
838 
839 } // namespace JSC
<a name="121" id="anc121"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="121" type="hidden" />
</body>
</html>
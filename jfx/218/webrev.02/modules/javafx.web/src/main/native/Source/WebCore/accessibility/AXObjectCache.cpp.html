<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #if ENABLE(ACCESSIBILITY)
  32 
  33 #include &quot;AXObjectCache.h&quot;
  34 
  35 #include &quot;AXIsolatedObject.h&quot;
  36 #include &quot;AXIsolatedTree.h&quot;
  37 #include &quot;AccessibilityARIAGrid.h&quot;
  38 #include &quot;AccessibilityARIAGridCell.h&quot;
  39 #include &quot;AccessibilityARIAGridRow.h&quot;
  40 #include &quot;AccessibilityAttachment.h&quot;
  41 #include &quot;AccessibilityImageMapLink.h&quot;
  42 #include &quot;AccessibilityLabel.h&quot;
  43 #include &quot;AccessibilityList.h&quot;
  44 #include &quot;AccessibilityListBox.h&quot;
  45 #include &quot;AccessibilityListBoxOption.h&quot;
  46 #include &quot;AccessibilityMathMLElement.h&quot;
  47 #include &quot;AccessibilityMediaControls.h&quot;
  48 #include &quot;AccessibilityMediaObject.h&quot;
  49 #include &quot;AccessibilityMenuList.h&quot;
  50 #include &quot;AccessibilityMenuListOption.h&quot;
  51 #include &quot;AccessibilityMenuListPopup.h&quot;
  52 #include &quot;AccessibilityProgressIndicator.h&quot;
  53 #include &quot;AccessibilityRenderObject.h&quot;
  54 #include &quot;AccessibilitySVGElement.h&quot;
  55 #include &quot;AccessibilitySVGRoot.h&quot;
  56 #include &quot;AccessibilityScrollView.h&quot;
  57 #include &quot;AccessibilityScrollbar.h&quot;
  58 #include &quot;AccessibilitySlider.h&quot;
  59 #include &quot;AccessibilitySpinButton.h&quot;
  60 #include &quot;AccessibilityTable.h&quot;
  61 #include &quot;AccessibilityTableCell.h&quot;
  62 #include &quot;AccessibilityTableColumn.h&quot;
  63 #include &quot;AccessibilityTableHeaderContainer.h&quot;
  64 #include &quot;AccessibilityTableRow.h&quot;
  65 #include &quot;AccessibilityTree.h&quot;
  66 #include &quot;AccessibilityTreeItem.h&quot;
  67 #include &quot;Document.h&quot;
  68 #include &quot;Editing.h&quot;
  69 #include &quot;Editor.h&quot;
  70 #include &quot;ElementIterator.h&quot;
  71 #include &quot;FocusController.h&quot;
  72 #include &quot;Frame.h&quot;
  73 #include &quot;HTMLAreaElement.h&quot;
  74 #include &quot;HTMLCanvasElement.h&quot;
  75 #include &quot;HTMLImageElement.h&quot;
  76 #include &quot;HTMLInputElement.h&quot;
  77 #include &quot;HTMLLabelElement.h&quot;
  78 #include &quot;HTMLMeterElement.h&quot;
  79 #include &quot;HTMLNames.h&quot;
  80 #include &quot;HTMLParserIdioms.h&quot;
  81 #include &quot;HTMLTextFormControlElement.h&quot;
  82 #include &quot;InlineElementBox.h&quot;
  83 #include &quot;MathMLElement.h&quot;
  84 #include &quot;Page.h&quot;
  85 #include &quot;RenderAttachment.h&quot;
  86 #include &quot;RenderLineBreak.h&quot;
  87 #include &quot;RenderListBox.h&quot;
  88 #include &quot;RenderMathMLOperator.h&quot;
  89 #include &quot;RenderMenuList.h&quot;
  90 #include &quot;RenderMeter.h&quot;
  91 #include &quot;RenderProgress.h&quot;
  92 #include &quot;RenderSVGRoot.h&quot;
  93 #include &quot;RenderSlider.h&quot;
  94 #include &quot;RenderTable.h&quot;
  95 #include &quot;RenderTableCell.h&quot;
  96 #include &quot;RenderTableRow.h&quot;
  97 #include &quot;RenderView.h&quot;
  98 #include &quot;RuntimeEnabledFeatures.h&quot;
  99 #include &quot;SVGElement.h&quot;
 100 #include &quot;ScriptDisallowedScope.h&quot;
 101 #include &quot;ScrollView.h&quot;
 102 #include &quot;TextBoundaries.h&quot;
 103 #include &quot;TextControlInnerElements.h&quot;
 104 #include &quot;TextIterator.h&quot;
 105 
 106 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE) &amp;&amp; PLATFORM(MAC)
 107 #include &lt;pal/spi/mac/HIServicesSPI.h&gt;
 108 #endif
 109 
 110 #include &lt;wtf/DataLog.h&gt;
 111 #include &lt;wtf/SetForScope.h&gt;
 112 
 113 #if ENABLE(VIDEO)
 114 #include &quot;MediaControlElements.h&quot;
 115 #endif
 116 
 117 #if COMPILER(MSVC)
 118 // See https://msdn.microsoft.com/en-us/library/1wea5zwe.aspx
 119 #pragma warning(disable: 4701)
 120 #endif
 121 
 122 namespace WebCore {
 123 
 124 using namespace HTMLNames;
 125 
 126 const AXID InvalidAXID = 0;
 127 
 128 // Post value change notifications for password fields or elements contained in password fields at a 40hz interval to thwart analysis of typing cadence
 129 static const Seconds accessibilityPasswordValueChangeNotificationInterval { 25_ms };
 130 static const Seconds accessibilityLiveRegionChangedNotificationInterval { 20_ms };
 131 static const Seconds accessibilityFocusModalNodeNotificationInterval { 50_ms };
 132 
 133 static bool rendererNeedsDeferredUpdate(const RenderObject&amp; renderer)
 134 {
 135     ASSERT(!renderer.beingDestroyed());
 136     auto&amp; document = renderer.document();
 137     return renderer.needsLayout() || document.needsStyleRecalc() || document.inRenderTreeUpdate() || (document.view() &amp;&amp; document.view()-&gt;layoutContext().isInRenderTreeLayout());
 138 }
 139 
 140 static bool nodeAndRendererAreValid(Node* node)
 141 {
 142     if (!node)
 143         return false;
 144 
 145     auto* renderer = node-&gt;renderer();
 146     return renderer &amp;&amp; !renderer-&gt;beingDestroyed();
 147 }
 148 
 149 AccessibilityObjectInclusion AXComputedObjectAttributeCache::getIgnored(AXID id) const
 150 {
 151     auto it = m_idMapping.find(id);
 152     return it != m_idMapping.end() ? it-&gt;value.ignored : AccessibilityObjectInclusion::DefaultBehavior;
 153 }
 154 
 155 void AXComputedObjectAttributeCache::setIgnored(AXID id, AccessibilityObjectInclusion inclusion)
 156 {
 157     HashMap&lt;AXID, CachedAXObjectAttributes&gt;::iterator it = m_idMapping.find(id);
 158     if (it != m_idMapping.end())
 159         it-&gt;value.ignored = inclusion;
 160     else {
 161         CachedAXObjectAttributes attributes;
 162         attributes.ignored = inclusion;
 163         m_idMapping.set(id, attributes);
 164     }
 165 }
 166 
 167 AccessibilityReplacedText::AccessibilityReplacedText(const VisibleSelection&amp; selection)
 168 {
 169     if (AXObjectCache::accessibilityEnabled()) {
 170         m_replacedRange.startIndex.value = indexForVisiblePosition(selection.start(), m_replacedRange.startIndex.scope);
 171         if (selection.isRange()) {
 172             m_replacedText = AccessibilityObject::stringForVisiblePositionRange(selection);
 173             m_replacedRange.endIndex.value = indexForVisiblePosition(selection.end(), m_replacedRange.endIndex.scope);
 174         } else
 175             m_replacedRange.endIndex = m_replacedRange.startIndex;
 176     }
 177 }
 178 
 179 void AccessibilityReplacedText::postTextStateChangeNotification(AXObjectCache* cache, AXTextEditType type, const String&amp; text, const VisibleSelection&amp; selection)
 180 {
 181     if (!cache)
 182         return;
 183     if (!AXObjectCache::accessibilityEnabled())
 184         return;
 185 
 186     VisiblePosition position = selection.start();
 187     auto* node = highestEditableRoot(position.deepEquivalent(), HasEditableAXRole);
 188     if (m_replacedText.length())
 189         cache-&gt;postTextReplacementNotification(node, AXTextEditTypeDelete, m_replacedText, type, text, position);
 190     else
 191         cache-&gt;postTextStateChangeNotification(node, type, text, position);
 192 }
 193 
 194 bool AXObjectCache::gAccessibilityEnabled = false;
 195 bool AXObjectCache::gAccessibilityEnhancedUserInterfaceEnabled = false;
 196 
 197 void AXObjectCache::enableAccessibility()
 198 {
 199     gAccessibilityEnabled = true;
 200 }
 201 
 202 void AXObjectCache::disableAccessibility()
 203 {
 204     gAccessibilityEnabled = false;
 205 }
 206 
 207 void AXObjectCache::setEnhancedUserInterfaceAccessibility(bool flag)
 208 {
 209     gAccessibilityEnhancedUserInterfaceEnabled = flag;
 210 #if PLATFORM(MAC)
 211     if (flag)
 212         enableAccessibility();
 213 #endif
 214 }
 215 
 216 AXObjectCache::AXObjectCache(Document&amp; document)
 217     : m_document(document)
 218     , m_pageID(document.pageID())
 219     , m_notificationPostTimer(*this, &amp;AXObjectCache::notificationPostTimerFired)
 220     , m_passwordNotificationPostTimer(*this, &amp;AXObjectCache::passwordNotificationPostTimerFired)
 221     , m_liveRegionChangedPostTimer(*this, &amp;AXObjectCache::liveRegionChangedNotificationPostTimerFired)
 222     , m_focusModalNodeTimer(*this, &amp;AXObjectCache::focusModalNodeTimerFired)
 223     , m_currentModalNode(nullptr)
 224     , m_performCacheUpdateTimer(*this, &amp;AXObjectCache::performCacheUpdateTimerFired)
 225 {
 226     findModalNodes();
 227 }
 228 
 229 AXObjectCache::~AXObjectCache()
 230 {
 231     m_notificationPostTimer.stop();
 232     m_liveRegionChangedPostTimer.stop();
 233     m_focusModalNodeTimer.stop();
 234     m_performCacheUpdateTimer.stop();
 235 
 236 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 237     // Destroy the IsolatedTree before destroying the live tree.
 238     if (m_pageID)
 239         AXIsolatedTree::removeTreeForPageID(*m_pageID);
 240 #endif
 241 
 242     for (const auto&amp; object : m_objects.values())
 243         object-&gt;detach(AccessibilityDetachmentType::CacheDestroyed);
 244 }
 245 
 246 void AXObjectCache::findModalNodes()
 247 {
 248     // Traverse the DOM tree to look for the aria-modal=true nodes.
 249     for (Element* element = ElementTraversal::firstWithin(document().rootNode()); element; element = ElementTraversal::nextIncludingPseudo(*element)) {
 250 
 251         // Must have dialog or alertdialog role
 252         if (!nodeHasRole(element, &quot;dialog&quot;) &amp;&amp; !nodeHasRole(element, &quot;alertdialog&quot;))
 253             continue;
 254         if (!equalLettersIgnoringASCIICase(element-&gt;attributeWithoutSynchronization(aria_modalAttr), &quot;true&quot;))
 255             continue;
 256 
 257         m_modalNodesSet.add(element);
 258     }
 259 
 260     // Set the current valid aria-modal node if possible.
 261     updateCurrentModalNode();
 262 }
 263 
 264 void AXObjectCache::updateCurrentModalNode()
 265 {
 266     // There might be multiple nodes with aria-modal=true set.
 267     // We use this function to pick the one we want.
 268     m_currentModalNode = nullptr;
 269     if (m_modalNodesSet.isEmpty())
 270         return;
 271 
 272     // We only care about the nodes which are visible.
 273     ListHashSet&lt;RefPtr&lt;Node&gt;&gt; visibleNodes;
 274     for (auto&amp; object : m_modalNodesSet) {
 275         if (isNodeVisible(object))
 276             visibleNodes.add(object);
 277     }
 278 
 279     if (visibleNodes.isEmpty())
 280         return;
 281 
 282     // If any of the node are keyboard focused, we want to pick that.
 283     Node* focusedNode = document().focusedElement();
 284     for (auto&amp; object : visibleNodes) {
 285         if (focusedNode != nullptr &amp;&amp; focusedNode-&gt;isDescendantOf(object.get())) {
 286             m_currentModalNode = object.get();
 287             break;
 288         }
 289     }
 290 
 291     // If none of the nodes are focused, we want to pick the last dialog in the DOM.
 292     if (!m_currentModalNode)
 293         m_currentModalNode = visibleNodes.last().get();
 294 }
 295 
 296 bool AXObjectCache::isNodeVisible(Node* node) const
 297 {
 298     if (!is&lt;Element&gt;(node))
 299         return false;
 300 
 301     RenderObject* renderer = node-&gt;renderer();
 302     if (!renderer)
 303         return false;
 304     const RenderStyle&amp; style = renderer-&gt;style();
 305     if (style.display() == DisplayType::None || style.visibility() != Visibility::Visible)
 306         return false;
 307 
 308     // We also need to consider aria hidden status.
 309     if (!isNodeAriaVisible(node))
 310         return false;
 311 
 312     return true;
 313 }
 314 
 315 Node* AXObjectCache::modalNode()
 316 {
 317     // This function returns the valid aria modal node.
 318     if (m_modalNodesSet.isEmpty())
 319         return nullptr;
 320 
 321     // Check the current valid aria modal node first.
 322     // Usually when one dialog sets aria-modal=true, that dialog is the one we want.
 323     if (isNodeVisible(m_currentModalNode))
 324         return m_currentModalNode;
 325 
 326     // Recompute the valid aria modal node when m_currentModalNode is null or hidden.
 327     updateCurrentModalNode();
 328     return isNodeVisible(m_currentModalNode) ? m_currentModalNode : nullptr;
 329 }
 330 
 331 AccessibilityObject* AXObjectCache::focusedImageMapUIElement(HTMLAreaElement* areaElement)
 332 {
 333     // Find the corresponding accessibility object for the HTMLAreaElement. This should be
 334     // in the list of children for its corresponding image.
 335     if (!areaElement)
 336         return nullptr;
 337 
 338     HTMLImageElement* imageElement = areaElement-&gt;imageElement();
 339     if (!imageElement)
 340         return nullptr;
 341 
 342     AccessibilityObject* axRenderImage = areaElement-&gt;document().axObjectCache()-&gt;getOrCreate(imageElement);
 343     if (!axRenderImage)
 344         return nullptr;
 345 
 346     for (const auto&amp; child : axRenderImage-&gt;children()) {
 347         if (!is&lt;AccessibilityImageMapLink&gt;(*child))
 348             continue;
 349 
 350         if (downcast&lt;AccessibilityImageMapLink&gt;(*child).areaElement() == areaElement)
 351             return downcast&lt;AccessibilityImageMapLink&gt;(child.get());
 352     }
 353 
 354     return nullptr;
 355 }
 356 
 357 AXCoreObject* AXObjectCache::focusedObject(Document&amp; document)
 358 {
 359     Element* focusedElement = document.focusedElement();
 360     if (is&lt;HTMLAreaElement&gt;(focusedElement))
 361         return focusedImageMapUIElement(downcast&lt;HTMLAreaElement&gt;(focusedElement));
 362 
 363     auto* axObjectCache = document.axObjectCache();
 364     if (!axObjectCache)
 365         return nullptr;
 366 
 367     AXCoreObject* focus = axObjectCache-&gt;getOrCreate(focusedElement ? focusedElement : static_cast&lt;Node*&gt;(&amp;document));
 368     if (!focus)
 369         return nullptr;
 370 
 371     if (focus-&gt;shouldFocusActiveDescendant()) {
 372         if (auto* descendant = focus-&gt;activeDescendant())
 373             focus = descendant;
 374     }
 375 
 376     // the HTML element, for example, is focusable but has an AX object that is ignored
 377     if (focus-&gt;accessibilityIsIgnored())
 378         focus = focus-&gt;parentObjectUnignored();
 379 
 380     return focus;
 381 }
 382 
 383 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 384 AXCoreObject* AXObjectCache::isolatedTreeFocusedObject(Document&amp; document)
 385 {
 386     auto pageID = document.pageID();
 387     if (!pageID)
 388         return nullptr;
 389 
 390     auto tree = AXIsolatedTree::treeForPageID(*pageID);
 391     if (!tree) {
 392         tree = generateIsolatedTree(*pageID, document);
 393         // Now that we have created our tree, initialize the secondary thread,
 394         // so future requests come in on the other thread.
 395         _AXUIElementUseSecondaryAXThread(true);
 396     }
 397 
 398     if (tree)
 399         return tree-&gt;focusedUIElement().get();
 400 
 401     // Should not get here, couldn&#39;t create the IsolatedTree.
 402     ASSERT_NOT_REACHED();
 403     return nullptr;
 404 }
 405 
 406 void AXObjectCache::setIsolatedTreeFocusedObject(Node* focusedNode)
 407 {
 408     ASSERT(isMainThread());
 409     if (!m_pageID)
 410         return;
 411 
 412     auto* focus = getOrCreate(focusedNode);
 413 
 414     if (auto tree = AXIsolatedTree::treeForPageID(*m_pageID))
 415         tree-&gt;setFocusedNodeID(focus ? focus-&gt;objectID() : InvalidAXID);
 416 }
 417 #endif
 418 
 419 AXCoreObject* AXObjectCache::focusedUIElementForPage(const Page* page)
 420 {
 421     ASSERT(isMainThread());
 422     if (!gAccessibilityEnabled)
 423         return nullptr;
 424 
 425     // get the focused node in the page
 426     Document* focusedDocument = page-&gt;focusController().focusedOrMainFrame().document();
 427     if (!focusedDocument)
 428         return nullptr;
 429 
 430 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 431     if (clientSupportsIsolatedTree())
 432         return isolatedTreeFocusedObject(*focusedDocument);
 433 #endif
 434 
 435     return focusedObject(*focusedDocument);
 436 }
 437 
 438 AccessibilityObject* AXObjectCache::get(Widget* widget)
 439 {
 440     if (!widget)
 441         return nullptr;
 442 
 443     AXID axID = m_widgetObjectMapping.get(widget);
 444     ASSERT(!HashTraits&lt;AXID&gt;::isDeletedValue(axID));
 445     if (!axID)
 446         return nullptr;
 447 
 448     return m_objects.get(axID);
 449 }
 450 
 451 AccessibilityObject* AXObjectCache::get(RenderObject* renderer)
 452 {
 453     if (!renderer)
 454         return nullptr;
 455 
 456     AXID axID = m_renderObjectMapping.get(renderer);
 457     ASSERT(!HashTraits&lt;AXID&gt;::isDeletedValue(axID));
 458     if (!axID)
 459         return nullptr;
 460 
 461     return m_objects.get(axID);
 462 }
 463 
 464 AccessibilityObject* AXObjectCache::get(Node* node)
 465 {
 466     if (!node)
 467         return nullptr;
 468 
 469     AXID renderID = node-&gt;renderer() ? m_renderObjectMapping.get(node-&gt;renderer()) : 0;
 470     ASSERT(!HashTraits&lt;AXID&gt;::isDeletedValue(renderID));
 471 
 472     AXID nodeID = m_nodeObjectMapping.get(node);
 473     ASSERT(!HashTraits&lt;AXID&gt;::isDeletedValue(nodeID));
 474 
 475     if (node-&gt;renderer() &amp;&amp; nodeID &amp;&amp; !renderID) {
 476         // This can happen if an AccessibilityNodeObject is created for a node that&#39;s not
 477         // rendered, but later something changes and it gets a renderer (like if it&#39;s
 478         // reparented).
 479         remove(nodeID);
 480         return nullptr;
 481     }
 482 
 483     if (renderID)
 484         return m_objects.get(renderID);
 485 
 486     if (!nodeID)
 487         return nullptr;
 488 
 489     return m_objects.get(nodeID);
 490 }
 491 
 492 // FIXME: This probably belongs on Node.
 493 // FIXME: This should take a const char*, but one caller passes nullAtom().
 494 bool nodeHasRole(Node* node, const String&amp; role)
 495 {
 496     if (!node || !is&lt;Element&gt;(node))
 497         return false;
 498 
 499     auto&amp; roleValue = downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(roleAttr);
 500     if (role.isNull())
 501         return roleValue.isEmpty();
 502     if (roleValue.isEmpty())
 503         return false;
 504 
 505     return SpaceSplitString(roleValue, true).contains(role);
 506 }
 507 
 508 static Ref&lt;AccessibilityObject&gt; createFromRenderer(RenderObject* renderer)
 509 {
 510     // FIXME: How could renderer-&gt;node() ever not be an Element?
 511     Node* node = renderer-&gt;node();
 512 
 513     // If the node is aria role=&quot;list&quot; or the aria role is empty and its a
 514     // ul/ol/dl type (it shouldn&#39;t be a list if aria says otherwise).
 515     if (node &amp;&amp; ((nodeHasRole(node, &quot;list&quot;) || nodeHasRole(node, &quot;directory&quot;))
 516                       || (nodeHasRole(node, nullAtom()) &amp;&amp; (node-&gt;hasTagName(ulTag) || node-&gt;hasTagName(olTag) || node-&gt;hasTagName(dlTag)))))
 517         return AccessibilityList::create(renderer);
 518 
 519     // aria tables
 520     if (nodeHasRole(node, &quot;grid&quot;) || nodeHasRole(node, &quot;treegrid&quot;) || nodeHasRole(node, &quot;table&quot;))
 521         return AccessibilityARIAGrid::create(renderer);
 522     if (nodeHasRole(node, &quot;row&quot;))
 523         return AccessibilityARIAGridRow::create(renderer);
 524     if (nodeHasRole(node, &quot;gridcell&quot;) || nodeHasRole(node, &quot;cell&quot;) || nodeHasRole(node, &quot;columnheader&quot;) || nodeHasRole(node, &quot;rowheader&quot;))
 525         return AccessibilityARIAGridCell::create(renderer);
 526 
 527     // aria tree
 528     if (nodeHasRole(node, &quot;tree&quot;))
 529         return AccessibilityTree::create(renderer);
 530     if (nodeHasRole(node, &quot;treeitem&quot;))
 531         return AccessibilityTreeItem::create(renderer);
 532 
 533     if (node &amp;&amp; is&lt;HTMLLabelElement&gt;(node) &amp;&amp; nodeHasRole(node, nullAtom()))
 534         return AccessibilityLabel::create(renderer);
 535 
 536 #if PLATFORM(IOS_FAMILY)
 537     if (is&lt;HTMLMediaElement&gt;(node) &amp;&amp; nodeHasRole(node, nullAtom()))
 538         return AccessibilityMediaObject::create(renderer);
 539 #endif
 540 
 541 #if ENABLE(VIDEO)
 542     // media controls
 543     if (node &amp;&amp; node-&gt;isMediaControlElement())
 544         return AccessibilityMediaControl::create(renderer);
 545 #endif
 546 
 547     if (is&lt;RenderSVGRoot&gt;(*renderer))
 548         return AccessibilitySVGRoot::create(renderer);
 549 
 550     if (is&lt;SVGElement&gt;(node))
 551         return AccessibilitySVGElement::create(renderer);
 552 
 553 #if ENABLE(MATHML)
 554     // The mfenced element creates anonymous RenderMathMLOperators which should be treated
 555     // as MathML elements and assigned the MathElementRole so that platform logic regarding
 556     // inclusion and role mapping is not bypassed.
 557     bool isAnonymousOperator = renderer-&gt;isAnonymous() &amp;&amp; is&lt;RenderMathMLOperator&gt;(*renderer);
 558     if (isAnonymousOperator || is&lt;MathMLElement&gt;(node))
 559         return AccessibilityMathMLElement::create(renderer, isAnonymousOperator);
 560 #endif
 561 
 562     if (is&lt;RenderBoxModelObject&gt;(*renderer)) {
 563         RenderBoxModelObject&amp; cssBox = downcast&lt;RenderBoxModelObject&gt;(*renderer);
 564         if (is&lt;RenderListBox&gt;(cssBox))
 565             return AccessibilityListBox::create(&amp;downcast&lt;RenderListBox&gt;(cssBox));
 566         if (is&lt;RenderMenuList&gt;(cssBox))
 567             return AccessibilityMenuList::create(&amp;downcast&lt;RenderMenuList&gt;(cssBox));
 568 
 569         // standard tables
 570         if (is&lt;RenderTable&gt;(cssBox))
 571             return AccessibilityTable::create(&amp;downcast&lt;RenderTable&gt;(cssBox));
 572         if (is&lt;RenderTableRow&gt;(cssBox))
 573             return AccessibilityTableRow::create(&amp;downcast&lt;RenderTableRow&gt;(cssBox));
 574         if (is&lt;RenderTableCell&gt;(cssBox))
 575             return AccessibilityTableCell::create(&amp;downcast&lt;RenderTableCell&gt;(cssBox));
 576 
 577         // progress bar
 578         if (is&lt;RenderProgress&gt;(cssBox))
 579             return AccessibilityProgressIndicator::create(&amp;downcast&lt;RenderProgress&gt;(cssBox));
 580 
 581 #if ENABLE(ATTACHMENT_ELEMENT)
 582         if (is&lt;RenderAttachment&gt;(cssBox))
 583             return AccessibilityAttachment::create(&amp;downcast&lt;RenderAttachment&gt;(cssBox));
 584 #endif
 585 #if ENABLE(METER_ELEMENT)
 586         if (is&lt;RenderMeter&gt;(cssBox))
 587             return AccessibilityProgressIndicator::create(&amp;downcast&lt;RenderMeter&gt;(cssBox));
 588 #endif
 589 
 590         // input type=range
 591         if (is&lt;RenderSlider&gt;(cssBox))
 592             return AccessibilitySlider::create(&amp;downcast&lt;RenderSlider&gt;(cssBox));
 593     }
 594 
 595     return AccessibilityRenderObject::create(renderer);
 596 }
 597 
 598 static Ref&lt;AccessibilityObject&gt; createFromNode(Node* node)
 599 {
 600     return AccessibilityNodeObject::create(node);
 601 }
 602 
 603 void AXObjectCache::cacheAndInitializeWrapper(AccessibilityObject* newObject, DOMObjectVariant domObject)
 604 {
 605     ASSERT(newObject);
 606     AXID axID = getAXID(newObject);
 607     WTF::switchOn(domObject,
 608         [&amp;axID, this] (RenderObject* typedValue) { m_renderObjectMapping.set(typedValue, axID); },
 609         [&amp;axID, this] (Node* typedValue) { m_nodeObjectMapping.set(typedValue, axID); },
 610         [&amp;axID, this] (Widget* typedValue) { m_widgetObjectMapping.set(typedValue, axID); },
 611         [] (auto&amp;) { }
 612     );
 613     m_objects.set(axID, newObject);
 614     newObject-&gt;init();
 615     attachWrapper(newObject);
 616 }
 617 
 618 AccessibilityObject* AXObjectCache::getOrCreate(Widget* widget)
 619 {
 620     if (!widget)
 621         return nullptr;
 622 
 623     if (AccessibilityObject* obj = get(widget))
 624         return obj;
 625 
 626     RefPtr&lt;AccessibilityObject&gt; newObj;
 627     if (is&lt;ScrollView&gt;(*widget))
 628         newObj = AccessibilityScrollView::create(downcast&lt;ScrollView&gt;(widget));
 629     else if (is&lt;Scrollbar&gt;(*widget))
 630         newObj = AccessibilityScrollbar::create(downcast&lt;Scrollbar&gt;(widget));
 631 
 632     // Will crash later if we have two objects for the same widget.
 633     ASSERT(!get(widget));
 634 
 635     // Catch the case if an (unsupported) widget type is used. Only FrameView and ScrollBar are supported now.
 636     ASSERT(newObj);
 637     if (!newObj)
 638         return nullptr;
 639 
 640     cacheAndInitializeWrapper(newObj.get(), widget);
 641     return newObj.get();
 642 }
 643 
 644 AccessibilityObject* AXObjectCache::getOrCreate(Node* node)
 645 {
 646     if (!node)
 647         return nullptr;
 648 
 649     if (AccessibilityObject* obj = get(node))
 650         return obj;
 651 
 652     if (node-&gt;renderer())
 653         return getOrCreate(node-&gt;renderer());
 654 
 655     if (!node-&gt;parentElement())
 656         return nullptr;
 657 
 658     // It&#39;s only allowed to create an AccessibilityObject from a Node if it&#39;s in a canvas subtree.
 659     // Or if it&#39;s a hidden element, but we still want to expose it because of other ARIA attributes.
 660     bool inCanvasSubtree = lineageOfType&lt;HTMLCanvasElement&gt;(*node-&gt;parentElement()).first();
 661     bool isHidden = isNodeAriaVisible(node);
 662 
 663     bool insideMeterElement = false;
 664 #if ENABLE(METER_ELEMENT)
 665     insideMeterElement = is&lt;HTMLMeterElement&gt;(*node-&gt;parentElement());
 666 #endif
 667 
 668     if (!inCanvasSubtree &amp;&amp; !isHidden &amp;&amp; !insideMeterElement)
 669         return nullptr;
 670 
 671     auto protectedNode = makeRef(*node);
 672 
 673     // Fallback content is only focusable as long as the canvas is displayed and visible.
 674     // Update the style before Element::isFocusable() gets called.
 675     if (inCanvasSubtree)
 676         node-&gt;document().updateStyleIfNeeded();
 677 
 678     RefPtr&lt;AccessibilityObject&gt; newObj = createFromNode(node);
 679 
 680     // Will crash later if we have two objects for the same node.
 681     ASSERT(!get(node));
 682 
 683     cacheAndInitializeWrapper(newObj.get(), node);
 684     newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
 685     // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
 686     // it will disappear when this function is finished, leading to a use-after-free.
 687     if (newObj-&gt;isDetached())
 688         return nullptr;
 689 
 690     return newObj.get();
 691 }
 692 
 693 AccessibilityObject* AXObjectCache::getOrCreate(RenderObject* renderer)
 694 {
 695     if (!renderer)
 696         return nullptr;
 697 
 698     if (AccessibilityObject* obj = get(renderer))
 699         return obj;
 700 
 701     RefPtr&lt;AccessibilityObject&gt; newObj = createFromRenderer(renderer);
 702 
 703     // Will crash later if we have two objects for the same renderer.
 704     ASSERT(!get(renderer));
 705 
 706     cacheAndInitializeWrapper(newObj.get(), renderer);
 707     newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
 708     // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
 709     // it will disappear when this function is finished, leading to a use-after-free.
 710     if (newObj-&gt;isDetached())
 711         return nullptr;
 712 
 713     return newObj.get();
 714 }
 715 
 716 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 717 bool AXObjectCache::clientSupportsIsolatedTree()
 718 {
 719     if (!RuntimeEnabledFeatures::sharedFeatures().isAccessibilityIsolatedTreeEnabled())
 720         return false;
 721 
 722     AXClientType type = _AXGetClientForCurrentRequestUntrusted();
 723     // FIXME: Remove unknown client before setting isAccessibilityIsolatedTreeEnabled initial value = true.
 724     return type == kAXClientTypeVoiceOver
 725         || type == kAXClientTypeUnknown;
 726 }
 727 #endif
 728 
 729 AXCoreObject* AXObjectCache::rootObject()
 730 {
 731     if (!gAccessibilityEnabled)
 732         return nullptr;
 733 
 734 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 735     if (clientSupportsIsolatedTree())
 736         return isolatedTreeRootObject();
 737 #endif
 738 
 739     return getOrCreate(m_document.view());
 740 }
 741 
 742 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 743 AXCoreObject* AXObjectCache::isolatedTreeRootObject()
 744 {
 745     if (!m_pageID)
 746         return nullptr;
 747 
 748     auto tree = AXIsolatedTree::treeForPageID(*m_pageID);
 749     if (!tree) {
 750         tree = Accessibility::retrieveValueFromMainThread&lt;RefPtr&lt;AXIsolatedTree&gt;&gt;([this] () -&gt; RefPtr&lt;AXIsolatedTree&gt; {
 751             return generateIsolatedTree(*m_pageID, m_document);
 752         });
 753 
 754         // Now that we have created our tree, initialize the secondary thread,
 755         // so future requests come in on the other thread.
 756         _AXUIElementUseSecondaryAXThread(true);
 757     }
 758 
 759     if (tree)
 760         return tree-&gt;rootNode().get();
 761 
 762     // Should not get here, couldn&#39;t create the IsolatedTree.
 763     ASSERT_NOT_REACHED();
 764     return nullptr;
 765 }
 766 #endif
 767 
 768 bool AXObjectCache::canUseSecondaryAXThread()
 769 {
 770 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE) &amp;&amp; PLATFORM(MAC)
 771     if (_AXUIElementRequestServicedBySecondaryAXThread())
 772         return true;
 773 
 774     // _AXUIElementRequestServicedBySecondaryAXThread returns false for
 775     // LayoutTests, but we still want to run LayoutTests using isolated tree on
 776     // a secondary thread to simulate the actual execution.
 777     return clientSupportsIsolatedTree();
 778 #else
 779     return false;
 780 #endif
 781 }
 782 
 783 AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame* frame)
 784 {
 785     if (!gAccessibilityEnabled)
 786         return nullptr;
 787 
 788     if (!frame)
 789         return nullptr;
 790     return getOrCreate(frame-&gt;view());
 791 }
 792 
 793 AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole role)
 794 {
 795     RefPtr&lt;AccessibilityObject&gt; obj;
 796 
 797     // will be filled in...
 798     switch (role) {
 799     case AccessibilityRole::ListBoxOption:
 800         obj = AccessibilityListBoxOption::create();
 801         break;
 802     case AccessibilityRole::ImageMapLink:
 803         obj = AccessibilityImageMapLink::create();
 804         break;
 805     case AccessibilityRole::Column:
 806         obj = AccessibilityTableColumn::create();
 807         break;
 808     case AccessibilityRole::TableHeaderContainer:
 809         obj = AccessibilityTableHeaderContainer::create();
 810         break;
 811     case AccessibilityRole::SliderThumb:
 812         obj = AccessibilitySliderThumb::create();
 813         break;
 814     case AccessibilityRole::MenuListPopup:
 815         obj = AccessibilityMenuListPopup::create();
 816         break;
 817     case AccessibilityRole::MenuListOption:
 818         obj = AccessibilityMenuListOption::create();
 819         break;
 820     case AccessibilityRole::SpinButton:
 821         obj = AccessibilitySpinButton::create();
 822         break;
 823     case AccessibilityRole::SpinButtonPart:
 824         obj = AccessibilitySpinButtonPart::create();
 825         break;
 826     default:
 827         obj = nullptr;
 828     }
 829 
 830     if (!obj)
 831         return nullptr;
 832 
 833     cacheAndInitializeWrapper(obj.get());
 834     return obj.get();
 835 }
 836 
 837 void AXObjectCache::remove(AXID axID)
 838 {
 839     if (!axID)
 840         return;
 841 
 842 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
 843     if (m_pageID) {
 844         if (auto tree = AXIsolatedTree::treeForPageID(*m_pageID))
 845             tree-&gt;removeNode(axID);
 846     }
 847 #endif
 848 
 849     auto object = m_objects.take(axID);
 850     if (!object)
 851         return;
 852 
 853     object-&gt;detach(AccessibilityDetachmentType::ElementDestroyed);
 854 
 855     m_idsInUse.remove(axID);
 856     ASSERT(m_objects.size() &gt;= m_idsInUse.size());
 857 }
 858 
 859 void AXObjectCache::remove(RenderObject* renderer)
 860 {
 861     if (!renderer)
 862         return;
 863     remove(m_renderObjectMapping.take(renderer));
 864 }
 865 
 866 void AXObjectCache::remove(Node&amp; node)
 867 {
 868     if (is&lt;Element&gt;(node)) {
 869         m_deferredRecomputeIsIgnoredList.remove(downcast&lt;Element&gt;(&amp;node));
 870         m_deferredSelectedChildredChangedList.remove(downcast&lt;Element&gt;(&amp;node));
 871         m_deferredTextFormControlValue.remove(downcast&lt;Element&gt;(&amp;node));
 872         m_deferredAttributeChange.remove(downcast&lt;Element&gt;(&amp;node));
 873     }
 874     m_deferredChildrenChangedNodeList.remove(&amp;node);
 875     m_deferredTextChangedList.remove(&amp;node);
 876     // Remove the entry if the new focused node is being removed.
 877     m_deferredFocusedNodeChange.removeAllMatching([&amp;node](auto&amp; entry) -&gt; bool {
 878         return entry.second == &amp;node;
 879     });
 880     // Set nullptr to the old focused node if it is being removed.
 881     std::for_each(m_deferredFocusedNodeChange.begin(), m_deferredFocusedNodeChange.end(), [&amp;node](auto&amp; entry) {
 882         if (entry.first == &amp;node)
 883             entry.first = nullptr;
 884     });
 885 
 886     removeNodeForUse(node);
 887 
 888     remove(m_nodeObjectMapping.take(&amp;node));
 889 
 890     if (m_currentModalNode == &amp;node)
 891         m_currentModalNode = nullptr;
 892     m_modalNodesSet.remove(&amp;node);
 893 
 894     remove(node.renderer());
 895 }
 896 
 897 void AXObjectCache::remove(Widget* view)
 898 {
 899     if (!view)
 900         return;
 901     remove(m_widgetObjectMapping.take(view));
 902 }
 903 
 904 
 905 #if !PLATFORM(WIN)
 906 AXID AXObjectCache::platformGenerateAXID() const
 907 {
 908     static AXID lastUsedID = 0;
 909 
 910     // Generate a new ID.
 911     AXID objID = lastUsedID;
 912     do {
 913         ++objID;
 914     } while (!objID || HashTraits&lt;AXID&gt;::isDeletedValue(objID) || m_idsInUse.contains(objID));
 915 
 916     lastUsedID = objID;
 917 
 918     return objID;
 919 }
 920 #endif
 921 
 922 AXID AXObjectCache::getAXID(AccessibilityObject* obj)
 923 {
 924     // check for already-assigned ID
 925     AXID objID = obj-&gt;objectID();
 926     if (objID) {
 927         ASSERT(m_idsInUse.contains(objID));
 928         return objID;
 929     }
 930 
 931     objID = platformGenerateAXID();
 932 
 933     m_idsInUse.add(objID);
 934     obj-&gt;setObjectID(objID);
 935 
 936     return objID;
 937 }
 938 
 939 void AXObjectCache::textChanged(Node* node)
 940 {
 941     textChanged(getOrCreate(node));
 942 }
 943 
 944 void AXObjectCache::textChanged(AccessibilityObject* obj)
 945 {
 946     if (!obj)
 947         return;
 948 
 949     bool parentAlreadyExists = obj-&gt;parentObjectIfExists();
 950     obj-&gt;textChanged();
 951     postNotification(obj, obj-&gt;document(), AXObjectCache::AXTextChanged);
 952     if (parentAlreadyExists)
 953         obj-&gt;notifyIfIgnoredValueChanged();
 954 }
 955 
 956 void AXObjectCache::updateCacheAfterNodeIsAttached(Node* node)
 957 {
 958     // Calling get() will update the AX object if we had an AccessibilityNodeObject but now we need
 959     // an AccessibilityRenderObject, because it was reparented to a location outside of a canvas.
 960     get(node);
 961 }
 962 
 963 void AXObjectCache::handleMenuOpened(Node* node)
 964 {
 965     if (!node || !node-&gt;renderer() || !nodeHasRole(node, &quot;menu&quot;))
 966         return;
 967 
 968     postNotification(getOrCreate(node), &amp;document(), AXMenuOpened);
 969 }
 970 
 971 void AXObjectCache::handleLiveRegionCreated(Node* node)
 972 {
 973     if (!is&lt;Element&gt;(node) || !node-&gt;renderer())
 974         return;
 975 
 976     Element* element = downcast&lt;Element&gt;(node);
 977     String liveRegionStatus = element-&gt;attributeWithoutSynchronization(aria_liveAttr);
 978     if (liveRegionStatus.isEmpty()) {
 979         const AtomString&amp; ariaRole = element-&gt;attributeWithoutSynchronization(roleAttr);
 980         if (!ariaRole.isEmpty())
 981             liveRegionStatus = AccessibilityObject::defaultLiveRegionStatusForRole(AccessibilityObject::ariaRoleToWebCoreRole(ariaRole));
 982     }
 983 
 984     if (AccessibilityObject::liveRegionStatusIsEnabled(liveRegionStatus))
 985         postNotification(getOrCreate(node), &amp;document(), AXLiveRegionCreated);
 986 }
 987 
 988 void AXObjectCache::childrenChanged(Node* node, Node* newChild)
 989 {
 990     if (newChild)
 991         m_deferredChildrenChangedNodeList.add(newChild);
 992 
 993     childrenChanged(get(node));
 994 }
 995 
 996 void AXObjectCache::childrenChanged(RenderObject* renderer, RenderObject* newChild)
 997 {
 998     if (!renderer)
 999         return;
1000 
1001     if (newChild &amp;&amp; newChild-&gt;node())
1002         m_deferredChildrenChangedNodeList.add(newChild-&gt;node());
1003 
1004     childrenChanged(get(renderer));
1005 }
1006 
1007 void AXObjectCache::childrenChanged(AXCoreObject* obj)
1008 {
1009     if (!obj)
1010         return;
1011 
1012     m_deferredChildrenChangedList.add(obj);
1013 }
1014 
1015 void AXObjectCache::notificationPostTimerFired()
1016 {
1017     Ref&lt;Document&gt; protectorForCacheOwner(m_document);
1018     m_notificationPostTimer.stop();
1019 
1020     // In tests, posting notifications has a tendency to immediately queue up other notifications, which can lead to unexpected behavior
1021     // when the notification list is cleared at the end. Instead copy this list at the start.
1022     auto notifications = WTFMove(m_notificationsToPost);
1023 
1024     for (const auto&amp; note : notifications) {
1025         AXCoreObject* obj = note.first.get();
1026         if (!obj-&gt;objectID())
1027             continue;
1028 
1029         if (!obj-&gt;axObjectCache())
1030             continue;
1031 
1032 #ifndef NDEBUG
1033         // Make sure none of the render views are in the process of being layed out.
1034         // Notifications should only be sent after the renderer has finished
1035         if (is&lt;AccessibilityRenderObject&gt;(*obj)) {
1036             if (auto* renderer = downcast&lt;AccessibilityRenderObject&gt;(*obj).renderer())
1037                 ASSERT(!renderer-&gt;view().frameView().layoutContext().layoutState());
1038         }
1039 #endif
1040 
1041         AXNotification notification = note.second;
1042 
1043         // Ensure that this menu really is a menu. We do this check here so that we don&#39;t have to create
1044         // the axChildren when the menu is marked as opening.
1045         if (notification == AXMenuOpened) {
1046             obj-&gt;updateChildrenIfNecessary();
1047             if (obj-&gt;roleValue() != AccessibilityRole::Menu)
1048                 continue;
1049         }
1050 
1051         postPlatformNotification(obj, notification);
1052 
1053         if (notification == AXChildrenChanged &amp;&amp; obj-&gt;parentObjectIfExists() &amp;&amp; obj-&gt;lastKnownIsIgnoredValue() != obj-&gt;accessibilityIsIgnored())
1054             childrenChanged(obj-&gt;parentObject());
1055     }
1056 }
1057 
1058 void AXObjectCache::passwordNotificationPostTimerFired()
1059 {
1060 #if PLATFORM(COCOA)
1061     m_passwordNotificationPostTimer.stop();
1062 
1063     // In tests, posting notifications has a tendency to immediately queue up other notifications, which can lead to unexpected behavior
1064     // when the notification list is cleared at the end. Instead copy this list at the start.
1065     auto notifications = WTFMove(m_passwordNotificationsToPost);
1066 
1067     for (auto&amp; notification : notifications)
1068         postTextStateChangePlatformNotification(notification.get(), AXTextEditTypeInsert, &quot; &quot;, VisiblePosition());
1069 #endif
1070 }
1071 
1072 void AXObjectCache::postNotification(RenderObject* renderer, AXNotification notification, PostTarget postTarget, PostType postType)
1073 {
1074     if (!renderer)
1075         return;
1076 
1077     stopCachingComputedObjectAttributes();
1078 
1079     // Get an accessibility object that already exists. One should not be created here
1080     // because a render update may be in progress and creating an AX object can re-trigger a layout
1081     RefPtr&lt;AccessibilityObject&gt; object = get(renderer);
1082     while (!object &amp;&amp; renderer) {
1083         renderer = renderer-&gt;parent();
1084         object = get(renderer);
1085     }
1086 
1087     if (!renderer)
1088         return;
1089 
1090     postNotification(object.get(), &amp;renderer-&gt;document(), notification, postTarget, postType);
1091 }
1092 
1093 void AXObjectCache::postNotification(Node* node, AXNotification notification, PostTarget postTarget, PostType postType)
1094 {
1095     if (!node)
1096         return;
1097 
1098     stopCachingComputedObjectAttributes();
1099 
1100     // Get an accessibility object that already exists. One should not be created here
1101     // because a render update may be in progress and creating an AX object can re-trigger a layout
1102     RefPtr&lt;AccessibilityObject&gt; object = get(node);
1103     while (!object &amp;&amp; node) {
1104         node = node-&gt;parentNode();
1105         object = get(node);
1106     }
1107 
1108     if (!node)
1109         return;
1110 
1111     postNotification(object.get(), &amp;node-&gt;document(), notification, postTarget, postType);
1112 }
1113 
1114 void AXObjectCache::postNotification(AXCoreObject* object, Document* document, AXNotification notification, PostTarget postTarget, PostType postType)
1115 {
1116     stopCachingComputedObjectAttributes();
1117 
1118     if (object &amp;&amp; postTarget == TargetObservableParent)
1119         object = object-&gt;observableObject();
1120 
1121     if (!object &amp;&amp; document)
1122         object = get(document-&gt;renderView());
1123 
1124     if (!object)
1125         return;
1126 
1127     if (postType == PostAsynchronously) {
1128         m_notificationsToPost.append(std::make_pair(object, notification));
1129         if (!m_notificationPostTimer.isActive())
1130             m_notificationPostTimer.startOneShot(0_s);
1131     } else
1132         postPlatformNotification(object, notification);
1133 }
1134 
1135 void AXObjectCache::checkedStateChanged(Node* node)
1136 {
1137     postNotification(node, AXObjectCache::AXCheckedStateChanged);
1138 }
1139 
1140 void AXObjectCache::handleMenuItemSelected(Node* node)
1141 {
1142     if (!node)
1143         return;
1144 
1145     if (!nodeHasRole(node, &quot;menuitem&quot;) &amp;&amp; !nodeHasRole(node, &quot;menuitemradio&quot;) &amp;&amp; !nodeHasRole(node, &quot;menuitemcheckbox&quot;))
1146         return;
1147 
1148     if (!downcast&lt;Element&gt;(*node).focused() &amp;&amp; !equalLettersIgnoringASCIICase(downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(aria_selectedAttr), &quot;true&quot;))
1149         return;
1150 
1151     postNotification(getOrCreate(node), &amp;document(), AXMenuListItemSelected);
1152 }
1153 
1154 void AXObjectCache::deferFocusedUIElementChangeIfNeeded(Node* oldNode, Node* newNode)
1155 {
1156     if (nodeAndRendererAreValid(newNode) &amp;&amp; rendererNeedsDeferredUpdate(*newNode-&gt;renderer())) {
1157         m_deferredFocusedNodeChange.append({ oldNode, newNode });
1158         if (!newNode-&gt;renderer()-&gt;needsLayout() &amp;&amp; !m_performCacheUpdateTimer.isActive())
1159             m_performCacheUpdateTimer.startOneShot(0_s);
1160     } else
1161         handleFocusedUIElementChanged(oldNode, newNode);
1162 }
1163 
1164 void AXObjectCache::handleFocusedUIElementChanged(Node* oldNode, Node* newNode)
1165 {
1166 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
1167     setIsolatedTreeFocusedObject(newNode);
1168 #endif
1169 
1170     handleMenuItemSelected(newNode);
1171     platformHandleFocusedUIElementChanged(oldNode, newNode);
1172 }
1173 
1174 void AXObjectCache::selectedChildrenChanged(Node* node)
1175 {
1176     handleMenuItemSelected(node);
1177 
1178     // postTarget is TargetObservableParent so that you can pass in any child of an element and it will go up the parent tree
1179     // to find the container which should send out the notification.
1180     postNotification(node, AXSelectedChildrenChanged, TargetObservableParent);
1181 }
1182 
1183 void AXObjectCache::selectedChildrenChanged(RenderObject* renderer)
1184 {
1185     if (renderer)
1186         handleMenuItemSelected(renderer-&gt;node());
1187 
1188     // postTarget is TargetObservableParent so that you can pass in any child of an element and it will go up the parent tree
1189     // to find the container which should send out the notification.
1190     postNotification(renderer, AXSelectedChildrenChanged, TargetObservableParent);
1191 }
1192 
1193 #ifndef NDEBUG
1194 void AXObjectCache::showIntent(const AXTextStateChangeIntent &amp;intent)
1195 {
1196     switch (intent.type) {
1197     case AXTextStateChangeTypeUnknown:
1198         dataLog(&quot;Unknown&quot;);
1199         break;
1200     case AXTextStateChangeTypeEdit:
1201         dataLog(&quot;Edit::&quot;);
1202         break;
1203     case AXTextStateChangeTypeSelectionMove:
1204         dataLog(&quot;Move::&quot;);
1205         break;
1206     case AXTextStateChangeTypeSelectionExtend:
1207         dataLog(&quot;Extend::&quot;);
1208         break;
1209     case AXTextStateChangeTypeSelectionBoundary:
1210         dataLog(&quot;Boundary::&quot;);
1211         break;
1212     }
1213     switch (intent.type) {
1214     case AXTextStateChangeTypeUnknown:
1215         break;
1216     case AXTextStateChangeTypeEdit:
1217         switch (intent.change) {
1218         case AXTextEditTypeUnknown:
1219             dataLog(&quot;Unknown&quot;);
1220             break;
1221         case AXTextEditTypeDelete:
1222             dataLog(&quot;Delete&quot;);
1223             break;
1224         case AXTextEditTypeInsert:
1225             dataLog(&quot;Insert&quot;);
1226             break;
1227         case AXTextEditTypeDictation:
1228             dataLog(&quot;DictationInsert&quot;);
1229             break;
1230         case AXTextEditTypeTyping:
1231             dataLog(&quot;TypingInsert&quot;);
1232             break;
1233         case AXTextEditTypeCut:
1234             dataLog(&quot;Cut&quot;);
1235             break;
1236         case AXTextEditTypePaste:
1237             dataLog(&quot;Paste&quot;);
1238             break;
1239         case AXTextEditTypeAttributesChange:
1240             dataLog(&quot;AttributesChange&quot;);
1241             break;
1242         }
1243         break;
1244     case AXTextStateChangeTypeSelectionMove:
1245     case AXTextStateChangeTypeSelectionExtend:
1246     case AXTextStateChangeTypeSelectionBoundary:
1247         switch (intent.selection.direction) {
1248         case AXTextSelectionDirectionUnknown:
1249             dataLog(&quot;Unknown::&quot;);
1250             break;
1251         case AXTextSelectionDirectionBeginning:
1252             dataLog(&quot;Beginning::&quot;);
1253             break;
1254         case AXTextSelectionDirectionEnd:
1255             dataLog(&quot;End::&quot;);
1256             break;
1257         case AXTextSelectionDirectionPrevious:
1258             dataLog(&quot;Previous::&quot;);
1259             break;
1260         case AXTextSelectionDirectionNext:
1261             dataLog(&quot;Next::&quot;);
1262             break;
1263         case AXTextSelectionDirectionDiscontiguous:
1264             dataLog(&quot;Discontiguous::&quot;);
1265             break;
1266         }
1267         switch (intent.selection.direction) {
1268         case AXTextSelectionDirectionUnknown:
1269         case AXTextSelectionDirectionBeginning:
1270         case AXTextSelectionDirectionEnd:
1271         case AXTextSelectionDirectionPrevious:
1272         case AXTextSelectionDirectionNext:
1273             switch (intent.selection.granularity) {
1274             case AXTextSelectionGranularityUnknown:
1275                 dataLog(&quot;Unknown&quot;);
1276                 break;
1277             case AXTextSelectionGranularityCharacter:
1278                 dataLog(&quot;Character&quot;);
1279                 break;
1280             case AXTextSelectionGranularityWord:
1281                 dataLog(&quot;Word&quot;);
1282                 break;
1283             case AXTextSelectionGranularityLine:
1284                 dataLog(&quot;Line&quot;);
1285                 break;
1286             case AXTextSelectionGranularitySentence:
1287                 dataLog(&quot;Sentence&quot;);
1288                 break;
1289             case AXTextSelectionGranularityParagraph:
1290                 dataLog(&quot;Paragraph&quot;);
1291                 break;
1292             case AXTextSelectionGranularityPage:
1293                 dataLog(&quot;Page&quot;);
1294                 break;
1295             case AXTextSelectionGranularityDocument:
1296                 dataLog(&quot;Document&quot;);
1297                 break;
1298             case AXTextSelectionGranularityAll:
1299                 dataLog(&quot;All&quot;);
1300                 break;
1301             }
1302             break;
1303         case AXTextSelectionDirectionDiscontiguous:
1304             break;
1305         }
1306         break;
1307     }
1308     dataLog(&quot;\n&quot;);
1309 }
1310 #endif
1311 
1312 void AXObjectCache::setTextSelectionIntent(const AXTextStateChangeIntent&amp; intent)
1313 {
1314     m_textSelectionIntent = intent;
1315 }
1316 
1317 void AXObjectCache::setIsSynchronizingSelection(bool isSynchronizing)
1318 {
1319     m_isSynchronizingSelection = isSynchronizing;
1320 }
1321 
1322 static bool isPasswordFieldOrContainedByPasswordField(AccessibilityObject* object)
1323 {
1324     return object &amp;&amp; (object-&gt;isPasswordField() || object-&gt;isContainedByPasswordField());
1325 }
1326 
1327 void AXObjectCache::postTextStateChangeNotification(Node* node, const AXTextStateChangeIntent&amp; intent, const VisibleSelection&amp; selection)
1328 {
1329     if (!node)
1330         return;
1331 
1332 #if PLATFORM(COCOA)
1333     stopCachingComputedObjectAttributes();
1334 
1335     postTextStateChangeNotification(getOrCreate(node), intent, selection);
1336 #else
1337     postNotification(node-&gt;renderer(), AXObjectCache::AXSelectedTextChanged, TargetObservableParent);
1338     UNUSED_PARAM(intent);
1339     UNUSED_PARAM(selection);
1340 #endif
1341 }
1342 
1343 void AXObjectCache::postTextStateChangeNotification(const Position&amp; position, const AXTextStateChangeIntent&amp; intent, const VisibleSelection&amp; selection)
1344 {
1345     Node* node = position.deprecatedNode();
1346     if (!node)
1347         return;
1348 
1349     stopCachingComputedObjectAttributes();
1350 
1351 #if PLATFORM(COCOA)
1352     AccessibilityObject* object = getOrCreate(node);
1353     if (object &amp;&amp; object-&gt;accessibilityIsIgnored()) {
1354         if (position.atLastEditingPositionForNode()) {
1355             if (AccessibilityObject* nextSibling = object-&gt;nextSiblingUnignored(1))
1356                 object = nextSibling;
1357         } else if (position.atFirstEditingPositionForNode()) {
1358             if (AccessibilityObject* previousSibling = object-&gt;previousSiblingUnignored(1))
1359                 object = previousSibling;
1360         }
1361     }
1362 
1363     postTextStateChangeNotification(object, intent, selection);
1364 #else
1365     postTextStateChangeNotification(node, intent, selection);
1366 #endif
1367 }
1368 
1369 void AXObjectCache::postTextStateChangeNotification(AccessibilityObject* object, const AXTextStateChangeIntent&amp; intent, const VisibleSelection&amp; selection)
1370 {
1371     stopCachingComputedObjectAttributes();
1372 
1373 #if PLATFORM(COCOA)
1374     if (object) {
1375         if (isPasswordFieldOrContainedByPasswordField(object))
1376             return;
1377 
1378         if (auto observableObject = object-&gt;observableObject())
1379             object = observableObject;
1380     }
1381 
1382     const AXTextStateChangeIntent&amp; newIntent = (intent.type == AXTextStateChangeTypeUnknown || (m_isSynchronizingSelection &amp;&amp; m_textSelectionIntent.type != AXTextStateChangeTypeUnknown)) ? m_textSelectionIntent : intent;
1383     postTextStateChangePlatformNotification(object, newIntent, selection);
1384 #else
1385     UNUSED_PARAM(object);
1386     UNUSED_PARAM(intent);
1387     UNUSED_PARAM(selection);
1388 #endif
1389 
1390     setTextSelectionIntent(AXTextStateChangeIntent());
1391     setIsSynchronizingSelection(false);
1392 }
1393 
1394 void AXObjectCache::postTextStateChangeNotification(Node* node, AXTextEditType type, const String&amp; text, const VisiblePosition&amp; position)
1395 {
1396     if (!node)
1397         return;
1398     if (type == AXTextEditTypeUnknown)
1399         return;
1400 
1401     stopCachingComputedObjectAttributes();
1402 
1403     AccessibilityObject* object = getOrCreate(node);
1404 #if PLATFORM(COCOA)
1405     if (object) {
1406         if (enqueuePasswordValueChangeNotification(object))
1407             return;
1408         object = object-&gt;observableObject();
1409     }
1410 
1411     postTextStateChangePlatformNotification(object, type, text, position);
1412 #else
1413     nodeTextChangePlatformNotification(object, textChangeForEditType(type), position.deepEquivalent().deprecatedEditingOffset(), text);
1414 #endif
1415 }
1416 
1417 void AXObjectCache::postTextReplacementNotification(Node* node, AXTextEditType deletionType, const String&amp; deletedText, AXTextEditType insertionType, const String&amp; insertedText, const VisiblePosition&amp; position)
1418 {
1419     if (!node)
1420         return;
1421     if (deletionType != AXTextEditTypeDelete)
1422         return;
1423     if (!(insertionType == AXTextEditTypeInsert || insertionType == AXTextEditTypeTyping || insertionType == AXTextEditTypeDictation || insertionType == AXTextEditTypePaste))
1424         return;
1425 
1426     stopCachingComputedObjectAttributes();
1427 
1428     AccessibilityObject* object = getOrCreate(node);
1429 #if PLATFORM(COCOA)
1430     if (object) {
1431         if (enqueuePasswordValueChangeNotification(object))
1432             return;
1433         object = object-&gt;observableObject();
1434     }
1435 
1436     postTextReplacementPlatformNotification(object, deletionType, deletedText, insertionType, insertedText, position);
1437 #else
1438     nodeTextChangePlatformNotification(object, textChangeForEditType(deletionType), position.deepEquivalent().deprecatedEditingOffset(), deletedText);
1439     nodeTextChangePlatformNotification(object, textChangeForEditType(insertionType), position.deepEquivalent().deprecatedEditingOffset(), insertedText);
1440 #endif
1441 }
1442 
1443 void AXObjectCache::postTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp; textControl, const String&amp; deletedText, const String&amp; insertedText)
1444 {
1445     stopCachingComputedObjectAttributes();
1446 
1447     AccessibilityObject* object = getOrCreate(&amp;textControl);
1448 #if PLATFORM(COCOA)
1449     if (object) {
1450         if (enqueuePasswordValueChangeNotification(object))
1451             return;
1452         object = object-&gt;observableObject();
1453     }
1454 
1455     postTextReplacementPlatformNotificationForTextControl(object, deletedText, insertedText, textControl);
1456 #else
1457     nodeTextChangePlatformNotification(object, textChangeForEditType(AXTextEditTypeDelete), 0, deletedText);
1458     nodeTextChangePlatformNotification(object, textChangeForEditType(AXTextEditTypeInsert), 0, insertedText);
1459 #endif
1460 }
1461 
1462 bool AXObjectCache::enqueuePasswordValueChangeNotification(AccessibilityObject* object)
1463 {
1464     if (!isPasswordFieldOrContainedByPasswordField(object))
1465         return false;
1466 
1467     AccessibilityObject* observableObject = object-&gt;observableObject();
1468     if (!observableObject) {
1469         ASSERT_NOT_REACHED();
1470         // return true even though the enqueue didn&#39;t happen because this is a password field and caller shouldn&#39;t post a notification
1471         return true;
1472     }
1473 
1474     m_passwordNotificationsToPost.add(observableObject);
1475     if (!m_passwordNotificationPostTimer.isActive())
1476         m_passwordNotificationPostTimer.startOneShot(accessibilityPasswordValueChangeNotificationInterval);
1477 
1478     return true;
1479 }
1480 
1481 void AXObjectCache::frameLoadingEventNotification(Frame* frame, AXLoadingEvent loadingEvent)
1482 {
1483     if (!frame)
1484         return;
1485 
1486     // Delegate on the right platform
1487     RenderView* contentRenderer = frame-&gt;contentRenderer();
1488     if (!contentRenderer)
1489         return;
1490 
1491     AccessibilityObject* obj = getOrCreate(contentRenderer);
1492     frameLoadingEventPlatformNotification(obj, loadingEvent);
1493 }
1494 
1495 void AXObjectCache::postLiveRegionChangeNotification(AccessibilityObject* object)
1496 {
1497     if (m_liveRegionChangedPostTimer.isActive())
1498         m_liveRegionChangedPostTimer.stop();
1499 
1500     if (!m_liveRegionObjectsSet.contains(object))
1501         m_liveRegionObjectsSet.add(object);
1502 
1503     m_liveRegionChangedPostTimer.startOneShot(accessibilityLiveRegionChangedNotificationInterval);
1504 }
1505 
1506 void AXObjectCache::liveRegionChangedNotificationPostTimerFired()
1507 {
1508     m_liveRegionChangedPostTimer.stop();
1509 
1510     if (m_liveRegionObjectsSet.isEmpty())
1511         return;
1512 
1513     for (auto&amp; object : m_liveRegionObjectsSet)
1514         postNotification(object.get(), object-&gt;document(), AXObjectCache::AXLiveRegionChanged);
1515     m_liveRegionObjectsSet.clear();
1516 }
1517 
1518 static AccessibilityObject* firstFocusableChild(AccessibilityObject* obj)
1519 {
1520     if (!obj)
1521         return nullptr;
1522 
1523     for (auto* child = obj-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
1524         if (child-&gt;canSetFocusAttribute())
1525             return child;
1526         if (AccessibilityObject* focusable = firstFocusableChild(child))
1527             return focusable;
1528     }
1529     return nullptr;
1530 }
1531 
1532 void AXObjectCache::focusModalNode()
1533 {
1534     if (m_focusModalNodeTimer.isActive())
1535         m_focusModalNodeTimer.stop();
1536 
1537     m_focusModalNodeTimer.startOneShot(accessibilityFocusModalNodeNotificationInterval);
1538 }
1539 
1540 void AXObjectCache::focusModalNodeTimerFired()
1541 {
1542     if (!m_currentModalNode)
1543         return;
1544 
1545     // Don&#39;t set focus if we are already focusing onto some element within
1546     // the dialog.
1547     if (m_currentModalNode-&gt;contains(document().focusedElement()))
1548         return;
1549 
1550     if (AccessibilityObject* currentModalNodeObject = getOrCreate(m_currentModalNode)) {
1551         if (AccessibilityObject* focusable = firstFocusableChild(currentModalNodeObject))
1552             focusable-&gt;setFocused(true);
1553     }
1554 }
1555 
1556 void AXObjectCache::handleScrollbarUpdate(ScrollView* view)
1557 {
1558     if (!view)
1559         return;
1560 
1561     // We don&#39;t want to create a scroll view from this method, only update an existing one.
1562     if (AccessibilityObject* scrollViewObject = get(view)) {
1563         stopCachingComputedObjectAttributes();
1564         scrollViewObject-&gt;updateChildrenIfNecessary();
1565     }
1566 }
1567 
1568 void AXObjectCache::handleAriaExpandedChange(Node* node)
1569 {
1570     if (AccessibilityObject* obj = get(node))
1571         obj-&gt;handleAriaExpandedChanged();
1572 }
1573 
1574 void AXObjectCache::handleActiveDescendantChanged(Node* node)
1575 {
1576     if (AccessibilityObject* obj = getOrCreate(node))
1577         obj-&gt;handleActiveDescendantChanged();
1578 }
1579 
1580 void AXObjectCache::handleAriaRoleChanged(Node* node)
1581 {
1582     stopCachingComputedObjectAttributes();
1583 
1584     // Don&#39;t make an AX object unless it&#39;s needed
1585     if (AccessibilityObject* obj = get(node)) {
1586         obj-&gt;updateAccessibilityRole();
1587         obj-&gt;notifyIfIgnoredValueChanged();
1588     }
1589 }
1590 
1591 void AXObjectCache::deferAttributeChangeIfNeeded(const QualifiedName&amp; attrName, Element* element)
1592 {
1593     if (nodeAndRendererAreValid(element) &amp;&amp; rendererNeedsDeferredUpdate(*element-&gt;renderer()))
1594         m_deferredAttributeChange.add(element, attrName);
1595     else
1596         handleAttributeChange(attrName, element);
1597 }
1598 
1599 bool AXObjectCache::shouldProcessAttributeChange(const QualifiedName&amp; attrName, Element* element)
1600 {
1601     if (!element)
1602         return false;
1603 
1604     // aria-modal ends up affecting sub-trees that are being shown/hidden so it&#39;s likely that
1605     // an AT would not have accessed this node yet.
1606     if (attrName == aria_modalAttr)
1607         return true;
1608 
1609     // If an AXObject has yet to be created, then there&#39;s no need to process attribute changes.
1610     // Some of these notifications are processed on the parent, so allow that to proceed as well
1611     if (get(element) || get(element-&gt;parentNode()))
1612         return true;
1613 
1614     return false;
1615 }
1616 
1617 void AXObjectCache::handleAttributeChange(const QualifiedName&amp; attrName, Element* element)
1618 {
1619     if (!shouldProcessAttributeChange(attrName, element))
1620         return;
1621 
1622     if (attrName == roleAttr)
1623         handleAriaRoleChanged(element);
1624     else if (attrName == altAttr || attrName == titleAttr)
1625         textChanged(element);
1626     else if (attrName == forAttr &amp;&amp; is&lt;HTMLLabelElement&gt;(*element))
1627         labelChanged(element);
1628     else if (attrName == tabindexAttr)
1629         childrenChanged(element-&gt;parentNode(), element);
1630 
1631     if (!attrName.localName().string().startsWith(&quot;aria-&quot;))
1632         return;
1633 
1634     if (attrName == aria_activedescendantAttr)
1635         handleActiveDescendantChanged(element);
1636     else if (attrName == aria_busyAttr)
1637         postNotification(element, AXObjectCache::AXElementBusyChanged);
1638     else if (attrName == aria_valuenowAttr || attrName == aria_valuetextAttr)
1639         postNotification(element, AXObjectCache::AXValueChanged);
1640     else if (attrName == aria_labelAttr || attrName == aria_labeledbyAttr || attrName == aria_labelledbyAttr)
1641         textChanged(element);
1642     else if (attrName == aria_checkedAttr)
1643         checkedStateChanged(element);
1644     else if (attrName == aria_selectedAttr)
1645         selectedChildrenChanged(element);
1646     else if (attrName == aria_expandedAttr)
1647         handleAriaExpandedChange(element);
1648     else if (attrName == aria_hiddenAttr)
1649         childrenChanged(element-&gt;parentNode(), element);
1650     else if (attrName == aria_invalidAttr)
1651         postNotification(element, AXObjectCache::AXInvalidStatusChanged);
1652     else if (attrName == aria_modalAttr)
1653         handleModalChange(element);
1654     else if (attrName == aria_currentAttr)
1655         postNotification(element, AXObjectCache::AXCurrentChanged);
1656     else if (attrName == aria_disabledAttr)
1657         postNotification(element, AXObjectCache::AXDisabledStateChanged);
1658     else if (attrName == aria_pressedAttr)
1659         postNotification(element, AXObjectCache::AXPressedStateChanged);
1660     else if (attrName == aria_readonlyAttr)
1661         postNotification(element, AXObjectCache::AXReadOnlyStatusChanged);
1662     else if (attrName == aria_requiredAttr)
1663         postNotification(element, AXObjectCache::AXRequiredStatusChanged);
1664     else
1665         postNotification(element, AXObjectCache::AXAriaAttributeChanged);
1666 }
1667 
1668 void AXObjectCache::handleModalChange(Node* node)
1669 {
1670     if (!is&lt;Element&gt;(node))
1671         return;
1672 
1673     if (!nodeHasRole(node, &quot;dialog&quot;) &amp;&amp; !nodeHasRole(node, &quot;alertdialog&quot;))
1674         return;
1675 
1676     stopCachingComputedObjectAttributes();
1677     if (equalLettersIgnoringASCIICase(downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(aria_modalAttr), &quot;true&quot;)) {
1678         // Add the newly modified node to the modal nodes set, and set it to be the current valid aria modal node.
1679         // We will recompute the current valid aria modal node in modalNode() when this node is not visible.
1680         m_modalNodesSet.add(node);
1681         m_currentModalNode = node;
1682     } else {
1683         // Remove the node from the modal nodes set. There might be other visible modal nodes, so we recompute here.
1684         m_modalNodesSet.remove(node);
1685         updateCurrentModalNode();
1686     }
1687     if (m_currentModalNode)
1688         focusModalNode();
1689 
1690     startCachingComputedObjectAttributesUntilTreeMutates();
1691 }
1692 
1693 void AXObjectCache::labelChanged(Element* element)
1694 {
1695     ASSERT(is&lt;HTMLLabelElement&gt;(*element));
1696     auto correspondingControl = downcast&lt;HTMLLabelElement&gt;(*element).control();
1697     deferTextChangedIfNeeded(correspondingControl.get());
1698 }
1699 
1700 void AXObjectCache::recomputeIsIgnored(RenderObject* renderer)
1701 {
1702     if (AccessibilityObject* obj = get(renderer))
1703         obj-&gt;notifyIfIgnoredValueChanged();
1704 }
1705 
1706 void AXObjectCache::startCachingComputedObjectAttributesUntilTreeMutates()
1707 {
1708     if (!m_computedObjectAttributeCache)
1709         m_computedObjectAttributeCache = makeUnique&lt;AXComputedObjectAttributeCache&gt;();
1710 }
1711 
1712 void AXObjectCache::stopCachingComputedObjectAttributes()
1713 {
1714     m_computedObjectAttributeCache = nullptr;
1715 }
1716 
1717 VisiblePosition AXObjectCache::visiblePositionForTextMarkerData(TextMarkerData&amp; textMarkerData)
1718 {
1719     if (!isNodeInUse(textMarkerData.node))
1720         return VisiblePosition();
1721 
1722     // FIXME: Accessability should make it clear these are DOM-compliant offsets or store Position objects.
1723     VisiblePosition visiblePos = VisiblePosition(createLegacyEditingPosition(textMarkerData.node, textMarkerData.offset), textMarkerData.affinity);
1724     Position deepPos = visiblePos.deepEquivalent();
1725     if (deepPos.isNull())
1726         return VisiblePosition();
1727 
1728     RenderObject* renderer = deepPos.deprecatedNode()-&gt;renderer();
1729     if (!renderer)
1730         return VisiblePosition();
1731 
1732     AXObjectCache* cache = renderer-&gt;document().axObjectCache();
1733     if (cache &amp;&amp; !cache-&gt;m_idsInUse.contains(textMarkerData.axID))
1734         return VisiblePosition();
1735 
1736     return visiblePos;
1737 }
1738 
1739 CharacterOffset AXObjectCache::characterOffsetForTextMarkerData(TextMarkerData&amp; textMarkerData)
1740 {
1741     if (!isNodeInUse(textMarkerData.node))
1742         return CharacterOffset();
1743 
1744     if (textMarkerData.ignored)
1745         return CharacterOffset();
1746 
1747     CharacterOffset result = CharacterOffset(textMarkerData.node, textMarkerData.characterStartIndex, textMarkerData.characterOffset);
1748     // When we are at a line wrap and the VisiblePosition is upstream, it means the text marker is at the end of the previous line.
1749     // We use the previous CharacterOffset so that it will match the Range.
1750     if (textMarkerData.affinity == UPSTREAM)
1751         return previousCharacterOffset(result, false);
1752     return result;
1753 }
1754 
1755 CharacterOffset AXObjectCache::traverseToOffsetInRange(RefPtr&lt;Range&gt;range, int offset, TraverseOption option, bool stayWithinRange)
1756 {
1757     if (!range)
1758         return CharacterOffset();
1759 
1760     bool toNodeEnd = option &amp; TraverseOptionToNodeEnd;
1761     bool validateOffset = option &amp; TraverseOptionValidateOffset;
1762     bool doNotEnterTextControls = option &amp; TraverseOptionDoNotEnterTextControls;
1763 
1764     int offsetInCharacter = 0;
1765     int cumulativeOffset = 0;
1766     int remaining = 0;
1767     int lastLength = 0;
1768     Node* currentNode = nullptr;
1769     bool finished = false;
1770     int lastStartOffset = 0;
1771 
1772     TextIterator iterator(range.get(), doNotEnterTextControls ? TextIteratorDefaultBehavior : TextIteratorEntersTextControls);
1773 
1774     // When the range has zero length, there might be replaced node or brTag that we need to increment the characterOffset.
1775     if (iterator.atEnd()) {
1776         currentNode = &amp;range-&gt;startContainer();
1777         lastStartOffset = range-&gt;startOffset();
1778         if (offset &gt; 0 || toNodeEnd) {
1779             if (AccessibilityObject::replacedNodeNeedsCharacter(currentNode) || (currentNode-&gt;renderer() &amp;&amp; currentNode-&gt;renderer()-&gt;isBR()))
1780                 cumulativeOffset++;
1781             lastLength = cumulativeOffset;
1782 
1783             // When going backwards, stayWithinRange is false.
1784             // Here when we don&#39;t have any character to move and we are going backwards, we traverse to the previous node.
1785             if (!lastLength &amp;&amp; toNodeEnd &amp;&amp; !stayWithinRange) {
1786                 if (Node* preNode = previousNode(currentNode))
1787                     return traverseToOffsetInRange(rangeForNodeContents(preNode), offset, option);
1788                 return CharacterOffset();
1789             }
1790         }
1791     }
1792 
1793     // Sometimes text contents in a node are splitted into several iterations, so that iterator.range()-&gt;startOffset()
1794     // might not be the correct character count. Here we use a previousNode object to keep track of that.
1795     Node* previousNode = nullptr;
1796     for (; !iterator.atEnd(); iterator.advance()) {
1797         int currentLength = iterator.text().length();
1798         bool hasReplacedNodeOrBR = false;
1799 
1800         Node&amp; node = iterator.range()-&gt;startContainer();
1801         currentNode = &amp;node;
1802 
1803         // When currentLength == 0, we check if there&#39;s any replaced node.
1804         // If not, we skip the node with no length.
1805         if (!currentLength) {
1806             int subOffset = iterator.range()-&gt;startOffset();
1807             Node* childNode = node.traverseToChildAt(subOffset);
1808             if (AccessibilityObject::replacedNodeNeedsCharacter(childNode)) {
1809                 cumulativeOffset++;
1810                 currentLength++;
1811                 currentNode = childNode;
1812                 hasReplacedNodeOrBR = true;
1813             } else
1814                 continue;
1815         } else {
1816             // Ignore space, new line, tag node.
1817             if (currentLength == 1) {
1818                 if (isHTMLSpace(iterator.text()[0])) {
1819                     // If the node has BR tag, we want to set the currentNode to it.
1820                     int subOffset = iterator.range()-&gt;startOffset();
1821                     Node* childNode = node.traverseToChildAt(subOffset);
1822                     if (childNode &amp;&amp; childNode-&gt;renderer() &amp;&amp; childNode-&gt;renderer()-&gt;isBR()) {
1823                         currentNode = childNode;
1824                         hasReplacedNodeOrBR = true;
1825                     } else if (auto* shadowHost = currentNode-&gt;shadowHost()) {
1826                         // Since we are entering text controls, we should set the currentNode
1827                         // to be the shadow host when there&#39;s no content.
1828                         if (nodeIsTextControl(shadowHost) &amp;&amp; currentNode-&gt;isShadowRoot()) {
1829                             currentNode = shadowHost;
1830                             continue;
1831                         }
1832                     } else if (previousNode &amp;&amp; previousNode-&gt;isTextNode() &amp;&amp; previousNode-&gt;isDescendantOf(currentNode) &amp;&amp; currentNode-&gt;hasTagName(pTag)) {
1833                         // TextIterator is emitting an extra newline after the &lt;p&gt; element. We should
1834                         // ignore that since the extra text node is not in the DOM tree.
1835                         currentNode = previousNode;
1836                         continue;
1837                     } else if (currentNode != previousNode) {
1838                         // We should set the start offset and length for the current node in case this is the last iteration.
1839                         lastStartOffset = 1;
1840                         lastLength = 0;
1841                         continue;
1842                     }
1843                 }
1844             }
1845             cumulativeOffset += currentLength;
1846         }
1847 
1848         if (currentNode == previousNode) {
1849             lastLength += currentLength;
1850             lastStartOffset = iterator.range()-&gt;endOffset() - lastLength;
1851         }
1852         else {
1853             lastLength = currentLength;
1854             lastStartOffset = hasReplacedNodeOrBR ? 0 : iterator.range()-&gt;startOffset();
1855         }
1856 
1857         // Break early if we have advanced enough characters.
1858         bool offsetLimitReached = validateOffset ? cumulativeOffset + lastStartOffset &gt;= offset : cumulativeOffset &gt;= offset;
1859         if (!toNodeEnd &amp;&amp; offsetLimitReached) {
1860             offsetInCharacter = validateOffset ? std::max(offset - lastStartOffset, 0) : offset - (cumulativeOffset - lastLength);
1861             finished = true;
1862             break;
1863         }
1864         previousNode = currentNode;
1865     }
1866 
1867     if (!finished) {
1868         offsetInCharacter = lastLength;
1869         if (!toNodeEnd)
1870             remaining = offset - cumulativeOffset;
1871     }
1872 
1873     // Sometimes when we are getting the end CharacterOffset of a line range, the TextIterator will emit an extra space at the end
1874     // and make the character count greater than the Range&#39;s end offset.
1875     if (toNodeEnd &amp;&amp; currentNode-&gt;isTextNode() &amp;&amp; currentNode == &amp;range-&gt;endContainer() &amp;&amp; static_cast&lt;int&gt;(range-&gt;endOffset()) &lt; lastStartOffset + offsetInCharacter)
1876         offsetInCharacter = range-&gt;endOffset() - lastStartOffset;
1877 
1878     return CharacterOffset(currentNode, lastStartOffset, offsetInCharacter, remaining);
1879 }
1880 
1881 int AXObjectCache::lengthForRange(Range* range)
1882 {
1883     if (!range)
1884         return -1;
1885 
1886     int length = 0;
1887     for (TextIterator it(range); !it.atEnd(); it.advance()) {
1888         // non-zero length means textual node, zero length means replaced node (AKA &quot;attachments&quot; in AX)
1889         if (it.text().length())
1890             length += it.text().length();
1891         else {
1892             // locate the node and starting offset for this replaced range
1893             Node&amp; node = it.range()-&gt;startContainer();
1894             int offset = it.range()-&gt;startOffset();
1895             if (AccessibilityObject::replacedNodeNeedsCharacter(node.traverseToChildAt(offset)))
1896                 ++length;
1897         }
1898     }
1899 
1900     return length;
1901 }
1902 
1903 RefPtr&lt;Range&gt; AXObjectCache::rangeForNodeContents(Node* node)
1904 {
1905     if (!node)
1906         return nullptr;
1907     Document* document = &amp;node-&gt;document();
1908     if (!document)
1909         return nullptr;
1910     auto range = Range::create(*document);
1911     if (AccessibilityObject::replacedNodeNeedsCharacter(node)) {
1912         // For replaced nodes without children, the node itself is included in the range.
1913         if (range-&gt;selectNode(*node).hasException())
1914             return nullptr;
1915     } else {
1916         if (range-&gt;selectNodeContents(*node).hasException())
1917             return nullptr;
1918     }
1919     return range;
1920 }
1921 
1922 RefPtr&lt;Range&gt; AXObjectCache::rangeMatchesTextNearRange(RefPtr&lt;Range&gt; originalRange, const String&amp; matchText)
1923 {
1924     if (!originalRange)
1925         return nullptr;
1926 
1927     // Create a large enough range for searching the text within.
1928     unsigned textLength = matchText.length();
1929     auto startPosition = visiblePositionForPositionWithOffset(originalRange-&gt;startPosition(), -textLength);
1930     auto endPosition = visiblePositionForPositionWithOffset(originalRange-&gt;startPosition(), 2 * textLength);
1931 
1932     if (startPosition.isNull())
1933         startPosition = firstPositionInOrBeforeNode(&amp;originalRange-&gt;startContainer());
1934     if (endPosition.isNull())
1935         endPosition = lastPositionInOrAfterNode(&amp;originalRange-&gt;endContainer());
1936 
1937     auto searchRange = Range::create(m_document, startPosition, endPosition);
1938     if (searchRange-&gt;collapsed())
1939         return nullptr;
1940 
1941     auto range = Range::create(m_document, startPosition, originalRange-&gt;startPosition());
1942     unsigned targetOffset = TextIterator::rangeLength(range.ptr(), true);
1943     return findClosestPlainText(searchRange.get(), matchText, { }, targetOffset);
1944 }
1945 
1946 static bool isReplacedNodeOrBR(Node* node)
1947 {
1948     return node &amp;&amp; (AccessibilityObject::replacedNodeNeedsCharacter(node) || node-&gt;hasTagName(brTag));
1949 }
1950 
1951 static bool characterOffsetsInOrder(const CharacterOffset&amp; characterOffset1, const CharacterOffset&amp; characterOffset2)
1952 {
1953     if (characterOffset1.isNull() || characterOffset2.isNull())
1954         return false;
1955 
1956     if (characterOffset1.node == characterOffset2.node)
1957         return characterOffset1.offset &lt;= characterOffset2.offset;
1958 
1959     Node* node1 = characterOffset1.node;
1960     Node* node2 = characterOffset2.node;
1961     if (!node1-&gt;isCharacterDataNode() &amp;&amp; !isReplacedNodeOrBR(node1) &amp;&amp; node1-&gt;hasChildNodes())
1962         node1 = node1-&gt;traverseToChildAt(characterOffset1.offset);
1963     if (!node2-&gt;isCharacterDataNode() &amp;&amp; !isReplacedNodeOrBR(node2) &amp;&amp; node2-&gt;hasChildNodes())
1964         node2 = node2-&gt;traverseToChildAt(characterOffset2.offset);
1965 
1966     if (!node1 || !node2)
1967         return false;
1968 
1969     RefPtr&lt;Range&gt; range1 = AXObjectCache::rangeForNodeContents(node1);
1970     RefPtr&lt;Range&gt; range2 = AXObjectCache::rangeForNodeContents(node2);
1971 
1972     if (!range2)
1973         return true;
1974     if (!range1)
1975         return false;
1976     auto result = range1-&gt;compareBoundaryPoints(Range::START_TO_START, *range2);
1977     if (result.hasException())
1978         return true;
1979     return result.releaseReturnValue() &lt;= 0;
1980 }
1981 
1982 static Node* resetNodeAndOffsetForReplacedNode(Node* replacedNode, int&amp; offset, int characterCount)
1983 {
1984     // Use this function to include the replaced node itself in the range we are creating.
1985     if (!replacedNode)
1986         return nullptr;
1987 
1988     RefPtr&lt;Range&gt; nodeRange = AXObjectCache::rangeForNodeContents(replacedNode);
1989     int nodeLength = TextIterator::rangeLength(nodeRange.get());
1990     offset = characterCount &lt;= nodeLength ? replacedNode-&gt;computeNodeIndex() : replacedNode-&gt;computeNodeIndex() + 1;
1991     return replacedNode-&gt;parentNode();
1992 }
1993 
1994 static bool setRangeStartOrEndWithCharacterOffset(Range&amp; range, const CharacterOffset&amp; characterOffset, bool isStart)
1995 {
1996     if (characterOffset.isNull())
1997         return false;
1998 
1999     int offset = characterOffset.startIndex + characterOffset.offset;
2000     Node* node = characterOffset.node;
2001     ASSERT(node);
2002 
2003     bool replacedNodeOrBR = isReplacedNodeOrBR(node);
2004     // For the non text node that has no children, we should create the range with its parent, otherwise the range would be collapsed.
2005     // Example: &lt;div contenteditable=&quot;true&quot;&gt;&lt;/div&gt;, we want the range to include the div element.
2006     bool noChildren = !replacedNodeOrBR &amp;&amp; !node-&gt;isTextNode() &amp;&amp; !node-&gt;hasChildNodes();
2007     int characterCount = noChildren ? (isStart ? 0 : 1) : characterOffset.offset;
2008 
2009     if (replacedNodeOrBR || noChildren)
2010         node = resetNodeAndOffsetForReplacedNode(node, offset, characterCount);
2011 
2012     if (!node)
2013         return false;
2014 
2015     if (isStart) {
2016         if (range.setStart(*node, offset).hasException())
2017             return false;
2018     } else {
2019         if (range.setEnd(*node, offset).hasException())
2020             return false;
2021     }
2022 
2023     return true;
2024 }
2025 
2026 RefPtr&lt;Range&gt; AXObjectCache::rangeForUnorderedCharacterOffsets(const CharacterOffset&amp; characterOffset1, const CharacterOffset&amp; characterOffset2)
2027 {
2028     if (characterOffset1.isNull() || characterOffset2.isNull())
2029         return nullptr;
2030 
2031     bool alreadyInOrder = characterOffsetsInOrder(characterOffset1, characterOffset2);
2032     CharacterOffset startCharacterOffset = alreadyInOrder ? characterOffset1 : characterOffset2;
2033     CharacterOffset endCharacterOffset = alreadyInOrder ? characterOffset2 : characterOffset1;
2034 
2035     auto result = Range::create(m_document);
2036     if (!setRangeStartOrEndWithCharacterOffset(result, startCharacterOffset, true))
2037         return nullptr;
2038     if (!setRangeStartOrEndWithCharacterOffset(result, endCharacterOffset, false))
2039         return nullptr;
2040     return result;
2041 }
2042 
2043 void AXObjectCache::setTextMarkerDataWithCharacterOffset(TextMarkerData&amp; textMarkerData, const CharacterOffset&amp; characterOffset)
2044 {
2045     if (characterOffset.isNull())
2046         return;
2047 
2048     Node* domNode = characterOffset.node;
2049     if (is&lt;HTMLInputElement&gt;(*domNode) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*domNode).isPasswordField()) {
2050         textMarkerData.ignored = true;
2051         return;
2052     }
2053 
2054     RefPtr&lt;AccessibilityObject&gt; obj = this-&gt;getOrCreate(domNode);
2055     if (!obj)
2056         return;
2057 
2058     // Convert to visible position.
2059     VisiblePosition visiblePosition = visiblePositionFromCharacterOffset(characterOffset);
2060     int vpOffset = 0;
2061     if (!visiblePosition.isNull()) {
2062         Position deepPos = visiblePosition.deepEquivalent();
2063         vpOffset = deepPos.deprecatedEditingOffset();
2064     }
2065 
2066     textMarkerData.axID = obj.get()-&gt;objectID();
2067     textMarkerData.node = domNode;
2068     textMarkerData.characterOffset = characterOffset.offset;
2069     textMarkerData.characterStartIndex = characterOffset.startIndex;
2070     textMarkerData.offset = vpOffset;
2071     textMarkerData.affinity = visiblePosition.affinity();
2072 
2073     this-&gt;setNodeInUse(domNode);
2074 }
2075 
2076 CharacterOffset AXObjectCache::startOrEndCharacterOffsetForRange(RefPtr&lt;Range&gt; range, bool isStart, bool enterTextControls)
2077 {
2078     if (!range)
2079         return CharacterOffset();
2080 
2081     // When getting the end CharacterOffset at node boundary, we don&#39;t want to collapse to the previous node.
2082     if (!isStart &amp;&amp; !range-&gt;endOffset())
2083         return characterOffsetForNodeAndOffset(range-&gt;endContainer(), 0, TraverseOptionIncludeStart);
2084 
2085     // If it&#39;s end text marker, we want to go to the end of the range, and stay within the range.
2086     bool stayWithinRange = !isStart;
2087 
2088     Node&amp; endNode = range-&gt;endContainer();
2089     if (endNode.isCharacterDataNode() &amp;&amp; !isStart)
2090         return traverseToOffsetInRange(rangeForNodeContents(&amp;endNode), range-&gt;endOffset(), TraverseOptionValidateOffset);
2091 
2092     Ref&lt;Range&gt; copyRange = *range;
2093     // Change the start of the range, so the character offset starts from node beginning.
2094     int offset = 0;
2095     Node&amp; node = copyRange-&gt;startContainer();
2096     if (node.isCharacterDataNode()) {
2097         CharacterOffset nodeStartOffset = traverseToOffsetInRange(rangeForNodeContents(&amp;node), range-&gt;startOffset(), TraverseOptionValidateOffset);
2098         if (isStart)
2099             return nodeStartOffset;
2100         copyRange = Range::create(range-&gt;ownerDocument(), &amp;range-&gt;startContainer(), 0, &amp;range-&gt;endContainer(), range-&gt;endOffset());
2101         offset += nodeStartOffset.offset;
2102     }
2103 
2104     TraverseOption options = isStart ? TraverseOptionDefault : TraverseOptionToNodeEnd;
2105     if (!enterTextControls)
2106         options = static_cast&lt;TraverseOption&gt;(options | TraverseOptionDoNotEnterTextControls);
2107     return traverseToOffsetInRange(WTFMove(copyRange), offset, options, stayWithinRange);
2108 }
2109 
2110 void AXObjectCache::startOrEndTextMarkerDataForRange(TextMarkerData&amp; textMarkerData, RefPtr&lt;Range&gt; range, bool isStart)
2111 {
2112     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2113     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2114     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2115 
2116     CharacterOffset characterOffset = startOrEndCharacterOffsetForRange(range, isStart);
2117     if (characterOffset.isNull())
2118         return;
2119 
2120     setTextMarkerDataWithCharacterOffset(textMarkerData, characterOffset);
2121 }
2122 
2123 CharacterOffset AXObjectCache::characterOffsetForNodeAndOffset(Node&amp; node, int offset, TraverseOption option)
2124 {
2125     Node* domNode = &amp;node;
2126     if (!domNode)
2127         return CharacterOffset();
2128 
2129     bool toNodeEnd = option &amp; TraverseOptionToNodeEnd;
2130     bool includeStart = option &amp; TraverseOptionIncludeStart;
2131 
2132     // ignoreStart is used to determine if we should go to previous node or
2133     // stay in current node when offset is 0.
2134     if (!toNodeEnd &amp;&amp; (offset &lt; 0 || (!offset &amp;&amp; !includeStart))) {
2135         // Set the offset to the amount of characters we need to go backwards.
2136         offset = - offset;
2137         CharacterOffset charOffset = CharacterOffset();
2138         while (offset &gt;= 0 &amp;&amp; charOffset.offset &lt;= offset) {
2139             offset -= charOffset.offset;
2140             domNode = previousNode(domNode);
2141             if (domNode) {
2142                 charOffset = characterOffsetForNodeAndOffset(*domNode, 0, TraverseOptionToNodeEnd);
2143             } else
2144                 return CharacterOffset();
2145             if (charOffset.offset == offset)
2146                 break;
2147         }
2148         if (offset &gt; 0)
2149             charOffset = characterOffsetForNodeAndOffset(*charOffset.node, charOffset.offset - offset, TraverseOptionIncludeStart);
2150         return charOffset;
2151     }
2152 
2153     RefPtr&lt;Range&gt; range = rangeForNodeContents(domNode);
2154 
2155     // Traverse the offset amount of characters forward and see if there&#39;s remaining offsets.
2156     // Keep traversing to the next node when there&#39;s remaining offsets.
2157     CharacterOffset characterOffset = traverseToOffsetInRange(range, offset, option);
2158     while (!characterOffset.isNull() &amp;&amp; characterOffset.remaining() &amp;&amp; !toNodeEnd) {
2159         domNode = nextNode(domNode);
2160         if (!domNode)
2161             return CharacterOffset();
2162         range = rangeForNodeContents(domNode);
2163         characterOffset = traverseToOffsetInRange(range, characterOffset.remaining(), option);
2164     }
2165 
2166     return characterOffset;
2167 }
2168 
2169 void AXObjectCache::textMarkerDataForCharacterOffset(TextMarkerData&amp; textMarkerData, const CharacterOffset&amp; characterOffset)
2170 {
2171     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2172     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2173     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2174 
2175     setTextMarkerDataWithCharacterOffset(textMarkerData, characterOffset);
2176 }
2177 
2178 bool AXObjectCache::shouldSkipBoundary(const CharacterOffset&amp; previous, const CharacterOffset&amp; next)
2179 {
2180     // Match the behavior of VisiblePosition, we should skip the node boundary when there&#39;s no visual space or new line character.
2181     if (previous.isNull() || next.isNull())
2182         return false;
2183 
2184     if (previous.node == next.node)
2185         return false;
2186 
2187     if (next.startIndex &gt; 0 || next.offset &gt; 0)
2188         return false;
2189 
2190     CharacterOffset newLine = startCharacterOffsetOfLine(next);
2191     if (next.isEqual(newLine))
2192         return false;
2193 
2194     return true;
2195 }
2196 
2197 void AXObjectCache::textMarkerDataForNextCharacterOffset(TextMarkerData&amp; textMarkerData, const CharacterOffset&amp; characterOffset)
2198 {
2199     CharacterOffset next = characterOffset;
2200     CharacterOffset previous = characterOffset;
2201     bool shouldContinue;
2202     do {
2203         shouldContinue = false;
2204         next = nextCharacterOffset(next, false);
2205         if (shouldSkipBoundary(previous, next))
2206             next = nextCharacterOffset(next, false);
2207         textMarkerDataForCharacterOffset(textMarkerData, next);
2208 
2209         // We should skip next CharactetOffset if it&#39;s visually the same.
2210         if (!lengthForRange(rangeForUnorderedCharacterOffsets(previous, next).get()))
2211             shouldContinue = true;
2212         previous = next;
2213     } while (textMarkerData.ignored || shouldContinue);
2214 }
2215 
2216 void AXObjectCache::textMarkerDataForPreviousCharacterOffset(TextMarkerData&amp; textMarkerData, const CharacterOffset&amp; characterOffset)
2217 {
2218     CharacterOffset previous = characterOffset;
2219     CharacterOffset next = characterOffset;
2220     bool shouldContinue;
2221     do {
2222         shouldContinue = false;
2223         previous = previousCharacterOffset(previous, false);
2224         textMarkerDataForCharacterOffset(textMarkerData, previous);
2225 
2226         // We should skip previous CharactetOffset if it&#39;s visually the same.
2227         if (!lengthForRange(rangeForUnorderedCharacterOffsets(previous, next).get()))
2228             shouldContinue = true;
2229         next = previous;
2230     } while (textMarkerData.ignored || shouldContinue);
2231 }
2232 
2233 Node* AXObjectCache::nextNode(Node* node) const
2234 {
2235     if (!node)
2236         return nullptr;
2237 
2238     return NodeTraversal::nextSkippingChildren(*node);
2239 }
2240 
2241 Node* AXObjectCache::previousNode(Node* node) const
2242 {
2243     if (!node)
2244         return nullptr;
2245 
2246     // First child of body shouldn&#39;t have previous node.
2247     if (node-&gt;parentNode() &amp;&amp; node-&gt;parentNode()-&gt;renderer() &amp;&amp; node-&gt;parentNode()-&gt;renderer()-&gt;isBody() &amp;&amp; !node-&gt;previousSibling())
2248         return nullptr;
2249 
2250     return NodeTraversal::previousSkippingChildren(*node);
2251 }
2252 
2253 VisiblePosition AXObjectCache::visiblePositionFromCharacterOffset(const CharacterOffset&amp; characterOffset)
2254 {
2255     if (characterOffset.isNull())
2256         return VisiblePosition();
2257 
2258     // Create a collapsed range and use that to form a VisiblePosition, so that the case with
2259     // composed characters will be covered.
2260     auto range = rangeForUnorderedCharacterOffsets(characterOffset, characterOffset);
2261     return range ? VisiblePosition(range-&gt;startPosition()) : VisiblePosition();
2262 }
2263 
2264 CharacterOffset AXObjectCache::characterOffsetFromVisiblePosition(const VisiblePosition&amp; visiblePos)
2265 {
2266     if (visiblePos.isNull())
2267         return CharacterOffset();
2268 
2269     Position deepPos = visiblePos.deepEquivalent();
2270     Node* domNode = deepPos.deprecatedNode();
2271     ASSERT(domNode);
2272 
2273     if (domNode-&gt;isCharacterDataNode())
2274         return traverseToOffsetInRange(rangeForNodeContents(domNode), deepPos.deprecatedEditingOffset(), TraverseOptionValidateOffset);
2275 
2276     RefPtr&lt;AccessibilityObject&gt; obj = this-&gt;getOrCreate(domNode);
2277     if (!obj)
2278         return CharacterOffset();
2279 
2280     // Use nextVisiblePosition to calculate how many characters we need to traverse to the current position.
2281     VisiblePositionRange visiblePositionRange = obj-&gt;visiblePositionRange();
2282     VisiblePosition visiblePosition = visiblePositionRange.start;
2283     int characterOffset = 0;
2284     Position currentPosition = visiblePosition.deepEquivalent();
2285 
2286     VisiblePosition previousVisiblePos;
2287     while (!currentPosition.isNull() &amp;&amp; !deepPos.equals(currentPosition)) {
2288         previousVisiblePos = visiblePosition;
2289         visiblePosition = obj-&gt;nextVisiblePosition(visiblePosition);
2290         currentPosition = visiblePosition.deepEquivalent();
2291         Position previousPosition = previousVisiblePos.deepEquivalent();
2292         // Sometimes nextVisiblePosition will give the same VisiblePostion,
2293         // we break here to avoid infinite loop.
2294         if (currentPosition.equals(previousPosition))
2295             break;
2296         characterOffset++;
2297 
2298         // When VisiblePostion moves to next node, it will count the leading line break as
2299         // 1 offset, which we shouldn&#39;t include in CharacterOffset.
2300         if (currentPosition.deprecatedNode() != previousPosition.deprecatedNode()) {
2301             if (visiblePosition.characterBefore() == &#39;\n&#39;)
2302                 characterOffset--;
2303         } else {
2304             // Sometimes VisiblePosition will move multiple characters, like emoji.
2305             if (currentPosition.deprecatedNode()-&gt;isCharacterDataNode())
2306                 characterOffset += currentPosition.offsetInContainerNode() - previousPosition.offsetInContainerNode() - 1;
2307         }
2308     }
2309 
2310     // Sometimes when the node is a replaced node and is ignored in accessibility, we get a wrong CharacterOffset from it.
2311     CharacterOffset result = traverseToOffsetInRange(rangeForNodeContents(obj-&gt;node()), characterOffset);
2312     if (result.remainingOffset &gt; 0 &amp;&amp; !result.isNull() &amp;&amp; isRendererReplacedElement(result.node-&gt;renderer()))
2313         result.offset += result.remainingOffset;
2314     return result;
2315 }
2316 
2317 AccessibilityObject* AXObjectCache::accessibilityObjectForTextMarkerData(TextMarkerData&amp; textMarkerData)
2318 {
2319     if (!isNodeInUse(textMarkerData.node))
2320         return nullptr;
2321 
2322     Node* domNode = textMarkerData.node;
2323     return this-&gt;getOrCreate(domNode);
2324 }
2325 
2326 Optional&lt;TextMarkerData&gt; AXObjectCache::textMarkerDataForVisiblePosition(const VisiblePosition&amp; visiblePos)
2327 {
2328     if (visiblePos.isNull())
2329         return WTF::nullopt;
2330 
2331     Position deepPos = visiblePos.deepEquivalent();
2332     Node* domNode = deepPos.deprecatedNode();
2333     ASSERT(domNode);
2334     if (!domNode)
2335         return WTF::nullopt;
2336 
2337     if (is&lt;HTMLInputElement&gt;(*domNode) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*domNode).isPasswordField())
2338         return WTF::nullopt;
2339 
2340     // If the visible position has an anchor type referring to a node other than the anchored node, we should
2341     // set the text marker data with CharacterOffset so that the offset will correspond to the node.
2342     CharacterOffset characterOffset = characterOffsetFromVisiblePosition(visiblePos);
2343     if (deepPos.anchorType() == Position::PositionIsAfterAnchor || deepPos.anchorType() == Position::PositionIsAfterChildren) {
2344         TextMarkerData textMarkerData;
2345         textMarkerDataForCharacterOffset(textMarkerData, characterOffset);
2346         return textMarkerData;
2347     }
2348 
2349     // find or create an accessibility object for this node
2350     AXObjectCache* cache = domNode-&gt;document().axObjectCache();
2351     if (!cache)
2352         return WTF::nullopt;
2353     RefPtr&lt;AccessibilityObject&gt; obj = cache-&gt;getOrCreate(domNode);
2354 
2355     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2356     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2357     TextMarkerData textMarkerData;
2358     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2359 
2360     textMarkerData.axID = obj.get()-&gt;objectID();
2361     textMarkerData.node = domNode;
2362     textMarkerData.offset = deepPos.deprecatedEditingOffset();
2363     textMarkerData.affinity = visiblePos.affinity();
2364 
2365     textMarkerData.characterOffset = characterOffset.offset;
2366     textMarkerData.characterStartIndex = characterOffset.startIndex;
2367 
2368     cache-&gt;setNodeInUse(domNode);
2369 
2370     return textMarkerData;
2371 }
2372 
2373 // This function exits as a performance optimization to avoid a synchronous layout.
2374 Optional&lt;TextMarkerData&gt; AXObjectCache::textMarkerDataForFirstPositionInTextControl(HTMLTextFormControlElement&amp; textControl)
2375 {
2376     if (is&lt;HTMLInputElement&gt;(textControl) &amp;&amp; downcast&lt;HTMLInputElement&gt;(textControl).isPasswordField())
2377         return WTF::nullopt;
2378 
2379     AXObjectCache* cache = textControl.document().axObjectCache();
2380     if (!cache)
2381         return WTF::nullopt;
2382 
2383     RefPtr&lt;AccessibilityObject&gt; obj = cache-&gt;getOrCreate(&amp;textControl);
2384     if (!obj)
2385         return WTF::nullopt;
2386 
2387     // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
2388     // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
2389     TextMarkerData textMarkerData;
2390     memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
2391 
2392     textMarkerData.axID = obj.get()-&gt;objectID();
2393     textMarkerData.node = &amp;textControl;
2394 
2395     cache-&gt;setNodeInUse(&amp;textControl);
2396 
2397     return textMarkerData;
2398 }
2399 
2400 CharacterOffset AXObjectCache::nextCharacterOffset(const CharacterOffset&amp; characterOffset, bool ignoreNextNodeStart)
2401 {
2402     if (characterOffset.isNull())
2403         return CharacterOffset();
2404 
2405     // We don&#39;t always move one &#39;character&#39; at a time since there might be composed characters.
2406     int nextOffset = Position::uncheckedNextOffset(characterOffset.node, characterOffset.offset);
2407     CharacterOffset next = characterOffsetForNodeAndOffset(*characterOffset.node, nextOffset);
2408 
2409     // To be consistent with VisiblePosition, we should consider the case that current node end to next node start counts 1 offset.
2410     if (!ignoreNextNodeStart &amp;&amp; !next.isNull() &amp;&amp; !isReplacedNodeOrBR(next.node) &amp;&amp; next.node != characterOffset.node) {
2411         int length = TextIterator::rangeLength(rangeForUnorderedCharacterOffsets(characterOffset, next).get());
2412         if (length &gt; nextOffset - characterOffset.offset)
2413             next = characterOffsetForNodeAndOffset(*next.node, 0, TraverseOptionIncludeStart);
2414     }
2415 
2416     return next;
2417 }
2418 
2419 CharacterOffset AXObjectCache::previousCharacterOffset(const CharacterOffset&amp; characterOffset, bool ignorePreviousNodeEnd)
2420 {
2421     if (characterOffset.isNull())
2422         return CharacterOffset();
2423 
2424     // To be consistent with VisiblePosition, we should consider the case that current node start to previous node end counts 1 offset.
2425     if (!ignorePreviousNodeEnd &amp;&amp; !characterOffset.offset)
2426         return characterOffsetForNodeAndOffset(*characterOffset.node, 0);
2427 
2428     // We don&#39;t always move one &#39;character&#39; a time since there might be composed characters.
2429     int previousOffset = Position::uncheckedPreviousOffset(characterOffset.node, characterOffset.offset);
2430     return characterOffsetForNodeAndOffset(*characterOffset.node, previousOffset, TraverseOptionIncludeStart);
2431 }
2432 
2433 CharacterOffset AXObjectCache::startCharacterOffsetOfWord(const CharacterOffset&amp; characterOffset, EWordSide side)
2434 {
2435     if (characterOffset.isNull())
2436         return CharacterOffset();
2437 
2438     CharacterOffset c = characterOffset;
2439     if (side == RightWordIfOnBoundary) {
2440         CharacterOffset endOfParagraph = endCharacterOffsetOfParagraph(c);
2441         if (c.isEqual(endOfParagraph))
2442             return c;
2443 
2444         // We should consider the node boundary that splits words. Otherwise VoiceOver won&#39;t see it as space.
2445         c = nextCharacterOffset(characterOffset, false);
2446         if (shouldSkipBoundary(characterOffset, c))
2447             c = nextCharacterOffset(c, false);
2448         if (c.isNull())
2449             return characterOffset;
2450     }
2451 
2452     return previousBoundary(c, startWordBoundary);
2453 }
2454 
2455 CharacterOffset AXObjectCache::endCharacterOffsetOfWord(const CharacterOffset&amp; characterOffset, EWordSide side)
2456 {
2457     if (characterOffset.isNull())
2458         return CharacterOffset();
2459 
2460     CharacterOffset c = characterOffset;
2461     if (side == LeftWordIfOnBoundary) {
2462         CharacterOffset startOfParagraph = startCharacterOffsetOfParagraph(c);
2463         if (c.isEqual(startOfParagraph))
2464             return c;
2465 
2466         c = previousCharacterOffset(characterOffset);
2467         if (c.isNull())
2468             return characterOffset;
2469     } else {
2470         CharacterOffset endOfParagraph = endCharacterOffsetOfParagraph(characterOffset);
2471         if (characterOffset.isEqual(endOfParagraph))
2472             return characterOffset;
2473     }
2474 
2475     return nextBoundary(c, endWordBoundary);
2476 }
2477 
2478 CharacterOffset AXObjectCache::previousWordStartCharacterOffset(const CharacterOffset&amp; characterOffset)
2479 {
2480     if (characterOffset.isNull())
2481         return CharacterOffset();
2482 
2483     CharacterOffset previousOffset = previousCharacterOffset(characterOffset);
2484     if (previousOffset.isNull())
2485         return CharacterOffset();
2486 
2487     return startCharacterOffsetOfWord(previousOffset, RightWordIfOnBoundary);
2488 }
2489 
2490 CharacterOffset AXObjectCache::nextWordEndCharacterOffset(const CharacterOffset&amp; characterOffset)
2491 {
2492     if (characterOffset.isNull())
2493         return CharacterOffset();
2494 
2495     CharacterOffset nextOffset = nextCharacterOffset(characterOffset);
2496     if (nextOffset.isNull())
2497         return CharacterOffset();
2498 
2499     return endCharacterOffsetOfWord(nextOffset, LeftWordIfOnBoundary);
2500 }
2501 
2502 RefPtr&lt;Range&gt; AXObjectCache::leftWordRange(const CharacterOffset&amp; characterOffset)
2503 {
2504     CharacterOffset start = startCharacterOffsetOfWord(characterOffset, LeftWordIfOnBoundary);
2505     CharacterOffset end = endCharacterOffsetOfWord(start);
2506     return rangeForUnorderedCharacterOffsets(start, end);
2507 }
2508 
2509 RefPtr&lt;Range&gt; AXObjectCache::rightWordRange(const CharacterOffset&amp; characterOffset)
2510 {
2511     CharacterOffset start = startCharacterOffsetOfWord(characterOffset, RightWordIfOnBoundary);
2512     CharacterOffset end = endCharacterOffsetOfWord(start);
2513     return rangeForUnorderedCharacterOffsets(start, end);
2514 }
2515 
2516 static UChar32 characterForCharacterOffset(const CharacterOffset&amp; characterOffset)
2517 {
2518     if (characterOffset.isNull() || !characterOffset.node-&gt;isTextNode())
2519         return 0;
2520 
2521     UChar32 ch = 0;
2522     unsigned offset = characterOffset.startIndex + characterOffset.offset;
2523     if (offset &lt; characterOffset.node-&gt;textContent().length()) {
2524 // FIXME: Remove IGNORE_CLANG_WARNINGS macros once one of &lt;rdar://problem/58615489&amp;58615391&gt; is fixed.
2525 IGNORE_CLANG_WARNINGS_BEGIN(&quot;conditional-uninitialized&quot;)
2526         U16_NEXT(characterOffset.node-&gt;textContent(), offset, characterOffset.node-&gt;textContent().length(), ch);
2527 IGNORE_CLANG_WARNINGS_END
2528     }
2529     return ch;
2530 }
2531 
2532 UChar32 AXObjectCache::characterAfter(const CharacterOffset&amp; characterOffset)
2533 {
2534     return characterForCharacterOffset(nextCharacterOffset(characterOffset));
2535 }
2536 
2537 UChar32 AXObjectCache::characterBefore(const CharacterOffset&amp; characterOffset)
2538 {
2539     return characterForCharacterOffset(characterOffset);
2540 }
2541 
2542 static bool characterOffsetNodeIsBR(const CharacterOffset&amp; characterOffset)
2543 {
2544     if (characterOffset.isNull())
2545         return false;
2546 
2547     return characterOffset.node-&gt;hasTagName(brTag);
2548 }
2549 
2550 static Node* parentEditingBoundary(Node* node)
2551 {
2552     if (!node)
2553         return nullptr;
2554 
2555     Node* documentElement = node-&gt;document().documentElement();
2556     if (!documentElement)
2557         return nullptr;
2558 
2559     Node* boundary = node;
2560     while (boundary != documentElement &amp;&amp; boundary-&gt;nonShadowBoundaryParentNode() &amp;&amp; node-&gt;hasEditableStyle() == boundary-&gt;parentNode()-&gt;hasEditableStyle())
2561         boundary = boundary-&gt;nonShadowBoundaryParentNode();
2562 
2563     return boundary;
2564 }
2565 
2566 CharacterOffset AXObjectCache::nextBoundary(const CharacterOffset&amp; characterOffset, BoundarySearchFunction searchFunction)
2567 {
2568     if (characterOffset.isNull())
2569         return { };
2570 
2571     Node* boundary = parentEditingBoundary(characterOffset.node);
2572     if (!boundary)
2573         return { };
2574 
2575     RefPtr&lt;Range&gt; searchRange = rangeForNodeContents(boundary);
2576     if (!searchRange)
2577         return { };
2578 
2579     Vector&lt;UChar, 1024&gt; string;
2580     unsigned prefixLength = 0;
2581 
2582     if (requiresContextForWordBoundary(characterAfter(characterOffset))) {
2583         auto backwardsScanRange = boundary-&gt;document().createRange();
2584         if (!setRangeStartOrEndWithCharacterOffset(backwardsScanRange, characterOffset, false))
2585             return { };
2586         prefixLength = prefixLengthForRange(backwardsScanRange, string);
2587     }
2588 
2589     if (!setRangeStartOrEndWithCharacterOffset(*searchRange, characterOffset, true))
2590         return { };
2591     CharacterOffset end = startOrEndCharacterOffsetForRange(searchRange, false);
2592 
2593     TextIterator it(searchRange.get(), TextIteratorEmitsObjectReplacementCharacters);
2594     unsigned next = forwardSearchForBoundaryWithTextIterator(it, string, prefixLength, searchFunction);
2595 
2596     if (it.atEnd() &amp;&amp; next == string.size())
2597         return end;
2598 
2599     // We should consider the node boundary that splits words.
2600     if (searchFunction == endWordBoundary &amp;&amp; next - prefixLength == 1)
2601         return nextCharacterOffset(characterOffset, false);
2602 
2603     // The endSentenceBoundary function will include a line break at the end of the sentence.
2604     if (searchFunction == endSentenceBoundary &amp;&amp; string[next - 1] == &#39;\n&#39;)
2605         next--;
2606 
2607     if (next &gt; prefixLength)
2608         return characterOffsetForNodeAndOffset(*characterOffset.node, characterOffset.offset + next - prefixLength);
2609 
2610     return characterOffset;
2611 }
2612 
2613 // FIXME: Share code with the one in VisibleUnits.cpp.
2614 CharacterOffset AXObjectCache::previousBoundary(const CharacterOffset&amp; characterOffset, BoundarySearchFunction searchFunction, NeedsContextAtParagraphStart needsContextAtParagraphStart)
2615 {
2616     if (characterOffset.isNull())
2617         return CharacterOffset();
2618 
2619     Node* boundary = parentEditingBoundary(characterOffset.node);
2620     if (!boundary)
2621         return CharacterOffset();
2622 
2623     RefPtr&lt;Range&gt; searchRange = rangeForNodeContents(boundary);
2624     Vector&lt;UChar, 1024&gt; string;
2625     unsigned suffixLength = 0;
2626 
2627     if (needsContextAtParagraphStart == NeedsContextAtParagraphStart::Yes &amp;&amp; startCharacterOffsetOfParagraph(characterOffset).isEqual(characterOffset)) {
2628         auto forwardsScanRange = boundary-&gt;document().createRange();
2629         auto endOfCurrentParagraph = endCharacterOffsetOfParagraph(characterOffset);
2630         if (!setRangeStartOrEndWithCharacterOffset(forwardsScanRange, characterOffset, true))
2631             return { };
2632         if (!setRangeStartOrEndWithCharacterOffset(forwardsScanRange, endOfCurrentParagraph, false))
2633             return { };
2634         for (TextIterator forwardsIterator(forwardsScanRange.ptr()); !forwardsIterator.atEnd(); forwardsIterator.advance())
2635             append(string, forwardsIterator.text());
2636         suffixLength = string.size();
2637     } else if (requiresContextForWordBoundary(characterBefore(characterOffset))) {
2638         auto forwardsScanRange = boundary-&gt;document().createRange();
2639         if (forwardsScanRange-&gt;setEndAfter(*boundary).hasException())
2640             return { };
2641         if (!setRangeStartOrEndWithCharacterOffset(forwardsScanRange, characterOffset, true))
2642             return { };
2643         suffixLength = suffixLengthForRange(forwardsScanRange, string);
2644     }
2645 
2646     if (!setRangeStartOrEndWithCharacterOffset(*searchRange, characterOffset, false))
2647         return { };
2648     CharacterOffset start = startOrEndCharacterOffsetForRange(searchRange, true);
2649 
2650     SimplifiedBackwardsTextIterator it(*searchRange);
2651     unsigned next = backwardSearchForBoundaryWithTextIterator(it, string, suffixLength, searchFunction);
2652 
2653     if (!next)
2654         return it.atEnd() ? start : characterOffset;
2655 
2656     Node&amp; node = it.atEnd() ? searchRange-&gt;startContainer() : it.range()-&gt;startContainer();
2657 
2658     // SimplifiedBackwardsTextIterator ignores replaced elements.
2659     if (AccessibilityObject::replacedNodeNeedsCharacter(characterOffset.node))
2660         return characterOffsetForNodeAndOffset(*characterOffset.node, 0);
2661     Node* nextSibling = node.nextSibling();
2662     if (&amp;node != characterOffset.node &amp;&amp; AccessibilityObject::replacedNodeNeedsCharacter(nextSibling))
2663         return startOrEndCharacterOffsetForRange(rangeForNodeContents(nextSibling), false);
2664 
2665     if ((!suffixLength &amp;&amp; node.isTextNode() &amp;&amp; static_cast&lt;int&gt;(next) &lt;= node.maxCharacterOffset()) || (node.renderer() &amp;&amp; node.renderer()-&gt;isBR() &amp;&amp; !next)) {
2666         // The next variable contains a usable index into a text node
2667         if (node.isTextNode())
2668             return traverseToOffsetInRange(rangeForNodeContents(&amp;node), next, TraverseOptionValidateOffset);
2669         return characterOffsetForNodeAndOffset(node, next, TraverseOptionIncludeStart);
2670     }
2671 
2672     int characterCount = characterOffset.offset;
2673     if (next &lt; string.size() - suffixLength)
2674         characterCount -= string.size() - suffixLength - next;
2675     // We don&#39;t want to go to the previous node if the node is at the start of a new line.
2676     if (characterCount &lt; 0 &amp;&amp; (characterOffsetNodeIsBR(characterOffset) || string[string.size() - suffixLength - 1] == &#39;\n&#39;))
2677         characterCount = 0;
2678     return characterOffsetForNodeAndOffset(*characterOffset.node, characterCount, TraverseOptionIncludeStart);
2679 }
2680 
2681 CharacterOffset AXObjectCache::startCharacterOffsetOfParagraph(const CharacterOffset&amp; characterOffset, EditingBoundaryCrossingRule boundaryCrossingRule)
2682 {
2683     if (characterOffset.isNull())
2684         return CharacterOffset();
2685 
2686     auto* startNode = characterOffset.node;
2687 
2688     if (isRenderedAsNonInlineTableImageOrHR(startNode))
2689         return startOrEndCharacterOffsetForRange(rangeForNodeContents(startNode), true);
2690 
2691     auto* startBlock = enclosingBlock(startNode);
2692     int offset = characterOffset.startIndex + characterOffset.offset;
2693     auto* highestRoot = highestEditableRoot(firstPositionInOrBeforeNode(startNode));
2694     Position::AnchorType type = Position::PositionIsOffsetInAnchor;
2695 
2696     auto* node = findStartOfParagraph(startNode, highestRoot, startBlock, offset, type, boundaryCrossingRule);
2697 
2698     if (type == Position::PositionIsOffsetInAnchor)
2699         return characterOffsetForNodeAndOffset(*node, offset, TraverseOptionIncludeStart);
2700 
2701     return startOrEndCharacterOffsetForRange(rangeForNodeContents(node), true);
2702 }
2703 
2704 CharacterOffset AXObjectCache::endCharacterOffsetOfParagraph(const CharacterOffset&amp; characterOffset, EditingBoundaryCrossingRule boundaryCrossingRule)
2705 {
2706     if (characterOffset.isNull())
2707         return CharacterOffset();
2708 
2709     Node* startNode = characterOffset.node;
2710     if (isRenderedAsNonInlineTableImageOrHR(startNode))
2711         return startOrEndCharacterOffsetForRange(rangeForNodeContents(startNode), false);
2712 
2713     Node* stayInsideBlock = enclosingBlock(startNode);
2714     int offset = characterOffset.startIndex + characterOffset.offset;
2715     Node* highestRoot = highestEditableRoot(firstPositionInOrBeforeNode(startNode));
2716     Position::AnchorType type = Position::PositionIsOffsetInAnchor;
2717 
2718     Node* node = findEndOfParagraph(startNode, highestRoot, stayInsideBlock, offset, type, boundaryCrossingRule);
2719     if (type == Position::PositionIsOffsetInAnchor) {
2720         if (node-&gt;isTextNode()) {
2721             CharacterOffset startOffset = startOrEndCharacterOffsetForRange(rangeForNodeContents(node), true);
2722             offset -= startOffset.startIndex;
2723         }
2724         return characterOffsetForNodeAndOffset(*node, offset, TraverseOptionIncludeStart);
2725     }
2726 
2727     return startOrEndCharacterOffsetForRange(rangeForNodeContents(node), false);
2728 }
2729 
2730 RefPtr&lt;Range&gt; AXObjectCache::paragraphForCharacterOffset(const CharacterOffset&amp; characterOffset)
2731 {
2732     CharacterOffset start = startCharacterOffsetOfParagraph(characterOffset);
2733     CharacterOffset end = endCharacterOffsetOfParagraph(start);
2734 
2735     return rangeForUnorderedCharacterOffsets(start, end);
2736 }
2737 
2738 CharacterOffset AXObjectCache::nextParagraphEndCharacterOffset(const CharacterOffset&amp; characterOffset)
2739 {
2740     // make sure we move off of a paragraph end
2741     CharacterOffset next = nextCharacterOffset(characterOffset);
2742 
2743     // We should skip the following BR node.
2744     if (characterOffsetNodeIsBR(next) &amp;&amp; !characterOffsetNodeIsBR(characterOffset))
2745         next = nextCharacterOffset(next);
2746 
2747     return endCharacterOffsetOfParagraph(next);
2748 }
2749 
2750 CharacterOffset AXObjectCache::previousParagraphStartCharacterOffset(const CharacterOffset&amp; characterOffset)
2751 {
2752     // make sure we move off of a paragraph start
2753     CharacterOffset previous = previousCharacterOffset(characterOffset);
2754 
2755     // We should skip the preceding BR node.
2756     if (characterOffsetNodeIsBR(previous) &amp;&amp; !characterOffsetNodeIsBR(characterOffset))
2757         previous = previousCharacterOffset(previous);
2758 
2759     return startCharacterOffsetOfParagraph(previous);
2760 }
2761 
2762 CharacterOffset AXObjectCache::startCharacterOffsetOfSentence(const CharacterOffset&amp; characterOffset)
2763 {
2764     return previousBoundary(characterOffset, startSentenceBoundary, NeedsContextAtParagraphStart::Yes);
2765 }
2766 
2767 CharacterOffset AXObjectCache::endCharacterOffsetOfSentence(const CharacterOffset&amp; characterOffset)
2768 {
2769     return nextBoundary(characterOffset, endSentenceBoundary);
2770 }
2771 
2772 RefPtr&lt;Range&gt; AXObjectCache::sentenceForCharacterOffset(const CharacterOffset&amp; characterOffset)
2773 {
2774     CharacterOffset start = startCharacterOffsetOfSentence(characterOffset);
2775     CharacterOffset end = endCharacterOffsetOfSentence(start);
2776     return rangeForUnorderedCharacterOffsets(start, end);
2777 }
2778 
2779 CharacterOffset AXObjectCache::nextSentenceEndCharacterOffset(const CharacterOffset&amp; characterOffset)
2780 {
2781     // Make sure we move off of a sentence end.
2782     return endCharacterOffsetOfSentence(nextCharacterOffset(characterOffset));
2783 }
2784 
2785 CharacterOffset AXObjectCache::previousSentenceStartCharacterOffset(const CharacterOffset&amp; characterOffset)
2786 {
2787     // Make sure we move off of a sentence start.
2788     CharacterOffset previous = previousCharacterOffset(characterOffset);
2789 
2790     // We should skip the preceding BR node.
2791     if (characterOffsetNodeIsBR(previous) &amp;&amp; !characterOffsetNodeIsBR(characterOffset))
2792         previous = previousCharacterOffset(previous);
2793 
2794     return startCharacterOffsetOfSentence(previous);
2795 }
2796 
2797 LayoutRect AXObjectCache::localCaretRectForCharacterOffset(RenderObject*&amp; renderer, const CharacterOffset&amp; characterOffset)
2798 {
2799     if (characterOffset.isNull()) {
2800         renderer = nullptr;
2801         return IntRect();
2802     }
2803 
2804     Node* node = characterOffset.node;
2805 
2806     renderer = node-&gt;renderer();
2807     if (!renderer)
2808         return LayoutRect();
2809 
2810     InlineBox* inlineBox = nullptr;
2811     int caretOffset;
2812     // Use a collapsed range to get the position.
2813     RefPtr&lt;Range&gt; range = rangeForUnorderedCharacterOffsets(characterOffset, characterOffset);
2814     if (!range)
2815         return IntRect();
2816 
2817     Position startPosition = range-&gt;startPosition();
2818     startPosition.getInlineBoxAndOffset(DOWNSTREAM, inlineBox, caretOffset);
2819 
2820     if (inlineBox)
2821         renderer = &amp;inlineBox-&gt;renderer();
2822 
2823     if (is&lt;RenderLineBreak&gt;(renderer) &amp;&amp; downcast&lt;RenderLineBreak&gt;(renderer)-&gt;inlineBoxWrapper() != inlineBox)
2824         return IntRect();
2825 
2826     return renderer-&gt;localCaretRect(inlineBox, caretOffset);
2827 }
2828 
2829 IntRect AXObjectCache::absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp; characterOffset)
2830 {
2831     RenderBlock* caretPainter = nullptr;
2832 
2833     // First compute a rect local to the renderer at the selection start.
2834     RenderObject* renderer = nullptr;
2835     LayoutRect localRect = localCaretRectForCharacterOffset(renderer, characterOffset);
2836 
2837     localRect = localCaretRectInRendererForRect(localRect, characterOffset.node, renderer, caretPainter);
2838     return absoluteBoundsForLocalCaretRect(caretPainter, localRect);
2839 }
2840 
2841 CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point, AXCoreObject* obj)
2842 {
2843     if (!obj)
2844         return CharacterOffset();
2845 
2846     VisiblePosition vp = obj-&gt;visiblePositionForPoint(point);
2847     RefPtr&lt;Range&gt; range = makeRange(vp, vp);
2848     return startOrEndCharacterOffsetForRange(range, true);
2849 }
2850 
2851 CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point)
2852 {
2853     RefPtr&lt;Range&gt; caretRange = m_document.caretRangeFromPoint(LayoutPoint(point));
2854     return startOrEndCharacterOffsetForRange(caretRange, true);
2855 }
2856 
2857 CharacterOffset AXObjectCache::characterOffsetForBounds(const IntRect&amp; rect, bool first)
2858 {
2859     if (rect.isEmpty())
2860         return CharacterOffset();
2861 
2862     IntPoint corner = first ? rect.minXMinYCorner() : rect.maxXMaxYCorner();
2863     CharacterOffset characterOffset = characterOffsetForPoint(corner);
2864 
2865     if (rect.contains(absoluteCaretBoundsForCharacterOffset(characterOffset).center()))
2866         return characterOffset;
2867 
2868     // If the initial position is located outside the bounds adjust it incrementally as needed.
2869     CharacterOffset nextCharOffset = nextCharacterOffset(characterOffset, false);
2870     CharacterOffset previousCharOffset = previousCharacterOffset(characterOffset, false);
2871     while (!nextCharOffset.isNull() || !previousCharOffset.isNull()) {
2872         if (rect.contains(absoluteCaretBoundsForCharacterOffset(nextCharOffset).center()))
2873             return nextCharOffset;
2874         if (rect.contains(absoluteCaretBoundsForCharacterOffset(previousCharOffset).center()))
2875             return previousCharOffset;
2876 
2877         nextCharOffset = nextCharacterOffset(nextCharOffset, false);
2878         previousCharOffset = previousCharacterOffset(previousCharOffset, false);
2879     }
2880 
2881     return CharacterOffset();
2882 }
2883 
2884 // FIXME: Remove VisiblePosition code after implementing this using CharacterOffset.
2885 CharacterOffset AXObjectCache::endCharacterOffsetOfLine(const CharacterOffset&amp; characterOffset)
2886 {
2887     if (characterOffset.isNull())
2888         return CharacterOffset();
2889 
2890     VisiblePosition vp = visiblePositionFromCharacterOffset(characterOffset);
2891     VisiblePosition endLine = endOfLine(vp);
2892 
2893     return characterOffsetFromVisiblePosition(endLine);
2894 }
2895 
2896 CharacterOffset AXObjectCache::startCharacterOffsetOfLine(const CharacterOffset&amp; characterOffset)
2897 {
2898     if (characterOffset.isNull())
2899         return CharacterOffset();
2900 
2901     VisiblePosition vp = visiblePositionFromCharacterOffset(characterOffset);
2902     VisiblePosition startLine = startOfLine(vp);
2903 
2904     return characterOffsetFromVisiblePosition(startLine);
2905 }
2906 
2907 CharacterOffset AXObjectCache::characterOffsetForIndex(int index, const AXCoreObject* obj)
2908 {
2909     if (!obj)
2910         return CharacterOffset();
2911 
2912     VisiblePosition vp = obj-&gt;visiblePositionForIndex(index);
2913     CharacterOffset validate = characterOffsetFromVisiblePosition(vp);
2914     // In text control, VisiblePosition always gives the before position of a
2915     // BR node, while CharacterOffset will do the opposite.
2916     if (obj-&gt;isTextControl() &amp;&amp; characterOffsetNodeIsBR(validate))
2917         validate.offset = 1;
2918 
2919     RefPtr&lt;Range&gt; range = obj-&gt;elementRange();
2920     CharacterOffset start = startOrEndCharacterOffsetForRange(range, true, true);
2921     CharacterOffset end = startOrEndCharacterOffsetForRange(range, false, true);
2922     CharacterOffset result = start;
2923     for (int i = 0; i &lt; index; i++) {
2924         if (result.isEqual(validate)) {
2925             // Do not include the new line character, always move the offset to the start of next node.
2926             if ((validate.node-&gt;isTextNode() || characterOffsetNodeIsBR(validate))) {
2927                 CharacterOffset next = nextCharacterOffset(validate, false);
2928                 if (!next.isNull() &amp;&amp; !next.offset &amp;&amp; rootAXEditableElement(next.node) == rootAXEditableElement(validate.node))
2929                     result = next;
2930             }
2931             break;
2932         }
2933 
2934         result = nextCharacterOffset(result, false);
2935         if (result.isEqual(end))
2936             break;
2937     }
2938     return result;
2939 }
2940 
2941 int AXObjectCache::indexForCharacterOffset(const CharacterOffset&amp; characterOffset, AccessibilityObject* obj)
2942 {
2943     // Create a collapsed range so that we can get the VisiblePosition from it.
2944     RefPtr&lt;Range&gt; range = rangeForUnorderedCharacterOffsets(characterOffset, characterOffset);
2945     if (!range)
2946         return 0;
2947     VisiblePosition vp = range-&gt;startPosition();
2948     return obj-&gt;indexForVisiblePosition(vp);
2949 }
2950 
2951 const Element* AXObjectCache::rootAXEditableElement(const Node* node)
2952 {
2953     const Element* result = node-&gt;rootEditableElement();
2954     const Element* element = is&lt;Element&gt;(*node) ? downcast&lt;Element&gt;(node) : node-&gt;parentElement();
2955 
2956     for (; element; element = element-&gt;parentElement()) {
2957         if (nodeIsTextControl(element))
2958             result = element;
2959     }
2960 
2961     return result;
2962 }
2963 
2964 static void conditionallyAddNodeToFilterList(Node* node, const Document&amp; document, HashSet&lt;Node*&gt;&amp; nodesToRemove)
2965 {
2966     if (node &amp;&amp; (!node-&gt;isConnected() || &amp;node-&gt;document() == &amp;document))
2967         nodesToRemove.add(node);
2968 }
2969 
2970 template&lt;typename T&gt;
2971 static void filterVectorPairForRemoval(const Vector&lt;std::pair&lt;T, T&gt;&gt;&amp; list, const Document&amp; document, HashSet&lt;Node*&gt;&amp; nodesToRemove)
2972 {
2973     for (auto&amp; entry : list) {
2974         conditionallyAddNodeToFilterList(entry.first, document, nodesToRemove);
2975         conditionallyAddNodeToFilterList(entry.second, document, nodesToRemove);
2976     }
2977 }
2978 
2979 template&lt;typename T, typename U&gt;
2980 static void filterMapForRemoval(const HashMap&lt;T, U&gt;&amp; list, const Document&amp; document, HashSet&lt;Node*&gt;&amp; nodesToRemove)
2981 {
2982     for (auto&amp; entry : list)
2983         conditionallyAddNodeToFilterList(entry.key, document, nodesToRemove);
2984 }
2985 
2986 template&lt;typename T&gt;
2987 static void filterListForRemoval(const ListHashSet&lt;T&gt;&amp; list, const Document&amp; document, HashSet&lt;Node*&gt;&amp; nodesToRemove)
2988 {
2989     for (auto* node : list)
2990         conditionallyAddNodeToFilterList(node, document, nodesToRemove);
2991 }
2992 
2993 void AXObjectCache::prepareForDocumentDestruction(const Document&amp; document)
2994 {
2995     HashSet&lt;Node*&gt; nodesToRemove;
2996     filterListForRemoval(m_textMarkerNodes, document, nodesToRemove);
2997     filterListForRemoval(m_modalNodesSet, document, nodesToRemove);
2998     filterListForRemoval(m_deferredRecomputeIsIgnoredList, document, nodesToRemove);
2999     filterListForRemoval(m_deferredTextChangedList, document, nodesToRemove);
3000     filterListForRemoval(m_deferredSelectedChildredChangedList, document, nodesToRemove);
3001     filterListForRemoval(m_deferredChildrenChangedNodeList, document, nodesToRemove);
3002     filterMapForRemoval(m_deferredTextFormControlValue, document, nodesToRemove);
3003     filterMapForRemoval(m_deferredAttributeChange, document, nodesToRemove);
3004     filterVectorPairForRemoval(m_deferredFocusedNodeChange, document, nodesToRemove);
3005 
3006     for (auto* node : nodesToRemove)
3007         remove(*node);
3008 }
3009 
3010 bool AXObjectCache::nodeIsTextControl(const Node* node)
3011 {
3012     if (!node)
3013         return false;
3014 
3015     const AccessibilityObject* axObject = getOrCreate(const_cast&lt;Node*&gt;(node));
3016     return axObject &amp;&amp; axObject-&gt;isTextControl();
3017 }
3018 
3019 void AXObjectCache::performCacheUpdateTimerFired()
3020 {
3021     // If there&#39;s a pending layout, let the layout trigger the AX update.
3022     if (!document().view() || document().view()-&gt;needsLayout())
3023         return;
3024 
3025     performDeferredCacheUpdate();
3026 }
3027 
3028 void AXObjectCache::performDeferredCacheUpdate()
3029 {
3030     if (m_performingDeferredCacheUpdate)
3031         return;
3032 
3033     SetForScope&lt;bool&gt; performingDeferredCacheUpdate(m_performingDeferredCacheUpdate, true);
3034 
3035     for (auto* nodeChild : m_deferredChildrenChangedNodeList) {
3036         handleMenuOpened(nodeChild);
3037         handleLiveRegionCreated(nodeChild);
3038     }
3039     m_deferredChildrenChangedNodeList.clear();
3040 
3041     for (auto&amp; child : m_deferredChildrenChangedList)
3042         child-&gt;childrenChanged();
3043     m_deferredChildrenChangedList.clear();
3044 
3045     for (auto* node : m_deferredTextChangedList)
3046         textChanged(node);
3047     m_deferredTextChangedList.clear();
3048 
3049     for (auto* element : m_deferredRecomputeIsIgnoredList) {
3050         if (auto* renderer = element-&gt;renderer())
3051             recomputeIsIgnored(renderer);
3052     }
3053     m_deferredRecomputeIsIgnoredList.clear();
3054 
3055     for (auto* selectElement : m_deferredSelectedChildredChangedList)
3056         selectedChildrenChanged(selectElement);
3057     m_deferredSelectedChildredChangedList.clear();
3058 
3059     for (auto&amp; deferredFormControlContext : m_deferredTextFormControlValue) {
3060         auto&amp; textFormControlElement = downcast&lt;HTMLTextFormControlElement&gt;(*deferredFormControlContext.key);
3061         postTextReplacementNotificationForTextControl(textFormControlElement, deferredFormControlContext.value, textFormControlElement.innerTextValue());
3062     }
3063     m_deferredTextFormControlValue.clear();
3064 
3065     for (auto&amp; deferredAttributeChangeContext : m_deferredAttributeChange)
3066         handleAttributeChange(deferredAttributeChangeContext.value, deferredAttributeChangeContext.key);
3067     m_deferredAttributeChange.clear();
3068 
3069     for (auto&amp; deferredFocusedChangeContext : m_deferredFocusedNodeChange)
3070         handleFocusedUIElementChanged(deferredFocusedChangeContext.first, deferredFocusedChangeContext.second);
3071     m_deferredFocusedNodeChange.clear();
3072 
3073     platformPerformDeferredCacheUpdate();
3074 }
3075 
3076 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
3077 Ref&lt;AXIsolatedObject&gt; AXObjectCache::createIsolatedTreeHierarchy(AXCoreObject&amp; object, AXID parentID, AXObjectCache* axObjectCache, AXIsolatedTree&amp; tree, Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt;&amp; nodeChanges, bool isRoot)
3078 {
3079     auto isolatedTreeNode = AXIsolatedObject::create(object, isRoot);
3080     nodeChanges.append(isolatedTreeNode.copyRef());
3081 
3082     isolatedTreeNode-&gt;setTreeIdentifier(tree.treeIdentifier());
3083     isolatedTreeNode-&gt;setParent(parentID);
3084     axObjectCache-&gt;attachWrapper(&amp;isolatedTreeNode.get(), object.wrapper());
3085 
3086     for (const auto&amp; child : object.children()) {
3087         auto staticChild = createIsolatedTreeHierarchy(*child, isolatedTreeNode-&gt;objectID(), axObjectCache, tree, nodeChanges, false);
3088         isolatedTreeNode-&gt;appendChild(staticChild-&gt;objectID());
3089     }
3090 
3091     return isolatedTreeNode;
3092 }
3093 
3094 Ref&lt;AXIsolatedTree&gt; AXObjectCache::generateIsolatedTree(PageIdentifier pageID, Document&amp; document)
3095 {
3096     RELEASE_ASSERT(isMainThread());
3097 
3098     RefPtr&lt;AXIsolatedTree&gt; tree(AXIsolatedTree::createTreeForPageID(pageID));
3099 
3100     // Set the root and focused objects in the isolated tree. For that, we need
3101     // the root and the focused object in the AXObject tree.
3102     auto* axObjectCache = document.axObjectCache();
3103     if (!axObjectCache)
3104         return makeRef(*tree);
3105     tree-&gt;setAXObjectCache(axObjectCache);
3106 
3107     auto* axRoot = axObjectCache-&gt;getOrCreate(document.view());
3108     if (axRoot) {
3109         Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt; nodeChanges;
3110         auto isolatedRoot = createIsolatedTreeHierarchy(*axRoot, InvalidAXID, axObjectCache, *tree, nodeChanges, true);
3111         tree-&gt;setRootNode(isolatedRoot);
3112         tree-&gt;appendNodeChanges(nodeChanges);
3113     }
3114 
3115     auto* axFocus = axObjectCache-&gt;focusedObject(document);
3116     if (axFocus)
3117         tree-&gt;setFocusedNodeID(axFocus-&gt;objectID());
3118 
3119     return makeRef(*tree);
3120 }
3121 #endif
3122 
3123 void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element* element)
3124 {
3125     if (!nodeAndRendererAreValid(element))
3126         return;
3127 
3128     if (rendererNeedsDeferredUpdate(*element-&gt;renderer())) {
3129         m_deferredRecomputeIsIgnoredList.add(element);
3130         return;
3131     }
3132     recomputeIsIgnored(element-&gt;renderer());
3133 }
3134 
3135 void AXObjectCache::deferRecomputeIsIgnored(Element* element)
3136 {
3137     if (!nodeAndRendererAreValid(element))
3138         return;
3139 
3140     m_deferredRecomputeIsIgnoredList.add(element);
3141 }
3142 
3143 void AXObjectCache::deferTextChangedIfNeeded(Node* node)
3144 {
3145     if (!nodeAndRendererAreValid(node))
3146         return;
3147 
3148     if (rendererNeedsDeferredUpdate(*node-&gt;renderer())) {
3149         m_deferredTextChangedList.add(node);
3150         return;
3151     }
3152     textChanged(node);
3153 }
3154 
3155 void AXObjectCache::deferSelectedChildrenChangedIfNeeded(Element&amp; selectElement)
3156 {
3157     if (!nodeAndRendererAreValid(&amp;selectElement))
3158         return;
3159 
3160     if (rendererNeedsDeferredUpdate(*selectElement.renderer())) {
3161         m_deferredSelectedChildredChangedList.add(&amp;selectElement);
3162         return;
3163     }
3164     selectedChildrenChanged(&amp;selectElement);
3165 }
3166 
3167 void AXObjectCache::deferTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp; formControlElement, const String&amp; previousValue)
3168 {
3169     auto* renderer = formControlElement.renderer();
3170     if (!renderer)
3171         return;
3172     m_deferredTextFormControlValue.add(&amp;formControlElement, previousValue);
3173 }
3174 
3175 bool isNodeAriaVisible(Node* node)
3176 {
3177     if (!node)
3178         return false;
3179 
3180     // ARIA Node visibility is controlled by aria-hidden
3181     //  1) if aria-hidden=true, the whole subtree is hidden
3182     //  2) if aria-hidden=false, and the object is rendered, there&#39;s no effect
3183     //  3) if aria-hidden=false, and the object is NOT rendered, then it must have
3184     //     aria-hidden=false on each parent until it gets to a rendered object
3185     //  3b) a text node inherits a parents aria-hidden value
3186     bool requiresAriaHiddenFalse = !node-&gt;renderer();
3187     bool ariaHiddenFalsePresent = false;
3188     for (Node* testNode = node; testNode; testNode = testNode-&gt;parentNode()) {
3189         if (is&lt;Element&gt;(*testNode)) {
3190             const AtomString&amp; ariaHiddenValue = downcast&lt;Element&gt;(*testNode).attributeWithoutSynchronization(aria_hiddenAttr);
3191             if (equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;true&quot;))
3192                 return false;
3193 
3194             bool ariaHiddenFalse = equalLettersIgnoringASCIICase(ariaHiddenValue, &quot;false&quot;);
3195             if (!testNode-&gt;renderer() &amp;&amp; !ariaHiddenFalse)
3196                 return false;
3197             if (!ariaHiddenFalsePresent &amp;&amp; ariaHiddenFalse)
3198                 ariaHiddenFalsePresent = true;
3199             // We should break early when it gets to a rendered object.
3200             if (testNode-&gt;renderer())
3201                 break;
3202         }
3203     }
3204 
3205     return !requiresAriaHiddenFalse || ariaHiddenFalsePresent;
3206 }
3207 
3208 AccessibilityObject* AXObjectCache::rootWebArea()
3209 {
3210     AXCoreObject* rootObject = this-&gt;rootObject();
3211     if (!rootObject || !rootObject-&gt;isAccessibilityScrollView())
3212         return nullptr;
3213     return downcast&lt;AccessibilityScrollView&gt;(*rootObject).webAreaObject();
3214 }
3215 
3216 AXAttributeCacheEnabler::AXAttributeCacheEnabler(AXObjectCache* cache)
3217     : m_cache(cache)
3218 {
3219     if (m_cache)
3220         m_cache-&gt;startCachingComputedObjectAttributesUntilTreeMutates();
3221 }
3222 
3223 AXAttributeCacheEnabler::~AXAttributeCacheEnabler()
3224 {
3225     if (m_cache)
3226         m_cache-&gt;stopCachingComputedObjectAttributes();
3227 }
3228 
3229 #if !PLATFORM(COCOA)
3230 AXTextChange AXObjectCache::textChangeForEditType(AXTextEditType type)
3231 {
3232     switch (type) {
3233     case AXTextEditTypeCut:
3234     case AXTextEditTypeDelete:
3235         return AXTextDeleted;
3236     case AXTextEditTypeInsert:
3237     case AXTextEditTypeDictation:
3238     case AXTextEditTypeTyping:
3239     case AXTextEditTypePaste:
3240         return AXTextInserted;
3241     case AXTextEditTypeAttributesChange:
3242         return AXTextAttributesChanged;
3243     case AXTextEditTypeUnknown:
3244         break;
3245     }
3246     ASSERT_NOT_REACHED();
3247     return AXTextInserted;
3248 }
3249 #endif
3250 
3251 } // namespace WebCore
3252 
3253 #endif // ENABLE(ACCESSIBILITY)
    </pre>
  </body>
</html>
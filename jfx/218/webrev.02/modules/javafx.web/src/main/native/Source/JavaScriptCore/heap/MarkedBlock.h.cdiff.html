<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MarkedBlock.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MarkedBlockInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedBlock.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,14 ***</span>
  #include &quot;CellAttributes.h&quot;
  #include &quot;DestructionMode.h&quot;
  #include &quot;HeapCell.h&quot;
  #include &quot;IterationStatus.h&quot;
  #include &quot;WeakSet.h&quot;
  #include &lt;wtf/Atomics.h&gt;
  #include &lt;wtf/Bitmap.h&gt;
<span class="line-removed">- #include &lt;wtf/HashFunctions.h&gt;</span>
  #include &lt;wtf/CountingLock.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  
  namespace JSC {
  
  class AlignedMemoryAllocator;
<span class="line-new-header">--- 24,16 ---</span>
  #include &quot;CellAttributes.h&quot;
  #include &quot;DestructionMode.h&quot;
  #include &quot;HeapCell.h&quot;
  #include &quot;IterationStatus.h&quot;
  #include &quot;WeakSet.h&quot;
<span class="line-added">+ #include &lt;algorithm&gt;</span>
  #include &lt;wtf/Atomics.h&gt;
  #include &lt;wtf/Bitmap.h&gt;
  #include &lt;wtf/CountingLock.h&gt;
<span class="line-added">+ #include &lt;wtf/HashFunctions.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/PageBlock.h&gt;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  
  namespace JSC {
  
  class AlignedMemoryAllocator;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,13 ***</span>
  // marked block, all cells have the same size. Objects smaller than the
  // cell size may be allocated in the marked block, in which case the
  // allocation suffers from internal fragmentation: wasted space whose
  // size is equal to the difference between the cell size and the object
  // size.
<span class="line-modified">! </span>
  class MarkedBlock {
      WTF_MAKE_NONCOPYABLE(MarkedBlock);
      friend class LLIntOffsetsExtractor;
      friend struct VerifyMarked;
  
  public:
      class Footer;
<span class="line-new-header">--- 52,15 ---</span>
  // marked block, all cells have the same size. Objects smaller than the
  // cell size may be allocated in the marked block, in which case the
  // allocation suffers from internal fragmentation: wasted space whose
  // size is equal to the difference between the cell size and the object
  // size.
<span class="line-modified">! DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MarkedBlock);</span>
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MarkedBlockHandle);</span>
  class MarkedBlock {
      WTF_MAKE_NONCOPYABLE(MarkedBlock);
<span class="line-added">+     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(MarkedBlock);</span>
      friend class LLIntOffsetsExtractor;
      friend struct VerifyMarked;
  
  public:
      class Footer;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,20 ***</span>
      friend class Handle;
  public:
      static constexpr size_t atomSize = 16; // bytes
  
      // Block size must be at least as large as the system page size.
<span class="line-modified">! #if CPU(PPC64) || CPU(PPC64LE) || CPU(PPC) || CPU(UNKNOWN)</span>
<span class="line-removed">-     static constexpr size_t blockSize = 64 * KB;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     static constexpr size_t blockSize = 16 * KB;</span>
<span class="line-removed">- #endif</span>
  
      static constexpr size_t blockMask = ~(blockSize - 1); // blockSize must be a power of two.
  
      static constexpr size_t atomsPerBlock = blockSize / atomSize;
  
      static_assert(!(MarkedBlock::atomSize &amp; (MarkedBlock::atomSize - 1)), &quot;MarkedBlock::atomSize must be a power of two.&quot;);
      static_assert(!(MarkedBlock::blockSize &amp; (MarkedBlock::blockSize - 1)), &quot;MarkedBlock::blockSize must be a power of two.&quot;);
  
      struct VoidFunctor {
          typedef void ReturnType;
<span class="line-new-header">--- 70,19 ---</span>
      friend class Handle;
  public:
      static constexpr size_t atomSize = 16; // bytes
  
      // Block size must be at least as large as the system page size.
<span class="line-modified">!     static constexpr size_t blockSize = std::max(16 * KB, CeilingOnPageSize);</span>
  
      static constexpr size_t blockMask = ~(blockSize - 1); // blockSize must be a power of two.
  
      static constexpr size_t atomsPerBlock = blockSize / atomSize;
  
<span class="line-added">+     static constexpr size_t maxNumberOfLowerTierCells = 8;</span>
<span class="line-added">+     static_assert(maxNumberOfLowerTierCells &lt;= 256);</span>
<span class="line-added">+ </span>
      static_assert(!(MarkedBlock::atomSize &amp; (MarkedBlock::atomSize - 1)), &quot;MarkedBlock::atomSize must be a power of two.&quot;);
      static_assert(!(MarkedBlock::blockSize &amp; (MarkedBlock::blockSize - 1)), &quot;MarkedBlock::blockSize must be a power of two.&quot;);
  
      struct VoidFunctor {
          typedef void ReturnType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,11 ***</span>
          mutable ReturnType m_count;
      };
  
      class Handle {
          WTF_MAKE_NONCOPYABLE(Handle);
<span class="line-modified">!         WTF_MAKE_FAST_ALLOCATED;</span>
          friend class LLIntOffsetsExtractor;
          friend class MarkedBlock;
          friend struct VerifyMarked;
      public:
  
<span class="line-new-header">--- 103,11 ---</span>
          mutable ReturnType m_count;
      };
  
      class Handle {
          WTF_MAKE_NONCOPYABLE(Handle);
<span class="line-modified">!         WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(MarkedBlockHandle);</span>
          friend class LLIntOffsetsExtractor;
          friend class MarkedBlock;
          friend struct VerifyMarked;
      public:
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,15 ***</span>
  
          void assertMarksNotStale();
  
          bool isFreeListed() const { return m_isFreeListed; }
  
<span class="line-modified">!         size_t index() const { return m_index; }</span>
  
          void removeFromDirectory();
  
<span class="line-modified">!         void didAddToDirectory(BlockDirectory*, size_t index);</span>
          void didRemoveFromDirectory();
  
          void* start() const { return &amp;m_block-&gt;atoms()[0]; }
          void* end() const { return &amp;m_block-&gt;atoms()[m_endAtom]; }
          bool contains(void* p) const { return start() &lt;= p &amp;&amp; p &lt; end(); }
<span class="line-new-header">--- 192,15 ---</span>
  
          void assertMarksNotStale();
  
          bool isFreeListed() const { return m_isFreeListed; }
  
<span class="line-modified">!         unsigned index() const { return m_index; }</span>
  
          void removeFromDirectory();
  
<span class="line-modified">!         void didAddToDirectory(BlockDirectory*, unsigned index);</span>
          void didRemoveFromDirectory();
  
          void* start() const { return &amp;m_block-&gt;atoms()[0]; }
          void* end() const { return &amp;m_block-&gt;atoms()[m_endAtom]; }
          bool contains(void* p) const { return start() &lt;= p &amp;&amp; p &lt; end(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,22 ***</span>
          template&lt;bool, EmptyMode, SweepMode, SweepDestructionMode, ScribbleMode, NewlyAllocatedMode, MarksMode, typename DestroyFunc&gt;
          void specializedSweep(FreeList*, EmptyMode, SweepMode, SweepDestructionMode, ScribbleMode, NewlyAllocatedMode, MarksMode, const DestroyFunc&amp;);
  
          void setIsFreeListed();
  
<span class="line-modified">!         MarkedBlock::Handle* m_prev { nullptr };</span>
<span class="line-modified">!         MarkedBlock::Handle* m_next { nullptr };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         size_t m_atomsPerCell { std::numeric_limits&lt;size_t&gt;::max() };</span>
<span class="line-removed">-         size_t m_endAtom { std::numeric_limits&lt;size_t&gt;::max() }; // This is a fuzzy end. Always test for &lt; m_endAtom.</span>
  
          CellAttributes m_attributes;
          bool m_isFreeListed { false };
  
          AlignedMemoryAllocator* m_alignedMemoryAllocator { nullptr };
          BlockDirectory* m_directory { nullptr };
<span class="line-removed">-         size_t m_index { std::numeric_limits&lt;size_t&gt;::max() };</span>
          WeakSet m_weakSet;
  
          MarkedBlock* m_block { nullptr };
      };
  
<span class="line-new-header">--- 225,19 ---</span>
          template&lt;bool, EmptyMode, SweepMode, SweepDestructionMode, ScribbleMode, NewlyAllocatedMode, MarksMode, typename DestroyFunc&gt;
          void specializedSweep(FreeList*, EmptyMode, SweepMode, SweepDestructionMode, ScribbleMode, NewlyAllocatedMode, MarksMode, const DestroyFunc&amp;);
  
          void setIsFreeListed();
  
<span class="line-modified">!         unsigned m_atomsPerCell { std::numeric_limits&lt;unsigned&gt;::max() };</span>
<span class="line-modified">!         unsigned m_endAtom { std::numeric_limits&lt;unsigned&gt;::max() }; // This is a fuzzy end. Always test for &lt; m_endAtom.</span>
  
          CellAttributes m_attributes;
          bool m_isFreeListed { false };
<span class="line-added">+         unsigned m_index { std::numeric_limits&lt;unsigned&gt;::max() };</span>
  
          AlignedMemoryAllocator* m_alignedMemoryAllocator { nullptr };
          BlockDirectory* m_directory { nullptr };
          WeakSet m_weakSet;
  
          MarkedBlock* m_block { nullptr };
      };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,13 ***</span>
      static constexpr size_t endAtom = (blockSize - sizeof(Footer)) / atomSize;
      static constexpr size_t payloadSize = endAtom * atomSize;
      static constexpr size_t footerSize = blockSize - payloadSize;
  
      static_assert(payloadSize == ((blockSize - sizeof(MarkedBlock::Footer)) &amp; ~(atomSize - 1)), &quot;Payload size computed the alternate way should give the same result&quot;);
<span class="line-removed">-     // Some of JSCell types assume that the last JSCell in a MarkedBlock has a subsequent memory region (Footer) that can still safely accessed.</span>
<span class="line-removed">-     // For example, JSRopeString assumes that it can safely access up to 2 bytes beyond the JSRopeString cell.</span>
<span class="line-removed">-     static_assert(sizeof(Footer) &gt;= sizeof(uint16_t));</span>
  
      static MarkedBlock::Handle* tryCreate(Heap&amp;, AlignedMemoryAllocator*);
  
      Handle&amp; handle();
      const Handle&amp; handle() const;
<span class="line-new-header">--- 306,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 321,11 ***</span>
      inline Heap* heap() const;
      inline MarkedSpace* space() const;
  
      static bool isAtomAligned(const void*);
      static MarkedBlock* blockFor(const void*);
<span class="line-modified">!     size_t atomNumber(const void*);</span>
  
      size_t markCount();
  
      bool isMarked(const void*);
      bool isMarked(HeapVersion markingVersion, const void*);
<span class="line-new-header">--- 318,12 ---</span>
      inline Heap* heap() const;
      inline MarkedSpace* space() const;
  
      static bool isAtomAligned(const void*);
      static MarkedBlock* blockFor(const void*);
<span class="line-modified">!     unsigned atomNumber(const void*);</span>
<span class="line-added">+     size_t candidateAtomNumber(const void*);</span>
  
      size_t markCount();
  
      bool isMarked(const void*);
      bool isMarked(HeapVersion markingVersion, const void*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,27 ***</span>
      size_t cellSize();
      const CellAttributes&amp; attributes() const;
  
      bool hasAnyMarked() const;
      void noteMarked();
<span class="line-modified">! #if ASSERT_DISABLED</span>
<span class="line-removed">-     void assertValidCell(VM&amp;, HeapCell*) const { }</span>
<span class="line-removed">- #else</span>
      void assertValidCell(VM&amp;, HeapCell*) const;
  #endif
  
      WeakSet&amp; weakSet();
  
      JS_EXPORT_PRIVATE bool areMarksStale();
      bool areMarksStale(HeapVersion markingVersion);
  
      Dependency aboutToMark(HeapVersion markingVersion);
  
<span class="line-modified">! #if ASSERT_DISABLED</span>
<span class="line-removed">-     void assertMarksNotStale() { }</span>
<span class="line-removed">- #else</span>
      JS_EXPORT_PRIVATE void assertMarksNotStale();
  #endif
  
      void resetMarks();
  
      bool isMarkedRaw(const void* p);
<span class="line-new-header">--- 348,27 ---</span>
      size_t cellSize();
      const CellAttributes&amp; attributes() const;
  
      bool hasAnyMarked() const;
      void noteMarked();
<span class="line-modified">! #if ASSERT_ENABLED</span>
      void assertValidCell(VM&amp;, HeapCell*) const;
<span class="line-added">+ #else</span>
<span class="line-added">+     void assertValidCell(VM&amp;, HeapCell*) const { }</span>
  #endif
  
      WeakSet&amp; weakSet();
  
      JS_EXPORT_PRIVATE bool areMarksStale();
      bool areMarksStale(HeapVersion markingVersion);
  
      Dependency aboutToMark(HeapVersion markingVersion);
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      JS_EXPORT_PRIVATE void assertMarksNotStale();
<span class="line-added">+ #else</span>
<span class="line-added">+     void assertMarksNotStale() { }</span>
  #endif
  
      void resetMarks();
  
      bool isMarkedRaw(const void* p);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,15 ***</span>
  inline size_t MarkedBlock::Handle::size()
  {
      return markCount() * cellSize();
  }
  
<span class="line-modified">! inline size_t MarkedBlock::atomNumber(const void* p)</span>
  {
      return (reinterpret_cast&lt;uintptr_t&gt;(p) - reinterpret_cast&lt;uintptr_t&gt;(this)) / atomSize;
  }
  
  inline bool MarkedBlock::areMarksStale(HeapVersion markingVersion)
  {
      return markingVersion != footer().m_markingVersion;
  }
  
<span class="line-new-header">--- 549,24 ---</span>
  inline size_t MarkedBlock::Handle::size()
  {
      return markCount() * cellSize();
  }
  
<span class="line-modified">! inline size_t MarkedBlock::candidateAtomNumber(const void* p)</span>
  {
<span class="line-added">+     // This function must return size_t instead of unsigned since pointer |p| is not guaranteed that this is within MarkedBlock.</span>
<span class="line-added">+     // See MarkedBlock::isAtom which can accept out-of-bound pointers.</span>
      return (reinterpret_cast&lt;uintptr_t&gt;(p) - reinterpret_cast&lt;uintptr_t&gt;(this)) / atomSize;
  }
  
<span class="line-added">+ inline unsigned MarkedBlock::atomNumber(const void* p)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     size_t atomNumber = candidateAtomNumber(p);</span>
<span class="line-added">+     ASSERT(atomNumber &lt; handle().m_endAtom);</span>
<span class="line-added">+     return atomNumber;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  inline bool MarkedBlock::areMarksStale(HeapVersion markingVersion)
  {
      return markingVersion != footer().m_markingVersion;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,11 ***</span>
  }
  
  inline bool MarkedBlock::isAtom(const void* p)
  {
      ASSERT(MarkedBlock::isAtomAligned(p));
<span class="line-modified">!     size_t atomNumber = this-&gt;atomNumber(p);</span>
      if (atomNumber % handle().m_atomsPerCell) // Filters pointers into cell middles.
          return false;
      if (atomNumber &gt;= handle().m_endAtom) // Filters pointers into invalid cells out of the range.
          return false;
      return true;
<span class="line-new-header">--- 634,11 ---</span>
  }
  
  inline bool MarkedBlock::isAtom(const void* p)
  {
      ASSERT(MarkedBlock::isAtomAligned(p));
<span class="line-modified">!     size_t atomNumber = candidateAtomNumber(p);</span>
      if (atomNumber % handle().m_atomsPerCell) // Filters pointers into cell middles.
          return false;
      if (atomNumber &gt;= handle().m_endAtom) // Filters pointers into invalid cells out of the range.
          return false;
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 641,11 ***</span>
  inline IterationStatus MarkedBlock::Handle::forEachCell(const Functor&amp; functor)
  {
      HeapCell::Kind kind = m_attributes.cellKind;
      for (size_t i = 0; i &lt; m_endAtom; i += m_atomsPerCell) {
          HeapCell* cell = reinterpret_cast_ptr&lt;HeapCell*&gt;(&amp;m_block-&gt;atoms()[i]);
<span class="line-modified">!         if (functor(cell, kind) == IterationStatus::Done)</span>
              return IterationStatus::Done;
      }
      return IterationStatus::Continue;
  }
  
<span class="line-new-header">--- 648,11 ---</span>
  inline IterationStatus MarkedBlock::Handle::forEachCell(const Functor&amp; functor)
  {
      HeapCell::Kind kind = m_attributes.cellKind;
      for (size_t i = 0; i &lt; m_endAtom; i += m_atomsPerCell) {
          HeapCell* cell = reinterpret_cast_ptr&lt;HeapCell*&gt;(&amp;m_block-&gt;atoms()[i]);
<span class="line-modified">!         if (functor(i, cell, kind) == IterationStatus::Done)</span>
              return IterationStatus::Done;
      }
      return IterationStatus::Continue;
  }
  
</pre>
<center><a href="MarkedBlock.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MarkedBlockInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
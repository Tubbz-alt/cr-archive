<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   3  * Copyright (C) 2015 Sukolsak Sakshuwong (sukolsak@gmail.com)
   4  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  25  * THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;IntlObject.h&quot;
  30 
  31 #if ENABLE(INTL)
  32 
  33 #include &quot;Error.h&quot;
  34 #include &quot;FunctionPrototype.h&quot;
  35 #include &quot;IntlCanonicalizeLanguage.h&quot;
  36 #include &quot;IntlCollatorConstructor.h&quot;
  37 #include &quot;IntlCollatorPrototype.h&quot;
  38 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  39 #include &quot;IntlDateTimeFormatPrototype.h&quot;
  40 #include &quot;IntlNumberFormatConstructor.h&quot;
  41 #include &quot;IntlNumberFormatPrototype.h&quot;
  42 #include &quot;IntlPluralRulesConstructor.h&quot;
  43 #include &quot;IntlPluralRulesPrototype.h&quot;
  44 #include &quot;JSCInlines.h&quot;
  45 #include &quot;JSCJSValueInlines.h&quot;
  46 #include &quot;Lookup.h&quot;
  47 #include &quot;ObjectPrototype.h&quot;
  48 #include &quot;Options.h&quot;
  49 #include &lt;unicode/ucol.h&gt;
  50 #include &lt;unicode/udat.h&gt;
  51 #include &lt;unicode/uloc.h&gt;
  52 #include &lt;unicode/unum.h&gt;
  53 #include &lt;unicode/unumsys.h&gt;
  54 #include &lt;wtf/Assertions.h&gt;
  55 #include &lt;wtf/Language.h&gt;
  56 #include &lt;wtf/NeverDestroyed.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
  58 #include &lt;wtf/text/StringImpl.h&gt;
  59 
  60 namespace JSC {
  61 
  62 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(IntlObject);
  63 
  64 static EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(JSGlobalObject*, CallFrame*);
  65 
  66 static JSValue createCollatorConstructor(VM&amp; vm, JSObject* object)
  67 {
  68     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  69     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  70     return IntlCollatorConstructor::create(vm, IntlCollatorConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlCollatorPrototype*&gt;(globalObject-&gt;collatorStructure()-&gt;storedPrototypeObject()));
  71 }
  72 
  73 static JSValue createNumberFormatConstructor(VM&amp; vm, JSObject* object)
  74 {
  75     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  76     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  77     return IntlNumberFormatConstructor::create(vm, IntlNumberFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlNumberFormatPrototype*&gt;(globalObject-&gt;numberFormatStructure()-&gt;storedPrototypeObject()));
  78 }
  79 
  80 static JSValue createDateTimeFormatConstructor(VM&amp; vm, JSObject* object)
  81 {
  82     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  83     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  84     return IntlDateTimeFormatConstructor::create(vm, IntlDateTimeFormatConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlDateTimeFormatPrototype*&gt;(globalObject-&gt;dateTimeFormatStructure()-&gt;storedPrototypeObject()));
  85 }
  86 
  87 static JSValue createPluralRulesConstructor(VM&amp; vm, JSObject* object)
  88 {
  89     IntlObject* intlObject = jsCast&lt;IntlObject*&gt;(object);
  90     JSGlobalObject* globalObject = intlObject-&gt;globalObject(vm);
  91     return IntlPluralRulesConstructor::create(vm, IntlPluralRulesConstructor::createStructure(vm, globalObject, globalObject-&gt;functionPrototype()), jsCast&lt;IntlPluralRulesPrototype*&gt;(globalObject-&gt;pluralRulesStructure()-&gt;storedPrototypeObject()));
  92 }
  93 
  94 }
  95 
  96 #include &quot;IntlObject.lut.h&quot;
  97 
  98 namespace JSC {
  99 
 100 /* Source for IntlObject.lut.h
 101 @begin intlObjectTable
 102   getCanonicalLocales   intlObjectFuncGetCanonicalLocales            DontEnum|Function 1
 103   Collator              createCollatorConstructor                    DontEnum|PropertyCallback
 104   DateTimeFormat        createDateTimeFormatConstructor              DontEnum|PropertyCallback
 105   NumberFormat          createNumberFormatConstructor                DontEnum|PropertyCallback
 106   PluralRules           createPluralRulesConstructor                 DontEnum|PropertyCallback
 107 @end
 108 */
 109 
 110 struct MatcherResult {
 111     String locale;
 112     String extension;
 113     size_t extensionIndex { 0 };
 114 };
 115 
 116 const ClassInfo IntlObject::s_info = { &quot;Object&quot;, &amp;Base::s_info, &amp;intlObjectTable, nullptr, CREATE_METHOD_TABLE(IntlObject) };
 117 
 118 IntlObject::IntlObject(VM&amp; vm, Structure* structure)
 119     : JSNonFinalObject(vm, structure)
 120 {
 121 }
 122 
 123 IntlObject* IntlObject::create(VM&amp; vm, Structure* structure)
 124 {
 125     IntlObject* object = new (NotNull, allocateCell&lt;IntlObject&gt;(vm.heap)) IntlObject(vm, structure);
 126     object-&gt;finishCreation(vm);
 127     return object;
 128 }
 129 
 130 Structure* IntlObject::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 131 {
 132     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 133 }
 134 
 135 static String convertICULocaleToBCP47LanguageTag(const char* localeID)
 136 {
 137     UErrorCode status = U_ZERO_ERROR;
 138     Vector&lt;char, 32&gt; buffer(32);
 139     auto length = uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
 140     if (status == U_BUFFER_OVERFLOW_ERROR) {
 141         buffer.grow(length);
 142         status = U_ZERO_ERROR;
 143         uloc_toLanguageTag(localeID, buffer.data(), buffer.size(), false, &amp;status);
 144     }
 145     if (!U_FAILURE(status))
 146         return String(StringImpl::createStaticStringImpl(buffer.data(), length));
 147     return String();
 148 }
 149 
 150 static void addMissingScriptLocales(HashSet&lt;String&gt;&amp; availableLocales)
 151 {
 152     static const NeverDestroyed&lt;String&gt; pa_PK_String(MAKE_STATIC_STRING_IMPL(&quot;pa-PK&quot;));
 153     static const NeverDestroyed&lt;String&gt; zh_CN_String(MAKE_STATIC_STRING_IMPL(&quot;zh-CN&quot;));
 154     static const NeverDestroyed&lt;String&gt; zh_HK_String(MAKE_STATIC_STRING_IMPL(&quot;zh-HK&quot;));
 155     static const NeverDestroyed&lt;String&gt; zh_SG_String(MAKE_STATIC_STRING_IMPL(&quot;zh-SG&quot;));
 156     static const NeverDestroyed&lt;String&gt; zh_TW_String(MAKE_STATIC_STRING_IMPL(&quot;zh-TW&quot;));
 157     if (availableLocales.contains(&quot;pa-Arab-PK&quot;))
 158         availableLocales.add(pa_PK_String.get());
 159     if (availableLocales.contains(&quot;zh-Hans-CN&quot;))
 160         availableLocales.add(zh_CN_String.get());
 161     if (availableLocales.contains(&quot;zh-Hant-HK&quot;))
 162         availableLocales.add(zh_HK_String.get());
 163     if (availableLocales.contains(&quot;zh-Hans-SG&quot;))
 164         availableLocales.add(zh_SG_String.get());
 165     if (availableLocales.contains(&quot;zh-Hant-TW&quot;))
 166         availableLocales.add(zh_TW_String.get());
 167 }
 168 
 169 const HashSet&lt;String&gt;&amp; intlCollatorAvailableLocales()
 170 {
 171     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;
 172     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();
 173 
 174     static std::once_flag initializeOnce;
 175     std::call_once(initializeOnce, [&amp;] {
 176         ASSERT(availableLocales.isEmpty());
 177         int32_t count = ucol_countAvailable();
 178         for (int32_t i = 0; i &lt; count; ++i) {
 179             String locale = convertICULocaleToBCP47LanguageTag(ucol_getAvailable(i));
 180             if (!locale.isEmpty())
 181                 availableLocales.add(locale);
 182         }
 183         addMissingScriptLocales(availableLocales);
 184     });
 185     return availableLocales;
 186 }
 187 
 188 const HashSet&lt;String&gt;&amp; intlDateTimeFormatAvailableLocales()
 189 {
 190     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;
 191     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();
 192 
 193     static std::once_flag initializeOnce;
 194     std::call_once(initializeOnce, [&amp;] {
 195         ASSERT(availableLocales.isEmpty());
 196         int32_t count = udat_countAvailable();
 197         for (int32_t i = 0; i &lt; count; ++i) {
 198             String locale = convertICULocaleToBCP47LanguageTag(udat_getAvailable(i));
 199             if (!locale.isEmpty())
 200                 availableLocales.add(locale);
 201         }
 202         addMissingScriptLocales(availableLocales);
 203     });
 204     return availableLocales;
 205 }
 206 
 207 const HashSet&lt;String&gt;&amp; intlNumberFormatAvailableLocales()
 208 {
 209     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; cachedAvailableLocales;
 210     HashSet&lt;String&gt;&amp; availableLocales = cachedAvailableLocales.get();
 211 
 212     static std::once_flag initializeOnce;
 213     std::call_once(initializeOnce, [&amp;] {
 214         ASSERT(availableLocales.isEmpty());
 215         int32_t count = unum_countAvailable();
 216         for (int32_t i = 0; i &lt; count; ++i) {
 217             String locale = convertICULocaleToBCP47LanguageTag(unum_getAvailable(i));
 218             if (!locale.isEmpty())
 219                 availableLocales.add(locale);
 220         }
 221         addMissingScriptLocales(availableLocales);
 222     });
 223     return availableLocales;
 224 }
 225 
 226 bool intlBooleanOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, bool&amp; usesFallback)
 227 {
 228     // GetOption (options, property, type=&quot;boolean&quot;, values, fallback)
 229     // https://tc39.github.io/ecma402/#sec-getoption
 230 
 231     VM&amp; vm = globalObject-&gt;vm();
 232     auto scope = DECLARE_THROW_SCOPE(vm);
 233 
 234     if (options.isUndefined()) {
 235         usesFallback = true;
 236         return false;
 237     }
 238 
 239     JSObject* opts = options.toObject(globalObject);
 240     RETURN_IF_EXCEPTION(scope, false);
 241 
 242     JSValue value = opts-&gt;get(globalObject, property);
 243     RETURN_IF_EXCEPTION(scope, false);
 244 
 245     if (!value.isUndefined()) {
 246         bool booleanValue = value.toBoolean(globalObject);
 247         usesFallback = false;
 248         return booleanValue;
 249     }
 250 
 251     // Because fallback can be undefined, we let the caller handle it instead.
 252     usesFallback = true;
 253     return false;
 254 }
 255 
 256 String intlStringOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, std::initializer_list&lt;const char*&gt; values, const char* notFound, const char* fallback)
 257 {
 258     // GetOption (options, property, type=&quot;string&quot;, values, fallback)
 259     // https://tc39.github.io/ecma402/#sec-getoption
 260 
 261     VM&amp; vm = globalObject-&gt;vm();
 262     auto scope = DECLARE_THROW_SCOPE(vm);
 263 
 264     if (options.isUndefined())
 265         return fallback;
 266 
 267     JSObject* opts = options.toObject(globalObject);
 268     RETURN_IF_EXCEPTION(scope, String());
 269 
 270     JSValue value = opts-&gt;get(globalObject, property);
 271     RETURN_IF_EXCEPTION(scope, String());
 272 
 273     if (!value.isUndefined()) {
 274         String stringValue = value.toWTFString(globalObject);
 275         RETURN_IF_EXCEPTION(scope, String());
 276 
 277         if (values.size() &amp;&amp; std::find(values.begin(), values.end(), stringValue) == values.end()) {
 278             throwException(globalObject, scope, createRangeError(globalObject, notFound));
 279             return { };
 280         }
 281         return stringValue;
 282     }
 283 
 284     return fallback;
 285 }
 286 
 287 unsigned intlNumberOption(JSGlobalObject* globalObject, JSValue options, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)
 288 {
 289     // GetNumberOption (options, property, minimum, maximum, fallback)
 290     // https://tc39.github.io/ecma402/#sec-getnumberoption
 291 
 292     VM&amp; vm = globalObject-&gt;vm();
 293     auto scope = DECLARE_THROW_SCOPE(vm);
 294 
 295     if (options.isUndefined())
 296         return fallback;
 297 
 298     JSObject* opts = options.toObject(globalObject);
 299     RETURN_IF_EXCEPTION(scope, 0);
 300 
 301     JSValue value = opts-&gt;get(globalObject, property);
 302     RETURN_IF_EXCEPTION(scope, 0);
 303 
 304     RELEASE_AND_RETURN(scope, intlDefaultNumberOption(globalObject, value, property, minimum, maximum, fallback));
 305 }
 306 
 307 unsigned intlDefaultNumberOption(JSGlobalObject* globalObject, JSValue value, PropertyName property, unsigned minimum, unsigned maximum, unsigned fallback)
 308 {
 309     // DefaultNumberOption (value, minimum, maximum, fallback)
 310     // https://tc39.github.io/ecma402/#sec-defaultnumberoption
 311 
 312     VM&amp; vm = globalObject-&gt;vm();
 313     auto scope = DECLARE_THROW_SCOPE(vm);
 314 
 315     if (!value.isUndefined()) {
 316         double doubleValue = value.toNumber(globalObject);
 317         RETURN_IF_EXCEPTION(scope, 0);
 318 
 319         if (!(doubleValue &gt;= minimum &amp;&amp; doubleValue &lt;= maximum)) {
 320             throwException(globalObject, scope, createRangeError(globalObject, *property.publicName() + &quot; is out of range&quot;));
 321             return 0;
 322         }
 323         return static_cast&lt;unsigned&gt;(doubleValue);
 324     }
 325     return fallback;
 326 }
 327 
 328 static String privateUseLangTag(const Vector&lt;String&gt;&amp; parts, size_t startIndex)
 329 {
 330     size_t numParts = parts.size();
 331     size_t currentIndex = startIndex;
 332 
 333     // Check for privateuse.
 334     // privateuse = &quot;x&quot; 1*(&quot;-&quot; (1*8alphanum))
 335     StringBuilder privateuse;
 336     while (currentIndex &lt; numParts) {
 337         const String&amp; singleton = parts[currentIndex];
 338         unsigned singletonLength = singleton.length();
 339         bool isValid = (singletonLength == 1 &amp;&amp; (singleton == &quot;x&quot; || singleton == &quot;X&quot;));
 340         if (!isValid)
 341             break;
 342 
 343         if (currentIndex != startIndex)
 344             privateuse.append(&#39;-&#39;);
 345 
 346         ++currentIndex;
 347         unsigned numExtParts = 0;
 348         privateuse.append(&#39;x&#39;);
 349         while (currentIndex &lt; numParts) {
 350             const String&amp; extPart = parts[currentIndex];
 351             unsigned extPartLength = extPart.length();
 352 
 353             bool isValid = (extPartLength &gt;= 1 &amp;&amp; extPartLength &lt;= 8 &amp;&amp; extPart.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;());
 354             if (!isValid)
 355                 break;
 356 
 357             ++currentIndex;
 358             ++numExtParts;
 359             privateuse.append(&#39;-&#39;);
 360             privateuse.append(extPart.convertToASCIILowercase());
 361         }
 362 
 363         // Requires at least one production.
 364         if (!numExtParts)
 365             return String();
 366     }
 367 
 368     // Leftovers makes it invalid.
 369     if (currentIndex &lt; numParts)
 370         return String();
 371 
 372     return privateuse.toString();
 373 }
 374 
 375 static String preferredLanguage(const String&amp; language)
 376 {
 377     auto preferred = intlPreferredLanguageTag(language);
 378     if (!preferred.isNull())
 379         return preferred;
 380     return language;
 381 }
 382 
 383 static String preferredRegion(const String&amp; region)
 384 {
 385     auto preferred = intlPreferredRegionTag(region);
 386     if (!preferred.isNull())
 387         return preferred;
 388     return region;
 389 
 390 }
 391 
 392 static String canonicalLangTag(const Vector&lt;String&gt;&amp; parts)
 393 {
 394     ASSERT(!parts.isEmpty());
 395 
 396     // Follows the grammar at https://www.rfc-editor.org/rfc/bcp/bcp47.txt
 397     // langtag = language [&quot;-&quot; script] [&quot;-&quot; region] *(&quot;-&quot; variant) *(&quot;-&quot; extension) [&quot;-&quot; privateuse]
 398 
 399     size_t numParts = parts.size();
 400     // Check for language.
 401     // language = 2*3ALPHA [&quot;-&quot; extlang] / 4ALPHA / 5*8ALPHA
 402     size_t currentIndex = 0;
 403     const String&amp; language = parts[currentIndex];
 404     unsigned languageLength = language.length();
 405     bool canHaveExtlang = languageLength &gt;= 2 &amp;&amp; languageLength &lt;= 3;
 406     bool isValidLanguage = languageLength &gt;= 2 &amp;&amp; languageLength &lt;= 8 &amp;&amp; language.isAllSpecialCharacters&lt;isASCIIAlpha&gt;();
 407     if (!isValidLanguage)
 408         return String();
 409 
 410     ++currentIndex;
 411     StringBuilder canonical;
 412 
 413     const String langtag = preferredLanguage(language.convertToASCIILowercase());
 414     canonical.append(langtag);
 415 
 416     // Check for extlang.
 417     // extlang = 3ALPHA *2(&quot;-&quot; 3ALPHA)
 418     if (canHaveExtlang) {
 419         for (unsigned times = 0; times &lt; 3 &amp;&amp; currentIndex &lt; numParts; ++times) {
 420             const String&amp; extlang = parts[currentIndex];
 421             unsigned extlangLength = extlang.length();
 422             if (extlangLength == 3 &amp;&amp; extlang.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
 423                 ++currentIndex;
 424                 auto extlangLower = extlang.convertToASCIILowercase();
 425                 if (!times &amp;&amp; intlPreferredExtlangTag(extlangLower) == langtag) {
 426                     canonical.clear();
 427                     canonical.append(extlangLower);
 428                     continue;
 429                 }
 430                 canonical.append(&#39;-&#39;);
 431                 canonical.append(extlangLower);
 432             } else
 433                 break;
 434         }
 435     }
 436 
 437     // Check for script.
 438     // script = 4ALPHA
 439     if (currentIndex &lt; numParts) {
 440         const String&amp; script = parts[currentIndex];
 441         unsigned scriptLength = script.length();
 442         if (scriptLength == 4 &amp;&amp; script.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
 443             ++currentIndex;
 444             canonical.append(&#39;-&#39;);
 445             canonical.append(toASCIIUpper(script[0]));
 446             canonical.append(script.substring(1, 3).convertToASCIILowercase());
 447         }
 448     }
 449 
 450     // Check for region.
 451     // region = 2ALPHA / 3DIGIT
 452     if (currentIndex &lt; numParts) {
 453         const String&amp; region = parts[currentIndex];
 454         unsigned regionLength = region.length();
 455         bool isValidRegion = (
 456             (regionLength == 2 &amp;&amp; region.isAllSpecialCharacters&lt;isASCIIAlpha&gt;())
 457             || (regionLength == 3 &amp;&amp; region.isAllSpecialCharacters&lt;isASCIIDigit&gt;())
 458         );
 459         if (isValidRegion) {
 460             ++currentIndex;
 461             canonical.append(&#39;-&#39;);
 462             canonical.append(preferredRegion(region.convertToASCIIUppercase()));
 463         }
 464     }
 465 
 466     // Check for variant.
 467     // variant = 5*8alphanum / (DIGIT 3alphanum)
 468     HashSet&lt;String&gt; subtags;
 469     while (currentIndex &lt; numParts) {
 470         const String&amp; variant = parts[currentIndex];
 471         unsigned variantLength = variant.length();
 472         bool isValidVariant = (
 473             (variantLength &gt;= 5 &amp;&amp; variantLength &lt;= 8 &amp;&amp; variant.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;())
 474             || (variantLength == 4 &amp;&amp; isASCIIDigit(variant[0]) &amp;&amp; variant.substring(1, 3).isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;())
 475         );
 476         if (!isValidVariant)
 477             break;
 478 
 479         // Cannot include duplicate subtags (case insensitive).
 480         String lowerVariant = variant.convertToASCIILowercase();
 481         if (!subtags.add(lowerVariant).isNewEntry)
 482             return String();
 483 
 484         ++currentIndex;
 485 
 486         // Reordering variant subtags is not required in the spec.
 487         canonical.append(&#39;-&#39;);
 488         canonical.append(lowerVariant);
 489     }
 490 
 491     // Check for extension.
 492     // extension = singleton 1*(&quot;-&quot; (2*8alphanum))
 493     // singleton = alphanum except x or X
 494     subtags.clear();
 495     Vector&lt;String&gt; extensions;
 496     while (currentIndex &lt; numParts) {
 497         const String&amp; possibleSingleton = parts[currentIndex];
 498         unsigned singletonLength = possibleSingleton.length();
 499         bool isValidSingleton = (singletonLength == 1 &amp;&amp; possibleSingleton != &quot;x&quot; &amp;&amp; possibleSingleton != &quot;X&quot; &amp;&amp; isASCIIAlphanumeric(possibleSingleton[0]));
 500         if (!isValidSingleton)
 501             break;
 502 
 503         // Cannot include duplicate singleton (case insensitive).
 504         String singleton = possibleSingleton.convertToASCIILowercase();
 505         if (!subtags.add(singleton).isNewEntry)
 506             return String();
 507 
 508         ++currentIndex;
 509         int numExtParts = 0;
 510         StringBuilder extension;
 511         extension.append(singleton);
 512         while (currentIndex &lt; numParts) {
 513             const String&amp; extPart = parts[currentIndex];
 514             unsigned extPartLength = extPart.length();
 515 
 516             bool isValid = (extPartLength &gt;= 2 &amp;&amp; extPartLength &lt;= 8 &amp;&amp; extPart.isAllSpecialCharacters&lt;isASCIIAlphanumeric&gt;());
 517             if (!isValid)
 518                 break;
 519 
 520             ++currentIndex;
 521             ++numExtParts;
 522             extension.append(&#39;-&#39;);
 523             extension.append(extPart.convertToASCIILowercase());
 524         }
 525 
 526         // Requires at least one production.
 527         if (!numExtParts)
 528             return String();
 529 
 530         extensions.append(extension.toString());
 531     }
 532 
 533     // Add extensions to canonical sorted by singleton.
 534     std::sort(
 535         extensions.begin(),
 536         extensions.end(),
 537         [] (const String&amp; a, const String&amp; b) -&gt; bool {
 538             return a[0] &lt; b[0];
 539         }
 540     );
 541     size_t numExtenstions = extensions.size();
 542     for (size_t i = 0; i &lt; numExtenstions; ++i) {
 543         canonical.append(&#39;-&#39;);
 544         canonical.append(extensions[i]);
 545     }
 546 
 547     // Check for privateuse.
 548     if (currentIndex &lt; numParts) {
 549         String privateuse = privateUseLangTag(parts, currentIndex);
 550         if (privateuse.isNull())
 551             return String();
 552         canonical.append(&#39;-&#39;);
 553         canonical.append(privateuse);
 554     }
 555 
 556     const String tag = canonical.toString();
 557     const String preferred = intlRedundantLanguageTag(tag);
 558     if (!preferred.isNull())
 559         return preferred;
 560     return tag;
 561 }
 562 
 563 static String canonicalizeLanguageTag(const String&amp; locale)
 564 {
 565     // IsStructurallyValidLanguageTag (locale)
 566     // CanonicalizeLanguageTag (locale)
 567     // These are done one after another in CanonicalizeLocaleList, so they are combined here to reduce duplication.
 568     // https://www.rfc-editor.org/rfc/bcp/bcp47.txt
 569 
 570     // Language-Tag = langtag / privateuse / grandfathered
 571     String grandfather = intlGrandfatheredLanguageTag(locale.convertToASCIILowercase());
 572     if (!grandfather.isNull())
 573         return grandfather;
 574 
 575     Vector&lt;String&gt; parts = locale.splitAllowingEmptyEntries(&#39;-&#39;);
 576     if (!parts.isEmpty()) {
 577         String langtag = canonicalLangTag(parts);
 578         if (!langtag.isNull())
 579             return langtag;
 580 
 581         String privateuse = privateUseLangTag(parts, 0);
 582         if (!privateuse.isNull())
 583             return privateuse;
 584     }
 585 
 586     return String();
 587 }
 588 
 589 Vector&lt;String&gt; canonicalizeLocaleList(JSGlobalObject* globalObject, JSValue locales)
 590 {
 591     // CanonicalizeLocaleList (locales)
 592     // https://tc39.github.io/ecma402/#sec-canonicalizelocalelist
 593 
 594     VM&amp; vm = globalObject-&gt;vm();
 595     auto scope = DECLARE_THROW_SCOPE(vm);
 596 
 597     Vector&lt;String&gt; seen;
 598 
 599     if (locales.isUndefined())
 600         return seen;
 601 
 602     JSObject* localesObject;
 603     if (locales.isString()) {
 604         JSArray* localesArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
 605         if (!localesArray) {
 606             throwOutOfMemoryError(globalObject, scope);
 607             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 608         }
 609         localesArray-&gt;push(globalObject, locales);
 610         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 611 
 612         localesObject = localesArray;
 613     } else {
 614         localesObject = locales.toObject(globalObject);
 615         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 616     }
 617 
 618     // 6. Let len be ToLength(Get(O, &quot;length&quot;)).
 619     JSValue lengthProperty = localesObject-&gt;get(globalObject, vm.propertyNames-&gt;length);
 620     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 621 
 622     double length = lengthProperty.toLength(globalObject);
 623     RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 624 
 625     HashSet&lt;String&gt; seenSet;
 626     for (double k = 0; k &lt; length; ++k) {
 627         bool kPresent = localesObject-&gt;hasProperty(globalObject, k);
 628         RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 629 
 630         if (kPresent) {
 631             JSValue kValue = localesObject-&gt;get(globalObject, k);
 632             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 633 
 634             if (!kValue.isString() &amp;&amp; !kValue.isObject()) {
 635                 throwTypeError(globalObject, scope, &quot;locale value must be a string or object&quot;_s);
 636                 return Vector&lt;String&gt;();
 637             }
 638 
 639             JSString* tag = kValue.toString(globalObject);
 640             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 641 
 642             auto tagValue = tag-&gt;value(globalObject);
 643             RETURN_IF_EXCEPTION(scope, Vector&lt;String&gt;());
 644 
 645             String canonicalizedTag = canonicalizeLanguageTag(tagValue);
 646             if (canonicalizedTag.isNull()) {
 647                 throwException(globalObject, scope, createRangeError(globalObject, &quot;invalid language tag: &quot; + tagValue));
 648                 return Vector&lt;String&gt;();
 649             }
 650 
 651             if (seenSet.add(canonicalizedTag).isNewEntry)
 652                 seen.append(canonicalizedTag);
 653         }
 654     }
 655 
 656     return seen;
 657 }
 658 
 659 String bestAvailableLocale(const HashSet&lt;String&gt;&amp; availableLocales, const String&amp; locale)
 660 {
 661     // BestAvailableLocale (availableLocales, locale)
 662     // https://tc39.github.io/ecma402/#sec-bestavailablelocale
 663 
 664     String candidate = locale;
 665     while (!candidate.isEmpty()) {
 666         if (availableLocales.contains(candidate))
 667             return candidate;
 668 
 669         size_t pos = candidate.reverseFind(&#39;-&#39;);
 670         if (pos == notFound)
 671             return String();
 672 
 673         if (pos &gt;= 2 &amp;&amp; candidate[pos - 2] == &#39;-&#39;)
 674             pos -= 2;
 675 
 676         candidate = candidate.substring(0, pos);
 677     }
 678 
 679     return String();
 680 }
 681 
 682 String defaultLocale(JSGlobalObject* globalObject)
 683 {
 684     // DefaultLocale ()
 685     // https://tc39.github.io/ecma402/#sec-defaultlocale
 686 
 687     // WebCore&#39;s global objects will have their own ideas of how to determine the language. It may
 688     // be determined by WebCore-specific logic like some WK settings. Usually this will return the
 689     // same thing as userPreferredLanguages()[0].
 690     if (auto defaultLanguage = globalObject-&gt;globalObjectMethodTable()-&gt;defaultLanguage) {
 691         String locale = canonicalizeLanguageTag(defaultLanguage());
 692         if (!locale.isEmpty())
 693             return locale;
 694     }
 695 
 696     Vector&lt;String&gt; languages = userPreferredLanguages();
 697     for (const auto&amp; language : languages) {
 698         String locale = canonicalizeLanguageTag(language);
 699         if (!locale.isEmpty())
 700             return locale;
 701     }
 702 
 703     // If all else fails, ask ICU. It will probably say something bogus like en_us even if the user
 704     // has configured some other language, but being wrong is better than crashing.
 705     static NeverDestroyed&lt;String&gt; icuDefaultLocalString;
 706     static std::once_flag initializeOnce;
 707     std::call_once(initializeOnce, [&amp;] {
 708         icuDefaultLocalString.get() = convertICULocaleToBCP47LanguageTag(uloc_getDefault());
 709     });
 710     if (!icuDefaultLocalString-&gt;isEmpty())
 711         return icuDefaultLocalString.get();
 712 
 713     return &quot;en&quot;_s;
 714 }
 715 
 716 String removeUnicodeLocaleExtension(const String&amp; locale)
 717 {
 718     Vector&lt;String&gt; parts = locale.split(&#39;-&#39;);
 719     StringBuilder builder;
 720     size_t partsSize = parts.size();
 721     bool atPrivate = false;
 722     if (partsSize &gt; 0)
 723         builder.append(parts[0]);
 724     for (size_t p = 1; p &lt; partsSize; ++p) {
 725         if (parts[p] == &quot;x&quot;)
 726             atPrivate = true;
 727         if (!atPrivate &amp;&amp; parts[p] == &quot;u&quot; &amp;&amp; p + 1 &lt; partsSize) {
 728             // Skip the u- and anything that follows until another singleton.
 729             // While the next part is part of the unicode extension, skip it.
 730             while (p + 1 &lt; partsSize &amp;&amp; parts[p + 1].length() &gt; 1)
 731                 ++p;
 732         } else {
 733             builder.append(&#39;-&#39;);
 734             builder.append(parts[p]);
 735         }
 736     }
 737     return builder.toString();
 738 }
 739 
 740 static MatcherResult lookupMatcher(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
 741 {
 742     // LookupMatcher (availableLocales, requestedLocales)
 743     // https://tc39.github.io/ecma402/#sec-lookupmatcher
 744 
 745     String locale;
 746     String noExtensionsLocale;
 747     String availableLocale;
 748     for (size_t i = 0; i &lt; requestedLocales.size() &amp;&amp; availableLocale.isNull(); ++i) {
 749         locale = requestedLocales[i];
 750         noExtensionsLocale = removeUnicodeLocaleExtension(locale);
 751         availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
 752     }
 753 
 754     MatcherResult result;
 755     if (!availableLocale.isEmpty()) {
 756         result.locale = availableLocale;
 757         if (locale != noExtensionsLocale) {
 758             size_t extensionIndex = locale.find(&quot;-u-&quot;);
 759             RELEASE_ASSERT(extensionIndex != notFound);
 760 
 761             size_t extensionLength = locale.length() - extensionIndex;
 762             size_t end = extensionIndex + 3;
 763             while (end &lt; locale.length()) {
 764                 end = locale.find(&#39;-&#39;, end);
 765                 if (end == notFound)
 766                     break;
 767                 if (end + 2 &lt; locale.length() &amp;&amp; locale[end + 2] == &#39;-&#39;) {
 768                     extensionLength = end - extensionIndex;
 769                     break;
 770                 }
 771                 end++;
 772             }
 773             result.extension = locale.substring(extensionIndex, extensionLength);
 774             result.extensionIndex = extensionIndex;
 775         }
 776     } else
 777         result.locale = defaultLocale(globalObject);
 778     return result;
 779 }
 780 
 781 static MatcherResult bestFitMatcher(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
 782 {
 783     // BestFitMatcher (availableLocales, requestedLocales)
 784     // https://tc39.github.io/ecma402/#sec-bestfitmatcher
 785 
 786     // FIXME: Implement something better than lookup.
 787     return lookupMatcher(globalObject, availableLocales, requestedLocales);
 788 }
 789 
 790 static void unicodeExtensionSubTags(const String&amp; extension, Vector&lt;String&gt;&amp; subtags)
 791 {
 792     // UnicodeExtensionSubtags (extension)
 793     // https://tc39.github.io/ecma402/#sec-unicodeextensionsubtags
 794 
 795     auto extensionLength = extension.length();
 796     if (extensionLength &lt; 3)
 797         return;
 798 
 799     size_t subtagStart = 3; // Skip initial -u-.
 800     size_t valueStart = 3;
 801     bool isLeading = true;
 802     for (size_t index = subtagStart; index &lt; extensionLength; ++index) {
 803         if (extension[index] == &#39;-&#39;) {
 804             if (index - subtagStart == 2) {
 805                 // Tag is a key, first append prior key&#39;s value if there is one.
 806                 if (subtagStart - valueStart &gt; 1)
 807                     subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
 808                 subtags.append(extension.substring(subtagStart, index - subtagStart));
 809                 valueStart = index + 1;
 810                 isLeading = false;
 811             } else if (isLeading) {
 812                 // Leading subtags before first key.
 813                 subtags.append(extension.substring(subtagStart, index - subtagStart));
 814                 valueStart = index + 1;
 815             }
 816             subtagStart = index + 1;
 817         }
 818     }
 819     if (extensionLength - subtagStart == 2) {
 820         // Trailing an extension key, first append prior key&#39;s value if there is one.
 821         if (subtagStart - valueStart &gt; 1)
 822             subtags.append(extension.substring(valueStart, subtagStart - valueStart - 1));
 823         valueStart = subtagStart;
 824     }
 825     // Append final key&#39;s value.
 826     subtags.append(extension.substring(valueStart, extensionLength - valueStart));
 827 }
 828 
 829 HashMap&lt;String, String&gt; resolveLocale(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, const HashMap&lt;String, String&gt;&amp; options, const char* const relevantExtensionKeys[], size_t relevantExtensionKeyCount, Vector&lt;String&gt; (*localeData)(const String&amp;, size_t))
 830 {
 831     // ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData)
 832     // https://tc39.github.io/ecma402/#sec-resolvelocale
 833 
 834     const String&amp; matcher = options.get(&quot;localeMatcher&quot;_s);
 835     MatcherResult matcherResult = (matcher == &quot;lookup&quot;)
 836         ? lookupMatcher(globalObject, availableLocales, requestedLocales)
 837         : bestFitMatcher(globalObject, availableLocales, requestedLocales);
 838 
 839     String foundLocale = matcherResult.locale;
 840 
 841     Vector&lt;String&gt; extensionSubtags;
 842     if (!matcherResult.extension.isNull())
 843         unicodeExtensionSubTags(matcherResult.extension, extensionSubtags);
 844 
 845     HashMap&lt;String, String&gt; result;
 846     result.add(&quot;dataLocale&quot;_s, foundLocale);
 847 
 848     String supportedExtension = &quot;-u&quot;_s;
 849     for (size_t keyIndex = 0; keyIndex &lt; relevantExtensionKeyCount; ++keyIndex) {
 850         const char* key = relevantExtensionKeys[keyIndex];
 851         Vector&lt;String&gt; keyLocaleData = localeData(foundLocale, keyIndex);
 852         ASSERT(!keyLocaleData.isEmpty());
 853 
 854         String value = keyLocaleData[0];
 855         String supportedExtensionAddition;
 856 
 857         if (!extensionSubtags.isEmpty()) {
 858             size_t keyPos = extensionSubtags.find(key);
 859             if (keyPos != notFound) {
 860                 if (keyPos + 1 &lt; extensionSubtags.size() &amp;&amp; extensionSubtags[keyPos + 1].length() &gt; 2) {
 861                     const String&amp; requestedValue = extensionSubtags[keyPos + 1];
 862                     if (keyLocaleData.contains(requestedValue)) {
 863                         value = requestedValue;
 864                         supportedExtensionAddition = makeString(&#39;-&#39;, key, &#39;-&#39;, value);
 865                     }
 866                 } else if (keyLocaleData.contains(static_cast&lt;String&gt;(&quot;true&quot;_s))) {
 867                     value = &quot;true&quot;_s;
 868                 }
 869             }
 870         }
 871 
 872         HashMap&lt;String, String&gt;::const_iterator iterator = options.find(key);
 873         if (iterator != options.end()) {
 874             const String&amp; optionsValue = iterator-&gt;value;
 875             // Undefined should not get added to the options, it won&#39;t displace the extension.
 876             // Null will remove the extension.
 877             if ((optionsValue.isNull() || keyLocaleData.contains(optionsValue)) &amp;&amp; optionsValue != value) {
 878                 value = optionsValue;
 879                 supportedExtensionAddition = String();
 880             }
 881         }
 882         result.add(key, value);
 883         supportedExtension.append(supportedExtensionAddition);
 884     }
 885 
 886     if (supportedExtension.length() &gt; 2) {
 887         String preExtension = foundLocale.substring(0, matcherResult.extensionIndex);
 888         String postExtension = foundLocale.substring(matcherResult.extensionIndex);
 889         foundLocale = preExtension + supportedExtension + postExtension;
 890     }
 891 
 892     result.add(&quot;locale&quot;_s, foundLocale);
 893     return result;
 894 }
 895 
 896 static JSArray* lookupSupportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
 897 {
 898     // LookupSupportedLocales (availableLocales, requestedLocales)
 899     // https://tc39.github.io/ecma402/#sec-lookupsupportedlocales
 900 
 901     VM&amp; vm = globalObject-&gt;vm();
 902     auto scope = DECLARE_THROW_SCOPE(vm);
 903 
 904     size_t len = requestedLocales.size();
 905     JSArray* subset = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), 0);
 906     if (!subset) {
 907         throwOutOfMemoryError(globalObject, scope);
 908         return nullptr;
 909     }
 910 
 911     unsigned index = 0;
 912     for (size_t k = 0; k &lt; len; ++k) {
 913         const String&amp; locale = requestedLocales[k];
 914         String noExtensionsLocale = removeUnicodeLocaleExtension(locale);
 915         String availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);
 916         if (!availableLocale.isNull()) {
 917             subset-&gt;putDirectIndex(globalObject, index++, jsString(vm, locale));
 918             RETURN_IF_EXCEPTION(scope, nullptr);
 919         }
 920     }
 921 
 922     return subset;
 923 }
 924 
 925 static JSArray* bestFitSupportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales)
 926 {
 927     // BestFitSupportedLocales (availableLocales, requestedLocales)
 928     // https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales
 929 
 930     // FIXME: Implement something better than lookup.
 931     return lookupSupportedLocales(globalObject, availableLocales, requestedLocales);
 932 }
 933 
 934 JSValue supportedLocales(JSGlobalObject* globalObject, const HashSet&lt;String&gt;&amp; availableLocales, const Vector&lt;String&gt;&amp; requestedLocales, JSValue options)
 935 {
 936     // SupportedLocales (availableLocales, requestedLocales, options)
 937     // https://tc39.github.io/ecma402/#sec-supportedlocales
 938 
 939     VM&amp; vm = globalObject-&gt;vm();
 940     auto scope = DECLARE_THROW_SCOPE(vm);
 941     String matcher;
 942 
 943     if (!options.isUndefined()) {
 944         matcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);
 945         RETURN_IF_EXCEPTION(scope, JSValue());
 946     } else
 947         matcher = &quot;best fit&quot;_s;
 948 
 949     JSArray* supportedLocales = (matcher == &quot;best fit&quot;)
 950         ? bestFitSupportedLocales(globalObject, availableLocales, requestedLocales)
 951         : lookupSupportedLocales(globalObject, availableLocales, requestedLocales);
 952     RETURN_IF_EXCEPTION(scope, JSValue());
 953 
 954     PropertyNameArray keys(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
 955     supportedLocales-&gt;getOwnPropertyNames(supportedLocales, globalObject, keys, EnumerationMode());
 956     RETURN_IF_EXCEPTION(scope, JSValue());
 957 
 958     PropertyDescriptor desc;
 959     desc.setConfigurable(false);
 960     desc.setWritable(false);
 961 
 962     size_t len = keys.size();
 963     for (size_t i = 0; i &lt; len; ++i) {
 964         supportedLocales-&gt;defineOwnProperty(supportedLocales, globalObject, keys[i], desc, true);
 965         RETURN_IF_EXCEPTION(scope, JSValue());
 966     }
 967     supportedLocales-&gt;defineOwnProperty(supportedLocales, globalObject, vm.propertyNames-&gt;length, desc, true);
 968     RETURN_IF_EXCEPTION(scope, JSValue());
 969 
 970     return supportedLocales;
 971 }
 972 
 973 Vector&lt;String&gt; numberingSystemsForLocale(const String&amp; locale)
 974 {
 975     static NeverDestroyed&lt;Vector&lt;String&gt;&gt; cachedNumberingSystems;
 976     Vector&lt;String&gt;&amp; availableNumberingSystems = cachedNumberingSystems.get();
 977 
 978     static std::once_flag initializeOnce;
 979     std::call_once(initializeOnce, [&amp;] {
 980         ASSERT(availableNumberingSystems.isEmpty());
 981         UErrorCode status = U_ZERO_ERROR;
 982         UEnumeration* numberingSystemNames = unumsys_openAvailableNames(&amp;status);
 983         ASSERT(U_SUCCESS(status));
 984 
 985         int32_t resultLength;
 986         // Numbering system names are always ASCII, so use char[].
 987         while (const char* result = uenum_next(numberingSystemNames, &amp;resultLength, &amp;status)) {
 988             ASSERT(U_SUCCESS(status));
 989             auto numsys = unumsys_openByName(result, &amp;status);
 990             ASSERT(U_SUCCESS(status));
 991             // Only support algorithmic if it is the default fot the locale, handled below.
 992             if (!unumsys_isAlgorithmic(numsys))
 993                 availableNumberingSystems.append(String(StringImpl::createStaticStringImpl(result, resultLength)));
 994             unumsys_close(numsys);
 995         }
 996         uenum_close(numberingSystemNames);
 997     });
 998 
 999     UErrorCode status = U_ZERO_ERROR;
1000     UNumberingSystem* defaultSystem = unumsys_open(locale.utf8().data(), &amp;status);
1001     ASSERT(U_SUCCESS(status));
1002     String defaultSystemName(unumsys_getName(defaultSystem));
1003     unumsys_close(defaultSystem);
1004 
1005     Vector&lt;String&gt; numberingSystems({ defaultSystemName });
1006     numberingSystems.appendVector(availableNumberingSystems);
1007     return numberingSystems;
1008 }
1009 
1010 EncodedJSValue JSC_HOST_CALL intlObjectFuncGetCanonicalLocales(JSGlobalObject* globalObject, CallFrame* callFrame)
1011 {
1012     // Intl.getCanonicalLocales(locales)
1013     // https://tc39.github.io/ecma402/#sec-intl.getcanonicallocales
1014 
1015     VM&amp; vm = globalObject-&gt;vm();
1016     auto scope = DECLARE_THROW_SCOPE(vm);
1017 
1018     Vector&lt;String&gt; localeList = canonicalizeLocaleList(globalObject, callFrame-&gt;argument(0));
1019     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1020     auto length = localeList.size();
1021 
1022     JSArray* localeArray = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), length);
1023     if (!localeArray) {
1024         throwOutOfMemoryError(globalObject, scope);
1025         return encodedJSValue();
1026     }
1027 
1028     for (size_t i = 0; i &lt; length; ++i) {
1029         localeArray-&gt;putDirectIndex(globalObject, i, jsString(vm, localeList[i]));
1030         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1031     }
1032     return JSValue::encode(localeArray);
1033 }
1034 
1035 } // namespace JSC
1036 
1037 #endif // ENABLE(INTL)
    </pre>
  </body>
</html>
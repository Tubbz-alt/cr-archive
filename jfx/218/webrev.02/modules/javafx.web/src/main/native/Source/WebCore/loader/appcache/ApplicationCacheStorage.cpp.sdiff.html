<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/appcache/ApplicationCacheStorage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ApplicationCacheResourceLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../archive/mhtml/MHTMLArchive.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/appcache/ApplicationCacheStorage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1042 
1043     groupStorageIDJournal.commit();
1044     resourceStorageIDJournal.commit();
1045     storeCacheTransaction.commit();
1046     return true;
1047 }
1048 
1049 bool ApplicationCacheStorage::storeNewestCache(ApplicationCacheGroup&amp; group)
1050 {
1051     // Ignore the reason for failing, just attempt the store.
1052     FailureReason ignoredFailureReason;
1053     return storeNewestCache(group, nullptr, ignoredFailureReason);
1054 }
1055 
1056 template&lt;typename CharacterType&gt;
1057 static inline void parseHeader(const CharacterType* header, unsigned headerLength, ResourceResponse&amp; response)
1058 {
1059     ASSERT(find(header, headerLength, &#39;:&#39;) != notFound);
1060     unsigned colonPosition = find(header, headerLength, &#39;:&#39;);
1061 
<span class="line-modified">1062     // Save memory by putting the header names into atomic strings so each is stored only once,</span>
<span class="line-modified">1063     // even though the setHTTPHeaderField function does not require an atomic string.</span>
1064     AtomString headerName { header, colonPosition };
1065     String headerValue { header + colonPosition + 1, headerLength - colonPosition - 1 };
1066 
1067     response.setHTTPHeaderField(headerName, headerValue);
1068 }
1069 
1070 static inline void parseHeaders(const String&amp; headers, ResourceResponse&amp; response)
1071 {
1072     unsigned startPos = 0;
1073     size_t endPos;
1074     while ((endPos = headers.find(&#39;\n&#39;, startPos)) != notFound) {
1075         ASSERT(startPos != endPos);
1076 
1077         if (headers.is8Bit())
1078             parseHeader(headers.characters8() + startPos, endPos - startPos, response);
1079         else
1080             parseHeader(headers.characters16() + startPos, endPos - startPos, response);
1081 
1082         startPos = endPos + 1;
1083     }
</pre>
</td>
<td>
<hr />
<pre>
1042 
1043     groupStorageIDJournal.commit();
1044     resourceStorageIDJournal.commit();
1045     storeCacheTransaction.commit();
1046     return true;
1047 }
1048 
1049 bool ApplicationCacheStorage::storeNewestCache(ApplicationCacheGroup&amp; group)
1050 {
1051     // Ignore the reason for failing, just attempt the store.
1052     FailureReason ignoredFailureReason;
1053     return storeNewestCache(group, nullptr, ignoredFailureReason);
1054 }
1055 
1056 template&lt;typename CharacterType&gt;
1057 static inline void parseHeader(const CharacterType* header, unsigned headerLength, ResourceResponse&amp; response)
1058 {
1059     ASSERT(find(header, headerLength, &#39;:&#39;) != notFound);
1060     unsigned colonPosition = find(header, headerLength, &#39;:&#39;);
1061 
<span class="line-modified">1062     // Save memory by putting the header names into atom strings so each is stored only once,</span>
<span class="line-modified">1063     // even though the setHTTPHeaderField function does not require an atom string.</span>
1064     AtomString headerName { header, colonPosition };
1065     String headerValue { header + colonPosition + 1, headerLength - colonPosition - 1 };
1066 
1067     response.setHTTPHeaderField(headerName, headerValue);
1068 }
1069 
1070 static inline void parseHeaders(const String&amp; headers, ResourceResponse&amp; response)
1071 {
1072     unsigned startPos = 0;
1073     size_t endPos;
1074     while ((endPos = headers.find(&#39;\n&#39;, startPos)) != notFound) {
1075         ASSERT(startPos != endPos);
1076 
1077         if (headers.is8Bit())
1078             parseHeader(headers.characters8() + startPos, endPos - startPos, response);
1079         else
1080             parseHeader(headers.characters16() + startPos, endPos - startPos, response);
1081 
1082         startPos = endPos + 1;
1083     }
</pre>
</td>
</tr>
</table>
<center><a href="ApplicationCacheResourceLoader.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../archive/mhtml/MHTMLArchive.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
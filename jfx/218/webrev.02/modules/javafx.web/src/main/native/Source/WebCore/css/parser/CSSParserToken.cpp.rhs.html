<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserToken.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2014 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2016 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSParserToken.h&quot;
 32 
 33 #include &quot;CSSMarkup.h&quot;
 34 #include &quot;CSSPrimitiveValue.h&quot;
 35 #include &quot;CSSPropertyParser.h&quot;
 36 #include &lt;limits.h&gt;
 37 #include &lt;wtf/HexNumber.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 template&lt;typename CharacterType&gt;
<a name="1" id="anc1"></a><span class="line-modified"> 43 CSSUnitType cssPrimitiveValueUnitFromTrie(const CharacterType* data, unsigned length)</span>
 44 {
 45     ASSERT(data);
 46     ASSERT(length);
 47     switch (length) {
 48     case 1:
 49         switch (toASCIILower(data[0])) {
<a name="2" id="anc2"></a><span class="line-added"> 50         case &#39;q&#39;:</span>
<span class="line-added"> 51             return CSSUnitType::CSS_Q;</span>
 52         case &#39;s&#39;:
<a name="3" id="anc3"></a><span class="line-modified"> 53             return CSSUnitType::CSS_S;</span>
 54         }
 55         break;
 56     case 2:
 57         switch (toASCIILower(data[0])) {
 58         case &#39;c&#39;:
 59             switch (toASCIILower(data[1])) {
 60             case &#39;h&#39;:
<a name="4" id="anc4"></a><span class="line-modified"> 61                 return CSSUnitType::CSS_CHS;</span>
 62             case &#39;m&#39;:
<a name="5" id="anc5"></a><span class="line-modified"> 63                 return CSSUnitType::CSS_CM;</span>
 64             }
 65             break;
 66         case &#39;e&#39;:
 67             switch (toASCIILower(data[1])) {
 68             case &#39;m&#39;:
<a name="6" id="anc6"></a><span class="line-modified"> 69                 return CSSUnitType::CSS_EMS;</span>
 70             case &#39;x&#39;:
<a name="7" id="anc7"></a><span class="line-modified"> 71                 return CSSUnitType::CSS_EXS;</span>
 72             }
 73             break;
 74         case &#39;f&#39;:
 75             if (toASCIILower(data[1]) == &#39;r&#39;)
<a name="8" id="anc8"></a><span class="line-modified"> 76                 return CSSUnitType::CSS_FR;</span>
 77             break;
 78         case &#39;h&#39;:
 79             if (toASCIILower(data[1]) == &#39;z&#39;)
<a name="9" id="anc9"></a><span class="line-modified"> 80                 return CSSUnitType::CSS_HZ;</span>
 81             break;
 82         case &#39;i&#39;:
 83             if (toASCIILower(data[1]) == &#39;n&#39;)
<a name="10" id="anc10"></a><span class="line-modified"> 84                 return CSSUnitType::CSS_IN;</span>
 85             break;
 86         case &#39;m&#39;:
 87             switch (toASCIILower(data[1])) {
 88             case &#39;m&#39;:
<a name="11" id="anc11"></a><span class="line-modified"> 89                 return CSSUnitType::CSS_MM;</span>
 90             case &#39;s&#39;:
<a name="12" id="anc12"></a><span class="line-modified"> 91                 return CSSUnitType::CSS_MS;</span>
 92             }
 93             break;
 94         case &#39;p&#39;:
 95             switch (toASCIILower(data[1])) {
 96             case &#39;c&#39;:
<a name="13" id="anc13"></a><span class="line-modified"> 97                 return CSSUnitType::CSS_PC;</span>
 98             case &#39;t&#39;:
<a name="14" id="anc14"></a><span class="line-modified"> 99                 return CSSUnitType::CSS_PT;</span>
100             case &#39;x&#39;:
<a name="15" id="anc15"></a><span class="line-modified">101                 return CSSUnitType::CSS_PX;</span>
102             }
103             break;
104         case &#39;v&#39;:
105             switch (toASCIILower(data[1])) {
106             case &#39;h&#39;:
<a name="16" id="anc16"></a><span class="line-modified">107                 return CSSUnitType::CSS_VH;</span>
108             case &#39;w&#39;:
<a name="17" id="anc17"></a><span class="line-modified">109                 return CSSUnitType::CSS_VW;</span>
110             }
111             break;
112         }
113         break;
114     case 3:
115         switch (toASCIILower(data[0])) {
116         case &#39;d&#39;:
117             switch (toASCIILower(data[1])) {
118             case &#39;e&#39;:
119                 if (toASCIILower(data[2]) == &#39;g&#39;)
<a name="18" id="anc18"></a><span class="line-modified">120                     return CSSUnitType::CSS_DEG;</span>
121                 break;
122             case &#39;p&#39;:
123                 if (toASCIILower(data[2]) == &#39;i&#39;)
<a name="19" id="anc19"></a><span class="line-modified">124                     return CSSUnitType::CSS_DPI;</span>
125                 break;
126             }
127         break;
128         case &#39;k&#39;:
129             if (toASCIILower(data[1]) == &#39;h&#39; &amp;&amp; toASCIILower(data[2]) == &#39;z&#39;)
<a name="20" id="anc20"></a><span class="line-modified">130                 return CSSUnitType::CSS_KHZ;</span>
131             break;
132         case &#39;r&#39;:
133             switch (toASCIILower(data[1])) {
134             case &#39;a&#39;:
135                 if (toASCIILower(data[2]) == &#39;d&#39;)
<a name="21" id="anc21"></a><span class="line-modified">136                     return CSSUnitType::CSS_RAD;</span>
137                 break;
138             case &#39;e&#39;:
139                 if (toASCIILower(data[2]) == &#39;m&#39;)
<a name="22" id="anc22"></a><span class="line-modified">140                     return CSSUnitType::CSS_REMS;</span>
141                 break;
142             }
143         break;
144     }
145     break;
146     case 4:
147         switch (toASCIILower(data[0])) {
148         case &#39;d&#39;:
149             switch (toASCIILower(data[1])) {
150             case &#39;p&#39;:
151                 switch (toASCIILower(data[2])) {
152                 case &#39;c&#39;:
153                     if (toASCIILower(data[3]) == &#39;m&#39;)
<a name="23" id="anc23"></a><span class="line-modified">154                         return CSSUnitType::CSS_DPCM;</span>
155                     break;
156                 case &#39;p&#39;:
157                     if (toASCIILower(data[3]) == &#39;x&#39;)
<a name="24" id="anc24"></a><span class="line-modified">158                         return CSSUnitType::CSS_DPPX;</span>
159                     break;
160                 }
161             break;
162         }
163         break;
164         case &#39;g&#39;:
165             if (toASCIILower(data[1]) == &#39;r&#39; &amp;&amp; toASCIILower(data[2]) == &#39;a&#39; &amp;&amp; toASCIILower(data[3]) == &#39;d&#39;)
<a name="25" id="anc25"></a><span class="line-modified">166                 return CSSUnitType::CSS_GRAD;</span>
167             break;
168         case &#39;t&#39;:
169             if (toASCIILower(data[1]) == &#39;u&#39; &amp;&amp; toASCIILower(data[2]) == &#39;r&#39; &amp;&amp; toASCIILower(data[3]) == &#39;n&#39;)
<a name="26" id="anc26"></a><span class="line-modified">170                 return CSSUnitType::CSS_TURN;</span>
171             break;
172         case &#39;v&#39;:
173             switch (toASCIILower(data[1])) {
174             case &#39;m&#39;:
175                 switch (toASCIILower(data[2])) {
176                 case &#39;a&#39;:
177                     if (toASCIILower(data[3]) == &#39;x&#39;)
<a name="27" id="anc27"></a><span class="line-modified">178                         return CSSUnitType::CSS_VMAX;</span>
179                     break;
180                 case &#39;i&#39;:
181                     if (toASCIILower(data[3]) == &#39;n&#39;)
<a name="28" id="anc28"></a><span class="line-modified">182                         return CSSUnitType::CSS_VMIN;</span>
183                     break;
184                 }
185                 break;
186             }
187             break;
188         }
189         break;
190     case 5:
191         switch (toASCIILower(data[0])) {
192         case &#39;_&#39;:
193             if (toASCIILower(data[1]) == &#39;_&#39; &amp;&amp; toASCIILower(data[2]) == &#39;q&#39; &amp;&amp; toASCIILower(data[3]) == &#39;e&#39; &amp;&amp; toASCIILower(data[4]) == &#39;m&#39;)
<a name="29" id="anc29"></a><span class="line-modified">194                 return CSSUnitType::CSS_QUIRKY_EMS;</span>
195             break;
196         }
197         break;
198     }
<a name="30" id="anc30"></a><span class="line-modified">199     return CSSUnitType::CSS_UNKNOWN;</span>
200 }
201 
<a name="31" id="anc31"></a><span class="line-modified">202 static CSSUnitType stringToUnitType(StringView stringView)</span>
203 {
204     if (stringView.is8Bit())
205         return cssPrimitiveValueUnitFromTrie(stringView.characters8(), stringView.length());
206     return cssPrimitiveValueUnitFromTrie(stringView.characters16(), stringView.length());
207 }
208 
209 CSSParserToken::CSSParserToken(CSSParserTokenType type, BlockType blockType)
210     : m_type(type)
211     , m_blockType(blockType)
212 {
213 }
214 
215 // Just a helper used for Delimiter tokens.
216 CSSParserToken::CSSParserToken(CSSParserTokenType type, UChar c)
217     : m_type(type)
218     , m_blockType(NotBlock)
219     , m_delimiter(c)
220 {
221     ASSERT(m_type == DelimiterToken);
222 }
223 
224 CSSParserToken::CSSParserToken(CSSParserTokenType type, StringView value, BlockType blockType)
225     : m_type(type)
226     , m_blockType(blockType)
227 {
228     initValueFromStringView(value);
229     m_id = -1;
230 }
231 
232 CSSParserToken::CSSParserToken(CSSParserTokenType type, double numericValue, NumericValueType numericValueType, NumericSign sign)
233     : m_type(type)
234     , m_blockType(NotBlock)
235     , m_numericValueType(numericValueType)
236     , m_numericSign(sign)
<a name="32" id="anc32"></a><span class="line-modified">237     , m_unit(static_cast&lt;unsigned&gt;(CSSUnitType::CSS_NUMBER))</span>
238 {
239     ASSERT(type == NumberToken);
240     m_numericValue = numericValue;
241 }
242 
243 CSSParserToken::CSSParserToken(CSSParserTokenType type, UChar32 start, UChar32 end)
244     : m_type(UnicodeRangeToken)
245     , m_blockType(NotBlock)
246 {
247     ASSERT_UNUSED(type, type == UnicodeRangeToken);
248     m_unicodeRange.start = start;
249     m_unicodeRange.end = end;
250 }
251 
252 CSSParserToken::CSSParserToken(HashTokenType type, StringView value)
253     : m_type(HashToken)
254     , m_blockType(NotBlock)
255     , m_hashTokenType(type)
256 {
257     initValueFromStringView(value);
258 }
259 
260 void CSSParserToken::convertToDimensionWithUnit(StringView unit)
261 {
262     ASSERT(m_type == NumberToken);
263     m_type = DimensionToken;
264     initValueFromStringView(unit);
265     m_unit = static_cast&lt;unsigned&gt;(stringToUnitType(unit));
266 }
267 
268 void CSSParserToken::convertToPercentage()
269 {
270     ASSERT(m_type == NumberToken);
271     m_type = PercentageToken;
<a name="33" id="anc33"></a><span class="line-modified">272     m_unit = static_cast&lt;unsigned&gt;(CSSUnitType::CSS_PERCENTAGE);</span>
273 }
274 
275 UChar CSSParserToken::delimiter() const
276 {
277     ASSERT(m_type == DelimiterToken);
278     return m_delimiter;
279 }
280 
281 NumericSign CSSParserToken::numericSign() const
282 {
283     // This is valid for DimensionToken and PercentageToken, but only used
284     // in &lt;an+b&gt; parsing on NumberTokens.
285     ASSERT(m_type == NumberToken);
286     return static_cast&lt;NumericSign&gt;(m_numericSign);
287 }
288 
289 NumericValueType CSSParserToken::numericValueType() const
290 {
291     ASSERT(m_type == NumberToken || m_type == PercentageToken || m_type == DimensionToken);
292     return static_cast&lt;NumericValueType&gt;(m_numericValueType);
293 }
294 
295 double CSSParserToken::numericValue() const
296 {
297     ASSERT(m_type == NumberToken || m_type == PercentageToken || m_type == DimensionToken);
298     return m_numericValue;
299 }
300 
301 CSSPropertyID CSSParserToken::parseAsCSSPropertyID() const
302 {
303     ASSERT(m_type == IdentToken);
304     return cssPropertyID(value());
305 }
306 
307 CSSValueID CSSParserToken::id() const
308 {
309     if (m_type != IdentToken)
310         return CSSValueInvalid;
311     if (m_id &lt; 0)
312         m_id = cssValueKeywordID(value());
313     return static_cast&lt;CSSValueID&gt;(m_id);
314 }
315 
316 CSSValueID CSSParserToken::functionId() const
317 {
318     if (m_type != FunctionToken)
319         return CSSValueInvalid;
320     if (m_id &lt; 0)
321         m_id = cssValueKeywordID(value());
322     return static_cast&lt;CSSValueID&gt;(m_id);
323 }
324 
325 bool CSSParserToken::hasStringBacking() const
326 {
327     CSSParserTokenType tokenType = type();
328     return tokenType == IdentToken
329         || tokenType == FunctionToken
330         || tokenType == AtKeywordToken
331         || tokenType == HashToken
332         || tokenType == UrlToken
333         || tokenType == DimensionToken
334         || tokenType == StringToken;
335 }
336 
337 CSSParserToken CSSParserToken::copyWithUpdatedString(const StringView&amp; string) const
338 {
339     CSSParserToken copy(*this);
340     copy.initValueFromStringView(string);
341     return copy;
342 }
343 
344 bool CSSParserToken::valueDataCharRawEqual(const CSSParserToken&amp; other) const
345 {
346     if (m_valueLength != other.m_valueLength)
347         return false;
348 
349     if (m_valueDataCharRaw == other.m_valueDataCharRaw &amp;&amp; m_valueIs8Bit == other.m_valueIs8Bit)
350         return true;
351 
352     if (m_valueIs8Bit)
353         return other.m_valueIs8Bit ? equal(static_cast&lt;const LChar*&gt;(m_valueDataCharRaw), static_cast&lt;const LChar*&gt;(other.m_valueDataCharRaw), m_valueLength) : equal(static_cast&lt;const LChar*&gt;(m_valueDataCharRaw), static_cast&lt;const UChar*&gt;(other.m_valueDataCharRaw), m_valueLength);
354 
355     return other.m_valueIs8Bit ? equal(static_cast&lt;const UChar*&gt;(m_valueDataCharRaw), static_cast&lt;const LChar*&gt;(other.m_valueDataCharRaw), m_valueLength) : equal(static_cast&lt;const UChar*&gt;(m_valueDataCharRaw), static_cast&lt;const UChar*&gt;(other.m_valueDataCharRaw), m_valueLength);
356 }
357 
358 bool CSSParserToken::operator==(const CSSParserToken&amp; other) const
359 {
360     if (m_type != other.m_type)
361         return false;
362     switch (m_type) {
363     case DelimiterToken:
364         return delimiter() == other.delimiter();
365     case HashToken:
366         if (m_hashTokenType != other.m_hashTokenType)
367             return false;
368         FALLTHROUGH;
369     case IdentToken:
370     case FunctionToken:
371     case StringToken:
372     case UrlToken:
373         return valueDataCharRawEqual(other);
374     case DimensionToken:
375         if (!valueDataCharRawEqual(other))
376             return false;
377         FALLTHROUGH;
378     case NumberToken:
379     case PercentageToken:
380         return m_numericSign == other.m_numericSign &amp;&amp; m_numericValue == other.m_numericValue &amp;&amp; m_numericValueType == other.m_numericValueType;
381     case UnicodeRangeToken:
382         return m_unicodeRange.start == other.m_unicodeRange.start &amp;&amp; m_unicodeRange.end == other.m_unicodeRange.end;
383     default:
384         return true;
385     }
386 }
387 
388 void CSSParserToken::serialize(StringBuilder&amp; builder) const
389 {
390     // This is currently only used for @supports CSSOM. To keep our implementation
391     // simple we handle some of the edge cases incorrectly (see comments below).
392     switch (type()) {
393     case IdentToken:
394         serializeIdentifier(value().toString(), builder);
395         break;
396     case FunctionToken:
397         serializeIdentifier(value().toString(), builder);
398         builder.append(&#39;(&#39;);
399         break;
400     case AtKeywordToken:
401         builder.append(&#39;@&#39;);
402         serializeIdentifier(value().toString(), builder);
403         break;
404     case HashToken:
405         builder.append(&#39;#&#39;);
406         serializeIdentifier(value().toString(), builder, (getHashTokenType() == HashTokenUnrestricted));
407         break;
408     case UrlToken:
409         builder.appendLiteral(&quot;url(&quot;);
410         serializeIdentifier(value().toString(), builder);
411         builder.append(&#39;)&#39;);
412         break;
413     case DelimiterToken:
414         if (delimiter() == &#39;\\&#39;) {
415             builder.appendLiteral(&quot;\\\n&quot;);
416             break;
417         }
418         builder.append(delimiter());
419         break;
420     case NumberToken:
421         // These won&#39;t properly preserve the NumericValueType flag
422         if (m_numericSign == PlusSign)
423             builder.append(&#39;+&#39;);
<a name="34" id="anc34"></a><span class="line-modified">424         builder.append(numericValue());</span>
425         break;
426     case PercentageToken:
<a name="35" id="anc35"></a><span class="line-modified">427         builder.append(numericValue(), &#39;%&#39;);</span>

428         break;
429     case DimensionToken:
430         // This will incorrectly serialize e.g. 4e3e2 as 4000e2
<a name="36" id="anc36"></a><span class="line-modified">431         builder.append(numericValue());</span>
432         serializeIdentifier(value().toString(), builder);
433         break;
434     case UnicodeRangeToken:
435         builder.appendLiteral(&quot;U+&quot;);
<a name="37" id="anc37"></a><span class="line-modified">436         builder.append(hex(unicodeRangeStart()));</span>
437         builder.append(&#39;-&#39;);
<a name="38" id="anc38"></a><span class="line-modified">438         builder.append(hex(unicodeRangeEnd()));</span>
439         break;
440     case StringToken:
441         serializeString(value().toString(), builder);
442         break;
443 
444     case IncludeMatchToken:
445         builder.appendLiteral(&quot;~=&quot;);
446         break;
447     case DashMatchToken:
448         builder.appendLiteral(&quot;|=&quot;);
449         break;
450     case PrefixMatchToken:
451         builder.appendLiteral(&quot;^=&quot;);
452         break;
453     case SuffixMatchToken:
454         builder.appendLiteral(&quot;$=&quot;);
455         break;
456     case SubstringMatchToken:
457         builder.appendLiteral(&quot;*=&quot;);
458         break;
459     case ColumnToken:
460         builder.appendLiteral(&quot;||&quot;);
461         break;
462     case CDOToken:
463         builder.appendLiteral(&quot;&lt;!--&quot;);
464         break;
465     case CDCToken:
466         builder.appendLiteral(&quot;--&gt;&quot;);
467         break;
468     case BadStringToken:
469         builder.appendLiteral(&quot;&#39;\n&quot;);
470         break;
471     case BadUrlToken:
472         builder.appendLiteral(&quot;url(()&quot;);
473         break;
474     case WhitespaceToken:
475         builder.append(&#39; &#39;);
476         break;
477     case ColonToken:
478         builder.append(&#39;:&#39;);
479         break;
480     case SemicolonToken:
481         builder.append(&#39;;&#39;);
482         break;
483     case CommaToken:
484         builder.append(&#39;,&#39;);
485         break;
486     case LeftParenthesisToken:
487         builder.append(&#39;(&#39;);
488         break;
489     case RightParenthesisToken:
490         builder.append(&#39;)&#39;);
491         break;
492     case LeftBracketToken:
493         builder.append(&#39;[&#39;);
494         break;
495     case RightBracketToken:
496         builder.append(&#39;]&#39;);
497         break;
498     case LeftBraceToken:
499         builder.append(&#39;{&#39;);
500         break;
501     case RightBraceToken:
502         builder.append(&#39;}&#39;);
503         break;
504 
505     case EOFToken:
506     case CommentToken:
507         ASSERT_NOT_REACHED();
508         break;
509     }
510 }
511 
512 } // namespace WebCore
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>
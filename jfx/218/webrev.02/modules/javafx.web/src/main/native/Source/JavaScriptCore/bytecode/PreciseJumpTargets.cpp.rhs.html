<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PreciseJumpTargets.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PreciseJumpTargets.h&quot;
 28 
 29 #include &quot;InterpreterInlines.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;PreciseJumpTargetsInlines.h&quot;
 32 
 33 namespace JSC {
 34 
 35 template &lt;size_t vectorSize, typename Block&gt;
 36 static void getJumpTargetsForInstruction(Block* codeBlock, const InstructionStream::Ref&amp; instruction, Vector&lt;InstructionStream::Offset, vectorSize&gt;&amp; out)
 37 {
 38     extractStoredJumpTargetsForInstruction(codeBlock, instruction, [&amp;](int32_t relativeOffset) {
 39         out.append(instruction.offset() + relativeOffset);
 40     });
 41     OpcodeID opcodeID = instruction-&gt;opcodeID();
 42     // op_loop_hint does not have jump target stored in bytecode instructions.
 43     if (opcodeID == op_loop_hint)
 44         out.append(instruction.offset());
 45     else if (opcodeID == op_enter &amp;&amp; codeBlock-&gt;hasTailCalls() &amp;&amp; Options::optimizeRecursiveTailCalls()) {
 46         // We need to insert a jump after op_enter, so recursive tail calls have somewhere to jump to.
 47         // But we only want to pay that price for functions that have at least one tail call.
 48         out.append(instruction.next().offset());
 49     }
 50 }
 51 
 52 enum class ComputePreciseJumpTargetsMode {
 53     FollowCodeBlockClaim,
 54     ForceCompute,
 55 };
 56 
 57 template&lt;ComputePreciseJumpTargetsMode Mode, typename Block, size_t vectorSize&gt;
 58 void computePreciseJumpTargetsInternal(Block* codeBlock, const InstructionStream&amp; instructions, Vector&lt;InstructionStream::Offset, vectorSize&gt;&amp; out)
 59 {
 60     ASSERT(out.isEmpty());
 61 
 62     // The code block has a superset of the jump targets. So if it claims to have none, we are done.
 63     if (Mode == ComputePreciseJumpTargetsMode::FollowCodeBlockClaim &amp;&amp; !codeBlock-&gt;numberOfJumpTargets())
 64         return;
 65 
 66     for (unsigned i = codeBlock-&gt;numberOfExceptionHandlers(); i--;) {
 67         out.append(codeBlock-&gt;exceptionHandler(i).target);
 68         out.append(codeBlock-&gt;exceptionHandler(i).start);
 69         out.append(codeBlock-&gt;exceptionHandler(i).end);
 70     }
 71 
 72     for (const auto&amp; instruction : instructions) {
 73         getJumpTargetsForInstruction(codeBlock, instruction, out);
 74     }
 75 
 76     std::sort(out.begin(), out.end());
 77 
 78     // We will have duplicates, and we must remove them.
 79     unsigned toIndex = 0;
 80     unsigned fromIndex = 0;
 81     unsigned lastValue = UINT_MAX;
 82     while (fromIndex &lt; out.size()) {
 83         unsigned value = out[fromIndex++];
 84         if (value == lastValue)
 85             continue;
 86         out[toIndex++] = value;
 87         lastValue = value;
 88     }
 89     out.shrinkCapacity(toIndex);
 90 }
 91 
 92 void computePreciseJumpTargets(CodeBlock* codeBlock, Vector&lt;InstructionStream::Offset, 32&gt;&amp; out)
 93 {
 94     computePreciseJumpTargetsInternal&lt;ComputePreciseJumpTargetsMode::FollowCodeBlockClaim&gt;(codeBlock, codeBlock-&gt;instructions(), out);
 95 }
 96 
 97 void computePreciseJumpTargets(CodeBlock* codeBlock, const InstructionStream&amp; instructions, Vector&lt;InstructionStream::Offset, 32&gt;&amp; out)
 98 {
 99     computePreciseJumpTargetsInternal&lt;ComputePreciseJumpTargetsMode::FollowCodeBlockClaim&gt;(codeBlock, instructions, out);
100 }
101 
<a name="1" id="anc1"></a><span class="line-modified">102 void computePreciseJumpTargets(UnlinkedCodeBlockGenerator* codeBlock, const InstructionStream&amp; instructions, Vector&lt;InstructionStream::Offset, 32&gt;&amp; out)</span>
103 {
104     computePreciseJumpTargetsInternal&lt;ComputePreciseJumpTargetsMode::FollowCodeBlockClaim&gt;(codeBlock, instructions, out);
105 }
106 
<a name="2" id="anc2"></a><span class="line-modified">107 void recomputePreciseJumpTargets(UnlinkedCodeBlockGenerator* codeBlock, const InstructionStream&amp; instructions, Vector&lt;InstructionStream::Offset&gt;&amp; out)</span>
108 {
109     computePreciseJumpTargetsInternal&lt;ComputePreciseJumpTargetsMode::ForceCompute&gt;(codeBlock, instructions, out);
110 }
111 
112 void findJumpTargetsForInstruction(CodeBlock* codeBlock, const InstructionStream::Ref&amp; instruction, Vector&lt;InstructionStream::Offset, 1&gt;&amp; out)
113 {
114     getJumpTargetsForInstruction(codeBlock, instruction, out);
115 }
116 
<a name="3" id="anc3"></a><span class="line-modified">117 void findJumpTargetsForInstruction(UnlinkedCodeBlockGenerator* codeBlock, const InstructionStream::Ref&amp; instruction, Vector&lt;InstructionStream::Offset, 1&gt;&amp; out)</span>
118 {
119     getJumpTargetsForInstruction(codeBlock, instruction, out);
120 }
121 
122 } // namespace JSC
123 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
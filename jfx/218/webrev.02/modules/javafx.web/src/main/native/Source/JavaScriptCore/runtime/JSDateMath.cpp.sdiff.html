<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDataViewPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDateMath.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83 #include &lt;time.h&gt;
 84 #include &lt;wtf/ASCIICType.h&gt;
 85 #include &lt;wtf/Assertions.h&gt;
 86 #include &lt;wtf/MathExtras.h&gt;
 87 #include &lt;wtf/StdLibExtras.h&gt;
 88 
 89 #if HAVE(ERRNO_H)
 90 #include &lt;errno.h&gt;
 91 #endif
 92 
 93 #if HAVE(SYS_TIME_H)
 94 #include &lt;sys/time.h&gt;
 95 #endif
 96 
 97 #if HAVE(SYS_TIMEB_H)
 98 #include &lt;sys/timeb.h&gt;
 99 #endif
100 
101 namespace JSC {
102 
<span class="line-removed">103 using namespace WTF;</span>
<span class="line-removed">104 </span>
<span class="line-removed">105 static inline double timeToMS(double hour, double min, double sec, double ms)</span>
<span class="line-removed">106 {</span>
<span class="line-removed">107     return (((hour * minutesPerHour + min) * secondsPerMinute + sec) * msPerSecond + ms);</span>
<span class="line-removed">108 }</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 static inline int msToSeconds(double ms)</span>
<span class="line-removed">111 {</span>
<span class="line-removed">112     double result = fmod(floor(ms / msPerSecond), secondsPerMinute);</span>
<span class="line-removed">113     if (result &lt; 0)</span>
<span class="line-removed">114         result += secondsPerMinute;</span>
<span class="line-removed">115     return static_cast&lt;int&gt;(result);</span>
<span class="line-removed">116 }</span>
<span class="line-removed">117 </span>
<span class="line-removed">118 // 0: Sunday, 1: Monday, etc.</span>
<span class="line-removed">119 static inline int msToWeekDay(double ms)</span>
<span class="line-removed">120 {</span>
<span class="line-removed">121     int wd = (static_cast&lt;int&gt;(msToDays(ms)) + 4) % 7;</span>
<span class="line-removed">122     if (wd &lt; 0)</span>
<span class="line-removed">123         wd += 7;</span>
<span class="line-removed">124     return wd;</span>
<span class="line-removed">125 }</span>
<span class="line-removed">126 </span>
127 // Get the combined UTC + DST offset for the time passed in.
128 //
129 // NOTE: The implementation relies on the fact that no time zones have
130 // more than one daylight savings offset change per month.
131 // If this function is called with NaN it returns NaN.
132 static LocalTimeOffset localTimeOffset(VM&amp; vm, double ms, WTF::TimeType inputTimeType = WTF::UTCTime)
133 {
134     LocalTimeOffsetCache&amp; cache = inputTimeType == WTF::LocalTime
135         ? vm.localTimeOffsetCache : vm.utcTimeOffsetCache;
136 
137     double start = cache.start;
138     double end = cache.end;
139 
140     if (start &lt;= ms) {
141         // If the time fits in the cached interval, return the cached offset.
142         if (ms &lt;= end)
143             return cache.offset;
144 
145         // Compute a possible new interval end.
146         double newEnd = end + cache.increment;
147 
148         if (ms &lt;= newEnd) {
149             LocalTimeOffset endOffset = calculateLocalTimeOffset(newEnd, inputTimeType);
150             if (cache.offset == endOffset) {
151                 // If the offset at the end of the new interval still matches
152                 // the offset in the cache, we grow the cached time interval
153                 // and return the offset.
154                 cache.end = newEnd;
<span class="line-modified">155                 cache.increment = msPerMonth;</span>
156                 return endOffset;
157             }
158             LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
159             if (offset == endOffset) {
160                 // The offset at the given time is equal to the offset at the
161                 // new end of the interval, so that means that we&#39;ve just skipped
162                 // the point in time where the DST offset change occurred. Updated
163                 // the interval to reflect this and reset the increment.
164                 cache.start = ms;
165                 cache.end = newEnd;
<span class="line-modified">166                 cache.increment = msPerMonth;</span>
167             } else {
168                 // The interval contains a DST offset change and the given time is
169                 // before it. Adjust the increment to avoid a linear search for
170                 // the offset change point and change the end of the interval.
171                 cache.increment /= 3;
172                 cache.end = ms;
173             }
174             // Update the offset in the cache and return it.
175             cache.offset = offset;
176             return offset;
177         }
178     }
179 
180     // Compute the DST offset for the time and shrink the cache interval
181     // to only contain the time. This allows fast repeated DST offset
182     // computations for the same time.
183     LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
184     cache.offset = offset;
185     cache.start = ms;
186     cache.end = ms;
<span class="line-modified">187     cache.increment = msPerMonth;</span>
188     return offset;
189 }
190 





191 double gregorianDateTimeToMS(VM&amp; vm, const GregorianDateTime&amp; t, double milliSeconds, WTF::TimeType inputTimeType)
192 {
193     double day = dateToDaysFrom1970(t.year(), t.month(), t.monthDay());
194     double ms = timeToMS(t.hour(), t.minute(), t.second(), milliSeconds);
195     double localTimeResult = (day * WTF::msPerDay) + ms;
196 
<span class="line-modified">197     double localToUTCTimeOffset = inputTimeType == LocalTime</span>
198         ? localTimeOffset(vm, localTimeResult, inputTimeType).offset : 0;
199 
200     return localTimeResult - localToUTCTimeOffset;
201 }
202 
203 // input is UTC
204 void msToGregorianDateTime(VM&amp; vm, double ms, WTF::TimeType outputTimeType, GregorianDateTime&amp; tm)
205 {
206     LocalTimeOffset localTime;
207     if (outputTimeType == WTF::LocalTime) {
208         localTime = localTimeOffset(vm, ms);
209         ms += localTime.offset;
210     }
<span class="line-modified">211 </span>
<span class="line-removed">212     const int year = msToYear(ms);</span>
<span class="line-removed">213     tm.setSecond(msToSeconds(ms));</span>
<span class="line-removed">214     tm.setMinute(msToMinutes(ms));</span>
<span class="line-removed">215     tm.setHour(msToHours(ms));</span>
<span class="line-removed">216     tm.setWeekDay(msToWeekDay(ms));</span>
<span class="line-removed">217     tm.setYearDay(dayInYear(ms, year));</span>
<span class="line-removed">218     tm.setMonthDay(dayInMonthFromDayInYear(tm.yearDay(), isLeapYear(year)));</span>
<span class="line-removed">219     tm.setMonth(monthFromDayInYear(tm.yearDay(), isLeapYear(year)));</span>
<span class="line-removed">220     tm.setYear(year);</span>
<span class="line-removed">221     tm.setIsDST(localTime.isDST);</span>
<span class="line-removed">222     tm.setUtcOffset(localTime.offset / WTF::msPerSecond);</span>
223 }
224 
<span class="line-modified">225 double parseDateFromNullTerminatedCharacters(VM&amp; vm, const char* dateString)</span>
226 {
<span class="line-modified">227     bool haveTZ;</span>
<span class="line-modified">228     int offset;</span>
<span class="line-modified">229     double localTimeMS = WTF::parseDateFromNullTerminatedCharacters(dateString, haveTZ, offset);</span>
<span class="line-modified">230     if (std::isnan(localTimeMS))</span>
<span class="line-removed">231         return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
232 
<span class="line-modified">233     // fall back to local timezone.</span>
<span class="line-modified">234     if (!haveTZ)</span>
<span class="line-removed">235         offset = localTimeOffset(vm, localTimeMS, WTF::LocalTime).offset / WTF::msPerMinute;</span>
236 
<span class="line-modified">237     return localTimeMS - (offset * WTF::msPerMinute);</span>
238 }
239 
<span class="line-modified">240 double parseDate(ExecState* exec, VM&amp; vm, const String&amp; date)</span>
241 {
242     auto scope = DECLARE_THROW_SCOPE(vm);
243 
244     if (date == vm.cachedDateString)
245         return vm.cachedDateStringValue;
246     auto expectedString = date.tryGetUtf8();
247     if (!expectedString) {
248         if (expectedString.error() == UTF8ConversionError::OutOfMemory)
<span class="line-modified">249             throwOutOfMemoryError(exec, scope);</span>
250         // https://tc39.github.io/ecma262/#sec-date-objects section 20.3.3.2 states that:
251         // &quot;Unrecognizable Strings or dates containing illegal element values in the
252         // format String shall cause Date.parse to return NaN.&quot;
253         return std::numeric_limits&lt;double&gt;::quiet_NaN();
254     }
255 
256     auto dateUtf8 = expectedString.value();
<span class="line-modified">257     double value = parseES5DateFromNullTerminatedCharacters(dateUtf8.data());</span>
<span class="line-removed">258     if (std::isnan(value))</span>
<span class="line-removed">259         value = parseDateFromNullTerminatedCharacters(vm, dateUtf8.data());</span>
260     vm.cachedDateString = date;
261     vm.cachedDateStringValue = value;
262     return value;
263 }
264 
265 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 83 #include &lt;time.h&gt;
 84 #include &lt;wtf/ASCIICType.h&gt;
 85 #include &lt;wtf/Assertions.h&gt;
 86 #include &lt;wtf/MathExtras.h&gt;
 87 #include &lt;wtf/StdLibExtras.h&gt;
 88 
 89 #if HAVE(ERRNO_H)
 90 #include &lt;errno.h&gt;
 91 #endif
 92 
 93 #if HAVE(SYS_TIME_H)
 94 #include &lt;sys/time.h&gt;
 95 #endif
 96 
 97 #if HAVE(SYS_TIMEB_H)
 98 #include &lt;sys/timeb.h&gt;
 99 #endif
100 
101 namespace JSC {
102 
























103 // Get the combined UTC + DST offset for the time passed in.
104 //
105 // NOTE: The implementation relies on the fact that no time zones have
106 // more than one daylight savings offset change per month.
107 // If this function is called with NaN it returns NaN.
108 static LocalTimeOffset localTimeOffset(VM&amp; vm, double ms, WTF::TimeType inputTimeType = WTF::UTCTime)
109 {
110     LocalTimeOffsetCache&amp; cache = inputTimeType == WTF::LocalTime
111         ? vm.localTimeOffsetCache : vm.utcTimeOffsetCache;
112 
113     double start = cache.start;
114     double end = cache.end;
115 
116     if (start &lt;= ms) {
117         // If the time fits in the cached interval, return the cached offset.
118         if (ms &lt;= end)
119             return cache.offset;
120 
121         // Compute a possible new interval end.
122         double newEnd = end + cache.increment;
123 
124         if (ms &lt;= newEnd) {
125             LocalTimeOffset endOffset = calculateLocalTimeOffset(newEnd, inputTimeType);
126             if (cache.offset == endOffset) {
127                 // If the offset at the end of the new interval still matches
128                 // the offset in the cache, we grow the cached time interval
129                 // and return the offset.
130                 cache.end = newEnd;
<span class="line-modified">131                 cache.increment = WTF::msPerMonth;</span>
132                 return endOffset;
133             }
134             LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
135             if (offset == endOffset) {
136                 // The offset at the given time is equal to the offset at the
137                 // new end of the interval, so that means that we&#39;ve just skipped
138                 // the point in time where the DST offset change occurred. Updated
139                 // the interval to reflect this and reset the increment.
140                 cache.start = ms;
141                 cache.end = newEnd;
<span class="line-modified">142                 cache.increment = WTF::msPerMonth;</span>
143             } else {
144                 // The interval contains a DST offset change and the given time is
145                 // before it. Adjust the increment to avoid a linear search for
146                 // the offset change point and change the end of the interval.
147                 cache.increment /= 3;
148                 cache.end = ms;
149             }
150             // Update the offset in the cache and return it.
151             cache.offset = offset;
152             return offset;
153         }
154     }
155 
156     // Compute the DST offset for the time and shrink the cache interval
157     // to only contain the time. This allows fast repeated DST offset
158     // computations for the same time.
159     LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
160     cache.offset = offset;
161     cache.start = ms;
162     cache.end = ms;
<span class="line-modified">163     cache.increment = WTF::msPerMonth;</span>
164     return offset;
165 }
166 
<span class="line-added">167 static inline double timeToMS(double hour, double min, double sec, double ms)</span>
<span class="line-added">168 {</span>
<span class="line-added">169     return (((hour * WTF::minutesPerHour + min) * WTF::secondsPerMinute + sec) * WTF::msPerSecond + ms);</span>
<span class="line-added">170 }</span>
<span class="line-added">171 </span>
172 double gregorianDateTimeToMS(VM&amp; vm, const GregorianDateTime&amp; t, double milliSeconds, WTF::TimeType inputTimeType)
173 {
174     double day = dateToDaysFrom1970(t.year(), t.month(), t.monthDay());
175     double ms = timeToMS(t.hour(), t.minute(), t.second(), milliSeconds);
176     double localTimeResult = (day * WTF::msPerDay) + ms;
177 
<span class="line-modified">178     double localToUTCTimeOffset = inputTimeType == WTF::LocalTime</span>
179         ? localTimeOffset(vm, localTimeResult, inputTimeType).offset : 0;
180 
181     return localTimeResult - localToUTCTimeOffset;
182 }
183 
184 // input is UTC
185 void msToGregorianDateTime(VM&amp; vm, double ms, WTF::TimeType outputTimeType, GregorianDateTime&amp; tm)
186 {
187     LocalTimeOffset localTime;
188     if (outputTimeType == WTF::LocalTime) {
189         localTime = localTimeOffset(vm, ms);
190         ms += localTime.offset;
191     }
<span class="line-modified">192     tm = GregorianDateTime(ms, localTime);</span>











193 }
194 
<span class="line-modified">195 static double parseDate(VM&amp; vm, const char* dateString)</span>
196 {
<span class="line-modified">197     bool isLocalTime;</span>
<span class="line-modified">198     double value = WTF::parseES5DateFromNullTerminatedCharacters(dateString, isLocalTime);</span>
<span class="line-modified">199     if (std::isnan(value))</span>
<span class="line-modified">200         value = WTF::parseDateFromNullTerminatedCharacters(dateString, isLocalTime);</span>

201 
<span class="line-modified">202     if (isLocalTime)</span>
<span class="line-modified">203         value -= localTimeOffset(vm, value, WTF::LocalTime).offset;</span>

204 
<span class="line-modified">205     return value;</span>
206 }
207 
<span class="line-modified">208 double parseDate(JSGlobalObject* globalObject, VM&amp; vm, const String&amp; date)</span>
209 {
210     auto scope = DECLARE_THROW_SCOPE(vm);
211 
212     if (date == vm.cachedDateString)
213         return vm.cachedDateStringValue;
214     auto expectedString = date.tryGetUtf8();
215     if (!expectedString) {
216         if (expectedString.error() == UTF8ConversionError::OutOfMemory)
<span class="line-modified">217             throwOutOfMemoryError(globalObject, scope);</span>
218         // https://tc39.github.io/ecma262/#sec-date-objects section 20.3.3.2 states that:
219         // &quot;Unrecognizable Strings or dates containing illegal element values in the
220         // format String shall cause Date.parse to return NaN.&quot;
221         return std::numeric_limits&lt;double&gt;::quiet_NaN();
222     }
223 
224     auto dateUtf8 = expectedString.value();
<span class="line-modified">225     double value = parseDate(vm, dateUtf8.data());</span>


226     vm.cachedDateString = date;
227     vm.cachedDateStringValue = value;
228     return value;
229 }
230 
231 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSDataViewPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDateMath.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
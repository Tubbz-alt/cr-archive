<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/style/SVGRenderStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2     Copyright (C) 2004, 2005, 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3                   2004, 2005, 2010 Rob Buis &lt;buis@kde.org&gt;
  4     Copyright (C) Research In Motion Limited 2010. All rights reserved.
  5 
  6     Based on khtml code by:
  7     Copyright (C) 1999 Antti Koivisto (koivisto@kde.org)
  8     Copyright (C) 1999-2003 Lars Knoll (knoll@kde.org)
  9     Copyright (C) 2002-2003 Dirk Mueller (mueller@kde.org)
 10     Copyright (C) 2002 Apple Inc.
 11 
 12     This library is free software; you can redistribute it and/or
 13     modify it under the terms of the GNU Library General Public
 14     License as published by the Free Software Foundation; either
 15     version 2 of the License, or (at your option) any later version.
 16 
 17     This library is distributed in the hope that it will be useful,
 18     but WITHOUT ANY WARRANTY; without even the implied warranty of
 19     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 20     Library General Public License for more details.
 21 
 22     You should have received a copy of the GNU Library General Public License
 23     along with this library; see the file COPYING.LIB.  If not, write to
 24     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25     Boston, MA 02110-1301, USA.
 26 */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;SVGRenderStyle.h&quot;
 30 
 31 #include &quot;CSSPrimitiveValue.h&quot;
 32 #include &quot;CSSValueList.h&quot;
 33 #include &quot;IntRect.h&quot;
 34 #include &quot;NodeRenderStyle.h&quot;
 35 #include &quot;SVGElement.h&quot;
 36 #include &lt;wtf/NeverDestroyed.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 static const SVGRenderStyle&amp; defaultSVGStyle()
 41 {
 42     static NeverDestroyed&lt;DataRef&lt;SVGRenderStyle&gt;&gt; style(SVGRenderStyle::createDefaultStyle());
 43     return *style.get();
 44 }
 45 
<a name="1" id="anc1"></a><span class="line-added"> 46 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SVGRenderStyle);</span>
<span class="line-added"> 47 </span>
 48 Ref&lt;SVGRenderStyle&gt; SVGRenderStyle::createDefaultStyle()
 49 {
 50     return adoptRef(*new SVGRenderStyle(CreateDefault));
 51 }
 52 
 53 SVGRenderStyle::SVGRenderStyle()
 54     : m_fillData(defaultSVGStyle().m_fillData)
 55     , m_strokeData(defaultSVGStyle().m_strokeData)
 56     , m_textData(defaultSVGStyle().m_textData)
 57     , m_inheritedResourceData(defaultSVGStyle().m_inheritedResourceData)
 58     , m_stopData(defaultSVGStyle().m_stopData)
 59     , m_miscData(defaultSVGStyle().m_miscData)
 60     , m_shadowData(defaultSVGStyle().m_shadowData)
 61     , m_layoutData(defaultSVGStyle().m_layoutData)
 62     , m_nonInheritedResourceData(defaultSVGStyle().m_nonInheritedResourceData)
 63 {
 64     setBitDefaults();
 65 }
 66 
 67 SVGRenderStyle::SVGRenderStyle(CreateDefaultType)
 68     : m_fillData(StyleFillData::create())
 69     , m_strokeData(StyleStrokeData::create())
 70     , m_textData(StyleTextData::create())
 71     , m_inheritedResourceData(StyleInheritedResourceData::create())
 72     , m_stopData(StyleStopData::create())
 73     , m_miscData(StyleMiscData::create())
 74     , m_shadowData(StyleShadowSVGData::create())
 75     , m_layoutData(StyleLayoutData::create())
 76     , m_nonInheritedResourceData(StyleResourceData::create())
 77 {
 78     setBitDefaults();
 79 }
 80 
 81 inline SVGRenderStyle::SVGRenderStyle(const SVGRenderStyle&amp; other)
 82     : RefCounted&lt;SVGRenderStyle&gt;()
 83     , m_inheritedFlags(other.m_inheritedFlags)
 84     , m_nonInheritedFlags(other.m_nonInheritedFlags)
 85     , m_fillData(other.m_fillData)
 86     , m_strokeData(other.m_strokeData)
 87     , m_textData(other.m_textData)
 88     , m_inheritedResourceData(other.m_inheritedResourceData)
 89     , m_stopData(other.m_stopData)
 90     , m_miscData(other.m_miscData)
 91     , m_shadowData(other.m_shadowData)
 92     , m_layoutData(other.m_layoutData)
 93     , m_nonInheritedResourceData(other.m_nonInheritedResourceData)
 94 {
 95 }
 96 
 97 Ref&lt;SVGRenderStyle&gt; SVGRenderStyle::copy() const
 98 {
 99     return adoptRef(*new SVGRenderStyle(*this));
100 }
101 
102 SVGRenderStyle::~SVGRenderStyle() = default;
103 
104 bool SVGRenderStyle::operator==(const SVGRenderStyle&amp; other) const
105 {
106     return m_fillData == other.m_fillData
107         &amp;&amp; m_strokeData == other.m_strokeData
108         &amp;&amp; m_textData == other.m_textData
109         &amp;&amp; m_stopData == other.m_stopData
110         &amp;&amp; m_miscData == other.m_miscData
111         &amp;&amp; m_shadowData == other.m_shadowData
112         &amp;&amp; m_layoutData == other.m_layoutData
113         &amp;&amp; m_inheritedResourceData == other.m_inheritedResourceData
114         &amp;&amp; m_nonInheritedResourceData == other.m_nonInheritedResourceData
115         &amp;&amp; m_inheritedFlags == other.m_inheritedFlags
116         &amp;&amp; m_nonInheritedFlags == other.m_nonInheritedFlags;
117 }
118 
<a name="2" id="anc2"></a><span class="line-modified">119 bool SVGRenderStyle::inheritedEqual(const SVGRenderStyle&amp; other) const</span>
120 {
<a name="3" id="anc3"></a><span class="line-modified">121     return m_fillData == other.m_fillData</span>
<span class="line-modified">122         &amp;&amp; m_strokeData == other.m_strokeData</span>
<span class="line-modified">123         &amp;&amp; m_textData == other.m_textData</span>
<span class="line-modified">124         &amp;&amp; m_inheritedResourceData == other.m_inheritedResourceData</span>
<span class="line-modified">125         &amp;&amp; m_inheritedFlags == other.m_inheritedFlags;</span>
126 }
127 
128 void SVGRenderStyle::inheritFrom(const SVGRenderStyle&amp; other)
129 {
130     m_fillData = other.m_fillData;
131     m_strokeData = other.m_strokeData;
132     m_textData = other.m_textData;
133     m_inheritedResourceData = other.m_inheritedResourceData;
134 
135     m_inheritedFlags = other.m_inheritedFlags;
136 }
137 
138 void SVGRenderStyle::copyNonInheritedFrom(const SVGRenderStyle&amp; other)
139 {
140     m_nonInheritedFlags = other.m_nonInheritedFlags;
141     m_stopData = other.m_stopData;
142     m_miscData = other.m_miscData;
143     m_shadowData = other.m_shadowData;
144     m_layoutData = other.m_layoutData;
145     m_nonInheritedResourceData = other.m_nonInheritedResourceData;
146 }
147 
148 StyleDifference SVGRenderStyle::diff(const SVGRenderStyle&amp; other) const
149 {
150     // NOTE: All comparisions that may return StyleDifference::Layout have to go before those who return StyleDifference::Repaint
151 
152     // If kerning changes, we need a relayout, to force SVGCharacterData to be recalculated in the SVGRootInlineBox.
153     if (m_textData != other.m_textData)
154         return StyleDifference::Layout;
155 
156     // If resources change, we need a relayout, as the presence of resources influences the repaint rect.
157     if (m_nonInheritedResourceData != other.m_nonInheritedResourceData)
158         return StyleDifference::Layout;
159 
160     // If markers change, we need a relayout, as marker boundaries are cached in RenderSVGPath.
161     if (m_inheritedResourceData != other.m_inheritedResourceData)
162         return StyleDifference::Layout;
163 
164     // All text related properties influence layout.
165     if (m_inheritedFlags.textAnchor != other.m_inheritedFlags.textAnchor
166         || m_inheritedFlags.glyphOrientationHorizontal != other.m_inheritedFlags.glyphOrientationHorizontal
167         || m_inheritedFlags.glyphOrientationVertical != other.m_inheritedFlags.glyphOrientationVertical
168         || m_nonInheritedFlags.flagBits.alignmentBaseline != other.m_nonInheritedFlags.flagBits.alignmentBaseline
169         || m_nonInheritedFlags.flagBits.dominantBaseline != other.m_nonInheritedFlags.flagBits.dominantBaseline
170         || m_nonInheritedFlags.flagBits.baselineShift != other.m_nonInheritedFlags.flagBits.baselineShift)
171         return StyleDifference::Layout;
172 
173     // Text related properties influence layout.
174     bool miscNotEqual = m_miscData != other.m_miscData;
175     if (miscNotEqual &amp;&amp; m_miscData-&gt;baselineShiftValue != other.m_miscData-&gt;baselineShiftValue)
176         return StyleDifference::Layout;
177 
178     // Shadow changes require relayouts, as they affect the repaint rects.
179     if (m_shadowData != other.m_shadowData)
180         return StyleDifference::Layout;
181 
182     // The x or y properties require relayout.
183     if (m_layoutData != other.m_layoutData)
184         return StyleDifference::Layout;
185 
186     // Some stroke properties, requires relayouts, as the cached stroke boundaries need to be recalculated.
187     if (m_strokeData != other.m_strokeData) {
188         if (m_strokeData-&gt;paintType != other.m_strokeData-&gt;paintType
189             || m_strokeData-&gt;paintColor != other.m_strokeData-&gt;paintColor
190             || m_strokeData-&gt;paintUri != other.m_strokeData-&gt;paintUri
191             || m_strokeData-&gt;dashArray != other.m_strokeData-&gt;dashArray
192             || m_strokeData-&gt;dashOffset != other.m_strokeData-&gt;dashOffset
193             || m_strokeData-&gt;visitedLinkPaintColor != other.m_strokeData-&gt;visitedLinkPaintColor
194             || m_strokeData-&gt;visitedLinkPaintUri != other.m_strokeData-&gt;visitedLinkPaintUri
195             || m_strokeData-&gt;visitedLinkPaintType != other.m_strokeData-&gt;visitedLinkPaintType)
196             return StyleDifference::Layout;
197 
198         // Only the stroke-opacity case remains, where we only need a repaint.
199         ASSERT(m_strokeData-&gt;opacity != other.m_strokeData-&gt;opacity);
200         return StyleDifference::Repaint;
201     }
202 
203     // vector-effect changes require a re-layout.
204     if (m_nonInheritedFlags.flagBits.vectorEffect != other.m_nonInheritedFlags.flagBits.vectorEffect)
205         return StyleDifference::Layout;
206 
207     // NOTE: All comparisions below may only return StyleDifference::Repaint
208 
209     // Painting related properties only need repaints.
210     if (miscNotEqual) {
211         if (m_miscData-&gt;floodColor != other.m_miscData-&gt;floodColor
212             || m_miscData-&gt;floodOpacity != other.m_miscData-&gt;floodOpacity
213             || m_miscData-&gt;lightingColor != other.m_miscData-&gt;lightingColor)
214             return StyleDifference::Repaint;
215     }
216 
217     // If fill data changes, we just need to repaint. Fill boundaries are not influenced by this, only by the Path, that RenderSVGPath contains.
218     if (m_fillData-&gt;paintType != other.m_fillData-&gt;paintType || m_fillData-&gt;paintColor != other.m_fillData-&gt;paintColor
219         || m_fillData-&gt;paintUri != other.m_fillData-&gt;paintUri || m_fillData-&gt;opacity != other.m_fillData-&gt;opacity)
220         return StyleDifference::Repaint;
221 
222     // If gradient stops change, we just need to repaint. Style updates are already handled through RenderSVGGradientSTop.
223     if (m_stopData != other.m_stopData)
224         return StyleDifference::Repaint;
225 
226     // Changes of these flags only cause repaints.
227     if (m_inheritedFlags.colorRendering != other.m_inheritedFlags.colorRendering
228         || m_inheritedFlags.shapeRendering != other.m_inheritedFlags.shapeRendering
229         || m_inheritedFlags.clipRule != other.m_inheritedFlags.clipRule
230         || m_inheritedFlags.fillRule != other.m_inheritedFlags.fillRule
231         || m_inheritedFlags.colorInterpolation != other.m_inheritedFlags.colorInterpolation
232         || m_inheritedFlags.colorInterpolationFilters != other.m_inheritedFlags.colorInterpolationFilters)
233         return StyleDifference::Repaint;
234 
235     if (m_nonInheritedFlags.flagBits.bufferedRendering != other.m_nonInheritedFlags.flagBits.bufferedRendering)
236         return StyleDifference::Repaint;
237 
238     if (m_nonInheritedFlags.flagBits.maskType != other.m_nonInheritedFlags.flagBits.maskType)
239         return StyleDifference::Repaint;
240 
241     return StyleDifference::Equal;
242 }
243 
244 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/Verification.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutState.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #ifndef NDEBUG</span>
 32 #include &quot;DisplayBox.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 33 #include &quot;InlineFormattingState.h&quot;</span>
 34 #include &quot;InlineTextBox.h&quot;
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 37 #include &quot;LayoutContext.h&quot;</span>
 38 #include &quot;LayoutTreeBuilder.h&quot;
 39 #include &quot;RenderBox.h&quot;
 40 #include &quot;RenderInline.h&quot;
 41 #include &quot;RenderLineBreak.h&quot;
 42 #include &quot;RenderView.h&quot;
 43 #include &lt;wtf/text/TextStream.h&gt;
 44 
 45 namespace WebCore {
 46 namespace Layout {
 47 
 48 static bool areEssentiallyEqual(LayoutUnit a, LayoutUnit b)
 49 {
 50     if (a == b)
 51         return true;
 52     // 1/4th CSS pixel.
 53     constexpr float epsilon = kFixedPointDenominator / 4;
 54     return abs(a.rawValue() - b.rawValue()) &lt;= epsilon;
 55 }
 56 
<a name="4" id="anc4"></a><span class="line-modified"> 57 static bool areEssentiallyEqual(float a, InlineLayoutUnit b)</span>
 58 {
<a name="5" id="anc5"></a><span class="line-modified"> 59     return areEssentiallyEqual(LayoutUnit { a }, LayoutUnit { b });</span>
 60 }
 61 
 62 static bool areEssentiallyEqual(LayoutRect a, LayoutRect b)
 63 {
 64     return areEssentiallyEqual(a.x(), b.x())
 65         &amp;&amp; areEssentiallyEqual(a.y(), b.y())
 66         &amp;&amp; areEssentiallyEqual(a.width(), b.width())
 67         &amp;&amp; areEssentiallyEqual(a.height(), b.height());
 68 }
 69 
 70 static bool outputMismatchingSimpleLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
 71 {
 72     auto* lineLayoutData = blockFlow.simpleLineLayout();
 73     if (!lineLayoutData) {
 74         ASSERT_NOT_REACHED();
 75         return true;
 76     }
 77 
 78     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
<a name="6" id="anc6"></a><span class="line-modified"> 79     auto* displayInlineContent = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).displayInlineContent();</span>
<span class="line-modified"> 80     if (!displayInlineContent) {</span>
<span class="line-added"> 81         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 82         return true;</span>
<span class="line-added"> 83     }</span>
 84 
<a name="7" id="anc7"></a><span class="line-modified"> 85     auto&amp; displayRuns = displayInlineContent-&gt;runs;</span>
<span class="line-modified"> 86 </span>
<span class="line-added"> 87     if (displayRuns.size() != lineLayoutData-&gt;runCount()) {</span>
<span class="line-added"> 88         stream &lt;&lt; &quot;Mismatching number of runs: simple runs(&quot; &lt;&lt; lineLayoutData-&gt;runCount() &lt;&lt; &quot;) inline runs(&quot; &lt;&lt; displayRuns.size() &lt;&lt; &quot;)&quot;;</span>
 89         stream.nextLine();
 90         return true;
 91     }
 92 
 93     auto mismatched = false;
 94     for (unsigned i = 0; i &lt; lineLayoutData-&gt;runCount(); ++i) {
 95         auto&amp; simpleRun = lineLayoutData-&gt;runAt(i);
<a name="8" id="anc8"></a><span class="line-modified"> 96         auto&amp; displayRun = displayRuns[i];</span>
 97 
<a name="9" id="anc9"></a><span class="line-modified"> 98         auto matchingRuns = areEssentiallyEqual(simpleRun.logicalLeft, displayRun.left()) &amp;&amp; areEssentiallyEqual(simpleRun.logicalRight, displayRun.right());</span>
<span class="line-modified"> 99         if (matchingRuns &amp;&amp; displayRun.textContext()) {</span>
<span class="line-modified">100             matchingRuns = simpleRun.start == displayRun.textContext()-&gt;start() &amp;&amp; simpleRun.end == displayRun.textContext()-&gt;end();</span>
101             // SLL handles strings in a more concatenated format &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; -&gt; foo -&gt; 0,3 bar -&gt; 3,6 vs. 0,3 and 0,3
102             if (!matchingRuns)
<a name="10" id="anc10"></a><span class="line-modified">103                 matchingRuns = (simpleRun.end - simpleRun.start) == (displayRun.textContext()-&gt;end() - displayRun.textContext()-&gt;start());</span>
104         }
105         if (matchingRuns)
106             continue;
107 
<a name="11" id="anc11"></a><span class="line-modified">108         stream &lt;&lt; &quot;Mismatching: simple run(&quot; &lt;&lt; simpleRun.start &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.end &lt;&lt; &quot;) (&quot; &lt;&lt; simpleRun.logicalLeft &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.logicalRight &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">109         stream &lt;&lt; &quot; inline run&quot;;</span>
<span class="line-added">110         if (displayRun.textContext())</span>
<span class="line-added">111             stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.textContext()-&gt;end() &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">112         stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.left() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.top() &lt;&lt; &quot;) (&quot; &lt;&lt; displayRun.width() &lt;&lt; &quot;x&quot; &lt;&lt; displayRun.height() &lt;&lt; &quot;)&quot;;</span>
113         stream.nextLine();
114         mismatched = true;
115     }
116     return mismatched;
117 }
118 
119 static bool checkForMatchingNonTextRuns(const Display::Run&amp; inlineRun, const WebCore::InlineBox&amp; inlineBox)
120 {
<a name="12" id="anc12"></a><span class="line-modified">121     return areEssentiallyEqual(inlineBox.left(), inlineRun.left())</span>
<span class="line-modified">122         &amp;&amp; areEssentiallyEqual(inlineBox.right(), inlineRun.right())</span>
<span class="line-modified">123         &amp;&amp; areEssentiallyEqual(inlineBox.top(), inlineRun.top())</span>
<span class="line-modified">124         &amp;&amp; areEssentiallyEqual(inlineBox.bottom(), inlineRun.bottom());</span>
125 }
126 
127 
128 static bool checkForMatchingTextRuns(const Display::Run&amp; inlineRun, const InlineTextBox&amp; inlineTextBox)
129 {
<a name="13" id="anc13"></a><span class="line-modified">130     return areEssentiallyEqual(inlineTextBox.left(), inlineRun.left())</span>
<span class="line-modified">131         &amp;&amp; areEssentiallyEqual(inlineTextBox.right(), inlineRun.right())</span>
<span class="line-modified">132         &amp;&amp; areEssentiallyEqual(inlineTextBox.top(), inlineRun.top())</span>
<span class="line-modified">133         &amp;&amp; areEssentiallyEqual(inlineTextBox.bottom(), inlineRun.bottom())</span>
<span class="line-modified">134         &amp;&amp; (inlineTextBox.isLineBreak() || (inlineTextBox.start() == inlineRun.textContext()-&gt;start() &amp;&amp; inlineTextBox.end() == inlineRun.textContext()-&gt;end()));</span>

135 }
136 
137 static void collectFlowBoxSubtree(const InlineFlowBox&amp; flowbox, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
138 {
<a name="14" id="anc14"></a><span class="line-modified">139     auto* inlineBox = flowbox.firstLeafDescendant();</span>
<span class="line-modified">140     auto* lastLeafDescendant = flowbox.lastLeafDescendant();</span>
141     while (inlineBox) {
142         inlineBoxes.append(inlineBox);
<a name="15" id="anc15"></a><span class="line-modified">143         if (inlineBox == lastLeafDescendant)</span>
144             break;
<a name="16" id="anc16"></a><span class="line-modified">145         inlineBox = inlineBox-&gt;nextLeafOnLine();</span>
146     }
147 }
148 
149 static void collectInlineBoxes(const RenderBlockFlow&amp; root, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
150 {
151     for (auto* rootLine = root.firstRootBox(); rootLine; rootLine = rootLine-&gt;nextRootBox()) {
152         for (auto* inlineBox = rootLine-&gt;firstChild(); inlineBox; inlineBox = inlineBox-&gt;nextOnLine()) {
153             if (!is&lt;InlineFlowBox&gt;(inlineBox)) {
154                 inlineBoxes.append(inlineBox);
155                 continue;
156             }
157             collectFlowBoxSubtree(downcast&lt;InlineFlowBox&gt;(*inlineBox), inlineBoxes);
158         }
159     }
160 }
161 
162 static bool outputMismatchingComplexLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
163 {
164     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
<a name="17" id="anc17"></a><span class="line-modified">165 </span>
<span class="line-modified">166     auto* displayInlineContent = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).displayInlineContent();</span>
<span class="line-added">167     if (!displayInlineContent) {</span>
<span class="line-added">168         ASSERT_NOT_REACHED();</span>
<span class="line-added">169         return true;</span>
<span class="line-added">170     }</span>
<span class="line-added">171     auto&amp; displayRuns = displayInlineContent-&gt;runs;</span>
172 
173     // Collect inlineboxes.
174     Vector&lt;WebCore::InlineBox*&gt; inlineBoxes;
175     collectInlineBoxes(blockFlow, inlineBoxes);
176 
177     auto mismatched = false;
178     unsigned runIndex = 0;
179 
<a name="18" id="anc18"></a><span class="line-modified">180     if (inlineBoxes.size() != displayRuns.size()) {</span>
<span class="line-modified">181         stream &lt;&lt; &quot;Warning: mismatching number of runs: inlineboxes(&quot; &lt;&lt; inlineBoxes.size() &lt;&lt; &quot;) vs. inline runs(&quot; &lt;&lt; displayRuns.size() &lt;&lt; &quot;)&quot;;</span>
182         stream.nextLine();
183     }
184 
<a name="19" id="anc19"></a><span class="line-modified">185     for (unsigned inlineBoxIndex = 0; inlineBoxIndex &lt; inlineBoxes.size() &amp;&amp; runIndex &lt; displayRuns.size(); ++inlineBoxIndex) {</span>
<span class="line-modified">186         auto&amp; displayRun = displayRuns[runIndex];</span>
187         auto* inlineBox = inlineBoxes[inlineBoxIndex];
188         auto* inlineTextBox = is&lt;InlineTextBox&gt;(inlineBox) ? downcast&lt;InlineTextBox&gt;(inlineBox) : nullptr;
<a name="20" id="anc20"></a><span class="line-modified">189         bool matchingRuns = inlineTextBox ? checkForMatchingTextRuns(displayRun, *inlineTextBox) : matchingRuns = checkForMatchingNonTextRuns(displayRun, *inlineBox);</span>
190 
191         if (!matchingRuns) {
192 
193             if (is&lt;RenderLineBreak&gt;(inlineBox-&gt;renderer())) {
194                 // &lt;br&gt; positioning is weird at this point. It needs proper baseline.
195                 matchingRuns = true;
196                 ++runIndex;
197                 continue;
198             }
199 
200             stream &lt;&lt; &quot;Mismatching: run&quot;;
201 
202             if (inlineTextBox)
<a name="21" id="anc21"></a><span class="line-modified">203                 stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineTextBox-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineTextBox-&gt;end() &lt;&lt; &quot;)&quot;;</span>
204             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineBox-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineBox-&gt;logicalTop() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineBox-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineBox-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;
205 
206             stream &lt;&lt; &quot; inline run&quot;;
<a name="22" id="anc22"></a><span class="line-modified">207             if (displayRun.textContext())</span>
<span class="line-modified">208                 stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.textContext()-&gt;end() &lt;&lt; &quot;)&quot;;</span>
<span class="line-modified">209             stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.left() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.top() &lt;&lt; &quot;) (&quot; &lt;&lt; displayRun.width() &lt;&lt; &quot;x&quot; &lt;&lt; displayRun.height() &lt;&lt; &quot;)&quot;;</span>
210             stream.nextLine();
211             mismatched = true;
212         }
213         ++runIndex;
214     }
215     return mismatched;
216 }
217 
218 static bool outputMismatchingBlockBoxInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
219 {
220     bool firstMismatchingRect = true;
221     auto outputRect = [&amp;] (const String&amp; prefix, const LayoutRect&amp; rendererRect, const LayoutRect&amp; layoutRect) {
222         if (firstMismatchingRect) {
223             stream &lt;&lt; (renderer.element() ? renderer.element()-&gt;nodeName().utf8().data() : &quot;&quot;) &lt;&lt; &quot; &quot; &lt;&lt; renderer.renderName() &lt;&lt; &quot;(&quot; &lt;&lt; &amp;renderer &lt;&lt; &quot;) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;;
224             stream.nextLine();
225             firstMismatchingRect = false;
226         }
227 
228         stream  &lt;&lt; prefix.utf8().data() &lt;&lt; &quot;\trenderer-&gt;(&quot; &lt;&lt; rendererRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; rendererRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; rendererRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; rendererRect.height() &lt;&lt; &quot;)&quot;
229             &lt;&lt; &quot;\tlayout-&gt;(&quot; &lt;&lt; layoutRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; layoutRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; layoutRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; layoutRect.height() &lt;&lt; &quot;)&quot;;
230         stream.nextLine();
231     };
232 
233     auto renderBoxLikeMarginBox = [](auto&amp; displayBox) {
234         // Produce a RenderBox matching margin box.
235         auto borderBox = displayBox.borderBox();
236 
237         return Display::Rect {
238             borderBox.top() - displayBox.nonCollapsedMarginBefore(),
239             borderBox.left() - displayBox.computedMarginStart().valueOr(0),
240             displayBox.computedMarginStart().valueOr(0) + borderBox.width() + displayBox.computedMarginEnd().valueOr(0),
241             displayBox.nonCollapsedMarginBefore() + borderBox.height() + displayBox.nonCollapsedMarginAfter()
242         };
243     };
244 
245     auto&amp; displayBox = context.displayBoxForLayoutBox(layoutBox);
246 
247     auto frameRect = renderer.frameRect();
248     // rendering does not offset for relative positioned boxes.
249     if (renderer.isInFlowPositioned())
250         frameRect.move(renderer.offsetForInFlowPosition());
251 
252     if (!areEssentiallyEqual(frameRect, displayBox.rect())) {
253         outputRect(&quot;frameBox&quot;, renderer.frameRect(), displayBox.rect());
254         return true;
255     }
256 
257     if (!areEssentiallyEqual(renderer.borderBoxRect(), displayBox.borderBox())) {
258         outputRect(&quot;borderBox&quot;, renderer.borderBoxRect(), displayBox.borderBox());
259         return true;
260     }
261 
262     if (!areEssentiallyEqual(renderer.paddingBoxRect(), displayBox.paddingBox())) {
263         outputRect(&quot;paddingBox&quot;, renderer.paddingBoxRect(), displayBox.paddingBox());
264         return true;
265     }
266 
267     if (!areEssentiallyEqual(renderer.contentBoxRect(), displayBox.contentBox())) {
268         outputRect(&quot;contentBox&quot;, renderer.contentBoxRect(), displayBox.contentBox());
269         return true;
270     }
271 
272     if (!areEssentiallyEqual(renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox))) {
273         // In certain cases, like out-of-flow boxes with margin auto, marginBoxRect() returns 0. It&#39;s clearly incorrect,
274         // so let&#39;s check the individual margin values instead (and at this point we know that all other boxes match).
275         auto marginsMatch = displayBox.marginBefore() == renderer.marginBefore()
276             &amp;&amp; displayBox.marginAfter() == renderer.marginAfter()
277             &amp;&amp; displayBox.marginStart() == renderer.marginStart()
278             &amp;&amp; displayBox.marginEnd() == renderer.marginEnd();
279 
280         if (!marginsMatch) {
281             outputRect(&quot;marginBox&quot;, renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox));
282             return true;
283         }
284     }
285 
286     return false;
287 }
288 
289 static bool verifyAndOutputSubtree(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
290 {
<a name="23" id="anc23"></a><span class="line-added">291     // Rendering code does not have the concept of table wrapper box. Skip it by verifying the first child(table box) instead.</span>
<span class="line-added">292     if (layoutBox.isTableWrapperBox())</span>
<span class="line-added">293         return verifyAndOutputSubtree(stream, context, renderer, *downcast&lt;Container&gt;(layoutBox).firstChild());</span>
<span class="line-added">294 </span>
295     auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, renderer, layoutBox);
296 
297     if (!is&lt;Container&gt;(layoutBox))
298         return mismtachingGeometry;
299 
300     auto&amp; container = downcast&lt;Container&gt;(layoutBox);
301     auto* childLayoutBox = container.firstChild();
302     auto* childRenderer = renderer.firstChild();
303 
304     while (childRenderer) {
305         if (!is&lt;RenderBox&gt;(*childRenderer)) {
306             childRenderer = childRenderer-&gt;nextSibling();
307             continue;
308         }
309 
310         if (!childLayoutBox) {
311             stream  &lt;&lt; &quot;Trees are out of sync!&quot;;
312             stream.nextLine();
313             return true;
314         }
315 
316         if (is&lt;RenderBlockFlow&gt;(*childRenderer) &amp;&amp; childLayoutBox-&gt;establishesInlineFormattingContext()) {
317             ASSERT(childRenderer-&gt;childrenInline());
318             auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
319             if (mismtachingGeometry)
320                 return true;
321 
322             auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*childRenderer);
323             auto&amp; formattingRoot = downcast&lt;Container&gt;(*childLayoutBox);
324             mismtachingGeometry |= blockFlow.lineLayoutPath() == RenderBlockFlow::SimpleLinesPath ? outputMismatchingSimpleLineInformationIfNeeded(stream, context, blockFlow, formattingRoot) : outputMismatchingComplexLineInformationIfNeeded(stream, context, blockFlow, formattingRoot);
325         } else {
326             auto mismatchingSubtreeGeometry = verifyAndOutputSubtree(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
327             mismtachingGeometry |= mismatchingSubtreeGeometry;
328         }
329 
330         childLayoutBox = childLayoutBox-&gt;nextSibling();
331         childRenderer = childRenderer-&gt;nextSibling();
332     }
333 
334     return mismtachingGeometry;
335 }
336 
<a name="24" id="anc24"></a><span class="line-modified">337 void LayoutContext::verifyAndOutputMismatchingLayoutTree(const LayoutState&amp; layoutState, const RenderView&amp; rootRenderer)</span>
338 {
339     TextStream stream;
<a name="25" id="anc25"></a><span class="line-modified">340     auto&amp; layoutRoot = layoutState.root();</span>
<span class="line-added">341     auto mismatchingGeometry = verifyAndOutputSubtree(stream, layoutState, rootRenderer, layoutRoot);</span>
342     if (!mismatchingGeometry)
343         return;
344 #if ENABLE(TREE_DEBUGGING)
<a name="26" id="anc26"></a><span class="line-modified">345     showRenderTree(&amp;rootRenderer);</span>
<span class="line-modified">346     showLayoutTree(layoutRoot, &amp;layoutState);</span>
347 #endif
348     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
349     ASSERT_NOT_REACHED();
350 }
351 
352 }
353 }
354 
355 #endif
<a name="27" id="anc27"></a><span class="line-added">356 </span>
<span class="line-added">357 #endif</span>
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp
@@ -98,22 +98,22 @@
     float boxHeight = horizontalWritingMode ? logicalBoxSize.height() : logicalBoxSize.width();
     std::unique_ptr<Shape> shape;
 
     switch (basicShape.type()) {
 
-    case BasicShape::BasicShapeCircleType: {
+    case BasicShape::Type::Circle: {
         const auto& circle = downcast<BasicShapeCircle>(basicShape);
         float centerX = floatValueForCenterCoordinate(circle.centerX(), boxWidth);
         float centerY = floatValueForCenterCoordinate(circle.centerY(), boxHeight);
         float radius = circle.floatValueForRadiusInBox(boxWidth, boxHeight);
         FloatPoint logicalCenter = physicalPointToLogical(FloatPoint(centerX, centerY), logicalBoxSize.height(), writingMode);
 
         shape = createCircleShape(logicalCenter, radius);
         break;
     }
 
-    case BasicShape::BasicShapeEllipseType: {
+    case BasicShape::Type::Ellipse: {
         const auto& ellipse = downcast<BasicShapeEllipse>(basicShape);
         float centerX = floatValueForCenterCoordinate(ellipse.centerX(), boxWidth);
         float centerY = floatValueForCenterCoordinate(ellipse.centerY(), boxHeight);
         float radiusX = ellipse.floatValueForRadiusInBox(ellipse.radiusX(), centerX, boxWidth);
         float radiusY = ellipse.floatValueForRadiusInBox(ellipse.radiusY(), centerY, boxHeight);
@@ -121,11 +121,11 @@
 
         shape = createEllipseShape(logicalCenter, FloatSize(radiusX, radiusY));
         break;
     }
 
-    case BasicShape::BasicShapePolygonType: {
+    case BasicShape::Type::Polygon: {
         const auto& polygon = downcast<BasicShapePolygon>(basicShape);
         const Vector<Length>& values = polygon.values();
         size_t valuesSize = values.size();
         ASSERT(!(valuesSize % 2));
         std::unique_ptr<Vector<FloatPoint>> vertices = makeUnique<Vector<FloatPoint>>(valuesSize / 2);
@@ -138,11 +138,11 @@
 
         shape = createPolygonShape(WTFMove(vertices), polygon.windRule());
         break;
     }
 
-    case BasicShape::BasicShapeInsetType: {
+    case BasicShape::Type::Inset: {
         const auto& inset = downcast<BasicShapeInset>(basicShape);
         float left = floatValueForLength(inset.left(), boxWidth);
         float top = floatValueForLength(inset.top(), boxHeight);
         FloatRect rect(left,
             top,
@@ -179,22 +179,22 @@
 
     IntRect imageRect = snappedIntRect(imageR);
     IntRect marginRect = snappedIntRect(marginR);
     auto intervals = makeUnique<RasterShapeIntervals>(marginRect.height(), -marginRect.y());
     // FIXME (149420): This buffer should not be unconditionally unaccelerated.
-    std::unique_ptr<ImageBuffer> imageBuffer = ImageBuffer::create(imageRect.size(), Unaccelerated);
+    std::unique_ptr<ImageBuffer> imageBuffer = ImageBuffer::create(imageRect.size(), RenderingMode::Unaccelerated);
 
     if (imageBuffer) {
         GraphicsContext& graphicsContext = imageBuffer->context();
         if (image)
             graphicsContext.drawImage(*image, IntRect(IntPoint(), imageRect.size()));
 
         RefPtr<Uint8ClampedArray> pixelArray = imageBuffer->getUnmultipliedImageData(IntRect(IntPoint(), imageRect.size()));
         RELEASE_ASSERT(pixelArray);
         unsigned pixelArrayLength = pixelArray->length();
         unsigned pixelArrayOffset = 3; // Each pixel is four bytes: RGBA.
-        uint8_t alphaPixelThreshold = threshold * 255;
+        uint8_t alphaPixelThreshold = static_cast<uint8_t>(lroundf(clampTo<float>(threshold, 0, 1) * 255.0f));
 
         int minBufferY = std::max(0, marginRect.y() - imageRect.y());
         int maxBufferY = std::min(imageRect.height(), marginRect.maxY() - imageRect.y());
 
         if ((imageRect.area() * 4).unsafeGet() == pixelArrayLength) {

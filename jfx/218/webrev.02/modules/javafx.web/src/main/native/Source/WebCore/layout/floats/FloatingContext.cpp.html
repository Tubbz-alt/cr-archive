<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FloatingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;DisplayBox.h&quot;
 32 #include &quot;FloatAvoider.h&quot;
 33 #include &quot;FloatBox.h&quot;
 34 #include &quot;FormattingContext.h&quot;
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 
 39 namespace WebCore {
 40 namespace Layout {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(FloatingContext);
 43 
 44 // Finding the top/left position for a new floating(F)
 45 //  ____  ____  _____               _______
 46 // |    || L2 ||     | &lt;-----1----&gt;|       |
 47 // |    ||____||  L3 |             |   R1  |
 48 // | L1 |      |_____|             |       |
 49 // |____| &lt;-------------2---------&gt;|       |
 50 //                                 |       |
 51 //                                 |_______|
 52 //
 53 // 1. Compute the initial vertical position for (F) -&gt; (1)
 54 // 2. Find the corresponding floating pair (L3-R1)
 55 // 3. Align (F) horizontally with (L3-R1) depending whether (F) is left/right positioned
 56 // 4. Intersect (F) with (L3-R1)
 57 // 5. If (F) does not fit, find the next floating pair (L1-R1)
 58 // 6. Repeat until either (F) fits/no more floats.
 59 // Note that all coordinates are in the coordinate system of the formatting root.
 60 // The formatting root here is always the one that establishes the floating context (see inherited floating context).
 61 // (It simply means that the float box&#39;s formatting root is not necessarily the same as the FormattingContext&#39;s root.)
 62 
 63 class Iterator;
 64 
 65 class FloatPair {
 66 public:
 67     struct LeftRightIndex {
 68         bool isEmpty() const { return !left &amp;&amp; !right;}
 69 
 70         Optional&lt;unsigned&gt; left;
 71         Optional&lt;unsigned&gt; right;
 72     };
 73 
 74     bool isEmpty() const { return m_floatPair.isEmpty(); }
 75     const FloatingState::FloatItem* left() const;
 76     const FloatingState::FloatItem* right() const;
 77     bool intersects(const Display::Rect&amp;) const;
 78     PositionInContextRoot verticalConstraint() const { return m_verticalPosition; }
 79     FloatAvoider::HorizontalConstraints horizontalConstraints() const;
 80     PositionInContextRoot bottom() const;
 81     LeftRightIndex operator*() const { return m_floatPair; };
 82     bool operator==(const FloatPair&amp;) const;
 83 
 84 private:
 85     friend class Iterator;
 86     FloatPair(const FloatingState::FloatList&amp;);
 87 
 88     const FloatingState::FloatList&amp; m_floats;
 89     LeftRightIndex m_floatPair;
 90     PositionInContextRoot m_verticalPosition;
 91 };
 92 
 93 class Iterator {
 94 public:
 95     Iterator(const FloatingState::FloatList&amp;, Optional&lt;PositionInContextRoot&gt; verticalPosition);
 96 
 97     const FloatPair&amp; operator*() const { return m_current; }
 98     Iterator&amp; operator++();
 99     bool operator==(const Iterator&amp;) const;
100     bool operator!=(const Iterator&amp;) const;
101 
102 private:
103     void set(PositionInContextRoot verticalPosition);
104 
105     const FloatingState::FloatList&amp; m_floats;
106     FloatPair m_current;
107 };
108 
109 static Iterator begin(const FloatingState::FloatList&amp; floats, PositionInContextRoot initialVerticalPosition)
110 {
111     // Start with the inner-most floating pair for the initial vertical position.
112     return Iterator(floats, initialVerticalPosition);
113 }
114 
115 static Iterator end(const FloatingState::FloatList&amp; floats)
116 {
117     return Iterator(floats, { });
118 }
119 
120 #if ASSERT_ENABLED
121 static bool areFloatsHorizontallySorted(const FloatingState&amp; floatingState)
122 {
123     auto&amp; floats = floatingState.floats();
124     auto rightEdgeOfLeftFloats = LayoutUnit::min();
125     auto leftEdgeOfRightFloats = LayoutUnit::max();
126     WTF::Optional&lt;LayoutUnit&gt; leftBottom;
127     WTF::Optional&lt;LayoutUnit&gt; rightBottom;
128 
129     for (auto&amp; floatItem : floats) {
130         if (floatItem.isLeftPositioned()) {
131             auto rightEdge = floatItem.rectWithMargin().right();
132             if (rightEdge &lt; rightEdgeOfLeftFloats) {
133                 if (leftBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *leftBottom)
134                     return false;
135             }
136             leftBottom = floatItem.rectWithMargin().bottom();
137             rightEdgeOfLeftFloats = rightEdge;
138         } else {
139             auto leftEdge = floatItem.rectWithMargin().left();
140             if (leftEdge &gt; leftEdgeOfRightFloats) {
141                 if (rightBottom &amp;&amp; floatItem.rectWithMargin().top() &lt; *rightBottom)
142                     return false;
143             }
144             rightBottom = floatItem.rectWithMargin().bottom();
145             leftEdgeOfRightFloats = leftEdge;
146         }
147     }
148     return true;
149 }
150 #endif
151 
152 struct FloatingContext::AbsoluteCoordinateValuesForFloatAvoider {
153     Display::Box displayBox;
154     LayoutPoint containingBlockTopLeft;
155     HorizontalEdges containingBlockContentBox;
156 };
157 
158 FloatingContext::FloatingContext(const Container&amp; floatingContextRoot, const FormattingContext&amp; formattingContext, FloatingState&amp; floatingState)
159     : m_root(makeWeakPtr(floatingContextRoot))
160     , m_formattingContext(formattingContext)
161     , m_floatingState(floatingState)
162 {
163 }
164 
165 Point FloatingContext::positionForFloat(const Box&amp; layoutBox) const
166 {
167     ASSERT(layoutBox.isFloatingPositioned());
168     ASSERT(areFloatsHorizontallySorted(m_floatingState));
169 
170     if (isEmpty()) {
171         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);
172 
173         auto alignWithContainingBlock = [&amp;]() -&gt; Position {
174             // If there is no floating to align with, push the box to the left/right edge of its containing block&#39;s content box.
175             auto&amp; containingBlockGeometry = formattingContext().geometryForBox(*layoutBox.containingBlock());
176 
177             if (layoutBox.isLeftFloatingPositioned())
178                 return Position { containingBlockGeometry.contentBoxLeft() + boxGeometry.marginStart() };
179 
180             return Position { containingBlockGeometry.contentBoxRight() - boxGeometry.marginEnd() - boxGeometry.width() };
181         };
182 
183         // No float box on the context yet -&gt; align it with the containing block&#39;s left/right edge.
184         return { alignWithContainingBlock(), boxGeometry.top() };
185     }
186 
187     // Find the top most position where the float box fits.
188     auto absoluteDisplayBoxCoordinates = this-&gt;absoluteDisplayBoxCoordinates(layoutBox);
189 
190     Optional&lt;LayoutUnit&gt; previousFloatAbsoluteTop;
191     if (!isEmpty())
192         previousFloatAbsoluteTop = floatingState().floats().last().rectWithMargin().top();
193     auto floatBox = FloatBox { layoutBox, absoluteDisplayBoxCoordinates.displayBox, absoluteDisplayBoxCoordinates.containingBlockTopLeft, absoluteDisplayBoxCoordinates.containingBlockContentBox, previousFloatAbsoluteTop };
194     findPositionForFloatBox(floatBox);
195     return floatBox.rectInContainingBlock().topLeft();
196 }
197 
198 Optional&lt;Point&gt; FloatingContext::positionForFormattingContextRoot(const Box&amp; layoutBox) const
199 {
200     ASSERT(layoutBox.establishesBlockFormattingContext());
201     ASSERT(!layoutBox.isFloatingPositioned());
202     ASSERT(!layoutBox.hasFloatClear());
203     ASSERT(areFloatsHorizontallySorted(m_floatingState));
204 
205     if (isEmpty())
206         return { };
207 
208     auto absoluteDisplayBoxCoordinates = this-&gt;absoluteDisplayBoxCoordinates(layoutBox);
209     auto floatAvoider = FloatAvoider { layoutBox, absoluteDisplayBoxCoordinates.displayBox, absoluteDisplayBoxCoordinates.containingBlockTopLeft, absoluteDisplayBoxCoordinates.containingBlockContentBox };
210     findPositionForFormattingContextRoot(floatAvoider);
211     return { floatAvoider.rectInContainingBlock().topLeft() };
212 }
213 
214 FloatingContext::ClearancePosition FloatingContext::verticalPositionWithClearance(const Box&amp; layoutBox) const
215 {
216     ASSERT(layoutBox.hasFloatClear());
217     ASSERT(layoutBox.isBlockLevelBox());
218     ASSERT(areFloatsHorizontallySorted(m_floatingState));
219 
220     if (isEmpty())
221         return { };
222 
223     auto bottom = [&amp;](Optional&lt;PositionInContextRoot&gt; floatBottom) -&gt; ClearancePosition {
224         // &#39;bottom&#39; is in the formatting root&#39;s coordinate system.
225         if (!floatBottom)
226             return { };
227 
228         // 9.5.2 Controlling flow next to floats: the &#39;clear&#39; property
229         // Then the amount of clearance is set to the greater of:
230         //
231         // 1. The amount necessary to place the border edge of the block even with the bottom outer edge of the lowest float that is to be cleared.
232         // 2. The amount necessary to place the top border edge of the block at its hypothetical position.
233         auto rootRelativeTop = mapTopToFloatingStateRoot(layoutBox);
234         auto clearance = *floatBottom - rootRelativeTop;
235         if (clearance &lt;= 0)
236             return { };
237 
238         // Clearance inhibits margin collapsing.
239         if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
240             // Does this box with clearance actually collapse its margin before with the previous inflow box&#39;s margin after?
241             auto verticalMargin = formattingContext().geometryForBox(layoutBox).verticalMargin();
242             if (verticalMargin.hasCollapsedValues() &amp;&amp; verticalMargin.collapsedValues().before) {
243                 auto previousVerticalMargin = formattingContext().geometryForBox(*previousInFlowSibling).verticalMargin();
244                 auto collapsedMargin = *verticalMargin.collapsedValues().before;
245                 auto nonCollapsedMargin = previousVerticalMargin.after() + verticalMargin.before();
246                 auto marginDifference = nonCollapsedMargin - collapsedMargin;
247                 // Move the box to the position where it would be with non-collapsed margins.
248                 rootRelativeTop += marginDifference;
249                 // Having negative clearance is also normal. It just means that the box with the non-collapsed margins is now lower than it needs to be.
250                 clearance -= marginDifference;
251             }
252         }
253         // Now adjust the box&#39;s position with the clearance.
254         rootRelativeTop += clearance;
255         ASSERT(*floatBottom == rootRelativeTop);
256 
257         // The return vertical position is in the containing block&#39;s coordinate system. Convert it to the formatting root&#39;s coordinate system if needed.
258         if (layoutBox.containingBlock() == &amp;m_floatingState.root())
259             return { Position { rootRelativeTop }, clearance };
260 
261         auto containingBlockRootRelativeTop = mapTopToFloatingStateRoot(*layoutBox.containingBlock());
262         return { Position { rootRelativeTop - containingBlockRootRelativeTop }, clearance };
263     };
264 
265     auto clear = layoutBox.style().clear();
266     if (clear == Clear::Left)
267         return bottom(m_floatingState.leftBottom(root()));
268 
269     if (clear == Clear::Right)
270         return bottom(m_floatingState.rightBottom(root()));
271 
272     if (clear == Clear::Both)
273         return bottom(m_floatingState.bottom(root()));
274 
275     ASSERT_NOT_REACHED();
276     return { };
277 }
278 
279 FloatingContext::Constraints FloatingContext::constraints(LayoutUnit logicalTop, LayoutUnit logicalBottom) const
280 {
281     if (isEmpty())
282         return { };
283 
284     // 1. Convert vertical position if this floating context is inherited.
285     // 2. Find the inner left/right floats at logicalTop/logicalBottom.
286     // 3. Convert left/right positions back to formattingContextRoot&#39;s cooridnate system.
287     auto coordinateMappingIsRequired = &amp;floatingState().root() != &amp;root();
288     auto adjustedLogicalTop = logicalTop;
289     LayoutSize adjustingDelta;
290     if (coordinateMappingIsRequired) {
291         auto adjustedPosition = mapPointFromFormattingContextRootToFloatingStateRoot({ 0, logicalTop });
292         adjustedLogicalTop = adjustedPosition.y;
293         adjustingDelta = { adjustedPosition.x, adjustedLogicalTop - logicalTop };
294     }
295     auto adjustedLogicalBottom = adjustedLogicalTop + (logicalBottom - logicalTop);
296 
297     Constraints constraints;
298     auto&amp; floats = floatingState().floats();
299     for (auto index = floats.size(); index--;) {
300         auto&amp; floatItem = floats[index];
301 
302         if (constraints.left &amp;&amp; floatItem.isLeftPositioned())
303             continue;
304 
305         if (constraints.right &amp;&amp; !floatItem.isLeftPositioned())
306             continue;
307 
308         auto rect = floatItem.rectWithMargin();
309         if (rect.top() &gt;= adjustedLogicalBottom || rect.bottom() &lt;= adjustedLogicalTop)
310             continue;
311 
312         if (floatItem.isLeftPositioned())
313             constraints.left = PointInContextRoot { rect.right(), rect.bottom() };
314         else
315             constraints.right = PointInContextRoot { rect.left(), rect.bottom() };
316 
317         if (constraints.left &amp;&amp; constraints.right)
318             break;
319     }
320 
321     if (coordinateMappingIsRequired) {
322         if (constraints.left)
323             constraints.left-&gt;move(-adjustingDelta);
324 
325         if (constraints.right)
326             constraints.right-&gt;move(-adjustingDelta);
327     }
328     return constraints;
329 }
330 
331 void FloatingContext::append(const Box&amp; floatBox)
332 {
333     floatingState().append(FloatingState::FloatItem { floatBox, mapToFloatingStateRoot(floatBox) });
334 }
335 
336 static FloatPair::LeftRightIndex findAvailablePosition(FloatAvoider&amp; floatAvoider, const FloatingState::FloatList&amp; floats)
337 {
338     Optional&lt;PositionInContextRoot&gt; bottomMost;
339     Optional&lt;FloatPair::LeftRightIndex&gt; innerMostLeftAndRight;
340     auto end = Layout::end(floats);
341     for (auto iterator = begin(floats, { floatAvoider.rect().top() }); iterator != end; ++iterator) {
342         ASSERT(!(*iterator).isEmpty());
343         auto leftRightFloatPair = *iterator;
344         innerMostLeftAndRight = innerMostLeftAndRight.valueOr(*leftRightFloatPair);
345 
346         // Move the box horizontally so that it either
347         // 1. aligns with the current floating pair
348         // 2. or with the containing block&#39;s content box if there&#39;s no float to align with at this vertical position.
349         floatAvoider.setHorizontalConstraints(leftRightFloatPair.horizontalConstraints());
350         floatAvoider.setVerticalConstraint(leftRightFloatPair.verticalConstraint());
351 
352         // Ensure that the float avoider
353         // 1. does not &quot;overflow&quot; its containing block with the current horiztonal constraints. It simply means that the float avoider&#39;s
354         // containing block could push the candidate position beyond the current float horizontally (too far to the left/right)
355         // 2. avoids floats on both sides.
356         if (!floatAvoider.overflowsContainingBlock() &amp;&amp; !leftRightFloatPair.intersects(floatAvoider.rect()))
357             return *innerMostLeftAndRight;
358 
359         bottomMost = leftRightFloatPair.bottom();
360         // Move to the next floating pair.
361     }
362 
363     // The candidate box is already below of all the floats.
364     if (!bottomMost)
365         return { };
366 
367     // Passed all the floats and still does not fit? Push it below the last float.
368     floatAvoider.setVerticalConstraint(*bottomMost);
369     floatAvoider.setHorizontalConstraints({ });
370     ASSERT(innerMostLeftAndRight);
371     return *innerMostLeftAndRight;
372 }
373 
374 void FloatingContext::findPositionForFloatBox(FloatBox&amp; floatBox) const
375 {
376     findAvailablePosition(floatBox, m_floatingState.floats());
377 }
378 
379 void FloatingContext::findPositionForFormattingContextRoot(FloatAvoider&amp; floatAvoider) const
380 {
381     // A non-floating formatting root&#39;s initial vertical position is its static position.
382     // It means that such boxes can end up vertically placed in-between existing floats (which is
383     // never the case for floats, since they cannot be placed above existing floats).
384     //  ____  ____
385     // |    || F1 |
386     // | L1 | ----
387     // |    |  ________
388     //  ----  |   R1   |
389     //         --------
390     // Document order: 1. float: left (L1) 2. float: right (R1) 3. formatting root (F1)
391     //
392     // 1. Probe for available placement at initial position (note it runs a backward probing algorithm at a specific vertical position)
393     // 2. Check if there&#39;s any intersecing float below (forward seaching)
394     // 3. Align the box with the intersected float and probe for placement again (#1).
395     auto&amp; floats = m_floatingState.floats();
396     while (true) {
397         auto innerMostLeftAndRight = findAvailablePosition(floatAvoider, floats);
398         if (innerMostLeftAndRight.isEmpty())
399             return;
400 
401         auto overlappingFloatBox = [&amp;floats](auto startFloatIndex, auto floatAvoiderRect) -&gt; const FloatingState::FloatItem* {
402             for (auto i = startFloatIndex; i &lt; floats.size(); ++i) {
403                 auto&amp; floatBox = floats[i];
404                 if (floatBox.rectWithMargin().intersects(floatAvoiderRect))
405                     return &amp;floatBox;
406             }
407             return nullptr;
408         };
409 
410         auto startIndex = std::max(innerMostLeftAndRight.left.valueOr(0), innerMostLeftAndRight.right.valueOr(0)) + 1;
411         auto* intersectedFloatBox = overlappingFloatBox(startIndex, floatAvoider.rect());
412         if (!intersectedFloatBox)
413             return;
414         floatAvoider.setVerticalConstraint({ intersectedFloatBox-&gt;rectWithMargin().top() });
415     }
416 }
417 
418 FloatingContext::AbsoluteCoordinateValuesForFloatAvoider FloatingContext::absoluteDisplayBoxCoordinates(const Box&amp; floatAvoider) const
419 {
420     auto&amp; containingBlock = *floatAvoider.containingBlock();
421     auto displayBox = mapToFloatingStateRoot(floatAvoider);
422 
423     if (&amp;containingBlock == &amp;floatingState().root()) {
424         auto containingBlockGeometry = formattingContext().geometryForBox(containingBlock, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates);
425         return { displayBox, { }, {  containingBlockGeometry.contentBoxLeft(), containingBlockGeometry.contentBoxRight() } };
426     }
427     auto containingBlockAbsoluteDisplayBox = mapToFloatingStateRoot(containingBlock);
428     auto containingBlockLeft = containingBlockAbsoluteDisplayBox.left();
429     return { displayBox, containingBlockAbsoluteDisplayBox.topLeft(), { containingBlockLeft + containingBlockAbsoluteDisplayBox.contentBoxLeft(), containingBlockLeft + containingBlockAbsoluteDisplayBox.contentBoxRight() } };
430 }
431 
432 Display::Box FloatingContext::mapToFloatingStateRoot(const Box&amp; floatBox) const
433 {
434     auto&amp; floatingStateRoot = floatingState().root();
435     auto&amp; boxGeometry = formattingContext().geometryForBox(floatBox, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates);
436     auto topLeft = boxGeometry.topLeft();
437     for (auto* containingBlock = floatBox.containingBlock(); containingBlock &amp;&amp; containingBlock != &amp;floatingStateRoot; containingBlock = containingBlock-&gt;containingBlock())
438         topLeft.moveBy(formattingContext().geometryForBox(*containingBlock, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).topLeft());
439 
440     auto mappedDisplayBox = Display::Box(boxGeometry);
441     mappedDisplayBox.setTopLeft(topLeft);
442     return mappedDisplayBox;
443 }
444 
445 LayoutUnit FloatingContext::mapTopToFloatingStateRoot(const Box&amp; floatBox) const
446 {
447     auto&amp; floatingStateRoot = floatingState().root();
448     auto top = formattingContext().geometryForBox(floatBox, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).top();
449     for (auto* container = floatBox.containingBlock(); container &amp;&amp; container != &amp;floatingStateRoot; container = container-&gt;containingBlock())
450         top += formattingContext().geometryForBox(*container, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).top();
451     return top;
452 }
453 
454 Point FloatingContext::mapPointFromFormattingContextRootToFloatingStateRoot(Point position) const
455 {
456     auto&amp; from = root();
457     auto&amp; to = floatingState().root();
458     if (&amp;from == &amp;to)
459         return position;
460     auto mappedPosition = position;
461     for (auto* container = &amp;from; container &amp;&amp; container != &amp;to; container = container-&gt;containingBlock())
462         mappedPosition.moveBy(formattingContext().geometryForBox(*container, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).topLeft());
463     return mappedPosition;
464 }
465 
466 FloatPair::FloatPair(const FloatingState::FloatList&amp; floats)
467     : m_floats(floats)
468 {
469 }
470 
471 const FloatingState::FloatItem* FloatPair::left() const
472 {
473     if (!m_floatPair.left)
474         return nullptr;
475 
476     ASSERT(m_floats[*m_floatPair.left].isLeftPositioned());
477     return &amp;m_floats[*m_floatPair.left];
478 }
479 
480 const FloatingState::FloatItem* FloatPair::right() const
481 {
482     if (!m_floatPair.right)
483         return nullptr;
484 
485     ASSERT(!m_floats[*m_floatPair.right].isLeftPositioned());
486     return &amp;m_floats[*m_floatPair.right];
487 }
488 
489 bool FloatPair::intersects(const Display::Rect&amp; floatAvoiderRect) const
490 {
491     auto intersects = [&amp;](auto* floating) {
492         return floating &amp;&amp; floating-&gt;rectWithMargin().intersects(floatAvoiderRect);
493     };
494 
495     ASSERT(!m_floatPair.isEmpty());
496     return intersects(left()) || intersects(right());
497 }
498 
499 bool FloatPair::operator ==(const FloatPair&amp; other) const
500 {
501     return m_floatPair.left == other.m_floatPair.left &amp;&amp; m_floatPair.right == other.m_floatPair.right;
502 }
503 
504 FloatAvoider::HorizontalConstraints FloatPair::horizontalConstraints() const
505 {
506     Optional&lt;PositionInContextRoot&gt; leftEdge;
507     Optional&lt;PositionInContextRoot&gt; rightEdge;
508 
509     if (left())
510         leftEdge = PositionInContextRoot { left()-&gt;rectWithMargin().right() };
511 
512     if (right())
513         rightEdge = PositionInContextRoot { right()-&gt;rectWithMargin().left() };
514 
515     return { leftEdge, rightEdge };
516 }
517 
518 PositionInContextRoot FloatPair::bottom() const
519 {
520     auto* left = this-&gt;left();
521     auto* right = this-&gt;right();
522     ASSERT(left || right);
523 
524     auto leftBottom = left ? Optional&lt;PositionInContextRoot&gt;(PositionInContextRoot { left-&gt;rectWithMargin().bottom() }) : WTF::nullopt;
525     auto rightBottom = right ? Optional&lt;PositionInContextRoot&gt;(PositionInContextRoot { right-&gt;rectWithMargin().bottom() }) : WTF::nullopt;
526 
527     if (leftBottom &amp;&amp; rightBottom)
528         return std::max(*leftBottom, *rightBottom);
529 
530     if (leftBottom)
531         return *leftBottom;
532 
533     return *rightBottom;
534 }
535 
536 Iterator::Iterator(const FloatingState::FloatList&amp; floats, Optional&lt;PositionInContextRoot&gt; verticalPosition)
537     : m_floats(floats)
538     , m_current(floats)
539 {
540     if (verticalPosition)
541         set(*verticalPosition);
542 }
543 
544 inline static Optional&lt;unsigned&gt; previousFloatingIndex(Float floatingType, const FloatingState::FloatList&amp; floats, unsigned currentIndex)
545 {
546     RELEASE_ASSERT(currentIndex &lt;= floats.size());
547 
548     while (currentIndex) {
549         auto&amp; floating = floats[--currentIndex];
550         if ((floatingType == Float::Left &amp;&amp; floating.isLeftPositioned()) || (floatingType == Float::Right &amp;&amp; !floating.isLeftPositioned()))
551             return currentIndex;
552     }
553 
554     return { };
555 }
556 
557 Iterator&amp; Iterator::operator++()
558 {
559     if (m_current.isEmpty()) {
560         ASSERT_NOT_REACHED();
561         return *this;
562     }
563 
564     auto findPreviousFloatingWithLowerBottom = [&amp;](Float floatingType, unsigned currentIndex) -&gt; Optional&lt;unsigned&gt; {
565 
566         RELEASE_ASSERT(currentIndex &lt; m_floats.size());
567 
568         // Last floating? There&#39;s certainly no previous floating at this point.
569         if (!currentIndex)
570             return { };
571 
572         auto currentBottom = m_floats[currentIndex].rectWithMargin().bottom();
573 
574         Optional&lt;unsigned&gt; index = currentIndex;
575         while (true) {
576             index = previousFloatingIndex(floatingType, m_floats, *index);
577             if (!index)
578                 return { };
579 
580             if (m_floats[*index].rectWithMargin().bottom() &gt; currentBottom)
581                 return index;
582         }
583 
584         ASSERT_NOT_REACHED();
585         return { };
586     };
587 
588     // 1. Take the current floating from left and right and check which one&#39;s bottom edge is positioned higher (they could be on the same vertical position too).
589     // The current floats from left and right are considered the inner-most pair for the current vertical position.
590     // 2. Move away from inner-most pair by picking one of the previous floats in the list(#1)
591     // Ensure that the new floating&#39;s bottom edge is positioned lower than the current one -which essentially means skipping in-between floats that are positioned higher).
592     // 3. Reset the vertical position and align it with the new left-right pair. These floats are now the inner-most boxes for the current vertical position.
593     // As the result we have more horizontal space on the current vertical position.
594     auto leftBottom = m_current.left() ? Optional&lt;PositionInContextRoot&gt;(m_current.left()-&gt;bottom()) : WTF::nullopt;
595     auto rightBottom = m_current.right() ? Optional&lt;PositionInContextRoot&gt;(m_current.right()-&gt;bottom()) : WTF::nullopt;
596 
597     auto updateLeft = (leftBottom == rightBottom) || (!rightBottom || (leftBottom &amp;&amp; leftBottom &lt; rightBottom));
598     auto updateRight = (leftBottom == rightBottom) || (!leftBottom || (rightBottom &amp;&amp; leftBottom &gt; rightBottom));
599 
600     if (updateLeft) {
601         ASSERT(m_current.m_floatPair.left);
602         m_current.m_verticalPosition = *leftBottom;
603         m_current.m_floatPair.left = findPreviousFloatingWithLowerBottom(Float::Left, *m_current.m_floatPair.left);
604     }
605 
606     if (updateRight) {
607         ASSERT(m_current.m_floatPair.right);
608         m_current.m_verticalPosition = *rightBottom;
609         m_current.m_floatPair.right = findPreviousFloatingWithLowerBottom(Float::Right, *m_current.m_floatPair.right);
610     }
611 
612     return *this;
613 }
614 
615 void Iterator::set(PositionInContextRoot verticalPosition)
616 {
617     // Move the iterator to the initial vertical position by starting at the inner-most floating pair (last floats on left/right).
618     // 1. Check if the inner-most pair covers the vertical position.
619     // 2. Move outwards from the inner-most pair until the vertical postion intersects.
620     m_current.m_verticalPosition = verticalPosition;
621     // No floats at all?
622     if (m_floats.isEmpty()) {
623         ASSERT_NOT_REACHED();
624         m_current.m_floatPair = { };
625         return;
626     }
627 
628     auto findFloatingBelow = [&amp;](Float floatingType) -&gt; Optional&lt;unsigned&gt; {
629 
630         ASSERT(!m_floats.isEmpty());
631 
632         auto index = floatingType == Float::Left ? m_current.m_floatPair.left : m_current.m_floatPair.right;
633         // Start from the end if we don&#39;t have current yet.
634         index = index.valueOr(m_floats.size());
635         while (true) {
636             index = previousFloatingIndex(floatingType, m_floats, *index);
637             if (!index)
638                 return { };
639 
640             // Is this floating intrusive on this position?
641             auto rect = m_floats[*index].rectWithMargin();
642             if (rect.top() &lt;= verticalPosition &amp;&amp; rect.bottom() &gt; verticalPosition)
643                 return index;
644         }
645 
646         return { };
647     };
648 
649     m_current.m_floatPair.left = findFloatingBelow(Float::Left);
650     m_current.m_floatPair.right = findFloatingBelow(Float::Right);
651 
652     ASSERT(!m_current.m_floatPair.left || (*m_current.m_floatPair.left &lt; m_floats.size() &amp;&amp; m_floats[*m_current.m_floatPair.left].isLeftPositioned()));
653     ASSERT(!m_current.m_floatPair.right || (*m_current.m_floatPair.right &lt; m_floats.size() &amp;&amp; !m_floats[*m_current.m_floatPair.right].isLeftPositioned()));
654 }
655 
656 bool Iterator::operator==(const Iterator&amp; other) const
657 {
658     return m_current == other.m_current;
659 }
660 
661 bool Iterator::operator!=(const Iterator&amp; other) const
662 {
663     return !(*this == other);
664 }
665 
666 }
667 }
668 #endif
    </pre>
  </body>
</html>
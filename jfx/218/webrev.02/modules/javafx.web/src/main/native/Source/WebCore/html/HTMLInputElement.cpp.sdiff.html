<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLInputElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLImageElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLInputElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLInputElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  45 #include &quot;FormController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameSelection.h&quot;
  48 #include &quot;FrameView.h&quot;
  49 #include &quot;HTMLDataListElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLImageLoader.h&quot;
  52 #include &quot;HTMLOptionElement.h&quot;
  53 #include &quot;HTMLParserIdioms.h&quot;
  54 #include &quot;IdTargetObserver.h&quot;
  55 #include &quot;KeyboardEvent.h&quot;
  56 #include &quot;LocalizedStrings.h&quot;
  57 #include &quot;MouseEvent.h&quot;
  58 #include &quot;Page.h&quot;
  59 #include &quot;PlatformMouseEvent.h&quot;
  60 #include &quot;RenderTextControlSingleLine.h&quot;
  61 #include &quot;RenderTheme.h&quot;
  62 #include &quot;ScopedEventQueue.h&quot;
  63 #include &quot;SearchInputType.h&quot;
  64 #include &quot;Settings.h&quot;
<span class="line-modified">  65 #include &quot;StyleResolver.h&quot;</span>
  66 #include &quot;TextControlInnerElements.h&quot;
  67 #include &lt;wtf/IsoMallocInlines.h&gt;
  68 #include &lt;wtf/Language.h&gt;
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/Ref.h&gt;
  71 
  72 #if ENABLE(TOUCH_EVENTS)
  73 #include &quot;TouchEvent.h&quot;
  74 #endif
  75 
  76 namespace WebCore {
  77 
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLInputElement);
  79 
  80 using namespace HTMLNames;
  81 
  82 #if ENABLE(DATALIST_ELEMENT)
  83 class ListAttributeTargetObserver : IdTargetObserver {
  84     WTF_MAKE_FAST_ALLOCATED;
  85 public:
</pre>
<hr />
<pre>
 156 {
 157     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 158     protectedInputType-&gt;createShadowSubtree();
 159     updateInnerTextElementEditability();
 160 }
 161 
 162 HTMLInputElement::~HTMLInputElement()
 163 {
 164     if (needsSuspensionCallback())
 165         document().unregisterForDocumentSuspensionCallbacks(*this);
 166 
 167     // Need to remove form association while this is still an HTMLInputElement
 168     // so that virtual functions are called correctly.
 169     setForm(nullptr);
 170 
 171     // This is needed for a radio button that was not in a form, and also for
 172     // a radio button that was in a form. The call to setForm(nullptr) above
 173     // actually adds the button to the document groups in the latter case.
 174     // That is inelegant, but harmless since we remove it here.
 175     if (isRadioButton())
<span class="line-modified"> 176         document().formController().radioButtonGroups().removeButton(*this);</span>
 177 
 178 #if ENABLE(TOUCH_EVENTS)
 179     if (m_hasTouchEventHandler)
 180         document().didRemoveEventTargetNode(*this);
 181 #endif
 182 }
 183 
 184 const AtomString&amp; HTMLInputElement::name() const
 185 {
 186     return m_name.isNull() ? emptyAtom() : m_name;
 187 }
 188 
 189 Vector&lt;FileChooserFileInfo&gt; HTMLInputElement::filesFromFileInputFormControlState(const FormControlState&amp; state)
 190 {
 191     return FileInputType::filesFromFormControlState(state);
 192 }
 193 
 194 HTMLElement* HTMLInputElement::containerElement() const
 195 {
 196     return m_inputType-&gt;containerElement();
</pre>
<hr />
<pre>
1533 }
1534 
1535 void HTMLInputElement::didChangeForm()
1536 {
1537     HTMLTextFormControlElement::didChangeForm();
1538     addToRadioButtonGroup();
1539 }
1540 
1541 Node::InsertedIntoAncestorResult HTMLInputElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1542 {
1543     HTMLTextFormControlElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
1544 #if ENABLE(DATALIST_ELEMENT)
1545     resetListAttributeTargetObserver();
1546 #endif
1547     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
1548 }
1549 
1550 void HTMLInputElement::didFinishInsertingNode()
1551 {
1552     HTMLTextFormControlElement::didFinishInsertingNode();
<span class="line-modified">1553     if (isConnected() &amp;&amp; !form())</span>
1554         addToRadioButtonGroup();
1555 }
1556 
1557 void HTMLInputElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
1558 {


1559     if (removalType.disconnectedFromDocument &amp;&amp; !form())
1560         removeFromRadioButtonGroup();
1561     HTMLTextFormControlElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
1562     ASSERT(!isConnected());
1563 #if ENABLE(DATALIST_ELEMENT)
1564     resetListAttributeTargetObserver();
1565 #endif
1566 }
1567 
1568 void HTMLInputElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
1569 {
1570     if (imageLoader())
1571         imageLoader()-&gt;elementDidMoveToNewDocument();
1572 
1573     // Always unregister for cache callbacks when leaving a document, even if we would otherwise like to be registered
1574     if (needsSuspensionCallback()) {
1575         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
1576         newDocument.registerForDocumentSuspensionCallbacks(*this);
1577     }
1578 
<span class="line-removed">1579     // We call this even for radio buttons in forms; it&#39;s harmless because the</span>
<span class="line-removed">1580     // removeButton function is written to be safe for buttons not in any group.</span>
<span class="line-removed">1581     if (isRadioButton())</span>
<span class="line-removed">1582         oldDocument.formController().radioButtonGroups().removeButton(*this);</span>
<span class="line-removed">1583 </span>
1584 #if ENABLE(TOUCH_EVENTS)
1585     if (m_hasTouchEventHandler) {
1586         oldDocument.didRemoveEventTargetNode(*this);
1587         newDocument.didAddTouchEventHandler(*this);
1588     }
1589 #endif
1590 
1591     HTMLTextFormControlElement::didMoveToNewDocument(oldDocument, newDocument);
1592 }
1593 
1594 void HTMLInputElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1595 {
1596     HTMLTextFormControlElement::addSubresourceAttributeURLs(urls);
1597 
1598     addSubresourceURL(urls, src());
1599 }
1600 
1601 bool HTMLInputElement::computeWillValidate() const
1602 {
1603     return m_inputType-&gt;supportsValidation() &amp;&amp; HTMLTextFormControlElement::computeWillValidate();
</pre>
<hr />
<pre>
1884 
1885     auto&amp; captureAttribute = attributeWithoutSynchronization(captureAttr);
1886     if (captureAttribute.isNull())
1887         return MediaCaptureTypeNone;
1888 
1889     if (equalLettersIgnoringASCIICase(captureAttribute, &quot;user&quot;))
1890         return MediaCaptureTypeUser;
1891 
1892     return MediaCaptureTypeEnvironment;
1893 }
1894 #endif
1895 
1896 bool HTMLInputElement::isInRequiredRadioButtonGroup()
1897 {
1898     ASSERT(isRadioButton());
1899     if (RadioButtonGroups* buttons = radioButtonGroups())
1900         return buttons-&gt;isInRequiredGroup(*this);
1901     return false;
1902 }
1903 
<span class="line-modified">1904 Vector&lt;HTMLInputElement*&gt; HTMLInputElement::radioButtonGroup() const</span>
1905 {
1906     RadioButtonGroups* buttons = radioButtonGroups();
1907     if (!buttons)
1908         return { };
1909     return buttons-&gt;groupMembers(*this);
1910 }
1911 
<span class="line-modified">1912 HTMLInputElement* HTMLInputElement::checkedRadioButtonForGroup() const</span>
1913 {
1914     if (RadioButtonGroups* buttons = radioButtonGroups())
1915         return buttons-&gt;checkedButtonForGroup(name());
1916     return nullptr;
1917 }
1918 
1919 RadioButtonGroups* HTMLInputElement::radioButtonGroups() const
1920 {
1921     if (!isRadioButton())
1922         return nullptr;
1923     if (auto* formElement = form())
1924         return &amp;formElement-&gt;radioButtonGroups();
<span class="line-modified">1925     if (isConnected())</span>
<span class="line-modified">1926         return &amp;document().formController().radioButtonGroups();</span>
1927     return nullptr;
1928 }
1929 
1930 inline void HTMLInputElement::addToRadioButtonGroup()
1931 {
1932     if (auto* buttons = radioButtonGroups())
1933         buttons-&gt;addButton(*this);
1934 }
1935 
1936 inline void HTMLInputElement::removeFromRadioButtonGroup()
1937 {
1938     if (auto* buttons = radioButtonGroups())
1939         buttons-&gt;removeButton(*this);
1940 }
1941 
1942 unsigned HTMLInputElement::height() const
1943 {
1944     return m_inputType-&gt;height();
1945 }
1946 
</pre>
<hr />
<pre>
2042     if (!canHaveSelection())
2043         return Exception { TypeError };
2044 
2045     setSelectionDirection(direction);
2046     return { };
2047 }
2048 
2049 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionRangeForBindings(int start, int end, const String&amp; direction)
2050 {
2051     if (!canHaveSelection())
2052         return Exception { TypeError };
2053 
2054     setSelectionRange(start, end, direction);
2055     return { };
2056 }
2057 
2058 static Ref&lt;CSSLinearGradientValue&gt; autoFillStrongPasswordMaskImage()
2059 {
2060     CSSGradientColorStop firstStop;
2061     firstStop.m_color = CSSValuePool::singleton().createColorValue(Color::black);
<span class="line-modified">2062     firstStop.m_position = CSSValuePool::singleton().createValue(50, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
2063 
2064     CSSGradientColorStop secondStop;
2065     secondStop.m_color = CSSValuePool::singleton().createColorValue(Color::transparent);
<span class="line-modified">2066     secondStop.m_position = CSSValuePool::singleton().createValue(100, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
2067 
2068     auto gradient = CSSLinearGradientValue::create(CSSGradientRepeat::NonRepeating, CSSGradientType::CSSLinearGradient);
<span class="line-modified">2069     gradient-&gt;setAngle(CSSValuePool::singleton().createValue(90, CSSPrimitiveValue::UnitType::CSS_DEG));</span>
2070     gradient-&gt;addStop(firstStop);
2071     gradient-&gt;addStop(secondStop);


2072     return gradient;
2073 }
2074 
2075 RenderStyle HTMLInputElement::createInnerTextStyle(const RenderStyle&amp; style)
2076 {
2077     auto textBlockStyle = RenderStyle::create();
2078     textBlockStyle.inheritFrom(style);
2079     adjustInnerTextStyle(style, textBlockStyle);
2080 
2081     textBlockStyle.setWhiteSpace(WhiteSpace::Pre);
2082     textBlockStyle.setOverflowWrap(OverflowWrap::Normal);
2083     textBlockStyle.setOverflowX(Overflow::Hidden);
2084     textBlockStyle.setOverflowY(Overflow::Hidden);
2085     textBlockStyle.setTextOverflow(shouldTruncateText(style) ? TextOverflow::Ellipsis : TextOverflow::Clip);
2086 
2087     textBlockStyle.setDisplay(DisplayType::Block);
2088 
2089     if (hasAutoFillStrongPasswordButton() &amp;&amp; !isDisabledOrReadOnly()) {
2090         textBlockStyle.setDisplay(DisplayType::InlineBlock);
2091         textBlockStyle.setMaxWidth(Length { 100, Percent });
2092         textBlockStyle.setColor({ 0.0f, 0.0f, 0.0f, 0.6f });
2093         textBlockStyle.setTextOverflow(TextOverflow::Clip);
<span class="line-modified">2094         textBlockStyle.setMaskImage(styleResolver().styleImage(autoFillStrongPasswordMaskImage()));</span>
2095         // A stacking context is needed for the mask.
<span class="line-modified">2096         if (textBlockStyle.hasAutoZIndex())</span>
<span class="line-modified">2097             textBlockStyle.setZIndex(0);</span>
2098     }
2099 
2100     // Do not allow line-height to be smaller than our default.
2101     if (textBlockStyle.fontMetrics().lineSpacing() &gt; style.computedLineHeight())
2102         textBlockStyle.setLineHeight(RenderStyle::initialLineHeight());
2103 
2104     return textBlockStyle;
2105 }
2106 
2107 #if ENABLE(DATE_AND_TIME_INPUT_TYPES)
2108 bool HTMLInputElement::setupDateTimeChooserParameters(DateTimeChooserParameters&amp; parameters)
2109 {
2110     if (!document().view())
2111         return false;
2112 
2113     parameters.type = type();
2114     parameters.minimum = minimum();
2115     parameters.maximum = maximum();
2116     parameters.required = isRequired();
2117 
</pre>
</td>
<td>
<hr />
<pre>
  45 #include &quot;FormController.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameSelection.h&quot;
  48 #include &quot;FrameView.h&quot;
  49 #include &quot;HTMLDataListElement.h&quot;
  50 #include &quot;HTMLFormElement.h&quot;
  51 #include &quot;HTMLImageLoader.h&quot;
  52 #include &quot;HTMLOptionElement.h&quot;
  53 #include &quot;HTMLParserIdioms.h&quot;
  54 #include &quot;IdTargetObserver.h&quot;
  55 #include &quot;KeyboardEvent.h&quot;
  56 #include &quot;LocalizedStrings.h&quot;
  57 #include &quot;MouseEvent.h&quot;
  58 #include &quot;Page.h&quot;
  59 #include &quot;PlatformMouseEvent.h&quot;
  60 #include &quot;RenderTextControlSingleLine.h&quot;
  61 #include &quot;RenderTheme.h&quot;
  62 #include &quot;ScopedEventQueue.h&quot;
  63 #include &quot;SearchInputType.h&quot;
  64 #include &quot;Settings.h&quot;
<span class="line-modified">  65 #include &quot;StyleGeneratedImage.h&quot;</span>
  66 #include &quot;TextControlInnerElements.h&quot;
  67 #include &lt;wtf/IsoMallocInlines.h&gt;
  68 #include &lt;wtf/Language.h&gt;
  69 #include &lt;wtf/MathExtras.h&gt;
  70 #include &lt;wtf/Ref.h&gt;
  71 
  72 #if ENABLE(TOUCH_EVENTS)
  73 #include &quot;TouchEvent.h&quot;
  74 #endif
  75 
  76 namespace WebCore {
  77 
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLInputElement);
  79 
  80 using namespace HTMLNames;
  81 
  82 #if ENABLE(DATALIST_ELEMENT)
  83 class ListAttributeTargetObserver : IdTargetObserver {
  84     WTF_MAKE_FAST_ALLOCATED;
  85 public:
</pre>
<hr />
<pre>
 156 {
 157     Ref&lt;InputType&gt; protectedInputType(*m_inputType);
 158     protectedInputType-&gt;createShadowSubtree();
 159     updateInnerTextElementEditability();
 160 }
 161 
 162 HTMLInputElement::~HTMLInputElement()
 163 {
 164     if (needsSuspensionCallback())
 165         document().unregisterForDocumentSuspensionCallbacks(*this);
 166 
 167     // Need to remove form association while this is still an HTMLInputElement
 168     // so that virtual functions are called correctly.
 169     setForm(nullptr);
 170 
 171     // This is needed for a radio button that was not in a form, and also for
 172     // a radio button that was in a form. The call to setForm(nullptr) above
 173     // actually adds the button to the document groups in the latter case.
 174     // That is inelegant, but harmless since we remove it here.
 175     if (isRadioButton())
<span class="line-modified"> 176         treeScope().radioButtonGroups().removeButton(*this);</span>
 177 
 178 #if ENABLE(TOUCH_EVENTS)
 179     if (m_hasTouchEventHandler)
 180         document().didRemoveEventTargetNode(*this);
 181 #endif
 182 }
 183 
 184 const AtomString&amp; HTMLInputElement::name() const
 185 {
 186     return m_name.isNull() ? emptyAtom() : m_name;
 187 }
 188 
 189 Vector&lt;FileChooserFileInfo&gt; HTMLInputElement::filesFromFileInputFormControlState(const FormControlState&amp; state)
 190 {
 191     return FileInputType::filesFromFormControlState(state);
 192 }
 193 
 194 HTMLElement* HTMLInputElement::containerElement() const
 195 {
 196     return m_inputType-&gt;containerElement();
</pre>
<hr />
<pre>
1533 }
1534 
1535 void HTMLInputElement::didChangeForm()
1536 {
1537     HTMLTextFormControlElement::didChangeForm();
1538     addToRadioButtonGroup();
1539 }
1540 
1541 Node::InsertedIntoAncestorResult HTMLInputElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
1542 {
1543     HTMLTextFormControlElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
1544 #if ENABLE(DATALIST_ELEMENT)
1545     resetListAttributeTargetObserver();
1546 #endif
1547     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
1548 }
1549 
1550 void HTMLInputElement::didFinishInsertingNode()
1551 {
1552     HTMLTextFormControlElement::didFinishInsertingNode();
<span class="line-modified">1553     if (isInTreeScope() &amp;&amp; !form())</span>
1554         addToRadioButtonGroup();
1555 }
1556 
1557 void HTMLInputElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
1558 {
<span class="line-added">1559     if (removalType.treeScopeChanged &amp;&amp; isRadioButton())</span>
<span class="line-added">1560         oldParentOfRemovedTree.treeScope().radioButtonGroups().removeButton(*this);</span>
1561     if (removalType.disconnectedFromDocument &amp;&amp; !form())
1562         removeFromRadioButtonGroup();
1563     HTMLTextFormControlElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
1564     ASSERT(!isConnected());
1565 #if ENABLE(DATALIST_ELEMENT)
1566     resetListAttributeTargetObserver();
1567 #endif
1568 }
1569 
1570 void HTMLInputElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
1571 {
1572     if (imageLoader())
1573         imageLoader()-&gt;elementDidMoveToNewDocument();
1574 
1575     // Always unregister for cache callbacks when leaving a document, even if we would otherwise like to be registered
1576     if (needsSuspensionCallback()) {
1577         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
1578         newDocument.registerForDocumentSuspensionCallbacks(*this);
1579     }
1580 





1581 #if ENABLE(TOUCH_EVENTS)
1582     if (m_hasTouchEventHandler) {
1583         oldDocument.didRemoveEventTargetNode(*this);
1584         newDocument.didAddTouchEventHandler(*this);
1585     }
1586 #endif
1587 
1588     HTMLTextFormControlElement::didMoveToNewDocument(oldDocument, newDocument);
1589 }
1590 
1591 void HTMLInputElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1592 {
1593     HTMLTextFormControlElement::addSubresourceAttributeURLs(urls);
1594 
1595     addSubresourceURL(urls, src());
1596 }
1597 
1598 bool HTMLInputElement::computeWillValidate() const
1599 {
1600     return m_inputType-&gt;supportsValidation() &amp;&amp; HTMLTextFormControlElement::computeWillValidate();
</pre>
<hr />
<pre>
1881 
1882     auto&amp; captureAttribute = attributeWithoutSynchronization(captureAttr);
1883     if (captureAttribute.isNull())
1884         return MediaCaptureTypeNone;
1885 
1886     if (equalLettersIgnoringASCIICase(captureAttribute, &quot;user&quot;))
1887         return MediaCaptureTypeUser;
1888 
1889     return MediaCaptureTypeEnvironment;
1890 }
1891 #endif
1892 
1893 bool HTMLInputElement::isInRequiredRadioButtonGroup()
1894 {
1895     ASSERT(isRadioButton());
1896     if (RadioButtonGroups* buttons = radioButtonGroups())
1897         return buttons-&gt;isInRequiredGroup(*this);
1898     return false;
1899 }
1900 
<span class="line-modified">1901 Vector&lt;Ref&lt;HTMLInputElement&gt;&gt; HTMLInputElement::radioButtonGroup() const</span>
1902 {
1903     RadioButtonGroups* buttons = radioButtonGroups();
1904     if (!buttons)
1905         return { };
1906     return buttons-&gt;groupMembers(*this);
1907 }
1908 
<span class="line-modified">1909 RefPtr&lt;HTMLInputElement&gt; HTMLInputElement::checkedRadioButtonForGroup() const</span>
1910 {
1911     if (RadioButtonGroups* buttons = radioButtonGroups())
1912         return buttons-&gt;checkedButtonForGroup(name());
1913     return nullptr;
1914 }
1915 
1916 RadioButtonGroups* HTMLInputElement::radioButtonGroups() const
1917 {
1918     if (!isRadioButton())
1919         return nullptr;
1920     if (auto* formElement = form())
1921         return &amp;formElement-&gt;radioButtonGroups();
<span class="line-modified">1922     if (isInTreeScope())</span>
<span class="line-modified">1923         return &amp;treeScope().radioButtonGroups();</span>
1924     return nullptr;
1925 }
1926 
1927 inline void HTMLInputElement::addToRadioButtonGroup()
1928 {
1929     if (auto* buttons = radioButtonGroups())
1930         buttons-&gt;addButton(*this);
1931 }
1932 
1933 inline void HTMLInputElement::removeFromRadioButtonGroup()
1934 {
1935     if (auto* buttons = radioButtonGroups())
1936         buttons-&gt;removeButton(*this);
1937 }
1938 
1939 unsigned HTMLInputElement::height() const
1940 {
1941     return m_inputType-&gt;height();
1942 }
1943 
</pre>
<hr />
<pre>
2039     if (!canHaveSelection())
2040         return Exception { TypeError };
2041 
2042     setSelectionDirection(direction);
2043     return { };
2044 }
2045 
2046 ExceptionOr&lt;void&gt; HTMLInputElement::setSelectionRangeForBindings(int start, int end, const String&amp; direction)
2047 {
2048     if (!canHaveSelection())
2049         return Exception { TypeError };
2050 
2051     setSelectionRange(start, end, direction);
2052     return { };
2053 }
2054 
2055 static Ref&lt;CSSLinearGradientValue&gt; autoFillStrongPasswordMaskImage()
2056 {
2057     CSSGradientColorStop firstStop;
2058     firstStop.m_color = CSSValuePool::singleton().createColorValue(Color::black);
<span class="line-modified">2059     firstStop.m_position = CSSValuePool::singleton().createValue(50, CSSUnitType::CSS_PERCENTAGE);</span>
2060 
2061     CSSGradientColorStop secondStop;
2062     secondStop.m_color = CSSValuePool::singleton().createColorValue(Color::transparent);
<span class="line-modified">2063     secondStop.m_position = CSSValuePool::singleton().createValue(100, CSSUnitType::CSS_PERCENTAGE);</span>
2064 
2065     auto gradient = CSSLinearGradientValue::create(CSSGradientRepeat::NonRepeating, CSSGradientType::CSSLinearGradient);
<span class="line-modified">2066     gradient-&gt;setAngle(CSSValuePool::singleton().createValue(90, CSSUnitType::CSS_DEG));</span>
2067     gradient-&gt;addStop(firstStop);
2068     gradient-&gt;addStop(secondStop);
<span class="line-added">2069     gradient-&gt;resolveRGBColors();</span>
<span class="line-added">2070 </span>
2071     return gradient;
2072 }
2073 
2074 RenderStyle HTMLInputElement::createInnerTextStyle(const RenderStyle&amp; style)
2075 {
2076     auto textBlockStyle = RenderStyle::create();
2077     textBlockStyle.inheritFrom(style);
2078     adjustInnerTextStyle(style, textBlockStyle);
2079 
2080     textBlockStyle.setWhiteSpace(WhiteSpace::Pre);
2081     textBlockStyle.setOverflowWrap(OverflowWrap::Normal);
2082     textBlockStyle.setOverflowX(Overflow::Hidden);
2083     textBlockStyle.setOverflowY(Overflow::Hidden);
2084     textBlockStyle.setTextOverflow(shouldTruncateText(style) ? TextOverflow::Ellipsis : TextOverflow::Clip);
2085 
2086     textBlockStyle.setDisplay(DisplayType::Block);
2087 
2088     if (hasAutoFillStrongPasswordButton() &amp;&amp; !isDisabledOrReadOnly()) {
2089         textBlockStyle.setDisplay(DisplayType::InlineBlock);
2090         textBlockStyle.setMaxWidth(Length { 100, Percent });
2091         textBlockStyle.setColor({ 0.0f, 0.0f, 0.0f, 0.6f });
2092         textBlockStyle.setTextOverflow(TextOverflow::Clip);
<span class="line-modified">2093         textBlockStyle.setMaskImage(StyleGeneratedImage::create(autoFillStrongPasswordMaskImage()));</span>
2094         // A stacking context is needed for the mask.
<span class="line-modified">2095         if (textBlockStyle.hasAutoUsedZIndex())</span>
<span class="line-modified">2096             textBlockStyle.setUsedZIndex(0);</span>
2097     }
2098 
2099     // Do not allow line-height to be smaller than our default.
2100     if (textBlockStyle.fontMetrics().lineSpacing() &gt; style.computedLineHeight())
2101         textBlockStyle.setLineHeight(RenderStyle::initialLineHeight());
2102 
2103     return textBlockStyle;
2104 }
2105 
2106 #if ENABLE(DATE_AND_TIME_INPUT_TYPES)
2107 bool HTMLInputElement::setupDateTimeChooserParameters(DateTimeChooserParameters&amp; parameters)
2108 {
2109     if (!document().view())
2110         return false;
2111 
2112     parameters.type = type();
2113     parameters.minimum = minimum();
2114     parameters.maximum = maximum();
2115     parameters.required = isRequired();
2116 
</pre>
</td>
</tr>
</table>
<center><a href="HTMLImageElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLInputElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
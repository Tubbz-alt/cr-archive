<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/mock/mediasource/MockMediaPlayerMediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MockBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MockMediaSourcePrivate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/mock/mediasource/MockMediaPlayerMediaSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MockMediaPlayerMediaSource.h&quot;
 28 
 29 #if ENABLE(MEDIA_SOURCE)
 30 
 31 #include &quot;MediaPlayer.h&quot;
 32 #include &quot;MediaSourcePrivateClient.h&quot;
 33 #include &quot;MockMediaSourcePrivate.h&quot;
 34 #include &lt;wtf/MainThread.h&gt;
 35 #include &lt;wtf/NeverDestroyed.h&gt;
 36 #include &lt;wtf/text/WTFString.h&gt;
 37 
 38 namespace WebCore {
 39 

















 40 // MediaPlayer Enigne Support
 41 void MockMediaPlayerMediaSource::registerMediaEngine(MediaEngineRegistrar registrar)
 42 {
<span class="line-modified"> 43     registrar([] (MediaPlayer* player) { return makeUnique&lt;MockMediaPlayerMediaSource&gt;(player); }, getSupportedTypes,</span>
<span class="line-removed"> 44         supportsType, 0, 0, 0, 0);</span>
 45 }
 46 
 47 // FIXME: What does the word &quot;cache&quot; mean here?
 48 static const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; mimeTypeCache()
 49 {
 50     static const auto cache = makeNeverDestroyed(HashSet&lt;String, ASCIICaseInsensitiveHash&gt; {
 51         &quot;video/mock&quot;,
 52         &quot;audio/mock&quot;,
 53     });
 54     return cache;
 55 }
 56 
 57 void MockMediaPlayerMediaSource::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedTypes)
 58 {
 59     supportedTypes = mimeTypeCache();
 60 }
 61 
 62 MediaPlayer::SupportsType MockMediaPlayerMediaSource::supportsType(const MediaEngineSupportParameters&amp; parameters)
 63 {
 64     if (!parameters.isMediaSource)
<span class="line-modified"> 65         return MediaPlayer::IsNotSupported;</span>
 66 
 67     auto containerType = parameters.type.containerType();
 68     if (containerType.isEmpty() || !mimeTypeCache().contains(containerType))
<span class="line-modified"> 69         return MediaPlayer::IsNotSupported;</span>
 70 
 71     auto codecs = parameters.type.parameter(ContentType::codecsParameter());
 72     if (codecs.isEmpty())
<span class="line-modified"> 73         return MediaPlayer::MayBeSupported;</span>
 74 
 75     if (codecs == &quot;mock&quot; || codecs == &quot;kcom&quot;)
<span class="line-modified"> 76         return MediaPlayer::IsSupported;</span>
 77 
<span class="line-modified"> 78     return MediaPlayer::MayBeSupported;</span>
 79 }
 80 
 81 MockMediaPlayerMediaSource::MockMediaPlayerMediaSource(MediaPlayer* player)
 82     : m_player(player)
 83     , m_currentTime(MediaTime::zeroTime())
<span class="line-modified"> 84     , m_readyState(MediaPlayer::HaveNothing)</span>
<span class="line-modified"> 85     , m_networkState(MediaPlayer::Empty)</span>
 86     , m_playing(false)
 87     , m_seekCompleted(true)
 88 {
 89 }
 90 
 91 MockMediaPlayerMediaSource::~MockMediaPlayerMediaSource() = default;
 92 
 93 void MockMediaPlayerMediaSource::load(const String&amp;)
 94 {
 95     ASSERT_NOT_REACHED();
 96 }
 97 
 98 void MockMediaPlayerMediaSource::load(const String&amp;, MediaSourcePrivateClient* source)
 99 {
100     m_mediaSourcePrivate = MockMediaSourcePrivate::create(*this, *source);
101 }
102 
103 void MockMediaPlayerMediaSource::cancelLoad()
104 {
105 }
</pre>
</td>
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MockMediaPlayerMediaSource.h&quot;
 28 
 29 #if ENABLE(MEDIA_SOURCE)
 30 
 31 #include &quot;MediaPlayer.h&quot;
 32 #include &quot;MediaSourcePrivateClient.h&quot;
 33 #include &quot;MockMediaSourcePrivate.h&quot;
 34 #include &lt;wtf/MainThread.h&gt;
 35 #include &lt;wtf/NeverDestroyed.h&gt;
 36 #include &lt;wtf/text/WTFString.h&gt;
 37 
 38 namespace WebCore {
 39 
<span class="line-added"> 40 class MediaPlayerFactoryMediaSourceMock final : public MediaPlayerFactory {</span>
<span class="line-added"> 41 private:</span>
<span class="line-added"> 42     MediaPlayerEnums::MediaEngineIdentifier identifier() const final { return MediaPlayerEnums::MediaEngineIdentifier::MockMSE; };</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44     std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; createMediaEnginePlayer(MediaPlayer* player) const final { return makeUnique&lt;MockMediaPlayerMediaSource&gt;(player); }</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46     void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types) const final</span>
<span class="line-added"> 47     {</span>
<span class="line-added"> 48         return MockMediaPlayerMediaSource::getSupportedTypes(types);</span>
<span class="line-added"> 49     }</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51     MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters&amp; parameters) const final</span>
<span class="line-added"> 52     {</span>
<span class="line-added"> 53         return MockMediaPlayerMediaSource::supportsType(parameters);</span>
<span class="line-added"> 54     }</span>
<span class="line-added"> 55 };</span>
<span class="line-added"> 56 </span>
 57 // MediaPlayer Enigne Support
 58 void MockMediaPlayerMediaSource::registerMediaEngine(MediaEngineRegistrar registrar)
 59 {
<span class="line-modified"> 60     registrar(makeUnique&lt;MediaPlayerFactoryMediaSourceMock&gt;());</span>

 61 }
 62 
 63 // FIXME: What does the word &quot;cache&quot; mean here?
 64 static const HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; mimeTypeCache()
 65 {
 66     static const auto cache = makeNeverDestroyed(HashSet&lt;String, ASCIICaseInsensitiveHash&gt; {
 67         &quot;video/mock&quot;,
 68         &quot;audio/mock&quot;,
 69     });
 70     return cache;
 71 }
 72 
 73 void MockMediaPlayerMediaSource::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedTypes)
 74 {
 75     supportedTypes = mimeTypeCache();
 76 }
 77 
 78 MediaPlayer::SupportsType MockMediaPlayerMediaSource::supportsType(const MediaEngineSupportParameters&amp; parameters)
 79 {
 80     if (!parameters.isMediaSource)
<span class="line-modified"> 81         return MediaPlayer::SupportsType::IsNotSupported;</span>
 82 
 83     auto containerType = parameters.type.containerType();
 84     if (containerType.isEmpty() || !mimeTypeCache().contains(containerType))
<span class="line-modified"> 85         return MediaPlayer::SupportsType::IsNotSupported;</span>
 86 
 87     auto codecs = parameters.type.parameter(ContentType::codecsParameter());
 88     if (codecs.isEmpty())
<span class="line-modified"> 89         return MediaPlayer::SupportsType::MayBeSupported;</span>
 90 
 91     if (codecs == &quot;mock&quot; || codecs == &quot;kcom&quot;)
<span class="line-modified"> 92         return MediaPlayer::SupportsType::IsSupported;</span>
 93 
<span class="line-modified"> 94     return MediaPlayer::SupportsType::MayBeSupported;</span>
 95 }
 96 
 97 MockMediaPlayerMediaSource::MockMediaPlayerMediaSource(MediaPlayer* player)
 98     : m_player(player)
 99     , m_currentTime(MediaTime::zeroTime())
<span class="line-modified">100     , m_readyState(MediaPlayer::ReadyState::HaveNothing)</span>
<span class="line-modified">101     , m_networkState(MediaPlayer::NetworkState::Empty)</span>
102     , m_playing(false)
103     , m_seekCompleted(true)
104 {
105 }
106 
107 MockMediaPlayerMediaSource::~MockMediaPlayerMediaSource() = default;
108 
109 void MockMediaPlayerMediaSource::load(const String&amp;)
110 {
111     ASSERT_NOT_REACHED();
112 }
113 
114 void MockMediaPlayerMediaSource::load(const String&amp;, MediaSourcePrivateClient* source)
115 {
116     m_mediaSourcePrivate = MockMediaSourcePrivate::create(*this, *source);
117 }
118 
119 void MockMediaPlayerMediaSource::cancelLoad()
120 {
121 }
</pre>
</td>
</tr>
</table>
<center><a href="MockBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="MockMediaSourcePrivate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
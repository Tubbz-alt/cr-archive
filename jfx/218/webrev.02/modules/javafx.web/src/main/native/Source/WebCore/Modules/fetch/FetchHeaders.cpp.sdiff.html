<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchHeaders.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FetchBodySource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchHeaders.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchHeaders.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchHeaders.h&quot;
 31 
 32 #include &quot;HTTPParsers.h&quot;
 33 
 34 namespace WebCore {
 35 






 36 static ExceptionOr&lt;bool&gt; canWriteHeader(const String&amp; name, const String&amp; value, const String&amp; combinedValue, FetchHeaders::Guard guard)
 37 {
 38     if (!isValidHTTPToken(name))
 39         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
 40     if (!isValidHTTPHeaderValue(value))
 41         return Exception { TypeError, makeString(&quot;Header &#39;&quot;, name, &quot;&#39; has invalid value: &#39;&quot;, value, &quot;&#39;&quot;) };
 42     if (guard == FetchHeaders::Guard::Immutable)
 43         return Exception { TypeError, &quot;Headers object&#39;s guard is &#39;immutable&#39;&quot;_s };
 44     if (guard == FetchHeaders::Guard::Request &amp;&amp; isForbiddenHeaderName(name))
 45         return false;
 46     if (guard == FetchHeaders::Guard::RequestNoCors &amp;&amp; !combinedValue.isEmpty() &amp;&amp; !isSimpleHeader(name, combinedValue))
 47         return false;
 48     if (guard == FetchHeaders::Guard::Response &amp;&amp; isForbiddenResponseHeaderName(name))
 49         return false;
 50     return true;
 51 }
 52 
 53 static ExceptionOr&lt;void&gt; appendToHeaderMap(const String&amp; name, const String&amp; value, HTTPHeaderMap&amp; headers, FetchHeaders::Guard guard)
 54 {
 55     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
 56     String combinedValue = normalizedValue;
 57     if (headers.contains(name))
 58         combinedValue = makeString(headers.get(name), &quot;, &quot;, normalizedValue);
 59     auto canWriteResult = canWriteHeader(name, normalizedValue, combinedValue, guard);
 60     if (canWriteResult.hasException())
 61         return canWriteResult.releaseException();
 62     if (!canWriteResult.releaseReturnValue())
 63         return { };
 64     headers.set(name, combinedValue);




 65     return { };
 66 }
 67 
 68 static ExceptionOr&lt;void&gt; appendToHeaderMap(const HTTPHeaderMap::HTTPHeaderMapConstIterator::KeyValue&amp; header, HTTPHeaderMap&amp; headers, FetchHeaders::Guard guard)
 69 {
 70     auto canWriteResult = canWriteHeader(header.key, header.value, header.value, guard);
 71     if (canWriteResult.hasException())
 72         return canWriteResult.releaseException();
 73     if (!canWriteResult.releaseReturnValue())
 74         return { };
 75     if (header.keyAsHTTPHeaderName)
 76         headers.add(header.keyAsHTTPHeaderName.value(), header.value);
 77     else
 78         headers.add(header.key, header.value);




 79     return { };
 80 }
 81 
 82 // https://fetch.spec.whatwg.org/#concept-headers-fill
 83 static ExceptionOr&lt;void&gt; fillHeaderMap(HTTPHeaderMap&amp; headers, const FetchHeaders::Init&amp; headersInit, FetchHeaders::Guard guard)
 84 {
 85     if (WTF::holds_alternative&lt;Vector&lt;Vector&lt;String&gt;&gt;&gt;(headersInit)) {
 86         auto&amp; sequence = WTF::get&lt;Vector&lt;Vector&lt;String&gt;&gt;&gt;(headersInit);
 87         for (auto&amp; header : sequence) {
 88             if (header.size() != 2)
 89                 return Exception { TypeError, &quot;Header sub-sequence must contain exactly two items&quot; };
 90             auto result = appendToHeaderMap(header[0], header[1], headers, guard);
 91             if (result.hasException())
 92                 return result.releaseException();
 93         }
 94     } else {
 95         auto&amp; record = WTF::get&lt;Vector&lt;WTF::KeyValuePair&lt;String, String&gt;&gt;&gt;(headersInit);
 96         for (auto&amp; header : record) {
 97             auto result = appendToHeaderMap(header.key, header.value, headers, guard);
 98             if (result.hasException())
</pre>
<hr />
<pre>
120 {
121     return fillHeaderMap(m_headers, headerInit, m_guard);
122 }
123 
124 ExceptionOr&lt;void&gt; FetchHeaders::fill(const FetchHeaders&amp; otherHeaders)
125 {
126     for (auto&amp; header : otherHeaders.m_headers) {
127         auto result = appendToHeaderMap(header, m_headers, m_guard);
128         if (result.hasException())
129             return result.releaseException();
130     }
131 
132     return { };
133 }
134 
135 ExceptionOr&lt;void&gt; FetchHeaders::append(const String&amp; name, const String&amp; value)
136 {
137     return appendToHeaderMap(name, value, m_headers, m_guard);
138 }
139 

140 ExceptionOr&lt;void&gt; FetchHeaders::remove(const String&amp; name)
141 {
<span class="line-modified">142     auto canWriteResult = canWriteHeader(name, { }, { }, m_guard);</span>
<span class="line-modified">143     if (canWriteResult.hasException())</span>
<span class="line-modified">144         return canWriteResult.releaseException();</span>
<span class="line-modified">145     if (!canWriteResult.releaseReturnValue())</span>



146         return { };



147     m_headers.remove(name);




148     return { };
149 }
150 
151 ExceptionOr&lt;String&gt; FetchHeaders::get(const String&amp; name) const
152 {
153     if (!isValidHTTPToken(name))
154         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
155     return m_headers.get(name);
156 }
157 
158 ExceptionOr&lt;bool&gt; FetchHeaders::has(const String&amp; name) const
159 {
160     if (!isValidHTTPToken(name))
161         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
162     return m_headers.contains(name);
163 }
164 
165 ExceptionOr&lt;void&gt; FetchHeaders::set(const String&amp; name, const String&amp; value)
166 {
167     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
168     auto canWriteResult = canWriteHeader(name, normalizedValue, normalizedValue, m_guard);
169     if (canWriteResult.hasException())
170         return canWriteResult.releaseException();
171     if (!canWriteResult.releaseReturnValue())
172         return { };

173     m_headers.set(name, normalizedValue);




174     return { };
175 }
176 
177 void FetchHeaders::filterAndFill(const HTTPHeaderMap&amp; headers, Guard guard)
178 {
179     for (auto&amp; header : headers) {
180         auto canWriteResult = canWriteHeader(header.key, header.value, header.value, guard);
181         if (canWriteResult.hasException())
182             continue;
183         if (!canWriteResult.releaseReturnValue())
184             continue;
185         if (header.keyAsHTTPHeaderName)
186             m_headers.add(header.keyAsHTTPHeaderName.value(), header.value);
187         else
188             m_headers.add(header.key, header.value);
189     }
190 }
191 
192 Optional&lt;WTF::KeyValuePair&lt;String, String&gt;&gt; FetchHeaders::Iterator::next()
193 {
</pre>
</td>
<td>
<hr />
<pre>
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY CANON INC. AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchHeaders.h&quot;
 31 
 32 #include &quot;HTTPParsers.h&quot;
 33 
 34 namespace WebCore {
 35 
<span class="line-added"> 36 // https://fetch.spec.whatwg.org/#concept-headers-remove-privileged-no-cors-request-headers</span>
<span class="line-added"> 37 static void removePrivilegedNoCORSRequestHeaders(HTTPHeaderMap&amp; headers)</span>
<span class="line-added"> 38 {</span>
<span class="line-added"> 39     headers.remove(HTTPHeaderName::Range);</span>
<span class="line-added"> 40 }</span>
<span class="line-added"> 41 </span>
 42 static ExceptionOr&lt;bool&gt; canWriteHeader(const String&amp; name, const String&amp; value, const String&amp; combinedValue, FetchHeaders::Guard guard)
 43 {
 44     if (!isValidHTTPToken(name))
 45         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
 46     if (!isValidHTTPHeaderValue(value))
 47         return Exception { TypeError, makeString(&quot;Header &#39;&quot;, name, &quot;&#39; has invalid value: &#39;&quot;, value, &quot;&#39;&quot;) };
 48     if (guard == FetchHeaders::Guard::Immutable)
 49         return Exception { TypeError, &quot;Headers object&#39;s guard is &#39;immutable&#39;&quot;_s };
 50     if (guard == FetchHeaders::Guard::Request &amp;&amp; isForbiddenHeaderName(name))
 51         return false;
 52     if (guard == FetchHeaders::Guard::RequestNoCors &amp;&amp; !combinedValue.isEmpty() &amp;&amp; !isSimpleHeader(name, combinedValue))
 53         return false;
 54     if (guard == FetchHeaders::Guard::Response &amp;&amp; isForbiddenResponseHeaderName(name))
 55         return false;
 56     return true;
 57 }
 58 
 59 static ExceptionOr&lt;void&gt; appendToHeaderMap(const String&amp; name, const String&amp; value, HTTPHeaderMap&amp; headers, FetchHeaders::Guard guard)
 60 {
 61     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
 62     String combinedValue = normalizedValue;
 63     if (headers.contains(name))
 64         combinedValue = makeString(headers.get(name), &quot;, &quot;, normalizedValue);
 65     auto canWriteResult = canWriteHeader(name, normalizedValue, combinedValue, guard);
 66     if (canWriteResult.hasException())
 67         return canWriteResult.releaseException();
 68     if (!canWriteResult.releaseReturnValue())
 69         return { };
 70     headers.set(name, combinedValue);
<span class="line-added"> 71 </span>
<span class="line-added"> 72     if (guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added"> 73         removePrivilegedNoCORSRequestHeaders(headers);</span>
<span class="line-added"> 74 </span>
 75     return { };
 76 }
 77 
 78 static ExceptionOr&lt;void&gt; appendToHeaderMap(const HTTPHeaderMap::HTTPHeaderMapConstIterator::KeyValue&amp; header, HTTPHeaderMap&amp; headers, FetchHeaders::Guard guard)
 79 {
 80     auto canWriteResult = canWriteHeader(header.key, header.value, header.value, guard);
 81     if (canWriteResult.hasException())
 82         return canWriteResult.releaseException();
 83     if (!canWriteResult.releaseReturnValue())
 84         return { };
 85     if (header.keyAsHTTPHeaderName)
 86         headers.add(header.keyAsHTTPHeaderName.value(), header.value);
 87     else
 88         headers.add(header.key, header.value);
<span class="line-added"> 89 </span>
<span class="line-added"> 90     if (guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added"> 91         removePrivilegedNoCORSRequestHeaders(headers);</span>
<span class="line-added"> 92 </span>
 93     return { };
 94 }
 95 
 96 // https://fetch.spec.whatwg.org/#concept-headers-fill
 97 static ExceptionOr&lt;void&gt; fillHeaderMap(HTTPHeaderMap&amp; headers, const FetchHeaders::Init&amp; headersInit, FetchHeaders::Guard guard)
 98 {
 99     if (WTF::holds_alternative&lt;Vector&lt;Vector&lt;String&gt;&gt;&gt;(headersInit)) {
100         auto&amp; sequence = WTF::get&lt;Vector&lt;Vector&lt;String&gt;&gt;&gt;(headersInit);
101         for (auto&amp; header : sequence) {
102             if (header.size() != 2)
103                 return Exception { TypeError, &quot;Header sub-sequence must contain exactly two items&quot; };
104             auto result = appendToHeaderMap(header[0], header[1], headers, guard);
105             if (result.hasException())
106                 return result.releaseException();
107         }
108     } else {
109         auto&amp; record = WTF::get&lt;Vector&lt;WTF::KeyValuePair&lt;String, String&gt;&gt;&gt;(headersInit);
110         for (auto&amp; header : record) {
111             auto result = appendToHeaderMap(header.key, header.value, headers, guard);
112             if (result.hasException())
</pre>
<hr />
<pre>
134 {
135     return fillHeaderMap(m_headers, headerInit, m_guard);
136 }
137 
138 ExceptionOr&lt;void&gt; FetchHeaders::fill(const FetchHeaders&amp; otherHeaders)
139 {
140     for (auto&amp; header : otherHeaders.m_headers) {
141         auto result = appendToHeaderMap(header, m_headers, m_guard);
142         if (result.hasException())
143             return result.releaseException();
144     }
145 
146     return { };
147 }
148 
149 ExceptionOr&lt;void&gt; FetchHeaders::append(const String&amp; name, const String&amp; value)
150 {
151     return appendToHeaderMap(name, value, m_headers, m_guard);
152 }
153 
<span class="line-added">154 // https://fetch.spec.whatwg.org/#dom-headers-delete</span>
155 ExceptionOr&lt;void&gt; FetchHeaders::remove(const String&amp; name)
156 {
<span class="line-modified">157     if (!isValidHTTPToken(name))</span>
<span class="line-modified">158         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };</span>
<span class="line-modified">159     if (m_guard == FetchHeaders::Guard::Immutable)</span>
<span class="line-modified">160         return Exception { TypeError, &quot;Headers object&#39;s guard is &#39;immutable&#39;&quot;_s };</span>
<span class="line-added">161     if (m_guard == FetchHeaders::Guard::Request &amp;&amp; isForbiddenHeaderName(name))</span>
<span class="line-added">162         return { };</span>
<span class="line-added">163     if (m_guard == FetchHeaders::Guard::RequestNoCors &amp;&amp; !isNoCORSSafelistedRequestHeaderName(name) &amp;&amp; !isPriviledgedNoCORSRequestHeaderName(name))</span>
164         return { };
<span class="line-added">165     if (m_guard == FetchHeaders::Guard::Response &amp;&amp; isForbiddenResponseHeaderName(name))</span>
<span class="line-added">166         return { };</span>
<span class="line-added">167 </span>
168     m_headers.remove(name);
<span class="line-added">169 </span>
<span class="line-added">170     if (m_guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added">171         removePrivilegedNoCORSRequestHeaders(m_headers);</span>
<span class="line-added">172 </span>
173     return { };
174 }
175 
176 ExceptionOr&lt;String&gt; FetchHeaders::get(const String&amp; name) const
177 {
178     if (!isValidHTTPToken(name))
179         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
180     return m_headers.get(name);
181 }
182 
183 ExceptionOr&lt;bool&gt; FetchHeaders::has(const String&amp; name) const
184 {
185     if (!isValidHTTPToken(name))
186         return Exception { TypeError, makeString(&quot;Invalid header name: &#39;&quot;, name, &quot;&#39;&quot;) };
187     return m_headers.contains(name);
188 }
189 
190 ExceptionOr&lt;void&gt; FetchHeaders::set(const String&amp; name, const String&amp; value)
191 {
192     String normalizedValue = stripLeadingAndTrailingHTTPSpaces(value);
193     auto canWriteResult = canWriteHeader(name, normalizedValue, normalizedValue, m_guard);
194     if (canWriteResult.hasException())
195         return canWriteResult.releaseException();
196     if (!canWriteResult.releaseReturnValue())
197         return { };
<span class="line-added">198 </span>
199     m_headers.set(name, normalizedValue);
<span class="line-added">200 </span>
<span class="line-added">201     if (m_guard == FetchHeaders::Guard::RequestNoCors)</span>
<span class="line-added">202         removePrivilegedNoCORSRequestHeaders(m_headers);</span>
<span class="line-added">203 </span>
204     return { };
205 }
206 
207 void FetchHeaders::filterAndFill(const HTTPHeaderMap&amp; headers, Guard guard)
208 {
209     for (auto&amp; header : headers) {
210         auto canWriteResult = canWriteHeader(header.key, header.value, header.value, guard);
211         if (canWriteResult.hasException())
212             continue;
213         if (!canWriteResult.releaseReturnValue())
214             continue;
215         if (header.keyAsHTTPHeaderName)
216             m_headers.add(header.keyAsHTTPHeaderName.value(), header.value);
217         else
218             m_headers.add(header.key, header.value);
219     }
220 }
221 
222 Optional&lt;WTF::KeyValuePair&lt;String, String&gt;&gt; FetchHeaders::Iterator::next()
223 {
</pre>
</td>
</tr>
</table>
<center><a href="FetchBodySource.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchHeaders.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
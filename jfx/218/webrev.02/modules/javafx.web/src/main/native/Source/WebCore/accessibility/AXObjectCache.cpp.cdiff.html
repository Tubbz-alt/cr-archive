<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../WebCorePrefix.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AXObjectCache.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,12 ***</span>
  
  #if ENABLE(ACCESSIBILITY)
  
  #include &quot;AXObjectCache.h&quot;
  
  #include &quot;AXIsolatedTree.h&quot;
<span class="line-removed">- #include &quot;AXIsolatedTreeNode.h&quot;</span>
  #include &quot;AccessibilityARIAGrid.h&quot;
  #include &quot;AccessibilityARIAGridCell.h&quot;
  #include &quot;AccessibilityARIAGridRow.h&quot;
  #include &quot;AccessibilityAttachment.h&quot;
  #include &quot;AccessibilityImageMapLink.h&quot;
<span class="line-new-header">--- 30,12 ---</span>
  
  #if ENABLE(ACCESSIBILITY)
  
  #include &quot;AXObjectCache.h&quot;
  
<span class="line-added">+ #include &quot;AXIsolatedObject.h&quot;</span>
  #include &quot;AXIsolatedTree.h&quot;
  #include &quot;AccessibilityARIAGrid.h&quot;
  #include &quot;AccessibilityARIAGridCell.h&quot;
  #include &quot;AccessibilityARIAGridRow.h&quot;
  #include &quot;AccessibilityAttachment.h&quot;
  #include &quot;AccessibilityImageMapLink.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,16 ***</span>
<span class="line-new-header">--- 93,22 ---</span>
  #include &quot;RenderSlider.h&quot;
  #include &quot;RenderTable.h&quot;
  #include &quot;RenderTableCell.h&quot;
  #include &quot;RenderTableRow.h&quot;
  #include &quot;RenderView.h&quot;
<span class="line-added">+ #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;SVGElement.h&quot;
  #include &quot;ScriptDisallowedScope.h&quot;
  #include &quot;ScrollView.h&quot;
  #include &quot;TextBoundaries.h&quot;
  #include &quot;TextControlInnerElements.h&quot;
  #include &quot;TextIterator.h&quot;
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE) &amp;&amp; PLATFORM(MAC)</span>
<span class="line-added">+ #include &lt;pal/spi/mac/HIServicesSPI.h&gt;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/SetForScope.h&gt;
  
  #if ENABLE(VIDEO)
  #include &quot;MediaControlElements.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,10 ***</span>
<span class="line-new-header">--- 213,11 ---</span>
  #endif
  }
  
  AXObjectCache::AXObjectCache(Document&amp; document)
      : m_document(document)
<span class="line-added">+     , m_pageID(document.pageID())</span>
      , m_notificationPostTimer(*this, &amp;AXObjectCache::notificationPostTimerFired)
      , m_passwordNotificationPostTimer(*this, &amp;AXObjectCache::passwordNotificationPostTimerFired)
      , m_liveRegionChangedPostTimer(*this, &amp;AXObjectCache::liveRegionChangedNotificationPostTimerFired)
      , m_focusModalNodeTimer(*this, &amp;AXObjectCache::focusModalNodeTimerFired)
      , m_currentModalNode(nullptr)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,15 ***</span>
      m_notificationPostTimer.stop();
      m_liveRegionChangedPostTimer.stop();
      m_focusModalNodeTimer.stop();
      m_performCacheUpdateTimer.stop();
  
<span class="line-modified">!     for (const auto&amp; object : m_objects.values()) {</span>
<span class="line-modified">!         detachWrapper(object.get(), AccessibilityDetachmentType::CacheDestroyed);</span>
          object-&gt;detach(AccessibilityDetachmentType::CacheDestroyed);
<span class="line-removed">-         object-&gt;setAXObjectID(0);</span>
<span class="line-removed">-     }</span>
  }
  
  void AXObjectCache::findModalNodes()
  {
      // Traverse the DOM tree to look for the aria-modal=true nodes.
<span class="line-new-header">--- 231,18 ---</span>
      m_notificationPostTimer.stop();
      m_liveRegionChangedPostTimer.stop();
      m_focusModalNodeTimer.stop();
      m_performCacheUpdateTimer.stop();
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-modified">!     // Destroy the IsolatedTree before destroying the live tree.</span>
<span class="line-added">+     if (m_pageID)</span>
<span class="line-added">+         AXIsolatedTree::removeTreeForPageID(*m_pageID);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (const auto&amp; object : m_objects.values())</span>
          object-&gt;detach(AccessibilityDetachmentType::CacheDestroyed);
  }
  
  void AXObjectCache::findModalNodes()
  {
      // Traverse the DOM tree to look for the aria-modal=true nodes.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,41 ***</span>
      for (const auto&amp; child : axRenderImage-&gt;children()) {
          if (!is&lt;AccessibilityImageMapLink&gt;(*child))
              continue;
  
          if (downcast&lt;AccessibilityImageMapLink&gt;(*child).areaElement() == areaElement)
<span class="line-modified">!             return child.get();</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! AccessibilityObject* AXObjectCache::focusedUIElementForPage(const Page* page)</span>
  {
<span class="line-modified">!     if (!gAccessibilityEnabled)</span>
<span class="line-removed">-         return nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // get the focused node in the page</span>
<span class="line-removed">-     Document* focusedDocument = page-&gt;focusController().focusedOrMainFrame().document();</span>
<span class="line-removed">-     Element* focusedElement = focusedDocument-&gt;focusedElement();</span>
      if (is&lt;HTMLAreaElement&gt;(focusedElement))
          return focusedImageMapUIElement(downcast&lt;HTMLAreaElement&gt;(focusedElement));
  
<span class="line-modified">!     AccessibilityObject* obj = focusedDocument-&gt;axObjectCache()-&gt;getOrCreate(focusedElement ? static_cast&lt;Node*&gt;(focusedElement) : focusedDocument);</span>
<span class="line-modified">!     if (!obj)</span>
          return nullptr;
  
<span class="line-modified">!     if (obj-&gt;shouldFocusActiveDescendant()) {</span>
<span class="line-modified">!         if (AccessibilityObject* descendant = obj-&gt;activeDescendant())</span>
<span class="line-modified">!             obj = descendant;</span>
      }
  
      // the HTML element, for example, is focusable but has an AX object that is ignored
<span class="line-modified">!     if (obj-&gt;accessibilityIsIgnored())</span>
<span class="line-modified">!         obj = obj-&gt;parentObjectUnignored();</span>
  
<span class="line-modified">!     return obj;</span>
  }
  
  AccessibilityObject* AXObjectCache::get(Widget* widget)
  {
      if (!widget)
<span class="line-new-header">--- 346,95 ---</span>
      for (const auto&amp; child : axRenderImage-&gt;children()) {
          if (!is&lt;AccessibilityImageMapLink&gt;(*child))
              continue;
  
          if (downcast&lt;AccessibilityImageMapLink&gt;(*child).areaElement() == areaElement)
<span class="line-modified">!             return downcast&lt;AccessibilityImageMapLink&gt;(child.get());</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! AXCoreObject* AXObjectCache::focusedObject(Document&amp; document)</span>
  {
<span class="line-modified">!     Element* focusedElement = document.focusedElement();</span>
      if (is&lt;HTMLAreaElement&gt;(focusedElement))
          return focusedImageMapUIElement(downcast&lt;HTMLAreaElement&gt;(focusedElement));
  
<span class="line-modified">!     auto* axObjectCache = document.axObjectCache();</span>
<span class="line-modified">!     if (!axObjectCache)</span>
          return nullptr;
  
<span class="line-modified">!     AXCoreObject* focus = axObjectCache-&gt;getOrCreate(focusedElement ? focusedElement : static_cast&lt;Node*&gt;(&amp;document));</span>
<span class="line-modified">!     if (!focus)</span>
<span class="line-modified">!         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (focus-&gt;shouldFocusActiveDescendant()) {</span>
<span class="line-added">+         if (auto* descendant = focus-&gt;activeDescendant())</span>
<span class="line-added">+             focus = descendant;</span>
      }
  
      // the HTML element, for example, is focusable but has an AX object that is ignored
<span class="line-modified">!     if (focus-&gt;accessibilityIsIgnored())</span>
<span class="line-modified">!         focus = focus-&gt;parentObjectUnignored();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return focus;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">+ AXCoreObject* AXObjectCache::isolatedTreeFocusedObject(Document&amp; document)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto pageID = document.pageID();</span>
<span class="line-added">+     if (!pageID)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto tree = AXIsolatedTree::treeForPageID(*pageID);</span>
<span class="line-added">+     if (!tree) {</span>
<span class="line-added">+         tree = generateIsolatedTree(*pageID, document);</span>
<span class="line-added">+         // Now that we have created our tree, initialize the secondary thread,</span>
<span class="line-added">+         // so future requests come in on the other thread.</span>
<span class="line-added">+         _AXUIElementUseSecondaryAXThread(true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (tree)</span>
<span class="line-added">+         return tree-&gt;focusedUIElement().get();</span>
  
<span class="line-modified">!     // Should not get here, couldn&#39;t create the IsolatedTree.</span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AXObjectCache::setIsolatedTreeFocusedObject(Node* focusedNode)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(isMainThread());</span>
<span class="line-added">+     if (!m_pageID)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* focus = getOrCreate(focusedNode);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (auto tree = AXIsolatedTree::treeForPageID(*m_pageID))</span>
<span class="line-added">+         tree-&gt;setFocusedNodeID(focus ? focus-&gt;objectID() : InvalidAXID);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ AXCoreObject* AXObjectCache::focusedUIElementForPage(const Page* page)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(isMainThread());</span>
<span class="line-added">+     if (!gAccessibilityEnabled)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // get the focused node in the page</span>
<span class="line-added">+     Document* focusedDocument = page-&gt;focusController().focusedOrMainFrame().document();</span>
<span class="line-added">+     if (!focusedDocument)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">+     if (clientSupportsIsolatedTree())</span>
<span class="line-added">+         return isolatedTreeFocusedObject(*focusedDocument);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     return focusedObject(*focusedDocument);</span>
  }
  
  AccessibilityObject* AXObjectCache::get(Widget* widget)
  {
      if (!widget)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,10 ***</span>
<span class="line-new-header">--- 598,25 ---</span>
  static Ref&lt;AccessibilityObject&gt; createFromNode(Node* node)
  {
      return AccessibilityNodeObject::create(node);
  }
  
<span class="line-added">+ void AXObjectCache::cacheAndInitializeWrapper(AccessibilityObject* newObject, DOMObjectVariant domObject)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(newObject);</span>
<span class="line-added">+     AXID axID = getAXID(newObject);</span>
<span class="line-added">+     WTF::switchOn(domObject,</span>
<span class="line-added">+         [&amp;axID, this] (RenderObject* typedValue) { m_renderObjectMapping.set(typedValue, axID); },</span>
<span class="line-added">+         [&amp;axID, this] (Node* typedValue) { m_nodeObjectMapping.set(typedValue, axID); },</span>
<span class="line-added">+         [&amp;axID, this] (Widget* typedValue) { m_widgetObjectMapping.set(typedValue, axID); },</span>
<span class="line-added">+         [] (auto&amp;) { }</span>
<span class="line-added">+     );</span>
<span class="line-added">+     m_objects.set(axID, newObject);</span>
<span class="line-added">+     newObject-&gt;init();</span>
<span class="line-added">+     attachWrapper(newObject);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  AccessibilityObject* AXObjectCache::getOrCreate(Widget* widget)
  {
      if (!widget)
          return nullptr;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 556,16 ***</span>
      // Catch the case if an (unsupported) widget type is used. Only FrameView and ScrollBar are supported now.
      ASSERT(newObj);
      if (!newObj)
          return nullptr;
  
<span class="line-modified">!     getAXID(newObj.get());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_widgetObjectMapping.set(widget, newObj-&gt;axObjectID());</span>
<span class="line-removed">-     m_objects.set(newObj-&gt;axObjectID(), newObj);</span>
<span class="line-removed">-     newObj-&gt;init();</span>
<span class="line-removed">-     attachWrapper(newObj.get());</span>
      return newObj.get();
  }
  
  AccessibilityObject* AXObjectCache::getOrCreate(Node* node)
  {
<span class="line-new-header">--- 635,11 ---</span>
      // Catch the case if an (unsupported) widget type is used. Only FrameView and ScrollBar are supported now.
      ASSERT(newObj);
      if (!newObj)
          return nullptr;
  
<span class="line-modified">!     cacheAndInitializeWrapper(newObj.get(), widget);</span>
      return newObj.get();
  }
  
  AccessibilityObject* AXObjectCache::getOrCreate(Node* node)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 604,16 ***</span>
      RefPtr&lt;AccessibilityObject&gt; newObj = createFromNode(node);
  
      // Will crash later if we have two objects for the same node.
      ASSERT(!get(node));
  
<span class="line-modified">!     getAXID(newObj.get());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_nodeObjectMapping.set(node, newObj-&gt;axObjectID());</span>
<span class="line-removed">-     m_objects.set(newObj-&gt;axObjectID(), newObj);</span>
<span class="line-removed">-     newObj-&gt;init();</span>
<span class="line-removed">-     attachWrapper(newObj.get());</span>
      newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
      // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
      // it will disappear when this function is finished, leading to a use-after-free.
      if (newObj-&gt;isDetached())
          return nullptr;
<span class="line-new-header">--- 678,11 ---</span>
      RefPtr&lt;AccessibilityObject&gt; newObj = createFromNode(node);
  
      // Will crash later if we have two objects for the same node.
      ASSERT(!get(node));
  
<span class="line-modified">!     cacheAndInitializeWrapper(newObj.get(), node);</span>
      newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
      // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
      // it will disappear when this function is finished, leading to a use-after-free.
      if (newObj-&gt;isDetached())
          return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,33 ***</span>
      RefPtr&lt;AccessibilityObject&gt; newObj = createFromRenderer(renderer);
  
      // Will crash later if we have two objects for the same renderer.
      ASSERT(!get(renderer));
  
<span class="line-modified">!     getAXID(newObj.get());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_renderObjectMapping.set(renderer, newObj-&gt;axObjectID());</span>
<span class="line-removed">-     m_objects.set(newObj-&gt;axObjectID(), newObj);</span>
<span class="line-removed">-     newObj-&gt;init();</span>
<span class="line-removed">-     attachWrapper(newObj.get());</span>
      newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
      // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
      // it will disappear when this function is finished, leading to a use-after-free.
      if (newObj-&gt;isDetached())
          return nullptr;
  
      return newObj.get();
  }
  
<span class="line-modified">! AccessibilityObject* AXObjectCache::rootObject()</span>
  {
      if (!gAccessibilityEnabled)
          return nullptr;
  
      return getOrCreate(m_document.view());
  }
  
  AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame* frame)
  {
      if (!gAccessibilityEnabled)
          return nullptr;
  
<span class="line-new-header">--- 701,87 ---</span>
      RefPtr&lt;AccessibilityObject&gt; newObj = createFromRenderer(renderer);
  
      // Will crash later if we have two objects for the same renderer.
      ASSERT(!get(renderer));
  
<span class="line-modified">!     cacheAndInitializeWrapper(newObj.get(), renderer);</span>
      newObj-&gt;setLastKnownIsIgnoredValue(newObj-&gt;accessibilityIsIgnored());
      // Sometimes asking accessibilityIsIgnored() will cause the newObject to be deallocated, and then
      // it will disappear when this function is finished, leading to a use-after-free.
      if (newObj-&gt;isDetached())
          return nullptr;
  
      return newObj.get();
  }
  
<span class="line-modified">! #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">+ bool AXObjectCache::clientSupportsIsolatedTree()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!RuntimeEnabledFeatures::sharedFeatures().isAccessibilityIsolatedTreeEnabled())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     AXClientType type = _AXGetClientForCurrentRequestUntrusted();</span>
<span class="line-added">+     // FIXME: Remove unknown client before setting isAccessibilityIsolatedTreeEnabled initial value = true.</span>
<span class="line-added">+     return type == kAXClientTypeVoiceOver</span>
<span class="line-added">+         || type == kAXClientTypeUnknown;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ AXCoreObject* AXObjectCache::rootObject()</span>
  {
      if (!gAccessibilityEnabled)
          return nullptr;
  
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">+     if (clientSupportsIsolatedTree())</span>
<span class="line-added">+         return isolatedTreeRootObject();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      return getOrCreate(m_document.view());
  }
  
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">+ AXCoreObject* AXObjectCache::isolatedTreeRootObject()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_pageID)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto tree = AXIsolatedTree::treeForPageID(*m_pageID);</span>
<span class="line-added">+     if (!tree) {</span>
<span class="line-added">+         tree = Accessibility::retrieveValueFromMainThread&lt;RefPtr&lt;AXIsolatedTree&gt;&gt;([this] () -&gt; RefPtr&lt;AXIsolatedTree&gt; {</span>
<span class="line-added">+             return generateIsolatedTree(*m_pageID, m_document);</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Now that we have created our tree, initialize the secondary thread,</span>
<span class="line-added">+         // so future requests come in on the other thread.</span>
<span class="line-added">+         _AXUIElementUseSecondaryAXThread(true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (tree)</span>
<span class="line-added">+         return tree-&gt;rootNode().get();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Should not get here, couldn&#39;t create the IsolatedTree.</span>
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool AXObjectCache::canUseSecondaryAXThread()</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE) &amp;&amp; PLATFORM(MAC)</span>
<span class="line-added">+     if (_AXUIElementRequestServicedBySecondaryAXThread())</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // _AXUIElementRequestServicedBySecondaryAXThread returns false for</span>
<span class="line-added">+     // LayoutTests, but we still want to run LayoutTests using isolated tree on</span>
<span class="line-added">+     // a secondary thread to simulate the actual execution.</span>
<span class="line-added">+     return clientSupportsIsolatedTree();</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame* frame)
  {
      if (!gAccessibilityEnabled)
          return nullptr;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,11 ***</span>
      return getOrCreate(frame-&gt;view());
  }
  
  AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole role)
  {
<span class="line-modified">!     RefPtr&lt;AccessibilityObject&gt; obj = nullptr;</span>
  
      // will be filled in...
      switch (role) {
      case AccessibilityRole::ListBoxOption:
          obj = AccessibilityListBoxOption::create();
<span class="line-new-header">--- 790,11 ---</span>
      return getOrCreate(frame-&gt;view());
  }
  
  AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole role)
  {
<span class="line-modified">!     RefPtr&lt;AccessibilityObject&gt; obj;</span>
  
      // will be filled in...
      switch (role) {
      case AccessibilityRole::ListBoxOption:
          obj = AccessibilityListBoxOption::create();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 702,40 ***</span>
          break;
      default:
          obj = nullptr;
      }
  
<span class="line-modified">!     if (obj)</span>
<span class="line-removed">-         getAXID(obj.get());</span>
<span class="line-removed">-     else</span>
          return nullptr;
  
<span class="line-modified">!     m_objects.set(obj-&gt;axObjectID(), obj);</span>
<span class="line-removed">-     obj-&gt;init();</span>
<span class="line-removed">-     attachWrapper(obj.get());</span>
      return obj.get();
  }
  
  void AXObjectCache::remove(AXID axID)
  {
      if (!axID)
          return;
  
      auto object = m_objects.take(axID);
      if (!object)
          return;
  
<span class="line-modified">!     detachWrapper(object.get(), AccessibilityDetachmentType::ElementDestroyed);</span>
<span class="line-removed">-     object-&gt;detach(AccessibilityDetachmentType::ElementDestroyed, this);</span>
<span class="line-removed">-     object-&gt;setAXObjectID(0);</span>
  
      m_idsInUse.remove(axID);
<span class="line-removed">- #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-removed">-     if (auto pageID = m_document.pageID())</span>
<span class="line-removed">-         AXIsolatedTree::treeForPageID(*pageID)-&gt;removeNode(axID);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      ASSERT(m_objects.size() &gt;= m_idsInUse.size());
  }
  
  void AXObjectCache::remove(RenderObject* renderer)
  {
<span class="line-new-header">--- 825,36 ---</span>
          break;
      default:
          obj = nullptr;
      }
  
<span class="line-modified">!     if (!obj)</span>
          return nullptr;
  
<span class="line-modified">!     cacheAndInitializeWrapper(obj.get());</span>
      return obj.get();
  }
  
  void AXObjectCache::remove(AXID axID)
  {
      if (!axID)
          return;
  
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">+     if (m_pageID) {</span>
<span class="line-added">+         if (auto tree = AXIsolatedTree::treeForPageID(*m_pageID))</span>
<span class="line-added">+             tree-&gt;removeNode(axID);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      auto object = m_objects.take(axID);
      if (!object)
          return;
  
<span class="line-modified">!     object-&gt;detach(AccessibilityDetachmentType::ElementDestroyed);</span>
  
      m_idsInUse.remove(axID);
      ASSERT(m_objects.size() &gt;= m_idsInUse.size());
  }
  
  void AXObjectCache::remove(RenderObject* renderer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 756,10 ***</span>
<span class="line-new-header">--- 875,16 ---</span>
      m_deferredTextChangedList.remove(&amp;node);
      // Remove the entry if the new focused node is being removed.
      m_deferredFocusedNodeChange.removeAllMatching([&amp;node](auto&amp; entry) -&gt; bool {
          return entry.second == &amp;node;
      });
<span class="line-added">+     // Set nullptr to the old focused node if it is being removed.</span>
<span class="line-added">+     std::for_each(m_deferredFocusedNodeChange.begin(), m_deferredFocusedNodeChange.end(), [&amp;node](auto&amp; entry) {</span>
<span class="line-added">+         if (entry.first == &amp;node)</span>
<span class="line-added">+             entry.first = nullptr;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ </span>
      removeNodeForUse(node);
  
      remove(m_nodeObjectMapping.take(&amp;node));
  
      if (m_currentModalNode == &amp;node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 795,20 ***</span>
  #endif
  
  AXID AXObjectCache::getAXID(AccessibilityObject* obj)
  {
      // check for already-assigned ID
<span class="line-modified">!     AXID objID = obj-&gt;axObjectID();</span>
      if (objID) {
          ASSERT(m_idsInUse.contains(objID));
          return objID;
      }
  
      objID = platformGenerateAXID();
  
      m_idsInUse.add(objID);
<span class="line-modified">!     obj-&gt;setAXObjectID(objID);</span>
  
      return objID;
  }
  
  void AXObjectCache::textChanged(Node* node)
<span class="line-new-header">--- 920,20 ---</span>
  #endif
  
  AXID AXObjectCache::getAXID(AccessibilityObject* obj)
  {
      // check for already-assigned ID
<span class="line-modified">!     AXID objID = obj-&gt;objectID();</span>
      if (objID) {
          ASSERT(m_idsInUse.contains(objID));
          return objID;
      }
  
      objID = platformGenerateAXID();
  
      m_idsInUse.add(objID);
<span class="line-modified">!     obj-&gt;setObjectID(objID);</span>
  
      return objID;
  }
  
  void AXObjectCache::textChanged(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,16 ***</span>
          m_deferredChildrenChangedNodeList.add(newChild-&gt;node());
  
      childrenChanged(get(renderer));
  }
  
<span class="line-modified">! void AXObjectCache::childrenChanged(AccessibilityObject* obj)</span>
  {
      if (!obj)
          return;
  
<span class="line-modified">!     m_deferredChildredChangedList.add(obj);</span>
  }
  
  void AXObjectCache::notificationPostTimerFired()
  {
      Ref&lt;Document&gt; protectorForCacheOwner(m_document);
<span class="line-new-header">--- 1002,16 ---</span>
          m_deferredChildrenChangedNodeList.add(newChild-&gt;node());
  
      childrenChanged(get(renderer));
  }
  
<span class="line-modified">! void AXObjectCache::childrenChanged(AXCoreObject* obj)</span>
  {
      if (!obj)
          return;
  
<span class="line-modified">!     m_deferredChildrenChangedList.add(obj);</span>
  }
  
  void AXObjectCache::notificationPostTimerFired()
  {
      Ref&lt;Document&gt; protectorForCacheOwner(m_document);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 895,12 ***</span>
      // In tests, posting notifications has a tendency to immediately queue up other notifications, which can lead to unexpected behavior
      // when the notification list is cleared at the end. Instead copy this list at the start.
      auto notifications = WTFMove(m_notificationsToPost);
  
      for (const auto&amp; note : notifications) {
<span class="line-modified">!         AccessibilityObject* obj = note.first.get();</span>
<span class="line-modified">!         if (!obj-&gt;axObjectID())</span>
              continue;
  
          if (!obj-&gt;axObjectCache())
              continue;
  
<span class="line-new-header">--- 1020,12 ---</span>
      // In tests, posting notifications has a tendency to immediately queue up other notifications, which can lead to unexpected behavior
      // when the notification list is cleared at the end. Instead copy this list at the start.
      auto notifications = WTFMove(m_notificationsToPost);
  
      for (const auto&amp; note : notifications) {
<span class="line-modified">!         AXCoreObject* obj = note.first.get();</span>
<span class="line-modified">!         if (!obj-&gt;objectID())</span>
              continue;
  
          if (!obj-&gt;axObjectCache())
              continue;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 984,11 ***</span>
          return;
  
      postNotification(object.get(), &amp;node-&gt;document(), notification, postTarget, postType);
  }
  
<span class="line-modified">! void AXObjectCache::postNotification(AccessibilityObject* object, Document* document, AXNotification notification, PostTarget postTarget, PostType postType)</span>
  {
      stopCachingComputedObjectAttributes();
  
      if (object &amp;&amp; postTarget == TargetObservableParent)
          object = object-&gt;observableObject();
<span class="line-new-header">--- 1109,11 ---</span>
          return;
  
      postNotification(object.get(), &amp;node-&gt;document(), notification, postTarget, postType);
  }
  
<span class="line-modified">! void AXObjectCache::postNotification(AXCoreObject* object, Document* document, AXNotification notification, PostTarget postTarget, PostType postType)</span>
  {
      stopCachingComputedObjectAttributes();
  
      if (object &amp;&amp; postTarget == TargetObservableParent)
          object = object-&gt;observableObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1036,10 ***</span>
<span class="line-new-header">--- 1161,14 ---</span>
          handleFocusedUIElementChanged(oldNode, newNode);
  }
  
  void AXObjectCache::handleFocusedUIElementChanged(Node* oldNode, Node* newNode)
  {
<span class="line-added">+ #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">+     setIsolatedTreeFocusedObject(newNode);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      handleMenuItemSelected(newNode);
      platformHandleFocusedUIElementChanged(oldNode, newNode);
  }
  
  void AXObjectCache::selectedChildrenChanged(Node* node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1494,10 ***</span>
<span class="line-new-header">--- 1623,12 ---</span>
          handleAriaRoleChanged(element);
      else if (attrName == altAttr || attrName == titleAttr)
          textChanged(element);
      else if (attrName == forAttr &amp;&amp; is&lt;HTMLLabelElement&gt;(*element))
          labelChanged(element);
<span class="line-added">+     else if (attrName == tabindexAttr)</span>
<span class="line-added">+         childrenChanged(element-&gt;parentNode(), element);</span>
  
      if (!attrName.localName().string().startsWith(&quot;aria-&quot;))
          return;
  
      if (attrName == aria_activedescendantAttr)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1930,11 ***</span>
      if (!visiblePosition.isNull()) {
          Position deepPos = visiblePosition.deepEquivalent();
          vpOffset = deepPos.deprecatedEditingOffset();
      }
  
<span class="line-modified">!     textMarkerData.axID = obj.get()-&gt;axObjectID();</span>
      textMarkerData.node = domNode;
      textMarkerData.characterOffset = characterOffset.offset;
      textMarkerData.characterStartIndex = characterOffset.startIndex;
      textMarkerData.offset = vpOffset;
      textMarkerData.affinity = visiblePosition.affinity();
<span class="line-new-header">--- 2061,11 ---</span>
      if (!visiblePosition.isNull()) {
          Position deepPos = visiblePosition.deepEquivalent();
          vpOffset = deepPos.deprecatedEditingOffset();
      }
  
<span class="line-modified">!     textMarkerData.axID = obj.get()-&gt;objectID();</span>
      textMarkerData.node = domNode;
      textMarkerData.characterOffset = characterOffset.offset;
      textMarkerData.characterStartIndex = characterOffset.startIndex;
      textMarkerData.offset = vpOffset;
      textMarkerData.affinity = visiblePosition.affinity();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2224,11 ***</span>
      // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
      // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
      TextMarkerData textMarkerData;
      memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
  
<span class="line-modified">!     textMarkerData.axID = obj.get()-&gt;axObjectID();</span>
      textMarkerData.node = domNode;
      textMarkerData.offset = deepPos.deprecatedEditingOffset();
      textMarkerData.affinity = visiblePos.affinity();
  
      textMarkerData.characterOffset = characterOffset.offset;
<span class="line-new-header">--- 2355,11 ---</span>
      // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
      // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
      TextMarkerData textMarkerData;
      memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
  
<span class="line-modified">!     textMarkerData.axID = obj.get()-&gt;objectID();</span>
      textMarkerData.node = domNode;
      textMarkerData.offset = deepPos.deprecatedEditingOffset();
      textMarkerData.affinity = visiblePos.affinity();
  
      textMarkerData.characterOffset = characterOffset.offset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2256,11 ***</span>
      // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
      // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
      TextMarkerData textMarkerData;
      memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
  
<span class="line-modified">!     textMarkerData.axID = obj.get()-&gt;axObjectID();</span>
      textMarkerData.node = &amp;textControl;
  
      cache-&gt;setNodeInUse(&amp;textControl);
  
      return textMarkerData;
<span class="line-new-header">--- 2387,11 ---</span>
      // This memory must be zero&#39;d so instances of TextMarkerData can be tested for byte-equivalence.
      // Warning: This is risky and bad because TextMarkerData is a nontrivial type.
      TextMarkerData textMarkerData;
      memset(static_cast&lt;void*&gt;(&amp;textMarkerData), 0, sizeof(TextMarkerData));
  
<span class="line-modified">!     textMarkerData.axID = obj.get()-&gt;objectID();</span>
      textMarkerData.node = &amp;textControl;
  
      cache-&gt;setNodeInUse(&amp;textControl);
  
      return textMarkerData;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2387,12 ***</span>
      if (characterOffset.isNull() || !characterOffset.node-&gt;isTextNode())
          return 0;
  
      UChar32 ch = 0;
      unsigned offset = characterOffset.startIndex + characterOffset.offset;
<span class="line-modified">!     if (offset &lt; characterOffset.node-&gt;textContent().length())</span>
          U16_NEXT(characterOffset.node-&gt;textContent(), offset, characterOffset.node-&gt;textContent().length(), ch);
      return ch;
  }
  
  UChar32 AXObjectCache::characterAfter(const CharacterOffset&amp; characterOffset)
  {
<span class="line-new-header">--- 2518,16 ---</span>
      if (characterOffset.isNull() || !characterOffset.node-&gt;isTextNode())
          return 0;
  
      UChar32 ch = 0;
      unsigned offset = characterOffset.startIndex + characterOffset.offset;
<span class="line-modified">!     if (offset &lt; characterOffset.node-&gt;textContent().length()) {</span>
<span class="line-added">+ // FIXME: Remove IGNORE_CLANG_WARNINGS macros once one of &lt;rdar://problem/58615489&amp;58615391&gt; is fixed.</span>
<span class="line-added">+ IGNORE_CLANG_WARNINGS_BEGIN(&quot;conditional-uninitialized&quot;)</span>
          U16_NEXT(characterOffset.node-&gt;textContent(), offset, characterOffset.node-&gt;textContent().length(), ch);
<span class="line-added">+ IGNORE_CLANG_WARNINGS_END</span>
<span class="line-added">+     }</span>
      return ch;
  }
  
  UChar32 AXObjectCache::characterAfter(const CharacterOffset&amp; characterOffset)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2701,11 ***</span>
  
      localRect = localCaretRectInRendererForRect(localRect, characterOffset.node, renderer, caretPainter);
      return absoluteBoundsForLocalCaretRect(caretPainter, localRect);
  }
  
<span class="line-modified">! CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point, AccessibilityObject* obj)</span>
  {
      if (!obj)
          return CharacterOffset();
  
      VisiblePosition vp = obj-&gt;visiblePositionForPoint(point);
<span class="line-new-header">--- 2836,11 ---</span>
  
      localRect = localCaretRectInRendererForRect(localRect, characterOffset.node, renderer, caretPainter);
      return absoluteBoundsForLocalCaretRect(caretPainter, localRect);
  }
  
<span class="line-modified">! CharacterOffset AXObjectCache::characterOffsetForPoint(const IntPoint &amp;point, AXCoreObject* obj)</span>
  {
      if (!obj)
          return CharacterOffset();
  
      VisiblePosition vp = obj-&gt;visiblePositionForPoint(point);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2767,11 ***</span>
      VisiblePosition startLine = startOfLine(vp);
  
      return characterOffsetFromVisiblePosition(startLine);
  }
  
<span class="line-modified">! CharacterOffset AXObjectCache::characterOffsetForIndex(int index, const AccessibilityObject* obj)</span>
  {
      if (!obj)
          return CharacterOffset();
  
      VisiblePosition vp = obj-&gt;visiblePositionForIndex(index);
<span class="line-new-header">--- 2902,11 ---</span>
      VisiblePosition startLine = startOfLine(vp);
  
      return characterOffsetFromVisiblePosition(startLine);
  }
  
<span class="line-modified">! CharacterOffset AXObjectCache::characterOffsetForIndex(int index, const AXCoreObject* obj)</span>
  {
      if (!obj)
          return CharacterOffset();
  
      VisiblePosition vp = obj-&gt;visiblePositionForIndex(index);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2901,13 ***</span>
          handleMenuOpened(nodeChild);
          handleLiveRegionCreated(nodeChild);
      }
      m_deferredChildrenChangedNodeList.clear();
  
<span class="line-modified">!     for (auto&amp; child : m_deferredChildredChangedList)</span>
          child-&gt;childrenChanged();
<span class="line-modified">!     m_deferredChildredChangedList.clear();</span>
  
      for (auto* node : m_deferredTextChangedList)
          textChanged(node);
      m_deferredTextChangedList.clear();
  
<span class="line-new-header">--- 3036,13 ---</span>
          handleMenuOpened(nodeChild);
          handleLiveRegionCreated(nodeChild);
      }
      m_deferredChildrenChangedNodeList.clear();
  
<span class="line-modified">!     for (auto&amp; child : m_deferredChildrenChangedList)</span>
          child-&gt;childrenChanged();
<span class="line-modified">!     m_deferredChildrenChangedList.clear();</span>
  
      for (auto* node : m_deferredTextChangedList)
          textChanged(node);
      m_deferredTextChangedList.clear();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2937,38 ***</span>
  
      platformPerformDeferredCacheUpdate();
  }
  
  #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified">! Ref&lt;AXIsolatedTreeNode&gt; AXObjectCache::createIsolatedAccessibilityTreeHierarchy(AccessibilityObject&amp; object, AXID parentID, AXIsolatedTree&amp; tree, Vector&lt;Ref&lt;AXIsolatedTreeNode&gt;&gt;&amp; nodeChanges)</span>
  {
<span class="line-modified">!     auto isolatedTreeNode = AXIsolatedTreeNode::create(object);</span>
      nodeChanges.append(isolatedTreeNode.copyRef());
  
      isolatedTreeNode-&gt;setParent(parentID);
<span class="line-modified">!     associateIsolatedTreeNode(object, isolatedTreeNode, tree.treeIdentifier());</span>
  
<span class="line-modified">!     for (auto child : object.children()) {</span>
<span class="line-modified">!         auto staticChild = createIsolatedAccessibilityTreeHierarchy(*child, isolatedTreeNode-&gt;identifier(), tree, nodeChanges);</span>
<span class="line-modified">!         isolatedTreeNode-&gt;appendChild(staticChild-&gt;identifier());</span>
      }
  
      return isolatedTreeNode;
  }
  
<span class="line-modified">! Ref&lt;AXIsolatedTree&gt; AXObjectCache::generateIsolatedAccessibilityTree()</span>
  {
      RELEASE_ASSERT(isMainThread());
  
<span class="line-modified">!     auto tree = AXIsolatedTree::treeForPageID(*m_document.pageID());</span>
<span class="line-modified">!     if (!tree)</span>
<span class="line-modified">!         tree = AXIsolatedTree::createTreeForPageID(*m_document.pageID());</span>
  
<span class="line-modified">!     Vector&lt;Ref&lt;AXIsolatedTreeNode&gt;&gt; nodeChanges;</span>
<span class="line-modified">!     auto root = createIsolatedAccessibilityTreeHierarchy(*rootObject(), InvalidAXID, *tree, nodeChanges);</span>
<span class="line-modified">!     tree-&gt;setRootNodeID(root-&gt;identifier());</span>
<span class="line-removed">-     tree-&gt;appendNodeChanges(nodeChanges);</span>
  
      return makeRef(*tree);
  }
  #endif
  
<span class="line-new-header">--- 3072,51 ---</span>
  
      platformPerformDeferredCacheUpdate();
  }
  
  #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<span class="line-modified">! Ref&lt;AXIsolatedObject&gt; AXObjectCache::createIsolatedTreeHierarchy(AXCoreObject&amp; object, AXID parentID, AXObjectCache* axObjectCache, AXIsolatedTree&amp; tree, Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt;&amp; nodeChanges, bool isRoot)</span>
  {
<span class="line-modified">!     auto isolatedTreeNode = AXIsolatedObject::create(object, isRoot);</span>
      nodeChanges.append(isolatedTreeNode.copyRef());
  
<span class="line-added">+     isolatedTreeNode-&gt;setTreeIdentifier(tree.treeIdentifier());</span>
      isolatedTreeNode-&gt;setParent(parentID);
<span class="line-modified">!     axObjectCache-&gt;attachWrapper(&amp;isolatedTreeNode.get(), object.wrapper());</span>
  
<span class="line-modified">!     for (const auto&amp; child : object.children()) {</span>
<span class="line-modified">!         auto staticChild = createIsolatedTreeHierarchy(*child, isolatedTreeNode-&gt;objectID(), axObjectCache, tree, nodeChanges, false);</span>
<span class="line-modified">!         isolatedTreeNode-&gt;appendChild(staticChild-&gt;objectID());</span>
      }
  
      return isolatedTreeNode;
  }
  
<span class="line-modified">! Ref&lt;AXIsolatedTree&gt; AXObjectCache::generateIsolatedTree(PageIdentifier pageID, Document&amp; document)</span>
  {
      RELEASE_ASSERT(isMainThread());
  
<span class="line-modified">!     RefPtr&lt;AXIsolatedTree&gt; tree(AXIsolatedTree::createTreeForPageID(pageID));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // Set the root and focused objects in the isolated tree. For that, we need</span>
<span class="line-added">+     // the root and the focused object in the AXObject tree.</span>
<span class="line-added">+     auto* axObjectCache = document.axObjectCache();</span>
<span class="line-added">+     if (!axObjectCache)</span>
<span class="line-added">+         return makeRef(*tree);</span>
<span class="line-added">+     tree-&gt;setAXObjectCache(axObjectCache);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* axRoot = axObjectCache-&gt;getOrCreate(document.view());</span>
<span class="line-added">+     if (axRoot) {</span>
<span class="line-added">+         Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt; nodeChanges;</span>
<span class="line-added">+         auto isolatedRoot = createIsolatedTreeHierarchy(*axRoot, InvalidAXID, axObjectCache, *tree, nodeChanges, true);</span>
<span class="line-added">+         tree-&gt;setRootNode(isolatedRoot);</span>
<span class="line-added">+         tree-&gt;appendNodeChanges(nodeChanges);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     auto* axFocus = axObjectCache-&gt;focusedObject(document);</span>
<span class="line-modified">!     if (axFocus)</span>
<span class="line-modified">!         tree-&gt;setFocusedNodeID(axFocus-&gt;objectID());</span>
  
      return makeRef(*tree);
  }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3057,11 ***</span>
      return !requiresAriaHiddenFalse || ariaHiddenFalsePresent;
  }
  
  AccessibilityObject* AXObjectCache::rootWebArea()
  {
<span class="line-modified">!     AccessibilityObject* rootObject = this-&gt;rootObject();</span>
      if (!rootObject || !rootObject-&gt;isAccessibilityScrollView())
          return nullptr;
      return downcast&lt;AccessibilityScrollView&gt;(*rootObject).webAreaObject();
  }
  
<span class="line-new-header">--- 3205,11 ---</span>
      return !requiresAriaHiddenFalse || ariaHiddenFalsePresent;
  }
  
  AccessibilityObject* AXObjectCache::rootWebArea()
  {
<span class="line-modified">!     AXCoreObject* rootObject = this-&gt;rootObject();</span>
      if (!rootObject || !rootObject-&gt;isAccessibilityScrollView())
          return nullptr;
      return downcast&lt;AccessibilityScrollView&gt;(*rootObject).webAreaObject();
  }
  
</pre>
<center><a href="../WebCorePrefix.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AXObjectCache.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
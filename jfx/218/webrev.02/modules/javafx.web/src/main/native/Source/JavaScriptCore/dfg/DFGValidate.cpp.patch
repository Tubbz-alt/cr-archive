diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGValidate.cpp
@@ -284,10 +284,15 @@
                     break;
                 case CompareEqPtr:
                     VALIDATE((node), !!node->child1());
                     VALIDATE((node), !!node->cellOperand()->value() && node->cellOperand()->value().isCell());
                     break;
+                case CheckArrayOrEmpty:
+                    VALIDATE((node), is64Bit());
+                    VALIDATE((node), !!node->child1());
+                    VALIDATE((node), node->child1().useKind() == CellUse);
+                    break;
                 case CheckStructureOrEmpty:
                     VALIDATE((node), is64Bit());
                     VALIDATE((node), !!node->child1());
                     VALIDATE((node), node->child1().useKind() == CellUse);
                     break;
@@ -471,21 +476,21 @@
                 HashSet<Node*> seenNodes;
                 for (size_t i = 0; i < block->size(); ++i) {
                     Node* node = block->at(i);
                     m_graph.doToChildren(node, [&] (const Edge& edge) {
                         Node* child = edge.node();
-                        VALIDATE((node), block->isInPhis(child) || seenNodes.contains(child));
+                        VALIDATE((node, edge), block->isInPhis(child) || seenNodes.contains(child));
                     });
                     seenNodes.add(node);
                 }
             }
 
             for (size_t i = 0; i < block->phis.size(); ++i) {
                 Node* node = block->phis[i];
                 ASSERT(phisInThisBlock.contains(node));
                 VALIDATE((node), node->op() == Phi);
-                VirtualRegister local = node->local();
+                Operand operand = node->operand();
                 for (unsigned j = 0; j < m_graph.numChildren(node); ++j) {
                     // Phi children in LoadStore form are invalid.
                     if (m_graph.m_form == LoadStore && block->isPhiIndex(i))
                         continue;
 
@@ -517,56 +522,52 @@
                     // its tail variables.
                     bool found = false;
                     for (unsigned k = 0; k < block->predecessors.size(); ++k) {
                         BasicBlock* prevBlock = block->predecessors[k];
                         VALIDATE((block->predecessors[k]), prevBlock);
-                        Node* prevNode = prevBlock->variablesAtTail.operand(local);
+                        Node* prevNode = prevBlock->variablesAtTail.operand(operand);
                         // If we have a Phi that is not referring to *this* block then all predecessors
                         // must have that local available.
-                        VALIDATE((local, block, block->predecessors[k]), prevNode);
+                        VALIDATE((operand, block, block->predecessors[k]), prevNode);
                         switch (prevNode->op()) {
                         case GetLocal:
                         case Flush:
                         case PhantomLocal:
                             prevNode = prevNode->child1().node();
                             break;
                         default:
                             break;
                         }
                         if (node->shouldGenerate()) {
-                            VALIDATE((local, block->predecessors[k], prevNode),
+                            VALIDATE((operand, block->predecessors[k], prevNode),
                                      prevNode->shouldGenerate());
                         }
                         VALIDATE(
-                            (local, block->predecessors[k], prevNode),
+                            (operand, block->predecessors[k], prevNode),
                             prevNode->op() == SetLocal
                             || prevNode->op() == SetArgumentDefinitely
                             || prevNode->op() == SetArgumentMaybe
                             || prevNode->op() == Phi);
                         if (prevNode == edge.node()) {
                             found = true;
                             break;
                         }
                         // At this point it cannot refer into this block.
-                        VALIDATE((local, block->predecessors[k], prevNode), !prevBlock->isInBlock(edge.node()));
+                        VALIDATE((operand, block->predecessors[k], prevNode), !prevBlock->isInBlock(edge.node()));
                     }
 
                     VALIDATE((node, edge), found);
                 }
             }
 
-            Operands<size_t> getLocalPositions(
-                block->variablesAtHead.numberOfArguments(),
-                block->variablesAtHead.numberOfLocals());
-            Operands<size_t> setLocalPositions(
-                block->variablesAtHead.numberOfArguments(),
-                block->variablesAtHead.numberOfLocals());
+            Operands<size_t> getLocalPositions(OperandsLike, block->variablesAtHead);
+            Operands<size_t> setLocalPositions(OperandsLike, block->variablesAtHead);
 
             for (size_t i = 0; i < block->variablesAtHead.numberOfArguments(); ++i) {
-                VALIDATE((virtualRegisterForArgument(i), block), !block->variablesAtHead.argument(i) || block->variablesAtHead.argument(i)->accessesStack(m_graph));
+                VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block->variablesAtHead.argument(i) || block->variablesAtHead.argument(i)->accessesStack(m_graph));
                 if (m_graph.m_form == ThreadedCPS)
-                    VALIDATE((virtualRegisterForArgument(i), block), !block->variablesAtTail.argument(i) || block->variablesAtTail.argument(i)->accessesStack(m_graph));
+                    VALIDATE((virtualRegisterForArgumentIncludingThis(i), block), !block->variablesAtTail.argument(i) || block->variablesAtTail.argument(i)->accessesStack(m_graph));
 
                 getLocalPositions.argument(i) = notSet;
                 setLocalPositions.argument(i) = notSet;
             }
             for (size_t i = 0; i < block->variablesAtHead.numberOfLocals(); ++i) {
@@ -666,28 +667,28 @@
                     // Ignore GetLocal's that we know to be dead, but that the graph
                     // doesn't yet know to be dead.
                     if (!m_myRefCounts.get(node))
                         break;
                     if (m_graph.m_form == ThreadedCPS) {
-                        VALIDATE((node, block), getLocalPositions.operand(node->local()) == notSet);
+                        VALIDATE((node, block), getLocalPositions.operand(node->operand()) == notSet);
                         VALIDATE((node, block), !!node->child1());
                         VALIDATE((node, block), node->child1()->op() == SetArgumentDefinitely || node->child1()->op() == Phi);
                     }
-                    getLocalPositions.operand(node->local()) = i;
+                    getLocalPositions.operand(node->operand()) = i;
                     break;
                 case SetLocal:
                     // Only record the first SetLocal. There may be multiple SetLocals
                     // because of flushing.
-                    if (setLocalPositions.operand(node->local()) != notSet)
+                    if (setLocalPositions.operand(node->operand()) != notSet)
                         break;
-                    setLocalPositions.operand(node->local()) = i;
+                    setLocalPositions.operand(node->operand()) = i;
                     break;
                 case SetArgumentDefinitely:
                     // This acts like a reset. It's ok to have a second GetLocal for a local in the same
                     // block if we had a SetArgumentDefinitely for that local.
-                    getLocalPositions.operand(node->local()) = notSet;
-                    setLocalPositions.operand(node->local()) = notSet;
+                    getLocalPositions.operand(node->operand()) = notSet;
+                    setLocalPositions.operand(node->operand()) = notSet;
                     break;
                 case SetArgumentMaybe:
                     break;
                 case Flush:
                 case PhantomLocal:
@@ -709,11 +710,11 @@
             if (m_graph.m_form == LoadStore)
                 continue;
 
             for (size_t i = 0; i < block->variablesAtHead.numberOfArguments(); ++i) {
                 checkOperand(
-                    block, getLocalPositions, setLocalPositions, virtualRegisterForArgument(i));
+                    block, getLocalPositions, setLocalPositions, virtualRegisterForArgumentIncludingThis(i));
             }
             for (size_t i = 0; i < block->variablesAtHead.numberOfLocals(); ++i) {
                 checkOperand(
                     block, getLocalPositions, setLocalPositions, virtualRegisterForLocal(i));
             }
@@ -757,11 +758,11 @@
                     break;
                 case SetArgumentMaybe:
                     VALIDATE((node), !"Should not reach SetArgumentMaybe. GetLocal that has data flow that reaches a SetArgumentMaybe is invalid IR.");
                     break;
                 default:
-                    VALIDATE((node), !"Unexecpted node type.");
+                    VALIDATE((node), !"Unexpected node type.");
                     break;
                 }
             }
         }
     }
@@ -778,11 +779,11 @@
 
         m_graph.initializeNodeOwners();
 
         auto& dominators = m_graph.ensureSSADominators();
 
-        for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeOffset.keys())
+        for (unsigned entrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeIndex.keys())
             VALIDATE((), entrypointIndex > 0); // By convention, 0 is the entrypoint index for the op_enter entrypoint, which can not be in a catch.
 
         for (BlockIndex blockIndex = 0; blockIndex < m_graph.numBlocks(); ++blockIndex) {
             BasicBlock* block = m_graph.block(blockIndex);
             if (!block)
@@ -966,30 +967,30 @@
     void reportValidationContext(Node* node, Edge edge)
     {
         dataLog(node, " -> ", edge);
     }
 
-    void reportValidationContext(VirtualRegister local, BasicBlock* block)
+    void reportValidationContext(Operand operand, BasicBlock* block)
     {
         if (!block) {
-            dataLog(local, " in null Block ");
+            dataLog(operand, " in null Block ");
             return;
         }
 
-        dataLog(local, " in Block ", *block);
+        dataLog(operand, " in Block ", *block);
     }
 
     void reportValidationContext(
-        VirtualRegister local, BasicBlock* sourceBlock, BasicBlock* destinationBlock)
+        Operand operand, BasicBlock* sourceBlock, BasicBlock* destinationBlock)
     {
-        dataLog(local, " in Block ", *sourceBlock, " -> ", *destinationBlock);
+        dataLog(operand, " in Block ", *sourceBlock, " -> ", *destinationBlock);
     }
 
     void reportValidationContext(
-        VirtualRegister local, BasicBlock* sourceBlock, Node* prevNode)
+        Operand operand, BasicBlock* sourceBlock, Node* prevNode)
     {
-        dataLog(prevNode, " for ", local, " in Block ", *sourceBlock);
+        dataLog(prevNode, " for ", operand, " in Block ", *sourceBlock);
     }
 
     void reportValidationContext(Node* node, BasicBlock* block)
     {
         dataLog(node, " in Block ", *block);

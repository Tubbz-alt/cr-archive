<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CommonSlowPaths.h&quot;
  28 
  29 #include &quot;ArithProfile.h&quot;
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeStructs.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;ClonedArguments.h&quot;
  35 #include &quot;CodeProfiling.h&quot;
  36 #include &quot;DefinePropertyAttributes.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;Error.h&quot;
  39 #include &quot;ErrorHandlingScope.h&quot;
  40 #include &quot;ExceptionFuzz.h&quot;
  41 #include &quot;FrameTracers.h&quot;
  42 #include &quot;GetterSetter.h&quot;
  43 #include &quot;HostCallReturnValue.h&quot;
  44 #include &quot;ICStats.h&quot;
  45 #include &quot;Interpreter.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JSArrayInlines.h&quot;
  49 #include &quot;JSAsyncGenerator.h&quot;
  50 #include &quot;JSCInlines.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;JSGlobalObjectFunctions.h&quot;
  53 #include &quot;JSImmutableButterfly.h&quot;
  54 #include &quot;JSInternalPromise.h&quot;
  55 #include &quot;JSInternalPromiseConstructor.h&quot;
  56 #include &quot;JSLexicalEnvironment.h&quot;
  57 #include &quot;JSPromiseConstructor.h&quot;
  58 #include &quot;JSPropertyNameEnumerator.h&quot;
  59 #include &quot;JSString.h&quot;
  60 #include &quot;JSWithScope.h&quot;
  61 #include &quot;LLIntCommon.h&quot;
  62 #include &quot;LLIntExceptions.h&quot;
  63 #include &quot;LowLevelInterpreter.h&quot;
  64 #include &quot;MathCommon.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;OpcodeInlines.h&quot;
  67 #include &quot;ScopedArguments.h&quot;
  68 #include &quot;StructureRareDataInlines.h&quot;
  69 #include &quot;ThunkGenerators.h&quot;
  70 #include &quot;TypeProfilerLog.h&quot;
  71 #include &lt;wtf/StringPrintStream.h&gt;
  72 #include &lt;wtf/Variant.h&gt;
  73 
  74 namespace JSC {
  75 
  76 #define BEGIN_NO_SET_PC() \
  77     CodeBlock* codeBlock = callFrame-&gt;codeBlock(); \
  78     JSGlobalObject* globalObject = codeBlock-&gt;globalObject(); \
  79     VM&amp; vm = codeBlock-&gt;vm(); \
  80     SlowPathFrameTracer tracer(vm, callFrame); \
  81     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  82     UNUSED_PARAM(throwScope)
  83 
  84 #ifndef NDEBUG
  85 #define SET_PC_FOR_STUBS() do { \
  86         codeBlock-&gt;bytecodeOffset(pc); \
  87         callFrame-&gt;setCurrentVPC(pc); \
  88     } while (false)
  89 #else
  90 #define SET_PC_FOR_STUBS() do { \
  91         callFrame-&gt;setCurrentVPC(pc); \
  92     } while (false)
  93 #endif
  94 
  95 #define RETURN_TO_THROW(pc)   pc = LLInt::returnToThrow(vm)
  96 
  97 #define BEGIN()                           \
  98     BEGIN_NO_SET_PC();                    \
  99     SET_PC_FOR_STUBS()
 100 
 101 #define GET(operand) (callFrame-&gt;uncheckedR(operand))
 102 #define GET_C(operand) (callFrame-&gt;r(operand))
 103 
 104 #define RETURN_TWO(first, second) do {       \
 105         return encodeResult(first, second);        \
 106     } while (false)
 107 
 108 #define END_IMPL() RETURN_TWO(pc, callFrame)
 109 
 110 #define THROW(exceptionToThrow) do {                        \
 111         throwException(globalObject, throwScope, exceptionToThrow); \
 112         RETURN_TO_THROW(pc);                          \
 113         END_IMPL();                                         \
 114     } while (false)
 115 
 116 #define CHECK_EXCEPTION() do {                    \
 117         doExceptionFuzzingIfEnabled(globalObject, throwScope, &quot;CommonSlowPaths&quot;, pc);   \
 118         if (UNLIKELY(throwScope.exception())) {   \
 119             RETURN_TO_THROW(pc);            \
 120             END_IMPL();                           \
 121         }                                         \
 122     } while (false)
 123 
 124 #define END() do {                        \
 125         CHECK_EXCEPTION();                \
 126         END_IMPL();                       \
 127     } while (false)
 128 
 129 #define BRANCH(condition) do {                      \
 130         bool bCondition = (condition);                         \
 131         CHECK_EXCEPTION();                                  \
 132         if (bCondition)                                        \
 133             pc = bytecode.m_targetLabel \
 134                 ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
 135                 : codeBlock-&gt;outOfLineJumpTarget(pc);                              \
 136         else                                                      \
 137             pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
 138         END_IMPL();                                         \
 139     } while (false)
 140 
 141 #define RETURN_WITH_PROFILING_CUSTOM(result__, value__, profilingAction__) do { \
 142         JSValue returnValue__ = (value__);  \
 143         CHECK_EXCEPTION();                  \
 144         GET(result__) = returnValue__;              \
 145         profilingAction__;                  \
 146         END_IMPL();                         \
 147     } while (false)
 148 
 149 #define RETURN_WITH_PROFILING(value__, profilingAction__) RETURN_WITH_PROFILING_CUSTOM(bytecode.m_dst, value__, profilingAction__)
 150 
 151 #define RETURN(value) \
 152     RETURN_WITH_PROFILING(value, { })
 153 
 154 #define RETURN_PROFILED(value__) \
 155     RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
 156 
 157 #define PROFILE_VALUE(value) do { \
 158         bytecode.metadata(codeBlock).m_profile.m_buckets[0] = JSValue::encode(value); \
 159     } while (false)
 160 
 161 static void throwArityCheckStackOverflowError(JSGlobalObject* globalObject, ThrowScope&amp; scope)
 162 {
 163     JSObject* error = createStackOverflowError(globalObject);
 164     throwException(globalObject, scope, error);
 165 #if LLINT_TRACING
 166     if (UNLIKELY(Options::traceLLIntSlowPath()))
 167         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 168 #endif
 169 }
 170 
 171 SLOW_PATH_DECL(slow_path_call_arityCheck)
 172 {
 173     BEGIN();
 174     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForCall);
 175     if (UNLIKELY(slotsToAdd &lt; 0)) {
 176         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForCall);
 177         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);
 178         SlowPathFrameTracer tracer(vm, callFrame);
 179         ErrorHandlingScope errorScope(vm);
 180         throwScope.release();
 181         throwArityCheckStackOverflowError(globalObject, throwScope);
 182         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);
 183     }
 184     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 185 }
 186 
 187 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 188 {
 189     BEGIN();
 190     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForConstruct);
 191     if (UNLIKELY(slotsToAdd &lt; 0)) {
 192         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForConstruct);
 193         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);
 194         SlowPathFrameTracer tracer(vm, callFrame);
 195         ErrorHandlingScope errorScope(vm);
 196         throwArityCheckStackOverflowError(globalObject, throwScope);
 197         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);
 198     }
 199     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 200 }
 201 
 202 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 203 {
 204     BEGIN();
 205     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
 206     RETURN(DirectArguments::createByCopying(globalObject, callFrame));
 207 }
 208 
 209 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 210 {
 211     BEGIN();
 212     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 213     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 214     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
 215     RETURN(ScopedArguments::createByCopying(globalObject, callFrame, table, scope));
 216 }
 217 
 218 SLOW_PATH_DECL(slow_path_create_cloned_arguments)
 219 {
 220     BEGIN();
 221     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
 222     RETURN(ClonedArguments::createWithMachineFrame(globalObject, callFrame, ArgumentsMode::Cloned));
 223 }
 224 
 225 SLOW_PATH_DECL(slow_path_create_arguments_butterfly)
 226 {
 227     BEGIN();
 228     auto bytecode = pc-&gt;as&lt;OpCreateArgumentsButterfly&gt;();
 229     int32_t argumentCount = callFrame-&gt;argumentCount();
 230     JSImmutableButterfly* butterfly = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), argumentCount);
 231     if (!butterfly)
 232         THROW(createOutOfMemoryError(globalObject));
 233     for (int32_t index = 0; index &lt; argumentCount; ++index)
 234         butterfly-&gt;setIndex(vm, index, callFrame-&gt;uncheckedArgument(index));
 235     RETURN(butterfly);
 236 }
 237 
 238 SLOW_PATH_DECL(slow_path_create_this)
 239 {
 240     BEGIN();
 241     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 242     JSObject* result;
 243     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
 244     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);
 245     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {
 246         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;
 247         if (!cachedCallee)
 248             cachedCallee.set(vm, codeBlock, constructor);
 249         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 250             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 251 
 252         size_t inlineCapacity = bytecode.m_inlineCapacity;
 253         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity)-&gt;objectAllocationProfile();
 254         throwScope.releaseAssertNoException();
 255         Structure* structure = allocationProfile-&gt;structure();
 256         result = constructEmptyObject(vm, structure);
 257         if (structure-&gt;hasPolyProto()) {
 258             JSObject* prototype = allocationProfile-&gt;prototype();
 259             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, globalObject));
 260             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 261             prototype-&gt;didBecomePrototype();
 262             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 263         }
 264     } else {
 265         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
 266         JSValue proto = constructorAsObject-&gt;get(globalObject, vm.propertyNames-&gt;prototype);
 267         CHECK_EXCEPTION();
 268         if (proto.isObject())
 269             result = constructEmptyObject(globalObject, asObject(proto));
 270         else
 271             result = constructEmptyObject(globalObject);
 272     }
 273     RETURN(result);
 274 }
 275 
 276 SLOW_PATH_DECL(slow_path_create_promise)
 277 {
 278     BEGIN();
 279     auto bytecode = pc-&gt;as&lt;OpCreatePromise&gt;();
 280     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
 281 
 282     JSPromise* result = nullptr;
 283     if (bytecode.m_isInternalPromise) {
 284         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;internalPromiseConstructor(), constructorAsObject, globalObject-&gt;internalPromiseStructure());
 285         CHECK_EXCEPTION();
 286         result = JSInternalPromise::create(vm, structure);
 287     } else {
 288         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;promiseConstructor(), constructorAsObject, globalObject-&gt;promiseStructure());
 289         CHECK_EXCEPTION();
 290         result = JSPromise::create(vm, structure);
 291     }
 292 
 293     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);
 294     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {
 295         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;
 296         if (!cachedCallee)
 297             cachedCallee.set(vm, codeBlock, constructor);
 298         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 299             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 300     }
 301     RETURN(result);
 302 }
 303 
 304 SLOW_PATH_DECL(slow_path_new_promise)
 305 {
 306     BEGIN();
 307     auto bytecode = pc-&gt;as&lt;OpNewPromise&gt;();
 308     JSPromise* result = nullptr;
 309     if (bytecode.m_isInternalPromise)
 310         result = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());
 311     else
 312         result = JSPromise::create(vm, globalObject-&gt;promiseStructure());
 313     RETURN(result);
 314 }
 315 
 316 template&lt;typename JSClass, typename Bytecode&gt;
 317 static JSClass* createInternalFieldObject(JSGlobalObject* globalObject, VM&amp; vm, CodeBlock* codeBlock, const Bytecode&amp; bytecode, JSObject* constructorAsObject, Structure* baseStructure)
 318 {
 319     auto scope = DECLARE_THROW_SCOPE(vm);
 320 
 321     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructorAsObject, baseStructure);
 322     RETURN_IF_EXCEPTION(scope, nullptr);
 323     JSClass* result = JSClass::create(vm, structure);
 324 
 325     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);
 326     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {
 327         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;
 328         if (!cachedCallee)
 329             cachedCallee.set(vm, codeBlock, constructor);
 330         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 331             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 332     }
 333     RELEASE_AND_RETURN(scope, result);
 334 }
 335 
 336 SLOW_PATH_DECL(slow_path_create_generator)
 337 {
 338     BEGIN();
 339     auto bytecode = pc-&gt;as&lt;OpCreateGenerator&gt;();
 340     RETURN(createInternalFieldObject&lt;JSGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;generatorStructure()));
 341 }
 342 
 343 SLOW_PATH_DECL(slow_path_create_async_generator)
 344 {
 345     BEGIN();
 346     auto bytecode = pc-&gt;as&lt;OpCreateAsyncGenerator&gt;();
 347     RETURN(createInternalFieldObject&lt;JSAsyncGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;asyncGeneratorStructure()));
 348 }
 349 
 350 SLOW_PATH_DECL(slow_path_new_generator)
 351 {
 352     BEGIN();
 353     auto bytecode = pc-&gt;as&lt;OpNewGenerator&gt;();
 354     JSGenerator* result = JSGenerator::create(vm, globalObject-&gt;generatorStructure());
 355     RETURN(result);
 356 }
 357 
 358 SLOW_PATH_DECL(slow_path_to_this)
 359 {
 360     BEGIN();
 361     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
 362     auto&amp; metadata = bytecode.metadata(codeBlock);
 363     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 364     if (v1.isCell()) {
 365         StructureID myStructureID = v1.asCell()-&gt;structureID();
 366         StructureID otherStructureID = metadata.m_cachedStructureID;
 367         if (myStructureID != otherStructureID) {
 368             if (otherStructureID)
 369                 metadata.m_toThisStatus = ToThisConflicted;
 370             metadata.m_cachedStructureID = myStructureID;
 371             vm.heap.writeBarrier(codeBlock, vm.getStructure(myStructureID));
 372         }
 373     } else {
 374         metadata.m_toThisStatus = ToThisConflicted;
 375         metadata.m_cachedStructureID = 0;
 376     }
 377     // Note: We only need to do this value profiling here on the slow path. The fast path
 378     // just returns the input to to_this if the structure check succeeds. If the structure
 379     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 380     // different object that still has the same structure on the fast path since it&#39;ll produce
 381     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 382     // fast path.
 383     auto value = v1.toThis(globalObject, codeBlock-&gt;isStrictMode() ? StrictMode : NotStrictMode);
 384     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 385 }
 386 
 387 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 388 {
 389     BEGIN();
 390     THROW(createTDZError(globalObject));
 391 }
 392 
 393 SLOW_PATH_DECL(slow_path_check_tdz)
 394 {
 395     BEGIN();
 396     THROW(createTDZError(globalObject));
 397 }
 398 
 399 SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
 400 {
 401     BEGIN();
 402     THROW(createTypeError(globalObject, ReadonlyPropertyWriteError));
 403 }
 404 
 405 SLOW_PATH_DECL(slow_path_not)
 406 {
 407     BEGIN();
 408     auto bytecode = pc-&gt;as&lt;OpNot&gt;();
 409     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(globalObject)));
 410 }
 411 
 412 SLOW_PATH_DECL(slow_path_eq)
 413 {
 414     BEGIN();
 415     auto bytecode = pc-&gt;as&lt;OpEq&gt;();
 416     RETURN(jsBoolean(JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 417 }
 418 
 419 SLOW_PATH_DECL(slow_path_neq)
 420 {
 421     BEGIN();
 422     auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
 423     RETURN(jsBoolean(!JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 424 }
 425 
 426 SLOW_PATH_DECL(slow_path_stricteq)
 427 {
 428     BEGIN();
 429     auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
 430     RETURN(jsBoolean(JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 431 }
 432 
 433 SLOW_PATH_DECL(slow_path_nstricteq)
 434 {
 435     BEGIN();
 436     auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
 437     RETURN(jsBoolean(!JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 438 }
 439 
 440 SLOW_PATH_DECL(slow_path_less)
 441 {
 442     BEGIN();
 443     auto bytecode = pc-&gt;as&lt;OpLess&gt;();
 444     RETURN(jsBoolean(jsLess&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 445 }
 446 
 447 SLOW_PATH_DECL(slow_path_lesseq)
 448 {
 449     BEGIN();
 450     auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
 451     RETURN(jsBoolean(jsLessEq&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));
 452 }
 453 
 454 SLOW_PATH_DECL(slow_path_greater)
 455 {
 456     BEGIN();
 457     auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
 458     RETURN(jsBoolean(jsLess&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));
 459 }
 460 
 461 SLOW_PATH_DECL(slow_path_greatereq)
 462 {
 463     BEGIN();
 464     auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
 465     RETURN(jsBoolean(jsLessEq&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));
 466 }
 467 
 468 SLOW_PATH_DECL(slow_path_inc)
 469 {
 470     BEGIN();
 471     auto bytecode = pc-&gt;as&lt;OpInc&gt;();
 472     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();
 473     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);
 474     CHECK_EXCEPTION();
 475     JSValue result;
 476     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))
 477         result = JSBigInt::inc(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));
 478     else
 479         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) + 1);
 480     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });
 481 }
 482 
 483 SLOW_PATH_DECL(slow_path_dec)
 484 {
 485     BEGIN();
 486     auto bytecode = pc-&gt;as&lt;OpDec&gt;();
 487     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();
 488     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);
 489     CHECK_EXCEPTION();
 490     JSValue result;
 491     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))
 492         result = JSBigInt::dec(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));
 493     else
 494         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) - 1);
 495     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });
 496 }
 497 
 498 SLOW_PATH_DECL(slow_path_to_string)
 499 {
 500     BEGIN();
 501     auto bytecode = pc-&gt;as&lt;OpToString&gt;();
 502     RETURN(GET_C(bytecode.m_operand).jsValue().toString(globalObject));
 503 }
 504 
 505 #if ENABLE(JIT)
 506 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
 507 {
 508     UnaryArithProfile&amp; profile = metadata.m_arithProfile;
 509     profile.observeArg(operand);
 510     ASSERT(result.isNumber() || result.isBigInt());
 511     if (result.isNumber()) {
 512         if (!result.isInt32()) {
 513             if (operand.isInt32())
 514                 profile.setObservedInt32Overflow();
 515 
 516             double doubleVal = result.asNumber();
 517             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 518                 profile.setObservedNegZeroDouble();
 519             else {
 520                 profile.setObservedNonNegZeroDouble();
 521 
 522                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 523                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 524                 // done to simplify the checking algorithm.
 525                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 526                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 527                 if (int64Val &gt;= int52OverflowPoint)
 528                     profile.setObservedInt52Overflow();
 529             }
 530         }
 531     } else if (result.isBigInt())
 532         profile.setObservedBigInt();
 533     else
 534         profile.setObservedNonNumeric();
 535 }
 536 #else
 537 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp;, JSValue, JSValue) { }
 538 #endif
 539 
 540 SLOW_PATH_DECL(slow_path_negate)
 541 {
 542     BEGIN();
 543     auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
 544     auto&amp; metadata = bytecode.metadata(codeBlock);
 545     JSValue operand = GET_C(bytecode.m_operand).jsValue();
 546     JSValue primValue = operand.toPrimitive(globalObject, PreferNumber);
 547     CHECK_EXCEPTION();
 548 
 549     if (primValue.isBigInt()) {
 550         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
 551         RETURN_WITH_PROFILING(result, {
 552             updateArithProfileForUnaryArithOp(metadata, result, operand);
 553         });
 554     }
 555 
 556     JSValue result = jsNumber(-primValue.toNumber(globalObject));
 557     CHECK_EXCEPTION();
 558     RETURN_WITH_PROFILING(result, {
 559         updateArithProfileForUnaryArithOp(metadata, result, operand);
 560     });
 561 }
 562 
 563 #if ENABLE(DFG_JIT)
 564 static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock* codeBlock, const Instruction* pc, JSValue result, JSValue left, JSValue right)
 565 {
 566     BinaryArithProfile&amp; profile = *codeBlock-&gt;binaryArithProfileForPC(pc);
 567 
 568     if (result.isNumber()) {
 569         if (!result.isInt32()) {
 570             if (left.isInt32() &amp;&amp; right.isInt32())
 571                 profile.setObservedInt32Overflow();
 572 
 573             double doubleVal = result.asNumber();
 574             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 575                 profile.setObservedNegZeroDouble();
 576             else {
 577                 profile.setObservedNonNegZeroDouble();
 578 
 579                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 580                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 581                 // done to simplify the checking algorithm.
 582                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 583                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 584                 if (int64Val &gt;= int52OverflowPoint)
 585                     profile.setObservedInt52Overflow();
 586             }
 587         }
 588     } else if (result.isBigInt())
 589         profile.setObservedBigInt();
 590     else
 591         profile.setObservedNonNumeric();
 592 }
 593 #else
 594 static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock*, const Instruction*, JSValue, JSValue, JSValue) { }
 595 #endif
 596 
 597 SLOW_PATH_DECL(slow_path_to_number)
 598 {
 599     BEGIN();
 600     auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
 601     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 602     JSValue result = jsNumber(argument.toNumber(globalObject));
 603     RETURN_PROFILED(result);
 604 }
 605 
 606 SLOW_PATH_DECL(slow_path_to_numeric)
 607 {
 608     BEGIN();
 609     auto bytecode = pc-&gt;as&lt;OpToNumeric&gt;();
 610     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 611     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);
 612     CHECK_EXCEPTION();
 613     JSValue result;
 614     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))
 615         result = WTF::get&lt;JSBigInt*&gt;(resultVariant);
 616     else
 617         result = jsNumber(WTF::get&lt;double&gt;(resultVariant));
 618     RETURN_PROFILED(result);
 619 }
 620 
 621 SLOW_PATH_DECL(slow_path_to_object)
 622 {
 623     BEGIN();
 624     auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
 625     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 626     if (UNLIKELY(argument.isUndefinedOrNull())) {
 627         const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_message);
 628         if (!ident.isEmpty())
 629             THROW(createTypeError(globalObject, ident.impl()));
 630     }
 631     JSObject* result = argument.toObject(globalObject);
 632     RETURN_PROFILED(result);
 633 }
 634 
 635 SLOW_PATH_DECL(slow_path_add)
 636 {
 637     BEGIN();
 638     auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
 639     JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
 640     JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
 641 
 642     BinaryArithProfile&amp; arithProfile = *codeBlock-&gt;binaryArithProfileForPC(pc);
 643     arithProfile.observeLHSAndRHS(v1, v2);
 644 
 645     JSValue result = jsAdd(globalObject, v1, v2);
 646 
 647     RETURN_WITH_PROFILING(result, {
 648         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, v1, v2);
 649     });
 650 }
 651 
 652 // The following arithmetic and bitwise operations need to be sure to run
 653 // toNumber() on their operands in order.  (A call to toNumber() is idempotent
 654 // if an exception is already set on the CallFrame.)
 655 
 656 SLOW_PATH_DECL(slow_path_mul)
 657 {
 658     BEGIN();
 659     auto bytecode = pc-&gt;as&lt;OpMul&gt;();
 660     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 661     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 662     JSValue result = jsMul(globalObject, left, right);
 663     CHECK_EXCEPTION();
 664     RETURN_WITH_PROFILING(result, {
 665         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);
 666     });
 667 }
 668 
 669 SLOW_PATH_DECL(slow_path_sub)
 670 {
 671     BEGIN();
 672     auto bytecode = pc-&gt;as&lt;OpSub&gt;();
 673     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 674     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 675     auto leftNumeric = left.toNumeric(globalObject);
 676     CHECK_EXCEPTION();
 677     auto rightNumeric = right.toNumeric(globalObject);
 678     CHECK_EXCEPTION();
 679 
 680     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 681         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 682             JSBigInt* result = JSBigInt::sub(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 683             CHECK_EXCEPTION();
 684             RETURN_WITH_PROFILING(result, {
 685                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);
 686             });
 687         }
 688 
 689         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));
 690     }
 691 
 692     JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
 693     RETURN_WITH_PROFILING(result, {
 694         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);
 695     });
 696 }
 697 
 698 SLOW_PATH_DECL(slow_path_div)
 699 {
 700     BEGIN();
 701     auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
 702     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 703     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 704     auto leftNumeric = left.toNumeric(globalObject);
 705     CHECK_EXCEPTION();
 706     auto rightNumeric = right.toNumeric(globalObject);
 707     CHECK_EXCEPTION();
 708 
 709     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 710         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 711             JSBigInt* result = JSBigInt::divide(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 712             CHECK_EXCEPTION();
 713             RETURN_WITH_PROFILING(result, {
 714                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);
 715             });
 716         }
 717 
 718         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in division.&quot;));
 719     }
 720 
 721     double a = WTF::get&lt;double&gt;(leftNumeric);
 722     double b = WTF::get&lt;double&gt;(rightNumeric);
 723     JSValue result = jsNumber(a / b);
 724     RETURN_WITH_PROFILING(result, {
 725         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);
 726     });
 727 }
 728 
 729 SLOW_PATH_DECL(slow_path_mod)
 730 {
 731     BEGIN();
 732     auto bytecode = pc-&gt;as&lt;OpMod&gt;();
 733     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 734     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 735     auto leftNumeric = left.toNumeric(globalObject);
 736     CHECK_EXCEPTION();
 737     auto rightNumeric = right.toNumeric(globalObject);
 738     CHECK_EXCEPTION();
 739 
 740     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 741         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 742             JSBigInt* result = JSBigInt::remainder(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 743             CHECK_EXCEPTION();
 744             RETURN(result);
 745         }
 746 
 747         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));
 748     }
 749 
 750     double a = WTF::get&lt;double&gt;(leftNumeric);
 751     double b = WTF::get&lt;double&gt;(rightNumeric);
 752     RETURN(jsNumber(jsMod(a, b)));
 753 }
 754 
 755 SLOW_PATH_DECL(slow_path_pow)
 756 {
 757     BEGIN();
 758     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
 759     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 760     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 761     auto leftNumeric = left.toNumeric(globalObject);
 762     CHECK_EXCEPTION();
 763     auto rightNumeric = right.toNumeric(globalObject);
 764     CHECK_EXCEPTION();
 765 
 766     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 767         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 768             JSBigInt* result = JSBigInt::exponentiate(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 769             CHECK_EXCEPTION();
 770             RETURN(result);
 771         }
 772 
 773         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));
 774     }
 775 
 776     double a = WTF::get&lt;double&gt;(leftNumeric);
 777     double b = WTF::get&lt;double&gt;(rightNumeric);
 778 
 779     RETURN(jsNumber(operationMathPow(a, b)));
 780 }
 781 
 782 SLOW_PATH_DECL(slow_path_lshift)
 783 {
 784     BEGIN();
 785     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 786     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 787     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 788     auto leftNumeric = left.toBigIntOrInt32(globalObject);
 789     CHECK_EXCEPTION();
 790     auto rightNumeric = right.toBigIntOrInt32(globalObject);
 791     CHECK_EXCEPTION();
 792 
 793     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 794         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 795             JSBigInt* result = JSBigInt::leftShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 796             CHECK_EXCEPTION();
 797             RETURN_PROFILED(result);
 798         }
 799 
 800         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));
 801     }
 802 
 803     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 804 }
 805 
 806 SLOW_PATH_DECL(slow_path_rshift)
 807 {
 808     BEGIN();
 809     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 810     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 811     JSValue right = GET_C(bytecode.m_rhs).jsValue();
 812     auto leftNumeric = left.toBigIntOrInt32(globalObject);
 813     CHECK_EXCEPTION();
 814     auto rightNumeric = right.toBigIntOrInt32(globalObject);
 815     CHECK_EXCEPTION();
 816 
 817     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 818         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 819             JSBigInt* result = JSBigInt::signedRightShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 820             CHECK_EXCEPTION();
 821             RETURN_PROFILED(result);
 822         }
 823 
 824         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;_s));
 825     }
 826 
 827     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 828 }
 829 
 830 SLOW_PATH_DECL(slow_path_urshift)
 831 {
 832     BEGIN();
 833     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
 834     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(globalObject);
 835     if (UNLIKELY(throwScope.exception()))
 836         RETURN(JSValue());
 837     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(globalObject);
 838     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 839 }
 840 
 841 SLOW_PATH_DECL(slow_path_unsigned)
 842 {
 843     BEGIN();
 844     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
 845     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(globalObject);
 846     RETURN(jsNumber(a));
 847 }
 848 
 849 SLOW_PATH_DECL(slow_path_bitnot)
 850 {
 851     BEGIN();
 852     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
 853     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(globalObject);
 854     CHECK_EXCEPTION();
 855 
 856     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
 857         JSBigInt* result = JSBigInt::bitwiseNot(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric));
 858         CHECK_EXCEPTION();
 859         RETURN_PROFILED(result);
 860     }
 861 
 862     RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 863 }
 864 
 865 SLOW_PATH_DECL(slow_path_bitand)
 866 {
 867     BEGIN();
 868     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
 869     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);
 870     CHECK_EXCEPTION();
 871     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);
 872     CHECK_EXCEPTION();
 873     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 874         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 875             JSBigInt* result = JSBigInt::bitwiseAnd(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 876             CHECK_EXCEPTION();
 877             RETURN_PROFILED(result);
 878         }
 879 
 880         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));
 881     }
 882 
 883     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
 884 }
 885 
 886 SLOW_PATH_DECL(slow_path_bitor)
 887 {
 888     BEGIN();
 889     auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
 890     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);
 891     CHECK_EXCEPTION();
 892     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);
 893     CHECK_EXCEPTION();
 894     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 895         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 896             JSBigInt* result = JSBigInt::bitwiseOr(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 897             CHECK_EXCEPTION();
 898             RETURN_PROFILED(result);
 899         }
 900 
 901         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));
 902     }
 903 
 904     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
 905 }
 906 
 907 SLOW_PATH_DECL(slow_path_bitxor)
 908 {
 909     BEGIN();
 910     auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
 911     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);
 912     CHECK_EXCEPTION();
 913     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);
 914     CHECK_EXCEPTION();
 915     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 916         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 917             JSBigInt* result = JSBigInt::bitwiseXor(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 918             CHECK_EXCEPTION();
 919             RETURN_PROFILED(result);
 920         }
 921 
 922         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));
 923     }
 924 
 925     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
 926 }
 927 
 928 SLOW_PATH_DECL(slow_path_typeof)
 929 {
 930     BEGIN();
 931     auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
 932     RETURN(jsTypeStringForValue(globalObject, GET_C(bytecode.m_value).jsValue()));
 933 }
 934 
 935 SLOW_PATH_DECL(slow_path_is_object_or_null)
 936 {
 937     BEGIN();
 938     auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
 939     RETURN(jsBoolean(jsIsObjectTypeOrNull(globalObject, GET_C(bytecode.m_operand).jsValue())));
 940 }
 941 
 942 SLOW_PATH_DECL(slow_path_is_function)
 943 {
 944     BEGIN();
 945     auto bytecode = pc-&gt;as&lt;OpIsFunction&gt;();
 946     RETURN(jsBoolean(GET_C(bytecode.m_operand).jsValue().isFunction(vm)));
 947 }
 948 
 949 SLOW_PATH_DECL(slow_path_in_by_val)
 950 {
 951     BEGIN();
 952     auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
 953     auto&amp; metadata = bytecode.metadata(codeBlock);
 954     RETURN(jsBoolean(CommonSlowPaths::opInByVal(globalObject, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));
 955 }
 956 
 957 SLOW_PATH_DECL(slow_path_in_by_id)
 958 {
 959     BEGIN();
 960 
 961     auto bytecode = pc-&gt;as&lt;OpInById&gt;();
 962     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 963     if (!baseValue.isObject())
 964         THROW(createInvalidInParameterError(globalObject, baseValue));
 965 
 966     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(globalObject, codeBlock-&gt;identifier(bytecode.m_property))));
 967 }
 968 
 969 SLOW_PATH_DECL(slow_path_del_by_val)
 970 {
 971     BEGIN();
 972     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
 973     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 974     JSObject* baseObject = baseValue.toObject(globalObject);
 975     CHECK_EXCEPTION();
 976 
 977     JSValue subscript = GET_C(bytecode.m_property).jsValue();
 978 
 979     bool couldDelete;
 980 
 981     uint32_t i;
 982     if (subscript.getUInt32(i))
 983         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, globalObject, i);
 984     else {
 985         CHECK_EXCEPTION();
 986         auto property = subscript.toPropertyKey(globalObject);
 987         CHECK_EXCEPTION();
 988         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, property);
 989     }
 990     CHECK_EXCEPTION();
 991 
 992     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
 993         THROW(createTypeError(globalObject, UnableToDeletePropertyError));
 994 
 995     RETURN(jsBoolean(couldDelete));
 996 }
 997 
 998 SLOW_PATH_DECL(slow_path_strcat)
 999 {
1000     BEGIN();
1001     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
1002     RETURN(jsStringFromRegisterArray(globalObject, &amp;GET(bytecode.m_src), bytecode.m_count));
1003 }
1004 
1005 SLOW_PATH_DECL(slow_path_to_primitive)
1006 {
1007     BEGIN();
1008     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
1009     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(globalObject));
1010 }
1011 
1012 SLOW_PATH_DECL(slow_path_enter)
1013 {
1014     BEGIN();
1015     Heap::heap(codeBlock)-&gt;writeBarrier(codeBlock);
1016     END();
1017 }
1018 
1019 SLOW_PATH_DECL(slow_path_to_property_key)
1020 {
1021     BEGIN();
1022     auto bytecode = pc-&gt;as&lt;OpToPropertyKey&gt;();
1023     RETURN(GET_C(bytecode.m_src).jsValue().toPropertyKeyValue(globalObject));
1024 }
1025 
1026 SLOW_PATH_DECL(slow_path_get_enumerable_length)
1027 {
1028     BEGIN();
1029     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
1030     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
1031     if (enumeratorValue.isUndefinedOrNull())
1032         RETURN(jsNumber(0));
1033 
1034     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
1035 
1036     RETURN(jsNumber(enumerator-&gt;indexedLength()));
1037 }
1038 
1039 SLOW_PATH_DECL(slow_path_has_indexed_property)
1040 {
1041     BEGIN();
1042     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
1043     auto&amp; metadata = bytecode.metadata(codeBlock);
1044     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);
1045     CHECK_EXCEPTION();
1046     JSValue property = GET(bytecode.m_property).jsValue();
1047     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
1048     ASSERT(property.isUInt32AsAnyInt());
1049     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));
1050 }
1051 
1052 SLOW_PATH_DECL(slow_path_has_structure_property)
1053 {
1054     BEGIN();
1055     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
1056     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);
1057     CHECK_EXCEPTION();
1058     JSValue property = GET(bytecode.m_property).jsValue();
1059     ASSERT(property.isString());
1060     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1061     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
1062         RETURN(jsBoolean(true));
1063     JSString* string = asString(property);
1064     auto propertyName = string-&gt;toIdentifier(globalObject);
1065     CHECK_EXCEPTION();
1066     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
1067 }
1068 
1069 SLOW_PATH_DECL(slow_path_has_generic_property)
1070 {
1071     BEGIN();
1072     auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
1073     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);
1074     CHECK_EXCEPTION();
1075     JSValue property = GET(bytecode.m_property).jsValue();
1076     ASSERT(property.isString());
1077     JSString* string = asString(property);
1078     auto propertyName = string-&gt;toIdentifier(globalObject);
1079     CHECK_EXCEPTION();
1080     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));
1081 }
1082 
1083 SLOW_PATH_DECL(slow_path_get_direct_pname)
1084 {
1085     BEGIN();
1086     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
1087     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1088     JSValue property = GET(bytecode.m_property).jsValue();
1089     ASSERT(property.isString());
1090     JSString* string = asString(property);
1091     auto propertyName = string-&gt;toIdentifier(globalObject);
1092     CHECK_EXCEPTION();
1093     RETURN(baseValue.get(globalObject, propertyName));
1094 }
1095 
1096 SLOW_PATH_DECL(slow_path_get_property_enumerator)
1097 {
1098     BEGIN();
1099     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
1100     JSValue baseValue = GET(bytecode.m_base).jsValue();
1101     if (baseValue.isUndefinedOrNull())
1102         RETURN(vm.emptyPropertyNameEnumerator());
1103 
1104     JSObject* base = baseValue.toObject(globalObject);
1105     CHECK_EXCEPTION();
1106 
1107     RETURN(propertyNameEnumerator(globalObject, base));
1108 }
1109 
1110 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
1111 {
1112     BEGIN();
1113     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
1114     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1115     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
1116 
1117     JSString* propertyName = nullptr;
1118     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
1119         propertyName = enumerator-&gt;propertyNameAtIndex(index);
1120     RETURN(propertyName ? propertyName : jsNull());
1121 }
1122 
1123 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
1124 {
1125     BEGIN();
1126     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
1127     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1128     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
1129 
1130     JSString* propertyName = nullptr;
1131     if (enumerator-&gt;endStructurePropertyIndex() &lt;= index &amp;&amp; index &lt; enumerator-&gt;endGenericPropertyIndex())
1132         propertyName = enumerator-&gt;propertyNameAtIndex(index);
1133     RETURN(propertyName ? propertyName : jsNull());
1134 }
1135 
1136 SLOW_PATH_DECL(slow_path_to_index_string)
1137 {
1138     BEGIN();
1139     auto bytecode = pc-&gt;as&lt;OpToIndexString&gt;();
1140     JSValue indexValue = GET(bytecode.m_index).jsValue();
1141     ASSERT(indexValue.isUInt32AsAnyInt());
1142     RETURN(jsString(vm, Identifier::from(vm, indexValue.asUInt32AsAnyInt()).string()));
1143 }
1144 
1145 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
1146 {
1147     BEGIN();
1148     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
1149     END();
1150 }
1151 
1152 SLOW_PATH_DECL(slow_path_unreachable)
1153 {
1154     BEGIN();
1155     UNREACHABLE_FOR_PLATFORM();
1156     END();
1157 }
1158 
1159 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1160 {
1161     BEGIN();
1162     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
1163     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1164     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
1165     JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
1166     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
1167     JSScope* newScope = JSLexicalEnvironment::create(vm, globalObject, currentScope, symbolTable, initialValue);
1168     RETURN(newScope);
1169 }
1170 
1171 SLOW_PATH_DECL(slow_path_push_with_scope)
1172 {
1173     BEGIN();
1174     auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
1175     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(globalObject);
1176     CHECK_EXCEPTION();
1177 
1178     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_currentScope).Register::scope();
1179     RETURN(JSWithScope::create(vm, globalObject, currentScope, newScope));
1180 }
1181 
1182 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1183 {
1184     BEGIN();
1185     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
1186     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1187     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1188     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);
1189 
1190     CHECK_EXCEPTION();
1191 
1192     RETURN(resolvedScope);
1193 }
1194 
1195 SLOW_PATH_DECL(slow_path_resolve_scope)
1196 {
1197     BEGIN();
1198     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
1199     auto&amp; metadata = bytecode.metadata(codeBlock);
1200     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
1201     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();
1202     JSObject* resolvedScope = JSScope::resolve(globalObject, scope, ident);
1203     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1204     CHECK_EXCEPTION();
1205 
1206     ResolveType resolveType = metadata.m_resolveType;
1207 
1208     // ModuleVar does not keep the scope register value alive in DFG.
1209     ASSERT(resolveType != ModuleVar);
1210 
1211     switch (resolveType) {
1212     case GlobalProperty:
1213     case GlobalPropertyWithVarInjectionChecks:
1214     case UnresolvedProperty:
1215     case UnresolvedPropertyWithVarInjectionChecks: {
1216         if (resolvedScope-&gt;isGlobalObject()) {
1217             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
1218             bool hasProperty = globalObject-&gt;hasProperty(globalObject, ident);
1219             CHECK_EXCEPTION();
1220             if (hasProperty) {
1221                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1222                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
1223                 metadata.m_globalObject.set(vm, codeBlock, globalObject);
1224                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1225             }
1226         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1227             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
1228             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1229             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
1230             metadata.m_globalLexicalEnvironment.set(vm, codeBlock, globalLexicalEnvironment);
1231         }
1232         break;
1233     }
1234     default:
1235         break;
1236     }
1237 
1238     RETURN(resolvedScope);
1239 }
1240 
1241 SLOW_PATH_DECL(slow_path_create_rest)
1242 {
1243     BEGIN();
1244     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1245     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
1246     Structure* structure = globalObject-&gt;restParameterStructure();
1247     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
1248     JSValue* argumentsToCopyRegion = callFrame-&gt;addressOfArgumentsStart() + numParamsToSkip;
1249     RETURN(constructArray(globalObject, structure, argumentsToCopyRegion, arraySize));
1250 }
1251 
1252 SLOW_PATH_DECL(slow_path_get_by_id_with_this)
1253 {
1254     BEGIN();
1255     auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
1256     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1257     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1258     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1259     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
1260     JSValue result = baseValue.get(globalObject, ident, slot);
1261     RETURN_PROFILED(result);
1262 }
1263 
1264 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1265 {
1266     BEGIN();
1267 
1268     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1269     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1270     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1271     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1272 
1273     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1274         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1275         if (JSCell::canUseFastGetOwnProperty(structure)) {
1276             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);
1277             CHECK_EXCEPTION();
1278             if (existingAtomString) {
1279                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1280                     RETURN_PROFILED(result);
1281             }
1282         }
1283     }
1284 
1285     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1286     if (subscript.isUInt32()) {
1287         uint32_t i = subscript.asUInt32();
1288         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
1289             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(globalObject, i));
1290 
1291         RETURN_PROFILED(baseValue.get(globalObject, i, slot));
1292     }
1293 
1294     baseValue.requireObjectCoercible(globalObject);
1295     CHECK_EXCEPTION();
1296     auto property = subscript.toPropertyKey(globalObject);
1297     CHECK_EXCEPTION();
1298     RETURN_PROFILED(baseValue.get(globalObject, property, slot));
1299 }
1300 
1301 SLOW_PATH_DECL(slow_path_put_by_id_with_this)
1302 {
1303     BEGIN();
1304     auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
1305     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1306     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1307     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1308     JSValue putValue = GET_C(bytecode.m_value).jsValue();
1309     PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
1310     baseValue.putInline(globalObject, ident, putValue, slot);
1311     END();
1312 }
1313 
1314 SLOW_PATH_DECL(slow_path_put_by_val_with_this)
1315 {
1316     BEGIN();
1317     auto bytecode = pc-&gt;as&lt;OpPutByValWithThis&gt;();
1318     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1319     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1320     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1321     JSValue value = GET_C(bytecode.m_value).jsValue();
1322 
1323     auto property = subscript.toPropertyKey(globalObject);
1324     CHECK_EXCEPTION();
1325     PutPropertySlot slot(thisValue, codeBlock-&gt;isStrictMode());
1326     baseValue.put(globalObject, property, value, slot);
1327     END();
1328 }
1329 
1330 SLOW_PATH_DECL(slow_path_define_data_property)
1331 {
1332     BEGIN();
1333     auto bytecode = pc-&gt;as&lt;OpDefineDataProperty&gt;();
1334     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1335     JSValue property = GET_C(bytecode.m_property).jsValue();
1336     JSValue value = GET_C(bytecode.m_value).jsValue();
1337     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1338     ASSERT(attributes.isInt32());
1339 
1340     auto propertyName = property.toPropertyKey(globalObject);
1341     CHECK_EXCEPTION();
1342     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
1343     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1344     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);
1345     END();
1346 }
1347 
1348 SLOW_PATH_DECL(slow_path_define_accessor_property)
1349 {
1350     BEGIN();
1351     auto bytecode = pc-&gt;as&lt;OpDefineAccessorProperty&gt;();
1352     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1353     JSValue property = GET_C(bytecode.m_property).jsValue();
1354     JSValue getter = GET_C(bytecode.m_getter).jsValue();
1355     JSValue setter = GET_C(bytecode.m_setter).jsValue();
1356     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1357     ASSERT(attributes.isInt32());
1358 
1359     auto propertyName = property.toPropertyKey(globalObject);
1360     CHECK_EXCEPTION();
1361     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
1362     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
1363     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);
1364     END();
1365 }
1366 
1367 SLOW_PATH_DECL(slow_path_throw_static_error)
1368 {
1369     BEGIN();
1370     auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
1371     JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
1372     RELEASE_ASSERT(errorMessageValue.isString());
1373     String errorMessage = asString(errorMessageValue)-&gt;value(globalObject);
1374     ErrorType errorType = bytecode.m_errorType;
1375     THROW(createError(globalObject, errorType, errorMessage));
1376 }
1377 
1378 SLOW_PATH_DECL(slow_path_new_array_with_spread)
1379 {
1380     BEGIN();
1381     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
1382     int numItems = bytecode.m_argc;
1383     ASSERT(numItems &gt;= 0);
1384     const BitVector&amp; bitVector = codeBlock-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);
1385 
1386     JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
1387 
1388     if (numItems == 1 &amp;&amp; bitVector.get(0)) {
1389         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous);
1390         if (isCopyOnWrite(structure-&gt;indexingMode())) {
1391             JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, jsCast&lt;JSImmutableButterfly*&gt;(values[0]));
1392             RETURN(result);
1393         }
1394     }
1395 
1396     Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
1397     for (int i = 0; i &lt; numItems; i++) {
1398         if (bitVector.get(i)) {
1399             JSValue value = values[-i];
1400             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);
1401             checkedArraySize += array-&gt;publicLength();
1402         } else
1403             checkedArraySize += 1;
1404     }
1405     if (UNLIKELY(checkedArraySize.hasOverflowed()))
1406         THROW(createOutOfMemoryError(globalObject));
1407 
1408     unsigned arraySize = checkedArraySize.unsafeGet();
1409     if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
1410         THROW(createOutOfMemoryError(globalObject));
1411 
1412     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
1413 
1414     JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
1415     if (UNLIKELY(!result))
1416         THROW(createOutOfMemoryError(globalObject));
1417     CHECK_EXCEPTION();
1418 
1419     unsigned index = 0;
1420     for (int i = 0; i &lt; numItems; i++) {
1421         JSValue value = values[-i];
1422         if (bitVector.get(i)) {
1423             // We are spreading.
1424             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);
1425             for (unsigned i = 0; i &lt; array-&gt;publicLength(); i++) {
1426                 RELEASE_ASSERT(array-&gt;get(i));
1427                 result-&gt;putDirectIndex(globalObject, index, array-&gt;get(i));
1428                 CHECK_EXCEPTION();
1429                 ++index;
1430             }
1431         } else {
1432             // We are not spreading.
1433             result-&gt;putDirectIndex(globalObject, index, value);
1434             CHECK_EXCEPTION();
1435             ++index;
1436         }
1437     }
1438 
1439     RETURN(result);
1440 }
1441 
1442 SLOW_PATH_DECL(slow_path_new_array_buffer)
1443 {
1444     BEGIN();
1445     auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
1446     ASSERT(bytecode.m_immutableButterfly.isConstant());
1447     JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
1448     auto&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;
1449 
1450     IndexingType indexingMode = profile.selectIndexingType();
1451     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);
1452     ASSERT(isCopyOnWrite(indexingMode));
1453     ASSERT(!structure-&gt;outOfLineCapacity());
1454 
1455     if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
1456         auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
1457         for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
1458             newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
1459         immutableButterfly = newButterfly;
1460 
1461         // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
1462         // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
1463         // a compilation thread.
1464         WTF::storeStoreFence();
1465         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly).set(vm, codeBlock, immutableButterfly);
1466         WTF::storeStoreFence();
1467     }
1468 
1469     JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
1470     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || globalObject-&gt;isHavingABadTime());
1471     ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
1472     RETURN(result);
1473 }
1474 
1475 SLOW_PATH_DECL(slow_path_spread)
1476 {
1477     BEGIN();
1478 
1479     auto bytecode = pc-&gt;as&lt;OpSpread&gt;();
1480     JSValue iterable = GET_C(bytecode.m_argument).jsValue();
1481 
1482     if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
1483         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
1484         if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
1485             // JSImmutableButterfly::createFromArray does not consult the prototype chain,
1486             // so we must be sure that not consulting the prototype chain would
1487             // produce the same value during iteration.
1488             RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));
1489         }
1490     }
1491 
1492     JSArray* array;
1493     {
1494         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
1495         CallData callData;
1496         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
1497         ASSERT(callType != CallType::None);
1498 
1499         MarkedArgumentBuffer arguments;
1500         arguments.append(iterable);
1501         ASSERT(!arguments.hasOverflowed());
1502         JSValue arrayResult = call(globalObject, iterationFunction, callType, callData, jsNull(), arguments);
1503         CHECK_EXCEPTION();
1504         array = jsCast&lt;JSArray*&gt;(arrayResult);
1505     }
1506 
1507     RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));
1508 }
1509 
1510 } // namespace JSC
    </pre>
  </body>
</html>
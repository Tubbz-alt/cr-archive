<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/RangeInputType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RadioNodeList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RangeInputType.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/RangeInputType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
118 {
119     ASSERT(element());
120     const Decimal minimum = parseToNumber(element()-&gt;attributeWithoutSynchronization(minAttr), rangeDefaultMinimum);
121     const Decimal maximum = ensureMaximum(parseToNumber(element()-&gt;attributeWithoutSynchronization(maxAttr), rangeDefaultMaximum), minimum, rangeDefaultMaximum);
122 
123     const AtomString&amp; precisionValue = element()-&gt;attributeWithoutSynchronization(precisionAttr);
124     if (!precisionValue.isNull()) {
125         const Decimal step = equalLettersIgnoringASCIICase(precisionValue, &quot;float&quot;) ? Decimal::nan() : 1;
126         return StepRange(minimum, RangeLimitations::Valid, minimum, maximum, step, rangeStepDescription);
127     }
128 
129     const Decimal step = StepRange::parseStep(anyStepHandling, rangeStepDescription, element()-&gt;attributeWithoutSynchronization(stepAttr));
130     return StepRange(minimum, RangeLimitations::Valid, minimum, maximum, step, rangeStepDescription);
131 }
132 
133 bool RangeInputType::isSteppable() const
134 {
135     return true;
136 }
137 
<span class="line-removed">138 #if !PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">139 </span>
140 void RangeInputType::handleMouseDownEvent(MouseEvent&amp; event)
141 {
142     ASSERT(element());
143     if (element()-&gt;isDisabledFormControl())
144         return;
145 
146     if (event.button() != LeftButton || !is&lt;Node&gt;(event.target()))
147         return;
148     ASSERT(element()-&gt;shadowRoot());
149     auto&amp; targetNode = downcast&lt;Node&gt;(*event.target());
150     if (&amp;targetNode != element() &amp;&amp; !targetNode.isDescendantOf(element()-&gt;userAgentShadowRoot().get()))
151         return;
152     auto&amp; thumb = typedSliderThumbElement();
153     if (&amp;targetNode == &amp;thumb)
154         return;
155     thumb.dragFrom(event.absoluteLocation());
156 }
157 
<span class="line-removed">158 #endif</span>
<span class="line-removed">159 </span>
160 #if ENABLE(TOUCH_EVENTS)
161 void RangeInputType::handleTouchEvent(TouchEvent&amp; event)
162 {
163 #if PLATFORM(IOS_FAMILY)
164     typedSliderThumbElement().handleTouchEvent(event);
165 #elif ENABLE(TOUCH_SLIDER)
166     ASSERT(element());
167     if (element()-&gt;isDisabledFormControl())
168         return;
169 
170     if (event.type() == eventNames().touchendEvent) {
171         event.setDefaultHandled();
172         return;
173     }
174 
175     RefPtr&lt;TouchList&gt; touches = event.targetTouches();
176     if (touches-&gt;length() == 1) {
177         typedSliderThumbElement().setPositionFromPoint(touches-&gt;item(0)-&gt;absoluteLocation());
178         event.setDefaultHandled();
179     }
</pre>
<hr />
<pre>
312 
313 String RangeInputType::serialize(const Decimal&amp; value) const
314 {
315     if (!value.isFinite())
316         return String();
317     return serializeForNumberType(value);
318 }
319 
320 // FIXME: Could share this with BaseClickableWithKeyInputType and BaseCheckableInputType if we had a common base class.
321 void RangeInputType::accessKeyAction(bool sendMouseEvents)
322 {
323     InputType::accessKeyAction(sendMouseEvents);
324 
325     if (auto* element = this-&gt;element())
326         element-&gt;dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
327 }
328 
329 void RangeInputType::attributeChanged(const QualifiedName&amp; name)
330 {
331     // FIXME: Don&#39;t we need to do this work for precisionAttr too?
<span class="line-modified">332     if (name == maxAttr || name == minAttr) {</span>
333         // Sanitize the value.
334         if (auto* element = this-&gt;element()) {
335             if (element-&gt;hasDirtyValue())
336                 element-&gt;setValue(element-&gt;value());
337         }
338         typedSliderThumbElement().setPositionFromValue();
339     }
340     InputType::attributeChanged(name);
341 }
342 
343 void RangeInputType::setValue(const String&amp; value, bool valueChanged, TextFieldEventBehavior eventBehavior)
344 {
345     InputType::setValue(value, valueChanged, eventBehavior);
346 
347     if (!valueChanged)
348         return;
349 
350     if (eventBehavior == DispatchNoEvent) {
351         ASSERT(element());
352         element()-&gt;setTextAsOfLastFormControlChangeEvent(value);
</pre>
</td>
<td>
<hr />
<pre>
118 {
119     ASSERT(element());
120     const Decimal minimum = parseToNumber(element()-&gt;attributeWithoutSynchronization(minAttr), rangeDefaultMinimum);
121     const Decimal maximum = ensureMaximum(parseToNumber(element()-&gt;attributeWithoutSynchronization(maxAttr), rangeDefaultMaximum), minimum, rangeDefaultMaximum);
122 
123     const AtomString&amp; precisionValue = element()-&gt;attributeWithoutSynchronization(precisionAttr);
124     if (!precisionValue.isNull()) {
125         const Decimal step = equalLettersIgnoringASCIICase(precisionValue, &quot;float&quot;) ? Decimal::nan() : 1;
126         return StepRange(minimum, RangeLimitations::Valid, minimum, maximum, step, rangeStepDescription);
127     }
128 
129     const Decimal step = StepRange::parseStep(anyStepHandling, rangeStepDescription, element()-&gt;attributeWithoutSynchronization(stepAttr));
130     return StepRange(minimum, RangeLimitations::Valid, minimum, maximum, step, rangeStepDescription);
131 }
132 
133 bool RangeInputType::isSteppable() const
134 {
135     return true;
136 }
137 


138 void RangeInputType::handleMouseDownEvent(MouseEvent&amp; event)
139 {
140     ASSERT(element());
141     if (element()-&gt;isDisabledFormControl())
142         return;
143 
144     if (event.button() != LeftButton || !is&lt;Node&gt;(event.target()))
145         return;
146     ASSERT(element()-&gt;shadowRoot());
147     auto&amp; targetNode = downcast&lt;Node&gt;(*event.target());
148     if (&amp;targetNode != element() &amp;&amp; !targetNode.isDescendantOf(element()-&gt;userAgentShadowRoot().get()))
149         return;
150     auto&amp; thumb = typedSliderThumbElement();
151     if (&amp;targetNode == &amp;thumb)
152         return;
153     thumb.dragFrom(event.absoluteLocation());
154 }
155 


156 #if ENABLE(TOUCH_EVENTS)
157 void RangeInputType::handleTouchEvent(TouchEvent&amp; event)
158 {
159 #if PLATFORM(IOS_FAMILY)
160     typedSliderThumbElement().handleTouchEvent(event);
161 #elif ENABLE(TOUCH_SLIDER)
162     ASSERT(element());
163     if (element()-&gt;isDisabledFormControl())
164         return;
165 
166     if (event.type() == eventNames().touchendEvent) {
167         event.setDefaultHandled();
168         return;
169     }
170 
171     RefPtr&lt;TouchList&gt; touches = event.targetTouches();
172     if (touches-&gt;length() == 1) {
173         typedSliderThumbElement().setPositionFromPoint(touches-&gt;item(0)-&gt;absoluteLocation());
174         event.setDefaultHandled();
175     }
</pre>
<hr />
<pre>
308 
309 String RangeInputType::serialize(const Decimal&amp; value) const
310 {
311     if (!value.isFinite())
312         return String();
313     return serializeForNumberType(value);
314 }
315 
316 // FIXME: Could share this with BaseClickableWithKeyInputType and BaseCheckableInputType if we had a common base class.
317 void RangeInputType::accessKeyAction(bool sendMouseEvents)
318 {
319     InputType::accessKeyAction(sendMouseEvents);
320 
321     if (auto* element = this-&gt;element())
322         element-&gt;dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
323 }
324 
325 void RangeInputType::attributeChanged(const QualifiedName&amp; name)
326 {
327     // FIXME: Don&#39;t we need to do this work for precisionAttr too?
<span class="line-modified">328     if (name == maxAttr || name == minAttr || name == valueAttr) {</span>
329         // Sanitize the value.
330         if (auto* element = this-&gt;element()) {
331             if (element-&gt;hasDirtyValue())
332                 element-&gt;setValue(element-&gt;value());
333         }
334         typedSliderThumbElement().setPositionFromValue();
335     }
336     InputType::attributeChanged(name);
337 }
338 
339 void RangeInputType::setValue(const String&amp; value, bool valueChanged, TextFieldEventBehavior eventBehavior)
340 {
341     InputType::setValue(value, valueChanged, eventBehavior);
342 
343     if (!valueChanged)
344         return;
345 
346     if (eventBehavior == DispatchNoEvent) {
347         ASSERT(element());
348         element()-&gt;setTextAsOfLastFormControlChangeEvent(value);
</pre>
</td>
</tr>
</table>
<center><a href="RadioNodeList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RangeInputType.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
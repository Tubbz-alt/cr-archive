<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Autocapitalize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CanvasBase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CanvasBase.h&quot;
 28 
 29 #include &quot;CSSCanvasValue.h&quot;
 30 #include &quot;CanvasRenderingContext.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;FloatRect.h&quot;
 33 #include &quot;InspectorInstrumentation.h&quot;



 34 #include &lt;wtf/Vector.h&gt;
 35 


 36 namespace WebCore {
 37 
<span class="line-modified"> 38 CanvasBase::CanvasBase()</span>









 39 {
 40 }
 41 
 42 CanvasBase::~CanvasBase()
 43 {
<span class="line-removed"> 44     ASSERT(!m_context); // Should have been set to null by base class.</span>
 45     ASSERT(m_didNotifyObserversCanvasDestroyed);
 46     ASSERT(m_observers.isEmpty());


















 47 }
 48 
<span class="line-modified"> 49 CanvasRenderingContext* CanvasBase::renderingContext() const</span>
 50 {
<span class="line-modified"> 51     return m_context.get();</span>




































 52 }
 53 
 54 void CanvasBase::addObserver(CanvasObserver&amp; observer)
 55 {
 56     m_observers.add(&amp;observer);
 57 
 58     if (is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
 59         InspectorInstrumentation::didChangeCSSCanvasClientNodes(*this);
 60 }
 61 
 62 void CanvasBase::removeObserver(CanvasObserver&amp; observer)
 63 {
 64     m_observers.remove(&amp;observer);
 65 
 66     if (is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
 67         InspectorInstrumentation::didChangeCSSCanvasClientNodes(*this);
 68 }
 69 
 70 void CanvasBase::notifyObserversCanvasChanged(const FloatRect&amp; rect)
 71 {
 72     for (auto&amp; observer : copyToVector(m_observers))
 73         observer-&gt;canvasChanged(*this, rect);
 74 }
 75 
 76 void CanvasBase::notifyObserversCanvasResized()
 77 {
 78     for (auto&amp; observer : copyToVector(m_observers))
 79         observer-&gt;canvasResized(*this);
 80 }
 81 
 82 void CanvasBase::notifyObserversCanvasDestroyed()
 83 {
 84     ASSERT(!m_didNotifyObserversCanvasDestroyed);
 85 
 86     for (auto&amp; observer : copyToVector(m_observers))
 87         observer-&gt;canvasDestroyed(*this);
 88 
 89     m_observers.clear();
 90 
<span class="line-modified"> 91 #ifndef NDEBUG</span>
 92     m_didNotifyObserversCanvasDestroyed = true;
 93 #endif
 94 }
 95 
 96 HashSet&lt;Element*&gt; CanvasBase::cssCanvasClients() const
 97 {
 98     HashSet&lt;Element*&gt; cssCanvasClients;
 99     for (auto&amp; observer : m_observers) {
100         if (!is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
101             continue;
102 
103         auto clients = downcast&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer)-&gt;ownerValue().clients();
104         for (auto&amp; entry : clients) {
105             if (RefPtr&lt;Element&gt; element = entry.key-&gt;element())
106                 cssCanvasClients.add(element.get());
107         }
108     }
109     return cssCanvasClients;
110 }
111 
112 bool CanvasBase::callTracingActive() const
113 {
<span class="line-modified">114     return m_context &amp;&amp; m_context-&gt;callTracingActive();</span>
















































115 }
116 
117 }
</pre>
</td>
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CanvasBase.h&quot;
 28 
 29 #include &quot;CSSCanvasValue.h&quot;
 30 #include &quot;CanvasRenderingContext.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;FloatRect.h&quot;
 33 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added"> 34 #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
<span class="line-added"> 35 #include &lt;JavaScriptCore/JSLock.h&gt;</span>
<span class="line-added"> 36 #include &lt;atomic&gt;</span>
 37 #include &lt;wtf/Vector.h&gt;
 38 
<span class="line-added"> 39 static std::atomic&lt;size_t&gt; s_activePixelMemory { 0 };</span>
<span class="line-added"> 40 </span>
 41 namespace WebCore {
 42 
<span class="line-modified"> 43 #if USE(CG)</span>
<span class="line-added"> 44 // FIXME: It seems strange that the default quality is not the one that is literally named &quot;default&quot;.</span>
<span class="line-added"> 45 // Should fix names to make this easier to understand, or write an excellent comment here explaining why not.</span>
<span class="line-added"> 46 const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Low;</span>
<span class="line-added"> 47 #else</span>
<span class="line-added"> 48 const InterpolationQuality defaultInterpolationQuality = InterpolationQuality::Default;</span>
<span class="line-added"> 49 #endif</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 CanvasBase::CanvasBase(IntSize size)</span>
<span class="line-added"> 52     : m_size(size)</span>
 53 {
 54 }
 55 
 56 CanvasBase::~CanvasBase()
 57 {

 58     ASSERT(m_didNotifyObserversCanvasDestroyed);
 59     ASSERT(m_observers.isEmpty());
<span class="line-added"> 60     ASSERT(!m_imageBuffer);</span>
<span class="line-added"> 61 }</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 GraphicsContext* CanvasBase::drawingContext() const</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     auto* context = renderingContext();</span>
<span class="line-added"> 66     if (context &amp;&amp; !context-&gt;is2d() &amp;&amp; !context-&gt;isOffscreen2d())</span>
<span class="line-added"> 67         return nullptr;</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69     return buffer() ? &amp;m_imageBuffer-&gt;context() : nullptr;</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 GraphicsContext* CanvasBase::existingDrawingContext() const</span>
<span class="line-added"> 73 {</span>
<span class="line-added"> 74     if (!hasCreatedImageBuffer())</span>
<span class="line-added"> 75         return nullptr;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77     return drawingContext();</span>
 78 }
 79 
<span class="line-modified"> 80 ImageBuffer* CanvasBase::buffer() const</span>
 81 {
<span class="line-modified"> 82     if (!hasCreatedImageBuffer())</span>
<span class="line-added"> 83         createImageBuffer();</span>
<span class="line-added"> 84     return m_imageBuffer.get();</span>
<span class="line-added"> 85 }</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87 AffineTransform CanvasBase::baseTransform() const</span>
<span class="line-added"> 88 {</span>
<span class="line-added"> 89     ASSERT(hasCreatedImageBuffer());</span>
<span class="line-added"> 90     return m_imageBuffer-&gt;baseTransform();</span>
<span class="line-added"> 91 }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93 void CanvasBase::makeRenderingResultsAvailable()</span>
<span class="line-added"> 94 {</span>
<span class="line-added"> 95     if (auto* context = renderingContext())</span>
<span class="line-added"> 96         context-&gt;paintRenderingResultsToCanvas();</span>
<span class="line-added"> 97 }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99 size_t CanvasBase::memoryCost() const</span>
<span class="line-added">100 {</span>
<span class="line-added">101     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="line-added">102     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="line-added">103     // from being changed while we access it.</span>
<span class="line-added">104     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-added">105     if (!m_imageBuffer)</span>
<span class="line-added">106         return 0;</span>
<span class="line-added">107     return m_imageBuffer-&gt;memoryCost();</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
<span class="line-added">110 size_t CanvasBase::externalMemoryCost() const</span>
<span class="line-added">111 {</span>
<span class="line-added">112     // externalMemoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="line-added">113     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="line-added">114     // from being changed while we access it.</span>
<span class="line-added">115     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-added">116     if (!m_imageBuffer)</span>
<span class="line-added">117         return 0;</span>
<span class="line-added">118     return m_imageBuffer-&gt;externalMemoryCost();</span>
119 }
120 
121 void CanvasBase::addObserver(CanvasObserver&amp; observer)
122 {
123     m_observers.add(&amp;observer);
124 
125     if (is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
126         InspectorInstrumentation::didChangeCSSCanvasClientNodes(*this);
127 }
128 
129 void CanvasBase::removeObserver(CanvasObserver&amp; observer)
130 {
131     m_observers.remove(&amp;observer);
132 
133     if (is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
134         InspectorInstrumentation::didChangeCSSCanvasClientNodes(*this);
135 }
136 
137 void CanvasBase::notifyObserversCanvasChanged(const FloatRect&amp; rect)
138 {
139     for (auto&amp; observer : copyToVector(m_observers))
140         observer-&gt;canvasChanged(*this, rect);
141 }
142 
143 void CanvasBase::notifyObserversCanvasResized()
144 {
145     for (auto&amp; observer : copyToVector(m_observers))
146         observer-&gt;canvasResized(*this);
147 }
148 
149 void CanvasBase::notifyObserversCanvasDestroyed()
150 {
151     ASSERT(!m_didNotifyObserversCanvasDestroyed);
152 
153     for (auto&amp; observer : copyToVector(m_observers))
154         observer-&gt;canvasDestroyed(*this);
155 
156     m_observers.clear();
157 
<span class="line-modified">158 #if ASSERT_ENABLED</span>
159     m_didNotifyObserversCanvasDestroyed = true;
160 #endif
161 }
162 
163 HashSet&lt;Element*&gt; CanvasBase::cssCanvasClients() const
164 {
165     HashSet&lt;Element*&gt; cssCanvasClients;
166     for (auto&amp; observer : m_observers) {
167         if (!is&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer))
168             continue;
169 
170         auto clients = downcast&lt;CSSCanvasValue::CanvasObserverProxy&gt;(observer)-&gt;ownerValue().clients();
171         for (auto&amp; entry : clients) {
172             if (RefPtr&lt;Element&gt; element = entry.key-&gt;element())
173                 cssCanvasClients.add(element.get());
174         }
175     }
176     return cssCanvasClients;
177 }
178 
179 bool CanvasBase::callTracingActive() const
180 {
<span class="line-modified">181     auto* context = renderingContext();</span>
<span class="line-added">182     return context &amp;&amp; context-&gt;callTracingActive();</span>
<span class="line-added">183 }</span>
<span class="line-added">184 </span>
<span class="line-added">185 std::unique_ptr&lt;ImageBuffer&gt; CanvasBase::setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer) const</span>
<span class="line-added">186 {</span>
<span class="line-added">187     std::unique_ptr&lt;ImageBuffer&gt; returnBuffer;</span>
<span class="line-added">188     {</span>
<span class="line-added">189         auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-added">190         m_contextStateSaver = nullptr;</span>
<span class="line-added">191         returnBuffer = std::exchange(m_imageBuffer, WTFMove(buffer));</span>
<span class="line-added">192     }</span>
<span class="line-added">193 </span>
<span class="line-added">194     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())</span>
<span class="line-added">195         m_size = m_imageBuffer-&gt;internalSize();</span>
<span class="line-added">196 </span>
<span class="line-added">197     size_t previousMemoryCost = m_imageBufferCost;</span>
<span class="line-added">198     m_imageBufferCost = memoryCost();</span>
<span class="line-added">199     s_activePixelMemory += m_imageBufferCost - previousMemoryCost;</span>
<span class="line-added">200 </span>
<span class="line-added">201     auto* context = renderingContext();</span>
<span class="line-added">202     if (context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != m_imageBufferCost)</span>
<span class="line-added">203         InspectorInstrumentation::didChangeCanvasMemory(*context);</span>
<span class="line-added">204 </span>
<span class="line-added">205     if (m_imageBuffer) {</span>
<span class="line-added">206         m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);</span>
<span class="line-added">207         m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);</span>
<span class="line-added">208         m_imageBuffer-&gt;context().setStrokeThickness(1);</span>
<span class="line-added">209         m_contextStateSaver = makeUnique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
<span class="line-added">210 </span>
<span class="line-added">211         JSC::JSLockHolder lock(scriptExecutionContext()-&gt;vm());</span>
<span class="line-added">212         scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     return returnBuffer;</span>
<span class="line-added">216 }</span>
<span class="line-added">217 </span>
<span class="line-added">218 size_t CanvasBase::activePixelMemory()</span>
<span class="line-added">219 {</span>
<span class="line-added">220     return s_activePixelMemory.load();</span>
<span class="line-added">221 }</span>
<span class="line-added">222 </span>
<span class="line-added">223 void CanvasBase::resetGraphicsContextState() const</span>
<span class="line-added">224 {</span>
<span class="line-added">225     if (m_contextStateSaver) {</span>
<span class="line-added">226         // Reset to the initial graphics context state.</span>
<span class="line-added">227         m_contextStateSaver-&gt;restore();</span>
<span class="line-added">228         m_contextStateSaver-&gt;save();</span>
<span class="line-added">229     }</span>
230 }
231 
232 }
</pre>
</td>
</tr>
</table>
<center><a href="Autocapitalize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CanvasBase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IteratorOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IterationKind.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IteratorOperations.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IteratorOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,104 ***</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! JSValue iteratorNext(ExecState* exec, IterationRecord iterationRecord, JSValue argument)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue iterator = iterationRecord.iterator;
      JSValue nextFunction = iterationRecord.nextMethod;
  
      CallData nextFunctionCallData;
      CallType nextFunctionCallType = getCallData(vm, nextFunction, nextFunctionCallData);
      if (nextFunctionCallType == CallType::None)
<span class="line-modified">!         return throwTypeError(exec, scope);</span>
  
      MarkedArgumentBuffer nextFunctionArguments;
      if (!argument.isEmpty())
          nextFunctionArguments.append(argument);
      ASSERT(!nextFunctionArguments.hasOverflowed());
<span class="line-modified">!     JSValue result = call(exec, nextFunction, nextFunctionCallType, nextFunctionCallData, iterator, nextFunctionArguments);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      if (!result.isObject())
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;Iterator result interface is not an object.&quot;_s);</span>
  
      return result;
  }
  
<span class="line-modified">! JSValue iteratorValue(ExecState* exec, JSValue iterResult)</span>
  {
<span class="line-modified">!     return iterResult.get(exec, exec-&gt;vm().propertyNames-&gt;value);</span>
  }
  
<span class="line-modified">! bool iteratorComplete(ExecState* exec, JSValue iterResult)</span>
  {
<span class="line-modified">!     JSValue done = iterResult.get(exec, exec-&gt;vm().propertyNames-&gt;done);</span>
<span class="line-modified">!     return done.toBoolean(exec);</span>
  }
  
<span class="line-modified">! JSValue iteratorStep(ExecState* exec, IterationRecord iterationRecord)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue result = iteratorNext(exec, iterationRecord);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!     bool done = iteratorComplete(exec, result);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (done)
          return jsBoolean(false);
      return result;
  }
  
<span class="line-modified">! void iteratorClose(ExecState* exec, IterationRecord iterationRecord)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
      Exception* exception = nullptr;
      if (UNLIKELY(catchScope.exception())) {
          exception = catchScope.exception();
          catchScope.clearException();
      }
<span class="line-modified">!     JSValue returnFunction = iterationRecord.iterator.get(exec, vm.propertyNames-&gt;returnKeyword);</span>
      RETURN_IF_EXCEPTION(throwScope, void());
  
      if (returnFunction.isUndefined()) {
          if (exception)
<span class="line-modified">!             throwException(exec, throwScope, exception);</span>
          return;
      }
  
      CallData returnFunctionCallData;
      CallType returnFunctionCallType = getCallData(vm, returnFunction, returnFunctionCallData);
      if (returnFunctionCallType == CallType::None) {
          if (exception)
<span class="line-modified">!             throwException(exec, throwScope, exception);</span>
          else
<span class="line-modified">!             throwTypeError(exec, throwScope);</span>
          return;
      }
  
      MarkedArgumentBuffer returnFunctionArguments;
      ASSERT(!returnFunctionArguments.hasOverflowed());
<span class="line-modified">!     JSValue innerResult = call(exec, returnFunction, returnFunctionCallType, returnFunctionCallData, iterationRecord.iterator, returnFunctionArguments);</span>
  
      if (exception) {
<span class="line-modified">!         throwException(exec, throwScope, exception);</span>
          return;
      }
  
      RETURN_IF_EXCEPTION(throwScope, void());
  
      if (!innerResult.isObject()) {
<span class="line-modified">!         throwTypeError(exec, throwScope, &quot;Iterator result interface is not an object.&quot;_s);</span>
          return;
      }
  }
  
  static const PropertyOffset valuePropertyOffset = 0;
<span class="line-new-header">--- 32,104 ---</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! JSValue iteratorNext(JSGlobalObject* globalObject, IterationRecord iterationRecord, JSValue argument)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSValue iterator = iterationRecord.iterator;
      JSValue nextFunction = iterationRecord.nextMethod;
  
      CallData nextFunctionCallData;
      CallType nextFunctionCallType = getCallData(vm, nextFunction, nextFunctionCallData);
      if (nextFunctionCallType == CallType::None)
<span class="line-modified">!         return throwTypeError(globalObject, scope);</span>
  
      MarkedArgumentBuffer nextFunctionArguments;
      if (!argument.isEmpty())
          nextFunctionArguments.append(argument);
      ASSERT(!nextFunctionArguments.hasOverflowed());
<span class="line-modified">!     JSValue result = call(globalObject, nextFunction, nextFunctionCallType, nextFunctionCallData, iterator, nextFunctionArguments);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      if (!result.isObject())
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;Iterator result interface is not an object.&quot;_s);</span>
  
      return result;
  }
  
<span class="line-modified">! JSValue iteratorValue(JSGlobalObject* globalObject, JSValue iterResult)</span>
  {
<span class="line-modified">!     return iterResult.get(globalObject, globalObject-&gt;vm().propertyNames-&gt;value);</span>
  }
  
<span class="line-modified">! bool iteratorComplete(JSGlobalObject* globalObject, JSValue iterResult)</span>
  {
<span class="line-modified">!     JSValue done = iterResult.get(globalObject, globalObject-&gt;vm().propertyNames-&gt;done);</span>
<span class="line-modified">!     return done.toBoolean(globalObject);</span>
  }
  
<span class="line-modified">! JSValue iteratorStep(JSGlobalObject* globalObject, IterationRecord iterationRecord)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue result = iteratorNext(globalObject, iterationRecord);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!     bool done = iteratorComplete(globalObject, result);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (done)
          return jsBoolean(false);
      return result;
  }
  
<span class="line-modified">! void iteratorClose(JSGlobalObject* globalObject, IterationRecord iterationRecord)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
      Exception* exception = nullptr;
      if (UNLIKELY(catchScope.exception())) {
          exception = catchScope.exception();
          catchScope.clearException();
      }
<span class="line-modified">!     JSValue returnFunction = iterationRecord.iterator.get(globalObject, vm.propertyNames-&gt;returnKeyword);</span>
      RETURN_IF_EXCEPTION(throwScope, void());
  
      if (returnFunction.isUndefined()) {
          if (exception)
<span class="line-modified">!             throwException(globalObject, throwScope, exception);</span>
          return;
      }
  
      CallData returnFunctionCallData;
      CallType returnFunctionCallType = getCallData(vm, returnFunction, returnFunctionCallData);
      if (returnFunctionCallType == CallType::None) {
          if (exception)
<span class="line-modified">!             throwException(globalObject, throwScope, exception);</span>
          else
<span class="line-modified">!             throwTypeError(globalObject, throwScope);</span>
          return;
      }
  
      MarkedArgumentBuffer returnFunctionArguments;
      ASSERT(!returnFunctionArguments.hasOverflowed());
<span class="line-modified">!     JSValue innerResult = call(globalObject, returnFunction, returnFunctionCallType, returnFunctionCallData, iterationRecord.iterator, returnFunctionArguments);</span>
  
      if (exception) {
<span class="line-modified">!         throwException(globalObject, throwScope, exception);</span>
          return;
      }
  
      RETURN_IF_EXCEPTION(throwScope, void());
  
      if (!innerResult.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, throwScope, &quot;Iterator result interface is not an object.&quot;_s);</span>
          return;
      }
  }
  
  static const PropertyOffset valuePropertyOffset = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,101 ***</span>
      iteratorResultStructure = Structure::addPropertyTransition(vm, iteratorResultStructure, vm.propertyNames-&gt;done, 0, offset);
      RELEASE_ASSERT(offset == donePropertyOffset);
      return iteratorResultStructure;
  }
  
<span class="line-modified">! JSObject* createIteratorResultObject(ExecState* exec, JSValue value, bool done)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* resultObject = constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;iteratorResultObjectStructure());</span>
      resultObject-&gt;putDirect(vm, valuePropertyOffset, value);
      resultObject-&gt;putDirect(vm, donePropertyOffset, jsBoolean(done));
      return resultObject;
  }
  
<span class="line-modified">! bool hasIteratorMethod(ExecState&amp; state, JSValue value)</span>
  {
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!value.isObject())
          return false;
  
      JSObject* object = asObject(value);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue applyMethod = object-&gt;getMethod(&amp;state, callData, callType, vm.propertyNames-&gt;iteratorSymbol, &quot;Symbol.iterator property should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      return !applyMethod.isUndefined();
  }
  
<span class="line-modified">! JSValue iteratorMethod(ExecState&amp; state, JSObject* object)</span>
  {
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue method = object-&gt;getMethod(&amp;state, callData, callType, vm.propertyNames-&gt;iteratorSymbol, &quot;Symbol.iterator property should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, jsUndefined());
  
      return method;
  }
  
<span class="line-modified">! IterationRecord iteratorForIterable(ExecState&amp; state, JSObject* object, JSValue iteratorMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      CallData iteratorMethodCallData;
      CallType iteratorMethodCallType = getCallData(vm, iteratorMethod, iteratorMethodCallData);
      if (iteratorMethodCallType == CallType::None) {
<span class="line-modified">!         throwTypeError(&amp;state, scope);</span>
          return { };
      }
  
      ArgList iteratorMethodArguments;
<span class="line-modified">!     JSValue iterator = call(&amp;state, iteratorMethod, iteratorMethodCallType, iteratorMethodCallData, object, iteratorMethodArguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!iterator.isObject()) {
<span class="line-modified">!         throwTypeError(&amp;state, scope);</span>
          return { };
      }
  
<span class="line-modified">!     JSValue nextMethod = iterator.getObject()-&gt;get(&amp;state, vm.propertyNames-&gt;next);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return { iterator, nextMethod };
  }
  
<span class="line-modified">! IterationRecord iteratorForIterable(ExecState* state, JSValue iterable)</span>
  {
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue iteratorFunction = iterable.get(state, vm.propertyNames-&gt;iteratorSymbol);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      CallData iteratorFunctionCallData;
      CallType iteratorFunctionCallType = getCallData(vm, iteratorFunction, iteratorFunctionCallData);
      if (iteratorFunctionCallType == CallType::None) {
<span class="line-modified">!         throwTypeError(state, scope);</span>
          return { };
      }
  
      ArgList iteratorFunctionArguments;
<span class="line-modified">!     JSValue iterator = call(state, iteratorFunction, iteratorFunctionCallType, iteratorFunctionCallData, iterable, iteratorFunctionArguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!iterator.isObject()) {
<span class="line-modified">!         throwTypeError(state, scope);</span>
          return { };
      }
  
<span class="line-modified">!     JSValue nextMethod = iterator.getObject()-&gt;get(state, vm.propertyNames-&gt;next);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return { iterator, nextMethod };
  }
  
<span class="line-new-header">--- 144,101 ---</span>
      iteratorResultStructure = Structure::addPropertyTransition(vm, iteratorResultStructure, vm.propertyNames-&gt;done, 0, offset);
      RELEASE_ASSERT(offset == donePropertyOffset);
      return iteratorResultStructure;
  }
  
<span class="line-modified">! JSObject* createIteratorResultObject(JSGlobalObject* globalObject, JSValue value, bool done)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* resultObject = constructEmptyObject(vm, globalObject-&gt;iteratorResultObjectStructure());</span>
      resultObject-&gt;putDirect(vm, valuePropertyOffset, value);
      resultObject-&gt;putDirect(vm, donePropertyOffset, jsBoolean(done));
      return resultObject;
  }
  
<span class="line-modified">! bool hasIteratorMethod(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     auto&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!value.isObject())
          return false;
  
      JSObject* object = asObject(value);
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue applyMethod = object-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;iteratorSymbol, &quot;Symbol.iterator property should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      return !applyMethod.isUndefined();
  }
  
<span class="line-modified">! JSValue iteratorMethod(JSGlobalObject* globalObject, JSObject* object)</span>
  {
<span class="line-modified">!     auto&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      CallData callData;
      CallType callType;
<span class="line-modified">!     JSValue method = object-&gt;getMethod(globalObject, callData, callType, vm.propertyNames-&gt;iteratorSymbol, &quot;Symbol.iterator property should be callable&quot;_s);</span>
      RETURN_IF_EXCEPTION(scope, jsUndefined());
  
      return method;
  }
  
<span class="line-modified">! IterationRecord iteratorForIterable(JSGlobalObject* globalObject, JSObject* object, JSValue iteratorMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      CallData iteratorMethodCallData;
      CallType iteratorMethodCallType = getCallData(vm, iteratorMethod, iteratorMethodCallData);
      if (iteratorMethodCallType == CallType::None) {
<span class="line-modified">!         throwTypeError(globalObject, scope);</span>
          return { };
      }
  
      ArgList iteratorMethodArguments;
<span class="line-modified">!     JSValue iterator = call(globalObject, iteratorMethod, iteratorMethodCallType, iteratorMethodCallData, object, iteratorMethodArguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!iterator.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, scope);</span>
          return { };
      }
  
<span class="line-modified">!     JSValue nextMethod = iterator.getObject()-&gt;get(globalObject, vm.propertyNames-&gt;next);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return { iterator, nextMethod };
  }
  
<span class="line-modified">! IterationRecord iteratorForIterable(JSGlobalObject* globalObject, JSValue iterable)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue iteratorFunction = iterable.get(globalObject, vm.propertyNames-&gt;iteratorSymbol);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      CallData iteratorFunctionCallData;
      CallType iteratorFunctionCallType = getCallData(vm, iteratorFunction, iteratorFunctionCallData);
      if (iteratorFunctionCallType == CallType::None) {
<span class="line-modified">!         throwTypeError(globalObject, scope);</span>
          return { };
      }
  
      ArgList iteratorFunctionArguments;
<span class="line-modified">!     JSValue iterator = call(globalObject, iteratorFunction, iteratorFunctionCallType, iteratorFunctionCallData, iterable, iteratorFunctionArguments);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      if (!iterator.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, scope);</span>
          return { };
      }
  
<span class="line-modified">!     JSValue nextMethod = iterator.getObject()-&gt;get(globalObject, vm.propertyNames-&gt;next);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      return { iterator, nextMethod };
  }
  
</pre>
<center><a href="IterationKind.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IteratorOperations.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
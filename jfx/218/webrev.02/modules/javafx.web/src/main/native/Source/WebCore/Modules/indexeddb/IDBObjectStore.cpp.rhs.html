<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBObjectStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBObjectStore.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;DOMStringList.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;IDBBindingUtilities.h&quot;
 34 #include &quot;IDBCursor.h&quot;
 35 #include &quot;IDBDatabase.h&quot;
 36 #include &quot;IDBError.h&quot;
 37 #include &quot;IDBGetRecordData.h&quot;
 38 #include &quot;IDBIndex.h&quot;
 39 #include &quot;IDBKey.h&quot;
 40 #include &quot;IDBKeyRangeData.h&quot;
 41 #include &quot;IDBRequest.h&quot;
 42 #include &quot;IDBTransaction.h&quot;
 43 #include &quot;IndexedDB.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;ScriptExecutionContext.h&quot;
 47 #include &quot;ScriptState.h&quot;
 48 #include &quot;SerializedScriptValue.h&quot;
 49 #include &lt;JavaScriptCore/CatchScope.h&gt;
 50 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 51 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 52 #include &lt;wtf/Locker.h&gt;
 53 
 54 namespace WebCore {
 55 using namespace JSC;
 56 
 57 IDBObjectStore::IDBObjectStore(ScriptExecutionContext&amp; context, const IDBObjectStoreInfo&amp; info, IDBTransaction&amp; transaction)
 58     : ActiveDOMObject(&amp;context)
 59     , m_info(info)
 60     , m_originalInfo(info)
 61     , m_transaction(transaction)
 62 {
<a name="1" id="anc1"></a><span class="line-modified"> 63     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 64 
 65     suspendIfNeeded();
 66 }
 67 
 68 IDBObjectStore::~IDBObjectStore()
 69 {
<a name="2" id="anc2"></a><span class="line-modified"> 70     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 71 }
 72 
 73 const char* IDBObjectStore::activeDOMObjectName() const
 74 {
 75     return &quot;IDBObjectStore&quot;;
 76 }
 77 
<a name="3" id="anc3"></a>




 78 bool IDBObjectStore::hasPendingActivity() const
 79 {
 80     return m_transaction.hasPendingActivity();
 81 }
 82 
 83 const String&amp; IDBObjectStore::name() const
 84 {
<a name="4" id="anc4"></a><span class="line-modified"> 85     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 86     return m_info.name();
 87 }
 88 
 89 ExceptionOr&lt;void&gt; IDBObjectStore::setName(const String&amp; name)
 90 {
<a name="5" id="anc5"></a><span class="line-modified"> 91     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
 92 
 93     if (m_deleted)
 94         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
 95 
 96     if (!m_transaction.isVersionChange())
 97         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store&#39;s transaction is not a version change transaction.&quot;_s };
 98 
 99     if (!m_transaction.isActive())
100         return Exception { TransactionInactiveError, &quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The object store&#39;s transaction is not active.&quot;_s };
101 
102     if (m_info.name() == name)
103         return { };
104 
105     if (m_transaction.database().info().hasObjectStore(name))
106         return Exception { ConstraintError, makeString(&quot;Failed set property &#39;name&#39; on &#39;IDBObjectStore&#39;: The database already has an object store named &#39;&quot;, name, &quot;&#39;.&quot;) };
107 
108     m_transaction.database().renameObjectStore(*this, name);
109     m_info.rename(name);
110 
111     return { };
112 }
113 
114 const Optional&lt;IDBKeyPath&gt;&amp; IDBObjectStore::keyPath() const
115 {
<a name="6" id="anc6"></a><span class="line-modified">116     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
117     return m_info.keyPath();
118 }
119 
120 Ref&lt;DOMStringList&gt; IDBObjectStore::indexNames() const
121 {
<a name="7" id="anc7"></a><span class="line-modified">122     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
123 
124     auto indexNames = DOMStringList::create();
125 
126     if (!m_deleted) {
127         for (auto&amp; name : m_info.indexNames())
128             indexNames-&gt;append(name);
129         indexNames-&gt;sort();
130     }
131 
132     return indexNames;
133 }
134 
135 IDBTransaction&amp; IDBObjectStore::transaction()
136 {
<a name="8" id="anc8"></a><span class="line-modified">137     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
138     return m_transaction;
139 }
140 
141 bool IDBObjectStore::autoIncrement() const
142 {
<a name="9" id="anc9"></a><span class="line-modified">143     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
144     return m_info.autoIncrement();
145 }
146 
<a name="10" id="anc10"></a><span class="line-modified">147 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
148 {
149     LOG(IndexedDB, &quot;IDBObjectStore::openCursor&quot;);
<a name="11" id="anc11"></a><span class="line-modified">150     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
151 
152     if (m_deleted)
153         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
154 
155     if (!m_transaction.isActive())
156         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
157 
158     auto keyRange = function();
159     if (keyRange.hasException())
160         return keyRange.releaseException();
161     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
162 
163     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyAndValue);
164     return m_transaction.requestOpenCursor(execState, *this, info);
165 }
166 
<a name="12" id="anc12"></a><span class="line-modified">167 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
168 {
169     return doOpenCursor(execState, direction, [range = WTFMove(range)]() {
170         return range;
171     });
172 }
173 
<a name="13" id="anc13"></a><span class="line-modified">174 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
175 {
176     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
177         auto onlyResult = IDBKeyRange::only(*state, key);
178         if (onlyResult.hasException())
179             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
180 
181         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
182     });
183 }
184 
<a name="14" id="anc14"></a><span class="line-modified">185 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doOpenKeyCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
186 {
187     LOG(IndexedDB, &quot;IDBObjectStore::openKeyCursor&quot;);
<a name="15" id="anc15"></a><span class="line-modified">188     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
189 
190     if (m_deleted)
191         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
192 
193     if (!m_transaction.isActive())
194         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
195 
196     auto keyRange = function();
197     if (keyRange.hasException())
198         return keyRange.releaseException();
199 
200     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
201     auto info = IDBCursorInfo::objectStoreCursor(m_transaction, m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
202     return m_transaction.requestOpenCursor(execState, *this, info);
203 }
204 
<a name="16" id="anc16"></a><span class="line-modified">205 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
206 {
207     return doOpenKeyCursor(execState, direction, [range = WTFMove(range)]() {
208         return range;
209     });
210 }
211 
<a name="17" id="anc17"></a><span class="line-modified">212 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::openKeyCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
213 {
214     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
215         auto onlyResult = IDBKeyRange::only(*state, key);
216         if (onlyResult.hasException())
217             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
218 
219         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
220     });
221 }
222 
<a name="18" id="anc18"></a><span class="line-modified">223 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(JSGlobalObject&amp; execState, JSValue key)</span>
224 {
225     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<a name="19" id="anc19"></a><span class="line-modified">226     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
227 
228     if (m_deleted)
229         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
230 
231     if (!m_transaction.isActive())
232         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
233 
234     auto idbKey = scriptValueToIDBKey(execState, key);
235     if (!idbKey-&gt;isValid())
236         return Exception { DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
237 
238     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyAndValue });
239 }
240 
<a name="20" id="anc20"></a><span class="line-modified">241 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::get(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
242 {
243     LOG(IndexedDB, &quot;IDBObjectStore::get&quot;);
<a name="21" id="anc21"></a><span class="line-modified">244     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
245 
246     if (m_deleted)
247         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
248 
249     if (!m_transaction.isActive())
250         return Exception { TransactionInactiveError };
251 
252     IDBKeyRangeData keyRangeData(keyRange);
253     if (!keyRangeData.isValid())
254         return Exception { DataError };
255 
256     return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyAndValue });
257 }
258 
<a name="22" id="anc22"></a><span class="line-modified">259 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(JSGlobalObject&amp; execState, JSValue key)</span>
260 {
261     LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<a name="23" id="anc23"></a><span class="line-modified">262     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
263 
264     if (m_deleted)
265         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
266 
267     if (!m_transaction.isActive())
268         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
269 
270     auto idbKey = scriptValueToIDBKey(execState, key);
271     if (!idbKey-&gt;isValid())
272         return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
273 
274     return m_transaction.requestGetRecord(execState, *this, { idbKey.ptr(), IDBGetRecordDataType::KeyOnly });
275 }
276 
<a name="24" id="anc24"></a><span class="line-modified">277 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getKey(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
278 {
279     LOG(IndexedDB, &quot;IDBObjectStore::getKey&quot;);
<a name="25" id="anc25"></a><span class="line-modified">280     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
281 
282     if (m_deleted)
283         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
284 
285     if (!m_transaction.isActive())
286         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
287 
288     IDBKeyRangeData keyRangeData(keyRange);
289     if (!keyRangeData.isValid())
290         return Exception { DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
291 
292     return m_transaction.requestGetRecord(execState, *this, { keyRangeData, IDBGetRecordDataType::KeyOnly });
293 }
294 
<a name="26" id="anc26"></a><span class="line-modified">295 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::add(JSGlobalObject&amp; execState, JSValue value, JSValue key)</span>
296 {
297     RefPtr&lt;IDBKey&gt; idbKey;
298     if (!key.isUndefined())
299         idbKey = scriptValueToIDBKey(execState, key);
300     return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::NoOverwrite, InlineKeyCheck::Perform);
301 }
302 
<a name="27" id="anc27"></a><span class="line-modified">303 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::put(JSGlobalObject&amp; execState, JSValue value, JSValue key)</span>
304 {
305     RefPtr&lt;IDBKey&gt; idbKey;
306     if (!key.isUndefined())
307         idbKey = scriptValueToIDBKey(execState, key);
308     return putOrAdd(execState, value, idbKey, IndexedDB::ObjectStoreOverwriteMode::Overwrite, InlineKeyCheck::Perform);
309 }
310 
<a name="28" id="anc28"></a><span class="line-modified">311 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putForCursorUpdate(JSGlobalObject&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key)</span>
312 {
313     return putOrAdd(state, value, WTFMove(key), IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor, InlineKeyCheck::DoNotPerform);
314 }
315 
<a name="29" id="anc29"></a><span class="line-modified">316 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::putOrAdd(JSGlobalObject&amp; state, JSValue value, RefPtr&lt;IDBKey&gt; key, IndexedDB::ObjectStoreOverwriteMode overwriteMode, InlineKeyCheck inlineKeyCheck)</span>
317 {
318     VM&amp; vm = state.vm();
319     auto scope = DECLARE_CATCH_SCOPE(vm);
320 
321     LOG(IndexedDB, &quot;IDBObjectStore::putOrAdd&quot;);
<a name="30" id="anc30"></a><span class="line-modified">322     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
323 
324     auto context = scriptExecutionContextFromExecState(&amp;state);
325     if (!context)
326         return Exception { UnknownError, &quot;Unable to store record in object store because it does not have a valid script execution context&quot;_s };
327 
328     if (m_deleted)
329         return Exception { InvalidStateError, &quot;Failed to store record in an IDBObjectStore: The object store has been deleted.&quot;_s };
330 
331     if (!m_transaction.isActive())
332         return Exception { TransactionInactiveError, &quot;Failed to store record in an IDBObjectStore: The transaction is inactive or finished.&quot;_s };
333 
334     if (m_transaction.isReadOnly())
335         return Exception { ReadonlyError, &quot;Failed to store record in an IDBObjectStore: The transaction is read-only.&quot;_s };
336 
337     auto serializedValue = SerializedScriptValue::create(state, value);
338     if (UNLIKELY(scope.exception()))
339         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: An object could not be cloned.&quot;_s };
340 
341     bool privateBrowsingEnabled = false;
342     if (is&lt;Document&gt;(*context)) {
343         if (auto* page = downcast&lt;Document&gt;(*context).page())
344             privateBrowsingEnabled = page-&gt;sessionID().isEphemeral();
345     }
346 
347     if (serializedValue-&gt;hasBlobURLs() &amp;&amp; privateBrowsingEnabled) {
348         // https://bugs.webkit.org/show_bug.cgi?id=156347 - Support Blobs in private browsing.
349         return Exception { DataCloneError, &quot;Failed to store record in an IDBObjectStore: BlobURLs are not yet supported.&quot;_s };
350     }
351 
352     if (key &amp;&amp; !key-&gt;isValid())
353         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The parameter is not a valid key.&quot;_s };
354 
355     bool usesInlineKeys = !!m_info.keyPath();
356     bool usesKeyGenerator = autoIncrement();
357     if (usesInlineKeys &amp;&amp; inlineKeyCheck == InlineKeyCheck::Perform) {
358         if (key)
359             return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses in-line keys and the key parameter was provided.&quot;_s };
360 
361         RefPtr&lt;IDBKey&gt; keyPathKey = maybeCreateIDBKeyFromScriptValueAndKeyPath(state, value, m_info.keyPath().value());
362         if (keyPathKey &amp;&amp; !keyPathKey-&gt;isValid())
363             return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path yielded a value that is not a valid key.&quot;_s };
364 
365         if (!keyPathKey) {
366             if (!usesKeyGenerator)
367                 return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: Evaluating the object store&#39;s key path did not yield a value.&quot;_s };
368             if (!canInjectIDBKeyIntoScriptValue(state, value, m_info.keyPath().value()))
369                 return Exception { DataError };
370         }
371 
372         if (keyPathKey) {
373             ASSERT(!key);
374             key = keyPathKey;
375         }
376     } else if (!usesKeyGenerator &amp;&amp; !key)
377         return Exception { DataError, &quot;Failed to store record in an IDBObjectStore: The object store uses out-of-line keys and has no key generator and the key parameter was not provided.&quot;_s };
378 
379     return m_transaction.requestPutOrAdd(state, *this, WTFMove(key), *serializedValue, overwriteMode);
380 }
381 
<a name="31" id="anc31"></a><span class="line-modified">382 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(JSGlobalObject&amp; execState, IDBKeyRange* keyRange)</span>
383 {
384     return doDelete(execState, [keyRange]() {
385         return makeRefPtr(keyRange);
386     });
387 }
388 
<a name="32" id="anc32"></a><span class="line-modified">389 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doDelete(JSGlobalObject&amp; execState, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
390 {
391     LOG(IndexedDB, &quot;IDBObjectStore::deleteFunction&quot;);
<a name="33" id="anc33"></a><span class="line-modified">392     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
393 
394     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
395     // the exception for an object store being deleted.
396     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
397     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
398     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
399     if (m_deleted)
400         return Exception { InvalidStateError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
401 
402     if (!m_transaction.isActive())
403         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
404 
405     if (m_transaction.isReadOnly())
406         return Exception { ReadonlyError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
407 
408     auto keyRange = function();
409     if (keyRange.hasException())
410         return keyRange.releaseException();
411 
412     IDBKeyRangeData keyRangeData = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
413     if (!keyRangeData.isValid())
414         return Exception { DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key range.&quot;_s };
415 
416     return m_transaction.requestDeleteRecord(execState, *this, keyRangeData);
417 }
418 
<a name="34" id="anc34"></a><span class="line-modified">419 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::deleteFunction(JSGlobalObject&amp; execState, JSValue key)</span>
420 {
421     return doDelete(execState, [state=&amp;execState, key]() {
422         auto idbKey = scriptValueToIDBKey(*state, key);
423         if (!idbKey-&gt;isValid())
424             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;delete&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
425         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { (IDBKeyRange::create(WTFMove(idbKey))).ptr() };
426     });
427 }
428 
<a name="35" id="anc35"></a><span class="line-modified">429 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::clear(JSGlobalObject&amp; execState)</span>
430 {
431     LOG(IndexedDB, &quot;IDBObjectStore::clear&quot;);
<a name="36" id="anc36"></a><span class="line-modified">432     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
433 
434     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
435     // the exception for an object store being deleted.
436     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
437     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
438     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
439     if (m_deleted)
440         return Exception { InvalidStateError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
441 
442     if (!m_transaction.isActive())
443         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
444 
445     if (m_transaction.isReadOnly())
446         return Exception { ReadonlyError, &quot;Failed to execute &#39;clear&#39; on &#39;IDBObjectStore&#39;: The transaction is read-only.&quot;_s };
447 
448     return m_transaction.requestClearObjectStore(execState, *this);
449 }
450 
<a name="37" id="anc37"></a><span class="line-modified">451 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::createIndex(JSGlobalObject&amp;, const String&amp; name, IDBKeyPath&amp;&amp; keyPath, const IndexParameters&amp; parameters)</span>
452 {
453     LOG(IndexedDB, &quot;IDBObjectStore::createIndex %s (keyPath: %s, unique: %i, multiEntry: %i)&quot;, name.utf8().data(), loggingString(keyPath).utf8().data(), parameters.unique, parameters.multiEntry);
<a name="38" id="anc38"></a><span class="line-modified">454     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
455 
456     if (!m_transaction.isVersionChange())
457         return Exception { InvalidStateError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
458 
459     if (m_deleted)
460         return Exception { InvalidStateError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
461 
462     if (!m_transaction.isActive())
463         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive.&quot;_s};
464 
465     if (m_info.hasIndex(name))
466         return Exception { ConstraintError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: An index with the specified name already exists.&quot;_s };
467 
468     if (!isIDBKeyPathValid(keyPath))
469         return Exception { SyntaxError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument contains an invalid key path.&quot;_s };
470 
471     if (name.isNull())
472         return Exception { TypeError };
473 
474     if (parameters.multiEntry &amp;&amp; WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath))
475         return Exception { InvalidAccessError, &quot;Failed to execute &#39;createIndex&#39; on &#39;IDBObjectStore&#39;: The keyPath argument was an array and the multiEntry option is true.&quot;_s };
476 
477     // Install the new Index into the ObjectStore&#39;s info.
<a name="39" id="anc39"></a><span class="line-modified">478     IDBIndexInfo info = m_info.createNewIndex(m_transaction.database().info().generateNextIndexID(), name, WTFMove(keyPath), parameters.unique, parameters.multiEntry);</span>
479     m_transaction.database().didCreateIndexInfo(info);
480 
481     // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
482     auto index = m_transaction.createIndex(*this, info);
483 
484     Ref&lt;IDBIndex&gt; referencedIndex { *index };
485 
486     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
487     m_referencedIndexes.set(name, WTFMove(index));
488 
489     return referencedIndex;
490 }
491 
492 ExceptionOr&lt;Ref&lt;IDBIndex&gt;&gt; IDBObjectStore::index(const String&amp; indexName)
493 {
494     LOG(IndexedDB, &quot;IDBObjectStore::index&quot;);
<a name="40" id="anc40"></a><span class="line-modified">495     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
496 
497     if (!scriptExecutionContext())
498         return Exception { InvalidStateError }; // FIXME: Is this code tested? Is iteven reachable?
499 
500     if (m_deleted)
501         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
502 
503     if (m_transaction.isFinishedOrFinishing())
504         return Exception { InvalidStateError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The transaction is finished.&quot;_s };
505 
506     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
507     auto iterator = m_referencedIndexes.find(indexName);
508     if (iterator != m_referencedIndexes.end())
509         return Ref&lt;IDBIndex&gt; { *iterator-&gt;value };
510 
511     auto* info = m_info.infoForExistingIndex(indexName);
512     if (!info)
513         return Exception { NotFoundError, &quot;Failed to execute &#39;index&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
514 
515     auto index = makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), *info, *this);
516 
517     Ref&lt;IDBIndex&gt; referencedIndex { *index };
518 
519     m_referencedIndexes.set(indexName, WTFMove(index));
520 
521     return referencedIndex;
522 }
523 
524 ExceptionOr&lt;void&gt; IDBObjectStore::deleteIndex(const String&amp; name)
525 {
526     LOG(IndexedDB, &quot;IDBObjectStore::deleteIndex %s&quot;, name.utf8().data());
<a name="41" id="anc41"></a><span class="line-modified">527     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
528 
529     if (m_deleted)
530         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
531 
532     if (!m_transaction.isVersionChange())
533         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The database is not running a version change transaction.&quot;_s };
534 
535     if (!m_transaction.isActive())
536         return Exception { TransactionInactiveError,  &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
537 
538     if (!m_info.hasIndex(name))
539         return Exception { NotFoundError, &quot;Failed to execute &#39;deleteIndex&#39; on &#39;IDBObjectStore&#39;: The specified index was not found.&quot;_s };
540 
541     auto* info = m_info.infoForExistingIndex(name);
542     ASSERT(info);
543     m_transaction.database().didDeleteIndexInfo(*info);
544 
545     m_info.deleteIndex(name);
546 
547     {
548         Locker&lt;Lock&gt; locker(m_referencedIndexLock);
549         if (auto index = m_referencedIndexes.take(name)) {
550             index-&gt;markAsDeleted();
551             auto identifier = index-&gt;info().identifier();
552             m_deletedIndexes.add(identifier, WTFMove(index));
553         }
554     }
555 
556     m_transaction.deleteIndex(m_info.identifier(), name);
557 
558     return { };
559 }
560 
<a name="42" id="anc42"></a><span class="line-modified">561 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(JSGlobalObject&amp; execState, JSValue key)</span>
562 {
563     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
564 
565     auto idbKey = scriptValueToIDBKey(execState, key);
566 
567     return doCount(execState, IDBKeyRangeData(idbKey-&gt;isValid() ? idbKey.ptr() : nullptr));
568 }
569 
<a name="43" id="anc43"></a><span class="line-modified">570 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::count(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
571 {
572     LOG(IndexedDB, &quot;IDBObjectStore::count&quot;);
573 
574     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
575 }
576 
<a name="44" id="anc44"></a><span class="line-modified">577 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doCount(JSGlobalObject&amp; execState, const IDBKeyRangeData&amp; range)</span>
578 {
<a name="45" id="anc45"></a><span class="line-modified">579     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
580 
581     // The IDB spec for several IDBObjectStore methods states that transaction related exceptions should fire before
582     // the exception for an object store being deleted.
583     // However, a handful of W3C IDB tests expect the deleted exception even though the transaction inactive exception also applies.
584     // Additionally, Chrome and Edge agree with the test, as does Legacy IDB in WebKit.
585     // Until this is sorted out, we&#39;ll agree with the test and the majority share browsers.
586     if (m_deleted)
587         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
588 
589     if (!m_transaction.isActive())
590         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
591 
592     if (!range.isValid())
593         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s };
594 
595     return m_transaction.requestCount(execState, *this, range);
596 }
597 
<a name="46" id="anc46"></a><span class="line-modified">598 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAll(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
599 {
600     LOG(IndexedDB, &quot;IDBObjectStore::getAll&quot;);
<a name="47" id="anc47"></a><span class="line-modified">601     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
602 
603     if (m_deleted)
604         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
605 
606     if (!m_transaction.isActive())
607         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
608 
609     auto keyRange = function();
610     if (keyRange.hasException())
611         return keyRange.releaseException();
612 
613     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
614     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
615 }
616 
<a name="48" id="anc48"></a><span class="line-modified">617 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
618 {
619     return doGetAll(execState, count, [range = WTFMove(range)]() {
620         return range;
621     });
622 }
623 
<a name="49" id="anc49"></a><span class="line-modified">624 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAll(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
625 {
626     return doGetAll(execState, count, [state=&amp;execState, key]() {
627         auto onlyResult = IDBKeyRange::only(*state, key);
628         if (onlyResult.hasException())
629             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
630 
631         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
632     });
633 }
634 
<a name="50" id="anc50"></a><span class="line-modified">635 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::doGetAllKeys(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
636 {
637     LOG(IndexedDB, &quot;IDBObjectStore::getAllKeys&quot;);
<a name="51" id="anc51"></a><span class="line-modified">638     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
639 
640     if (m_deleted)
641         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The object store has been deleted.&quot;_s };
642 
643     if (!m_transaction.isActive())
644         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The transaction is inactive or finished.&quot;_s };
645 
646     auto keyRange = function();
647     if (keyRange.hasException())
648         return keyRange.releaseException();
649 
650     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
651     return m_transaction.requestGetAllObjectStoreRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
652 }
653 
<a name="52" id="anc52"></a><span class="line-modified">654 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
655 {
656     return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
657         return range;
658     });
659 }
660 
<a name="53" id="anc53"></a><span class="line-modified">661 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBObjectStore::getAllKeys(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
662 {
663     return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
664         auto onlyResult = IDBKeyRange::only(*state, key);
665         if (onlyResult.hasException())
666             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBObjectStore&#39;: The parameter is not a valid key.&quot;_s) };
667 
668         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
669     });
670 }
671 
672 void IDBObjectStore::markAsDeleted()
673 {
<a name="54" id="anc54"></a><span class="line-modified">674     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
675     m_deleted = true;
676 }
677 
678 void IDBObjectStore::rollbackForVersionChangeAbort()
679 {
<a name="55" id="anc55"></a><span class="line-modified">680     ASSERT(canCurrentThreadAccessThreadLocalData(m_transaction.database().originThread()));</span>
681 
682     String currentName = m_info.name();
683     m_info = m_originalInfo;
684 
685     auto&amp; databaseInfo = transaction().database().info();
686     auto* objectStoreInfo = databaseInfo.infoForExistingObjectStore(m_info.identifier());
687     if (!objectStoreInfo) {
688         m_info.rename(currentName);
689         m_deleted = true;
690     } else {
691         m_deleted = false;
692 
693         HashSet&lt;uint64_t&gt; indexesToRemove;
694         for (auto indexIdentifier : objectStoreInfo-&gt;indexMap().keys()) {
695             if (!objectStoreInfo-&gt;hasIndex(indexIdentifier))
696                 indexesToRemove.add(indexIdentifier);
697         }
698 
699         for (auto indexIdentifier : indexesToRemove)
700             m_info.deleteIndex(indexIdentifier);
701     }
702 
703     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
704 
705     Vector&lt;uint64_t&gt; identifiersToRemove;
706     for (auto&amp; iterator : m_deletedIndexes) {
707         if (m_info.hasIndex(iterator.key)) {
708             auto name = iterator.value-&gt;info().name();
709             m_referencedIndexes.set(name, WTFMove(iterator.value));
710             identifiersToRemove.append(iterator.key);
711         }
712     }
713 
714     for (auto identifier : identifiersToRemove)
715         m_deletedIndexes.remove(identifier);
716 
717     for (auto&amp; index : m_referencedIndexes.values())
718         index-&gt;rollbackInfoForVersionChangeAbort();
719 }
720 
721 void IDBObjectStore::visitReferencedIndexes(SlotVisitor&amp; visitor) const
722 {
723     Locker&lt;Lock&gt; locker(m_referencedIndexLock);
724     for (auto&amp; index : m_referencedIndexes.values())
725         visitor.addOpaqueRoot(index.get());
726     for (auto&amp; index : m_deletedIndexes.values())
727         visitor.addOpaqueRoot(index.get());
728 }
729 
730 void IDBObjectStore::renameReferencedIndex(IDBIndex&amp; index, const String&amp; newName)
731 {
732     LOG(IndexedDB, &quot;IDBObjectStore::renameReferencedIndex&quot;);
733 
734     auto* indexInfo = m_info.infoForExistingIndex(index.info().identifier());
735     ASSERT(indexInfo);
736     indexInfo-&gt;rename(newName);
737 
738     ASSERT(m_referencedIndexes.contains(index.info().name()));
739     ASSERT(!m_referencedIndexes.contains(newName));
740     ASSERT(m_referencedIndexes.get(index.info().name()) == &amp;index);
741 
742     m_referencedIndexes.set(newName, m_referencedIndexes.take(index.info().name()));
743 }
744 
745 void IDBObjectStore::ref()
746 {
747     m_transaction.ref();
748 }
749 
750 void IDBObjectStore::deref()
751 {
752     m_transaction.deref();
753 }
754 
755 } // namespace WebCore
756 
757 #endif // ENABLE(INDEXED_DATABASE)
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>
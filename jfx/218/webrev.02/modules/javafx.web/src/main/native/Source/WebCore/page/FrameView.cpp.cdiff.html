<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameTree.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;FrameView.h&quot;
  
  #include &quot;AXObjectCache.h&quot;
<span class="line-added">+ #include &quot;BackForwardCache.h&quot;</span>
  #include &quot;BackForwardController.h&quot;
  #include &quot;CSSAnimationController.h&quot;
  #include &quot;CachedImage.h&quot;
  #include &quot;CachedResourceLoader.h&quot;
  #include &quot;Chrome.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,10 ***</span>
<span class="line-new-header">--- 39,11 ---</span>
  #include &quot;DOMWindow.h&quot;
  #include &quot;DebugPageOverlays.h&quot;
  #include &quot;DeprecatedGlobalSettings.h&quot;
  #include &quot;DocumentLoader.h&quot;
  #include &quot;DocumentMarkerController.h&quot;
<span class="line-added">+ #include &quot;Editor.h&quot;</span>
  #include &quot;EventHandler.h&quot;
  #include &quot;EventNames.h&quot;
  #include &quot;FloatRect.h&quot;
  #include &quot;FocusController.h&quot;
  #include &quot;Frame.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MemoryCache.h&quot;
  #include &quot;OverflowEvent.h&quot;
  #include &quot;Page.h&quot;
<span class="line-removed">- #include &quot;PageCache.h&quot;</span>
  #include &quot;PageOverlayController.h&quot;
  #include &quot;ProgressTracker.h&quot;
  #include &quot;RenderEmbeddedObject.h&quot;
  #include &quot;RenderFullScreen.h&quot;
  #include &quot;RenderIFrame.h&quot;
<span class="line-new-header">--- 68,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,11 ***</span>
  #include &quot;StyleScope.h&quot;
  #include &quot;TextResourceDecoder.h&quot;
  #include &quot;TiledBacking.h&quot;
  #include &quot;VelocityData.h&quot;
  #include &quot;VisualViewport.h&quot;
<span class="line-modified">! #include &quot;WheelEventTestTrigger.h&quot;</span>
  #include &lt;wtf/text/TextStream.h&gt;
  
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/MemoryPressureHandler.h&gt;
  #include &lt;wtf/Ref.h&gt;
<span class="line-new-header">--- 100,11 ---</span>
  #include &quot;StyleScope.h&quot;
  #include &quot;TextResourceDecoder.h&quot;
  #include &quot;TiledBacking.h&quot;
  #include &quot;VelocityData.h&quot;
  #include &quot;VisualViewport.h&quot;
<span class="line-modified">! #include &quot;WheelEventTestMonitor.h&quot;</span>
  #include &lt;wtf/text/TextStream.h&gt;
  
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/MemoryPressureHandler.h&gt;
  #include &lt;wtf/Ref.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,11 ***</span>
  
  #if PLATFORM(MAC)
  #include &quot;LocalDefaultSystemAppearance.h&quot;
  #endif
  
<span class="line-modified">! #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), Layout, &quot;%p - FrameView::&quot; fmt, this, ##__VA_ARGS__)</span>
  
  namespace WebCore {
  
  using namespace HTMLNames;
  
<span class="line-new-header">--- 126,15 ---</span>
  
  #if PLATFORM(MAC)
  #include &quot;LocalDefaultSystemAppearance.h&quot;
  #endif
  
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+ #include &quot;LayoutContext.h&quot;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameView::&quot; fmt, this, &amp;frame(), frame().isMainFrame(), ##__VA_ARGS__)</span>
  
  namespace WebCore {
  
  using namespace HTMLNames;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 522,37 ***</span>
          setCanHaveScrollbars(false);
      else
          setCanHaveScrollbars(true);
  }
  
<span class="line-modified">! Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)</span>
  {
      // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
<span class="line-modified">!     Document* doc = frame().document();</span>
  
      // Try the &lt;body&gt; element first as a scrollbar source.
<span class="line-modified">!     HTMLElement* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;</span>
<span class="line-modified">!     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))</span>
<span class="line-modified">!         return RenderScrollbar::createCustomScrollbar(*this, orientation, body);</span>
  
      // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
<span class="line-modified">!     Element* docElement = doc ? doc-&gt;documentElement() : nullptr;</span>
<span class="line-modified">!     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))</span>
<span class="line-modified">!         return RenderScrollbar::createCustomScrollbar(*this, orientation, docElement);</span>
  
      // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
      RenderWidget* frameRenderer = frame().ownerRenderer();
      if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
          return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
  
      // Nobody set a custom style, so we just use a native scrollbar.
      return ScrollView::createScrollbar(orientation);
  }
  
<span class="line-modified">! void FrameView::didRestoreFromPageCache()</span>
  {
<span class="line-modified">!     // When restoring from page cache, the main frame stays in place while subframes get swapped in.</span>
      // We update the scrollable area set to ensure that scrolling data structures get invalidated.
      updateScrollableAreaSet();
  }
  
  void FrameView::willDestroyRenderTree()
<span class="line-new-header">--- 527,48 ---</span>
          setCanHaveScrollbars(false);
      else
          setCanHaveScrollbars(true);
  }
  
<span class="line-modified">! RefPtr&lt;Element&gt; FrameView::rootElementForCustomScrollbarPartStyle(PseudoId partPseudoId) const</span>
  {
      // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
<span class="line-modified">!     auto* document = frame().document();</span>
<span class="line-added">+     if (!document)</span>
<span class="line-added">+         return nullptr;</span>
  
      // Try the &lt;body&gt; element first as a scrollbar source.
<span class="line-modified">!     auto* body = document-&gt;bodyOrFrameset();</span>
<span class="line-modified">!     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(partPseudoId))</span>
<span class="line-modified">!         return body;</span>
  
      // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
<span class="line-modified">!     auto* docElement = document-&gt;documentElement();</span>
<span class="line-modified">!     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(partPseudoId))</span>
<span class="line-modified">!         return docElement;</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto element = rootElementForCustomScrollbarPartStyle(PseudoId::Scrollbar))</span>
<span class="line-added">+         return RenderScrollbar::createCustomScrollbar(*this, orientation, element.get());</span>
  
      // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
<span class="line-added">+     // FIXME: Seems bad to do this for cross-origin frames.</span>
      RenderWidget* frameRenderer = frame().ownerRenderer();
      if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
          return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
  
      // Nobody set a custom style, so we just use a native scrollbar.
      return ScrollView::createScrollbar(orientation);
  }
  
<span class="line-modified">! void FrameView::didRestoreFromBackForwardCache()</span>
  {
<span class="line-modified">!     // When restoring from back/forward cache, the main frame stays in place while subframes get swapped in.</span>
      // We update the scrollable area set to ensure that scrolling data structures get invalidated.
      updateScrollableAreaSet();
  }
  
  void FrameView::willDestroyRenderTree()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 594,11 ***</span>
  
      page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
  
      if (frame().isMainFrame()) {
          page-&gt;pageOverlayController().didChangeDocumentSize();
<span class="line-modified">!         PageCache::singleton().markPagesForContentsSizeChanged(*page);</span>
      }
      layoutContext().enableSetNeedsLayout();
  }
  
  void FrameView::adjustViewSize()
<span class="line-new-header">--- 610,11 ---</span>
  
      page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
  
      if (frame().isMainFrame()) {
          page-&gt;pageOverlayController().didChangeDocumentSize();
<span class="line-modified">!         BackForwardCache::singleton().markPagesForContentsSizeChanged(*page);</span>
      }
      layoutContext().enableSetNeedsLayout();
  }
  
  void FrameView::adjustViewSize()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 781,10 ***</span>
<span class="line-new-header">--- 797,22 ---</span>
          return;
  
      renderView-&gt;compositor().willRecalcStyle();
  }
  
<span class="line-added">+ void FrameView::styleDidChange()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ScrollView::styleDidChange();</span>
<span class="line-added">+     RenderView* renderView = this-&gt;renderView();</span>
<span class="line-added">+     if (!renderView)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RenderLayer* layerTreeMutationRoot = renderView-&gt;takeStyleChangeLayerTreeMutationRoot();</span>
<span class="line-added">+     if (layerTreeMutationRoot &amp;&amp; !needsLayout())</span>
<span class="line-added">+         layerTreeMutationRoot-&gt;updateLayerPositionsAfterStyleChange();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool FrameView::updateCompositingLayersAfterStyleChange()
  {
      // If we expect to update compositing after an incipient layout, don&#39;t do so here.
      if (!renderView() || needsLayout() || layoutContext().isInLayout())
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1189,12 ***</span>
              setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
          // Set the initial hMode to AlwaysOff if we&#39;re auto.
          if (hMode == ScrollbarAuto)
              setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
          ASSERT(frame().page());
<span class="line-modified">!         if (frame().page()-&gt;expectsWheelEventTriggers())</span>
<span class="line-modified">!             scrollAnimator().setWheelEventTestTrigger(frame().page()-&gt;testTrigger());</span>
          setScrollbarModes(hMode, vMode);
          setScrollbarsSuppressed(false, true);
      } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
          setScrollbarModes(hMode, vMode);
  }
<span class="line-new-header">--- 1217,12 ---</span>
              setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
          // Set the initial hMode to AlwaysOff if we&#39;re auto.
          if (hMode == ScrollbarAuto)
              setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
          ASSERT(frame().page());
<span class="line-modified">!         if (frame().page()-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">!             scrollAnimator().setWheelEventTestMonitor(frame().page()-&gt;wheelEventTestMonitor());</span>
          setScrollbarModes(hMode, vMode);
          setScrollbarsSuppressed(false, true);
      } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
          setScrollbarModes(hMode, vMode);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1402,10 ***</span>
<span class="line-new-header">--- 1430,45 ---</span>
      builder.appendLiteral(&quot;FrameView: &quot;);
      builder.append(message);
      document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
  }
  
<span class="line-added">+ bool FrameView::styleHidesScrollbarWithOrientation(ScrollbarOrientation orientation) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto element = rootElementForCustomScrollbarPartStyle(PseudoId::Scrollbar);</span>
<span class="line-added">+     if (!element)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     auto* renderer = element-&gt;renderer();</span>
<span class="line-added">+     ASSERT(renderer); // rootElementForCustomScrollbarPart assures that it&#39;s not null.</span>
<span class="line-added">+ </span>
<span class="line-added">+     StyleScrollbarState scrollbarState;</span>
<span class="line-added">+     scrollbarState.scrollbarPart = ScrollbarBGPart;</span>
<span class="line-added">+     scrollbarState.orientation = orientation;</span>
<span class="line-added">+     auto scrollbarStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::Scrollbar, scrollbarState }, &amp;renderer-&gt;style());</span>
<span class="line-added">+     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool FrameView::horizontalScrollbarHiddenByStyle() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (managesScrollbars()) {</span>
<span class="line-added">+         auto* scrollbar = horizontalScrollbar();</span>
<span class="line-added">+         return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return styleHidesScrollbarWithOrientation(HorizontalScrollbar);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool FrameView::verticalScrollbarHiddenByStyle() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (managesScrollbars()) {</span>
<span class="line-added">+         auto* scrollbar = verticalScrollbar();</span>
<span class="line-added">+         return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return styleHidesScrollbarWithOrientation(VerticalScrollbar);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void FrameView::setCannotBlitToWindow()
  {
      m_cannotBlitToWindow = true;
      updateCanBlitOnScrollRecursively();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2116,40 ***</span>
  }
  
  bool FrameView::scrollToFragment(const URL&amp; url)
  {
      String fragmentIdentifier = url.fragmentIdentifier();
<span class="line-modified">!     if (scrollToAnchor(fragmentIdentifier))</span>
          return true;
  
      // Try again after decoding the ref, based on the document&#39;s encoding.
      if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
<span class="line-modified">!         if (scrollToAnchor(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))</span>
              return true;
      }
  
      resetScrollAnchor();
      return false;
  }
  
<span class="line-modified">! bool FrameView::scrollToAnchor(const String&amp; fragmentIdentifier)</span>
  {
      LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
  
      // If our URL has no ref, then we have no place we need to jump to.
      if (fragmentIdentifier.isNull())
          return false;
  
      ASSERT(frame().document());
      auto&amp; document = *frame().document();
<span class="line-modified">! </span>
<span class="line-removed">-     if (!document.haveStylesheetsLoaded()) {</span>
<span class="line-removed">-         document.setGotoAnchorNeededAfterStylesheetsLoad(true);</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     document.setGotoAnchorNeededAfterStylesheetsLoad(false);</span>
  
      Element* anchorElement = document.findAnchor(fragmentIdentifier);
  
      LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
  
<span class="line-new-header">--- 2179,34 ---</span>
  }
  
  bool FrameView::scrollToFragment(const URL&amp; url)
  {
      String fragmentIdentifier = url.fragmentIdentifier();
<span class="line-modified">!     if (scrollToFragmentInternal(fragmentIdentifier))</span>
          return true;
  
      // Try again after decoding the ref, based on the document&#39;s encoding.
      if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
<span class="line-modified">!         if (scrollToFragmentInternal(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))</span>
              return true;
      }
  
      resetScrollAnchor();
      return false;
  }
  
<span class="line-modified">! bool FrameView::scrollToFragmentInternal(const String&amp; fragmentIdentifier)</span>
  {
      LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
  
      // If our URL has no ref, then we have no place we need to jump to.
      if (fragmentIdentifier.isNull())
          return false;
  
      ASSERT(frame().document());
      auto&amp; document = *frame().document();
<span class="line-modified">!     RELEASE_ASSERT(document.haveStylesheetsLoaded());</span>
  
      Element* anchorElement = document.findAnchor(fragmentIdentifier);
  
      LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2220,24 ***</span>
      int centeringOffsetX = (rect.width() - bounds.width()) / 2;
      int centeringOffsetY = (rect.height() - bounds.height()) / 2;
      setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
  }
  
<span class="line-modified">! void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)</span>
  {
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
  
      auto oldScrollType = currentScrollType();
      setCurrentScrollType(ScrollType::Programmatic);
  
      m_maintainScrollPositionAnchor = nullptr;
      m_shouldScrollToFocusedElement = false;
      m_delayedScrollToFocusedElementTimer.stop();
      Page* page = frame().page();
<span class="line-modified">!     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</span>
<span class="line-modified">!         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</span>
<span class="line-modified">!     ScrollView::setScrollPosition(scrollPosition);</span>
  
      setCurrentScrollType(oldScrollType);
  }
  
  void FrameView::resetScrollAnchor()
<span class="line-new-header">--- 2277,24 ---</span>
      int centeringOffsetX = (rect.width() - bounds.width()) / 2;
      int centeringOffsetY = (rect.height() - bounds.height()) / 2;
      setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
  }
  
<span class="line-modified">! void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition, ScrollClamping clamping)</span>
  {
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
  
      auto oldScrollType = currentScrollType();
      setCurrentScrollType(ScrollType::Programmatic);
  
      m_maintainScrollPositionAnchor = nullptr;
      m_shouldScrollToFocusedElement = false;
      m_delayedScrollToFocusedElementTimer.stop();
      Page* page = frame().page();
<span class="line-modified">!     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">!         scrollAnimator().setWheelEventTestMonitor(page-&gt;wheelEventTestMonitor());</span>
<span class="line-modified">!     ScrollView::setScrollPosition(scrollPosition, clamping);</span>
  
      setCurrentScrollType(oldScrollType);
  }
  
  void FrameView::resetScrollAnchor()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2421,10 ***</span>
<span class="line-new-header">--- 2478,15 ---</span>
      }
  
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; scrollPositionChanged from &quot; &lt;&lt; oldPosition &lt;&lt; &quot; to &quot; &lt;&lt; newPosition &lt;&lt; &quot; (scale &quot; &lt;&lt; frameScaleFactor() &lt;&lt; &quot; )&quot;);
      updateLayoutViewport();
      viewportContentsChanged();
<span class="line-added">+ </span>
<span class="line-added">+     if (auto* renderView = this-&gt;renderView()) {</span>
<span class="line-added">+         if (auto* layer = renderView-&gt;layer())</span>
<span class="line-added">+             frame().editor().renderLayerDidScroll(*layer);</span>
<span class="line-added">+     }</span>
  }
  
  void FrameView::applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp; apply)
  {
      IntRect windowClipRect = this-&gt;windowClipRect();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2552,11 ***</span>
          return scrollAnimator-&gt;isRubberBandInProgress();
  
      return false;
  }
  
<span class="line-modified">! bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position)</span>
  {
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
  
  #if ENABLE(ASYNC_SCROLLING)
      if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
<span class="line-new-header">--- 2614,11 ---</span>
          return scrollAnimator-&gt;isRubberBandInProgress();
  
      return false;
  }
  
<span class="line-modified">! bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position, ScrollType scrollType, ScrollClamping clamping)</span>
  {
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
  
  #if ENABLE(ASYNC_SCROLLING)
      if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2564,11 ***</span>
  #endif
  
  #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
      if (Page* page = frame().page()) {
          if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
<span class="line-modified">!             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position);</span>
      }
  #else
      UNUSED_PARAM(position);
  #endif
  
<span class="line-new-header">--- 2626,11 ---</span>
  #endif
  
  #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
      if (Page* page = frame().page()) {
          if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
<span class="line-modified">!             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position, scrollType, clamping);</span>
      }
  #else
      UNUSED_PARAM(position);
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2743,18 ***</span>
          if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
              scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);
      }
  }
  
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">- </span>
  void FrameView::unobscuredContentSizeChanged()
  {
      updateTiledBackingAdaptiveSizing();
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  #endif
  
  static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
  {
      // We only throttle when constantly receiving new data during the inital page load.
      if (!page.progress().isMainLoadProgressing())
<span class="line-new-header">--- 2805,16 ---</span>
          if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
              scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);
      }
  }
  
  void FrameView::unobscuredContentSizeChanged()
  {
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
      updateTiledBackingAdaptiveSizing();
  #endif
<span class="line-added">+ }</span>
  
  static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
  {
      // We only throttle when constantly receiving new data during the inital page load.
      if (!page.progress().isMainLoadProgressing())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3359,25 ***</span>
          if (documentLoader-&gt;isLoadingInAPISense())
              return;
      }
  #endif
  
<span class="line-modified">!     bool isMainFrame = frame().isMainFrame();</span>
<span class="line-modified">!     bool canSendResizeEventSynchronously = isMainFrame &amp;&amp; !m_shouldAutoSize;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     LOG(Events, &quot;FrameView %p sendResizeEventIfNeeded sending resize event, size %dx%d (canSendResizeEventSynchronously %d)&quot;, this, currentSize.width(), currentSize.height(), canSendResizeEventSynchronously);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Ref&lt;Event&gt; resizeEvent = Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No);</span>
<span class="line-removed">-     if (canSendResizeEventSynchronously)</span>
<span class="line-removed">-         frame().document()-&gt;dispatchWindowEvent(resizeEvent);</span>
<span class="line-removed">-     else {</span>
<span class="line-removed">-         // FIXME: Queueing this event for an unpredictable time in the future seems</span>
<span class="line-removed">-         // intrinsically racy. By the time this resize event fires, the frame might</span>
<span class="line-removed">-         // be resized again, so we could end up with two resize events for the same size.</span>
<span class="line-removed">-         frame().document()-&gt;enqueueWindowEvent(WTFMove(resizeEvent));</span>
<span class="line-removed">-     }</span>
  
      if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
          if (Page* page = frame().page()) {
              if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
                  inspectorClient-&gt;didResizeMainFrame(&amp;frame());
          }
<span class="line-new-header">--- 3419,14 ---</span>
          if (documentLoader-&gt;isLoadingInAPISense())
              return;
      }
  #endif
  
<span class="line-modified">!     LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;FrameView&quot; &lt;&lt; this &lt;&lt; &quot;sendResizeEventIfNeeded scheduling resize event for document&quot; &lt;&lt; frame().document() &lt;&lt; &quot;, size &quot; &lt;&lt; currentSize);</span>
<span class="line-modified">!     frame().document()-&gt;setNeedsDOMWindowResizeEvent();</span>
  
<span class="line-added">+     bool isMainFrame = frame().isMainFrame();</span>
      if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
          if (Page* page = frame().page()) {
              if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
                  inspectorClient-&gt;didResizeMainFrame(&amp;frame());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3651,15 ***</span>
      invalidateRect(dirtyRect);
  }
  
  float FrameView::visibleContentScaleFactor() const
  {
<span class="line-modified">!     if (!frame().isMainFrame() || !frame().settings().delegatesPageScaling())</span>
          return 1;
  
      Page* page = frame().page();
<span class="line-modified">!     if (!page)</span>
          return 1;
  
      return page-&gt;pageScaleFactor();
  }
  
<span class="line-new-header">--- 3700,17 ---</span>
      invalidateRect(dirtyRect);
  }
  
  float FrameView::visibleContentScaleFactor() const
  {
<span class="line-modified">!     if (!frame().isMainFrame())</span>
          return 1;
  
      Page* page = frame().page();
<span class="line-modified">!     // FIXME: This !delegatesScaling() is confusing, and the opposite behavior to Frame::frameScaleFactor().</span>
<span class="line-added">+     // This function should probably be renamed to delegatedPageScaleFactor().</span>
<span class="line-added">+     if (!page || !page-&gt;delegatesScaling())</span>
          return 1;
  
      return page-&gt;pageScaleFactor();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3810,26 ***</span>
          // Try the &lt;body&gt; element first as a scroll corner source.
          Document* doc = frame().document();
          Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
          if (body &amp;&amp; body-&gt;renderer()) {
              renderer = body-&gt;renderer();
<span class="line-modified">!             cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());</span>
          }
  
          if (!cornerStyle) {
              // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
              Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
              if (docElement &amp;&amp; docElement-&gt;renderer()) {
                  renderer = docElement-&gt;renderer();
<span class="line-modified">!                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());</span>
              }
          }
  
          if (!cornerStyle) {
              // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
              if (RenderWidget* renderer = frame().ownerRenderer())
<span class="line-modified">!                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());</span>
          }
      }
  
      if (!cornerStyle)
          m_scrollCorner = nullptr;
<span class="line-new-header">--- 3861,27 ---</span>
          // Try the &lt;body&gt; element first as a scroll corner source.
          Document* doc = frame().document();
          Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
          if (body &amp;&amp; body-&gt;renderer()) {
              renderer = body-&gt;renderer();
<span class="line-modified">!             cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
          }
  
          if (!cornerStyle) {
              // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
              Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
              if (docElement &amp;&amp; docElement-&gt;renderer()) {
                  renderer = docElement-&gt;renderer();
<span class="line-modified">!                 cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
              }
          }
  
          if (!cornerStyle) {
              // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
<span class="line-added">+             // FIXME: Seems wrong to do this for cross-origin frames.</span>
              if (RenderWidget* renderer = frame().ownerRenderer())
<span class="line-modified">!                 cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
          }
      }
  
      if (!cornerStyle)
          m_scrollCorner = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4101,26 ***</span>
      else if (m_nodeToDraw)
          fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
      else
          fillWithWarningColor = true;
  
<span class="line-modified">!     if (fillWithWarningColor)</span>
<span class="line-modified">!         context.fillRect(dirtyRect, Color(255, 64, 255));</span>
  #endif
  
      RenderView* renderView = this-&gt;renderView();
      if (!renderView) {
          LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
          return;
      }
  
      if (!layoutContext().inPaintableState())
          return;
  
      ASSERT(!needsLayout());
      if (needsLayout()) {
<span class="line-modified">!         RELEASE_LOG_IF_ALLOWED(&quot;FrameView::paintContents() - not painting because render tree needs layout (is main frame %d)&quot;, frame().isMainFrame());</span>
          return;
      }
  
      PaintingState paintingState;
      willPaintContents(context, dirtyRect, paintingState);
<span class="line-new-header">--- 4153,37 ---</span>
      else if (m_nodeToDraw)
          fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
      else
          fillWithWarningColor = true;
  
<span class="line-modified">!     if (fillWithWarningColor) {</span>
<span class="line-modified">!         IntRect debugRect = frameRect();</span>
<span class="line-added">+         debugRect.intersect(dirtyRect);</span>
<span class="line-added">+         context.fillRect(debugRect, Color(255, 64, 255));</span>
<span class="line-added">+     }</span>
  #endif
  
      RenderView* renderView = this-&gt;renderView();
      if (!renderView) {
          LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
          return;
      }
  
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">+         if (auto* layoutState = layoutContext().layoutFormattingState())</span>
<span class="line-added">+             Layout::LayoutContext::paint(*layoutState, context, dirtyRect);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      if (!layoutContext().inPaintableState())
          return;
  
      ASSERT(!needsLayout());
      if (needsLayout()) {
<span class="line-modified">!         FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(Layout, &quot;paintContents: Not painting because render tree needs layout&quot;);</span>
          return;
      }
  
      PaintingState paintingState;
      willPaintContents(context, dirtyRect, paintingState);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4262,11 ***</span>
          }
          if (!didWork)
              break;
      }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      auto needsStyleRecalc = [&amp;] {
          DescendantsDeque deque;
          while (auto view = nextRenderedDescendant(deque)) {
              auto* document = view-&gt;frame().document();
              if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
<span class="line-new-header">--- 4325,11 ---</span>
          }
          if (!didWork)
              break;
      }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      auto needsStyleRecalc = [&amp;] {
          DescendantsDeque deque;
          while (auto view = nextRenderedDescendant(deque)) {
              auto* document = view-&gt;frame().document();
              if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4281,11 ***</span>
              if (view-&gt;needsLayout())
                  return true;
          }
          return false;
      };
<span class="line-modified">! #endif</span>
  
      ASSERT(!needsStyleRecalc());
      ASSERT(!needsLayout());
  }
  
<span class="line-new-header">--- 4344,11 ---</span>
              if (view-&gt;needsLayout())
                  return true;
          }
          return false;
      };
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
      ASSERT(!needsStyleRecalc());
      ASSERT(!needsLayout());
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5034,12 ***</span>
  
  void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
  {
      ScrollableArea::didAddScrollbar(scrollbar, orientation);
      Page* page = frame().page();
<span class="line-modified">!     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</span>
<span class="line-modified">!         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</span>
      if (AXObjectCache* cache = axObjectCache())
          cache-&gt;handleScrollbarUpdate(this);
  }
  
  void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
<span class="line-new-header">--- 5097,12 ---</span>
  
  void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
  {
      ScrollableArea::didAddScrollbar(scrollbar, orientation);
      Page* page = frame().page();
<span class="line-modified">!     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">!         scrollAnimator().setWheelEventTestMonitor(page-&gt;wheelEventTestMonitor());</span>
      if (AXObjectCache* cache = axObjectCache())
          cache-&gt;handleScrollbarUpdate(this);
  }
  
  void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5086,11 ***</span>
              milestonesAchieved.add(DidRenderSignificantAmountOfText);
      }
  
      if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
          if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
<span class="line-modified">!             RELEASE_LOG_IF_ALLOWED(&quot;fireLayoutRelatedMilestonesIfNeeded() - firing first visually non-empty layout milestone on the main frame&quot;);</span>
          frame().loader().didReachLayoutMilestone(milestonesAchieved);
      }
  }
  
  void FrameView::firePaintRelatedMilestonesIfNeeded()
<span class="line-new-header">--- 5149,11 ---</span>
              milestonesAchieved.add(DidRenderSignificantAmountOfText);
      }
  
      if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
          if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
<span class="line-modified">!             FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(Layout, &quot;fireLayoutRelatedMilestonesIfNeeded: Firing first visually non-empty layout milestone on the main frame&quot;);</span>
          frame().loader().didReachLayoutMilestone(milestonesAchieved);
      }
  }
  
  void FrameView::firePaintRelatedMilestonesIfNeeded()
</pre>
<center><a href="FrameTree.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
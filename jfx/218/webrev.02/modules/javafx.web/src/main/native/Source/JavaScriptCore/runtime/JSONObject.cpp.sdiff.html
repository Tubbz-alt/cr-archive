<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSNativeStdFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSONObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSONObject.h&quot;
 28 
 29 #include &quot;ArrayConstructor.h&quot;
 30 #include &quot;BigIntObject.h&quot;
 31 #include &quot;BooleanObject.h&quot;
 32 #include &quot;Error.h&quot;
 33 #include &quot;ExceptionHelpers.h&quot;
 34 #include &quot;JSArray.h&quot;

 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;LiteralParser.h&quot;
 37 #include &quot;Lookup.h&quot;
 38 #include &quot;ObjectConstructor.h&quot;
 39 #include &quot;JSCInlines.h&quot;
 40 #include &quot;PropertyNameArray.h&quot;
 41 #include &lt;wtf/MathExtras.h&gt;
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 
 44 namespace JSC {
 45 
 46 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSONObject);
 47 
<span class="line-modified"> 48 EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(ExecState*);</span>
<span class="line-modified"> 49 EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(ExecState*);</span>
 50 
 51 }
 52 
 53 #include &quot;JSONObject.lut.h&quot;
 54 
 55 namespace JSC {
 56 
 57 JSONObject::JSONObject(VM&amp; vm, Structure* structure)
 58     : JSNonFinalObject(vm, structure)
 59 {
 60 }
 61 
 62 void JSONObject::finishCreation(VM&amp; vm)
 63 {
 64     Base::finishCreation(vm);
 65     ASSERT(inherits(vm, info()));
 66 
<span class="line-modified"> 67     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsString(vm, &quot;JSON&quot;), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);</span>
 68 }
 69 
 70 // PropertyNameForFunctionCall objects must be on the stack, since the JSValue that they create is not marked.
 71 class PropertyNameForFunctionCall {
 72 public:
 73     PropertyNameForFunctionCall(const Identifier&amp;);
 74     PropertyNameForFunctionCall(unsigned);
 75 
<span class="line-modified"> 76     JSValue value(ExecState*) const;</span>
 77 
 78 private:
 79     const Identifier* m_identifier;
 80     unsigned m_number;
 81     mutable JSValue m_value;
 82 };
 83 
 84 class Stringifier {
 85     WTF_MAKE_NONCOPYABLE(Stringifier);
 86     WTF_FORBID_HEAP_ALLOCATION;
 87 public:
<span class="line-modified"> 88     Stringifier(ExecState*, JSValue replacer, JSValue space);</span>
 89     JSValue stringify(JSValue);
 90 
 91 private:
 92     class Holder {
 93     public:
 94         enum RootHolderTag { RootHolder };
<span class="line-modified"> 95         Holder(ExecState*, JSObject*);</span>
 96         Holder(RootHolderTag, JSObject*);
 97 
 98         JSObject* object() const { return m_object; }
 99         bool isArray() const { return m_isArray; }
100 
101         bool appendNextProperty(Stringifier&amp;, StringBuilder&amp;);
102 
103     private:
104         JSObject* m_object;
105         const bool m_isJSArray;
106         const bool m_isArray;
107         unsigned m_index { 0 };
108         unsigned m_size { 0 };
109         RefPtr&lt;PropertyNameArrayData&gt; m_propertyNames;
110     };
111 
112     friend class Holder;
113 
114     JSValue toJSON(JSValue, const PropertyNameForFunctionCall&amp;);
115     JSValue toJSONImpl(VM&amp;, JSValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp;);
116 
117     enum StringifyResult { StringifyFailed, StringifySucceeded, StringifyFailedDueToUndefinedOrSymbolValue };
118     StringifyResult appendStringifiedValue(StringBuilder&amp;, JSValue, const Holder&amp;, const PropertyNameForFunctionCall&amp;);
119 
120     bool willIndent() const;
121     void indent();
122     void unindent();
123     void startNewLine(StringBuilder&amp;) const;
124     bool isCallableReplacer() const { return m_replacerCallType != CallType::None; }
125 
<span class="line-modified">126     ExecState* const m_exec;</span>
127     JSValue m_replacer;
128     bool m_usingArrayReplacer { false };
129     PropertyNameArray m_arrayReplacerPropertyNames;
130     CallType m_replacerCallType { CallType::None };
131     CallData m_replacerCallData;
132     String m_gap;
133 
134     MarkedArgumentBuffer m_objectStack;
135     Vector&lt;Holder, 16, UnsafeVectorOverflow&gt; m_holderStack;
136     String m_repeatedGap;
137     String m_indent;
138 };
139 
140 // ------------------------------ helper functions --------------------------------
141 
<span class="line-modified">142 static inline JSValue unwrapBoxedPrimitive(ExecState* exec, JSValue value)</span>
143 {
<span class="line-modified">144     VM&amp; vm = exec-&gt;vm();</span>
145     if (!value.isObject())
146         return value;
147     JSObject* object = asObject(value);
148     if (object-&gt;inherits&lt;NumberObject&gt;(vm))
<span class="line-modified">149         return jsNumber(object-&gt;toNumber(exec));</span>
150     if (object-&gt;inherits&lt;StringObject&gt;(vm))
<span class="line-modified">151         return object-&gt;toString(exec);</span>
152     if (object-&gt;inherits&lt;BooleanObject&gt;(vm) || object-&gt;inherits&lt;BigIntObject&gt;(vm))
153         return jsCast&lt;JSWrapperObject*&gt;(object)-&gt;internalValue();
154 
155     // Do not unwrap SymbolObject to Symbol. It is not performed in the spec.
156     // http://www.ecma-international.org/ecma-262/6.0/#sec-serializejsonproperty
157     return value;
158 }
159 
<span class="line-modified">160 static inline String gap(ExecState* exec, JSValue space)</span>
161 {
<span class="line-modified">162     VM&amp; vm = exec-&gt;vm();</span>
163     auto scope = DECLARE_THROW_SCOPE(vm);
164 
165     const unsigned maxGapLength = 10;
<span class="line-modified">166     space = unwrapBoxedPrimitive(exec, space);</span>
167     RETURN_IF_EXCEPTION(scope, { });
168 
169     // If the space value is a number, create a gap string with that number of spaces.
170     if (space.isNumber()) {
171         double spaceCount = space.asNumber();
172         int count;
173         if (spaceCount &gt; maxGapLength)
174             count = maxGapLength;
175         else if (!(spaceCount &gt; 0))
176             count = 0;
177         else
178             count = static_cast&lt;int&gt;(spaceCount);
179         char spaces[maxGapLength];
180         for (int i = 0; i &lt; count; ++i)
181             spaces[i] = &#39; &#39;;
182         return String(spaces, count);
183     }
184 
185     // If the space value is a string, use it as the gap string, otherwise use no gap string.
<span class="line-modified">186     String spaces = space.getString(exec);</span>

187     if (spaces.length() &lt;= maxGapLength)
188         return spaces;
189     return spaces.substringSharingImpl(0, maxGapLength);
190 }
191 
192 // ------------------------------ PropertyNameForFunctionCall --------------------------------
193 
194 inline PropertyNameForFunctionCall::PropertyNameForFunctionCall(const Identifier&amp; identifier)
195     : m_identifier(&amp;identifier)
196 {
197 }
198 
199 inline PropertyNameForFunctionCall::PropertyNameForFunctionCall(unsigned number)
200     : m_identifier(0)
201     , m_number(number)
202 {
203 }
204 
<span class="line-modified">205 JSValue PropertyNameForFunctionCall::value(ExecState* exec) const</span>
206 {
207     if (!m_value) {
<span class="line-modified">208         VM&amp; vm = exec-&gt;vm();</span>
209         if (m_identifier)
210             m_value = jsString(vm, m_identifier-&gt;string());
211         else {
212             if (m_number &lt;= 9)
213                 return vm.smallStrings.singleCharacterString(m_number + &#39;0&#39;);
214             m_value = jsNontrivialString(vm, vm.numericStrings.add(m_number));
215         }
216     }
217     return m_value;
218 }
219 
220 // ------------------------------ Stringifier --------------------------------
221 
<span class="line-modified">222 Stringifier::Stringifier(ExecState* exec, JSValue replacer, JSValue space)</span>
<span class="line-modified">223     : m_exec(exec)</span>
224     , m_replacer(replacer)
<span class="line-modified">225     , m_arrayReplacerPropertyNames(exec-&gt;vm(), PropertyNameMode::Strings, PrivateSymbolMode::Exclude)</span>
226 {
<span class="line-modified">227     VM&amp; vm = exec-&gt;vm();</span>
228     auto scope = DECLARE_THROW_SCOPE(vm);
229 
230     if (m_replacer.isObject()) {
231         JSObject* replacerObject = asObject(m_replacer);
232 
233         m_replacerCallType = CallType::None;
234         if (!replacerObject-&gt;isCallable(vm, m_replacerCallType, m_replacerCallData)) {
<span class="line-modified">235             bool isArrayReplacer = JSC::isArray(exec, replacerObject);</span>
236             RETURN_IF_EXCEPTION(scope, );
237             if (isArrayReplacer) {
238                 m_usingArrayReplacer = true;
<span class="line-modified">239                 unsigned length = replacerObject-&gt;get(exec, vm.propertyNames-&gt;length).toUInt32(exec);</span>
240                 RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">241                 for (unsigned i = 0; i &lt; length; ++i) {</span>
<span class="line-modified">242                     JSValue name = replacerObject-&gt;get(exec, i);</span>
<span class="line-modified">243                     RETURN_IF_EXCEPTION(scope, );</span>





244                     if (name.isObject()) {
245                         auto* nameObject = jsCast&lt;JSObject*&gt;(name);
246                         if (!nameObject-&gt;inherits&lt;NumberObject&gt;(vm) &amp;&amp; !nameObject-&gt;inherits&lt;StringObject&gt;(vm))
247                             continue;
248                     } else if (!name.isNumber() &amp;&amp; !name.isString())
249                         continue;
<span class="line-modified">250                     JSString* propertyNameString = name.toString(exec);</span>
251                     RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">252                     auto propertyName = propertyNameString-&gt;toIdentifier(exec);</span>
253                     RETURN_IF_EXCEPTION(scope, );
254                     m_arrayReplacerPropertyNames.add(WTFMove(propertyName));
255                 }
256             }
257         }
258     }
259 
260     scope.release();
<span class="line-modified">261     m_gap = gap(exec, space);</span>
262 }
263 
264 JSValue Stringifier::stringify(JSValue value)
265 {
<span class="line-modified">266     VM&amp; vm = m_exec-&gt;vm();</span>
267     auto scope = DECLARE_THROW_SCOPE(vm);
268 
269     PropertyNameForFunctionCall emptyPropertyName(vm.propertyNames-&gt;emptyIdentifier);
270 
271     // If the replacer is not callable, root object wrapper is non-user-observable.
272     // We can skip creating this wrapper object.
273     JSObject* object = nullptr;
274     if (isCallableReplacer()) {
<span class="line-modified">275         object = constructEmptyObject(m_exec);</span>
<span class="line-removed">276         RETURN_IF_EXCEPTION(scope, jsUndefined());</span>
277         object-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, value);
278     }
279 
280     StringBuilder result(StringBuilder::OverflowHandler::RecordOverflow);
281     Holder root(Holder::RootHolder, object);
282     auto stringifyResult = appendStringifiedValue(result, value, root, emptyPropertyName);
283     RETURN_IF_EXCEPTION(scope, jsUndefined());
284     if (UNLIKELY(result.hasOverflowed())) {
<span class="line-modified">285         throwOutOfMemoryError(m_exec, scope);</span>
286         return jsUndefined();
287     }
288     if (UNLIKELY(stringifyResult != StringifySucceeded))
289         return jsUndefined();
290     RELEASE_AND_RETURN(scope, jsString(vm, result.toString()));
291 }
292 
293 ALWAYS_INLINE JSValue Stringifier::toJSON(JSValue baseValue, const PropertyNameForFunctionCall&amp; propertyName)
294 {
<span class="line-modified">295     VM&amp; vm = m_exec-&gt;vm();</span>
296     auto scope = DECLARE_THROW_SCOPE(vm);
297     scope.assertNoException();
298 
299     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified">300     bool hasProperty = baseValue.getPropertySlot(m_exec, vm.propertyNames-&gt;toJSON, slot);</span>
301     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
302     if (!hasProperty)
303         return baseValue;
304 
<span class="line-modified">305     JSValue toJSONFunction = slot.getValue(m_exec, vm.propertyNames-&gt;toJSON);</span>
306     RETURN_IF_EXCEPTION(scope, { });
307     RELEASE_AND_RETURN(scope, toJSONImpl(vm, baseValue, toJSONFunction, propertyName));
308 }
309 
310 JSValue Stringifier::toJSONImpl(VM&amp; vm, JSValue baseValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp; propertyName)
311 {
312     CallType callType;
313     CallData callData;
314     if (!toJSONFunction.isCallable(vm, callType, callData))
315         return baseValue;
316 
317     MarkedArgumentBuffer args;
<span class="line-modified">318     args.append(propertyName.value(m_exec));</span>
319     ASSERT(!args.hasOverflowed());
<span class="line-modified">320     return call(m_exec, asObject(toJSONFunction), callType, callData, baseValue, args);</span>
321 }
322 
323 Stringifier::StringifyResult Stringifier::appendStringifiedValue(StringBuilder&amp; builder, JSValue value, const Holder&amp; holder, const PropertyNameForFunctionCall&amp; propertyName)
324 {
<span class="line-modified">325     VM&amp; vm = m_exec-&gt;vm();</span>
326     auto scope = DECLARE_THROW_SCOPE(vm);
327 
328     // Call the toJSON function.
329     if (value.isObject() || value.isBigInt()) {
330         value = toJSON(value, propertyName);
331         RETURN_IF_EXCEPTION(scope, StringifyFailed);
332     }
333 
334     // Call the replacer function.
335     if (isCallableReplacer()) {
336         MarkedArgumentBuffer args;
<span class="line-modified">337         args.append(propertyName.value(m_exec));</span>
338         args.append(value);
339         ASSERT(!args.hasOverflowed());
340         ASSERT(holder.object());
<span class="line-modified">341         value = call(m_exec, m_replacer, m_replacerCallType, m_replacerCallData, holder.object(), args);</span>
342         RETURN_IF_EXCEPTION(scope, StringifyFailed);
343     }
344 
345     if ((value.isUndefined() || value.isSymbol()) &amp;&amp; !holder.isArray())
346         return StringifyFailedDueToUndefinedOrSymbolValue;
347 
348     if (value.isNull()) {
349         builder.appendLiteral(&quot;null&quot;);
350         return StringifySucceeded;
351     }
352 
<span class="line-modified">353     value = unwrapBoxedPrimitive(m_exec, value);</span>
354 
355     RETURN_IF_EXCEPTION(scope, StringifyFailed);
356 
357     if (value.isBoolean()) {
358         if (value.isTrue())
359             builder.appendLiteral(&quot;true&quot;);
360         else
361             builder.appendLiteral(&quot;false&quot;);
362         return StringifySucceeded;
363     }
364 
365     if (value.isString()) {
<span class="line-modified">366         const String&amp; string = asString(value)-&gt;value(m_exec);</span>
367         RETURN_IF_EXCEPTION(scope, StringifyFailed);
368         builder.appendQuotedJSONString(string);
369         return StringifySucceeded;
370     }
371 
372     if (value.isNumber()) {
373         if (value.isInt32())
374             builder.appendNumber(value.asInt32());
375         else {
376             double number = value.asNumber();
377             if (!std::isfinite(number))
378                 builder.appendLiteral(&quot;null&quot;);
379             else
380                 builder.appendNumber(number);
381         }
382         return StringifySucceeded;
383     }
384 
385     if (value.isBigInt()) {
<span class="line-modified">386         throwTypeError(m_exec, scope, &quot;JSON.stringify cannot serialize BigInt.&quot;_s);</span>
387         return StringifyFailed;
388     }
389 
390     if (!value.isObject())
391         return StringifyFailed;
392 
393     JSObject* object = asObject(value);
394     if (object-&gt;isFunction(vm)) {
395         if (holder.isArray()) {
396             builder.appendLiteral(&quot;null&quot;);
397             return StringifySucceeded;
398         }
399         return StringifyFailedDueToUndefinedOrSymbolValue;
400     }
401 
402     if (UNLIKELY(builder.hasOverflowed()))
403         return StringifyFailed;
404 
405     // Handle cycle detection, and put the holder on the stack.
406     for (unsigned i = 0; i &lt; m_holderStack.size(); i++) {
407         if (m_holderStack[i].object() == object) {
<span class="line-modified">408             throwTypeError(m_exec, scope, &quot;JSON.stringify cannot serialize cyclic structures.&quot;_s);</span>
409             return StringifyFailed;
410         }
411     }
412 
413     bool holderStackWasEmpty = m_holderStack.isEmpty();
<span class="line-modified">414     m_holderStack.append(Holder(m_exec, object));</span>
415     m_objectStack.appendWithCrashOnOverflow(object);
416     RETURN_IF_EXCEPTION(scope, StringifyFailed);
417     if (!holderStackWasEmpty)
418         return StringifySucceeded;
419 
420     do {
421         while (m_holderStack.last().appendNextProperty(*this, builder))
422             RETURN_IF_EXCEPTION(scope, StringifyFailed);
423         RETURN_IF_EXCEPTION(scope, StringifyFailed);
424         if (UNLIKELY(builder.hasOverflowed()))
425             return StringifyFailed;
426         m_holderStack.removeLast();
427         m_objectStack.removeLast();
428     } while (!m_holderStack.isEmpty());
429     return StringifySucceeded;
430 }
431 
432 inline bool Stringifier::willIndent() const
433 {
434     return !m_gap.isEmpty();
</pre>
<hr />
<pre>
441     if (newSize &gt; m_repeatedGap.length())
442         m_repeatedGap = makeString(m_repeatedGap, m_gap);
443     ASSERT(newSize &lt;= m_repeatedGap.length());
444     m_indent = m_repeatedGap.substringSharingImpl(0, newSize);
445 }
446 
447 inline void Stringifier::unindent()
448 {
449     ASSERT(m_indent.length() &gt;= m_gap.length());
450     m_indent = m_repeatedGap.substringSharingImpl(0, m_indent.length() - m_gap.length());
451 }
452 
453 inline void Stringifier::startNewLine(StringBuilder&amp; builder) const
454 {
455     if (m_gap.isEmpty())
456         return;
457     builder.append(&#39;\n&#39;);
458     builder.append(m_indent);
459 }
460 
<span class="line-modified">461 inline Stringifier::Holder::Holder(ExecState* exec, JSObject* object)</span>
462     : m_object(object)
463     , m_isJSArray(isJSArray(object))
<span class="line-modified">464     , m_isArray(JSC::isArray(exec, object))</span>
465 {
466 }
467 
468 inline Stringifier::Holder::Holder(RootHolderTag, JSObject* object)
469     : m_object(object)
470     , m_isJSArray(false)
471     , m_isArray(false)
472 {
473 }
474 
475 bool Stringifier::Holder::appendNextProperty(Stringifier&amp; stringifier, StringBuilder&amp; builder)
476 {
477     ASSERT(m_index &lt;= m_size);
478 
<span class="line-modified">479     ExecState* exec = stringifier.m_exec;</span>
<span class="line-modified">480     VM&amp; vm = exec-&gt;vm();</span>
481     auto scope = DECLARE_THROW_SCOPE(vm);
482 
483     // First time through, initialize.
484     if (!m_index) {
485         if (m_isArray) {
<span class="line-modified">486             if (m_isJSArray)</span>
<span class="line-modified">487                 m_size = asArray(m_object)-&gt;length();</span>
<span class="line-removed">488             else {</span>
<span class="line-removed">489                 JSValue value = m_object-&gt;get(exec, vm.propertyNames-&gt;length);</span>
<span class="line-removed">490                 RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-removed">491                 m_size = value.toUInt32(exec);</span>
<span class="line-removed">492                 RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-removed">493             }</span>
494             builder.append(&#39;[&#39;);
495         } else {
496             if (stringifier.m_usingArrayReplacer)
497                 m_propertyNames = stringifier.m_arrayReplacerPropertyNames.data();
498             else {
499                 PropertyNameArray objectPropertyNames(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">500                 m_object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(m_object, exec, objectPropertyNames, EnumerationMode());</span>
501                 RETURN_IF_EXCEPTION(scope, false);
502                 m_propertyNames = objectPropertyNames.releaseData();
503             }
504             m_size = m_propertyNames-&gt;propertyNameVector().size();
505             builder.append(&#39;{&#39;);
506         }
507         stringifier.indent();
508     }
509     if (UNLIKELY(builder.hasOverflowed()))
510         return false;
511 
512     // Last time through, finish up and return false.
513     if (m_index == m_size) {
514         stringifier.unindent();
515         if (m_size &amp;&amp; builder[builder.length() - 1] != &#39;{&#39;)
516             stringifier.startNewLine(builder);
517         builder.append(m_isArray ? &#39;]&#39; : &#39;}&#39;);
518         return false;
519     }
520 
521     // Handle a single element of the array or object.
522     unsigned index = m_index++;
523     unsigned rollBackPoint = 0;
524     StringifyResult stringifyResult;
525     if (m_isArray) {
526         // Get the value.
527         JSValue value;
<span class="line-modified">528         if (m_isJSArray &amp;&amp; asArray(m_object)-&gt;canGetIndexQuickly(index))</span>
<span class="line-modified">529             value = asArray(m_object)-&gt;getIndexQuickly(index);</span>
530         else {
531             PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
<span class="line-modified">532             bool hasProperty = m_object-&gt;getPropertySlot(exec, index, slot);</span>
533             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
534             if (hasProperty)
<span class="line-modified">535                 value = slot.getValue(exec, index);</span>
536             else
537                 value = jsUndefined();
538             RETURN_IF_EXCEPTION(scope, false);
539         }
540 
541         // Append the separator string.
542         if (index)
543             builder.append(&#39;,&#39;);
544         stringifier.startNewLine(builder);
545 
546         // Append the stringified value.
547         stringifyResult = stringifier.appendStringifiedValue(builder, value, *this, index);
548         ASSERT(stringifyResult != StringifyFailedDueToUndefinedOrSymbolValue);
549     } else {
550         // Get the value.
551         PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
552         Identifier&amp; propertyName = m_propertyNames-&gt;propertyNameVector()[index];
<span class="line-modified">553         bool hasProperty = m_object-&gt;getPropertySlot(exec, propertyName, slot);</span>
554         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
555         if (!hasProperty)
556             return true;
<span class="line-modified">557         JSValue value = slot.getValue(exec, propertyName);</span>
558         RETURN_IF_EXCEPTION(scope, false);
559 
560         rollBackPoint = builder.length();
561 
562         // Append the separator string.
563         if (builder[rollBackPoint - 1] != &#39;{&#39;)
564             builder.append(&#39;,&#39;);
565         stringifier.startNewLine(builder);
566 
567         // Append the property name.
568         builder.appendQuotedJSONString(propertyName.string());
569         builder.append(&#39;:&#39;);
570         if (stringifier.willIndent())
571             builder.append(&#39; &#39;);
572 
573         // Append the stringified value.
574         stringifyResult = stringifier.appendStringifiedValue(builder, value, *this, propertyName);
575     }
576     RETURN_IF_EXCEPTION(scope, false);
577 
</pre>
<hr />
<pre>
596     return true;
597 }
598 
599 // ------------------------------ JSONObject --------------------------------
600 
601 const ClassInfo JSONObject::s_info = { &quot;JSON&quot;, &amp;JSNonFinalObject::s_info, &amp;jsonTable, nullptr, CREATE_METHOD_TABLE(JSONObject) };
602 
603 /* Source for JSONObject.lut.h
604 @begin jsonTable
605   parse         JSONProtoFuncParse             DontEnum|Function 2
606   stringify     JSONProtoFuncStringify         DontEnum|Function 3
607 @end
608 */
609 
610 // ECMA 15.8
611 
612 class Walker {
613     WTF_MAKE_NONCOPYABLE(Walker);
614     WTF_FORBID_HEAP_ALLOCATION;
615 public:
<span class="line-modified">616     Walker(ExecState* exec, JSObject* function, CallType callType, CallData callData)</span>
<span class="line-modified">617         : m_exec(exec)</span>
618         , m_function(function)
619         , m_callType(callType)
620         , m_callData(callData)
621     {
622     }
623     JSValue walk(JSValue unfiltered);
624 private:
625     JSValue callReviver(JSObject* thisObj, JSValue property, JSValue unfiltered)
626     {
627         MarkedArgumentBuffer args;
628         args.append(property);
629         args.append(unfiltered);
630         ASSERT(!args.hasOverflowed());
<span class="line-modified">631         return call(m_exec, m_function, m_callType, m_callData, thisObj, args);</span>
632     }
633 
634     friend class Holder;
635 
<span class="line-modified">636     ExecState* m_exec;</span>
637     JSObject* m_function;
638     CallType m_callType;
639     CallData m_callData;
640 };
641 
642 // We clamp recursion well beyond anything reasonable.
<span class="line-modified">643 static const unsigned maximumFilterRecursion = 40000;</span>
644 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
645                                  ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember };
646 NEVER_INLINE JSValue Walker::walk(JSValue unfiltered)
647 {
<span class="line-modified">648     VM&amp; vm = m_exec-&gt;vm();</span>
649     auto scope = DECLARE_THROW_SCOPE(vm);
650 
651     Vector&lt;PropertyNameArray, 16, UnsafeVectorOverflow&gt; propertyStack;
652     Vector&lt;uint32_t, 16, UnsafeVectorOverflow&gt; indexStack;
653     MarkedArgumentBuffer markedStack;
654     Vector&lt;unsigned, 16, UnsafeVectorOverflow&gt; arrayLengthStack;
655 
656     Vector&lt;WalkerState, 16, UnsafeVectorOverflow&gt; stateStack;
657     WalkerState state = StateUnknown;
658     JSValue inValue = unfiltered;
659     JSValue outValue = jsNull();
660 
661     while (1) {
662         switch (state) {
663             arrayStartState:
664             case ArrayStartState: {
665                 ASSERT(inValue.isObject());
<span class="line-modified">666                 ASSERT(asObject(inValue)-&gt;inherits&lt;JSArray&gt;(vm));</span>


667                 if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">668                     return throwStackOverflowError(m_exec, scope);</span>
669 
<span class="line-modified">670                 JSArray* array = asArray(inValue);</span>
671                 markedStack.appendWithCrashOnOverflow(array);
<span class="line-modified">672                 arrayLengthStack.append(array-&gt;length());</span>


673                 indexStack.append(0);
674             }
675             arrayStartVisitMember:
676             FALLTHROUGH;
677             case ArrayStartVisitMember: {
<span class="line-modified">678                 JSArray* array = jsCast&lt;JSArray*&gt;(markedStack.last());</span>
679                 uint32_t index = indexStack.last();
680                 unsigned arrayLength = arrayLengthStack.last();
681                 if (index == arrayLength) {
682                     outValue = array;
683                     markedStack.removeLast();
684                     arrayLengthStack.removeLast();
685                     indexStack.removeLast();
686                     break;
687                 }
688                 if (isJSArray(array) &amp;&amp; array-&gt;canGetIndexQuickly(index))
689                     inValue = array-&gt;getIndexQuickly(index);
690                 else {
<span class="line-modified">691                     PropertySlot slot(array, PropertySlot::InternalMethodType::Get);</span>
<span class="line-removed">692                     if (array-&gt;methodTable(vm)-&gt;getOwnPropertySlotByIndex(array, m_exec, index, slot))</span>
<span class="line-removed">693                         inValue = slot.getValue(m_exec, index);</span>
<span class="line-removed">694                     else</span>
<span class="line-removed">695                         inValue = jsUndefined();</span>
696                     RETURN_IF_EXCEPTION(scope, { });
697                 }
698 
699                 if (inValue.isObject()) {
700                     stateStack.append(ArrayEndVisitMember);
701                     goto stateUnknown;
702                 } else
703                     outValue = inValue;
704                 FALLTHROUGH;
705             }
706             case ArrayEndVisitMember: {
<span class="line-modified">707                 JSArray* array = jsCast&lt;JSArray*&gt;(markedStack.last());</span>
708                 JSValue filteredValue = callReviver(array, jsString(vm, String::number(indexStack.last())), outValue);
709                 RETURN_IF_EXCEPTION(scope, { });
710                 if (filteredValue.isUndefined())
<span class="line-modified">711                     array-&gt;methodTable(vm)-&gt;deletePropertyByIndex(array, m_exec, indexStack.last());</span>
712                 else
<span class="line-modified">713                     array-&gt;putDirectIndex(m_exec, indexStack.last(), filteredValue, 0, PutDirectIndexShouldNotThrow);</span>
714                 RETURN_IF_EXCEPTION(scope, { });
715                 indexStack.last()++;
716                 goto arrayStartVisitMember;
717             }
718             objectStartState:
719             case ObjectStartState: {
720                 ASSERT(inValue.isObject());
<span class="line-modified">721                 ASSERT(!asObject(inValue)-&gt;inherits&lt;JSArray&gt;(vm));</span>
722                 if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">723                     return throwStackOverflowError(m_exec, scope);</span>
724 
725                 JSObject* object = asObject(inValue);
726                 markedStack.appendWithCrashOnOverflow(object);
727                 indexStack.append(0);
728                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">729                 object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());</span>
730                 RETURN_IF_EXCEPTION(scope, { });
731             }
732             objectStartVisitMember:
733             FALLTHROUGH;
734             case ObjectStartVisitMember: {
735                 JSObject* object = jsCast&lt;JSObject*&gt;(markedStack.last());
736                 uint32_t index = indexStack.last();
737                 PropertyNameArray&amp; properties = propertyStack.last();
738                 if (index == properties.size()) {
739                     outValue = object;
740                     markedStack.removeLast();
741                     indexStack.removeLast();
742                     propertyStack.removeLast();
743                     break;
744                 }
<span class="line-modified">745                 PropertySlot slot(object, PropertySlot::InternalMethodType::Get);</span>
<span class="line-removed">746                 if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_exec, properties[index], slot))</span>
<span class="line-removed">747                     inValue = slot.getValue(m_exec, properties[index]);</span>
<span class="line-removed">748                 else</span>
<span class="line-removed">749                     inValue = jsUndefined();</span>
<span class="line-removed">750 </span>
751                 // The holder may be modified by the reviver function so any lookup may throw
752                 RETURN_IF_EXCEPTION(scope, { });
753 
754                 if (inValue.isObject()) {
755                     stateStack.append(ObjectEndVisitMember);
756                     goto stateUnknown;
757                 } else
758                     outValue = inValue;
759                 FALLTHROUGH;
760             }
761             case ObjectEndVisitMember: {
762                 JSObject* object = jsCast&lt;JSObject*&gt;(markedStack.last());
763                 Identifier prop = propertyStack.last()[indexStack.last()];
764                 PutPropertySlot slot(object);
765                 JSValue filteredValue = callReviver(object, jsString(vm, prop.string()), outValue);
766                 RETURN_IF_EXCEPTION(scope, { });
767                 if (filteredValue.isUndefined())
<span class="line-modified">768                     object-&gt;methodTable(vm)-&gt;deleteProperty(object, m_exec, prop);</span>
769                 else
<span class="line-modified">770                     object-&gt;methodTable(vm)-&gt;put(object, m_exec, prop, filteredValue, slot);</span>
771                 RETURN_IF_EXCEPTION(scope, { });
772                 indexStack.last()++;
773                 goto objectStartVisitMember;
774             }
775             stateUnknown:
776             case StateUnknown:
777                 if (!inValue.isObject()) {
778                     outValue = inValue;
779                     break;
780                 }
<span class="line-modified">781                 JSObject* object = asObject(inValue);</span>
<span class="line-modified">782                 if (object-&gt;inherits&lt;JSArray&gt;(vm))</span>

783                     goto arrayStartState;
784                 goto objectStartState;
785         }
786         if (stateStack.isEmpty())
787             break;
788 
789         state = stateStack.last();
790         stateStack.removeLast();
791     }
<span class="line-modified">792     JSObject* finalHolder = constructEmptyObject(m_exec);</span>
<span class="line-modified">793     PutPropertySlot slot(finalHolder);</span>
<span class="line-removed">794     finalHolder-&gt;methodTable(vm)-&gt;put(finalHolder, m_exec, vm.propertyNames-&gt;emptyIdentifier, outValue, slot);</span>
<span class="line-removed">795     RETURN_IF_EXCEPTION(scope, { });</span>
796     RELEASE_AND_RETURN(scope, callReviver(finalHolder, jsEmptyString(vm), outValue));
797 }
798 
799 // ECMA-262 v5 15.12.2
<span class="line-modified">800 EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(ExecState* exec)</span>
801 {
<span class="line-modified">802     VM&amp; vm = exec-&gt;vm();</span>
803     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">804     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
805     RETURN_IF_EXCEPTION(scope, { });
806     StringView view = viewWithString.view;
807 
808     JSValue unfiltered;
809     if (view.is8Bit()) {
<span class="line-modified">810         LiteralParser&lt;LChar&gt; jsonParser(exec, view.characters8(), view.length(), StrictJSON);</span>
811         unfiltered = jsonParser.tryLiteralParse();
812         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
813         if (!unfiltered) {
814             RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">815             return throwVMError(exec, scope, createSyntaxError(exec, jsonParser.getErrorMessage()));</span>
816         }
817     } else {
<span class="line-modified">818         LiteralParser&lt;UChar&gt; jsonParser(exec, view.characters16(), view.length(), StrictJSON);</span>
819         unfiltered = jsonParser.tryLiteralParse();
820         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
821         if (!unfiltered) {
822             RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">823             return throwVMError(exec, scope, createSyntaxError(exec, jsonParser.getErrorMessage()));</span>
824         }
825     }
826 
<span class="line-modified">827     if (exec-&gt;argumentCount() &lt; 2)</span>
828         return JSValue::encode(unfiltered);
829 
<span class="line-modified">830     JSValue function = exec-&gt;uncheckedArgument(1);</span>
831     CallData callData;
832     CallType callType = getCallData(vm, function, callData);
833     if (callType == CallType::None)
834         return JSValue::encode(unfiltered);
835     scope.release();
<span class="line-modified">836     Walker walker(exec, asObject(function), callType, callData);</span>
837     return JSValue::encode(walker.walk(unfiltered));
838 }
839 
840 // ECMA-262 v5 15.12.3
<span class="line-modified">841 EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(ExecState* exec)</span>
842 {
<span class="line-modified">843     VM&amp; vm = exec-&gt;vm();</span>
844     auto scope = DECLARE_THROW_SCOPE(vm);
845 
<span class="line-modified">846     Stringifier stringifier(exec, exec-&gt;argument(1), exec-&gt;argument(2));</span>
847     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">848     RELEASE_AND_RETURN(scope, JSValue::encode(stringifier.stringify(exec-&gt;argument(0))));</span>
849 }
850 
<span class="line-modified">851 JSValue JSONParse(ExecState* exec, const String&amp; json)</span>
852 {
853     if (json.isNull())
854         return JSValue();
855 
856     if (json.is8Bit()) {
<span class="line-modified">857         LiteralParser&lt;LChar&gt; jsonParser(exec, json.characters8(), json.length(), StrictJSON);</span>
858         return jsonParser.tryLiteralParse();
859     }
860 
<span class="line-modified">861     LiteralParser&lt;UChar&gt; jsonParser(exec, json.characters16(), json.length(), StrictJSON);</span>
862     return jsonParser.tryLiteralParse();
863 }
864 
<span class="line-modified">865 String JSONStringify(ExecState* exec, JSValue value, JSValue space)</span>
866 {
<span class="line-modified">867     VM&amp; vm = exec-&gt;vm();</span>
868     auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">869     Stringifier stringifier(exec, jsNull(), space);</span>
870     RETURN_IF_EXCEPTION(throwScope, { });
871     JSValue result = stringifier.stringify(value);
872     if (UNLIKELY(throwScope.exception()) || result.isUndefinedOrNull())
873         return String();
<span class="line-modified">874     return result.getString(exec);</span>
875 }
876 
<span class="line-modified">877 String JSONStringify(ExecState* exec, JSValue value, unsigned indent)</span>
878 {
<span class="line-modified">879     return JSONStringify(exec, value, jsNumber(indent));</span>
880 }
881 
882 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSONObject.h&quot;
 28 
 29 #include &quot;ArrayConstructor.h&quot;
 30 #include &quot;BigIntObject.h&quot;
 31 #include &quot;BooleanObject.h&quot;
 32 #include &quot;Error.h&quot;
 33 #include &quot;ExceptionHelpers.h&quot;
 34 #include &quot;JSArray.h&quot;
<span class="line-added"> 35 #include &quot;JSArrayInlines.h&quot;</span>
 36 #include &quot;JSGlobalObject.h&quot;
 37 #include &quot;LiteralParser.h&quot;
 38 #include &quot;Lookup.h&quot;
 39 #include &quot;ObjectConstructor.h&quot;
 40 #include &quot;JSCInlines.h&quot;
 41 #include &quot;PropertyNameArray.h&quot;
 42 #include &lt;wtf/MathExtras.h&gt;
 43 #include &lt;wtf/text/StringBuilder.h&gt;
 44 
 45 namespace JSC {
 46 
 47 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSONObject);
 48 
<span class="line-modified"> 49 EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 50 EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject*, CallFrame*);</span>
 51 
 52 }
 53 
 54 #include &quot;JSONObject.lut.h&quot;
 55 
 56 namespace JSC {
 57 
 58 JSONObject::JSONObject(VM&amp; vm, Structure* structure)
 59     : JSNonFinalObject(vm, structure)
 60 {
 61 }
 62 
 63 void JSONObject::finishCreation(VM&amp; vm)
 64 {
 65     Base::finishCreation(vm);
 66     ASSERT(inherits(vm, info()));
 67 
<span class="line-modified"> 68     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsNontrivialString(vm, &quot;JSON&quot;_s), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);</span>
 69 }
 70 
 71 // PropertyNameForFunctionCall objects must be on the stack, since the JSValue that they create is not marked.
 72 class PropertyNameForFunctionCall {
 73 public:
 74     PropertyNameForFunctionCall(const Identifier&amp;);
 75     PropertyNameForFunctionCall(unsigned);
 76 
<span class="line-modified"> 77     JSValue value(JSGlobalObject*) const;</span>
 78 
 79 private:
 80     const Identifier* m_identifier;
 81     unsigned m_number;
 82     mutable JSValue m_value;
 83 };
 84 
 85 class Stringifier {
 86     WTF_MAKE_NONCOPYABLE(Stringifier);
 87     WTF_FORBID_HEAP_ALLOCATION;
 88 public:
<span class="line-modified"> 89     Stringifier(JSGlobalObject*, JSValue replacer, JSValue space);</span>
 90     JSValue stringify(JSValue);
 91 
 92 private:
 93     class Holder {
 94     public:
 95         enum RootHolderTag { RootHolder };
<span class="line-modified"> 96         Holder(JSGlobalObject*, JSObject*);</span>
 97         Holder(RootHolderTag, JSObject*);
 98 
 99         JSObject* object() const { return m_object; }
100         bool isArray() const { return m_isArray; }
101 
102         bool appendNextProperty(Stringifier&amp;, StringBuilder&amp;);
103 
104     private:
105         JSObject* m_object;
106         const bool m_isJSArray;
107         const bool m_isArray;
108         unsigned m_index { 0 };
109         unsigned m_size { 0 };
110         RefPtr&lt;PropertyNameArrayData&gt; m_propertyNames;
111     };
112 
113     friend class Holder;
114 
115     JSValue toJSON(JSValue, const PropertyNameForFunctionCall&amp;);
116     JSValue toJSONImpl(VM&amp;, JSValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp;);
117 
118     enum StringifyResult { StringifyFailed, StringifySucceeded, StringifyFailedDueToUndefinedOrSymbolValue };
119     StringifyResult appendStringifiedValue(StringBuilder&amp;, JSValue, const Holder&amp;, const PropertyNameForFunctionCall&amp;);
120 
121     bool willIndent() const;
122     void indent();
123     void unindent();
124     void startNewLine(StringBuilder&amp;) const;
125     bool isCallableReplacer() const { return m_replacerCallType != CallType::None; }
126 
<span class="line-modified">127     JSGlobalObject* const m_globalObject;</span>
128     JSValue m_replacer;
129     bool m_usingArrayReplacer { false };
130     PropertyNameArray m_arrayReplacerPropertyNames;
131     CallType m_replacerCallType { CallType::None };
132     CallData m_replacerCallData;
133     String m_gap;
134 
135     MarkedArgumentBuffer m_objectStack;
136     Vector&lt;Holder, 16, UnsafeVectorOverflow&gt; m_holderStack;
137     String m_repeatedGap;
138     String m_indent;
139 };
140 
141 // ------------------------------ helper functions --------------------------------
142 
<span class="line-modified">143 static inline JSValue unwrapBoxedPrimitive(JSGlobalObject* globalObject, JSValue value)</span>
144 {
<span class="line-modified">145     VM&amp; vm = globalObject-&gt;vm();</span>
146     if (!value.isObject())
147         return value;
148     JSObject* object = asObject(value);
149     if (object-&gt;inherits&lt;NumberObject&gt;(vm))
<span class="line-modified">150         return jsNumber(object-&gt;toNumber(globalObject));</span>
151     if (object-&gt;inherits&lt;StringObject&gt;(vm))
<span class="line-modified">152         return object-&gt;toString(globalObject);</span>
153     if (object-&gt;inherits&lt;BooleanObject&gt;(vm) || object-&gt;inherits&lt;BigIntObject&gt;(vm))
154         return jsCast&lt;JSWrapperObject*&gt;(object)-&gt;internalValue();
155 
156     // Do not unwrap SymbolObject to Symbol. It is not performed in the spec.
157     // http://www.ecma-international.org/ecma-262/6.0/#sec-serializejsonproperty
158     return value;
159 }
160 
<span class="line-modified">161 static inline String gap(JSGlobalObject* globalObject, JSValue space)</span>
162 {
<span class="line-modified">163     VM&amp; vm = globalObject-&gt;vm();</span>
164     auto scope = DECLARE_THROW_SCOPE(vm);
165 
166     const unsigned maxGapLength = 10;
<span class="line-modified">167     space = unwrapBoxedPrimitive(globalObject, space);</span>
168     RETURN_IF_EXCEPTION(scope, { });
169 
170     // If the space value is a number, create a gap string with that number of spaces.
171     if (space.isNumber()) {
172         double spaceCount = space.asNumber();
173         int count;
174         if (spaceCount &gt; maxGapLength)
175             count = maxGapLength;
176         else if (!(spaceCount &gt; 0))
177             count = 0;
178         else
179             count = static_cast&lt;int&gt;(spaceCount);
180         char spaces[maxGapLength];
181         for (int i = 0; i &lt; count; ++i)
182             spaces[i] = &#39; &#39;;
183         return String(spaces, count);
184     }
185 
186     // If the space value is a string, use it as the gap string, otherwise use no gap string.
<span class="line-modified">187     String spaces = space.getString(globalObject);</span>
<span class="line-added">188     RETURN_IF_EXCEPTION(scope, { });</span>
189     if (spaces.length() &lt;= maxGapLength)
190         return spaces;
191     return spaces.substringSharingImpl(0, maxGapLength);
192 }
193 
194 // ------------------------------ PropertyNameForFunctionCall --------------------------------
195 
196 inline PropertyNameForFunctionCall::PropertyNameForFunctionCall(const Identifier&amp; identifier)
197     : m_identifier(&amp;identifier)
198 {
199 }
200 
201 inline PropertyNameForFunctionCall::PropertyNameForFunctionCall(unsigned number)
202     : m_identifier(0)
203     , m_number(number)
204 {
205 }
206 
<span class="line-modified">207 JSValue PropertyNameForFunctionCall::value(JSGlobalObject* globalObject) const</span>
208 {
209     if (!m_value) {
<span class="line-modified">210         VM&amp; vm = globalObject-&gt;vm();</span>
211         if (m_identifier)
212             m_value = jsString(vm, m_identifier-&gt;string());
213         else {
214             if (m_number &lt;= 9)
215                 return vm.smallStrings.singleCharacterString(m_number + &#39;0&#39;);
216             m_value = jsNontrivialString(vm, vm.numericStrings.add(m_number));
217         }
218     }
219     return m_value;
220 }
221 
222 // ------------------------------ Stringifier --------------------------------
223 
<span class="line-modified">224 Stringifier::Stringifier(JSGlobalObject* globalObject, JSValue replacer, JSValue space)</span>
<span class="line-modified">225     : m_globalObject(globalObject)</span>
226     , m_replacer(replacer)
<span class="line-modified">227     , m_arrayReplacerPropertyNames(globalObject-&gt;vm(), PropertyNameMode::Strings, PrivateSymbolMode::Exclude)</span>
228 {
<span class="line-modified">229     VM&amp; vm = globalObject-&gt;vm();</span>
230     auto scope = DECLARE_THROW_SCOPE(vm);
231 
232     if (m_replacer.isObject()) {
233         JSObject* replacerObject = asObject(m_replacer);
234 
235         m_replacerCallType = CallType::None;
236         if (!replacerObject-&gt;isCallable(vm, m_replacerCallType, m_replacerCallData)) {
<span class="line-modified">237             bool isArrayReplacer = JSC::isArray(globalObject, replacerObject);</span>
238             RETURN_IF_EXCEPTION(scope, );
239             if (isArrayReplacer) {
240                 m_usingArrayReplacer = true;
<span class="line-modified">241                 unsigned length = toLength(globalObject, replacerObject);</span>
242                 RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">243                 for (unsigned index = 0; index &lt; length; ++index) {</span>
<span class="line-modified">244                     JSValue name;</span>
<span class="line-modified">245                     if (isJSArray(replacerObject) &amp;&amp; replacerObject-&gt;canGetIndexQuickly(index))</span>
<span class="line-added">246                         name = replacerObject-&gt;getIndexQuickly(index);</span>
<span class="line-added">247                     else {</span>
<span class="line-added">248                         name = replacerObject-&gt;get(globalObject, index);</span>
<span class="line-added">249                         RETURN_IF_EXCEPTION(scope, );</span>
<span class="line-added">250                     }</span>
251                     if (name.isObject()) {
252                         auto* nameObject = jsCast&lt;JSObject*&gt;(name);
253                         if (!nameObject-&gt;inherits&lt;NumberObject&gt;(vm) &amp;&amp; !nameObject-&gt;inherits&lt;StringObject&gt;(vm))
254                             continue;
255                     } else if (!name.isNumber() &amp;&amp; !name.isString())
256                         continue;
<span class="line-modified">257                     JSString* propertyNameString = name.toString(globalObject);</span>
258                     RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">259                     auto propertyName = propertyNameString-&gt;toIdentifier(globalObject);</span>
260                     RETURN_IF_EXCEPTION(scope, );
261                     m_arrayReplacerPropertyNames.add(WTFMove(propertyName));
262                 }
263             }
264         }
265     }
266 
267     scope.release();
<span class="line-modified">268     m_gap = gap(globalObject, space);</span>
269 }
270 
271 JSValue Stringifier::stringify(JSValue value)
272 {
<span class="line-modified">273     VM&amp; vm = m_globalObject-&gt;vm();</span>
274     auto scope = DECLARE_THROW_SCOPE(vm);
275 
276     PropertyNameForFunctionCall emptyPropertyName(vm.propertyNames-&gt;emptyIdentifier);
277 
278     // If the replacer is not callable, root object wrapper is non-user-observable.
279     // We can skip creating this wrapper object.
280     JSObject* object = nullptr;
281     if (isCallableReplacer()) {
<span class="line-modified">282         object = constructEmptyObject(m_globalObject);</span>

283         object-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, value);
284     }
285 
286     StringBuilder result(StringBuilder::OverflowHandler::RecordOverflow);
287     Holder root(Holder::RootHolder, object);
288     auto stringifyResult = appendStringifiedValue(result, value, root, emptyPropertyName);
289     RETURN_IF_EXCEPTION(scope, jsUndefined());
290     if (UNLIKELY(result.hasOverflowed())) {
<span class="line-modified">291         throwOutOfMemoryError(m_globalObject, scope);</span>
292         return jsUndefined();
293     }
294     if (UNLIKELY(stringifyResult != StringifySucceeded))
295         return jsUndefined();
296     RELEASE_AND_RETURN(scope, jsString(vm, result.toString()));
297 }
298 
299 ALWAYS_INLINE JSValue Stringifier::toJSON(JSValue baseValue, const PropertyNameForFunctionCall&amp; propertyName)
300 {
<span class="line-modified">301     VM&amp; vm = m_globalObject-&gt;vm();</span>
302     auto scope = DECLARE_THROW_SCOPE(vm);
303     scope.assertNoException();
304 
305     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified">306     bool hasProperty = baseValue.getPropertySlot(m_globalObject, vm.propertyNames-&gt;toJSON, slot);</span>
307     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
308     if (!hasProperty)
309         return baseValue;
310 
<span class="line-modified">311     JSValue toJSONFunction = slot.getValue(m_globalObject, vm.propertyNames-&gt;toJSON);</span>
312     RETURN_IF_EXCEPTION(scope, { });
313     RELEASE_AND_RETURN(scope, toJSONImpl(vm, baseValue, toJSONFunction, propertyName));
314 }
315 
316 JSValue Stringifier::toJSONImpl(VM&amp; vm, JSValue baseValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp; propertyName)
317 {
318     CallType callType;
319     CallData callData;
320     if (!toJSONFunction.isCallable(vm, callType, callData))
321         return baseValue;
322 
323     MarkedArgumentBuffer args;
<span class="line-modified">324     args.append(propertyName.value(m_globalObject));</span>
325     ASSERT(!args.hasOverflowed());
<span class="line-modified">326     return call(m_globalObject, asObject(toJSONFunction), callType, callData, baseValue, args);</span>
327 }
328 
329 Stringifier::StringifyResult Stringifier::appendStringifiedValue(StringBuilder&amp; builder, JSValue value, const Holder&amp; holder, const PropertyNameForFunctionCall&amp; propertyName)
330 {
<span class="line-modified">331     VM&amp; vm = m_globalObject-&gt;vm();</span>
332     auto scope = DECLARE_THROW_SCOPE(vm);
333 
334     // Call the toJSON function.
335     if (value.isObject() || value.isBigInt()) {
336         value = toJSON(value, propertyName);
337         RETURN_IF_EXCEPTION(scope, StringifyFailed);
338     }
339 
340     // Call the replacer function.
341     if (isCallableReplacer()) {
342         MarkedArgumentBuffer args;
<span class="line-modified">343         args.append(propertyName.value(m_globalObject));</span>
344         args.append(value);
345         ASSERT(!args.hasOverflowed());
346         ASSERT(holder.object());
<span class="line-modified">347         value = call(m_globalObject, m_replacer, m_replacerCallType, m_replacerCallData, holder.object(), args);</span>
348         RETURN_IF_EXCEPTION(scope, StringifyFailed);
349     }
350 
351     if ((value.isUndefined() || value.isSymbol()) &amp;&amp; !holder.isArray())
352         return StringifyFailedDueToUndefinedOrSymbolValue;
353 
354     if (value.isNull()) {
355         builder.appendLiteral(&quot;null&quot;);
356         return StringifySucceeded;
357     }
358 
<span class="line-modified">359     value = unwrapBoxedPrimitive(m_globalObject, value);</span>
360 
361     RETURN_IF_EXCEPTION(scope, StringifyFailed);
362 
363     if (value.isBoolean()) {
364         if (value.isTrue())
365             builder.appendLiteral(&quot;true&quot;);
366         else
367             builder.appendLiteral(&quot;false&quot;);
368         return StringifySucceeded;
369     }
370 
371     if (value.isString()) {
<span class="line-modified">372         const String&amp; string = asString(value)-&gt;value(m_globalObject);</span>
373         RETURN_IF_EXCEPTION(scope, StringifyFailed);
374         builder.appendQuotedJSONString(string);
375         return StringifySucceeded;
376     }
377 
378     if (value.isNumber()) {
379         if (value.isInt32())
380             builder.appendNumber(value.asInt32());
381         else {
382             double number = value.asNumber();
383             if (!std::isfinite(number))
384                 builder.appendLiteral(&quot;null&quot;);
385             else
386                 builder.appendNumber(number);
387         }
388         return StringifySucceeded;
389     }
390 
391     if (value.isBigInt()) {
<span class="line-modified">392         throwTypeError(m_globalObject, scope, &quot;JSON.stringify cannot serialize BigInt.&quot;_s);</span>
393         return StringifyFailed;
394     }
395 
396     if (!value.isObject())
397         return StringifyFailed;
398 
399     JSObject* object = asObject(value);
400     if (object-&gt;isFunction(vm)) {
401         if (holder.isArray()) {
402             builder.appendLiteral(&quot;null&quot;);
403             return StringifySucceeded;
404         }
405         return StringifyFailedDueToUndefinedOrSymbolValue;
406     }
407 
408     if (UNLIKELY(builder.hasOverflowed()))
409         return StringifyFailed;
410 
411     // Handle cycle detection, and put the holder on the stack.
412     for (unsigned i = 0; i &lt; m_holderStack.size(); i++) {
413         if (m_holderStack[i].object() == object) {
<span class="line-modified">414             throwTypeError(m_globalObject, scope, &quot;JSON.stringify cannot serialize cyclic structures.&quot;_s);</span>
415             return StringifyFailed;
416         }
417     }
418 
419     bool holderStackWasEmpty = m_holderStack.isEmpty();
<span class="line-modified">420     m_holderStack.append(Holder(m_globalObject, object));</span>
421     m_objectStack.appendWithCrashOnOverflow(object);
422     RETURN_IF_EXCEPTION(scope, StringifyFailed);
423     if (!holderStackWasEmpty)
424         return StringifySucceeded;
425 
426     do {
427         while (m_holderStack.last().appendNextProperty(*this, builder))
428             RETURN_IF_EXCEPTION(scope, StringifyFailed);
429         RETURN_IF_EXCEPTION(scope, StringifyFailed);
430         if (UNLIKELY(builder.hasOverflowed()))
431             return StringifyFailed;
432         m_holderStack.removeLast();
433         m_objectStack.removeLast();
434     } while (!m_holderStack.isEmpty());
435     return StringifySucceeded;
436 }
437 
438 inline bool Stringifier::willIndent() const
439 {
440     return !m_gap.isEmpty();
</pre>
<hr />
<pre>
447     if (newSize &gt; m_repeatedGap.length())
448         m_repeatedGap = makeString(m_repeatedGap, m_gap);
449     ASSERT(newSize &lt;= m_repeatedGap.length());
450     m_indent = m_repeatedGap.substringSharingImpl(0, newSize);
451 }
452 
453 inline void Stringifier::unindent()
454 {
455     ASSERT(m_indent.length() &gt;= m_gap.length());
456     m_indent = m_repeatedGap.substringSharingImpl(0, m_indent.length() - m_gap.length());
457 }
458 
459 inline void Stringifier::startNewLine(StringBuilder&amp; builder) const
460 {
461     if (m_gap.isEmpty())
462         return;
463     builder.append(&#39;\n&#39;);
464     builder.append(m_indent);
465 }
466 
<span class="line-modified">467 inline Stringifier::Holder::Holder(JSGlobalObject* globalObject, JSObject* object)</span>
468     : m_object(object)
469     , m_isJSArray(isJSArray(object))
<span class="line-modified">470     , m_isArray(JSC::isArray(globalObject, object))</span>
471 {
472 }
473 
474 inline Stringifier::Holder::Holder(RootHolderTag, JSObject* object)
475     : m_object(object)
476     , m_isJSArray(false)
477     , m_isArray(false)
478 {
479 }
480 
481 bool Stringifier::Holder::appendNextProperty(Stringifier&amp; stringifier, StringBuilder&amp; builder)
482 {
483     ASSERT(m_index &lt;= m_size);
484 
<span class="line-modified">485     JSGlobalObject* globalObject = stringifier.m_globalObject;</span>
<span class="line-modified">486     VM&amp; vm = globalObject-&gt;vm();</span>
487     auto scope = DECLARE_THROW_SCOPE(vm);
488 
489     // First time through, initialize.
490     if (!m_index) {
491         if (m_isArray) {
<span class="line-modified">492             m_size = toLength(globalObject, m_object);</span>
<span class="line-modified">493             RETURN_IF_EXCEPTION(scope, false);</span>






494             builder.append(&#39;[&#39;);
495         } else {
496             if (stringifier.m_usingArrayReplacer)
497                 m_propertyNames = stringifier.m_arrayReplacerPropertyNames.data();
498             else {
499                 PropertyNameArray objectPropertyNames(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">500                 m_object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(m_object, globalObject, objectPropertyNames, EnumerationMode());</span>
501                 RETURN_IF_EXCEPTION(scope, false);
502                 m_propertyNames = objectPropertyNames.releaseData();
503             }
504             m_size = m_propertyNames-&gt;propertyNameVector().size();
505             builder.append(&#39;{&#39;);
506         }
507         stringifier.indent();
508     }
509     if (UNLIKELY(builder.hasOverflowed()))
510         return false;
511 
512     // Last time through, finish up and return false.
513     if (m_index == m_size) {
514         stringifier.unindent();
515         if (m_size &amp;&amp; builder[builder.length() - 1] != &#39;{&#39;)
516             stringifier.startNewLine(builder);
517         builder.append(m_isArray ? &#39;]&#39; : &#39;}&#39;);
518         return false;
519     }
520 
521     // Handle a single element of the array or object.
522     unsigned index = m_index++;
523     unsigned rollBackPoint = 0;
524     StringifyResult stringifyResult;
525     if (m_isArray) {
526         // Get the value.
527         JSValue value;
<span class="line-modified">528         if (m_isJSArray &amp;&amp; m_object-&gt;canGetIndexQuickly(index))</span>
<span class="line-modified">529             value = m_object-&gt;getIndexQuickly(index);</span>
530         else {
531             PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
<span class="line-modified">532             bool hasProperty = m_object-&gt;getPropertySlot(globalObject, index, slot);</span>
533             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
534             if (hasProperty)
<span class="line-modified">535                 value = slot.getValue(globalObject, index);</span>
536             else
537                 value = jsUndefined();
538             RETURN_IF_EXCEPTION(scope, false);
539         }
540 
541         // Append the separator string.
542         if (index)
543             builder.append(&#39;,&#39;);
544         stringifier.startNewLine(builder);
545 
546         // Append the stringified value.
547         stringifyResult = stringifier.appendStringifiedValue(builder, value, *this, index);
548         ASSERT(stringifyResult != StringifyFailedDueToUndefinedOrSymbolValue);
549     } else {
550         // Get the value.
551         PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
552         Identifier&amp; propertyName = m_propertyNames-&gt;propertyNameVector()[index];
<span class="line-modified">553         bool hasProperty = m_object-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
554         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
555         if (!hasProperty)
556             return true;
<span class="line-modified">557         JSValue value = slot.getValue(globalObject, propertyName);</span>
558         RETURN_IF_EXCEPTION(scope, false);
559 
560         rollBackPoint = builder.length();
561 
562         // Append the separator string.
563         if (builder[rollBackPoint - 1] != &#39;{&#39;)
564             builder.append(&#39;,&#39;);
565         stringifier.startNewLine(builder);
566 
567         // Append the property name.
568         builder.appendQuotedJSONString(propertyName.string());
569         builder.append(&#39;:&#39;);
570         if (stringifier.willIndent())
571             builder.append(&#39; &#39;);
572 
573         // Append the stringified value.
574         stringifyResult = stringifier.appendStringifiedValue(builder, value, *this, propertyName);
575     }
576     RETURN_IF_EXCEPTION(scope, false);
577 
</pre>
<hr />
<pre>
596     return true;
597 }
598 
599 // ------------------------------ JSONObject --------------------------------
600 
601 const ClassInfo JSONObject::s_info = { &quot;JSON&quot;, &amp;JSNonFinalObject::s_info, &amp;jsonTable, nullptr, CREATE_METHOD_TABLE(JSONObject) };
602 
603 /* Source for JSONObject.lut.h
604 @begin jsonTable
605   parse         JSONProtoFuncParse             DontEnum|Function 2
606   stringify     JSONProtoFuncStringify         DontEnum|Function 3
607 @end
608 */
609 
610 // ECMA 15.8
611 
612 class Walker {
613     WTF_MAKE_NONCOPYABLE(Walker);
614     WTF_FORBID_HEAP_ALLOCATION;
615 public:
<span class="line-modified">616     Walker(JSGlobalObject* globalObject, JSObject* function, CallType callType, CallData callData)</span>
<span class="line-modified">617         : m_globalObject(globalObject)</span>
618         , m_function(function)
619         , m_callType(callType)
620         , m_callData(callData)
621     {
622     }
623     JSValue walk(JSValue unfiltered);
624 private:
625     JSValue callReviver(JSObject* thisObj, JSValue property, JSValue unfiltered)
626     {
627         MarkedArgumentBuffer args;
628         args.append(property);
629         args.append(unfiltered);
630         ASSERT(!args.hasOverflowed());
<span class="line-modified">631         return call(m_globalObject, m_function, m_callType, m_callData, thisObj, args);</span>
632     }
633 
634     friend class Holder;
635 
<span class="line-modified">636     JSGlobalObject* m_globalObject;</span>
637     JSObject* m_function;
638     CallType m_callType;
639     CallData m_callData;
640 };
641 
642 // We clamp recursion well beyond anything reasonable.
<span class="line-modified">643 static constexpr unsigned maximumFilterRecursion = 40000;</span>
644 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
645                                  ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember };
646 NEVER_INLINE JSValue Walker::walk(JSValue unfiltered)
647 {
<span class="line-modified">648     VM&amp; vm = m_globalObject-&gt;vm();</span>
649     auto scope = DECLARE_THROW_SCOPE(vm);
650 
651     Vector&lt;PropertyNameArray, 16, UnsafeVectorOverflow&gt; propertyStack;
652     Vector&lt;uint32_t, 16, UnsafeVectorOverflow&gt; indexStack;
653     MarkedArgumentBuffer markedStack;
654     Vector&lt;unsigned, 16, UnsafeVectorOverflow&gt; arrayLengthStack;
655 
656     Vector&lt;WalkerState, 16, UnsafeVectorOverflow&gt; stateStack;
657     WalkerState state = StateUnknown;
658     JSValue inValue = unfiltered;
659     JSValue outValue = jsNull();
660 
661     while (1) {
662         switch (state) {
663             arrayStartState:
664             case ArrayStartState: {
665                 ASSERT(inValue.isObject());
<span class="line-modified">666                 ASSERT(isArray(m_globalObject, inValue));</span>
<span class="line-added">667                 EXCEPTION_ASSERT(!scope.exception());</span>
<span class="line-added">668 </span>
669                 if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">670                     return throwStackOverflowError(m_globalObject, scope);</span>
671 
<span class="line-modified">672                 JSObject* array = asObject(inValue);</span>
673                 markedStack.appendWithCrashOnOverflow(array);
<span class="line-modified">674                 unsigned length = toLength(m_globalObject, array);</span>
<span class="line-added">675                 RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">676                 arrayLengthStack.append(length);</span>
677                 indexStack.append(0);
678             }
679             arrayStartVisitMember:
680             FALLTHROUGH;
681             case ArrayStartVisitMember: {
<span class="line-modified">682                 JSObject* array = asObject(markedStack.last());</span>
683                 uint32_t index = indexStack.last();
684                 unsigned arrayLength = arrayLengthStack.last();
685                 if (index == arrayLength) {
686                     outValue = array;
687                     markedStack.removeLast();
688                     arrayLengthStack.removeLast();
689                     indexStack.removeLast();
690                     break;
691                 }
692                 if (isJSArray(array) &amp;&amp; array-&gt;canGetIndexQuickly(index))
693                     inValue = array-&gt;getIndexQuickly(index);
694                 else {
<span class="line-modified">695                     inValue = array-&gt;get(m_globalObject, index);</span>




696                     RETURN_IF_EXCEPTION(scope, { });
697                 }
698 
699                 if (inValue.isObject()) {
700                     stateStack.append(ArrayEndVisitMember);
701                     goto stateUnknown;
702                 } else
703                     outValue = inValue;
704                 FALLTHROUGH;
705             }
706             case ArrayEndVisitMember: {
<span class="line-modified">707                 JSObject* array = asObject(markedStack.last());</span>
708                 JSValue filteredValue = callReviver(array, jsString(vm, String::number(indexStack.last())), outValue);
709                 RETURN_IF_EXCEPTION(scope, { });
710                 if (filteredValue.isUndefined())
<span class="line-modified">711                     array-&gt;methodTable(vm)-&gt;deletePropertyByIndex(array, m_globalObject, indexStack.last());</span>
712                 else
<span class="line-modified">713                     array-&gt;putDirectIndex(m_globalObject, indexStack.last(), filteredValue, 0, PutDirectIndexShouldNotThrow);</span>
714                 RETURN_IF_EXCEPTION(scope, { });
715                 indexStack.last()++;
716                 goto arrayStartVisitMember;
717             }
718             objectStartState:
719             case ObjectStartState: {
720                 ASSERT(inValue.isObject());
<span class="line-modified">721                 ASSERT(!isJSArray(inValue));</span>
722                 if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">723                     return throwStackOverflowError(m_globalObject, scope);</span>
724 
725                 JSObject* object = asObject(inValue);
726                 markedStack.appendWithCrashOnOverflow(object);
727                 indexStack.append(0);
728                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">729                 object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_globalObject, propertyStack.last(), EnumerationMode());</span>
730                 RETURN_IF_EXCEPTION(scope, { });
731             }
732             objectStartVisitMember:
733             FALLTHROUGH;
734             case ObjectStartVisitMember: {
735                 JSObject* object = jsCast&lt;JSObject*&gt;(markedStack.last());
736                 uint32_t index = indexStack.last();
737                 PropertyNameArray&amp; properties = propertyStack.last();
738                 if (index == properties.size()) {
739                     outValue = object;
740                     markedStack.removeLast();
741                     indexStack.removeLast();
742                     propertyStack.removeLast();
743                     break;
744                 }
<span class="line-modified">745                 inValue = object-&gt;get(m_globalObject, properties[index]);</span>





746                 // The holder may be modified by the reviver function so any lookup may throw
747                 RETURN_IF_EXCEPTION(scope, { });
748 
749                 if (inValue.isObject()) {
750                     stateStack.append(ObjectEndVisitMember);
751                     goto stateUnknown;
752                 } else
753                     outValue = inValue;
754                 FALLTHROUGH;
755             }
756             case ObjectEndVisitMember: {
757                 JSObject* object = jsCast&lt;JSObject*&gt;(markedStack.last());
758                 Identifier prop = propertyStack.last()[indexStack.last()];
759                 PutPropertySlot slot(object);
760                 JSValue filteredValue = callReviver(object, jsString(vm, prop.string()), outValue);
761                 RETURN_IF_EXCEPTION(scope, { });
762                 if (filteredValue.isUndefined())
<span class="line-modified">763                     object-&gt;methodTable(vm)-&gt;deleteProperty(object, m_globalObject, prop);</span>
764                 else
<span class="line-modified">765                     object-&gt;methodTable(vm)-&gt;put(object, m_globalObject, prop, filteredValue, slot);</span>
766                 RETURN_IF_EXCEPTION(scope, { });
767                 indexStack.last()++;
768                 goto objectStartVisitMember;
769             }
770             stateUnknown:
771             case StateUnknown:
772                 if (!inValue.isObject()) {
773                     outValue = inValue;
774                     break;
775                 }
<span class="line-modified">776                 bool valueIsArray = isArray(m_globalObject, inValue);</span>
<span class="line-modified">777                 RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">778                 if (valueIsArray)</span>
779                     goto arrayStartState;
780                 goto objectStartState;
781         }
782         if (stateStack.isEmpty())
783             break;
784 
785         state = stateStack.last();
786         stateStack.removeLast();
787     }
<span class="line-modified">788     JSObject* finalHolder = constructEmptyObject(m_globalObject);</span>
<span class="line-modified">789     finalHolder-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, outValue);</span>


790     RELEASE_AND_RETURN(scope, callReviver(finalHolder, jsEmptyString(vm), outValue));
791 }
792 
793 // ECMA-262 v5 15.12.2
<span class="line-modified">794 EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
795 {
<span class="line-modified">796     VM&amp; vm = globalObject-&gt;vm();</span>
797     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">798     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
799     RETURN_IF_EXCEPTION(scope, { });
800     StringView view = viewWithString.view;
801 
802     JSValue unfiltered;
803     if (view.is8Bit()) {
<span class="line-modified">804         LiteralParser&lt;LChar&gt; jsonParser(globalObject, view.characters8(), view.length(), StrictJSON);</span>
805         unfiltered = jsonParser.tryLiteralParse();
806         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
807         if (!unfiltered) {
808             RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">809             return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));</span>
810         }
811     } else {
<span class="line-modified">812         LiteralParser&lt;UChar&gt; jsonParser(globalObject, view.characters16(), view.length(), StrictJSON);</span>
813         unfiltered = jsonParser.tryLiteralParse();
814         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
815         if (!unfiltered) {
816             RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">817             return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));</span>
818         }
819     }
820 
<span class="line-modified">821     if (callFrame-&gt;argumentCount() &lt; 2)</span>
822         return JSValue::encode(unfiltered);
823 
<span class="line-modified">824     JSValue function = callFrame-&gt;uncheckedArgument(1);</span>
825     CallData callData;
826     CallType callType = getCallData(vm, function, callData);
827     if (callType == CallType::None)
828         return JSValue::encode(unfiltered);
829     scope.release();
<span class="line-modified">830     Walker walker(globalObject, asObject(function), callType, callData);</span>
831     return JSValue::encode(walker.walk(unfiltered));
832 }
833 
834 // ECMA-262 v5 15.12.3
<span class="line-modified">835 EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
836 {
<span class="line-modified">837     VM&amp; vm = globalObject-&gt;vm();</span>
838     auto scope = DECLARE_THROW_SCOPE(vm);
839 
<span class="line-modified">840     Stringifier stringifier(globalObject, callFrame-&gt;argument(1), callFrame-&gt;argument(2));</span>
841     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">842     RELEASE_AND_RETURN(scope, JSValue::encode(stringifier.stringify(callFrame-&gt;argument(0))));</span>
843 }
844 
<span class="line-modified">845 JSValue JSONParse(JSGlobalObject* globalObject, const String&amp; json)</span>
846 {
847     if (json.isNull())
848         return JSValue();
849 
850     if (json.is8Bit()) {
<span class="line-modified">851         LiteralParser&lt;LChar&gt; jsonParser(globalObject, json.characters8(), json.length(), StrictJSON);</span>
852         return jsonParser.tryLiteralParse();
853     }
854 
<span class="line-modified">855     LiteralParser&lt;UChar&gt; jsonParser(globalObject, json.characters16(), json.length(), StrictJSON);</span>
856     return jsonParser.tryLiteralParse();
857 }
858 
<span class="line-modified">859 String JSONStringify(JSGlobalObject* globalObject, JSValue value, JSValue space)</span>
860 {
<span class="line-modified">861     VM&amp; vm = globalObject-&gt;vm();</span>
862     auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">863     Stringifier stringifier(globalObject, jsNull(), space);</span>
864     RETURN_IF_EXCEPTION(throwScope, { });
865     JSValue result = stringifier.stringify(value);
866     if (UNLIKELY(throwScope.exception()) || result.isUndefinedOrNull())
867         return String();
<span class="line-modified">868     return result.getString(globalObject);</span>
869 }
870 
<span class="line-modified">871 String JSONStringify(JSGlobalObject* globalObject, JSValue value, unsigned indent)</span>
872 {
<span class="line-modified">873     return JSONStringify(globalObject, value, jsNumber(indent));</span>
874 }
875 
876 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSNativeStdFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSONObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
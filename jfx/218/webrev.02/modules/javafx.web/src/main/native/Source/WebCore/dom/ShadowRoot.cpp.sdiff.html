<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectorQuery.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowRoot.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * this software without specific prior written permission.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 16  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 17  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 18  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 19  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 20  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 21  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 22  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 23  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ShadowRoot.h&quot;
 30 
 31 #include &quot;CSSStyleSheet.h&quot;
 32 #include &quot;ElementTraversal.h&quot;

 33 #include &quot;HTMLSlotElement.h&quot;



 34 #include &quot;RenderElement.h&quot;
 35 #include &quot;RuntimeEnabledFeatures.h&quot;
 36 #include &quot;SlotAssignment.h&quot;
 37 #include &quot;StyleResolver.h&quot;
 38 #include &quot;StyleScope.h&quot;
 39 #include &quot;StyleSheetList.h&quot;
 40 #include &quot;markup.h&quot;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(ShadowRoot);
 46 
 47 struct SameSizeAsShadowRoot : public DocumentFragment, public TreeScope {
<span class="line-modified"> 48     unsigned countersAndFlags[1];</span>

 49     void* styleScope;
 50     void* styleSheetList;
 51     void* host;
 52     void* slotAssignment;

 53 };
 54 
 55 COMPILE_ASSERT(sizeof(ShadowRoot) == sizeof(SameSizeAsShadowRoot), shadowroot_should_stay_small);
 56 
<span class="line-modified"> 57 ShadowRoot::ShadowRoot(Document&amp; document, ShadowRootMode type)</span>
 58     : DocumentFragment(document, CreateShadowRoot)
 59     , TreeScope(*this, document)

 60     , m_type(type)
 61     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 62 {
 63 }
 64 
 65 
 66 ShadowRoot::ShadowRoot(Document&amp; document, std::unique_ptr&lt;SlotAssignment&gt;&amp;&amp; slotAssignment)
 67     : DocumentFragment(document, CreateShadowRoot)
 68     , TreeScope(*this, document)
 69     , m_type(ShadowRootMode::UserAgent)
 70     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 71     , m_slotAssignment(WTFMove(slotAssignment))
 72 {
 73 }
 74 
 75 
 76 ShadowRoot::~ShadowRoot()
 77 {
 78     if (isConnected())
 79         document().didRemoveInDocumentShadowRoot(*this);
</pre>
<hr />
<pre>
235 
236 void ShadowRoot::removeSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slot, ContainerNode&amp; oldParentOfRemovedTree)
237 {
238     ASSERT(m_slotAssignment);
239     return m_slotAssignment-&gt;removeSlotElementByName(name, slot, &amp;oldParentOfRemovedTree, *this);
240 }
241 
242 void ShadowRoot::slotFallbackDidChange(HTMLSlotElement&amp; slot)
243 {
244     ASSERT(&amp;slot.rootNode() == this);
245     return m_slotAssignment-&gt;slotFallbackDidChange(slot, *this);
246 }
247 
248 const Vector&lt;Node*&gt;* ShadowRoot::assignedNodesForSlot(const HTMLSlotElement&amp; slot)
249 {
250     if (!m_slotAssignment)
251         return nullptr;
252     return m_slotAssignment-&gt;assignedNodesForSlot(slot, *this);
253 }
254 


























































































255 Vector&lt;ShadowRoot*&gt; assignedShadowRootsIfSlotted(const Node&amp; node)
256 {
257     Vector&lt;ShadowRoot*&gt; result;
258     for (auto* slot = node.assignedSlot(); slot; slot = slot-&gt;assignedSlot()) {
259         ASSERT(slot-&gt;containingShadowRoot());
260         result.append(slot-&gt;containingShadowRoot());
261     }
262     return result;
263 }
264 








265 }
</pre>
</td>
<td>
<hr />
<pre>
 13  * this software without specific prior written permission.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 16  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 17  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 18  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 19  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 20  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 21  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 22  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 23  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ShadowRoot.h&quot;
 30 
 31 #include &quot;CSSStyleSheet.h&quot;
 32 #include &quot;ElementTraversal.h&quot;
<span class="line-added"> 33 #include &quot;HTMLParserIdioms.h&quot;</span>
 34 #include &quot;HTMLSlotElement.h&quot;
<span class="line-added"> 35 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 36 #include &quot;NotImplemented.h&quot;</span>
<span class="line-added"> 37 #endif</span>
 38 #include &quot;RenderElement.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;SlotAssignment.h&quot;
 41 #include &quot;StyleResolver.h&quot;
 42 #include &quot;StyleScope.h&quot;
 43 #include &quot;StyleSheetList.h&quot;
 44 #include &quot;markup.h&quot;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 WTF_MAKE_ISO_ALLOCATED_IMPL(ShadowRoot);
 50 
 51 struct SameSizeAsShadowRoot : public DocumentFragment, public TreeScope {
<span class="line-modified"> 52     bool flags[4];</span>
<span class="line-added"> 53     uint8_t mode;</span>
 54     void* styleScope;
 55     void* styleSheetList;
 56     void* host;
 57     void* slotAssignment;
<span class="line-added"> 58     Optional&lt;HashMap&lt;AtomString, AtomString&gt;&gt; partMappings;</span>
 59 };
 60 
 61 COMPILE_ASSERT(sizeof(ShadowRoot) == sizeof(SameSizeAsShadowRoot), shadowroot_should_stay_small);
 62 
<span class="line-modified"> 63 ShadowRoot::ShadowRoot(Document&amp; document, ShadowRootMode type, DelegatesFocus delegatesFocus)</span>
 64     : DocumentFragment(document, CreateShadowRoot)
 65     , TreeScope(*this, document)
<span class="line-added"> 66     , m_delegatesFocus(delegatesFocus == DelegatesFocus::Yes)</span>
 67     , m_type(type)
 68     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 69 {
 70 }
 71 
 72 
 73 ShadowRoot::ShadowRoot(Document&amp; document, std::unique_ptr&lt;SlotAssignment&gt;&amp;&amp; slotAssignment)
 74     : DocumentFragment(document, CreateShadowRoot)
 75     , TreeScope(*this, document)
 76     , m_type(ShadowRootMode::UserAgent)
 77     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 78     , m_slotAssignment(WTFMove(slotAssignment))
 79 {
 80 }
 81 
 82 
 83 ShadowRoot::~ShadowRoot()
 84 {
 85     if (isConnected())
 86         document().didRemoveInDocumentShadowRoot(*this);
</pre>
<hr />
<pre>
242 
243 void ShadowRoot::removeSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slot, ContainerNode&amp; oldParentOfRemovedTree)
244 {
245     ASSERT(m_slotAssignment);
246     return m_slotAssignment-&gt;removeSlotElementByName(name, slot, &amp;oldParentOfRemovedTree, *this);
247 }
248 
249 void ShadowRoot::slotFallbackDidChange(HTMLSlotElement&amp; slot)
250 {
251     ASSERT(&amp;slot.rootNode() == this);
252     return m_slotAssignment-&gt;slotFallbackDidChange(slot, *this);
253 }
254 
255 const Vector&lt;Node*&gt;* ShadowRoot::assignedNodesForSlot(const HTMLSlotElement&amp; slot)
256 {
257     if (!m_slotAssignment)
258         return nullptr;
259     return m_slotAssignment-&gt;assignedNodesForSlot(slot, *this);
260 }
261 
<span class="line-added">262 static Optional&lt;std::pair&lt;AtomString, AtomString&gt;&gt; parsePartMapping(StringView mappingString)</span>
<span class="line-added">263 {</span>
<span class="line-added">264     const auto end = mappingString.length();</span>
<span class="line-added">265 </span>
<span class="line-added">266     auto skipWhitespace = [&amp;](auto position) {</span>
<span class="line-added">267         while (position &lt; end &amp;&amp; isHTMLSpace(mappingString[position]))</span>
<span class="line-added">268             ++position;</span>
<span class="line-added">269         return position;</span>
<span class="line-added">270     };</span>
<span class="line-added">271 </span>
<span class="line-added">272     auto collectValue = [&amp;](auto position) {</span>
<span class="line-added">273         while (position &lt; end &amp;&amp; (!isHTMLSpace(mappingString[position]) &amp;&amp; mappingString[position] != &#39;:&#39;))</span>
<span class="line-added">274             ++position;</span>
<span class="line-added">275         return position;</span>
<span class="line-added">276     };</span>
<span class="line-added">277 </span>
<span class="line-added">278     size_t begin = 0;</span>
<span class="line-added">279     begin = skipWhitespace(begin);</span>
<span class="line-added">280 </span>
<span class="line-added">281     auto firstPartEnd = collectValue(begin);</span>
<span class="line-added">282     if (firstPartEnd == begin)</span>
<span class="line-added">283         return { };</span>
<span class="line-added">284 </span>
<span class="line-added">285     auto firstPart = mappingString.substring(begin, firstPartEnd - begin).toAtomString();</span>
<span class="line-added">286 </span>
<span class="line-added">287     begin = skipWhitespace(firstPartEnd);</span>
<span class="line-added">288     if (begin == end)</span>
<span class="line-added">289         return std::make_pair(firstPart, firstPart);</span>
<span class="line-added">290 </span>
<span class="line-added">291     if (mappingString[begin] != &#39;:&#39;)</span>
<span class="line-added">292         return { };</span>
<span class="line-added">293 </span>
<span class="line-added">294     begin = skipWhitespace(begin + 1);</span>
<span class="line-added">295 </span>
<span class="line-added">296     auto secondPartEnd = collectValue(begin);</span>
<span class="line-added">297     if (secondPartEnd == begin)</span>
<span class="line-added">298         return { };</span>
<span class="line-added">299 </span>
<span class="line-added">300     auto secondPart = mappingString.substring(begin, secondPartEnd - begin).toAtomString();</span>
<span class="line-added">301 </span>
<span class="line-added">302     begin = skipWhitespace(secondPartEnd);</span>
<span class="line-added">303     if (begin != end)</span>
<span class="line-added">304         return { };</span>
<span class="line-added">305 </span>
<span class="line-added">306     return std::make_pair(firstPart, secondPart);</span>
<span class="line-added">307 }</span>
<span class="line-added">308 </span>
<span class="line-added">309 static ShadowRoot::PartMappings parsePartMappingsList(StringView mappingsListString)</span>
<span class="line-added">310 {</span>
<span class="line-added">311     if (!RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())</span>
<span class="line-added">312         return { };</span>
<span class="line-added">313 </span>
<span class="line-added">314     ShadowRoot::PartMappings mappings;</span>
<span class="line-added">315 </span>
<span class="line-added">316     const auto end = mappingsListString.length();</span>
<span class="line-added">317 </span>
<span class="line-added">318     size_t begin = 0;</span>
<span class="line-added">319     while (begin &lt; end) {</span>
<span class="line-added">320         size_t mappingEnd = begin;</span>
<span class="line-added">321         while (mappingEnd &lt; end &amp;&amp; mappingsListString[mappingEnd] != &#39;,&#39;)</span>
<span class="line-added">322             ++mappingEnd;</span>
<span class="line-added">323 </span>
<span class="line-added">324         auto result = parsePartMapping(mappingsListString.substring(begin, mappingEnd - begin));</span>
<span class="line-added">325         if (result)</span>
<span class="line-added">326             mappings.add(result-&gt;first, Vector&lt;AtomString, 1&gt;()).iterator-&gt;value.append(result-&gt;second);</span>
<span class="line-added">327 </span>
<span class="line-added">328         if (mappingEnd == end)</span>
<span class="line-added">329             break;</span>
<span class="line-added">330 </span>
<span class="line-added">331         begin = mappingEnd + 1;</span>
<span class="line-added">332     }</span>
<span class="line-added">333 </span>
<span class="line-added">334     return mappings;</span>
<span class="line-added">335 }</span>
<span class="line-added">336 </span>
<span class="line-added">337 const ShadowRoot::PartMappings&amp; ShadowRoot::partMappings() const</span>
<span class="line-added">338 {</span>
<span class="line-added">339     if (!m_partMappings) {</span>
<span class="line-added">340         auto exportpartsValue = host()-&gt;attributeWithoutSynchronization(HTMLNames::exportpartsAttr);</span>
<span class="line-added">341         m_partMappings = parsePartMappingsList(exportpartsValue);</span>
<span class="line-added">342     }</span>
<span class="line-added">343 </span>
<span class="line-added">344     return *m_partMappings;</span>
<span class="line-added">345 }</span>
<span class="line-added">346 </span>
<span class="line-added">347 void ShadowRoot::invalidatePartMappings()</span>
<span class="line-added">348 {</span>
<span class="line-added">349     m_partMappings = { };</span>
<span class="line-added">350 }</span>
<span class="line-added">351 </span>
352 Vector&lt;ShadowRoot*&gt; assignedShadowRootsIfSlotted(const Node&amp; node)
353 {
354     Vector&lt;ShadowRoot*&gt; result;
355     for (auto* slot = node.assignedSlot(); slot; slot = slot-&gt;assignedSlot()) {
356         ASSERT(slot-&gt;containingShadowRoot());
357         result.append(slot-&gt;containingShadowRoot());
358     }
359     return result;
360 }
361 
<span class="line-added">362 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">363 HTMLVideoElement* ShadowRoot::pictureInPictureElement() const</span>
<span class="line-added">364 {</span>
<span class="line-added">365     notImplemented();</span>
<span class="line-added">366     return nullptr;</span>
<span class="line-added">367 }</span>
<span class="line-added">368 #endif</span>
<span class="line-added">369 </span>
370 }
</pre>
</td>
</tr>
</table>
<center><a href="SelectorQuery.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowRoot.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
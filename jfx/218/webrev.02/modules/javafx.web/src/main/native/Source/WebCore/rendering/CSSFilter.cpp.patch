diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/CSSFilter.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/CSSFilter.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/CSSFilter.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/CSSFilter.cpp
@@ -119,11 +119,11 @@
         if (!effect)
             continue;
 
         effectElement.setStandardAttributes(effect.get());
         if (effectElement.renderer())
-            effect->setOperatingColorSpace(effectElement.renderer()->style().svgStyle().colorInterpolationFilters() == ColorInterpolation::LinearRGB ? ColorSpaceLinearRGB : ColorSpaceSRGB);
+            effect->setOperatingColorSpace(effectElement.renderer()->style().svgStyle().colorInterpolationFilters() == ColorInterpolation::LinearRGB ? ColorSpace::LinearRGB : ColorSpace::SRGB);
 
         builder->add(effectElement.result(), effect);
         m_effects.append(*effect);
     }
     return effect;
@@ -131,14 +131,13 @@
 
 bool CSSFilter::build(RenderElement& renderer, const FilterOperations& operations, FilterConsumer consumer)
 {
     m_hasFilterThatMovesPixels = operations.hasFilterThatMovesPixels();
     m_hasFilterThatShouldBeRestrictedBySecurityOrigin = operations.hasFilterThatShouldBeRestrictedBySecurityOrigin();
-    if (m_hasFilterThatMovesPixels)
-        m_outsets = operations.outsets();
 
     m_effects.clear();
+    m_outsets = { };
 
     RefPtr<FilterEffect> previousEffect = m_sourceGraphic.ptr();
     for (auto& operation : operations.operations()) {
         RefPtr<FilterEffect> effect;
         auto& filterOperation = *operation;
@@ -288,11 +287,11 @@
 
         if (effect) {
             // Unlike SVG Filters and CSSFilterImages, filter functions on the filter
             // property applied here should not clip to their primitive subregions.
             effect->setClipsToBounds(consumer == FilterConsumer::FilterFunction);
-            effect->setOperatingColorSpace(ColorSpaceSRGB);
+            effect->setOperatingColorSpace(ColorSpace::SRGB);
 
             if (filterOperation.type() != FilterOperation::REFERENCE) {
                 effect->inputEffects().append(WTFMove(previousEffect));
                 m_effects.append(*effect);
             }
@@ -365,23 +364,19 @@
 
 void CSSFilter::apply()
 {
     auto& effect = m_effects.last().get();
     effect.apply();
-    effect.transformResultColorSpace(ColorSpaceSRGB);
+    effect.transformResultColorSpace(ColorSpace::SRGB);
 }
 
 LayoutRect CSSFilter::computeSourceImageRectForDirtyRect(const LayoutRect& filterBoxRect, const LayoutRect& dirtyRect)
 {
     // The result of this function is the area in the "filterBoxRect" that needs to be repainted, so that we fully cover the "dirtyRect".
     auto rectForRepaint = dirtyRect;
-    if (hasFilterThatMovesPixels()) {
-        // Note that the outsets are reversed here because we are going backwards -> we have the dirty rect and
-        // need to find out what is the rectangle that might influence the result inside that dirty rect.
-        rectForRepaint.move(-m_outsets.right(), -m_outsets.bottom());
-        rectForRepaint.expand(m_outsets.left() + m_outsets.right(), m_outsets.top() + m_outsets.bottom());
-    }
+    if (hasFilterThatMovesPixels())
+        rectForRepaint += outsets();
     rectForRepaint.intersect(filterBoxRect);
     return rectForRepaint;
 }
 
 ImageBuffer* CSSFilter::output() const
@@ -395,11 +390,10 @@
     setMaxEffectRects(sourceImageRect);
     setFilterRegion(sourceImageRect);
     m_graphicsBufferAttached = false;
 }
 
-
 void CSSFilter::setMaxEffectRects(const FloatRect& effectRect)
 {
     for (auto& effect : m_effects)
         effect->setMaxEffectRect(effectRect);
 }
@@ -410,6 +404,19 @@
     if (!lastEffect.hasResult())
         return { };
     return lastEffect.requestedRegionOfInputImageData(IntRect { m_filterRegion });
 }
 
+IntOutsets CSSFilter::outsets() const
+{
+    if (!m_hasFilterThatMovesPixels)
+        return { };
+
+    if (!m_outsets.isZero())
+        return m_outsets;
+
+    for (auto& effect : m_effects)
+        m_outsets += effect->outsets();
+    return m_outsets;
+}
+
 } // namespace WebCore

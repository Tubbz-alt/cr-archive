<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bridge/jni/jsc/JavaInstanceJSC.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2003, 2008, 2010 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JavaInstanceJSC.h&quot;
 28 
 29 #if ENABLE(JAVA_BRIDGE)
 30 #include &quot;BridgeUtils.h&quot;
 31 #include &quot;JavaRuntimeObject.h&quot;
 32 #include &quot;JNIUtilityPrivate.h&quot;
 33 #include &quot;JSDOMBinding.h&quot;
 34 #include &quot;jni_jsobject.h&quot;
 35 #include &quot;runtime_method.h&quot;
 36 #include &quot;runtime_object.h&quot;
 37 #include &quot;runtime_root.h&quot;
 38 #include &quot;JavaArrayJSC.h&quot;
 39 #include &quot;JavaClassJSC.h&quot;
 40 #include &quot;JavaMethodJSC.h&quot;
 41 #include &quot;JavaStringJSC.h&quot;
 42 #include &quot;Logging.h&quot;
 43 
 44 #include &lt;JavaScriptCore/APICast.h&gt;
 45 #include &lt;JavaScriptCore/ArgList.h&gt;
 46 #include &lt;JavaScriptCore/Error.h&gt;
 47 #include &lt;JavaScriptCore/FunctionPrototype.h&gt;
 48 #include &lt;JavaScriptCore/JSLock.h&gt;
 49 #include &lt;JavaScriptCore/JSString.h&gt;
 50 
 51 using namespace JSC::Bindings;
 52 using namespace JSC;
 53 using namespace WebCore;
 54 
 55 JavaInstance::JavaInstance(jobject instance, RefPtr&lt;RootObject&gt;&amp;&amp; rootObject, jobject accessControlContext)
 56     : Instance(WTFMove(rootObject))
 57 {
 58     m_instance = JobjectWrapper::create(instance);
 59     m_class = 0;
 60     m_accessControlContext = JobjectWrapper::create(accessControlContext, true);
 61 }
 62 
 63 JavaInstance::~JavaInstance()
 64 {
 65     delete m_class;
 66 }
 67 
<a name="1" id="anc1"></a><span class="line-modified"> 68 RuntimeObject* JavaInstance::newRuntimeObject(JSGlobalObject* globalObject)</span>
 69 {
<a name="2" id="anc2"></a><span class="line-modified"> 70     return JavaRuntimeObject::create(globalObject, this);</span>
 71 }
 72 
 73 #define NUM_LOCAL_REFS 64
 74 
 75 void JavaInstance::virtualBegin()
 76 {
 77     getJNIEnv()-&gt;PushLocalFrame(NUM_LOCAL_REFS);
 78 }
 79 
 80 void JavaInstance::virtualEnd()
 81 {
 82     getJNIEnv()-&gt;PopLocalFrame(0);
 83 }
 84 
 85 Class* JavaInstance::getClass() const
 86 {
 87     if (!m_class) {
 88         jobject acc = accessControlContext();
 89         m_class = new JavaClass(m_instance-&gt;instance(), rootObject(), acc);
 90     }
 91     return m_class;
 92 }
 93 
<a name="3" id="anc3"></a><span class="line-modified"> 94 JSValue JavaInstance::stringValue(JSGlobalObject* globalObject) const</span>
 95 {
<a name="4" id="anc4"></a><span class="line-modified"> 96     JSLockHolder lock(globalObject);</span>
 97 
<a name="5" id="anc5"></a><span class="line-modified"> 98     VM&amp; vm = globalObject-&gt;vm();</span>
 99     auto scope = DECLARE_THROW_SCOPE(vm);
100 
101     jobject obj = m_instance-&gt;instance();
102     // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
103     JLObject jlinstance(obj, true);
104 
105     if (!jlinstance) {
106         LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::stringValue&quot;, (jobject)jlinstance);
107         return jsUndefined();
108     }
109 
110     jobject acc  = accessControlContext();
111 
112     jmethodID methodId = getMethodID(obj, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;);
113     jvalue result;
114     jthrowable ex = dispatchJNICall(0, rootObject(), obj, false,
115                                     JavaTypeObject, methodId,
116                                     NULL, result, acc);
117     if (ex != 0) {
118         // FIXME duplicates code in JavaInstance::invokeMethod
119         JSValue exceptionDescription
120             = (JavaInstance::create(ex, rootObject(), accessControlContext())
<a name="6" id="anc6"></a><span class="line-modified">121                -&gt;createRuntimeObject(globalObject));</span>
<span class="line-modified">122         throwException(globalObject, scope, createError(globalObject,</span>
<span class="line-modified">123                                 (exceptionDescription.toString(globalObject)</span>
<span class="line-modified">124                                     -&gt;value(globalObject))));</span>
125         return jsUndefined();
126     }
127 
128     jstring stringValue = (jstring) result.l;
129     JNIEnv* env = getJNIEnv();
130     const jchar* c = getUCharactersFromJStringInEnv(env, stringValue);
131     String u((const UChar*)c, (int)env-&gt;GetStringLength(stringValue));
132     releaseUCharactersForJStringInEnv(env, stringValue, c);
133     return jsString(vm, u);
134 }
135 
136 static JSValue numberValueForCharacter(jobject obj) {
137 
138     // Since obj is WeakGlobalRef, creating a localref to safeguard instance() from GC
139     JLObject jlinstance(obj, true);
140 
141     if (!jlinstance) {
142         LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::numberValueForCharacter&quot;, (jobject)jlinstance);
143         return jsUndefined();
144     }
145 
146     return jsNumber((int) callJNIMethod&lt;jchar&gt;(obj, &quot;charValue&quot;, &quot;()C&quot;));
147 }
148 
149 static JSValue numberValueForNumber(jobject obj) {
150 
151     // Since obj is WeakGlobalRef, creating a localref to safeguard instance() from GC
152     JLObject jlinstance(obj, true);
153 
154     if (!jlinstance) {
155         LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::numberValueForNumber&quot;, (jobject)jlinstance);
156         return jsUndefined();
157     }
158 
159     return jsNumber(callJNIMethod&lt;jdouble&gt;(obj, &quot;doubleValue&quot;, &quot;()D&quot;));
160 }
161 
162 
<a name="7" id="anc7"></a><span class="line-modified">163 JSValue JavaInstance::numberValue(JSGlobalObject*) const</span>
164 {
165     jobject obj = m_instance-&gt;instance();
166     // Since obj is WeakGlobalRef, creating a localref to safeguard instance() from GC
167     JLObject jlinstance(obj, true);
168 
169     if (!jlinstance) {
170         LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::numberValue&quot;, (jobject)jlinstance);
171         return jsUndefined();
172     }
173 
174     JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
175     if (aClass-&gt;isCharacterClass())
176         return numberValueForCharacter(obj);
177     if (aClass-&gt;isBooleanClass())
178         return jsNumber((int)
179                         // Replaced the following line to work around possible GCC bug, see RT-22725
180                     // callJNIMethod&lt;jboolean&gt;(obj, &quot;booleanValue&quot;, &quot;()Z&quot;));
181                         callJNIMethod(obj, JavaTypeBoolean, &quot;booleanValue&quot;, &quot;()Z&quot;, 0).z);
182     return numberValueForNumber(obj);
183 }
184 
185 JSValue JavaInstance::booleanValue() const
186 {
187     // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
188     JLObject jlinstance(m_instance-&gt;instance(), true);
189 
190     if (!jlinstance) {
191         LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::booleanValue&quot;, (jobject)jlinstance);
192         return jsUndefined();
193     }
194 
195     // Changed the call to work around possible GCC bug, see RT-22725
196     jboolean booleanValue = callJNIMethod(m_instance-&gt;instance(), JavaTypeBoolean, &quot;booleanValue&quot;, &quot;()Z&quot;, 0).z;
197     return jsBoolean(booleanValue);
198 }
199 
200 class JavaRuntimeMethod : public RuntimeMethod {
201 public:
202     typedef RuntimeMethod Base;
203 
<a name="8" id="anc8"></a><span class="line-modified">204     static JavaRuntimeMethod* create(JSGlobalObject* globalObject, const String&amp; name, Bindings::Method *method)</span>
205     {
206         VM&amp; vm = globalObject-&gt;vm();
207         // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object
208         // We need to pass in the right global object for &quot;i&quot;.
<a name="9" id="anc9"></a><span class="line-modified">209         Structure* domStructure = WebCore::deprecatedGetDOMStructure&lt;JavaRuntimeMethod&gt;(globalObject);</span>
<span class="line-modified">210         JavaRuntimeMethod* _method = new (NotNull, allocateCell&lt;JavaRuntimeMethod&gt;(vm.heap)) JavaRuntimeMethod(vm, domStructure, method);</span>
<span class="line-modified">211         _method-&gt;finishCreation(globalObject-&gt;vm(), name);</span>
212         return _method;
213     }
214 
215     static Structure* createStructure(VM&amp; globalData, JSGlobalObject* globalObject, JSValue prototype)
216     {
217         return Structure::create(globalData, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), &amp;s_info);
218     }
219 
220     static const ClassInfo s_info;
221 
222 private:
<a name="10" id="anc10"></a><span class="line-modified">223     JavaRuntimeMethod(VM&amp; vm, Structure* structure, Bindings::Method *method)</span>
<span class="line-modified">224         : RuntimeMethod(vm, structure, method)</span>
225     {
226     }
227 
228     void finishCreation(VM&amp; globalData, const String&amp; name)
229     {
230         Base::finishCreation(globalData, name);
231         ASSERT(inherits(globalData, &amp;s_info));
232     }
233 };
234 
235 const ClassInfo JavaRuntimeMethod::s_info = { &quot;JavaRuntimeMethod&quot;, &amp;RuntimeMethod::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JavaRuntimeMethod) };
236 
<a name="11" id="anc11"></a><span class="line-modified">237 JSValue JavaInstance::getMethod(JSGlobalObject* globalObject, PropertyName propertyName)</span>
238 {
239     JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
240     Method *method = aClass-&gt;methodNamed(propertyName, this);
<a name="12" id="anc12"></a><span class="line-modified">241     return JavaRuntimeMethod::create(globalObject, propertyName.publicName(), method);</span>
242 }
243 
<a name="13" id="anc13"></a><span class="line-modified">244 JSValue JavaInstance::invokeMethod(JSGlobalObject* globalObject, CallFrame* callFrame, RuntimeMethod* runtimeMethod)</span>
245 {
<a name="14" id="anc14"></a><span class="line-modified">246     VM&amp; vm = globalObject-&gt;vm();</span>
247     auto scope = DECLARE_THROW_SCOPE(vm);
248 
<a name="15" id="anc15"></a><span class="line-modified">249     ASSERT(globalObject-&gt;vm().apiLock().currentThreadIsHoldingLock());</span>
250 
251     if (!asObject(runtimeMethod)-&gt;inherits(vm, &amp;JavaRuntimeMethod::s_info))
<a name="16" id="anc16"></a><span class="line-modified">252         throwException(globalObject, scope, createTypeError(globalObject, &quot;Attempt to invoke non-Java method on Java object.&quot;));</span>
253 
254 #if 0
255     const MethodList&amp; methodList = *runtimeMethod-&gt;methods();
256     size_t numMethods = methodList.size();
257 
258     Method* method = 0;
259     // Try to find a good match for the overloaded method.  The
260     // fundamental problem is that JavaScript doesn&#39;t have the
261     // notion of method overloading and Java does.  We could
262     // get a bit more sophisticated and attempt to does some
263     // type checking as we as checking the number of parameters.
264     for (size_t methodIndex = 0; methodIndex &lt; numMethods; methodIndex++) {
265         Method* aMethod = methodList[methodIndex];
266         if (aMethod-&gt;numParameters() == count) {
267             method = aMethod;
268             break;
269         }
270     }
271 #else
272     Method* method = runtimeMethod-&gt;method();
273 #endif
274 
275     if (!method) {
276         LOG(LiveConnect, &quot;JavaInstance::invokeMethod unable to find an appropriate method&quot;);
277         return jsUndefined();
278     }
279 
280     const JavaMethod* jMethod = static_cast&lt;const JavaMethod*&gt;(method);
281     // Since we can&#39;t convert java.lang.Character to any JS primitive, we have
282     // to handle valueOf method call.
283     jobject obj = m_instance-&gt;instance();
284     JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
285     if (aClass-&gt;isCharacterClass() &amp;&amp; jMethod-&gt;name() == &quot;valueOf&quot;)
286         return numberValueForCharacter(obj);
287 
288     // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
289     JLObject jlinstance(obj, true);
290 
291     if (!jlinstance) {
292         LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::invokeMethod&quot;, (jobject)jlinstance);
293         return jsUndefined();
294     }
295 
296     LOG(LiveConnect, &quot;JavaInstance::invokeMethod call %s %s on %p&quot;, String(jMethod-&gt;name().impl()).utf8().data(), jMethod-&gt;signature(), m_instance-&gt;instance());
297 
<a name="17" id="anc17"></a><span class="line-modified">298     const int count = callFrame-&gt;argumentCount();</span>
299     if (jMethod-&gt;numParameters() != count) {
300         LOG(LiveConnect, &quot;JavaInstance::invokeMethod unable to find an appropriate method with specified signature&quot;);
301         return jsUndefined();
302     }
303 
304     Vector&lt;jobject&gt; jArgs(count);
305 
306     for (int i = 0; i &lt; count; i++) {
307         CString javaClassName = jMethod-&gt;parameterAt(i).utf8();
308         JavaType jtype = javaTypeFromClassName(javaClassName.data());
<a name="18" id="anc18"></a><span class="line-modified">309         jvalue jarg = convertValueToJValue(globalObject, m_rootObject.get(),</span>
<span class="line-modified">310             callFrame-&gt;argument(i), jtype, javaClassName.data());</span>
311         jArgs[i] = jvalueToJObject(jarg, jtype);
<a name="19" id="anc19"></a><span class="line-modified">312         LOG(LiveConnect, &quot;JavaInstance::invokeMethod arg[%d] = %s&quot;, i, globalObject-&gt;argument(i).toString(globalObject)-&gt;value(globalObject).ascii().data());</span>
313     }
314 
315     jvalue result;
316 
317     // Try to use the JNI abstraction first, otherwise fall back to
318     // normal JNI.  The JNI dispatch abstraction allows the Java plugin
319     // to dispatch the call on the appropriate internal VM thread.
320     RootObject* rootObject = this-&gt;rootObject();
321     if (jMethod-&gt;isStatic())
<a name="20" id="anc20"></a><span class="line-modified">322         return throwException(globalObject, scope, createTypeError(globalObject, &quot;invoking static method&quot;));</span>
323     if (!rootObject)
324         return jsUndefined();
325 
326     // bool handled = false;
327     if (rootObject-&gt;nativeHandle()) {
328         jobject obj = m_instance-&gt;instance();
329         // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
330         JLObject jlinstance(obj, true);
331 
332         if (!jlinstance) {
333             LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::invokeMethod&quot;, (jobject)jlinstance);
334             return jsUndefined();
335         }
336 
337         // const char *callingURL = 0; // FIXME, need to propagate calling URL to Java
338         jmethodID methodId = getMethodID(obj, jMethod-&gt;name().utf8().data(), jMethod-&gt;signature());
339 
<a name="21" id="anc21"></a><span class="line-modified">340         jthrowable ex = dispatchJNICall(callFrame-&gt;argumentCount(), rootObject,</span>
341                                         obj, jMethod-&gt;isStatic(),
342                                         jMethod-&gt;returnType(), methodId,
343                                         jArgs.data(), result,
344                                         accessControlContext());
345         if (ex != NULL) {
346             JSValue exceptionDescription
347               = (JavaInstance::create(ex, rootObject, accessControlContext())
<a name="22" id="anc22"></a><span class="line-modified">348                  -&gt;createRuntimeObject(globalObject));</span>
<span class="line-modified">349             throwException(globalObject, scope, exceptionDescription);</span>
350             return jsUndefined();
351         }
352     }
353 
354     JSValue resultValue;
355     switch (jMethod-&gt;returnType()) {
356     case JavaTypeVoid:
357         {
358             resultValue = jsUndefined();
359         }
360         break;
361 
362     case JavaTypeArray:
363       /* ... fall through ... */
364     case JavaTypeObject:
365     // Since we can&#39;t convert java.lang.Character to any JS primitive, we have
366     // to treat it as JS foreign object.
367     case JavaTypeChar:
368         {
369             JNIEnv* env = getJNIEnv();
<a name="23" id="anc23"></a><span class="line-modified">370             resultValue = toJS(globalObject, WebCore::Java_Object_to_JSValue(env, toRef(globalObject), rootObject, result.l, accessControlContext()));</span>
371         }
372         break;
373 
374     case JavaTypeBoolean:
375         {
376             resultValue = jsBoolean(result.z);
377         }
378         break;
379 
380     case JavaTypeByte:
381         {
382             resultValue = jsNumber(result.b);
383         }
384         break;
385 
386     case JavaTypeShort:
387         {
388             resultValue = jsNumber(result.s);
389         }
390         break;
391 
392     case JavaTypeInt:
393         {
394             resultValue = jsNumber(result.i);
395         }
396         break;
397 
398     case JavaTypeLong:
399         {
400             resultValue = jsNumber(result.j);
401         }
402         break;
403 
404     case JavaTypeFloat:
405         {
406             resultValue = jsNumber(result.f);
407         }
408         break;
409 
410     case JavaTypeDouble:
411         {
412             resultValue = jsNumber(result.d);
413         }
414         break;
415 
416     case JavaTypeInvalid:
417         {
418             resultValue = jsUndefined();
419         }
420         break;
421     }
422 
423     return resultValue;
424 }
425 
<a name="24" id="anc24"></a><span class="line-modified">426 JSValue JavaInstance::defaultValue(JSGlobalObject* globalObject, PreferredPrimitiveType hint) const</span>
427 {
428     if (hint == PreferString)
<a name="25" id="anc25"></a><span class="line-modified">429         return stringValue(globalObject);</span>
430     if (hint == PreferNumber)
<a name="26" id="anc26"></a><span class="line-modified">431         return numberValue(globalObject);</span>
432 
433     JavaClass* aClass = static_cast&lt;JavaClass*&gt;(getClass());
434     if (aClass-&gt;isStringClass())
<a name="27" id="anc27"></a><span class="line-modified">435         return stringValue(globalObject);</span>
436 
437     jobject obj = m_instance-&gt;instance();
438     // Since m_instance-&gt;instance() is WeakGlobalRef, creating a localref to safeguard instance() from GC
439     JLObject jlinstance(obj, true);
440 
441     if (!jlinstance) {
442         LOG_ERROR(&quot;Could not get javaInstance for %p in JavaInstance::defaultValue&quot;, (jobject)jlinstance);
443         return jsUndefined();
444     }
445 
446     if (aClass-&gt;isNumberClass())
447         return numberValueForNumber(m_instance-&gt;instance());
448     if (aClass-&gt;isBooleanClass())
449         return booleanValue();
<a name="28" id="anc28"></a><span class="line-modified">450     return valueOf(globalObject);</span>
451 }
452 
<a name="29" id="anc29"></a><span class="line-modified">453 JSValue JavaInstance::valueOf(JSGlobalObject* globalObject) const</span>
454 {
<a name="30" id="anc30"></a><span class="line-modified">455     return stringValue(globalObject);</span>
456 }
457 
458 #endif // ENABLE(JAVA_BRIDGE)
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
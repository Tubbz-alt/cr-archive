<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ModuleNamespaceAccessCase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPropertyCondition.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/ObjectPropertyCondition.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;TrackedReferences.h&quot;
 31 
 32 namespace JSC {
 33 
 34 void ObjectPropertyCondition::dumpInContext(PrintStream&amp; out, DumpContext* context) const
 35 {
 36     if (!*this) {
 37         out.print(&quot;&lt;invalid&gt;&quot;);
 38         return;
 39     }
 40 
 41     out.print(&quot;&lt;&quot;, inContext(JSValue(m_object), context), &quot;: &quot;, inContext(m_condition, context), &quot;&gt;&quot;);
 42 }
 43 
 44 void ObjectPropertyCondition::dump(PrintStream&amp; out) const
 45 {
 46     dumpInContext(out, nullptr);
 47 }
 48 
<span class="line-removed"> 49 bool ObjectPropertyCondition::structureEnsuresValidityAssumingImpurePropertyWatchpoint(</span>
<span class="line-removed"> 50     Structure* structure) const</span>
<span class="line-removed"> 51 {</span>
<span class="line-removed"> 52     return m_condition.isStillValidAssumingImpurePropertyWatchpoint(structure);</span>
<span class="line-removed"> 53 }</span>
<span class="line-removed"> 54 </span>
 55 bool ObjectPropertyCondition::structureEnsuresValidityAssumingImpurePropertyWatchpoint() const
 56 {
 57     if (!*this)
 58         return false;
 59 
<span class="line-modified"> 60     return structureEnsuresValidityAssumingImpurePropertyWatchpoint(m_object-&gt;structure());</span>
 61 }
 62 
 63 bool ObjectPropertyCondition::validityRequiresImpurePropertyWatchpoint(Structure* structure) const
 64 {
 65     return m_condition.validityRequiresImpurePropertyWatchpoint(structure);
 66 }
 67 
 68 bool ObjectPropertyCondition::validityRequiresImpurePropertyWatchpoint() const
 69 {
 70     if (!*this)
 71         return false;
 72 
 73     return validityRequiresImpurePropertyWatchpoint(m_object-&gt;structure());
 74 }
 75 
 76 bool ObjectPropertyCondition::isStillValidAssumingImpurePropertyWatchpoint(Structure* structure) const
 77 {
 78     return m_condition.isStillValidAssumingImpurePropertyWatchpoint(structure, m_object);
 79 }
 80 
</pre>
<hr />
<pre>
130 
131 bool ObjectPropertyCondition::isWatchable(
132     Structure* structure, PropertyCondition::WatchabilityEffort effort) const
133 {
134     return m_condition.isWatchable(structure, m_object, effort);
135 }
136 
137 bool ObjectPropertyCondition::isWatchable(PropertyCondition::WatchabilityEffort effort) const
138 {
139     if (!*this)
140         return false;
141 
142     return isWatchable(m_object-&gt;structure(), effort);
143 }
144 
145 bool ObjectPropertyCondition::isStillLive(VM&amp; vm) const
146 {
147     if (!*this)
148         return false;
149 
<span class="line-modified">150     if (!vm.heap.isMarked(m_object))</span>
<span class="line-modified">151         return false;</span>
<span class="line-modified">152 </span>
<span class="line-modified">153     return m_condition.isStillLive(vm);</span>

154 }
155 
156 void ObjectPropertyCondition::validateReferences(const TrackedReferences&amp; tracked) const
157 {
158     if (!*this)
159         return;
160 
161     tracked.check(m_object);
162     m_condition.validateReferences(tracked);
163 }
164 
165 ObjectPropertyCondition ObjectPropertyCondition::attemptToMakeEquivalenceWithoutBarrier(VM&amp; vm) const
166 {
167     PropertyCondition result = condition().attemptToMakeEquivalenceWithoutBarrier(vm, object());
168     if (!result)
169         return ObjectPropertyCondition();
170     return ObjectPropertyCondition(object(), result);
171 }
172 
173 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;TrackedReferences.h&quot;
 31 
 32 namespace JSC {
 33 
 34 void ObjectPropertyCondition::dumpInContext(PrintStream&amp; out, DumpContext* context) const
 35 {
 36     if (!*this) {
 37         out.print(&quot;&lt;invalid&gt;&quot;);
 38         return;
 39     }
 40 
 41     out.print(&quot;&lt;&quot;, inContext(JSValue(m_object), context), &quot;: &quot;, inContext(m_condition, context), &quot;&gt;&quot;);
 42 }
 43 
 44 void ObjectPropertyCondition::dump(PrintStream&amp; out) const
 45 {
 46     dumpInContext(out, nullptr);
 47 }
 48 






 49 bool ObjectPropertyCondition::structureEnsuresValidityAssumingImpurePropertyWatchpoint() const
 50 {
 51     if (!*this)
 52         return false;
 53 
<span class="line-modified"> 54     return m_condition.isStillValidAssumingImpurePropertyWatchpoint(m_object-&gt;structure(), nullptr);</span>
 55 }
 56 
 57 bool ObjectPropertyCondition::validityRequiresImpurePropertyWatchpoint(Structure* structure) const
 58 {
 59     return m_condition.validityRequiresImpurePropertyWatchpoint(structure);
 60 }
 61 
 62 bool ObjectPropertyCondition::validityRequiresImpurePropertyWatchpoint() const
 63 {
 64     if (!*this)
 65         return false;
 66 
 67     return validityRequiresImpurePropertyWatchpoint(m_object-&gt;structure());
 68 }
 69 
 70 bool ObjectPropertyCondition::isStillValidAssumingImpurePropertyWatchpoint(Structure* structure) const
 71 {
 72     return m_condition.isStillValidAssumingImpurePropertyWatchpoint(structure, m_object);
 73 }
 74 
</pre>
<hr />
<pre>
124 
125 bool ObjectPropertyCondition::isWatchable(
126     Structure* structure, PropertyCondition::WatchabilityEffort effort) const
127 {
128     return m_condition.isWatchable(structure, m_object, effort);
129 }
130 
131 bool ObjectPropertyCondition::isWatchable(PropertyCondition::WatchabilityEffort effort) const
132 {
133     if (!*this)
134         return false;
135 
136     return isWatchable(m_object-&gt;structure(), effort);
137 }
138 
139 bool ObjectPropertyCondition::isStillLive(VM&amp; vm) const
140 {
141     if (!*this)
142         return false;
143 
<span class="line-modified">144     bool isStillLive = true;</span>
<span class="line-modified">145     forEachDependentCell([&amp;](JSCell* cell) {</span>
<span class="line-modified">146         isStillLive &amp;= vm.heap.isMarked(cell);</span>
<span class="line-modified">147     });</span>
<span class="line-added">148     return isStillLive;</span>
149 }
150 
151 void ObjectPropertyCondition::validateReferences(const TrackedReferences&amp; tracked) const
152 {
153     if (!*this)
154         return;
155 
156     tracked.check(m_object);
157     m_condition.validateReferences(tracked);
158 }
159 
160 ObjectPropertyCondition ObjectPropertyCondition::attemptToMakeEquivalenceWithoutBarrier(VM&amp; vm) const
161 {
162     PropertyCondition result = condition().attemptToMakeEquivalenceWithoutBarrier(vm, object());
163     if (!result)
164         return ObjectPropertyCondition();
165     return ObjectPropertyCondition(object(), result);
166 }
167 
168 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ModuleNamespaceAccessCase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPropertyCondition.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
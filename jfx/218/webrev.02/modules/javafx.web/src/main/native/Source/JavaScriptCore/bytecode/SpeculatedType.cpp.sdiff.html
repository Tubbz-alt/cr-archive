<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RecordedStatuses.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SpeculatedType.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SpeculatedType.h&quot;
 31 

 32 #include &quot;DirectArguments.h&quot;
 33 #include &quot;JSArray.h&quot;
 34 #include &quot;JSBigInt.h&quot;
 35 #include &quot;JSBoundFunction.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &quot;JSFunction.h&quot;
 38 #include &quot;JSMap.h&quot;
 39 #include &quot;JSSet.h&quot;
 40 #include &quot;JSWeakMap.h&quot;
 41 #include &quot;JSWeakSet.h&quot;
 42 #include &quot;ProxyObject.h&quot;
 43 #include &quot;RegExpObject.h&quot;
 44 #include &quot;ScopedArguments.h&quot;
 45 #include &quot;StringObject.h&quot;
 46 #include &quot;ValueProfile.h&quot;
 47 #include &lt;wtf/CommaPrinter.h&gt;
 48 #include &lt;wtf/StringPrintStream.h&gt;
 49 
 50 namespace JSC {
 51 
</pre>
<hr />
<pre>
157             if (value &amp; SpecDirectArguments)
158                 strOut.print(&quot;DirectArguments&quot;);
159             else
160                 isTop = false;
161 
162             if (value &amp; SpecScopedArguments)
163                 strOut.print(&quot;ScopedArguments&quot;);
164             else
165                 isTop = false;
166 
167             if (value &amp; SpecStringObject)
168                 strOut.print(&quot;StringObject&quot;);
169             else
170                 isTop = false;
171 
172             if (value &amp; SpecRegExpObject)
173                 strOut.print(&quot;RegExpObject&quot;);
174             else
175                 isTop = false;
176 










177             if (value &amp; SpecMapObject)
178                 strOut.print(&quot;MapObject&quot;);
179             else
180                 isTop = false;
181 
182             if (value &amp; SpecSetObject)
183                 strOut.print(&quot;SetObject&quot;);
184             else
185                 isTop = false;
186 
187             if (value &amp; SpecWeakMapObject)
188                 strOut.print(&quot;WeakMapObject&quot;);
189             else
190                 isTop = false;
191 
192             if (value &amp; SpecWeakSetObject)
193                 strOut.print(&quot;WeakSetObject&quot;);
194             else
195                 isTop = false;
196 
</pre>
<hr />
<pre>
246         if (value &amp; SpecNonBoolInt32)
247             strOut.print(&quot;NonBoolInt32&quot;);
248         else
249             isTop = false;
250     }
251 
252     if ((value &amp; SpecBytecodeDouble) == SpecBytecodeDouble)
253         strOut.print(&quot;BytecodeDouble&quot;);
254     else {
255         if (value &amp; SpecAnyIntAsDouble)
256             strOut.print(&quot;AnyIntAsDouble&quot;);
257         else
258             isTop = false;
259 
260         if (value &amp; SpecNonIntAsDouble)
261             strOut.print(&quot;NonIntAsDouble&quot;);
262         else
263             isTop = false;
264 
265         if (value &amp; SpecDoublePureNaN)
<span class="line-modified">266             strOut.print(&quot;DoublePureNan&quot;);</span>
267         else
268             isTop = false;
269     }
270 
271     if (value &amp; SpecDoubleImpureNaN)
<span class="line-modified">272         out.print(&quot;DoubleImpureNan&quot;);</span>
273 
274     if (value &amp; SpecBoolean)
275         strOut.print(&quot;Bool&quot;);
276     else
277         isTop = false;
278 
279     if (value &amp; SpecOther)
280         strOut.print(&quot;Other&quot;);
281     else
282         isTop = false;
283 
284     if (value &amp; SpecEmpty)
285         strOut.print(&quot;Empty&quot;);
286     else
287         isTop = false;
288 
289     if (value &amp; SpecInt52Any) {
290         if ((value &amp; SpecInt52Any) == SpecInt52Any)
291             strOut.print(&quot;Int52Any&quot;);
292         else if (value &amp; SpecInt32AsInt52)
</pre>
<hr />
<pre>
423         return SpecBigInt;
424 
425     if (classInfo == JSFinalObject::info())
426         return SpecFinalObject;
427 
428     if (classInfo == JSArray::info())
429         return SpecArray;
430 
431     if (classInfo == DirectArguments::info())
432         return SpecDirectArguments;
433 
434     if (classInfo == ScopedArguments::info())
435         return SpecScopedArguments;
436 
437     if (classInfo == StringObject::info())
438         return SpecStringObject;
439 
440     if (classInfo == RegExpObject::info())
441         return SpecRegExpObject;
442 



443     if (classInfo == JSMap::info())
444         return SpecMapObject;
445 
446     if (classInfo == JSSet::info())
447         return SpecSetObject;
448 
449     if (classInfo == JSWeakMap::info())
450         return SpecWeakMapObject;
451 
452     if (classInfo == JSWeakSet::info())
453         return SpecWeakSetObject;
454 
455     if (classInfo == ProxyObject::info())
456         return SpecProxyObject;
457 
458     if (classInfo == JSDataView::info())
459         return SpecDataViewObject;
460 
461     if (classInfo-&gt;isSubClassOf(JSFunction::info())) {
462         if (classInfo == JSBoundFunction::info())
463             return SpecFunctionWithNonDefaultHasInstance;
464         return SpecFunctionWithDefaultHasInstance;
465     }
466 



467     if (isTypedView(classInfo-&gt;typedArrayStorageType))
468         return speculationFromTypedArrayType(classInfo-&gt;typedArrayStorageType);
469 
470     if (classInfo-&gt;isSubClassOf(JSArray::info()))
471         return SpecDerivedArray;
472 
473     if (classInfo-&gt;isSubClassOf(JSObject::info()))
474         return SpecObjectOther;
475 
476     return SpecCellOther;
477 }
478 
479 SpeculatedType speculationFromStructure(Structure* structure)
480 {
481     if (structure-&gt;typeInfo().type() == StringType)
482         return SpecString;
483     if (structure-&gt;typeInfo().type() == SymbolType)
484         return SpecSymbol;
485     if (structure-&gt;typeInfo().type() == BigIntType)
486         return SpecBigInt;
</pre>
<hr />
<pre>
554         return TypeUint8;
555 
556     if (isUint8ClampedArraySpeculation(type))
557         return TypeUint8Clamped;
558 
559     if (isUint16ArraySpeculation(type))
560         return TypeUint16;
561 
562     if (isUint32ArraySpeculation(type))
563         return TypeUint32;
564 
565     if (isFloat32ArraySpeculation(type))
566         return TypeFloat32;
567 
568     if (isFloat64ArraySpeculation(type))
569         return TypeFloat64;
570 
571     return NotTypedArray;
572 }
573 
<span class="line-modified">574 SpeculatedType speculationFromJSType(JSType type)</span>
575 {
576     switch (type) {
577     case StringType:
578         return SpecString;
579     case SymbolType:
580         return SpecSymbol;
581     case BigIntType:
582         return SpecBigInt;
583     case ArrayType:
584         return SpecArray;
585     case DerivedArrayType:
586         return SpecDerivedArray;
587     case RegExpObjectType:
588         return SpecRegExpObject;


589     case ProxyObjectType:
590         return SpecProxyObject;


591     case JSMapType:
592         return SpecMapObject;
593     case JSSetType:
594         return SpecSetObject;
595     case JSWeakMapType:
596         return SpecWeakMapObject;
597     case JSWeakSetType:
598         return SpecWeakSetObject;
599     case DataViewType:
600         return SpecDataViewObject;
601     default:
<span class="line-modified">602         ASSERT_NOT_REACHED();</span>
603     }
<span class="line-removed">604     return SpecNone;</span>
605 }
606 
607 SpeculatedType leastUpperBoundOfStrictlyEquivalentSpeculations(SpeculatedType type)
608 {
609     // SpecNonIntAsDouble includes negative zero (-0.0), which can be equal to 0 and 0.0 in the context of == and ===.
610     if (type &amp; (SpecIntAnyFormat | SpecNonIntAsDouble))
611         type |= (SpecIntAnyFormat | SpecNonIntAsDouble);
612 
613     if (type &amp; SpecString)
614         type |= SpecString;
615     return type;
616 }
617 











618 bool valuesCouldBeEqual(SpeculatedType a, SpeculatedType b)
619 {
<span class="line-modified">620     a = leastUpperBoundOfStrictlyEquivalentSpeculations(a);</span>
<span class="line-modified">621     b = leastUpperBoundOfStrictlyEquivalentSpeculations(b);</span>
622 
623     // Anything could be equal to a string.
624     if (a &amp; SpecString)
625         return true;
626     if (b &amp; SpecString)
627         return true;
628 
629     // If both sides are definitely only objects, then equality is fairly sane.
630     if (isObjectSpeculation(a) &amp;&amp; isObjectSpeculation(b))
631         return !!(a &amp; b);
632 
633     // If either side could be an object or not, then we could call toString or
634     // valueOf, which could return anything.
635     if (a &amp; SpecObject)
636         return true;
637     if (b &amp; SpecObject)
638         return true;
639 
640     // Neither side is an object or string, so the world is relatively sane.
641     return !!(a &amp; b);
</pre>
<hr />
<pre>
655 
656     // Impure NaN could become pure NaN during addition because addition may clear bits.
657     if (result &amp; SpecDoubleImpureNaN)
658         result |= SpecDoublePureNaN;
659     // Values could overflow, or fractions could become integers.
660     if (result &amp; SpecDoubleReal)
661         result |= SpecDoubleReal;
662     return result;
663 }
664 
665 SpeculatedType typeOfDoubleSum(SpeculatedType a, SpeculatedType b)
666 {
667     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
668 }
669 
670 SpeculatedType typeOfDoubleDifference(SpeculatedType a, SpeculatedType b)
671 {
672     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
673 }
674 











675 SpeculatedType typeOfDoubleProduct(SpeculatedType a, SpeculatedType b)
676 {
677     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
678 }
679 
680 static SpeculatedType polluteDouble(SpeculatedType value)
681 {
682     // Impure NaN could become pure NaN because the operation could clear some bits.
683     if (value &amp; SpecDoubleImpureNaN)
684         value |= SpecDoubleNaN;
685     // Values could overflow, fractions could become integers, or an error could produce
686     // PureNaN.
687     if (value &amp; SpecDoubleReal)
688         value |= SpecDoubleReal | SpecDoublePureNaN;
689     return value;
690 }
691 
692 SpeculatedType typeOfDoubleQuotient(SpeculatedType a, SpeculatedType b)
693 {
694     return polluteDouble(a | b);
</pre>
<hr />
<pre>
777     if (!strncmp(speculation, &quot;SpecUint8ClampedArray&quot;, strlen(&quot;SpecUint8ClampedArray&quot;)))
778         return SpecUint8ClampedArray;
779     if (!strncmp(speculation, &quot;SpecUint16Array&quot;, strlen(&quot;SpecUint16Array&quot;)))
780         return SpecUint16Array;
781     if (!strncmp(speculation, &quot;SpecUint32Array&quot;, strlen(&quot;SpecUint32Array&quot;)))
782         return SpecUint32Array;
783     if (!strncmp(speculation, &quot;SpecFloat32Array&quot;, strlen(&quot;SpecFloat32Array&quot;)))
784         return SpecFloat32Array;
785     if (!strncmp(speculation, &quot;SpecFloat64Array&quot;, strlen(&quot;SpecFloat64Array&quot;)))
786         return SpecFloat64Array;
787     if (!strncmp(speculation, &quot;SpecTypedArrayView&quot;, strlen(&quot;SpecTypedArrayView&quot;)))
788         return SpecTypedArrayView;
789     if (!strncmp(speculation, &quot;SpecDirectArguments&quot;, strlen(&quot;SpecDirectArguments&quot;)))
790         return SpecDirectArguments;
791     if (!strncmp(speculation, &quot;SpecScopedArguments&quot;, strlen(&quot;SpecScopedArguments&quot;)))
792         return SpecScopedArguments;
793     if (!strncmp(speculation, &quot;SpecStringObject&quot;, strlen(&quot;SpecStringObject&quot;)))
794         return SpecStringObject;
795     if (!strncmp(speculation, &quot;SpecRegExpObject&quot;, strlen(&quot;SpecRegExpObject&quot;)))
796         return SpecRegExpObject;




797     if (!strncmp(speculation, &quot;SpecMapObject&quot;, strlen(&quot;SpecMapObject&quot;)))
798         return SpecMapObject;
799     if (!strncmp(speculation, &quot;SpecSetObject&quot;, strlen(&quot;SpecSetObject&quot;)))
800         return SpecSetObject;
801     if (!strncmp(speculation, &quot;SpecWeakMapObject&quot;, strlen(&quot;SpecWeakMapObject&quot;)))
802         return SpecWeakMapObject;
803     if (!strncmp(speculation, &quot;SpecWeakSetObject&quot;, strlen(&quot;SpecWeakSetObject&quot;)))
804         return SpecWeakSetObject;
805     if (!strncmp(speculation, &quot;SpecProxyObject&quot;, strlen(&quot;SpecProxyObject&quot;)))
806         return SpecProxyObject;
807     if (!strncmp(speculation, &quot;SpecDerivedArray&quot;, strlen(&quot;SpecDerivedArray&quot;)))
808         return SpecDerivedArray;
809     if (!strncmp(speculation, &quot;SpecDataViewObject&quot;, strlen(&quot;SpecDataViewObject&quot;)))
810         return SpecDataViewObject;
811     if (!strncmp(speculation, &quot;SpecObjectOther&quot;, strlen(&quot;SpecObjectOther&quot;)))
812         return SpecObjectOther;
813     if (!strncmp(speculation, &quot;SpecObject&quot;, strlen(&quot;SpecObject&quot;)))
814         return SpecObject;
815     if (!strncmp(speculation, &quot;SpecStringIdent&quot;, strlen(&quot;SpecStringIdent&quot;)))
816         return SpecStringIdent;
</pre>
</td>
<td>
<hr />
<pre>
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SpeculatedType.h&quot;
 31 
<span class="line-added"> 32 #include &quot;DateInstance.h&quot;</span>
 33 #include &quot;DirectArguments.h&quot;
 34 #include &quot;JSArray.h&quot;
 35 #include &quot;JSBigInt.h&quot;
 36 #include &quot;JSBoundFunction.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;JSFunction.h&quot;
 39 #include &quot;JSMap.h&quot;
 40 #include &quot;JSSet.h&quot;
 41 #include &quot;JSWeakMap.h&quot;
 42 #include &quot;JSWeakSet.h&quot;
 43 #include &quot;ProxyObject.h&quot;
 44 #include &quot;RegExpObject.h&quot;
 45 #include &quot;ScopedArguments.h&quot;
 46 #include &quot;StringObject.h&quot;
 47 #include &quot;ValueProfile.h&quot;
 48 #include &lt;wtf/CommaPrinter.h&gt;
 49 #include &lt;wtf/StringPrintStream.h&gt;
 50 
 51 namespace JSC {
 52 
</pre>
<hr />
<pre>
158             if (value &amp; SpecDirectArguments)
159                 strOut.print(&quot;DirectArguments&quot;);
160             else
161                 isTop = false;
162 
163             if (value &amp; SpecScopedArguments)
164                 strOut.print(&quot;ScopedArguments&quot;);
165             else
166                 isTop = false;
167 
168             if (value &amp; SpecStringObject)
169                 strOut.print(&quot;StringObject&quot;);
170             else
171                 isTop = false;
172 
173             if (value &amp; SpecRegExpObject)
174                 strOut.print(&quot;RegExpObject&quot;);
175             else
176                 isTop = false;
177 
<span class="line-added">178             if (value &amp; SpecDateObject)</span>
<span class="line-added">179                 strOut.print(&quot;DateObject&quot;);</span>
<span class="line-added">180             else</span>
<span class="line-added">181                 isTop = false;</span>
<span class="line-added">182 </span>
<span class="line-added">183             if (value &amp; SpecPromiseObject)</span>
<span class="line-added">184                 strOut.print(&quot;PromiseObject&quot;);</span>
<span class="line-added">185             else</span>
<span class="line-added">186                 isTop = false;</span>
<span class="line-added">187 </span>
188             if (value &amp; SpecMapObject)
189                 strOut.print(&quot;MapObject&quot;);
190             else
191                 isTop = false;
192 
193             if (value &amp; SpecSetObject)
194                 strOut.print(&quot;SetObject&quot;);
195             else
196                 isTop = false;
197 
198             if (value &amp; SpecWeakMapObject)
199                 strOut.print(&quot;WeakMapObject&quot;);
200             else
201                 isTop = false;
202 
203             if (value &amp; SpecWeakSetObject)
204                 strOut.print(&quot;WeakSetObject&quot;);
205             else
206                 isTop = false;
207 
</pre>
<hr />
<pre>
257         if (value &amp; SpecNonBoolInt32)
258             strOut.print(&quot;NonBoolInt32&quot;);
259         else
260             isTop = false;
261     }
262 
263     if ((value &amp; SpecBytecodeDouble) == SpecBytecodeDouble)
264         strOut.print(&quot;BytecodeDouble&quot;);
265     else {
266         if (value &amp; SpecAnyIntAsDouble)
267             strOut.print(&quot;AnyIntAsDouble&quot;);
268         else
269             isTop = false;
270 
271         if (value &amp; SpecNonIntAsDouble)
272             strOut.print(&quot;NonIntAsDouble&quot;);
273         else
274             isTop = false;
275 
276         if (value &amp; SpecDoublePureNaN)
<span class="line-modified">277             strOut.print(&quot;DoublePureNaN&quot;);</span>
278         else
279             isTop = false;
280     }
281 
282     if (value &amp; SpecDoubleImpureNaN)
<span class="line-modified">283         strOut.print(&quot;DoubleImpureNaN&quot;);</span>
284 
285     if (value &amp; SpecBoolean)
286         strOut.print(&quot;Bool&quot;);
287     else
288         isTop = false;
289 
290     if (value &amp; SpecOther)
291         strOut.print(&quot;Other&quot;);
292     else
293         isTop = false;
294 
295     if (value &amp; SpecEmpty)
296         strOut.print(&quot;Empty&quot;);
297     else
298         isTop = false;
299 
300     if (value &amp; SpecInt52Any) {
301         if ((value &amp; SpecInt52Any) == SpecInt52Any)
302             strOut.print(&quot;Int52Any&quot;);
303         else if (value &amp; SpecInt32AsInt52)
</pre>
<hr />
<pre>
434         return SpecBigInt;
435 
436     if (classInfo == JSFinalObject::info())
437         return SpecFinalObject;
438 
439     if (classInfo == JSArray::info())
440         return SpecArray;
441 
442     if (classInfo == DirectArguments::info())
443         return SpecDirectArguments;
444 
445     if (classInfo == ScopedArguments::info())
446         return SpecScopedArguments;
447 
448     if (classInfo == StringObject::info())
449         return SpecStringObject;
450 
451     if (classInfo == RegExpObject::info())
452         return SpecRegExpObject;
453 
<span class="line-added">454     if (classInfo == DateInstance::info())</span>
<span class="line-added">455         return SpecDateObject;</span>
<span class="line-added">456 </span>
457     if (classInfo == JSMap::info())
458         return SpecMapObject;
459 
460     if (classInfo == JSSet::info())
461         return SpecSetObject;
462 
463     if (classInfo == JSWeakMap::info())
464         return SpecWeakMapObject;
465 
466     if (classInfo == JSWeakSet::info())
467         return SpecWeakSetObject;
468 
469     if (classInfo == ProxyObject::info())
470         return SpecProxyObject;
471 
472     if (classInfo == JSDataView::info())
473         return SpecDataViewObject;
474 
475     if (classInfo-&gt;isSubClassOf(JSFunction::info())) {
476         if (classInfo == JSBoundFunction::info())
477             return SpecFunctionWithNonDefaultHasInstance;
478         return SpecFunctionWithDefaultHasInstance;
479     }
480 
<span class="line-added">481     if (classInfo-&gt;isSubClassOf(JSPromise::info()))</span>
<span class="line-added">482         return SpecPromiseObject;</span>
<span class="line-added">483 </span>
484     if (isTypedView(classInfo-&gt;typedArrayStorageType))
485         return speculationFromTypedArrayType(classInfo-&gt;typedArrayStorageType);
486 
487     if (classInfo-&gt;isSubClassOf(JSArray::info()))
488         return SpecDerivedArray;
489 
490     if (classInfo-&gt;isSubClassOf(JSObject::info()))
491         return SpecObjectOther;
492 
493     return SpecCellOther;
494 }
495 
496 SpeculatedType speculationFromStructure(Structure* structure)
497 {
498     if (structure-&gt;typeInfo().type() == StringType)
499         return SpecString;
500     if (structure-&gt;typeInfo().type() == SymbolType)
501         return SpecSymbol;
502     if (structure-&gt;typeInfo().type() == BigIntType)
503         return SpecBigInt;
</pre>
<hr />
<pre>
571         return TypeUint8;
572 
573     if (isUint8ClampedArraySpeculation(type))
574         return TypeUint8Clamped;
575 
576     if (isUint16ArraySpeculation(type))
577         return TypeUint16;
578 
579     if (isUint32ArraySpeculation(type))
580         return TypeUint32;
581 
582     if (isFloat32ArraySpeculation(type))
583         return TypeFloat32;
584 
585     if (isFloat64ArraySpeculation(type))
586         return TypeFloat64;
587 
588     return NotTypedArray;
589 }
590 
<span class="line-modified">591 Optional&lt;SpeculatedType&gt; speculationFromJSType(JSType type)</span>
592 {
593     switch (type) {
594     case StringType:
595         return SpecString;
596     case SymbolType:
597         return SpecSymbol;
598     case BigIntType:
599         return SpecBigInt;
600     case ArrayType:
601         return SpecArray;
602     case DerivedArrayType:
603         return SpecDerivedArray;
604     case RegExpObjectType:
605         return SpecRegExpObject;
<span class="line-added">606     case JSDateType:</span>
<span class="line-added">607         return SpecDateObject;</span>
608     case ProxyObjectType:
609         return SpecProxyObject;
<span class="line-added">610     case JSPromiseType:</span>
<span class="line-added">611         return SpecPromiseObject;</span>
612     case JSMapType:
613         return SpecMapObject;
614     case JSSetType:
615         return SpecSetObject;
616     case JSWeakMapType:
617         return SpecWeakMapObject;
618     case JSWeakSetType:
619         return SpecWeakSetObject;
620     case DataViewType:
621         return SpecDataViewObject;
622     default:
<span class="line-modified">623         return WTF::nullopt;</span>
624     }

625 }
626 
627 SpeculatedType leastUpperBoundOfStrictlyEquivalentSpeculations(SpeculatedType type)
628 {
629     // SpecNonIntAsDouble includes negative zero (-0.0), which can be equal to 0 and 0.0 in the context of == and ===.
630     if (type &amp; (SpecIntAnyFormat | SpecNonIntAsDouble))
631         type |= (SpecIntAnyFormat | SpecNonIntAsDouble);
632 
633     if (type &amp; SpecString)
634         type |= SpecString;
635     return type;
636 }
637 
<span class="line-added">638 static inline SpeculatedType leastUpperBoundOfEquivalentSpeculations(SpeculatedType type)</span>
<span class="line-added">639 {</span>
<span class="line-added">640     type = leastUpperBoundOfStrictlyEquivalentSpeculations(type);</span>
<span class="line-added">641 </span>
<span class="line-added">642     // Boolean or BigInt can be converted to Number when performing non-strict equal.</span>
<span class="line-added">643     if (type &amp; (SpecIntAnyFormat | SpecNonIntAsDouble | SpecBoolean | SpecBigInt))</span>
<span class="line-added">644         type |= (SpecIntAnyFormat | SpecNonIntAsDouble | SpecBoolean | SpecBigInt);</span>
<span class="line-added">645 </span>
<span class="line-added">646     return type;</span>
<span class="line-added">647 }</span>
<span class="line-added">648 </span>
649 bool valuesCouldBeEqual(SpeculatedType a, SpeculatedType b)
650 {
<span class="line-modified">651     a = leastUpperBoundOfEquivalentSpeculations(a);</span>
<span class="line-modified">652     b = leastUpperBoundOfEquivalentSpeculations(b);</span>
653 
654     // Anything could be equal to a string.
655     if (a &amp; SpecString)
656         return true;
657     if (b &amp; SpecString)
658         return true;
659 
660     // If both sides are definitely only objects, then equality is fairly sane.
661     if (isObjectSpeculation(a) &amp;&amp; isObjectSpeculation(b))
662         return !!(a &amp; b);
663 
664     // If either side could be an object or not, then we could call toString or
665     // valueOf, which could return anything.
666     if (a &amp; SpecObject)
667         return true;
668     if (b &amp; SpecObject)
669         return true;
670 
671     // Neither side is an object or string, so the world is relatively sane.
672     return !!(a &amp; b);
</pre>
<hr />
<pre>
686 
687     // Impure NaN could become pure NaN during addition because addition may clear bits.
688     if (result &amp; SpecDoubleImpureNaN)
689         result |= SpecDoublePureNaN;
690     // Values could overflow, or fractions could become integers.
691     if (result &amp; SpecDoubleReal)
692         result |= SpecDoubleReal;
693     return result;
694 }
695 
696 SpeculatedType typeOfDoubleSum(SpeculatedType a, SpeculatedType b)
697 {
698     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
699 }
700 
701 SpeculatedType typeOfDoubleDifference(SpeculatedType a, SpeculatedType b)
702 {
703     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
704 }
705 
<span class="line-added">706 SpeculatedType typeOfDoubleIncOrDec(SpeculatedType t)</span>
<span class="line-added">707 {</span>
<span class="line-added">708     // Impure NaN could become pure NaN during addition because addition may clear bits.</span>
<span class="line-added">709     if (t &amp; SpecDoubleImpureNaN)</span>
<span class="line-added">710         t |= SpecDoublePureNaN;</span>
<span class="line-added">711     // Values could overflow, or fractions could become integers.</span>
<span class="line-added">712     if (t &amp; SpecDoubleReal)</span>
<span class="line-added">713         t |= SpecDoubleReal;</span>
<span class="line-added">714     return t;</span>
<span class="line-added">715 }</span>
<span class="line-added">716 </span>
717 SpeculatedType typeOfDoubleProduct(SpeculatedType a, SpeculatedType b)
718 {
719     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
720 }
721 
722 static SpeculatedType polluteDouble(SpeculatedType value)
723 {
724     // Impure NaN could become pure NaN because the operation could clear some bits.
725     if (value &amp; SpecDoubleImpureNaN)
726         value |= SpecDoubleNaN;
727     // Values could overflow, fractions could become integers, or an error could produce
728     // PureNaN.
729     if (value &amp; SpecDoubleReal)
730         value |= SpecDoubleReal | SpecDoublePureNaN;
731     return value;
732 }
733 
734 SpeculatedType typeOfDoubleQuotient(SpeculatedType a, SpeculatedType b)
735 {
736     return polluteDouble(a | b);
</pre>
<hr />
<pre>
819     if (!strncmp(speculation, &quot;SpecUint8ClampedArray&quot;, strlen(&quot;SpecUint8ClampedArray&quot;)))
820         return SpecUint8ClampedArray;
821     if (!strncmp(speculation, &quot;SpecUint16Array&quot;, strlen(&quot;SpecUint16Array&quot;)))
822         return SpecUint16Array;
823     if (!strncmp(speculation, &quot;SpecUint32Array&quot;, strlen(&quot;SpecUint32Array&quot;)))
824         return SpecUint32Array;
825     if (!strncmp(speculation, &quot;SpecFloat32Array&quot;, strlen(&quot;SpecFloat32Array&quot;)))
826         return SpecFloat32Array;
827     if (!strncmp(speculation, &quot;SpecFloat64Array&quot;, strlen(&quot;SpecFloat64Array&quot;)))
828         return SpecFloat64Array;
829     if (!strncmp(speculation, &quot;SpecTypedArrayView&quot;, strlen(&quot;SpecTypedArrayView&quot;)))
830         return SpecTypedArrayView;
831     if (!strncmp(speculation, &quot;SpecDirectArguments&quot;, strlen(&quot;SpecDirectArguments&quot;)))
832         return SpecDirectArguments;
833     if (!strncmp(speculation, &quot;SpecScopedArguments&quot;, strlen(&quot;SpecScopedArguments&quot;)))
834         return SpecScopedArguments;
835     if (!strncmp(speculation, &quot;SpecStringObject&quot;, strlen(&quot;SpecStringObject&quot;)))
836         return SpecStringObject;
837     if (!strncmp(speculation, &quot;SpecRegExpObject&quot;, strlen(&quot;SpecRegExpObject&quot;)))
838         return SpecRegExpObject;
<span class="line-added">839     if (!strncmp(speculation, &quot;SpecDateObject&quot;, strlen(&quot;SpecDateObject&quot;)))</span>
<span class="line-added">840         return SpecDateObject;</span>
<span class="line-added">841     if (!strncmp(speculation, &quot;SpecPromiseObject&quot;, strlen(&quot;SpecPromiseObject&quot;)))</span>
<span class="line-added">842         return SpecPromiseObject;</span>
843     if (!strncmp(speculation, &quot;SpecMapObject&quot;, strlen(&quot;SpecMapObject&quot;)))
844         return SpecMapObject;
845     if (!strncmp(speculation, &quot;SpecSetObject&quot;, strlen(&quot;SpecSetObject&quot;)))
846         return SpecSetObject;
847     if (!strncmp(speculation, &quot;SpecWeakMapObject&quot;, strlen(&quot;SpecWeakMapObject&quot;)))
848         return SpecWeakMapObject;
849     if (!strncmp(speculation, &quot;SpecWeakSetObject&quot;, strlen(&quot;SpecWeakSetObject&quot;)))
850         return SpecWeakSetObject;
851     if (!strncmp(speculation, &quot;SpecProxyObject&quot;, strlen(&quot;SpecProxyObject&quot;)))
852         return SpecProxyObject;
853     if (!strncmp(speculation, &quot;SpecDerivedArray&quot;, strlen(&quot;SpecDerivedArray&quot;)))
854         return SpecDerivedArray;
855     if (!strncmp(speculation, &quot;SpecDataViewObject&quot;, strlen(&quot;SpecDataViewObject&quot;)))
856         return SpecDataViewObject;
857     if (!strncmp(speculation, &quot;SpecObjectOther&quot;, strlen(&quot;SpecObjectOther&quot;)))
858         return SpecObjectOther;
859     if (!strncmp(speculation, &quot;SpecObject&quot;, strlen(&quot;SpecObject&quot;)))
860         return SpecObject;
861     if (!strncmp(speculation, &quot;SpecStringIdent&quot;, strlen(&quot;SpecStringIdent&quot;)))
862         return SpecStringIdent;
</pre>
</td>
</tr>
</table>
<center><a href="RecordedStatuses.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SpeculatedType.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
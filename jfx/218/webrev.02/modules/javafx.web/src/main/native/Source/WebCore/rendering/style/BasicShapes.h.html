<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Adobe Systems Incorporated. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above
  9  *    copyright notice, this list of conditions and the following
 10  *    disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;Length.h&quot;
 33 #include &quot;LengthSize.h&quot;
 34 #include &quot;WindRule.h&quot;
 35 #include &lt;wtf/RefCounted.h&gt;
 36 #include &lt;wtf/RefPtr.h&gt;
 37 #include &lt;wtf/TypeCasts.h&gt;
 38 #include &lt;wtf/Vector.h&gt;
 39 
 40 namespace WTF {
 41 class TextStream;
 42 }
 43 
 44 namespace WebCore {
 45 
 46 class FloatRect;
 47 class Path;
 48 class RenderBox;
 49 class SVGPathByteStream;
 50 
 51 class BasicShape : public RefCounted&lt;BasicShape&gt; {
 52 public:
 53     virtual ~BasicShape() = default;
 54 
 55     enum class Type {
 56         Polygon,
 57         Path,
 58         Circle,
 59         Ellipse,
 60         Inset
 61     };
 62 
 63     virtual Type type() const = 0;
 64 
 65     virtual const Path&amp; path(const FloatRect&amp;) = 0;
 66     virtual WindRule windRule() const { return WindRule::NonZero; }
 67 
 68     virtual bool canBlend(const BasicShape&amp;) const = 0;
 69     virtual Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const = 0;
 70 
 71     virtual bool operator==(const BasicShape&amp;) const = 0;
 72 
 73     virtual void dump(TextStream&amp;) const = 0;
 74 };
 75 
 76 class BasicShapeCenterCoordinate {
 77 public:
 78     enum Direction {
 79         TopLeft,
 80         BottomRight
 81     };
 82 
 83     BasicShapeCenterCoordinate()
 84     {
 85         updateComputedLength();
 86     }
 87 
 88     BasicShapeCenterCoordinate(Direction direction, Length length)
 89         : m_direction(direction)
 90         , m_length(length)
 91     {
 92         updateComputedLength();
 93     }
 94 
 95     Direction direction() const { return m_direction; }
 96     const Length&amp; length() const { return m_length; }
 97     const Length&amp; computedLength() const { return m_computedLength; }
 98 
 99     BasicShapeCenterCoordinate blend(const BasicShapeCenterCoordinate&amp; from, double progress) const
100     {
101         return BasicShapeCenterCoordinate(TopLeft, WebCore::blend(from.m_computedLength, m_computedLength, progress));
102     }
103 
104     bool operator==(const BasicShapeCenterCoordinate&amp; other) const
105     {
106         return m_direction == other.m_direction
107             &amp;&amp; m_length == other.m_length
108             &amp;&amp; m_computedLength == other.m_computedLength;
109     }
110 
111 private:
112     void updateComputedLength();
113 
114     Direction m_direction { TopLeft };
115     Length m_length { Undefined };
116     Length m_computedLength;
117 };
118 
119 class BasicShapeRadius {
120 public:
121     enum Type {
122         Value,
123         ClosestSide,
124         FarthestSide
125     };
126 
127     BasicShapeRadius() = default;
128 
129     explicit BasicShapeRadius(Length v)
130         : m_value(v)
131         , m_type(Value)
132     { }
133     explicit BasicShapeRadius(Type t)
134         : m_value(Undefined)
135         , m_type(t)
136     { }
137 
138     const Length&amp; value() const { return m_value; }
139     Type type() const { return m_type; }
140 
141     bool canBlend(const BasicShapeRadius&amp; other) const
142     {
143         // FIXME determine how to interpolate between keywords. See bug 125108.
144         return m_type == Value &amp;&amp; other.type() == Value;
145     }
146 
147     BasicShapeRadius blend(const BasicShapeRadius&amp; from, double progress) const
148     {
149         if (m_type != Value || from.type() != Value)
150             return BasicShapeRadius(from);
151 
152         return BasicShapeRadius(WebCore::blend(from.value(), value(), progress));
153     }
154 
155     bool operator==(const BasicShapeRadius&amp; other) const
156     {
157         return m_value == other.m_value &amp;&amp; m_type == other.m_type;
158     }
159 
160 private:
161     Length m_value { Undefined };
162     Type m_type { ClosestSide };
163 };
164 
165 class BasicShapeCircle final : public BasicShape {
166 public:
167     static Ref&lt;BasicShapeCircle&gt; create() { return adoptRef(*new BasicShapeCircle); }
168 
169     const BasicShapeCenterCoordinate&amp; centerX() const { return m_centerX; }
170     const BasicShapeCenterCoordinate&amp; centerY() const { return m_centerY; }
171     const BasicShapeRadius&amp; radius() const { return m_radius; }
172     float floatValueForRadiusInBox(float boxWidth, float boxHeight) const;
173 
174     void setCenterX(BasicShapeCenterCoordinate centerX) { m_centerX = WTFMove(centerX); }
175     void setCenterY(BasicShapeCenterCoordinate centerY) { m_centerY = WTFMove(centerY); }
176     void setRadius(BasicShapeRadius radius) { m_radius = WTFMove(radius); }
177 
178 private:
179     BasicShapeCircle() = default;
180 
181     Type type() const override { return Type::Circle; }
182 
183     const Path&amp; path(const FloatRect&amp;) override;
184 
185     bool canBlend(const BasicShape&amp;) const override;
186     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
187 
188     bool operator==(const BasicShape&amp;) const override;
189 
190     void dump(TextStream&amp;) const final;
191 
192     BasicShapeCenterCoordinate m_centerX;
193     BasicShapeCenterCoordinate m_centerY;
194     BasicShapeRadius m_radius;
195 };
196 
197 class BasicShapeEllipse final : public BasicShape {
198 public:
199     static Ref&lt;BasicShapeEllipse&gt; create() { return adoptRef(*new BasicShapeEllipse); }
200 
201     const BasicShapeCenterCoordinate&amp; centerX() const { return m_centerX; }
202     const BasicShapeCenterCoordinate&amp; centerY() const { return m_centerY; }
203     const BasicShapeRadius&amp; radiusX() const { return m_radiusX; }
204     const BasicShapeRadius&amp; radiusY() const { return m_radiusY; }
205     float floatValueForRadiusInBox(const BasicShapeRadius&amp;, float center, float boxWidthOrHeight) const;
206 
207     void setCenterX(BasicShapeCenterCoordinate centerX) { m_centerX = WTFMove(centerX); }
208     void setCenterY(BasicShapeCenterCoordinate centerY) { m_centerY = WTFMove(centerY); }
209     void setRadiusX(BasicShapeRadius radiusX) { m_radiusX = WTFMove(radiusX); }
210     void setRadiusY(BasicShapeRadius radiusY) { m_radiusY = WTFMove(radiusY); }
211 
212 private:
213     BasicShapeEllipse() = default;
214 
215     Type type() const override { return Type::Ellipse; }
216 
217     const Path&amp; path(const FloatRect&amp;) override;
218 
219     bool canBlend(const BasicShape&amp;) const override;
220     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
221 
222     bool operator==(const BasicShape&amp;) const override;
223 
224     void dump(TextStream&amp;) const final;
225 
226     BasicShapeCenterCoordinate m_centerX;
227     BasicShapeCenterCoordinate m_centerY;
228     BasicShapeRadius m_radiusX;
229     BasicShapeRadius m_radiusY;
230 };
231 
232 class BasicShapePolygon final : public BasicShape {
233 public:
234     static Ref&lt;BasicShapePolygon&gt; create() { return adoptRef(*new BasicShapePolygon); }
235 
236     const Vector&lt;Length&gt;&amp; values() const { return m_values; }
237     const Length&amp; getXAt(unsigned i) const { return m_values[2 * i]; }
238     const Length&amp; getYAt(unsigned i) const { return m_values[2 * i + 1]; }
239 
240     void setWindRule(WindRule windRule) { m_windRule = windRule; }
241     void appendPoint(Length x, Length y) { m_values.append(WTFMove(x)); m_values.append(WTFMove(y)); }
242 
243     WindRule windRule() const override { return m_windRule; }
244 
245 private:
246     BasicShapePolygon() = default;
247 
248     Type type() const override { return Type::Polygon; }
249 
250     const Path&amp; path(const FloatRect&amp;) override;
251 
252     bool canBlend(const BasicShape&amp;) const override;
253     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
254 
255     bool operator==(const BasicShape&amp;) const override;
256 
257     void dump(TextStream&amp;) const final;
258 
259     WindRule m_windRule { WindRule::NonZero };
260     Vector&lt;Length&gt; m_values;
261 };
262 
263 class BasicShapePath final : public BasicShape {
264 public:
265     static Ref&lt;BasicShapePath&gt; create(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; byteStream)
266     {
267         return adoptRef(*new BasicShapePath(WTFMove(byteStream)));
268     }
269 
270     void setWindRule(WindRule windRule) { m_windRule = windRule; }
271     WindRule windRule() const override { return m_windRule; }
272 
273     const SVGPathByteStream* pathData() const { return m_byteStream.get(); }
274 
275 private:
276     BasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp;);
277 
278     Type type() const override { return Type::Path; }
279 
280     const Path&amp; path(const FloatRect&amp;) override;
281 
282     bool canBlend(const BasicShape&amp;) const override;
283     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
284 
285     bool operator==(const BasicShape&amp;) const override;
286 
287     void dump(TextStream&amp;) const final;
288 
289     std::unique_ptr&lt;SVGPathByteStream&gt; m_byteStream;
290     WindRule m_windRule { WindRule::NonZero };
291 };
292 
293 class BasicShapeInset final : public BasicShape {
294 public:
295     static Ref&lt;BasicShapeInset&gt; create() { return adoptRef(*new BasicShapeInset); }
296 
297     const Length&amp; top() const { return m_top; }
298     const Length&amp; right() const { return m_right; }
299     const Length&amp; bottom() const { return m_bottom; }
300     const Length&amp; left() const { return m_left; }
301 
302     const LengthSize&amp; topLeftRadius() const { return m_topLeftRadius; }
303     const LengthSize&amp; topRightRadius() const { return m_topRightRadius; }
304     const LengthSize&amp; bottomRightRadius() const { return m_bottomRightRadius; }
305     const LengthSize&amp; bottomLeftRadius() const { return m_bottomLeftRadius; }
306 
307     void setTop(Length top) { m_top = WTFMove(top); }
308     void setRight(Length right) { m_right = WTFMove(right); }
309     void setBottom(Length bottom) { m_bottom = WTFMove(bottom); }
310     void setLeft(Length left) { m_left = WTFMove(left); }
311 
312     void setTopLeftRadius(LengthSize radius) { m_topLeftRadius = WTFMove(radius); }
313     void setTopRightRadius(LengthSize radius) { m_topRightRadius = WTFMove(radius); }
314     void setBottomRightRadius(LengthSize radius) { m_bottomRightRadius = WTFMove(radius); }
315     void setBottomLeftRadius(LengthSize radius) { m_bottomLeftRadius = WTFMove(radius); }
316 
317 private:
318     BasicShapeInset() = default;
319 
320     Type type() const override { return Type::Inset; }
321 
322     const Path&amp; path(const FloatRect&amp;) override;
323 
324     bool canBlend(const BasicShape&amp;) const override;
325     Ref&lt;BasicShape&gt; blend(const BasicShape&amp; from, double) const override;
326 
327     bool operator==(const BasicShape&amp;) const override;
328 
329     void dump(TextStream&amp;) const final;
330 
331     Length m_right;
332     Length m_top;
333     Length m_bottom;
334     Length m_left;
335 
336     LengthSize m_topLeftRadius;
337     LengthSize m_topRightRadius;
338     LengthSize m_bottomRightRadius;
339     LengthSize m_bottomLeftRadius;
340 };
341 
342 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const BasicShapeRadius&amp;);
343 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const BasicShapeCenterCoordinate&amp;);
344 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const BasicShape&amp;);
345 
346 } // namespace WebCore
347 
348 #define SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(ToValueTypeName, predicate) \
349 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
350     static bool isType(const WebCore::BasicShape&amp; basicShape) { return basicShape.type() == WebCore::predicate; } \
351 SPECIALIZE_TYPE_TRAITS_END()
352 
353 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeCircle, BasicShape::Type::Circle)
354 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeEllipse, BasicShape::Type::Ellipse)
355 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapePolygon, BasicShape::Type::Polygon)
356 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapePath, BasicShape::Type::Path)
357 SPECIALIZE_TYPE_TRAITS_BASIC_SHAPE(BasicShapeInset, BasicShape::Type::Inset)
    </pre>
  </body>
</html>
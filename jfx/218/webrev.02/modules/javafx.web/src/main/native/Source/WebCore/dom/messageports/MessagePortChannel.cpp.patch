diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannel.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannel.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannel.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannel.cpp
@@ -145,11 +145,11 @@
 
     ASSERT(m_pendingMessageProtectors[i] == this);
     return false;
 }
 
-void MessagePortChannel::takeAllMessagesForPort(const MessagePortIdentifier& port, Function<void(Vector<MessageWithMessagePorts>&&, Function<void()>&&)>&& callback)
+void MessagePortChannel::takeAllMessagesForPort(const MessagePortIdentifier& port, CompletionHandler<void(Vector<MessageWithMessagePorts>&&, Function<void()>&&)>&& callback)
 {
     ASSERT(isMainThread());
 
     LOG(MessagePorts, "MessagePortChannel %p taking all messages for port %s", this, port.logString().utf8().data());
 
@@ -180,11 +180,11 @@
         LOG(MessagePorts, "Message port channel %s was notified that a batch of %zu message port messages targeted for port %s just completed dispatch, in flight is now %" PRIu64, logString().utf8().data(), size, port.logString().utf8().data(), m_messageBatchesInFlight);
 
     });
 }
 
-void MessagePortChannel::checkRemotePortForActivity(const MessagePortIdentifier& remotePort, Function<void(MessagePortChannelProvider::HasActivity)>&& callback)
+void MessagePortChannel::checkRemotePortForActivity(const MessagePortIdentifier& remotePort, CompletionHandler<void(MessagePortChannelProvider::HasActivity)>&& callback)
 {
     ASSERT(isMainThread());
     ASSERT(remotePort == m_ports[0] || remotePort == m_ports[1]);
 
     // If the remote port is closed there is no pending activity.
@@ -205,11 +205,11 @@
     if (!m_processes[i]) {
         callback(MessagePortChannelProvider::HasActivity::Yes);
         return;
     }
 
-    auto outerCallback = Function<void(MessagePortChannelProvider::HasActivity)> { [this, protectedThis = makeRef(*this), callback = WTFMove(callback)] (MessagePortChannelProvider::HasActivity hasActivity) mutable {
+    CompletionHandler<void(MessagePortChannelProvider::HasActivity)> outerCallback = [this, protectedThis = makeRef(*this), callback = WTFMove(callback)](auto hasActivity) mutable {
         if (hasActivity == MessagePortChannelProvider::HasActivity::Yes) {
             callback(hasActivity);
             return;
         }
 
@@ -217,13 +217,13 @@
         // This is because it might have asynchronously sent a message just before it was asked about local activity.
         if (hasAnyMessagesPendingOrInFlight())
             hasActivity = MessagePortChannelProvider::HasActivity::Yes;
 
         callback(hasActivity);
-    } };
+    };
 
-    m_registry.provider().checkProcessLocalPortForActivity(remotePort, *m_processes[i], WTFMove(outerCallback));
+    m_registry.checkProcessLocalPortForActivity(remotePort, *m_processes[i], WTFMove(outerCallback));
 }
 
 bool MessagePortChannel::hasAnyMessagesPendingOrInFlight() const
 {
     ASSERT(isMainThread());

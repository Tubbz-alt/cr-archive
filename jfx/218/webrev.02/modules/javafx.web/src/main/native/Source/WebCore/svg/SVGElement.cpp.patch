diff a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.cpp
@@ -49,10 +49,11 @@
 #include "SVGRenderSupport.h"
 #include "SVGSVGElement.h"
 #include "SVGTitleElement.h"
 #include "SVGUseElement.h"
 #include "ShadowRoot.h"
+#include "StyleAdjuster.h"
 #include "XMLNames.h"
 #include <wtf/Assertions.h>
 #include <wtf/HashMap.h>
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/NeverDestroyed.h>
@@ -158,11 +159,10 @@
     return map;
 }
 
 SVGElement::SVGElement(const QualifiedName& tagName, Document& document)
     : StyledElement(tagName, document, CreateSVGElement)
-    , SVGLangSpace(this)
     , m_propertyAnimatorFactory(makeUnique<SVGPropertyAnimatorFactory>())
 {
     static std::once_flag onceFlag;
     std::call_once(onceFlag, [] {
         PropertyRegistry::registerProperty<HTMLNames::classAttr, &SVGElement::m_className>();
@@ -352,12 +352,10 @@
     auto& eventName = HTMLElement::eventNameForEventHandlerAttribute(name);
     if (!eventName.isNull()) {
         setAttributeEventListener(eventName, name, value);
         return;
     }
-
-    SVGLangSpace::parseAttribute(name, value);
 }
 
 bool SVGElement::haveLoadedRequiredResources()
 {
     for (auto& child : childrenOfType<SVGElement>(*this)) {
@@ -438,68 +436,39 @@
     }
 
     return false;
 }
 
-void SVGElement::sendSVGLoadEventIfPossible(bool sendParentLoadEvents)
+void SVGElement::sendLoadEventIfPossible()
 {
     if (!isConnected() || !document().frame())
         return;
 
-    RefPtr<SVGElement> currentTarget = this;
-    while (currentTarget && currentTarget->haveLoadedRequiredResources()) {
-        RefPtr<Element> parent;
-        if (sendParentLoadEvents)
-            parent = currentTarget->parentOrShadowHostElement(); // save the next parent to dispatch too incase dispatching the event changes the tree
-        if (hasLoadListener(currentTarget.get()))
-            currentTarget->dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
-        currentTarget = (parent && parent->isSVGElement()) ? static_pointer_cast<SVGElement>(parent) : RefPtr<SVGElement>();
-        SVGElement* element = currentTarget.get();
-        if (!element || !element->isOutermostSVGSVGElement())
-            continue;
-
-        // Consider <svg onload="foo()"><image xlink:href="foo.png" externalResourcesRequired="true"/></svg>.
-        // If foo.png is not yet loaded, the first SVGLoad event will go to the <svg> element, sent through
-        // Document::implicitClose(). Then the SVGLoad event will fire for <image>, once its loaded.
-        ASSERT(sendParentLoadEvents);
-
-        // If the load event was not sent yet by Document::implicitClose(), but the <image> from the example
-        // above, just appeared, don't send the SVGLoad event to the outermost <svg>, but wait for the document
-        // to be "ready to render", first.
-        if (!document().loadEventFinished())
-            break;
-    }
-}
+    if (!haveLoadedRequiredResources() || !hasLoadListener(this))
+        return;
 
-void SVGElement::sendSVGLoadEventIfPossibleAsynchronously()
-{
-    svgLoadEventTimer()->startOneShot(0_s);
+    dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 }
 
-void SVGElement::svgLoadEventTimerFired()
+void SVGElement::loadEventTimerFired()
 {
-    sendSVGLoadEventIfPossible();
+    sendLoadEventIfPossible();
 }
 
-Timer* SVGElement::svgLoadEventTimer()
+Timer* SVGElement::loadEventTimer()
 {
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
 void SVGElement::finishParsingChildren()
 {
     StyledElement::finishParsingChildren();
 
-    // The outermost SVGSVGElement SVGLoad event is fired through Document::dispatchWindowLoadEvent.
     if (isOutermostSVGSVGElement())
         return;
 
-    // finishParsingChildren() is called when the close tag is reached for an element (e.g. </svg>)
-    // we send SVGLoad events here if we can, otherwise they'll be sent when any required loads finish
-    sendSVGLoadEventIfPossible();
-
     // Notify all the elements which have references to this element to rebuild their shadow and render
     // trees, e.g. a <use> element references a target element before this target element is defined.
     invalidateInstances();
 }
 
@@ -579,11 +548,11 @@
     ASSERT(attributeName != nullQName());
 
     // A change in a style property, e.g SVGRectElement::x should be serialized to
     // the attribute immediately. Otherwise it is okay to be lazy in this regard.
     if (!propertyRegistry().isAnimatedStylePropertyAttribute(attributeName))
-        animatedProperty.setDirty();
+        propertyRegistry().setAnimatedPropertDirty(attributeName, animatedProperty);
     else
         setSynchronizedLazyAttribute(attributeName, animatedProperty.baseValAsString());
 
     invalidateSVGAttributes();
     svgAttributeChanged(attributeName);
@@ -622,16 +591,16 @@
 void SVGElement::animatorWillBeDeleted(const QualifiedName& attributeName)
 {
     propertyAnimatorFactory().animatorWillBeDeleted(attributeName);
 }
 
-Optional<ElementStyle> SVGElement::resolveCustomStyle(const RenderStyle& parentStyle, const RenderStyle*)
+Optional<Style::ElementStyle> SVGElement::resolveCustomStyle(const RenderStyle& parentStyle, const RenderStyle*)
 {
     // If the element is in a <use> tree we get the style from the definition tree.
     if (auto styleElement = makeRefPtr(this->correspondingElement())) {
-        Optional<ElementStyle> style = styleElement->resolveStyle(&parentStyle);
-        StyleResolver::adjustSVGElementStyle(*this, *style->renderStyle);
+        auto style = styleElement->resolveStyle(&parentStyle);
+        Style::Adjuster::adjustSVGElementStyle(*style.renderStyle, *this);
         return style;
     }
 
     return resolveStyle(&parentStyle);
 }
@@ -861,12 +830,10 @@
         if (isConnected())
             buildPendingResourcesIfNeeded();
         invalidateInstances();
         return;
     }
-
-    SVGLangSpace::svgAttributeChanged(attrName);
 }
 
 Node::InsertedIntoAncestorResult SVGElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode& parentOfInsertedTree)
 {
     StyledElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
@@ -905,29 +872,10 @@
     if (change.source == ChildChangeSource::Parser)
         return;
     invalidateInstances();
 }
 
-RefPtr<DeprecatedCSSOMValue> SVGElement::getPresentationAttribute(const String& name)
-{
-    if (!hasAttributesWithoutUpdate())
-        return 0;
-
-    QualifiedName attributeName(nullAtom(), name, nullAtom());
-    const Attribute* attribute = findAttributeByName(attributeName);
-    if (!attribute)
-        return 0;
-
-    auto style = MutableStyleProperties::create(SVGAttributeMode);
-    CSSPropertyID propertyID = cssPropertyIdForSVGAttributeName(attribute->name());
-    style->setProperty(propertyID, attribute->value());
-    auto cssValue = style->getPropertyCSSValue(propertyID);
-    if (!cssValue)
-        return nullptr;
-    return cssValue->createDeprecatedCSSOMWrapper(style->ensureCSSStyleDeclaration());
-}
-
 bool SVGElement::instanceUpdatesBlocked() const
 {
     return m_svgRareData && m_svgRareData->instanceUpdatesBlocked();
 }
 

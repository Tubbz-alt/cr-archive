<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/FrameView.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;

  31 #include &quot;BackForwardController.h&quot;
  32 #include &quot;CSSAnimationController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;CachedResourceLoader.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;ChromeClient.h&quot;
  37 #include &quot;CustomHeaderFields.h&quot;
  38 #include &quot;DOMWindow.h&quot;
  39 #include &quot;DebugPageOverlays.h&quot;
  40 #include &quot;DeprecatedGlobalSettings.h&quot;
  41 #include &quot;DocumentLoader.h&quot;
  42 #include &quot;DocumentMarkerController.h&quot;

  43 #include &quot;EventHandler.h&quot;
  44 #include &quot;EventNames.h&quot;
  45 #include &quot;FloatRect.h&quot;
  46 #include &quot;FocusController.h&quot;
  47 #include &quot;Frame.h&quot;
  48 #include &quot;FrameLoader.h&quot;
  49 #include &quot;FrameLoaderClient.h&quot;
  50 #include &quot;FrameSelection.h&quot;
  51 #include &quot;FrameTree.h&quot;
  52 #include &quot;GraphicsContext.h&quot;
  53 #include &quot;HTMLBodyElement.h&quot;
  54 #include &quot;HTMLEmbedElement.h&quot;
  55 #include &quot;HTMLFrameElement.h&quot;
  56 #include &quot;HTMLFrameSetElement.h&quot;
  57 #include &quot;HTMLHtmlElement.h&quot;
  58 #include &quot;HTMLIFrameElement.h&quot;
  59 #include &quot;HTMLNames.h&quot;
  60 #include &quot;HTMLObjectElement.h&quot;
  61 #include &quot;HTMLParserIdioms.h&quot;
  62 #include &quot;HTMLPlugInImageElement.h&quot;
  63 #include &quot;ImageDocument.h&quot;
  64 #include &quot;InspectorClient.h&quot;
  65 #include &quot;InspectorController.h&quot;
  66 #include &quot;InspectorInstrumentation.h&quot;
  67 #include &quot;Logging.h&quot;
  68 #include &quot;MemoryCache.h&quot;
  69 #include &quot;OverflowEvent.h&quot;
  70 #include &quot;Page.h&quot;
<span class="line-removed">  71 #include &quot;PageCache.h&quot;</span>
  72 #include &quot;PageOverlayController.h&quot;
  73 #include &quot;ProgressTracker.h&quot;
  74 #include &quot;RenderEmbeddedObject.h&quot;
  75 #include &quot;RenderFullScreen.h&quot;
  76 #include &quot;RenderIFrame.h&quot;
  77 #include &quot;RenderInline.h&quot;
  78 #include &quot;RenderLayer.h&quot;
  79 #include &quot;RenderLayerBacking.h&quot;
  80 #include &quot;RenderLayerCompositor.h&quot;
  81 #include &quot;RenderSVGRoot.h&quot;
  82 #include &quot;RenderScrollbar.h&quot;
  83 #include &quot;RenderScrollbarPart.h&quot;
  84 #include &quot;RenderStyle.h&quot;
  85 #include &quot;RenderText.h&quot;
  86 #include &quot;RenderTheme.h&quot;
  87 #include &quot;RenderView.h&quot;
  88 #include &quot;RenderWidget.h&quot;
  89 #include &quot;ResizeObserver.h&quot;
  90 #include &quot;RuntimeEnabledFeatures.h&quot;
  91 #include &quot;SVGDocument.h&quot;
  92 #include &quot;SVGSVGElement.h&quot;
  93 #include &quot;ScriptRunner.h&quot;
  94 #include &quot;ScriptedAnimationController.h&quot;
  95 #include &quot;ScrollAnimator.h&quot;
  96 #include &quot;ScrollingCoordinator.h&quot;
  97 #include &quot;Settings.h&quot;
  98 #include &quot;StyleResolver.h&quot;
  99 #include &quot;StyleScope.h&quot;
 100 #include &quot;TextResourceDecoder.h&quot;
 101 #include &quot;TiledBacking.h&quot;
 102 #include &quot;VelocityData.h&quot;
 103 #include &quot;VisualViewport.h&quot;
<span class="line-modified"> 104 #include &quot;WheelEventTestTrigger.h&quot;</span>
 105 #include &lt;wtf/text/TextStream.h&gt;
 106 
 107 #include &lt;wtf/IsoMallocInlines.h&gt;
 108 #include &lt;wtf/MemoryPressureHandler.h&gt;
 109 #include &lt;wtf/Ref.h&gt;
 110 #include &lt;wtf/SetForScope.h&gt;
 111 #include &lt;wtf/SystemTracing.h&gt;
 112 
 113 #if USE(COORDINATED_GRAPHICS)
 114 #include &quot;TiledBackingStore.h&quot;
 115 #endif
 116 
 117 #if ENABLE(CSS_SCROLL_SNAP)
 118 #include &quot;AxisScrollSnapOffsets.h&quot;
 119 #endif
 120 
 121 #if PLATFORM(IOS_FAMILY)
 122 #include &quot;DocumentLoader.h&quot;
 123 #include &quot;LegacyTileCache.h&quot;
 124 #endif
 125 
 126 #if PLATFORM(MAC)
 127 #include &quot;LocalDefaultSystemAppearance.h&quot;
 128 #endif
 129 
<span class="line-modified"> 130 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), Layout, &quot;%p - FrameView::&quot; fmt, this, ##__VA_ARGS__)</span>




 131 
 132 namespace WebCore {
 133 
 134 using namespace HTMLNames;
 135 
 136 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 137 
 138 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 139 
 140 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 141 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 142 
 143 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 144 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 145 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 146 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 147 
 148 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 149 {
 150     Overflow overflow = style.overflowY();
</pre>
<hr />
<pre>
 507     return isFrameFlatteningValidForThisFrame();
 508 }
 509 
 510 void FrameView::setCanHaveScrollbars(bool canHaveScrollbars)
 511 {
 512     m_canHaveScrollbars = canHaveScrollbars;
 513     ScrollView::setCanHaveScrollbars(canHaveScrollbars);
 514 }
 515 
 516 void FrameView::updateCanHaveScrollbars()
 517 {
 518     ScrollbarMode hMode;
 519     ScrollbarMode vMode;
 520     scrollbarModes(hMode, vMode);
 521     if (hMode == ScrollbarAlwaysOff &amp;&amp; vMode == ScrollbarAlwaysOff)
 522         setCanHaveScrollbars(false);
 523     else
 524         setCanHaveScrollbars(true);
 525 }
 526 
<span class="line-modified"> 527 Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)</span>
 528 {
 529     // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
<span class="line-modified"> 530     Document* doc = frame().document();</span>


 531 
 532     // Try the &lt;body&gt; element first as a scrollbar source.
<span class="line-modified"> 533     HTMLElement* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;</span>
<span class="line-modified"> 534     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))</span>
<span class="line-modified"> 535         return RenderScrollbar::createCustomScrollbar(*this, orientation, body);</span>
 536 
 537     // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
<span class="line-modified"> 538     Element* docElement = doc ? doc-&gt;documentElement() : nullptr;</span>
<span class="line-modified"> 539     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))</span>
<span class="line-modified"> 540         return RenderScrollbar::createCustomScrollbar(*this, orientation, docElement);</span>








 541 
 542     // If we have an owning iframe/frame element, then it can set the custom scrollbar also.

 543     RenderWidget* frameRenderer = frame().ownerRenderer();
 544     if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 545         return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
 546 
 547     // Nobody set a custom style, so we just use a native scrollbar.
 548     return ScrollView::createScrollbar(orientation);
 549 }
 550 
<span class="line-modified"> 551 void FrameView::didRestoreFromPageCache()</span>
 552 {
<span class="line-modified"> 553     // When restoring from page cache, the main frame stays in place while subframes get swapped in.</span>
 554     // We update the scrollable area set to ensure that scrolling data structures get invalidated.
 555     updateScrollableAreaSet();
 556 }
 557 
 558 void FrameView::willDestroyRenderTree()
 559 {
 560     detachCustomScrollbars();
 561     layoutContext().clearSubtreeLayoutRoot();
 562 }
 563 
 564 void FrameView::didDestroyRenderTree()
 565 {
 566     ASSERT(!layoutContext().subtreeLayoutRoot());
 567     ASSERT(m_widgetsInRenderTree.isEmpty());
 568 
 569     // If the render tree is destroyed below FrameView::updateEmbeddedObjects(), there will still be a null sentinel in the set.
 570     // Everything else should have removed itself as the tree was felled.
 571     ASSERT(!m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty() || (m_embeddedObjectsToUpdate-&gt;size() == 1 &amp;&amp; m_embeddedObjectsToUpdate-&gt;first() == nullptr));
 572 
 573     ASSERT(!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty());
</pre>
<hr />
<pre>
 579 void FrameView::setContentsSize(const IntSize&amp; size)
 580 {
 581     if (size == contentsSize())
 582         return;
 583 
 584     layoutContext().disableSetNeedsLayout();
 585 
 586     ScrollView::setContentsSize(size);
 587     contentsResized();
 588 
 589     Page* page = frame().page();
 590     if (!page)
 591         return;
 592 
 593     updateScrollableAreaSet();
 594 
 595     page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
 596 
 597     if (frame().isMainFrame()) {
 598         page-&gt;pageOverlayController().didChangeDocumentSize();
<span class="line-modified"> 599         PageCache::singleton().markPagesForContentsSizeChanged(*page);</span>
 600     }
 601     layoutContext().enableSetNeedsLayout();
 602 }
 603 
 604 void FrameView::adjustViewSize()
 605 {
 606     RenderView* renderView = this-&gt;renderView();
 607     if (!renderView)
 608         return;
 609 
 610     ASSERT(frame().view() == this);
 611 
 612     const IntRect rect = renderView-&gt;documentRect();
 613     const IntSize&amp; size = rect.size();
 614     ScrollView::setScrollOrigin(IntPoint(-rect.x(), -rect.y()), !frame().document()-&gt;printing(), size == contentsSize());
 615 
 616     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; adjustViewSize: unscaled document rect changed to &quot; &lt;&lt; renderView-&gt;unscaledDocumentRect() &lt;&lt; &quot; (scaled to &quot; &lt;&lt; size &lt;&lt; &quot;)&quot;);
 617 
 618     setContentsSize(size);
 619 }
</pre>
<hr />
<pre>
 766             if (bodyRenderer) {
 767                 applyOverflowToViewport(*bodyRenderer, hMode, vMode);
 768                 m_viewportRendererType = ViewportRendererType::Body;
 769             }
 770         } else {
 771             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 772             m_viewportRendererType = ViewportRendererType::Document;
 773         }
 774     }
 775 }
 776 
 777 void FrameView::willRecalcStyle()
 778 {
 779     RenderView* renderView = this-&gt;renderView();
 780     if (!renderView)
 781         return;
 782 
 783     renderView-&gt;compositor().willRecalcStyle();
 784 }
 785 












 786 bool FrameView::updateCompositingLayersAfterStyleChange()
 787 {
 788     // If we expect to update compositing after an incipient layout, don&#39;t do so here.
 789     if (!renderView() || needsLayout() || layoutContext().isInLayout())
 790         return false;
 791     return renderView()-&gt;compositor().didRecalcStyleWithNoPendingLayout();
 792 }
 793 
 794 void FrameView::updateCompositingLayersAfterLayout()
 795 {
 796     RenderView* renderView = this-&gt;renderView();
 797     if (!renderView)
 798         return;
 799 
 800     renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::AfterLayout);
 801 }
 802 
 803 GraphicsLayer* FrameView::layerForHorizontalScrollbar() const
 804 {
 805     RenderView* renderView = this-&gt;renderView();
</pre>
<hr />
<pre>
1174     if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())
1175         bodyRenderer-&gt;setChildNeedsLayout();
1176     else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())
1177         rootRenderer-&gt;setChildNeedsLayout();
1178 }
1179 
1180 void FrameView::adjustScrollbarsForLayout(bool isFirstLayout)
1181 {
1182     ScrollbarMode hMode;
1183     ScrollbarMode vMode;
1184     calculateScrollbarModesForLayout(hMode, vMode);
1185     if (isFirstLayout &amp;&amp; !layoutContext().isLayoutNested()) {
1186         setScrollbarsSuppressed(true);
1187         // Set the initial vMode to AlwaysOn if we&#39;re auto.
1188         if (vMode == ScrollbarAuto)
1189             setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
1190         // Set the initial hMode to AlwaysOff if we&#39;re auto.
1191         if (hMode == ScrollbarAuto)
1192             setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
1193         ASSERT(frame().page());
<span class="line-modified">1194         if (frame().page()-&gt;expectsWheelEventTriggers())</span>
<span class="line-modified">1195             scrollAnimator().setWheelEventTestTrigger(frame().page()-&gt;testTrigger());</span>
1196         setScrollbarModes(hMode, vMode);
1197         setScrollbarsSuppressed(false, true);
1198     } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
1199         setScrollbarModes(hMode, vMode);
1200 }
1201 
1202 void FrameView::willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1203 {
1204     bool subtreeLayout = !is&lt;RenderView&gt;(*layoutRoot);
1205     if (subtreeLayout)
1206         return;
1207 
1208     if (auto* body = frame().document()-&gt;bodyOrFrameset()) {
1209         if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled() &amp;&amp; body-&gt;renderer())
1210             body-&gt;renderer()-&gt;setChildNeedsLayout();
1211     }
1212     auto firstLayout = !layoutContext().didFirstLayout();
1213     if (firstLayout) {
1214         m_lastViewportSize = sizeForResizeEvent();
1215         m_lastZoomFactor = layoutRoot-&gt;style().zoom();
</pre>
<hr />
<pre>
1387 }
1388 
1389 bool FrameView::usesMockScrollAnimator() const
1390 {
1391     return DeprecatedGlobalSettings::usesMockScrollAnimator();
1392 }
1393 
1394 void FrameView::logMockScrollAnimatorMessage(const String&amp; message) const
1395 {
1396     Document* document = frame().document();
1397     if (!document)
1398         return;
1399     StringBuilder builder;
1400     if (frame().isMainFrame())
1401         builder.appendLiteral(&quot;Main&quot;);
1402     builder.appendLiteral(&quot;FrameView: &quot;);
1403     builder.append(message);
1404     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1405 }
1406 



































1407 void FrameView::setCannotBlitToWindow()
1408 {
1409     m_cannotBlitToWindow = true;
1410     updateCanBlitOnScrollRecursively();
1411 }
1412 
1413 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1414 {
1415     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1416 
1417     if (!m_slowRepaintObjects)
1418         m_slowRepaintObjects = makeUnique&lt;HashSet&lt;const RenderElement*&gt;&gt;();
1419 
1420     m_slowRepaintObjects-&gt;add(&amp;renderer);
1421     if (hadSlowRepaintObjects)
1422         return;
1423 
1424     updateCanBlitOnScrollRecursively();
1425 
1426     if (auto* page = frame().page()) {
</pre>
<hr />
<pre>
2101     updateCanBlitOnScrollRecursively();
2102 }
2103 
2104 void FrameView::setContentIsOpaque(bool contentIsOpaque)
2105 {
2106     if (contentIsOpaque == m_contentIsOpaque)
2107         return;
2108 
2109     m_contentIsOpaque = contentIsOpaque;
2110     updateCanBlitOnScrollRecursively();
2111 }
2112 
2113 void FrameView::restoreScrollbar()
2114 {
2115     setScrollbarsSuppressed(false);
2116 }
2117 
2118 bool FrameView::scrollToFragment(const URL&amp; url)
2119 {
2120     String fragmentIdentifier = url.fragmentIdentifier();
<span class="line-modified">2121     if (scrollToAnchor(fragmentIdentifier))</span>
2122         return true;
2123 
2124     // Try again after decoding the ref, based on the document&#39;s encoding.
2125     if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
<span class="line-modified">2126         if (scrollToAnchor(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))</span>
2127             return true;
2128     }
2129 
2130     resetScrollAnchor();
2131     return false;
2132 }
2133 
<span class="line-modified">2134 bool FrameView::scrollToAnchor(const String&amp; fragmentIdentifier)</span>
2135 {
2136     LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
2137 
2138     // If our URL has no ref, then we have no place we need to jump to.
2139     if (fragmentIdentifier.isNull())
2140         return false;
2141 
2142     ASSERT(frame().document());
2143     auto&amp; document = *frame().document();
<span class="line-modified">2144 </span>
<span class="line-removed">2145     if (!document.haveStylesheetsLoaded()) {</span>
<span class="line-removed">2146         document.setGotoAnchorNeededAfterStylesheetsLoad(true);</span>
<span class="line-removed">2147         return false;</span>
<span class="line-removed">2148     }</span>
<span class="line-removed">2149 </span>
<span class="line-removed">2150     document.setGotoAnchorNeededAfterStylesheetsLoad(false);</span>
2151 
2152     Element* anchorElement = document.findAnchor(fragmentIdentifier);
2153 
2154     LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
2155 
2156     // Setting to null will clear the current target.
2157     document.setCSSTarget(anchorElement);
2158 
2159     if (is&lt;SVGDocument&gt;(document)) {
2160         if (fragmentIdentifier.isEmpty())
2161             return false;
2162         if (auto rootElement = SVGDocument::rootElement(document)) {
2163             if (rootElement-&gt;scrollToFragment(fragmentIdentifier))
2164                 return true;
2165             // If SVG failed to scrollToAnchor() and anchorElement is null, no other scrolling will be possible.
2166             if (!anchorElement)
2167                 return false;
2168         }
2169     } else if (!anchorElement &amp;&amp; !(fragmentIdentifier.isEmpty() || equalLettersIgnoringASCIICase(fragmentIdentifier, &quot;top&quot;))) {
2170         // Implement the rule that &quot;&quot; and &quot;top&quot; both mean top of page as in other browsers.
</pre>
<hr />
<pre>
2205     // Only do a layout if changes have occurred that make it necessary.
2206     RenderView* renderView = this-&gt;renderView();
2207     if (renderView &amp;&amp; renderView-&gt;needsLayout())
2208         layoutContext().layout();
2209     else
2210         scrollToAnchor();
2211 }
2212 
2213 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2214 {
2215     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2216 
2217     LayoutRect bounds;
2218     if (RenderElement* renderer = element.renderer())
2219         bounds = renderer-&gt;absoluteAnchorRect();
2220     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2221     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2222     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2223 }
2224 
<span class="line-modified">2225 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition)</span>
2226 {
2227     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2228 
2229     auto oldScrollType = currentScrollType();
2230     setCurrentScrollType(ScrollType::Programmatic);
2231 
2232     m_maintainScrollPositionAnchor = nullptr;
2233     m_shouldScrollToFocusedElement = false;
2234     m_delayedScrollToFocusedElementTimer.stop();
2235     Page* page = frame().page();
<span class="line-modified">2236     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</span>
<span class="line-modified">2237         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</span>
<span class="line-modified">2238     ScrollView::setScrollPosition(scrollPosition);</span>
2239 
2240     setCurrentScrollType(oldScrollType);
2241 }
2242 
2243 void FrameView::resetScrollAnchor()
2244 {
2245     ASSERT(frame().document());
2246     auto&amp; document = *frame().document();
2247 
2248     // If CSS target was set previously, we want to set it to 0, recalc
2249     // and possibly repaint because :target pseudo class may have been
2250     // set (see bug 11321).
2251     document.setCSSTarget(nullptr);
2252 
2253     if (is&lt;SVGDocument&gt;(document)) {
2254         if (auto rootElement = SVGDocument::rootElement(document)) {
2255             // We need to update the layout before resetScrollAnchor(), otherwise we
2256             // could really mess things up if resetting the anchor comes at a bad moment.
2257             document.updateStyleIfNeeded();
2258             rootElement-&gt;resetScrollAnchor();
</pre>
<hr />
<pre>
2406     UNUSED_PARAM(oldPosition);
2407     UNUSED_PARAM(newPosition);
2408 
2409     Page* page = frame().page();
2410     Seconds throttlingDelay = page ? page-&gt;chrome().client().eventThrottlingDelay() : 0_s;
2411 
2412     if (throttlingDelay == 0_s) {
2413         m_delayedScrollEventTimer.stop();
2414         sendScrollEvent();
2415     } else if (!m_delayedScrollEventTimer.isActive())
2416         m_delayedScrollEventTimer.startOneShot(throttlingDelay);
2417 
2418     if (RenderView* renderView = this-&gt;renderView()) {
2419         if (renderView-&gt;usesCompositing())
2420             renderView-&gt;compositor().frameViewDidScroll();
2421     }
2422 
2423     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; scrollPositionChanged from &quot; &lt;&lt; oldPosition &lt;&lt; &quot; to &quot; &lt;&lt; newPosition &lt;&lt; &quot; (scale &quot; &lt;&lt; frameScaleFactor() &lt;&lt; &quot; )&quot;);
2424     updateLayoutViewport();
2425     viewportContentsChanged();





2426 }
2427 
2428 void FrameView::applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp; apply)
2429 {
2430     IntRect windowClipRect = this-&gt;windowClipRect();
2431     auto visibleRect = windowToContents(windowClipRect);
2432     apply(*this, visibleRect);
2433 
2434     // Recursive call for subframes. We cache the current FrameView&#39;s windowClipRect to avoid recomputing it for every subframe.
2435     SetForScope&lt;IntRect*&gt; windowClipRectCache(m_cachedWindowClipRect, &amp;windowClipRect);
2436     for (Frame* childFrame = frame().tree().firstChild(); childFrame; childFrame = childFrame-&gt;tree().nextSibling()) {
2437         if (auto* childView = childFrame-&gt;view())
2438             childView-&gt;applyRecursivelyWithVisibleRect(apply);
2439     }
2440 }
2441 
2442 void FrameView::resumeVisibleImageAnimations(const IntRect&amp; visibleRect)
2443 {
2444     if (visibleRect.isEmpty())
2445         return;
</pre>
<hr />
<pre>
2537     if (scrollbarsSuppressed())
2538         return false;
2539 
2540     // If the scrolling thread updates the scroll position for this FrameView, then we should return
2541     // ScrollingCoordinator::isRubberBandInProgress().
2542     if (Page* page = frame().page()) {
2543         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
2544             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2545                 return scrollingCoordinator-&gt;isRubberBandInProgress();
2546         }
2547     }
2548 
2549     // If the main thread updates the scroll position for this FrameView, we should return
2550     // ScrollAnimator::isRubberBandInProgress().
2551     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
2552         return scrollAnimator-&gt;isRubberBandInProgress();
2553 
2554     return false;
2555 }
2556 
<span class="line-modified">2557 bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position)</span>
2558 {
2559     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
2560 
2561 #if ENABLE(ASYNC_SCROLLING)
2562     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
2563         tiledBacking-&gt;prepopulateRect(FloatRect(position, visibleContentRect().size()));
2564 #endif
2565 
2566 #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
2567     if (Page* page = frame().page()) {
2568         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
<span class="line-modified">2569             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position);</span>
2570     }
2571 #else
2572     UNUSED_PARAM(position);
2573 #endif
2574 
2575     return false;
2576 }
2577 
2578 HostWindow* FrameView::hostWindow() const
2579 {
2580     auto* page = frame().page();
2581     if (!page)
2582         return nullptr;
2583     return &amp;page-&gt;chrome();
2584 }
2585 
2586 void FrameView::addTrackedRepaintRect(const FloatRect&amp; r)
2587 {
2588     if (!m_isTrackingRepaints || r.isEmpty())
2589         return;
</pre>
<hr />
<pre>
2728         return;
2729 
2730     tiledBacking-&gt;setScrollability(computeScrollability());
2731 }
2732 
2733 // FIXME: This shouldn&#39;t be called from outside; FrameView should call it when the relevant viewports change.
2734 void FrameView::layoutOrVisualViewportChanged()
2735 {
2736     if (!frame().settings().visualViewportAPIEnabled())
2737         return;
2738 
2739     if (auto* window = frame().window())
2740         window-&gt;visualViewport().update();
2741 
2742     if (auto* page = frame().page()) {
2743         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
2744             scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);
2745     }
2746 }
2747 
<span class="line-removed">2748 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-removed">2749 </span>
2750 void FrameView::unobscuredContentSizeChanged()
2751 {

2752     updateTiledBackingAdaptiveSizing();
<span class="line-removed">2753 }</span>
<span class="line-removed">2754 </span>
2755 #endif

2756 
2757 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2758 {
2759     // We only throttle when constantly receiving new data during the inital page load.
2760     if (!page.progress().isMainLoadProgressing())
2761         return 0;
2762     // Scrolling during page loading disables throttling.
2763     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2764         return 0;
2765     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2766     auto* document = page.mainFrame().document();
2767     if (!document || is&lt;ImageDocument&gt;(*document))
2768         return 0;
2769     return LayerFlushThrottleState::Enabled;
2770 }
2771 
2772 void FrameView::disableLayerFlushThrottlingTemporarilyForInteraction()
2773 {
2774     if (!frame().page())
2775         return;
</pre>
<hr />
<pre>
3344 
3345     if (currentSize == m_lastViewportSize &amp;&amp; currentZoomFactor == m_lastZoomFactor)
3346         return;
3347 
3348     m_lastViewportSize = currentSize;
3349     m_lastZoomFactor = currentZoomFactor;
3350 
3351     if (!layoutContext().didFirstLayout())
3352         return;
3353 
3354 #if PLATFORM(IOS_FAMILY)
3355     // Don&#39;t send the resize event if the document is loading. Some pages automatically reload
3356     // when the window is resized; Safari on iOS often resizes the window while setting up its
3357     // viewport. This obviously can cause problems.
3358     if (DocumentLoader* documentLoader = frame().loader().documentLoader()) {
3359         if (documentLoader-&gt;isLoadingInAPISense())
3360             return;
3361     }
3362 #endif
3363 
<span class="line-modified">3364     bool isMainFrame = frame().isMainFrame();</span>
<span class="line-modified">3365     bool canSendResizeEventSynchronously = isMainFrame &amp;&amp; !m_shouldAutoSize;</span>
<span class="line-removed">3366 </span>
<span class="line-removed">3367     LOG(Events, &quot;FrameView %p sendResizeEventIfNeeded sending resize event, size %dx%d (canSendResizeEventSynchronously %d)&quot;, this, currentSize.width(), currentSize.height(), canSendResizeEventSynchronously);</span>
<span class="line-removed">3368 </span>
<span class="line-removed">3369     Ref&lt;Event&gt; resizeEvent = Event::create(eventNames().resizeEvent, Event::CanBubble::No, Event::IsCancelable::No);</span>
<span class="line-removed">3370     if (canSendResizeEventSynchronously)</span>
<span class="line-removed">3371         frame().document()-&gt;dispatchWindowEvent(resizeEvent);</span>
<span class="line-removed">3372     else {</span>
<span class="line-removed">3373         // FIXME: Queueing this event for an unpredictable time in the future seems</span>
<span class="line-removed">3374         // intrinsically racy. By the time this resize event fires, the frame might</span>
<span class="line-removed">3375         // be resized again, so we could end up with two resize events for the same size.</span>
<span class="line-removed">3376         frame().document()-&gt;enqueueWindowEvent(WTFMove(resizeEvent));</span>
<span class="line-removed">3377     }</span>
3378 

3379     if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
3380         if (Page* page = frame().page()) {
3381             if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
3382                 inspectorClient-&gt;didResizeMainFrame(&amp;frame());
3383         }
3384     }
3385 }
3386 
3387 void FrameView::willStartLiveResize()
3388 {
3389     ScrollView::willStartLiveResize();
3390     adjustTiledBackingCoverage();
3391 }
3392 
3393 void FrameView::willEndLiveResize()
3394 {
3395     ScrollView::willEndLiveResize();
3396     adjustTiledBackingCoverage();
3397 }
3398 
</pre>
<hr />
<pre>
3636 
3637         if (fixedRectInView.y() == unobscuredContentRect.y())
3638             topObscuredArea = std::max(topObscuredArea, fixedRectInView.height());
3639         else if (fixedRectInView.maxY() == unobscuredContentRect.maxY())
3640             bottomObscuredArea = std::max(bottomObscuredArea, fixedRectInView.height());
3641     }
3642 
3643     return Scrollbar::pageStep(unobscuredContentRect.height(), unobscuredContentRect.height() - topObscuredArea - bottomObscuredArea);
3644 }
3645 
3646 void FrameView::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3647 {
3648     // Add in our offset within the FrameView.
3649     IntRect dirtyRect = rect;
3650     dirtyRect.moveBy(scrollbar.location());
3651     invalidateRect(dirtyRect);
3652 }
3653 
3654 float FrameView::visibleContentScaleFactor() const
3655 {
<span class="line-modified">3656     if (!frame().isMainFrame() || !frame().settings().delegatesPageScaling())</span>
3657         return 1;
3658 
3659     Page* page = frame().page();
<span class="line-modified">3660     if (!page)</span>


3661         return 1;
3662 
3663     return page-&gt;pageScaleFactor();
3664 }
3665 
3666 void FrameView::setVisibleScrollerThumbRect(const IntRect&amp; scrollerThumb)
3667 {
3668     if (!frame().isMainFrame())
3669         return;
3670 
3671     if (Page* page = frame().page())
3672         page-&gt;chrome().client().notifyScrollerThumbIsVisibleInRect(scrollerThumb);
3673 }
3674 
3675 ScrollableArea* FrameView::enclosingScrollableArea() const
3676 {
3677     // FIXME: Walk up the frame tree and look for a scrollable parent frame or RenderLayer.
3678     return nullptr;
3679 }
3680 
</pre>
<hr />
<pre>
3795 #if ENABLE(SMOOTH_SCROLLING)
3796     if (Page* page = frame().page())
3797         return page-&gt;settings().scrollAnimatorEnabled();
3798 #endif
3799 
3800     return false;
3801 }
3802 
3803 void FrameView::updateScrollCorner()
3804 {
3805     RenderElement* renderer = nullptr;
3806     std::unique_ptr&lt;RenderStyle&gt; cornerStyle;
3807     IntRect cornerRect = scrollCornerRect();
3808 
3809     if (!cornerRect.isEmpty()) {
3810         // Try the &lt;body&gt; element first as a scroll corner source.
3811         Document* doc = frame().document();
3812         Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
3813         if (body &amp;&amp; body-&gt;renderer()) {
3814             renderer = body-&gt;renderer();
<span class="line-modified">3815             cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());</span>
3816         }
3817 
3818         if (!cornerStyle) {
3819             // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
3820             Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
3821             if (docElement &amp;&amp; docElement-&gt;renderer()) {
3822                 renderer = docElement-&gt;renderer();
<span class="line-modified">3823                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());</span>
3824             }
3825         }
3826 
3827         if (!cornerStyle) {
3828             // If we have an owning iframe/frame element, then it can set the custom scrollbar also.

3829             if (RenderWidget* renderer = frame().ownerRenderer())
<span class="line-modified">3830                 cornerStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::ScrollbarCorner), &amp;renderer-&gt;style());</span>
3831         }
3832     }
3833 
3834     if (!cornerStyle)
3835         m_scrollCorner = nullptr;
3836     else {
3837         if (!m_scrollCorner) {
3838             m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer-&gt;document(), WTFMove(*cornerStyle));
3839             m_scrollCorner-&gt;initializeStyle();
3840         } else
3841             m_scrollCorner-&gt;setStyle(WTFMove(*cornerStyle));
3842         invalidateScrollCorner(cornerRect);
3843     }
3844 }
3845 
3846 void FrameView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
3847 {
3848     if (context.invalidatingControlTints()) {
3849         updateScrollCorner();
3850         return;
</pre>
<hr />
<pre>
4086     }
4087 }
4088 
4089 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4090 {
4091 #ifndef NDEBUG
4092     bool fillWithWarningColor;
4093     if (frame().document()-&gt;printing())
4094         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4095     else if (frame().ownerElement())
4096         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4097     else if (isTransparent())
4098         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
4099     else if (m_paintBehavior &amp; PaintBehavior::SelectionOnly)
4100         fillWithWarningColor = false; // Selections are transparent, don&#39;t fill with red.
4101     else if (m_nodeToDraw)
4102         fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
4103     else
4104         fillWithWarningColor = true;
4105 
<span class="line-modified">4106     if (fillWithWarningColor)</span>
<span class="line-modified">4107         context.fillRect(dirtyRect, Color(255, 64, 255));</span>



4108 #endif
4109 
4110     RenderView* renderView = this-&gt;renderView();
4111     if (!renderView) {
4112         LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
4113         return;
4114     }
4115 








4116     if (!layoutContext().inPaintableState())
4117         return;
4118 
4119     ASSERT(!needsLayout());
4120     if (needsLayout()) {
<span class="line-modified">4121         RELEASE_LOG_IF_ALLOWED(&quot;FrameView::paintContents() - not painting because render tree needs layout (is main frame %d)&quot;, frame().isMainFrame());</span>
4122         return;
4123     }
4124 
4125     PaintingState paintingState;
4126     willPaintContents(context, dirtyRect, paintingState);
4127 
4128     // m_nodeToDraw is used to draw only one element (and its descendants)
4129     RenderObject* renderer = m_nodeToDraw ? m_nodeToDraw-&gt;renderer() : nullptr;
4130     RenderLayer* rootLayer = renderView-&gt;layer();
4131 
4132 #ifndef NDEBUG
4133     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;rootLayer-&gt;renderer());
4134 #endif
4135 
4136     // To work around http://webkit.org/b/135106, ensure that the paint root isn&#39;t an inline with culled line boxes.
4137     // FIXME: This can cause additional content to be included in the snapshot, so remove this once that bug is fixed.
4138     while (is&lt;RenderInline&gt;(renderer) &amp;&amp; !downcast&lt;RenderInline&gt;(*renderer).firstLineBox())
4139         renderer = renderer-&gt;parent();
4140 
4141     rootLayer-&gt;paint(context, dirtyRect, LayoutSize(), m_paintBehavior, renderer, { }, securityOriginPaintPolicy == SecurityOriginPaintPolicy::AnyOrigin ? RenderLayer::SecurityOriginPaintPolicy::AnyOrigin : RenderLayer::SecurityOriginPaintPolicy::AccessibleOriginOnly);
</pre>
<hr />
<pre>
4247                 return nullptr;
4248         }
4249         return descendantsDeque.first().ptr();
4250     };
4251 
4252     for (unsigned i = 0; i &lt; maxUpdatePasses; ++i) {
4253         bool didWork = false;
4254         DescendantsDeque deque;
4255         while (auto view = nextRenderedDescendant(deque)) {
4256             if (view-&gt;frame().document()-&gt;updateStyleIfNeeded())
4257                 didWork = true;
4258             if (view-&gt;needsLayout()) {
4259                 view-&gt;layoutContext().layout();
4260                 didWork = true;
4261             }
4262         }
4263         if (!didWork)
4264             break;
4265     }
4266 
<span class="line-modified">4267 #if !ASSERT_DISABLED</span>
4268     auto needsStyleRecalc = [&amp;] {
4269         DescendantsDeque deque;
4270         while (auto view = nextRenderedDescendant(deque)) {
4271             auto* document = view-&gt;frame().document();
4272             if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
4273                 return true;
4274         }
4275         return false;
4276     };
4277 
4278     auto needsLayout = [&amp;] {
4279         DescendantsDeque deque;
4280         while (auto view = nextRenderedDescendant(deque)) {
4281             if (view-&gt;needsLayout())
4282                 return true;
4283         }
4284         return false;
4285     };
<span class="line-modified">4286 #endif</span>
4287 
4288     ASSERT(!needsStyleRecalc());
4289     ASSERT(!needsLayout());
4290 }
4291 
4292 void FrameView::incrementVisuallyNonEmptyCharacterCount(const String&amp; inlineText)
4293 {
4294     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold &amp;&amp; m_hasReachedSignificantRenderedTextThreshold)
4295         return;
4296 
4297     auto nonWhitespaceLength = [](auto&amp; inlineText) {
4298         auto length = inlineText.length();
4299         for (unsigned i = 0; i &lt; inlineText.length(); ++i) {
4300             if (isNotHTMLSpace(inlineText[i]))
4301                 continue;
4302             --length;
4303         }
4304         return length;
4305     };
4306     m_visuallyNonEmptyCharacterCount += nonWhitespaceLength(inlineText);
</pre>
<hr />
<pre>
5019     sendResizeEventIfNeeded();
5020 }
5021 
5022 void FrameView::setScrollVelocity(const VelocityData&amp; velocityData)
5023 {
5024     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5025         tiledBacking-&gt;setVelocity(velocityData);
5026 }
5027 #endif // PLATFORM(IOS_FAMILY)
5028 
5029 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5030 {
5031     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5032         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5033 }
5034 
5035 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5036 {
5037     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5038     Page* page = frame().page();
<span class="line-modified">5039     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</span>
<span class="line-modified">5040         scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</span>
5041     if (AXObjectCache* cache = axObjectCache())
5042         cache-&gt;handleScrollbarUpdate(this);
5043 }
5044 
5045 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5046 {
5047     ScrollableArea::willRemoveScrollbar(scrollbar, orientation);
5048     if (AXObjectCache* cache = axObjectCache()) {
5049         cache-&gt;remove(scrollbar);
5050         cache-&gt;handleScrollbarUpdate(this);
5051     }
5052 }
5053 
5054 void FrameView::addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
5055 {
5056     m_milestonesPendingPaint.add(milestones);
5057 }
5058 
5059 void FrameView::fireLayoutRelatedMilestonesIfNeeded()
5060 {
</pre>
<hr />
<pre>
5071             milestonesAchieved.add(DidFirstLayout);
5072         if (frame().isMainFrame())
5073             page-&gt;startCountingRelevantRepaintedObjects();
5074     }
5075 
5076     if (!m_isVisuallyNonEmpty &amp;&amp; qualifiesAsVisuallyNonEmpty()) {
5077         m_isVisuallyNonEmpty = true;
5078         addPaintPendingMilestones(DidFirstMeaningfulPaint);
5079         if (requestedMilestones &amp; DidFirstVisuallyNonEmptyLayout)
5080             milestonesAchieved.add(DidFirstVisuallyNonEmptyLayout);
5081     }
5082 
5083     if (!m_renderedSignificantAmountOfText &amp;&amp; qualifiesAsSignificantRenderedText()) {
5084         m_renderedSignificantAmountOfText = true;
5085         if (requestedMilestones &amp; DidRenderSignificantAmountOfText)
5086             milestonesAchieved.add(DidRenderSignificantAmountOfText);
5087     }
5088 
5089     if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
5090         if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
<span class="line-modified">5091             RELEASE_LOG_IF_ALLOWED(&quot;fireLayoutRelatedMilestonesIfNeeded() - firing first visually non-empty layout milestone on the main frame&quot;);</span>
5092         frame().loader().didReachLayoutMilestone(milestonesAchieved);
5093     }
5094 }
5095 
5096 void FrameView::firePaintRelatedMilestonesIfNeeded()
5097 {
5098     Page* page = frame().page();
5099     if (!page)
5100         return;
5101 
5102     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5103 
5104     // Make sure the pending paint milestones have actually been requested before we send them.
5105     if (m_milestonesPendingPaint &amp; DidFirstFlushForHeaderLayer) {
5106         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstFlushForHeaderLayer)
5107             milestonesAchieved.add(DidFirstFlushForHeaderLayer);
5108     }
5109 
5110     if (m_milestonesPendingPaint &amp; DidFirstPaintAfterSuppressedIncrementalRendering) {
5111         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstPaintAfterSuppressedIncrementalRendering)
</pre>
</td>
<td>
<hr />
<pre>
  11  * This library is free software; you can redistribute it and/or
  12  * modify it under the terms of the GNU Library General Public
  13  * License as published by the Free Software Foundation; either
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;FrameView.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
<span class="line-added">  31 #include &quot;BackForwardCache.h&quot;</span>
  32 #include &quot;BackForwardController.h&quot;
  33 #include &quot;CSSAnimationController.h&quot;
  34 #include &quot;CachedImage.h&quot;
  35 #include &quot;CachedResourceLoader.h&quot;
  36 #include &quot;Chrome.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;CustomHeaderFields.h&quot;
  39 #include &quot;DOMWindow.h&quot;
  40 #include &quot;DebugPageOverlays.h&quot;
  41 #include &quot;DeprecatedGlobalSettings.h&quot;
  42 #include &quot;DocumentLoader.h&quot;
  43 #include &quot;DocumentMarkerController.h&quot;
<span class="line-added">  44 #include &quot;Editor.h&quot;</span>
  45 #include &quot;EventHandler.h&quot;
  46 #include &quot;EventNames.h&quot;
  47 #include &quot;FloatRect.h&quot;
  48 #include &quot;FocusController.h&quot;
  49 #include &quot;Frame.h&quot;
  50 #include &quot;FrameLoader.h&quot;
  51 #include &quot;FrameLoaderClient.h&quot;
  52 #include &quot;FrameSelection.h&quot;
  53 #include &quot;FrameTree.h&quot;
  54 #include &quot;GraphicsContext.h&quot;
  55 #include &quot;HTMLBodyElement.h&quot;
  56 #include &quot;HTMLEmbedElement.h&quot;
  57 #include &quot;HTMLFrameElement.h&quot;
  58 #include &quot;HTMLFrameSetElement.h&quot;
  59 #include &quot;HTMLHtmlElement.h&quot;
  60 #include &quot;HTMLIFrameElement.h&quot;
  61 #include &quot;HTMLNames.h&quot;
  62 #include &quot;HTMLObjectElement.h&quot;
  63 #include &quot;HTMLParserIdioms.h&quot;
  64 #include &quot;HTMLPlugInImageElement.h&quot;
  65 #include &quot;ImageDocument.h&quot;
  66 #include &quot;InspectorClient.h&quot;
  67 #include &quot;InspectorController.h&quot;
  68 #include &quot;InspectorInstrumentation.h&quot;
  69 #include &quot;Logging.h&quot;
  70 #include &quot;MemoryCache.h&quot;
  71 #include &quot;OverflowEvent.h&quot;
  72 #include &quot;Page.h&quot;

  73 #include &quot;PageOverlayController.h&quot;
  74 #include &quot;ProgressTracker.h&quot;
  75 #include &quot;RenderEmbeddedObject.h&quot;
  76 #include &quot;RenderFullScreen.h&quot;
  77 #include &quot;RenderIFrame.h&quot;
  78 #include &quot;RenderInline.h&quot;
  79 #include &quot;RenderLayer.h&quot;
  80 #include &quot;RenderLayerBacking.h&quot;
  81 #include &quot;RenderLayerCompositor.h&quot;
  82 #include &quot;RenderSVGRoot.h&quot;
  83 #include &quot;RenderScrollbar.h&quot;
  84 #include &quot;RenderScrollbarPart.h&quot;
  85 #include &quot;RenderStyle.h&quot;
  86 #include &quot;RenderText.h&quot;
  87 #include &quot;RenderTheme.h&quot;
  88 #include &quot;RenderView.h&quot;
  89 #include &quot;RenderWidget.h&quot;
  90 #include &quot;ResizeObserver.h&quot;
  91 #include &quot;RuntimeEnabledFeatures.h&quot;
  92 #include &quot;SVGDocument.h&quot;
  93 #include &quot;SVGSVGElement.h&quot;
  94 #include &quot;ScriptRunner.h&quot;
  95 #include &quot;ScriptedAnimationController.h&quot;
  96 #include &quot;ScrollAnimator.h&quot;
  97 #include &quot;ScrollingCoordinator.h&quot;
  98 #include &quot;Settings.h&quot;
  99 #include &quot;StyleResolver.h&quot;
 100 #include &quot;StyleScope.h&quot;
 101 #include &quot;TextResourceDecoder.h&quot;
 102 #include &quot;TiledBacking.h&quot;
 103 #include &quot;VelocityData.h&quot;
 104 #include &quot;VisualViewport.h&quot;
<span class="line-modified"> 105 #include &quot;WheelEventTestMonitor.h&quot;</span>
 106 #include &lt;wtf/text/TextStream.h&gt;
 107 
 108 #include &lt;wtf/IsoMallocInlines.h&gt;
 109 #include &lt;wtf/MemoryPressureHandler.h&gt;
 110 #include &lt;wtf/Ref.h&gt;
 111 #include &lt;wtf/SetForScope.h&gt;
 112 #include &lt;wtf/SystemTracing.h&gt;
 113 
 114 #if USE(COORDINATED_GRAPHICS)
 115 #include &quot;TiledBackingStore.h&quot;
 116 #endif
 117 
 118 #if ENABLE(CSS_SCROLL_SNAP)
 119 #include &quot;AxisScrollSnapOffsets.h&quot;
 120 #endif
 121 
 122 #if PLATFORM(IOS_FAMILY)
 123 #include &quot;DocumentLoader.h&quot;
 124 #include &quot;LegacyTileCache.h&quot;
 125 #endif
 126 
 127 #if PLATFORM(MAC)
 128 #include &quot;LocalDefaultSystemAppearance.h&quot;
 129 #endif
 130 
<span class="line-modified"> 131 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 132 #include &quot;LayoutContext.h&quot;</span>
<span class="line-added"> 133 #endif</span>
<span class="line-added"> 134 </span>
<span class="line-added"> 135 #define FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(channel, fmt, ...) RELEASE_LOG_IF(frame().page() &amp;&amp; frame().page()-&gt;isAlwaysOnLoggingAllowed(), channel, &quot;%p - [frame=%p, main=%d] FrameView::&quot; fmt, this, &amp;frame(), frame().isMainFrame(), ##__VA_ARGS__)</span>
 136 
 137 namespace WebCore {
 138 
 139 using namespace HTMLNames;
 140 
 141 WTF_MAKE_ISO_ALLOCATED_IMPL(FrameView);
 142 
 143 MonotonicTime FrameView::sCurrentPaintTimeStamp { };
 144 
 145 // The maximum number of updateEmbeddedObjects iterations that should be done before returning.
 146 static const unsigned maxUpdateEmbeddedObjectsIterations = 2;
 147 
 148 static constexpr unsigned defaultSignificantRenderedTextCharacterThreshold = 3000;
 149 static constexpr float defaultSignificantRenderedTextMeanLength = 50;
 150 static constexpr unsigned mainArticleSignificantRenderedTextCharacterThreshold = 1500;
 151 static constexpr float mainArticleSignificantRenderedTextMeanLength = 25;
 152 
 153 Pagination::Mode paginationModeForRenderStyle(const RenderStyle&amp; style)
 154 {
 155     Overflow overflow = style.overflowY();
</pre>
<hr />
<pre>
 512     return isFrameFlatteningValidForThisFrame();
 513 }
 514 
 515 void FrameView::setCanHaveScrollbars(bool canHaveScrollbars)
 516 {
 517     m_canHaveScrollbars = canHaveScrollbars;
 518     ScrollView::setCanHaveScrollbars(canHaveScrollbars);
 519 }
 520 
 521 void FrameView::updateCanHaveScrollbars()
 522 {
 523     ScrollbarMode hMode;
 524     ScrollbarMode vMode;
 525     scrollbarModes(hMode, vMode);
 526     if (hMode == ScrollbarAlwaysOff &amp;&amp; vMode == ScrollbarAlwaysOff)
 527         setCanHaveScrollbars(false);
 528     else
 529         setCanHaveScrollbars(true);
 530 }
 531 
<span class="line-modified"> 532 RefPtr&lt;Element&gt; FrameView::rootElementForCustomScrollbarPartStyle(PseudoId partPseudoId) const</span>
 533 {
 534     // FIXME: We need to update the scrollbar dynamically as documents change (or as doc elements and bodies get discovered that have custom styles).
<span class="line-modified"> 535     auto* document = frame().document();</span>
<span class="line-added"> 536     if (!document)</span>
<span class="line-added"> 537         return nullptr;</span>
 538 
 539     // Try the &lt;body&gt; element first as a scrollbar source.
<span class="line-modified"> 540     auto* body = document-&gt;bodyOrFrameset();</span>
<span class="line-modified"> 541     if (body &amp;&amp; body-&gt;renderer() &amp;&amp; body-&gt;renderer()-&gt;style().hasPseudoStyle(partPseudoId))</span>
<span class="line-modified"> 542         return body;</span>
 543 
 544     // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
<span class="line-modified"> 545     auto* docElement = document-&gt;documentElement();</span>
<span class="line-modified"> 546     if (docElement &amp;&amp; docElement-&gt;renderer() &amp;&amp; docElement-&gt;renderer()-&gt;style().hasPseudoStyle(partPseudoId))</span>
<span class="line-modified"> 547         return docElement;</span>
<span class="line-added"> 548 </span>
<span class="line-added"> 549     return nullptr;</span>
<span class="line-added"> 550 }</span>
<span class="line-added"> 551 </span>
<span class="line-added"> 552 Ref&lt;Scrollbar&gt; FrameView::createScrollbar(ScrollbarOrientation orientation)</span>
<span class="line-added"> 553 {</span>
<span class="line-added"> 554     if (auto element = rootElementForCustomScrollbarPartStyle(PseudoId::Scrollbar))</span>
<span class="line-added"> 555         return RenderScrollbar::createCustomScrollbar(*this, orientation, element.get());</span>
 556 
 557     // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
<span class="line-added"> 558     // FIXME: Seems bad to do this for cross-origin frames.</span>
 559     RenderWidget* frameRenderer = frame().ownerRenderer();
 560     if (frameRenderer &amp;&amp; frameRenderer-&gt;style().hasPseudoStyle(PseudoId::Scrollbar))
 561         return RenderScrollbar::createCustomScrollbar(*this, orientation, nullptr, &amp;frame());
 562 
 563     // Nobody set a custom style, so we just use a native scrollbar.
 564     return ScrollView::createScrollbar(orientation);
 565 }
 566 
<span class="line-modified"> 567 void FrameView::didRestoreFromBackForwardCache()</span>
 568 {
<span class="line-modified"> 569     // When restoring from back/forward cache, the main frame stays in place while subframes get swapped in.</span>
 570     // We update the scrollable area set to ensure that scrolling data structures get invalidated.
 571     updateScrollableAreaSet();
 572 }
 573 
 574 void FrameView::willDestroyRenderTree()
 575 {
 576     detachCustomScrollbars();
 577     layoutContext().clearSubtreeLayoutRoot();
 578 }
 579 
 580 void FrameView::didDestroyRenderTree()
 581 {
 582     ASSERT(!layoutContext().subtreeLayoutRoot());
 583     ASSERT(m_widgetsInRenderTree.isEmpty());
 584 
 585     // If the render tree is destroyed below FrameView::updateEmbeddedObjects(), there will still be a null sentinel in the set.
 586     // Everything else should have removed itself as the tree was felled.
 587     ASSERT(!m_embeddedObjectsToUpdate || m_embeddedObjectsToUpdate-&gt;isEmpty() || (m_embeddedObjectsToUpdate-&gt;size() == 1 &amp;&amp; m_embeddedObjectsToUpdate-&gt;first() == nullptr));
 588 
 589     ASSERT(!m_viewportConstrainedObjects || m_viewportConstrainedObjects-&gt;isEmpty());
</pre>
<hr />
<pre>
 595 void FrameView::setContentsSize(const IntSize&amp; size)
 596 {
 597     if (size == contentsSize())
 598         return;
 599 
 600     layoutContext().disableSetNeedsLayout();
 601 
 602     ScrollView::setContentsSize(size);
 603     contentsResized();
 604 
 605     Page* page = frame().page();
 606     if (!page)
 607         return;
 608 
 609     updateScrollableAreaSet();
 610 
 611     page-&gt;chrome().contentsSizeChanged(frame(), size); // Notify only.
 612 
 613     if (frame().isMainFrame()) {
 614         page-&gt;pageOverlayController().didChangeDocumentSize();
<span class="line-modified"> 615         BackForwardCache::singleton().markPagesForContentsSizeChanged(*page);</span>
 616     }
 617     layoutContext().enableSetNeedsLayout();
 618 }
 619 
 620 void FrameView::adjustViewSize()
 621 {
 622     RenderView* renderView = this-&gt;renderView();
 623     if (!renderView)
 624         return;
 625 
 626     ASSERT(frame().view() == this);
 627 
 628     const IntRect rect = renderView-&gt;documentRect();
 629     const IntSize&amp; size = rect.size();
 630     ScrollView::setScrollOrigin(IntPoint(-rect.x(), -rect.y()), !frame().document()-&gt;printing(), size == contentsSize());
 631 
 632     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; adjustViewSize: unscaled document rect changed to &quot; &lt;&lt; renderView-&gt;unscaledDocumentRect() &lt;&lt; &quot; (scaled to &quot; &lt;&lt; size &lt;&lt; &quot;)&quot;);
 633 
 634     setContentsSize(size);
 635 }
</pre>
<hr />
<pre>
 782             if (bodyRenderer) {
 783                 applyOverflowToViewport(*bodyRenderer, hMode, vMode);
 784                 m_viewportRendererType = ViewportRendererType::Body;
 785             }
 786         } else {
 787             applyOverflowToViewport(*rootRenderer, hMode, vMode);
 788             m_viewportRendererType = ViewportRendererType::Document;
 789         }
 790     }
 791 }
 792 
 793 void FrameView::willRecalcStyle()
 794 {
 795     RenderView* renderView = this-&gt;renderView();
 796     if (!renderView)
 797         return;
 798 
 799     renderView-&gt;compositor().willRecalcStyle();
 800 }
 801 
<span class="line-added"> 802 void FrameView::styleDidChange()</span>
<span class="line-added"> 803 {</span>
<span class="line-added"> 804     ScrollView::styleDidChange();</span>
<span class="line-added"> 805     RenderView* renderView = this-&gt;renderView();</span>
<span class="line-added"> 806     if (!renderView)</span>
<span class="line-added"> 807         return;</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809     RenderLayer* layerTreeMutationRoot = renderView-&gt;takeStyleChangeLayerTreeMutationRoot();</span>
<span class="line-added"> 810     if (layerTreeMutationRoot &amp;&amp; !needsLayout())</span>
<span class="line-added"> 811         layerTreeMutationRoot-&gt;updateLayerPositionsAfterStyleChange();</span>
<span class="line-added"> 812 }</span>
<span class="line-added"> 813 </span>
 814 bool FrameView::updateCompositingLayersAfterStyleChange()
 815 {
 816     // If we expect to update compositing after an incipient layout, don&#39;t do so here.
 817     if (!renderView() || needsLayout() || layoutContext().isInLayout())
 818         return false;
 819     return renderView()-&gt;compositor().didRecalcStyleWithNoPendingLayout();
 820 }
 821 
 822 void FrameView::updateCompositingLayersAfterLayout()
 823 {
 824     RenderView* renderView = this-&gt;renderView();
 825     if (!renderView)
 826         return;
 827 
 828     renderView-&gt;compositor().updateCompositingLayers(CompositingUpdateType::AfterLayout);
 829 }
 830 
 831 GraphicsLayer* FrameView::layerForHorizontalScrollbar() const
 832 {
 833     RenderView* renderView = this-&gt;renderView();
</pre>
<hr />
<pre>
1202     if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())
1203         bodyRenderer-&gt;setChildNeedsLayout();
1204     else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())
1205         rootRenderer-&gt;setChildNeedsLayout();
1206 }
1207 
1208 void FrameView::adjustScrollbarsForLayout(bool isFirstLayout)
1209 {
1210     ScrollbarMode hMode;
1211     ScrollbarMode vMode;
1212     calculateScrollbarModesForLayout(hMode, vMode);
1213     if (isFirstLayout &amp;&amp; !layoutContext().isLayoutNested()) {
1214         setScrollbarsSuppressed(true);
1215         // Set the initial vMode to AlwaysOn if we&#39;re auto.
1216         if (vMode == ScrollbarAuto)
1217             setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.
1218         // Set the initial hMode to AlwaysOff if we&#39;re auto.
1219         if (hMode == ScrollbarAuto)
1220             setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.
1221         ASSERT(frame().page());
<span class="line-modified">1222         if (frame().page()-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">1223             scrollAnimator().setWheelEventTestMonitor(frame().page()-&gt;wheelEventTestMonitor());</span>
1224         setScrollbarModes(hMode, vMode);
1225         setScrollbarsSuppressed(false, true);
1226     } else if (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())
1227         setScrollbarModes(hMode, vMode);
1228 }
1229 
1230 void FrameView::willDoLayout(WeakPtr&lt;RenderElement&gt; layoutRoot)
1231 {
1232     bool subtreeLayout = !is&lt;RenderView&gt;(*layoutRoot);
1233     if (subtreeLayout)
1234         return;
1235 
1236     if (auto* body = frame().document()-&gt;bodyOrFrameset()) {
1237         if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled() &amp;&amp; body-&gt;renderer())
1238             body-&gt;renderer()-&gt;setChildNeedsLayout();
1239     }
1240     auto firstLayout = !layoutContext().didFirstLayout();
1241     if (firstLayout) {
1242         m_lastViewportSize = sizeForResizeEvent();
1243         m_lastZoomFactor = layoutRoot-&gt;style().zoom();
</pre>
<hr />
<pre>
1415 }
1416 
1417 bool FrameView::usesMockScrollAnimator() const
1418 {
1419     return DeprecatedGlobalSettings::usesMockScrollAnimator();
1420 }
1421 
1422 void FrameView::logMockScrollAnimatorMessage(const String&amp; message) const
1423 {
1424     Document* document = frame().document();
1425     if (!document)
1426         return;
1427     StringBuilder builder;
1428     if (frame().isMainFrame())
1429         builder.appendLiteral(&quot;Main&quot;);
1430     builder.appendLiteral(&quot;FrameView: &quot;);
1431     builder.append(message);
1432     document-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Debug, builder.toString());
1433 }
1434 
<span class="line-added">1435 bool FrameView::styleHidesScrollbarWithOrientation(ScrollbarOrientation orientation) const</span>
<span class="line-added">1436 {</span>
<span class="line-added">1437     auto element = rootElementForCustomScrollbarPartStyle(PseudoId::Scrollbar);</span>
<span class="line-added">1438     if (!element)</span>
<span class="line-added">1439         return false;</span>
<span class="line-added">1440     auto* renderer = element-&gt;renderer();</span>
<span class="line-added">1441     ASSERT(renderer); // rootElementForCustomScrollbarPart assures that it&#39;s not null.</span>
<span class="line-added">1442 </span>
<span class="line-added">1443     StyleScrollbarState scrollbarState;</span>
<span class="line-added">1444     scrollbarState.scrollbarPart = ScrollbarBGPart;</span>
<span class="line-added">1445     scrollbarState.orientation = orientation;</span>
<span class="line-added">1446     auto scrollbarStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::Scrollbar, scrollbarState }, &amp;renderer-&gt;style());</span>
<span class="line-added">1447     return scrollbarStyle &amp;&amp; scrollbarStyle-&gt;display() == DisplayType::None;</span>
<span class="line-added">1448 }</span>
<span class="line-added">1449 </span>
<span class="line-added">1450 bool FrameView::horizontalScrollbarHiddenByStyle() const</span>
<span class="line-added">1451 {</span>
<span class="line-added">1452     if (managesScrollbars()) {</span>
<span class="line-added">1453         auto* scrollbar = horizontalScrollbar();</span>
<span class="line-added">1454         return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>
<span class="line-added">1455     }</span>
<span class="line-added">1456 </span>
<span class="line-added">1457     return styleHidesScrollbarWithOrientation(HorizontalScrollbar);</span>
<span class="line-added">1458 }</span>
<span class="line-added">1459 </span>
<span class="line-added">1460 bool FrameView::verticalScrollbarHiddenByStyle() const</span>
<span class="line-added">1461 {</span>
<span class="line-added">1462     if (managesScrollbars()) {</span>
<span class="line-added">1463         auto* scrollbar = verticalScrollbar();</span>
<span class="line-added">1464         return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();</span>
<span class="line-added">1465     }</span>
<span class="line-added">1466 </span>
<span class="line-added">1467     return styleHidesScrollbarWithOrientation(VerticalScrollbar);</span>
<span class="line-added">1468 }</span>
<span class="line-added">1469 </span>
1470 void FrameView::setCannotBlitToWindow()
1471 {
1472     m_cannotBlitToWindow = true;
1473     updateCanBlitOnScrollRecursively();
1474 }
1475 
1476 void FrameView::addSlowRepaintObject(RenderElement&amp; renderer)
1477 {
1478     bool hadSlowRepaintObjects = hasSlowRepaintObjects();
1479 
1480     if (!m_slowRepaintObjects)
1481         m_slowRepaintObjects = makeUnique&lt;HashSet&lt;const RenderElement*&gt;&gt;();
1482 
1483     m_slowRepaintObjects-&gt;add(&amp;renderer);
1484     if (hadSlowRepaintObjects)
1485         return;
1486 
1487     updateCanBlitOnScrollRecursively();
1488 
1489     if (auto* page = frame().page()) {
</pre>
<hr />
<pre>
2164     updateCanBlitOnScrollRecursively();
2165 }
2166 
2167 void FrameView::setContentIsOpaque(bool contentIsOpaque)
2168 {
2169     if (contentIsOpaque == m_contentIsOpaque)
2170         return;
2171 
2172     m_contentIsOpaque = contentIsOpaque;
2173     updateCanBlitOnScrollRecursively();
2174 }
2175 
2176 void FrameView::restoreScrollbar()
2177 {
2178     setScrollbarsSuppressed(false);
2179 }
2180 
2181 bool FrameView::scrollToFragment(const URL&amp; url)
2182 {
2183     String fragmentIdentifier = url.fragmentIdentifier();
<span class="line-modified">2184     if (scrollToFragmentInternal(fragmentIdentifier))</span>
2185         return true;
2186 
2187     // Try again after decoding the ref, based on the document&#39;s encoding.
2188     if (TextResourceDecoder* decoder = frame().document()-&gt;decoder()) {
<span class="line-modified">2189         if (scrollToFragmentInternal(decodeURLEscapeSequences(fragmentIdentifier, decoder-&gt;encoding())))</span>
2190             return true;
2191     }
2192 
2193     resetScrollAnchor();
2194     return false;
2195 }
2196 
<span class="line-modified">2197 bool FrameView::scrollToFragmentInternal(const String&amp; fragmentIdentifier)</span>
2198 {
2199     LOG(Scrolling, &quot;FrameView::scrollToAnchor %s&quot;, fragmentIdentifier.utf8().data());
2200 
2201     // If our URL has no ref, then we have no place we need to jump to.
2202     if (fragmentIdentifier.isNull())
2203         return false;
2204 
2205     ASSERT(frame().document());
2206     auto&amp; document = *frame().document();
<span class="line-modified">2207     RELEASE_ASSERT(document.haveStylesheetsLoaded());</span>






2208 
2209     Element* anchorElement = document.findAnchor(fragmentIdentifier);
2210 
2211     LOG(Scrolling, &quot; anchorElement is %p&quot;, anchorElement);
2212 
2213     // Setting to null will clear the current target.
2214     document.setCSSTarget(anchorElement);
2215 
2216     if (is&lt;SVGDocument&gt;(document)) {
2217         if (fragmentIdentifier.isEmpty())
2218             return false;
2219         if (auto rootElement = SVGDocument::rootElement(document)) {
2220             if (rootElement-&gt;scrollToFragment(fragmentIdentifier))
2221                 return true;
2222             // If SVG failed to scrollToAnchor() and anchorElement is null, no other scrolling will be possible.
2223             if (!anchorElement)
2224                 return false;
2225         }
2226     } else if (!anchorElement &amp;&amp; !(fragmentIdentifier.isEmpty() || equalLettersIgnoringASCIICase(fragmentIdentifier, &quot;top&quot;))) {
2227         // Implement the rule that &quot;&quot; and &quot;top&quot; both mean top of page as in other browsers.
</pre>
<hr />
<pre>
2262     // Only do a layout if changes have occurred that make it necessary.
2263     RenderView* renderView = this-&gt;renderView();
2264     if (renderView &amp;&amp; renderView-&gt;needsLayout())
2265         layoutContext().layout();
2266     else
2267         scrollToAnchor();
2268 }
2269 
2270 void FrameView::scrollElementToRect(const Element&amp; element, const IntRect&amp; rect)
2271 {
2272     frame().document()-&gt;updateLayoutIgnorePendingStylesheets();
2273 
2274     LayoutRect bounds;
2275     if (RenderElement* renderer = element.renderer())
2276         bounds = renderer-&gt;absoluteAnchorRect();
2277     int centeringOffsetX = (rect.width() - bounds.width()) / 2;
2278     int centeringOffsetY = (rect.height() - bounds.height()) / 2;
2279     setScrollPosition(IntPoint(bounds.x() - centeringOffsetX - rect.x(), bounds.y() - centeringOffsetY - rect.y()));
2280 }
2281 
<span class="line-modified">2282 void FrameView::setScrollPosition(const ScrollPosition&amp; scrollPosition, ScrollClamping clamping)</span>
2283 {
2284     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::setScrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; , clearing anchor&quot;);
2285 
2286     auto oldScrollType = currentScrollType();
2287     setCurrentScrollType(ScrollType::Programmatic);
2288 
2289     m_maintainScrollPositionAnchor = nullptr;
2290     m_shouldScrollToFocusedElement = false;
2291     m_delayedScrollToFocusedElementTimer.stop();
2292     Page* page = frame().page();
<span class="line-modified">2293     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">2294         scrollAnimator().setWheelEventTestMonitor(page-&gt;wheelEventTestMonitor());</span>
<span class="line-modified">2295     ScrollView::setScrollPosition(scrollPosition, clamping);</span>
2296 
2297     setCurrentScrollType(oldScrollType);
2298 }
2299 
2300 void FrameView::resetScrollAnchor()
2301 {
2302     ASSERT(frame().document());
2303     auto&amp; document = *frame().document();
2304 
2305     // If CSS target was set previously, we want to set it to 0, recalc
2306     // and possibly repaint because :target pseudo class may have been
2307     // set (see bug 11321).
2308     document.setCSSTarget(nullptr);
2309 
2310     if (is&lt;SVGDocument&gt;(document)) {
2311         if (auto rootElement = SVGDocument::rootElement(document)) {
2312             // We need to update the layout before resetScrollAnchor(), otherwise we
2313             // could really mess things up if resetting the anchor comes at a bad moment.
2314             document.updateStyleIfNeeded();
2315             rootElement-&gt;resetScrollAnchor();
</pre>
<hr />
<pre>
2463     UNUSED_PARAM(oldPosition);
2464     UNUSED_PARAM(newPosition);
2465 
2466     Page* page = frame().page();
2467     Seconds throttlingDelay = page ? page-&gt;chrome().client().eventThrottlingDelay() : 0_s;
2468 
2469     if (throttlingDelay == 0_s) {
2470         m_delayedScrollEventTimer.stop();
2471         sendScrollEvent();
2472     } else if (!m_delayedScrollEventTimer.isActive())
2473         m_delayedScrollEventTimer.startOneShot(throttlingDelay);
2474 
2475     if (RenderView* renderView = this-&gt;renderView()) {
2476         if (renderView-&gt;usesCompositing())
2477             renderView-&gt;compositor().frameViewDidScroll();
2478     }
2479 
2480     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; scrollPositionChanged from &quot; &lt;&lt; oldPosition &lt;&lt; &quot; to &quot; &lt;&lt; newPosition &lt;&lt; &quot; (scale &quot; &lt;&lt; frameScaleFactor() &lt;&lt; &quot; )&quot;);
2481     updateLayoutViewport();
2482     viewportContentsChanged();
<span class="line-added">2483 </span>
<span class="line-added">2484     if (auto* renderView = this-&gt;renderView()) {</span>
<span class="line-added">2485         if (auto* layer = renderView-&gt;layer())</span>
<span class="line-added">2486             frame().editor().renderLayerDidScroll(*layer);</span>
<span class="line-added">2487     }</span>
2488 }
2489 
2490 void FrameView::applyRecursivelyWithVisibleRect(const WTF::Function&lt;void (FrameView&amp; frameView, const IntRect&amp; visibleRect)&gt;&amp; apply)
2491 {
2492     IntRect windowClipRect = this-&gt;windowClipRect();
2493     auto visibleRect = windowToContents(windowClipRect);
2494     apply(*this, visibleRect);
2495 
2496     // Recursive call for subframes. We cache the current FrameView&#39;s windowClipRect to avoid recomputing it for every subframe.
2497     SetForScope&lt;IntRect*&gt; windowClipRectCache(m_cachedWindowClipRect, &amp;windowClipRect);
2498     for (Frame* childFrame = frame().tree().firstChild(); childFrame; childFrame = childFrame-&gt;tree().nextSibling()) {
2499         if (auto* childView = childFrame-&gt;view())
2500             childView-&gt;applyRecursivelyWithVisibleRect(apply);
2501     }
2502 }
2503 
2504 void FrameView::resumeVisibleImageAnimations(const IntRect&amp; visibleRect)
2505 {
2506     if (visibleRect.isEmpty())
2507         return;
</pre>
<hr />
<pre>
2599     if (scrollbarsSuppressed())
2600         return false;
2601 
2602     // If the scrolling thread updates the scroll position for this FrameView, then we should return
2603     // ScrollingCoordinator::isRubberBandInProgress().
2604     if (Page* page = frame().page()) {
2605         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator()) {
2606             if (!scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(*this))
2607                 return scrollingCoordinator-&gt;isRubberBandInProgress();
2608         }
2609     }
2610 
2611     // If the main thread updates the scroll position for this FrameView, we should return
2612     // ScrollAnimator::isRubberBandInProgress().
2613     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
2614         return scrollAnimator-&gt;isRubberBandInProgress();
2615 
2616     return false;
2617 }
2618 
<span class="line-modified">2619 bool FrameView::requestScrollPositionUpdate(const ScrollPosition&amp; position, ScrollType scrollType, ScrollClamping clamping)</span>
2620 {
2621     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;FrameView::requestScrollPositionUpdate &quot; &lt;&lt; position);
2622 
2623 #if ENABLE(ASYNC_SCROLLING)
2624     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
2625         tiledBacking-&gt;prepopulateRect(FloatRect(position, visibleContentRect().size()));
2626 #endif
2627 
2628 #if ENABLE(ASYNC_SCROLLING) || USE(COORDINATED_GRAPHICS)
2629     if (Page* page = frame().page()) {
2630         if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
<span class="line-modified">2631             return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position, scrollType, clamping);</span>
2632     }
2633 #else
2634     UNUSED_PARAM(position);
2635 #endif
2636 
2637     return false;
2638 }
2639 
2640 HostWindow* FrameView::hostWindow() const
2641 {
2642     auto* page = frame().page();
2643     if (!page)
2644         return nullptr;
2645     return &amp;page-&gt;chrome();
2646 }
2647 
2648 void FrameView::addTrackedRepaintRect(const FloatRect&amp; r)
2649 {
2650     if (!m_isTrackingRepaints || r.isEmpty())
2651         return;
</pre>
<hr />
<pre>
2790         return;
2791 
2792     tiledBacking-&gt;setScrollability(computeScrollability());
2793 }
2794 
2795 // FIXME: This shouldn&#39;t be called from outside; FrameView should call it when the relevant viewports change.
2796 void FrameView::layoutOrVisualViewportChanged()
2797 {
2798     if (!frame().settings().visualViewportAPIEnabled())
2799         return;
2800 
2801     if (auto* window = frame().window())
2802         window-&gt;visualViewport().update();
2803 
2804     if (auto* page = frame().page()) {
2805         if (auto* scrollingCoordinator = page-&gt;scrollingCoordinator())
2806             scrollingCoordinator-&gt;frameViewVisualViewportChanged(*this);
2807     }
2808 }
2809 


2810 void FrameView::unobscuredContentSizeChanged()
2811 {
<span class="line-added">2812 #if PLATFORM(IOS_FAMILY)</span>
2813     updateTiledBackingAdaptiveSizing();


2814 #endif
<span class="line-added">2815 }</span>
2816 
2817 static LayerFlushThrottleState::Flags determineLayerFlushThrottleState(Page&amp; page)
2818 {
2819     // We only throttle when constantly receiving new data during the inital page load.
2820     if (!page.progress().isMainLoadProgressing())
2821         return 0;
2822     // Scrolling during page loading disables throttling.
2823     if (page.mainFrame().view()-&gt;wasScrolledByUser())
2824         return 0;
2825     // Disable for image documents so large GIF animations don&#39;t get throttled during loading.
2826     auto* document = page.mainFrame().document();
2827     if (!document || is&lt;ImageDocument&gt;(*document))
2828         return 0;
2829     return LayerFlushThrottleState::Enabled;
2830 }
2831 
2832 void FrameView::disableLayerFlushThrottlingTemporarilyForInteraction()
2833 {
2834     if (!frame().page())
2835         return;
</pre>
<hr />
<pre>
3404 
3405     if (currentSize == m_lastViewportSize &amp;&amp; currentZoomFactor == m_lastZoomFactor)
3406         return;
3407 
3408     m_lastViewportSize = currentSize;
3409     m_lastZoomFactor = currentZoomFactor;
3410 
3411     if (!layoutContext().didFirstLayout())
3412         return;
3413 
3414 #if PLATFORM(IOS_FAMILY)
3415     // Don&#39;t send the resize event if the document is loading. Some pages automatically reload
3416     // when the window is resized; Safari on iOS often resizes the window while setting up its
3417     // viewport. This obviously can cause problems.
3418     if (DocumentLoader* documentLoader = frame().loader().documentLoader()) {
3419         if (documentLoader-&gt;isLoadingInAPISense())
3420             return;
3421     }
3422 #endif
3423 
<span class="line-modified">3424     LOG_WITH_STREAM(Events, stream &lt;&lt; &quot;FrameView&quot; &lt;&lt; this &lt;&lt; &quot;sendResizeEventIfNeeded scheduling resize event for document&quot; &lt;&lt; frame().document() &lt;&lt; &quot;, size &quot; &lt;&lt; currentSize);</span>
<span class="line-modified">3425     frame().document()-&gt;setNeedsDOMWindowResizeEvent();</span>












3426 
<span class="line-added">3427     bool isMainFrame = frame().isMainFrame();</span>
3428     if (InspectorInstrumentation::hasFrontends() &amp;&amp; isMainFrame) {
3429         if (Page* page = frame().page()) {
3430             if (InspectorClient* inspectorClient = page-&gt;inspectorController().inspectorClient())
3431                 inspectorClient-&gt;didResizeMainFrame(&amp;frame());
3432         }
3433     }
3434 }
3435 
3436 void FrameView::willStartLiveResize()
3437 {
3438     ScrollView::willStartLiveResize();
3439     adjustTiledBackingCoverage();
3440 }
3441 
3442 void FrameView::willEndLiveResize()
3443 {
3444     ScrollView::willEndLiveResize();
3445     adjustTiledBackingCoverage();
3446 }
3447 
</pre>
<hr />
<pre>
3685 
3686         if (fixedRectInView.y() == unobscuredContentRect.y())
3687             topObscuredArea = std::max(topObscuredArea, fixedRectInView.height());
3688         else if (fixedRectInView.maxY() == unobscuredContentRect.maxY())
3689             bottomObscuredArea = std::max(bottomObscuredArea, fixedRectInView.height());
3690     }
3691 
3692     return Scrollbar::pageStep(unobscuredContentRect.height(), unobscuredContentRect.height() - topObscuredArea - bottomObscuredArea);
3693 }
3694 
3695 void FrameView::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3696 {
3697     // Add in our offset within the FrameView.
3698     IntRect dirtyRect = rect;
3699     dirtyRect.moveBy(scrollbar.location());
3700     invalidateRect(dirtyRect);
3701 }
3702 
3703 float FrameView::visibleContentScaleFactor() const
3704 {
<span class="line-modified">3705     if (!frame().isMainFrame())</span>
3706         return 1;
3707 
3708     Page* page = frame().page();
<span class="line-modified">3709     // FIXME: This !delegatesScaling() is confusing, and the opposite behavior to Frame::frameScaleFactor().</span>
<span class="line-added">3710     // This function should probably be renamed to delegatedPageScaleFactor().</span>
<span class="line-added">3711     if (!page || !page-&gt;delegatesScaling())</span>
3712         return 1;
3713 
3714     return page-&gt;pageScaleFactor();
3715 }
3716 
3717 void FrameView::setVisibleScrollerThumbRect(const IntRect&amp; scrollerThumb)
3718 {
3719     if (!frame().isMainFrame())
3720         return;
3721 
3722     if (Page* page = frame().page())
3723         page-&gt;chrome().client().notifyScrollerThumbIsVisibleInRect(scrollerThumb);
3724 }
3725 
3726 ScrollableArea* FrameView::enclosingScrollableArea() const
3727 {
3728     // FIXME: Walk up the frame tree and look for a scrollable parent frame or RenderLayer.
3729     return nullptr;
3730 }
3731 
</pre>
<hr />
<pre>
3846 #if ENABLE(SMOOTH_SCROLLING)
3847     if (Page* page = frame().page())
3848         return page-&gt;settings().scrollAnimatorEnabled();
3849 #endif
3850 
3851     return false;
3852 }
3853 
3854 void FrameView::updateScrollCorner()
3855 {
3856     RenderElement* renderer = nullptr;
3857     std::unique_ptr&lt;RenderStyle&gt; cornerStyle;
3858     IntRect cornerRect = scrollCornerRect();
3859 
3860     if (!cornerRect.isEmpty()) {
3861         // Try the &lt;body&gt; element first as a scroll corner source.
3862         Document* doc = frame().document();
3863         Element* body = doc ? doc-&gt;bodyOrFrameset() : nullptr;
3864         if (body &amp;&amp; body-&gt;renderer()) {
3865             renderer = body-&gt;renderer();
<span class="line-modified">3866             cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
3867         }
3868 
3869         if (!cornerStyle) {
3870             // If the &lt;body&gt; didn&#39;t have a custom style, then the root element might.
3871             Element* docElement = doc ? doc-&gt;documentElement() : nullptr;
3872             if (docElement &amp;&amp; docElement-&gt;renderer()) {
3873                 renderer = docElement-&gt;renderer();
<span class="line-modified">3874                 cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
3875             }
3876         }
3877 
3878         if (!cornerStyle) {
3879             // If we have an owning iframe/frame element, then it can set the custom scrollbar also.
<span class="line-added">3880             // FIXME: Seems wrong to do this for cross-origin frames.</span>
3881             if (RenderWidget* renderer = frame().ownerRenderer())
<span class="line-modified">3882                 cornerStyle = renderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;renderer-&gt;style());</span>
3883         }
3884     }
3885 
3886     if (!cornerStyle)
3887         m_scrollCorner = nullptr;
3888     else {
3889         if (!m_scrollCorner) {
3890             m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer-&gt;document(), WTFMove(*cornerStyle));
3891             m_scrollCorner-&gt;initializeStyle();
3892         } else
3893             m_scrollCorner-&gt;setStyle(WTFMove(*cornerStyle));
3894         invalidateScrollCorner(cornerRect);
3895     }
3896 }
3897 
3898 void FrameView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
3899 {
3900     if (context.invalidatingControlTints()) {
3901         updateScrollCorner();
3902         return;
</pre>
<hr />
<pre>
4138     }
4139 }
4140 
4141 void FrameView::paintContents(GraphicsContext&amp; context, const IntRect&amp; dirtyRect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
4142 {
4143 #ifndef NDEBUG
4144     bool fillWithWarningColor;
4145     if (frame().document()-&gt;printing())
4146         fillWithWarningColor = false; // Printing, don&#39;t fill with red (can&#39;t remember why).
4147     else if (frame().ownerElement())
4148         fillWithWarningColor = false; // Subframe, don&#39;t fill with red.
4149     else if (isTransparent())
4150         fillWithWarningColor = false; // Transparent, don&#39;t fill with red.
4151     else if (m_paintBehavior &amp; PaintBehavior::SelectionOnly)
4152         fillWithWarningColor = false; // Selections are transparent, don&#39;t fill with red.
4153     else if (m_nodeToDraw)
4154         fillWithWarningColor = false; // Element images are transparent, don&#39;t fill with red.
4155     else
4156         fillWithWarningColor = true;
4157 
<span class="line-modified">4158     if (fillWithWarningColor) {</span>
<span class="line-modified">4159         IntRect debugRect = frameRect();</span>
<span class="line-added">4160         debugRect.intersect(dirtyRect);</span>
<span class="line-added">4161         context.fillRect(debugRect, Color(255, 64, 255));</span>
<span class="line-added">4162     }</span>
4163 #endif
4164 
4165     RenderView* renderView = this-&gt;renderView();
4166     if (!renderView) {
4167         LOG_ERROR(&quot;called FrameView::paint with nil renderer&quot;);
4168         return;
4169     }
4170 
<span class="line-added">4171 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">4172     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">4173         if (auto* layoutState = layoutContext().layoutFormattingState())</span>
<span class="line-added">4174             Layout::LayoutContext::paint(*layoutState, context, dirtyRect);</span>
<span class="line-added">4175         return;</span>
<span class="line-added">4176     }</span>
<span class="line-added">4177 #endif</span>
<span class="line-added">4178 </span>
4179     if (!layoutContext().inPaintableState())
4180         return;
4181 
4182     ASSERT(!needsLayout());
4183     if (needsLayout()) {
<span class="line-modified">4184         FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(Layout, &quot;paintContents: Not painting because render tree needs layout&quot;);</span>
4185         return;
4186     }
4187 
4188     PaintingState paintingState;
4189     willPaintContents(context, dirtyRect, paintingState);
4190 
4191     // m_nodeToDraw is used to draw only one element (and its descendants)
4192     RenderObject* renderer = m_nodeToDraw ? m_nodeToDraw-&gt;renderer() : nullptr;
4193     RenderLayer* rootLayer = renderView-&gt;layer();
4194 
4195 #ifndef NDEBUG
4196     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;rootLayer-&gt;renderer());
4197 #endif
4198 
4199     // To work around http://webkit.org/b/135106, ensure that the paint root isn&#39;t an inline with culled line boxes.
4200     // FIXME: This can cause additional content to be included in the snapshot, so remove this once that bug is fixed.
4201     while (is&lt;RenderInline&gt;(renderer) &amp;&amp; !downcast&lt;RenderInline&gt;(*renderer).firstLineBox())
4202         renderer = renderer-&gt;parent();
4203 
4204     rootLayer-&gt;paint(context, dirtyRect, LayoutSize(), m_paintBehavior, renderer, { }, securityOriginPaintPolicy == SecurityOriginPaintPolicy::AnyOrigin ? RenderLayer::SecurityOriginPaintPolicy::AnyOrigin : RenderLayer::SecurityOriginPaintPolicy::AccessibleOriginOnly);
</pre>
<hr />
<pre>
4310                 return nullptr;
4311         }
4312         return descendantsDeque.first().ptr();
4313     };
4314 
4315     for (unsigned i = 0; i &lt; maxUpdatePasses; ++i) {
4316         bool didWork = false;
4317         DescendantsDeque deque;
4318         while (auto view = nextRenderedDescendant(deque)) {
4319             if (view-&gt;frame().document()-&gt;updateStyleIfNeeded())
4320                 didWork = true;
4321             if (view-&gt;needsLayout()) {
4322                 view-&gt;layoutContext().layout();
4323                 didWork = true;
4324             }
4325         }
4326         if (!didWork)
4327             break;
4328     }
4329 
<span class="line-modified">4330 #if ASSERT_ENABLED</span>
4331     auto needsStyleRecalc = [&amp;] {
4332         DescendantsDeque deque;
4333         while (auto view = nextRenderedDescendant(deque)) {
4334             auto* document = view-&gt;frame().document();
4335             if (document &amp;&amp; document-&gt;childNeedsStyleRecalc())
4336                 return true;
4337         }
4338         return false;
4339     };
4340 
4341     auto needsLayout = [&amp;] {
4342         DescendantsDeque deque;
4343         while (auto view = nextRenderedDescendant(deque)) {
4344             if (view-&gt;needsLayout())
4345                 return true;
4346         }
4347         return false;
4348     };
<span class="line-modified">4349 #endif // ASSERT_ENABLED</span>
4350 
4351     ASSERT(!needsStyleRecalc());
4352     ASSERT(!needsLayout());
4353 }
4354 
4355 void FrameView::incrementVisuallyNonEmptyCharacterCount(const String&amp; inlineText)
4356 {
4357     if (m_visuallyNonEmptyCharacterCount &gt; visualCharacterThreshold &amp;&amp; m_hasReachedSignificantRenderedTextThreshold)
4358         return;
4359 
4360     auto nonWhitespaceLength = [](auto&amp; inlineText) {
4361         auto length = inlineText.length();
4362         for (unsigned i = 0; i &lt; inlineText.length(); ++i) {
4363             if (isNotHTMLSpace(inlineText[i]))
4364                 continue;
4365             --length;
4366         }
4367         return length;
4368     };
4369     m_visuallyNonEmptyCharacterCount += nonWhitespaceLength(inlineText);
</pre>
<hr />
<pre>
5082     sendResizeEventIfNeeded();
5083 }
5084 
5085 void FrameView::setScrollVelocity(const VelocityData&amp; velocityData)
5086 {
5087     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5088         tiledBacking-&gt;setVelocity(velocityData);
5089 }
5090 #endif // PLATFORM(IOS_FAMILY)
5091 
5092 void FrameView::setScrollingPerformanceLoggingEnabled(bool flag)
5093 {
5094     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
5095         tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(flag);
5096 }
5097 
5098 void FrameView::didAddScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5099 {
5100     ScrollableArea::didAddScrollbar(scrollbar, orientation);
5101     Page* page = frame().page();
<span class="line-modified">5102     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents())</span>
<span class="line-modified">5103         scrollAnimator().setWheelEventTestMonitor(page-&gt;wheelEventTestMonitor());</span>
5104     if (AXObjectCache* cache = axObjectCache())
5105         cache-&gt;handleScrollbarUpdate(this);
5106 }
5107 
5108 void FrameView::willRemoveScrollbar(Scrollbar* scrollbar, ScrollbarOrientation orientation)
5109 {
5110     ScrollableArea::willRemoveScrollbar(scrollbar, orientation);
5111     if (AXObjectCache* cache = axObjectCache()) {
5112         cache-&gt;remove(scrollbar);
5113         cache-&gt;handleScrollbarUpdate(this);
5114     }
5115 }
5116 
5117 void FrameView::addPaintPendingMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
5118 {
5119     m_milestonesPendingPaint.add(milestones);
5120 }
5121 
5122 void FrameView::fireLayoutRelatedMilestonesIfNeeded()
5123 {
</pre>
<hr />
<pre>
5134             milestonesAchieved.add(DidFirstLayout);
5135         if (frame().isMainFrame())
5136             page-&gt;startCountingRelevantRepaintedObjects();
5137     }
5138 
5139     if (!m_isVisuallyNonEmpty &amp;&amp; qualifiesAsVisuallyNonEmpty()) {
5140         m_isVisuallyNonEmpty = true;
5141         addPaintPendingMilestones(DidFirstMeaningfulPaint);
5142         if (requestedMilestones &amp; DidFirstVisuallyNonEmptyLayout)
5143             milestonesAchieved.add(DidFirstVisuallyNonEmptyLayout);
5144     }
5145 
5146     if (!m_renderedSignificantAmountOfText &amp;&amp; qualifiesAsSignificantRenderedText()) {
5147         m_renderedSignificantAmountOfText = true;
5148         if (requestedMilestones &amp; DidRenderSignificantAmountOfText)
5149             milestonesAchieved.add(DidRenderSignificantAmountOfText);
5150     }
5151 
5152     if (milestonesAchieved &amp;&amp; frame().isMainFrame()) {
5153         if (milestonesAchieved.contains(DidFirstVisuallyNonEmptyLayout))
<span class="line-modified">5154             FRAMEVIEW_RELEASE_LOG_IF_ALLOWED(Layout, &quot;fireLayoutRelatedMilestonesIfNeeded: Firing first visually non-empty layout milestone on the main frame&quot;);</span>
5155         frame().loader().didReachLayoutMilestone(milestonesAchieved);
5156     }
5157 }
5158 
5159 void FrameView::firePaintRelatedMilestonesIfNeeded()
5160 {
5161     Page* page = frame().page();
5162     if (!page)
5163         return;
5164 
5165     OptionSet&lt;LayoutMilestone&gt; milestonesAchieved;
5166 
5167     // Make sure the pending paint milestones have actually been requested before we send them.
5168     if (m_milestonesPendingPaint &amp; DidFirstFlushForHeaderLayer) {
5169         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstFlushForHeaderLayer)
5170             milestonesAchieved.add(DidFirstFlushForHeaderLayer);
5171     }
5172 
5173     if (m_milestonesPendingPaint &amp; DidFirstPaintAfterSuppressedIncrementalRendering) {
5174         if (page-&gt;requestedLayoutMilestones() &amp; DidFirstPaintAfterSuppressedIncrementalRendering)
</pre>
</td>
</tr>
</table>
<center><a href="FrameTree.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameView.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
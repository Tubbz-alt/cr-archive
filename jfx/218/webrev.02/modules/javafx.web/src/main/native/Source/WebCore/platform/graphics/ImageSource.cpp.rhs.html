<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2017 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ImageSource.h&quot;
 28 
 29 #include &quot;BitmapImage.h&quot;
 30 #include &quot;ImageDecoder.h&quot;
 31 #include &quot;ImageObserver.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &lt;wtf/CheckedArithmetic.h&gt;
<a name="1" id="anc1"></a>

 34 #include &lt;wtf/SystemTracing.h&gt;
 35 #include &lt;wtf/URL.h&gt;
 36 
 37 #if USE(DIRECT2D)
 38 #include &quot;GraphicsContext.h&quot;
 39 #include &quot;PlatformContextDirect2D.h&quot;
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 ImageSource::ImageSource(BitmapImage* image, AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
 45     : m_image(image)
 46     , m_alphaOption(alphaOption)
 47     , m_gammaAndColorProfileOption(gammaAndColorProfileOption)
<a name="2" id="anc2"></a><span class="line-added"> 48     , m_runLoop(RunLoop::current())</span>
 49 {
<a name="3" id="anc3"></a>
 50 }
 51 
 52 ImageSource::ImageSource(NativeImagePtr&amp;&amp; nativeImage)
<a name="4" id="anc4"></a><span class="line-added"> 53     : m_runLoop(RunLoop::current())</span>
 54 {
<a name="5" id="anc5"></a>

 55     m_frameCount = 1;
 56     m_encodedDataStatus = EncodedDataStatus::Complete;
 57     growFrames();
 58 
 59     setNativeImage(WTFMove(nativeImage));
 60 
 61     m_decodedSize = m_frames[0].frameBytes();
 62 
<a name="6" id="anc6"></a>

 63     m_size = m_frames[0].size();
<a name="7" id="anc7"></a><span class="line-modified"> 64     m_orientation = ImageOrientation(ImageOrientation::None);</span>
 65 }
 66 
 67 ImageSource::~ImageSource()
 68 {
 69     ASSERT(!hasAsyncDecodingQueue());
<a name="8" id="anc8"></a><span class="line-modified"> 70     ASSERT(&amp;m_runLoop == &amp;RunLoop::current());</span>
 71 }
 72 
 73 bool ImageSource::ensureDecoderAvailable(SharedBuffer* data)
 74 {
 75     if (!data || isDecoderAvailable())
 76         return true;
 77 
 78     m_decoder = ImageDecoder::create(*data, mimeType(), m_alphaOption, m_gammaAndColorProfileOption);
 79     if (!isDecoderAvailable())
 80         return false;
 81 
 82     m_decoder-&gt;setEncodedDataStatusChangeCallback([weakThis = makeWeakPtr(this)] (auto status) {
 83         if (weakThis)
 84             weakThis-&gt;encodedDataStatusChanged(status);
 85     });
 86 
 87     if (auto expectedContentSize = expectedContentLength())
 88         m_decoder-&gt;setExpectedContentSize(expectedContentSize);
 89 
 90     // Changing the decoder has to stop the decoding thread. The current frame will
 91     // continue decoding safely because the decoding thread has its own
 92     // reference of the old decoder.
 93     stopAsyncDecodingQueue();
 94     return true;
 95 }
 96 
 97 void ImageSource::setData(SharedBuffer* data, bool allDataReceived)
 98 {
 99     if (!data || !ensureDecoderAvailable(data))
100         return;
101 
102     m_decoder-&gt;setData(*data, allDataReceived);
103 }
104 
105 void ImageSource::resetData(SharedBuffer* data)
106 {
107     m_decoder = nullptr;
108     setData(data, isAllDataReceived());
109 }
110 
111 EncodedDataStatus ImageSource::dataChanged(SharedBuffer* data, bool allDataReceived)
112 {
113     setData(data, allDataReceived);
114     clearMetadata();
115     EncodedDataStatus status = encodedDataStatus();
116     if (status &gt;= EncodedDataStatus::SizeAvailable)
117         growFrames();
118     return status;
119 }
120 
121 bool ImageSource::isAllDataReceived()
122 {
123     return isDecoderAvailable() ? m_decoder-&gt;isAllDataReceived() : frameCount();
124 }
125 
126 void ImageSource::destroyDecodedData(size_t frameCount, size_t excludeFrame)
127 {
128     unsigned decodedSize = 0;
129 
130     ASSERT(frameCount &lt;= m_frames.size());
131 
132     for (size_t index = 0; index &lt; frameCount; ++index) {
133         if (index == excludeFrame)
134             continue;
135         decodedSize += m_frames[index].clearImage();
136     }
137 
138     decodedSizeReset(decodedSize);
139 }
140 
141 void ImageSource::destroyIncompleteDecodedData()
142 {
143     unsigned decodedSize = 0;
144 
145     for (auto&amp; frame : m_frames) {
146         if (!frame.hasMetadata() || frame.isComplete())
147             continue;
148 
149         decodedSize += frame.clear();
150     }
151 
152     decodedSizeDecreased(decodedSize);
153 }
154 
155 void ImageSource::clearFrameBufferCache(size_t beforeFrame)
156 {
157     if (!isDecoderAvailable())
158         return;
159     m_decoder-&gt;clearFrameBufferCache(beforeFrame);
160 }
161 
162 void ImageSource::encodedDataStatusChanged(EncodedDataStatus status)
163 {
164     if (status == m_encodedDataStatus)
165         return;
166 
167     m_encodedDataStatus = status;
168 
169     if (status &gt;= EncodedDataStatus::SizeAvailable)
170         growFrames();
171 
172     if (m_image &amp;&amp; m_image-&gt;imageObserver())
173         m_image-&gt;imageObserver()-&gt;encodedDataStatusChanged(*m_image, status);
174 }
175 
176 void ImageSource::decodedSizeChanged(long long decodedSize)
177 {
178     if (!decodedSize || !m_image || !m_image-&gt;imageObserver())
179         return;
180 
181     m_image-&gt;imageObserver()-&gt;decodedSizeChanged(*m_image, decodedSize);
182 }
183 
184 void ImageSource::decodedSizeIncreased(unsigned decodedSize)
185 {
186     if (!decodedSize)
187         return;
188 
189     m_decodedSize += decodedSize;
190 
191     // The fully-decoded frame will subsume the partially decoded data used
192     // to determine image properties.
193     long long changeSize = static_cast&lt;long long&gt;(decodedSize) - m_decodedPropertiesSize;
194     m_decodedPropertiesSize = 0;
195     decodedSizeChanged(changeSize);
196 }
197 
198 void ImageSource::decodedSizeDecreased(unsigned decodedSize)
199 {
200     if (!decodedSize)
201         return;
202 
203     ASSERT(m_decodedSize &gt;= decodedSize);
204     m_decodedSize -= decodedSize;
205     decodedSizeChanged(-static_cast&lt;long long&gt;(decodedSize));
206 }
207 
208 void ImageSource::decodedSizeReset(unsigned decodedSize)
209 {
210     ASSERT(m_decodedSize &gt;= decodedSize);
211     m_decodedSize -= decodedSize;
212 
213     // Clearing the ImageSource destroys the extra decoded data used for
214     // determining image properties.
215     decodedSize += m_decodedPropertiesSize;
216     m_decodedPropertiesSize = 0;
217     decodedSizeChanged(-static_cast&lt;long long&gt;(decodedSize));
218 }
219 
220 void ImageSource::didDecodeProperties(unsigned decodedPropertiesSize)
221 {
222     if (m_decodedSize)
223         return;
224 
225     long long decodedSize = static_cast&lt;long long&gt;(decodedPropertiesSize) - m_decodedPropertiesSize;
226     m_decodedPropertiesSize = decodedPropertiesSize;
227     decodedSizeChanged(decodedSize);
228 }
229 
230 void ImageSource::growFrames()
231 {
232     ASSERT(isSizeAvailable());
233     auto newSize = frameCount();
234     if (newSize &gt; m_frames.size())
235         m_frames.grow(newSize);
236 }
237 
238 void ImageSource::setNativeImage(NativeImagePtr&amp;&amp; nativeImage)
239 {
240     ASSERT(m_frames.size() == 1);
241     ImageFrame&amp; frame = m_frames[0];
242 
243     ASSERT(!isDecoderAvailable());
244 
245     frame.m_nativeImage = WTFMove(nativeImage);
246 
247     frame.m_decodingStatus = DecodingStatus::Complete;
248     frame.m_size = nativeImageSize(frame.m_nativeImage);
249     frame.m_hasAlpha = nativeImageHasAlpha(frame.m_nativeImage);
250 }
251 
252 void ImageSource::cacheMetadataAtIndex(size_t index, SubsamplingLevel subsamplingLevel, DecodingStatus decodingStatus)
253 {
254     ASSERT(index &lt; m_frames.size());
255     ImageFrame&amp; frame = m_frames[index];
256 
257     ASSERT(isDecoderAvailable());
258     if (decodingStatus == DecodingStatus::Invalid)
259         frame.m_decodingStatus = m_decoder-&gt;frameIsCompleteAtIndex(index) ? DecodingStatus::Complete : DecodingStatus::Partial;
260     else
261         frame.m_decodingStatus = decodingStatus;
262 
263     if (frame.hasMetadata())
264         return;
265 
266     frame.m_subsamplingLevel = subsamplingLevel;
267 
268     if (frame.m_decodingOptions.hasSizeForDrawing()) {
269         ASSERT(frame.hasNativeImage());
270         frame.m_size = nativeImageSize(frame.nativeImage());
271     } else
272         frame.m_size = m_decoder-&gt;frameSizeAtIndex(index, subsamplingLevel);
273 
274     frame.m_orientation = m_decoder-&gt;frameOrientationAtIndex(index);
275     frame.m_hasAlpha = m_decoder-&gt;frameHasAlphaAtIndex(index);
276 
277     if (repetitionCount())
278         frame.m_duration = m_decoder-&gt;frameDurationAtIndex(index);
279 }
280 
281 void ImageSource::cacheNativeImageAtIndex(NativeImagePtr&amp;&amp; nativeImage, size_t index, SubsamplingLevel subsamplingLevel, const DecodingOptions&amp; decodingOptions, DecodingStatus decodingStatus)
282 {
283     ASSERT(index &lt; m_frames.size());
284     ImageFrame&amp; frame = m_frames[index];
285 
286     // Clear the current image frame and update the observer with this clearance.
287     decodedSizeDecreased(frame.clear());
288 
289     // Do not cache the NativeImage if adding its frameByes to the MemoryCache will cause numerical overflow.
290     size_t frameBytes = size().unclampedArea() * sizeof(uint32_t);
291     if (!WTF::isInBounds&lt;unsigned&gt;(frameBytes + decodedSize()))
292         return;
293 
294     // Move the new image to the cache.
295     frame.m_nativeImage = WTFMove(nativeImage);
296     frame.m_decodingOptions = decodingOptions;
297     cacheMetadataAtIndex(index, subsamplingLevel, decodingStatus);
298 
299     // Update the observer with the new image frame bytes.
300     decodedSizeIncreased(frame.frameBytes());
301 }
302 
303 void ImageSource::cacheNativeImageAtIndexAsync(NativeImagePtr&amp;&amp; nativeImage, size_t index, SubsamplingLevel subsamplingLevel, const DecodingOptions&amp; decodingOptions, DecodingStatus decodingStatus)
304 {
305     if (!isDecoderAvailable())
306         return;
307 
308     ASSERT(index &lt; m_frames.size());
309 
310     // Clean the old native image and set a new one
311     cacheNativeImageAtIndex(WTFMove(nativeImage), index, subsamplingLevel, decodingOptions, decodingStatus);
312     LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld has been cached]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), index);
313 
314     // Notify the image with the readiness of the new frame NativeImage.
315     if (m_image)
316         m_image-&gt;imageFrameAvailableAtIndex(index);
317 }
318 
319 WorkQueue&amp; ImageSource::decodingQueue()
320 {
321     if (!m_decodingQueue)
322         m_decodingQueue = WorkQueue::create(&quot;org.webkit.ImageDecoder&quot;, WorkQueue::Type::Serial, WorkQueue::QOS::Default);
323 
324     return *m_decodingQueue;
325 }
326 
327 ImageSource::FrameRequestQueue&amp; ImageSource::frameRequestQueue()
328 {
329     if (!m_frameRequestQueue)
330         m_frameRequestQueue = FrameRequestQueue::create();
331 
332     return *m_frameRequestQueue;
333 }
334 
335 bool ImageSource::canUseAsyncDecoding()
336 {
337     if (!isDecoderAvailable())
338         return false;
339     // FIXME: figure out the best heuristic for enabling async image decoding.
340     return size().area() * sizeof(uint32_t) &gt;= (frameCount() &gt; 1 ? 100 * KB : 500 * KB);
341 }
342 
343 void ImageSource::startAsyncDecodingQueue()
344 {
345     if (hasAsyncDecodingQueue() || !isDecoderAvailable())
346         return;
347 
<a name="9" id="anc9"></a><span class="line-added">348     // Async decoding is only enabled for HTMLImageElement and CSS background images.</span>
<span class="line-added">349     ASSERT(isMainThread());</span>
<span class="line-added">350 </span>
351     // We need to protect this, m_decodingQueue and m_decoder from being deleted while we are in the decoding loop.
<a name="10" id="anc10"></a><span class="line-modified">352     decodingQueue().dispatch([protectedThis = makeRef(*this), protectedDecodingQueue = makeRef(decodingQueue()), protectedFrameRequestQueue = makeRef(frameRequestQueue()), protectedDecoder = makeRef(*m_decoder), sourceURL = sourceURL().string().isolatedCopy()] () mutable {</span>
353         ImageFrameRequest frameRequest;
354         Seconds minDecodingDuration = protectedThis-&gt;frameDecodingDurationForTesting();
355 
356         while (protectedFrameRequestQueue-&gt;dequeue(frameRequest)) {
357             TraceScope tracingScope(AsyncImageDecodeStart, AsyncImageDecodeEnd);
358 
359             MonotonicTime startingTime;
360             if (minDecodingDuration &gt; 0_s)
361                 startingTime = MonotonicTime::now();
362 
363             // Get the frame NativeImage on the decoding thread.
364             NativeImagePtr nativeImage = protectedDecoder-&gt;createFrameImageAtIndex(frameRequest.index, frameRequest.subsamplingLevel, frameRequest.decodingOptions);
365             if (nativeImage)
366                 LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld has been decoded]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
367             else {
368                 LOG(Images, &quot;ImageSource::%s - %p - url: %s [decoding for frame %ld has failed]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
369                 continue;
370             }
371 
372             // Pretend as if the decoding takes minDecodingDuration.
373             if (minDecodingDuration &gt; 0_s)
374                 sleep(minDecodingDuration - (MonotonicTime::now() - startingTime));
375 
<a name="11" id="anc11"></a><span class="line-modified">376             // Update the cached frames on the creation thread to avoid updating the MemoryCache from a different thread.</span>
377             callOnMainThread([protectedThis = protectedThis.copyRef(), protectedQueue = protectedDecodingQueue.copyRef(), protectedDecoder = protectedDecoder.copyRef(), sourceURL = sourceURL.isolatedCopy(), nativeImage = WTFMove(nativeImage), frameRequest] () mutable {
378                 // The queue may have been closed if after we got the frame NativeImage, stopAsyncDecodingQueue() was called.
379                 if (protectedQueue.ptr() == protectedThis-&gt;m_decodingQueue &amp;&amp; protectedDecoder.ptr() == protectedThis-&gt;m_decoder) {
380                     ASSERT(protectedThis-&gt;m_frameCommitQueue.first() == frameRequest);
381                     protectedThis-&gt;m_frameCommitQueue.removeFirst();
382                     protectedThis-&gt;cacheNativeImageAtIndexAsync(WTFMove(nativeImage), frameRequest.index, frameRequest.subsamplingLevel, frameRequest.decodingOptions, frameRequest.decodingStatus);
383                 } else
384                     LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld will not cached]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
385             });
386         }
<a name="12" id="anc12"></a><span class="line-added">387 </span>
<span class="line-added">388         // Ensure destruction happens on creation thread.</span>
<span class="line-added">389         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedQueue = WTFMove(protectedDecodingQueue), protectedDecoder = WTFMove(protectedDecoder)] () mutable { });</span>
390     });
391 }
392 
393 void ImageSource::requestFrameAsyncDecodingAtIndex(size_t index, SubsamplingLevel subsamplingLevel, const Optional&lt;IntSize&gt;&amp; sizeForDrawing)
394 {
395     ASSERT(isDecoderAvailable());
396     if (!hasAsyncDecodingQueue())
397         startAsyncDecodingQueue();
398 
399     ASSERT(index &lt; m_frames.size());
400     DecodingStatus decodingStatus = m_decoder-&gt;frameIsCompleteAtIndex(index) ? DecodingStatus::Complete : DecodingStatus::Partial;
401 
402     LOG(Images, &quot;ImageSource::%s - %p - url: %s [enqueuing frame %ld for decoding]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), index);
403     m_frameRequestQueue-&gt;enqueue({ index, subsamplingLevel, sizeForDrawing, decodingStatus });
404     m_frameCommitQueue.append({ index, subsamplingLevel, sizeForDrawing, decodingStatus });
405 }
406 
407 bool ImageSource::isAsyncDecodingQueueIdle() const
408 {
409     return m_frameCommitQueue.isEmpty();
410 }
411 
412 void ImageSource::stopAsyncDecodingQueue()
413 {
414     if (!hasAsyncDecodingQueue())
415         return;
416 
417     std::for_each(m_frameCommitQueue.begin(), m_frameCommitQueue.end(), [this](const ImageFrameRequest&amp; frameRequest) {
418         ImageFrame&amp; frame = m_frames[frameRequest.index];
419         if (!frame.isInvalid()) {
420             LOG(Images, &quot;ImageSource::%s - %p - url: %s [decoding has been cancelled for frame %ld]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), frameRequest.index);
421             frame.clear();
422         }
423     });
424 
425     // Close m_frameRequestQueue then set it to nullptr. A new decoding thread might start and a
426     // new m_frameRequestQueue will be created. So the terminating thread will not have access to it.
427     m_frameRequestQueue-&gt;close();
428     m_frameRequestQueue = nullptr;
429     m_frameCommitQueue.clear();
430     m_decodingQueue = nullptr;
431     LOG(Images, &quot;ImageSource::%s - %p - url: %s [decoding has been stopped]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
432 }
433 
434 const ImageFrame&amp; ImageSource::frameAtIndexCacheIfNeeded(size_t index, ImageFrame::Caching caching, const Optional&lt;SubsamplingLevel&gt;&amp; subsamplingLevel)
435 {
436     ASSERT(index &lt; m_frames.size());
437     ImageFrame&amp; frame = m_frames[index];
438     if (!isDecoderAvailable() || frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(index, DecodingOptions(DecodingMode::Asynchronous)))
439         return frame;
440 
441     SubsamplingLevel subsamplingLevelValue = subsamplingLevel ? subsamplingLevel.value() : frame.subsamplingLevel();
442 
443     switch (caching) {
444     case ImageFrame::Caching::Metadata:
445         // Retrieve the metadata from ImageDecoder if the ImageFrame isn&#39;t complete.
446         if (frame.isComplete())
447             break;
448         cacheMetadataAtIndex(index, subsamplingLevelValue);
449         break;
450 
451     case ImageFrame::Caching::MetadataAndImage:
452         // Cache the image and retrieve the metadata from ImageDecoder only if there was not valid image stored.
453         if (frame.hasFullSizeNativeImage(subsamplingLevel))
454             break;
455         // We have to perform synchronous image decoding in this code.
456         NativeImagePtr nativeImage = m_decoder-&gt;createFrameImageAtIndex(index, subsamplingLevelValue);
457         // Clean the old native image and set a new one.
458         cacheNativeImageAtIndex(WTFMove(nativeImage), index, subsamplingLevelValue, DecodingOptions(DecodingMode::Synchronous));
459         break;
460     }
461 
462     return frame;
463 }
464 
465 void ImageSource::clearMetadata()
466 {
467     m_frameCount = WTF::nullopt;
468     m_repetitionCount = WTF::nullopt;
469     m_singlePixelSolidColor = WTF::nullopt;
470     m_encodedDataStatus = WTF::nullopt;
471     m_uti = WTF::nullopt;
472 }
473 
474 URL ImageSource::sourceURL() const
475 {
476     return m_image ? m_image-&gt;sourceURL() : URL();
477 }
478 
479 String ImageSource::mimeType() const
480 {
481     return m_image ? m_image-&gt;mimeType() : emptyString();
482 }
483 
484 long long ImageSource::expectedContentLength() const
485 {
486     return m_image ? m_image-&gt;expectedContentLength() : 0;
487 }
488 
489 template&lt;typename T, T (ImageDecoder::*functor)() const&gt;
490 T ImageSource::metadata(const T&amp; defaultValue, Optional&lt;T&gt;* cachedValue)
491 {
492     if (cachedValue &amp;&amp; *cachedValue)
493         return cachedValue-&gt;value();
494 
495     if (!isDecoderAvailable() || !m_decoder-&gt;isSizeAvailable())
496         return defaultValue;
497 
498     if (!cachedValue)
499         return (*m_decoder.*functor)();
500 
501     *cachedValue = (*m_decoder.*functor)();
502     didDecodeProperties(m_decoder-&gt;bytesDecodedToDetermineProperties());
503     return cachedValue-&gt;value();
504 }
505 
506 template&lt;typename T, typename... Args&gt;
507 T ImageSource::frameMetadataAtIndex(size_t index, T (ImageFrame::*functor)(Args...) const, Args&amp;&amp;... args)
508 {
509     const ImageFrame&amp; frame = index &lt; m_frames.size() ? m_frames[index] : ImageFrame::defaultFrame();
510     return (frame.*functor)(std::forward&lt;Args&gt;(args)...);
511 }
512 
513 template&lt;typename T, typename... Args&gt;
514 T ImageSource::frameMetadataAtIndexCacheIfNeeded(size_t index, T (ImageFrame::*functor)() const, Optional&lt;T&gt;* cachedValue, Args&amp;&amp;... args)
515 {
516     if (cachedValue &amp;&amp; *cachedValue)
517         return cachedValue-&gt;value();
518 
519     const ImageFrame&amp; frame = index &lt; m_frames.size() ? frameAtIndexCacheIfNeeded(index, std::forward&lt;Args&gt;(args)...) : ImageFrame::defaultFrame();
520 
521     // Don&#39;t cache any unavailable frame metadata.
522     if (!frame.hasMetadata() || !cachedValue)
523         return (frame.*functor)();
524 
525     *cachedValue = (frame.*functor)();
526     return cachedValue-&gt;value();
527 }
528 
529 EncodedDataStatus ImageSource::encodedDataStatus()
530 {
531     return metadata&lt;EncodedDataStatus, (&amp;ImageDecoder::encodedDataStatus)&gt;(EncodedDataStatus::Unknown, &amp;m_encodedDataStatus);
532 }
533 
534 size_t ImageSource::frameCount()
535 {
536     return metadata&lt;size_t, (&amp;ImageDecoder::frameCount)&gt;(m_frames.size(), &amp;m_frameCount);
537 }
538 
539 RepetitionCount ImageSource::repetitionCount()
540 {
541     return metadata&lt;RepetitionCount, (&amp;ImageDecoder::repetitionCount)&gt;(RepetitionCountNone, &amp;m_repetitionCount);
542 }
543 
544 String ImageSource::uti()
545 {
546 #if USE(CG)
547     return metadata&lt;String, (&amp;ImageDecoder::uti)&gt;(String(), &amp;m_uti);
548 #else
549     return String();
550 #endif
551 }
552 
553 String ImageSource::filenameExtension()
554 {
555     return metadata&lt;String, (&amp;ImageDecoder::filenameExtension)&gt;(String(), &amp;m_filenameExtension);
556 }
557 
558 Optional&lt;IntPoint&gt; ImageSource::hotSpot()
559 {
560     return metadata&lt;Optional&lt;IntPoint&gt;, (&amp;ImageDecoder::hotSpot)&gt;(WTF::nullopt, &amp;m_hotSpot);
561 }
562 
<a name="13" id="anc13"></a><span class="line-modified">563 ImageOrientation ImageSource::orientation()</span>
564 {
<a name="14" id="anc14"></a><span class="line-added">565     return frameMetadataAtIndexCacheIfNeeded&lt;ImageOrientation&gt;(0, (&amp;ImageFrame::orientation), &amp;m_orientation, ImageFrame::Caching::Metadata);</span>
<span class="line-added">566 }</span>
<span class="line-added">567 </span>
<span class="line-added">568 IntSize ImageSource::size(ImageOrientation orientation)</span>
<span class="line-added">569 {</span>
<span class="line-added">570     IntSize size;</span>
571 #if !USE(CG)
572     // It&#39;s possible that we have decoded the metadata, but not frame contents yet. In that case ImageDecoder claims to
573     // have the size available, but the frame cache is empty. Return the decoder size without caching in such case.
574     if (m_frames.isEmpty() &amp;&amp; isDecoderAvailable())
<a name="15" id="anc15"></a><span class="line-modified">575         size = m_decoder-&gt;size();</span>
<span class="line-added">576     else</span>
577 #endif
<a name="16" id="anc16"></a><span class="line-modified">578         size = frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(0, (&amp;ImageFrame::size), &amp;m_size, ImageFrame::Caching::Metadata, SubsamplingLevel::Default);</span>

579 
<a name="17" id="anc17"></a><span class="line-modified">580     if (orientation == ImageOrientation::FromImage)</span>
<span class="line-modified">581         orientation = this-&gt;orientation();</span>
<span class="line-modified">582 </span>
<span class="line-added">583     return orientation.usesWidthAsHeight() ? size.transposedSize() : size;</span>
584 }
585 
586 Color ImageSource::singlePixelSolidColor()
587 {
588     if (!m_singlePixelSolidColor &amp;&amp; (size() != IntSize(1, 1) || frameCount() != 1))
589         m_singlePixelSolidColor = Color();
590 
591     if (m_singlePixelSolidColor)
592         return m_singlePixelSolidColor.value();
593 
594     return frameMetadataAtIndexCacheIfNeeded&lt;Color&gt;(0, (&amp;ImageFrame::singlePixelSolidColor), &amp;m_singlePixelSolidColor, ImageFrame::Caching::MetadataAndImage);
595 }
596 
597 SubsamplingLevel ImageSource::maximumSubsamplingLevel()
598 {
599     if (m_maximumSubsamplingLevel)
600         return m_maximumSubsamplingLevel.value();
601 
602     if (!isDecoderAvailable() || !m_decoder-&gt;frameAllowSubsamplingAtIndex(0))
603         return SubsamplingLevel::Default;
604 
605     // FIXME: this value was chosen to be appropriate for iOS since the image
606     // subsampling is only enabled by default on iOS. Choose a different value
607     // if image subsampling is enabled on other platform.
608     const int maximumImageAreaBeforeSubsampling = 5 * 1024 * 1024;
609     SubsamplingLevel level = SubsamplingLevel::First;
610 
611     for (; level &lt; SubsamplingLevel::Last; ++level) {
612         if (frameSizeAtIndex(0, level).area().unsafeGet() &lt; maximumImageAreaBeforeSubsampling)
613             break;
614     }
615 
616     m_maximumSubsamplingLevel = level;
617     return m_maximumSubsamplingLevel.value();
618 }
619 
620 bool ImageSource::frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(size_t index, const DecodingOptions&amp; decodingOptions)
621 {
622     auto it = std::find_if(m_frameCommitQueue.begin(), m_frameCommitQueue.end(), [index, &amp;decodingOptions](const ImageFrameRequest&amp; frameRequest) {
623         return frameRequest.index == index &amp;&amp; frameRequest.decodingOptions.isAsynchronousCompatibleWith(decodingOptions);
624     });
625     return it != m_frameCommitQueue.end();
626 }
627 
628 DecodingStatus ImageSource::frameDecodingStatusAtIndex(size_t index)
629 {
630     return frameMetadataAtIndexCacheIfNeeded&lt;DecodingStatus&gt;(index, (&amp;ImageFrame::decodingStatus), nullptr, ImageFrame::Caching::Metadata);
631 }
632 
633 bool ImageSource::frameHasAlphaAtIndex(size_t index)
634 {
635     return frameMetadataAtIndex&lt;bool&gt;(index, (&amp;ImageFrame::hasAlpha));
636 }
637 
638 bool ImageSource::frameHasFullSizeNativeImageAtIndex(size_t index, const Optional&lt;SubsamplingLevel&gt;&amp; subsamplingLevel)
639 {
640     return frameMetadataAtIndex&lt;bool&gt;(index, (&amp;ImageFrame::hasFullSizeNativeImage), subsamplingLevel);
641 }
642 
643 bool ImageSource::frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(size_t index, const Optional&lt;SubsamplingLevel&gt;&amp; subsamplingLevel, const DecodingOptions&amp; decodingOptions)
644 {
645     return frameMetadataAtIndex&lt;bool&gt;(index, (&amp;ImageFrame::hasDecodedNativeImageCompatibleWithOptions), subsamplingLevel, decodingOptions);
646 }
647 
648 SubsamplingLevel ImageSource::frameSubsamplingLevelAtIndex(size_t index)
649 {
650     return frameMetadataAtIndex&lt;SubsamplingLevel&gt;(index, (&amp;ImageFrame::subsamplingLevel));
651 }
652 
653 IntSize ImageSource::frameSizeAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
654 {
655     return frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(index, (&amp;ImageFrame::size), nullptr, ImageFrame::Caching::Metadata, subsamplingLevel);
656 }
657 
658 unsigned ImageSource::frameBytesAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
659 {
660     return frameMetadataAtIndexCacheIfNeeded&lt;unsigned&gt;(index, (&amp;ImageFrame::frameBytes), nullptr, ImageFrame::Caching::Metadata, subsamplingLevel);
661 }
662 
663 Seconds ImageSource::frameDurationAtIndex(size_t index)
664 {
665     return frameMetadataAtIndexCacheIfNeeded&lt;Seconds&gt;(index, (&amp;ImageFrame::duration), nullptr, ImageFrame::Caching::Metadata);
666 }
667 
668 ImageOrientation ImageSource::frameOrientationAtIndex(size_t index)
669 {
670     return frameMetadataAtIndexCacheIfNeeded&lt;ImageOrientation&gt;(index, (&amp;ImageFrame::orientation), nullptr, ImageFrame::Caching::Metadata);
671 }
672 
673 #if USE(DIRECT2D)
674 void ImageSource::setTargetContext(const GraphicsContext* targetContext)
675 {
676     if (isDecoderAvailable() &amp;&amp; targetContext)
677         m_decoder-&gt;setTargetContext(targetContext-&gt;platformContext()-&gt;renderTarget());
678 }
679 #endif
680 
681 NativeImagePtr ImageSource::createFrameImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel)
682 {
683     return isDecoderAvailable() ? m_decoder-&gt;createFrameImageAtIndex(index, subsamplingLevel) : nullptr;
684 }
685 
686 NativeImagePtr ImageSource::frameImageAtIndex(size_t index)
687 {
688     return frameMetadataAtIndex&lt;NativeImagePtr&gt;(index, (&amp;ImageFrame::nativeImage));
689 }
690 
691 NativeImagePtr ImageSource::frameImageAtIndexCacheIfNeeded(size_t index, SubsamplingLevel subsamplingLevel)
692 {
693     return frameMetadataAtIndexCacheIfNeeded&lt;NativeImagePtr&gt;(index, (&amp;ImageFrame::nativeImage), nullptr, ImageFrame::Caching::MetadataAndImage, subsamplingLevel);
694 }
695 
696 void ImageSource::dump(TextStream&amp; ts)
697 {
698     ts.dumpProperty(&quot;type&quot;, filenameExtension());
699     ts.dumpProperty(&quot;frame-count&quot;, frameCount());
700     ts.dumpProperty(&quot;repetitions&quot;, repetitionCount());
701     ts.dumpProperty(&quot;solid-color&quot;, singlePixelSolidColor());
702 
703     ImageOrientation orientation = frameOrientationAtIndex(0);
704     if (orientation != ImageOrientation::None)
705         ts.dumpProperty(&quot;orientation&quot;, orientation);
706 }
707 
708 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
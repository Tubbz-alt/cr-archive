<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/StackStats.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StackShot.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackTrace.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/StackStats.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 56 int StackStats::s_maxLayoutReentryDepth = 0;
 57 
 58 
 59 StackStats::PerThreadStats::PerThreadStats()
 60 {
 61     const StackBounds&amp; stack = Thread::current().stack();
 62     m_reentryDepth = 0;
 63     m_stackStart = (char*)stack.origin();
 64     m_currentCheckPoint = 0;
 65 
 66     dataLogF(&quot; === THREAD new stackStart %p ========\n&quot;, m_stackStart);
 67 }
 68 
 69 StackStats::CheckPoint::CheckPoint()
 70 {
 71     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
 72     Thread&amp; thread = Thread::current();
 73     StackStats::PerThreadStats&amp; t = thread.stackStats();
 74     const StackBounds&amp; stack = thread.stack();
 75 
<span class="line-removed"> 76     bool isGrowingDownward = stack.isGrowingDownward();</span>
 77     bool needToLog = false;
 78     char* current = reinterpret_cast&lt;char*&gt;(this);
 79     char* last = reinterpret_cast&lt;char*&gt;(t.m_currentCheckPoint);
 80 
 81     // If there was no previous checkpoint, measure from the start of the stack:
 82     if (!last)
 83         last = t.m_stackStart;
 84 
 85     // Update the reentry depth stats:
 86     t.m_reentryDepth++;
 87     if (t.m_reentryDepth &gt; StackStats::s_maxReentryDepth) {
 88         StackStats::s_maxReentryDepth = t.m_reentryDepth;
 89         needToLog = true;
 90     }
 91 
 92     // Update the stack height stats:
 93     int height = t.m_stackStart - current;
<span class="line-removed"> 94     if (!isGrowingDownward)</span>
<span class="line-removed"> 95         height = -height;</span>
 96     if (height &gt; StackStats::s_maxStackHeight) {
 97         StackStats::s_maxStackHeight = height;
 98         needToLog = true;
 99     }
100 
101     // Update the checkpoint diff stats:
102     int diff = last - current;
<span class="line-removed">103     if (!isGrowingDownward)</span>
<span class="line-removed">104         diff = -diff;</span>
105     if (diff &gt; StackStats::s_maxCheckPointDiff) {
106         StackStats::s_maxCheckPointDiff = diff;
107         needToLog = true;
108     }
109 
110     // Push this checkpoint:
111     m_prev = t.m_currentCheckPoint;
112     t.m_currentCheckPoint = this;
113 
114 #if ENABLE(VERBOSE_STACK_STATS)
115     needToLog = true; // always log.
116 #endif
117 
118     // Log this checkpoint if needed:
119     if (needToLog)
120         dataLogF(&quot; CHECKPOINT %p diff %d/%.1fk/max %.1fk | reentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n&quot;,
121             this, diff, diff / 1024.0, StackStats::s_maxCheckPointDiff / 1024.0,
122             t.m_reentryDepth, StackStats::s_maxReentryDepth,
123             height / 1024.0, StackStats::s_maxStackHeight / 1024.0,
124             stack.origin(), stack.size() / 1024.0);
125 }
126 
127 StackStats::CheckPoint::~CheckPoint()
128 {
129     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
130     Thread&amp; thread = Thread::current();
131     StackStats::PerThreadStats&amp; t = thread.stackStats();
132 
133     // Pop to previous checkpoint:
134     t.m_currentCheckPoint = m_prev;
135     --t.m_reentryDepth;
136 
137     // Log this checkpoint if needed:
138 #if ENABLE(VERBOSE_STACK_STATS)
139     if (!m_prev) {
140         const StackBounds&amp; stack = thread.stack();
<span class="line-removed">141         bool isGrowingDownward = stack.isGrowingDownward();</span>
142 
143         char* current = reinterpret_cast&lt;char*&gt;(this);
144         int height = t.m_stackStart - current;
145 
<span class="line-removed">146         if (!isGrowingDownward)</span>
<span class="line-removed">147             height = -height;</span>
<span class="line-removed">148 </span>
149         dataLogF(&quot; POP to %p diff max %.1fk | reentry %d/%d max | height %.1fk/max %.1fk | stack %p size %.1fk)\n&quot;,
150             this, StackStats::s_maxCheckPointDiff / 1024.0,
151             t.m_reentryDepth, StackStats::s_maxReentryDepth,
152             height / 1024.0, StackStats::s_maxStackHeight / 1024.0,
153             stack.origin(), stack.size() / 1024.0);
154     }
155 #endif
156 }
157 
158 void StackStats::probe()
159 {
160     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
161     Thread&amp; thread = Thread::current();
162     StackStats::PerThreadStats&amp; t = thread.stackStats();
163     const StackBounds&amp; stack = thread.stack();
164 
<span class="line-removed">165     bool isGrowingDownward = stack.isGrowingDownward();</span>
<span class="line-removed">166 </span>
167     bool needToLog = false;
168 
169     int dummy;
170     char* current = reinterpret_cast&lt;char*&gt;(&amp;dummy);
171     char* last = reinterpret_cast&lt;char*&gt;(t.m_currentCheckPoint);
172 
173     // If there was no previous checkpoint, measure from the start of the stack:
174     if (!last)
175         last = t.m_stackStart;
176 
177     // We did not reach another checkpoint yet. Hence, we do not touch the
178     // reentry stats.
179 
180     // Update the stack height stats:
181     int height = t.m_stackStart - current;
<span class="line-removed">182     if (!isGrowingDownward)</span>
<span class="line-removed">183         height = -height;</span>
184     if (height &gt; StackStats::s_maxStackHeight) {
185         StackStats::s_maxStackHeight = height;
186         needToLog = true;
187     }
188 
189     // Update the checkpoint diff stats:
190     int diff = last - current;
<span class="line-removed">191     if (!isGrowingDownward)</span>
<span class="line-removed">192         diff = -diff;</span>
193     if (diff &gt; StackStats::s_maxCheckPointDiff) {
194         StackStats::s_maxCheckPointDiff = diff;
195         needToLog = true;
196     }
197 
198 #if ENABLE(VERBOSE_STACK_STATS)
199     needToLog = true; // always log.
200 #endif
201 
202     if (needToLog)
203         dataLogF(&quot; PROBE %p diff %d/%.1fk/max %.1fk | reentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n&quot;,
204             current, diff, diff / 1024.0, StackStats::s_maxCheckPointDiff / 1024.0,
205             t.m_reentryDepth, StackStats::s_maxReentryDepth,
206             height / 1024.0, StackStats::s_maxStackHeight / 1024.0,
207             stack.origin(), stack.size() / 1024.0);
208 }
209 
210 StackStats::LayoutCheckPoint::LayoutCheckPoint()
211 {
212     // While a layout checkpoint is not necessarily a checkpoint where we
213     // we will do a recursion check, it is a convenient spot for doing a
214     // probe to measure the height of stack usage.
215     //
216     // We&#39;ll do this probe before we commence with the layout checkpoint.
217     // This is because the probe also locks the sharedLock. By calling the
218     // probe first, we can avoid re-entering the lock.
219     StackStats::probe();
220 
221     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
222     Thread&amp; thread = Thread::current();
223     StackStats::PerThreadStats&amp; t = thread.stackStats();
224     const StackBounds&amp; stack = thread.stack();
225 
<span class="line-removed">226     bool isGrowingDownward = stack.isGrowingDownward();</span>
<span class="line-removed">227 </span>
228     // Push this checkpoint:
229     m_prev = StackStats::s_topLayoutCheckPoint;
230     if (m_prev)
231         m_depth = m_prev-&gt;m_depth + 1;
232     else {
233         StackStats::s_firstLayoutCheckPoint = this;
234         m_depth = 0;
235     }
236     StackStats::s_topLayoutCheckPoint = this;
237 
238     //
239     char* current = reinterpret_cast&lt;char*&gt;(this);
240     char* last = reinterpret_cast&lt;char*&gt;(m_prev);
241     char* root = reinterpret_cast&lt;char*&gt;(StackStats::s_firstLayoutCheckPoint);
242     bool needToLog = false;
243 
244     int diff = last - current;
245     if (!last)
246         diff = 0;
247     int totalDiff = root - current;
248     if (!root)
249         totalDiff = 0;
250 
251     // Update the stack height stats:
252     int height = t.m_stackStart - current;
<span class="line-removed">253     if (!isGrowingDownward)</span>
<span class="line-removed">254         height = -height;</span>
255     if (height &gt; StackStats::s_maxStackHeight) {
256         StackStats::s_maxStackHeight = height;
257         needToLog = true;
258     }
259 
260     // Update the layout checkpoint diff stats:
<span class="line-removed">261     if (!isGrowingDownward)</span>
<span class="line-removed">262         diff = -diff;</span>
263     if (diff &gt; StackStats::s_maxLayoutCheckPointDiff) {
264         StackStats::s_maxLayoutCheckPointDiff = diff;
265         needToLog = true;
266     }
267 
268     // Update the total layout checkpoint diff stats:
<span class="line-removed">269     if (!isGrowingDownward)</span>
<span class="line-removed">270         totalDiff = -totalDiff;</span>
271     if (totalDiff &gt; StackStats::s_maxTotalLayoutCheckPointDiff) {
272         StackStats::s_maxTotalLayoutCheckPointDiff = totalDiff;
273         needToLog = true;
274     }
275 
276 #if ENABLE(VERBOSE_STACK_STATS)
277     needToLog = true; // always log.
278 #endif
279 
280     if (needToLog)
281         dataLogF(&quot; LAYOUT %p diff %d/%.1fk/max %.1fk | reentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n&quot;,
282             current, diff, diff / 1024.0, StackStats::s_maxLayoutCheckPointDiff / 1024.0,
283             m_depth, StackStats::s_maxLayoutReentryDepth,
284             totalDiff / 1024.0, StackStats::s_maxTotalLayoutCheckPointDiff / 1024.0,
285             stack.origin(), stack.size() / 1024.0);
286 }
287 
288 StackStats::LayoutCheckPoint::~LayoutCheckPoint()
289 {
290     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 56 int StackStats::s_maxLayoutReentryDepth = 0;
 57 
 58 
 59 StackStats::PerThreadStats::PerThreadStats()
 60 {
 61     const StackBounds&amp; stack = Thread::current().stack();
 62     m_reentryDepth = 0;
 63     m_stackStart = (char*)stack.origin();
 64     m_currentCheckPoint = 0;
 65 
 66     dataLogF(&quot; === THREAD new stackStart %p ========\n&quot;, m_stackStart);
 67 }
 68 
 69 StackStats::CheckPoint::CheckPoint()
 70 {
 71     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
 72     Thread&amp; thread = Thread::current();
 73     StackStats::PerThreadStats&amp; t = thread.stackStats();
 74     const StackBounds&amp; stack = thread.stack();
 75 

 76     bool needToLog = false;
 77     char* current = reinterpret_cast&lt;char*&gt;(this);
 78     char* last = reinterpret_cast&lt;char*&gt;(t.m_currentCheckPoint);
 79 
 80     // If there was no previous checkpoint, measure from the start of the stack:
 81     if (!last)
 82         last = t.m_stackStart;
 83 
 84     // Update the reentry depth stats:
 85     t.m_reentryDepth++;
 86     if (t.m_reentryDepth &gt; StackStats::s_maxReentryDepth) {
 87         StackStats::s_maxReentryDepth = t.m_reentryDepth;
 88         needToLog = true;
 89     }
 90 
 91     // Update the stack height stats:
 92     int height = t.m_stackStart - current;


 93     if (height &gt; StackStats::s_maxStackHeight) {
 94         StackStats::s_maxStackHeight = height;
 95         needToLog = true;
 96     }
 97 
 98     // Update the checkpoint diff stats:
 99     int diff = last - current;


100     if (diff &gt; StackStats::s_maxCheckPointDiff) {
101         StackStats::s_maxCheckPointDiff = diff;
102         needToLog = true;
103     }
104 
105     // Push this checkpoint:
106     m_prev = t.m_currentCheckPoint;
107     t.m_currentCheckPoint = this;
108 
109 #if ENABLE(VERBOSE_STACK_STATS)
110     needToLog = true; // always log.
111 #endif
112 
113     // Log this checkpoint if needed:
114     if (needToLog)
115         dataLogF(&quot; CHECKPOINT %p diff %d/%.1fk/max %.1fk | reentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n&quot;,
116             this, diff, diff / 1024.0, StackStats::s_maxCheckPointDiff / 1024.0,
117             t.m_reentryDepth, StackStats::s_maxReentryDepth,
118             height / 1024.0, StackStats::s_maxStackHeight / 1024.0,
119             stack.origin(), stack.size() / 1024.0);
120 }
121 
122 StackStats::CheckPoint::~CheckPoint()
123 {
124     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
125     Thread&amp; thread = Thread::current();
126     StackStats::PerThreadStats&amp; t = thread.stackStats();
127 
128     // Pop to previous checkpoint:
129     t.m_currentCheckPoint = m_prev;
130     --t.m_reentryDepth;
131 
132     // Log this checkpoint if needed:
133 #if ENABLE(VERBOSE_STACK_STATS)
134     if (!m_prev) {
135         const StackBounds&amp; stack = thread.stack();

136 
137         char* current = reinterpret_cast&lt;char*&gt;(this);
138         int height = t.m_stackStart - current;
139 



140         dataLogF(&quot; POP to %p diff max %.1fk | reentry %d/%d max | height %.1fk/max %.1fk | stack %p size %.1fk)\n&quot;,
141             this, StackStats::s_maxCheckPointDiff / 1024.0,
142             t.m_reentryDepth, StackStats::s_maxReentryDepth,
143             height / 1024.0, StackStats::s_maxStackHeight / 1024.0,
144             stack.origin(), stack.size() / 1024.0);
145     }
146 #endif
147 }
148 
149 void StackStats::probe()
150 {
151     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
152     Thread&amp; thread = Thread::current();
153     StackStats::PerThreadStats&amp; t = thread.stackStats();
154     const StackBounds&amp; stack = thread.stack();
155 


156     bool needToLog = false;
157 
158     int dummy;
159     char* current = reinterpret_cast&lt;char*&gt;(&amp;dummy);
160     char* last = reinterpret_cast&lt;char*&gt;(t.m_currentCheckPoint);
161 
162     // If there was no previous checkpoint, measure from the start of the stack:
163     if (!last)
164         last = t.m_stackStart;
165 
166     // We did not reach another checkpoint yet. Hence, we do not touch the
167     // reentry stats.
168 
169     // Update the stack height stats:
170     int height = t.m_stackStart - current;


171     if (height &gt; StackStats::s_maxStackHeight) {
172         StackStats::s_maxStackHeight = height;
173         needToLog = true;
174     }
175 
176     // Update the checkpoint diff stats:
177     int diff = last - current;


178     if (diff &gt; StackStats::s_maxCheckPointDiff) {
179         StackStats::s_maxCheckPointDiff = diff;
180         needToLog = true;
181     }
182 
183 #if ENABLE(VERBOSE_STACK_STATS)
184     needToLog = true; // always log.
185 #endif
186 
187     if (needToLog)
188         dataLogF(&quot; PROBE %p diff %d/%.1fk/max %.1fk | reentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n&quot;,
189             current, diff, diff / 1024.0, StackStats::s_maxCheckPointDiff / 1024.0,
190             t.m_reentryDepth, StackStats::s_maxReentryDepth,
191             height / 1024.0, StackStats::s_maxStackHeight / 1024.0,
192             stack.origin(), stack.size() / 1024.0);
193 }
194 
195 StackStats::LayoutCheckPoint::LayoutCheckPoint()
196 {
197     // While a layout checkpoint is not necessarily a checkpoint where we
198     // we will do a recursion check, it is a convenient spot for doing a
199     // probe to measure the height of stack usage.
200     //
201     // We&#39;ll do this probe before we commence with the layout checkpoint.
202     // This is because the probe also locks the sharedLock. By calling the
203     // probe first, we can avoid re-entering the lock.
204     StackStats::probe();
205 
206     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
207     Thread&amp; thread = Thread::current();
208     StackStats::PerThreadStats&amp; t = thread.stackStats();
209     const StackBounds&amp; stack = thread.stack();
210 


211     // Push this checkpoint:
212     m_prev = StackStats::s_topLayoutCheckPoint;
213     if (m_prev)
214         m_depth = m_prev-&gt;m_depth + 1;
215     else {
216         StackStats::s_firstLayoutCheckPoint = this;
217         m_depth = 0;
218     }
219     StackStats::s_topLayoutCheckPoint = this;
220 
221     //
222     char* current = reinterpret_cast&lt;char*&gt;(this);
223     char* last = reinterpret_cast&lt;char*&gt;(m_prev);
224     char* root = reinterpret_cast&lt;char*&gt;(StackStats::s_firstLayoutCheckPoint);
225     bool needToLog = false;
226 
227     int diff = last - current;
228     if (!last)
229         diff = 0;
230     int totalDiff = root - current;
231     if (!root)
232         totalDiff = 0;
233 
234     // Update the stack height stats:
235     int height = t.m_stackStart - current;


236     if (height &gt; StackStats::s_maxStackHeight) {
237         StackStats::s_maxStackHeight = height;
238         needToLog = true;
239     }
240 
241     // Update the layout checkpoint diff stats:


242     if (diff &gt; StackStats::s_maxLayoutCheckPointDiff) {
243         StackStats::s_maxLayoutCheckPointDiff = diff;
244         needToLog = true;
245     }
246 
247     // Update the total layout checkpoint diff stats:


248     if (totalDiff &gt; StackStats::s_maxTotalLayoutCheckPointDiff) {
249         StackStats::s_maxTotalLayoutCheckPointDiff = totalDiff;
250         needToLog = true;
251     }
252 
253 #if ENABLE(VERBOSE_STACK_STATS)
254     needToLog = true; // always log.
255 #endif
256 
257     if (needToLog)
258         dataLogF(&quot; LAYOUT %p diff %d/%.1fk/max %.1fk | reentry %d/max %d | height %.1fk/max %.1fk | stack %p size %.1fk\n&quot;,
259             current, diff, diff / 1024.0, StackStats::s_maxLayoutCheckPointDiff / 1024.0,
260             m_depth, StackStats::s_maxLayoutReentryDepth,
261             totalDiff / 1024.0, StackStats::s_maxTotalLayoutCheckPointDiff / 1024.0,
262             stack.origin(), stack.size() / 1024.0);
263 }
264 
265 StackStats::LayoutCheckPoint::~LayoutCheckPoint()
266 {
267     std::lock_guard&lt;Lock&gt; lock(StackStats::s_sharedMutex);
</pre>
</td>
</tr>
</table>
<center><a href="StackShot.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackTrace.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
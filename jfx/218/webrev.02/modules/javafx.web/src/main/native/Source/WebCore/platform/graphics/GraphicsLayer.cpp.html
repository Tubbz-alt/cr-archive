<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;GraphicsLayer.h&quot;
  29 
  30 #include &quot;FloatPoint.h&quot;
  31 #include &quot;FloatRect.h&quot;
  32 #include &quot;GraphicsContext.h&quot;
  33 #include &quot;LayoutRect.h&quot;
  34 #include &quot;RotateTransformOperation.h&quot;
  35 #include &lt;wtf/HashMap.h&gt;
  36 #include &lt;wtf/NeverDestroyed.h&gt;
  37 #include &lt;wtf/text/CString.h&gt;
  38 #include &lt;wtf/text/StringBuilder.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 #include &lt;wtf/text/WTFString.h&gt;
  41 
  42 #ifndef NDEBUG
  43 #include &lt;stdio.h&gt;
  44 #endif
  45 
  46 namespace WebCore {
  47 
  48 typedef HashMap&lt;const GraphicsLayer*, Vector&lt;FloatRect&gt;&gt; RepaintMap;
  49 static RepaintMap&amp; repaintRectMap()
  50 {
  51     static NeverDestroyed&lt;RepaintMap&gt; map;
  52     return map;
  53 }
  54 
  55 void KeyframeValueList::insert(std::unique_ptr&lt;const AnimationValue&gt; value)
  56 {
  57     for (size_t i = 0; i &lt; m_values.size(); ++i) {
  58         const AnimationValue* curValue = m_values[i].get();
  59         if (curValue-&gt;keyTime() == value-&gt;keyTime()) {
  60             ASSERT_NOT_REACHED();
  61             // insert after
  62             m_values.insert(i + 1, WTFMove(value));
  63             return;
  64         }
  65         if (curValue-&gt;keyTime() &gt; value-&gt;keyTime()) {
  66             // insert before
  67             m_values.insert(i, WTFMove(value));
  68             return;
  69         }
  70     }
  71 
  72     m_values.append(WTFMove(value));
  73 }
  74 
  75 #if !USE(CA)
  76 bool GraphicsLayer::supportsLayerType(Type type)
  77 {
  78     switch (type) {
  79     case Type::Normal:
  80     case Type::PageTiledBacking:
  81     case Type::ScrollContainer:
  82     case Type::ScrolledContents:
  83         return true;
  84     case Type::Shape:
  85         return false;
  86     }
  87     ASSERT_NOT_REACHED();
  88     return false;
  89 }
  90 
  91 bool GraphicsLayer::supportsBackgroundColorContent()
  92 {
  93 #if USE(TEXTURE_MAPPER)
  94     return true;
  95 #else
  96     return false;
  97 #endif
  98 }
  99 
 100 bool GraphicsLayer::supportsSubpixelAntialiasedLayerText()
 101 {
 102     return false;
 103 }
 104 #endif
 105 
 106 #if !USE(COORDINATED_GRAPHICS)
 107 bool GraphicsLayer::supportsContentsTiling()
 108 {
 109     // FIXME: Enable the feature on different ports.
 110     return false;
 111 }
 112 #endif
 113 
 114 // Singleton client used for layers on which clearClient has been called.
 115 class EmptyGraphicsLayerClient final : public GraphicsLayerClient {
 116     WTF_MAKE_FAST_ALLOCATED;
 117 public:
 118     static EmptyGraphicsLayerClient&amp; singleton();
 119 };
 120 
 121 EmptyGraphicsLayerClient&amp; EmptyGraphicsLayerClient::singleton()
 122 {
 123     static NeverDestroyed&lt;EmptyGraphicsLayerClient&gt; client;
 124     return client;
 125 }
 126 
 127 GraphicsLayer::GraphicsLayer(Type type, GraphicsLayerClient&amp; layerClient)
 128     : m_client(&amp;layerClient)
 129     , m_type(type)
 130     , m_beingDestroyed(false)
 131     , m_contentsOpaque(false)
 132     , m_supportsSubpixelAntialiasedText(false)
 133     , m_preserves3D(false)
 134     , m_backfaceVisibility(true)
 135     , m_masksToBounds(false)
 136     , m_drawsContent(false)
 137     , m_contentsVisible(true)
 138     , m_acceleratesDrawing(false)
 139     , m_usesDisplayListDrawing(false)
 140     , m_appliesPageScale(false)
 141     , m_showDebugBorder(false)
 142     , m_showRepaintCounter(false)
 143     , m_isMaskLayer(false)
 144     , m_isTrackingDisplayListReplay(false)
 145     , m_userInteractionEnabled(true)
 146     , m_canDetachBackingStore(true)
 147 {
 148 #ifndef NDEBUG
 149     client().verifyNotPainting();
 150 #endif
 151 }
 152 
 153 GraphicsLayer::~GraphicsLayer()
 154 {
 155     resetTrackedRepaints();
 156     ASSERT(!m_parent); // willBeDestroyed should have been called already.
 157 }
 158 
 159 void GraphicsLayer::unparentAndClear(RefPtr&lt;GraphicsLayer&gt;&amp; layer)
 160 {
 161     if (layer) {
 162         layer-&gt;removeFromParent();
 163         layer-&gt;clearClient();
 164         layer = nullptr;
 165     }
 166 }
 167 
 168 void GraphicsLayer::clear(RefPtr&lt;GraphicsLayer&gt;&amp; layer)
 169 {
 170     if (layer) {
 171         layer-&gt;clearClient();
 172         layer = nullptr;
 173     }
 174 }
 175 
 176 void GraphicsLayer::willBeDestroyed()
 177 {
 178     m_beingDestroyed = true;
 179 #ifndef NDEBUG
 180     client().verifyNotPainting();
 181 #endif
 182     if (m_replicaLayer)
 183         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 184 
 185     if (m_replicatedLayer)
 186         m_replicatedLayer-&gt;setReplicatedByLayer(nullptr);
 187 
 188     if (m_maskLayer) {
 189         m_maskLayer-&gt;setParent(nullptr);
 190         m_maskLayer-&gt;setIsMaskLayer(false);
 191     }
 192 
 193     removeAllChildren();
 194     removeFromParent();
 195 }
 196 
 197 void GraphicsLayer::clearClient()
 198 {
 199     m_client = &amp;EmptyGraphicsLayerClient::singleton();
 200 }
 201 
 202 String GraphicsLayer::debugName() const
 203 {
 204     return name();
 205 }
 206 
 207 void GraphicsLayer::setClient(GraphicsLayerClient&amp; client)
 208 {
 209     m_client = &amp;client;
 210 }
 211 
 212 void GraphicsLayer::setParent(GraphicsLayer* layer)
 213 {
 214     ASSERT(!layer || !layer-&gt;hasAncestor(this));
 215     m_parent = layer;
 216 }
 217 
 218 bool GraphicsLayer::hasAncestor(GraphicsLayer* ancestor) const
 219 {
 220     for (GraphicsLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
 221         if (curr == ancestor)
 222             return true;
 223     }
 224 
 225     return false;
 226 }
 227 
 228 bool GraphicsLayer::setChildren(Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp;&amp; newChildren)
 229 {
 230     // If the contents of the arrays are the same, nothing to do.
 231     if (newChildren == m_children)
 232         return false;
 233 
 234     removeAllChildren();
 235 
 236     size_t listSize = newChildren.size();
 237     for (size_t i = 0; i &lt; listSize; ++i)
 238         addChild(WTFMove(newChildren[i]));
 239 
 240     return true;
 241 }
 242 
 243 void GraphicsLayer::addChild(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer)
 244 {
 245     ASSERT(childLayer.ptr() != this);
 246 
 247     childLayer-&gt;removeFromParent();
 248     childLayer-&gt;setParent(this);
 249     m_children.append(WTFMove(childLayer));
 250 }
 251 
 252 void GraphicsLayer::addChildAtIndex(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, int index)
 253 {
 254     ASSERT(childLayer.ptr() != this);
 255 
 256     childLayer-&gt;removeFromParent();
 257     childLayer-&gt;setParent(this);
 258     m_children.insert(index, WTFMove(childLayer));
 259 }
 260 
 261 void GraphicsLayer::addChildBelow(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, GraphicsLayer* sibling)
 262 {
 263     ASSERT(childLayer.ptr() != this);
 264     childLayer-&gt;removeFromParent();
 265 
 266     childLayer-&gt;setParent(this);
 267 
 268     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 269         if (sibling == m_children[i].ptr()) {
 270             m_children.insert(i, WTFMove(childLayer));
 271             return;
 272         }
 273     }
 274 
 275     m_children.append(WTFMove(childLayer));
 276 }
 277 
 278 void GraphicsLayer::addChildAbove(Ref&lt;GraphicsLayer&gt;&amp;&amp; childLayer, GraphicsLayer* sibling)
 279 {
 280     childLayer-&gt;removeFromParent();
 281     ASSERT(childLayer.ptr() != this);
 282 
 283     childLayer-&gt;setParent(this);
 284 
 285     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 286         if (sibling == m_children[i].ptr()) {
 287             m_children.insert(i + 1, WTFMove(childLayer));
 288             return;
 289         }
 290     }
 291 
 292     m_children.append(WTFMove(childLayer));
 293 }
 294 
 295 bool GraphicsLayer::replaceChild(GraphicsLayer* oldChild, Ref&lt;GraphicsLayer&gt;&amp;&amp; newChild)
 296 {
 297     ASSERT(!newChild-&gt;parent());
 298 
 299     GraphicsLayer* rawNewChild = newChild.ptr();
 300 
 301     bool found = false;
 302     for (unsigned i = 0; i &lt; m_children.size(); i++) {
 303         if (oldChild == m_children[i].ptr()) {
 304             m_children[i] = WTFMove(newChild);
 305             found = true;
 306             break;
 307         }
 308     }
 309     if (found) {
 310         oldChild-&gt;setParent(nullptr);
 311 
 312         rawNewChild-&gt;removeFromParent();
 313         rawNewChild-&gt;setParent(this);
 314         return true;
 315     }
 316     return false;
 317 }
 318 
 319 void GraphicsLayer::removeAllChildren()
 320 {
 321     while (m_children.size()) {
 322         GraphicsLayer* curLayer = m_children[0].ptr();
 323         ASSERT(curLayer-&gt;parent());
 324         curLayer-&gt;removeFromParent();
 325         // curLayer may be destroyed here.
 326     }
 327 }
 328 
 329 void GraphicsLayer::removeFromParent()
 330 {
 331     if (m_parent) {
 332         GraphicsLayer* parent = m_parent;
 333         setParent(nullptr);
 334         parent-&gt;m_children.removeFirstMatching([this](auto&amp; layer) {
 335             return layer.ptr() == this;
 336         });
 337         // |this| may be destroyed here.
 338     }
 339 }
 340 
 341 const TransformationMatrix&amp; GraphicsLayer::transform() const
 342 {
 343     return m_transform ? *m_transform : TransformationMatrix::identity;
 344 }
 345 
 346 void GraphicsLayer::setTransform(const TransformationMatrix&amp; matrix)
 347 {
 348     if (m_transform)
 349         *m_transform = matrix;
 350     else
 351         m_transform = makeUnique&lt;TransformationMatrix&gt;(matrix);
 352 }
 353 
 354 const TransformationMatrix&amp; GraphicsLayer::childrenTransform() const
 355 {
 356     return m_childrenTransform ? *m_childrenTransform : TransformationMatrix::identity;
 357 }
 358 
 359 void GraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; matrix)
 360 {
 361     if (m_childrenTransform)
 362         *m_childrenTransform = matrix;
 363     else
 364         m_childrenTransform = makeUnique&lt;TransformationMatrix&gt;(matrix);
 365 }
 366 
 367 void GraphicsLayer::setMaskLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 368 {
 369     if (layer == m_maskLayer)
 370         return;
 371 
 372     if (layer) {
 373         layer-&gt;removeFromParent();
 374         layer-&gt;setParent(this);
 375         layer-&gt;setIsMaskLayer(true);
 376     } else if (m_maskLayer) {
 377         m_maskLayer-&gt;setParent(nullptr);
 378         m_maskLayer-&gt;setIsMaskLayer(false);
 379     }
 380 
 381     m_maskLayer = WTFMove(layer);
 382 }
 383 
 384 Path GraphicsLayer::shapeLayerPath() const
 385 {
 386 #if USE(CA)
 387     return m_shapeLayerPath;
 388 #else
 389     return Path();
 390 #endif
 391 }
 392 
 393 void GraphicsLayer::setShapeLayerPath(const Path&amp; path)
 394 {
 395 #if USE(CA)
 396     m_shapeLayerPath = path;
 397 #else
 398     UNUSED_PARAM(path);
 399 #endif
 400 }
 401 
 402 WindRule GraphicsLayer::shapeLayerWindRule() const
 403 {
 404 #if USE(CA)
 405     return m_shapeLayerWindRule;
 406 #else
 407     return WindRule::NonZero;
 408 #endif
 409 }
 410 
 411 void GraphicsLayer::setShapeLayerWindRule(WindRule windRule)
 412 {
 413 #if USE(CA)
 414     m_shapeLayerWindRule = windRule;
 415 #else
 416     UNUSED_PARAM(windRule);
 417 #endif
 418 }
 419 
 420 void GraphicsLayer::setEventRegion(EventRegion&amp;&amp; eventRegion)
 421 {
 422     m_eventRegion = WTFMove(eventRegion);
 423 }
 424 
 425 void GraphicsLayer::noteDeviceOrPageScaleFactorChangedIncludingDescendants()
 426 {
 427     deviceOrPageScaleFactorChanged();
 428 
 429     if (m_maskLayer)
 430         m_maskLayer-&gt;deviceOrPageScaleFactorChanged();
 431 
 432     if (m_replicaLayer)
 433         m_replicaLayer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 434 
 435     for (auto&amp; layer : children())
 436         layer-&gt;noteDeviceOrPageScaleFactorChangedIncludingDescendants();
 437 }
 438 
 439 void GraphicsLayer::setIsInWindow(bool inWindow)
 440 {
 441     if (TiledBacking* tiledBacking = this-&gt;tiledBacking())
 442         tiledBacking-&gt;setIsInWindow(inWindow);
 443 }
 444 
 445 void GraphicsLayer::setReplicatedByLayer(RefPtr&lt;GraphicsLayer&gt;&amp;&amp; layer)
 446 {
 447     if (m_replicaLayer == layer)
 448         return;
 449 
 450     if (m_replicaLayer)
 451         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 452 
 453     if (layer)
 454         layer-&gt;setReplicatedLayer(this);
 455 
 456     m_replicaLayer = WTFMove(layer);
 457 }
 458 
 459 void GraphicsLayer::setOffsetFromRenderer(const FloatSize&amp; offset, ShouldSetNeedsDisplay shouldSetNeedsDisplay)
 460 {
 461     if (offset == m_offsetFromRenderer)
 462         return;
 463 
 464     m_offsetFromRenderer = offset;
 465 
 466     // If the compositing layer offset changes, we need to repaint.
 467     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 468         setNeedsDisplay();
 469 }
 470 
 471 void GraphicsLayer::setScrollOffset(const ScrollOffset&amp; offset, ShouldSetNeedsDisplay shouldSetNeedsDisplay)
 472 {
 473     if (offset == m_scrollOffset)
 474         return;
 475 
 476     m_scrollOffset = offset;
 477 
 478     // If the compositing layer offset changes, we need to repaint.
 479     if (shouldSetNeedsDisplay == SetNeedsDisplay)
 480         setNeedsDisplay();
 481 }
 482 
 483 void GraphicsLayer::setSize(const FloatSize&amp; size)
 484 {
 485     if (size == m_size)
 486         return;
 487 
 488     m_size = size;
 489 
 490     if (shouldRepaintOnSizeChange())
 491         setNeedsDisplay();
 492 }
 493 
 494 void GraphicsLayer::setBackgroundColor(const Color&amp; color)
 495 {
 496     m_backgroundColor = color;
 497 }
 498 
 499 void GraphicsLayer::setPaintingPhase(OptionSet&lt;GraphicsLayerPaintingPhase&gt; phase)
 500 {
 501     if (phase == m_paintingPhase)
 502         return;
 503 
 504     setNeedsDisplay();
 505     m_paintingPhase = phase;
 506 }
 507 
 508 void GraphicsLayer::paintGraphicsLayerContents(GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 509 {
 510     FloatSize offset = offsetFromRenderer() - toFloatSize(scrollOffset());
 511     context.translate(-offset);
 512 
 513     FloatRect clipRect(clip);
 514     clipRect.move(offset);
 515 
 516     client().paintContents(this, context, clipRect, layerPaintBehavior);
 517 }
 518 
 519 FloatRect GraphicsLayer::adjustCoverageRectForMovement(const FloatRect&amp; coverageRect, const FloatRect&amp; previousVisibleRect, const FloatRect&amp; currentVisibleRect)
 520 {
 521     // If the old visible rect is empty, we have no information about how the visible area is changing
 522     // (maybe the layer was just created), so don&#39;t attempt to expand. Also don&#39;t attempt to expand if the rects don&#39;t overlap.
 523     if (previousVisibleRect.isEmpty() || !currentVisibleRect.intersects(previousVisibleRect))
 524         return unionRect(coverageRect, currentVisibleRect);
 525 
 526     const float paddingMultiplier = 2;
 527 
 528     float leftEdgeDelta = paddingMultiplier * (currentVisibleRect.x() - previousVisibleRect.x());
 529     float rightEdgeDelta = paddingMultiplier * (currentVisibleRect.maxX() - previousVisibleRect.maxX());
 530 
 531     float topEdgeDelta = paddingMultiplier * (currentVisibleRect.y() - previousVisibleRect.y());
 532     float bottomEdgeDelta = paddingMultiplier * (currentVisibleRect.maxY() - previousVisibleRect.maxY());
 533 
 534     FloatRect expandedRect = currentVisibleRect;
 535 
 536     // More exposed on left side.
 537     if (leftEdgeDelta &lt; 0) {
 538         float newLeft = expandedRect.x() + leftEdgeDelta;
 539         // Pad to the left, but don&#39;t reduce padding that&#39;s already in the backing store (since we&#39;re still exposing to the left).
 540         if (newLeft &lt; previousVisibleRect.x())
 541             expandedRect.shiftXEdgeTo(newLeft);
 542         else
 543             expandedRect.shiftXEdgeTo(previousVisibleRect.x());
 544     }
 545 
 546     // More exposed on right.
 547     if (rightEdgeDelta &gt; 0) {
 548         float newRight = expandedRect.maxX() + rightEdgeDelta;
 549         // Pad to the right, but don&#39;t reduce padding that&#39;s already in the backing store (since we&#39;re still exposing to the right).
 550         if (newRight &gt; previousVisibleRect.maxX())
 551             expandedRect.setWidth(newRight - expandedRect.x());
 552         else
 553             expandedRect.setWidth(previousVisibleRect.maxX() - expandedRect.x());
 554     }
 555 
 556     // More exposed at top.
 557     if (topEdgeDelta &lt; 0) {
 558         float newTop = expandedRect.y() + topEdgeDelta;
 559         if (newTop &lt; previousVisibleRect.y())
 560             expandedRect.shiftYEdgeTo(newTop);
 561         else
 562             expandedRect.shiftYEdgeTo(previousVisibleRect.y());
 563     }
 564 
 565     // More exposed on bottom.
 566     if (bottomEdgeDelta &gt; 0) {
 567         float newBottom = expandedRect.maxY() + bottomEdgeDelta;
 568         if (newBottom &gt; previousVisibleRect.maxY())
 569             expandedRect.setHeight(newBottom - expandedRect.y());
 570         else
 571             expandedRect.setHeight(previousVisibleRect.maxY() - expandedRect.y());
 572     }
 573 
 574     return unionRect(coverageRect, expandedRect);
 575 }
 576 
 577 String GraphicsLayer::animationNameForTransition(AnimatedPropertyID property)
 578 {
 579     // | is not a valid identifier character in CSS, so this can never conflict with a keyframe identifier.
 580     StringBuilder id;
 581     id.appendLiteral(&quot;-|transition&quot;);
 582     id.appendNumber(static_cast&lt;int&gt;(property));
 583     id.append(&#39;-&#39;);
 584     return id.toString();
 585 }
 586 
 587 void GraphicsLayer::suspendAnimations(MonotonicTime)
 588 {
 589 }
 590 
 591 void GraphicsLayer::resumeAnimations()
 592 {
 593 }
 594 
 595 void GraphicsLayer::getDebugBorderInfo(Color&amp; color, float&amp; width) const
 596 {
 597     width = 2;
 598 
 599     if (needsBackdrop()) {
 600         color = Color(255, 0, 255, 128); // has backdrop: magenta
 601         width = 12;
 602         return;
 603     }
 604 
 605     if (drawsContent()) {
 606         if (tiledBacking()) {
 607             color = Color(255, 128, 0, 128); // tiled layer: orange
 608             return;
 609         }
 610 
 611         color = Color(0, 128, 32, 128); // normal layer: green
 612         return;
 613     }
 614 
 615     if (usesContentsLayer()) {
 616         color = Color(0, 64, 128, 150); // non-painting layer with contents: blue
 617         width = 8;
 618         return;
 619     }
 620 
 621     if (masksToBounds()) {
 622         color = Color(128, 255, 255, 48); // masking layer: pale blue
 623         width = 16;
 624         return;
 625     }
 626 
 627     color = Color(255, 255, 0, 192); // container: yellow
 628 }
 629 
 630 void GraphicsLayer::updateDebugIndicators()
 631 {
 632     if (!isShowingDebugBorder())
 633         return;
 634 
 635     Color borderColor;
 636     float width = 0;
 637     getDebugBorderInfo(borderColor, width);
 638     setDebugBorder(borderColor, width);
 639 }
 640 
 641 void GraphicsLayer::setZPosition(float position)
 642 {
 643     m_zPosition = position;
 644 }
 645 
 646 float GraphicsLayer::accumulatedOpacity() const
 647 {
 648     if (!preserves3D())
 649         return 1;
 650 
 651     return m_opacity * (parent() ? parent()-&gt;accumulatedOpacity() : 1);
 652 }
 653 
 654 void GraphicsLayer::distributeOpacity(float accumulatedOpacity)
 655 {
 656     // If this is a transform layer we need to distribute our opacity to all our children
 657 
 658     // Incoming accumulatedOpacity is the contribution from our parent(s). We mutiply this by our own
 659     // opacity to get the total contribution
 660     accumulatedOpacity *= m_opacity;
 661 
 662     setOpacityInternal(accumulatedOpacity);
 663 
 664     if (preserves3D()) {
 665         for (auto&amp; layer : children())
 666             layer-&gt;distributeOpacity(accumulatedOpacity);
 667     }
 668 }
 669 
 670 static inline const FilterOperations&amp; filterOperationsAt(const KeyframeValueList&amp; valueList, size_t index)
 671 {
 672     return static_cast&lt;const FilterAnimationValue&amp;&gt;(valueList.at(index)).value();
 673 }
 674 
 675 int GraphicsLayer::validateFilterOperations(const KeyframeValueList&amp; valueList)
 676 {
 677 #if ENABLE(FILTERS_LEVEL_2)
 678     ASSERT(valueList.property() == AnimatedPropertyFilter || valueList.property() == AnimatedPropertyWebkitBackdropFilter);
 679 #else
 680     ASSERT(valueList.property() == AnimatedPropertyFilter);
 681 #endif
 682 
 683     if (valueList.size() &lt; 2)
 684         return -1;
 685 
 686     // Empty filters match anything, so find the first non-empty entry as the reference
 687     size_t firstIndex = 0;
 688     for ( ; firstIndex &lt; valueList.size(); ++firstIndex) {
 689         if (!filterOperationsAt(valueList, firstIndex).operations().isEmpty())
 690             break;
 691     }
 692 
 693     if (firstIndex &gt;= valueList.size())
 694         return -1;
 695 
 696     const FilterOperations&amp; firstVal = filterOperationsAt(valueList, firstIndex);
 697 
 698     for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 699         const FilterOperations&amp; val = filterOperationsAt(valueList, i);
 700 
 701         // An emtpy filter list matches anything.
 702         if (val.operations().isEmpty())
 703             continue;
 704 
 705         if (!firstVal.operationsMatch(val))
 706             return -1;
 707     }
 708 
 709     return firstIndex;
 710 }
 711 
 712 // An &quot;invalid&quot; list is one whose functions don&#39;t match, and therefore has to be animated as a Matrix
 713 // The hasBigRotation flag will always return false if isValid is false. Otherwise hasBigRotation is
 714 // true if the rotation between any two keyframes is &gt;= 180 degrees.
 715 
 716 static inline const TransformOperations&amp; operationsAt(const KeyframeValueList&amp; valueList, size_t index)
 717 {
 718     return static_cast&lt;const TransformAnimationValue&amp;&gt;(valueList.at(index)).value();
 719 }
 720 
 721 int GraphicsLayer::validateTransformOperations(const KeyframeValueList&amp; valueList, bool&amp; hasBigRotation)
 722 {
 723     ASSERT(valueList.property() == AnimatedPropertyTransform);
 724 
 725     hasBigRotation = false;
 726 
 727     if (valueList.size() &lt; 2)
 728         return -1;
 729 
 730     // Empty transforms match anything, so find the first non-empty entry as the reference.
 731     size_t firstIndex = 0;
 732     for ( ; firstIndex &lt; valueList.size(); ++firstIndex) {
 733         if (!operationsAt(valueList, firstIndex).operations().isEmpty())
 734             break;
 735     }
 736 
 737     if (firstIndex &gt;= valueList.size())
 738         return -1;
 739 
 740     const TransformOperations&amp; firstVal = operationsAt(valueList, firstIndex);
 741 
 742     // See if the keyframes are valid.
 743     for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 744         const TransformOperations&amp; val = operationsAt(valueList, i);
 745 
 746         // An empty transform list matches anything.
 747         if (val.operations().isEmpty())
 748             continue;
 749 
 750         if (!firstVal.operationsMatch(val))
 751             return -1;
 752     }
 753 
 754     // Keyframes are valid, check for big rotations.
 755     double lastRotationAngle = 0.0;
 756     double maxRotationAngle = -1.0;
 757 
 758     for (size_t j = 0; j &lt; firstVal.operations().size(); ++j) {
 759         TransformOperation::OperationType type = firstVal.operations().at(j)-&gt;type();
 760 
 761         // if this is a rotation entry, we need to see if any angle differences are &gt;= 180 deg
 762         if (type == TransformOperation::ROTATE_X ||
 763             type == TransformOperation::ROTATE_Y ||
 764             type == TransformOperation::ROTATE_Z ||
 765             type == TransformOperation::ROTATE_3D) {
 766             lastRotationAngle = downcast&lt;RotateTransformOperation&gt;(*firstVal.operations().at(j)).angle();
 767 
 768             if (maxRotationAngle &lt; 0)
 769                 maxRotationAngle = fabs(lastRotationAngle);
 770 
 771             for (size_t i = firstIndex + 1; i &lt; valueList.size(); ++i) {
 772                 const TransformOperations&amp; val = operationsAt(valueList, i);
 773                 double rotationAngle = val.operations().isEmpty() ? 0 : downcast&lt;RotateTransformOperation&gt;(*val.operations().at(j)).angle();
 774                 double diffAngle = fabs(rotationAngle - lastRotationAngle);
 775                 if (diffAngle &gt; maxRotationAngle)
 776                     maxRotationAngle = diffAngle;
 777                 lastRotationAngle = rotationAngle;
 778             }
 779         }
 780     }
 781 
 782     hasBigRotation = maxRotationAngle &gt;= 180.0;
 783 
 784     return firstIndex;
 785 }
 786 
 787 double GraphicsLayer::backingStoreMemoryEstimate() const
 788 {
 789     if (!drawsContent())
 790         return 0;
 791 
 792     // Effects of page and device scale are ignored; subclasses should override to take these into account.
 793     return static_cast&lt;double&gt;(4 * size().width()) * size().height();
 794 }
 795 
 796 void GraphicsLayer::resetTrackedRepaints()
 797 {
 798     repaintRectMap().remove(this);
 799 }
 800 
 801 void GraphicsLayer::addRepaintRect(const FloatRect&amp; repaintRect)
 802 {
 803     if (!client().isTrackingRepaints())
 804         return;
 805 
 806     FloatRect largestRepaintRect(FloatPoint(), m_size);
 807     largestRepaintRect.intersect(repaintRect);
 808     RepaintMap::iterator repaintIt = repaintRectMap().find(this);
 809     if (repaintIt == repaintRectMap().end()) {
 810         Vector&lt;FloatRect&gt; repaintRects;
 811         repaintRects.append(largestRepaintRect);
 812         repaintRectMap().set(this, repaintRects);
 813     } else {
 814         Vector&lt;FloatRect&gt;&amp; repaintRects = repaintIt-&gt;value;
 815         repaintRects.append(largestRepaintRect);
 816     }
 817 }
 818 
 819 void GraphicsLayer::traverse(GraphicsLayer&amp; layer, const WTF::Function&lt;void (GraphicsLayer&amp;)&gt;&amp; traversalFunc)
 820 {
 821     traversalFunc(layer);
 822 
 823     for (auto&amp; childLayer : layer.children())
 824         traverse(childLayer.get(), traversalFunc);
 825 
 826     if (auto* replicaLayer = layer.replicaLayer())
 827         traverse(*replicaLayer, traversalFunc);
 828 
 829     if (auto* maskLayer = layer.maskLayer())
 830         traverse(*maskLayer, traversalFunc);
 831 }
 832 
 833 GraphicsLayer::EmbeddedViewID GraphicsLayer::nextEmbeddedViewID()
 834 {
 835     static GraphicsLayer::EmbeddedViewID nextEmbeddedViewID;
 836     return ++nextEmbeddedViewID;
 837 }
 838 
 839 void GraphicsLayer::dumpLayer(TextStream&amp; ts, LayerTreeAsTextBehavior behavior) const
 840 {
 841     ts &lt;&lt; indent &lt;&lt; &quot;(&quot; &lt;&lt; &quot;GraphicsLayer&quot;;
 842 
 843     if (behavior &amp; LayerTreeAsTextDebug) {
 844         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;void*&gt;(const_cast&lt;GraphicsLayer*&gt;(this));
 845         ts &lt;&lt; &quot; \&quot;&quot; &lt;&lt; m_name &lt;&lt; &quot;\&quot;&quot;;
 846     }
 847 
 848     ts &lt;&lt; &quot;\n&quot;;
 849     dumpProperties(ts, behavior);
 850     ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
 851 }
 852 
 853 static void dumpChildren(TextStream&amp; ts, const Vector&lt;Ref&lt;GraphicsLayer&gt;&gt;&amp; children, unsigned&amp; totalChildCount, LayerTreeAsTextBehavior behavior)
 854 {
 855     totalChildCount += children.size();
 856     for (auto&amp; child : children) {
 857         if ((behavior &amp; LayerTreeAsTextDebug) || !child-&gt;client().shouldSkipLayerInDump(child.ptr(), behavior)) {
 858             TextStream::IndentScope indentScope(ts);
 859             child-&gt;dumpLayer(ts, behavior);
 860             continue;
 861         }
 862 
 863         totalChildCount--;
 864         dumpChildren(ts, child-&gt;children(), totalChildCount, behavior);
 865     }
 866 }
 867 
 868 void GraphicsLayer::dumpProperties(TextStream&amp; ts, LayerTreeAsTextBehavior behavior) const
 869 {
 870     TextStream::IndentScope indentScope(ts);
 871     if (!m_offsetFromRenderer.isZero())
 872         ts &lt;&lt; indent &lt;&lt; &quot;(offsetFromRenderer &quot; &lt;&lt; m_offsetFromRenderer &lt;&lt; &quot;)\n&quot;;
 873 
 874     if (!m_scrollOffset.isZero())
 875         ts &lt;&lt; indent &lt;&lt; &quot;(scrollOffset &quot; &lt;&lt; m_scrollOffset &lt;&lt; &quot;)\n&quot;;
 876 
 877     if (m_position != FloatPoint())
 878         ts &lt;&lt; indent &lt;&lt; &quot;(position &quot; &lt;&lt; m_position.x() &lt;&lt; &quot; &quot; &lt;&lt; m_position.y() &lt;&lt; &quot;)\n&quot;;
 879 
 880     if (m_approximatePosition)
 881         ts &lt;&lt; indent &lt;&lt; &quot;(approximate position &quot; &lt;&lt; m_approximatePosition.value().x() &lt;&lt; &quot; &quot; &lt;&lt; m_approximatePosition.value().y() &lt;&lt; &quot;)\n&quot;;
 882 
 883     if (m_boundsOrigin != FloatPoint())
 884         ts &lt;&lt; indent &lt;&lt; &quot;(bounds origin &quot; &lt;&lt; m_boundsOrigin.x() &lt;&lt; &quot; &quot; &lt;&lt; m_boundsOrigin.y() &lt;&lt; &quot;)\n&quot;;
 885 
 886     if (m_anchorPoint != FloatPoint3D(0.5f, 0.5f, 0)) {
 887         ts &lt;&lt; indent &lt;&lt; &quot;(anchor &quot; &lt;&lt; m_anchorPoint.x() &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.y();
 888         if (m_anchorPoint.z())
 889             ts &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.z();
 890         ts &lt;&lt; &quot;)\n&quot;;
 891     }
 892 
 893     if (m_size != IntSize())
 894         ts &lt;&lt; indent &lt;&lt; &quot;(bounds &quot; &lt;&lt; m_size.width() &lt;&lt; &quot; &quot; &lt;&lt; m_size.height() &lt;&lt; &quot;)\n&quot;;
 895 
 896     if (m_opacity != 1)
 897         ts &lt;&lt; indent &lt;&lt; &quot;(opacity &quot; &lt;&lt; m_opacity &lt;&lt; &quot;)\n&quot;;
 898 
 899 #if ENABLE(CSS_COMPOSITING)
 900     if (m_blendMode != BlendMode::Normal)
 901         ts &lt;&lt; indent &lt;&lt; &quot;(blendMode &quot; &lt;&lt; compositeOperatorName(CompositeOperator::SourceOver, m_blendMode) &lt;&lt; &quot;)\n&quot;;
 902 #endif
 903 
 904     if (type() == Type::Normal &amp;&amp; tiledBacking())
 905         ts &lt;&lt; indent &lt;&lt; &quot;(usingTiledLayer 1)\n&quot;;
 906 
 907     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack = client().needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(*this);
 908     if (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack)
 909         ts &lt;&lt; indent &lt;&lt; &quot;(contentsOpaque &quot; &lt;&lt; (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack) &lt;&lt; &quot;)\n&quot;;
 910 
 911     if (m_supportsSubpixelAntialiasedText)
 912         ts &lt;&lt; indent &lt;&lt; &quot;(supports subpixel antialiased text &quot; &lt;&lt; m_supportsSubpixelAntialiasedText &lt;&lt; &quot;)\n&quot;;
 913 
 914     if (m_masksToBounds &amp;&amp; behavior &amp; LayerTreeAsTextIncludeClipping)
 915         ts &lt;&lt; indent &lt;&lt; &quot;(clips &quot; &lt;&lt; m_masksToBounds &lt;&lt; &quot;)\n&quot;;
 916 
 917     if (m_preserves3D)
 918         ts &lt;&lt; indent &lt;&lt; &quot;(preserves3D &quot; &lt;&lt; m_preserves3D &lt;&lt; &quot;)\n&quot;;
 919 
 920     if (m_drawsContent &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;drawsContent&quot;, behavior))
 921         ts &lt;&lt; indent &lt;&lt; &quot;(drawsContent &quot; &lt;&lt; m_drawsContent &lt;&lt; &quot;)\n&quot;;
 922 
 923     if (!m_contentsVisible)
 924         ts &lt;&lt; indent &lt;&lt; &quot;(contentsVisible &quot; &lt;&lt; m_contentsVisible &lt;&lt; &quot;)\n&quot;;
 925 
 926     if (!m_backfaceVisibility)
 927         ts &lt;&lt; indent &lt;&lt; &quot;(backfaceVisibility &quot; &lt;&lt; (m_backfaceVisibility ? &quot;visible&quot; : &quot;hidden&quot;) &lt;&lt; &quot;)\n&quot;;
 928 
 929     if (behavior &amp; LayerTreeAsTextDebug)
 930         ts &lt;&lt; indent &lt;&lt; &quot;(primary-layer-id &quot; &lt;&lt; primaryLayerID() &lt;&lt; &quot;)\n&quot;;
 931 
 932     if (m_backgroundColor.isValid() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;backgroundColor&quot;, behavior))
 933         ts &lt;&lt; indent &lt;&lt; &quot;(backgroundColor &quot; &lt;&lt; m_backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;)\n&quot;;
 934 
 935     if (behavior &amp; LayerTreeAsTextIncludeAcceleratesDrawing &amp;&amp; m_acceleratesDrawing)
 936         ts &lt;&lt; indent &lt;&lt; &quot;(acceleratesDrawing &quot; &lt;&lt; m_acceleratesDrawing &lt;&lt; &quot;)\n&quot;;
 937 
 938     if (behavior &amp; LayerTreeAsTextIncludeBackingStoreAttached)
 939         ts &lt;&lt; indent &lt;&lt; &quot;(backingStoreAttached &quot; &lt;&lt; backingStoreAttachedForTesting() &lt;&lt; &quot;)\n&quot;;
 940 
 941     if (m_transform &amp;&amp; !m_transform-&gt;isIdentity()) {
 942         ts &lt;&lt; indent &lt;&lt; &quot;(transform &quot;;
 943         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m14() &lt;&lt; &quot;] &quot;;
 944         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m24() &lt;&lt; &quot;] &quot;;
 945         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m34() &lt;&lt; &quot;] &quot;;
 946         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_transform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_transform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 947     }
 948 
 949     // Avoid dumping the sublayer transform on the root layer, because it&#39;s used for geometry flipping, whose behavior
 950     // differs between platforms.
 951     if (parent() &amp;&amp; m_childrenTransform &amp;&amp; !m_childrenTransform-&gt;isIdentity()) {
 952         ts &lt;&lt; indent &lt;&lt; &quot;(childrenTransform &quot;;
 953         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m11() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m12() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m13() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m14() &lt;&lt; &quot;] &quot;;
 954         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m21() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m22() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m23() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m24() &lt;&lt; &quot;] &quot;;
 955         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m31() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m32() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m33() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m34() &lt;&lt; &quot;] &quot;;
 956         ts &lt;&lt; &quot;[&quot; &lt;&lt; m_childrenTransform-&gt;m41() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m42() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m43() &lt;&lt; &quot; &quot; &lt;&lt; m_childrenTransform-&gt;m44() &lt;&lt; &quot;])\n&quot;;
 957     }
 958 
 959     if (m_maskLayer) {
 960         ts &lt;&lt; indent &lt;&lt; &quot;(mask layer&quot;;
 961         if (behavior &amp; LayerTreeAsTextDebug)
 962             ts &lt;&lt; &quot; &quot; &lt;&lt; m_maskLayer;
 963         ts &lt;&lt; &quot;)\n&quot;;
 964 
 965         TextStream::IndentScope indentScope(ts);
 966         m_maskLayer-&gt;dumpLayer(ts, behavior);
 967     }
 968 
 969     if (m_replicaLayer) {
 970         ts &lt;&lt; indent &lt;&lt; &quot;(replica layer&quot;;
 971         if (behavior &amp; LayerTreeAsTextDebug)
 972             ts &lt;&lt; &quot; &quot; &lt;&lt; m_replicaLayer;
 973         ts &lt;&lt; &quot;)\n&quot;;
 974 
 975         TextStream::IndentScope indentScope(ts);
 976         m_replicaLayer-&gt;dumpLayer(ts, behavior);
 977     }
 978 
 979     if (m_replicatedLayer) {
 980         ts &lt;&lt; indent &lt;&lt; &quot;(replicated layer&quot;;
 981         if (behavior &amp; LayerTreeAsTextDebug)
 982             ts &lt;&lt; &quot; &quot; &lt;&lt; m_replicatedLayer;
 983         ts &lt;&lt; &quot;)\n&quot;;
 984     }
 985 
 986     if (behavior &amp; LayerTreeAsTextIncludeRepaintRects &amp;&amp; repaintRectMap().contains(this) &amp;&amp; !repaintRectMap().get(this).isEmpty() &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;repaintRects&quot;, behavior)) {
 987         ts &lt;&lt; indent &lt;&lt; &quot;(repaint rects\n&quot;;
 988         for (size_t i = 0; i &lt; repaintRectMap().get(this).size(); ++i) {
 989             if (repaintRectMap().get(this)[i].isEmpty())
 990                 continue;
 991 
 992             TextStream::IndentScope indentScope(ts);
 993             ts &lt;&lt; indent &lt;&lt; &quot;(rect &quot;;
 994             ts &lt;&lt; repaintRectMap().get(this)[i].x() &lt;&lt; &quot; &quot;;
 995             ts &lt;&lt; repaintRectMap().get(this)[i].y() &lt;&lt; &quot; &quot;;
 996             ts &lt;&lt; repaintRectMap().get(this)[i].width() &lt;&lt; &quot; &quot;;
 997             ts &lt;&lt; repaintRectMap().get(this)[i].height();
 998             ts &lt;&lt; &quot;)\n&quot;;
 999         }
1000         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
1001     }
1002 
1003     if (behavior &amp; LayerTreeAsTextIncludeEventRegion &amp;&amp; !m_eventRegion.isEmpty()) {
1004         ts &lt;&lt; indent &lt;&lt; &quot;(event region&quot; &lt;&lt; m_eventRegion;
1005         ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
1006     }
1007 
1008     if (behavior &amp; LayerTreeAsTextIncludePaintingPhases &amp;&amp; paintingPhase())
1009         ts &lt;&lt; indent &lt;&lt; &quot;(paintingPhases &quot; &lt;&lt; paintingPhase() &lt;&lt; &quot;)\n&quot;;
1010 
1011     dumpAdditionalProperties(ts, behavior);
1012 
1013     if (m_children.size()) {
1014         TextStream childrenStream;
1015 
1016         childrenStream.increaseIndent(ts.indent());
1017         unsigned totalChildCount = 0;
1018         dumpChildren(childrenStream, m_children, totalChildCount, behavior);
1019 
1020         if (totalChildCount) {
1021             ts &lt;&lt; indent &lt;&lt; &quot;(children &quot; &lt;&lt; totalChildCount &lt;&lt; &quot;\n&quot;;
1022             ts &lt;&lt; childrenStream.release();
1023             ts &lt;&lt; indent &lt;&lt; &quot;)\n&quot;;
1024         }
1025     }
1026 }
1027 
1028 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Vector&lt;GraphicsLayer::PlatformLayerID&gt;&amp; layers)
1029 {
1030     for (size_t i = 0; i &lt; layers.size(); ++i) {
1031         if (i)
1032             ts &lt;&lt; &quot; &quot;;
1033         ts &lt;&lt; layers[i];
1034     }
1035 
1036     return ts;
1037 }
1038 
1039 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, GraphicsLayerPaintingPhase phase)
1040 {
1041     switch (phase) {
1042     case GraphicsLayerPaintingPhase::Background: ts &lt;&lt; &quot;background&quot;; break;
1043     case GraphicsLayerPaintingPhase::Foreground: ts &lt;&lt; &quot;foreground&quot;; break;
1044     case GraphicsLayerPaintingPhase::Mask: ts &lt;&lt; &quot;mask&quot;; break;
1045     case GraphicsLayerPaintingPhase::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;
1046     case GraphicsLayerPaintingPhase::OverflowContents: ts &lt;&lt; &quot;overflow-contents&quot;; break;
1047     case GraphicsLayerPaintingPhase::CompositedScroll: ts &lt;&lt; &quot;composited-scroll&quot;; break;
1048     case GraphicsLayerPaintingPhase::ChildClippingMask: ts &lt;&lt; &quot;child-clipping-mask&quot;; break;
1049     }
1050 
1051     return ts;
1052 }
1053 
1054 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsLayer::CustomAppearance&amp; customAppearance)
1055 {
1056     switch (customAppearance) {
1057     case GraphicsLayer::CustomAppearance::None: ts &lt;&lt; &quot;none&quot;; break;
1058     case GraphicsLayer::CustomAppearance::ScrollingOverhang: ts &lt;&lt; &quot;scrolling-overhang&quot;; break;
1059     case GraphicsLayer::CustomAppearance::ScrollingShadow: ts &lt;&lt; &quot;scrolling-shadow&quot;; break;
1060     case GraphicsLayer::CustomAppearance::LightBackdrop: ts &lt;&lt; &quot;light-backdrop&quot;; break;
1061     case GraphicsLayer::CustomAppearance::DarkBackdrop: ts &lt;&lt; &quot;dark-backdrop&quot;; break;
1062     }
1063     return ts;
1064 }
1065 
1066 String GraphicsLayer::layerTreeAsText(LayerTreeAsTextBehavior behavior) const
1067 {
1068     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect);
1069 
1070     dumpLayer(ts, behavior);
1071     return ts.release();
1072 }
1073 
1074 } // namespace WebCore
1075 
1076 #if ENABLE(TREE_DEBUGGING)
1077 void showGraphicsLayerTree(const WebCore::GraphicsLayer* layer)
1078 {
1079     if (!layer)
1080         return;
1081 
1082     String output = layer-&gt;layerTreeAsText(WebCore::LayerTreeAsTextShowAll);
1083     WTFLogAlways(&quot;%s\n&quot;, output.utf8().data());
1084 }
1085 #endif
    </pre>
  </body>
</html>
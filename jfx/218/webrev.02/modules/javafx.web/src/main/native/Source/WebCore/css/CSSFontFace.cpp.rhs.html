<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/CSSFontFace.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSFontFace.h&quot;
 28 
 29 #include &quot;CSSFontFaceSource.h&quot;
 30 #include &quot;CSSFontFaceSrcValue.h&quot;
 31 #include &quot;CSSFontFeatureValue.h&quot;
 32 #include &quot;CSSFontSelector.h&quot;
 33 #include &quot;CSSFontStyleRangeValue.h&quot;
 34 #include &quot;CSSPrimitiveValueMappings.h&quot;
 35 #include &quot;CSSUnicodeRangeValue.h&quot;
 36 #include &quot;CSSValue.h&quot;
 37 #include &quot;CSSValueList.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 38 #include &quot;CachedFont.h&quot;</span>
 39 #include &quot;Document.h&quot;
 40 #include &quot;Font.h&quot;
 41 #include &quot;FontCache.h&quot;
 42 #include &quot;FontDescription.h&quot;
 43 #include &quot;FontFace.h&quot;
<a name="2" id="anc2"></a>
 44 #include &quot;Settings.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 45 #include &quot;SharedBuffer.h&quot;</span>
 46 #include &quot;StyleBuilderConverter.h&quot;
 47 #include &quot;StyleProperties.h&quot;
 48 #include &quot;StyleRule.h&quot;
 49 
 50 namespace WebCore {
 51 
<a name="4" id="anc4"></a><span class="line-added"> 52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CSSFontFace);</span>
<span class="line-added"> 53 </span>
 54 template&lt;typename T&gt; void iterateClients(HashSet&lt;CSSFontFace::Client*&gt;&amp; clients, T callback)
 55 {
 56     Vector&lt;Ref&lt;CSSFontFace::Client&gt;&gt; clientsCopy;
 57     clientsCopy.reserveInitialCapacity(clients.size());
 58     for (auto* client : clients)
 59         clientsCopy.uncheckedAppend(*client);
 60 
 61     for (auto* client : clients)
 62         callback(*client);
 63 }
 64 
 65 void CSSFontFace::appendSources(CSSFontFace&amp; fontFace, CSSValueList&amp; srcList, Document* document, bool isInitiatingElementInUserAgentShadowTree)
 66 {
 67     for (auto&amp; src : srcList) {
 68         // An item in the list either specifies a string (local font name) or a URL (remote font to download).
 69         CSSFontFaceSrcValue&amp; item = downcast&lt;CSSFontFaceSrcValue&gt;(src.get());
 70         std::unique_ptr&lt;CSSFontFaceSource&gt; source;
 71         SVGFontFaceElement* fontFaceElement = nullptr;
 72         bool foundSVGFont = false;
 73 
 74 #if ENABLE(SVG_FONTS)
 75         foundSVGFont = item.isSVGFontFaceSrc() || item.svgFontFaceElement();
 76         fontFaceElement = item.svgFontFaceElement();
 77 #endif
 78         if (!item.isLocal()) {
 79             const Settings* settings = document ? &amp;document-&gt;settings() : nullptr;
 80             bool allowDownloading = foundSVGFont || (settings &amp;&amp; settings-&gt;downloadableBinaryFontsEnabled());
 81             if (allowDownloading &amp;&amp; item.isSupportedFormat() &amp;&amp; document) {
 82                 if (CachedFont* cachedFont = item.cachedFont(document, foundSVGFont, isInitiatingElementInUserAgentShadowTree))
 83                     source = makeUnique&lt;CSSFontFaceSource&gt;(fontFace, item.resource(), cachedFont);
 84             }
 85         } else
 86             source = makeUnique&lt;CSSFontFaceSource&gt;(fontFace, item.resource(), nullptr, fontFaceElement);
 87 
 88         if (source)
 89             fontFace.adoptSource(WTFMove(source));
 90     }
 91     fontFace.sourcesPopulated();
 92 }
 93 
 94 CSSFontFace::CSSFontFace(CSSFontSelector* fontSelector, StyleRuleFontFace* cssConnection, FontFace* wrapper, bool isLocalFallback)
<a name="5" id="anc5"></a><span class="line-modified"> 95     : m_fontSelector(makeWeakPtr(fontSelector))</span>
 96     , m_cssConnection(cssConnection)
 97     , m_wrapper(makeWeakPtr(wrapper))
 98     , m_isLocalFallback(isLocalFallback)
 99     , m_mayBePurged(!wrapper)
100     , m_timeoutTimer(*this, &amp;CSSFontFace::timeoutFired)
101 {
102 }
103 
104 CSSFontFace::~CSSFontFace() = default;
105 
106 bool CSSFontFace::setFamilies(CSSValue&amp; family)
107 {
108     if (!is&lt;CSSValueList&gt;(family))
109         return false;
110 
111     CSSValueList&amp; familyList = downcast&lt;CSSValueList&gt;(family);
112     if (!familyList.length())
113         return false;
114 
115     RefPtr&lt;CSSValueList&gt; oldFamilies = m_families;
116     m_families = &amp;familyList;
117 
118     if (m_cssConnection)
119         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontFamily, &amp;family);
120 
121     iterateClients(m_clients, [&amp;](Client&amp; client) {
122         client.fontPropertyChanged(*this, oldFamilies.get());
123     });
124 
125     return true;
126 }
127 
128 FontFace* CSSFontFace::existingWrapper()
129 {
130     return m_wrapper.get();
131 }
132 
133 static FontSelectionRange calculateWeightRange(CSSValue&amp; value)
134 {
135     if (value.isValueList()) {
136         auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
137         ASSERT(valueList.length() == 2);
138         if (valueList.length() != 2)
139             return { normalWeightValue(), normalWeightValue() };
140         ASSERT(valueList.item(0)-&gt;isPrimitiveValue());
141         ASSERT(valueList.item(1)-&gt;isPrimitiveValue());
142         auto&amp; value0 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(0));
143         auto&amp; value1 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(1));
<a name="6" id="anc6"></a><span class="line-modified">144         auto result0 = Style::BuilderConverter::convertFontWeightFromValue(value0);</span>
<span class="line-modified">145         auto result1 = Style::BuilderConverter::convertFontWeightFromValue(value1);</span>
146         return { result0, result1 };
147     }
148 
149     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
150     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
<a name="7" id="anc7"></a><span class="line-modified">151     FontSelectionValue result = Style::BuilderConverter::convertFontWeightFromValue(primitiveValue);</span>
152     return { result, result };
153 }
154 
155 void CSSFontFace::setWeight(CSSValue&amp; weight)
156 {
157     auto range = calculateWeightRange(weight);
158     if (m_fontSelectionCapabilities.weight == range)
159         return;
160 
161     setWeight(range);
162 
163     if (m_cssConnection)
164         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontWeight, &amp;weight);
165 
166     iterateClients(m_clients, [&amp;](Client&amp; client) {
167         client.fontPropertyChanged(*this);
168     });
169 }
170 
171 static FontSelectionRange calculateStretchRange(CSSValue&amp; value)
172 {
173     if (value.isValueList()) {
174         auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
175         ASSERT(valueList.length() == 2);
176         if (valueList.length() != 2)
177             return { normalStretchValue(), normalStretchValue() };
178         ASSERT(valueList.item(0)-&gt;isPrimitiveValue());
179         ASSERT(valueList.item(1)-&gt;isPrimitiveValue());
180         auto&amp; value0 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(0));
181         auto&amp; value1 = downcast&lt;CSSPrimitiveValue&gt;(*valueList.item(1));
<a name="8" id="anc8"></a><span class="line-modified">182         auto result0 = Style::BuilderConverter::convertFontStretchFromValue(value0);</span>
<span class="line-modified">183         auto result1 = Style::BuilderConverter::convertFontStretchFromValue(value1);</span>
184         return { result0, result1 };
185     }
186 
187     ASSERT(is&lt;CSSPrimitiveValue&gt;(value));
188     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
<a name="9" id="anc9"></a><span class="line-modified">189     FontSelectionValue result = Style::BuilderConverter::convertFontStretchFromValue(primitiveValue);</span>
190     return { result, result };
191 }
192 
193 void CSSFontFace::setStretch(CSSValue&amp; style)
194 {
195     auto range = calculateStretchRange(style);
196     if (m_fontSelectionCapabilities.width == range)
197         return;
198 
199     setStretch(range);
200 
201     if (m_cssConnection)
202         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontStretch, &amp;style);
203 
204     iterateClients(m_clients, [&amp;](Client&amp; client) {
205         client.fontPropertyChanged(*this);
206     });
207 }
208 
209 static FontSelectionRange calculateItalicRange(CSSValue&amp; value)
210 {
211     if (value.isFontStyleValue()) {
<a name="10" id="anc10"></a><span class="line-modified">212         auto result = Style::BuilderConverter::convertFontStyleFromValue(value);</span>
213         return { result.valueOr(normalItalicValue()), result.valueOr(normalItalicValue()) };
214     }
215 
216     ASSERT(value.isFontStyleRangeValue());
217     auto&amp; rangeValue = downcast&lt;CSSFontStyleRangeValue&gt;(value);
218     ASSERT(rangeValue.fontStyleValue-&gt;isValueID());
219     auto valueID = rangeValue.fontStyleValue-&gt;valueID();
220     if (!rangeValue.obliqueValues) {
221         if (valueID == CSSValueNormal)
222             return { normalItalicValue(), normalItalicValue() };
223         ASSERT(valueID == CSSValueItalic || valueID == CSSValueOblique);
224         return { italicValue(), italicValue() };
225     }
226     ASSERT(valueID == CSSValueOblique);
227     auto length = rangeValue.obliqueValues-&gt;length();
228     if (length == 1) {
229         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(0));
<a name="11" id="anc11"></a><span class="line-modified">230         FontSelectionValue result(primitiveValue.value&lt;float&gt;(CSSUnitType::CSS_DEG));</span>
231         return { result, result };
232     }
233     ASSERT(length == 2);
234     auto&amp; primitiveValue1 = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(0));
235     auto&amp; primitiveValue2 = downcast&lt;CSSPrimitiveValue&gt;(*rangeValue.obliqueValues-&gt;item(1));
<a name="12" id="anc12"></a><span class="line-modified">236     FontSelectionValue result1(primitiveValue1.value&lt;float&gt;(CSSUnitType::CSS_DEG));</span>
<span class="line-modified">237     FontSelectionValue result2(primitiveValue2.value&lt;float&gt;(CSSUnitType::CSS_DEG));</span>
238     return { result1, result2 };
239 }
240 
241 void CSSFontFace::setStyle(CSSValue&amp; style)
242 {
243     auto range = calculateItalicRange(style);
244     if (m_fontSelectionCapabilities.slope == range)
245         return;
246 
247     setStyle(range);
248 
249     if (m_cssConnection)
250         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontStyle, &amp;style);
251 
252     iterateClients(m_clients, [&amp;](Client&amp; client) {
253         client.fontPropertyChanged(*this);
254     });
255 }
256 
257 bool CSSFontFace::setUnicodeRange(CSSValue&amp; unicodeRange)
258 {
259     if (!is&lt;CSSValueList&gt;(unicodeRange))
260         return false;
261 
262     Vector&lt;UnicodeRange&gt; ranges;
263     auto&amp; list = downcast&lt;CSSValueList&gt;(unicodeRange);
264     for (auto&amp; rangeValue : list) {
265         auto&amp; range = downcast&lt;CSSUnicodeRangeValue&gt;(rangeValue.get());
266         ranges.append({ range.from(), range.to() });
267     }
268 
269     if (ranges == m_ranges)
270         return true;
271 
272     m_ranges = WTFMove(ranges);
273 
274     if (m_cssConnection)
275         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyUnicodeRange, &amp;unicodeRange);
276 
277     iterateClients(m_clients, [&amp;](Client&amp; client) {
278         client.fontPropertyChanged(*this);
279     });
280 
281     return true;
282 }
283 
<a name="13" id="anc13"></a>












































































































































284 void CSSFontFace::setFeatureSettings(CSSValue&amp; featureSettings)
285 {
286     // Can only call this with a primitive value of normal, or a value list containing font feature values.
287     ASSERT(is&lt;CSSPrimitiveValue&gt;(featureSettings) || is&lt;CSSValueList&gt;(featureSettings));
288 
289     FontFeatureSettings settings;
290 
291     if (is&lt;CSSValueList&gt;(featureSettings)) {
292         auto&amp; list = downcast&lt;CSSValueList&gt;(featureSettings);
293         for (auto&amp; rangeValue : list) {
294             auto&amp; feature = downcast&lt;CSSFontFeatureValue&gt;(rangeValue.get());
295             settings.insert({ feature.tag(), feature.value() });
296         }
297     }
298 
299     if (m_featureSettings == settings)
300         return;
301 
302     m_featureSettings = WTFMove(settings);
303 
304     if (m_cssConnection)
305         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontFeatureSettings, &amp;featureSettings);
306 
307     iterateClients(m_clients, [&amp;](Client&amp; client) {
308         client.fontPropertyChanged(*this);
309     });
310 }
311 
312 void CSSFontFace::setLoadingBehavior(CSSValue&amp; loadingBehaviorValue)
313 {
314     auto loadingBehavior = static_cast&lt;FontLoadingBehavior&gt;(downcast&lt;CSSPrimitiveValue&gt;(loadingBehaviorValue));
315 
316     if (m_loadingBehavior == loadingBehavior)
317         return;
318 
319     m_loadingBehavior = loadingBehavior;
320 
321     if (m_cssConnection)
322         m_cssConnection-&gt;mutableProperties().setProperty(CSSPropertyFontDisplay, &amp;loadingBehaviorValue);
323 
324     iterateClients(m_clients, [&amp;](Client&amp; client) {
325         client.fontPropertyChanged(*this);
326     });
327 }
328 
329 bool CSSFontFace::rangesMatchCodePoint(UChar32 character) const
330 {
331     if (m_ranges.isEmpty())
332         return true;
333 
334     for (auto&amp; range : m_ranges) {
335         if (range.from &lt;= character &amp;&amp; character &lt;= range.to)
336             return true;
337     }
338     return false;
339 }
340 
341 void CSSFontFace::fontLoadEventOccurred()
342 {
343     // If the font is already in the cache, CSSFontFaceSource may report it&#39;s loaded before it is added here as a source.
344     // Let&#39;s not pump the state machine until we&#39;ve got all our sources. font() and load() are smart enough to act correctly
345     // when a source is failed or succeeded before we have asked it to load.
346     if (m_sourcesPopulated)
347         pump(ExternalResourceDownloadPolicy::Forbid);
348 
<a name="14" id="anc14"></a><span class="line-modified">349     if (m_fontSelector)</span>
<span class="line-modified">350         m_fontSelector-&gt;fontLoaded();</span>
351 
352     iterateClients(m_clients, [&amp;](Client&amp; client) {
353         client.fontLoaded(*this);
354     });
355 }
356 
357 void CSSFontFace::timeoutFired()
358 {
359     Ref&lt;CSSFontFace&gt; protectedThis(*this);
360 
361     switch (status()) {
362     case Status::Loading:
363         setStatus(Status::TimedOut);
364         break;
365     case Status::TimedOut:
366         // Cancelling the network request here could lead to a situation where a site&#39;s font never gets
367         // shown as the user navigates around to different pages on the site. This would occur if the
368         // download always takes longer than the timeout (even though the user may spend substantial time
369         // on each page). Therefore, we shouldn&#39;t cancel the network request here, but should use the
370         // loading infrastructure&#39;s timeout policies instead.
371         setStatus(Status::Failure);
372         break;
373     default:
374         ASSERT_NOT_REACHED();
375         break;
376     }
377 
378     fontLoadEventOccurred();
379 }
380 
381 bool CSSFontFace::computeFailureState() const
382 {
383     if (status() == Status::Failure)
384         return true;
385     for (auto&amp; source : m_sources) {
386         if (source-&gt;status() != CSSFontFaceSource::Status::Failure)
387             return false;
388     }
389     return true;
390 }
391 
392 void CSSFontFace::addClient(Client&amp; client)
393 {
394     m_clients.add(&amp;client);
395 }
396 
397 void CSSFontFace::removeClient(Client&amp; client)
398 {
399     ASSERT(m_clients.contains(&amp;client));
400     m_clients.remove(&amp;client);
401 }
402 
403 void CSSFontFace::initializeWrapper()
404 {
405     switch (m_status) {
406     case Status::Pending:
407         break;
408     case Status::Loading:
409         m_wrapper-&gt;fontStateChanged(*this, Status::Pending, Status::Loading);
410         break;
411     case Status::TimedOut:
412         m_wrapper-&gt;fontStateChanged(*this, Status::Pending, Status::Loading);
413         m_wrapper-&gt;fontStateChanged(*this, Status::Loading, Status::TimedOut);
414         break;
415     case Status::Success:
416         m_wrapper-&gt;fontStateChanged(*this, Status::Pending, Status::Loading);
417         m_wrapper-&gt;fontStateChanged(*this, Status::Pending, Status::Success);
418         break;
419     case Status::Failure:
420         m_wrapper-&gt;fontStateChanged(*this, Status::Pending, Status::Loading);
421         m_wrapper-&gt;fontStateChanged(*this, Status::Pending, Status::Failure);
422         break;
423     }
424     m_mayBePurged = false;
425 }
426 
427 Ref&lt;FontFace&gt; CSSFontFace::wrapper()
428 {
429     if (m_wrapper)
430         return *m_wrapper.get();
431 
432     auto wrapper = FontFace::create(*this);
433     m_wrapper = makeWeakPtr(wrapper.get());
434     initializeWrapper();
435     return wrapper;
436 }
437 
438 void CSSFontFace::setWrapper(FontFace&amp; newWrapper)
439 {
440     m_wrapper = makeWeakPtr(newWrapper);
441     initializeWrapper();
442 }
443 
444 void CSSFontFace::adoptSource(std::unique_ptr&lt;CSSFontFaceSource&gt;&amp;&amp; source)
445 {
446     m_sources.append(WTFMove(source));
447 
448     // We should never add sources in the middle of loading.
449     ASSERT(!m_sourcesPopulated);
450 }
451 
<a name="15" id="anc15"></a><span class="line-modified">452 Document* CSSFontFace::document() const</span>
453 {
<a name="16" id="anc16"></a><span class="line-modified">454     return m_fontSelector ? m_fontSelector-&gt;document() : nullptr;</span>


455 }
456 
<a name="17" id="anc17"></a><span class="line-modified">457 AllowUserInstalledFonts CSSFontFace::allowUserInstalledFonts() const</span>
458 {
459     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())
<a name="18" id="anc18"></a><span class="line-modified">460         return m_fontSelector-&gt;document()-&gt;settings().shouldAllowUserInstalledFonts() ? AllowUserInstalledFonts::Yes : AllowUserInstalledFonts::No;</span>
<span class="line-modified">461     return AllowUserInstalledFonts::Yes;</span>
462 }
463 
464 static Settings::FontLoadTimingOverride fontLoadTimingOverride(CSSFontSelector* fontSelector)
465 {
466     auto overrideValue = Settings::FontLoadTimingOverride::None;
467     if (fontSelector &amp;&amp; fontSelector-&gt;document())
468         overrideValue = fontSelector-&gt;document()-&gt;settings().fontLoadTimingOverride();
469     return overrideValue;
470 }
471 
472 auto CSSFontFace::fontLoadTiming() const -&gt; FontLoadTiming
473 {
474     switch (fontLoadTimingOverride(m_fontSelector.get())) {
475     case Settings::FontLoadTimingOverride::None:
476         switch (m_loadingBehavior) {
477         case FontLoadingBehavior::Auto:
478         case FontLoadingBehavior::Block:
479             return { 3_s, Seconds::infinity() };
480         case FontLoadingBehavior::Swap:
481             return { 0_s, Seconds::infinity() };
482         case FontLoadingBehavior::Fallback:
483             return { 0.1_s, 3_s };
484         case FontLoadingBehavior::Optional:
485             return { 0.1_s, 0_s };
486         }
487         RELEASE_ASSERT_NOT_REACHED();
488     case Settings::FontLoadTimingOverride::Block:
489         return { Seconds::infinity(), 0_s };
490     case Settings::FontLoadTimingOverride::Swap:
491         return { 0_s, Seconds::infinity() };
492     case Settings::FontLoadTimingOverride::Failure:
493         return { 0_s, 0_s };
494     }
495     RELEASE_ASSERT_NOT_REACHED();
496 }
497 
498 void CSSFontFace::setStatus(Status newStatus)
499 {
500     switch (newStatus) {
501     case Status::Pending:
502         ASSERT_NOT_REACHED();
503         break;
504     case Status::Loading:
505         ASSERT(m_status == Status::Pending);
506         break;
507     case Status::TimedOut:
508         ASSERT(m_status == Status::Loading);
509         break;
510     case Status::Success:
511         ASSERT(m_status == Status::Loading || m_status == Status::TimedOut);
512         break;
513     case Status::Failure:
514         ASSERT(m_status == Status::Loading || m_status == Status::TimedOut);
515         break;
516     }
517 
518     iterateClients(m_clients, [&amp;](Client&amp; client) {
519         client.fontStateChanged(*this, m_status, newStatus);
520     });
521 
522     m_status = newStatus;
523 
524     Seconds blockPeriodTimeout;
525     Seconds swapPeriodTimeout;
526     auto timeouts = fontLoadTiming();
527     blockPeriodTimeout = timeouts.blockPeriod;
528     swapPeriodTimeout = timeouts.swapPeriod;
529 
530     // Transfer across 0-delay timers synchronously. Layouts/script may
531     // take arbitrarily long time, and we shouldn&#39;t be in a 0-duration
532     // state for an arbitrarily long time. Also it&#39;s necessary for
533     // testing so we don&#39;t have a race with the font load.
534     switch (newStatus) {
535     case Status::Pending:
536         ASSERT_NOT_REACHED();
537         break;
538     case Status::Loading:
539         if (blockPeriodTimeout == 0_s)
540             setStatus(Status::TimedOut);
541         else if (std::isfinite(blockPeriodTimeout.value()))
542             m_timeoutTimer.startOneShot(blockPeriodTimeout);
543         break;
544     case Status::TimedOut:
545         if (swapPeriodTimeout == 0_s)
546             setStatus(Status::Failure);
547         else if (std::isfinite(swapPeriodTimeout.value()))
548             m_timeoutTimer.startOneShot(swapPeriodTimeout);
549         break;
550     case Status::Success:
551     case Status::Failure:
552         m_timeoutTimer.stop();
553         break;
554     }
555 }
556 
557 void CSSFontFace::fontLoaded(CSSFontFaceSource&amp;)
558 {
559     Ref&lt;CSSFontFace&gt; protectedThis(*this);
560 
561     fontLoadEventOccurred();
562 }
563 
564 bool CSSFontFace::shouldIgnoreFontLoadCompletions() const
565 {
566     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())
567         return m_fontSelector-&gt;document()-&gt;settings().shouldIgnoreFontLoadCompletions();
568     return false;
569 }
570 
571 void CSSFontFace::opportunisticallyStartFontDataURLLoading(CSSFontSelector&amp; fontSelector)
572 {
573     // We don&#39;t want to go crazy here and blow the cache. Usually these data URLs are the first item in the src: list, so let&#39;s just check that one.
574     if (!m_sources.isEmpty())
575         m_sources[0]-&gt;opportunisticallyStartFontDataURLLoading(fontSelector);
576 }
577 
578 size_t CSSFontFace::pump(ExternalResourceDownloadPolicy policy)
579 {
580     if (status() == Status::Failure)
581         return 0;
582 
583     size_t i;
584     for (i = 0; i &lt; m_sources.size(); ++i) {
585         auto&amp; source = m_sources[i];
586 
587         if (source-&gt;status() == CSSFontFaceSource::Status::Pending) {
588             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut);
589             // This is a little tricky. After calling CSSFontFace::font(Forbid), a font must never fail later in
590             // this turn of the runloop because the return value of CSSFontFace::font() shouldn&#39;t get nulled out
591             // from under an existing FontRanges object. Remote fonts are all downloaded asynchronously, so this
592             // isn&#39;t a problem for them because CSSFontFace::font() will always return the interstitial font.
593             // However, local fonts may synchronously fail when you call load() on them. Therefore, we have to call
594             // load() here in order to guarantee that, if the font synchronously fails, it happens now during the
595             // first call to CSSFontFace::font() and the FontRanges object sees a consistent view of the
596             // CSSFontFace. This means we eagerly create some internal font objects when they may not be needed,
597             // but it seems that this behavior is a requirement of the design of FontRanges. FIXME: Perhaps rethink
598             // this design.
599             if (policy == ExternalResourceDownloadPolicy::Allow || !source-&gt;requiresExternalResource()) {
<a name="19" id="anc19"></a><span class="line-modified">600                 if (policy == ExternalResourceDownloadPolicy::Allow &amp;&amp; m_status == Status::Pending)</span>
601                     setStatus(Status::Loading);
602                 source-&gt;load(m_fontSelector.get());
603             }
604         }
605 
606         switch (source-&gt;status()) {
607         case CSSFontFaceSource::Status::Pending:
608             ASSERT(policy == ExternalResourceDownloadPolicy::Forbid);
609             return i;
610         case CSSFontFaceSource::Status::Loading:
611             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut || m_status == Status::Failure);
<a name="20" id="anc20"></a><span class="line-modified">612             if (policy == ExternalResourceDownloadPolicy::Allow &amp;&amp; m_status == Status::Pending)</span>
613                 setStatus(Status::Loading);
614             return i;
615         case CSSFontFaceSource::Status::Success:
616             ASSERT(m_status == Status::Pending || m_status == Status::Loading || m_status == Status::TimedOut || m_status == Status::Success || m_status == Status::Failure);
617             if (m_status == Status::Pending)
618                 setStatus(Status::Loading);
619             if (m_status == Status::Loading || m_status == Status::TimedOut)
620                 setStatus(Status::Success);
621             return i;
622         case CSSFontFaceSource::Status::Failure:
<a name="21" id="anc21"></a><span class="line-modified">623             if (policy == ExternalResourceDownloadPolicy::Allow &amp;&amp; m_status == Status::Pending)</span>
624                 setStatus(Status::Loading);
625             break;
626         }
627     }
628     if (m_sources.isEmpty() &amp;&amp; m_status == Status::Pending)
629         setStatus(Status::Loading);
630     if (m_status == Status::Loading || m_status == Status::TimedOut)
631         setStatus(Status::Failure);
632     return m_sources.size();
633 }
634 
635 void CSSFontFace::load()
636 {
637     pump(ExternalResourceDownloadPolicy::Allow);
638 }
639 
640 static Font::Visibility visibility(CSSFontFace::Status status, CSSFontFace::FontLoadTiming timing)
641 {
642     switch (status) {
643     case CSSFontFace::Status::Pending:
644         return timing.blockPeriod == 0_s ? Font::Visibility::Visible : Font::Visibility::Invisible;
645     case CSSFontFace::Status::Loading:
646         return Font::Visibility::Invisible;
647     case CSSFontFace::Status::TimedOut:
648     case CSSFontFace::Status::Failure:
649     case CSSFontFace::Status::Success:
650     default:
651         return Font::Visibility::Visible;
652     }
653 }
654 
655 RefPtr&lt;Font&gt; CSSFontFace::font(const FontDescription&amp; fontDescription, bool syntheticBold, bool syntheticItalic, ExternalResourceDownloadPolicy policy)
656 {
657     if (computeFailureState())
658         return nullptr;
659 
660     Ref&lt;CSSFontFace&gt; protectedThis(*this);
661 
662     // Our status is derived from the first non-failed source. However, this source may
663     // return null from font(), which means we need to continue looping through the remainder
664     // of the sources to try to find a font to use. These subsequent tries should not affect
665     // our own state, though.
666     size_t startIndex = pump(policy);
667 
668     if (computeFailureState())
669         return nullptr;
670 
671     for (size_t i = startIndex; i &lt; m_sources.size(); ++i) {
672         auto&amp; source = m_sources[i];
673         if (source-&gt;status() == CSSFontFaceSource::Status::Pending &amp;&amp; (policy == ExternalResourceDownloadPolicy::Allow || !source-&gt;requiresExternalResource()))
674             source-&gt;load(m_fontSelector.get());
675 
676         switch (source-&gt;status()) {
677         case CSSFontFaceSource::Status::Pending:
678         case CSSFontFaceSource::Status::Loading: {
679             Font::Visibility visibility = WebCore::visibility(status(), fontLoadTiming());
680             return Font::create(FontCache::singleton().lastResortFallbackFont(fontDescription)-&gt;platformData(), Font::Origin::Local, Font::Interstitial::Yes, visibility);
681         }
682         case CSSFontFaceSource::Status::Success:
<a name="22" id="anc22"></a><span class="line-modified">683             if (auto result = source-&gt;font(fontDescription, syntheticBold, syntheticItalic, m_featureSettings, m_fontSelectionCapabilities)) {</span>
<span class="line-added">684                 auto* cachedFont = source-&gt;cachedFont();</span>
<span class="line-added">685                 result-&gt;setFontFaceData(cachedFont ? cachedFont-&gt;resourceBuffer() : nullptr);</span>
686                 return result;
<a name="23" id="anc23"></a><span class="line-added">687             }</span>
688             break;
689         case CSSFontFaceSource::Status::Failure:
690             break;
691         }
692     }
693 
694     return nullptr;
695 }
696 
697 bool CSSFontFace::purgeable() const
698 {
699     return cssConnection() &amp;&amp; m_mayBePurged;
700 }
701 
702 void CSSFontFace::updateStyleIfNeeded()
703 {
704     if (m_fontSelector &amp;&amp; m_fontSelector-&gt;document())
705         m_fontSelector-&gt;document()-&gt;updateStyleIfNeeded();
706 }
707 
708 #if ENABLE(SVG_FONTS)
709 bool CSSFontFace::hasSVGFontFaceSource() const
710 {
711     size_t size = m_sources.size();
712     for (size_t i = 0; i &lt; size; i++) {
713         if (m_sources[i]-&gt;isSVGFontFaceSource())
714             return true;
715     }
716     return false;
717 }
718 #endif
719 
<a name="24" id="anc24"></a><span class="line-added">720 void CSSFontFace::setErrorState()</span>
<span class="line-added">721 {</span>
<span class="line-added">722     switch (m_status) {</span>
<span class="line-added">723     case Status::Pending:</span>
<span class="line-added">724         setStatus(Status::Loading);</span>
<span class="line-added">725         break;</span>
<span class="line-added">726     case Status::Success:</span>
<span class="line-added">727         ASSERT_NOT_REACHED();</span>
<span class="line-added">728         break;</span>
<span class="line-added">729     case Status::Failure:</span>
<span class="line-added">730         return;</span>
<span class="line-added">731     default:</span>
<span class="line-added">732         break;</span>
<span class="line-added">733     }</span>
<span class="line-added">734 </span>
<span class="line-added">735     setStatus(Status::Failure);</span>
<span class="line-added">736 }</span>
<span class="line-added">737 </span>
738 }
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
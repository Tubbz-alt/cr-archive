<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/SlotAssignment.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SlotAssignment.h&quot;
 28 
 29 
 30 #include &quot;HTMLSlotElement.h&quot;
 31 #include &quot;ShadowRoot.h&quot;
 32 #include &quot;TypedElementDescendantIterator.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 using namespace HTMLNames;
 37 
 38 static const AtomString&amp; slotNameFromAttributeValue(const AtomString&amp; value)
 39 {
 40     return value == nullAtom() ? SlotAssignment::defaultSlotName() : value;
 41 }
 42 
 43 static const AtomString&amp; slotNameFromSlotAttribute(const Node&amp; child)
 44 {
 45     if (is&lt;Text&gt;(child))
 46         return SlotAssignment::defaultSlotName();
 47 
 48     return slotNameFromAttributeValue(downcast&lt;Element&gt;(child).attributeWithoutSynchronization(slotAttr));
 49 }
 50 
<a name="1" id="anc1"></a><span class="line-modified"> 51 #if ASSERT_ENABLED</span>
 52 static HTMLSlotElement* findSlotElement(ShadowRoot&amp; shadowRoot, const AtomString&amp; slotName)
 53 {
 54     for (auto&amp; slotElement : descendantsOfType&lt;HTMLSlotElement&gt;(shadowRoot)) {
 55         if (slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr)) == slotName)
 56             return &amp;slotElement;
 57     }
 58     return nullptr;
 59 }
<a name="2" id="anc2"></a><span class="line-modified"> 60 #endif // ASSERT_ENABLED</span>
 61 
 62 static HTMLSlotElement* nextSlotElementSkippingSubtree(ContainerNode&amp; startingNode, ContainerNode* skippedSubtree)
 63 {
 64     Node* node = &amp;startingNode;
 65     do {
 66         if (UNLIKELY(node == skippedSubtree))
 67             node = NodeTraversal::nextSkippingChildren(*node);
 68         else
 69             node = NodeTraversal::next(*node);
 70     } while (node &amp;&amp; !is&lt;HTMLSlotElement&gt;(node));
 71     return downcast&lt;HTMLSlotElement&gt;(node);
 72 }
 73 
 74 SlotAssignment::SlotAssignment() = default;
 75 
 76 SlotAssignment::~SlotAssignment() = default;
 77 
 78 HTMLSlotElement* SlotAssignment::findAssignedSlot(const Node&amp; node, ShadowRoot&amp; shadowRoot)
 79 {
 80     if (!is&lt;Text&gt;(node) &amp;&amp; !is&lt;Element&gt;(node))
 81         return nullptr;
 82 
 83     auto* slot = m_slots.get(slotNameForHostChild(node));
 84     if (!slot)
 85         return nullptr;
 86 
 87     return findFirstSlotElement(*slot, shadowRoot);
 88 }
 89 
 90 inline bool SlotAssignment::hasAssignedNodes(ShadowRoot&amp; shadowRoot, Slot&amp; slot)
 91 {
 92     if (!m_slotAssignmentsIsValid)
 93         assignSlots(shadowRoot);
 94     return !slot.assignedNodes.isEmpty();
 95 }
 96 
 97 void SlotAssignment::renameSlotElement(HTMLSlotElement&amp; slotElement, const AtomString&amp; oldName, const AtomString&amp; newName, ShadowRoot&amp; shadowRoot)
 98 {
 99     ASSERT(m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
100 
101     m_slotMutationVersion++;
102 
103     removeSlotElementByName(oldName, slotElement, nullptr, shadowRoot);
104     addSlotElementByName(newName, slotElement, shadowRoot);
105 }
106 
107 void SlotAssignment::addSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slotElement, ShadowRoot&amp; shadowRoot)
108 {
<a name="3" id="anc3"></a><span class="line-modified">109 #if ASSERT_ENABLED</span>
110     ASSERT(!m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
111     m_slotElementsForConsistencyCheck.add(&amp;slotElement);
112 #endif
113 
114     // FIXME: We should be able to do a targeted reconstruction.
115     shadowRoot.host()-&gt;invalidateStyleAndRenderersForSubtree();
116 
117     auto&amp; slotName = slotNameFromAttributeValue(name);
118     auto addResult = m_slots.ensure(slotName, [&amp;] {
<a name="4" id="anc4"></a><span class="line-modified">119         m_slotAssignmentsIsValid = false;</span>



120         return makeUnique&lt;Slot&gt;();
121     });
122     auto&amp; slot = *addResult.iterator-&gt;value;
123     bool needsSlotchangeEvent = shadowRoot.shouldFireSlotchangeEvent() &amp;&amp; hasAssignedNodes(shadowRoot, slot);
124 
125     slot.elementCount++;
126     if (slot.elementCount == 1) {
127         slot.element = makeWeakPtr(slotElement);
128         if (needsSlotchangeEvent)
129             slotElement.enqueueSlotChangeEvent();
130         return;
131     }
132 
133     if (!needsSlotchangeEvent) {
134         ASSERT(slot.element || m_needsToResolveSlotElements);
135         slot.element = nullptr;
136         m_needsToResolveSlotElements = true;
137         return;
138     }
139 
140     resolveSlotsAfterSlotMutation(shadowRoot, SlotMutationType::Insertion);
141 }
142 
143 void SlotAssignment::removeSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slotElement, ContainerNode* oldParentOfRemovedTreeForRemoval, ShadowRoot&amp; shadowRoot)
144 {
<a name="5" id="anc5"></a><span class="line-modified">145 #if ASSERT_ENABLED</span>
146     ASSERT(m_slotElementsForConsistencyCheck.contains(&amp;slotElement));
147     m_slotElementsForConsistencyCheck.remove(&amp;slotElement);
148 #endif
149 
150     if (auto* host = shadowRoot.host()) // FIXME: We should be able to do a targeted reconstruction.
151         host-&gt;invalidateStyleAndRenderersForSubtree();
152 
153     auto* slot = m_slots.get(slotNameFromAttributeValue(name));
154     RELEASE_ASSERT(slot &amp;&amp; slot-&gt;hasSlotElements());
155     bool needsSlotchangeEvent = shadowRoot.shouldFireSlotchangeEvent() &amp;&amp; hasAssignedNodes(shadowRoot, *slot);
156 
157     slot-&gt;elementCount--;
158     if (!slot-&gt;elementCount) {
159         slot-&gt;element = nullptr;
160         if (needsSlotchangeEvent &amp;&amp; m_slotResolutionVersion != m_slotMutationVersion)
161             slotElement.enqueueSlotChangeEvent();
162         return;
163     }
164 
165     if (!needsSlotchangeEvent) {
166         ASSERT(slot-&gt;element || m_needsToResolveSlotElements);
167         slot-&gt;element = nullptr;
168         m_needsToResolveSlotElements = true;
169         return;
170     }
171 
172     bool elementWasRenamed = !oldParentOfRemovedTreeForRemoval;
173     if (elementWasRenamed &amp;&amp; slot-&gt;element == &amp;slotElement)
174         slotElement.enqueueSlotChangeEvent();
175 
176     // A previous invocation to resolveSlotsAfterSlotMutation during this removal has updated this slot.
177     ASSERT(slot-&gt;element || (m_slotResolutionVersion == m_slotMutationVersion &amp;&amp; !findSlotElement(shadowRoot, name)));
178     if (slot-&gt;element) {
179         resolveSlotsAfterSlotMutation(shadowRoot, elementWasRenamed ? SlotMutationType::Insertion : SlotMutationType::Removal,
180             m_willBeRemovingAllChildren ? oldParentOfRemovedTreeForRemoval : nullptr);
181     }
182 
183     if (slot-&gt;oldElement == &amp;slotElement) {
184         slotElement.enqueueSlotChangeEvent();
185         slot-&gt;oldElement = nullptr;
186     }
187 }
188 
189 void SlotAssignment::resolveSlotsAfterSlotMutation(ShadowRoot&amp; shadowRoot, SlotMutationType mutationType, ContainerNode* subtreeToSkip)
190 {
191     if (m_slotResolutionVersion == m_slotMutationVersion)
192         return;
193     m_slotResolutionVersion = m_slotMutationVersion;
194 
195     ASSERT(!subtreeToSkip || mutationType == SlotMutationType::Removal);
196     m_needsToResolveSlotElements = false;
197 
198     for (auto&amp; slot : m_slots.values())
199         slot-&gt;seenFirstElement = false;
200 
201     unsigned slotCount = 0;
202     HTMLSlotElement* currentElement = nextSlotElementSkippingSubtree(shadowRoot, subtreeToSkip);
203     for (; currentElement; currentElement = nextSlotElementSkippingSubtree(*currentElement, subtreeToSkip)) {
204         auto&amp; currentSlotName = slotNameFromAttributeValue(currentElement-&gt;attributeWithoutSynchronization(nameAttr));
205         auto* currentSlot = m_slots.get(currentSlotName);
206         if (!currentSlot) {
207             // A new slot may have been inserted with this node but appears later in the tree order.
208             // Such a slot would go through the fast path in addSlotElementByName,
209             // and any subsequently inserted slot of the same name would not result in any slotchange or invokation of this function.
210             ASSERT(mutationType == SlotMutationType::Insertion);
211             continue;
212         }
213         if (currentSlot-&gt;seenFirstElement) {
214             if (mutationType == SlotMutationType::Insertion &amp;&amp; currentSlot-&gt;oldElement == currentElement) {
215                 currentElement-&gt;enqueueSlotChangeEvent();
216                 currentSlot-&gt;oldElement = nullptr;
217             }
218             continue;
219         }
220         currentSlot-&gt;seenFirstElement = true;
221         slotCount++;
222         ASSERT(currentSlot-&gt;element || !hasAssignedNodes(shadowRoot, *currentSlot));
223         if (currentSlot-&gt;element != currentElement) {
224             if (hasAssignedNodes(shadowRoot, *currentSlot)) {
225                 currentSlot-&gt;oldElement = WTFMove(currentSlot-&gt;element);
226                 currentElement-&gt;enqueueSlotChangeEvent();
227             }
228             currentSlot-&gt;element = makeWeakPtr(*currentElement);
229         }
230     }
231 
232     if (slotCount == m_slots.size())
233         return;
234 
235     if (mutationType == SlotMutationType::Insertion) {
236         // This code path is taken only when continue above for !currentSlot is taken.
237         // i.e. there is a new slot being inserted into the tree but we have yet to invoke addSlotElementByName on it.
<a name="6" id="anc6"></a><span class="line-modified">238 #if ASSERT_ENABLED</span>
239         for (auto&amp; entry : m_slots)
240             ASSERT(entry.value-&gt;seenFirstElement || !findSlotElement(shadowRoot, entry.key));
241 #endif
242         return;
243     }
244 
245     for (auto&amp; slot : m_slots.values()) {
246         if (slot-&gt;seenFirstElement)
247             continue;
248         if (!slot-&gt;elementCount) {
249             // Taken the fast path for removal.
250             ASSERT(!slot-&gt;element);
251             continue;
252         }
253         // All slot elements have been removed for this slot.
254         slot-&gt;seenFirstElement = true;
255         ASSERT(slot-&gt;element);
256         if (hasAssignedNodes(shadowRoot, *slot))
257             slot-&gt;oldElement = WTFMove(slot-&gt;element);
258         slot-&gt;element = nullptr;
259     }
260 }
261 
262 void SlotAssignment::slotFallbackDidChange(HTMLSlotElement&amp; slotElement, ShadowRoot&amp; shadowRoot)
263 {
264     if (shadowRoot.mode() == ShadowRootMode::UserAgent)
265         return;
266 
267     bool usesFallbackContent = !assignedNodesForSlot(slotElement, shadowRoot);
268     if (usesFallbackContent)
269         slotElement.enqueueSlotChangeEvent();
270 }
271 
272 void SlotAssignment::resolveSlotsBeforeNodeInsertionOrRemoval(ShadowRoot&amp; shadowRoot)
273 {
274     ASSERT(shadowRoot.shouldFireSlotchangeEvent());
275     m_slotMutationVersion++;
276     m_willBeRemovingAllChildren = false;
277     if (m_needsToResolveSlotElements)
278         resolveAllSlotElements(shadowRoot);
279 }
280 
281 void SlotAssignment::willRemoveAllChildren(ShadowRoot&amp; shadowRoot)
282 {
283     m_slotMutationVersion++;
284     m_willBeRemovingAllChildren = true;
285     if (m_needsToResolveSlotElements)
286         resolveAllSlotElements(shadowRoot);
287 }
288 
289 void SlotAssignment::didChangeSlot(const AtomString&amp; slotAttrValue, ShadowRoot&amp; shadowRoot)
290 {
291     auto&amp; slotName = slotNameFromAttributeValue(slotAttrValue);
292     auto* slot = m_slots.get(slotName);
293     if (!slot)
294         return;
295 
296     slot-&gt;assignedNodes.clear();
297     m_slotAssignmentsIsValid = false;
298 
299     auto slotElement = makeRefPtr(findFirstSlotElement(*slot, shadowRoot));
300     if (!slotElement)
301         return;
302 
303     shadowRoot.host()-&gt;invalidateStyleAndRenderersForSubtree();
304 
305     if (shadowRoot.shouldFireSlotchangeEvent())
306         slotElement-&gt;enqueueSlotChangeEvent();
307 }
308 
309 void SlotAssignment::hostChildElementDidChange(const Element&amp; childElement, ShadowRoot&amp; shadowRoot)
310 {
311     didChangeSlot(childElement.attributeWithoutSynchronization(slotAttr), shadowRoot);
312 }
313 
314 const Vector&lt;Node*&gt;* SlotAssignment::assignedNodesForSlot(const HTMLSlotElement&amp; slotElement, ShadowRoot&amp; shadowRoot)
315 {
316     ASSERT(slotElement.containingShadowRoot() == &amp;shadowRoot);
317     const AtomString&amp; slotName = slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr));
318     auto* slot = m_slots.get(slotName);
319     RELEASE_ASSERT(slot);
320 
321     if (!m_slotAssignmentsIsValid)
322         assignSlots(shadowRoot);
323 
324     if (slot-&gt;assignedNodes.isEmpty())
325         return nullptr;
326 
327     RELEASE_ASSERT(slot-&gt;hasSlotElements());
328     if (slot-&gt;hasDuplicatedSlotElements() &amp;&amp; findFirstSlotElement(*slot, shadowRoot) != &amp;slotElement)
329         return nullptr;
330 
331     return &amp;slot-&gt;assignedNodes;
332 }
333 
334 const AtomString&amp; SlotAssignment::slotNameForHostChild(const Node&amp; child) const
335 {
336     return slotNameFromSlotAttribute(child);
337 }
338 
339 HTMLSlotElement* SlotAssignment::findFirstSlotElement(Slot&amp; slot, ShadowRoot&amp; shadowRoot)
340 {
341     if (slot.shouldResolveSlotElement())
342         resolveAllSlotElements(shadowRoot);
343 
<a name="7" id="anc7"></a>
344     ASSERT(!slot.element || m_slotElementsForConsistencyCheck.contains(slot.element.get()));
345     ASSERT(!!slot.element == !!slot.elementCount);
<a name="8" id="anc8"></a>
346 
347     return slot.element.get();
348 }
349 
350 void SlotAssignment::resolveAllSlotElements(ShadowRoot&amp; shadowRoot)
351 {
352     ASSERT(m_needsToResolveSlotElements);
353     m_needsToResolveSlotElements = false;
354 
355     // FIXME: It&#39;s inefficient to reset all values. We should be able to void this in common case.
356     for (auto&amp; entry : m_slots)
357         entry.value-&gt;seenFirstElement = false;
358 
359     unsigned slotCount = m_slots.size();
360     for (auto&amp; slotElement : descendantsOfType&lt;HTMLSlotElement&gt;(shadowRoot)) {
361         auto&amp; slotName = slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr));
362 
363         auto* slot = m_slots.get(slotName);
364         RELEASE_ASSERT(slot); // slot must have been created when a slot was inserted.
365 
366         if (slot-&gt;seenFirstElement)
367             continue;
368         slot-&gt;seenFirstElement = true;
369 
370         slot-&gt;element = makeWeakPtr(slotElement);
371         slotCount--;
372         if (!slotCount)
373             break;
374     }
375 }
376 
377 void SlotAssignment::assignSlots(ShadowRoot&amp; shadowRoot)
378 {
379     ASSERT(!m_slotAssignmentsIsValid);
380     m_slotAssignmentsIsValid = true;
381 
382     for (auto&amp; entry : m_slots)
383         entry.value-&gt;assignedNodes.shrink(0);
384 
385     auto&amp; host = *shadowRoot.host();
386     for (auto* child = host.firstChild(); child; child = child-&gt;nextSibling()) {
387         if (!is&lt;Text&gt;(*child) &amp;&amp; !is&lt;Element&gt;(*child))
388             continue;
389         auto slotName = slotNameForHostChild(*child);
390         assignToSlot(*child, slotName);
391     }
392 
393     for (auto&amp; entry : m_slots)
394         entry.value-&gt;assignedNodes.shrinkToFit();
395 }
396 
397 void SlotAssignment::assignToSlot(Node&amp; child, const AtomString&amp; slotName)
398 {
399     ASSERT(!slotName.isNull());
400     if (slotName == defaultSlotName()) {
401         auto defaultSlotEntry = m_slots.find(defaultSlotName());
402         if (defaultSlotEntry != m_slots.end())
403             defaultSlotEntry-&gt;value-&gt;assignedNodes.append(&amp;child);
404         return;
405     }
406 
407     auto addResult = m_slots.ensure(slotName, [] {
408         return makeUnique&lt;Slot&gt;();
409     });
410     addResult.iterator-&gt;value-&gt;assignedNodes.append(&amp;child);
411 }
412 
413 }
414 
415 
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
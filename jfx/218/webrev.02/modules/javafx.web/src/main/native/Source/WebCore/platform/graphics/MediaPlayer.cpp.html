<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;MediaPlayer.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ContentType.h&quot;
  32 #include &quot;DeprecatedGlobalSettings.h&quot;
  33 #include &quot;Document.h&quot;
  34 #include &quot;IntRect.h&quot;
  35 #include &quot;Logging.h&quot;
  36 #include &quot;MIMETypeRegistry.h&quot;
  37 #include &quot;MediaPlayerPrivate.h&quot;
  38 #include &quot;PlatformTimeRanges.h&quot;
  39 #include &lt;wtf/NeverDestroyed.h&gt;
  40 #include &lt;wtf/text/CString.h&gt;
  41 
  42 #if ENABLE(VIDEO_TRACK)
  43 #include &quot;InbandTextTrackPrivate.h&quot;
  44 #endif
  45 
  46 #if ENABLE(MEDIA_SOURCE)
  47 #include &quot;MediaSourcePrivateClient.h&quot;
  48 #endif
  49 
  50 #if ENABLE(MEDIA_STREAM)
  51 #include &quot;MediaStreamPrivate.h&quot;
  52 #endif
  53 
  54 #if USE(GSTREAMER)
  55 #include &quot;MediaPlayerPrivateGStreamer.h&quot;
  56 #define PlatformMediaEngineClassName MediaPlayerPrivateGStreamer
  57 #if ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
  58 #include &quot;MediaPlayerPrivateGStreamerMSE.h&quot;
  59 #endif
  60 #endif // USE(GSTREAMER)
  61 
  62 #if USE(MEDIA_FOUNDATION)
  63 #include &quot;MediaPlayerPrivateMediaFoundation.h&quot;
  64 #define PlatformMediaEngineClassName MediaPlayerPrivateMediaFoundation
  65 #endif
  66 
  67 #if PLATFORM(COCOA)
  68 
  69 #if USE(AVFOUNDATION)
  70 #include &quot;MediaPlayerPrivateAVFoundationObjC.h&quot;
  71 #endif
  72 
  73 #if ENABLE(MEDIA_SOURCE) &amp;&amp; USE(AVFOUNDATION)
  74 #include &quot;MediaPlayerPrivateMediaSourceAVFObjC.h&quot;
  75 #endif
  76 
  77 #if ENABLE(MEDIA_STREAM) &amp;&amp; USE(AVFOUNDATION)
  78 #include &quot;MediaPlayerPrivateMediaStreamAVFObjC.h&quot;
  79 #endif
  80 
  81 #endif // PLATFORM(COCOA)
  82 
  83 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION) &amp;&amp; !USE(GSTREAMER)
  84 #include &quot;MediaPlayerPrivateAVFoundationCF.h&quot;
  85 #endif // USE(AVFOUNDATION)
  86 
  87 #if PLATFORM(JAVA)
  88 #include &quot;MediaPlayerPrivateJava.h&quot;
  89 #define PlatformMediaEngineClassName MediaPlayerPrivate
  90 #endif  // PLATFORM(JAVA)
  91 
  92 #if USE(EXTERNAL_HOLEPUNCH)
  93 #include &quot;MediaPlayerPrivateHolePunch.h&quot;
  94 #endif
  95 
  96 namespace WebCore {
  97 
  98 // a null player to make MediaPlayer logic simpler
  99 
 100 class NullMediaPlayerPrivate final : public MediaPlayerPrivateInterface {
 101 public:
 102     explicit NullMediaPlayerPrivate(MediaPlayer*) { }
 103 
 104     void load(const String&amp;) final { }
 105 #if ENABLE(MEDIA_SOURCE)
 106     void load(const String&amp;, MediaSourcePrivateClient*) final { }
 107 #endif
 108 #if ENABLE(MEDIA_STREAM)
 109     void load(MediaStreamPrivate&amp;) final { }
 110 #endif
 111     void cancelLoad() final { }
 112 
 113     void prepareToPlay() final { }
 114     void play() final { }
 115     void pause() final { }
 116 
 117     PlatformLayer* platformLayer() const final { return nullptr; }
 118 
 119     FloatSize naturalSize() const final { return FloatSize(); }
 120 
 121     bool hasVideo() const final { return false; }
 122     bool hasAudio() const final { return false; }
 123 
 124     void setVisible(bool) final { }
 125 
 126     double durationDouble() const final { return 0; }
 127 
 128     double currentTimeDouble() const final { return 0; }
 129     void seekDouble(double) final { }
 130     bool seeking() const final { return false; }
 131 
 132     void setRateDouble(double) final { }
 133     void setPreservesPitch(bool) final { }
 134     bool paused() const final { return true; }
 135 
 136     void setVolumeDouble(double) final { }
 137 
 138     void setMuted(bool) final { }
 139 
 140     bool hasClosedCaptions() const final { return false; }
 141     void setClosedCaptionsVisible(bool) final { };
 142 
 143     MediaPlayer::NetworkState networkState() const final { return MediaPlayer::NetworkState::Empty; }
 144     MediaPlayer::ReadyState readyState() const final { return MediaPlayer::ReadyState::HaveNothing; }
 145 
 146     float maxTimeSeekable() const final { return 0; }
 147     double minTimeSeekable() const final { return 0; }
 148     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const final { return makeUnique&lt;PlatformTimeRanges&gt;(); }
 149 
 150     double seekableTimeRangesLastModifiedTime() const final { return 0; }
 151     double liveUpdateInterval() const final { return 0; }
 152 
 153     unsigned long long totalBytes() const final { return 0; }
 154     bool didLoadingProgress() const final { return false; }
 155 
 156     void setSize(const IntSize&amp;) final { }
 157 
 158     void paint(GraphicsContext&amp;, const FloatRect&amp;) final { }
 159 
 160     bool hasSingleSecurityOrigin() const final { return true; }
 161 };
 162 
 163 #if !RELEASE_LOG_DISABLED
 164 static RefPtr&lt;Logger&gt;&amp; nullLogger()
 165 {
 166     static NeverDestroyed&lt;RefPtr&lt;Logger&gt;&gt; logger;
 167     return logger;
 168 }
 169 #endif
 170 
 171 static const Vector&lt;WebCore::ContentType&gt;&amp; nullContentTypeVector()
 172 {
 173     static NeverDestroyed&lt;Vector&lt;WebCore::ContentType&gt;&gt; vector;
 174     return vector;
 175 }
 176 
 177 class NullMediaPlayerClient : public MediaPlayerClient {
 178 private:
 179 #if !RELEASE_LOG_DISABLED
 180     const Logger&amp; mediaPlayerLogger() final
 181     {
 182         if (!nullLogger().get()) {
 183             nullLogger() = Logger::create(this);
 184             nullLogger()-&gt;setEnabled(this, false);
 185         }
 186 
 187         return *nullLogger().get();
 188     }
 189 #endif
 190 
 191     const Vector&lt;WebCore::ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const final { return nullContentTypeVector(); }
 192 };
 193 
 194 
 195 const Vector&lt;ContentType&gt;&amp; MediaPlayerClient::mediaContentTypesRequiringHardwareSupport() const
 196 {
 197     static NeverDestroyed&lt;Vector&lt;ContentType&gt;&gt; contentTypes;
 198     return contentTypes;
 199 }
 200 
 201 static MediaPlayerClient&amp; nullMediaPlayerClient()
 202 {
 203     static NeverDestroyed&lt;NullMediaPlayerClient&gt; client;
 204     return client.get();
 205 }
 206 
 207 // engine support
 208 
 209 static void addMediaEngine(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp;);
 210 
 211 static Lock mediaEngineVectorLock;
 212 
 213 static bool&amp; haveMediaEnginesVector()
 214 {
 215     static bool haveVector;
 216     return haveVector;
 217 }
 218 
 219 static Vector&lt;std::unique_ptr&lt;MediaPlayerFactory&gt;&gt;&amp; mutableInstalledMediaEnginesVector()
 220 {
 221     static NeverDestroyed&lt;Vector&lt;std::unique_ptr&lt;MediaPlayerFactory&gt;&gt;&gt; installedEngines;
 222     return installedEngines;
 223 }
 224 
 225 static RemoteMediaPlayerSupport::RegisterRemotePlayerCallback&amp; registerRemotePlayerCallback()
 226 {
 227     static NeverDestroyed&lt;RemoteMediaPlayerSupport::RegisterRemotePlayerCallback&gt; callback;
 228     return callback;
 229 }
 230 
 231 void RemoteMediaPlayerSupport::setRegisterRemotePlayerCallback(RegisterRemotePlayerCallback&amp;&amp; callback)
 232 {
 233     registerRemotePlayerCallback() = WTFMove(callback);
 234 }
 235 
 236 static void buildMediaEnginesVector()
 237 {
 238     ASSERT(mediaEngineVectorLock.isLocked());
 239 
 240 #if USE(AVFOUNDATION)
 241 
 242     if (DeprecatedGlobalSettings::isAVFoundationEnabled()) {
 243 
 244         auto&amp; registerRemoteEngine = registerRemotePlayerCallback();
 245 #if PLATFORM(COCOA)
 246         if (registerRemoteEngine)
 247             registerRemoteEngine(addMediaEngine, MediaPlayerEnums::MediaEngineIdentifier::AVFoundation);
 248         else
 249             MediaPlayerPrivateAVFoundationObjC::registerMediaEngine(addMediaEngine);
 250 #endif
 251 
 252 #if ENABLE(MEDIA_SOURCE)
 253         MediaPlayerPrivateMediaSourceAVFObjC::registerMediaEngine(addMediaEngine);
 254 #endif
 255 
 256 #if ENABLE(MEDIA_STREAM)
 257         MediaPlayerPrivateMediaStreamAVFObjC::registerMediaEngine(addMediaEngine);
 258 #endif
 259 
 260 #if PLATFORM(WIN)
 261         MediaPlayerPrivateAVFoundationCF::registerMediaEngine(addMediaEngine);
 262 #endif
 263     }
 264 #endif // USE(AVFOUNDATION)
 265 
 266 #if defined(PlatformMediaEngineClassName)
 267 #if USE(GSTREAMER)
 268     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 269 #endif
 270         PlatformMediaEngineClassName::registerMediaEngine(addMediaEngine);
 271 #endif
 272 
 273 #if USE(GSTREAMER) &amp;&amp; ENABLE(MEDIA_SOURCE) &amp;&amp; ENABLE(VIDEO_TRACK)
 274     if (DeprecatedGlobalSettings::isGStreamerEnabled())
 275         MediaPlayerPrivateGStreamerMSE::registerMediaEngine(addMediaEngine);
 276 #endif
 277 
 278 #if USE(EXTERNAL_HOLEPUNCH)
 279     MediaPlayerPrivateHolePunch::registerMediaEngine(addMediaEngine);
 280 #endif
 281 
 282     haveMediaEnginesVector() = true;
 283 }
 284 
 285 static const Vector&lt;std::unique_ptr&lt;MediaPlayerFactory&gt;&gt;&amp; installedMediaEngines()
 286 {
 287     {
 288         auto locker = holdLock(mediaEngineVectorLock);
 289         if (!haveMediaEnginesVector())
 290             buildMediaEnginesVector();
 291     }
 292 
 293     return mutableInstalledMediaEnginesVector();
 294 }
 295 
 296 static void addMediaEngine(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp; factory)
 297 {
 298     mutableInstalledMediaEnginesVector().append(WTFMove(factory));
 299 }
 300 
 301 static const AtomString&amp; applicationOctetStream()
 302 {
 303     static NeverDestroyed&lt;const AtomString&gt; applicationOctetStream(&quot;application/octet-stream&quot;, AtomString::ConstructFromLiteral);
 304     return applicationOctetStream;
 305 }
 306 
 307 static const AtomString&amp; textPlain()
 308 {
 309     static NeverDestroyed&lt;const AtomString&gt; textPlain(&quot;text/plain&quot;, AtomString::ConstructFromLiteral);
 310     return textPlain;
 311 }
 312 
 313 const MediaPlayerFactory* MediaPlayer::mediaEngine(MediaPlayerEnums::MediaEngineIdentifier identifier)
 314 {
 315     auto&amp; engines = installedMediaEngines();
 316     auto currentIndex = engines.findMatching([identifier] (auto&amp; engine) {
 317         return engine-&gt;identifier() == identifier;
 318     });
 319 
 320     if (currentIndex == notFound) {
 321         ASSERT_NOT_REACHED();
 322         return nullptr;
 323     }
 324 
 325     return engines[currentIndex].get();
 326 }
 327 
 328 static const MediaPlayerFactory* bestMediaEngineForSupportParameters(const MediaEngineSupportParameters&amp; parameters, const MediaPlayerFactory* current = nullptr)
 329 {
 330     if (parameters.type.isEmpty() &amp;&amp; !parameters.isMediaSource &amp;&amp; !parameters.isMediaStream)
 331         return nullptr;
 332 
 333     // 4.8.10.3 MIME types - In the absence of a specification to the contrary, the MIME type &quot;application/octet-stream&quot;
 334     // when used with parameters, e.g. &quot;application/octet-stream;codecs=theora&quot;, is a type that the user agent knows
 335     // it cannot render.
 336     if (parameters.type.containerType() == applicationOctetStream()) {
 337         if (!parameters.type.codecs().isEmpty())
 338             return nullptr;
 339     }
 340 
 341     const MediaPlayerFactory* foundEngine = nullptr;
 342     MediaPlayer::SupportsType supported = MediaPlayer::SupportsType::IsNotSupported;
 343     for (auto&amp; engine : installedMediaEngines()) {
 344         if (current) {
 345             if (current == engine.get())
 346                 current = nullptr;
 347             continue;
 348         }
 349         MediaPlayer::SupportsType engineSupport = engine-&gt;supportsTypeAndCodecs(parameters);
 350         if (engineSupport &gt; supported) {
 351             supported = engineSupport;
 352             foundEngine = engine.get();
 353         }
 354     }
 355 
 356     return foundEngine;
 357 }
 358 
 359 const MediaPlayerFactory* MediaPlayer::nextMediaEngine(const MediaPlayerFactory* current)
 360 {
 361     if (m_activeEngineIdentifier) {
 362         auto* engine = mediaEngine(m_activeEngineIdentifier.value());
 363         return current != engine ? engine : nullptr;
 364     }
 365 
 366     auto&amp; engines = installedMediaEngines();
 367     if (engines.isEmpty())
 368         return nullptr;
 369 
 370     if (!current)
 371         return engines.first().get();
 372 
 373     auto currentIndex = engines.findMatching([current] (auto&amp; engine) {
 374         return engine.get() == current;
 375     });
 376     if (currentIndex == notFound) {
 377         ASSERT_NOT_REACHED();
 378         return nullptr;
 379     }
 380 
 381     if (currentIndex + 1 &gt;= engines.size())
 382         return nullptr;
 383 
 384     return engines[currentIndex + 1].get();
 385 }
 386 
 387 // media player
 388 
 389 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client)
 390 {
 391     return adoptRef(*new MediaPlayer(client));
 392 }
 393 
 394 Ref&lt;MediaPlayer&gt; MediaPlayer::create(MediaPlayerClient&amp; client, MediaPlayerEnums::MediaEngineIdentifier mediaEngineIdentifier)
 395 {
 396     return adoptRef(*new MediaPlayer(client, mediaEngineIdentifier));
 397 }
 398 
 399 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client)
 400     : m_client(&amp;client)
 401     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
 402     , m_private(makeUnique&lt;NullMediaPlayerPrivate&gt;(this))
 403 {
 404 }
 405 
 406 MediaPlayer::MediaPlayer(MediaPlayerClient&amp; client, MediaPlayerEnums::MediaEngineIdentifier mediaEngineIdentifier)
 407     : m_client(&amp;client)
 408     , m_reloadTimer(*this, &amp;MediaPlayer::reloadTimerFired)
 409     , m_private(makeUnique&lt;NullMediaPlayerPrivate&gt;(this))
 410     , m_activeEngineIdentifier(mediaEngineIdentifier)
 411 {
 412 }
 413 
 414 MediaPlayer::~MediaPlayer()
 415 {
 416     ASSERT(!m_initializingMediaEngine);
 417 }
 418 
 419 void MediaPlayer::invalidate()
 420 {
 421     m_client = &amp;nullMediaPlayerClient();
 422 }
 423 
 424 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, const String&amp; keySystem)
 425 {
 426     ASSERT(!m_reloadTimer.isActive());
 427 
 428     // Protect against MediaPlayer being destroyed during a MediaPlayerClient callback.
 429     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 430 
 431     m_contentType = contentType;
 432     m_url = url;
 433     m_keySystem = keySystem.convertToASCIILowercase();
 434     m_contentMIMETypeWasInferredFromExtension = false;
 435 
 436 #if ENABLE(MEDIA_SOURCE)
 437     m_mediaSource = nullptr;
 438 #endif
 439 #if ENABLE(MEDIA_STREAM)
 440     m_mediaStream = nullptr;
 441 #endif
 442 
 443     // If the MIME type is missing or is not meaningful, try to figure it out from the URL.
 444     AtomString containerType = m_contentType.containerType();
 445     if (containerType.isEmpty() || containerType == applicationOctetStream() || containerType == textPlain()) {
 446         if (m_url.protocolIsData())
 447             m_contentType = ContentType(mimeTypeFromDataURL(m_url.string()));
 448         else {
 449             String lastPathComponent = url.lastPathComponent();
 450             size_t pos = lastPathComponent.reverseFind(&#39;.&#39;);
 451             if (pos != notFound) {
 452                 String extension = lastPathComponent.substring(pos + 1);
 453                 String mediaType = MIMETypeRegistry::getMediaMIMETypeForExtension(extension);
 454                 if (!mediaType.isEmpty()) {
 455                     m_contentType = ContentType { WTFMove(mediaType) };
 456                     m_contentMIMETypeWasInferredFromExtension = true;
 457                 }
 458             }
 459         }
 460     }
 461 
 462     loadWithNextMediaEngine(nullptr);
 463     return m_currentMediaEngine;
 464 }
 465 
 466 #if ENABLE(MEDIA_SOURCE)
 467 bool MediaPlayer::load(const URL&amp; url, const ContentType&amp; contentType, MediaSourcePrivateClient* mediaSource)
 468 {
 469     ASSERT(!m_reloadTimer.isActive());
 470     ASSERT(mediaSource);
 471 
 472     m_mediaSource = mediaSource;
 473     m_contentType = contentType;
 474     m_url = url;
 475     m_keySystem = emptyString();
 476     m_contentMIMETypeWasInferredFromExtension = false;
 477     loadWithNextMediaEngine(nullptr);
 478     return m_currentMediaEngine;
 479 }
 480 #endif
 481 
 482 #if ENABLE(MEDIA_STREAM)
 483 bool MediaPlayer::load(MediaStreamPrivate&amp; mediaStream)
 484 {
 485     ASSERT(!m_reloadTimer.isActive());
 486 
 487     m_mediaStream = &amp;mediaStream;
 488     m_keySystem = emptyString();
 489     m_contentType = { };
 490     m_contentMIMETypeWasInferredFromExtension = false;
 491     loadWithNextMediaEngine(nullptr);
 492     return m_currentMediaEngine;
 493 }
 494 #endif
 495 
 496 const MediaPlayerFactory* MediaPlayer::nextBestMediaEngine(const MediaPlayerFactory* current)
 497 {
 498     MediaEngineSupportParameters parameters;
 499     parameters.type = m_contentType;
 500     parameters.url = m_url;
 501 #if ENABLE(MEDIA_SOURCE)
 502     parameters.isMediaSource = !!m_mediaSource;
 503 #endif
 504 #if ENABLE(MEDIA_STREAM)
 505     parameters.isMediaStream = !!m_mediaStream;
 506 #endif
 507 
 508     if (m_activeEngineIdentifier) {
 509         if (current)
 510             return nullptr;
 511 
 512         auto* engine = mediaEngine(m_activeEngineIdentifier.value());
 513         if (engine &amp;&amp; engine-&gt;supportsTypeAndCodecs(parameters) != SupportsType::IsNotSupported)
 514             return engine;
 515 
 516         return nullptr;
 517     }
 518 
 519     return bestMediaEngineForSupportParameters(parameters, current);
 520 }
 521 
 522 void MediaPlayer::loadWithNextMediaEngine(const MediaPlayerFactory* current)
 523 {
 524 #if ENABLE(MEDIA_SOURCE)
 525 #define MEDIASOURCE m_mediaSource
 526 #else
 527 #define MEDIASOURCE 0
 528 #endif
 529 
 530 #if ENABLE(MEDIA_STREAM)
 531 #define MEDIASTREAM m_mediaStream
 532 #else
 533 #define MEDIASTREAM 0
 534 #endif
 535 
 536     ASSERT(!m_initializingMediaEngine);
 537     m_initializingMediaEngine = true;
 538 
 539     const MediaPlayerFactory* engine = nullptr;
 540 
 541     if (!m_contentType.isEmpty() || MEDIASTREAM || MEDIASOURCE)
 542         engine = nextBestMediaEngine(current);
 543 
 544     // If no MIME type is specified or the type was inferred from the file extension, just use the next engine.
 545     if (!engine &amp;&amp; (m_contentType.isEmpty() || m_contentMIMETypeWasInferredFromExtension))
 546         engine = nextMediaEngine(current);
 547 
 548     // Don&#39;t delete and recreate the player unless it comes from a different engine.
 549     if (!engine) {
 550         LOG(Media, &quot;MediaPlayer::loadWithNextMediaEngine - no media engine found for type \&quot;%s\&quot;&quot;, m_contentType.raw().utf8().data());
 551         m_currentMediaEngine = engine;
 552         m_private = nullptr;
 553     } else if (m_currentMediaEngine != engine) {
 554         m_currentMediaEngine = engine;
 555         m_private = engine-&gt;createMediaEnginePlayer(this);
 556         if (m_private) {
 557             client().mediaPlayerEngineUpdated();
 558             m_private-&gt;prepareForPlayback(m_privateBrowsing, m_preload, m_preservesPitch, m_shouldPrepareToRender);
 559         }
 560     }
 561 
 562     if (m_private) {
 563 #if ENABLE(MEDIA_SOURCE)
 564         if (m_mediaSource)
 565             m_private-&gt;load(m_url.string(), m_mediaSource.get());
 566         else
 567 #endif
 568 #if ENABLE(MEDIA_STREAM)
 569         if (m_mediaStream)
 570             m_private-&gt;load(*m_mediaStream);
 571         else
 572 #endif
 573         m_private-&gt;load(m_url, m_contentType, m_keySystem);
 574     } else {
 575         m_private = makeUnique&lt;NullMediaPlayerPrivate&gt;(this);
 576         if (!m_activeEngineIdentifier &amp;&amp; installedMediaEngines().size() &gt; 1 &amp;&amp; nextBestMediaEngine(m_currentMediaEngine))
 577             m_reloadTimer.startOneShot(0_s);
 578         else {
 579             client().mediaPlayerEngineUpdated();
 580             client().mediaPlayerResourceNotSupported();
 581         }
 582     }
 583 
 584     m_initializingMediaEngine = false;
 585 }
 586 
 587 bool MediaPlayer::hasAvailableVideoFrame() const
 588 {
 589     return m_private-&gt;hasAvailableVideoFrame();
 590 }
 591 
 592 void MediaPlayer::prepareForRendering()
 593 {
 594     m_shouldPrepareToRender = true;
 595     m_private-&gt;prepareForRendering();
 596 }
 597 
 598 void MediaPlayer::cancelLoad()
 599 {
 600     m_private-&gt;cancelLoad();
 601 }
 602 
 603 void MediaPlayer::prepareToPlay()
 604 {
 605     Ref&lt;MediaPlayer&gt; protectedThis(*this);
 606 
 607     m_private-&gt;prepareToPlay();
 608 }
 609 
 610 void MediaPlayer::play()
 611 {
 612     m_private-&gt;play();
 613 }
 614 
 615 void MediaPlayer::pause()
 616 {
 617     m_private-&gt;pause();
 618 }
 619 
 620 void MediaPlayer::setBufferingPolicy(BufferingPolicy policy)
 621 {
 622     m_private-&gt;setBufferingPolicy(policy);
 623 }
 624 
 625 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 626 
 627 std::unique_ptr&lt;LegacyCDMSession&gt; MediaPlayer::createSession(const String&amp; keySystem, LegacyCDMSessionClient* client)
 628 {
 629     return m_private-&gt;createSession(keySystem, client);
 630 }
 631 
 632 void MediaPlayer::setCDMSession(LegacyCDMSession* session)
 633 {
 634     m_private-&gt;setCDMSession(session);
 635 }
 636 
 637 void MediaPlayer::keyAdded()
 638 {
 639     m_private-&gt;keyAdded();
 640 }
 641 
 642 #endif
 643 
 644 #if ENABLE(ENCRYPTED_MEDIA)
 645 
 646 void MediaPlayer::cdmInstanceAttached(CDMInstance&amp; instance)
 647 {
 648     m_private-&gt;cdmInstanceAttached(instance);
 649 }
 650 
 651 void MediaPlayer::cdmInstanceDetached(CDMInstance&amp; instance)
 652 {
 653     m_private-&gt;cdmInstanceDetached(instance);
 654 }
 655 
 656 void MediaPlayer::attemptToDecryptWithInstance(CDMInstance&amp; instance)
 657 {
 658     m_private-&gt;attemptToDecryptWithInstance(instance);
 659 }
 660 
 661 #endif
 662 
 663 MediaTime MediaPlayer::duration() const
 664 {
 665     return m_private-&gt;durationMediaTime();
 666 }
 667 
 668 MediaTime MediaPlayer::startTime() const
 669 {
 670     return m_private-&gt;startTime();
 671 }
 672 
 673 MediaTime MediaPlayer::initialTime() const
 674 {
 675     return m_private-&gt;initialTime();
 676 }
 677 
 678 MediaTime MediaPlayer::currentTime() const
 679 {
 680     return m_private-&gt;currentMediaTime();
 681 }
 682 
 683 MediaTime MediaPlayer::getStartDate() const
 684 {
 685     return m_private-&gt;getStartDate();
 686 }
 687 
 688 void MediaPlayer::seekWithTolerance(const MediaTime&amp; time, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
 689 {
 690     m_private-&gt;seekWithTolerance(time, negativeTolerance, positiveTolerance);
 691 }
 692 
 693 void MediaPlayer::seek(const MediaTime&amp; time)
 694 {
 695     m_private-&gt;seek(time);
 696 }
 697 
 698 bool MediaPlayer::paused() const
 699 {
 700     return m_private-&gt;paused();
 701 }
 702 
 703 bool MediaPlayer::seeking() const
 704 {
 705     return m_private-&gt;seeking();
 706 }
 707 
 708 bool MediaPlayer::supportsFullscreen() const
 709 {
 710     return m_private-&gt;supportsFullscreen();
 711 }
 712 
 713 bool MediaPlayer::canSaveMediaData() const
 714 {
 715     return m_private-&gt;canSaveMediaData();
 716 }
 717 
 718 bool MediaPlayer::supportsScanning() const
 719 {
 720     return m_private-&gt;supportsScanning();
 721 }
 722 
 723 bool MediaPlayer::requiresImmediateCompositing() const
 724 {
 725     return m_private-&gt;requiresImmediateCompositing();
 726 }
 727 
 728 FloatSize MediaPlayer::naturalSize()
 729 {
 730     return m_private-&gt;naturalSize();
 731 }
 732 
 733 bool MediaPlayer::hasVideo() const
 734 {
 735     return m_private-&gt;hasVideo();
 736 }
 737 
 738 bool MediaPlayer::hasAudio() const
 739 {
 740     return m_private-&gt;hasAudio();
 741 }
 742 
 743 PlatformLayer* MediaPlayer::platformLayer() const
 744 {
 745     return m_private-&gt;platformLayer();
 746 }
 747 
 748 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 749 
 750 void MediaPlayer::setVideoFullscreenLayer(PlatformLayer* layer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
 751 {
 752     m_private-&gt;setVideoFullscreenLayer(layer, WTFMove(completionHandler));
 753 }
 754 
 755 void MediaPlayer::updateVideoFullscreenInlineImage()
 756 {
 757     m_private-&gt;updateVideoFullscreenInlineImage();
 758 }
 759 
 760 void MediaPlayer::setVideoFullscreenFrame(FloatRect frame)
 761 {
 762     m_private-&gt;setVideoFullscreenFrame(frame);
 763 }
 764 
 765 void MediaPlayer::setVideoFullscreenGravity(MediaPlayer::VideoGravity gravity)
 766 {
 767     m_private-&gt;setVideoFullscreenGravity(gravity);
 768 }
 769 
 770 void MediaPlayer::setVideoFullscreenMode(MediaPlayer::VideoFullscreenMode mode)
 771 {
 772     m_private-&gt;setVideoFullscreenMode(mode);
 773 }
 774 
 775 MediaPlayer::VideoFullscreenMode MediaPlayer::fullscreenMode() const
 776 {
 777     return client().mediaPlayerFullscreenMode();
 778 }
 779 
 780 void MediaPlayer::videoFullscreenStandbyChanged()
 781 {
 782     m_private-&gt;videoFullscreenStandbyChanged();
 783 }
 784 
 785 bool MediaPlayer::isVideoFullscreenStandby() const
 786 {
 787     return client().mediaPlayerIsVideoFullscreenStandby();
 788 }
 789 
 790 #endif
 791 
 792 #if PLATFORM(IOS_FAMILY)
 793 
 794 NSArray* MediaPlayer::timedMetadata() const
 795 {
 796     return m_private-&gt;timedMetadata();
 797 }
 798 
 799 String MediaPlayer::accessLog() const
 800 {
 801     return m_private-&gt;accessLog();
 802 }
 803 
 804 String MediaPlayer::errorLog() const
 805 {
 806     return m_private-&gt;errorLog();
 807 }
 808 
 809 #endif
 810 
 811 MediaPlayer::NetworkState MediaPlayer::networkState()
 812 {
 813     return m_private-&gt;networkState();
 814 }
 815 
 816 MediaPlayer::ReadyState MediaPlayer::readyState()
 817 {
 818     return m_private-&gt;readyState();
 819 }
 820 
 821 double MediaPlayer::volume() const
 822 {
 823     return m_volume;
 824 }
 825 
 826 void MediaPlayer::setVolume(double volume)
 827 {
 828     m_volume = volume;
 829     m_private-&gt;setVolumeDouble(volume);
 830 }
 831 
 832 bool MediaPlayer::muted() const
 833 {
 834     return m_muted;
 835 }
 836 
 837 void MediaPlayer::setMuted(bool muted)
 838 {
 839     m_muted = muted;
 840 
 841     m_private-&gt;setMuted(muted);
 842 }
 843 
 844 bool MediaPlayer::hasClosedCaptions() const
 845 {
 846     return m_private-&gt;hasClosedCaptions();
 847 }
 848 
 849 void MediaPlayer::setClosedCaptionsVisible(bool closedCaptionsVisible)
 850 {
 851     m_private-&gt;setClosedCaptionsVisible(closedCaptionsVisible);
 852 }
 853 
 854 double MediaPlayer::rate() const
 855 {
 856     return m_private-&gt;rate();
 857 }
 858 
 859 void MediaPlayer::setRate(double rate)
 860 {
 861     m_private-&gt;setRateDouble(rate);
 862 }
 863 
 864 double MediaPlayer::requestedRate() const
 865 {
 866     return client().mediaPlayerRequestedPlaybackRate();
 867 }
 868 
 869 bool MediaPlayer::preservesPitch() const
 870 {
 871     return m_preservesPitch;
 872 }
 873 
 874 void MediaPlayer::setPreservesPitch(bool preservesPitch)
 875 {
 876     m_preservesPitch = preservesPitch;
 877     m_private-&gt;setPreservesPitch(preservesPitch);
 878 }
 879 
 880 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::buffered()
 881 {
 882     return m_private-&gt;buffered();
 883 }
 884 
 885 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayer::seekable()
 886 {
 887     return m_private-&gt;seekable();
 888 }
 889 
 890 MediaTime MediaPlayer::maxTimeSeekable()
 891 {
 892     return m_private-&gt;maxMediaTimeSeekable();
 893 }
 894 
 895 MediaTime MediaPlayer::minTimeSeekable()
 896 {
 897     return m_private-&gt;minMediaTimeSeekable();
 898 }
 899 
 900 double MediaPlayer::seekableTimeRangesLastModifiedTime()
 901 {
 902     return m_private-&gt;seekableTimeRangesLastModifiedTime();
 903 }
 904 
 905 void MediaPlayer::bufferedTimeRangesChanged()
 906 {
 907     client().mediaPlayerBufferedTimeRangesChanged();
 908 }
 909 
 910 void MediaPlayer::seekableTimeRangesChanged()
 911 {
 912     client().mediaPlayerSeekableTimeRangesChanged();
 913 }
 914 
 915 double MediaPlayer::liveUpdateInterval()
 916 {
 917     return m_private-&gt;liveUpdateInterval();
 918 }
 919 
 920 bool MediaPlayer::didLoadingProgress()
 921 {
 922     return m_private-&gt;didLoadingProgress();
 923 }
 924 
 925 void MediaPlayer::setSize(const IntSize&amp; size)
 926 {
 927     m_size = size;
 928     m_private-&gt;setSize(size);
 929 }
 930 
 931 bool MediaPlayer::visible() const
 932 {
 933     return m_visible;
 934 }
 935 
 936 void MediaPlayer::setVisible(bool b)
 937 {
 938     m_visible = b;
 939     m_private-&gt;setVisible(b);
 940 }
 941 
 942 MediaPlayer::Preload MediaPlayer::preload() const
 943 {
 944     return m_preload;
 945 }
 946 
 947 void MediaPlayer::setPreload(MediaPlayer::Preload preload)
 948 {
 949     m_preload = preload;
 950     m_private-&gt;setPreload(preload);
 951 }
 952 
 953 void MediaPlayer::paint(GraphicsContext&amp; p, const FloatRect&amp; r)
 954 {
 955     m_private-&gt;paint(p, r);
 956 }
 957 
 958 void MediaPlayer::paintCurrentFrameInContext(GraphicsContext&amp; p, const FloatRect&amp; r)
 959 {
 960     m_private-&gt;paintCurrentFrameInContext(p, r);
 961 }
 962 
 963 bool MediaPlayer::copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL* context, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)
 964 {
 965     return m_private-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 966 }
 967 
 968 NativeImagePtr MediaPlayer::nativeImageForCurrentTime()
 969 {
 970     return m_private-&gt;nativeImageForCurrentTime();
 971 }
 972 
 973 MediaPlayer::SupportsType MediaPlayer::supportsType(const MediaEngineSupportParameters&amp; parameters)
 974 {
 975     // 4.8.10.3 MIME types - The canPlayType(type) method must return the empty string if type is a type that the
 976     // user agent knows it cannot render or is the type &quot;application/octet-stream&quot;
 977     AtomString containerType = parameters.type.containerType();
 978     if (containerType == applicationOctetStream())
 979         return SupportsType::IsNotSupported;
 980 
 981     const MediaPlayerFactory* engine = bestMediaEngineForSupportParameters(parameters);
 982     if (!engine)
 983         return SupportsType::IsNotSupported;
 984 
 985     return engine-&gt;supportsTypeAndCodecs(parameters);
 986 }
 987 
 988 void MediaPlayer::getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
 989 {
 990     for (auto&amp; engine : installedMediaEngines()) {
 991         HashSet&lt;String, ASCIICaseInsensitiveHash&gt; engineTypes;
 992         engine-&gt;getSupportedTypes(engineTypes);
 993         types.add(engineTypes.begin(), engineTypes.end());
 994     }
 995 }
 996 
 997 bool MediaPlayer::isAvailable()
 998 {
 999 #if PLATFORM(IOS_FAMILY)
1000     if (DeprecatedGlobalSettings::isAVFoundationEnabled())
1001         return true;
1002 #endif
1003     return !installedMediaEngines().isEmpty();
1004 }
1005 
1006 bool MediaPlayer::supportsPictureInPicture() const
1007 {
1008     return m_private-&gt;supportsPictureInPicture();
1009 }
1010 
1011 #if USE(NATIVE_FULLSCREEN_VIDEO)
1012 
1013 void MediaPlayer::enterFullscreen()
1014 {
1015     m_private-&gt;enterFullscreen();
1016 }
1017 
1018 void MediaPlayer::exitFullscreen()
1019 {
1020     m_private-&gt;exitFullscreen();
1021 }
1022 
1023 #endif
1024 
1025 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1026 
1027 bool MediaPlayer::isCurrentPlaybackTargetWireless() const
1028 {
1029     return m_private-&gt;isCurrentPlaybackTargetWireless();
1030 }
1031 
1032 String MediaPlayer::wirelessPlaybackTargetName() const
1033 {
1034     return m_private-&gt;wirelessPlaybackTargetName();
1035 }
1036 
1037 MediaPlayer::WirelessPlaybackTargetType MediaPlayer::wirelessPlaybackTargetType() const
1038 {
1039     return m_private-&gt;wirelessPlaybackTargetType();
1040 }
1041 
1042 bool MediaPlayer::wirelessVideoPlaybackDisabled() const
1043 {
1044     return m_private-&gt;wirelessVideoPlaybackDisabled();
1045 }
1046 
1047 void MediaPlayer::setWirelessVideoPlaybackDisabled(bool disabled)
1048 {
1049     m_private-&gt;setWirelessVideoPlaybackDisabled(disabled);
1050 }
1051 
1052 void MediaPlayer::currentPlaybackTargetIsWirelessChanged(bool isCurrentPlaybackTargetWireless)
1053 {
1054     client().mediaPlayerCurrentPlaybackTargetIsWirelessChanged(isCurrentPlaybackTargetWireless);
1055 }
1056 
1057 bool MediaPlayer::canPlayToWirelessPlaybackTarget() const
1058 {
1059     return m_private-&gt;canPlayToWirelessPlaybackTarget();
1060 }
1061 
1062 void MediaPlayer::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
1063 {
1064     m_private-&gt;setWirelessPlaybackTarget(WTFMove(device));
1065 }
1066 
1067 void MediaPlayer::setShouldPlayToPlaybackTarget(bool shouldPlay)
1068 {
1069     m_private-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
1070 }
1071 
1072 #endif
1073 
1074 double MediaPlayer::maxFastForwardRate() const
1075 {
1076     return m_private-&gt;maxFastForwardRate();
1077 }
1078 
1079 double MediaPlayer::minFastReverseRate() const
1080 {
1081     return m_private-&gt;minFastReverseRate();
1082 }
1083 
1084 #if USE(NATIVE_FULLSCREEN_VIDEO)
1085 
1086 bool MediaPlayer::canEnterFullscreen() const
1087 {
1088     return m_private-&gt;canEnterFullscreen();
1089 }
1090 
1091 #endif
1092 
1093 void MediaPlayer::acceleratedRenderingStateChanged()
1094 {
1095     m_private-&gt;acceleratedRenderingStateChanged();
1096 }
1097 
1098 bool MediaPlayer::supportsAcceleratedRendering() const
1099 {
1100     return m_private-&gt;supportsAcceleratedRendering();
1101 }
1102 
1103 bool MediaPlayer::shouldMaintainAspectRatio() const
1104 {
1105     return m_private-&gt;shouldMaintainAspectRatio();
1106 }
1107 
1108 void MediaPlayer::setShouldMaintainAspectRatio(bool maintainAspectRatio)
1109 {
1110     m_private-&gt;setShouldMaintainAspectRatio(maintainAspectRatio);
1111 }
1112 
1113 bool MediaPlayer::hasSingleSecurityOrigin() const
1114 {
1115     return m_private-&gt;hasSingleSecurityOrigin();
1116 }
1117 
1118 bool MediaPlayer::didPassCORSAccessCheck() const
1119 {
1120     return m_private-&gt;didPassCORSAccessCheck();
1121 }
1122 
1123 bool MediaPlayer::wouldTaintOrigin(const SecurityOrigin&amp; origin) const
1124 {
1125     auto wouldTaint = m_private-&gt;wouldTaintOrigin(origin);
1126     if (wouldTaint.hasValue())
1127         return wouldTaint.value();
1128 
1129     if (m_url.protocolIsData())
1130         return false;
1131 
1132     return !origin.canRequest(m_url);
1133 }
1134 
1135 MediaPlayer::MovieLoadType MediaPlayer::movieLoadType() const
1136 {
1137     return m_private-&gt;movieLoadType();
1138 }
1139 
1140 MediaTime MediaPlayer::mediaTimeForTimeValue(const MediaTime&amp; timeValue) const
1141 {
1142     return m_private-&gt;mediaTimeForTimeValue(timeValue);
1143 }
1144 
1145 double MediaPlayer::maximumDurationToCacheMediaTime() const
1146 {
1147     return m_private-&gt;maximumDurationToCacheMediaTime();
1148 }
1149 
1150 unsigned MediaPlayer::decodedFrameCount() const
1151 {
1152     return m_private-&gt;decodedFrameCount();
1153 }
1154 
1155 unsigned MediaPlayer::droppedFrameCount() const
1156 {
1157     return m_private-&gt;droppedFrameCount();
1158 }
1159 
1160 unsigned MediaPlayer::audioDecodedByteCount() const
1161 {
1162     return m_private-&gt;audioDecodedByteCount();
1163 }
1164 
1165 unsigned MediaPlayer::videoDecodedByteCount() const
1166 {
1167     return m_private-&gt;videoDecodedByteCount();
1168 }
1169 
1170 void MediaPlayer::reloadTimerFired()
1171 {
1172     m_private-&gt;cancelLoad();
1173     loadWithNextMediaEngine(m_currentMediaEngine);
1174 }
1175 
1176 template&lt;typename T&gt;
1177 static void addToHash(HashSet&lt;T&gt;&amp; toHash, HashSet&lt;T&gt;&amp;&amp; fromHash)
1178 {
1179     if (toHash.isEmpty())
1180         toHash = WTFMove(fromHash);
1181     else
1182         toHash.add(fromHash.begin(), fromHash.end());
1183 }
1184 
1185 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; MediaPlayer::originsInMediaCache(const String&amp; path)
1186 {
1187     HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; origins;
1188     for (auto&amp; engine : installedMediaEngines())
1189         addToHash(origins, engine-&gt;originsInMediaCache(path));
1190 
1191     return origins;
1192 }
1193 
1194 void MediaPlayer::clearMediaCache(const String&amp; path, WallTime modifiedSince)
1195 {
1196     for (auto&amp; engine : installedMediaEngines())
1197         engine-&gt;clearMediaCache(path, modifiedSince);
1198 }
1199 
1200 void MediaPlayer::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
1201 {
1202     for (auto&amp; engine : installedMediaEngines())
1203         engine-&gt;clearMediaCacheForOrigins(path, origins);
1204 }
1205 
1206 bool MediaPlayer::supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType)
1207 {
1208     for (auto&amp; engine : installedMediaEngines()) {
1209         if (engine-&gt;supportsKeySystem(keySystem, mimeType))
1210             return true;
1211     }
1212     return false;
1213 }
1214 
1215 void MediaPlayer::setPrivateBrowsingMode(bool privateBrowsingMode)
1216 {
1217     m_privateBrowsing = privateBrowsingMode;
1218     if (m_private)
1219         m_private-&gt;setPrivateBrowsingMode(m_privateBrowsing);
1220 }
1221 
1222 // Client callbacks.
1223 void MediaPlayer::networkStateChanged()
1224 {
1225     // If more than one media engine is installed and this one failed before finding metadata,
1226     // let the next engine try.
1227     if (m_private-&gt;networkState() &gt;= MediaPlayer::NetworkState::FormatError &amp;&amp; m_private-&gt;readyState() &lt; MediaPlayer::ReadyState::HaveMetadata) {
1228         client().mediaPlayerEngineFailedToLoad();
1229         if (!m_activeEngineIdentifier &amp;&amp; installedMediaEngines().size() &gt; 1 &amp;&amp; (m_contentType.isEmpty() || nextBestMediaEngine(m_currentMediaEngine))) {
1230             m_reloadTimer.startOneShot(0_s);
1231             return;
1232         }
1233     }
1234     client().mediaPlayerNetworkStateChanged();
1235 }
1236 
1237 void MediaPlayer::readyStateChanged()
1238 {
1239     client().mediaPlayerReadyStateChanged();
1240 }
1241 
1242 void MediaPlayer::volumeChanged(double newVolume)
1243 {
1244 #if PLATFORM(IOS_FAMILY)
1245     UNUSED_PARAM(newVolume);
1246     m_volume = m_private-&gt;volume();
1247 #else
1248     m_volume = newVolume;
1249 #endif
1250     client().mediaPlayerVolumeChanged();
1251 }
1252 
1253 void MediaPlayer::muteChanged(bool newMuted)
1254 {
1255     if (newMuted == m_muted)
1256         return;
1257 
1258     m_muted = newMuted;
1259     client().mediaPlayerMuteChanged();
1260 }
1261 
1262 void MediaPlayer::timeChanged()
1263 {
1264     client().mediaPlayerTimeChanged();
1265 }
1266 
1267 void MediaPlayer::sizeChanged()
1268 {
1269     client().mediaPlayerSizeChanged();
1270 }
1271 
1272 void MediaPlayer::repaint()
1273 {
1274     client().mediaPlayerRepaint();
1275 }
1276 
1277 void MediaPlayer::durationChanged()
1278 {
1279     client().mediaPlayerDurationChanged();
1280 }
1281 
1282 void MediaPlayer::rateChanged()
1283 {
1284     client().mediaPlayerRateChanged();
1285 }
1286 
1287 void MediaPlayer::playbackStateChanged()
1288 {
1289     client().mediaPlayerPlaybackStateChanged();
1290 }
1291 
1292 void MediaPlayer::firstVideoFrameAvailable()
1293 {
1294     client().mediaPlayerFirstVideoFrameAvailable();
1295 }
1296 
1297 void MediaPlayer::characteristicChanged()
1298 {
1299     client().mediaPlayerCharacteristicChanged();
1300 }
1301 
1302 #if ENABLE(WEB_AUDIO)
1303 
1304 AudioSourceProvider* MediaPlayer::audioSourceProvider()
1305 {
1306     return m_private-&gt;audioSourceProvider();
1307 }
1308 
1309 #endif
1310 
1311 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1312 
1313 RefPtr&lt;ArrayBuffer&gt; MediaPlayer::cachedKeyForKeyId(const String&amp; keyId) const
1314 {
1315     return client().mediaPlayerCachedKeyForKeyId(keyId);
1316 }
1317 
1318 bool MediaPlayer::keyNeeded(Uint8Array* initData)
1319 {
1320     return client().mediaPlayerKeyNeeded(initData);
1321 }
1322 
1323 String MediaPlayer::mediaKeysStorageDirectory() const
1324 {
1325     return client().mediaPlayerMediaKeysStorageDirectory();
1326 }
1327 
1328 #endif
1329 
1330 #if ENABLE(ENCRYPTED_MEDIA)
1331 
1332 void MediaPlayer::initializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
1333 {
1334     client().mediaPlayerInitializationDataEncountered(initDataType, WTFMove(initData));
1335 }
1336 
1337 void MediaPlayer::waitingForKeyChanged()
1338 {
1339     client().mediaPlayerWaitingForKeyChanged();
1340 }
1341 
1342 bool MediaPlayer::waitingForKey() const
1343 {
1344     if (!m_private)
1345         return false;
1346     return m_private-&gt;waitingForKey();
1347 }
1348 #endif
1349 
1350 String MediaPlayer::referrer() const
1351 {
1352     return client().mediaPlayerReferrer();
1353 }
1354 
1355 String MediaPlayer::userAgent() const
1356 {
1357     return client().mediaPlayerUserAgent();
1358 }
1359 
1360 String MediaPlayer::engineDescription() const
1361 {
1362     if (!m_private)
1363         return String();
1364 
1365     return m_private-&gt;engineDescription();
1366 }
1367 
1368 long MediaPlayer::platformErrorCode() const
1369 {
1370     if (!m_private)
1371         return 0;
1372 
1373     return m_private-&gt;platformErrorCode();
1374 }
1375 
1376 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
1377 GraphicsDeviceAdapter* MediaPlayer::graphicsDeviceAdapter() const
1378 {
1379     return client().mediaPlayerGraphicsDeviceAdapter();
1380 }
1381 #endif
1382 
1383 CachedResourceLoader* MediaPlayer::cachedResourceLoader()
1384 {
1385     return client().mediaPlayerCachedResourceLoader();
1386 }
1387 
1388 RefPtr&lt;PlatformMediaResourceLoader&gt; MediaPlayer::createResourceLoader()
1389 {
1390     return client().mediaPlayerCreateResourceLoader();
1391 }
1392 
1393 #if ENABLE(VIDEO_TRACK)
1394 
1395 void MediaPlayer::addAudioTrack(AudioTrackPrivate&amp; track)
1396 {
1397     client().mediaPlayerDidAddAudioTrack(track);
1398 }
1399 
1400 void MediaPlayer::removeAudioTrack(AudioTrackPrivate&amp; track)
1401 {
1402     client().mediaPlayerDidRemoveAudioTrack(track);
1403 }
1404 
1405 void MediaPlayer::addTextTrack(InbandTextTrackPrivate&amp; track)
1406 {
1407     client().mediaPlayerDidAddTextTrack(track);
1408 }
1409 
1410 void MediaPlayer::removeTextTrack(InbandTextTrackPrivate&amp; track)
1411 {
1412     client().mediaPlayerDidRemoveTextTrack(track);
1413 }
1414 
1415 void MediaPlayer::addVideoTrack(VideoTrackPrivate&amp; track)
1416 {
1417     client().mediaPlayerDidAddVideoTrack(track);
1418 }
1419 
1420 void MediaPlayer::removeVideoTrack(VideoTrackPrivate&amp; track)
1421 {
1422     client().mediaPlayerDidRemoveVideoTrack(track);
1423 }
1424 
1425 bool MediaPlayer::requiresTextTrackRepresentation() const
1426 {
1427     return m_private-&gt;requiresTextTrackRepresentation();
1428 }
1429 
1430 void MediaPlayer::setTextTrackRepresentation(TextTrackRepresentation* representation)
1431 {
1432     m_private-&gt;setTextTrackRepresentation(representation);
1433 }
1434 
1435 void MediaPlayer::syncTextTrackBounds()
1436 {
1437     m_private-&gt;syncTextTrackBounds();
1438 }
1439 
1440 void MediaPlayer::tracksChanged()
1441 {
1442     m_private-&gt;tracksChanged();
1443 }
1444 
1445 #if ENABLE(AVF_CAPTIONS)
1446 
1447 void MediaPlayer::notifyTrackModeChanged()
1448 {
1449     if (m_private)
1450         m_private-&gt;notifyTrackModeChanged();
1451 }
1452 
1453 Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; MediaPlayer::outOfBandTrackSources()
1454 {
1455     return client().outOfBandTrackSources();
1456 }
1457 
1458 #endif
1459 
1460 #endif // ENABLE(VIDEO_TRACK)
1461 
1462 void MediaPlayer::resetMediaEngines()
1463 {
1464     auto locker = holdLock(mediaEngineVectorLock);
1465 
1466     mutableInstalledMediaEnginesVector().clear();
1467     haveMediaEnginesVector() = false;
1468 }
1469 
1470 #if USE(GSTREAMER)
1471 void MediaPlayer::simulateAudioInterruption()
1472 {
1473     if (!m_private)
1474         return;
1475 
1476     m_private-&gt;simulateAudioInterruption();
1477 }
1478 #endif
1479 
1480 void MediaPlayer::beginSimulatedHDCPError()
1481 {
1482     if (m_private)
1483         m_private-&gt;beginSimulatedHDCPError();
1484 }
1485 
1486 void MediaPlayer::endSimulatedHDCPError()
1487 {
1488     if (m_private)
1489         m_private-&gt;endSimulatedHDCPError();
1490 }
1491 
1492 String MediaPlayer::languageOfPrimaryAudioTrack() const
1493 {
1494     if (!m_private)
1495         return emptyString();
1496 
1497     return m_private-&gt;languageOfPrimaryAudioTrack();
1498 }
1499 
1500 size_t MediaPlayer::extraMemoryCost() const
1501 {
1502     if (!m_private)
1503         return 0;
1504 
1505     return m_private-&gt;extraMemoryCost();
1506 }
1507 
1508 unsigned long long MediaPlayer::fileSize() const
1509 {
1510     if (!m_private)
1511         return 0;
1512 
1513     return m_private-&gt;fileSize();
1514 }
1515 
1516 bool MediaPlayer::ended() const
1517 {
1518     return m_private-&gt;ended();
1519 }
1520 
1521 Optional&lt;VideoPlaybackQualityMetrics&gt; MediaPlayer::videoPlaybackQualityMetrics()
1522 {
1523     if (!m_private)
1524         return WTF::nullopt;
1525 
1526     return m_private-&gt;videoPlaybackQualityMetrics();
1527 }
1528 
1529 String MediaPlayer::sourceApplicationIdentifier() const
1530 {
1531     return client().mediaPlayerSourceApplicationIdentifier();
1532 }
1533 
1534 Vector&lt;String&gt; MediaPlayer::preferredAudioCharacteristics() const
1535 {
1536     return client().mediaPlayerPreferredAudioCharacteristics();
1537 }
1538 
1539 void MediaPlayerFactorySupport::callRegisterMediaEngine(MediaEngineRegister registerMediaEngine)
1540 {
1541     registerMediaEngine(addMediaEngine);
1542 }
1543 
1544 bool MediaPlayer::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const
1545 {
1546     return client().doesHaveAttribute(attribute, value);
1547 }
1548 
1549 #if PLATFORM(IOS_FAMILY)
1550 String MediaPlayer::mediaPlayerNetworkInterfaceName() const
1551 {
1552     return client().mediaPlayerNetworkInterfaceName();
1553 }
1554 
1555 bool MediaPlayer::getRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
1556 {
1557     return client().mediaPlayerGetRawCookies(url, cookies);
1558 }
1559 #endif
1560 
1561 void MediaPlayer::setShouldDisableSleep(bool flag)
1562 {
1563     if (m_private)
1564         m_private-&gt;setShouldDisableSleep(flag);
1565 }
1566 
1567 bool MediaPlayer::shouldDisableSleep() const
1568 {
1569     return client().mediaPlayerShouldDisableSleep();
1570 }
1571 
1572 const Vector&lt;ContentType&gt;&amp; MediaPlayer::mediaContentTypesRequiringHardwareSupport() const
1573 {
1574     return client().mediaContentTypesRequiringHardwareSupport();
1575 }
1576 
1577 bool MediaPlayer::shouldCheckHardwareSupport() const
1578 {
1579     return client().mediaPlayerShouldCheckHardwareSupport();
1580 }
1581 
1582 void MediaPlayer::applicationWillResignActive()
1583 {
1584     m_private-&gt;applicationWillResignActive();
1585 }
1586 
1587 void MediaPlayer::applicationDidBecomeActive()
1588 {
1589     m_private-&gt;applicationDidBecomeActive();
1590 }
1591 
1592 #if USE(AVFOUNDATION)
1593 
1594 AVPlayer* MediaPlayer::objCAVFoundationAVPlayer() const
1595 {
1596     return m_private-&gt;objCAVFoundationAVPlayer();
1597 }
1598 
1599 #endif
1600 
1601 bool MediaPlayer::performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp; task, MediaTime time)
1602 {
1603     return m_private-&gt;performTaskAtMediaTime(WTFMove(task), time);
1604 }
1605 
1606 bool MediaPlayer::shouldIgnoreIntrinsicSize()
1607 {
1608     return m_private-&gt;shouldIgnoreIntrinsicSize();
1609 }
1610 
1611 void MediaPlayer::remoteEngineFailedToLoad()
1612 {
1613     client().mediaPlayerEngineFailedToLoad();
1614 }
1615 
1616 #if !RELEASE_LOG_DISABLED
1617 const Logger&amp; MediaPlayer::mediaPlayerLogger()
1618 {
1619     return client().mediaPlayerLogger();
1620 }
1621 #endif
1622 
1623 String convertEnumerationToString(MediaPlayer::ReadyState enumerationValue)
1624 {
1625     static const NeverDestroyed&lt;String&gt; values[] = {
1626         MAKE_STATIC_STRING_IMPL(&quot;HaveNothing&quot;),
1627         MAKE_STATIC_STRING_IMPL(&quot;HaveMetadata&quot;),
1628         MAKE_STATIC_STRING_IMPL(&quot;HaveCurrentData&quot;),
1629         MAKE_STATIC_STRING_IMPL(&quot;HaveFutureData&quot;),
1630         MAKE_STATIC_STRING_IMPL(&quot;HaveEnoughData&quot;),
1631     };
1632     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveNothing) == 0, &quot;MediaPlayer::ReadyState::HaveNothing is not 0 as expected&quot;);
1633     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveMetadata) == 1, &quot;MediaPlayer::ReadyState::HaveMetadata is not 1 as expected&quot;);
1634     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveCurrentData) == 2, &quot;MediaPlayer::ReadyState::HaveCurrentData is not 2 as expected&quot;);
1635     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveFutureData) == 3, &quot;MediaPlayer::ReadyState::HaveFutureData is not 3 as expected&quot;);
1636     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::ReadyState::HaveEnoughData) == 4, &quot;MediaPlayer::ReadyState::HaveEnoughData is not 4 as expected&quot;);
1637     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1638     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1639 }
1640 
1641 String convertEnumerationToString(MediaPlayer::NetworkState enumerationValue)
1642 {
1643     static const NeverDestroyed&lt;String&gt; values[] = {
1644         MAKE_STATIC_STRING_IMPL(&quot;Empty&quot;),
1645         MAKE_STATIC_STRING_IMPL(&quot;Idle&quot;),
1646         MAKE_STATIC_STRING_IMPL(&quot;Loading&quot;),
1647         MAKE_STATIC_STRING_IMPL(&quot;Loaded&quot;),
1648         MAKE_STATIC_STRING_IMPL(&quot;FormatError&quot;),
1649         MAKE_STATIC_STRING_IMPL(&quot;NetworkError&quot;),
1650         MAKE_STATIC_STRING_IMPL(&quot;DecodeError&quot;),
1651     };
1652     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Empty) == 0, &quot;MediaPlayer::NetworkState::Empty is not 0 as expected&quot;);
1653     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Idle) == 1, &quot;MediaPlayer::NetworkState::Idle is not 1 as expected&quot;);
1654     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Loading) == 2, &quot;MediaPlayer::NetworkState::Loading is not 2 as expected&quot;);
1655     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::Loaded) == 3, &quot;MediaPlayer::NetworkState::Loaded is not 3 as expected&quot;);
1656     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::FormatError) == 4, &quot;MediaPlayer::NetworkState::FormatError is not 4 as expected&quot;);
1657     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::NetworkError) == 5, &quot;MediaPlayer::NetworkError is not 5 as expected&quot;);
1658     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::NetworkState::DecodeError) == 6, &quot;MediaPlayer::NetworkState::DecodeError is not 6 as expected&quot;);
1659     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1660     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1661 }
1662 
1663 String convertEnumerationToString(MediaPlayer::Preload enumerationValue)
1664 {
1665     static const NeverDestroyed&lt;String&gt; values[] = {
1666         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
1667         MAKE_STATIC_STRING_IMPL(&quot;MetaData&quot;),
1668         MAKE_STATIC_STRING_IMPL(&quot;Auto&quot;),
1669     };
1670     static_assert(!static_cast&lt;size_t&gt;(MediaPlayer::Preload::None), &quot;MediaPlayer::Preload::None is not 0 as expected&quot;);
1671     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::Preload::MetaData) == 1, &quot;MediaPlayer::Preload::MetaData is not 1 as expected&quot;);
1672     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::Preload::Auto) == 2, &quot;MediaPlayer::Preload::Auto is not 2 as expected&quot;);
1673     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1674     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1675 }
1676 
1677 String convertEnumerationToString(MediaPlayer::SupportsType enumerationValue)
1678 {
1679     static const NeverDestroyed&lt;String&gt; values[] = {
1680         MAKE_STATIC_STRING_IMPL(&quot;IsNotSupported&quot;),
1681         MAKE_STATIC_STRING_IMPL(&quot;IsSupported&quot;),
1682         MAKE_STATIC_STRING_IMPL(&quot;MayBeSupported&quot;),
1683     };
1684     static_assert(!static_cast&lt;size_t&gt;(MediaPlayer::SupportsType::IsNotSupported), &quot;MediaPlayer::SupportsType::IsNotSupported is not 0 as expected&quot;);
1685     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::SupportsType::IsSupported) == 1, &quot;MediaPlayer::SupportsType::IsSupported is not 1 as expected&quot;);
1686     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::SupportsType::MayBeSupported) == 2, &quot;MediaPlayer::SupportsType::MayBeSupported is not 2 as expected&quot;);
1687     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1688     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1689 }
1690 
1691 String convertEnumerationToString(MediaPlayer::BufferingPolicy enumerationValue)
1692 {
1693     static const NeverDestroyed&lt;String&gt; values[] = {
1694         MAKE_STATIC_STRING_IMPL(&quot;Default&quot;),
1695         MAKE_STATIC_STRING_IMPL(&quot;LimitReadAhead&quot;),
1696         MAKE_STATIC_STRING_IMPL(&quot;MakeResourcesPurgeable&quot;),
1697         MAKE_STATIC_STRING_IMPL(&quot;PurgeResources&quot;),
1698     };
1699     static_assert(!static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::Default), &quot;MediaPlayer::Default is not 0 as expected&quot;);
1700     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::LimitReadAhead) == 1, &quot;MediaPlayer::LimitReadAhead is not 1 as expected&quot;);
1701     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::MakeResourcesPurgeable) == 2, &quot;MediaPlayer::MakeResourcesPurgeable is not 2 as expected&quot;);
1702     static_assert(static_cast&lt;size_t&gt;(MediaPlayer::BufferingPolicy::PurgeResources) == 3, &quot;MediaPlayer::PurgeResources is not 3 as expected&quot;);
1703     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
1704     return values[static_cast&lt;size_t&gt;(enumerationValue)];
1705 }
1706 
1707 }
1708 
1709 #endif
    </pre>
  </body>
</html>
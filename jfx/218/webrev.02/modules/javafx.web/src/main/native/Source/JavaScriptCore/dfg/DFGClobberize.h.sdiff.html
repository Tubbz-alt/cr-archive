<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCapabilities.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGClobbersExitState.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;DFGAbstractHeap.h&quot;
  31 #include &quot;DFGGraph.h&quot;
  32 #include &quot;DFGHeapLocation.h&quot;
  33 #include &quot;DFGLazyNode.h&quot;
  34 #include &quot;DFGPureValue.h&quot;
  35 #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
  36 #include &quot;DOMJITSignature.h&quot;
  37 #include &quot;InlineCallFrame.h&quot;
<span class="line-removed">  38 #include &quot;JSFixedArray.h&quot;</span>
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 
  41 namespace JSC { namespace DFG {
  42 
  43 template&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;
  44 void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFunctor&amp; write, const DefFunctor&amp; def)
  45 {
  46     // Some notes:
  47     //
  48     // - The canonical way of clobbering the world is to read world and write
  49     //   heap. This is because World subsumes Heap and Stack, and Stack can be
  50     //   read by anyone but only written to by explicit stack writing operations.
  51     //   Of course, claiming to also write World is not wrong; it&#39;ll just
  52     //   pessimise some important optimizations.
  53     //
  54     // - We cannot hoist, or sink, anything that has effects. This means that the
  55     //   easiest way of indicating that something cannot be hoisted is to claim
  56     //   that it side-effects some miscellaneous thing.
  57     //
  58     // - We cannot hoist forward-exiting nodes without some additional effort. I
</pre>
<hr />
<pre>
  95     //
  96     // - The abstract heap is the only abstract heap that could be clobbered to invalidate any such
  97     //   CSE attempt. I.e. if clobberize() reports that on every path between some node and a node
  98     //   that defines a HeapLocation that it wanted, there were no writes to any abstract heap that
  99     //   overlap the location&#39;s heap, then we have a sound match. Effectively, the semantics of
 100     //   write() and def() are intertwined such that for them to be sound they must agree on what
 101     //   is CSEable.
 102     //
 103     // read(), write(), and def() for heap locations is enough to do GCSE on effectful things. To
 104     // keep things simple, this code will also def() pure things. def() must be overloaded to also
 105     // accept PureValue. This way, a client of clobberize() can implement GCSE entirely using the
 106     // information that clobberize() passes to write() and def(). Other clients of clobberize() can
 107     // just ignore def() by using a NoOpClobberize functor.
 108 
 109     // We allow the runtime to perform a stack scan at any time. We don&#39;t model which nodes get implemented
 110     // by calls into the runtime. For debugging we might replace the implementation of any node with a call
 111     // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
 112     // scan would read. That&#39;s what this does.
 113     for (InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
 114         if (inlineCallFrame-&gt;isClosureCall)
<span class="line-modified"> 115             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
 116         if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified"> 117             read(AbstractHeap(Stack, inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
 118     }
 119 
 120     // We don&#39;t want to specifically account which nodes can read from the scope
 121     // when the debugger is enabled. It&#39;s helpful to just claim all nodes do.
 122     // Specifically, if a node allocates, this may call into the debugger&#39;s machinery.
 123     // The debugger&#39;s machinery is free to take a stack trace and try to read from
 124     // a scope which is expected to be flushed to the stack.
 125     if (graph.hasDebuggerEnabled()) {
 126         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
 127         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
 128     }
 129 
 130     switch (node-&gt;op()) {
 131     case JSConstant:
 132     case DoubleConstant:
 133     case Int52Constant:
 134         def(PureValue(node, node-&gt;constant()));
 135         return;
 136 
 137     case Identity:
</pre>
<hr />
<pre>
 151         write(CatchLocals);
 152         return;
 153 
 154     case LazyJSConstant:
 155         // We should enable CSE of LazyJSConstant. It&#39;s a little annoying since LazyJSValue has
 156         // more bits than we currently have in PureValue.
 157         return;
 158 
 159     case CompareEqPtr:
 160         def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));
 161         return;
 162 
 163     case ArithIMul:
 164     case ArithMin:
 165     case ArithMax:
 166     case ArithPow:
 167     case GetScope:
 168     case SkipScope:
 169     case GetGlobalObject:
 170     case StringCharCodeAt:

 171     case CompareStrictEq:
 172     case SameValue:
 173     case IsEmpty:
 174     case IsUndefined:
 175     case IsUndefinedOrNull:
 176     case IsBoolean:
 177     case IsNumber:
 178     case NumberIsInteger:
 179     case IsObject:
 180     case IsTypedArrayView:
 181     case LogicalNot:
 182     case CheckInBounds:
 183     case DoubleRep:
 184     case ValueRep:
 185     case Int52Rep:
 186     case BooleanToNumber:
 187     case FiatInt52:
 188     case MakeRope:
 189     case StrCat:
 190     case ValueToInt32:
</pre>
<hr />
<pre>
 264             def(PureValue(node));
 265             return;
 266         }
 267         read(World);
 268         write(Heap);
 269         return;
 270 
 271     case ArithBitNot:
 272         if (node-&gt;child1().useKind() == UntypedUse) {
 273             read(World);
 274             write(Heap);
 275             return;
 276         }
 277         def(PureValue(node));
 278         return;
 279 
 280     case ArithBitAnd:
 281     case ArithBitOr:
 282     case ArithBitXor:
 283     case ArithBitLShift:
<span class="line-modified"> 284     case BitRShift:</span>
 285     case BitURShift:
 286         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 287             read(World);
 288             write(Heap);
 289             return;
 290         }
 291         def(PureValue(node));
 292         return;
 293 
 294     case ArithRandom:
 295         read(MathDotRandomState);
 296         write(MathDotRandomState);
 297         return;
 298 
 299     case GetEnumerableLength: {
 300         read(Heap);
 301         write(SideState);
 302         return;
 303     }
 304 
</pre>
<hr />
<pre>
 415         if (node-&gt;child1().useKind() == DoubleRepUse)
 416             def(PureValue(node, static_cast&lt;uintptr_t&gt;(node-&gt;arithRoundingMode())));
 417         else {
 418             read(World);
 419             write(Heap);
 420         }
 421         return;
 422 
 423     case CheckCell:
 424         def(PureValue(CheckCell, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;cellOperand()));
 425         return;
 426 
 427     case CheckNotEmpty:
 428         def(PureValue(CheckNotEmpty, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1())));
 429         return;
 430 
 431     case AssertNotEmpty:
 432         write(SideState);
 433         return;
 434 
<span class="line-modified"> 435     case CheckStringIdent:</span>
<span class="line-modified"> 436         def(PureValue(CheckStringIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));</span>
 437         return;
 438 
 439     case ConstantStoragePointer:
 440         def(PureValue(node, node-&gt;storagePointer()));
 441         return;
 442 
 443     case KillStack:
<span class="line-modified"> 444         write(AbstractHeap(Stack, node-&gt;unlinkedLocal()));</span>
 445         return;
 446 
 447     case MovHint:
 448     case ZombieHint:
 449     case ExitOK:
 450     case Upsilon:
 451     case Phi:
 452     case PhantomLocal:
 453     case SetArgumentDefinitely:
 454     case SetArgumentMaybe:
 455     case Jump:
 456     case Branch:
 457     case Switch:
 458     case EntrySwitch:
 459     case ForceOSRExit:
 460     case CPUIntrinsic:
 461     case CheckBadCell:
 462     case Return:
 463     case Unreachable:
 464     case CheckTierUpInLoop:
 465     case CheckTierUpAtReturn:
 466     case CheckTierUpAndOSREnter:
 467     case LoopHint:
 468     case ProfileType:
 469     case ProfileControlFlow:
 470     case PutHint:
 471     case InitializeEntrypointArguments:
 472     case FilterCallLinkStatus:
<span class="line-modified"> 473     case FilterGetByIdStatus:</span>
 474     case FilterPutByIdStatus:
 475     case FilterInByIdStatus:
 476         write(SideState);
 477         return;
 478 
 479     case StoreBarrier:
 480         read(JSCell_cellState);
 481         write(JSCell_cellState);
 482         return;
 483 
 484     case FencedStoreBarrier:
 485         read(Heap);
 486         write(JSCell_cellState);
 487         return;
 488 
 489     case CheckTraps:
 490         read(InternalState);
 491         write(InternalState);
 492         return;
 493 
 494     case InvalidationPoint:
 495         write(SideState);
 496         def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
 497         return;
 498 
 499     case Flush:
<span class="line-modified"> 500         read(AbstractHeap(Stack, node-&gt;local()));</span>
 501         write(SideState);
 502         return;
 503 
 504     case NotifyWrite:
 505         write(Watchpoint_fire);
 506         write(SideState);
 507         return;
 508 
 509     case PushWithScope: {
 510         read(World);
 511         write(HeapObjectCount);
 512         return;
 513     }
 514 
 515     case CreateActivation: {
 516         SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 517         if (table-&gt;singleton().isStillValid())
 518             write(Watchpoint_fire);
 519         read(HeapObjectCount);
 520         write(HeapObjectCount);
 521         return;
 522     }
 523 
 524     case CreateDirectArguments:
 525     case CreateScopedArguments:
 526     case CreateClonedArguments:

 527         read(Stack);
 528         read(HeapObjectCount);
 529         write(HeapObjectCount);
 530         return;
 531 
 532     case PhantomDirectArguments:
 533     case PhantomClonedArguments:
 534         // DFG backend requires that the locals that this reads are flushed. FTL backend can handle those
 535         // locals being promoted.
 536         if (!graph.m_plan.isFTL())
 537             read(Stack);
 538 
 539         // Even though it&#39;s phantom, it still has the property that one can&#39;t be replaced with another.
 540         read(HeapObjectCount);
 541         write(HeapObjectCount);
 542         return;
 543 
 544     case PhantomSpread:
 545     case PhantomNewArrayWithSpread:
 546     case PhantomNewArrayBuffer:
</pre>
<hr />
<pre>
 631     case PutSetterByVal:
 632     case DefineDataProperty:
 633     case DefineAccessorProperty:
 634     case DeleteById:
 635     case DeleteByVal:
 636     case ArrayPush:
 637     case ArrayPop:
 638     case Call:
 639     case DirectCall:
 640     case TailCallInlinedCaller:
 641     case DirectTailCallInlinedCaller:
 642     case Construct:
 643     case DirectConstruct:
 644     case CallVarargs:
 645     case CallForwardVarargs:
 646     case TailCallVarargsInlinedCaller:
 647     case TailCallForwardVarargsInlinedCaller:
 648     case ConstructVarargs:
 649     case ConstructForwardVarargs:
 650     case ToPrimitive:

 651     case InByVal:
 652     case InById:
 653     case HasOwnProperty:
 654     case ValueNegate:
 655     case SetFunctionName:
 656     case GetDynamicVar:
 657     case PutDynamicVar:
 658     case ResolveScopeForHoistingFuncDeclInEval:
 659     case ResolveScope:
 660     case ToObject:
 661     case HasGenericProperty:
 662     case HasStructureProperty:
 663     case GetPropertyEnumerator:
 664     case GetDirectPname:
 665     case InstanceOfCustom:
 666     case ToNumber:

 667     case NumberToStringWithRadix:
 668     case CreateThis:



 669     case InstanceOf:
 670     case StringValueOf:
 671     case ObjectKeys:
 672         read(World);
 673         write(Heap);
 674         return;
 675 

















 676     case ValueBitAnd:
 677     case ValueBitXor:
 678     case ValueBitOr:
 679     case ValueAdd:
 680     case ValueSub:
 681     case ValueMul:
 682     case ValueDiv:
 683     case ValueMod:
 684     case ValuePow:
 685     case ValueBitLShift:

 686         if (node-&gt;isBinaryUseKind(BigIntUse)) {
 687             def(PureValue(node));
 688             return;
 689         }
 690         read(World);
 691         write(Heap);
 692         return;
 693 
 694     case AtomicsAdd:
 695     case AtomicsAnd:
 696     case AtomicsCompareExchange:
 697     case AtomicsExchange:
 698     case AtomicsLoad:
 699     case AtomicsOr:
 700     case AtomicsStore:
 701     case AtomicsSub:
 702     case AtomicsXor: {
 703         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
 704         Edge storageEdge = graph.child(node, 2 + numExtraArgs);
 705         if (!storageEdge) {
 706             read(World);
 707             write(Heap);
 708             return;
 709         }
 710         read(TypedArrayProperties);
 711         read(MiscFields);
 712         write(TypedArrayProperties);
 713         return;
 714     }
 715 
 716     case CallEval:
 717         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
 718         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
<span class="line-modified"> 719         read(AbstractHeap(Stack, virtualRegisterForArgument(0)));</span>
 720         read(World);
 721         write(Heap);
 722         return;
 723 
 724     case Throw:
 725     case ThrowStaticError:
 726     case TailCall:
 727     case DirectTailCall:
 728     case TailCallVarargs:
 729     case TailCallForwardVarargs:
 730         read(World);
 731         write(SideState);
 732         return;
 733 
 734     case GetGetter:
 735         read(GetterSetter_getter);
 736         def(HeapLocation(GetterLoc, GetterSetter_getter, node-&gt;child1()), LazyNode(node));
 737         return;
 738 
 739     case GetSetter:
 740         read(GetterSetter_setter);
 741         def(HeapLocation(SetterLoc, GetterSetter_setter, node-&gt;child1()), LazyNode(node));
 742         return;
 743 
 744     case GetCallee:
<span class="line-modified"> 745         read(AbstractHeap(Stack, CallFrameSlot::callee));</span>
<span class="line-modified"> 746         def(HeapLocation(StackLoc, AbstractHeap(Stack, CallFrameSlot::callee)), LazyNode(node));</span>
 747         return;
 748 
 749     case SetCallee:
<span class="line-modified"> 750         write(AbstractHeap(Stack, CallFrameSlot::callee));</span>
 751         return;
 752 
 753     case GetArgumentCountIncludingThis: {
<span class="line-modified"> 754         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCount)));</span>
 755         read(heap);
 756         def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
 757         return;
 758     }
 759 
 760     case SetArgumentCountIncludingThis:
<span class="line-modified"> 761         write(AbstractHeap(Stack, CallFrameSlot::argumentCount));</span>
 762         return;
 763 
 764     case GetRestLength:
 765         read(Stack);
 766         return;
 767 
 768     case GetLocal:
<span class="line-modified"> 769         read(AbstractHeap(Stack, node-&gt;local()));</span>
<span class="line-modified"> 770         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node));</span>
 771         return;
 772 
 773     case SetLocal:
<span class="line-modified"> 774         write(AbstractHeap(Stack, node-&gt;local()));</span>
<span class="line-modified"> 775         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;local())), LazyNode(node-&gt;child1().node()));</span>
 776         return;
 777 
 778     case GetStack: {
<span class="line-modified"> 779         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);</span>
 780         read(heap);
 781         def(HeapLocation(StackLoc, heap), LazyNode(node));
 782         return;
 783     }
 784 
 785     case PutStack: {
<span class="line-modified"> 786         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;local);</span>
 787         write(heap);
 788         def(HeapLocation(StackLoc, heap), LazyNode(node-&gt;child1().node()));
 789         return;
 790     }
 791 






 792     case LoadVarargs: {
 793         read(World);
 794         write(Heap);
 795         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified"> 796         write(AbstractHeap(Stack, data-&gt;count.offset()));</span>
 797         for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified"> 798             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));</span>
 799         return;
 800     }
 801 
 802     case ForwardVarargs: {
 803         // We could be way more precise here.
 804         read(Stack);
 805 
 806         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified"> 807         write(AbstractHeap(Stack, data-&gt;count.offset()));</span>
 808         for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified"> 809             write(AbstractHeap(Stack, data-&gt;start.offset() + static_cast&lt;int&gt;(i)));</span>
 810         return;
 811     }
 812 
 813     case GetByVal: {
 814         ArrayMode mode = node-&gt;arrayMode();
 815         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
 816         switch (mode.type()) {
 817         case Array::SelectUsingPredictions:
 818         case Array::Unprofiled:
 819         case Array::SelectUsingArguments:
 820             // Assume the worst since we don&#39;t have profiling yet.
 821             read(World);
 822             write(Heap);
 823             return;
 824 
 825         case Array::ForceExit:
 826             write(SideState);
 827             return;
 828 
 829         case Array::Generic:
</pre>
<hr />
<pre>
1001                 write(Heap);
1002                 return;
1003             }
1004             read(Butterfly_publicLength);
1005             read(Butterfly_vectorLength);
1006             read(IndexedContiguousProperties);
1007             write(IndexedContiguousProperties);
1008             if (node-&gt;arrayMode().mayStoreToHole())
1009                 write(Butterfly_publicLength);
1010             def(HeapLocation(indexedPropertyLoc, IndexedContiguousProperties, base, index), LazyNode(value));
1011             return;
1012 
1013         case Array::ArrayStorage:
1014             if (node-&gt;arrayMode().isOutOfBounds()) {
1015                 read(World);
1016                 write(Heap);
1017                 return;
1018             }
1019             read(Butterfly_publicLength);
1020             read(Butterfly_vectorLength);
<span class="line-modified">1021             read(ArrayStorageProperties);</span>
<span class="line-modified">1022             write(ArrayStorageProperties);</span>
1023             if (node-&gt;arrayMode().mayStoreToHole())
1024                 write(Butterfly_publicLength);
1025             return;
1026 
1027         case Array::SlowPutArrayStorage:
1028             if (node-&gt;arrayMode().mayStoreToHole()) {
1029                 read(World);
1030                 write(Heap);
1031                 return;
1032             }
1033             read(Butterfly_publicLength);
1034             read(Butterfly_vectorLength);
<span class="line-modified">1035             read(ArrayStorageProperties);</span>
<span class="line-modified">1036             write(ArrayStorageProperties);</span>
1037             return;
1038 
1039         case Array::Int8Array:
1040         case Array::Int16Array:
1041         case Array::Int32Array:
1042         case Array::Uint8Array:
1043         case Array::Uint8ClampedArray:
1044         case Array::Uint16Array:
1045         case Array::Uint32Array:
1046         case Array::Float32Array:
1047         case Array::Float64Array:
1048             read(MiscFields);
1049             write(TypedArrayProperties);
1050             // FIXME: We can&#39;t def() anything here because these operations truncate their inputs.
1051             // https://bugs.webkit.org/show_bug.cgi?id=134737
1052             return;
1053         case Array::AnyTypedArray:
1054         case Array::String:
1055         case Array::DirectArguments:
1056         case Array::ScopedArguments:
1057             DFG_CRASH(graph, node, &quot;impossible array mode for put&quot;);
1058             return;
1059         }
1060         RELEASE_ASSERT_NOT_REACHED();
1061         return;
1062     }
1063 
1064     case CheckStructureOrEmpty:
1065     case CheckStructure:
1066         read(JSCell_structureID);
1067         return;
1068 

1069     case CheckArray:
1070         read(JSCell_indexingType);
<span class="line-removed">1071         read(JSCell_typeInfoType);</span>
1072         read(JSCell_structureID);
1073         return;
1074 




1075     case CheckTypeInfoFlags:
1076         read(JSCell_typeInfoFlags);
1077         def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1078         return;
1079 
1080     case ParseInt:
1081         // Note: We would have eliminated a ParseInt that has just a single child as an Int32Use inside fixup.
1082         if (node-&gt;child1().useKind() == StringUse &amp;&amp; (!node-&gt;child2() || node-&gt;child2().useKind() == Int32Use)) {
1083             def(PureValue(node));
1084             return;
1085         }
1086 
1087         read(World);
1088         write(Heap);
1089         return;
1090 
1091     case OverridesHasInstance:
1092         read(JSCell_typeInfoFlags);
1093         def(HeapLocation(OverridesHasInstanceLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1094         return;
1095 
1096     case PutStructure:
1097         read(JSObject_butterfly);
1098         write(JSCell_structureID);
<span class="line-removed">1099         write(JSCell_typeInfoType);</span>
1100         write(JSCell_typeInfoFlags);
1101         write(JSCell_indexingType);
1102         return;
1103 
1104     case AllocatePropertyStorage:
1105     case ReallocatePropertyStorage:
1106         read(HeapObjectCount);
1107         write(HeapObjectCount);
1108         return;
1109 
1110     case NukeStructureAndSetButterfly:
1111         write(JSObject_butterfly);
1112         write(JSCell_structureID);
1113         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1114         return;
1115 
1116     case GetButterfly:
1117         read(JSObject_butterfly);
1118         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node));
1119         return;
</pre>
<hr />
<pre>
1299             read(Butterfly_vectorLength);
1300             def(HeapLocation(VectorLengthLoc, Butterfly_vectorLength, node-&gt;child1()), LazyNode(node));
1301             return;
1302 
1303         default:
1304             RELEASE_ASSERT_NOT_REACHED();
1305             return;
1306         }
1307     }
1308 
1309     case GetClosureVar:
1310         read(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1311         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node));
1312         return;
1313 
1314     case PutClosureVar:
1315         write(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1316         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1317         return;
1318 














1319     case GetRegExpObjectLastIndex:
1320         read(RegExpObject_lastIndex);
1321         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node));
1322         return;
1323 
1324     case SetRegExpObjectLastIndex:
1325         write(RegExpObject_lastIndex);
1326         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1327         return;
1328 
1329     case RecordRegExpCachedResult:
1330         write(RegExpState);
1331         return;
1332 
1333     case GetFromArguments: {
1334         AbstractHeap heap(DirectArgumentsProperties, node-&gt;capturedArgumentsOffset().offset());
1335         read(heap);
1336         def(HeapLocation(DirectArgumentsLoc, heap, node-&gt;child1()), LazyNode(node));
1337         return;
1338     }
</pre>
<hr />
<pre>
1366         read(HeapObjectCount);
1367         write(HeapObjectCount);
1368         return;
1369 
1370     case NewTypedArray:
1371         switch (node-&gt;child1().useKind()) {
1372         case Int32Use:
1373             read(HeapObjectCount);
1374             write(HeapObjectCount);
1375             return;
1376         case UntypedUse:
1377             read(World);
1378             write(Heap);
1379             return;
1380         default:
1381             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
1382         }
1383         break;
1384 
1385     case NewArrayWithSpread: {
<span class="line-removed">1386         // This also reads from JSFixedArray&#39;s data store, but we don&#39;t have any way of describing that yet.</span>
1387         read(HeapObjectCount);

1388         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
1389             Node* child = graph.varArgChild(node, i).node();
1390             if (child-&gt;op() == PhantomSpread) {
1391                 read(Stack);
1392                 break;
1393             }
1394         }
1395         write(HeapObjectCount);
1396         return;
1397     }
1398 
1399     case Spread: {
1400         if (node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
1401             read(MiscFields);
1402             return;
1403         }
1404 
1405         if (node-&gt;child1()-&gt;op() == PhantomCreateRest) {
1406             read(Stack);
1407             write(HeapObjectCount);
</pre>
<hr />
<pre>
1532         return;
1533     }
1534 
1535     case ObjectCreate: {
1536         switch (node-&gt;child1().useKind()) {
1537         case ObjectUse:
1538             read(HeapObjectCount);
1539             write(HeapObjectCount);
1540             return;
1541         case UntypedUse:
1542             read(World);
1543             write(Heap);
1544             return;
1545         default:
1546             RELEASE_ASSERT_NOT_REACHED();
1547             return;
1548         }
1549     }
1550 
1551     case NewObject:




1552     case NewRegexp:
1553     case NewSymbol:
1554     case NewStringObject:
1555     case PhantomNewObject:
1556     case MaterializeNewObject:
1557     case PhantomNewFunction:
1558     case PhantomNewGeneratorFunction:
1559     case PhantomNewAsyncFunction:
1560     case PhantomNewAsyncGeneratorFunction:


1561     case PhantomCreateActivation:
1562     case MaterializeCreateActivation:
1563     case PhantomNewRegexp:
1564         read(HeapObjectCount);
1565         write(HeapObjectCount);
1566         return;
1567 
1568     case NewFunction:
1569     case NewGeneratorFunction:
1570     case NewAsyncGeneratorFunction:
1571     case NewAsyncFunction:
1572         if (node-&gt;castOperand&lt;FunctionExecutable*&gt;()-&gt;singleton().isStillValid())
1573             write(Watchpoint_fire);
1574         read(HeapObjectCount);
1575         write(HeapObjectCount);
1576         return;
1577 
1578     case RegExpExec:
1579     case RegExpTest:
1580         // Even if we&#39;ve proven known input types as RegExpObject and String,
</pre>
<hr />
<pre>
1774         write(JSWeakMapFields);
1775         def(HeapLocation(WeakMapGetLoc, JSWeakMapFields, mapEdge, keyEdge), LazyNode(valueEdge.node()));
1776         return;
1777     }
1778 
1779     case ExtractValueFromWeakMapGet:
1780         def(PureValue(node));
1781         return;
1782 
1783     case StringSlice:
1784         def(PureValue(node));
1785         return;
1786 
1787     case ToLowerCase:
1788         def(PureValue(node));
1789         return;
1790 
1791     case NumberToStringWithValidRadixConstant:
1792         def(PureValue(node, node-&gt;validRadixConstant()));
1793         return;







1794 
1795     case DataViewGetFloat:
1796     case DataViewGetInt: {
1797         read(MiscFields);
1798         read(TypedArrayProperties);
1799         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
1800         def(HeapLocation(indexedPropertyLoc, AbstractHeap(TypedArrayProperties, node-&gt;dataViewData().asQuadWord),
1801             node-&gt;child1(), node-&gt;child2(), node-&gt;child3()), LazyNode(node));
1802         return;
1803     }
1804 
1805     case DataViewSet: {
1806         read(MiscFields);
1807         read(TypedArrayProperties);
1808         write(TypedArrayProperties);
1809         return;
1810     }
1811 
1812     case LastNodeType:
1813         RELEASE_ASSERT_NOT_REACHED();
</pre>
</td>
<td>
<hr />
<pre>
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;DFGAbstractHeap.h&quot;
  31 #include &quot;DFGGraph.h&quot;
  32 #include &quot;DFGHeapLocation.h&quot;
  33 #include &quot;DFGLazyNode.h&quot;
  34 #include &quot;DFGPureValue.h&quot;
  35 #include &quot;DOMJITCallDOMGetterSnippet.h&quot;
  36 #include &quot;DOMJITSignature.h&quot;
  37 #include &quot;InlineCallFrame.h&quot;

  38 #include &quot;JSImmutableButterfly.h&quot;
  39 
  40 namespace JSC { namespace DFG {
  41 
  42 template&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;
  43 void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFunctor&amp; write, const DefFunctor&amp; def)
  44 {
  45     // Some notes:
  46     //
  47     // - The canonical way of clobbering the world is to read world and write
  48     //   heap. This is because World subsumes Heap and Stack, and Stack can be
  49     //   read by anyone but only written to by explicit stack writing operations.
  50     //   Of course, claiming to also write World is not wrong; it&#39;ll just
  51     //   pessimise some important optimizations.
  52     //
  53     // - We cannot hoist, or sink, anything that has effects. This means that the
  54     //   easiest way of indicating that something cannot be hoisted is to claim
  55     //   that it side-effects some miscellaneous thing.
  56     //
  57     // - We cannot hoist forward-exiting nodes without some additional effort. I
</pre>
<hr />
<pre>
  94     //
  95     // - The abstract heap is the only abstract heap that could be clobbered to invalidate any such
  96     //   CSE attempt. I.e. if clobberize() reports that on every path between some node and a node
  97     //   that defines a HeapLocation that it wanted, there were no writes to any abstract heap that
  98     //   overlap the location&#39;s heap, then we have a sound match. Effectively, the semantics of
  99     //   write() and def() are intertwined such that for them to be sound they must agree on what
 100     //   is CSEable.
 101     //
 102     // read(), write(), and def() for heap locations is enough to do GCSE on effectful things. To
 103     // keep things simple, this code will also def() pure things. def() must be overloaded to also
 104     // accept PureValue. This way, a client of clobberize() can implement GCSE entirely using the
 105     // information that clobberize() passes to write() and def(). Other clients of clobberize() can
 106     // just ignore def() by using a NoOpClobberize functor.
 107 
 108     // We allow the runtime to perform a stack scan at any time. We don&#39;t model which nodes get implemented
 109     // by calls into the runtime. For debugging we might replace the implementation of any node with a call
 110     // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
 111     // scan would read. That&#39;s what this does.
 112     for (InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame-&gt;directCaller.inlineCallFrame()) {
 113         if (inlineCallFrame-&gt;isClosureCall)
<span class="line-modified"> 114             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee)));</span>
 115         if (inlineCallFrame-&gt;isVarargs())
<span class="line-modified"> 116             read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis)));</span>
 117     }
 118 
 119     // We don&#39;t want to specifically account which nodes can read from the scope
 120     // when the debugger is enabled. It&#39;s helpful to just claim all nodes do.
 121     // Specifically, if a node allocates, this may call into the debugger&#39;s machinery.
 122     // The debugger&#39;s machinery is free to take a stack trace and try to read from
 123     // a scope which is expected to be flushed to the stack.
 124     if (graph.hasDebuggerEnabled()) {
 125         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
 126         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
 127     }
 128 
 129     switch (node-&gt;op()) {
 130     case JSConstant:
 131     case DoubleConstant:
 132     case Int52Constant:
 133         def(PureValue(node, node-&gt;constant()));
 134         return;
 135 
 136     case Identity:
</pre>
<hr />
<pre>
 150         write(CatchLocals);
 151         return;
 152 
 153     case LazyJSConstant:
 154         // We should enable CSE of LazyJSConstant. It&#39;s a little annoying since LazyJSValue has
 155         // more bits than we currently have in PureValue.
 156         return;
 157 
 158     case CompareEqPtr:
 159         def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));
 160         return;
 161 
 162     case ArithIMul:
 163     case ArithMin:
 164     case ArithMax:
 165     case ArithPow:
 166     case GetScope:
 167     case SkipScope:
 168     case GetGlobalObject:
 169     case StringCharCodeAt:
<span class="line-added"> 170     case StringCodePointAt:</span>
 171     case CompareStrictEq:
 172     case SameValue:
 173     case IsEmpty:
 174     case IsUndefined:
 175     case IsUndefinedOrNull:
 176     case IsBoolean:
 177     case IsNumber:
 178     case NumberIsInteger:
 179     case IsObject:
 180     case IsTypedArrayView:
 181     case LogicalNot:
 182     case CheckInBounds:
 183     case DoubleRep:
 184     case ValueRep:
 185     case Int52Rep:
 186     case BooleanToNumber:
 187     case FiatInt52:
 188     case MakeRope:
 189     case StrCat:
 190     case ValueToInt32:
</pre>
<hr />
<pre>
 264             def(PureValue(node));
 265             return;
 266         }
 267         read(World);
 268         write(Heap);
 269         return;
 270 
 271     case ArithBitNot:
 272         if (node-&gt;child1().useKind() == UntypedUse) {
 273             read(World);
 274             write(Heap);
 275             return;
 276         }
 277         def(PureValue(node));
 278         return;
 279 
 280     case ArithBitAnd:
 281     case ArithBitOr:
 282     case ArithBitXor:
 283     case ArithBitLShift:
<span class="line-modified"> 284     case ArithBitRShift:</span>
 285     case BitURShift:
 286         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 287             read(World);
 288             write(Heap);
 289             return;
 290         }
 291         def(PureValue(node));
 292         return;
 293 
 294     case ArithRandom:
 295         read(MathDotRandomState);
 296         write(MathDotRandomState);
 297         return;
 298 
 299     case GetEnumerableLength: {
 300         read(Heap);
 301         write(SideState);
 302         return;
 303     }
 304 
</pre>
<hr />
<pre>
 415         if (node-&gt;child1().useKind() == DoubleRepUse)
 416             def(PureValue(node, static_cast&lt;uintptr_t&gt;(node-&gt;arithRoundingMode())));
 417         else {
 418             read(World);
 419             write(Heap);
 420         }
 421         return;
 422 
 423     case CheckCell:
 424         def(PureValue(CheckCell, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;cellOperand()));
 425         return;
 426 
 427     case CheckNotEmpty:
 428         def(PureValue(CheckNotEmpty, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1())));
 429         return;
 430 
 431     case AssertNotEmpty:
 432         write(SideState);
 433         return;
 434 
<span class="line-modified"> 435     case CheckIdent:</span>
<span class="line-modified"> 436         def(PureValue(CheckIdent, AdjacencyList(AdjacencyList::Fixed, node-&gt;child1()), node-&gt;uidOperand()));</span>
 437         return;
 438 
 439     case ConstantStoragePointer:
 440         def(PureValue(node, node-&gt;storagePointer()));
 441         return;
 442 
 443     case KillStack:
<span class="line-modified"> 444         write(AbstractHeap(Stack, node-&gt;unlinkedOperand()));</span>
 445         return;
 446 
 447     case MovHint:
 448     case ZombieHint:
 449     case ExitOK:
 450     case Upsilon:
 451     case Phi:
 452     case PhantomLocal:
 453     case SetArgumentDefinitely:
 454     case SetArgumentMaybe:
 455     case Jump:
 456     case Branch:
 457     case Switch:
 458     case EntrySwitch:
 459     case ForceOSRExit:
 460     case CPUIntrinsic:
 461     case CheckBadCell:
 462     case Return:
 463     case Unreachable:
 464     case CheckTierUpInLoop:
 465     case CheckTierUpAtReturn:
 466     case CheckTierUpAndOSREnter:
 467     case LoopHint:
 468     case ProfileType:
 469     case ProfileControlFlow:
 470     case PutHint:
 471     case InitializeEntrypointArguments:
 472     case FilterCallLinkStatus:
<span class="line-modified"> 473     case FilterGetByStatus:</span>
 474     case FilterPutByIdStatus:
 475     case FilterInByIdStatus:
 476         write(SideState);
 477         return;
 478 
 479     case StoreBarrier:
 480         read(JSCell_cellState);
 481         write(JSCell_cellState);
 482         return;
 483 
 484     case FencedStoreBarrier:
 485         read(Heap);
 486         write(JSCell_cellState);
 487         return;
 488 
 489     case CheckTraps:
 490         read(InternalState);
 491         write(InternalState);
 492         return;
 493 
 494     case InvalidationPoint:
 495         write(SideState);
 496         def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
 497         return;
 498 
 499     case Flush:
<span class="line-modified"> 500         read(AbstractHeap(Stack, node-&gt;operand()));</span>
 501         write(SideState);
 502         return;
 503 
 504     case NotifyWrite:
 505         write(Watchpoint_fire);
 506         write(SideState);
 507         return;
 508 
 509     case PushWithScope: {
 510         read(World);
 511         write(HeapObjectCount);
 512         return;
 513     }
 514 
 515     case CreateActivation: {
 516         SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 517         if (table-&gt;singleton().isStillValid())
 518             write(Watchpoint_fire);
 519         read(HeapObjectCount);
 520         write(HeapObjectCount);
 521         return;
 522     }
 523 
 524     case CreateDirectArguments:
 525     case CreateScopedArguments:
 526     case CreateClonedArguments:
<span class="line-added"> 527     case CreateArgumentsButterfly:</span>
 528         read(Stack);
 529         read(HeapObjectCount);
 530         write(HeapObjectCount);
 531         return;
 532 
 533     case PhantomDirectArguments:
 534     case PhantomClonedArguments:
 535         // DFG backend requires that the locals that this reads are flushed. FTL backend can handle those
 536         // locals being promoted.
 537         if (!graph.m_plan.isFTL())
 538             read(Stack);
 539 
 540         // Even though it&#39;s phantom, it still has the property that one can&#39;t be replaced with another.
 541         read(HeapObjectCount);
 542         write(HeapObjectCount);
 543         return;
 544 
 545     case PhantomSpread:
 546     case PhantomNewArrayWithSpread:
 547     case PhantomNewArrayBuffer:
</pre>
<hr />
<pre>
 632     case PutSetterByVal:
 633     case DefineDataProperty:
 634     case DefineAccessorProperty:
 635     case DeleteById:
 636     case DeleteByVal:
 637     case ArrayPush:
 638     case ArrayPop:
 639     case Call:
 640     case DirectCall:
 641     case TailCallInlinedCaller:
 642     case DirectTailCallInlinedCaller:
 643     case Construct:
 644     case DirectConstruct:
 645     case CallVarargs:
 646     case CallForwardVarargs:
 647     case TailCallVarargsInlinedCaller:
 648     case TailCallForwardVarargsInlinedCaller:
 649     case ConstructVarargs:
 650     case ConstructForwardVarargs:
 651     case ToPrimitive:
<span class="line-added"> 652     case ToPropertyKey:</span>
 653     case InByVal:
 654     case InById:
 655     case HasOwnProperty:
 656     case ValueNegate:
 657     case SetFunctionName:
 658     case GetDynamicVar:
 659     case PutDynamicVar:
 660     case ResolveScopeForHoistingFuncDeclInEval:
 661     case ResolveScope:
 662     case ToObject:
 663     case HasGenericProperty:
 664     case HasStructureProperty:
 665     case GetPropertyEnumerator:
 666     case GetDirectPname:
 667     case InstanceOfCustom:
 668     case ToNumber:
<span class="line-added"> 669     case ToNumeric:</span>
 670     case NumberToStringWithRadix:
 671     case CreateThis:
<span class="line-added"> 672     case CreatePromise:</span>
<span class="line-added"> 673     case CreateGenerator:</span>
<span class="line-added"> 674     case CreateAsyncGenerator:</span>
 675     case InstanceOf:
 676     case StringValueOf:
 677     case ObjectKeys:
 678         read(World);
 679         write(Heap);
 680         return;
 681 
<span class="line-added"> 682     case Inc:</span>
<span class="line-added"> 683     case Dec:</span>
<span class="line-added"> 684         switch (node-&gt;child1().useKind()) {</span>
<span class="line-added"> 685         case Int32Use:</span>
<span class="line-added"> 686         case Int52RepUse:</span>
<span class="line-added"> 687         case DoubleRepUse:</span>
<span class="line-added"> 688         case BigIntUse:</span>
<span class="line-added"> 689             def(PureValue(node));</span>
<span class="line-added"> 690             return;</span>
<span class="line-added"> 691         case UntypedUse:</span>
<span class="line-added"> 692             read(World);</span>
<span class="line-added"> 693             write(Heap);</span>
<span class="line-added"> 694             return;</span>
<span class="line-added"> 695         default:</span>
<span class="line-added"> 696             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);</span>
<span class="line-added"> 697         }</span>
<span class="line-added"> 698 </span>
 699     case ValueBitAnd:
 700     case ValueBitXor:
 701     case ValueBitOr:
 702     case ValueAdd:
 703     case ValueSub:
 704     case ValueMul:
 705     case ValueDiv:
 706     case ValueMod:
 707     case ValuePow:
 708     case ValueBitLShift:
<span class="line-added"> 709     case ValueBitRShift:</span>
 710         if (node-&gt;isBinaryUseKind(BigIntUse)) {
 711             def(PureValue(node));
 712             return;
 713         }
 714         read(World);
 715         write(Heap);
 716         return;
 717 
 718     case AtomicsAdd:
 719     case AtomicsAnd:
 720     case AtomicsCompareExchange:
 721     case AtomicsExchange:
 722     case AtomicsLoad:
 723     case AtomicsOr:
 724     case AtomicsStore:
 725     case AtomicsSub:
 726     case AtomicsXor: {
 727         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
 728         Edge storageEdge = graph.child(node, 2 + numExtraArgs);
 729         if (!storageEdge) {
 730             read(World);
 731             write(Heap);
 732             return;
 733         }
 734         read(TypedArrayProperties);
 735         read(MiscFields);
 736         write(TypedArrayProperties);
 737         return;
 738     }
 739 
 740     case CallEval:
 741         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
 742         read(AbstractHeap(Stack, graph.m_codeBlock-&gt;scopeRegister()));
<span class="line-modified"> 743         read(AbstractHeap(Stack, virtualRegisterForArgumentIncludingThis(0)));</span>
 744         read(World);
 745         write(Heap);
 746         return;
 747 
 748     case Throw:
 749     case ThrowStaticError:
 750     case TailCall:
 751     case DirectTailCall:
 752     case TailCallVarargs:
 753     case TailCallForwardVarargs:
 754         read(World);
 755         write(SideState);
 756         return;
 757 
 758     case GetGetter:
 759         read(GetterSetter_getter);
 760         def(HeapLocation(GetterLoc, GetterSetter_getter, node-&gt;child1()), LazyNode(node));
 761         return;
 762 
 763     case GetSetter:
 764         read(GetterSetter_setter);
 765         def(HeapLocation(SetterLoc, GetterSetter_setter, node-&gt;child1()), LazyNode(node));
 766         return;
 767 
 768     case GetCallee:
<span class="line-modified"> 769         read(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));</span>
<span class="line-modified"> 770         def(HeapLocation(StackLoc, AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee))), LazyNode(node));</span>
 771         return;
 772 
 773     case SetCallee:
<span class="line-modified"> 774         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));</span>
 775         return;
 776 
 777     case GetArgumentCountIncludingThis: {
<span class="line-modified"> 778         auto heap = AbstractHeap(Stack, remapOperand(node-&gt;argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 779         read(heap);
 780         def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
 781         return;
 782     }
 783 
 784     case SetArgumentCountIncludingThis:
<span class="line-modified"> 785         write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 786         return;
 787 
 788     case GetRestLength:
 789         read(Stack);
 790         return;
 791 
 792     case GetLocal:
<span class="line-modified"> 793         read(AbstractHeap(Stack, node-&gt;operand()));</span>
<span class="line-modified"> 794         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node));</span>
 795         return;
 796 
 797     case SetLocal:
<span class="line-modified"> 798         write(AbstractHeap(Stack, node-&gt;operand()));</span>
<span class="line-modified"> 799         def(HeapLocation(StackLoc, AbstractHeap(Stack, node-&gt;operand())), LazyNode(node-&gt;child1().node()));</span>
 800         return;
 801 
 802     case GetStack: {
<span class="line-modified"> 803         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);</span>
 804         read(heap);
 805         def(HeapLocation(StackLoc, heap), LazyNode(node));
 806         return;
 807     }
 808 
 809     case PutStack: {
<span class="line-modified"> 810         AbstractHeap heap(Stack, node-&gt;stackAccessData()-&gt;operand);</span>
 811         write(heap);
 812         def(HeapLocation(StackLoc, heap), LazyNode(node-&gt;child1().node()));
 813         return;
 814     }
 815 
<span class="line-added"> 816     case VarargsLength: {</span>
<span class="line-added"> 817         read(World);</span>
<span class="line-added"> 818         write(Heap);</span>
<span class="line-added"> 819         return;</span>
<span class="line-added"> 820     }</span>
<span class="line-added"> 821 </span>
 822     case LoadVarargs: {
 823         read(World);
 824         write(Heap);
 825         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified"> 826         write(AbstractHeap(Stack, data-&gt;count));</span>
 827         for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified"> 828             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));</span>
 829         return;
 830     }
 831 
 832     case ForwardVarargs: {
 833         // We could be way more precise here.
 834         read(Stack);
 835 
 836         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified"> 837         write(AbstractHeap(Stack, data-&gt;count));</span>
 838         for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified"> 839             write(AbstractHeap(Stack, data-&gt;start + static_cast&lt;int&gt;(i)));</span>
 840         return;
 841     }
 842 
 843     case GetByVal: {
 844         ArrayMode mode = node-&gt;arrayMode();
 845         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
 846         switch (mode.type()) {
 847         case Array::SelectUsingPredictions:
 848         case Array::Unprofiled:
 849         case Array::SelectUsingArguments:
 850             // Assume the worst since we don&#39;t have profiling yet.
 851             read(World);
 852             write(Heap);
 853             return;
 854 
 855         case Array::ForceExit:
 856             write(SideState);
 857             return;
 858 
 859         case Array::Generic:
</pre>
<hr />
<pre>
1031                 write(Heap);
1032                 return;
1033             }
1034             read(Butterfly_publicLength);
1035             read(Butterfly_vectorLength);
1036             read(IndexedContiguousProperties);
1037             write(IndexedContiguousProperties);
1038             if (node-&gt;arrayMode().mayStoreToHole())
1039                 write(Butterfly_publicLength);
1040             def(HeapLocation(indexedPropertyLoc, IndexedContiguousProperties, base, index), LazyNode(value));
1041             return;
1042 
1043         case Array::ArrayStorage:
1044             if (node-&gt;arrayMode().isOutOfBounds()) {
1045                 read(World);
1046                 write(Heap);
1047                 return;
1048             }
1049             read(Butterfly_publicLength);
1050             read(Butterfly_vectorLength);
<span class="line-modified">1051             read(IndexedArrayStorageProperties);</span>
<span class="line-modified">1052             write(IndexedArrayStorageProperties);</span>
1053             if (node-&gt;arrayMode().mayStoreToHole())
1054                 write(Butterfly_publicLength);
1055             return;
1056 
1057         case Array::SlowPutArrayStorage:
1058             if (node-&gt;arrayMode().mayStoreToHole()) {
1059                 read(World);
1060                 write(Heap);
1061                 return;
1062             }
1063             read(Butterfly_publicLength);
1064             read(Butterfly_vectorLength);
<span class="line-modified">1065             read(IndexedArrayStorageProperties);</span>
<span class="line-modified">1066             write(IndexedArrayStorageProperties);</span>
1067             return;
1068 
1069         case Array::Int8Array:
1070         case Array::Int16Array:
1071         case Array::Int32Array:
1072         case Array::Uint8Array:
1073         case Array::Uint8ClampedArray:
1074         case Array::Uint16Array:
1075         case Array::Uint32Array:
1076         case Array::Float32Array:
1077         case Array::Float64Array:
1078             read(MiscFields);
1079             write(TypedArrayProperties);
1080             // FIXME: We can&#39;t def() anything here because these operations truncate their inputs.
1081             // https://bugs.webkit.org/show_bug.cgi?id=134737
1082             return;
1083         case Array::AnyTypedArray:
1084         case Array::String:
1085         case Array::DirectArguments:
1086         case Array::ScopedArguments:
1087             DFG_CRASH(graph, node, &quot;impossible array mode for put&quot;);
1088             return;
1089         }
1090         RELEASE_ASSERT_NOT_REACHED();
1091         return;
1092     }
1093 
1094     case CheckStructureOrEmpty:
1095     case CheckStructure:
1096         read(JSCell_structureID);
1097         return;
1098 
<span class="line-added">1099     case CheckArrayOrEmpty:</span>
1100     case CheckArray:
1101         read(JSCell_indexingType);

1102         read(JSCell_structureID);
1103         return;
1104 
<span class="line-added">1105     case CheckNeutered:</span>
<span class="line-added">1106         read(MiscFields);</span>
<span class="line-added">1107         return;</span>
<span class="line-added">1108 </span>
1109     case CheckTypeInfoFlags:
1110         read(JSCell_typeInfoFlags);
1111         def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1112         return;
1113 
1114     case ParseInt:
1115         // Note: We would have eliminated a ParseInt that has just a single child as an Int32Use inside fixup.
1116         if (node-&gt;child1().useKind() == StringUse &amp;&amp; (!node-&gt;child2() || node-&gt;child2().useKind() == Int32Use)) {
1117             def(PureValue(node));
1118             return;
1119         }
1120 
1121         read(World);
1122         write(Heap);
1123         return;
1124 
1125     case OverridesHasInstance:
1126         read(JSCell_typeInfoFlags);
1127         def(HeapLocation(OverridesHasInstanceLoc, JSCell_typeInfoFlags, node-&gt;child1()), LazyNode(node));
1128         return;
1129 
1130     case PutStructure:
1131         read(JSObject_butterfly);
1132         write(JSCell_structureID);

1133         write(JSCell_typeInfoFlags);
1134         write(JSCell_indexingType);
1135         return;
1136 
1137     case AllocatePropertyStorage:
1138     case ReallocatePropertyStorage:
1139         read(HeapObjectCount);
1140         write(HeapObjectCount);
1141         return;
1142 
1143     case NukeStructureAndSetButterfly:
1144         write(JSObject_butterfly);
1145         write(JSCell_structureID);
1146         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1147         return;
1148 
1149     case GetButterfly:
1150         read(JSObject_butterfly);
1151         def(HeapLocation(ButterflyLoc, JSObject_butterfly, node-&gt;child1()), LazyNode(node));
1152         return;
</pre>
<hr />
<pre>
1332             read(Butterfly_vectorLength);
1333             def(HeapLocation(VectorLengthLoc, Butterfly_vectorLength, node-&gt;child1()), LazyNode(node));
1334             return;
1335 
1336         default:
1337             RELEASE_ASSERT_NOT_REACHED();
1338             return;
1339         }
1340     }
1341 
1342     case GetClosureVar:
1343         read(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1344         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node));
1345         return;
1346 
1347     case PutClosureVar:
1348         write(AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()));
1349         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node-&gt;scopeOffset().offset()), node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1350         return;
1351 
<span class="line-added">1352     case GetInternalField: {</span>
<span class="line-added">1353         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());</span>
<span class="line-added">1354         read(heap);</span>
<span class="line-added">1355         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node));</span>
<span class="line-added">1356         return;</span>
<span class="line-added">1357     }</span>
<span class="line-added">1358 </span>
<span class="line-added">1359     case PutInternalField: {</span>
<span class="line-added">1360         AbstractHeap heap(JSInternalFields, node-&gt;internalFieldIndex());</span>
<span class="line-added">1361         write(heap);</span>
<span class="line-added">1362         def(HeapLocation(InternalFieldObjectLoc, heap, node-&gt;child1()), LazyNode(node-&gt;child2().node()));</span>
<span class="line-added">1363         return;</span>
<span class="line-added">1364     }</span>
<span class="line-added">1365 </span>
1366     case GetRegExpObjectLastIndex:
1367         read(RegExpObject_lastIndex);
1368         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node));
1369         return;
1370 
1371     case SetRegExpObjectLastIndex:
1372         write(RegExpObject_lastIndex);
1373         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node-&gt;child1()), LazyNode(node-&gt;child2().node()));
1374         return;
1375 
1376     case RecordRegExpCachedResult:
1377         write(RegExpState);
1378         return;
1379 
1380     case GetFromArguments: {
1381         AbstractHeap heap(DirectArgumentsProperties, node-&gt;capturedArgumentsOffset().offset());
1382         read(heap);
1383         def(HeapLocation(DirectArgumentsLoc, heap, node-&gt;child1()), LazyNode(node));
1384         return;
1385     }
</pre>
<hr />
<pre>
1413         read(HeapObjectCount);
1414         write(HeapObjectCount);
1415         return;
1416 
1417     case NewTypedArray:
1418         switch (node-&gt;child1().useKind()) {
1419         case Int32Use:
1420             read(HeapObjectCount);
1421             write(HeapObjectCount);
1422             return;
1423         case UntypedUse:
1424             read(World);
1425             write(Heap);
1426             return;
1427         default:
1428             DFG_CRASH(graph, node, &quot;Bad use kind&quot;);
1429         }
1430         break;
1431 
1432     case NewArrayWithSpread: {

1433         read(HeapObjectCount);
<span class="line-added">1434         // This appears to read nothing because it&#39;s only reading immutable butterfly data.</span>
1435         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
1436             Node* child = graph.varArgChild(node, i).node();
1437             if (child-&gt;op() == PhantomSpread) {
1438                 read(Stack);
1439                 break;
1440             }
1441         }
1442         write(HeapObjectCount);
1443         return;
1444     }
1445 
1446     case Spread: {
1447         if (node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
1448             read(MiscFields);
1449             return;
1450         }
1451 
1452         if (node-&gt;child1()-&gt;op() == PhantomCreateRest) {
1453             read(Stack);
1454             write(HeapObjectCount);
</pre>
<hr />
<pre>
1579         return;
1580     }
1581 
1582     case ObjectCreate: {
1583         switch (node-&gt;child1().useKind()) {
1584         case ObjectUse:
1585             read(HeapObjectCount);
1586             write(HeapObjectCount);
1587             return;
1588         case UntypedUse:
1589             read(World);
1590             write(Heap);
1591             return;
1592         default:
1593             RELEASE_ASSERT_NOT_REACHED();
1594             return;
1595         }
1596     }
1597 
1598     case NewObject:
<span class="line-added">1599     case NewPromise:</span>
<span class="line-added">1600     case NewGenerator:</span>
<span class="line-added">1601     case NewAsyncGenerator:</span>
<span class="line-added">1602     case NewArrayIterator:</span>
1603     case NewRegexp:
1604     case NewSymbol:
1605     case NewStringObject:
1606     case PhantomNewObject:
1607     case MaterializeNewObject:
1608     case PhantomNewFunction:
1609     case PhantomNewGeneratorFunction:
1610     case PhantomNewAsyncFunction:
1611     case PhantomNewAsyncGeneratorFunction:
<span class="line-added">1612     case PhantomNewArrayIterator:</span>
<span class="line-added">1613     case MaterializeNewInternalFieldObject:</span>
1614     case PhantomCreateActivation:
1615     case MaterializeCreateActivation:
1616     case PhantomNewRegexp:
1617         read(HeapObjectCount);
1618         write(HeapObjectCount);
1619         return;
1620 
1621     case NewFunction:
1622     case NewGeneratorFunction:
1623     case NewAsyncGeneratorFunction:
1624     case NewAsyncFunction:
1625         if (node-&gt;castOperand&lt;FunctionExecutable*&gt;()-&gt;singleton().isStillValid())
1626             write(Watchpoint_fire);
1627         read(HeapObjectCount);
1628         write(HeapObjectCount);
1629         return;
1630 
1631     case RegExpExec:
1632     case RegExpTest:
1633         // Even if we&#39;ve proven known input types as RegExpObject and String,
</pre>
<hr />
<pre>
1827         write(JSWeakMapFields);
1828         def(HeapLocation(WeakMapGetLoc, JSWeakMapFields, mapEdge, keyEdge), LazyNode(valueEdge.node()));
1829         return;
1830     }
1831 
1832     case ExtractValueFromWeakMapGet:
1833         def(PureValue(node));
1834         return;
1835 
1836     case StringSlice:
1837         def(PureValue(node));
1838         return;
1839 
1840     case ToLowerCase:
1841         def(PureValue(node));
1842         return;
1843 
1844     case NumberToStringWithValidRadixConstant:
1845         def(PureValue(node, node-&gt;validRadixConstant()));
1846         return;
<span class="line-added">1847 </span>
<span class="line-added">1848     case DateGetTime:</span>
<span class="line-added">1849     case DateGetInt32OrNaN: {</span>
<span class="line-added">1850         read(JSDateFields);</span>
<span class="line-added">1851         def(HeapLocation(DateFieldLoc, AbstractHeap(JSDateFields, static_cast&lt;uint64_t&gt;(node-&gt;intrinsic())), node-&gt;child1()), LazyNode(node));</span>
<span class="line-added">1852         return;</span>
<span class="line-added">1853     }</span>
1854 
1855     case DataViewGetFloat:
1856     case DataViewGetInt: {
1857         read(MiscFields);
1858         read(TypedArrayProperties);
1859         LocationKind indexedPropertyLoc = indexedPropertyLocForResultType(node-&gt;result());
1860         def(HeapLocation(indexedPropertyLoc, AbstractHeap(TypedArrayProperties, node-&gt;dataViewData().asQuadWord),
1861             node-&gt;child1(), node-&gt;child2(), node-&gt;child3()), LazyNode(node));
1862         return;
1863     }
1864 
1865     case DataViewSet: {
1866         read(MiscFields);
1867         read(TypedArrayProperties);
1868         write(TypedArrayProperties);
1869         return;
1870     }
1871 
1872     case LastNodeType:
1873         RELEASE_ASSERT_NOT_REACHED();
</pre>
</td>
</tr>
</table>
<center><a href="DFGCapabilities.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGClobbersExitState.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
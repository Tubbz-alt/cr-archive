diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2017-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -25,19 +25,22 @@
 
 #pragma once
 
 #if ENABLE(JIT)
 
+#include "CacheableIdentifier.h"
 #include "JSFunctionInlines.h"
 #include "ObjectPropertyConditionSet.h"
 #include "PolyProtoAccessChain.h"
 #include <wtf/CommaPrinter.h>
 
 namespace JSC {
 
 struct AccessGenerationState;
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AccessCase);
+
 // An AccessCase describes one of the cases of a PolymorphicAccess. A PolymorphicAccess represents a
 // planned (to generate in future) or generated stub for some inline cache. That stub contains fast
 // path code for some finite number of fast cases, each described by an AccessCase object.
 //
 // An AccessCase object has a lifecycle that proceeds through several states. Note that the states
@@ -75,11 +78,11 @@
 //
 // We will sometimes buffer committed AccessCases in the PolymorphicAccess object before generating
 // code. This allows us to only regenerate once we've accumulated (hopefully) more than one new
 // AccessCase.
 class AccessCase {
-    WTF_MAKE_FAST_ALLOCATED;
+    WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(AccessCase);
 public:
     enum AccessType : uint8_t {
         Load,
         Transition,
         Replace,
@@ -99,11 +102,27 @@
         DirectArgumentsLength,
         ScopedArgumentsLength,
         ModuleNamespaceLoad,
         InstanceOfHit,
         InstanceOfMiss,
-        InstanceOfGeneric
+        InstanceOfGeneric,
+        IndexedInt32Load,
+        IndexedDoubleLoad,
+        IndexedContiguousLoad,
+        IndexedArrayStorageLoad,
+        IndexedScopedArgumentsLoad,
+        IndexedDirectArgumentsLoad,
+        IndexedTypedArrayInt8Load,
+        IndexedTypedArrayUint8Load,
+        IndexedTypedArrayUint8ClampedLoad,
+        IndexedTypedArrayInt16Load,
+        IndexedTypedArrayUint16Load,
+        IndexedTypedArrayInt32Load,
+        IndexedTypedArrayUint32Load,
+        IndexedTypedArrayFloat32Load,
+        IndexedTypedArrayFloat64Load,
+        IndexedStringLoad
     };
 
     enum State : uint8_t {
         Primordial,
         Committed,
@@ -121,18 +140,18 @@
     static std::unique_ptr<AccessCaseType> create(Arguments... arguments)
     {
         return std::unique_ptr<AccessCaseType>(new AccessCaseType(arguments...));
     }
 
-    static std::unique_ptr<AccessCase> create(VM&, JSCell* owner, AccessType, PropertyOffset = invalidOffset,
+    static std::unique_ptr<AccessCase> create(VM&, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset = invalidOffset,
         Structure* = nullptr, const ObjectPropertyConditionSet& = ObjectPropertyConditionSet(), std::unique_ptr<PolyProtoAccessChain> = nullptr);
 
     // This create method should be used for transitions.
-    static std::unique_ptr<AccessCase> create(VM&, JSCell* owner, PropertyOffset, Structure* oldStructure,
+    static std::unique_ptr<AccessCase> create(VM&, JSCell* owner, CacheableIdentifier, PropertyOffset, Structure* oldStructure,
         Structure* newStructure, const ObjectPropertyConditionSet&, std::unique_ptr<PolyProtoAccessChain>);
 
-    static std::unique_ptr<AccessCase> fromStructureStubInfo(VM&, JSCell* owner, StructureStubInfo&);
+    static std::unique_ptr<AccessCase> fromStructureStubInfo(VM&, JSCell* owner, CacheableIdentifier, StructureStubInfo&);
 
     AccessType type() const { return m_type; }
     State state() const { return m_state; }
     PropertyOffset offset() const { return m_offset; }
 
@@ -140,11 +159,11 @@
     {
         if (m_type == Transition)
             return m_structure->previousID();
         return m_structure.get();
     }
-    bool guardedByStructureCheck() const;
+    bool guardedByStructureCheck(const StructureStubInfo&) const;
 
     Structure* newStructure() const
     {
         ASSERT(m_type == Transition);
         return m_structure.get();
@@ -158,11 +177,24 @@
     virtual WatchpointSet* additionalSet() const { return nullptr; }
     bool viaProxy() const { return m_viaProxy; }
 
     // If you supply the optional vector, this will append the set of cells that this will need to keep alive
     // past the call.
-    bool doesCalls(Vector<JSCell*>* cellsToMark = nullptr) const;
+    bool doesCalls(VM&, Vector<JSCell*>* cellsToMark = nullptr) const;
+
+    bool isCustom() const
+    {
+        switch (type()) {
+        case CustomValueGetter:
+        case CustomAccessorGetter:
+        case CustomValueSetter:
+        case CustomAccessorSetter:
+            return true;
+        default:
+            return false;
+        }
+    }
 
     bool isGetter() const
     {
         switch (type()) {
         case Getter:
@@ -195,20 +227,36 @@
     bool usesPolyProto() const
     {
         return !!m_polyProtoAccessChain;
     }
 
+    bool requiresIdentifierNameMatch() const;
+    bool requiresInt32PropertyCheck() const;
+    bool needsScratchFPR() const;
+
+    static TypedArrayType toTypedArrayType(AccessType);
+
+    UniquedStringImpl* uid() const { return m_identifier.uid(); }
+    CacheableIdentifier identifier() const { return m_identifier; }
+
+#if ASSERT_ENABLED
+    void checkConsistency(StructureStubInfo&);
+#else
+    ALWAYS_INLINE void checkConsistency(StructureStubInfo&) { }
+#endif
+
 protected:
-    AccessCase(VM&, JSCell* owner, AccessType, PropertyOffset, Structure*, const ObjectPropertyConditionSet&, std::unique_ptr<PolyProtoAccessChain>);
+    AccessCase(VM&, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset, Structure*, const ObjectPropertyConditionSet&, std::unique_ptr<PolyProtoAccessChain>);
     AccessCase(AccessCase&&) = default;
     AccessCase(const AccessCase& other)
         : m_type(other.m_type)
         , m_state(other.m_state)
         , m_viaProxy(other.m_viaProxy)
         , m_offset(other.m_offset)
         , m_structure(other.m_structure)
         , m_conditionSet(other.m_conditionSet)
+        , m_identifier(other.m_identifier)
     {
         if (other.m_polyProtoAccessChain)
             m_polyProtoAccessChain = other.m_polyProtoAccessChain->clone();
     }
 
@@ -217,20 +265,24 @@
 
 private:
     friend class CodeBlock;
     friend class PolymorphicAccess;
 
+    template<typename Functor>
+    void forEachDependentCell(VM&, const Functor&) const;
+
+    void visitAggregate(SlotVisitor&) const;
     bool visitWeak(VM&) const;
     bool propagateTransitions(SlotVisitor&) const;
 
     // FIXME: This only exists because of how AccessCase puts post-generation things into itself.
     // https://bugs.webkit.org/show_bug.cgi?id=156456
     virtual std::unique_ptr<AccessCase> clone() const;
 
     // Perform any action that must be performed before the end of the epoch in which the case
     // was created. Returns a set of watchpoint sets that will need to be watched.
-    Vector<WatchpointSet*, 2> commit(VM&, const Identifier&);
+    Vector<WatchpointSet*, 2> commit(VM&);
 
     // Fall through on success. Two kinds of failures are supported: fall-through, which means that we
     // should try a different case; and failure, which means that this was the right case but it needs
     // help from the slow path.
     void generateWithGuard(AccessGenerationState&, MacroAssembler::JumpList& fallThrough);
@@ -238,10 +290,12 @@
     // Fall through on success, add a jump to the failure list on failure.
     void generate(AccessGenerationState&);
 
     void generateImpl(AccessGenerationState&);
 
+    bool guardedByStructureCheckSkippingConstantIdentifierCheck() const;
+
     AccessType m_type;
     State m_state { Primordial };
 protected:
     // m_viaProxy is true only if the instance inherits (or it is) ProxyableAccessCase.
     // We put this value here instead of ProxyableAccessCase to reduce the size of ProxyableAccessCase and its
@@ -256,10 +310,12 @@
     WriteBarrier<Structure> m_structure;
 
     ObjectPropertyConditionSet m_conditionSet;
 
     std::unique_ptr<PolyProtoAccessChain> m_polyProtoAccessChain;
+
+    CacheableIdentifier m_identifier;
 };
 
 } // namespace JSC
 
 #endif

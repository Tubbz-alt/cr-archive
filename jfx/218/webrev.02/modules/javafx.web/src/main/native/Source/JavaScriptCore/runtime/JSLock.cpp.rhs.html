<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSLock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005-2018 Apple Inc. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the NU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;JSLock.h&quot;
 23 
 24 #include &quot;Heap.h&quot;
 25 #include &quot;CallFrame.h&quot;
 26 #include &quot;JSGlobalObject.h&quot;
 27 #include &quot;JSObject.h&quot;
 28 #include &quot;JSCInlines.h&quot;
 29 #include &quot;MachineStackMarker.h&quot;
 30 #include &quot;SamplingProfiler.h&quot;
 31 #include &quot;WasmCapabilities.h&quot;
 32 #include &quot;WasmMachineThreads.h&quot;
 33 #include &lt;thread&gt;
 34 #include &lt;wtf/StackPointer.h&gt;
 35 #include &lt;wtf/Threading.h&gt;
 36 #include &lt;wtf/threads/Signals.h&gt;
 37 
 38 #if USE(WEB_THREAD)
 39 #include &lt;wtf/ios/WebCoreThread.h&gt;
 40 #endif
 41 
 42 namespace JSC {
 43 
 44 Lock GlobalJSLock::s_sharedInstanceMutex;
 45 
 46 GlobalJSLock::GlobalJSLock()
 47 {
 48     s_sharedInstanceMutex.lock();
 49 }
 50 
 51 GlobalJSLock::~GlobalJSLock()
 52 {
 53     s_sharedInstanceMutex.unlock();
 54 }
 55 
<a name="1" id="anc1"></a><span class="line-modified"> 56 JSLockHolder::JSLockHolder(JSGlobalObject* globalObject)</span>
<span class="line-modified"> 57     : JSLockHolder(globalObject-&gt;vm())</span>
 58 {
 59 }
 60 
 61 JSLockHolder::JSLockHolder(VM* vm)
 62     : JSLockHolder(*vm)
 63 {
 64 }
 65 
 66 JSLockHolder::JSLockHolder(VM&amp; vm)
 67     : m_vm(&amp;vm)
 68 {
 69     m_vm-&gt;apiLock().lock();
 70 }
 71 
 72 JSLockHolder::~JSLockHolder()
 73 {
 74     RefPtr&lt;JSLock&gt; apiLock(&amp;m_vm-&gt;apiLock());
 75     m_vm = nullptr;
 76     apiLock-&gt;unlock();
 77 }
 78 
 79 JSLock::JSLock(VM* vm)
 80     : m_lockCount(0)
 81     , m_lockDropDepth(0)
 82     , m_vm(vm)
 83     , m_entryAtomStringTable(nullptr)
 84 {
 85 }
 86 
 87 JSLock::~JSLock()
 88 {
 89 }
 90 
 91 void JSLock::willDestroyVM(VM* vm)
 92 {
 93     ASSERT_UNUSED(vm, m_vm == vm);
 94     m_vm = nullptr;
 95 }
 96 
 97 void JSLock::lock()
 98 {
 99     lock(1);
100 }
101 
102 void JSLock::lock(intptr_t lockCount)
103 {
104     ASSERT(lockCount &gt; 0);
105 #if USE(WEB_THREAD)
106     if (m_isWebThreadAware) {
107         ASSERT(WebCoreWebThreadIsEnabled &amp;&amp; WebCoreWebThreadIsEnabled());
108         WebCoreWebThreadLock();
109     }
110 #endif
111 
112     bool success = m_lock.tryLock();
113     if (UNLIKELY(!success)) {
114         if (currentThreadIsHoldingLock()) {
115             m_lockCount += lockCount;
116             return;
117         }
118         m_lock.lock();
119     }
120 
121     m_ownerThread = &amp;Thread::current();
122     WTF::storeStoreFence();
123     m_hasOwnerThread = true;
124     ASSERT(!m_lockCount);
125     m_lockCount = lockCount;
126 
127     didAcquireLock();
128 }
129 
130 void JSLock::didAcquireLock()
131 {
132     // FIXME: What should happen to the per-thread identifier table if we don&#39;t have a VM?
133     if (!m_vm)
134         return;
135 
136     Thread&amp; thread = Thread::current();
137     ASSERT(!m_entryAtomStringTable);
138     m_entryAtomStringTable = thread.setCurrentAtomStringTable(m_vm-&gt;atomStringTable());
139     ASSERT(m_entryAtomStringTable);
140 
141     m_vm-&gt;setLastStackTop(thread.savedLastStackTop());
142     ASSERT(thread.stack().contains(m_vm-&gt;lastStackTop()));
143 
144     if (m_vm-&gt;heap.hasAccess())
145         m_shouldReleaseHeapAccess = false;
146     else {
147         m_vm-&gt;heap.acquireAccess();
148         m_shouldReleaseHeapAccess = true;
149     }
150 
151     RELEASE_ASSERT(!m_vm-&gt;stackPointerAtVMEntry());
152     void* p = currentStackPointer();
153     m_vm-&gt;setStackPointerAtVMEntry(p);
154 
155     if (m_vm-&gt;heap.machineThreads().addCurrentThread()) {
156         if (isKernTCSMAvailable())
157             enableKernTCSM();
158     }
159 
160 #if ENABLE(WEBASSEMBLY)
161     if (Wasm::isSupported())
162         Wasm::startTrackingCurrentThread();
163 #endif
164 
165 #if HAVE(MACH_EXCEPTIONS)
166     registerThreadForMachExceptionHandling(Thread::current());
167 #endif
168 
169     // Note: everything below must come after addCurrentThread().
170     m_vm-&gt;traps().notifyGrabAllLocks();
171 
172     m_vm-&gt;firePrimitiveGigacageEnabledIfNecessary();
173 
174 #if ENABLE(SAMPLING_PROFILER)
175     if (SamplingProfiler* samplingProfiler = m_vm-&gt;samplingProfiler())
176         samplingProfiler-&gt;noticeJSLockAcquisition();
177 #endif
178 }
179 
180 void JSLock::unlock()
181 {
182     unlock(1);
183 }
184 
185 void JSLock::unlock(intptr_t unlockCount)
186 {
187     RELEASE_ASSERT(currentThreadIsHoldingLock());
188     ASSERT(m_lockCount &gt;= unlockCount);
189 
190     // Maintain m_lockCount while calling willReleaseLock() so that its callees know that
191     // they still have the lock.
192     if (unlockCount == m_lockCount)
193         willReleaseLock();
194 
195     m_lockCount -= unlockCount;
196 
197     if (!m_lockCount) {
198         m_hasOwnerThread = false;
199         m_lock.unlock();
200     }
201 }
202 
203 void JSLock::willReleaseLock()
204 {
205     RefPtr&lt;VM&gt; vm = m_vm;
206     if (vm) {
<a name="2" id="anc2"></a><span class="line-added">207         RELEASE_ASSERT_WITH_MESSAGE(!vm-&gt;hasCheckpointOSRSideState(), &quot;Releasing JSLock but pending checkpoint side state still available&quot;);</span>
208         vm-&gt;drainMicrotasks();
209 
210         if (!vm-&gt;topCallFrame)
211             vm-&gt;clearLastException();
212 
213         vm-&gt;heap.releaseDelayedReleasedObjects();
214         vm-&gt;setStackPointerAtVMEntry(nullptr);
215 
216         if (m_shouldReleaseHeapAccess)
217             vm-&gt;heap.releaseAccess();
218     }
219 
220     if (m_entryAtomStringTable) {
221         Thread::current().setCurrentAtomStringTable(m_entryAtomStringTable);
222         m_entryAtomStringTable = nullptr;
223     }
224 }
225 
<a name="3" id="anc3"></a><span class="line-modified">226 void JSLock::lock(JSGlobalObject* globalObject)</span>
227 {
<a name="4" id="anc4"></a><span class="line-modified">228     globalObject-&gt;vm().apiLock().lock();</span>
229 }
230 
<a name="5" id="anc5"></a><span class="line-modified">231 void JSLock::unlock(JSGlobalObject* globalObject)</span>
232 {
<a name="6" id="anc6"></a><span class="line-modified">233     globalObject-&gt;vm().apiLock().unlock();</span>
234 }
235 
236 // This function returns the number of locks that were dropped.
237 unsigned JSLock::dropAllLocks(DropAllLocks* dropper)
238 {
239     if (!currentThreadIsHoldingLock())
240         return 0;
241 
242     ++m_lockDropDepth;
243 
244     dropper-&gt;setDropDepth(m_lockDropDepth);
245 
246     Thread&amp; thread = Thread::current();
247     thread.setSavedStackPointerAtVMEntry(m_vm-&gt;stackPointerAtVMEntry());
248     thread.setSavedLastStackTop(m_vm-&gt;lastStackTop());
249 
250     unsigned droppedLockCount = m_lockCount;
251     unlock(droppedLockCount);
252 
253     return droppedLockCount;
254 }
255 
256 void JSLock::grabAllLocks(DropAllLocks* dropper, unsigned droppedLockCount)
257 {
258     // If no locks were dropped, nothing to do!
259     if (!droppedLockCount)
260         return;
261 
262     ASSERT(!currentThreadIsHoldingLock());
263     lock(droppedLockCount);
264 
265     while (dropper-&gt;dropDepth() != m_lockDropDepth) {
266         unlock(droppedLockCount);
267         Thread::yield();
268         lock(droppedLockCount);
269     }
270 
271     --m_lockDropDepth;
272 
273     Thread&amp; thread = Thread::current();
274     m_vm-&gt;setStackPointerAtVMEntry(thread.savedStackPointerAtVMEntry());
275     m_vm-&gt;setLastStackTop(thread.savedLastStackTop());
276 }
277 
278 JSLock::DropAllLocks::DropAllLocks(VM* vm)
279     : m_droppedLockCount(0)
280     // If the VM is in the middle of being destroyed then we don&#39;t want to resurrect it
281     // by allowing DropAllLocks to ref it. By this point the JSLock has already been
282     // released anyways, so it doesn&#39;t matter that DropAllLocks is a no-op.
<a name="7" id="anc7"></a><span class="line-modified">283     , m_vm(vm-&gt;heap.isShuttingDown() ? nullptr : vm)</span>
284 {
285     if (!m_vm)
286         return;
287     RELEASE_ASSERT(!m_vm-&gt;apiLock().currentThreadIsHoldingLock() || !m_vm-&gt;isCollectorBusyOnCurrentThread());
288     m_droppedLockCount = m_vm-&gt;apiLock().dropAllLocks(this);
289 }
290 
<a name="8" id="anc8"></a><span class="line-modified">291 JSLock::DropAllLocks::DropAllLocks(JSGlobalObject* globalObject)</span>
<span class="line-modified">292     : DropAllLocks(globalObject ? &amp;globalObject-&gt;vm() : nullptr)</span>
293 {
294 }
295 
296 JSLock::DropAllLocks::DropAllLocks(VM&amp; vm)
297     : DropAllLocks(&amp;vm)
298 {
299 }
300 
301 JSLock::DropAllLocks::~DropAllLocks()
302 {
303     if (!m_vm)
304         return;
305     m_vm-&gt;apiLock().grabAllLocks(this, m_droppedLockCount);
306 }
307 
308 } // namespace JSC
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
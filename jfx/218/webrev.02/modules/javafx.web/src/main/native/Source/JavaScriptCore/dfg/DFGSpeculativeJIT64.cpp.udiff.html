<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT32_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStackLayoutPhase.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -34,10 +34,11 @@</span>
  #include &quot;DFGAbstractInterpreterInlines.h&quot;
  #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  #include &quot;DFGDoesGC.h&quot;
  #include &quot;DFGOperations.h&quot;
  #include &quot;DFGSlowPathGenerator.h&quot;
<span class="udiff-line-added">+ #include &quot;DateInstance.h&quot;</span>
  #include &quot;DirectArguments.h&quot;
  #include &quot;GetterSetter.h&quot;
  #include &quot;HasOwnPropertyCache.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -99,11 +100,11 @@</span>
              DataFormat spillFormat = info.spillFormat();
              m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
              switch (spillFormat) {
              case DataFormatInt32: {
                  m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
<span class="udiff-line-modified-removed">-                 m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);</span>
<span class="udiff-line-modified-added">+                 m_jit.or64(GPRInfo::numberTagRegister, gpr);</span>
                  spillFormat = DataFormatJSInt32;
                  break;
              }
  
              default:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,15 +121,15 @@</span>
          GPRReg gpr = info.gpr();
          // If the register has already been locked we need to take a copy.
          // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
          if (m_gprs.isLocked(gpr)) {
              GPRReg result = allocate();
<span class="udiff-line-modified-removed">-             m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr, result);</span>
<span class="udiff-line-modified-added">+             m_jit.or64(GPRInfo::numberTagRegister, gpr, result);</span>
              return result;
          }
          m_gprs.lock(gpr);
<span class="udiff-line-modified-removed">-         m_jit.or64(GPRInfo::tagTypeNumberRegister, gpr);</span>
<span class="udiff-line-modified-added">+         m_jit.or64(GPRInfo::numberTagRegister, gpr);</span>
          info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
          return gpr;
      }
  
      case DataFormatCell:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180,11 +181,11 @@</span>
      slowCases.append(gen.slowPathJump());
  
      std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
          slowCases, this, appropriateOptimizingGetByIdFunction(type),
          spillMode, ExceptionCheckRequirement::CheckNeeded,
<span class="udiff-line-modified-removed">-         resultGPR, gen.stubInfo(), baseGPR, identifierUID(identifierNumber));</span>
<span class="udiff-line-modified-added">+         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), baseGPR, identifierUID(identifierNumber));</span>
  
      m_jit.addGetById(gen, slowPath.get());
      addSlowPathGenerator(WTFMove(slowPath));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -197,21 +198,21 @@</span>
      usedRegisters.set(thisGPR, false);
      usedRegisters.set(resultGPR, false);
  
      JITGetByIdWithThisGenerator gen(
          m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
<span class="udiff-line-modified-removed">-         JSValueRegs(resultGPR), JSValueRegs(baseGPR), JSValueRegs(thisGPR), AccessType::GetWithThis);</span>
<span class="udiff-line-modified-added">+         JSValueRegs(resultGPR), JSValueRegs(baseGPR), JSValueRegs(thisGPR));</span>
      gen.generateFastPath(m_jit);
  
      JITCompiler::JumpList slowCases;
      slowCases.append(slowPathTarget);
      slowCases.append(gen.slowPathJump());
  
      std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
          slowCases, this, operationGetByIdWithThisOptimize,
          DontSpill, ExceptionCheckRequirement::CheckNeeded,
<span class="udiff-line-modified-removed">-         resultGPR, gen.stubInfo(), baseGPR, thisGPR, identifierUID(identifierNumber));</span>
<span class="udiff-line-modified-added">+         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), baseGPR, thisGPR, identifierUID(identifierNumber));</span>
  
      m_jit.addGetByIdWithThis(gen, slowPath.get());
      addSlowPathGenerator(WTFMove(slowPath));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -255,17 +256,17 @@</span>
              notCell.link(&amp;m_jit);
      }
  
      if (!isKnownNotOther(operand.node())) {
          m_jit.move(argGPR, resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="udiff-line-modified-removed">-         m_jit.compare64(JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(ValueNull), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.and64(JITCompiler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.compare64(JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(JSValue::ValueNull), resultGPR);</span>
      }
  
      done.link(&amp;m_jit);
  
<span class="udiff-line-modified-removed">-     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
      jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
  }
  
  void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -317,12 +318,12 @@</span>
          if (taken == nextBlock()) {
              condition = JITCompiler::NotEqual;
              std::swap(taken, notTaken);
          }
          m_jit.move(argGPR, resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.and64(JITCompiler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="udiff-line-modified-removed">-         branch64(condition, resultGPR, JITCompiler::TrustedImm64(ValueNull), taken);</span>
<span class="udiff-line-modified-added">+         m_jit.and64(JITCompiler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="udiff-line-modified-added">+         branch64(condition, resultGPR, JITCompiler::TrustedImm64(JSValue::ValueNull), taken);</span>
          jump(notTaken);
      }
  }
  
  void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -354,11 +355,11 @@</span>
          // see if we get lucky: if the arguments are cells and they reference the same
          // cell, then they must be strictly equal.
          branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
  
          silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationCompareStrictEqCell, resultGPR, arg1GPR, arg2GPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
          silentFillAllRegisters();
          m_jit.exceptionCheck();
  
          branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -381,11 +382,11 @@</span>
  
          leftDouble.link(&amp;m_jit);
          rightDouble.link(&amp;m_jit);
  
          silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationCompareStrictEq, resultGPR, arg1GPR, arg2GPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationCompareStrictEq, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
          silentFillAllRegisters();
          m_jit.exceptionCheck();
  
          branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -417,11 +418,11 @@</span>
          JITCompiler::Jump done = m_jit.jump();
  
          notEqualCase.link(&amp;m_jit);
  
          silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationCompareStrictEqCell, resultGPR, arg1Regs, arg2Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
          silentFillAllRegisters();
          m_jit.exceptionCheck();
  
          done.link(&amp;m_jit);
          unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -448,11 +449,11 @@</span>
      twoCellsCase.link(&amp;m_jit);
      slowPathCases.append(m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr()));
  
      m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
  
<span class="udiff-line-modified-removed">-     addSlowPathGenerator(slowPathCall(slowPathCases, this, operationCompareStrictEq, resultGPR, arg1Regs, arg2Regs));</span>
<span class="udiff-line-modified-added">+     addSlowPathGenerator(slowPathCall(slowPathCases, this, operationCompareStrictEq, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs));</span>
  
      done.link(&amp;m_jit);
  
      unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -541,10 +542,11 @@</span>
      }
  
      GPRReg calleeGPR = InvalidGPRReg;
      CallFrameShuffleData shuffleData;
  
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
      ExecutableBase* executable = nullptr;
      FunctionExecutable* functionExecutable = nullptr;
      if (isDirect) {
          executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
          functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -582,11 +584,11 @@</span>
                  inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
              // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
              emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
              JITCompiler::Jump done = m_jit.jump();
              slowCase.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-             callOperation(operationThrowStackOverflowForVarargs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationThrowStackOverflowForVarargs, TrustedImmPtr::weakPointer(m_graph, globalObject));</span>
              m_jit.exceptionCheck();
              m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
              done.link(&amp;m_jit);
          } else {
              GPRReg argumentsGPR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -611,21 +613,21 @@</span>
              loadArgumentsGPR(InvalidGPRReg);
  
              DFG_ASSERT(m_jit.graph(), node, isFlushed());
  
              // Right now, arguments is in argumentsGPR and the register file is flushed.
<span class="udiff-line-modified-removed">-             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, argumentsGPR, numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
<span class="udiff-line-modified-added">+             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsGPR, numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
              m_jit.exceptionCheck();
  
              // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
              // Reconstruct the arguments operand while preserving the callee frame.
              loadArgumentsGPR(GPRInfo::returnValueGPR);
              m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
              emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
              m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
  
<span class="udiff-line-modified-removed">-             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, scratchGPR1, argumentsGPR, data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scratchGPR1, argumentsGPR, data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
              m_jit.exceptionCheck();
              m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
          }
  
          DFG_ASSERT(m_jit.graph(), node, isFlushed());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -670,11 +672,11 @@</span>
              JSValueOperand callee(this, calleeEdge);
              calleeGPR = callee.gpr();
              if (!isDirect)
                  callee.use();
  
<span class="udiff-line-modified-removed">-             shuffleData.tagTypeNumber = GPRInfo::tagTypeNumberRegister;</span>
<span class="udiff-line-modified-added">+             shuffleData.numberTagRegister = GPRInfo::numberTagRegister;</span>
              shuffleData.numLocals = m_jit.graph().frameRegisterCount();
              shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatJS);
              shuffleData.args.resize(numAllocatedArgs);
              shuffleData.numPassedArgs = numPassedArgs;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -689,11 +691,11 @@</span>
              for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
                  shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
  
              shuffleData.setupCalleeSaveRegisters(m_jit.codeBlock());
          } else {
<span class="udiff-line-modified-removed">-             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), JITCompiler::calleeFramePayloadSlot(CallFrameSlot::argumentCount));</span>
<span class="udiff-line-modified-added">+             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), JITCompiler::calleeFramePayloadSlot(CallFrameSlot::argumentCountIncludingThis));</span>
  
              for (unsigned i = 0; i &lt; numPassedArgs; i++) {
                  Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
                  JSValueOperand arg(this, argEdge);
                  GPRReg argGPR = arg.gpr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -753,32 +755,32 @@</span>
          m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
  
          // Now we need to make room for:
          // - The caller frame and PC of a call to operationCallEval.
          // - Potentially two arguments on the stack.
<span class="udiff-line-modified-removed">-         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;</span>
<span class="udiff-line-modified-added">+         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;</span>
          requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
          m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
<span class="udiff-line-modified-removed">-         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);</span>
<span class="udiff-line-modified-added">+         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT0);</span>
          prepareForExternalCall();
          m_jit.appendCall(operationCallEval);
          m_jit.exceptionCheck();
          JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR);
  
          // This is the part where we meant to make a normal call. Oops.
          m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
          m_jit.load64(JITCompiler::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<span class="udiff-line-modified-removed">-         m_jit.emitDumbVirtualCall(vm(), callLinkInfo);</span>
<span class="udiff-line-modified-added">+         m_jit.emitDumbVirtualCall(vm(), globalObject, callLinkInfo);</span>
  
          done.link(&amp;m_jit);
          setResultAndResetStack();
          return;
      }
  
      if (isDirect) {
          callLinkInfo-&gt;setExecutableDuringCompilation(executable);
<span class="udiff-line-modified-removed">-         callLinkInfo-&gt;setMaxNumArguments(numAllocatedArgs);</span>
<span class="udiff-line-modified-added">+         callLinkInfo-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
  
          if (isTail) {
              RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
  
              JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -860,10 +862,11 @@</span>
          if (isTail)
              m_jit.emitRestoreCalleeSaves(); // This needs to happen after we moved calleeGPR to regT0
      }
  
      m_jit.move(TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2
<span class="udiff-line-added">+     m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT3); // JSGlobalObject needs to be in regT3</span>
      JITCompiler::Call slowCall = m_jit.nearCall();
  
      done.link(&amp;m_jit);
  
      if (isTail)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1203,11 +1206,11 @@</span>
  
      case DataFormatCell:
      case DataFormatJSCell: {
          GPRReg gpr = info.gpr();
          m_gprs.lock(gpr);
<span class="udiff-line-modified-removed">-         if (!ASSERT_DISABLED) {</span>
<span class="udiff-line-modified-added">+         if (ASSERT_ENABLED) {</span>
              MacroAssembler::Jump checkCell = m_jit.branchIfCell(JSValueRegs(gpr));
              m_jit.abortWithReason(DFGIsNotCell);
              checkCell.link(&amp;m_jit);
          }
          return gpr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1270,13 +1273,13 @@</span>
          m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
          m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
  
          info.fillJSValue(*m_stream, gpr, DataFormatJS);
          if (type &amp; ~SpecBoolean) {
<span class="udiff-line-modified-removed">-             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
<span class="udiff-line-modified-added">+             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
              speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<span class="udiff-line-modified-removed">-             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
<span class="udiff-line-modified-added">+             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
          }
          info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
          return gpr;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1289,13 +1292,13 @@</span>
  
      case DataFormatJS: {
          GPRReg gpr = info.gpr();
          m_gprs.lock(gpr);
          if (type &amp; ~SpecBoolean) {
<span class="udiff-line-modified-removed">-             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
<span class="udiff-line-modified-added">+             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
              speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<span class="udiff-line-modified-removed">-             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), gpr);</span>
<span class="udiff-line-modified-added">+             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
          }
          info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
          return gpr;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1329,11 +1332,11 @@</span>
      DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
  
      // At this point we know that we can perform a straight-forward equality comparison on pointer
      // values because we are doing strict equality.
      m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
<span class="udiff-line-modified-removed">-     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
      jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
  }
  
  void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1411,22 +1414,22 @@</span>
  
      // We know that within this branch, rightChild must not be a cell. Check if that is enough to
      // prove that it is either null or undefined.
      if (needsTypeCheck(rightChild, SpecCellCheck | SpecOther)) {
          m_jit.move(op2GPR, resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
  
          typeCheck(
              JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther,
              m_jit.branch64(
                  MacroAssembler::NotEqual, resultGPR,
<span class="udiff-line-modified-removed">-                 MacroAssembler::TrustedImm64(ValueNull)));</span>
<span class="udiff-line-modified-added">+                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
      }
      m_jit.move(TrustedImm32(0), result.gpr());
  
      done.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-     m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
      jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
  }
  
  void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1487,16 +1490,16 @@</span>
      else {
          jump(notTaken, ForceJump);
  
          rightNotCell.link(&amp;m_jit);
          m_jit.move(op2GPR, resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
  
          typeCheck(
              JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther, m_jit.branch64(
                  MacroAssembler::NotEqual, resultGPR,
<span class="udiff-line-modified-removed">-                 MacroAssembler::TrustedImm64(ValueNull)));</span>
<span class="udiff-line-modified-added">+                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
      }
  
      jump(notTaken);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1525,11 +1528,11 @@</span>
      GPRTemporary result(this, Reuse, op1, op2);
  
      m_jit.compare64(condition, op1.gpr(), op2.gpr(), result.gpr());
  
      // If we add a DataFormatBool, we should use it here.
<span class="udiff-line-modified-removed">-     m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+     m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
      jsValueResult(result.gpr(), m_currentNode, DataFormatJSBoolean);
  }
  
  void SpeculativeJIT::compilePeepHoleInt52Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1610,25 +1613,25 @@</span>
                  MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
                  TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
  
          isNotMasqueradesAsUndefined.link(&amp;m_jit);
      }
<span class="udiff-line-modified-removed">-     m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
      MacroAssembler::Jump done = m_jit.jump();
  
      notCell.link(&amp;m_jit);
  
      if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
          m_jit.move(valueGPR, resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
          typeCheck(
              JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
                  MacroAssembler::NotEqual,
                  resultGPR,
<span class="udiff-line-modified-removed">-                 MacroAssembler::TrustedImm64(ValueNull)));</span>
<span class="udiff-line-modified-added">+                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
      }
<span class="udiff-line-modified-removed">-     m_jit.move(TrustedImm32(ValueTrue), resultGPR);</span>
<span class="udiff-line-modified-added">+     m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
  
      done.link(&amp;m_jit);
  
      jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1643,20 +1646,20 @@</span>
  
      case Int32Use: {
          SpeculateInt32Operand value(this, node-&gt;child1());
          GPRTemporary result(this, Reuse, value);
          m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), result.gpr());
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
          jsValueResult(result.gpr(), node, DataFormatJSBoolean);
          return;
      }
  
      case DoubleRepUse: {
          SpeculateDoubleOperand value(this, node-&gt;child1());
          FPRTemporary scratch(this);
          GPRTemporary result(this);
<span class="udiff-line-modified-removed">-         m_jit.move(TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.move(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
          MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
          m_jit.xor32(TrustedImm32(true), result.gpr());
          nonZero.link(&amp;m_jit);
          jsValueResult(result.gpr(), node, DataFormatJSBoolean);
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1677,15 +1680,15 @@</span>
  
          JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
          GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
  
          m_jit.move(value.gpr(), result.gpr());
<span class="udiff-line-modified-removed">-         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
          typeCheck(
              JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
                  JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
<span class="udiff-line-modified-removed">-         m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueTrue)), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.xor64(TrustedImm32(JSValue::ValueTrue), result.gpr());</span>
  
          // If we add a DataFormatBool, we should use it here.
          jsValueResult(result.gpr(), node, DataFormatJSBoolean);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1708,11 +1711,11 @@</span>
              scratch.emplace(this);
              scratchGPR = scratch-&gt;gpr();
          }
          bool negateResult = true;
          m_jit.emitConvertValueToBoolean(vm(), JSValueRegs(arg1GPR), resultGPR, scratchGPR, valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
          jsValueResult(resultGPR, node, DataFormatJSBoolean);
          return;
      }
      case StringUse:
          return compileStringZeroLength(node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1767,14 +1770,14 @@</span>
  
      notCell.link(&amp;m_jit);
  
      if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
          m_jit.move(valueGPR, scratchGPR);
<span class="udiff-line-modified-removed">-         m_jit.and64(MacroAssembler::TrustedImm32(~TagBitUndefined), scratchGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), scratchGPR);</span>
          typeCheck(
              JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
<span class="udiff-line-modified-removed">-                 MacroAssembler::NotEqual, scratchGPR, MacroAssembler::TrustedImm64(ValueNull)));</span>
<span class="udiff-line-modified-added">+                 MacroAssembler::NotEqual, scratchGPR, MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
      }
      jump(notTaken);
  
      noResult(m_currentNode);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1869,11 +1872,11 @@</span>
              FPRReg valueFPR = fprValue.fpr();
              FPRReg tempFPR = fprTemp.fpr();
  
              if (node-&gt;child1()-&gt;prediction() &amp; SpecInt32Only) {
                  branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsNumber(0))), notTaken);
<span class="udiff-line-modified-removed">-                 branch64(MacroAssembler::AboveOrEqual, valueGPR, GPRInfo::tagTypeNumberRegister, taken);</span>
<span class="udiff-line-modified-added">+                 branch64(MacroAssembler::AboveOrEqual, valueGPR, GPRInfo::numberTagRegister, taken);</span>
              }
  
              if (node-&gt;child1()-&gt;prediction() &amp; SpecBoolean) {
                  branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
                  branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1925,12 +1928,17 @@</span>
      case Identity: {
          compileIdentity(node);
          break;
      }
  
<span class="udiff-line-added">+     case Inc:</span>
<span class="udiff-line-added">+     case Dec:</span>
<span class="udiff-line-added">+         compileIncOrDec(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
      case GetLocal: {
<span class="udiff-line-modified-removed">-         AbstractValue&amp; value = m_state.operand(node-&gt;local());</span>
<span class="udiff-line-modified-added">+         AbstractValue&amp; value = m_state.operand(node-&gt;operand());</span>
  
          // If the CFA is tracking this variable and it found that the variable
          // cannot have been assigned, then don&#39;t attempt to proceed.
          if (value.isClear()) {
              m_compileOkay = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1997,11 +2005,11 @@</span>
          noResult(node);
          break;
      }
  
      case ZombieHint: {
<span class="udiff-line-modified-removed">-         recordSetLocal(m_currentNode-&gt;unlinkedLocal(), VirtualRegister(), DataFormatDead);</span>
<span class="udiff-line-modified-added">+         recordSetLocal(m_currentNode-&gt;unlinkedOperand(), VirtualRegister(), DataFormatDead);</span>
          noResult(node);
          break;
      }
  
      case ExitOK: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2102,11 +2110,15 @@</span>
  
      case ValueBitLShift:
          compileValueLShiftOp(node);
          break;
  
<span class="udiff-line-modified-removed">-     case BitRShift:</span>
<span class="udiff-line-modified-added">+     case ValueBitRShift:</span>
<span class="udiff-line-added">+         compileValueBitRShift(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ArithBitRShift:</span>
      case ArithBitLShift:
      case BitURShift:
          compileShiftOp(node);
          break;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2341,10 +2353,15 @@</span>
      case StringCharCodeAt: {
          compileGetCharCodeAt(node);
          break;
      }
  
<span class="udiff-line-added">+     case StringCodePointAt: {</span>
<span class="udiff-line-added">+         compileStringCodePointAt(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case StringCharAt: {
          // Relies on StringCharAt node having same basic layout as GetByVal
          compileGetByValOnString(node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2352,10 +2369,16 @@</span>
      case StringFromCharCode: {
          compileFromCharCode(node);
          break;
      }
  
<span class="udiff-line-added">+     case CheckNeutered: {</span>
<span class="udiff-line-added">+         compileCheckNeutered(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case CheckArrayOrEmpty:</span>
      case CheckArray: {
          checkArray(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2384,37 +2407,83 @@</span>
                  m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
  
              use(m_graph.varArgChild(node, 0));
              index.use();
  
<span class="udiff-line-modified-removed">-             m_jit.move(MacroAssembler::TrustedImm64(ValueUndefined), resultGPR);</span>
<span class="udiff-line-modified-added">+             m_jit.move(MacroAssembler::TrustedImm64(JSValue::ValueUndefined), resultGPR);</span>
              jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
              break;
          }
          case Array::Generic: {
<span class="udiff-line-modified-removed">-             if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="udiff-line-modified-removed">-                 if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="udiff-line-modified-removed">-                     compileGetByValForObjectWithString(node);</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-added">+             if (m_graph.m_slowGetByVal.contains(node)) {</span>
<span class="udiff-line-modified-added">+                 if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="udiff-line-modified-added">+                     if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="udiff-line-modified-added">+                         compileGetByValForObjectWithString(node);</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="udiff-line-added">+                         compileGetByValForObjectWithSymbol(node);</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
                  }
  
<span class="udiff-line-modified-removed">-                 if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="udiff-line-modified-removed">-                     compileGetByValForObjectWithSymbol(node);</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 JSValueOperand base(this, m_graph.varArgChild(node, 0));</span>
<span class="udiff-line-modified-added">+                 JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="udiff-line-modified-added">+                 GPRReg baseGPR = base.gpr();</span>
<span class="udiff-line-modified-added">+                 GPRReg propertyGPR = property.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 flushRegisters();</span>
<span class="udiff-line-added">+                 GPRFlushedCallResult result(this);</span>
<span class="udiff-line-added">+                 callOperation(operationGetByVal, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR);</span>
<span class="udiff-line-added">+                 m_jit.exceptionCheck();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 jsValueResult(result.gpr(), node);</span>
<span class="udiff-line-added">+                 break;</span>
              }
<span class="udiff-line-modified-removed">-             JSValueOperand base(this, m_graph.varArgChild(node, 0));</span>
<span class="udiff-line-modified-removed">-             JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             speculate(node, m_graph.varArgChild(node, 0));</span>
<span class="udiff-line-added">+             speculate(node, m_graph.varArgChild(node, 1));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             JSValueOperand base(this, m_graph.varArgChild(node, 0), ManualOperandSpeculation);</span>
<span class="udiff-line-added">+             JSValueOperand property(this, m_graph.varArgChild(node, 1), ManualOperandSpeculation);</span>
<span class="udiff-line-added">+             GPRTemporary result(this, Reuse, property);</span>
              GPRReg baseGPR = base.gpr();
              GPRReg propertyGPR = property.gpr();
<span class="udiff-line-added">+             GPRReg resultGPR = result.gpr();</span>
  
<span class="udiff-line-modified-removed">-             flushRegisters();</span>
<span class="udiff-line-modified-removed">-             GPRFlushedCallResult result(this);</span>
<span class="udiff-line-modified-removed">-             callOperation(operationGetByVal, result.gpr(), baseGPR, propertyGPR);</span>
<span class="udiff-line-removed">-             m_jit.exceptionCheck();</span>
<span class="udiff-line-modified-added">+             CodeOrigin codeOrigin = node-&gt;origin.semantic;</span>
<span class="udiff-line-modified-added">+             CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());</span>
<span class="udiff-line-modified-added">+             RegisterSet usedRegisters = this-&gt;usedRegisters();</span>
  
<span class="udiff-line-modified-removed">-             jsValueResult(result.gpr(), node);</span>
<span class="udiff-line-modified-added">+             JITCompiler::JumpList slowCases;</span>
<span class="udiff-line-added">+             if (!m_state.forNode(m_graph.varArgChild(node, 0)).isType(SpecCell))</span>
<span class="udiff-line-added">+                 slowCases.append(m_jit.branchIfNotCell(baseGPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             JITGetByValGenerator gen(</span>
<span class="udiff-line-added">+                 m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,</span>
<span class="udiff-line-added">+                 JSValueRegs(baseGPR), JSValueRegs(propertyGPR), JSValueRegs(resultGPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecString))</span>
<span class="udiff-line-added">+                 gen.stubInfo()-&gt;propertyIsString = true;</span>
<span class="udiff-line-added">+             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))</span>
<span class="udiff-line-added">+                 gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="udiff-line-added">+             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecSymbol))</span>
<span class="udiff-line-added">+                 gen.stubInfo()-&gt;propertyIsSymbol = true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             gen.generateFastPath(m_jit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             slowCases.append(gen.slowPathJump());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(</span>
<span class="udiff-line-added">+                 slowCases, this, operationGetByValOptimize,</span>
<span class="udiff-line-added">+                 resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), nullptr, baseGPR, propertyGPR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             m_jit.addGetByVal(gen, slowPath.get());</span>
<span class="udiff-line-added">+             addSlowPathGenerator(WTFMove(slowPath));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             jsValueResult(resultGPR, node);</span>
              break;
          }
          case Array::Int32:
          case Array::Contiguous: {
              if (node-&gt;arrayMode().isInBounds()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2468,11 +2537,11 @@</span>
              slowCases.append(m_jit.branchIfEmpty(resultReg));
  
              addSlowPathGenerator(
                  slowPathCall(
                      slowCases, this, operationGetByValObjectInt,
<span class="udiff-line-modified-removed">-                     result.gpr(), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
  
              jsValueResult(resultReg, node);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2524,11 +2593,11 @@</span>
              boxDouble(tempReg, resultReg);
  
              addSlowPathGenerator(
                  slowPathCall(
                      slowCases, this, operationGetByValObjectInt,
<span class="udiff-line-modified-removed">-                     result.gpr(), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
  
              jsValueResult(resultReg, node);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2576,11 +2645,11 @@</span>
              slowCases.append(m_jit.branchIfEmpty(resultReg));
  
              addSlowPathGenerator(
                  slowPathCall(
                      slowCases, this, operationGetByValObjectInt,
<span class="udiff-line-modified-removed">-                     result.gpr(), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
  
              jsValueResult(resultReg, node);
              break;
          }
          case Array::String:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2654,13 +2723,13 @@</span>
              GPRReg arg1GPR = arg1.gpr();
              GPRReg arg2GPR = arg2.gpr();
              GPRReg arg3GPR = arg3.gpr();
              flushRegisters();
              if (node-&gt;op() == PutByValDirect)
<span class="udiff-line-modified-removed">-                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict, arg1GPR, arg2GPR, arg3GPR);</span>
<span class="udiff-line-modified-added">+                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3GPR);</span>
              else
<span class="udiff-line-modified-removed">-                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict, arg1GPR, arg2GPR, arg3GPR);</span>
<span class="udiff-line-modified-added">+                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3GPR);</span>
              m_jit.exceptionCheck();
  
              noResult(node);
              alreadyHandled = true;
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2741,11 +2810,11 @@</span>
                  addSlowPathGenerator(slowPathCall(
                      slowCase, this,
                      m_jit.isStrictModeFor(node-&gt;origin.semantic)
                          ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
                          : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<span class="udiff-line-modified-removed">-                     NoResult, baseReg, propertyReg, valueReg));</span>
<span class="udiff-line-modified-added">+                     NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
              }
  
              noResult(node, UseChildrenCalledExplicitly);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2825,11 +2894,11 @@</span>
                  addSlowPathGenerator(slowPathCall(
                      slowCases, this,
                      m_jit.isStrictModeFor(node-&gt;origin.semantic)
                          ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
                          : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<span class="udiff-line-modified-removed">-                     NoResult, baseReg, propertyReg, valueReg));</span>
<span class="udiff-line-modified-added">+                     NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
              }
  
              noResult(node, UseChildrenCalledExplicitly);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2887,37 +2956,38 @@</span>
          GPRReg indexGPR;
          GPRReg argGPRs[2];
          GPRReg resultGPR;
  
          auto callSlowPath = [&amp;] () {
<span class="udiff-line-added">+             auto globalObjectImmPtr = TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic));</span>
              switch (node-&gt;op()) {
              case AtomicsAdd:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsAdd, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsAdd, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
                  break;
              case AtomicsAnd:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsAnd, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsAnd, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
                  break;
              case AtomicsCompareExchange:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsCompareExchange, resultGPR, baseGPR, indexGPR, argGPRs[0], argGPRs[1]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsCompareExchange, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0], argGPRs[1]);</span>
                  break;
              case AtomicsExchange:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsExchange, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsExchange, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
                  break;
              case AtomicsLoad:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsLoad, resultGPR, baseGPR, indexGPR);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsLoad, resultGPR, globalObjectImmPtr, baseGPR, indexGPR);</span>
                  break;
              case AtomicsOr:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsOr, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsOr, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
                  break;
              case AtomicsStore:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsStore, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsStore, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
                  break;
              case AtomicsSub:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsSub, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsSub, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
                  break;
              case AtomicsXor:
<span class="udiff-line-modified-removed">-                 callOperation(operationAtomicsXor, resultGPR, baseGPR, indexGPR, argGPRs[0]);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationAtomicsXor, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
                  break;
              default:
                  RELEASE_ASSERT_NOT_REACHED();
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3084,26 +3154,26 @@</span>
              JSValueOperand operand(this, node-&gt;child1());
              GPRReg operandGPR = operand.gpr();
              flushRegisters();
              GPRFlushedCallResult result(this);
              GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-             callOperation(operationAtomicsIsLockFree, resultGPR, operandGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationAtomicsIsLockFree, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandGPR);</span>
              m_jit.exceptionCheck();
              jsValueResult(resultGPR, node);
              break;
          }
  
          SpeculateInt32Operand operand(this, node-&gt;child1());
          GPRTemporary result(this);
          GPRReg operandGPR = operand.gpr();
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         m_jit.move(TrustedImm32(ValueTrue), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
          JITCompiler::JumpList done;
          done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(4)));
          done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(1)));
          done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(2)));
<span class="udiff-line-modified-removed">-         m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
          done.link(&amp;m_jit);
          jsValueResult(resultGPR, node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3220,11 +3290,11 @@</span>
                  slowPathMove(
                      undefinedCase, this,
                      MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
              addSlowPathGenerator(
                  slowPathCall(
<span class="udiff-line-modified-removed">-                     slowCase, this, operationArrayPopAndRecoverLength, valueGPR, baseGPR));</span>
<span class="udiff-line-modified-added">+                     slowCase, this, operationArrayPopAndRecoverLength, valueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
  
              // We can&#39;t know for sure that the result is an int because of the slow paths. :-/
              jsValueResult(valueGPR, node);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3253,11 +3323,11 @@</span>
                      undefinedCase, this,
                      MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
  
              addSlowPathGenerator(
                  slowPathCall(
<span class="udiff-line-modified-removed">-                     slowCases, this, operationArrayPop, valueGPR, baseGPR));</span>
<span class="udiff-line-modified-added">+                     slowCases, this, operationArrayPop, valueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
  
              jsValueResult(valueGPR, node);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3314,11 +3384,11 @@</span>
          case BooleanUse: {
              JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
              GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
  
              m_jit.move(value.gpr(), result.gpr());
<span class="udiff-line-modified-removed">-             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());</span>
<span class="udiff-line-modified-added">+             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
              DFG_TYPE_CHECK(
                  JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
                      JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
  
              int32Result(result.gpr(), node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3335,17 +3405,17 @@</span>
                  int32Result(result.gpr(), node);
                  break;
              }
  
              m_jit.move(value.gpr(), result.gpr());
<span class="udiff-line-modified-removed">-             m_jit.xor64(TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), result.gpr());</span>
<span class="udiff-line-modified-added">+             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
              JITCompiler::Jump isBoolean = m_jit.branchTest64(
                  JITCompiler::Zero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
              m_jit.move(value.gpr(), result.gpr());
              JITCompiler::Jump done = m_jit.jump();
              isBoolean.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-             m_jit.or64(GPRInfo::tagTypeNumberRegister, result.gpr());</span>
<span class="udiff-line-modified-added">+             m_jit.or64(GPRInfo::numberTagRegister, result.gpr());</span>
              done.link(&amp;m_jit);
  
              jsValueResult(result.gpr(), node);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3360,10 +3430,15 @@</span>
      case ToPrimitive: {
          compileToPrimitive(node);
          break;
      }
  
<span class="udiff-line-added">+     case ToPropertyKey: {</span>
<span class="udiff-line-added">+         compileToPropertyKey(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case ToNumber: {
          JSValueOperand argument(this, node-&gt;child1());
          GPRTemporary result(this, Reuse, argument);
  
          GPRReg argumentGPR = argument.gpr();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3374,30 +3449,35 @@</span>
          // We have several attempts to remove ToNumber. But ToNumber still exists.
          // It means that converting non-numbers to numbers by this ToNumber is not rare.
          // Instead of the slow path generator, we emit callOperation here.
          if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
              flushRegisters();
<span class="udiff-line-modified-removed">-             callOperation(operationToNumber, resultGPR, argumentGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationToNumber, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentGPR);</span>
              m_jit.exceptionCheck();
          } else {
              MacroAssembler::Jump notNumber = m_jit.branchIfNotNumber(argumentGPR);
              m_jit.move(argumentGPR, resultGPR);
              MacroAssembler::Jump done = m_jit.jump();
  
              notNumber.link(&amp;m_jit);
              silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-             callOperation(operationToNumber, resultGPR, argumentGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationToNumber, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentGPR);</span>
              silentFillAllRegisters();
              m_jit.exceptionCheck();
  
              done.link(&amp;m_jit);
          }
  
          jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
          break;
      }
  
<span class="udiff-line-added">+     case ToNumeric: {</span>
<span class="udiff-line-added">+         compileToNumeric(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case ToString:
      case CallStringConstructor:
      case StringValueOf: {
          compileToStringOrCallStringConstructorOrStringValueOf(node);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3472,15 +3552,50 @@</span>
      case CreateThis: {
          compileCreateThis(node);
          break;
      }
  
<span class="udiff-line-added">+     case CreatePromise: {</span>
<span class="udiff-line-added">+         compileCreatePromise(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case CreateGenerator: {</span>
<span class="udiff-line-added">+         compileCreateGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case CreateAsyncGenerator: {</span>
<span class="udiff-line-added">+         compileCreateAsyncGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case NewObject: {
          compileNewObject(node);
          break;
      }
  
<span class="udiff-line-added">+     case NewPromise: {</span>
<span class="udiff-line-added">+         compileNewPromise(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case NewGenerator: {</span>
<span class="udiff-line-added">+         compileNewGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case NewAsyncGenerator: {</span>
<span class="udiff-line-added">+         compileNewAsyncGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case NewArrayIterator: {</span>
<span class="udiff-line-added">+         compileNewArrayIterator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case GetCallee: {
          compileGetCallee(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3526,32 +3641,42 @@</span>
      case PutClosureVar: {
          compilePutClosureVar(node);
          break;
      }
  
<span class="udiff-line-added">+     case GetInternalField: {</span>
<span class="udiff-line-added">+         compileGetInternalField(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case PutInternalField: {</span>
<span class="udiff-line-added">+         compilePutInternalField(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case TryGetById: {
<span class="udiff-line-modified-removed">-         compileGetById(node, AccessType::TryGet);</span>
<span class="udiff-line-modified-added">+         compileGetById(node, AccessType::TryGetById);</span>
          break;
      }
  
      case GetByIdDirect: {
<span class="udiff-line-modified-removed">-         compileGetById(node, AccessType::GetDirect);</span>
<span class="udiff-line-modified-added">+         compileGetById(node, AccessType::GetByIdDirect);</span>
          break;
      }
  
      case GetByIdDirectFlush: {
<span class="udiff-line-modified-removed">-         compileGetByIdFlush(node, AccessType::GetDirect);</span>
<span class="udiff-line-modified-added">+         compileGetByIdFlush(node, AccessType::GetByIdDirect);</span>
          break;
      }
  
      case GetById: {
<span class="udiff-line-modified-removed">-         compileGetById(node, AccessType::Get);</span>
<span class="udiff-line-modified-added">+         compileGetById(node, AccessType::GetById);</span>
          break;
      }
  
      case GetByIdFlush: {
<span class="udiff-line-modified-removed">-         compileGetByIdFlush(node, AccessType::Get);</span>
<span class="udiff-line-modified-added">+         compileGetByIdFlush(node, AccessType::GetById);</span>
          break;
      }
  
      case GetByIdWithThis: {
          if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3626,12 +3751,12 @@</span>
          }
          noResult(node);
          break;
      }
  
<span class="udiff-line-modified-removed">-     case CheckStringIdent:</span>
<span class="udiff-line-modified-removed">-         compileCheckStringIdent(node);</span>
<span class="udiff-line-modified-added">+     case CheckIdent:</span>
<span class="udiff-line-modified-added">+         compileCheckIdent(node);</span>
          break;
  
      case GetExecutable: {
          compileGetExecutable(node);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3770,11 +3895,11 @@</span>
          GPRReg propertyGPR = property.gpr();
          JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
          GPRReg valueGPR = value.gpr();
  
          flushRegisters();
<span class="udiff-line-modified-removed">-         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis, NoResult, baseGPR, thisValueGPR, propertyGPR, valueGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, thisValueGPR, propertyGPR, valueGPR);</span>
          m_jit.exceptionCheck();
  
          noResult(node);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3875,11 +4000,11 @@</span>
      case IsEmpty: {
          JSValueOperand value(this, node-&gt;child1());
          GPRTemporary result(this, Reuse, value);
  
          m_jit.comparePtr(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::encode(JSValue())), result.gpr());
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
  
          jsValueResult(result.gpr(), node, DataFormatJSBoolean);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3890,11 +4015,11 @@</span>
          GPRTemporary remoteGlobalObject(this);
          GPRTemporary scratch(this);
  
          JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
  
<span class="udiff-line-modified-removed">-         m_jit.compare64(JITCompiler::Equal, value.gpr(), TrustedImm32(ValueUndefined), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.compare64(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::ValueUndefined), result.gpr());</span>
          JITCompiler::Jump done = m_jit.jump();
  
          isCell.link(&amp;m_jit);
          JITCompiler::Jump notMasqueradesAsUndefined;
          if (masqueradesAsUndefinedWatchpointIsStillValid()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3917,11 +4042,11 @@</span>
              m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
          }
  
          notMasqueradesAsUndefined.link(&amp;m_jit);
          done.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
          jsValueResult(result.gpr(), node, DataFormatJSBoolean);
          break;
      }
  
      case IsUndefinedOrNull: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3930,35 +4055,35 @@</span>
  
          GPRReg valueGPR = value.gpr();
          GPRReg resultGPR = result.gpr();
  
          m_jit.move(valueGPR, resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.and64(CCallHelpers::TrustedImm32(~TagBitUndefined), resultGPR);</span>
<span class="udiff-line-modified-removed">-         m_jit.compare64(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(ValueNull), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.and64(CCallHelpers::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.compare64(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(JSValue::ValueNull), resultGPR);</span>
  
          unblessedBooleanResult(resultGPR, node);
          break;
      }
  
      case IsBoolean: {
          JSValueOperand value(this, node-&gt;child1());
          GPRTemporary result(this, Reuse, value);
  
          m_jit.move(value.gpr(), result.gpr());
<span class="udiff-line-modified-removed">-         m_jit.xor64(JITCompiler::TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.xor64(JITCompiler::TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
          m_jit.test64(JITCompiler::Zero, result.gpr(), JITCompiler::TrustedImm32(static_cast&lt;int32_t&gt;(~1)), result.gpr());
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
          jsValueResult(result.gpr(), node, DataFormatJSBoolean);
          break;
      }
  
      case IsNumber: {
          JSValueOperand value(this, node-&gt;child1());
          GPRTemporary result(this, Reuse, value);
  
<span class="udiff-line-modified-removed">-         m_jit.test64(JITCompiler::NonZero, value.gpr(), GPRInfo::tagTypeNumberRegister, result.gpr());</span>
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.test64(JITCompiler::NonZero, value.gpr(), GPRInfo::numberTagRegister, result.gpr());</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
          jsValueResult(result.gpr(), node, DataFormatJSBoolean);
          break;
      }
  
      case NumberIsInteger: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3982,25 +4107,25 @@</span>
          // We&#39;re a double here.
          m_jit.unboxDouble(valueRegs.gpr(), resultGPR, tempFPR1);
          m_jit.urshift64(TrustedImm32(52), resultGPR);
          m_jit.and32(TrustedImm32(0x7ff), resultGPR);
          auto notNanNorInfinity = m_jit.branch32(JITCompiler::NotEqual, TrustedImm32(0x7ff), resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
          done.append(m_jit.jump());
  
          notNanNorInfinity.link(&amp;m_jit);
          m_jit.roundTowardZeroDouble(tempFPR1, tempFPR2);
          m_jit.compareDouble(JITCompiler::DoubleEqual, tempFPR1, tempFPR2, resultGPR);
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
          done.append(m_jit.jump());
  
          isInt32.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-         m_jit.move(TrustedImm32(ValueTrue), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
          done.append(m_jit.jump());
  
          notNumber.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-         m_jit.move(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
  
          done.link(&amp;m_jit);
          jsValueResult(resultGPR, node, DataFormatJSBoolean);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4061,11 +4186,11 @@</span>
              slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
              done.append(m_jit.jump());
  
              slowPath.link(&amp;m_jit);
              silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-             callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));</span>
<span class="udiff-line-modified-added">+             callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(inputGPR));</span>
              silentFillAllRegisters();
              m_jit.exceptionCheck();
  
              done.link(&amp;m_jit);
              int32Result(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4104,11 +4229,11 @@</span>
          m_jit.wangsInt64Hash(resultGPR, tempGPR);
          done.append(m_jit.jump());
  
          slowPath.link(&amp;m_jit);
          silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationMapHash, resultGPR, JSValueRegs(inputGPR));</span>
<span class="udiff-line-modified-added">+         callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(inputGPR));</span>
          silentFillAllRegisters();
          m_jit.exceptionCheck();
  
          done.link(&amp;m_jit);
          int32Result(resultGPR, node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4222,13 +4347,13 @@</span>
  
          if (!slowPathCases.empty()) {
              slowPathCases.link(&amp;m_jit);
              silentSpillAllRegisters(indexGPR);
              if (node-&gt;child1().useKind() == MapObjectUse)
<span class="udiff-line-modified-removed">-                 callOperation(operationJSMapFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationJSMapFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyGPR, hashGPR);</span>
              else
<span class="udiff-line-modified-removed">-                 callOperation(operationJSSetFindBucket, resultGPR, mapGPR, keyGPR, hashGPR);</span>
<span class="udiff-line-modified-added">+                 callOperation(operationJSSetFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyGPR, hashGPR);</span>
              silentFillAllRegisters();
              m_jit.exceptionCheck();
              done.append(m_jit.jump());
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4353,10 +4478,15 @@</span>
      case DirectTailCall:
      case DirectTailCallInlinedCaller:
          emitCall(node);
          break;
  
<span class="udiff-line-added">+     case VarargsLength: {</span>
<span class="udiff-line-added">+         compileVarargsLength(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case LoadVarargs: {
          compileLoadVarargs(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4402,10 +4532,16 @@</span>
  
      case CreateClonedArguments: {
          compileCreateClonedArguments(node);
          break;
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case CreateArgumentsButterfly: {</span>
<span class="udiff-line-added">+         compileCreateArgumentsButterfly(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case CreateRest: {
          compileCreateRest(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4518,16 +4654,16 @@</span>
          slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
          auto done = m_jit.jump();
  
          slowPath.link(&amp;m_jit);
          silentSpillAllRegisters(resultGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationHasOwnProperty, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR, keyGPR);</span>
          silentFillAllRegisters();
          m_jit.exceptionCheck();
  
          done.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-         m_jit.or32(TrustedImm32(ValueFalse), resultGPR);</span>
<span class="udiff-line-modified-added">+         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
          jsValueResult(resultGPR, node, DataFormatJSBoolean);
          break;
      }
  
      case CountExecution:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4820,10 +4956,15 @@</span>
          }
  
          break;
      }
  
<span class="udiff-line-added">+     case DateGetInt32OrNaN:</span>
<span class="udiff-line-added">+     case DateGetTime:</span>
<span class="udiff-line-added">+         compileDateGet(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
      case DataViewSet: {
          SpeculateCellOperand dataView(this, m_graph.varArgChild(node, 0));
          GPRReg dataViewGPR = dataView.gpr();
          speculateDataViewObject(m_graph.varArgChild(node, 0), dataViewGPR);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5025,17 +5166,17 @@</span>
  
          MacroAssembler::Label toNextOperation = m_jit.label();
  
          Vector&lt;SilentRegisterSavePlan&gt; savePlans;
          silentSpillAllRegistersImpl(false, savePlans, InvalidGPRReg);
<span class="udiff-line-modified-removed">-         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-added">+         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
  
          addSlowPathGeneratorLambda([=]() {
              callTierUp.link(&amp;m_jit);
  
              silentSpill(savePlans);
<span class="udiff-line-modified-removed">-             callOperation(triggerTierUpNowInLoop, TrustedImm32(bytecodeIndex));</span>
<span class="udiff-line-modified-added">+             callOperation(operationTriggerTierUpNowInLoop, &amp;vm(), TrustedImm32(bytecodeIndex.asBits()));</span>
              silentFill(savePlans);
  
              m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
          });
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5046,11 +5187,11 @@</span>
              MacroAssembler::Signed,
              TrustedImm32(Options::ftlTierUpCounterIncrementForReturn()),
              MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
  
          silentSpillAllRegisters(InvalidGPRReg);
<span class="udiff-line-modified-removed">-         callOperation(triggerTierUpNow);</span>
<span class="udiff-line-modified-added">+         callOperation(operationTriggerTierUpNow, &amp;vm());</span>
          silentFillAllRegisters();
  
          done.link(&amp;m_jit);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5059,11 +5200,11 @@</span>
          ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
  
          GPRTemporary temp(this);
          GPRReg tempGPR = temp.gpr();
  
<span class="udiff-line-modified-removed">-         unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="udiff-line-modified-added">+         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
          auto triggerIterator = m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex);
          DFG_ASSERT(m_jit.graph(), node, triggerIterator != m_jit.jitCode()-&gt;tierUpEntryTriggers.end());
          JITCode::TriggerReason* forceEntryTrigger = &amp;(m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex)-&gt;value);
          static_assert(!static_cast&lt;uint8_t&gt;(JITCode::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
          static_assert(sizeof(JITCode::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5084,11 +5225,11 @@</span>
          addSlowPathGeneratorLambda([=]() {
              forceOSREntry.link(&amp;m_jit);
              overflowedCounter.link(&amp;m_jit);
  
              silentSpill(savePlans);
<span class="udiff-line-modified-removed">-             callOperation(triggerOSREntryNow, tempGPR, TrustedImm32(bytecodeIndex));</span>
<span class="udiff-line-modified-added">+             callOperation(operationTriggerOSREntryNow, tempGPR, &amp;vm(), TrustedImm32(bytecodeIndex.asBits()));</span>
  
              if (savePlans.isEmpty())
                  m_jit.branchTestPtr(MacroAssembler::Zero, tempGPR).linkTo(toNextOperation, &amp;m_jit);
              else {
                  MacroAssembler::Jump osrEnter = m_jit.branchTestPtr(MacroAssembler::NonZero, tempGPR);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5109,11 +5250,11 @@</span>
          DFG_CRASH(m_jit.graph(), node, &quot;Unexpected tier-up node&quot;);
          break;
  #endif // ENABLE(FTL_JIT)
  
      case FilterCallLinkStatus:
<span class="udiff-line-modified-removed">-     case FilterGetByIdStatus:</span>
<span class="udiff-line-modified-added">+     case FilterGetByStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
          m_interpreter.filterICStatus(node);
          noResult(node);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5134,18 +5275,20 @@</span>
      case PhantomNewObject:
      case PhantomNewFunction:
      case PhantomNewGeneratorFunction:
      case PhantomNewAsyncFunction:
      case PhantomNewAsyncGeneratorFunction:
<span class="udiff-line-added">+     case PhantomNewArrayIterator:</span>
      case PhantomCreateActivation:
      case PhantomNewRegexp:
      case GetMyArgumentByVal:
      case GetMyArgumentByValOutOfBounds:
      case GetVectorLength:
      case PutHint:
      case CheckStructureImmediate:
      case MaterializeCreateActivation:
<span class="udiff-line-added">+     case MaterializeNewInternalFieldObject:</span>
      case PutStack:
      case KillStack:
      case GetStack:
      case PhantomCreateRest:
      case PhantomSpread:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5164,21 +5307,21 @@</span>
          use(node);
  }
  
  void SpeculativeJIT::moveTrueTo(GPRReg gpr)
  {
<span class="udiff-line-modified-removed">-     m_jit.move(TrustedImm32(ValueTrue), gpr);</span>
<span class="udiff-line-modified-added">+     m_jit.move(TrustedImm32(JSValue::ValueTrue), gpr);</span>
  }
  
  void SpeculativeJIT::moveFalseTo(GPRReg gpr)
  {
<span class="udiff-line-modified-removed">-     m_jit.move(TrustedImm32(ValueFalse), gpr);</span>
<span class="udiff-line-modified-added">+     m_jit.move(TrustedImm32(JSValue::ValueFalse), gpr);</span>
  }
  
  void SpeculativeJIT::blessBoolean(GPRReg gpr)
  {
<span class="udiff-line-modified-removed">-     m_jit.or32(TrustedImm32(ValueFalse), gpr);</span>
<span class="udiff-line-modified-added">+     m_jit.or32(TrustedImm32(JSValue::ValueFalse), gpr);</span>
  }
  
  void SpeculativeJIT::convertAnyInt(Edge valueEdge, GPRReg resultGPR)
  {
      JSValueOperand value(this, valueEdge, ManualOperandSpeculation);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5245,10 +5388,196 @@</span>
      FPRTemporary result(this);
      m_jit.emitRandomThunk(globalObject, temp1.gpr(), temp2.gpr(), temp3.gpr(), result.fpr());
      doubleResult(result.fpr(), node);
  }
  
<span class="udiff-line-added">+ void SpeculativeJIT::compileStringCodePointAt(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // We emit CheckArray on this node as we do in StringCharCodeAt node so that we do not need to check SpecString here.</span>
<span class="udiff-line-added">+     // And CheckArray also ensures that this String is not a rope.</span>
<span class="udiff-line-added">+     SpeculateCellOperand string(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     SpeculateStrictInt32Operand index(this, node-&gt;child2());</span>
<span class="udiff-line-added">+     StorageOperand storage(this, node-&gt;child3());</span>
<span class="udiff-line-added">+     GPRTemporary scratch1(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch2(this);</span>
<span class="udiff-line-added">+     GPRTemporary scratch3(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg stringGPR = string.gpr();</span>
<span class="udiff-line-added">+     GPRReg indexGPR = index.gpr();</span>
<span class="udiff-line-added">+     GPRReg storageGPR = storage.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="udiff-line-added">+     GPRReg scratch3GPR = scratch3.gpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), scratch1GPR);</span>
<span class="udiff-line-added">+     m_jit.load32(CCallHelpers::Address(scratch1GPR, StringImpl::lengthMemoryOffset()), scratch2GPR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // unsigned comparison so we can filter out negative indices and indices that are too large</span>
<span class="udiff-line-added">+     speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, scratch2GPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Load the character into scratch1GPR</span>
<span class="udiff-line-added">+     auto is16Bit = m_jit.branchTest32(CCallHelpers::Zero, CCallHelpers::Address(scratch1GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     CCallHelpers::JumpList done;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_jit.load8(CCallHelpers::BaseIndex(storageGPR, indexGPR, CCallHelpers::TimesOne, 0), scratch1GPR);</span>
<span class="udiff-line-added">+     done.append(m_jit.jump());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     is16Bit.link(&amp;m_jit);</span>
<span class="udiff-line-added">+     m_jit.load16(CCallHelpers::BaseIndex(storageGPR, indexGPR, CCallHelpers::TimesTwo, 0), scratch1GPR);</span>
<span class="udiff-line-added">+     // This is ok. indexGPR must be positive int32_t here and adding 1 never causes overflow if we treat indexGPR as uint32_t.</span>
<span class="udiff-line-added">+     m_jit.add32(CCallHelpers::TrustedImm32(1), indexGPR, scratch3GPR);</span>
<span class="udiff-line-added">+     done.append(m_jit.branch32(CCallHelpers::AboveOrEqual, scratch3GPR, scratch2GPR));</span>
<span class="udiff-line-added">+     m_jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), scratch1GPR, scratch2GPR);</span>
<span class="udiff-line-added">+     done.append(m_jit.branch32(CCallHelpers::NotEqual, scratch2GPR, CCallHelpers::TrustedImm32(0xd800)));</span>
<span class="udiff-line-added">+     m_jit.load16(CCallHelpers::BaseIndex(storageGPR, scratch3GPR, CCallHelpers::TimesTwo, 0), scratch3GPR);</span>
<span class="udiff-line-added">+     m_jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), scratch3GPR, scratch2GPR);</span>
<span class="udiff-line-added">+     done.append(m_jit.branch32(CCallHelpers::NotEqual, scratch2GPR, CCallHelpers::TrustedImm32(0xdc00)));</span>
<span class="udiff-line-added">+     m_jit.lshift32(CCallHelpers::TrustedImm32(10), scratch1GPR);</span>
<span class="udiff-line-added">+     m_jit.getEffectiveAddress(CCallHelpers::BaseIndex(scratch1GPR, scratch3GPR, CCallHelpers::TimesOne, -U16_SURROGATE_OFFSET), scratch1GPR);</span>
<span class="udiff-line-added">+     done.link(&amp;m_jit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int32Result(scratch1GPR, m_currentNode);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void SpeculativeJIT::compileDateGet(Node* node)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="udiff-line-added">+     GPRReg baseGPR = base.gpr();</span>
<span class="udiff-line-added">+     speculateDateObject(node-&gt;child1(), baseGPR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto emitGetCodeWithCallback = [&amp;] (ptrdiff_t cachedDoubleOffset, ptrdiff_t cachedDataOffset, auto* operation, auto callback) {</span>
<span class="udiff-line-added">+         JSValueRegsTemporary result(this);</span>
<span class="udiff-line-added">+         FPRTemporary temp1(this);</span>
<span class="udiff-line-added">+         FPRTemporary temp2(this);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-added">+         FPRReg temp1FPR = temp1.fpr();</span>
<span class="udiff-line-added">+         FPRReg temp2FPR = temp2.fpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         CCallHelpers::JumpList slowCases;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         m_jit.loadPtr(CCallHelpers::Address(baseGPR, DateInstance::offsetOfData()), resultRegs.payloadGPR());</span>
<span class="udiff-line-added">+         slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, resultRegs.payloadGPR()));</span>
<span class="udiff-line-added">+         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), temp1FPR);</span>
<span class="udiff-line-added">+         m_jit.loadDouble(CCallHelpers::Address(resultRegs.payloadGPR(), cachedDoubleOffset), temp2FPR);</span>
<span class="udiff-line-added">+         slowCases.append(m_jit.branchDouble(CCallHelpers::DoubleNotEqualOrUnordered, temp1FPR, temp2FPR));</span>
<span class="udiff-line-added">+         m_jit.load32(CCallHelpers::Address(resultRegs.payloadGPR(), cachedDataOffset), resultRegs.payloadGPR());</span>
<span class="udiff-line-added">+         callback(resultRegs.payloadGPR());</span>
<span class="udiff-line-added">+         m_jit.boxInt32(resultRegs.payloadGPR(), resultRegs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultRegs, &amp;vm(), baseGPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         jsValueResult(resultRegs, node);</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto emitGetCode = [&amp;] (ptrdiff_t cachedDoubleOffset, ptrdiff_t cachedDataOffset, auto* operation) {</span>
<span class="udiff-line-added">+         emitGetCodeWithCallback(cachedDoubleOffset, cachedDataOffset, operation, [] (GPRReg) { });</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     switch (node-&gt;intrinsic()) {</span>
<span class="udiff-line-added">+     case DatePrototypeGetTimeIntrinsic: {</span>
<span class="udiff-line-added">+         FPRTemporary result(this);</span>
<span class="udiff-line-added">+         FPRReg resultFPR = result.fpr();</span>
<span class="udiff-line-added">+         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), resultFPR);</span>
<span class="udiff-line-added">+         doubleResult(resultFPR, node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // We do not have any timezone offset which affects on milliseconds.</span>
<span class="udiff-line-added">+     // So Date#getMilliseconds and Date#getUTCMilliseconds have the same implementation.</span>
<span class="udiff-line-added">+     case DatePrototypeGetMillisecondsIntrinsic:</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCMillisecondsIntrinsic: {</span>
<span class="udiff-line-added">+         JSValueRegsTemporary result(this);</span>
<span class="udiff-line-added">+         FPRTemporary temp1(this);</span>
<span class="udiff-line-added">+         FPRTemporary temp2(this);</span>
<span class="udiff-line-added">+         FPRTemporary temp3(this);</span>
<span class="udiff-line-added">+         JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-added">+         FPRReg temp1FPR = temp1.fpr();</span>
<span class="udiff-line-added">+         FPRReg temp2FPR = temp2.fpr();</span>
<span class="udiff-line-added">+         FPRReg temp3FPR = temp3.fpr();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         m_jit.moveTrustedValue(jsNaN(), resultRegs);</span>
<span class="udiff-line-added">+         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), temp1FPR);</span>
<span class="udiff-line-added">+         auto isNaN = m_jit.branchIfNaN(temp1FPR);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static const double msPerSecondConstant = msPerSecond;</span>
<span class="udiff-line-added">+         m_jit.loadDouble(TrustedImmPtr(&amp;msPerSecondConstant), temp2FPR);</span>
<span class="udiff-line-added">+         m_jit.divDouble(temp1FPR, temp2FPR, temp3FPR);</span>
<span class="udiff-line-added">+         m_jit.floorDouble(temp3FPR, temp3FPR);</span>
<span class="udiff-line-added">+         m_jit.mulDouble(temp3FPR, temp2FPR, temp3FPR);</span>
<span class="udiff-line-added">+         m_jit.subDouble(temp1FPR, temp3FPR, temp1FPR);</span>
<span class="udiff-line-added">+         m_jit.truncateDoubleToInt32(temp1FPR, resultRegs.payloadGPR());</span>
<span class="udiff-line-added">+         m_jit.boxInt32(resultRegs.payloadGPR(), resultRegs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         isNaN.link(&amp;m_jit);</span>
<span class="udiff-line-added">+         jsValueResult(resultRegs, node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case DatePrototypeGetFullYearIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfYear(), operationDateGetFullYear);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCFullYearIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfYear(), operationDateGetUTCFullYear);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetMonthIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMonth(), operationDateGetMonth);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCMonthIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMonth(), operationDateGetUTCMonth);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetDateIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMonthDay(), operationDateGetDate);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCDateIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMonthDay(), operationDateGetUTCDate);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetDayIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfWeekDay(), operationDateGetDay);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCDayIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfWeekDay(), operationDateGetUTCDay);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetHoursIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfHour(), operationDateGetHours);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCHoursIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfHour(), operationDateGetUTCHours);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetMinutesIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMinute(), operationDateGetMinutes);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCMinutesIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMinute(), operationDateGetUTCMinutes);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetSecondsIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfSecond(), operationDateGetSeconds);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case DatePrototypeGetUTCSecondsIntrinsic:</span>
<span class="udiff-line-added">+         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfSecond(), operationDateGetUTCSeconds);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case DatePrototypeGetTimezoneOffsetIntrinsic: {</span>
<span class="udiff-line-added">+         emitGetCodeWithCallback(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfUTCOffsetInMinute(), operationDateGetTimezoneOffset, [&amp;] (GPRReg offsetGPR) {</span>
<span class="udiff-line-added">+             m_jit.neg32(offsetGPR);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case DatePrototypeGetYearIntrinsic: {</span>
<span class="udiff-line-added">+         emitGetCodeWithCallback(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfYear(), operationDateGetYear, [&amp;] (GPRReg yearGPR) {</span>
<span class="udiff-line-added">+             m_jit.sub32(TrustedImm32(1900), yearGPR);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #endif
  
  } } // namespace JSC::DFG
  
  #endif
</pre>
<center><a href="DFGSpeculativeJIT32_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStackLayoutPhase.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
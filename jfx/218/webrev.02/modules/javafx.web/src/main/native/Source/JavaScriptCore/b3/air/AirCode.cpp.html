<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirCode.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirAllocateRegistersAndStackAndGenerateCode.h&quot;
 32 #include &quot;AirCCallSpecial.h&quot;
 33 #include &quot;AirCFG.h&quot;
 34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
 35 #include &quot;B3BasicBlockUtils.h&quot;
 36 #include &quot;B3Procedure.h&quot;
 37 #include &quot;B3StackSlot.h&quot;
 38 #include &quot;CCallHelpers.h&quot;
 39 #include &lt;wtf/ListDump.h&gt;
 40 #include &lt;wtf/MathExtras.h&gt;
 41 
 42 namespace JSC { namespace B3 { namespace Air {
 43 
 44 const char* const tierName = &quot;Air &quot;;
 45 
 46 static void defaultPrologueGenerator(CCallHelpers&amp; jit, Code&amp; code)
 47 {
 48     jit.emitFunctionPrologue();
 49     if (code.frameSize()) {
 50         AllowMacroScratchRegisterUsageIf allowScratch(jit, isARM64());
 51         jit.addPtr(MacroAssembler::TrustedImm32(-code.frameSize()), MacroAssembler::framePointerRegister,  MacroAssembler::stackPointerRegister);
 52     }
 53 
 54     jit.emitSave(code.calleeSaveRegisterAtOffsetList());
 55 }
 56 
 57 Code::Code(Procedure&amp; proc)
 58     : m_proc(proc)
 59     , m_cfg(new CFG(*this))
 60     , m_lastPhaseName(&quot;initial&quot;)
 61     , m_defaultPrologueGenerator(createSharedTask&lt;PrologueGeneratorFunction&gt;(&amp;defaultPrologueGenerator))
 62 {
 63     // Come up with initial orderings of registers. The user may replace this with something else.
 64     forEachBank(
 65         [&amp;] (Bank bank) {
 66             Vector&lt;Reg&gt; volatileRegs;
 67             Vector&lt;Reg&gt; calleeSaveRegs;
 68             RegisterSet all = bank == GP ? RegisterSet::allGPRs() : RegisterSet::allFPRs();
 69             all.exclude(RegisterSet::stackRegisters());
 70             all.exclude(RegisterSet::reservedHardwareRegisters());
 71             RegisterSet calleeSave = RegisterSet::calleeSaveRegisters();
 72             all.forEach(
 73                 [&amp;] (Reg reg) {
 74                     if (!calleeSave.get(reg))
 75                         volatileRegs.append(reg);
 76                 });
 77             all.forEach(
 78                 [&amp;] (Reg reg) {
 79                     if (calleeSave.get(reg))
 80                         calleeSaveRegs.append(reg);
 81                 });
 82             if (Options::airRandomizeRegs()) {
 83                 WeakRandom random(Options::airRandomizeRegsSeed() ? Options::airRandomizeRegsSeed() : m_weakRandom.getUint32());
 84                 shuffleVector(volatileRegs, [&amp;] (unsigned limit) { return random.getUint32(limit); });
 85                 shuffleVector(calleeSaveRegs, [&amp;] (unsigned limit) { return random.getUint32(limit); });
 86             }
 87             Vector&lt;Reg&gt; result;
 88             result.appendVector(volatileRegs);
 89             result.appendVector(calleeSaveRegs);
 90             setRegsInPriorityOrder(bank, result);
 91         });
 92 
 93     if (auto reg = pinnedExtendedOffsetAddrRegister())
 94         pinRegister(*reg);
 95 
 96     m_pinnedRegs.set(MacroAssembler::framePointerRegister);
 97 }
 98 
 99 Code::~Code()
100 {
101 }
102 
103 void Code::emitDefaultPrologue(CCallHelpers&amp; jit)
104 {
105     defaultPrologueGenerator(jit, *this);
106 }
107 
108 void Code::setRegsInPriorityOrder(Bank bank, const Vector&lt;Reg&gt;&amp; regs)
109 {
110     regsInPriorityOrderImpl(bank) = regs;
111     m_mutableRegs = { };
112     forEachBank(
113         [&amp;] (Bank bank) {
114             for (Reg reg : regsInPriorityOrder(bank))
115                 m_mutableRegs.set(reg);
116         });
117 }
118 
119 void Code::pinRegister(Reg reg)
120 {
121     Vector&lt;Reg&gt;&amp; regs = regsInPriorityOrderImpl(Arg(Tmp(reg)).bank());
122     ASSERT(regs.contains(reg));
123     regs.removeFirst(reg);
124     m_mutableRegs.clear(reg);
125     ASSERT(!regs.contains(reg));
126     m_pinnedRegs.set(reg);
127 }
128 
129 RegisterSet Code::mutableGPRs()
130 {
131     RegisterSet result = m_mutableRegs;
132     result.filter(RegisterSet::allGPRs());
133     return result;
134 }
135 
136 RegisterSet Code::mutableFPRs()
137 {
138     RegisterSet result = m_mutableRegs;
139     result.filter(RegisterSet::allFPRs());
140     return result;
141 }
142 
143 bool Code::needsUsedRegisters() const
144 {
145     return m_proc.needsUsedRegisters();
146 }
147 
148 BasicBlock* Code::addBlock(double frequency)
149 {
150     std::unique_ptr&lt;BasicBlock&gt; block(new BasicBlock(m_blocks.size(), frequency));
151     BasicBlock* result = block.get();
152     m_blocks.append(WTFMove(block));
153     return result;
154 }
155 
156 StackSlot* Code::addStackSlot(unsigned byteSize, StackSlotKind kind, B3::StackSlot* b3Slot)
157 {
158     StackSlot* result = m_stackSlots.addNew(byteSize, kind, b3Slot);
159     if (m_stackIsAllocated) {
160         // FIXME: This is unnecessarily awful. Fortunately, it doesn&#39;t run often.
161         unsigned extent = WTF::roundUpToMultipleOf(result-&gt;alignment(), frameSize() + byteSize);
162         result-&gt;setOffsetFromFP(-static_cast&lt;ptrdiff_t&gt;(extent));
163         setFrameSize(WTF::roundUpToMultipleOf(stackAlignmentBytes(), extent));
164     }
165     return result;
166 }
167 
168 StackSlot* Code::addStackSlot(B3::StackSlot* b3Slot)
169 {
170     return addStackSlot(b3Slot-&gt;byteSize(), StackSlotKind::Locked, b3Slot);
171 }
172 
173 Special* Code::addSpecial(std::unique_ptr&lt;Special&gt; special)
174 {
175     special-&gt;m_code = this;
176     return m_specials.add(WTFMove(special));
177 }
178 
179 CCallSpecial* Code::cCallSpecial()
180 {
181     if (!m_cCallSpecial) {
182         m_cCallSpecial = static_cast&lt;CCallSpecial*&gt;(
183             addSpecial(makeUnique&lt;CCallSpecial&gt;()));
184     }
185 
186     return m_cCallSpecial;
187 }
188 
189 bool Code::isEntrypoint(BasicBlock* block) const
190 {
191     // Note: This function must work both before and after LowerEntrySwitch.
192 
193     if (m_entrypoints.isEmpty())
194         return !block-&gt;index();
195 
196     for (const FrequentedBlock&amp; entrypoint : m_entrypoints) {
197         if (entrypoint.block() == block)
198             return true;
199     }
200     return false;
201 }
202 
203 Optional&lt;unsigned&gt; Code::entrypointIndex(BasicBlock* block) const
204 {
205     RELEASE_ASSERT(m_entrypoints.size());
206     for (unsigned i = 0; i &lt; m_entrypoints.size(); ++i) {
207         if (m_entrypoints[i].block() == block)
208             return i;
209     }
210     return WTF::nullopt;
211 }
212 
213 void Code::setCalleeSaveRegisterAtOffsetList(RegisterAtOffsetList&amp;&amp; registerAtOffsetList, StackSlot* slot)
214 {
215     m_uncorrectedCalleeSaveRegisterAtOffsetList = WTFMove(registerAtOffsetList);
216     for (const RegisterAtOffset&amp; registerAtOffset : m_uncorrectedCalleeSaveRegisterAtOffsetList)
217         m_calleeSaveRegisters.set(registerAtOffset.reg());
218     m_calleeSaveStackSlot = slot;
219 }
220 
221 RegisterAtOffsetList Code::calleeSaveRegisterAtOffsetList() const
222 {
223     RegisterAtOffsetList result = m_uncorrectedCalleeSaveRegisterAtOffsetList;
224     if (StackSlot* slot = m_calleeSaveStackSlot) {
225         ptrdiff_t offset = slot-&gt;byteSize() + slot-&gt;offsetFromFP();
226         for (size_t i = result.size(); i--;) {
227             result.at(i) = RegisterAtOffset(
228                 result.at(i).reg(),
229                 result.at(i).offset() + offset);
230         }
231     }
232     return result;
233 }
234 
235 void Code::resetReachability()
236 {
237     clearPredecessors(m_blocks);
238     if (m_entrypoints.isEmpty())
239         updatePredecessorsAfter(m_blocks[0].get());
240     else {
241         for (const FrequentedBlock&amp; entrypoint : m_entrypoints)
242             updatePredecessorsAfter(entrypoint.block());
243     }
244 
245     for (auto&amp; block : m_blocks) {
246         if (isBlockDead(block.get()) &amp;&amp; !isEntrypoint(block.get()))
247             block = nullptr;
248     }
249 }
250 
251 void Code::dump(PrintStream&amp; out) const
252 {
253     if (!m_entrypoints.isEmpty())
254         out.print(tierName, &quot;Entrypoints: &quot;, listDump(m_entrypoints), &quot;\n&quot;);
255     for (BasicBlock* block : *this)
256         out.print(deepDump(block));
257     if (stackSlots().size()) {
258         out.print(tierName, &quot;Stack slots:\n&quot;);
259         for (StackSlot* slot : stackSlots())
260             out.print(tierName, &quot;    &quot;, pointerDump(slot), &quot;: &quot;, deepDump(slot), &quot;\n&quot;);
261     }
262     if (specials().size()) {
263         out.print(tierName, &quot;Specials:\n&quot;);
264         for (Special* special : specials())
265             out.print(tierName, &quot;    &quot;, deepDump(special), &quot;\n&quot;);
266     }
267     if (m_frameSize || m_stackIsAllocated)
268         out.print(tierName, &quot;Frame size: &quot;, m_frameSize, m_stackIsAllocated ? &quot; (Allocated)&quot; : &quot;&quot;, &quot;\n&quot;);
269     if (m_callArgAreaSize)
270         out.print(tierName, &quot;Call arg area size: &quot;, m_callArgAreaSize, &quot;\n&quot;);
271     RegisterAtOffsetList calleeSaveRegisters = this-&gt;calleeSaveRegisterAtOffsetList();
272     if (calleeSaveRegisters.size())
273         out.print(tierName, &quot;Callee saves: &quot;, calleeSaveRegisters, &quot;\n&quot;);
274 }
275 
276 unsigned Code::findFirstBlockIndex(unsigned index) const
277 {
278     while (index &lt; size() &amp;&amp; !at(index))
279         index++;
280     return index;
281 }
282 
283 unsigned Code::findNextBlockIndex(unsigned index) const
284 {
285     return findFirstBlockIndex(index + 1);
286 }
287 
288 BasicBlock* Code::findNextBlock(BasicBlock* block) const
289 {
290     unsigned index = findNextBlockIndex(block-&gt;index());
291     if (index &lt; size())
292         return at(index);
293     return nullptr;
294 }
295 
296 void Code::addFastTmp(Tmp tmp)
297 {
298     m_fastTmps.add(tmp);
299 }
300 
301 void* Code::addDataSection(size_t size)
302 {
303     return m_proc.addDataSection(size);
304 }
305 
306 unsigned Code::jsHash() const
307 {
308     unsigned result = 0;
309 
310     for (BasicBlock* block : *this) {
311         result *= 1000001;
312         for (Inst&amp; inst : *block) {
313             result *= 97;
314             result += inst.jsHash();
315         }
316         for (BasicBlock* successor : block-&gt;successorBlocks()) {
317             result *= 7;
318             result += successor-&gt;index();
319         }
320     }
321     for (StackSlot* slot : stackSlots()) {
322         result *= 101;
323         result += slot-&gt;jsHash();
324     }
325 
326     return result;
327 }
328 
329 void Code::setNumEntrypoints(unsigned numEntrypoints)
330 {
331     m_prologueGenerators.clear();
332     m_prologueGenerators.reserveCapacity(numEntrypoints);
333     for (unsigned i = 0; i &lt; numEntrypoints; ++i)
334         m_prologueGenerators.uncheckedAppend(m_defaultPrologueGenerator.copyRef());
335 }
336 
337 } } } // namespace JSC::B3::Air
338 
339 #endif // ENABLE(B3_JIT)
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeBasicBlock.cpp
@@ -28,16 +28,40 @@
 
 #include "CodeBlock.h"
 #include "InterpreterInlines.h"
 #include "JSCInlines.h"
 #include "PreciseJumpTargets.h"
+#include "UnlinkedCodeBlockGenerator.h"
 
 namespace JSC {
 
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(BytecodeBasicBlock);
+
+BytecodeBasicBlock::BytecodeBasicBlock(const InstructionStream::Ref& instruction, unsigned blockIndex)
+    : m_leaderOffset(instruction.offset())
+    , m_totalLength(0)
+    , m_index(blockIndex)
+{
+    addLength(instruction->size());
+}
+
+BytecodeBasicBlock::BytecodeBasicBlock(BytecodeBasicBlock::SpecialBlockType blockType, unsigned blockIndex)
+    : m_leaderOffset(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)
+    , m_totalLength(blockType == BytecodeBasicBlock::EntryBlock ? 0 : UINT_MAX)
+    , m_index(blockIndex)
+{
+}
+
+void BytecodeBasicBlock::addLength(unsigned bytecodeLength)
+{
+    m_delta.append(bytecodeLength);
+    m_totalLength += bytecodeLength;
+}
+
 void BytecodeBasicBlock::shrinkToFit()
 {
-    m_offsets.shrinkToFit();
+    m_delta.shrinkToFit();
     m_successors.shrinkToFit();
 }
 
 static bool isJumpTarget(OpcodeID opcodeID, const Vector<InstructionStream::Offset, 32>& jumpTargets, unsigned bytecodeOffset)
 {
@@ -46,116 +70,118 @@
 
     return std::binary_search(jumpTargets.begin(), jumpTargets.end(), bytecodeOffset);
 }
 
 template<typename Block>
-void BytecodeBasicBlock::computeImpl(Block* codeBlock, const InstructionStream& instructions, Vector<std::unique_ptr<BytecodeBasicBlock>>& basicBlocks)
+auto BytecodeBasicBlock::computeImpl(Block* codeBlock, const InstructionStream& instructions) -> BasicBlockVector
 {
+    BasicBlockVector basicBlocks;
     Vector<InstructionStream::Offset, 32> jumpTargets;
     computePreciseJumpTargets(codeBlock, instructions, jumpTargets);
 
-    auto appendBlock = [&] (std::unique_ptr<BytecodeBasicBlock>&& block) {
-        block->m_index = basicBlocks.size();
-        basicBlocks.append(WTFMove(block));
-    };
-
-    auto linkBlocks = [&] (BytecodeBasicBlock* from, BytecodeBasicBlock* to) {
-        from->addSuccessor(to);
+    auto linkBlocks = [&] (BytecodeBasicBlock& from, BytecodeBasicBlock& to) {
+        from.addSuccessor(to);
     };
 
-    // Create the entry and exit basic blocks.
-    basicBlocks.reserveCapacity(jumpTargets.size() + 2);
-
-    auto entry = makeUnique<BytecodeBasicBlock>(BytecodeBasicBlock::EntryBlock);
-    auto firstBlock = makeUnique<BytecodeBasicBlock>(BytecodeBasicBlock::EntryBlock);
-    linkBlocks(entry.get(), firstBlock.get());
+    {
+        // Create the entry and exit basic blocks.
+        basicBlocks.reserveCapacity(jumpTargets.size() + 2);
+        {
+            // Entry block.
+            basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());
+            // First block.
+            basicBlocks.constructAndAppend(BytecodeBasicBlock::EntryBlock, basicBlocks.size());
+            linkBlocks(basicBlocks[0], basicBlocks[1]);
+        }
 
-    appendBlock(WTFMove(entry));
-    BytecodeBasicBlock* current = firstBlock.get();
-    appendBlock(WTFMove(firstBlock));
+        BytecodeBasicBlock* current = &basicBlocks.last();
+        auto appendBlock = [&] (const InstructionStream::Ref& instruction) -> BytecodeBasicBlock* {
+            basicBlocks.constructAndAppend(instruction, basicBlocks.size());
+            return &basicBlocks.last();
+        };
+        bool nextInstructionIsLeader = false;
+        for (const auto& instruction : instructions) {
+            auto bytecodeOffset = instruction.offset();
+            OpcodeID opcodeID = instruction->opcodeID();
 
-    auto exit = makeUnique<BytecodeBasicBlock>(BytecodeBasicBlock::ExitBlock);
+            bool createdBlock = false;
+            // If the current bytecode is a jump target, then it's the leader of its own basic block.
+            if (nextInstructionIsLeader || isJumpTarget(opcodeID, jumpTargets, bytecodeOffset)) {
+                current = appendBlock(instruction);
+                createdBlock = true;
+                nextInstructionIsLeader = false;
+            }
 
-    bool nextInstructionIsLeader = false;
+            // If the current bytecode is a branch or a return, then the next instruction is the leader of its own basic block.
+            if (isBranch(opcodeID) || isTerminal(opcodeID) || isThrow(opcodeID))
+                nextInstructionIsLeader = true;
 
-    for (const auto& instruction : instructions) {
-        auto bytecodeOffset = instruction.offset();
-        OpcodeID opcodeID = instruction->opcodeID();
+            if (createdBlock)
+                continue;
 
-        bool createdBlock = false;
-        // If the current bytecode is a jump target, then it's the leader of its own basic block.
-        if (isJumpTarget(opcodeID, jumpTargets, bytecodeOffset) || nextInstructionIsLeader) {
-            auto newBlock = makeUnique<BytecodeBasicBlock>(instruction);
-            current = newBlock.get();
-            appendBlock(WTFMove(newBlock));
-            createdBlock = true;
-            nextInstructionIsLeader = false;
+            // Otherwise, just add to the length of the current block.
+            current->addLength(instruction->size());
         }
-
-        // If the current bytecode is a branch or a return, then the next instruction is the leader of its own basic block.
-        if (isBranch(opcodeID) || isTerminal(opcodeID) || isThrow(opcodeID))
-            nextInstructionIsLeader = true;
-
-        if (createdBlock)
-            continue;
-
-        // Otherwise, just add to the length of the current block.
-        current->addLength(instruction->size());
+        // Exit block.
+        basicBlocks.constructAndAppend(BytecodeBasicBlock::ExitBlock, basicBlocks.size());
+        basicBlocks.shrinkToFit();
+        ASSERT(basicBlocks.last().isExitBlock());
     }
+    // After this point, we never change basicBlocks.
 
     // Link basic blocks together.
     for (unsigned i = 0; i < basicBlocks.size(); i++) {
-        BytecodeBasicBlock* block = basicBlocks[i].get();
+        BytecodeBasicBlock& block = basicBlocks[i];
 
-        if (block->isEntryBlock() || block->isExitBlock())
+        if (block.isEntryBlock() || block.isExitBlock())
             continue;
 
         bool fallsThrough = true;
-        for (auto bytecodeOffset : block->offsets()) {
-            auto instruction = instructions.at(bytecodeOffset);
+        for (unsigned visitedLength = 0; visitedLength < block.totalLength();) {
+            InstructionStream::Ref instruction = instructions.at(block.leaderOffset() + visitedLength);
             OpcodeID opcodeID = instruction->opcodeID();
 
+            visitedLength += instruction->size();
+
             // If we found a terminal bytecode, link to the exit block.
             if (isTerminal(opcodeID)) {
-                ASSERT(bytecodeOffset + instruction->size() == block->leaderOffset() + block->totalLength());
-                linkBlocks(block, exit.get());
+                ASSERT(instruction.offset() + instruction->size() == block.leaderOffset() + block.totalLength());
+                linkBlocks(block, basicBlocks.last());
                 fallsThrough = false;
                 break;
             }
 
             // If we found a throw, get the HandlerInfo for this instruction to see where we will jump.
             // If there isn't one, treat this throw as a terminal. This is true even if we have a finally
             // block because the finally block will create its own catch, which will generate a HandlerInfo.
             if (isThrow(opcodeID)) {
-                ASSERT(bytecodeOffset + instruction->size() == block->leaderOffset() + block->totalLength());
-                auto* handler = codeBlock->handlerForBytecodeOffset(instruction.offset());
+                ASSERT(instruction.offset() + instruction->size() == block.leaderOffset() + block.totalLength());
+                auto* handler = codeBlock->handlerForBytecodeIndex(BytecodeIndex(instruction.offset()));
                 fallsThrough = false;
                 if (!handler) {
-                    linkBlocks(block, exit.get());
+                    linkBlocks(block, basicBlocks.last());
                     break;
                 }
-                for (unsigned i = 0; i < basicBlocks.size(); i++) {
-                    BytecodeBasicBlock* otherBlock = basicBlocks[i].get();
-                    if (handler->target == otherBlock->leaderOffset()) {
+                for (auto& otherBlock : basicBlocks) {
+                    if (handler->target == otherBlock.leaderOffset()) {
                         linkBlocks(block, otherBlock);
                         break;
                     }
                 }
                 break;
             }
 
             // If we found a branch, link to the block(s) that we jump to.
             if (isBranch(opcodeID)) {
-                ASSERT(bytecodeOffset + instruction->size() == block->leaderOffset() + block->totalLength());
+                ASSERT(instruction.offset() + instruction->size() == block.leaderOffset() + block.totalLength());
                 Vector<InstructionStream::Offset, 1> bytecodeOffsetsJumpedTo;
                 findJumpTargetsForInstruction(codeBlock, instruction, bytecodeOffsetsJumpedTo);
 
                 size_t numberOfJumpTargets = bytecodeOffsetsJumpedTo.size();
                 ASSERT(numberOfJumpTargets);
-                for (unsigned i = 0; i < basicBlocks.size(); i++) {
-                    BytecodeBasicBlock* otherBlock = basicBlocks[i].get();
-                    if (bytecodeOffsetsJumpedTo.contains(otherBlock->leaderOffset())) {
+                for (auto& otherBlock : basicBlocks) {
+                    if (bytecodeOffsetsJumpedTo.contains(otherBlock.leaderOffset())) {
                         linkBlocks(block, otherBlock);
                         --numberOfJumpTargets;
                         if (!numberOfJumpTargets)
                             break;
                     }
@@ -174,27 +200,30 @@
         }
 
         // If we fall through then link to the next block in program order.
         if (fallsThrough) {
             ASSERT(i + 1 < basicBlocks.size());
-            BytecodeBasicBlock* nextBlock = basicBlocks[i + 1].get();
+            BytecodeBasicBlock& nextBlock = basicBlocks[i + 1];
             linkBlocks(block, nextBlock);
         }
     }
 
-    appendBlock(WTFMove(exit));
+    unsigned index = 0;
+    for (auto& basicBlock : basicBlocks) {
+        basicBlock.shrinkToFit();
+        ASSERT_UNUSED(index, basicBlock.index() == index++);
+    }
 
-    for (auto& basicBlock : basicBlocks)
-        basicBlock->shrinkToFit();
+    return basicBlocks;
 }
 
-void BytecodeBasicBlock::compute(CodeBlock* codeBlock, const InstructionStream& instructions, Vector<std::unique_ptr<BytecodeBasicBlock>>& basicBlocks)
+auto BytecodeBasicBlock::compute(CodeBlock* codeBlock, const InstructionStream& instructions) -> BasicBlockVector
 {
-    computeImpl(codeBlock, instructions, basicBlocks);
+    return computeImpl(codeBlock, instructions);
 }
 
-void BytecodeBasicBlock::compute(UnlinkedCodeBlock* codeBlock, const InstructionStream& instructions, Vector<std::unique_ptr<BytecodeBasicBlock>>& basicBlocks)
+auto BytecodeBasicBlock::compute(UnlinkedCodeBlockGenerator* codeBlock, const InstructionStream& instructions) -> BasicBlockVector
 {
-    computeImpl(codeBlock, instructions, basicBlocks);
+    return computeImpl(codeBlock, instructions);
 }
 
 } // namespace JSC

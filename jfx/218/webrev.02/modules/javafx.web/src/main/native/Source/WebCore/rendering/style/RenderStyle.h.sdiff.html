<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyleConstants.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  96     } while (0)
  97 
  98 #define SET_BORDERVALUE_COLOR(group, variable, value) do { \
  99         if (!compareEqual(group-&gt;variable.color(), value)) \
 100             group.access().variable.setColor(value); \
 101     } while (0)
 102 
 103 namespace WebCore {
 104 
 105 class BorderData;
 106 class ContentData;
 107 class CounterContent;
 108 class CursorList;
 109 class FontCascade;
 110 class FontMetrics;
 111 class IntRect;
 112 class Pair;
 113 class ShadowData;
 114 class StyleImage;
 115 class StyleInheritedData;
<span class="line-removed"> 116 class StyleResolver;</span>
 117 class StyleScrollSnapArea;
 118 class StyleScrollSnapPort;
 119 class TransformationMatrix;
 120 
 121 struct ScrollSnapAlign;
 122 struct ScrollSnapType;
 123 
 124 using PseudoStyleCache = Vector&lt;std::unique_ptr&lt;RenderStyle&gt;, 4&gt;;
 125 
 126 template&lt;typename T, typename U&gt; inline bool compareEqual(const T&amp; t, const U&amp; u) { return t == static_cast&lt;const T&amp;&gt;(u); }
 127 

 128 class RenderStyle {
<span class="line-modified"> 129     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed"> 130 </span>
 131 private:
 132     enum CloneTag { Clone };
 133     enum CreateDefaultStyleTag { CreateDefaultStyle };
 134 
 135 public:
 136     RenderStyle(RenderStyle&amp;&amp;);
 137     RenderStyle&amp; operator=(RenderStyle&amp;&amp;);
<span class="line-modified"> 138     ~RenderStyle();</span>
 139 
 140     RenderStyle replace(RenderStyle&amp;&amp;) WARN_UNUSED_RETURN;
 141 
 142     explicit RenderStyle(CreateDefaultStyleTag);
 143     RenderStyle(const RenderStyle&amp;, CloneTag);
 144 
 145     static RenderStyle&amp; defaultStyle();
 146 
 147     static RenderStyle create();
 148     static std::unique_ptr&lt;RenderStyle&gt; createPtr();
 149 
 150     static RenderStyle clone(const RenderStyle&amp;);
 151     static std::unique_ptr&lt;RenderStyle&gt; clonePtr(const RenderStyle&amp;);
 152 
 153     static RenderStyle createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType);
 154     static RenderStyle createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle);
 155 
<span class="line-modified"> 156 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
 157     bool deletionHasBegun() const { return m_deletionHasBegun; }
 158 #endif
 159 
 160     bool operator==(const RenderStyle&amp;) const;
 161     bool operator!=(const RenderStyle&amp; other) const { return !(*this == other); }
 162 
 163     void inheritFrom(const RenderStyle&amp; inheritParent);
 164     void copyNonInheritedFrom(const RenderStyle&amp;);
 165     void copyContentFrom(const RenderStyle&amp;);
 166 
 167     ContentPosition resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 168     ContentDistribution resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 169     ContentPosition resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 170     ContentDistribution resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 171     StyleSelfAlignmentData resolvedAlignItems(ItemPosition normalValueBehaviour) const;
 172     StyleSelfAlignmentData resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 173     StyleContentAlignmentData resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 174     StyleSelfAlignmentData resolvedJustifyItems(ItemPosition normalValueBehaviour) const;
 175     StyleSelfAlignmentData resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 176     StyleContentAlignmentData resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
</pre>
<hr />
<pre>
 212     bool hasPadding() const { return !m_surroundData-&gt;padding.isZero(); }
 213     bool hasOffset() const { return !m_surroundData-&gt;offset.isZero(); }
 214     bool hasMarginBeforeQuirk() const { return marginBefore().hasQuirk(); }
 215     bool hasMarginAfterQuirk() const { return marginAfter().hasQuirk(); }
 216 
 217     bool hasBackgroundImage() const { return m_backgroundData-&gt;background.hasImage(); }
 218     bool hasFixedBackgroundImage() const { return m_backgroundData-&gt;background.hasFixedImage(); }
 219 
 220     bool hasEntirelyFixedBackground() const;
 221 
 222     bool hasAppearance() const { return appearance() != NoControlPart; }
 223 
 224     bool hasBackground() const;
 225 
 226     LayoutBoxExtent imageOutsets(const NinePieceImage&amp;) const;
 227     bool hasBorderImageOutsets() const { return borderImage().hasImage() &amp;&amp; !borderImage().outset().isZero(); }
 228     LayoutBoxExtent borderImageOutsets() const { return imageOutsets(borderImage()); }
 229 
 230     LayoutBoxExtent maskBoxImageOutsets() const { return imageOutsets(maskBoxImage()); }
 231 
<span class="line-modified"> 232     bool hasFilterOutsets() const { return hasFilter() &amp;&amp; filter().hasOutsets(); }</span>
<span class="line-removed"> 233     FilterOutsets filterOutsets() const { return hasFilter() ? filter().outsets() : FilterOutsets(); }</span>
 234 
 235     Order rtlOrdering() const { return static_cast&lt;Order&gt;(m_inheritedFlags.rtlOrdering); }
 236     void setRTLOrdering(Order ordering) { m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(ordering); }
 237 
 238     bool isStyleAvailable() const;
 239 
 240     bool hasAnyPublicPseudoStyles() const;
 241     bool hasPseudoStyle(PseudoId) const;
 242     void setHasPseudoStyle(PseudoId);
 243     void setHasPseudoStyles(PseudoIdSet);
 244     bool hasUniquePseudoStyle() const;
 245 
 246     // attribute getter methods
 247 
 248     DisplayType display() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay); }
 249 
 250     const Length&amp; left() const { return m_surroundData-&gt;offset.left(); }
 251     const Length&amp; right() const { return m_surroundData-&gt;offset.right(); }
 252     const Length&amp; top() const { return m_surroundData-&gt;offset.top(); }
 253     const Length&amp; bottom() const { return m_surroundData-&gt;offset.bottom(); }
</pre>
<hr />
<pre>
 282     const Length&amp; logicalMinHeight() const { return isHorizontalWritingMode() ? minHeight() : minWidth(); }
 283     const Length&amp; logicalMaxHeight() const { return isHorizontalWritingMode() ? maxHeight() : maxWidth(); }
 284 
 285     const BorderData&amp; border() const { return m_surroundData-&gt;border; }
 286     const BorderValue&amp; borderLeft() const { return m_surroundData-&gt;border.left(); }
 287     const BorderValue&amp; borderRight() const { return m_surroundData-&gt;border.right(); }
 288     const BorderValue&amp; borderTop() const { return m_surroundData-&gt;border.top(); }
 289     const BorderValue&amp; borderBottom() const { return m_surroundData-&gt;border.bottom(); }
 290 
 291     const BorderValue&amp; borderBefore() const;
 292     const BorderValue&amp; borderAfter() const;
 293     const BorderValue&amp; borderStart() const;
 294     const BorderValue&amp; borderEnd() const;
 295 
 296     const NinePieceImage&amp; borderImage() const { return m_surroundData-&gt;border.image(); }
 297     StyleImage* borderImageSource() const { return m_surroundData-&gt;border.image().image(); }
 298     const LengthBox&amp; borderImageSlices() const { return m_surroundData-&gt;border.image().imageSlices(); }
 299     const LengthBox&amp; borderImageWidth() const { return m_surroundData-&gt;border.image().borderSlices(); }
 300     const LengthBox&amp; borderImageOutset() const { return m_surroundData-&gt;border.image().outset(); }
 301 
<span class="line-modified"> 302     const LengthSize&amp; borderTopLeftRadius() const { return m_surroundData-&gt;border.topLeft(); }</span>
<span class="line-modified"> 303     const LengthSize&amp; borderTopRightRadius() const { return m_surroundData-&gt;border.topRight(); }</span>
<span class="line-modified"> 304     const LengthSize&amp; borderBottomLeftRadius() const { return m_surroundData-&gt;border.bottomLeft(); }</span>
<span class="line-modified"> 305     const LengthSize&amp; borderBottomRightRadius() const { return m_surroundData-&gt;border.bottomRight(); }</span>
 306     bool hasBorderRadius() const { return m_surroundData-&gt;border.hasBorderRadius(); }
 307 
 308     float borderLeftWidth() const { return m_surroundData-&gt;border.borderLeftWidth(); }
 309     BorderStyle borderLeftStyle() const { return m_surroundData-&gt;border.left().style(); }
 310     bool borderLeftIsTransparent() const { return m_surroundData-&gt;border.left().isTransparent(); }
 311     float borderRightWidth() const { return m_surroundData-&gt;border.borderRightWidth(); }
 312     BorderStyle borderRightStyle() const { return m_surroundData-&gt;border.right().style(); }
 313     bool borderRightIsTransparent() const { return m_surroundData-&gt;border.right().isTransparent(); }
 314     float borderTopWidth() const { return m_surroundData-&gt;border.borderTopWidth(); }
 315     BorderStyle borderTopStyle() const { return m_surroundData-&gt;border.top().style(); }
 316     bool borderTopIsTransparent() const { return m_surroundData-&gt;border.top().isTransparent(); }
 317     float borderBottomWidth() const { return m_surroundData-&gt;border.borderBottomWidth(); }
 318     BorderStyle borderBottomStyle() const { return m_surroundData-&gt;border.bottom().style(); }
 319     bool borderBottomIsTransparent() const { return m_surroundData-&gt;border.bottom().isTransparent(); }
 320     FloatBoxExtent borderWidth() const { return m_surroundData-&gt;border.borderWidth(); }
 321 
 322     float borderBeforeWidth() const;
 323     float borderAfterWidth() const;
 324     float borderStartWidth() const;
 325     float borderEndWidth() const;
</pre>
<hr />
<pre>
 677     AnimationList&amp; ensureAnimations();
 678     AnimationList&amp; ensureTransitions();
 679 
 680     bool hasAnimations() const { return m_rareNonInheritedData-&gt;animations &amp;&amp; m_rareNonInheritedData-&gt;animations-&gt;size() &gt; 0; }
 681     bool hasTransitions() const { return m_rareNonInheritedData-&gt;transitions &amp;&amp; m_rareNonInheritedData-&gt;transitions-&gt;size() &gt; 0; }
 682 
 683     // Return the first found Animation (including &#39;all&#39; transitions).
 684     const Animation* transitionForProperty(CSSPropertyID) const;
 685 
 686     TransformStyle3D transformStyle3D() const { return static_cast&lt;TransformStyle3D&gt;(m_rareNonInheritedData-&gt;transformStyle3D); }
 687     bool preserves3D() const { return transformStyle3D() == TransformStyle3D::Preserve3D; }
 688 
 689     BackfaceVisibility backfaceVisibility() const { return static_cast&lt;BackfaceVisibility&gt;(m_rareNonInheritedData-&gt;backfaceVisibility); }
 690     float perspective() const { return m_rareNonInheritedData-&gt;perspective; }
 691     bool hasPerspective() const { return m_rareNonInheritedData-&gt;perspective &gt; 0; }
 692     const Length&amp; perspectiveOriginX() const { return m_rareNonInheritedData-&gt;perspectiveOriginX; }
 693     const Length&amp; perspectiveOriginY() const { return m_rareNonInheritedData-&gt;perspectiveOriginY; }
 694     const LengthSize&amp; pageSize() const { return m_rareNonInheritedData-&gt;pageSize; }
 695     PageSizeType pageSizeType() const { return static_cast&lt;PageSizeType&gt;(m_rareNonInheritedData-&gt;pageSizeType); }
 696 
<span class="line-modified"> 697     LineBoxContain lineBoxContain() const { return m_rareInheritedData-&gt;lineBoxContain; }</span>
 698     const LineClampValue&amp; lineClamp() const { return m_rareNonInheritedData-&gt;lineClamp; }
 699     const IntSize&amp; initialLetter() const { return m_rareNonInheritedData-&gt;initialLetter; }
 700     int initialLetterDrop() const { return initialLetter().width(); }
 701     int initialLetterHeight() const { return initialLetter().height(); }
 702 
 703 #if ENABLE(POINTER_EVENTS)
 704     OptionSet&lt;TouchAction&gt; touchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareNonInheritedData-&gt;touchActions); }
 705     // &#39;touch-action&#39; behavior depends on values in ancestors. We use an additional inherited property to implement that.
 706     OptionSet&lt;TouchAction&gt; effectiveTouchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareInheritedData-&gt;effectiveTouchActions); }
 707 #endif
 708 
 709 #if ENABLE(CSS_SCROLL_SNAP)
 710     // Scroll snap port style.
 711     const StyleScrollSnapPort&amp; scrollSnapPort() const;
 712     const ScrollSnapType&amp; scrollSnapType() const;
 713     const LengthBox&amp; scrollPadding() const;
 714     const Length&amp; scrollPaddingTop() const;
 715     const Length&amp; scrollPaddingBottom() const;
 716     const Length&amp; scrollPaddingLeft() const;
 717     const Length&amp; scrollPaddingRight() const;
</pre>
<hr />
<pre>
 721     const ScrollSnapAlign&amp; scrollSnapAlign() const;
 722     const LengthBox&amp; scrollSnapMargin() const;
 723     const Length&amp; scrollSnapMarginTop() const;
 724     const Length&amp; scrollSnapMarginBottom() const;
 725     const Length&amp; scrollSnapMarginLeft() const;
 726     const Length&amp; scrollSnapMarginRight() const;
 727 #endif
 728 
 729 #if ENABLE(TOUCH_EVENTS)
 730     Color tapHighlightColor() const { return m_rareInheritedData-&gt;tapHighlightColor; }
 731 #endif
 732 
 733 #if PLATFORM(IOS_FAMILY)
 734     bool touchCalloutEnabled() const { return m_rareInheritedData-&gt;touchCalloutEnabled; }
 735 #endif
 736 
 737 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 738     bool useTouchOverflowScrolling() const { return m_rareInheritedData-&gt;useTouchOverflowScrolling; }
 739 #endif
 740 


 741 #if ENABLE(TEXT_AUTOSIZING)
 742     TextSizeAdjustment textSizeAdjust() const { return m_rareInheritedData-&gt;textSizeAdjust; }
 743     AutosizeStatus autosizeStatus() const;
 744     bool isIdempotentTextAutosizingCandidate() const;
 745 #endif
 746 
 747     TextSecurity textSecurity() const { return static_cast&lt;TextSecurity&gt;(m_rareInheritedData-&gt;textSecurity); }
 748 
 749     WritingMode writingMode() const { return static_cast&lt;WritingMode&gt;(m_inheritedFlags.writingMode); }
 750     bool isHorizontalWritingMode() const { return WebCore::isHorizontalWritingMode(writingMode()); }
 751     bool isVerticalWritingMode() const { return WebCore::isVerticalWritingMode(writingMode()); }
 752     bool isFlippedLinesWritingMode() const { return WebCore::isFlippedLinesWritingMode(writingMode()); }
 753     bool isFlippedBlocksWritingMode() const { return WebCore::isFlippedWritingMode(writingMode()); }
 754 
 755     ImageOrientation imageOrientation() const;
 756 
 757     ImageRendering imageRendering() const { return static_cast&lt;ImageRendering&gt;(m_rareInheritedData-&gt;imageRendering); }
 758 
 759 #if ENABLE(CSS_IMAGE_RESOLUTION)
 760     ImageResolutionSource imageResolutionSource() const { return static_cast&lt;ImageResolutionSource&gt;(m_rareInheritedData-&gt;imageResolutionSource); }
</pre>
<hr />
<pre>
 821     void setBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.bottom(), WTFMove(length)); }
 822 
 823     void setWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_width, WTFMove(length)); }
 824     void setHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_height, WTFMove(length)); }
 825 
 826     void setLogicalWidth(Length&amp;&amp;);
 827     void setLogicalHeight(Length&amp;&amp;);
 828 
 829     void setMinWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minWidth, WTFMove(length)); }
 830     void setMaxWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxWidth, WTFMove(length)); }
 831     void setMinHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minHeight, WTFMove(length)); }
 832     void setMaxHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxHeight, WTFMove(length)); }
 833 
 834     void resetBorder() { resetBorderImage(); resetBorderTop(); resetBorderRight(); resetBorderBottom(); resetBorderLeft(); resetBorderRadius(); }
 835     void resetBorderTop() { SET_VAR(m_surroundData, border.m_top, BorderValue()); }
 836     void resetBorderRight() { SET_VAR(m_surroundData, border.m_right, BorderValue()); }
 837     void resetBorderBottom() { SET_VAR(m_surroundData, border.m_bottom, BorderValue()); }
 838     void resetBorderLeft() { SET_VAR(m_surroundData, border.m_left, BorderValue()); }
 839     void resetBorderImage() { SET_VAR(m_surroundData, border.m_image, NinePieceImage()); }
 840     void resetBorderRadius() { resetBorderTopLeftRadius(); resetBorderTopRightRadius(); resetBorderBottomLeftRadius(); resetBorderBottomRightRadius(); }
<span class="line-modified"> 841     void resetBorderTopLeftRadius() { SET_VAR(m_surroundData, border.m_topLeft, initialBorderRadius()); }</span>
<span class="line-modified"> 842     void resetBorderTopRightRadius() { SET_VAR(m_surroundData, border.m_topRight, initialBorderRadius()); }</span>
<span class="line-modified"> 843     void resetBorderBottomLeftRadius() { SET_VAR(m_surroundData, border.m_bottomLeft, initialBorderRadius()); }</span>
<span class="line-modified"> 844     void resetBorderBottomRightRadius() { SET_VAR(m_surroundData, border.m_bottomRight, initialBorderRadius()); }</span>
 845 
 846     void setBackgroundColor(const Color&amp; v) { SET_VAR(m_backgroundData, color, v); }
 847 
 848     void setBackgroundXPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_xPosition, WTFMove(length)); }
 849     void setBackgroundYPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_yPosition, WTFMove(length)); }
 850     void setBackgroundSize(FillSizeType b) { SET_VAR(m_backgroundData, background.m_sizeType, static_cast&lt;unsigned&gt;(b)); }
 851     void setBackgroundSizeLength(LengthSize&amp;&amp; size) { SET_VAR(m_backgroundData, background.m_sizeLength, WTFMove(size)); }
 852 
 853     void setBorderImage(const NinePieceImage&amp; b) { SET_VAR(m_surroundData, border.m_image, b); }
 854     void setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp;);
 855     void setBorderImageSlices(LengthBox&amp;&amp;);
 856     void setBorderImageWidth(LengthBox&amp;&amp;);
 857     void setBorderImageOutset(LengthBox&amp;&amp;);
 858 
<span class="line-modified"> 859     void setBorderTopLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topLeft, WTFMove(size)); }</span>
<span class="line-modified"> 860     void setBorderTopRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topRight, WTFMove(size)); }</span>
<span class="line-modified"> 861     void setBorderBottomLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomLeft, WTFMove(size)); }</span>
<span class="line-modified"> 862     void setBorderBottomRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomRight, WTFMove(size)); }</span>
 863 
 864     void setBorderRadius(LengthSize&amp;&amp;);
 865     void setBorderRadius(const IntSize&amp;);
 866 
 867     RoundedRect getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 868     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 869 
 870     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
 871         LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 872 
 873     void setBorderLeftWidth(float v) { SET_VAR(m_surroundData, border.m_left.m_width, v); }
 874     void setBorderLeftStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_left.m_style, static_cast&lt;unsigned&gt;(v)); }
 875     void setBorderLeftColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_left, v); }
 876     void setBorderRightWidth(float v) { SET_VAR(m_surroundData, border.m_right.m_width, v); }
 877     void setBorderRightStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_right.m_style, static_cast&lt;unsigned&gt;(v)); }
 878     void setBorderRightColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_right, v); }
 879     void setBorderTopWidth(float v) { SET_VAR(m_surroundData, border.m_top.m_width, v); }
 880     void setBorderTopStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_top.m_style, static_cast&lt;unsigned&gt;(v)); }
 881     void setBorderTopColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_top, v); }
 882     void setBorderBottomWidth(float v) { SET_VAR(m_surroundData, border.m_bottom.m_width, v); }
</pre>
<hr />
<pre>
 933     void setTextDecorationThickness(TextDecorationThickness textDecorationThickness) { SET_VAR(m_rareInheritedData, textDecorationThickness, textDecorationThickness); }
 934     void setDirection(TextDirection v) { m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(v); }
 935     void setHasExplicitlySetDirection(bool v) { m_nonInheritedFlags.hasExplicitlySetDirection = v; }
 936     void setLineHeight(Length&amp;&amp;);
 937     bool setZoom(float);
 938     void setZoomWithoutReturnValue(float f) { setZoom(f); }
 939     bool setEffectiveZoom(float);
 940     void setTextZoom(TextZoom v) { SET_VAR(m_rareInheritedData, textZoom, static_cast&lt;unsigned&gt;(v)); }
 941 
 942 #if ENABLE(CSS3_TEXT)
 943     void setTextIndentLine(TextIndentLine v) { SET_VAR(m_rareInheritedData, textIndentLine, v); }
 944     void setTextIndentType(TextIndentType v) { SET_VAR(m_rareInheritedData, textIndentType, v); }
 945     void setTextAlignLast(TextAlignLast v) { SET_VAR(m_rareInheritedData, textAlignLast, v); }
 946     void setTextJustify(TextJustify v) { SET_VAR(m_rareInheritedData, textJustify, v); }
 947 #endif
 948 
 949 #if ENABLE(TEXT_AUTOSIZING)
 950     void setSpecifiedLineHeight(Length&amp;&amp;);
 951 #endif
 952 
<span class="line-removed"> 953 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
 954     void setImageOrientation(ImageOrientation v) { SET_VAR(m_rareInheritedData, imageOrientation, static_cast&lt;int&gt;(v)); }
<span class="line-removed"> 955 #endif</span>
<span class="line-removed"> 956 </span>
 957     void setImageRendering(ImageRendering v) { SET_VAR(m_rareInheritedData, imageRendering, static_cast&lt;unsigned&gt;(v)); }
 958 
 959 #if ENABLE(CSS_IMAGE_RESOLUTION)
 960     void setImageResolutionSource(ImageResolutionSource v) { SET_VAR(m_rareInheritedData, imageResolutionSource, v); }
 961     void setImageResolutionSnap(ImageResolutionSnap v) { SET_VAR(m_rareInheritedData, imageResolutionSnap, v); }
 962     void setImageResolution(float f) { SET_VAR(m_rareInheritedData, imageResolution, f); }
 963 #endif
 964 
 965     void setWhiteSpace(WhiteSpace v) { m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(v); }
 966 
 967     void setWordSpacing(Length&amp;&amp;);
 968     void setLetterSpacing(float);
 969 
 970     void clearBackgroundLayers() { m_backgroundData.access().background = FillLayer(FillLayerType::Background); }
 971     void inheritBackgroundLayers(const FillLayer&amp; parent) { m_backgroundData.access().background = parent; }
 972 
 973     void adjustBackgroundLayers();
 974 
 975     void clearMaskLayers() { m_rareNonInheritedData.access().mask = FillLayer(FillLayerType::Mask); }
 976     void inheritMaskLayers(const FillLayer&amp; parent) { m_rareNonInheritedData.access().mask = parent; }
</pre>
<hr />
<pre>
1014     void setPaddingLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.left(), WTFMove(length)); }
1015     void setPaddingRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.right(), WTFMove(length)); }
1016 
1017     void setCursor(CursorType c) { m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(c); }
1018     void addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp;, const IntPoint&amp; hotSpot = IntPoint());
1019     void setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp;);
1020     void clearCursorList();
1021 
1022 #if ENABLE(CURSOR_VISIBILITY)
1023     void setCursorVisibility(CursorVisibility c) { m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(c); }
1024 #endif
1025 
1026     void setInsideLink(InsideLink insideLink) { m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(insideLink); }
1027     void setIsLink(bool v) { m_nonInheritedFlags.isLink = v; }
1028 
1029     void setInsideDefaultButton(bool insideDefaultButton) { m_inheritedFlags.insideDefaultButton = insideDefaultButton; }
1030 
1031     PrintColorAdjust printColorAdjust() const { return static_cast&lt;PrintColorAdjust&gt;(m_inheritedFlags.printColorAdjust); }
1032     void setPrintColorAdjust(PrintColorAdjust value) { m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(value); }
1033 
<span class="line-modified">1034     bool hasAutoZIndex() const { return m_boxData-&gt;hasAutoZIndex(); }</span>
<span class="line-modified">1035     void setHasAutoZIndex() { SET_VAR(m_boxData, m_hasAutoZIndex, true); SET_VAR(m_boxData, m_zIndex, 0); }</span>
<span class="line-modified">1036     int zIndex() const { return m_boxData-&gt;zIndex(); }</span>
<span class="line-modified">1037     void setZIndex(int v) { SET_VAR(m_boxData, m_hasAutoZIndex, false); SET_VAR(m_boxData, m_zIndex, v); }</span>





















1038 
1039     void setHasAutoWidows() { SET_VAR(m_rareInheritedData, hasAutoWidows, true); SET_VAR(m_rareInheritedData, widows, initialWidows()); }
1040     void setWidows(short w) { SET_VAR(m_rareInheritedData, hasAutoWidows, false); SET_VAR(m_rareInheritedData, widows, w); }
1041 
1042     void setHasAutoOrphans() { SET_VAR(m_rareInheritedData, hasAutoOrphans, true); SET_VAR(m_rareInheritedData, orphans, initialOrphans()); }
1043     void setOrphans(short o) { SET_VAR(m_rareInheritedData, hasAutoOrphans, false); SET_VAR(m_rareInheritedData, orphans, o); }
1044 
1045     // CSS3 Setters
1046     void setOutlineOffset(float v) { SET_VAR(m_backgroundData, outline.m_offset, v); }
1047     void setTextShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1048     void setTextStrokeColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textStrokeColor, c); }
1049     void setTextStrokeWidth(float w) { SET_VAR(m_rareInheritedData, textStrokeWidth, w); }
1050     void setTextFillColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textFillColor, c); }
1051     void setCaretColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, caretColor, c); }
1052     void setOpacity(float f) { float v = clampTo&lt;float&gt;(f, 0.f, 1.f); SET_VAR(m_rareNonInheritedData, opacity, v); }
1053     void setAppearance(ControlPart a) { SET_VAR(m_rareNonInheritedData, appearance, a); }
1054     // For valid values of box-align see http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/#alignment
1055     void setBoxAlign(BoxAlignment a) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, align, static_cast&lt;unsigned&gt;(a)); }
1056     void setBoxDirection(BoxDirection d) { m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(d); }
1057     void setBoxFlex(float f) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flex, f); }
</pre>
<hr />
<pre>
1195     void setLineSnap(LineSnap lineSnap) { SET_VAR(m_rareInheritedData, lineSnap, static_cast&lt;unsigned&gt;(lineSnap)); }
1196     void setLineAlign(LineAlign lineAlign) { SET_VAR(m_rareInheritedData, lineAlign, static_cast&lt;unsigned&gt;(lineAlign)); }
1197 
1198     void setPointerEvents(PointerEvents p) { m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(p); }
1199 
1200     void clearAnimations();
1201     void clearTransitions();
1202 
1203     void adjustAnimations();
1204     void adjustTransitions();
1205 
1206     void setTransformStyle3D(TransformStyle3D b) { SET_VAR(m_rareNonInheritedData, transformStyle3D, static_cast&lt;unsigned&gt;(b)); }
1207     void setBackfaceVisibility(BackfaceVisibility b) { SET_VAR(m_rareNonInheritedData, backfaceVisibility, static_cast&lt;unsigned&gt;(b)); }
1208     void setPerspective(float p) { SET_VAR(m_rareNonInheritedData, perspective, p); }
1209     void setPerspectiveOriginX(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginX, WTFMove(length)); }
1210     void setPerspectiveOriginY(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginY, WTFMove(length)); }
1211     void setPageSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, pageSize, WTFMove(size)); }
1212     void setPageSizeType(PageSizeType t) { SET_VAR(m_rareNonInheritedData, pageSizeType, t); }
1213     void resetPageSizeType() { SET_VAR(m_rareNonInheritedData, pageSizeType, PAGE_SIZE_AUTO); }
1214 
<span class="line-modified">1215     void setLineBoxContain(LineBoxContain c) { SET_VAR(m_rareInheritedData, lineBoxContain, c); }</span>
1216     void setLineClamp(LineClampValue c) { SET_VAR(m_rareNonInheritedData, lineClamp, c); }
1217 
1218     void setInitialLetter(const IntSize&amp; size) { SET_VAR(m_rareNonInheritedData, initialLetter, size); }
1219 
1220 #if ENABLE(POINTER_EVENTS)
1221     void setTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareNonInheritedData, touchActions, touchActions.toRaw()); }
1222     void setEffectiveTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareInheritedData, effectiveTouchActions, touchActions.toRaw()); }
1223 #endif
1224 
1225 #if ENABLE(CSS_SCROLL_SNAP)
1226     void setScrollSnapType(const ScrollSnapType&amp;);
1227     void setScrollPaddingTop(Length&amp;&amp;);
1228     void setScrollPaddingBottom(Length&amp;&amp;);
1229     void setScrollPaddingLeft(Length&amp;&amp;);
1230     void setScrollPaddingRight(Length&amp;&amp;);
1231 
1232     void setScrollSnapAlign(const ScrollSnapAlign&amp;);
1233     void setScrollSnapMarginTop(Length&amp;&amp;);
1234     void setScrollSnapMarginBottom(Length&amp;&amp;);
1235     void setScrollSnapMarginLeft(Length&amp;&amp;);
1236     void setScrollSnapMarginRight(Length&amp;&amp;);
1237 #endif
1238 
1239 #if ENABLE(TOUCH_EVENTS)
1240     void setTapHighlightColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, tapHighlightColor, c); }
1241 #endif
1242 
1243 #if PLATFORM(IOS_FAMILY)
1244     void setTouchCalloutEnabled(bool v) { SET_VAR(m_rareInheritedData, touchCalloutEnabled, v); }
1245 #endif
1246 
1247 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1248     void setUseTouchOverflowScrolling(bool v) { SET_VAR(m_rareInheritedData, useTouchOverflowScrolling, v); }
1249 #endif
1250 


1251 #if ENABLE(TEXT_AUTOSIZING)
1252     void setTextSizeAdjust(TextSizeAdjustment adjustment) { SET_VAR(m_rareInheritedData, textSizeAdjust, adjustment); }
1253     void setAutosizeStatus(AutosizeStatus);
1254 #endif
1255 
1256     void setTextSecurity(TextSecurity security) { SET_VAR(m_rareInheritedData, textSecurity, static_cast&lt;unsigned&gt;(security)); }
1257 
1258 #if ENABLE(CSS_TRAILING_WORD)
1259     void setTrailingWord(TrailingWord) { }
1260 #endif
1261 
1262 #if ENABLE(APPLE_PAY)
1263     void setApplePayButtonStyle(ApplePayButtonStyle style) { SET_VAR(m_rareNonInheritedData, applePayButtonStyle, static_cast&lt;unsigned&gt;(style)); }
1264     void setApplePayButtonType(ApplePayButtonType type) { SET_VAR(m_rareNonInheritedData, applePayButtonType, static_cast&lt;unsigned&gt;(type)); }
1265 #endif
1266 
1267 #if ENABLE(CSS_PAINTING_API)
1268     void addCustomPaintWatchProperty(const String&amp; name);
1269 #endif
1270 
</pre>
<hr />
<pre>
1380     void setContent(std::unique_ptr&lt;CounterContent&gt;, bool add = false);
1381     void setContent(QuoteType, bool add = false);
1382     void setContentAltText(const String&amp;);
1383     const String&amp; contentAltText() const;
1384     bool hasAttrContent() const { return m_rareNonInheritedData-&gt;hasAttrContent; }
1385     void setHasAttrContent();
1386 
1387     const CounterDirectiveMap* counterDirectives() const;
1388     CounterDirectiveMap&amp; accessCounterDirectives();
1389 
1390     QuotesData* quotes() const { return m_rareInheritedData-&gt;quotes.get(); }
1391     void setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp;);
1392 
1393     WillChangeData* willChange() const { return m_rareNonInheritedData-&gt;willChange.get(); }
1394     void setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp;);
1395 
1396     bool willChangeCreatesStackingContext() const;
1397 
1398     const AtomString&amp; hyphenString() const;
1399 
<span class="line-modified">1400     bool inheritedNotEqual(const RenderStyle*) const;</span>
<span class="line-modified">1401     bool inheritedDataShared(const RenderStyle*) const;</span>
1402 
1403 #if ENABLE(TEXT_AUTOSIZING)
1404     uint32_t hashForTextAutosizing() const;
1405     bool equalForTextAutosizing(const RenderStyle&amp;) const;
1406 #endif
1407 
1408     StyleDifference diff(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1409     bool diffRequiresLayerRepaint(const RenderStyle&amp;, bool isComposited) const;
1410 
1411     bool isDisplayInlineType() const { return isDisplayInlineType(display()); }
1412     bool isOriginalDisplayInlineType() const { return isDisplayInlineType(originalDisplay()); }
1413     bool isDisplayFlexibleOrGridBox() const { return isDisplayFlexibleOrGridBox(display()); }
1414     bool isDisplayRegionType() const;
1415 
1416     bool setWritingMode(WritingMode);
1417 
1418     bool hasExplicitlySetWritingMode() const { return m_nonInheritedFlags.hasExplicitlySetWritingMode; }
1419     void setHasExplicitlySetWritingMode(bool v) { m_nonInheritedFlags.hasExplicitlySetWritingMode = v; }
1420 
1421     bool hasExplicitlySetTextAlign() const { return m_nonInheritedFlags.hasExplicitlySetTextAlign; }
</pre>
<hr />
<pre>
1472     static EmptyCell initialEmptyCells() { return EmptyCell::Show; }
1473     static ListStylePosition initialListStylePosition() { return ListStylePosition::Outside; }
1474     static ListStyleType initialListStyleType() { return ListStyleType::Disc; }
1475     static TextTransform initialTextTransform() { return TextTransform::None; }
1476     static Visibility initialVisibility() { return Visibility::Visible; }
1477     static WhiteSpace initialWhiteSpace() { return WhiteSpace::Normal; }
1478     static float initialHorizontalBorderSpacing() { return 0; }
1479     static float initialVerticalBorderSpacing() { return 0; }
1480     static CursorType initialCursor() { return CursorType::Auto; }
1481     static Color initialColor() { return Color::black; }
1482     static StyleImage* initialListStyleImage() { return 0; }
1483     static float initialBorderWidth() { return 3; }
1484     static unsigned short initialColumnRuleWidth() { return 3; }
1485     static float initialOutlineWidth() { return 3; }
1486     static float initialLetterSpacing() { return 0; }
1487     static Length initialWordSpacing() { return Length(Fixed); }
1488     static Length initialSize() { return Length(); }
1489     static Length initialMinSize() { return Length(); }
1490     static Length initialMaxSize() { return Length(Undefined); }
1491     static Length initialOffset() { return Length(); }

1492     static Length initialMargin() { return Length(Fixed); }
1493     static Length initialPadding() { return Length(Fixed); }
1494     static Length initialTextIndent() { return Length(Fixed); }
1495     static Length initialZeroLength() { return Length(Fixed); }
1496     static Length initialOneLength() { return Length(1, Fixed); }
1497     static short initialWidows() { return 2; }
1498     static short initialOrphans() { return 2; }
1499     static Length initialLineHeight() { return Length(-100.0f, Percent); }
1500     static TextAlignMode initialTextAlign() { return TextAlignMode::Start; }
1501     static OptionSet&lt;TextDecoration&gt; initialTextDecoration() { return OptionSet&lt;TextDecoration&gt; { }; }
1502     static TextDecorationStyle initialTextDecorationStyle() { return TextDecorationStyle::Solid; }
1503     static OptionSet&lt;TextDecorationSkip&gt; initialTextDecorationSkip() { return TextDecorationSkip::Auto; }
1504     static TextUnderlinePosition initialTextUnderlinePosition() { return TextUnderlinePosition::Auto; }
1505     static TextUnderlineOffset initialTextUnderlineOffset() { return TextUnderlineOffset::createWithAuto(); }
1506     static TextDecorationThickness initialTextDecorationThickness() { return TextDecorationThickness::createWithAuto(); }
1507     static float initialZoom() { return 1.0f; }
1508     static TextZoom initialTextZoom() { return TextZoom::Normal; }
1509     static float initialOutlineOffset() { return 0; }
1510     static float initialOpacity() { return 1.0f; }
1511     static BoxAlignment initialBoxAlign() { return BoxAlignment::Stretch; }
</pre>
<hr />
<pre>
1564     static GapLength initialColumnGap() { return GapLength(); }
1565     static GapLength initialRowGap() { return GapLength(); }
1566     static const TransformOperations&amp; initialTransform() { static NeverDestroyed&lt;TransformOperations&gt; ops; return ops; }
1567     static Length initialTransformOriginX() { return Length(50.0f, Percent); }
1568     static Length initialTransformOriginY() { return Length(50.0f, Percent); }
1569     static TransformBox initialTransformBox() { return TransformBox::BorderBox; }
1570     static PointerEvents initialPointerEvents() { return PointerEvents::Auto; }
1571     static float initialTransformOriginZ() { return 0; }
1572     static TransformStyle3D initialTransformStyle3D() { return TransformStyle3D::Flat; }
1573     static BackfaceVisibility initialBackfaceVisibility() { return BackfaceVisibility::Visible; }
1574     static float initialPerspective() { return 0; }
1575     static Length initialPerspectiveOriginX() { return Length(50.0f, Percent); }
1576     static Length initialPerspectiveOriginY() { return Length(50.0f, Percent); }
1577     static Color initialBackgroundColor() { return Color::transparent; }
1578     static Color initialTextEmphasisColor() { return Color(); }
1579     static TextEmphasisFill initialTextEmphasisFill() { return TextEmphasisFill::Filled; }
1580     static TextEmphasisMark initialTextEmphasisMark() { return TextEmphasisMark::None; }
1581     static const AtomString&amp; initialTextEmphasisCustomMark() { return nullAtom(); }
1582     static OptionSet&lt;TextEmphasisPosition&gt; initialTextEmphasisPosition() { return { TextEmphasisPosition::Over, TextEmphasisPosition::Right }; }
1583     static RubyPosition initialRubyPosition() { return RubyPosition::Before; }
<span class="line-modified">1584     static LineBoxContain initialLineBoxContain() { return LineBoxContainBlock | LineBoxContainInline | LineBoxContainReplaced; }</span>
<span class="line-modified">1585     static ImageOrientation initialImageOrientation() { return ImageOrientation::None; }</span>
1586     static ImageRendering initialImageRendering() { return ImageRendering::Auto; }
1587     static ImageResolutionSource initialImageResolutionSource() { return ImageResolutionSource::Specified; }
1588     static ImageResolutionSnap initialImageResolutionSnap() { return ImageResolutionSnap::None; }
1589     static float initialImageResolution() { return 1; }
1590     static StyleImage* initialBorderImageSource() { return nullptr; }
1591     static StyleImage* initialMaskBoxImageSource() { return nullptr; }
1592     static PrintColorAdjust initialPrintColorAdjust() { return PrintColorAdjust::Economy; }
1593     static QuotesData* initialQuotes() { return nullptr; }
1594     static const AtomString&amp; initialContentAltText() { return emptyAtom(); }
1595 
1596 #if ENABLE(DARK_MODE_CSS)
1597     static StyleColorScheme initialColorScheme() { return { }; }
1598 #endif
1599 
1600 #if ENABLE(CSS3_TEXT)
1601     static TextIndentLine initialTextIndentLine() { return TextIndentLine::FirstLine; }
1602     static TextIndentType initialTextIndentType() { return TextIndentType::Normal; }
1603     static TextAlignLast initialTextAlignLast() { return TextAlignLast::Auto; }
1604     static TextJustify initialTextJustify() { return TextJustify::Auto; }
1605 #endif
</pre>
<hr />
<pre>
1668     static const AtomString&amp; initialLineGrid() { return nullAtom(); }
1669     static LineSnap initialLineSnap() { return LineSnap::None; }
1670     static LineAlign initialLineAlign() { return LineAlign::None; }
1671 
1672     static IntSize initialInitialLetter() { return IntSize(); }
1673     static LineClampValue initialLineClamp() { return LineClampValue(); }
1674     static TextSecurity initialTextSecurity() { return TextSecurity::None; }
1675 
1676 #if PLATFORM(IOS_FAMILY)
1677     static bool initialTouchCalloutEnabled() { return true; }
1678 #endif
1679 
1680 #if ENABLE(TOUCH_EVENTS)
1681     static Color initialTapHighlightColor();
1682 #endif
1683 
1684 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1685     static bool initialUseTouchOverflowScrolling() { return false; }
1686 #endif
1687 


1688     static const FilterOperations&amp; initialFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1689     static const FilterOperations&amp; initialAppleColorFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1690 
1691 #if ENABLE(FILTERS_LEVEL_2)
1692     static const FilterOperations&amp; initialBackdropFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1693 #endif
1694 
1695 #if ENABLE(CSS_COMPOSITING)
1696     static BlendMode initialBlendMode() { return BlendMode::Normal; }
1697     static Isolation initialIsolation() { return Isolation::Auto; }
1698 #endif
1699 
1700     // Indicates the style is likely to change due to a pending stylesheet load.
1701     bool isNotFinal() const { return m_rareNonInheritedData-&gt;isNotFinal; }
1702     void setIsNotFinal() { SET_VAR(m_rareNonInheritedData, isNotFinal, true); }
1703 
1704     void setVisitedLinkColor(const Color&amp;);
1705     void setVisitedLinkBackgroundColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBackgroundColor, v); }
1706     void setVisitedLinkBorderLeftColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderLeftColor, v); }
1707     void setVisitedLinkBorderRightColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderRightColor, v); }
</pre>
<hr />
<pre>
1711     void setVisitedLinkColumnRuleColor(const Color&amp; v) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, visitedLinkColumnRuleColor, v); }
1712     void setVisitedLinkTextDecorationColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkTextDecorationColor, v); }
1713     void setVisitedLinkTextEmphasisColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextEmphasisColor, v); }
1714     void setVisitedLinkTextFillColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextFillColor, v); }
1715     void setVisitedLinkTextStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextStrokeColor, v); }
1716     void setVisitedLinkCaretColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkCaretColor, v); }
1717 
1718     void inheritUnicodeBidiFrom(const RenderStyle* parent) { m_nonInheritedFlags.unicodeBidi = parent-&gt;m_nonInheritedFlags.unicodeBidi; }
1719     void getShadowExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const;
1720     void getShadowHorizontalExtent(const ShadowData*, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
1721     void getShadowVerticalExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; bottom) const;
1722     void getShadowInlineDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const;
1723     void getShadowBlockDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const;
1724 
1725     static Color invalidColor() { return Color(); }
1726     const Color&amp; borderLeftColor() const { return m_surroundData-&gt;border.left().color(); }
1727     const Color&amp; borderRightColor() const { return m_surroundData-&gt;border.right().color(); }
1728     const Color&amp; borderTopColor() const { return m_surroundData-&gt;border.top().color(); }
1729     const Color&amp; borderBottomColor() const { return m_surroundData-&gt;border.bottom().color(); }
1730     const Color&amp; backgroundColor() const { return m_backgroundData-&gt;color; }
<span class="line-modified">1731     const Color&amp; color() const;</span>
1732     const Color&amp; columnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.color(); }
1733     const Color&amp; outlineColor() const { return m_backgroundData-&gt;outline.color(); }
1734     const Color&amp; textEmphasisColor() const { return m_rareInheritedData-&gt;textEmphasisColor; }
1735     const Color&amp; textFillColor() const { return m_rareInheritedData-&gt;textFillColor; }
1736     const Color&amp; textStrokeColor() const { return m_rareInheritedData-&gt;textStrokeColor; }
1737     const Color&amp; caretColor() const { return m_rareInheritedData-&gt;caretColor; }
1738     const Color&amp; visitedLinkColor() const;
1739     const Color&amp; visitedLinkBackgroundColor() const { return m_rareNonInheritedData-&gt;visitedLinkBackgroundColor; }
1740     const Color&amp; visitedLinkBorderLeftColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderLeftColor; }
1741     const Color&amp; visitedLinkBorderRightColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderRightColor; }
1742     const Color&amp; visitedLinkBorderBottomColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderBottomColor; }
1743     const Color&amp; visitedLinkBorderTopColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderTopColor; }
1744     const Color&amp; visitedLinkOutlineColor() const { return m_rareNonInheritedData-&gt;visitedLinkOutlineColor; }
1745     const Color&amp; visitedLinkColumnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;visitedLinkColumnRuleColor; }
1746     const Color&amp; textDecorationColor() const { return m_rareNonInheritedData-&gt;textDecorationColor; }
1747     const Color&amp; visitedLinkTextDecorationColor() const { return m_rareNonInheritedData-&gt;visitedLinkTextDecorationColor; }
1748     const Color&amp; visitedLinkTextEmphasisColor() const { return m_rareInheritedData-&gt;visitedLinkTextEmphasisColor; }
1749     const Color&amp; visitedLinkTextFillColor() const { return m_rareInheritedData-&gt;visitedLinkTextFillColor; }
1750     const Color&amp; visitedLinkTextStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkTextStrokeColor; }
1751     const Color&amp; visitedLinkCaretColor() const { return m_rareInheritedData-&gt;visitedLinkCaretColor; }
</pre>
<hr />
<pre>
1869     bool changeRequiresRecompositeLayer(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1870 
1871     // non-inherited attributes
1872     DataRef&lt;StyleBoxData&gt; m_boxData;
1873     DataRef&lt;StyleVisualData&gt; m_visualData;
1874     DataRef&lt;StyleBackgroundData&gt; m_backgroundData;
1875     DataRef&lt;StyleSurroundData&gt; m_surroundData;
1876     DataRef&lt;StyleRareNonInheritedData&gt; m_rareNonInheritedData;
1877     NonInheritedFlags m_nonInheritedFlags;
1878 
1879     // inherited attributes
1880     DataRef&lt;StyleRareInheritedData&gt; m_rareInheritedData;
1881     DataRef&lt;StyleInheritedData&gt; m_inheritedData;
1882     InheritedFlags m_inheritedFlags;
1883 
1884     // list of associated pseudo styles
1885     std::unique_ptr&lt;PseudoStyleCache&gt; m_cachedPseudoStyles;
1886 
1887     DataRef&lt;SVGRenderStyle&gt; m_svgStyle;
1888 
<span class="line-modified">1889 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
1890     bool m_deletionHasBegun { false };
1891 #endif
1892 };
1893 
1894 int adjustForAbsoluteZoom(int, const RenderStyle&amp;);
1895 float adjustFloatForAbsoluteZoom(float, const RenderStyle&amp;);
1896 LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit, const RenderStyle&amp;);
1897 
1898 BorderStyle collapsedBorderStyle(BorderStyle);
1899 
1900 bool pseudoElementRendererIsNeeded(const RenderStyle*);
1901 
1902 inline bool RenderStyle::NonInheritedFlags::operator==(const NonInheritedFlags&amp; other) const
1903 {
1904     return effectiveDisplay == other.effectiveDisplay
1905         &amp;&amp; originalDisplay == other.originalDisplay
1906         &amp;&amp; overflowX == other.overflowX
1907         &amp;&amp; overflowY == other.overflowY
1908         &amp;&amp; verticalAlign == other.verticalAlign
1909         &amp;&amp; clear == other.clear
</pre>
<hr />
<pre>
2076 }
2077 
2078 inline bool RenderStyle::breakOnlyAfterWhiteSpace() const
2079 {
2080     return whiteSpace() == WhiteSpace::PreWrap || whiteSpace() == WhiteSpace::BreakSpaces || lineBreak() == LineBreak::AfterWhiteSpace;
2081 }
2082 
2083 inline bool RenderStyle::breakWords() const
2084 {
2085     return wordBreak() == WordBreak::BreakWord || overflowWrap() == OverflowWrap::Break;
2086 }
2087 
2088 inline bool RenderStyle::hasInlineColumnAxis() const
2089 {
2090     auto axis = columnAxis();
2091     return axis == ColumnAxis::Auto || isHorizontalWritingMode() == (axis == ColumnAxis::Horizontal);
2092 }
2093 
2094 inline ImageOrientation RenderStyle::imageOrientation() const
2095 {
<span class="line-modified">2096 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">2097     return ImageOrientation(m_rareInheritedData-&gt;imageOrientation);</span>
<span class="line-removed">2098 #else</span>
<span class="line-removed">2099     return ImageOrientation::None;</span>
<span class="line-removed">2100 #endif</span>
2101 }
2102 
2103 inline void RenderStyle::setLogicalWidth(Length&amp;&amp; logicalWidth)
2104 {
2105     if (isHorizontalWritingMode())
2106         setWidth(WTFMove(logicalWidth));
2107     else
2108         setHeight(WTFMove(logicalWidth));
2109 }
2110 
2111 inline void RenderStyle::setLogicalHeight(Length&amp;&amp; logicalHeight)
2112 {
2113     if (isHorizontalWritingMode())
2114         setHeight(WTFMove(logicalHeight));
2115     else
2116         setWidth(WTFMove(logicalHeight));
2117 }
2118 
2119 inline void RenderStyle::setBorderRadius(LengthSize&amp;&amp; size)
2120 {
</pre>
</td>
<td>
<hr />
<pre>
  96     } while (0)
  97 
  98 #define SET_BORDERVALUE_COLOR(group, variable, value) do { \
  99         if (!compareEqual(group-&gt;variable.color(), value)) \
 100             group.access().variable.setColor(value); \
 101     } while (0)
 102 
 103 namespace WebCore {
 104 
 105 class BorderData;
 106 class ContentData;
 107 class CounterContent;
 108 class CursorList;
 109 class FontCascade;
 110 class FontMetrics;
 111 class IntRect;
 112 class Pair;
 113 class ShadowData;
 114 class StyleImage;
 115 class StyleInheritedData;

 116 class StyleScrollSnapArea;
 117 class StyleScrollSnapPort;
 118 class TransformationMatrix;
 119 
 120 struct ScrollSnapAlign;
 121 struct ScrollSnapType;
 122 
 123 using PseudoStyleCache = Vector&lt;std::unique_ptr&lt;RenderStyle&gt;, 4&gt;;
 124 
 125 template&lt;typename T, typename U&gt; inline bool compareEqual(const T&amp; t, const U&amp; u) { return t == static_cast&lt;const T&amp;&gt;(u); }
 126 
<span class="line-added"> 127 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderStyle);</span>
 128 class RenderStyle {
<span class="line-modified"> 129     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(RenderStyle);</span>

 130 private:
 131     enum CloneTag { Clone };
 132     enum CreateDefaultStyleTag { CreateDefaultStyle };
 133 
 134 public:
 135     RenderStyle(RenderStyle&amp;&amp;);
 136     RenderStyle&amp; operator=(RenderStyle&amp;&amp;);
<span class="line-modified"> 137     WEBCORE_EXPORT ~RenderStyle();</span>
 138 
 139     RenderStyle replace(RenderStyle&amp;&amp;) WARN_UNUSED_RETURN;
 140 
 141     explicit RenderStyle(CreateDefaultStyleTag);
 142     RenderStyle(const RenderStyle&amp;, CloneTag);
 143 
 144     static RenderStyle&amp; defaultStyle();
 145 
 146     static RenderStyle create();
 147     static std::unique_ptr&lt;RenderStyle&gt; createPtr();
 148 
 149     static RenderStyle clone(const RenderStyle&amp;);
 150     static std::unique_ptr&lt;RenderStyle&gt; clonePtr(const RenderStyle&amp;);
 151 
 152     static RenderStyle createAnonymousStyleWithDisplay(const RenderStyle&amp; parentStyle, DisplayType);
 153     static RenderStyle createStyleInheritingFromPseudoStyle(const RenderStyle&amp; pseudoStyle);
 154 
<span class="line-modified"> 155 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
 156     bool deletionHasBegun() const { return m_deletionHasBegun; }
 157 #endif
 158 
 159     bool operator==(const RenderStyle&amp;) const;
 160     bool operator!=(const RenderStyle&amp; other) const { return !(*this == other); }
 161 
 162     void inheritFrom(const RenderStyle&amp; inheritParent);
 163     void copyNonInheritedFrom(const RenderStyle&amp;);
 164     void copyContentFrom(const RenderStyle&amp;);
 165 
 166     ContentPosition resolvedJustifyContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 167     ContentDistribution resolvedJustifyContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 168     ContentPosition resolvedAlignContentPosition(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 169     ContentDistribution resolvedAlignContentDistribution(const StyleContentAlignmentData&amp; normalValueBehavior) const;
 170     StyleSelfAlignmentData resolvedAlignItems(ItemPosition normalValueBehaviour) const;
 171     StyleSelfAlignmentData resolvedAlignSelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 172     StyleContentAlignmentData resolvedAlignContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
 173     StyleSelfAlignmentData resolvedJustifyItems(ItemPosition normalValueBehaviour) const;
 174     StyleSelfAlignmentData resolvedJustifySelf(const RenderStyle* parentStyle, ItemPosition normalValueBehaviour) const;
 175     StyleContentAlignmentData resolvedJustifyContent(const StyleContentAlignmentData&amp; normalValueBehaviour) const;
</pre>
<hr />
<pre>
 211     bool hasPadding() const { return !m_surroundData-&gt;padding.isZero(); }
 212     bool hasOffset() const { return !m_surroundData-&gt;offset.isZero(); }
 213     bool hasMarginBeforeQuirk() const { return marginBefore().hasQuirk(); }
 214     bool hasMarginAfterQuirk() const { return marginAfter().hasQuirk(); }
 215 
 216     bool hasBackgroundImage() const { return m_backgroundData-&gt;background.hasImage(); }
 217     bool hasFixedBackgroundImage() const { return m_backgroundData-&gt;background.hasFixedImage(); }
 218 
 219     bool hasEntirelyFixedBackground() const;
 220 
 221     bool hasAppearance() const { return appearance() != NoControlPart; }
 222 
 223     bool hasBackground() const;
 224 
 225     LayoutBoxExtent imageOutsets(const NinePieceImage&amp;) const;
 226     bool hasBorderImageOutsets() const { return borderImage().hasImage() &amp;&amp; !borderImage().outset().isZero(); }
 227     LayoutBoxExtent borderImageOutsets() const { return imageOutsets(borderImage()); }
 228 
 229     LayoutBoxExtent maskBoxImageOutsets() const { return imageOutsets(maskBoxImage()); }
 230 
<span class="line-modified"> 231     IntOutsets filterOutsets() const { return hasFilter() ? filter().outsets() : IntOutsets(); }</span>

 232 
 233     Order rtlOrdering() const { return static_cast&lt;Order&gt;(m_inheritedFlags.rtlOrdering); }
 234     void setRTLOrdering(Order ordering) { m_inheritedFlags.rtlOrdering = static_cast&lt;unsigned&gt;(ordering); }
 235 
 236     bool isStyleAvailable() const;
 237 
 238     bool hasAnyPublicPseudoStyles() const;
 239     bool hasPseudoStyle(PseudoId) const;
 240     void setHasPseudoStyle(PseudoId);
 241     void setHasPseudoStyles(PseudoIdSet);
 242     bool hasUniquePseudoStyle() const;
 243 
 244     // attribute getter methods
 245 
 246     DisplayType display() const { return static_cast&lt;DisplayType&gt;(m_nonInheritedFlags.effectiveDisplay); }
 247 
 248     const Length&amp; left() const { return m_surroundData-&gt;offset.left(); }
 249     const Length&amp; right() const { return m_surroundData-&gt;offset.right(); }
 250     const Length&amp; top() const { return m_surroundData-&gt;offset.top(); }
 251     const Length&amp; bottom() const { return m_surroundData-&gt;offset.bottom(); }
</pre>
<hr />
<pre>
 280     const Length&amp; logicalMinHeight() const { return isHorizontalWritingMode() ? minHeight() : minWidth(); }
 281     const Length&amp; logicalMaxHeight() const { return isHorizontalWritingMode() ? maxHeight() : maxWidth(); }
 282 
 283     const BorderData&amp; border() const { return m_surroundData-&gt;border; }
 284     const BorderValue&amp; borderLeft() const { return m_surroundData-&gt;border.left(); }
 285     const BorderValue&amp; borderRight() const { return m_surroundData-&gt;border.right(); }
 286     const BorderValue&amp; borderTop() const { return m_surroundData-&gt;border.top(); }
 287     const BorderValue&amp; borderBottom() const { return m_surroundData-&gt;border.bottom(); }
 288 
 289     const BorderValue&amp; borderBefore() const;
 290     const BorderValue&amp; borderAfter() const;
 291     const BorderValue&amp; borderStart() const;
 292     const BorderValue&amp; borderEnd() const;
 293 
 294     const NinePieceImage&amp; borderImage() const { return m_surroundData-&gt;border.image(); }
 295     StyleImage* borderImageSource() const { return m_surroundData-&gt;border.image().image(); }
 296     const LengthBox&amp; borderImageSlices() const { return m_surroundData-&gt;border.image().imageSlices(); }
 297     const LengthBox&amp; borderImageWidth() const { return m_surroundData-&gt;border.image().borderSlices(); }
 298     const LengthBox&amp; borderImageOutset() const { return m_surroundData-&gt;border.image().outset(); }
 299 
<span class="line-modified"> 300     const LengthSize&amp; borderTopLeftRadius() const { return m_surroundData-&gt;border.topLeftRadius(); }</span>
<span class="line-modified"> 301     const LengthSize&amp; borderTopRightRadius() const { return m_surroundData-&gt;border.topRightRadius(); }</span>
<span class="line-modified"> 302     const LengthSize&amp; borderBottomLeftRadius() const { return m_surroundData-&gt;border.bottomLeftRadius(); }</span>
<span class="line-modified"> 303     const LengthSize&amp; borderBottomRightRadius() const { return m_surroundData-&gt;border.bottomRightRadius(); }</span>
 304     bool hasBorderRadius() const { return m_surroundData-&gt;border.hasBorderRadius(); }
 305 
 306     float borderLeftWidth() const { return m_surroundData-&gt;border.borderLeftWidth(); }
 307     BorderStyle borderLeftStyle() const { return m_surroundData-&gt;border.left().style(); }
 308     bool borderLeftIsTransparent() const { return m_surroundData-&gt;border.left().isTransparent(); }
 309     float borderRightWidth() const { return m_surroundData-&gt;border.borderRightWidth(); }
 310     BorderStyle borderRightStyle() const { return m_surroundData-&gt;border.right().style(); }
 311     bool borderRightIsTransparent() const { return m_surroundData-&gt;border.right().isTransparent(); }
 312     float borderTopWidth() const { return m_surroundData-&gt;border.borderTopWidth(); }
 313     BorderStyle borderTopStyle() const { return m_surroundData-&gt;border.top().style(); }
 314     bool borderTopIsTransparent() const { return m_surroundData-&gt;border.top().isTransparent(); }
 315     float borderBottomWidth() const { return m_surroundData-&gt;border.borderBottomWidth(); }
 316     BorderStyle borderBottomStyle() const { return m_surroundData-&gt;border.bottom().style(); }
 317     bool borderBottomIsTransparent() const { return m_surroundData-&gt;border.bottom().isTransparent(); }
 318     FloatBoxExtent borderWidth() const { return m_surroundData-&gt;border.borderWidth(); }
 319 
 320     float borderBeforeWidth() const;
 321     float borderAfterWidth() const;
 322     float borderStartWidth() const;
 323     float borderEndWidth() const;
</pre>
<hr />
<pre>
 675     AnimationList&amp; ensureAnimations();
 676     AnimationList&amp; ensureTransitions();
 677 
 678     bool hasAnimations() const { return m_rareNonInheritedData-&gt;animations &amp;&amp; m_rareNonInheritedData-&gt;animations-&gt;size() &gt; 0; }
 679     bool hasTransitions() const { return m_rareNonInheritedData-&gt;transitions &amp;&amp; m_rareNonInheritedData-&gt;transitions-&gt;size() &gt; 0; }
 680 
 681     // Return the first found Animation (including &#39;all&#39; transitions).
 682     const Animation* transitionForProperty(CSSPropertyID) const;
 683 
 684     TransformStyle3D transformStyle3D() const { return static_cast&lt;TransformStyle3D&gt;(m_rareNonInheritedData-&gt;transformStyle3D); }
 685     bool preserves3D() const { return transformStyle3D() == TransformStyle3D::Preserve3D; }
 686 
 687     BackfaceVisibility backfaceVisibility() const { return static_cast&lt;BackfaceVisibility&gt;(m_rareNonInheritedData-&gt;backfaceVisibility); }
 688     float perspective() const { return m_rareNonInheritedData-&gt;perspective; }
 689     bool hasPerspective() const { return m_rareNonInheritedData-&gt;perspective &gt; 0; }
 690     const Length&amp; perspectiveOriginX() const { return m_rareNonInheritedData-&gt;perspectiveOriginX; }
 691     const Length&amp; perspectiveOriginY() const { return m_rareNonInheritedData-&gt;perspectiveOriginY; }
 692     const LengthSize&amp; pageSize() const { return m_rareNonInheritedData-&gt;pageSize; }
 693     PageSizeType pageSizeType() const { return static_cast&lt;PageSizeType&gt;(m_rareNonInheritedData-&gt;pageSizeType); }
 694 
<span class="line-modified"> 695     OptionSet&lt;LineBoxContain&gt; lineBoxContain() const { return OptionSet&lt;LineBoxContain&gt;::fromRaw(m_rareInheritedData-&gt;lineBoxContain); }</span>
 696     const LineClampValue&amp; lineClamp() const { return m_rareNonInheritedData-&gt;lineClamp; }
 697     const IntSize&amp; initialLetter() const { return m_rareNonInheritedData-&gt;initialLetter; }
 698     int initialLetterDrop() const { return initialLetter().width(); }
 699     int initialLetterHeight() const { return initialLetter().height(); }
 700 
 701 #if ENABLE(POINTER_EVENTS)
 702     OptionSet&lt;TouchAction&gt; touchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareNonInheritedData-&gt;touchActions); }
 703     // &#39;touch-action&#39; behavior depends on values in ancestors. We use an additional inherited property to implement that.
 704     OptionSet&lt;TouchAction&gt; effectiveTouchActions() const { return OptionSet&lt;TouchAction&gt;::fromRaw(m_rareInheritedData-&gt;effectiveTouchActions); }
 705 #endif
 706 
 707 #if ENABLE(CSS_SCROLL_SNAP)
 708     // Scroll snap port style.
 709     const StyleScrollSnapPort&amp; scrollSnapPort() const;
 710     const ScrollSnapType&amp; scrollSnapType() const;
 711     const LengthBox&amp; scrollPadding() const;
 712     const Length&amp; scrollPaddingTop() const;
 713     const Length&amp; scrollPaddingBottom() const;
 714     const Length&amp; scrollPaddingLeft() const;
 715     const Length&amp; scrollPaddingRight() const;
</pre>
<hr />
<pre>
 719     const ScrollSnapAlign&amp; scrollSnapAlign() const;
 720     const LengthBox&amp; scrollSnapMargin() const;
 721     const Length&amp; scrollSnapMarginTop() const;
 722     const Length&amp; scrollSnapMarginBottom() const;
 723     const Length&amp; scrollSnapMarginLeft() const;
 724     const Length&amp; scrollSnapMarginRight() const;
 725 #endif
 726 
 727 #if ENABLE(TOUCH_EVENTS)
 728     Color tapHighlightColor() const { return m_rareInheritedData-&gt;tapHighlightColor; }
 729 #endif
 730 
 731 #if PLATFORM(IOS_FAMILY)
 732     bool touchCalloutEnabled() const { return m_rareInheritedData-&gt;touchCalloutEnabled; }
 733 #endif
 734 
 735 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 736     bool useTouchOverflowScrolling() const { return m_rareInheritedData-&gt;useTouchOverflowScrolling; }
 737 #endif
 738 
<span class="line-added"> 739     bool useSmoothScrolling() const { return m_rareNonInheritedData-&gt;useSmoothScrolling; }</span>
<span class="line-added"> 740 </span>
 741 #if ENABLE(TEXT_AUTOSIZING)
 742     TextSizeAdjustment textSizeAdjust() const { return m_rareInheritedData-&gt;textSizeAdjust; }
 743     AutosizeStatus autosizeStatus() const;
 744     bool isIdempotentTextAutosizingCandidate() const;
 745 #endif
 746 
 747     TextSecurity textSecurity() const { return static_cast&lt;TextSecurity&gt;(m_rareInheritedData-&gt;textSecurity); }
 748 
 749     WritingMode writingMode() const { return static_cast&lt;WritingMode&gt;(m_inheritedFlags.writingMode); }
 750     bool isHorizontalWritingMode() const { return WebCore::isHorizontalWritingMode(writingMode()); }
 751     bool isVerticalWritingMode() const { return WebCore::isVerticalWritingMode(writingMode()); }
 752     bool isFlippedLinesWritingMode() const { return WebCore::isFlippedLinesWritingMode(writingMode()); }
 753     bool isFlippedBlocksWritingMode() const { return WebCore::isFlippedWritingMode(writingMode()); }
 754 
 755     ImageOrientation imageOrientation() const;
 756 
 757     ImageRendering imageRendering() const { return static_cast&lt;ImageRendering&gt;(m_rareInheritedData-&gt;imageRendering); }
 758 
 759 #if ENABLE(CSS_IMAGE_RESOLUTION)
 760     ImageResolutionSource imageResolutionSource() const { return static_cast&lt;ImageResolutionSource&gt;(m_rareInheritedData-&gt;imageResolutionSource); }
</pre>
<hr />
<pre>
 821     void setBottom(Length&amp;&amp; length) { SET_VAR(m_surroundData, offset.bottom(), WTFMove(length)); }
 822 
 823     void setWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_width, WTFMove(length)); }
 824     void setHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_height, WTFMove(length)); }
 825 
 826     void setLogicalWidth(Length&amp;&amp;);
 827     void setLogicalHeight(Length&amp;&amp;);
 828 
 829     void setMinWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minWidth, WTFMove(length)); }
 830     void setMaxWidth(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxWidth, WTFMove(length)); }
 831     void setMinHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_minHeight, WTFMove(length)); }
 832     void setMaxHeight(Length&amp;&amp; length) { SET_VAR(m_boxData, m_maxHeight, WTFMove(length)); }
 833 
 834     void resetBorder() { resetBorderImage(); resetBorderTop(); resetBorderRight(); resetBorderBottom(); resetBorderLeft(); resetBorderRadius(); }
 835     void resetBorderTop() { SET_VAR(m_surroundData, border.m_top, BorderValue()); }
 836     void resetBorderRight() { SET_VAR(m_surroundData, border.m_right, BorderValue()); }
 837     void resetBorderBottom() { SET_VAR(m_surroundData, border.m_bottom, BorderValue()); }
 838     void resetBorderLeft() { SET_VAR(m_surroundData, border.m_left, BorderValue()); }
 839     void resetBorderImage() { SET_VAR(m_surroundData, border.m_image, NinePieceImage()); }
 840     void resetBorderRadius() { resetBorderTopLeftRadius(); resetBorderTopRightRadius(); resetBorderBottomLeftRadius(); resetBorderBottomRightRadius(); }
<span class="line-modified"> 841     void resetBorderTopLeftRadius() { SET_VAR(m_surroundData, border.m_topLeftRadius, initialBorderRadius()); }</span>
<span class="line-modified"> 842     void resetBorderTopRightRadius() { SET_VAR(m_surroundData, border.m_topRightRadius, initialBorderRadius()); }</span>
<span class="line-modified"> 843     void resetBorderBottomLeftRadius() { SET_VAR(m_surroundData, border.m_bottomLeftRadius, initialBorderRadius()); }</span>
<span class="line-modified"> 844     void resetBorderBottomRightRadius() { SET_VAR(m_surroundData, border.m_bottomRightRadius, initialBorderRadius()); }</span>
 845 
 846     void setBackgroundColor(const Color&amp; v) { SET_VAR(m_backgroundData, color, v); }
 847 
 848     void setBackgroundXPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_xPosition, WTFMove(length)); }
 849     void setBackgroundYPosition(Length&amp;&amp; length) { SET_VAR(m_backgroundData, background.m_yPosition, WTFMove(length)); }
 850     void setBackgroundSize(FillSizeType b) { SET_VAR(m_backgroundData, background.m_sizeType, static_cast&lt;unsigned&gt;(b)); }
 851     void setBackgroundSizeLength(LengthSize&amp;&amp; size) { SET_VAR(m_backgroundData, background.m_sizeLength, WTFMove(size)); }
 852 
 853     void setBorderImage(const NinePieceImage&amp; b) { SET_VAR(m_surroundData, border.m_image, b); }
 854     void setBorderImageSource(RefPtr&lt;StyleImage&gt;&amp;&amp;);
 855     void setBorderImageSlices(LengthBox&amp;&amp;);
 856     void setBorderImageWidth(LengthBox&amp;&amp;);
 857     void setBorderImageOutset(LengthBox&amp;&amp;);
 858 
<span class="line-modified"> 859     void setBorderTopLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topLeftRadius, WTFMove(size)); }</span>
<span class="line-modified"> 860     void setBorderTopRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_topRightRadius, WTFMove(size)); }</span>
<span class="line-modified"> 861     void setBorderBottomLeftRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomLeftRadius, WTFMove(size)); }</span>
<span class="line-modified"> 862     void setBorderBottomRightRadius(LengthSize&amp;&amp; size) { SET_VAR(m_surroundData, border.m_bottomRightRadius, WTFMove(size)); }</span>
 863 
 864     void setBorderRadius(LengthSize&amp;&amp;);
 865     void setBorderRadius(const IntSize&amp;);
 866 
 867     RoundedRect getRoundedBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 868     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 869 
 870     RoundedRect getRoundedInnerBorderFor(const LayoutRect&amp; borderRect, LayoutUnit topWidth, LayoutUnit bottomWidth,
 871         LayoutUnit leftWidth, LayoutUnit rightWidth, bool includeLogicalLeftEdge = true, bool includeLogicalRightEdge = true) const;
 872 
 873     void setBorderLeftWidth(float v) { SET_VAR(m_surroundData, border.m_left.m_width, v); }
 874     void setBorderLeftStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_left.m_style, static_cast&lt;unsigned&gt;(v)); }
 875     void setBorderLeftColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_left, v); }
 876     void setBorderRightWidth(float v) { SET_VAR(m_surroundData, border.m_right.m_width, v); }
 877     void setBorderRightStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_right.m_style, static_cast&lt;unsigned&gt;(v)); }
 878     void setBorderRightColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_right, v); }
 879     void setBorderTopWidth(float v) { SET_VAR(m_surroundData, border.m_top.m_width, v); }
 880     void setBorderTopStyle(BorderStyle v) { SET_VAR(m_surroundData, border.m_top.m_style, static_cast&lt;unsigned&gt;(v)); }
 881     void setBorderTopColor(const Color&amp; v) { SET_BORDERVALUE_COLOR(m_surroundData, border.m_top, v); }
 882     void setBorderBottomWidth(float v) { SET_VAR(m_surroundData, border.m_bottom.m_width, v); }
</pre>
<hr />
<pre>
 933     void setTextDecorationThickness(TextDecorationThickness textDecorationThickness) { SET_VAR(m_rareInheritedData, textDecorationThickness, textDecorationThickness); }
 934     void setDirection(TextDirection v) { m_inheritedFlags.direction = static_cast&lt;unsigned&gt;(v); }
 935     void setHasExplicitlySetDirection(bool v) { m_nonInheritedFlags.hasExplicitlySetDirection = v; }
 936     void setLineHeight(Length&amp;&amp;);
 937     bool setZoom(float);
 938     void setZoomWithoutReturnValue(float f) { setZoom(f); }
 939     bool setEffectiveZoom(float);
 940     void setTextZoom(TextZoom v) { SET_VAR(m_rareInheritedData, textZoom, static_cast&lt;unsigned&gt;(v)); }
 941 
 942 #if ENABLE(CSS3_TEXT)
 943     void setTextIndentLine(TextIndentLine v) { SET_VAR(m_rareInheritedData, textIndentLine, v); }
 944     void setTextIndentType(TextIndentType v) { SET_VAR(m_rareInheritedData, textIndentType, v); }
 945     void setTextAlignLast(TextAlignLast v) { SET_VAR(m_rareInheritedData, textAlignLast, v); }
 946     void setTextJustify(TextJustify v) { SET_VAR(m_rareInheritedData, textJustify, v); }
 947 #endif
 948 
 949 #if ENABLE(TEXT_AUTOSIZING)
 950     void setSpecifiedLineHeight(Length&amp;&amp;);
 951 #endif
 952 

 953     void setImageOrientation(ImageOrientation v) { SET_VAR(m_rareInheritedData, imageOrientation, static_cast&lt;int&gt;(v)); }


 954     void setImageRendering(ImageRendering v) { SET_VAR(m_rareInheritedData, imageRendering, static_cast&lt;unsigned&gt;(v)); }
 955 
 956 #if ENABLE(CSS_IMAGE_RESOLUTION)
 957     void setImageResolutionSource(ImageResolutionSource v) { SET_VAR(m_rareInheritedData, imageResolutionSource, v); }
 958     void setImageResolutionSnap(ImageResolutionSnap v) { SET_VAR(m_rareInheritedData, imageResolutionSnap, v); }
 959     void setImageResolution(float f) { SET_VAR(m_rareInheritedData, imageResolution, f); }
 960 #endif
 961 
 962     void setWhiteSpace(WhiteSpace v) { m_inheritedFlags.whiteSpace = static_cast&lt;unsigned&gt;(v); }
 963 
 964     void setWordSpacing(Length&amp;&amp;);
 965     void setLetterSpacing(float);
 966 
 967     void clearBackgroundLayers() { m_backgroundData.access().background = FillLayer(FillLayerType::Background); }
 968     void inheritBackgroundLayers(const FillLayer&amp; parent) { m_backgroundData.access().background = parent; }
 969 
 970     void adjustBackgroundLayers();
 971 
 972     void clearMaskLayers() { m_rareNonInheritedData.access().mask = FillLayer(FillLayerType::Mask); }
 973     void inheritMaskLayers(const FillLayer&amp; parent) { m_rareNonInheritedData.access().mask = parent; }
</pre>
<hr />
<pre>
1011     void setPaddingLeft(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.left(), WTFMove(length)); }
1012     void setPaddingRight(Length&amp;&amp; length) { SET_VAR(m_surroundData, padding.right(), WTFMove(length)); }
1013 
1014     void setCursor(CursorType c) { m_inheritedFlags.cursor = static_cast&lt;unsigned&gt;(c); }
1015     void addCursor(RefPtr&lt;StyleImage&gt;&amp;&amp;, const IntPoint&amp; hotSpot = IntPoint());
1016     void setCursorList(RefPtr&lt;CursorList&gt;&amp;&amp;);
1017     void clearCursorList();
1018 
1019 #if ENABLE(CURSOR_VISIBILITY)
1020     void setCursorVisibility(CursorVisibility c) { m_inheritedFlags.cursorVisibility = static_cast&lt;unsigned&gt;(c); }
1021 #endif
1022 
1023     void setInsideLink(InsideLink insideLink) { m_inheritedFlags.insideLink = static_cast&lt;unsigned&gt;(insideLink); }
1024     void setIsLink(bool v) { m_nonInheritedFlags.isLink = v; }
1025 
1026     void setInsideDefaultButton(bool insideDefaultButton) { m_inheritedFlags.insideDefaultButton = insideDefaultButton; }
1027 
1028     PrintColorAdjust printColorAdjust() const { return static_cast&lt;PrintColorAdjust&gt;(m_inheritedFlags.printColorAdjust); }
1029     void setPrintColorAdjust(PrintColorAdjust value) { m_inheritedFlags.printColorAdjust = static_cast&lt;unsigned&gt;(value); }
1030 
<span class="line-modified">1031     int specifiedZIndex() const { return m_boxData-&gt;specifiedZIndex(); }</span>
<span class="line-modified">1032     bool hasAutoSpecifiedZIndex() const { return m_boxData-&gt;hasAutoSpecifiedZIndex(); }</span>
<span class="line-modified">1033     void setSpecifiedZIndex(int v)</span>
<span class="line-modified">1034     {</span>
<span class="line-added">1035         SET_VAR(m_boxData, m_hasAutoSpecifiedZIndex, false);</span>
<span class="line-added">1036         SET_VAR(m_boxData, m_specifiedZIndex, v);</span>
<span class="line-added">1037     }</span>
<span class="line-added">1038     void setHasAutoSpecifiedZIndex()</span>
<span class="line-added">1039     {</span>
<span class="line-added">1040         SET_VAR(m_boxData, m_hasAutoSpecifiedZIndex, true);</span>
<span class="line-added">1041         SET_VAR(m_boxData, m_specifiedZIndex, 0);</span>
<span class="line-added">1042     }</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     int usedZIndex() const { return m_boxData-&gt;usedZIndex(); }</span>
<span class="line-added">1045     bool hasAutoUsedZIndex() const { return m_boxData-&gt;hasAutoUsedZIndex(); }</span>
<span class="line-added">1046     void setUsedZIndex(int v)</span>
<span class="line-added">1047     {</span>
<span class="line-added">1048         SET_VAR(m_boxData, m_hasAutoUsedZIndex, false);</span>
<span class="line-added">1049         SET_VAR(m_boxData, m_usedZIndex, v);</span>
<span class="line-added">1050     }</span>
<span class="line-added">1051     void setHasAutoUsedZIndex()</span>
<span class="line-added">1052     {</span>
<span class="line-added">1053         SET_VAR(m_boxData, m_hasAutoUsedZIndex, true);</span>
<span class="line-added">1054         SET_VAR(m_boxData, m_usedZIndex, 0);</span>
<span class="line-added">1055     }</span>
1056 
1057     void setHasAutoWidows() { SET_VAR(m_rareInheritedData, hasAutoWidows, true); SET_VAR(m_rareInheritedData, widows, initialWidows()); }
1058     void setWidows(short w) { SET_VAR(m_rareInheritedData, hasAutoWidows, false); SET_VAR(m_rareInheritedData, widows, w); }
1059 
1060     void setHasAutoOrphans() { SET_VAR(m_rareInheritedData, hasAutoOrphans, true); SET_VAR(m_rareInheritedData, orphans, initialOrphans()); }
1061     void setOrphans(short o) { SET_VAR(m_rareInheritedData, hasAutoOrphans, false); SET_VAR(m_rareInheritedData, orphans, o); }
1062 
1063     // CSS3 Setters
1064     void setOutlineOffset(float v) { SET_VAR(m_backgroundData, outline.m_offset, v); }
1065     void setTextShadow(std::unique_ptr&lt;ShadowData&gt;, bool add = false);
1066     void setTextStrokeColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textStrokeColor, c); }
1067     void setTextStrokeWidth(float w) { SET_VAR(m_rareInheritedData, textStrokeWidth, w); }
1068     void setTextFillColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, textFillColor, c); }
1069     void setCaretColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, caretColor, c); }
1070     void setOpacity(float f) { float v = clampTo&lt;float&gt;(f, 0.f, 1.f); SET_VAR(m_rareNonInheritedData, opacity, v); }
1071     void setAppearance(ControlPart a) { SET_VAR(m_rareNonInheritedData, appearance, a); }
1072     // For valid values of box-align see http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/#alignment
1073     void setBoxAlign(BoxAlignment a) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, align, static_cast&lt;unsigned&gt;(a)); }
1074     void setBoxDirection(BoxDirection d) { m_inheritedFlags.boxDirection = static_cast&lt;unsigned&gt;(d); }
1075     void setBoxFlex(float f) { SET_NESTED_VAR(m_rareNonInheritedData, deprecatedFlexibleBox, flex, f); }
</pre>
<hr />
<pre>
1213     void setLineSnap(LineSnap lineSnap) { SET_VAR(m_rareInheritedData, lineSnap, static_cast&lt;unsigned&gt;(lineSnap)); }
1214     void setLineAlign(LineAlign lineAlign) { SET_VAR(m_rareInheritedData, lineAlign, static_cast&lt;unsigned&gt;(lineAlign)); }
1215 
1216     void setPointerEvents(PointerEvents p) { m_inheritedFlags.pointerEvents = static_cast&lt;unsigned&gt;(p); }
1217 
1218     void clearAnimations();
1219     void clearTransitions();
1220 
1221     void adjustAnimations();
1222     void adjustTransitions();
1223 
1224     void setTransformStyle3D(TransformStyle3D b) { SET_VAR(m_rareNonInheritedData, transformStyle3D, static_cast&lt;unsigned&gt;(b)); }
1225     void setBackfaceVisibility(BackfaceVisibility b) { SET_VAR(m_rareNonInheritedData, backfaceVisibility, static_cast&lt;unsigned&gt;(b)); }
1226     void setPerspective(float p) { SET_VAR(m_rareNonInheritedData, perspective, p); }
1227     void setPerspectiveOriginX(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginX, WTFMove(length)); }
1228     void setPerspectiveOriginY(Length&amp;&amp; length) { SET_VAR(m_rareNonInheritedData, perspectiveOriginY, WTFMove(length)); }
1229     void setPageSize(LengthSize size) { SET_VAR(m_rareNonInheritedData, pageSize, WTFMove(size)); }
1230     void setPageSizeType(PageSizeType t) { SET_VAR(m_rareNonInheritedData, pageSizeType, t); }
1231     void resetPageSizeType() { SET_VAR(m_rareNonInheritedData, pageSizeType, PAGE_SIZE_AUTO); }
1232 
<span class="line-modified">1233     void setLineBoxContain(OptionSet&lt;LineBoxContain&gt; c) { SET_VAR(m_rareInheritedData, lineBoxContain, c.toRaw()); }</span>
1234     void setLineClamp(LineClampValue c) { SET_VAR(m_rareNonInheritedData, lineClamp, c); }
1235 
1236     void setInitialLetter(const IntSize&amp; size) { SET_VAR(m_rareNonInheritedData, initialLetter, size); }
1237 
1238 #if ENABLE(POINTER_EVENTS)
1239     void setTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareNonInheritedData, touchActions, touchActions.toRaw()); }
1240     void setEffectiveTouchActions(OptionSet&lt;TouchAction&gt; touchActions) { SET_VAR(m_rareInheritedData, effectiveTouchActions, touchActions.toRaw()); }
1241 #endif
1242 
1243 #if ENABLE(CSS_SCROLL_SNAP)
1244     void setScrollSnapType(const ScrollSnapType&amp;);
1245     void setScrollPaddingTop(Length&amp;&amp;);
1246     void setScrollPaddingBottom(Length&amp;&amp;);
1247     void setScrollPaddingLeft(Length&amp;&amp;);
1248     void setScrollPaddingRight(Length&amp;&amp;);
1249 
1250     void setScrollSnapAlign(const ScrollSnapAlign&amp;);
1251     void setScrollSnapMarginTop(Length&amp;&amp;);
1252     void setScrollSnapMarginBottom(Length&amp;&amp;);
1253     void setScrollSnapMarginLeft(Length&amp;&amp;);
1254     void setScrollSnapMarginRight(Length&amp;&amp;);
1255 #endif
1256 
1257 #if ENABLE(TOUCH_EVENTS)
1258     void setTapHighlightColor(const Color&amp; c) { SET_VAR(m_rareInheritedData, tapHighlightColor, c); }
1259 #endif
1260 
1261 #if PLATFORM(IOS_FAMILY)
1262     void setTouchCalloutEnabled(bool v) { SET_VAR(m_rareInheritedData, touchCalloutEnabled, v); }
1263 #endif
1264 
1265 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1266     void setUseTouchOverflowScrolling(bool v) { SET_VAR(m_rareInheritedData, useTouchOverflowScrolling, v); }
1267 #endif
1268 
<span class="line-added">1269     void setUseSmoothScrolling(bool v) { SET_VAR(m_rareNonInheritedData, useSmoothScrolling, v); }</span>
<span class="line-added">1270 </span>
1271 #if ENABLE(TEXT_AUTOSIZING)
1272     void setTextSizeAdjust(TextSizeAdjustment adjustment) { SET_VAR(m_rareInheritedData, textSizeAdjust, adjustment); }
1273     void setAutosizeStatus(AutosizeStatus);
1274 #endif
1275 
1276     void setTextSecurity(TextSecurity security) { SET_VAR(m_rareInheritedData, textSecurity, static_cast&lt;unsigned&gt;(security)); }
1277 
1278 #if ENABLE(CSS_TRAILING_WORD)
1279     void setTrailingWord(TrailingWord) { }
1280 #endif
1281 
1282 #if ENABLE(APPLE_PAY)
1283     void setApplePayButtonStyle(ApplePayButtonStyle style) { SET_VAR(m_rareNonInheritedData, applePayButtonStyle, static_cast&lt;unsigned&gt;(style)); }
1284     void setApplePayButtonType(ApplePayButtonType type) { SET_VAR(m_rareNonInheritedData, applePayButtonType, static_cast&lt;unsigned&gt;(type)); }
1285 #endif
1286 
1287 #if ENABLE(CSS_PAINTING_API)
1288     void addCustomPaintWatchProperty(const String&amp; name);
1289 #endif
1290 
</pre>
<hr />
<pre>
1400     void setContent(std::unique_ptr&lt;CounterContent&gt;, bool add = false);
1401     void setContent(QuoteType, bool add = false);
1402     void setContentAltText(const String&amp;);
1403     const String&amp; contentAltText() const;
1404     bool hasAttrContent() const { return m_rareNonInheritedData-&gt;hasAttrContent; }
1405     void setHasAttrContent();
1406 
1407     const CounterDirectiveMap* counterDirectives() const;
1408     CounterDirectiveMap&amp; accessCounterDirectives();
1409 
1410     QuotesData* quotes() const { return m_rareInheritedData-&gt;quotes.get(); }
1411     void setQuotes(RefPtr&lt;QuotesData&gt;&amp;&amp;);
1412 
1413     WillChangeData* willChange() const { return m_rareNonInheritedData-&gt;willChange.get(); }
1414     void setWillChange(RefPtr&lt;WillChangeData&gt;&amp;&amp;);
1415 
1416     bool willChangeCreatesStackingContext() const;
1417 
1418     const AtomString&amp; hyphenString() const;
1419 
<span class="line-modified">1420     bool inheritedEqual(const RenderStyle&amp;) const;</span>
<span class="line-modified">1421     bool descendantAffectingNonInheritedPropertiesEqual(const RenderStyle&amp;) const;</span>
1422 
1423 #if ENABLE(TEXT_AUTOSIZING)
1424     uint32_t hashForTextAutosizing() const;
1425     bool equalForTextAutosizing(const RenderStyle&amp;) const;
1426 #endif
1427 
1428     StyleDifference diff(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1429     bool diffRequiresLayerRepaint(const RenderStyle&amp;, bool isComposited) const;
1430 
1431     bool isDisplayInlineType() const { return isDisplayInlineType(display()); }
1432     bool isOriginalDisplayInlineType() const { return isDisplayInlineType(originalDisplay()); }
1433     bool isDisplayFlexibleOrGridBox() const { return isDisplayFlexibleOrGridBox(display()); }
1434     bool isDisplayRegionType() const;
1435 
1436     bool setWritingMode(WritingMode);
1437 
1438     bool hasExplicitlySetWritingMode() const { return m_nonInheritedFlags.hasExplicitlySetWritingMode; }
1439     void setHasExplicitlySetWritingMode(bool v) { m_nonInheritedFlags.hasExplicitlySetWritingMode = v; }
1440 
1441     bool hasExplicitlySetTextAlign() const { return m_nonInheritedFlags.hasExplicitlySetTextAlign; }
</pre>
<hr />
<pre>
1492     static EmptyCell initialEmptyCells() { return EmptyCell::Show; }
1493     static ListStylePosition initialListStylePosition() { return ListStylePosition::Outside; }
1494     static ListStyleType initialListStyleType() { return ListStyleType::Disc; }
1495     static TextTransform initialTextTransform() { return TextTransform::None; }
1496     static Visibility initialVisibility() { return Visibility::Visible; }
1497     static WhiteSpace initialWhiteSpace() { return WhiteSpace::Normal; }
1498     static float initialHorizontalBorderSpacing() { return 0; }
1499     static float initialVerticalBorderSpacing() { return 0; }
1500     static CursorType initialCursor() { return CursorType::Auto; }
1501     static Color initialColor() { return Color::black; }
1502     static StyleImage* initialListStyleImage() { return 0; }
1503     static float initialBorderWidth() { return 3; }
1504     static unsigned short initialColumnRuleWidth() { return 3; }
1505     static float initialOutlineWidth() { return 3; }
1506     static float initialLetterSpacing() { return 0; }
1507     static Length initialWordSpacing() { return Length(Fixed); }
1508     static Length initialSize() { return Length(); }
1509     static Length initialMinSize() { return Length(); }
1510     static Length initialMaxSize() { return Length(Undefined); }
1511     static Length initialOffset() { return Length(); }
<span class="line-added">1512     static Length initialRadius() { return Length(); }</span>
1513     static Length initialMargin() { return Length(Fixed); }
1514     static Length initialPadding() { return Length(Fixed); }
1515     static Length initialTextIndent() { return Length(Fixed); }
1516     static Length initialZeroLength() { return Length(Fixed); }
1517     static Length initialOneLength() { return Length(1, Fixed); }
1518     static short initialWidows() { return 2; }
1519     static short initialOrphans() { return 2; }
1520     static Length initialLineHeight() { return Length(-100.0f, Percent); }
1521     static TextAlignMode initialTextAlign() { return TextAlignMode::Start; }
1522     static OptionSet&lt;TextDecoration&gt; initialTextDecoration() { return OptionSet&lt;TextDecoration&gt; { }; }
1523     static TextDecorationStyle initialTextDecorationStyle() { return TextDecorationStyle::Solid; }
1524     static OptionSet&lt;TextDecorationSkip&gt; initialTextDecorationSkip() { return TextDecorationSkip::Auto; }
1525     static TextUnderlinePosition initialTextUnderlinePosition() { return TextUnderlinePosition::Auto; }
1526     static TextUnderlineOffset initialTextUnderlineOffset() { return TextUnderlineOffset::createWithAuto(); }
1527     static TextDecorationThickness initialTextDecorationThickness() { return TextDecorationThickness::createWithAuto(); }
1528     static float initialZoom() { return 1.0f; }
1529     static TextZoom initialTextZoom() { return TextZoom::Normal; }
1530     static float initialOutlineOffset() { return 0; }
1531     static float initialOpacity() { return 1.0f; }
1532     static BoxAlignment initialBoxAlign() { return BoxAlignment::Stretch; }
</pre>
<hr />
<pre>
1585     static GapLength initialColumnGap() { return GapLength(); }
1586     static GapLength initialRowGap() { return GapLength(); }
1587     static const TransformOperations&amp; initialTransform() { static NeverDestroyed&lt;TransformOperations&gt; ops; return ops; }
1588     static Length initialTransformOriginX() { return Length(50.0f, Percent); }
1589     static Length initialTransformOriginY() { return Length(50.0f, Percent); }
1590     static TransformBox initialTransformBox() { return TransformBox::BorderBox; }
1591     static PointerEvents initialPointerEvents() { return PointerEvents::Auto; }
1592     static float initialTransformOriginZ() { return 0; }
1593     static TransformStyle3D initialTransformStyle3D() { return TransformStyle3D::Flat; }
1594     static BackfaceVisibility initialBackfaceVisibility() { return BackfaceVisibility::Visible; }
1595     static float initialPerspective() { return 0; }
1596     static Length initialPerspectiveOriginX() { return Length(50.0f, Percent); }
1597     static Length initialPerspectiveOriginY() { return Length(50.0f, Percent); }
1598     static Color initialBackgroundColor() { return Color::transparent; }
1599     static Color initialTextEmphasisColor() { return Color(); }
1600     static TextEmphasisFill initialTextEmphasisFill() { return TextEmphasisFill::Filled; }
1601     static TextEmphasisMark initialTextEmphasisMark() { return TextEmphasisMark::None; }
1602     static const AtomString&amp; initialTextEmphasisCustomMark() { return nullAtom(); }
1603     static OptionSet&lt;TextEmphasisPosition&gt; initialTextEmphasisPosition() { return { TextEmphasisPosition::Over, TextEmphasisPosition::Right }; }
1604     static RubyPosition initialRubyPosition() { return RubyPosition::Before; }
<span class="line-modified">1605     static OptionSet&lt;LineBoxContain&gt; initialLineBoxContain() { return { LineBoxContain::Block, LineBoxContain::Inline, LineBoxContain::Replaced }; }</span>
<span class="line-modified">1606     static ImageOrientation initialImageOrientation() { return ImageOrientation::FromImage; }</span>
1607     static ImageRendering initialImageRendering() { return ImageRendering::Auto; }
1608     static ImageResolutionSource initialImageResolutionSource() { return ImageResolutionSource::Specified; }
1609     static ImageResolutionSnap initialImageResolutionSnap() { return ImageResolutionSnap::None; }
1610     static float initialImageResolution() { return 1; }
1611     static StyleImage* initialBorderImageSource() { return nullptr; }
1612     static StyleImage* initialMaskBoxImageSource() { return nullptr; }
1613     static PrintColorAdjust initialPrintColorAdjust() { return PrintColorAdjust::Economy; }
1614     static QuotesData* initialQuotes() { return nullptr; }
1615     static const AtomString&amp; initialContentAltText() { return emptyAtom(); }
1616 
1617 #if ENABLE(DARK_MODE_CSS)
1618     static StyleColorScheme initialColorScheme() { return { }; }
1619 #endif
1620 
1621 #if ENABLE(CSS3_TEXT)
1622     static TextIndentLine initialTextIndentLine() { return TextIndentLine::FirstLine; }
1623     static TextIndentType initialTextIndentType() { return TextIndentType::Normal; }
1624     static TextAlignLast initialTextAlignLast() { return TextAlignLast::Auto; }
1625     static TextJustify initialTextJustify() { return TextJustify::Auto; }
1626 #endif
</pre>
<hr />
<pre>
1689     static const AtomString&amp; initialLineGrid() { return nullAtom(); }
1690     static LineSnap initialLineSnap() { return LineSnap::None; }
1691     static LineAlign initialLineAlign() { return LineAlign::None; }
1692 
1693     static IntSize initialInitialLetter() { return IntSize(); }
1694     static LineClampValue initialLineClamp() { return LineClampValue(); }
1695     static TextSecurity initialTextSecurity() { return TextSecurity::None; }
1696 
1697 #if PLATFORM(IOS_FAMILY)
1698     static bool initialTouchCalloutEnabled() { return true; }
1699 #endif
1700 
1701 #if ENABLE(TOUCH_EVENTS)
1702     static Color initialTapHighlightColor();
1703 #endif
1704 
1705 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
1706     static bool initialUseTouchOverflowScrolling() { return false; }
1707 #endif
1708 
<span class="line-added">1709     static bool initialUseSmoothScrolling() { return false; }</span>
<span class="line-added">1710 </span>
1711     static const FilterOperations&amp; initialFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1712     static const FilterOperations&amp; initialAppleColorFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1713 
1714 #if ENABLE(FILTERS_LEVEL_2)
1715     static const FilterOperations&amp; initialBackdropFilter() { static NeverDestroyed&lt;FilterOperations&gt; ops; return ops; }
1716 #endif
1717 
1718 #if ENABLE(CSS_COMPOSITING)
1719     static BlendMode initialBlendMode() { return BlendMode::Normal; }
1720     static Isolation initialIsolation() { return Isolation::Auto; }
1721 #endif
1722 
1723     // Indicates the style is likely to change due to a pending stylesheet load.
1724     bool isNotFinal() const { return m_rareNonInheritedData-&gt;isNotFinal; }
1725     void setIsNotFinal() { SET_VAR(m_rareNonInheritedData, isNotFinal, true); }
1726 
1727     void setVisitedLinkColor(const Color&amp;);
1728     void setVisitedLinkBackgroundColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBackgroundColor, v); }
1729     void setVisitedLinkBorderLeftColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderLeftColor, v); }
1730     void setVisitedLinkBorderRightColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkBorderRightColor, v); }
</pre>
<hr />
<pre>
1734     void setVisitedLinkColumnRuleColor(const Color&amp; v) { SET_NESTED_VAR(m_rareNonInheritedData, multiCol, visitedLinkColumnRuleColor, v); }
1735     void setVisitedLinkTextDecorationColor(const Color&amp; v) { SET_VAR(m_rareNonInheritedData, visitedLinkTextDecorationColor, v); }
1736     void setVisitedLinkTextEmphasisColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextEmphasisColor, v); }
1737     void setVisitedLinkTextFillColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextFillColor, v); }
1738     void setVisitedLinkTextStrokeColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkTextStrokeColor, v); }
1739     void setVisitedLinkCaretColor(const Color&amp; v) { SET_VAR(m_rareInheritedData, visitedLinkCaretColor, v); }
1740 
1741     void inheritUnicodeBidiFrom(const RenderStyle* parent) { m_nonInheritedFlags.unicodeBidi = parent-&gt;m_nonInheritedFlags.unicodeBidi; }
1742     void getShadowExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const;
1743     void getShadowHorizontalExtent(const ShadowData*, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
1744     void getShadowVerticalExtent(const ShadowData*, LayoutUnit&amp; top, LayoutUnit&amp; bottom) const;
1745     void getShadowInlineDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalLeft, LayoutUnit&amp; logicalRight) const;
1746     void getShadowBlockDirectionExtent(const ShadowData*, LayoutUnit&amp; logicalTop, LayoutUnit&amp; logicalBottom) const;
1747 
1748     static Color invalidColor() { return Color(); }
1749     const Color&amp; borderLeftColor() const { return m_surroundData-&gt;border.left().color(); }
1750     const Color&amp; borderRightColor() const { return m_surroundData-&gt;border.right().color(); }
1751     const Color&amp; borderTopColor() const { return m_surroundData-&gt;border.top().color(); }
1752     const Color&amp; borderBottomColor() const { return m_surroundData-&gt;border.bottom().color(); }
1753     const Color&amp; backgroundColor() const { return m_backgroundData-&gt;color; }
<span class="line-modified">1754     WEBCORE_EXPORT const Color&amp; color() const;</span>
1755     const Color&amp; columnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;rule.color(); }
1756     const Color&amp; outlineColor() const { return m_backgroundData-&gt;outline.color(); }
1757     const Color&amp; textEmphasisColor() const { return m_rareInheritedData-&gt;textEmphasisColor; }
1758     const Color&amp; textFillColor() const { return m_rareInheritedData-&gt;textFillColor; }
1759     const Color&amp; textStrokeColor() const { return m_rareInheritedData-&gt;textStrokeColor; }
1760     const Color&amp; caretColor() const { return m_rareInheritedData-&gt;caretColor; }
1761     const Color&amp; visitedLinkColor() const;
1762     const Color&amp; visitedLinkBackgroundColor() const { return m_rareNonInheritedData-&gt;visitedLinkBackgroundColor; }
1763     const Color&amp; visitedLinkBorderLeftColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderLeftColor; }
1764     const Color&amp; visitedLinkBorderRightColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderRightColor; }
1765     const Color&amp; visitedLinkBorderBottomColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderBottomColor; }
1766     const Color&amp; visitedLinkBorderTopColor() const { return m_rareNonInheritedData-&gt;visitedLinkBorderTopColor; }
1767     const Color&amp; visitedLinkOutlineColor() const { return m_rareNonInheritedData-&gt;visitedLinkOutlineColor; }
1768     const Color&amp; visitedLinkColumnRuleColor() const { return m_rareNonInheritedData-&gt;multiCol-&gt;visitedLinkColumnRuleColor; }
1769     const Color&amp; textDecorationColor() const { return m_rareNonInheritedData-&gt;textDecorationColor; }
1770     const Color&amp; visitedLinkTextDecorationColor() const { return m_rareNonInheritedData-&gt;visitedLinkTextDecorationColor; }
1771     const Color&amp; visitedLinkTextEmphasisColor() const { return m_rareInheritedData-&gt;visitedLinkTextEmphasisColor; }
1772     const Color&amp; visitedLinkTextFillColor() const { return m_rareInheritedData-&gt;visitedLinkTextFillColor; }
1773     const Color&amp; visitedLinkTextStrokeColor() const { return m_rareInheritedData-&gt;visitedLinkTextStrokeColor; }
1774     const Color&amp; visitedLinkCaretColor() const { return m_rareInheritedData-&gt;visitedLinkCaretColor; }
</pre>
<hr />
<pre>
1892     bool changeRequiresRecompositeLayer(const RenderStyle&amp;, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const;
1893 
1894     // non-inherited attributes
1895     DataRef&lt;StyleBoxData&gt; m_boxData;
1896     DataRef&lt;StyleVisualData&gt; m_visualData;
1897     DataRef&lt;StyleBackgroundData&gt; m_backgroundData;
1898     DataRef&lt;StyleSurroundData&gt; m_surroundData;
1899     DataRef&lt;StyleRareNonInheritedData&gt; m_rareNonInheritedData;
1900     NonInheritedFlags m_nonInheritedFlags;
1901 
1902     // inherited attributes
1903     DataRef&lt;StyleRareInheritedData&gt; m_rareInheritedData;
1904     DataRef&lt;StyleInheritedData&gt; m_inheritedData;
1905     InheritedFlags m_inheritedFlags;
1906 
1907     // list of associated pseudo styles
1908     std::unique_ptr&lt;PseudoStyleCache&gt; m_cachedPseudoStyles;
1909 
1910     DataRef&lt;SVGRenderStyle&gt; m_svgStyle;
1911 
<span class="line-modified">1912 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
1913     bool m_deletionHasBegun { false };
1914 #endif
1915 };
1916 
1917 int adjustForAbsoluteZoom(int, const RenderStyle&amp;);
1918 float adjustFloatForAbsoluteZoom(float, const RenderStyle&amp;);
1919 LayoutUnit adjustLayoutUnitForAbsoluteZoom(LayoutUnit, const RenderStyle&amp;);
1920 
1921 BorderStyle collapsedBorderStyle(BorderStyle);
1922 
1923 bool pseudoElementRendererIsNeeded(const RenderStyle*);
1924 
1925 inline bool RenderStyle::NonInheritedFlags::operator==(const NonInheritedFlags&amp; other) const
1926 {
1927     return effectiveDisplay == other.effectiveDisplay
1928         &amp;&amp; originalDisplay == other.originalDisplay
1929         &amp;&amp; overflowX == other.overflowX
1930         &amp;&amp; overflowY == other.overflowY
1931         &amp;&amp; verticalAlign == other.verticalAlign
1932         &amp;&amp; clear == other.clear
</pre>
<hr />
<pre>
2099 }
2100 
2101 inline bool RenderStyle::breakOnlyAfterWhiteSpace() const
2102 {
2103     return whiteSpace() == WhiteSpace::PreWrap || whiteSpace() == WhiteSpace::BreakSpaces || lineBreak() == LineBreak::AfterWhiteSpace;
2104 }
2105 
2106 inline bool RenderStyle::breakWords() const
2107 {
2108     return wordBreak() == WordBreak::BreakWord || overflowWrap() == OverflowWrap::Break;
2109 }
2110 
2111 inline bool RenderStyle::hasInlineColumnAxis() const
2112 {
2113     auto axis = columnAxis();
2114     return axis == ColumnAxis::Auto || isHorizontalWritingMode() == (axis == ColumnAxis::Horizontal);
2115 }
2116 
2117 inline ImageOrientation RenderStyle::imageOrientation() const
2118 {
<span class="line-modified">2119     return static_cast&lt;ImageOrientation::Orientation&gt;(m_rareInheritedData-&gt;imageOrientation);</span>




2120 }
2121 
2122 inline void RenderStyle::setLogicalWidth(Length&amp;&amp; logicalWidth)
2123 {
2124     if (isHorizontalWritingMode())
2125         setWidth(WTFMove(logicalWidth));
2126     else
2127         setHeight(WTFMove(logicalWidth));
2128 }
2129 
2130 inline void RenderStyle::setLogicalHeight(Length&amp;&amp; logicalHeight)
2131 {
2132     if (isHorizontalWritingMode())
2133         setHeight(WTFMove(logicalHeight));
2134     else
2135         setWidth(WTFMove(logicalHeight));
2136 }
2137 
2138 inline void RenderStyle::setBorderRadius(LengthSize&amp;&amp; size)
2139 {
</pre>
</td>
</tr>
</table>
<center><a href="RenderStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyleConstants.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTierUpCheckInjectionPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGThunks.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGToFTLDeferredCompilationCallback.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTierUpCheckInjectionPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 83,13 ***</span>
          if (!Options::useOSREntryToFTL())
              level = FTL::CanCompile;
  
          m_graph.ensureCPSNaturalLoops();
          CPSNaturalLoops&amp; naturalLoops = *m_graph.m_cpsNaturalLoops;
<span class="line-modified">!         HashMap&lt;const NaturalLoop*, unsigned&gt; naturalLoopToLoopHint = buildNaturalLoopToLoopHintMap(naturalLoops);</span>
  
<span class="line-modified">!         HashMap&lt;unsigned, LoopHintDescriptor&gt; tierUpHierarchy;</span>
  
          InsertionSet insertionSet(m_graph);
          for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
              BasicBlock* block = m_graph.block(blockIndex);
              if (!block)
<span class="line-new-header">--- 83,13 ---</span>
          if (!Options::useOSREntryToFTL())
              level = FTL::CanCompile;
  
          m_graph.ensureCPSNaturalLoops();
          CPSNaturalLoops&amp; naturalLoops = *m_graph.m_cpsNaturalLoops;
<span class="line-modified">!         HashMap&lt;const NaturalLoop*, BytecodeIndex&gt; naturalLoopToLoopHint = buildNaturalLoopToLoopHintMap(naturalLoops);</span>
  
<span class="line-modified">!         HashMap&lt;BytecodeIndex, LoopHintDescriptor&gt; tierUpHierarchy;</span>
  
          InsertionSet insertionSet(m_graph);
          for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
              BasicBlock* block = m_graph.block(blockIndex);
              if (!block)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 106,11 ***</span>
                  NodeType tierUpType = CheckTierUpAndOSREnter;
                  if (!canOSREnter)
                      tierUpType = CheckTierUpInLoop;
                  insertionSet.insertNode(nodeIndex + 1, SpecNone, tierUpType, origin);
  
<span class="line-modified">!                 unsigned bytecodeIndex = origin.semantic.bytecodeIndex();</span>
                  if (canOSREnter)
                      m_graph.m_plan.tierUpAndOSREnterBytecodes().append(bytecodeIndex);
  
                  if (const NaturalLoop* loop = naturalLoops.innerMostLoopOf(block)) {
                      LoopHintDescriptor descriptor;
<span class="line-new-header">--- 106,11 ---</span>
                  NodeType tierUpType = CheckTierUpAndOSREnter;
                  if (!canOSREnter)
                      tierUpType = CheckTierUpInLoop;
                  insertionSet.insertNode(nodeIndex + 1, SpecNone, tierUpType, origin);
  
<span class="line-modified">!                 auto bytecodeIndex = origin.semantic.bytecodeIndex();</span>
                  if (canOSREnter)
                      m_graph.m_plan.tierUpAndOSREnterBytecodes().append(bytecodeIndex);
  
                  if (const NaturalLoop* loop = naturalLoops.innerMostLoopOf(block)) {
                      LoopHintDescriptor descriptor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,12 ***</span>
              insertionSet.execute(block);
          }
  
          // Add all the candidates that can be OSR Entered.
          for (auto entry : tierUpHierarchy) {
<span class="line-modified">!             Vector&lt;unsigned&gt; tierUpCandidates;</span>
<span class="line-modified">!             for (unsigned bytecodeIndex : entry.value.osrEntryCandidates) {</span>
                  auto descriptorIt = tierUpHierarchy.find(bytecodeIndex);
                  if (descriptorIt != tierUpHierarchy.end()
                      &amp;&amp; descriptorIt-&gt;value.canOSREnter)
                      tierUpCandidates.append(bytecodeIndex);
              }
<span class="line-new-header">--- 136,12 ---</span>
              insertionSet.execute(block);
          }
  
          // Add all the candidates that can be OSR Entered.
          for (auto entry : tierUpHierarchy) {
<span class="line-modified">!             Vector&lt;BytecodeIndex&gt; tierUpCandidates;</span>
<span class="line-modified">!             for (BytecodeIndex bytecodeIndex : entry.value.osrEntryCandidates) {</span>
                  auto descriptorIt = tierUpHierarchy.find(bytecodeIndex);
                  if (descriptorIt != tierUpHierarchy.end()
                      &amp;&amp; descriptorIt-&gt;value.canOSREnter)
                      tierUpCandidates.append(bytecodeIndex);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
      }
  
  private:
  #if ENABLE(FTL_JIT)
      struct LoopHintDescriptor {
<span class="line-modified">!         Vector&lt;unsigned&gt; osrEntryCandidates;</span>
          bool canOSREnter;
      };
  
      bool canOSREnterAtLoopHint(FTL::CapabilityLevel level, const BasicBlock* block, unsigned nodeIndex)
      {
<span class="line-new-header">--- 158,11 ---</span>
      }
  
  private:
  #if ENABLE(FTL_JIT)
      struct LoopHintDescriptor {
<span class="line-modified">!         Vector&lt;BytecodeIndex&gt; osrEntryCandidates;</span>
          bool canOSREnter;
      };
  
      bool canOSREnterAtLoopHint(FTL::CapabilityLevel level, const BasicBlock* block, unsigned nodeIndex)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,22 ***</span>
                  return false;
          }
          return true;
      }
  
<span class="line-modified">!     HashMap&lt;const NaturalLoop*, unsigned&gt; buildNaturalLoopToLoopHintMap(const CPSNaturalLoops&amp; naturalLoops)</span>
      {
<span class="line-modified">!         HashMap&lt;const NaturalLoop*, unsigned&gt; naturalLoopsToLoopHint;</span>
  
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
                  Node* node = block-&gt;at(nodeIndex);
                  if (node-&gt;op() != LoopHint)
                      continue;
  
                  if (const NaturalLoop* loop = naturalLoops.innerMostLoopOf(block)) {
<span class="line-modified">!                     unsigned bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
                      naturalLoopsToLoopHint.add(loop, bytecodeIndex);
                  }
                  break;
              }
          }
<span class="line-new-header">--- 181,22 ---</span>
                  return false;
          }
          return true;
      }
  
<span class="line-modified">!     HashMap&lt;const NaturalLoop*, BytecodeIndex&gt; buildNaturalLoopToLoopHintMap(const CPSNaturalLoops&amp; naturalLoops)</span>
      {
<span class="line-modified">!         HashMap&lt;const NaturalLoop*, BytecodeIndex&gt; naturalLoopsToLoopHint;</span>
  
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
              for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
                  Node* node = block-&gt;at(nodeIndex);
                  if (node-&gt;op() != LoopHint)
                      continue;
  
                  if (const NaturalLoop* loop = naturalLoops.innerMostLoopOf(block)) {
<span class="line-modified">!                     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
                      naturalLoopsToLoopHint.add(loop, bytecodeIndex);
                  }
                  break;
              }
          }
</pre>
<center><a href="DFGThunks.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGToFTLDeferredCompilationCallback.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
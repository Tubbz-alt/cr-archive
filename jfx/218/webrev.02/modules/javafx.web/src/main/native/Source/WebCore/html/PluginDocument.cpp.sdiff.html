<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/PluginDocument.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PasswordInputType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PublicURLManager.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/PluginDocument.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
125 
126     // Below we assume that renderer-&gt;widget() to have been created by
127     // document()-&gt;updateLayout(). However, in some cases, updateLayout() will
128     // recurse too many times and delay its post-layout tasks (such as creating
129     // the widget). Here we kick off the pending post-layout tasks so that we
130     // can synchronously redirect data to the plugin.
131     frame-&gt;view()-&gt;flushAnyPendingPostLayoutTasks();
132 
133     if (RenderWidget* renderer = m_embedElement-&gt;renderWidget()) {
134         if (RefPtr&lt;Widget&gt; widget = renderer-&gt;widget()) {
135             frame-&gt;loader().client().redirectDataToPlugin(*widget);
136             // In a plugin document, the main resource is the plugin. If we have a null widget, that means
137             // the loading of the plugin was cancelled, which gives us a null mainResourceLoader(), so we
138             // need to have this call in a null check of the widget or of mainResourceLoader().
139             frame-&gt;loader().activeDocumentLoader()-&gt;setMainResourceDataBufferingPolicy(DataBufferingPolicy::DoNotBufferData);
140         }
141     }
142 }
143 
144 PluginDocument::PluginDocument(Frame&amp; frame, const URL&amp; url)
<span class="line-modified">145     : HTMLDocument(frame.sessionID(), &amp;frame, url, PluginDocumentClass)</span>
146 {
147     setCompatibilityMode(DocumentCompatibilityMode::QuirksMode);
148     lockCompatibilityMode();
149 }
150 
151 Ref&lt;DocumentParser&gt; PluginDocument::createParser()
152 {
153     return PluginDocumentParser::create(*this);
154 }
155 
156 Widget* PluginDocument::pluginWidget()
157 {
158     if (!m_pluginElement)
159         return nullptr;
160     auto* renderer = m_pluginElement-&gt;renderer();
161     if (!renderer)
162         return nullptr;
163     return downcast&lt;RenderEmbeddedObject&gt;(*m_pluginElement-&gt;renderer()).widget();
164 }
165 
</pre>
</td>
<td>
<hr />
<pre>
125 
126     // Below we assume that renderer-&gt;widget() to have been created by
127     // document()-&gt;updateLayout(). However, in some cases, updateLayout() will
128     // recurse too many times and delay its post-layout tasks (such as creating
129     // the widget). Here we kick off the pending post-layout tasks so that we
130     // can synchronously redirect data to the plugin.
131     frame-&gt;view()-&gt;flushAnyPendingPostLayoutTasks();
132 
133     if (RenderWidget* renderer = m_embedElement-&gt;renderWidget()) {
134         if (RefPtr&lt;Widget&gt; widget = renderer-&gt;widget()) {
135             frame-&gt;loader().client().redirectDataToPlugin(*widget);
136             // In a plugin document, the main resource is the plugin. If we have a null widget, that means
137             // the loading of the plugin was cancelled, which gives us a null mainResourceLoader(), so we
138             // need to have this call in a null check of the widget or of mainResourceLoader().
139             frame-&gt;loader().activeDocumentLoader()-&gt;setMainResourceDataBufferingPolicy(DataBufferingPolicy::DoNotBufferData);
140         }
141     }
142 }
143 
144 PluginDocument::PluginDocument(Frame&amp; frame, const URL&amp; url)
<span class="line-modified">145     : HTMLDocument(&amp;frame, url, PluginDocumentClass)</span>
146 {
147     setCompatibilityMode(DocumentCompatibilityMode::QuirksMode);
148     lockCompatibilityMode();
149 }
150 
151 Ref&lt;DocumentParser&gt; PluginDocument::createParser()
152 {
153     return PluginDocumentParser::create(*this);
154 }
155 
156 Widget* PluginDocument::pluginWidget()
157 {
158     if (!m_pluginElement)
159         return nullptr;
160     auto* renderer = m_pluginElement-&gt;renderer();
161     if (!renderer)
162         return nullptr;
163     return downcast&lt;RenderEmbeddedObject&gt;(*m_pluginElement-&gt;renderer()).widget();
164 }
165 
</pre>
</td>
</tr>
</table>
<center><a href="PasswordInputType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PublicURLManager.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
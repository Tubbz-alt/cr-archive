diff a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLPlugInImageElement.cpp
@@ -31,30 +31,31 @@
 #include "HTMLImageLoader.h"
 #include "JSDOMConvertBoolean.h"
 #include "JSDOMConvertInterface.h"
 #include "JSDOMConvertStrings.h"
 #include "JSShadowRoot.h"
+#include "LegacySchemeRegistry.h"
 #include "LocalizedStrings.h"
 #include "Logging.h"
 #include "MouseEvent.h"
 #include "Page.h"
 #include "PlatformMouseEvent.h"
 #include "PlugInClient.h"
 #include "PluginViewBase.h"
 #include "RenderImage.h"
 #include "RenderSnapshottedPlugIn.h"
 #include "RenderTreeUpdater.h"
-#include "SchemeRegistry.h"
 #include "ScriptController.h"
 #include "SecurityOrigin.h"
 #include "Settings.h"
 #include "ShadowRoot.h"
 #include "StyleTreeResolver.h"
 #include "SubframeLoader.h"
 #include "TypedElementDescendantIterator.h"
 #include "UserGestureIndicator.h"
 #include <JavaScriptCore/CatchScope.h>
+#include <JavaScriptCore/JSGlobalObjectInlines.h>
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLPlugInImageElement);
@@ -182,17 +183,17 @@
     return document().frame()->loader().client().objectContentType(completedURL, serviceType) == ObjectContentType::PlugIn;
 }
 
 RenderPtr<RenderElement> HTMLPlugInImageElement::createElementRenderer(RenderStyle&& style, const RenderTreePosition& insertionPosition)
 {
-    ASSERT(document().pageCacheState() == Document::NotInPageCache);
+    ASSERT(document().backForwardCacheState() == Document::NotInBackForwardCache);
 
     if (displayState() >= PreparingPluginReplacement)
         return HTMLPlugInElement::createElementRenderer(WTFMove(style), insertionPosition);
 
     // Once a plug-in element creates its renderer, it needs to be told when the document goes
-    // inactive or reactivates so it can clear the renderer before going into the page cache.
+    // inactive or reactivates so it can clear the renderer before going into the back/forward cache.
     if (!m_needsDocumentActivationCallbacks) {
         m_needsDocumentActivationCallbacks = true;
         document().registerForDocumentSuspensionCallbacks(*this);
     }
 
@@ -360,11 +361,11 @@
         renderer->repaint();
 }
 
 static DOMWrapperWorld& plugInImageElementIsolatedWorld()
 {
-    static auto& isolatedWorld = DOMWrapperWorld::create(commonVM()).leakRef();
+    static auto& isolatedWorld = DOMWrapperWorld::create(commonVM(), DOMWrapperWorld::Type::Internal, "Plugin"_s).leakRef();
     return isolatedWorld;
 }
 
 void HTMLPlugInImageElement::didAddUserAgentShadowRoot(ShadowRoot& root)
 {
@@ -390,35 +391,35 @@
     auto& globalObject = *JSC::jsCast<JSDOMGlobalObject*>(scriptController.globalObject(isolatedWorld));
 
     auto& vm = globalObject.vm();
     JSC::JSLockHolder lock(vm);
     auto scope = DECLARE_CATCH_SCOPE(vm);
-    auto& state = *globalObject.globalExec();
+    auto& lexicalGlobalObject = globalObject;
 
     JSC::MarkedArgumentBuffer argList;
-    argList.append(toJS<IDLInterface<ShadowRoot>>(state, globalObject, root));
-    argList.append(toJS<IDLDOMString>(state, titleText(*page, mimeType)));
-    argList.append(toJS<IDLDOMString>(state, subtitleText(*page, mimeType)));
+    argList.append(toJS<IDLInterface<ShadowRoot>>(lexicalGlobalObject, globalObject, root));
+    argList.append(toJS<IDLDOMString>(lexicalGlobalObject, titleText(*page, mimeType)));
+    argList.append(toJS<IDLDOMString>(lexicalGlobalObject, subtitleText(*page, mimeType)));
 
     // This parameter determines whether or not the snapshot overlay should always be visible over the plugin snapshot.
     // If no snapshot was found then we want the overlay to be visible.
     argList.append(toJS<IDLBoolean>(!m_snapshotImage));
     ASSERT(!argList.hasOverflowed());
 
     // It is expected the JS file provides a createOverlay(shadowRoot, title, subtitle) function.
-    auto* overlay = globalObject.get(&state, JSC::Identifier::fromString(vm, "createOverlay")).toObject(&state);
+    auto* overlay = globalObject.get(&lexicalGlobalObject, JSC::Identifier::fromString(vm, "createOverlay")).toObject(&lexicalGlobalObject);
     ASSERT(!overlay == !!scope.exception());
     if (!overlay) {
         scope.clearException();
         return;
     }
     JSC::CallData callData;
     auto callType = overlay->methodTable(vm)->getCallData(overlay, callData);
     if (callType == JSC::CallType::None)
         return;
 
-    call(&state, overlay, callType, callData, &globalObject, argList);
+    call(&lexicalGlobalObject, overlay, callType, callData, &globalObject, argList);
     scope.clearException();
 }
 
 bool HTMLPlugInImageElement::partOfSnapshotOverlay(const EventTarget* target) const
 {
@@ -482,12 +483,12 @@
 {
     if (forwardEvent)
         m_pendingClickEventFromSnapshot = &event;
 
     auto plugInOrigin = m_loadedUrl.host();
-    if (document().page() && !SchemeRegistry::shouldTreatURLSchemeAsLocal(document().page()->mainFrame().document()->baseURL().protocol().toStringWithoutCopying()) && document().page()->settings().autostartOriginPlugInSnapshottingEnabled())
-        document().page()->plugInClient()->didStartFromOrigin(document().page()->mainFrame().document()->baseURL().host().toString(), plugInOrigin.toString(), serviceType(), document().page()->sessionID());
+    if (document().page() && !LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(document().page()->mainFrame().document()->baseURL().protocol().toStringWithoutCopying()) && document().page()->settings().autostartOriginPlugInSnapshottingEnabled())
+        document().page()->plugInClient()->didStartFromOrigin(document().page()->mainFrame().document()->baseURL().host().toString(), plugInOrigin.toString(), serviceType());
 
     LOG(Plugins, "%p User clicked on snapshotted plug-in. Restart.", this);
     restartSnapshottedPlugIn();
     if (forwardEvent)
         setDisplayState(RestartingWithPendingMouseClick);
@@ -699,11 +700,11 @@
         LOG(Plugins, "%p Plug-in has no src URL but does have a valid mime type %s, set to play", this, serviceType().utf8().data());
         m_snapshotDecision = MaySnapshotWhenContentIsSet;
         return;
     }
 
-    if (!SchemeRegistry::shouldTreatURLSchemeAsLocal(m_loadedUrl.protocol().toStringWithoutCopying()) && !m_loadedUrl.host().isEmpty() && m_loadedUrl.host() == document().page()->mainFrame().document()->baseURL().host()) {
+    if (!LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_loadedUrl.protocol().toStringWithoutCopying()) && !m_loadedUrl.host().isEmpty() && m_loadedUrl.host() == document().page()->mainFrame().document()->baseURL().host()) {
         LOG(Plugins, "%p Plug-in is served from page's domain, set to play", this);
         m_snapshotDecision = NeverSnapshot;
         return;
     }
 

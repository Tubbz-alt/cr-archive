<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/HashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2008 David Levin &lt;levin@chromium.org&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public License
  16  * along with this library; see the file COPYING.LIB.  If not, write to
  17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  *
  20  */
  21 
  22 #pragma once
  23 
  24 #include &lt;atomic&gt;
  25 #include &lt;iterator&gt;
  26 #include &lt;mutex&gt;
  27 #include &lt;string.h&gt;
  28 #include &lt;type_traits&gt;
  29 #include &lt;utility&gt;
  30 #include &lt;wtf/Assertions.h&gt;
<a name="2" id="anc2"></a><span class="line-added">  31 #include &lt;wtf/DebugHeap.h&gt;</span>
  32 #include &lt;wtf/FastMalloc.h&gt;
  33 #include &lt;wtf/HashTraits.h&gt;
  34 #include &lt;wtf/Lock.h&gt;
  35 #include &lt;wtf/MathExtras.h&gt;
  36 #include &lt;wtf/RandomNumber.h&gt;
  37 #include &lt;wtf/StdLibExtras.h&gt;
  38 #include &lt;wtf/ValueCheck.h&gt;
  39 
  40 #define DUMP_HASHTABLE_STATS 0
  41 #define DUMP_HASHTABLE_STATS_PER_TABLE 0
  42 
  43 #if DUMP_HASHTABLE_STATS_PER_TABLE
  44 #include &lt;wtf/DataLog.h&gt;
  45 #endif
  46 
  47 namespace WTF {
  48 
<a name="3" id="anc3"></a><span class="line-added">  49 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(HashTable);</span>
<span class="line-added">  50 </span>
  51 // Enables internal WTF consistency checks that are invoked automatically. Non-WTF callers can call checkTableConsistency() even if internal checks are disabled.
  52 #define CHECK_HASHTABLE_CONSISTENCY 0
  53 
  54 #ifdef NDEBUG
  55 #define CHECK_HASHTABLE_ITERATORS 0
  56 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 0
  57 #else
  58 #define CHECK_HASHTABLE_ITERATORS 1
  59 #define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 1
  60 #endif
  61 
  62 #if DUMP_HASHTABLE_STATS
  63 
  64     struct HashTableStats {
  65         // The following variables are all atomically incremented when modified.
  66         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numAccesses;
  67         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRehashes;
  68         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numRemoves;
  69         WTF_EXPORT_PRIVATE static std::atomic&lt;unsigned&gt; numReinserts;
  70 
  71         // The following variables are only modified in the recordCollisionAtCount method within a mutex.
  72         WTF_EXPORT_PRIVATE static unsigned maxCollisions;
  73         WTF_EXPORT_PRIVATE static unsigned numCollisions;
  74         WTF_EXPORT_PRIVATE static unsigned collisionGraph[4096];
  75 
  76         WTF_EXPORT_PRIVATE static void recordCollisionAtCount(unsigned count);
  77         WTF_EXPORT_PRIVATE static void dumpStats();
  78     };
  79 
  80 #endif
  81 
  82     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  83     class HashTable;
  84     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  85     class HashTableIterator;
  86     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  87     class HashTableConstIterator;
  88 
  89     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  90     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
  91         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  92 
  93     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  94     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*);
  95 
  96 #if !CHECK_HASHTABLE_ITERATORS
  97 
  98     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
  99     inline void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*,
 100         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
 101 
 102     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 103     inline void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;*) { }
 104 
 105 #endif
 106 
 107     typedef enum { HashItemKnownGood } HashItemKnownGoodTag;
 108 
 109     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 110     class HashTableConstIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, const Value*, const Value&amp;&gt; {
 111         WTF_MAKE_FAST_ALLOCATED;
 112     private:
 113         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 114         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 115         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 116         typedef Value ValueType;
 117         typedef const ValueType&amp; ReferenceType;
 118         typedef const ValueType* PointerType;
 119 
 120         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 121         friend class HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 122 
 123         void skipEmptyBuckets()
 124         {
 125             while (m_position != m_endPosition &amp;&amp; HashTableType::isEmptyOrDeletedBucket(*m_position))
 126                 ++m_position;
 127         }
 128 
 129         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition)
 130             : m_position(position), m_endPosition(endPosition)
 131         {
 132             addIterator(table, this);
 133             skipEmptyBuckets();
 134         }
 135 
 136         HashTableConstIterator(const HashTableType* table, PointerType position, PointerType endPosition, HashItemKnownGoodTag)
 137             : m_position(position), m_endPosition(endPosition)
 138         {
 139             addIterator(table, this);
 140         }
 141 
 142     public:
 143         HashTableConstIterator()
 144         {
 145             addIterator(static_cast&lt;const HashTableType*&gt;(0), this);
 146         }
 147 
 148         // default copy, assignment and destructor are OK if CHECK_HASHTABLE_ITERATORS is 0
 149 
 150 #if CHECK_HASHTABLE_ITERATORS
 151         ~HashTableConstIterator()
 152         {
 153             removeIterator(this);
 154         }
 155 
 156         HashTableConstIterator(const const_iterator&amp; other)
 157             : m_position(other.m_position), m_endPosition(other.m_endPosition)
 158         {
 159             addIterator(other.m_table, this);
 160         }
 161 
 162         const_iterator&amp; operator=(const const_iterator&amp; other)
 163         {
 164             m_position = other.m_position;
 165             m_endPosition = other.m_endPosition;
 166 
 167             removeIterator(this);
 168             addIterator(other.m_table, this);
 169 
 170             return *this;
 171         }
 172 #endif
 173 
 174         PointerType get() const
 175         {
 176             checkValidity();
 177             return m_position;
 178         }
 179         ReferenceType operator*() const { return *get(); }
 180         PointerType operator-&gt;() const { return get(); }
 181 
 182         const_iterator&amp; operator++()
 183         {
 184             checkValidity();
 185             ASSERT(m_position != m_endPosition);
 186             ++m_position;
 187             skipEmptyBuckets();
 188             return *this;
 189         }
 190 
 191         // postfix ++ intentionally omitted
 192 
 193         // Comparison.
 194         bool operator==(const const_iterator&amp; other) const
 195         {
 196             checkValidity(other);
 197             return m_position == other.m_position;
 198         }
 199         bool operator!=(const const_iterator&amp; other) const
 200         {
 201             checkValidity(other);
 202             return m_position != other.m_position;
 203         }
 204         bool operator==(const iterator&amp; other) const
 205         {
 206             return *this == static_cast&lt;const_iterator&gt;(other);
 207         }
 208         bool operator!=(const iterator&amp; other) const
 209         {
 210             return *this != static_cast&lt;const_iterator&gt;(other);
 211         }
 212 
 213     private:
 214         void checkValidity() const
 215         {
 216 #if CHECK_HASHTABLE_ITERATORS
 217             ASSERT(m_table);
 218 #endif
 219         }
 220 
 221 
 222 #if CHECK_HASHTABLE_ITERATORS
 223         void checkValidity(const const_iterator&amp; other) const
 224         {
 225             ASSERT(m_table);
 226             ASSERT_UNUSED(other, other.m_table);
 227             ASSERT(m_table == other.m_table);
 228         }
 229 #else
 230         void checkValidity(const const_iterator&amp;) const { }
 231 #endif
 232 
 233         PointerType m_position { nullptr };
 234         PointerType m_endPosition { nullptr };
 235 
 236 #if CHECK_HASHTABLE_ITERATORS
 237     public:
 238         // Any modifications of the m_next or m_previous of an iterator that is in a linked list of a HashTable::m_iterator,
 239         // should be guarded with m_table-&gt;m_mutex.
 240         mutable const HashTableType* m_table;
 241         mutable const_iterator* m_next;
 242         mutable const_iterator* m_previous;
 243 #endif
 244     };
 245 
 246     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 247     class HashTableIterator : public std::iterator&lt;std::forward_iterator_tag, Value, std::ptrdiff_t, Value*, Value&amp;&gt; {
 248         WTF_MAKE_FAST_ALLOCATED;
 249     private:
 250         typedef HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; HashTableType;
 251         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 252         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 253         typedef Value ValueType;
 254         typedef ValueType&amp; ReferenceType;
 255         typedef ValueType* PointerType;
 256 
 257         friend class HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;;
 258 
 259         HashTableIterator(HashTableType* table, PointerType pos, PointerType end) : m_iterator(table, pos, end) { }
 260         HashTableIterator(HashTableType* table, PointerType pos, PointerType end, HashItemKnownGoodTag tag) : m_iterator(table, pos, end, tag) { }
 261 
 262     public:
 263         HashTableIterator() { }
 264 
 265         // default copy, assignment and destructor are OK
 266 
 267         PointerType get() const { return const_cast&lt;PointerType&gt;(m_iterator.get()); }
 268         ReferenceType operator*() const { return *get(); }
 269         PointerType operator-&gt;() const { return get(); }
 270 
 271         iterator&amp; operator++() { ++m_iterator; return *this; }
 272 
 273         // postfix ++ intentionally omitted
 274 
 275         // Comparison.
 276         bool operator==(const iterator&amp; other) const { return m_iterator == other.m_iterator; }
 277         bool operator!=(const iterator&amp; other) const { return m_iterator != other.m_iterator; }
 278         bool operator==(const const_iterator&amp; other) const { return m_iterator == other; }
 279         bool operator!=(const const_iterator&amp; other) const { return m_iterator != other; }
 280 
 281         operator const_iterator() const { return m_iterator; }
 282 
 283     private:
 284         const_iterator m_iterator;
 285     };
 286 
 287     template&lt;typename ValueTraits, typename HashFunctions&gt; class IdentityHashTranslator {
 288     public:
 289         template&lt;typename T&gt; static unsigned hash(const T&amp; key) { return HashFunctions::hash(key); }
 290         template&lt;typename T, typename U&gt; static bool equal(const T&amp; a, const U&amp; b) { return HashFunctions::equal(a, b); }
 291         template&lt;typename T, typename U, typename V&gt; static void translate(T&amp; location, const U&amp;, V&amp;&amp; value)
 292         {
 293             ValueTraits::assignToEmpty(location, std::forward&lt;V&gt;(value));
 294         }
 295     };
 296 
 297     template&lt;typename IteratorType&gt; struct HashTableAddResult {
 298         HashTableAddResult() : isNewEntry(false) { }
 299         HashTableAddResult(IteratorType iter, bool isNewEntry) : iterator(iter), isNewEntry(isNewEntry) { }
 300         IteratorType iterator;
 301         bool isNewEntry;
 302 
 303         explicit operator bool() const { return isNewEntry; }
 304     };
 305 
<a name="4" id="anc4"></a><span class="line-added"> 306     // HashTableCapacityForSize computes the upper power of two capacity to hold the size parameter.</span>
<span class="line-added"> 307     // This is done at compile time to initialize the HashTraits.</span>
<span class="line-added"> 308     template&lt;unsigned size&gt;</span>
<span class="line-added"> 309     struct HashTableCapacityForSize {</span>
<span class="line-added"> 310         // Load-factor for small table is 75%.</span>
<span class="line-added"> 311         static constexpr unsigned smallMaxLoadNumerator = 3;</span>
<span class="line-added"> 312         static constexpr unsigned smallMaxLoadDenominator = 4;</span>
<span class="line-added"> 313         // Load-factor for large table is 50%.</span>
<span class="line-added"> 314         static constexpr unsigned largeMaxLoadNumerator = 1;</span>
<span class="line-added"> 315         static constexpr unsigned largeMaxLoadDenominator = 2;</span>
<span class="line-added"> 316         static constexpr unsigned maxSmallTableCapacity = 1024;</span>
<span class="line-added"> 317         static constexpr unsigned minLoad = 6;</span>
<span class="line-added"> 318 </span>
<span class="line-added"> 319         static constexpr bool shouldExpand(uint64_t keyAndDeleteCount, uint64_t tableSize)</span>
<span class="line-added"> 320         {</span>
<span class="line-added"> 321             if (tableSize &lt;= maxSmallTableCapacity)</span>
<span class="line-added"> 322                 return keyAndDeleteCount * smallMaxLoadDenominator &gt;= tableSize * smallMaxLoadNumerator;</span>
<span class="line-added"> 323             return keyAndDeleteCount * largeMaxLoadDenominator &gt;= tableSize * largeMaxLoadNumerator;</span>
<span class="line-added"> 324         }</span>
<span class="line-added"> 325 </span>
<span class="line-added"> 326         static constexpr unsigned capacityForSize(uint32_t sizeArg)</span>
<span class="line-added"> 327         {</span>
<span class="line-added"> 328             if (!sizeArg)</span>
<span class="line-added"> 329                 return 0;</span>
<span class="line-added"> 330             constexpr unsigned maxCapacity = 1U &lt;&lt; 31;</span>
<span class="line-added"> 331             UNUSED_PARAM(maxCapacity);</span>
<span class="line-added"> 332             ASSERT_UNDER_CONSTEXPR_CONTEXT(sizeArg &lt;= maxCapacity);</span>
<span class="line-added"> 333             uint32_t capacity = roundUpToPowerOfTwo(sizeArg);</span>
<span class="line-added"> 334             ASSERT_UNDER_CONSTEXPR_CONTEXT(capacity &lt;= maxCapacity);</span>
<span class="line-added"> 335             if (shouldExpand(sizeArg, capacity)) {</span>
<span class="line-added"> 336                 ASSERT_UNDER_CONSTEXPR_CONTEXT((static_cast&lt;uint64_t&gt;(capacity) * 2) &lt;= maxCapacity);</span>
<span class="line-added"> 337                 return capacity * 2;</span>
<span class="line-added"> 338             }</span>
<span class="line-added"> 339             return capacity;</span>
<span class="line-added"> 340         }</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342         static constexpr unsigned value = capacityForSize(size);</span>
<span class="line-added"> 343         static_assert(size &gt; 0, &quot;HashTableNonZeroMinimumCapacity&quot;);</span>
<span class="line-added"> 344         static_assert(!static_cast&lt;unsigned&gt;(value &gt;&gt; 31), &quot;HashTableNoCapacityOverflow&quot;);</span>
<span class="line-added"> 345     };</span>
<span class="line-added"> 346 </span>
 347     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 348     class HashTable {
 349     public:
 350         typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
 351         typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
 352         typedef Traits ValueTraits;
 353         typedef Key KeyType;
 354         typedef Value ValueType;
 355         typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
 356         typedef HashTableAddResult&lt;iterator&gt; AddResult;
 357 
<a name="5" id="anc5"></a><span class="line-added"> 358         using HashTableSizePolicy = HashTableCapacityForSize&lt;1&gt;;</span>
<span class="line-added"> 359 </span>
 360 #if DUMP_HASHTABLE_STATS_PER_TABLE
 361         struct Stats {
 362             WTF_MAKE_STRUCT_FAST_ALLOCATED;
 363 
 364             Stats()
 365                 : numAccesses(0)
 366                 , numRehashes(0)
 367                 , numRemoves(0)
 368                 , numReinserts(0)
 369                 , maxCollisions(0)
 370                 , numCollisions(0)
 371                 , collisionGraph()
 372             {
 373             }
 374 
 375             unsigned numAccesses;
 376             unsigned numRehashes;
 377             unsigned numRemoves;
 378             unsigned numReinserts;
 379 
 380             unsigned maxCollisions;
 381             unsigned numCollisions;
 382             unsigned collisionGraph[4096];
 383 
 384             void recordCollisionAtCount(unsigned count)
 385             {
 386                 if (count &gt; maxCollisions)
 387                     maxCollisions = count;
 388                 numCollisions++;
 389                 collisionGraph[count]++;
 390             }
 391 
 392             void dumpStats()
 393             {
 394                 dataLogF(&quot;\nWTF::HashTable::Stats dump\n\n&quot;);
 395                 dataLogF(&quot;%d accesses\n&quot;, numAccesses);
 396                 dataLogF(&quot;%d total collisions, average %.2f probes per access\n&quot;, numCollisions, 1.0 * (numAccesses + numCollisions) / numAccesses);
 397                 dataLogF(&quot;longest collision chain: %d\n&quot;, maxCollisions);
 398                 for (unsigned i = 1; i &lt;= maxCollisions; i++) {
 399                     dataLogF(&quot;  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n&quot;, collisionGraph[i], i, 100.0 * (collisionGraph[i] - collisionGraph[i+1]) / numAccesses, 100.0 * collisionGraph[i] / numAccesses);
 400                 }
 401                 dataLogF(&quot;%d rehashes\n&quot;, numRehashes);
 402                 dataLogF(&quot;%d reinserts\n&quot;, numReinserts);
 403             }
 404         };
 405 #endif
 406 
 407         HashTable();
 408         ~HashTable()
 409         {
 410 
 411 #if PLATFORM(JAVA)
 412 #if CHECK_HASHTABLE_ITERATORS
 413             // does the same as invalidateIterators() but without
 414             // taking a lock since the destructor may be invoked
 415             // during atexit() handler which may lead to crash
 416             const_iterator* next;
 417             for (const_iterator* p = m_iterators; p; p = next) {
 418                 next = p-&gt;m_next;
 419                 p-&gt;m_table = 0;
 420                 p-&gt;m_next = 0;
 421                 p-&gt;m_previous = 0;
 422             }
 423             m_iterators = 0;
 424 #endif
 425 #else
 426             invalidateIterators();
 427 #endif
 428 
 429             if (m_table)
<a name="6" id="anc6"></a><span class="line-modified"> 430                 deallocateTable(m_table);</span>
 431 #if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
 432             m_table = (ValueType*)(uintptr_t)0xbbadbeef;
 433 #endif
 434         }
 435 
 436         HashTable(const HashTable&amp;);
 437         void swap(HashTable&amp;);
 438         HashTable&amp; operator=(const HashTable&amp;);
 439 
 440         HashTable(HashTable&amp;&amp;);
 441         HashTable&amp; operator=(HashTable&amp;&amp;);
 442 
 443         // When the hash table is empty, just return the same iterator for end as for begin.
 444         // This is more efficient because we don&#39;t have to skip all the empty and deleted
 445         // buckets, and iterating an empty table is a common case that&#39;s worth optimizing.
 446         iterator begin() { return isEmpty() ? end() : makeIterator(m_table); }
<a name="7" id="anc7"></a><span class="line-modified"> 447         iterator end() { return makeKnownGoodIterator(m_table + tableSize()); }</span>
 448         const_iterator begin() const { return isEmpty() ? end() : makeConstIterator(m_table); }
<a name="8" id="anc8"></a><span class="line-modified"> 449         const_iterator end() const { return makeKnownGoodConstIterator(m_table + tableSize()); }</span>
 450 
 451         iterator random()
 452         {
 453             if (isEmpty())
 454                 return end();
 455 
 456             while (1) {
<a name="9" id="anc9"></a><span class="line-modified"> 457                 auto&amp; bucket = m_table[weakRandomUint32() &amp; tableSizeMask()];</span>
 458                 if (!isEmptyOrDeletedBucket(bucket))
 459                     return makeKnownGoodIterator(&amp;bucket);
 460             };
 461         }
 462 
 463         const_iterator random() const { return static_cast&lt;const_iterator&gt;(const_cast&lt;HashTable*&gt;(this)-&gt;random()); }
 464 
<a name="10" id="anc10"></a><span class="line-modified"> 465         unsigned size() const { return keyCount(); }</span>
<span class="line-modified"> 466         unsigned capacity() const { return tableSize(); }</span>
<span class="line-modified"> 467         bool isEmpty() const { return !keyCount(); }</span>
 468 
 469         void reserveInitialCapacity(unsigned keyCount)
 470         {
 471             ASSERT(!m_table);
<a name="11" id="anc11"></a><span class="line-modified"> 472             ASSERT(!tableSize());</span>

 473 
 474             unsigned minimumTableSize = KeyTraits::minimumTableSize;
 475             unsigned newTableSize = std::max(minimumTableSize, computeBestTableSize(keyCount));
 476 
<a name="12" id="anc12"></a>

 477             m_table = allocateTable(newTableSize);
<a name="13" id="anc13"></a><span class="line-added"> 478             setTableSize(newTableSize);</span>
<span class="line-added"> 479             setTableSizeMask(newTableSize - 1);</span>
<span class="line-added"> 480             setDeletedCount(0);</span>
<span class="line-added"> 481             setKeyCount(0);</span>
 482         }
 483 
 484         AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); }
 485         AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); }
 486 
 487         // A special version of add() that finds the object by hashing and comparing
 488         // with some other type, to avoid the cost of type conversion if the object is already
 489         // in the table.
 490         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
 491         template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);
 492 
 493         iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); }
 494         const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); }
 495         bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); }
 496 
 497         template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
 498         template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
 499         template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;
 500 
 501         void remove(const KeyType&amp;);
 502         void remove(iterator);
 503         void removeWithoutEntryConsistencyCheck(iterator);
 504         void removeWithoutEntryConsistencyCheck(const_iterator);
 505         template&lt;typename Functor&gt;
 506         bool removeIf(const Functor&amp;);
 507         void clear();
 508 
 509         static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
 510         static bool isReleasedWeakBucket(const ValueType&amp; value) { return isHashTraitsReleasedWeakValue&lt;KeyTraits&gt;(Extractor::extract(value)); }
 511         static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); }
 512         static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); }
 513 
 514         ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); }
 515         template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
 516         template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);
 517 
<a name="14" id="anc14"></a><span class="line-modified"> 518 #if ASSERT_ENABLED</span>
 519         void checkTableConsistency() const;
 520 #else
 521         static void checkTableConsistency() { }
 522 #endif
 523 #if CHECK_HASHTABLE_CONSISTENCY
 524         void internalCheckTableConsistency() const { checkTableConsistency(); }
 525         void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }
 526 #else
 527         static void internalCheckTableConsistencyExceptSize() { }
 528         static void internalCheckTableConsistency() { }
 529 #endif
 530 
 531     private:
 532         static ValueType* allocateTable(unsigned size);
<a name="15" id="anc15"></a><span class="line-modified"> 533         static void deallocateTable(ValueType* table);</span>
 534 
 535         typedef std::pair&lt;ValueType*, bool&gt; LookupType;
 536         typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;
 537 
 538         LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); };
 539         template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
 540         template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);
 541 
 542         template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);
 543 
 544         template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);
 545 
 546         void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
 547         void removeAndInvalidate(ValueType*);
 548         void remove(ValueType*);
 549 
 550         static constexpr unsigned computeBestTableSize(unsigned keyCount);
<a name="16" id="anc16"></a><span class="line-modified"> 551         bool shouldExpand() const { return HashTableSizePolicy::shouldExpand(keyCount() + deletedCount(), tableSize()); }</span>
<span class="line-modified"> 552         bool mustRehashInPlace() const { return keyCount() * minLoad &lt; tableSize() * 2; }</span>
<span class="line-modified"> 553         bool shouldShrink() const { return keyCount() * minLoad &lt; tableSize() &amp;&amp; tableSize() &gt; KeyTraits::minimumTableSize; }</span>
 554         ValueType* expand(ValueType* entry = nullptr);
<a name="17" id="anc17"></a><span class="line-modified"> 555         void shrink() { rehash(tableSize() / 2, nullptr); }</span>
 556         void shrinkToBestSize();
 557 
 558         void deleteReleasedWeakBuckets();
 559 
 560         ValueType* rehash(unsigned newTableSize, ValueType* entry);
 561         ValueType* reinsert(ValueType&amp;&amp;);
 562 
 563         static void initializeBucket(ValueType&amp; bucket);
 564         static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); }
 565 
 566         FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
 567             { return FullLookupType(LookupType(position, found), hash); }
 568 
<a name="18" id="anc18"></a><span class="line-modified"> 569         iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + tableSize()); }</span>
<span class="line-modified"> 570         const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + tableSize()); }</span>
<span class="line-modified"> 571         iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + tableSize(), HashItemKnownGood); }</span>
<span class="line-modified"> 572         const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + tableSize(), HashItemKnownGood); }</span>
 573 
<a name="19" id="anc19"></a><span class="line-modified"> 574 #if ASSERT_ENABLED</span>
 575         void checkTableConsistencyExceptSize() const;
 576 #else
 577         static void checkTableConsistencyExceptSize() { }
 578 #endif
 579 
 580 #if CHECK_HASHTABLE_ITERATORS
 581         void invalidateIterators();
 582 #else
 583         static void invalidateIterators() { }
 584 #endif
 585 
<a name="20" id="anc20"></a><span class="line-modified"> 586         // Load-factor for small table is 75%.</span>
<span class="line-modified"> 587         static constexpr unsigned smallMaxLoadNumerator = HashTableSizePolicy::smallMaxLoadNumerator;</span>
<span class="line-modified"> 588         static constexpr unsigned smallMaxLoadDenominator = HashTableSizePolicy::smallMaxLoadDenominator;</span>
<span class="line-modified"> 589         // Load-factor for large table is 50%.</span>
<span class="line-modified"> 590         static constexpr unsigned largeMaxLoadNumerator = HashTableSizePolicy::largeMaxLoadNumerator;</span>
<span class="line-modified"> 591         static constexpr unsigned largeMaxLoadDenominator = HashTableSizePolicy::largeMaxLoadDenominator;</span>
<span class="line-modified"> 592         static constexpr unsigned maxSmallTableCapacity = HashTableSizePolicy::maxSmallTableCapacity;</span>
<span class="line-modified"> 593         static constexpr unsigned minLoad = HashTableSizePolicy::minLoad;</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595         static constexpr int tableSizeOffset = -1;</span>
<span class="line-added"> 596         static constexpr int tableSizeMaskOffset = -2;</span>
<span class="line-added"> 597         static constexpr int keyCountOffset = -3;</span>
<span class="line-added"> 598         static constexpr int deletedCountOffset = -4;</span>
<span class="line-added"> 599         static constexpr unsigned metadataSize = 4 * sizeof(unsigned);</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601         unsigned tableSize() const { return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeOffset] : 0; }</span>
<span class="line-added"> 602         void setTableSize(unsigned size) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeOffset] = size; }</span>
<span class="line-added"> 603         unsigned tableSizeMask() const { ASSERT(m_table); return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeMaskOffset] : 0; }</span>
<span class="line-added"> 604         void setTableSizeMask(unsigned mask) { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[tableSizeMaskOffset] = mask; }</span>
<span class="line-added"> 605         unsigned keyCount() const { return m_table ? reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[keyCountOffset] : 0; }</span>
<span class="line-added"> 606         void setKeyCount(unsigned count) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[keyCountOffset] = count; }</span>
<span class="line-added"> 607         unsigned deletedCount() const { ASSERT(m_table); return reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[deletedCountOffset]; }</span>
<span class="line-added"> 608         void setDeletedCount(unsigned count) const { ASSERT(m_table); reinterpret_cast_ptr&lt;unsigned*&gt;(m_table)[deletedCountOffset] = count; }</span>
<span class="line-added"> 609 </span>
<span class="line-added"> 610         ValueType* m_table { nullptr };</span>
 611 
 612 #if CHECK_HASHTABLE_ITERATORS
 613     public:
 614         // All access to m_iterators should be guarded with m_mutex.
 615         mutable const_iterator* m_iterators;
 616         // Use std::unique_ptr so HashTable can still be memmove&#39;d or memcpy&#39;ed.
 617         mutable std::unique_ptr&lt;Lock&gt; m_mutex;
 618 #endif
 619 
 620 #if DUMP_HASHTABLE_STATS_PER_TABLE
 621     public:
 622         mutable std::unique_ptr&lt;Stats&gt; m_stats;
 623 #endif
 624     };
 625 
<a name="21" id="anc21"></a>





































 626     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 627     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable()
<a name="22" id="anc22"></a><span class="line-modified"> 628         : m_table(nullptr)</span>




 629 #if CHECK_HASHTABLE_ITERATORS
 630         , m_iterators(0)
 631         , m_mutex(makeUnique&lt;Lock&gt;())
 632 #endif
 633 #if DUMP_HASHTABLE_STATS_PER_TABLE
 634         , m_stats(makeUnique&lt;Stats&gt;())
 635 #endif
 636     {
 637     }
 638 
 639     inline unsigned doubleHash(unsigned key)
 640     {
 641         key = ~key + (key &gt;&gt; 23);
 642         key ^= (key &lt;&lt; 12);
 643         key ^= (key &gt;&gt; 7);
 644         key ^= (key &lt;&lt; 2);
 645         key ^= (key &gt;&gt; 20);
 646         return key;
 647     }
 648 
<a name="23" id="anc23"></a><span class="line-modified"> 649 #if !ASSERT_ENABLED</span>
 650 
 651     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 652     template&lt;typename HashTranslator, typename T&gt;
 653     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp;)
 654     {
 655     }
 656 
<a name="24" id="anc24"></a><span class="line-modified"> 657 #else // ASSERT_ENABLED</span>
 658 
 659     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 660     template&lt;typename HashTranslator, typename T&gt;
 661     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkKey(const T&amp; key)
 662     {
 663         if (!HashFunctions::safeToCompareToEmptyOrDeleted)
 664             return;
 665         ASSERT(!HashTranslator::equal(KeyTraits::emptyValue(), key));
 666         typename std::aligned_storage&lt;sizeof(ValueType), std::alignment_of&lt;ValueType&gt;::value&gt;::type deletedValueBuffer;
 667         ValueType* deletedValuePtr = reinterpret_cast_ptr&lt;ValueType*&gt;(&amp;deletedValueBuffer);
 668         ValueType&amp; deletedValue = *deletedValuePtr;
 669         Traits::constructDeletedValue(deletedValue);
 670         ASSERT(!HashTranslator::equal(Extractor::extract(deletedValue), key));
 671     }
 672 
<a name="25" id="anc25"></a><span class="line-modified"> 673 #endif // ASSERT_ENABLED</span>
 674 
 675     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 676     template&lt;typename HashTranslator, typename T&gt;
 677     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookup(const T&amp; key) -&gt; ValueType*
 678     {
 679         return inlineLookup&lt;HashTranslator&gt;(key);
 680     }
 681 
 682     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 683     template&lt;typename HashTranslator, typename T&gt;
 684     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::inlineLookup(const T&amp; key) -&gt; ValueType*
 685     {
 686         checkKey&lt;HashTranslator&gt;(key);
 687 
 688         unsigned k = 0;
<a name="26" id="anc26"></a>
 689         ValueType* table = m_table;
<a name="27" id="anc27"></a><span class="line-added"> 690         if (!table)</span>
<span class="line-added"> 691             return nullptr;</span>
<span class="line-added"> 692 </span>
<span class="line-added"> 693         unsigned sizeMask = tableSizeMask();</span>
 694         unsigned h = HashTranslator::hash(key);
 695         unsigned i = h &amp; sizeMask;
 696 
<a name="28" id="anc28"></a>


 697 #if DUMP_HASHTABLE_STATS
 698         ++HashTableStats::numAccesses;
 699         unsigned probeCount = 0;
 700 #endif
 701 
 702 #if DUMP_HASHTABLE_STATS_PER_TABLE
 703         ++m_stats-&gt;numAccesses;
 704 #endif
 705 
 706         while (1) {
 707             ValueType* entry = table + i;
 708 
 709             // we count on the compiler to optimize out this branch
 710             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 711                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 712                     return entry;
 713 
 714                 if (isEmptyBucket(*entry))
 715                     return 0;
 716             } else {
 717                 if (isEmptyBucket(*entry))
 718                     return 0;
 719 
 720                 if (!isDeletedBucket(*entry) &amp;&amp; HashTranslator::equal(Extractor::extract(*entry), key))
 721                     return entry;
 722             }
 723 #if DUMP_HASHTABLE_STATS
 724             ++probeCount;
 725             HashTableStats::recordCollisionAtCount(probeCount);
 726 #endif
 727 
 728 #if DUMP_HASHTABLE_STATS_PER_TABLE
 729             m_stats-&gt;recordCollisionAtCount(probeCount);
 730 #endif
 731 
 732             if (k == 0)
 733                 k = 1 | doubleHash(h);
 734             i = (i + k) &amp; sizeMask;
 735         }
 736     }
 737 
 738     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 739     template&lt;typename HashTranslator, typename T&gt;
 740     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::lookupForWriting(const T&amp; key) -&gt; LookupType
 741     {
 742         ASSERT(m_table);
 743         checkKey&lt;HashTranslator&gt;(key);
 744 
 745         unsigned k = 0;
 746         ValueType* table = m_table;
<a name="29" id="anc29"></a><span class="line-modified"> 747         unsigned sizeMask = tableSizeMask();</span>
 748         unsigned h = HashTranslator::hash(key);
 749         unsigned i = h &amp; sizeMask;
 750 
 751 #if DUMP_HASHTABLE_STATS
 752         ++HashTableStats::numAccesses;
 753         unsigned probeCount = 0;
 754 #endif
 755 
 756 #if DUMP_HASHTABLE_STATS_PER_TABLE
 757         ++m_stats-&gt;numAccesses;
 758 #endif
 759 
 760         ValueType* deletedEntry = 0;
 761 
 762         while (1) {
 763             ValueType* entry = table + i;
 764 
 765             // we count on the compiler to optimize out this branch
 766             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 767                 if (isEmptyBucket(*entry))
 768                     return LookupType(deletedEntry ? deletedEntry : entry, false);
 769 
 770                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 771                     return LookupType(entry, true);
 772 
 773                 if (isDeletedBucket(*entry))
 774                     deletedEntry = entry;
 775             } else {
 776                 if (isEmptyBucket(*entry))
 777                     return LookupType(deletedEntry ? deletedEntry : entry, false);
 778 
 779                 if (isDeletedBucket(*entry))
 780                     deletedEntry = entry;
 781                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 782                     return LookupType(entry, true);
 783             }
 784 #if DUMP_HASHTABLE_STATS
 785             ++probeCount;
 786             HashTableStats::recordCollisionAtCount(probeCount);
 787 #endif
 788 
 789 #if DUMP_HASHTABLE_STATS_PER_TABLE
 790             m_stats-&gt;recordCollisionAtCount(probeCount);
 791 #endif
 792 
 793             if (k == 0)
 794                 k = 1 | doubleHash(h);
 795             i = (i + k) &amp; sizeMask;
 796         }
 797     }
 798 
 799     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 800     template&lt;typename HashTranslator, typename T&gt;
 801     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::fullLookupForWriting(const T&amp; key) -&gt; FullLookupType
 802     {
 803         ASSERT(m_table);
 804         checkKey&lt;HashTranslator&gt;(key);
 805 
 806         unsigned k = 0;
 807         ValueType* table = m_table;
<a name="30" id="anc30"></a><span class="line-modified"> 808         unsigned sizeMask = tableSizeMask();</span>
 809         unsigned h = HashTranslator::hash(key);
 810         unsigned i = h &amp; sizeMask;
 811 
 812 #if DUMP_HASHTABLE_STATS
 813         ++HashTableStats::numAccesses;
 814         unsigned probeCount = 0;
 815 #endif
 816 
 817 #if DUMP_HASHTABLE_STATS_PER_TABLE
 818         ++m_stats-&gt;numAccesses;
 819 #endif
 820 
 821         ValueType* deletedEntry = 0;
 822 
 823         while (1) {
 824             ValueType* entry = table + i;
 825 
 826             // we count on the compiler to optimize out this branch
 827             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 828                 if (isEmptyBucket(*entry))
 829                     return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);
 830 
 831                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 832                     return makeLookupResult(entry, true, h);
 833 
 834                 if (isDeletedBucket(*entry))
 835                     deletedEntry = entry;
 836             } else {
 837                 if (isEmptyBucket(*entry))
 838                     return makeLookupResult(deletedEntry ? deletedEntry : entry, false, h);
 839 
 840                 if (isDeletedBucket(*entry))
 841                     deletedEntry = entry;
 842                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 843                     return makeLookupResult(entry, true, h);
 844             }
 845 #if DUMP_HASHTABLE_STATS
 846             ++probeCount;
 847             HashTableStats::recordCollisionAtCount(probeCount);
 848 #endif
 849 
 850 #if DUMP_HASHTABLE_STATS_PER_TABLE
 851             m_stats-&gt;recordCollisionAtCount(probeCount);
 852 #endif
 853 
 854             if (k == 0)
 855                 k = 1 | doubleHash(h);
 856             i = (i + k) &amp; sizeMask;
 857         }
 858     }
 859 
 860     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 861     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 862     ALWAYS_INLINE void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp; extra)
 863     {
 864         ASSERT(m_table);
 865 
 866         checkKey&lt;HashTranslator&gt;(key);
 867 
 868         invalidateIterators();
 869 
 870         internalCheckTableConsistency();
 871 
 872         unsigned k = 0;
 873         ValueType* table = m_table;
<a name="31" id="anc31"></a><span class="line-modified"> 874         unsigned sizeMask = tableSizeMask();</span>
 875         unsigned h = HashTranslator::hash(key);
 876         unsigned i = h &amp; sizeMask;
 877 
 878 #if DUMP_HASHTABLE_STATS
 879         ++HashTableStats::numAccesses;
 880         unsigned probeCount = 0;
 881 #endif
 882 
 883 #if DUMP_HASHTABLE_STATS_PER_TABLE
 884         ++m_stats-&gt;numAccesses;
 885 #endif
 886 
 887         ValueType* entry;
 888         while (1) {
 889             entry = table + i;
 890 
 891             if (isEmptyBucket(*entry))
 892                 break;
 893 
 894 #if DUMP_HASHTABLE_STATS
 895             ++probeCount;
 896             HashTableStats::recordCollisionAtCount(probeCount);
 897 #endif
 898 
 899 #if DUMP_HASHTABLE_STATS_PER_TABLE
 900             m_stats-&gt;recordCollisionAtCount(probeCount);
 901 #endif
 902 
 903             if (k == 0)
 904                 k = 1 | doubleHash(h);
 905             i = (i + k) &amp; sizeMask;
 906         }
 907 
 908         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
 909 
 910         internalCheckTableConsistency();
 911     }
 912 
 913     template&lt;bool emptyValueIsZero&gt; struct HashTableBucketInitializer;
 914 
 915     template&lt;&gt; struct HashTableBucketInitializer&lt;false&gt; {
 916         template&lt;typename Traits, typename Value&gt; static void initialize(Value&amp; bucket)
 917         {
 918             Traits::template constructEmptyValue&lt;Traits&gt;(bucket);
 919         }
 920     };
 921 
 922     template&lt;&gt; struct HashTableBucketInitializer&lt;true&gt; {
 923         template&lt;typename Traits, typename Value&gt; static void initialize(Value&amp; bucket)
 924         {
 925             // This initializes the bucket without copying the empty value.
 926             // That makes it possible to use this with types that don&#39;t support copying.
 927             // The memset to 0 looks like a slow operation but is optimized by the compilers.
 928             memset(static_cast&lt;void*&gt;(std::addressof(bucket)), 0, sizeof(bucket));
 929         }
 930     };
 931 
 932     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 933     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::initializeBucket(ValueType&amp; bucket)
 934     {
 935         HashTableBucketInitializer&lt;Traits::emptyValueIsZero&gt;::template initialize&lt;Traits&gt;(bucket);
 936     }
 937 
 938     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
 939     template&lt;typename HashTranslator, typename T, typename Extra&gt;
 940     ALWAYS_INLINE auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::add(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
 941     {
 942         checkKey&lt;HashTranslator&gt;(key);
 943 
 944         invalidateIterators();
 945 
 946         if (!m_table)
 947             expand(nullptr);
 948 
 949         internalCheckTableConsistency();
 950 
 951         ASSERT(m_table);
 952 
 953         unsigned k = 0;
 954         ValueType* table = m_table;
<a name="32" id="anc32"></a><span class="line-modified"> 955         unsigned sizeMask = tableSizeMask();</span>
 956         unsigned h = HashTranslator::hash(key);
 957         unsigned i = h &amp; sizeMask;
 958 
 959 #if DUMP_HASHTABLE_STATS
 960         ++HashTableStats::numAccesses;
 961         unsigned probeCount = 0;
 962 #endif
 963 
 964 #if DUMP_HASHTABLE_STATS_PER_TABLE
 965         ++m_stats-&gt;numAccesses;
 966 #endif
 967 
 968         ValueType* deletedEntry = 0;
 969         ValueType* entry;
 970         while (1) {
 971             entry = table + i;
 972 
 973             // we count on the compiler to optimize out this branch
 974             if (HashFunctions::safeToCompareToEmptyOrDeleted) {
 975                 if (isEmptyBucket(*entry))
 976                     break;
 977 
 978                 if (HashTranslator::equal(Extractor::extract(*entry), key))
 979                     return AddResult(makeKnownGoodIterator(entry), false);
 980 
 981                 if (isDeletedBucket(*entry))
 982                     deletedEntry = entry;
 983             } else {
 984                 if (isEmptyBucket(*entry))
 985                     break;
 986 
 987                 if (isDeletedBucket(*entry))
 988                     deletedEntry = entry;
 989                 else if (HashTranslator::equal(Extractor::extract(*entry), key))
 990                     return AddResult(makeKnownGoodIterator(entry), false);
 991             }
 992 #if DUMP_HASHTABLE_STATS
 993             ++probeCount;
 994             HashTableStats::recordCollisionAtCount(probeCount);
 995 #endif
 996 
 997 #if DUMP_HASHTABLE_STATS_PER_TABLE
 998             m_stats-&gt;recordCollisionAtCount(probeCount);
 999 #endif
1000 
1001             if (k == 0)
1002                 k = 1 | doubleHash(h);
1003             i = (i + k) &amp; sizeMask;
1004         }
1005 
1006         if (deletedEntry) {
1007             initializeBucket(*deletedEntry);
1008             entry = deletedEntry;
<a name="33" id="anc33"></a><span class="line-modified">1009             setDeletedCount(deletedCount() - 1);</span>
1010         }
1011 
1012         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra));
<a name="34" id="anc34"></a><span class="line-modified">1013         setKeyCount(keyCount() + 1);</span>
1014 
1015         if (shouldExpand())
1016             entry = expand(entry);
1017 
1018         internalCheckTableConsistency();
1019 
1020         return AddResult(makeKnownGoodIterator(entry), true);
1021     }
1022 
1023     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1024     template&lt;typename HashTranslator, typename T, typename Extra&gt;
1025     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp; extra) -&gt; AddResult
1026     {
1027         checkKey&lt;HashTranslator&gt;(key);
1028 
1029         invalidateIterators();
1030 
1031         if (!m_table)
1032             expand();
1033 
1034         internalCheckTableConsistency();
1035 
1036         FullLookupType lookupResult = fullLookupForWriting&lt;HashTranslator&gt;(key);
1037 
1038         ValueType* entry = lookupResult.first.first;
1039         bool found = lookupResult.first.second;
1040         unsigned h = lookupResult.second;
1041 
1042         if (found)
1043             return AddResult(makeKnownGoodIterator(entry), false);
1044 
1045         if (isDeletedBucket(*entry)) {
1046             initializeBucket(*entry);
<a name="35" id="anc35"></a><span class="line-modified">1047             setDeletedCount(deletedCount() - 1);</span>
1048         }
1049 
1050         HashTranslator::translate(*entry, std::forward&lt;T&gt;(key), std::forward&lt;Extra&gt;(extra), h);
<a name="36" id="anc36"></a><span class="line-modified">1051         setKeyCount(keyCount() + 1);</span>
1052 
1053         if (shouldExpand())
1054             entry = expand(entry);
1055 
1056         internalCheckTableConsistency();
1057 
1058         return AddResult(makeKnownGoodIterator(entry), true);
1059     }
1060 
1061     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1062     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::reinsert(ValueType&amp;&amp; entry) -&gt; ValueType*
1063     {
1064         ASSERT(m_table);
1065         ASSERT(!lookupForWriting(Extractor::extract(entry)).second);
1066         ASSERT(!isDeletedBucket(*(lookupForWriting(Extractor::extract(entry)).first)));
1067 #if DUMP_HASHTABLE_STATS
1068         ++HashTableStats::numReinserts;
1069 #endif
1070 #if DUMP_HASHTABLE_STATS_PER_TABLE
1071         ++m_stats-&gt;numReinserts;
1072 #endif
1073 
1074         Value* newEntry = lookupForWriting(Extractor::extract(entry)).first;
1075         newEntry-&gt;~Value();
1076         new (NotNull, newEntry) ValueType(WTFMove(entry));
1077 
1078         return newEntry;
1079     }
1080 
1081     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1082     template &lt;typename HashTranslator, typename T&gt;
1083     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::find(const T&amp; key) -&gt; iterator
1084     {
1085         if (!m_table)
1086             return end();
1087 
1088         ValueType* entry = lookup&lt;HashTranslator&gt;(key);
1089         if (!entry)
1090             return end();
1091 
1092         return makeKnownGoodIterator(entry);
1093     }
1094 
1095     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1096     template &lt;typename HashTranslator, typename T&gt;
1097     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::find(const T&amp; key) const -&gt; const_iterator
1098     {
1099         if (!m_table)
1100             return end();
1101 
1102         ValueType* entry = const_cast&lt;HashTable*&gt;(this)-&gt;lookup&lt;HashTranslator&gt;(key);
1103         if (!entry)
1104             return end();
1105 
1106         return makeKnownGoodConstIterator(entry);
1107     }
1108 
1109     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1110     template &lt;typename HashTranslator, typename T&gt;
1111     bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::contains(const T&amp; key) const
1112     {
1113         if (!m_table)
1114             return false;
1115 
1116         return const_cast&lt;HashTable*&gt;(this)-&gt;lookup&lt;HashTranslator&gt;(key);
1117     }
1118 
1119     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1120     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidateWithoutEntryConsistencyCheck(ValueType* pos)
1121     {
1122         invalidateIterators();
1123         remove(pos);
1124     }
1125 
1126     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1127     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeAndInvalidate(ValueType* pos)
1128     {
1129         invalidateIterators();
1130         internalCheckTableConsistency();
1131         remove(pos);
1132     }
1133 
1134     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1135     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(ValueType* pos)
1136     {
1137 #if DUMP_HASHTABLE_STATS
1138         ++HashTableStats::numRemoves;
1139 #endif
1140 #if DUMP_HASHTABLE_STATS_PER_TABLE
1141         ++m_stats-&gt;numRemoves;
1142 #endif
1143 
1144         deleteBucket(*pos);
<a name="37" id="anc37"></a><span class="line-modified">1145         setDeletedCount(deletedCount() + 1);</span>
<span class="line-modified">1146         setKeyCount(keyCount() - 1);</span>
1147 
1148         if (shouldShrink())
1149             shrink();
1150 
1151         internalCheckTableConsistency();
1152     }
1153 
1154     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1155     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(iterator it)
1156     {
1157         if (it == end())
1158             return;
1159 
1160         removeAndInvalidate(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1161     }
1162 
1163     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1164     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(iterator it)
1165     {
1166         if (it == end())
1167             return;
1168 
1169         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_iterator.m_position));
1170     }
1171 
1172     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1173     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeWithoutEntryConsistencyCheck(const_iterator it)
1174     {
1175         if (it == end())
1176             return;
1177 
1178         removeAndInvalidateWithoutEntryConsistencyCheck(const_cast&lt;ValueType*&gt;(it.m_position));
1179     }
1180 
1181     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1182     inline void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::remove(const KeyType&amp; key)
1183     {
1184         remove(find(key));
1185     }
1186 
1187     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1188     template&lt;typename Functor&gt;
1189     inline bool HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::removeIf(const Functor&amp; functor)
1190     {
1191         // We must use local copies in case &quot;functor&quot; or &quot;deleteBucket&quot;
1192         // make a function call, which prevents the compiler from keeping
1193         // the values in register.
1194         unsigned removedBucketCount = 0;
1195         ValueType* table = m_table;
1196 
<a name="38" id="anc38"></a><span class="line-modified">1197         for (unsigned i = tableSize(); i--;) {</span>
1198             ValueType&amp; bucket = table[i];
1199             if (isEmptyOrDeletedBucket(bucket))
1200                 continue;
1201 
1202             if (!functor(bucket))
1203                 continue;
1204 
1205             deleteBucket(bucket);
1206             ++removedBucketCount;
1207         }
<a name="39" id="anc39"></a><span class="line-modified">1208         if (removedBucketCount) {</span>
<span class="line-modified">1209             setDeletedCount(deletedCount() + removedBucketCount);</span>
<span class="line-added">1210             setKeyCount(keyCount() - removedBucketCount);</span>
<span class="line-added">1211         }</span>
1212 
1213         if (shouldShrink())
1214             shrinkToBestSize();
1215 
1216         internalCheckTableConsistency();
1217         return removedBucketCount;
1218     }
1219 
1220     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1221     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::allocateTable(unsigned size) -&gt; ValueType*
1222     {
<a name="40" id="anc40"></a><span class="line-added">1223         static_assert(!(metadataSize % alignof(ValueType)));</span>
<span class="line-added">1224 </span>
1225         // would use a template member function with explicit specializations here, but
1226         // gcc doesn&#39;t appear to support that
1227         if (Traits::emptyValueIsZero)
<a name="41" id="anc41"></a><span class="line-modified">1228             return reinterpret_cast_ptr&lt;ValueType*&gt;(static_cast&lt;char*&gt;(HashTableMalloc::zeroedMalloc(metadataSize + size * sizeof(ValueType))) + metadataSize);</span>
<span class="line-modified">1229 </span>
<span class="line-added">1230         ValueType* result = reinterpret_cast_ptr&lt;ValueType*&gt;(static_cast&lt;char*&gt;(HashTableMalloc::malloc(metadataSize + size * sizeof(ValueType))) + metadataSize);</span>
1231         for (unsigned i = 0; i &lt; size; i++)
1232             initializeBucket(result[i]);
1233         return result;
1234     }
1235 
1236     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
<a name="42" id="anc42"></a><span class="line-modified">1237     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deallocateTable(ValueType* table)</span>
1238     {
<a name="43" id="anc43"></a><span class="line-added">1239         unsigned size = reinterpret_cast_ptr&lt;unsigned*&gt;(table)[tableSizeOffset];</span>
1240         for (unsigned i = 0; i &lt; size; ++i) {
1241             if (!isDeletedBucket(table[i]))
1242                 table[i].~ValueType();
1243         }
<a name="44" id="anc44"></a><span class="line-modified">1244         HashTableMalloc::free(reinterpret_cast&lt;char*&gt;(table) - metadataSize);</span>
1245     }
1246 
1247     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1248     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::expand(ValueType* entry) -&gt; ValueType*
1249     {
1250         if (KeyTraits::hasIsReleasedWeakValueFunction)
1251             deleteReleasedWeakBuckets();
1252 
1253         unsigned newSize;
<a name="45" id="anc45"></a><span class="line-modified">1254         unsigned oldSize = tableSize();</span>
<span class="line-added">1255         if (!oldSize)</span>
1256             newSize = KeyTraits::minimumTableSize;
1257         else if (mustRehashInPlace())
<a name="46" id="anc46"></a><span class="line-modified">1258             newSize = oldSize;</span>
1259         else
<a name="47" id="anc47"></a><span class="line-modified">1260             newSize = oldSize * 2;</span>
1261 
1262         return rehash(newSize, entry);
1263     }
1264 
1265     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1266     constexpr unsigned HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::computeBestTableSize(unsigned keyCount)
1267     {
<a name="48" id="anc48"></a><span class="line-modified">1268         unsigned bestTableSize = WTF::roundUpToPowerOfTwo(keyCount);</span>
1269 
<a name="49" id="anc49"></a><span class="line-modified">1270         if (HashTableSizePolicy::shouldExpand(keyCount, bestTableSize))</span>




1271             bestTableSize *= 2;
1272 
<a name="50" id="anc50"></a><span class="line-added">1273         auto aboveThresholdForEagerExpansion = [](double loadFactor, unsigned keyCount, unsigned tableSize)</span>
<span class="line-added">1274         {</span>
<span class="line-added">1275             // Here is the rationale behind this calculation, using 3/4 load-factor.</span>
<span class="line-added">1276             // With maxLoad at 3/4 and minLoad at 1/6, our average load is 11/24.</span>
<span class="line-added">1277             // If we are getting half-way between 11/24 and 3/4, we double the size</span>
<span class="line-added">1278             // to avoid being too close to loadMax and bring the ratio close to 11/24. This</span>
<span class="line-added">1279             // give us a load in the bounds [9/24, 15/24).</span>
<span class="line-added">1280             double maxLoadRatio = loadFactor;</span>
<span class="line-added">1281             double minLoadRatio = 1.0 / minLoad;</span>
<span class="line-added">1282             double averageLoadRatio = (maxLoadRatio + minLoadRatio) / 2;</span>
<span class="line-added">1283             double halfWayBetweenAverageAndMaxLoadRatio = (averageLoadRatio + maxLoadRatio) / 2;</span>
<span class="line-added">1284             return keyCount &gt;= tableSize * halfWayBetweenAverageAndMaxLoadRatio;</span>
<span class="line-added">1285         };</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         if (bestTableSize &lt;= maxSmallTableCapacity) {</span>
<span class="line-added">1288             constexpr double smallLoadFactor = static_cast&lt;double&gt;(smallMaxLoadNumerator) / smallMaxLoadDenominator;</span>
<span class="line-added">1289             if (aboveThresholdForEagerExpansion(smallLoadFactor, keyCount, bestTableSize))</span>
<span class="line-added">1290                 bestTableSize *= 2;</span>
<span class="line-added">1291         } else {</span>
<span class="line-added">1292             constexpr double largeLoadFactor = static_cast&lt;double&gt;(largeMaxLoadNumerator) / largeMaxLoadDenominator;</span>
<span class="line-added">1293             if (aboveThresholdForEagerExpansion(largeLoadFactor, keyCount, bestTableSize))</span>
<span class="line-added">1294                 bestTableSize *= 2;</span>
<span class="line-added">1295         }</span>
1296         unsigned minimumTableSize = KeyTraits::minimumTableSize;
1297         return std::max(bestTableSize, minimumTableSize);
1298     }
1299 
1300     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1301     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::shrinkToBestSize()
1302     {
1303         unsigned minimumTableSize = KeyTraits::minimumTableSize;
<a name="51" id="anc51"></a><span class="line-modified">1304         rehash(std::max(minimumTableSize, computeBestTableSize(keyCount())), nullptr);</span>
1305     }
1306 
1307     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1308     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::deleteReleasedWeakBuckets()
1309     {
<a name="52" id="anc52"></a><span class="line-modified">1310         unsigned tableSize = this-&gt;tableSize();</span>
<span class="line-added">1311         for (unsigned i = 0; i &lt; tableSize; ++i) {</span>
1312             auto&amp; entry = m_table[i];
1313             if (isReleasedWeakBucket(entry)) {
1314                 deleteBucket(entry);
<a name="53" id="anc53"></a><span class="line-modified">1315                 setDeletedCount(deletedCount() + 1);</span>
<span class="line-modified">1316                 setKeyCount(keyCount() - 1);</span>
1317             }
1318         }
1319     }
1320 
1321     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1322     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::rehash(unsigned newTableSize, ValueType* entry) -&gt; ValueType*
1323     {
1324         internalCheckTableConsistencyExceptSize();
1325 
<a name="54" id="anc54"></a><span class="line-modified">1326         unsigned oldTableSize = tableSize();</span>
1327         ValueType* oldTable = m_table;
1328 
1329 #if DUMP_HASHTABLE_STATS
1330         if (oldTableSize != 0)
1331             ++HashTableStats::numRehashes;
1332 #endif
1333 
1334 #if DUMP_HASHTABLE_STATS_PER_TABLE
1335         if (oldTableSize != 0)
1336             ++m_stats-&gt;numRehashes;
1337 #endif
1338 
<a name="55" id="anc55"></a><span class="line-modified">1339         unsigned oldKeyCount = keyCount();</span>

1340         m_table = allocateTable(newTableSize);
<a name="56" id="anc56"></a><span class="line-added">1341         setTableSize(newTableSize);</span>
<span class="line-added">1342         setTableSizeMask(newTableSize - 1);</span>
<span class="line-added">1343         setDeletedCount(0);</span>
<span class="line-added">1344         setKeyCount(oldKeyCount);</span>
1345 
1346         Value* newEntry = nullptr;
1347         for (unsigned i = 0; i != oldTableSize; ++i) {
1348             auto&amp; oldEntry = oldTable[i];
1349             if (isDeletedBucket(oldEntry)) {
1350                 ASSERT(std::addressof(oldEntry) != entry);
1351                 continue;
1352             }
1353 
1354             if (isEmptyBucket(oldEntry)) {
1355                 ASSERT(std::addressof(oldEntry) != entry);
1356                 oldTable[i].~ValueType();
1357                 continue;
1358             }
1359 
1360             if (isReleasedWeakBucket(oldEntry)) {
1361                 ASSERT(std::addressof(oldEntry) != entry);
1362                 oldEntry.~ValueType();
<a name="57" id="anc57"></a><span class="line-modified">1363                 setKeyCount(keyCount() - 1);</span>
1364                 continue;
1365             }
1366 
1367             Value* reinsertedEntry = reinsert(WTFMove(oldEntry));
1368             oldEntry.~ValueType();
1369             if (std::addressof(oldEntry) == entry) {
1370                 ASSERT(!newEntry);
1371                 newEntry = reinsertedEntry;
1372             }
1373         }
1374 
<a name="58" id="anc58"></a><span class="line-modified">1375         if (oldTable)</span>
<span class="line-modified">1376             HashTableMalloc::free(reinterpret_cast&lt;char*&gt;(oldTable) - metadataSize);</span>

1377 
1378         internalCheckTableConsistency();
1379         return newEntry;
1380     }
1381 
1382     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1383     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::clear()
1384     {
1385         invalidateIterators();
1386         if (!m_table)
1387             return;
1388 
<a name="59" id="anc59"></a><span class="line-modified">1389         deallocateTable(m_table);</span>
<span class="line-modified">1390         m_table = nullptr;</span>




1391     }
1392 
1393     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1394     HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(const HashTable&amp; other)
1395         : m_table(nullptr)
<a name="60" id="anc60"></a>



1396 #if CHECK_HASHTABLE_ITERATORS
1397         , m_iterators(nullptr)
1398         , m_mutex(makeUnique&lt;Lock&gt;())
1399 #endif
1400 #if DUMP_HASHTABLE_STATS_PER_TABLE
1401         , m_stats(makeUnique&lt;Stats&gt;(*other.m_stats))
1402 #endif
1403     {
1404         unsigned otherKeyCount = other.size();
1405         if (!otherKeyCount)
1406             return;
1407 
<a name="61" id="anc61"></a><span class="line-modified">1408         unsigned bestTableSize = computeBestTableSize(otherKeyCount);</span>
<span class="line-modified">1409         m_table = allocateTable(bestTableSize);</span>
<span class="line-modified">1410         setTableSize(bestTableSize);</span>
<span class="line-modified">1411         setTableSizeMask(bestTableSize - 1);</span>
<span class="line-added">1412         setKeyCount(otherKeyCount);</span>
<span class="line-added">1413         setDeletedCount(0);</span>
1414 
1415         for (const auto&amp; otherValue : other)
1416             addUniqueForInitialization&lt;IdentityTranslatorType&gt;(Extractor::extract(otherValue), otherValue);
1417     }
1418 
1419     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1420     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::swap(HashTable&amp; other)
1421     {
1422         invalidateIterators();
1423         other.invalidateIterators();
1424 
1425         std::swap(m_table, other.m_table);
<a name="62" id="anc62"></a>



1426 
1427 #if DUMP_HASHTABLE_STATS_PER_TABLE
1428         m_stats.swap(other.m_stats);
1429 #endif
1430     }
1431 
1432     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1433     auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(const HashTable&amp; other) -&gt; HashTable&amp;
1434     {
1435         HashTable tmp(other);
1436         swap(tmp);
1437         return *this;
1438     }
1439 
1440     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1441     inline HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::HashTable(HashTable&amp;&amp; other)
1442 #if CHECK_HASHTABLE_ITERATORS
1443         : m_iterators(nullptr)
1444         , m_mutex(makeUnique&lt;Lock&gt;())
1445 #endif
1446     {
1447         other.invalidateIterators();
1448 
<a name="63" id="anc63"></a><span class="line-modified">1449         m_table = std::exchange(other.m_table, nullptr);</span>










1450 
1451 #if DUMP_HASHTABLE_STATS_PER_TABLE
1452         m_stats = WTFMove(other.m_stats);
1453         other.m_stats = nullptr;
1454 #endif
1455     }
1456 
1457     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1458     inline auto HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::operator=(HashTable&amp;&amp; other) -&gt; HashTable&amp;
1459     {
1460         HashTable temp = WTFMove(other);
1461         swap(temp);
1462         return *this;
1463     }
1464 
<a name="64" id="anc64"></a><span class="line-modified">1465 #if ASSERT_ENABLED</span>
1466 
1467     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1468     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistency() const
1469     {
1470         checkTableConsistencyExceptSize();
1471         ASSERT(!m_table || !shouldExpand());
1472         ASSERT(!shouldShrink());
1473     }
1474 
1475     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1476     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::checkTableConsistencyExceptSize() const
1477     {
1478         if (!m_table)
1479             return;
1480 
1481         unsigned count = 0;
1482         unsigned deletedCount = 0;
<a name="65" id="anc65"></a><span class="line-modified">1483         unsigned tableSize = this-&gt;tableSize();</span>
<span class="line-added">1484         for (unsigned j = 0; j &lt; tableSize; ++j) {</span>
1485             ValueType* entry = m_table + j;
1486             if (isEmptyBucket(*entry))
1487                 continue;
1488 
1489             if (isDeletedBucket(*entry)) {
1490                 ++deletedCount;
1491                 continue;
1492             }
1493 
1494             auto&amp; key = Extractor::extract(*entry);
1495             const_iterator it = find(key);
1496             ASSERT(entry == it.m_position);
1497             ++count;
1498 
1499             ValueCheck&lt;Key&gt;::checkConsistency(key);
1500         }
1501 
<a name="66" id="anc66"></a><span class="line-modified">1502         ASSERT(count == keyCount());</span>
<span class="line-modified">1503         ASSERT(deletedCount == this-&gt;deletedCount());</span>
<span class="line-modified">1504         ASSERT(this-&gt;tableSize() &gt;= KeyTraits::minimumTableSize);</span>
<span class="line-modified">1505         ASSERT(tableSizeMask());</span>
<span class="line-modified">1506         ASSERT(this-&gt;tableSize() == tableSizeMask() + 1);</span>
1507     }
1508 
<a name="67" id="anc67"></a><span class="line-modified">1509 #endif // ASSERT_ENABLED</span>
1510 
1511 #if CHECK_HASHTABLE_ITERATORS
1512 
1513     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1514     void HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;::invalidateIterators()
1515     {
1516         std::lock_guard&lt;Lock&gt; lock(*m_mutex);
1517         const_iterator* next;
1518         for (const_iterator* p = m_iterators; p; p = next) {
1519             next = p-&gt;m_next;
1520             p-&gt;m_table = 0;
1521             p-&gt;m_next = 0;
1522             p-&gt;m_previous = 0;
1523         }
1524         m_iterators = 0;
1525     }
1526 
1527     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1528     void addIterator(const HashTable&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* table,
1529         HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
1530     {
1531         it-&gt;m_table = table;
1532         it-&gt;m_previous = 0;
1533 
1534         // Insert iterator at head of doubly-linked list of iterators.
1535         if (!table) {
1536             it-&gt;m_next = 0;
1537         } else {
1538             std::lock_guard&lt;Lock&gt; lock(*table-&gt;m_mutex);
1539             ASSERT(table-&gt;m_iterators != it);
1540             it-&gt;m_next = table-&gt;m_iterators;
1541             table-&gt;m_iterators = it;
1542             if (it-&gt;m_next) {
1543                 ASSERT(!it-&gt;m_next-&gt;m_previous);
1544                 it-&gt;m_next-&gt;m_previous = it;
1545             }
1546         }
1547     }
1548 
1549     template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
1550     void removeIterator(HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt;* it)
1551     {
1552         // Delete iterator from doubly-linked list of iterators.
1553         if (!it-&gt;m_table) {
1554             ASSERT(!it-&gt;m_next);
1555             ASSERT(!it-&gt;m_previous);
1556         } else {
1557             std::lock_guard&lt;Lock&gt; lock(*it-&gt;m_table-&gt;m_mutex);
1558             if (it-&gt;m_next) {
1559                 ASSERT(it-&gt;m_next-&gt;m_previous == it);
1560                 it-&gt;m_next-&gt;m_previous = it-&gt;m_previous;
1561             }
1562             if (it-&gt;m_previous) {
1563                 ASSERT(it-&gt;m_table-&gt;m_iterators != it);
1564                 ASSERT(it-&gt;m_previous-&gt;m_next == it);
1565                 it-&gt;m_previous-&gt;m_next = it-&gt;m_next;
1566             } else {
1567                 ASSERT(it-&gt;m_table-&gt;m_iterators == it);
1568                 it-&gt;m_table-&gt;m_iterators = it-&gt;m_next;
1569             }
1570         }
1571 
1572         it-&gt;m_table = 0;
1573         it-&gt;m_next = 0;
1574         it-&gt;m_previous = 0;
1575     }
1576 
1577 #endif // CHECK_HASHTABLE_ITERATORS
1578 
1579     // iterator adapters
1580 
1581     template&lt;typename HashTableType, typename ValueType&gt; struct HashTableConstIteratorAdapter : public std::iterator&lt;std::forward_iterator_tag, ValueType, std::ptrdiff_t, const ValueType*, const ValueType&amp;&gt; {
1582         HashTableConstIteratorAdapter() {}
1583         HashTableConstIteratorAdapter(const typename HashTableType::const_iterator&amp; impl) : m_impl(impl) {}
1584 
1585         const ValueType* get() const { return (const ValueType*)m_impl.get(); }
1586         const ValueType&amp; operator*() const { return *get(); }
1587         const ValueType* operator-&gt;() const { return get(); }
1588 
1589         HashTableConstIteratorAdapter&amp; operator++() { ++m_impl; return *this; }
1590         // postfix ++ intentionally omitted
1591 
1592         typename HashTableType::const_iterator m_impl;
1593     };
1594 
1595     template&lt;typename HashTableType, typename ValueType&gt; struct HashTableIteratorAdapter : public std::iterator&lt;std::forward_iterator_tag, ValueType, std::ptrdiff_t, ValueType*, ValueType&amp;&gt; {
1596         HashTableIteratorAdapter() {}
1597         HashTableIteratorAdapter(const typename HashTableType::iterator&amp; impl) : m_impl(impl) {}
1598 
1599         ValueType* get() const { return (ValueType*)m_impl.get(); }
1600         ValueType&amp; operator*() const { return *get(); }
1601         ValueType* operator-&gt;() const { return get(); }
1602 
1603         HashTableIteratorAdapter&amp; operator++() { ++m_impl; return *this; }
1604         // postfix ++ intentionally omitted
1605 
1606         operator HashTableConstIteratorAdapter&lt;HashTableType, ValueType&gt;() {
1607             typename HashTableType::const_iterator i = m_impl;
1608             return i;
1609         }
1610 
1611         typename HashTableType::iterator m_impl;
1612     };
1613 
1614     template&lt;typename T, typename U&gt;
1615     inline bool operator==(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1616     {
1617         return a.m_impl == b.m_impl;
1618     }
1619 
1620     template&lt;typename T, typename U&gt;
1621     inline bool operator!=(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1622     {
1623         return a.m_impl != b.m_impl;
1624     }
1625 
1626     template&lt;typename T, typename U&gt;
1627     inline bool operator==(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1628     {
1629         return a.m_impl == b.m_impl;
1630     }
1631 
1632     template&lt;typename T, typename U&gt;
1633     inline bool operator!=(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1634     {
1635         return a.m_impl != b.m_impl;
1636     }
1637 
1638     // All 4 combinations of ==, != and Const,non const.
1639     template&lt;typename T, typename U&gt;
1640     inline bool operator==(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1641     {
1642         return a.m_impl == b.m_impl;
1643     }
1644 
1645     template&lt;typename T, typename U&gt;
1646     inline bool operator!=(const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableIteratorAdapter&lt;T, U&gt;&amp; b)
1647     {
1648         return a.m_impl != b.m_impl;
1649     }
1650 
1651     template&lt;typename T, typename U&gt;
1652     inline bool operator==(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1653     {
1654         return a.m_impl == b.m_impl;
1655     }
1656 
1657     template&lt;typename T, typename U&gt;
1658     inline bool operator!=(const HashTableIteratorAdapter&lt;T, U&gt;&amp; a, const HashTableConstIteratorAdapter&lt;T, U&gt;&amp; b)
1659     {
1660         return a.m_impl != b.m_impl;
1661     }
1662 
1663 } // namespace WTF
1664 
1665 #include &lt;wtf/HashIterators.h&gt;
<a name="68" id="anc68"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="68" type="hidden" />
</body>
</html>
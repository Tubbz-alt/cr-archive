<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/EventLoop.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;EventLoop.h&quot;
 28 
 29 #include &quot;Microtasks.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 void EventLoop::queueTask(std::unique_ptr&lt;EventLoopTask&gt;&amp;&amp; task)
 34 {
 35     ASSERT(task-&gt;taskSource() != TaskSource::Microtask);
 36     ASSERT(task-&gt;group());
 37     ASSERT(isContextThread());
 38     scheduleToRunIfNeeded();
 39     m_tasks.append(WTFMove(task));
 40 }
 41 
 42 void EventLoop::queueMicrotask(std::unique_ptr&lt;EventLoopTask&gt;&amp;&amp; microtask)
 43 {
 44     ASSERT(microtask-&gt;taskSource() == TaskSource::Microtask);
 45     microtaskQueue().append(WTFMove(microtask));
 46     scheduleToRunIfNeeded(); // FIXME: Remove this once everything is integrated with the event loop.
 47 }
 48 
 49 void EventLoop::performMicrotaskCheckpoint()
 50 {
 51     microtaskQueue().performMicrotaskCheckpoint();
 52 }
 53 
 54 void EventLoop::resumeGroup(EventLoopTaskGroup&amp; group)
 55 {
 56     ASSERT(isContextThread());
 57     if (!m_groupsWithSuspenedTasks.contains(group))
 58         return;
 59     scheduleToRunIfNeeded();
 60 }
 61 
 62 void EventLoop::stopGroup(EventLoopTaskGroup&amp; group)
 63 {
 64     ASSERT(isContextThread());
 65     m_tasks.removeAllMatching([&amp;group] (auto&amp; task) {
 66         return group.matchesTask(*task);
 67     });
 68 }
 69 
 70 void EventLoop::scheduleToRunIfNeeded()
 71 {
 72     if (m_isScheduledToRun)
 73         return;
 74     m_isScheduledToRun = true;
 75     scheduleToRun();
 76 }
 77 
 78 void EventLoop::run()
 79 {
 80     m_isScheduledToRun = false;
 81     bool didPerformMicrotaskCheckpoint = false;
 82 
 83     if (!m_tasks.isEmpty()) {
 84         auto tasks = std::exchange(m_tasks, { });
 85         m_groupsWithSuspenedTasks.clear();
 86         Vector&lt;std::unique_ptr&lt;EventLoopTask&gt;&gt; remainingTasks;
 87         for (auto&amp; task : tasks) {
 88             auto* group = task-&gt;group();
 89             if (!group || group-&gt;isStoppedPermanently())
 90                 continue;
 91 
 92             if (group-&gt;isSuspended()) {
 93                 m_groupsWithSuspenedTasks.add(group);
 94                 remainingTasks.append(WTFMove(task));
 95                 continue;
 96             }
 97 
 98             task-&gt;execute();
 99             didPerformMicrotaskCheckpoint = true;
100             microtaskQueue().performMicrotaskCheckpoint();
101         }
102         for (auto&amp; task : m_tasks)
103             remainingTasks.append(WTFMove(task));
104         m_tasks = WTFMove(remainingTasks);
105     }
106 
107     // FIXME: Remove this once everything is integrated with the event loop.
108     if (!didPerformMicrotaskCheckpoint)
109         microtaskQueue().performMicrotaskCheckpoint();
110 }
111 
112 void EventLoop::clearAllTasks()
113 {
114     m_tasks.clear();
115     m_groupsWithSuspenedTasks.clear();
116 }
117 
118 void EventLoopTaskGroup::queueTask(std::unique_ptr&lt;EventLoopTask&gt;&amp;&amp; task)
119 {
120     if (m_state == State::Stopped || !m_eventLoop)
121         return;
122     ASSERT(task-&gt;group() == this);
123     m_eventLoop-&gt;queueTask(WTFMove(task));
124 }
125 
126 class EventLoopFunctionDispatchTask : public EventLoopTask {
127 public:
128     EventLoopFunctionDispatchTask(TaskSource source, EventLoopTaskGroup&amp; group, EventLoop::TaskFunction&amp;&amp; function)
129         : EventLoopTask(source, group)
130         , m_function(WTFMove(function))
131     {
132     }
133 
134     void execute() final { m_function(); }
135 
136 private:
137     EventLoop::TaskFunction m_function;
138 };
139 
140 void EventLoopTaskGroup::queueTask(TaskSource source, EventLoop::TaskFunction&amp;&amp; function)
141 {
142     return queueTask(makeUnique&lt;EventLoopFunctionDispatchTask&gt;(source, *this, WTFMove(function)));
143 }
144 
145 void EventLoopTaskGroup::queueMicrotask(EventLoop::TaskFunction&amp;&amp; function)
146 {
147     if (m_state == State::Stopped || !m_eventLoop)
148         return;
149     m_eventLoop-&gt;queueMicrotask(makeUnique&lt;EventLoopFunctionDispatchTask&gt;(TaskSource::Microtask, *this, WTFMove(function)));
150 }
151 
152 void EventLoopTaskGroup::performMicrotaskCheckpoint()
153 {
154     if (m_eventLoop)
155         m_eventLoop-&gt;performMicrotaskCheckpoint();
156 }
157 
158 } // namespace WebCore
    </pre>
  </body>
</html>
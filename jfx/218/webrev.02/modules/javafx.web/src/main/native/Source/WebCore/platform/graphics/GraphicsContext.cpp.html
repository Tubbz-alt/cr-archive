<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2003, 2004, 2005, 2006, 2009, 2013 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  23  * THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;GraphicsContext.h&quot;
  28 
  29 #include &quot;BidiResolver.h&quot;
  30 #include &quot;BitmapImage.h&quot;
  31 #include &quot;FloatRoundedRect.h&quot;
  32 #include &quot;Gradient.h&quot;
  33 #include &quot;GraphicsContextImpl.h&quot;
  34 #include &quot;ImageBuffer.h&quot;
  35 #include &quot;IntRect.h&quot;
  36 #include &quot;RoundedRect.h&quot;
  37 #include &quot;TextRun.h&quot;
  38 #include &lt;wtf/text/TextStream.h&gt;
  39 
  40 namespace WebCore {
  41 
  42 class TextRunIterator {
  43 public:
  44     TextRunIterator()
  45         : m_textRun(0)
  46         , m_offset(0)
  47     {
  48     }
  49 
  50     TextRunIterator(const TextRun* textRun, unsigned offset)
  51         : m_textRun(textRun)
  52         , m_offset(offset)
  53     {
  54     }
  55 
  56     unsigned offset() const { return m_offset; }
  57     void increment() { m_offset++; }
  58     bool atEnd() const { return !m_textRun || m_offset &gt;= m_textRun-&gt;length(); }
  59     UChar current() const { return (*m_textRun)[m_offset]; }
  60     UCharDirection direction() const { return atEnd() ? U_OTHER_NEUTRAL : u_charDirection(current()); }
  61 
  62     bool operator==(const TextRunIterator&amp; other)
  63     {
  64         return m_offset == other.m_offset &amp;&amp; m_textRun == other.m_textRun;
  65     }
  66 
  67     bool operator!=(const TextRunIterator&amp; other) { return !operator==(other); }
  68 
  69 private:
  70     const TextRun* m_textRun;
  71     unsigned m_offset;
  72 };
  73 
  74 #define CHECK_FOR_CHANGED_PROPERTY(flag, property) \
  75     if (m_changeFlags.contains(GraphicsContextState::flag) &amp;&amp; (m_state.property != state.property)) \
  76         changeFlags.add(GraphicsContextState::flag);
  77 
  78 GraphicsContextState::StateChangeFlags GraphicsContextStateChange::changesFromState(const GraphicsContextState&amp; state) const
  79 {
  80     GraphicsContextState::StateChangeFlags changeFlags;
  81 
  82     CHECK_FOR_CHANGED_PROPERTY(StrokeGradientChange, strokeGradient);
  83     CHECK_FOR_CHANGED_PROPERTY(StrokePatternChange, strokePattern);
  84     CHECK_FOR_CHANGED_PROPERTY(FillGradientChange, fillGradient);
  85     CHECK_FOR_CHANGED_PROPERTY(FillPatternChange, fillPattern);
  86 
  87     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)
  88         &amp;&amp; (m_state.shadowOffset != state.shadowOffset
  89             || m_state.shadowBlur != state.shadowBlur
  90             || m_state.shadowColor != state.shadowColor))
  91         changeFlags.add(GraphicsContextState::ShadowChange);
  92 
  93     CHECK_FOR_CHANGED_PROPERTY(StrokeThicknessChange, strokeThickness);
  94     CHECK_FOR_CHANGED_PROPERTY(TextDrawingModeChange, textDrawingMode);
  95     CHECK_FOR_CHANGED_PROPERTY(StrokeColorChange, strokeColor);
  96     CHECK_FOR_CHANGED_PROPERTY(FillColorChange, fillColor);
  97     CHECK_FOR_CHANGED_PROPERTY(StrokeStyleChange, strokeStyle);
  98     CHECK_FOR_CHANGED_PROPERTY(FillRuleChange, fillRule);
  99     CHECK_FOR_CHANGED_PROPERTY(AlphaChange, alpha);
 100 
 101     if (m_changeFlags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange })
 102         &amp;&amp; (m_state.compositeOperator != state.compositeOperator || m_state.blendMode != state.blendMode)) {
 103         changeFlags.add(GraphicsContextState::CompositeOperationChange);
 104         changeFlags.add(GraphicsContextState::BlendModeChange);
 105     }
 106 
 107     CHECK_FOR_CHANGED_PROPERTY(ShouldAntialiasChange, shouldAntialias);
 108     CHECK_FOR_CHANGED_PROPERTY(ShouldSmoothFontsChange, shouldSmoothFonts);
 109     CHECK_FOR_CHANGED_PROPERTY(ShouldSubpixelQuantizeFontsChange, shouldSubpixelQuantizeFonts);
 110     CHECK_FOR_CHANGED_PROPERTY(ShadowsIgnoreTransformsChange, shadowsIgnoreTransforms);
 111     CHECK_FOR_CHANGED_PROPERTY(DrawLuminanceMaskChange, drawLuminanceMask);
 112     CHECK_FOR_CHANGED_PROPERTY(ImageInterpolationQualityChange, imageInterpolationQuality);
 113 
 114 #if HAVE(OS_DARK_MODE_SUPPORT)
 115     CHECK_FOR_CHANGED_PROPERTY(UseDarkAppearanceChange, useDarkAppearance);
 116 #endif
 117 
 118     return changeFlags;
 119 }
 120 
 121 void GraphicsContextStateChange::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 122 {
 123     // FIXME: This code should move to GraphicsContextState.
 124     if (flags.contains(GraphicsContextState::StrokeGradientChange))
 125         m_state.strokeGradient = state.strokeGradient;
 126 
 127     if (flags.contains(GraphicsContextState::StrokePatternChange))
 128         m_state.strokePattern = state.strokePattern;
 129 
 130     if (flags.contains(GraphicsContextState::FillGradientChange))
 131         m_state.fillGradient = state.fillGradient;
 132 
 133     if (flags.contains(GraphicsContextState::FillPatternChange))
 134         m_state.fillPattern = state.fillPattern;
 135 
 136     if (flags.contains(GraphicsContextState::ShadowChange)) {
 137         // FIXME: Deal with state.shadowsUseLegacyRadius.
 138         m_state.shadowOffset = state.shadowOffset;
 139         m_state.shadowBlur = state.shadowBlur;
 140         m_state.shadowColor = state.shadowColor;
 141     }
 142 
 143     if (flags.contains(GraphicsContextState::StrokeThicknessChange))
 144         m_state.strokeThickness = state.strokeThickness;
 145 
 146     if (flags.contains(GraphicsContextState::TextDrawingModeChange))
 147         m_state.textDrawingMode = state.textDrawingMode;
 148 
 149     if (flags.contains(GraphicsContextState::StrokeColorChange))
 150         m_state.strokeColor = state.strokeColor;
 151 
 152     if (flags.contains(GraphicsContextState::FillColorChange))
 153         m_state.fillColor = state.fillColor;
 154 
 155     if (flags.contains(GraphicsContextState::StrokeStyleChange))
 156         m_state.strokeStyle = state.strokeStyle;
 157 
 158     if (flags.contains(GraphicsContextState::FillRuleChange))
 159         m_state.fillRule = state.fillRule;
 160 
 161     if (flags.contains(GraphicsContextState::AlphaChange))
 162         m_state.alpha = state.alpha;
 163 
 164     if (flags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange })) {
 165         m_state.compositeOperator = state.compositeOperator;
 166         m_state.blendMode = state.blendMode;
 167     }
 168 
 169     if (flags.contains(GraphicsContextState::ShouldAntialiasChange))
 170         m_state.shouldAntialias = state.shouldAntialias;
 171 
 172     if (flags.contains(GraphicsContextState::ShouldSmoothFontsChange))
 173         m_state.shouldSmoothFonts = state.shouldSmoothFonts;
 174 
 175     if (flags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))
 176         m_state.shouldSubpixelQuantizeFonts = state.shouldSubpixelQuantizeFonts;
 177 
 178     if (flags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))
 179         m_state.shadowsIgnoreTransforms = state.shadowsIgnoreTransforms;
 180 
 181     if (flags.contains(GraphicsContextState::DrawLuminanceMaskChange))
 182         m_state.drawLuminanceMask = state.drawLuminanceMask;
 183 
 184     if (flags.contains(GraphicsContextState::ImageInterpolationQualityChange))
 185         m_state.imageInterpolationQuality = state.imageInterpolationQuality;
 186 
 187 #if HAVE(OS_DARK_MODE_SUPPORT)
 188     if (flags.contains(GraphicsContextState::UseDarkAppearanceChange))
 189         m_state.useDarkAppearance = state.useDarkAppearance;
 190 #endif
 191 
 192     m_changeFlags.add(flags);
 193 }
 194 
 195 void GraphicsContextStateChange::apply(GraphicsContext&amp; context) const
 196 {
 197     if (m_changeFlags.contains(GraphicsContextState::StrokeGradientChange))
 198         context.setStrokeGradient(*m_state.strokeGradient);
 199 
 200     if (m_changeFlags.contains(GraphicsContextState::StrokePatternChange))
 201         context.setStrokePattern(*m_state.strokePattern);
 202 
 203     if (m_changeFlags.contains(GraphicsContextState::FillGradientChange))
 204         context.setFillGradient(*m_state.fillGradient);
 205 
 206     if (m_changeFlags.contains(GraphicsContextState::FillPatternChange))
 207         context.setFillPattern(*m_state.fillPattern);
 208 
 209     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)) {
 210 #if USE(CG)
 211         if (m_state.shadowsUseLegacyRadius)
 212             context.setLegacyShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 213         else
 214 #endif
 215             context.setShadow(m_state.shadowOffset, m_state.shadowBlur, m_state.shadowColor);
 216     }
 217 
 218     if (m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange))
 219         context.setStrokeThickness(m_state.strokeThickness);
 220 
 221     if (m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange))
 222         context.setTextDrawingMode(m_state.textDrawingMode);
 223 
 224     if (m_changeFlags.contains(GraphicsContextState::StrokeColorChange))
 225         context.setStrokeColor(m_state.strokeColor);
 226 
 227     if (m_changeFlags.contains(GraphicsContextState::FillColorChange))
 228         context.setFillColor(m_state.fillColor);
 229 
 230     if (m_changeFlags.contains(GraphicsContextState::StrokeStyleChange))
 231         context.setStrokeStyle(m_state.strokeStyle);
 232 
 233     if (m_changeFlags.contains(GraphicsContextState::FillRuleChange))
 234         context.setFillRule(m_state.fillRule);
 235 
 236     if (m_changeFlags.contains(GraphicsContextState::AlphaChange))
 237         context.setAlpha(m_state.alpha);
 238 
 239     if (m_changeFlags.containsAny({ GraphicsContextState::CompositeOperationChange, GraphicsContextState::BlendModeChange }))
 240         context.setCompositeOperation(m_state.compositeOperator, m_state.blendMode);
 241 
 242     if (m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))
 243         context.setShouldAntialias(m_state.shouldAntialias);
 244 
 245     if (m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))
 246         context.setShouldSmoothFonts(m_state.shouldSmoothFonts);
 247 
 248     if (m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))
 249         context.setShouldSubpixelQuantizeFonts(m_state.shouldSubpixelQuantizeFonts);
 250 
 251     if (m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))
 252         context.setShadowsIgnoreTransforms(m_state.shadowsIgnoreTransforms);
 253 
 254     if (m_changeFlags.contains(GraphicsContextState::DrawLuminanceMaskChange))
 255         context.setDrawLuminanceMask(m_state.drawLuminanceMask);
 256 
 257     if (m_changeFlags.contains(GraphicsContextState::ImageInterpolationQualityChange))
 258         context.setImageInterpolationQuality(m_state.imageInterpolationQuality);
 259 
 260 #if HAVE(OS_DARK_MODE_SUPPORT)
 261     if (m_changeFlags.contains(GraphicsContextState::UseDarkAppearanceChange))
 262         context.setUseDarkAppearance(m_state.useDarkAppearance);
 263 #endif
 264 }
 265 
 266 void GraphicsContextStateChange::dump(TextStream&amp; ts) const
 267 {
 268     ts.dumpProperty(&quot;change-flags&quot;, m_changeFlags.toRaw());
 269 
 270     if (m_changeFlags.contains(GraphicsContextState::StrokeGradientChange))
 271         ts.dumpProperty(&quot;stroke-gradient&quot;, m_state.strokeGradient.get());
 272 
 273     if (m_changeFlags.contains(GraphicsContextState::StrokePatternChange))
 274         ts.dumpProperty(&quot;stroke-pattern&quot;, m_state.strokePattern.get());
 275 
 276     if (m_changeFlags.contains(GraphicsContextState::FillGradientChange))
 277         ts.dumpProperty(&quot;fill-gradient&quot;, m_state.fillGradient.get());
 278 
 279     if (m_changeFlags.contains(GraphicsContextState::FillPatternChange))
 280         ts.dumpProperty(&quot;fill-pattern&quot;, m_state.fillPattern.get());
 281 
 282     if (m_changeFlags.contains(GraphicsContextState::ShadowChange)) {
 283         ts.dumpProperty(&quot;shadow-blur&quot;, m_state.shadowBlur);
 284         ts.dumpProperty(&quot;shadow-offset&quot;, m_state.shadowOffset);
 285 #if USE(CG)
 286         ts.dumpProperty(&quot;shadows-use-legacy-radius&quot;, m_state.shadowsUseLegacyRadius);
 287 #endif
 288     }
 289 
 290     if (m_changeFlags.contains(GraphicsContextState::StrokeThicknessChange))
 291         ts.dumpProperty(&quot;stroke-thickness&quot;, m_state.strokeThickness);
 292 
 293     if (m_changeFlags.contains(GraphicsContextState::TextDrawingModeChange))
 294         ts.dumpProperty(&quot;text-drawing-mode&quot;, m_state.textDrawingMode);
 295 
 296     if (m_changeFlags.contains(GraphicsContextState::StrokeColorChange))
 297         ts.dumpProperty(&quot;stroke-color&quot;, m_state.strokeColor);
 298 
 299     if (m_changeFlags.contains(GraphicsContextState::FillColorChange))
 300         ts.dumpProperty(&quot;fill-color&quot;, m_state.fillColor);
 301 
 302     if (m_changeFlags.contains(GraphicsContextState::StrokeStyleChange))
 303         ts.dumpProperty(&quot;stroke-style&quot;, m_state.strokeStyle);
 304 
 305     if (m_changeFlags.contains(GraphicsContextState::FillRuleChange))
 306         ts.dumpProperty(&quot;fill-rule&quot;, m_state.fillRule);
 307 
 308     if (m_changeFlags.contains(GraphicsContextState::AlphaChange))
 309         ts.dumpProperty(&quot;alpha&quot;, m_state.alpha);
 310 
 311     if (m_changeFlags.contains(GraphicsContextState::CompositeOperationChange))
 312         ts.dumpProperty(&quot;composite-operator&quot;, m_state.compositeOperator);
 313 
 314     if (m_changeFlags.contains(GraphicsContextState::BlendModeChange))
 315         ts.dumpProperty(&quot;blend-mode&quot;, m_state.blendMode);
 316 
 317     if (m_changeFlags.contains(GraphicsContextState::ShouldAntialiasChange))
 318         ts.dumpProperty(&quot;should-antialias&quot;, m_state.shouldAntialias);
 319 
 320     if (m_changeFlags.contains(GraphicsContextState::ShouldSmoothFontsChange))
 321         ts.dumpProperty(&quot;should-smooth-fonts&quot;, m_state.shouldSmoothFonts);
 322 
 323     if (m_changeFlags.contains(GraphicsContextState::ShouldSubpixelQuantizeFontsChange))
 324         ts.dumpProperty(&quot;should-subpixel-quantize-fonts&quot;, m_state.shouldSubpixelQuantizeFonts);
 325 
 326     if (m_changeFlags.contains(GraphicsContextState::ShadowsIgnoreTransformsChange))
 327         ts.dumpProperty(&quot;shadows-ignore-transforms&quot;, m_state.shadowsIgnoreTransforms);
 328 
 329     if (m_changeFlags.contains(GraphicsContextState::DrawLuminanceMaskChange))
 330         ts.dumpProperty(&quot;draw-luminance-mask&quot;, m_state.drawLuminanceMask);
 331 
 332 #if HAVE(OS_DARK_MODE_SUPPORT)
 333     if (m_changeFlags.contains(GraphicsContextState::UseDarkAppearanceChange))
 334         ts.dumpProperty(&quot;use-dark-appearance&quot;, m_state.useDarkAppearance);
 335 #endif
 336 }
 337 
 338 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const GraphicsContextStateChange&amp; stateChange)
 339 {
 340     stateChange.dump(ts);
 341     return ts;
 342 }
 343 
 344 GraphicsContext::GraphicsContext(PaintInvalidationReasons paintInvalidationReasons)
 345     : m_paintInvalidationReasons(paintInvalidationReasons)
 346 {
 347 }
 348 
 349 GraphicsContext::GraphicsContext(PlatformGraphicsContext* platformGraphicsContext)
 350 {
 351     platformInit(platformGraphicsContext);
 352 }
 353 
 354 GraphicsContext::GraphicsContext(const GraphicsContextImplFactory&amp; factoryFunction)
 355     : m_impl(factoryFunction(*this))
 356 {
 357 }
 358 
 359 GraphicsContext::~GraphicsContext()
 360 {
 361     ASSERT(m_stack.isEmpty());
 362     ASSERT(!m_transparencyCount);
 363     platformDestroy();
 364 }
 365 
 366 bool GraphicsContext::hasPlatformContext() const
 367 {
 368     if (m_impl)
 369         return m_impl-&gt;hasPlatformContext();
 370     return !!m_data;
 371 }
 372 
 373 void GraphicsContext::save()
 374 {
 375     if (paintingDisabled())
 376         return;
 377 
 378     m_stack.append(m_state);
 379 
 380     if (m_impl) {
 381         m_impl-&gt;save();
 382         return;
 383     }
 384 
 385     savePlatformState();
 386 }
 387 
 388 void GraphicsContext::restore()
 389 {
 390     if (paintingDisabled())
 391         return;
 392 
 393     if (m_stack.isEmpty()) {
 394         LOG_ERROR(&quot;ERROR void GraphicsContext::restore() stack is empty&quot;);
 395         return;
 396     }
 397 
 398     m_state = m_stack.last();
 399     m_stack.removeLast();
 400 
 401     // Make sure we deallocate the state stack buffer when it goes empty.
 402     // Canvas elements will immediately save() again, but that goes into inline capacity.
 403     if (m_stack.isEmpty())
 404         m_stack.clear();
 405 
 406     if (m_impl) {
 407         m_impl-&gt;restore();
 408         return;
 409     }
 410 
 411     restorePlatformState();
 412 }
 413 
 414 void GraphicsContext::drawRaisedEllipse(const FloatRect&amp; rect, const Color&amp; ellipseColor, const Color&amp; shadowColor)
 415 {
 416     if (paintingDisabled())
 417         return;
 418 
 419     save();
 420 
 421     setStrokeColor(shadowColor);
 422     setFillColor(shadowColor);
 423 
 424     drawEllipse(FloatRect(rect.x(), rect.y() + 1, rect.width(), rect.height()));
 425 
 426     setStrokeColor(ellipseColor);
 427     setFillColor(ellipseColor);
 428 
 429     drawEllipse(rect);
 430 
 431     restore();
 432 }
 433 
 434 void GraphicsContext::setStrokeThickness(float thickness)
 435 {
 436     m_state.strokeThickness = thickness;
 437     if (m_impl) {
 438         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeThicknessChange);
 439         return;
 440     }
 441 
 442     setPlatformStrokeThickness(thickness);
 443 }
 444 
 445 void GraphicsContext::setStrokeStyle(StrokeStyle style)
 446 {
 447     m_state.strokeStyle = style;
 448     if (m_impl) {
 449         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeStyleChange);
 450         return;
 451     }
 452     setPlatformStrokeStyle(style);
 453 }
 454 
 455 void GraphicsContext::setStrokeColor(const Color&amp; color)
 456 {
 457     m_state.strokeColor = color;
 458     m_state.strokeGradient = nullptr;
 459     m_state.strokePattern = nullptr;
 460     if (m_impl) {
 461         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeColorChange);
 462         return;
 463     }
 464     setPlatformStrokeColor(color);
 465 }
 466 
 467 void GraphicsContext::setShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
 468 {
 469     m_state.shadowOffset = offset;
 470     m_state.shadowBlur = blur;
 471     m_state.shadowColor = color;
 472 #if USE(CG)
 473     m_state.shadowsUseLegacyRadius = false;
 474 #endif
 475     if (m_impl) {
 476         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowChange);
 477         return;
 478     }
 479     setPlatformShadow(offset, blur, color);
 480 }
 481 
 482 void GraphicsContext::setLegacyShadow(const FloatSize&amp; offset, float blur, const Color&amp; color)
 483 {
 484     m_state.shadowOffset = offset;
 485     m_state.shadowBlur = blur;
 486     m_state.shadowColor = color;
 487 #if USE(CG)
 488     m_state.shadowsUseLegacyRadius = true;
 489 #endif
 490     if (m_impl) {
 491         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowChange);
 492         return;
 493     }
 494     setPlatformShadow(offset, blur, color);
 495 }
 496 
 497 void GraphicsContext::clearShadow()
 498 {
 499     m_state.shadowOffset = FloatSize();
 500     m_state.shadowBlur = 0;
 501     m_state.shadowColor = Color();
 502 #if USE(CG)
 503     m_state.shadowsUseLegacyRadius = false;
 504 #endif
 505 
 506     if (m_impl) {
 507         m_impl-&gt;clearShadow();
 508         return;
 509     }
 510     clearPlatformShadow();
 511 }
 512 
 513 bool GraphicsContext::getShadow(FloatSize&amp; offset, float&amp; blur, Color&amp; color) const
 514 {
 515     offset = m_state.shadowOffset;
 516     blur = m_state.shadowBlur;
 517     color = m_state.shadowColor;
 518 
 519     return hasShadow();
 520 }
 521 
 522 void GraphicsContext::setFillColor(const Color&amp; color)
 523 {
 524     m_state.fillColor = color;
 525     m_state.fillGradient = nullptr;
 526     m_state.fillPattern = nullptr;
 527 
 528     if (m_impl) {
 529         m_impl-&gt;updateState(m_state, GraphicsContextState::FillColorChange);
 530         return;
 531     }
 532 
 533     setPlatformFillColor(color);
 534 }
 535 
 536 void GraphicsContext::setShadowsIgnoreTransforms(bool shadowsIgnoreTransforms)
 537 {
 538     m_state.shadowsIgnoreTransforms = shadowsIgnoreTransforms;
 539     if (m_impl)
 540         m_impl-&gt;updateState(m_state, GraphicsContextState::ShadowsIgnoreTransformsChange);
 541 }
 542 
 543 void GraphicsContext::setShouldAntialias(bool shouldAntialias)
 544 {
 545     m_state.shouldAntialias = shouldAntialias;
 546 
 547     if (m_impl) {
 548         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldAntialiasChange);
 549         return;
 550     }
 551 
 552     setPlatformShouldAntialias(shouldAntialias);
 553 }
 554 
 555 void GraphicsContext::setShouldSmoothFonts(bool shouldSmoothFonts)
 556 {
 557     m_state.shouldSmoothFonts = shouldSmoothFonts;
 558 
 559     if (m_impl) {
 560         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldSmoothFontsChange);
 561         return;
 562     }
 563 
 564     setPlatformShouldSmoothFonts(shouldSmoothFonts);
 565 }
 566 
 567 void GraphicsContext::setShouldSubpixelQuantizeFonts(bool shouldSubpixelQuantizeFonts)
 568 {
 569     m_state.shouldSubpixelQuantizeFonts = shouldSubpixelQuantizeFonts;
 570     if (m_impl)
 571         m_impl-&gt;updateState(m_state, GraphicsContextState::ShouldSubpixelQuantizeFontsChange);
 572 }
 573 
 574 void GraphicsContext::setImageInterpolationQuality(InterpolationQuality imageInterpolationQuality)
 575 {
 576     m_state.imageInterpolationQuality = imageInterpolationQuality;
 577 
 578     if (paintingDisabled())
 579         return;
 580 
 581     if (m_impl) {
 582         m_impl-&gt;updateState(m_state, GraphicsContextState::ImageInterpolationQualityChange);
 583         return;
 584     }
 585 
 586     setPlatformImageInterpolationQuality(imageInterpolationQuality);
 587 }
 588 
 589 void GraphicsContext::setStrokePattern(Ref&lt;Pattern&gt;&amp;&amp; pattern)
 590 {
 591     m_state.strokeGradient = nullptr;
 592     m_state.strokePattern = WTFMove(pattern);
 593     if (m_impl)
 594         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokePatternChange);
 595 }
 596 
 597 void GraphicsContext::setFillPattern(Ref&lt;Pattern&gt;&amp;&amp; pattern)
 598 {
 599     m_state.fillGradient = nullptr;
 600     m_state.fillPattern = WTFMove(pattern);
 601     if (m_impl)
 602         m_impl-&gt;updateState(m_state, GraphicsContextState::FillPatternChange);
 603 }
 604 
 605 void GraphicsContext::setStrokeGradient(Ref&lt;Gradient&gt;&amp;&amp; gradient)
 606 {
 607     m_state.strokeGradient = WTFMove(gradient);
 608     m_state.strokePattern = nullptr;
 609     if (m_impl)
 610         m_impl-&gt;updateState(m_state, GraphicsContextState::StrokeGradientChange);
 611 }
 612 
 613 void GraphicsContext::setFillRule(WindRule fillRule)
 614 {
 615     m_state.fillRule = fillRule;
 616     if (m_impl)
 617         m_impl-&gt;updateState(m_state, GraphicsContextState::FillRuleChange);
 618 }
 619 
 620 void GraphicsContext::setFillGradient(Ref&lt;Gradient&gt;&amp;&amp; gradient)
 621 {
 622     m_state.fillGradient = WTFMove(gradient);
 623     m_state.fillPattern = nullptr;
 624     if (m_impl)
 625         m_impl-&gt;updateState(m_state, GraphicsContextState::FillGradientChange); // FIXME: also fill pattern?
 626 }
 627 
 628 void GraphicsContext::beginTransparencyLayer(float opacity)
 629 {
 630     if (m_impl) {
 631         m_impl-&gt;beginTransparencyLayer(opacity);
 632         return;
 633     }
 634     beginPlatformTransparencyLayer(opacity);
 635     ++m_transparencyCount;
 636 }
 637 
 638 void GraphicsContext::endTransparencyLayer()
 639 {
 640     if (m_impl) {
 641         m_impl-&gt;endTransparencyLayer();
 642         return;
 643     }
 644     endPlatformTransparencyLayer();
 645     ASSERT(m_transparencyCount &gt; 0);
 646     --m_transparencyCount;
 647 }
 648 
 649 float GraphicsContext::drawText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)
 650 {
 651     if (paintingDisabled())
 652         return 0;
 653 
 654     // Display list recording for text content is done at glyphs level. See GraphicsContext::drawGlyphs.
 655     return font.drawText(*this, run, point, from, to);
 656 }
 657 
 658 void GraphicsContext::drawGlyphs(const Font&amp; font, const GlyphBuffer&amp; buffer, unsigned from, unsigned numGlyphs, const FloatPoint&amp; point, FontSmoothingMode fontSmoothingMode)
 659 {
 660     if (paintingDisabled())
 661         return;
 662 
 663     if (m_impl) {
 664         m_impl-&gt;drawGlyphs(font, buffer, from, numGlyphs, point, fontSmoothingMode);
 665         return;
 666     }
 667 
 668     FontCascade::drawGlyphs(*this, font, buffer, from, numGlyphs, point, fontSmoothingMode);
 669 }
 670 
 671 void GraphicsContext::drawEmphasisMarks(const FontCascade&amp; font, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to)
 672 {
 673     if (paintingDisabled())
 674         return;
 675 
 676     font.drawEmphasisMarks(*this, run, mark, point, from, to);
 677 }
 678 
 679 void GraphicsContext::drawBidiText(const FontCascade&amp; font, const TextRun&amp; run, const FloatPoint&amp; point, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
 680 {
 681     if (paintingDisabled())
 682         return;
 683 
 684     BidiResolver&lt;TextRunIterator, BidiCharacterRun&gt; bidiResolver;
 685     bidiResolver.setStatus(BidiStatus(run.direction(), run.directionalOverride()));
 686     bidiResolver.setPositionIgnoringNestedIsolates(TextRunIterator(&amp;run, 0));
 687 
 688     // FIXME: This ownership should be reversed. We should pass BidiRunList
 689     // to BidiResolver in createBidiRunsForLine.
 690     BidiRunList&lt;BidiCharacterRun&gt;&amp; bidiRuns = bidiResolver.runs();
 691     bidiResolver.createBidiRunsForLine(TextRunIterator(&amp;run, run.length()));
 692 
 693     if (!bidiRuns.runCount())
 694         return;
 695 
 696     FloatPoint currPoint = point;
 697     BidiCharacterRun* bidiRun = bidiRuns.firstRun();
 698     while (bidiRun) {
 699         TextRun subrun = run.subRun(bidiRun-&gt;start(), bidiRun-&gt;stop() - bidiRun-&gt;start());
 700         bool isRTL = bidiRun-&gt;level() % 2;
 701         subrun.setDirection(isRTL ? TextDirection::RTL : TextDirection::LTR);
 702         subrun.setDirectionalOverride(bidiRun-&gt;dirOverride(false));
 703 
 704         float width = font.drawText(*this, subrun, currPoint, 0, WTF::nullopt, customFontNotReadyAction);
 705         currPoint.move(width, 0);
 706 
 707         bidiRun = bidiRun-&gt;next();
 708     }
 709 
 710     bidiRuns.clear();
 711 }
 712 
 713 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 714 {
 715     return drawImage(image, FloatRect(destination, image.size()), FloatRect(FloatPoint(), image.size()), imagePaintingOptions);
 716 }
 717 
 718 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 719 {
 720     FloatRect srcRect(FloatPoint(), image.size());
 721     return drawImage(image, destination, srcRect, imagePaintingOptions);
 722 }
 723 
 724 ImageDrawResult GraphicsContext::drawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)
 725 {
 726     if (paintingDisabled())
 727         return ImageDrawResult::DidNothing;
 728 
 729     if (m_impl)
 730         return m_impl-&gt;drawImage(image, destination, source, options);
 731 
 732     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());
 733     return image.draw(*this, destination, source, options);
 734 }
 735 
 736 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
 737 {
 738     if (paintingDisabled())
 739         return ImageDrawResult::DidNothing;
 740 
 741     if (m_impl)
 742         return m_impl-&gt;drawTiledImage(image, destination, source, tileSize, spacing, options);
 743 
 744     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());
 745     return image.drawTiled(*this, destination, source, tileSize, spacing, options);
 746 }
 747 
 748 ImageDrawResult GraphicsContext::drawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor,
 749     Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; options)
 750 {
 751     if (paintingDisabled())
 752         return ImageDrawResult::DidNothing;
 753 
 754     if (m_impl)
 755         return m_impl-&gt;drawTiledImage(image, destination, source, tileScaleFactor, hRule, vRule, options);
 756 
 757     if (hRule == Image::StretchTile &amp;&amp; vRule == Image::StretchTile) {
 758         // Just do a scale.
 759         return drawImage(image, destination, source, options);
 760     }
 761 
 762     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());
 763     return image.drawTiled(*this, destination, source, tileScaleFactor, hRule, vRule, options.compositeOperator());
 764 }
 765 
 766 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 767 {
 768     drawImageBuffer(image, FloatRect(destination, image.logicalSize()), FloatRect(FloatPoint(), image.logicalSize()), imagePaintingOptions);
 769 }
 770 
 771 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 772 {
 773     drawImageBuffer(image, destination, FloatRect(FloatPoint(), FloatSize(image.logicalSize())), imagePaintingOptions);
 774 }
 775 
 776 void GraphicsContext::drawImageBuffer(ImageBuffer&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)
 777 {
 778     if (paintingDisabled())
 779         return;
 780 
 781     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());
 782     image.draw(*this, destination, source, options);
 783 }
 784 
 785 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatPoint&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 786 {
 787     if (!image)
 788         return;
 789     IntSize imageLogicalSize = image-&gt;logicalSize();
 790     drawConsumingImageBuffer(WTFMove(image), FloatRect(destination, imageLogicalSize), FloatRect(FloatPoint(), imageLogicalSize), imagePaintingOptions);
 791 }
 792 
 793 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const ImagePaintingOptions&amp; imagePaintingOptions)
 794 {
 795     if (!image)
 796         return;
 797     IntSize imageLogicalSize = image-&gt;logicalSize();
 798     drawConsumingImageBuffer(WTFMove(image), destination, FloatRect(FloatPoint(), FloatSize(imageLogicalSize)), imagePaintingOptions);
 799 }
 800 
 801 void GraphicsContext::drawConsumingImageBuffer(std::unique_ptr&lt;ImageBuffer&gt; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; options)
 802 {
 803     if (paintingDisabled() || !image)
 804         return;
 805 
 806     InterpolationQualityMaintainer interpolationQualityForThisScope(*this, options.interpolationQuality());
 807     ImageBuffer::drawConsuming(WTFMove(image), *this, destination, source, options);
 808 }
 809 
 810 void GraphicsContext::clipRoundedRect(const FloatRoundedRect&amp; rect)
 811 {
 812     if (paintingDisabled())
 813         return;
 814 
 815     Path path;
 816     path.addRoundedRect(rect);
 817     clipPath(path);
 818 }
 819 
 820 void GraphicsContext::clipOutRoundedRect(const FloatRoundedRect&amp; rect)
 821 {
 822     if (paintingDisabled())
 823         return;
 824 
 825     if (!rect.isRounded()) {
 826         clipOut(rect.rect());
 827         return;
 828     }
 829 
 830     Path path;
 831     path.addRoundedRect(rect);
 832     clipOut(path);
 833 }
 834 
 835 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO) &amp;&amp; !PLATFORM(JAVA)
 836 IntRect GraphicsContext::clipBounds() const
 837 {
 838     ASSERT_NOT_REACHED();
 839     return IntRect();
 840 }
 841 #endif
 842 
 843 void GraphicsContext::setTextDrawingMode(TextDrawingModeFlags mode)
 844 {
 845     m_state.textDrawingMode = mode;
 846     if (paintingDisabled())
 847         return;
 848 
 849     if (m_impl) {
 850         m_impl-&gt;updateState(m_state, GraphicsContextState::TextDrawingModeChange);
 851         return;
 852     }
 853     setPlatformTextDrawingMode(mode);
 854 }
 855 
 856 void GraphicsContext::fillRect(const FloatRect&amp; rect, Gradient&amp; gradient)
 857 {
 858     if (paintingDisabled())
 859         return;
 860 
 861     if (m_impl) {
 862         m_impl-&gt;fillRect(rect, gradient);
 863         return;
 864     }
 865 
 866     gradient.fill(*this, rect);
 867 }
 868 
 869 void GraphicsContext::fillRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)
 870 {
 871     if (paintingDisabled())
 872         return;
 873 
 874     if (m_impl) {
 875         m_impl-&gt;fillRect(rect, color, op, blendMode);
 876         return;
 877     }
 878 
 879     CompositeOperator previousOperator = compositeOperation();
 880     setCompositeOperation(op, blendMode);
 881     fillRect(rect, color);
 882     setCompositeOperation(previousOperator);
 883 }
 884 
 885 #if !PLATFORM(JAVA) // FIXME-java: recheck
 886 void GraphicsContext::fillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)
 887 {
 888     if (paintingDisabled())
 889         return;
 890 
 891     if (m_impl) {
 892         m_impl-&gt;fillRoundedRect(rect, color, blendMode);
 893         return;
 894     }
 895 
 896     if (rect.isRounded()) {
 897         setCompositeOperation(compositeOperation(), blendMode);
 898         platformFillRoundedRect(rect, color);
 899         setCompositeOperation(compositeOperation());
 900     } else
 901         fillRect(rect.rect(), color, compositeOperation(), blendMode);
 902 }
 903 #endif
 904 
 905 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO) &amp;&amp; !PLATFORM(JAVA)
 906 void GraphicsContext::fillRectWithRoundedHole(const IntRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)
 907 {
 908     if (paintingDisabled())
 909         return;
 910 
 911     Path path;
 912     path.addRect(rect);
 913 
 914     if (!roundedHoleRect.radii().isZero())
 915         path.addRoundedRect(roundedHoleRect);
 916     else
 917         path.addRect(roundedHoleRect.rect());
 918 
 919     WindRule oldFillRule = fillRule();
 920     Color oldFillColor = fillColor();
 921 
 922     setFillRule(WindRule::EvenOdd);
 923     setFillColor(color);
 924 
 925     fillPath(path);
 926 
 927     setFillRule(oldFillRule);
 928     setFillColor(oldFillColor);
 929 }
 930 #endif
 931 
 932 void GraphicsContext::setAlpha(float alpha)
 933 {
 934     m_state.alpha = alpha;
 935     if (m_impl) {
 936         m_impl-&gt;updateState(m_state, GraphicsContextState::AlphaChange);
 937         return;
 938     }
 939     setPlatformAlpha(alpha);
 940 }
 941 
 942 void GraphicsContext::setCompositeOperation(CompositeOperator compositeOperation, BlendMode blendMode)
 943 {
 944     m_state.compositeOperator = compositeOperation;
 945     m_state.blendMode = blendMode;
 946     if (m_impl) {
 947         m_impl-&gt;updateState(m_state, GraphicsContextState::CompositeOperationChange);
 948         return;
 949     }
 950     setPlatformCompositeOperation(compositeOperation, blendMode);
 951 }
 952 
 953 void GraphicsContext::setDrawLuminanceMask(bool drawLuminanceMask)
 954 {
 955     m_state.drawLuminanceMask = drawLuminanceMask;
 956     if (m_impl)
 957         m_impl-&gt;updateState(m_state, GraphicsContextState::DrawLuminanceMaskChange);
 958 }
 959 
 960 #if HAVE(OS_DARK_MODE_SUPPORT)
 961 void GraphicsContext::setUseDarkAppearance(bool useDarkAppearance)
 962 {
 963     m_state.useDarkAppearance = useDarkAppearance;
 964     if (m_impl)
 965         m_impl-&gt;updateState(m_state, GraphicsContextState::UseDarkAppearanceChange);
 966 }
 967 #endif
 968 
 969 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 970 // Implement this if you want to go push the drawing mode into your native context immediately.
 971 void GraphicsContext::setPlatformTextDrawingMode(TextDrawingModeFlags)
 972 {
 973 }
 974 #endif
 975 
 976 #if !USE(CAIRO) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !PLATFORM(JAVA)
 977 void GraphicsContext::setPlatformStrokeStyle(StrokeStyle)
 978 {
 979 }
 980 #endif
 981 
 982 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
 983 void GraphicsContext::setPlatformShouldSmoothFonts(bool)
 984 {
 985 }
 986 #endif
 987 
 988 #if !USE(CG) &amp;&amp; !USE(DIRECT2D) &amp;&amp; !USE(CAIRO)
 989 bool GraphicsContext::isAcceleratedContext() const
 990 {
 991     return false;
 992 }
 993 #endif
 994 
 995 void GraphicsContext::adjustLineToPixelBoundaries(FloatPoint&amp; p1, FloatPoint&amp; p2, float strokeWidth, StrokeStyle penStyle)
 996 {
 997     // For odd widths, we add in 0.5 to the appropriate x/y so that the float arithmetic
 998     // works out.  For example, with a border width of 3, WebKit will pass us (y1+y2)/2, e.g.,
 999     // (50+53)/2 = 103/2 = 51 when we want 51.5.  It is always true that an even width gave
1000     // us a perfect position, but an odd width gave us a position that is off by exactly 0.5.
1001     if (penStyle == DottedStroke || penStyle == DashedStroke) {
1002         if (p1.x() == p2.x()) {
1003             p1.setY(p1.y() + strokeWidth);
1004             p2.setY(p2.y() - strokeWidth);
1005         } else {
1006             p1.setX(p1.x() + strokeWidth);
1007             p2.setX(p2.x() - strokeWidth);
1008         }
1009     }
1010 
1011     if (static_cast&lt;int&gt;(strokeWidth) % 2) { //odd
1012         if (p1.x() == p2.x()) {
1013             // We&#39;re a vertical line.  Adjust our x.
1014             p1.setX(p1.x() + 0.5f);
1015             p2.setX(p2.x() + 0.5f);
1016         } else {
1017             // We&#39;re a horizontal line. Adjust our y.
1018             p1.setY(p1.y() + 0.5f);
1019             p2.setY(p2.y() + 0.5f);
1020         }
1021     }
1022 }
1023 
1024 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
1025 void GraphicsContext::platformApplyDeviceScaleFactor(float)
1026 {
1027 }
1028 #endif
1029 
1030 void GraphicsContext::applyDeviceScaleFactor(float deviceScaleFactor)
1031 {
1032     scale(deviceScaleFactor);
1033 
1034     if (m_impl) {
1035         m_impl-&gt;applyDeviceScaleFactor(deviceScaleFactor);
1036         return;
1037     }
1038 
1039     platformApplyDeviceScaleFactor(deviceScaleFactor);
1040 }
1041 
1042 FloatSize GraphicsContext::scaleFactor() const
1043 {
1044     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1045     return FloatSize(transform.xScale(), transform.yScale());
1046 }
1047 
1048 FloatSize GraphicsContext::scaleFactorForDrawing(const FloatRect&amp; destRect, const FloatRect&amp; srcRect) const
1049 {
1050     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1051     auto transformedDestRect = transform.mapRect(destRect);
1052     return transformedDestRect.size() / srcRect.size();
1053 }
1054 
1055 void GraphicsContext::fillEllipse(const FloatRect&amp; ellipse)
1056 {
1057     if (m_impl) {
1058         m_impl-&gt;fillEllipse(ellipse);
1059         return;
1060     }
1061 
1062     platformFillEllipse(ellipse);
1063 }
1064 
1065 void GraphicsContext::strokeEllipse(const FloatRect&amp; ellipse)
1066 {
1067     if (m_impl) {
1068         m_impl-&gt;strokeEllipse(ellipse);
1069         return;
1070     }
1071 
1072     platformStrokeEllipse(ellipse);
1073 }
1074 
1075 void GraphicsContext::fillEllipseAsPath(const FloatRect&amp; ellipse)
1076 {
1077     Path path;
1078     path.addEllipse(ellipse);
1079     fillPath(path);
1080 }
1081 
1082 void GraphicsContext::strokeEllipseAsPath(const FloatRect&amp; ellipse)
1083 {
1084     Path path;
1085     path.addEllipse(ellipse);
1086     strokePath(path);
1087 }
1088 
1089 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
1090 void GraphicsContext::platformFillEllipse(const FloatRect&amp; ellipse)
1091 {
1092     if (paintingDisabled())
1093         return;
1094 
1095     fillEllipseAsPath(ellipse);
1096 }
1097 
1098 void GraphicsContext::platformStrokeEllipse(const FloatRect&amp; ellipse)
1099 {
1100     if (paintingDisabled())
1101         return;
1102 
1103     strokeEllipseAsPath(ellipse);
1104 }
1105 #endif
1106 
1107 FloatRect GraphicsContext::computeUnderlineBoundsForText(const FloatRect&amp; rect, bool printing)
1108 {
1109     Color dummyColor;
1110     return computeLineBoundsAndAntialiasingModeForText(rect, printing, dummyColor);
1111 }
1112 
1113 FloatRect GraphicsContext::computeLineBoundsAndAntialiasingModeForText(const FloatRect&amp; rect, bool printing, Color&amp; color)
1114 {
1115     FloatPoint origin = rect.location();
1116     float thickness = std::max(rect.height(), 0.5f);
1117     if (printing)
1118         return FloatRect(origin, FloatSize(rect.width(), thickness));
1119 
1120     AffineTransform transform = getCTM(GraphicsContext::DefinitelyIncludeDeviceScale);
1121     // Just compute scale in x dimension, assuming x and y scales are equal.
1122     float scale = transform.b() ? std::hypot(transform.a(), transform.b()) : transform.a();
1123     if (scale &lt; 1.0) {
1124         // This code always draws a line that is at least one-pixel line high,
1125         // which tends to visually overwhelm text at small scales. To counter this
1126         // effect, an alpha is applied to the underline color when text is at small scales.
1127         static const float minimumUnderlineAlpha = 0.4f;
1128         float shade = scale &gt; minimumUnderlineAlpha ? scale : minimumUnderlineAlpha;
1129         color = color.colorWithAlphaMultipliedBy(shade);
1130     }
1131 
1132     FloatPoint devicePoint = transform.mapPoint(rect.location());
1133     // Visual overflow might occur here due to integral roundf/ceilf. visualOverflowForDecorations adjusts the overflow value for underline decoration.
1134     FloatPoint deviceOrigin = FloatPoint(roundf(devicePoint.x()), ceilf(devicePoint.y()));
1135     if (auto inverse = transform.inverse())
1136         origin = inverse.value().mapPoint(deviceOrigin);
1137     return FloatRect(origin, FloatSize(rect.width(), thickness));
1138 }
1139 
1140 void GraphicsContext::builderState(const GraphicsContextState&amp; state)
1141 {
1142     setPlatformShadow(state.shadowOffset, state.shadowBlur, state.shadowColor);
1143     setPlatformStrokeThickness(state.strokeThickness);
1144     setPlatformTextDrawingMode(state.textDrawingMode);
1145     setPlatformStrokeColor(state.strokeColor);
1146     setPlatformFillColor(state.fillColor);
1147     setPlatformStrokeStyle(state.strokeStyle);
1148     setPlatformAlpha(state.alpha);
1149     setPlatformCompositeOperation(state.compositeOperator, state.blendMode);
1150     setPlatformShouldAntialias(state.shouldAntialias);
1151     setPlatformShouldSmoothFonts(state.shouldSmoothFonts);
1152 }
1153 
1154 float GraphicsContext::dashedLineCornerWidthForStrokeWidth(float strokeWidth) const
1155 {
1156     float thickness = strokeThickness();
1157     return strokeStyle() == DottedStroke ? thickness : std::min(2.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1158 }
1159 
1160 float GraphicsContext::dashedLinePatternWidthForStrokeWidth(float strokeWidth) const
1161 {
1162     float thickness = strokeThickness();
1163     return strokeStyle() == DottedStroke ? thickness : std::min(3.0f * thickness, std::max(thickness, strokeWidth / 3.0f));
1164 }
1165 
1166 float GraphicsContext::dashedLinePatternOffsetForPatternAndStrokeWidth(float patternWidth, float strokeWidth) const
1167 {
1168     // Pattern starts with full fill and ends with the empty fill.
1169     // 1. Let&#39;s start with the empty phase after the corner.
1170     // 2. Check if we&#39;ve got odd or even number of patterns and whether they fully cover the line.
1171     // 3. In case of even number of patterns and/or remainder, move the pattern start position
1172     // so that the pattern is balanced between the corners.
1173     float patternOffset = patternWidth;
1174     int numberOfSegments = std::floor(strokeWidth / patternWidth);
1175     bool oddNumberOfSegments = numberOfSegments % 2;
1176     float remainder = strokeWidth - (numberOfSegments * patternWidth);
1177     if (oddNumberOfSegments &amp;&amp; remainder)
1178         patternOffset -= remainder / 2.0f;
1179     else if (!oddNumberOfSegments) {
1180         if (remainder)
1181             patternOffset += patternOffset - (patternWidth + remainder) / 2.0f;
1182         else
1183             patternOffset += patternWidth / 2.0f;
1184     }
1185 
1186     return patternOffset;
1187 }
1188 
1189 Vector&lt;FloatPoint&gt; GraphicsContext::centerLineAndCutOffCorners(bool isVerticalLine, float cornerWidth, FloatPoint point1, FloatPoint point2) const
1190 {
1191     // Center line and cut off corners for pattern painting.
1192     if (isVerticalLine) {
1193         float centerOffset = (point2.x() - point1.x()) / 2.0f;
1194         point1.move(centerOffset, cornerWidth);
1195         point2.move(-centerOffset, -cornerWidth);
1196     } else {
1197         float centerOffset = (point2.y() - point1.y()) / 2.0f;
1198         point1.move(cornerWidth, centerOffset);
1199         point2.move(-cornerWidth, -centerOffset);
1200     }
1201 
1202     return { point1, point2 };
1203 }
1204 
1205 #if !USE(CG)
1206 bool GraphicsContext::supportsInternalLinks() const
1207 {
1208     return false;
1209 }
1210 
1211 void GraphicsContext::setDestinationForRect(const String&amp;, const FloatRect&amp;)
1212 {
1213 }
1214 
1215 void GraphicsContext::addDestinationAtPoint(const String&amp;, const FloatPoint&amp;)
1216 {
1217 }
1218 #endif
1219 
1220 }
    </pre>
  </body>
</html>
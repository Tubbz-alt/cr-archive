<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseConstructor.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 function all(iterable)
 27 {
 28     &quot;use strict&quot;;
 29 
 30     if (!@isObject(this))
 31         @throwTypeError(&quot;|this| is not an object&quot;);
 32 
 33     var promiseCapability = @newPromiseCapability(this);
 34 
 35     var values = [];
 36     var index = 0;
 37     var remainingElementsCount = 1;
 38 
 39     function newResolveElement(index)
 40     {
 41         var alreadyCalled = false;
 42         return function (argument)
 43         {
 44             if (alreadyCalled)
 45                 return @undefined;
 46             alreadyCalled = true;
 47 
 48             @putByValDirect(values, index, argument);
 49 
 50             --remainingElementsCount;
 51             if (remainingElementsCount === 0)
 52                 return promiseCapability.@resolve.@call(@undefined, values);
 53 
 54             return @undefined;
 55         }
 56     }
 57 
 58     try {
 59         var promiseResolve = this.resolve;
 60         if (typeof promiseResolve !== &quot;function&quot;)
 61             @throwTypeError(&quot;Promise resolve is not a function&quot;);
 62 
 63         for (var value of iterable) {
 64             @putByValDirect(values, index, @undefined);
 65             var nextPromise = promiseResolve.@call(this, value);
 66             var resolveElement = newResolveElement(index);
 67             ++remainingElementsCount;
 68             nextPromise.then(resolveElement, promiseCapability.@reject);
 69             ++index;
 70         }
 71 
 72         --remainingElementsCount;
 73         if (remainingElementsCount === 0)
 74             promiseCapability.@resolve.@call(@undefined, values);
 75     } catch (error) {
 76         promiseCapability.@reject.@call(@undefined, error);
 77     }
 78 
 79     return promiseCapability.@promise;
 80 }
 81 
 82 function allSettled(iterable)
 83 {
 84     &quot;use strict&quot;;
 85 
 86     if (!@isObject(this))
 87         @throwTypeError(&quot;|this| is not an object&quot;);
 88 
 89     var promiseCapability = @newPromiseCapability(this);
 90 
 91     var values = [];
 92     var remainingElementsCount = 1;
 93     var index = 0;
 94 
 95     function newResolveRejectElements(index)
 96     {
 97         var alreadyCalled = false;
 98 
 99         return [
100             function (value) {
101                 if (alreadyCalled)
102                     return @undefined;
103                 alreadyCalled = true;
104 
105                 var obj = {
106                     status: &quot;fulfilled&quot;,
107                     value
108                 };
109 
110                 @putByValDirect(values, index, obj);
111 
112                 --remainingElementsCount;
113                 if (remainingElementsCount === 0)
114                     return promiseCapability.@resolve.@call(@undefined, values);
115 
116                 return @undefined;
117             },
118 
119             function (reason) {
120                 if (alreadyCalled)
121                     return @undefined;
122                 alreadyCalled = true;
123 
124                 var obj = {
125                     status: &quot;rejected&quot;,
126                     reason
127                 };
128 
129                 @putByValDirect(values, index, obj);
130 
131                 --remainingElementsCount;
132                 if (remainingElementsCount === 0)
133                     return promiseCapability.@resolve.@call(@undefined, values);
134 
135                 return @undefined;
136             }
137         ];
138     }
139 
140     try {
141         var promiseResolve = this.resolve;
142         if (typeof promiseResolve !== &quot;function&quot;)
143             @throwTypeError(&quot;Promise resolve is not a function&quot;);
144 
145         for (var value of iterable) {
146             @putByValDirect(values, index, @undefined);
147             var nextPromise = promiseResolve.@call(this, value);
148             var [resolveElement, rejectElement] = newResolveRejectElements(index);
149             ++remainingElementsCount;
150             nextPromise.then(resolveElement, rejectElement);
151             ++index;
152         }
153 
154         --remainingElementsCount;
155         if (remainingElementsCount === 0)
156             promiseCapability.@resolve.@call(@undefined, values);
157     } catch (error) {
158         promiseCapability.@reject.@call(@undefined, error);
159     }
160 
161     return promiseCapability.@promise;
162 }
163 
164 function race(iterable)
165 {
166     &quot;use strict&quot;;
167 
168     if (!@isObject(this))
169         @throwTypeError(&quot;|this| is not an object&quot;);
170 
171     var promiseCapability = @newPromiseCapability(this);
172 
173     try {
174         var promiseResolve = this.resolve;
175         if (typeof promiseResolve !== &quot;function&quot;)
176             @throwTypeError(&quot;Promise resolve is not a function&quot;);
177 
178         for (var value of iterable) {
179             var nextPromise = promiseResolve.@call(this, value);
180             nextPromise.then(promiseCapability.@resolve, promiseCapability.@reject);
181         }
182     } catch (error) {
183         promiseCapability.@reject.@call(@undefined, error);
184     }
185 
186     return promiseCapability.@promise;
187 }
188 
189 function reject(reason)
190 {
191     &quot;use strict&quot;;
192 
193     if (!@isObject(this))
194         @throwTypeError(&quot;|this| is not an object&quot;);
195 
196     if (this === @Promise) {
197         var promise = @newPromise();
198         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, reason);
199         return promise;
200     }
201 
202     return @promiseRejectSlow(this, reason);
203 }
204 
205 function resolve(value)
206 {
207     &quot;use strict&quot;;
208 
209     if (!@isObject(this))
210         @throwTypeError(&quot;|this| is not an object&quot;);
211 
212     if (@isPromise(value)) {
213         var valueConstructor = value.constructor;
214         if (valueConstructor === this)
215             return value;
216     }
217 
218     if (this === @Promise) {
219         var promise = @newPromise();
220         @resolvePromiseWithFirstResolvingFunctionCallCheck(promise, value);
221         return promise;
222     }
223 
224     return @promiseResolveSlow(this, value);
225 }
226 
227 @nakedConstructor
228 function Promise(executor)
229 {
230     &quot;use strict&quot;;
231 
232     if (typeof executor !== &quot;function&quot;)
233         @throwTypeError(&quot;Promise constructor takes a function argument&quot;);
234 
235     var promise = @createPromise(this, /* isInternalPromise */ false);
236     var capturedPromise = promise;
237 
238     try {
239         executor(
240             function (resolution) {
241                 return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);
242             },
243             function (reason) {
244                 return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);
245             });
246     } catch (error) {
247         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);
248     }
249 
250     return promise;
251 }
252 
253 @nakedConstructor
254 function InternalPromise(executor)
255 {
256     &quot;use strict&quot;;
257 
258     if (typeof executor !== &quot;function&quot;)
259         @throwTypeError(&quot;InternalPromise constructor takes a function argument&quot;);
260 
261     var promise = @createPromise(this, /* isInternalPromise */ true);
262     var capturedPromise = promise;
263 
264     try {
265         executor(
266             function (resolution) {
267                 return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);
268             },
269             function (reason) {
270                 return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);
271             });
272     } catch (error) {
273         @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);
274     }
275 
276     return promise;
277 }
    </pre>
  </body>
</html>
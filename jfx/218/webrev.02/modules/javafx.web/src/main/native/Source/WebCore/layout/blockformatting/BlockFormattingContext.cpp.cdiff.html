<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Verification.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingContext.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,447 ***</span>
  #include &quot;BlockFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;BlockFormattingState.h&quot;
<span class="line-removed">- #include &quot;DisplayBox.h&quot;</span>
  #include &quot;FloatingContext.h&quot;
  #include &quot;FloatingState.h&quot;
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutState.h&quot;
  #include &quot;Logging.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(BlockFormattingContext);
  
<span class="line-modified">! BlockFormattingContext::BlockFormattingContext(const Box&amp; formattingContextRoot, BlockFormattingState&amp; formattingState)</span>
      : FormattingContext(formattingContextRoot, formattingState)
  {
  }
  
<span class="line-modified">! void BlockFormattingContext::layout() const</span>
  {
      // 9.4.1 Block formatting contexts
      // In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block.
      // The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties.
      // Vertical margins between adjacent block-level boxes in a block formatting context collapse.
<span class="line-removed">-     if (!is&lt;Container&gt;(root()))</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; block formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);
  
<span class="line-removed">-     auto&amp; formattingRoot = downcast&lt;Container&gt;(root());</span>
      LayoutQueue layoutQueue;
<span class="line-modified">!     FloatingContext floatingContext(formattingState().floatingState());</span>
      // This is a post-order tree traversal layout.
      // The root container layout is done in the formatting context it lives in, not that one it creates, so let&#39;s start with the first child.
<span class="line-modified">!     if (auto* firstChild = formattingRoot.firstInFlowOrFloatingChild())</span>
<span class="line-removed">-         layoutQueue.append(firstChild);</span>
      // 1. Go all the way down to the leaf node
      // 2. Compute static position and width as we traverse down
      // 3. As we climb back on the tree, compute height and finialize position
      // (Any subtrees with new formatting contexts need to layout synchronously)
      while (!layoutQueue.isEmpty()) {
          // Traverse down on the descendants and compute width/static position until we find a leaf node.
          while (true) {
              auto&amp; layoutBox = *layoutQueue.last();
  
              if (layoutBox.establishesFormattingContext()) {
<span class="line-modified">!                 layoutFormattingContextRoot(floatingContext, layoutBox);</span>
<span class="line-modified">!                 layoutQueue.removeLast();</span>
<span class="line-modified">!                 // Since this box is a formatting context root, it takes care of its entire subtree.</span>
<span class="line-modified">!                 // Continue with next sibling if exists.</span>
<span class="line-modified">!                 if (!layoutBox.nextInFlowOrFloatingSibling())</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 layoutQueue.append(layoutBox.nextInFlowOrFloatingSibling());</span>
<span class="line-modified">!                 continue;</span>
              }
<span class="line-modified">! </span>
<span class="line-removed">-             LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Compute] -&gt; [Position][Border][Padding][Width][Margin] -&gt; for layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-removed">-             computeBorderAndPadding(layoutBox);</span>
<span class="line-removed">-             computeWidthAndMargin(layoutBox);</span>
<span class="line-removed">-             computeStaticPosition(floatingContext, layoutBox);</span>
<span class="line-removed">-             if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())</span>
                  break;
<span class="line-removed">-             layoutQueue.append(downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild());</span>
          }
  
          // Climb back on the ancestors and compute height/final position.
          while (!layoutQueue.isEmpty()) {
<span class="line-removed">-             // All inflow descendants (if there are any) are laid out by now. Let&#39;s compute the box&#39;s height.</span>
              auto&amp; layoutBox = *layoutQueue.takeLast();
  
<span class="line-modified">!             LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Compute] -&gt; [Height][Margin] -&gt; for layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!             // Formatting root boxes are special-cased and they don&#39;t come here.</span>
<span class="line-modified">!             ASSERT(!layoutBox.establishesFormattingContext());</span>
<span class="line-modified">!             computeHeightAndMargin(layoutBox);</span>
<span class="line-modified">!             // Move in-flow positioned children to their final position.</span>
<span class="line-modified">!             placeInFlowPositionedChildren(layoutBox);</span>
<span class="line-modified">!             if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {</span>
<span class="line-modified">!                 layoutQueue.append(nextSibling);</span>
<span class="line-modified">!                 break;</span>
              }
          }
      }
      // Place the inflow positioned children.
<span class="line-modified">!     placeInFlowPositionedChildren(formattingRoot);</span>
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; block formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);
  }
  
  Optional&lt;LayoutUnit&gt; BlockFormattingContext::usedAvailableWidthForFloatAvoider(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const
  {
      // Normally the available width for an in-flow block level box is the width of the containing block&#39;s content box.
      // However (and can&#39;t find it anywhere in the spec) non-floating positioned float avoider block level boxes are constrained by existing floats.
<span class="line-modified">!     if (!layoutBox.isFloatAvoider() || layoutBox.isFloatingPositioned())</span>
<span class="line-modified">!         return { };</span>
<span class="line-removed">-     auto&amp; floatingState = floatingContext.floatingState();</span>
<span class="line-removed">-     if (floatingState.isEmpty())</span>
          return { };
<span class="line-modified">!     // Vertical static position is not computed yet, so let&#39;s just estimate it for now.</span>
<span class="line-modified">!     auto&amp; formattingRoot = downcast&lt;Container&gt;(root());</span>
<span class="line-modified">!     auto verticalPosition = FormattingContext::mapTopToAncestor(layoutState(), layoutBox, formattingRoot);</span>
<span class="line-modified">!     auto constraints = floatingState.constraints({ verticalPosition }, formattingRoot);</span>
      if (!constraints.left &amp;&amp; !constraints.right)
          return { };
<span class="line-modified">!     auto&amp; containingBlock = downcast&lt;Container&gt;(*layoutBox.containingBlock());</span>
<span class="line-modified">!     auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(containingBlock);</span>
<span class="line-modified">!     auto availableWidth = containingBlockDisplayBox.contentBoxWidth();</span>
  
      LayoutUnit containingBlockLeft;
<span class="line-modified">!     LayoutUnit containingBlockRight = containingBlockDisplayBox.right();</span>
<span class="line-modified">!     if (&amp;containingBlock != &amp;formattingRoot) {</span>
          // Move containing block left/right to the root&#39;s coordinate system.
<span class="line-modified">!         containingBlockLeft = FormattingContext::mapLeftToAncestor(layoutState(), containingBlock, formattingRoot);</span>
<span class="line-modified">!         containingBlockRight = FormattingContext::mapRightToAncestor(layoutState(), containingBlock, formattingRoot);</span>
      }
<span class="line-modified">!     auto containingBlockContentBoxLeft = containingBlockLeft + containingBlockDisplayBox.borderLeft() + containingBlockDisplayBox.paddingLeft().valueOr(0);</span>
<span class="line-modified">!     auto containingBlockContentBoxRight = containingBlockRight - containingBlockDisplayBox.borderRight() + containingBlockDisplayBox.paddingRight().valueOr(0);</span>
  
      // Shrink the available space if the floats are actually intruding at this vertical position.
      if (constraints.left)
          availableWidth -= std::max&lt;LayoutUnit&gt;(0, constraints.left-&gt;x - containingBlockContentBoxLeft);
      if (constraints.right)
          availableWidth -= std::max&lt;LayoutUnit&gt;(0, containingBlockContentBoxRight - constraints.right-&gt;x);
      return availableWidth;
  }
  
<span class="line-modified">! void BlockFormattingContext::layoutFormattingContextRoot(FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(layoutBox.establishesFormattingContext());</span>
<span class="line-removed">-     // Start laying out this formatting root in the formatting contenxt it lives in.</span>
<span class="line-removed">-     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Compute] -&gt; [Position][Border][Padding][Width][Margin] -&gt; for layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-removed">-     computeBorderAndPadding(layoutBox);</span>
<span class="line-removed">-     computeStaticVerticalPosition(floatingContext, layoutBox);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     computeWidthAndMargin(layoutBox, usedAvailableWidthForFloatAvoider(floatingContext, layoutBox));</span>
<span class="line-removed">-     computeStaticHorizontalPosition(layoutBox);</span>
<span class="line-removed">-     // Swich over to the new formatting context (the one that the root creates).</span>
<span class="line-removed">-     auto formattingContext = layoutState().createFormattingContext(layoutBox);</span>
<span class="line-removed">-     formattingContext-&gt;layout();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Come back and finalize the root&#39;s geometry.</span>
<span class="line-removed">-     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Compute] -&gt; [Height][Margin] -&gt; for layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-removed">-     computeHeightAndMargin(layoutBox);</span>
<span class="line-removed">-     // Now that we computed the root&#39;s height, we can go back and layout the out-of-flow content.</span>
<span class="line-removed">-     formattingContext-&gt;layoutOutOfFlowContent();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Float related final positioning.</span>
<span class="line-removed">-     if (layoutBox.isFloatingPositioned()) {</span>
<span class="line-removed">-         computeFloatingPosition(floatingContext, layoutBox);</span>
<span class="line-removed">-         floatingContext.floatingState().append(layoutBox);</span>
<span class="line-removed">-     } else if (layoutBox.establishesBlockFormattingContext())</span>
<span class="line-removed">-         computePositionToAvoidFloats(floatingContext, layoutBox);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BlockFormattingContext::placeInFlowPositionedChildren(const Box&amp; layoutBox) const</span>
  {
      if (!is&lt;Container&gt;(layoutBox))
          return;
<span class="line-removed">- </span>
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;Start: move in-flow positioned children -&gt; parent: &quot; &lt;&lt; &amp;layoutBox);
      auto&amp; container = downcast&lt;Container&gt;(layoutBox);
      for (auto&amp; childBox : childrenOfType&lt;Box&gt;(container)) {
          if (!childBox.isInFlowPositioned())
              continue;
<span class="line-modified">! </span>
<span class="line-modified">!         auto computeInFlowPositionedPosition = [&amp;] {</span>
<span class="line-removed">-             auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">-             auto positionOffset = Geometry::inFlowPositionedPositionOffset(layoutState, childBox);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             auto&amp; displayBox = layoutState.displayBoxForLayoutBox(childBox);</span>
<span class="line-removed">-             auto topLeft = displayBox.topLeft();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             topLeft.move(positionOffset);</span>
<span class="line-removed">- </span>
<span class="line-removed">-             displayBox.setTopLeft(topLeft);</span>
<span class="line-removed">-         };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         computeInFlowPositionedPosition();</span>
      }
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;End: move in-flow positioned children -&gt; parent: &quot; &lt;&lt; &amp;layoutBox);
  }
  
<span class="line-modified">! void BlockFormattingContext::computeStaticVerticalPosition(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">-     layoutState.displayBoxForLayoutBox(layoutBox).setTop(Geometry::staticVerticalPosition(layoutState, layoutBox));</span>
<span class="line-removed">-     if (layoutBox.hasFloatClear())</span>
<span class="line-removed">-         computeEstimatedVerticalPositionForFloatClear(floatingContext, layoutBox);</span>
<span class="line-removed">-     else if (layoutBox.establishesFormattingContext())</span>
<span class="line-removed">-         computeEstimatedVerticalPositionForFormattingRoot(layoutBox);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BlockFormattingContext::computeStaticHorizontalPosition(const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     layoutState().displayBoxForLayoutBox(layoutBox).setLeft(Geometry::staticHorizontalPosition(layoutState(), layoutBox));</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::computeStaticPosition(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     computeStaticVerticalPosition(floatingContext, layoutBox);</span>
<span class="line-removed">-     computeStaticHorizontalPosition(layoutBox);</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::computeEstimatedVerticalPosition(const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">!     auto estimatedMarginBefore = MarginCollapse::estimatedMarginBefore(layoutState, layoutBox);</span>
<span class="line-modified">!     setEstimatedMarginBefore(layoutBox, estimatedMarginBefore);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     auto nonCollapsedValues = UsedVerticalMargin::NonCollapsedValues { estimatedMarginBefore.nonCollapsedValue, { } };</span>
<span class="line-modified">!     auto collapsedValues = UsedVerticalMargin::CollapsedValues { estimatedMarginBefore.collapsedValue, { }, estimatedMarginBefore.isCollapsedThrough };</span>
      auto verticalMargin = UsedVerticalMargin { nonCollapsedValues, collapsedValues };
      displayBox.setVerticalMargin(verticalMargin);
<span class="line-modified">!     displayBox.setTop(verticalPositionWithMargin(layoutBox, verticalMargin));</span>
<span class="line-modified">! #if !ASSERT_DISABLED</span>
<span class="line-modified">!     displayBox.setHasEstimatedMarginBefore();</span>
  #endif
  }
  
<span class="line-modified">! void BlockFormattingContext::computeEstimatedVerticalPositionForAncestors(const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     // We only need to estimate margin top for float related layout (formatting context roots avoid floats).</span>
<span class="line-modified">!     ASSERT(layoutBox.isFloatingPositioned() || layoutBox.hasFloatClear() || layoutBox.establishesBlockFormattingContext() || layoutBox.establishesInlineFormattingContext());</span>
  
      // In order to figure out whether a box should avoid a float, we need to know the final positions of both (ignore relative positioning for now).
      // In block formatting context the final position for a normal flow box includes
      // 1. the static position and
      // 2. the corresponding (non)collapsed margins.
      // Now the vertical margins are computed when all the descendants are finalized, because the margin values might be depending on the height of the box
      // (and the height might be based on the content).
      // So when we get to the point where we intersect the box with the float to decide if the box needs to move, we don&#39;t yet have the final vertical position.
      //
      // The idea here is that as long as we don&#39;t cross the block formatting context boundary, we should be able to pre-compute the final top position.
      for (auto* ancestor = layoutBox.containingBlock(); ancestor &amp;&amp; !ancestor-&gt;establishesBlockFormattingContext(); ancestor = ancestor-&gt;containingBlock()) {
<span class="line-modified">!         // FIXME: with incremental layout, we might actually have a valid (non-estimated) margin top as well.</span>
<span class="line-modified">!         if (hasEstimatedMarginBefore(*ancestor))</span>
              return;
<span class="line-modified">!         computeEstimatedVerticalPosition(*ancestor);</span>
      }
  }
  
<span class="line-modified">! void BlockFormattingContext::computeEstimatedVerticalPositionForFormattingRoot(const Box&amp; layoutBox) const</span>
  {
      ASSERT(layoutBox.establishesFormattingContext());
<span class="line-modified">!     ASSERT(!layoutBox.hasFloatClear());</span>
  
      if (layoutBox.isFloatingPositioned()) {
<span class="line-modified">!         computeEstimatedVerticalPositionForAncestors(layoutBox);</span>
          return;
      }
  
<span class="line-modified">!     computeEstimatedVerticalPosition(layoutBox);</span>
<span class="line-modified">!     computeEstimatedVerticalPositionForAncestors(layoutBox);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     // If the inline formatting root is also the root for the floats (happens when the root box also establishes a block formatting context)</span>
<span class="line-removed">-     // the floats are in the coordinate system of this root. No need to find the final vertical position.</span>
<span class="line-removed">-     auto inlineContextInheritsFloats = layoutBox.establishesInlineFormattingContextOnly();</span>
<span class="line-removed">-     if (inlineContextInheritsFloats) {</span>
<span class="line-removed">-         computeEstimatedVerticalPosition(layoutBox);</span>
<span class="line-removed">-         computeEstimatedVerticalPositionForAncestors(layoutBox);</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::computeEstimatedVerticalPositionForFloatClear(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const</span>
  {
      ASSERT(layoutBox.hasFloatClear());
<span class="line-modified">!     if (floatingContext.floatingState().isEmpty())</span>
          return;
<span class="line-removed">-     // The static position with clear requires margin esitmation to see if clearance is needed.</span>
<span class="line-removed">-     computeEstimatedVerticalPosition(layoutBox);</span>
<span class="line-removed">-     computeEstimatedVerticalPositionForAncestors(layoutBox);</span>
      auto verticalPositionAndClearance = floatingContext.verticalPositionWithClearance(layoutBox);
      if (!verticalPositionAndClearance.position) {
          ASSERT(!verticalPositionAndClearance.clearance);
          return;
      }
  
<span class="line-modified">!     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
      ASSERT(*verticalPositionAndClearance.position &gt;= displayBox.top());
      displayBox.setTop(*verticalPositionAndClearance.position);
      if (verticalPositionAndClearance.clearance)
          displayBox.setHasClearance();
  }
  
<span class="line-modified">! #ifndef NDEBUG</span>
<span class="line-removed">- bool BlockFormattingContext::hasPrecomputedMarginBefore(const Box&amp; layoutBox) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto* ancestor = layoutBox.containingBlock(); ancestor &amp;&amp; !ancestor-&gt;establishesBlockFormattingContext(); ancestor = ancestor-&gt;containingBlock()) {</span>
<span class="line-removed">-         if (hasEstimatedMarginBefore(*ancestor))</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BlockFormattingContext::computeFloatingPosition(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(layoutBox.isFloatingPositioned());</span>
<span class="line-removed">-     ASSERT(hasPrecomputedMarginBefore(layoutBox));</span>
<span class="line-removed">-     layoutState().displayBoxForLayoutBox(layoutBox).setTopLeft(floatingContext.positionForFloat(layoutBox));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BlockFormattingContext::computePositionToAvoidFloats(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">-     // Formatting context roots avoid floats.</span>
<span class="line-removed">-     ASSERT(layoutBox.establishesBlockFormattingContext());</span>
<span class="line-removed">-     ASSERT(!layoutBox.isFloatingPositioned());</span>
<span class="line-removed">-     ASSERT(!layoutBox.hasFloatClear());</span>
<span class="line-removed">-     ASSERT(hasPrecomputedMarginBefore(layoutBox));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (floatingContext.floatingState().isEmpty())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (auto adjustedPosition = floatingContext.positionForFormattingContextRoot(layoutBox))</span>
<span class="line-removed">-         layoutState.displayBoxForLayoutBox(layoutBox).setTopLeft(*adjustedPosition);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BlockFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, Optional&lt;LayoutUnit&gt; usedAvailableWidth) const</span>
  {
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
  
<span class="line-modified">!     LayoutUnit availableWidth;</span>
<span class="line-modified">!     if (usedAvailableWidth)</span>
<span class="line-modified">!         availableWidth = *usedAvailableWidth;</span>
<span class="line-modified">!     else</span>
<span class="line-removed">-         availableWidth = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth();</span>
  
<span class="line-removed">-     auto compute = [&amp;](Optional&lt;LayoutUnit&gt; usedWidth) -&gt; WidthAndMargin {</span>
<span class="line-removed">-         auto usedValues = UsedHorizontalValues { availableWidth, usedWidth, { } };</span>
          if (layoutBox.isInFlow())
<span class="line-modified">!             return Geometry::inFlowWidthAndMargin(layoutState, layoutBox, usedValues);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (layoutBox.isFloatingPositioned())</span>
<span class="line-removed">-             return Geometry::floatingWidthAndMargin(layoutState, layoutBox, usedValues);</span>
  
          ASSERT_NOT_REACHED();
          return { };
      };
  
<span class="line-modified">!     auto widthAndMargin = compute({ });</span>
  
<span class="line-modified">!     if (auto maxWidth = Geometry::computedValueIfNotAuto(layoutBox.style().logicalMaxWidth(), availableWidth)) {</span>
          auto maxWidthAndMargin = compute(maxWidth);
<span class="line-modified">!         if (widthAndMargin.width &gt; maxWidthAndMargin.width)</span>
<span class="line-modified">!             widthAndMargin = maxWidthAndMargin;</span>
      }
  
<span class="line-modified">!     auto minWidth = Geometry::computedValueIfNotAuto(layoutBox.style().logicalMinWidth(), availableWidth).valueOr(0);</span>
      auto minWidthAndMargin = compute(minWidth);
<span class="line-modified">!     if (widthAndMargin.width &lt; minWidthAndMargin.width)</span>
<span class="line-modified">!         widthAndMargin = minWidthAndMargin;</span>
  
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     displayBox.setContentBoxWidth(widthAndMargin.width);</span>
<span class="line-modified">!     displayBox.setHorizontalMargin(widthAndMargin.usedMargin);</span>
<span class="line-modified">!     displayBox.setHorizontalComputedMargin(widthAndMargin.computedMargin);</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto compute = [&amp;](UsedVerticalValues usedValues) -&gt; HeightAndMargin {</span>
<span class="line-removed">- </span>
          if (layoutBox.isInFlow())
<span class="line-modified">!             return Geometry::inFlowHeightAndMargin(layoutState, layoutBox, usedValues);</span>
  
          if (layoutBox.isFloatingPositioned())
<span class="line-modified">!             return Geometry::floatingHeightAndMargin(layoutState, layoutBox, usedValues, UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() });</span>
  
          ASSERT_NOT_REACHED();
          return { };
      };
  
<span class="line-modified">!     auto heightAndMargin = compute({ });</span>
<span class="line-modified">!     if (auto maxHeight = Geometry::computedMaxHeight(layoutState, layoutBox)) {</span>
<span class="line-modified">!         if (heightAndMargin.height &gt; *maxHeight) {</span>
<span class="line-modified">!             auto maxHeightAndMargin = compute({ *maxHeight });</span>
              // Used height should remain the same.
<span class="line-modified">!             ASSERT((layoutState.inQuirksMode() &amp;&amp; (layoutBox.isBodyBox() || layoutBox.isDocumentBox())) || maxHeightAndMargin.height == *maxHeight);</span>
<span class="line-modified">!             heightAndMargin = { *maxHeight, maxHeightAndMargin.nonCollapsedMargin };</span>
          }
      }
  
<span class="line-modified">!     if (auto minHeight = Geometry::computedMinHeight(layoutState, layoutBox)) {</span>
<span class="line-modified">!         if (heightAndMargin.height &lt; *minHeight) {</span>
<span class="line-modified">!             auto minHeightAndMargin = compute({ *minHeight });</span>
              // Used height should remain the same.
<span class="line-modified">!             ASSERT((layoutState.inQuirksMode() &amp;&amp; (layoutBox.isBodyBox() || layoutBox.isDocumentBox())) || minHeightAndMargin.height == *minHeight);</span>
<span class="line-modified">!             heightAndMargin = { *minHeight, minHeightAndMargin.nonCollapsedMargin };</span>
          }
      }
  
      // 1. Compute collapsed margins.
      // 2. Adjust vertical position using the collapsed values
      // 3. Adjust previous in-flow sibling margin after using this margin.
<span class="line-modified">!     auto collapsedMargin = MarginCollapse::collapsedVerticalValues(layoutState, layoutBox, heightAndMargin.nonCollapsedMargin);</span>
<span class="line-modified">!     auto verticalMargin = UsedVerticalMargin { heightAndMargin.nonCollapsedMargin, collapsedMargin };</span>
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
  
      // Out of flow boxes don&#39;t need vertical adjustment after margin collapsing.
      if (layoutBox.isOutOfFlowPositioned()) {
<span class="line-modified">!         ASSERT(!hasEstimatedMarginBefore(layoutBox));</span>
<span class="line-modified">!         displayBox.setContentBoxHeight(heightAndMargin.height);</span>
          displayBox.setVerticalMargin(verticalMargin);
          return;
      }
  
<span class="line-modified">!     ASSERT(!hasEstimatedMarginBefore(layoutBox) || estimatedMarginBefore(layoutBox).usedValue() == verticalMargin.before());</span>
<span class="line-modified">!     removeEstimatedMarginBefore(layoutBox);</span>
<span class="line-modified">!     displayBox.setTop(verticalPositionWithMargin(layoutBox, verticalMargin));</span>
<span class="line-modified">!     displayBox.setContentBoxHeight(heightAndMargin.height);</span>
      displayBox.setVerticalMargin(verticalMargin);
  
<span class="line-modified">!     MarginCollapse::updatePositiveNegativeMarginValues(layoutState, layoutBox);</span>
      // Adjust the previous sibling&#39;s margin bottom now that this box&#39;s vertical margin is computed.
<span class="line-modified">!     MarginCollapse::updateMarginAfterForPreviousSibling(layoutState, layoutBox);</span>
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints BlockFormattingContext::computedIntrinsicWidthConstraints() const</span>
  {
<span class="line-removed">-     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed">-     auto&amp; formattingRoot = root();</span>
      auto&amp; formattingState = this-&gt;formattingState();
      ASSERT(!formattingState.intrinsicWidthConstraints());
  
      // Visit the in-flow descendants and compute their min/max intrinsic width if needed.
      // 1. Go all the way down to the leaf node
      // 2. Check if actually need to visit all the boxes as we traverse down (already computed, container&#39;s min/max does not depend on descendants etc)
      // 3. As we climb back on the tree, compute min/max intrinsic width
      // (Any subtrees with new formatting contexts need to layout synchronously)
      Vector&lt;const Box*&gt; queue;
<span class="line-modified">!     if (is&lt;Container&gt;(formattingRoot) &amp;&amp; downcast&lt;Container&gt;(formattingRoot).hasInFlowOrFloatingChild())</span>
<span class="line-modified">!         queue.append(downcast&lt;Container&gt;(formattingRoot).firstInFlowOrFloatingChild());</span>
  
      IntrinsicWidthConstraints constraints;
      while (!queue.isEmpty()) {
          while (true) {
              auto&amp; layoutBox = *queue.last();
<span class="line-new-header">--- 27,431 ---</span>
  #include &quot;BlockFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;BlockFormattingState.h&quot;
  #include &quot;FloatingContext.h&quot;
  #include &quot;FloatingState.h&quot;
<span class="line-added">+ #include &quot;InvalidationState.h&quot;</span>
  #include &quot;LayoutBox.h&quot;
<span class="line-added">+ #include &quot;LayoutChildIterator.h&quot;</span>
  #include &quot;LayoutContainer.h&quot;
<span class="line-added">+ #include &quot;LayoutContext.h&quot;</span>
  #include &quot;LayoutState.h&quot;
  #include &quot;Logging.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(BlockFormattingContext);
  
<span class="line-modified">! BlockFormattingContext::BlockFormattingContext(const Container&amp; formattingContextRoot, BlockFormattingState&amp; formattingState)</span>
      : FormattingContext(formattingContextRoot, formattingState)
  {
  }
  
<span class="line-modified">! void BlockFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; rootHorizontalConstraints, const VerticalConstraints&amp; rootVerticalConstraints)</span>
  {
      // 9.4.1 Block formatting contexts
      // In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block.
      // The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties.
      // Vertical margins between adjacent block-level boxes in a block formatting context collapse.
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; block formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);
<span class="line-added">+     auto&amp; formattingRoot = root();</span>
<span class="line-added">+     ASSERT(formattingRoot.hasInFlowOrFloatingChild());</span>
<span class="line-added">+     auto floatingContext = FloatingContext { formattingRoot, *this, formattingState().floatingState() };</span>
  
      LayoutQueue layoutQueue;
<span class="line-modified">!     enum class LayoutDirection { Child, Sibling };</span>
<span class="line-added">+     auto appendNextToLayoutQueue = [&amp;] (const auto&amp; layoutBox, auto direction) {</span>
<span class="line-added">+         if (direction == LayoutDirection::Child) {</span>
<span class="line-added">+             if (!is&lt;Container&gt;(layoutBox))</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             for (auto* child = downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild(); child; child = child-&gt;nextInFlowOrFloatingSibling()) {</span>
<span class="line-added">+                 if (!invalidationState.needsLayout(*child))</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 layoutQueue.append(child);</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (direction == LayoutDirection::Sibling) {</span>
<span class="line-added">+             for (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling(); nextSibling; nextSibling = nextSibling-&gt;nextInFlowOrFloatingSibling()) {</span>
<span class="line-added">+                 if (!invalidationState.needsLayout(*nextSibling))</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 layoutQueue.append(nextSibling);</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto horizontalConstraintsForLayoutBox = [&amp;] (const auto&amp; layoutBox) -&gt; ConstraintsPair&lt;HorizontalConstraints&gt; {</span>
<span class="line-added">+         auto* containingBlock = layoutBox.containingBlock();</span>
<span class="line-added">+         ASSERT(containingBlock);</span>
<span class="line-added">+         if (containingBlock == &amp;formattingRoot)</span>
<span class="line-added">+             return { rootHorizontalConstraints, rootHorizontalConstraints };</span>
<span class="line-added">+         return { rootHorizontalConstraints, Geometry::horizontalConstraintsForInFlow(geometryForBox(*containingBlock)) };</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto verticalConstraintsForLayoutBox = [&amp;] (const auto&amp; layoutBox) -&gt; ConstraintsPair&lt;VerticalConstraints&gt; {</span>
<span class="line-added">+         auto* containingBlock = layoutBox.containingBlock();</span>
<span class="line-added">+         ASSERT(containingBlock);</span>
<span class="line-added">+         if (containingBlock == &amp;formattingRoot)</span>
<span class="line-added">+             return { rootVerticalConstraints, rootVerticalConstraints };</span>
<span class="line-added">+         return { rootVerticalConstraints, Geometry::verticalConstraintsForInFlow(geometryForBox(*containingBlock)) };</span>
<span class="line-added">+     };</span>
      // This is a post-order tree traversal layout.
      // The root container layout is done in the formatting context it lives in, not that one it creates, so let&#39;s start with the first child.
<span class="line-modified">!     appendNextToLayoutQueue(formattingRoot, LayoutDirection::Child);</span>
      // 1. Go all the way down to the leaf node
      // 2. Compute static position and width as we traverse down
      // 3. As we climb back on the tree, compute height and finialize position
      // (Any subtrees with new formatting contexts need to layout synchronously)
      while (!layoutQueue.isEmpty()) {
          // Traverse down on the descendants and compute width/static position until we find a leaf node.
          while (true) {
              auto&amp; layoutBox = *layoutQueue.last();
<span class="line-added">+             auto horizontalConstraints = horizontalConstraintsForLayoutBox(layoutBox);</span>
<span class="line-added">+             auto verticalConstraints = verticalConstraintsForLayoutBox(layoutBox);</span>
<span class="line-added">+ </span>
<span class="line-added">+             computeBorderAndPadding(layoutBox, horizontalConstraints.containingBlock);</span>
<span class="line-added">+             computeStaticVerticalPosition(layoutBox, verticalConstraints);</span>
<span class="line-added">+             computeWidthAndMargin(floatingContext, layoutBox, horizontalConstraints);</span>
<span class="line-added">+             computeStaticHorizontalPosition(layoutBox, horizontalConstraints);</span>
  
              if (layoutBox.establishesFormattingContext()) {
<span class="line-modified">!                 if (is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild()) {</span>
<span class="line-modified">!                     // Layout the inflow descendants of this formatting context root.</span>
<span class="line-modified">!                     precomputeVerticalPositionForFormattingRoot(floatingContext, layoutBox, horizontalConstraints, verticalConstraints);</span>
<span class="line-modified">!                     auto&amp; rootDisplayBox = geometryForBox(layoutBox);</span>
<span class="line-modified">!                     auto horizontalConstraintsForFormattingContext = Geometry::horizontalConstraintsForInFlow(rootDisplayBox);</span>
<span class="line-modified">!                     auto verticalConstraintsForFormattingContext = Geometry::verticalConstraintsForInFlow(rootDisplayBox);</span>
<span class="line-modified">!                     LayoutContext::createFormattingContext(downcast&lt;Container&gt;(layoutBox), layoutState())-&gt;layoutInFlowContent(invalidationState, horizontalConstraintsForFormattingContext, verticalConstraintsForFormattingContext);</span>
<span class="line-modified">!                 }</span>
<span class="line-added">+                 break;</span>
              }
<span class="line-modified">!             if (!appendNextToLayoutQueue(layoutBox, LayoutDirection::Child))</span>
                  break;
          }
  
          // Climb back on the ancestors and compute height/final position.
          while (!layoutQueue.isEmpty()) {
              auto&amp; layoutBox = *layoutQueue.takeLast();
<span class="line-added">+             auto horizontalConstraints = horizontalConstraintsForLayoutBox(layoutBox);</span>
<span class="line-added">+             auto verticalConstraints = verticalConstraintsForLayoutBox(layoutBox);</span>
  
<span class="line-modified">!             // All inflow descendants (if there are any) are laid out by now. Let&#39;s compute the box&#39;s height.</span>
<span class="line-modified">!             computeHeightAndMargin(layoutBox, horizontalConstraints, verticalConstraints);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (layoutBox.establishesFormattingContext()) {</span>
<span class="line-modified">!                 // Now that we computed the root&#39;s height, we can layout the out-of-flow descendants.</span>
<span class="line-modified">!                 if (is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasChild()) {</span>
<span class="line-modified">!                     auto&amp; rootDisplayBox = geometryForBox(layoutBox);</span>
<span class="line-modified">!                     auto horizontalConstraintsForOutOfFlow =  Geometry::horizontalConstraintsForOutOfFlow(rootDisplayBox);</span>
<span class="line-modified">!                     auto verticalConstraintsForOutOfFlow = Geometry::verticalConstraintsForOutOfFlow(rootDisplayBox);</span>
<span class="line-added">+                     LayoutContext::createFormattingContext(downcast&lt;Container&gt;(layoutBox), layoutState())-&gt;layoutOutOfFlowContent(invalidationState, horizontalConstraintsForOutOfFlow, verticalConstraintsForOutOfFlow);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Resolve final positions.</span>
<span class="line-added">+             placeInFlowPositionedChildren(layoutBox, horizontalConstraints);</span>
<span class="line-added">+             if (layoutBox.isFloatAvoider()) {</span>
<span class="line-added">+                 computePositionToAvoidFloats(floatingContext, layoutBox, horizontalConstraints, verticalConstraints);</span>
<span class="line-added">+                 if (layoutBox.isFloatingPositioned())</span>
<span class="line-added">+                     floatingContext.append(layoutBox);</span>
              }
<span class="line-added">+ </span>
<span class="line-added">+             if (appendNextToLayoutQueue(layoutBox, LayoutDirection::Sibling))</span>
<span class="line-added">+                 break;</span>
          }
      }
      // Place the inflow positioned children.
<span class="line-modified">!     placeInFlowPositionedChildren(formattingRoot, ConstraintsPair&lt;HorizontalConstraints&gt; { rootHorizontalConstraints, rootHorizontalConstraints });</span>
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; block formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);
  }
  
  Optional&lt;LayoutUnit&gt; BlockFormattingContext::usedAvailableWidthForFloatAvoider(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox) const
  {
      // Normally the available width for an in-flow block level box is the width of the containing block&#39;s content box.
      // However (and can&#39;t find it anywhere in the spec) non-floating positioned float avoider block level boxes are constrained by existing floats.
<span class="line-modified">!     ASSERT(layoutBox.isFloatAvoider());</span>
<span class="line-modified">!     if (floatingContext.isEmpty())</span>
          return { };
<span class="line-modified">!     // Vertical static position is not computed yet, so let&#39;s just pre-compute it for now.</span>
<span class="line-modified">!     auto verticalPosition = mapTopToFormattingContextRoot(layoutBox);</span>
<span class="line-modified">!     // FIXME: Check if the non-yet-computed height affects this computation - and whether we have to resolve it</span>
<span class="line-modified">!     // at a later point or not (can&#39;t find this in the spec).</span>
<span class="line-added">+     auto constraints = floatingContext.constraints(verticalPosition, verticalPosition);</span>
      if (!constraints.left &amp;&amp; !constraints.right)
          return { };
<span class="line-modified">!     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-modified">!     auto&amp; containingBlockGeometry = geometryForBox(containingBlock);</span>
<span class="line-modified">!     auto availableWidth = containingBlockGeometry.contentBoxWidth();</span>
  
      LayoutUnit containingBlockLeft;
<span class="line-modified">!     LayoutUnit containingBlockRight = containingBlockGeometry.right();</span>
<span class="line-modified">!     if (&amp;containingBlock != &amp;root()) {</span>
          // Move containing block left/right to the root&#39;s coordinate system.
<span class="line-modified">!         containingBlockLeft = mapLeftToFormattingContextRoot(containingBlock);</span>
<span class="line-modified">!         containingBlockRight = mapRightToFormattingContextRoot(containingBlock);</span>
      }
<span class="line-modified">!     auto containingBlockContentBoxLeft = containingBlockLeft + containingBlockGeometry.borderLeft() + containingBlockGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified">!     auto containingBlockContentBoxRight = containingBlockRight - containingBlockGeometry.borderRight() + containingBlockGeometry.paddingRight().valueOr(0);</span>
  
      // Shrink the available space if the floats are actually intruding at this vertical position.
      if (constraints.left)
          availableWidth -= std::max&lt;LayoutUnit&gt;(0, constraints.left-&gt;x - containingBlockContentBoxLeft);
      if (constraints.right)
          availableWidth -= std::max&lt;LayoutUnit&gt;(0, containingBlockContentBoxRight - constraints.right-&gt;x);
      return availableWidth;
  }
  
<span class="line-modified">! void BlockFormattingContext::placeInFlowPositionedChildren(const Box&amp; layoutBox, const ConstraintsPair&lt;HorizontalConstraints&gt;&amp; horizontalConstraints)</span>
  {
      if (!is&lt;Container&gt;(layoutBox))
          return;
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;Start: move in-flow positioned children -&gt; parent: &quot; &lt;&lt; &amp;layoutBox);
      auto&amp; container = downcast&lt;Container&gt;(layoutBox);
      for (auto&amp; childBox : childrenOfType&lt;Box&gt;(container)) {
          if (!childBox.isInFlowPositioned())
              continue;
<span class="line-modified">!         auto positionOffset = geometry().inFlowPositionedPositionOffset(childBox, horizontalConstraints.containingBlock);</span>
<span class="line-modified">!         formattingState().displayBox(childBox).move(positionOffset);</span>
      }
      LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;End: move in-flow positioned children -&gt; parent: &quot; &lt;&lt; &amp;layoutBox);
  }
  
<span class="line-modified">! void BlockFormattingContext::computeStaticVerticalPosition(const Box&amp; layoutBox, const ConstraintsPair&lt;VerticalConstraints&gt;&amp; verticalConstraints)</span>
  {
<span class="line-modified">!     formattingState().displayBox(layoutBox).setTop(geometry().staticVerticalPosition(layoutBox, verticalConstraints.containingBlock));</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::computeStaticHorizontalPosition(const Box&amp; layoutBox, const ConstraintsPair&lt;HorizontalConstraints&gt;&amp; horizontalConstraints)</span>
  {
<span class="line-modified">!     formattingState().displayBox(layoutBox).setLeft(geometry().staticHorizontalPosition(layoutBox, horizontalConstraints.containingBlock));</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::precomputeVerticalPosition(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints)</span>
  {
<span class="line-modified">!     auto computedVerticalMargin = geometry().computedVerticalMargin(layoutBox, horizontalConstraints);</span>
<span class="line-modified">!     auto usedNonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };</span>
<span class="line-modified">!     auto precomputedMarginBefore = marginCollapse().precomputedMarginBefore(layoutBox, usedNonCollapsedMargin);</span>
<span class="line-modified">!     setPrecomputedMarginBefore(layoutBox, precomputedMarginBefore);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
<span class="line-modified">!     auto nonCollapsedValues = UsedVerticalMargin::NonCollapsedValues { precomputedMarginBefore.nonCollapsedValue, { } };</span>
<span class="line-added">+     auto collapsedValues = UsedVerticalMargin::CollapsedValues { precomputedMarginBefore.collapsedValue, { }, precomputedMarginBefore.isCollapsedThrough };</span>
      auto verticalMargin = UsedVerticalMargin { nonCollapsedValues, collapsedValues };
      displayBox.setVerticalMargin(verticalMargin);
<span class="line-modified">!     displayBox.setTop(verticalPositionWithMargin(layoutBox, verticalMargin, verticalConstraints));</span>
<span class="line-modified">! #if ASSERT_ENABLED</span>
<span class="line-modified">!     displayBox.setHasPrecomputedMarginBefore();</span>
  #endif
  }
  
<span class="line-modified">! void BlockFormattingContext::precomputeVerticalPositionForAncestors(const Box&amp; layoutBox, const ConstraintsPair&lt;HorizontalConstraints&gt;&amp; horizontalConstraints, const ConstraintsPair&lt;VerticalConstraints&gt;&amp; verticalConstraints)</span>
  {
<span class="line-modified">!     // We only need to pre-compute the margin top for float related layout (formatting context roots avoid floats).</span>
<span class="line-modified">!     ASSERT(layoutBox.isFloatAvoider() || layoutBox.establishesInlineFormattingContext());</span>
  
      // In order to figure out whether a box should avoid a float, we need to know the final positions of both (ignore relative positioning for now).
      // In block formatting context the final position for a normal flow box includes
      // 1. the static position and
      // 2. the corresponding (non)collapsed margins.
      // Now the vertical margins are computed when all the descendants are finalized, because the margin values might be depending on the height of the box
      // (and the height might be based on the content).
      // So when we get to the point where we intersect the box with the float to decide if the box needs to move, we don&#39;t yet have the final vertical position.
      //
      // The idea here is that as long as we don&#39;t cross the block formatting context boundary, we should be able to pre-compute the final top position.
<span class="line-added">+     // FIXME: we currently don&#39;t account for the &quot;clear&quot; property when computing the final position for an ancestor.</span>
      for (auto* ancestor = layoutBox.containingBlock(); ancestor &amp;&amp; !ancestor-&gt;establishesBlockFormattingContext(); ancestor = ancestor-&gt;containingBlock()) {
<span class="line-modified">!         // FIXME: with incremental layout, we might actually have a valid (non-precomputed) margin top as well.</span>
<span class="line-modified">!         if (hasPrecomputedMarginBefore(*ancestor))</span>
              return;
<span class="line-modified">!         auto horizontalConstraintsForAncestor = [&amp;] {</span>
<span class="line-added">+             auto* containingBlock = layoutBox.containingBlock();</span>
<span class="line-added">+             return containingBlock == &amp;root() ? horizontalConstraints.root : Geometry::horizontalConstraintsForInFlow(geometryForBox(*containingBlock));</span>
<span class="line-added">+         };</span>
<span class="line-added">+         auto verticalConstraintsForAncestor = [&amp;] {</span>
<span class="line-added">+             auto* containingBlock = layoutBox.containingBlock();</span>
<span class="line-added">+             return containingBlock == &amp;root() ? verticalConstraints.root : Geometry::verticalConstraintsForInFlow(geometryForBox(*containingBlock));</span>
<span class="line-added">+         };</span>
<span class="line-added">+         precomputeVerticalPosition(*ancestor, horizontalConstraintsForAncestor(), verticalConstraintsForAncestor());</span>
      }
  }
  
<span class="line-modified">! void BlockFormattingContext::precomputeVerticalPositionForFormattingRoot(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox, const ConstraintsPair&lt;HorizontalConstraints&gt;&amp; horizontalConstraints, const ConstraintsPair&lt;VerticalConstraints&gt;&amp; verticalConstraints)</span>
  {
      ASSERT(layoutBox.establishesFormattingContext());
<span class="line-modified">!     if (layoutBox.isFloatAvoider() &amp;&amp; !layoutBox.hasFloatClear())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     // We need the final vertical position when the formatting context inherits floats from the parent FC.</span>
<span class="line-added">+     precomputeVerticalPositionForAncestors(layoutBox, horizontalConstraints, verticalConstraints);</span>
<span class="line-added">+     precomputeVerticalPosition(layoutBox, horizontalConstraints.containingBlock, verticalConstraints.containingBlock);</span>
<span class="line-added">+     if (layoutBox.hasFloatClear()) {</span>
<span class="line-added">+         // if we just let the box sit at the static vertical position, we might find unrelated float boxes there (boxes that we need to clear).</span>
<span class="line-added">+         computeVerticalPositionForFloatClear(floatingContext, layoutBox);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ void BlockFormattingContext::computePositionToAvoidFloats(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox, const ConstraintsPair&lt;HorizontalConstraints&gt;&amp; horizontalConstraints, const ConstraintsPair&lt;VerticalConstraints&gt;&amp; verticalConstraints)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(layoutBox.isFloatAvoider());</span>
<span class="line-added">+     // In order to position a float avoider we need to know its vertical position relative to its formatting context root (and not just its containing block),</span>
<span class="line-added">+     // because all the already-placed floats (floats that we are trying to avoid here) in this BFC might belong</span>
<span class="line-added">+     // to a different set of containing blocks (but they all descendants of the BFC root).</span>
<span class="line-added">+     // However according to the BFC rules, at this point of the layout flow we don&#39;t yet have computed vertical positions for the ancestors.</span>
      if (layoutBox.isFloatingPositioned()) {
<span class="line-modified">!         precomputeVerticalPositionForAncestors(layoutBox, horizontalConstraints, verticalConstraints);</span>
<span class="line-added">+         formattingState().displayBox(layoutBox).setTopLeft(floatingContext.positionForFloat(layoutBox));</span>
          return;
      }
<span class="line-added">+     // Non-float positioned float avoiders (formatting context roots and clear boxes) should be fine unless there are floats in this context.</span>
<span class="line-added">+     if (floatingContext.isEmpty())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     precomputeVerticalPositionForAncestors(layoutBox, horizontalConstraints, verticalConstraints);</span>
<span class="line-added">+     if (layoutBox.hasFloatClear())</span>
<span class="line-added">+         return computeVerticalPositionForFloatClear(floatingContext, layoutBox);</span>
  
<span class="line-modified">!     ASSERT(layoutBox.establishesFormattingContext());</span>
<span class="line-modified">!     if (auto adjustedPosition = floatingContext.positionForFormattingContextRoot(layoutBox))</span>
<span class="line-modified">!         formattingState().displayBox(layoutBox).setTopLeft(*adjustedPosition);</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::computeVerticalPositionForFloatClear(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox)</span>
  {
      ASSERT(layoutBox.hasFloatClear());
<span class="line-modified">!     if (floatingContext.isEmpty())</span>
          return;
      auto verticalPositionAndClearance = floatingContext.verticalPositionWithClearance(layoutBox);
      if (!verticalPositionAndClearance.position) {
          ASSERT(!verticalPositionAndClearance.clearance);
          return;
      }
  
<span class="line-modified">!     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
      ASSERT(*verticalPositionAndClearance.position &gt;= displayBox.top());
      displayBox.setTop(*verticalPositionAndClearance.position);
      if (verticalPositionAndClearance.clearance)
          displayBox.setHasClearance();
  }
  
<span class="line-modified">! void BlockFormattingContext::computeWidthAndMargin(const FloatingContext&amp; floatingContext, const Box&amp; layoutBox, const ConstraintsPair&lt;HorizontalConstraints&gt;&amp; horizontalConstraints)</span>
  {
<span class="line-modified">!     auto compute = [&amp;](Optional&lt;LayoutUnit&gt; usedWidth) -&gt; ContentWidthAndMargin {</span>
<span class="line-added">+         if (layoutBox.isFloatingPositioned())</span>
<span class="line-added">+             return geometry().floatingWidthAndMargin(layoutBox, horizontalConstraints.containingBlock, { usedWidth, { } });</span>
  
<span class="line-modified">!         if (layoutBox.isFloatAvoider()) {</span>
<span class="line-modified">!             auto availableWidth = usedAvailableWidthForFloatAvoider(floatingContext, layoutBox).valueOr(horizontalConstraints.containingBlock.logicalWidth);</span>
<span class="line-modified">!             return geometry().inFlowWidthAndMargin(layoutBox, { horizontalConstraints.containingBlock.logicalLeft, availableWidth }, { usedWidth, { } });</span>
<span class="line-modified">!         }</span>
  
          if (layoutBox.isInFlow())
<span class="line-modified">!             return geometry().inFlowWidthAndMargin(layoutBox, horizontalConstraints.containingBlock, { usedWidth, { } });</span>
  
          ASSERT_NOT_REACHED();
          return { };
      };
  
<span class="line-modified">!     auto contentWidthAndMargin = compute({ });</span>
  
<span class="line-modified">!     auto availableWidth = horizontalConstraints.containingBlock.logicalWidth;</span>
<span class="line-added">+     if (auto maxWidth = geometry().computedMaxWidth(layoutBox, availableWidth)) {</span>
          auto maxWidthAndMargin = compute(maxWidth);
<span class="line-modified">!         if (contentWidthAndMargin.contentWidth &gt; maxWidthAndMargin.contentWidth)</span>
<span class="line-modified">!             contentWidthAndMargin = maxWidthAndMargin;</span>
      }
  
<span class="line-modified">!     auto minWidth = geometry().computedMinWidth(layoutBox, availableWidth).valueOr(0);</span>
      auto minWidthAndMargin = compute(minWidth);
<span class="line-modified">!     if (contentWidthAndMargin.contentWidth &lt; minWidthAndMargin.contentWidth)</span>
<span class="line-modified">!         contentWidthAndMargin = minWidthAndMargin;</span>
  
<span class="line-modified">!     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
<span class="line-modified">!     displayBox.setContentBoxWidth(contentWidthAndMargin.contentWidth);</span>
<span class="line-modified">!     displayBox.setHorizontalMargin(contentWidthAndMargin.usedMargin);</span>
<span class="line-modified">!     displayBox.setHorizontalComputedMargin(contentWidthAndMargin.computedMargin);</span>
  }
  
<span class="line-modified">! void BlockFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox, const ConstraintsPair&lt;HorizontalConstraints&gt;&amp; horizontalConstraints, const ConstraintsPair&lt;VerticalConstraints&gt;&amp; verticalConstraints)</span>
  {
<span class="line-modified">!     auto compute = [&amp;](Optional&lt;LayoutUnit&gt; usedHeight) -&gt; ContentHeightAndMargin {</span>
          if (layoutBox.isInFlow())
<span class="line-modified">!             return geometry().inFlowHeightAndMargin(layoutBox, horizontalConstraints.containingBlock, { usedHeight });</span>
  
          if (layoutBox.isFloatingPositioned())
<span class="line-modified">!             return geometry().floatingHeightAndMargin(layoutBox, horizontalConstraints.containingBlock, { usedHeight });</span>
  
          ASSERT_NOT_REACHED();
          return { };
      };
  
<span class="line-modified">!     auto contentHeightAndMargin = compute({ });</span>
<span class="line-modified">!     if (auto maxHeight = geometry().computedMaxHeight(layoutBox)) {</span>
<span class="line-modified">!         if (contentHeightAndMargin.contentHeight &gt; *maxHeight) {</span>
<span class="line-modified">!             auto maxHeightAndMargin = compute(maxHeight);</span>
              // Used height should remain the same.
<span class="line-modified">!             ASSERT((layoutState().inQuirksMode() &amp;&amp; (layoutBox.isBodyBox() || layoutBox.isDocumentBox())) || maxHeightAndMargin.contentHeight == *maxHeight);</span>
<span class="line-modified">!             contentHeightAndMargin = { *maxHeight, maxHeightAndMargin.nonCollapsedMargin };</span>
          }
      }
  
<span class="line-modified">!     if (auto minHeight = geometry().computedMinHeight(layoutBox)) {</span>
<span class="line-modified">!         if (contentHeightAndMargin.contentHeight &lt; *minHeight) {</span>
<span class="line-modified">!             auto minHeightAndMargin = compute(minHeight);</span>
              // Used height should remain the same.
<span class="line-modified">!             ASSERT((layoutState().inQuirksMode() &amp;&amp; (layoutBox.isBodyBox() || layoutBox.isDocumentBox())) || minHeightAndMargin.contentHeight == *minHeight);</span>
<span class="line-modified">!             contentHeightAndMargin = { *minHeight, minHeightAndMargin.nonCollapsedMargin };</span>
          }
      }
  
      // 1. Compute collapsed margins.
      // 2. Adjust vertical position using the collapsed values
      // 3. Adjust previous in-flow sibling margin after using this margin.
<span class="line-modified">!     auto collapsedMargin = marginCollapse().collapsedVerticalValues(layoutBox, contentHeightAndMargin.nonCollapsedMargin);</span>
<span class="line-modified">!     auto verticalMargin = UsedVerticalMargin { contentHeightAndMargin.nonCollapsedMargin, collapsedMargin };</span>
<span class="line-modified">!     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
  
      // Out of flow boxes don&#39;t need vertical adjustment after margin collapsing.
      if (layoutBox.isOutOfFlowPositioned()) {
<span class="line-modified">!         ASSERT(!hasPrecomputedMarginBefore(layoutBox));</span>
<span class="line-modified">!         displayBox.setContentBoxHeight(contentHeightAndMargin.contentHeight);</span>
          displayBox.setVerticalMargin(verticalMargin);
          return;
      }
  
<span class="line-modified">!     ASSERT(!hasPrecomputedMarginBefore(layoutBox) || precomputedMarginBefore(layoutBox).usedValue() == verticalMargin.before());</span>
<span class="line-modified">!     removePrecomputedMarginBefore(layoutBox);</span>
<span class="line-modified">!     displayBox.setTop(verticalPositionWithMargin(layoutBox, verticalMargin, verticalConstraints.containingBlock));</span>
<span class="line-modified">!     displayBox.setContentBoxHeight(contentHeightAndMargin.contentHeight);</span>
      displayBox.setVerticalMargin(verticalMargin);
  
<span class="line-modified">!     auto marginCollapse = this-&gt;marginCollapse();</span>
<span class="line-added">+     formattingState().setPositiveAndNegativeVerticalMargin(layoutBox, marginCollapse.resolvedPositiveNegativeMarginValues(layoutBox, contentHeightAndMargin.nonCollapsedMargin));</span>
      // Adjust the previous sibling&#39;s margin bottom now that this box&#39;s vertical margin is computed.
<span class="line-modified">!     MarginCollapse::updateMarginAfterForPreviousSibling(*this, marginCollapse, layoutBox);</span>
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints BlockFormattingContext::computedIntrinsicWidthConstraints()</span>
  {
      auto&amp; formattingState = this-&gt;formattingState();
      ASSERT(!formattingState.intrinsicWidthConstraints());
  
      // Visit the in-flow descendants and compute their min/max intrinsic width if needed.
      // 1. Go all the way down to the leaf node
      // 2. Check if actually need to visit all the boxes as we traverse down (already computed, container&#39;s min/max does not depend on descendants etc)
      // 3. As we climb back on the tree, compute min/max intrinsic width
      // (Any subtrees with new formatting contexts need to layout synchronously)
      Vector&lt;const Box*&gt; queue;
<span class="line-modified">!     if (root().hasInFlowOrFloatingChild())</span>
<span class="line-modified">!         queue.append(root().firstInFlowOrFloatingChild());</span>
  
      IntrinsicWidthConstraints constraints;
      while (!queue.isEmpty()) {
          while (true) {
              auto&amp; layoutBox = *queue.last();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 480,11 ***</span>
          // Compute min/max intrinsic width bottom up if needed.
          while (!queue.isEmpty()) {
              auto&amp; layoutBox = *queue.takeLast();
              auto desdendantConstraints = formattingState.intrinsicWidthConstraintsForBox(layoutBox);
              if (!desdendantConstraints) {
<span class="line-modified">!                 desdendantConstraints = Geometry::intrinsicWidthConstraints(layoutState, layoutBox);</span>
                  formattingState.setIntrinsicWidthConstraintsForBox(layoutBox, *desdendantConstraints);
              }
              constraints.minimum = std::max(constraints.minimum, desdendantConstraints-&gt;minimum);
              constraints.maximum = std::max(constraints.maximum, desdendantConstraints-&gt;maximum);
              // Move over to the next sibling or take the next box in the queue.
<span class="line-new-header">--- 464,11 ---</span>
          // Compute min/max intrinsic width bottom up if needed.
          while (!queue.isEmpty()) {
              auto&amp; layoutBox = *queue.takeLast();
              auto desdendantConstraints = formattingState.intrinsicWidthConstraintsForBox(layoutBox);
              if (!desdendantConstraints) {
<span class="line-modified">!                 desdendantConstraints = geometry().intrinsicWidthConstraints(layoutBox);</span>
                  formattingState.setIntrinsicWidthConstraintsForBox(layoutBox, *desdendantConstraints);
              }
              constraints.minimum = std::max(constraints.minimum, desdendantConstraints-&gt;minimum);
              constraints.maximum = std::max(constraints.maximum, desdendantConstraints-&gt;maximum);
              // Move over to the next sibling or take the next box in the queue.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 496,83 ***</span>
      }
      formattingState.setIntrinsicWidthConstraints(constraints);
      return constraints;
  }
  
<span class="line-modified">! LayoutUnit BlockFormattingContext::verticalPositionWithMargin(const Box&amp; layoutBox, const UsedVerticalMargin&amp; verticalMargin) const</span>
  {
      ASSERT(!layoutBox.isOutOfFlowPositioned());
      // Now that we&#39;ve computed the final margin before, let&#39;s shift the box&#39;s vertical position if needed.
      // 1. Check if the box has clearance. If so, we&#39;ve already precomputed/finalized the top value and vertical margin does not impact it anymore.
      // 2. Check if the margin before collapses with the previous box&#39;s margin after. if not -&gt; return previous box&#39;s bottom including margin after + marginBefore
      // 3. Check if the previous box&#39;s margins collapse through. If not -&gt; return previous box&#39; bottom excluding margin after + marginBefore (they are supposed to be equal)
      // 4. Go to previous box and start from step #1 until we hit the parent box.
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     if (displayBox.hasClearance())</span>
<span class="line-removed">-         return displayBox.top();</span>
  
      auto* currentLayoutBox = &amp;layoutBox;
      while (currentLayoutBox) {
          if (!currentLayoutBox-&gt;previousInFlowSibling())
              break;
          auto&amp; previousInFlowSibling = *currentLayoutBox-&gt;previousInFlowSibling();
<span class="line-modified">!         if (!MarginCollapse::marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *currentLayoutBox)) {</span>
<span class="line-modified">!             auto&amp; previousDisplayBox = layoutState.displayBoxForLayoutBox(previousInFlowSibling);</span>
<span class="line-modified">!             return previousDisplayBox.rectWithMargin().bottom() + verticalMargin.before();</span>
          }
  
<span class="line-modified">!         if (!MarginCollapse::marginsCollapseThrough(layoutState, previousInFlowSibling)) {</span>
<span class="line-modified">!             auto&amp; previousDisplayBox = layoutState.displayBoxForLayoutBox(previousInFlowSibling);</span>
<span class="line-modified">!             return previousDisplayBox.bottom() + verticalMargin.before();</span>
          }
          currentLayoutBox = &amp;previousInFlowSibling;
      }
  
<span class="line-modified">!     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
<span class="line-removed">-     auto containingBlockContentBoxTop = layoutState.displayBoxForLayoutBox(containingBlock).contentBoxTop();</span>
      // Adjust vertical position depending whether this box directly or indirectly adjoins with its parent.
      auto directlyAdjoinsParent = !layoutBox.previousInFlowSibling();
      if (directlyAdjoinsParent) {
          // If the top and bottom margins of a box are adjoining, then it is possible for margins to collapse through it.
          // In this case, the position of the element depends on its relationship with the other elements whose margins are being collapsed.
          if (verticalMargin.collapsedValues().isCollapsedThrough) {
              // If the element&#39;s margins are collapsed with its parent&#39;s top margin, the top border edge of the box is defined to be the same as the parent&#39;s.
<span class="line-modified">!             if (MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(layoutState, layoutBox))</span>
                  return containingBlockContentBoxTop;
              // Otherwise, either the element&#39;s parent is not taking part in the margin collapsing, or only the parent&#39;s bottom margin is involved.
              // The position of the element&#39;s top border edge is the same as it would have been if the element had a non-zero bottom border.
<span class="line-modified">!             auto beforeMarginWithBottomBorder = MarginCollapse::marginBeforeIgnoringCollapsingThrough(layoutState, layoutBox, verticalMargin.nonCollapsedValues());</span>
              return containingBlockContentBoxTop + beforeMarginWithBottomBorder;
          }
          // Non-collapsed through box vertical position depending whether the margin collapses.
<span class="line-modified">!         if (MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(layoutState, layoutBox))</span>
              return containingBlockContentBoxTop;
  
          return containingBlockContentBoxTop + verticalMargin.before();
      }
      // At this point this box indirectly (via collapsed through previous in-flow siblings) adjoins the parent. Let&#39;s check if it margin collapses with the parent.
      ASSERT(containingBlock.firstInFlowChild());
      ASSERT(containingBlock.firstInFlowChild() != &amp;layoutBox);
<span class="line-modified">!     if (MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(layoutState, *containingBlock.firstInFlowChild()))</span>
          return containingBlockContentBoxTop;
  
      return containingBlockContentBoxTop + verticalMargin.before();
  }
  
<span class="line-modified">! void BlockFormattingContext::setEstimatedMarginBefore(const Box&amp; layoutBox, const EstimatedMarginBefore&amp; estimatedMarginBefore) const</span>
  {
      // Can&#39;t cross formatting context boundary.
      ASSERT(&amp;layoutState().formattingStateForBox(layoutBox) == &amp;formattingState());
<span class="line-modified">!     m_estimatedMarginBeforeList.set(&amp;layoutBox, estimatedMarginBefore);</span>
  }
  
<span class="line-modified">! bool BlockFormattingContext::hasEstimatedMarginBefore(const Box&amp; layoutBox) const</span>
  {
      // Can&#39;t cross formatting context boundary.
      ASSERT(&amp;layoutState().formattingStateForBox(layoutBox) == &amp;formattingState());
<span class="line-modified">!     return m_estimatedMarginBeforeList.contains(&amp;layoutBox);</span>
  }
  
  }
  }
  
<span class="line-new-header">--- 480,82 ---</span>
      }
      formattingState.setIntrinsicWidthConstraints(constraints);
      return constraints;
  }
  
<span class="line-modified">! LayoutUnit BlockFormattingContext::verticalPositionWithMargin(const Box&amp; layoutBox, const UsedVerticalMargin&amp; verticalMargin,  const VerticalConstraints&amp; verticalConstraints) const</span>
  {
      ASSERT(!layoutBox.isOutOfFlowPositioned());
      // Now that we&#39;ve computed the final margin before, let&#39;s shift the box&#39;s vertical position if needed.
      // 1. Check if the box has clearance. If so, we&#39;ve already precomputed/finalized the top value and vertical margin does not impact it anymore.
      // 2. Check if the margin before collapses with the previous box&#39;s margin after. if not -&gt; return previous box&#39;s bottom including margin after + marginBefore
      // 3. Check if the previous box&#39;s margins collapse through. If not -&gt; return previous box&#39; bottom excluding margin after + marginBefore (they are supposed to be equal)
      // 4. Go to previous box and start from step #1 until we hit the parent box.
<span class="line-modified">!     auto&amp; boxGeometry = geometryForBox(layoutBox);</span>
<span class="line-modified">!     if (boxGeometry.hasClearance())</span>
<span class="line-modified">!         return boxGeometry.top();</span>
  
      auto* currentLayoutBox = &amp;layoutBox;
      while (currentLayoutBox) {
          if (!currentLayoutBox-&gt;previousInFlowSibling())
              break;
          auto&amp; previousInFlowSibling = *currentLayoutBox-&gt;previousInFlowSibling();
<span class="line-modified">!         if (!marginCollapse().marginBeforeCollapsesWithPreviousSiblingMarginAfter(*currentLayoutBox)) {</span>
<span class="line-modified">!             auto&amp; previousBoxGeometry = geometryForBox(previousInFlowSibling);</span>
<span class="line-modified">!             return previousBoxGeometry.rectWithMargin().bottom() + verticalMargin.before();</span>
          }
  
<span class="line-modified">!         if (!marginCollapse().marginsCollapseThrough(previousInFlowSibling)) {</span>
<span class="line-modified">!             auto&amp; previousBoxGeometry = geometryForBox(previousInFlowSibling);</span>
<span class="line-modified">!             return previousBoxGeometry.bottom() + verticalMargin.before();</span>
          }
          currentLayoutBox = &amp;previousInFlowSibling;
      }
  
<span class="line-modified">!     auto containingBlockContentBoxTop = verticalConstraints.logicalTop;</span>
      // Adjust vertical position depending whether this box directly or indirectly adjoins with its parent.
      auto directlyAdjoinsParent = !layoutBox.previousInFlowSibling();
      if (directlyAdjoinsParent) {
          // If the top and bottom margins of a box are adjoining, then it is possible for margins to collapse through it.
          // In this case, the position of the element depends on its relationship with the other elements whose margins are being collapsed.
          if (verticalMargin.collapsedValues().isCollapsedThrough) {
              // If the element&#39;s margins are collapsed with its parent&#39;s top margin, the top border edge of the box is defined to be the same as the parent&#39;s.
<span class="line-modified">!             if (marginCollapse().marginBeforeCollapsesWithParentMarginBefore(layoutBox))</span>
                  return containingBlockContentBoxTop;
              // Otherwise, either the element&#39;s parent is not taking part in the margin collapsing, or only the parent&#39;s bottom margin is involved.
              // The position of the element&#39;s top border edge is the same as it would have been if the element had a non-zero bottom border.
<span class="line-modified">!             auto beforeMarginWithBottomBorder = marginCollapse().marginBeforeIgnoringCollapsingThrough(layoutBox, verticalMargin.nonCollapsedValues());</span>
              return containingBlockContentBoxTop + beforeMarginWithBottomBorder;
          }
          // Non-collapsed through box vertical position depending whether the margin collapses.
<span class="line-modified">!         if (marginCollapse().marginBeforeCollapsesWithParentMarginBefore(layoutBox))</span>
              return containingBlockContentBoxTop;
  
          return containingBlockContentBoxTop + verticalMargin.before();
      }
      // At this point this box indirectly (via collapsed through previous in-flow siblings) adjoins the parent. Let&#39;s check if it margin collapses with the parent.
<span class="line-added">+     auto&amp; containingBlock = *layoutBox.containingBlock();</span>
      ASSERT(containingBlock.firstInFlowChild());
      ASSERT(containingBlock.firstInFlowChild() != &amp;layoutBox);
<span class="line-modified">!     if (marginCollapse().marginBeforeCollapsesWithParentMarginBefore(*containingBlock.firstInFlowChild()))</span>
          return containingBlockContentBoxTop;
  
      return containingBlockContentBoxTop + verticalMargin.before();
  }
  
<span class="line-modified">! void BlockFormattingContext::setPrecomputedMarginBefore(const Box&amp; layoutBox, const PrecomputedMarginBefore&amp; precomputedMarginBefore)</span>
  {
      // Can&#39;t cross formatting context boundary.
      ASSERT(&amp;layoutState().formattingStateForBox(layoutBox) == &amp;formattingState());
<span class="line-modified">!     m_precomputedMarginBeforeList.set(&amp;layoutBox, precomputedMarginBefore);</span>
  }
  
<span class="line-modified">! bool BlockFormattingContext::hasPrecomputedMarginBefore(const Box&amp; layoutBox) const</span>
  {
      // Can&#39;t cross formatting context boundary.
      ASSERT(&amp;layoutState().formattingStateForBox(layoutBox) == &amp;formattingState());
<span class="line-modified">!     return m_precomputedMarginBeforeList.contains(&amp;layoutBox);</span>
  }
  
  }
  }
  
</pre>
<center><a href="../Verification.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingContext.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
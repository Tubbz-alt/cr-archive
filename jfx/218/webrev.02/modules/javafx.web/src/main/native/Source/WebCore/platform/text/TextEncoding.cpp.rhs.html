<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncoding.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  3  * Copyright (C) 2006 Alexey Proskuryakov &lt;ap@nypop.com&gt;
  4  * Copyright (C) 2007-2009 Torch Mobile, Inc.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;TextEncoding.h&quot;
 30 
 31 #include &quot;DecodeEscapeSequences.h&quot;
 32 #include &quot;TextCodec.h&quot;
 33 #include &quot;TextEncodingRegistry.h&quot;
 34 #include &lt;wtf/NeverDestroyed.h&gt;
 35 #include &lt;wtf/StdLibExtras.h&gt;
 36 #include &lt;wtf/text/StringView.h&gt;
 37 
<a name="1" id="anc1"></a><span class="line-added"> 38 #if USE(JAVA_UNICODE)</span>
<span class="line-added"> 39 #include &quot;TextNormalizerJava.h&quot;</span>
<span class="line-added"> 40 #endif</span>
<span class="line-added"> 41 </span>
 42 namespace WebCore {
 43 
 44 static const TextEncoding&amp; UTF7Encoding()
 45 {
 46     static NeverDestroyed&lt;TextEncoding&gt; globalUTF7Encoding(&quot;UTF-7&quot;);
 47     return globalUTF7Encoding;
 48 }
 49 
 50 TextEncoding::TextEncoding(const char* name)
<a name="2" id="anc2"></a><span class="line-modified"> 51     : m_name(atomCanonicalTextEncodingName(name))</span>
 52     , m_backslashAsCurrencySymbol(backslashAsCurrencySymbol())
 53 {
 54     // Aliases are valid, but not &quot;replacement&quot; itself.
 55     if (equalLettersIgnoringASCIICase(name, &quot;replacement&quot;))
 56         m_name = nullptr;
 57 }
 58 
 59 TextEncoding::TextEncoding(const String&amp; name)
<a name="3" id="anc3"></a><span class="line-modified"> 60     : m_name(atomCanonicalTextEncodingName(name))</span>
 61     , m_backslashAsCurrencySymbol(backslashAsCurrencySymbol())
 62 {
 63     // Aliases are valid, but not &quot;replacement&quot; itself.
 64     if (equalLettersIgnoringASCIICase(name, &quot;replacement&quot;))
 65         m_name = nullptr;
 66 }
 67 
 68 String TextEncoding::decode(const char* data, size_t length, bool stopOnError, bool&amp; sawError) const
 69 {
 70     if (!m_name)
 71         return String();
 72 
 73     return newTextCodec(*this)-&gt;decode(data, length, true, stopOnError, sawError);
 74 }
 75 
 76 Vector&lt;uint8_t&gt; TextEncoding::encode(StringView string, UnencodableHandling handling) const
 77 {
 78     if (!m_name || string.isEmpty())
 79         return { };
 80 
 81     // FIXME: What&#39;s the right place to do normalization?
 82     // It&#39;s a little strange to do it inside the encode function.
 83     // Perhaps normalization should be an explicit step done before calling encode.
<a name="4" id="anc4"></a><span class="line-added"> 84 #if !USE(JAVA_UNICODE)</span>
 85     auto normalizedString = normalizedNFC(string);
 86     return newTextCodec(*this)-&gt;encode(normalizedString.view, handling);
<a name="5" id="anc5"></a><span class="line-added"> 87 #else</span>
<span class="line-added"> 88     String normalized = TextNormalizer::normalize(text.upconvertedCharacters(), text.length(), TextNormalizer::NFC);</span>
<span class="line-added"> 89     return newTextCodec(*this)-&gt;encode(StringView { normalized.characters16(), normalized.length() }, handling);</span>
<span class="line-added"> 90 #endif</span>
 91 }
 92 
 93 const char* TextEncoding::domName() const
 94 {
 95     if (noExtendedTextEncodingNameUsed())
 96         return m_name;
 97 
 98     // We treat EUC-KR as windows-949 (its superset), but need to expose
 99     // the name &#39;EUC-KR&#39; because the name &#39;windows-949&#39; is not recognized by
100     // most Korean web servers even though they do use the encoding
101     // &#39;windows-949&#39; with the name &#39;EUC-KR&#39;.
102     // FIXME: This is not thread-safe. At the moment, this function is
103     // only accessed in a single thread, but eventually has to be made
104     // thread-safe along with usesVisualOrdering().
<a name="6" id="anc6"></a><span class="line-modified">105     static const char* const a = atomCanonicalTextEncodingName(&quot;windows-949&quot;);</span>
106     if (m_name == a)
107         return &quot;EUC-KR&quot;;
108     return m_name;
109 }
110 
111 bool TextEncoding::usesVisualOrdering() const
112 {
113     if (noExtendedTextEncodingNameUsed())
114         return false;
115 
<a name="7" id="anc7"></a><span class="line-modified">116     static const char* const a = atomCanonicalTextEncodingName(&quot;ISO-8859-8&quot;);</span>
117     return m_name == a;
118 }
119 
120 bool TextEncoding::isJapanese() const
121 {
122     return isJapaneseEncoding(m_name);
123 }
124 
125 UChar TextEncoding::backslashAsCurrencySymbol() const
126 {
127     return shouldShowBackslashAsCurrencySymbolIn(m_name) ? 0x00A5 : &#39;\\&#39;;
128 }
129 
130 bool TextEncoding::isNonByteBasedEncoding() const
131 {
132     return *this == UTF16LittleEndianEncoding() || *this == UTF16BigEndianEncoding();
133 }
134 
135 bool TextEncoding::isUTF7Encoding() const
136 {
137     if (noExtendedTextEncodingNameUsed())
138         return false;
139 
140     return *this == UTF7Encoding();
141 }
142 
143 const TextEncoding&amp; TextEncoding::closestByteBasedEquivalent() const
144 {
145     if (isNonByteBasedEncoding())
146         return UTF8Encoding();
147     return *this;
148 }
149 
150 // HTML5 specifies that UTF-8 be used in form submission when a form is
151 // is a part of a document in UTF-16 probably because UTF-16 is not a
152 // byte-based encoding and can contain 0x00. By extension, the same
153 // should be done for UTF-32. In case of UTF-7, it is a byte-based encoding,
154 // but it&#39;s fraught with problems and we&#39;d rather steer clear of it.
155 const TextEncoding&amp; TextEncoding::encodingForFormSubmissionOrURLParsing() const
156 {
157     if (isNonByteBasedEncoding() || isUTF7Encoding())
158         return UTF8Encoding();
159     return *this;
160 }
161 
162 const TextEncoding&amp; ASCIIEncoding()
163 {
164     static NeverDestroyed&lt;TextEncoding&gt; globalASCIIEncoding(&quot;ASCII&quot;);
165     return globalASCIIEncoding;
166 }
167 
168 const TextEncoding&amp; Latin1Encoding()
169 {
170     static NeverDestroyed&lt;TextEncoding&gt; globalLatin1Encoding(&quot;latin1&quot;);
171     return globalLatin1Encoding;
172 }
173 
174 const TextEncoding&amp; UTF16BigEndianEncoding()
175 {
176     static NeverDestroyed&lt;TextEncoding&gt; globalUTF16BigEndianEncoding(&quot;UTF-16BE&quot;);
177     return globalUTF16BigEndianEncoding;
178 }
179 
180 const TextEncoding&amp; UTF16LittleEndianEncoding()
181 {
182     static NeverDestroyed&lt;TextEncoding&gt; globalUTF16LittleEndianEncoding(&quot;UTF-16LE&quot;);
183     return globalUTF16LittleEndianEncoding;
184 }
185 
186 const TextEncoding&amp; UTF8Encoding()
187 {
188     static NeverDestroyed&lt;TextEncoding&gt; globalUTF8Encoding(&quot;UTF-8&quot;);
189     ASSERT(globalUTF8Encoding.get().isValid());
190     return globalUTF8Encoding;
191 }
192 
193 const TextEncoding&amp; WindowsLatin1Encoding()
194 {
195     static NeverDestroyed&lt;TextEncoding&gt; globalWindowsLatin1Encoding(&quot;WinLatin-1&quot;);
196     return globalWindowsLatin1Encoding;
197 }
198 
199 String decodeURLEscapeSequences(const String&amp; string, const TextEncoding&amp; encoding)
200 {
201     if (string.isEmpty())
202         return string;
203     return decodeEscapeSequences&lt;URLEscapeSequence&gt;(string, encoding);
204 }
205 
206 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBCursor.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBDatabase.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBDatabase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 50 
 51 Ref&lt;IDBDatabase&gt; IDBDatabase::create(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBResultData&amp; resultData)
 52 {
 53     return adoptRef(*new IDBDatabase(context, connectionProxy, resultData));
 54 }
 55 
 56 IDBDatabase::IDBDatabase(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBResultData&amp; resultData)
 57     : IDBActiveDOMObject(&amp;context)
 58     , m_connectionProxy(connectionProxy)
 59     , m_info(resultData.databaseInfo())
 60     , m_databaseConnectionIdentifier(resultData.databaseConnectionIdentifier())
 61     , m_eventNames(eventNames())
 62 {
 63     LOG(IndexedDB, &quot;IDBDatabase::IDBDatabase - Creating database %s with version %&quot; PRIu64 &quot; connection %&quot; PRIu64 &quot; (%p)&quot;, m_info.name().utf8().data(), m_info.version(), m_databaseConnectionIdentifier, this);
 64     suspendIfNeeded();
 65     m_connectionProxy-&gt;registerDatabaseConnection(*this);
 66 }
 67 
 68 IDBDatabase::~IDBDatabase()
 69 {
<span class="line-modified"> 70     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
 71 
 72     if (!m_closedInServer)
 73         m_connectionProxy-&gt;databaseConnectionClosed(*this);
 74 
 75     m_connectionProxy-&gt;unregisterDatabaseConnection(*this);
 76 }
 77 
 78 bool IDBDatabase::hasPendingActivity() const
 79 {
<span class="line-modified"> 80     ASSERT(&amp;originThread() == &amp;Thread::current() || Thread::mayBeGCThread());</span>
 81 
 82     if (m_closedInServer || isContextStopped())
 83         return false;
 84 
 85     if (!m_activeTransactions.isEmpty() || !m_committingTransactions.isEmpty() || !m_abortingTransactions.isEmpty())
 86         return true;
 87 
 88     return hasEventListeners(m_eventNames.abortEvent) || hasEventListeners(m_eventNames.errorEvent) || hasEventListeners(m_eventNames.versionchangeEvent);
 89 }
 90 
 91 const String IDBDatabase::name() const
 92 {
<span class="line-modified"> 93     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
 94     return m_info.name();
 95 }
 96 
 97 uint64_t IDBDatabase::version() const
 98 {
<span class="line-modified"> 99     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
100     return m_info.version();
101 }
102 
103 Ref&lt;DOMStringList&gt; IDBDatabase::objectStoreNames() const
104 {
<span class="line-modified">105     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
106 
107     auto objectStoreNames = DOMStringList::create();
108     for (auto&amp; name : m_info.objectStoreNames())
109         objectStoreNames-&gt;append(name);
110     objectStoreNames-&gt;sort();
111     return objectStoreNames;
112 }
113 
114 void IDBDatabase::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
115 {
<span class="line-modified">116     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
117     ASSERT(m_versionChangeTransaction);
118     ASSERT(m_info.hasObjectStore(objectStore.info().name()));
119 
120     m_info.renameObjectStore(objectStore.info().identifier(), newName);
121 
122     m_versionChangeTransaction-&gt;renameObjectStore(objectStore, newName);
123 }
124 
125 void IDBDatabase::renameIndex(IDBIndex&amp; index, const String&amp; newName)
126 {
<span class="line-modified">127     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
128     ASSERT(m_versionChangeTransaction);
129     ASSERT(m_info.hasObjectStore(index.objectStore().info().name()));
130     ASSERT(m_info.infoForExistingObjectStore(index.objectStore().info().name())-&gt;hasIndex(index.info().name()));
131 
132     m_info.infoForExistingObjectStore(index.objectStore().info().name())-&gt;infoForExistingIndex(index.info().identifier())-&gt;rename(newName);
133 
134     m_versionChangeTransaction-&gt;renameIndex(index, newName);
135 }
136 
137 ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBDatabase::createObjectStore(const String&amp; name, ObjectStoreParameters&amp;&amp; parameters)
138 {
139     LOG(IndexedDB, &quot;IDBDatabase::createObjectStore - (%s %s)&quot;, m_info.name().utf8().data(), name.utf8().data());
140 
<span class="line-modified">141     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
142     ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;isVersionChange());
143 
144     if (!m_versionChangeTransaction)
145         return Exception { InvalidStateError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: The database is not running a version change transaction.&quot;_s };
146 
147     if (!m_versionChangeTransaction-&gt;isActive())
148         return Exception { TransactionInactiveError };
149 
150     auto&amp; keyPath = parameters.keyPath;
151     if (keyPath &amp;&amp; !isIDBKeyPathValid(keyPath.value()))
152         return Exception { SyntaxError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: The keyPath option is not a valid key path.&quot;_s };
153 
154     if (m_info.hasObjectStore(name))
155         return Exception { ConstraintError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: An object store with the specified name already exists.&quot;_s };
156 
157     if (keyPath &amp;&amp; parameters.autoIncrement &amp;&amp; ((WTF::holds_alternative&lt;String&gt;(keyPath.value()) &amp;&amp; WTF::get&lt;String&gt;(keyPath.value()).isEmpty()) || WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath.value())))
158         return Exception { InvalidAccessError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: The autoIncrement option was set but the keyPath option was empty or an array.&quot;_s };
159 
160     // Install the new ObjectStore into the connection&#39;s metadata.
161     auto info = m_info.createNewObjectStore(name, WTFMove(keyPath), parameters.autoIncrement);
162 
163     // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
164     return m_versionChangeTransaction-&gt;createObjectStore(info);
165 }
166 
167 ExceptionOr&lt;Ref&lt;IDBTransaction&gt;&gt; IDBDatabase::transaction(StringOrVectorOfStrings&amp;&amp; storeNames, IDBTransactionMode mode)
168 {
169     LOG(IndexedDB, &quot;IDBDatabase::transaction&quot;);
170 
<span class="line-modified">171     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
172 
173     if (m_versionChangeTransaction &amp;&amp; !m_versionChangeTransaction-&gt;isFinishedOrFinishing())
174         return Exception { InvalidStateError, &quot;Failed to execute &#39;transaction&#39; on &#39;IDBDatabase&#39;: A version change transaction is running.&quot;_s };
175 
176     if (m_closePending)
177         return Exception { InvalidStateError, &quot;Failed to execute &#39;transaction&#39; on &#39;IDBDatabase&#39;: The database connection is closing.&quot;_s };
178 
179     Vector&lt;String&gt; objectStores;
180     if (WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(storeNames))
181         objectStores = WTFMove(WTF::get&lt;Vector&lt;String&gt;&gt;(storeNames));
182     else
183         objectStores.append(WTFMove(WTF::get&lt;String&gt;(storeNames)));
184 
185     // It is valid for javascript to pass in a list of object store names with the same name listed twice,
186     // so we need to put them all in a set to get a unique list.
187     HashSet&lt;String&gt; objectStoreSet;
188     for (auto&amp; objectStore : objectStores)
189         objectStoreSet.add(objectStore);
190 
191     objectStores = copyToVector(objectStoreSet);
</pre>
<hr />
<pre>
201 
202     if (mode != IDBTransactionMode::Readonly &amp;&amp; mode != IDBTransactionMode::Readwrite)
203         return Exception { TypeError };
204 
205     auto info = IDBTransactionInfo::clientTransaction(m_connectionProxy.get(), objectStores, mode);
206 
207     LOG(IndexedDBOperations, &quot;IDB creating transaction: %s&quot;, info.loggingString().utf8().data());
208     auto transaction = IDBTransaction::create(*this, info);
209 
210     LOG(IndexedDB, &quot;IDBDatabase::transaction - Added active transaction %s&quot;, info.identifier().loggingString().utf8().data());
211 
212     m_activeTransactions.set(info.identifier(), transaction.ptr());
213 
214     return transaction;
215 }
216 
217 ExceptionOr&lt;void&gt; IDBDatabase::deleteObjectStore(const String&amp; objectStoreName)
218 {
219     LOG(IndexedDB, &quot;IDBDatabase::deleteObjectStore&quot;);
220 
<span class="line-modified">221     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
222 
223     if (!m_versionChangeTransaction)
224         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteObjectStore&#39; on &#39;IDBDatabase&#39;: The database is not running a version change transaction.&quot;_s };
225 
226     if (!m_versionChangeTransaction-&gt;isActive())
227         return Exception { TransactionInactiveError };
228 
229     if (!m_info.hasObjectStore(objectStoreName))
230         return Exception { NotFoundError, &quot;Failed to execute &#39;deleteObjectStore&#39; on &#39;IDBDatabase&#39;: The specified object store was not found.&quot;_s };
231 
232     m_info.deleteObjectStore(objectStoreName);
233     m_versionChangeTransaction-&gt;deleteObjectStore(objectStoreName);
234 
235     return { };
236 }
237 
238 void IDBDatabase::close()
239 {
240     LOG(IndexedDB, &quot;IDBDatabase::close - %&quot; PRIu64, m_databaseConnectionIdentifier);
241 
<span class="line-modified">242     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
243 
244     if (!m_closePending) {
245         m_closePending = true;
246         m_connectionProxy-&gt;databaseConnectionPendingClose(*this);
247     }
248 
249     maybeCloseInServer();
250 }
251 
252 void IDBDatabase::didCloseFromServer(const IDBError&amp; error)
253 {
254     LOG(IndexedDB, &quot;IDBDatabase::didCloseFromServer - %&quot; PRIu64, m_databaseConnectionIdentifier);
255 
256     connectionToServerLost(error);
<span class="line-removed">257 </span>
<span class="line-removed">258     m_connectionProxy-&gt;confirmDidCloseFromServer(*this);</span>
259 }
260 
261 void IDBDatabase::connectionToServerLost(const IDBError&amp; error)
262 {
263     LOG(IndexedDB, &quot;IDBDatabase::connectionToServerLost - %&quot; PRIu64, m_databaseConnectionIdentifier);
264 
<span class="line-modified">265     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
266 
267     m_closePending = true;
268     m_closedInServer = true;
269 
270     auto activeTransactions = copyToVector(m_activeTransactions.values());
271     for (auto&amp; transaction : activeTransactions)
272         transaction-&gt;connectionClosedFromServer(error);
273 
274     auto committingTransactions = copyToVector(m_committingTransactions.values());
275     for (auto&amp; transaction : committingTransactions)
276         transaction-&gt;connectionClosedFromServer(error);
277 
278     auto errorEvent = Event::create(m_eventNames.errorEvent, Event::CanBubble::Yes, Event::IsCancelable::No);
279     errorEvent-&gt;setTarget(this);
280 
<span class="line-modified">281     if (auto* context = scriptExecutionContext())</span>
<span class="line-modified">282         context-&gt;eventQueue().enqueueEvent(WTFMove(errorEvent));</span>
283 
284     auto closeEvent = Event::create(m_eventNames.closeEvent, Event::CanBubble::Yes, Event::IsCancelable::No);
285     closeEvent-&gt;setTarget(this);
286 
<span class="line-modified">287     if (auto* context = scriptExecutionContext())</span>
<span class="line-modified">288         context-&gt;eventQueue().enqueueEvent(WTFMove(closeEvent));</span>
289 }
290 
291 void IDBDatabase::maybeCloseInServer()
292 {
293     LOG(IndexedDB, &quot;IDBDatabase::maybeCloseInServer - %&quot; PRIu64, m_databaseConnectionIdentifier);
294 
<span class="line-modified">295     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
296 
297     if (m_closedInServer)
298         return;
299 
300     // 3.3.9 Database closing steps
301     // Wait for all transactions created using this connection to complete.
302     // Once they are complete, this connection is closed.
303     if (!m_activeTransactions.isEmpty() || !m_committingTransactions.isEmpty())
304         return;
305 
306     m_closedInServer = true;
307     m_connectionProxy-&gt;databaseConnectionClosed(*this);
308 }
309 
310 const char* IDBDatabase::activeDOMObjectName() const
311 {
<span class="line-modified">312     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
313     return &quot;IDBDatabase&quot;;
314 }
315 
<span class="line-removed">316 bool IDBDatabase::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">317 {</span>
<span class="line-removed">318     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
<span class="line-removed">319 </span>
<span class="line-removed">320     // FIXME: This value will sometimes be false when database operations are actually in progress.</span>
<span class="line-removed">321     // Such database operations do not yet exist.</span>
<span class="line-removed">322     return true;</span>
<span class="line-removed">323 }</span>
<span class="line-removed">324 </span>
325 void IDBDatabase::stop()
326 {
327     LOG(IndexedDB, &quot;IDBDatabase::stop - %&quot; PRIu64, m_databaseConnectionIdentifier);
328 
<span class="line-modified">329     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
330 
331     removeAllEventListeners();
332 
333     Vector&lt;IDBResourceIdentifier&gt; transactionIdentifiers;
334     transactionIdentifiers.reserveInitialCapacity(m_activeTransactions.size());
335 
336     for (auto&amp; id : m_activeTransactions.keys())
337         transactionIdentifiers.uncheckedAppend(id);
338 
339     for (auto&amp; id : transactionIdentifiers) {
340         IDBTransaction* transaction = m_activeTransactions.get(id);
341         if (transaction)
342             transaction-&gt;stop();
343     }
344 
345     close();
346 }
347 
348 Ref&lt;IDBTransaction&gt; IDBDatabase::startVersionChangeTransaction(const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
349 {
350     LOG(IndexedDB, &quot;IDBDatabase::startVersionChangeTransaction %s&quot;, info.identifier().loggingString().utf8().data());
351 
<span class="line-modified">352     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
353     ASSERT(!m_versionChangeTransaction);
354     ASSERT(info.mode() == IDBTransactionMode::Versionchange);
355     ASSERT(!m_closePending);
356     ASSERT(scriptExecutionContext());
357 
358     Ref&lt;IDBTransaction&gt; transaction = IDBTransaction::create(*this, info, request);
359     m_versionChangeTransaction = &amp;transaction.get();
360 
361     m_activeTransactions.set(transaction-&gt;info().identifier(), &amp;transaction.get());
362 
363     return transaction;
364 }
365 
366 void IDBDatabase::didStartTransaction(IDBTransaction&amp; transaction)
367 {
368     LOG(IndexedDB, &quot;IDBDatabase::didStartTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
369     ASSERT(!m_versionChangeTransaction);
<span class="line-modified">370     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
371 
372     // It is possible for the client to have aborted a transaction before the server replies back that it has started.
373     if (m_abortingTransactions.contains(transaction.info().identifier()))
374         return;
375 
376     m_activeTransactions.set(transaction.info().identifier(), &amp;transaction);
377 }
378 
379 void IDBDatabase::willCommitTransaction(IDBTransaction&amp; transaction)
380 {
381     LOG(IndexedDB, &quot;IDBDatabase::willCommitTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
382 
<span class="line-modified">383     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
384 
385     auto refTransaction = m_activeTransactions.take(transaction.info().identifier());
386     ASSERT(refTransaction);
387     m_committingTransactions.set(transaction.info().identifier(), WTFMove(refTransaction));
388 }
389 
390 void IDBDatabase::didCommitTransaction(IDBTransaction&amp; transaction)
391 {
392     LOG(IndexedDB, &quot;IDBDatabase::didCommitTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
393 
<span class="line-modified">394     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
395 
396     if (m_versionChangeTransaction == &amp;transaction)
397         m_info.setVersion(transaction.info().newVersion());
398 
399     didCommitOrAbortTransaction(transaction);
400 }
401 
402 void IDBDatabase::willAbortTransaction(IDBTransaction&amp; transaction)
403 {
404     LOG(IndexedDB, &quot;IDBDatabase::willAbortTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
405 
<span class="line-modified">406     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
407 
408     auto refTransaction = m_activeTransactions.take(transaction.info().identifier());
409     if (!refTransaction)
410         refTransaction = m_committingTransactions.take(transaction.info().identifier());
411 
412     ASSERT(refTransaction);
413     m_abortingTransactions.set(transaction.info().identifier(), WTFMove(refTransaction));
414 
415     if (transaction.isVersionChange()) {
416         ASSERT(transaction.originalDatabaseInfo());
417         m_info = *transaction.originalDatabaseInfo();
418         m_closePending = true;
419     }
420 }
421 
422 void IDBDatabase::didAbortTransaction(IDBTransaction&amp; transaction)
423 {
424     LOG(IndexedDB, &quot;IDBDatabase::didAbortTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
425 
<span class="line-modified">426     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
427 
428     if (transaction.isVersionChange()) {
429         ASSERT(transaction.originalDatabaseInfo());
430         ASSERT(m_info.version() == transaction.originalDatabaseInfo()-&gt;version());
431         m_closePending = true;
432         maybeCloseInServer();
433     }
434 
435     didCommitOrAbortTransaction(transaction);
436 }
437 
438 void IDBDatabase::didCommitOrAbortTransaction(IDBTransaction&amp; transaction)
439 {
440     LOG(IndexedDB, &quot;IDBDatabase::didCommitOrAbortTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
441 
<span class="line-modified">442     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
443 
444     if (m_versionChangeTransaction == &amp;transaction)
445         m_versionChangeTransaction = nullptr;
446 
447 #ifndef NDBEBUG
448     unsigned count = 0;
449     if (m_activeTransactions.contains(transaction.info().identifier()))
450         ++count;
451     if (m_committingTransactions.contains(transaction.info().identifier()))
452         ++count;
453     if (m_abortingTransactions.contains(transaction.info().identifier()))
454         ++count;
455 
456     ASSERT(count == 1);
457 #endif
458 
459     m_activeTransactions.remove(transaction.info().identifier());
460     m_committingTransactions.remove(transaction.info().identifier());
461     m_abortingTransactions.remove(transaction.info().identifier());
462 
463     if (m_closePending)
464         maybeCloseInServer();
465 }
466 
467 void IDBDatabase::fireVersionChangeEvent(const IDBResourceIdentifier&amp; requestIdentifier, uint64_t requestedVersion)
468 {
469     uint64_t currentVersion = m_info.version();
470     LOG(IndexedDB, &quot;IDBDatabase::fireVersionChangeEvent - current version %&quot; PRIu64 &quot;, requested version %&quot; PRIu64 &quot;, connection %&quot; PRIu64 &quot; (%p)&quot;, currentVersion, requestedVersion, m_databaseConnectionIdentifier, this);
471 
<span class="line-modified">472     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
473 
474     if (!scriptExecutionContext() || m_closePending) {
475         connectionProxy().didFireVersionChangeEvent(m_databaseConnectionIdentifier, requestIdentifier);
476         return;
477     }
478 
479     Ref&lt;Event&gt; event = IDBVersionChangeEvent::create(requestIdentifier, currentVersion, requestedVersion, m_eventNames.versionchangeEvent);
<span class="line-modified">480     event-&gt;setTarget(this);</span>
<span class="line-removed">481     scriptExecutionContext()-&gt;eventQueue().enqueueEvent(WTFMove(event));</span>
482 }
483 
484 void IDBDatabase::dispatchEvent(Event&amp; event)
485 {
486     LOG(IndexedDB, &quot;IDBDatabase::dispatchEvent (%&quot; PRIu64 &quot;) (%p)&quot;, m_databaseConnectionIdentifier, this);
<span class="line-modified">487     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
488 
489     auto protectedThis = makeRef(*this);
490 
491     EventTargetWithInlineData::dispatchEvent(event);
492 
493     if (event.isVersionChangeEvent() &amp;&amp; event.type() == m_eventNames.versionchangeEvent)
494         m_connectionProxy-&gt;didFireVersionChangeEvent(m_databaseConnectionIdentifier, downcast&lt;IDBVersionChangeEvent&gt;(event).requestIdentifier());
495 }
496 
497 void IDBDatabase::didCreateIndexInfo(const IDBIndexInfo&amp; info)
498 {
<span class="line-modified">499     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
500 
501     auto* objectStore = m_info.infoForExistingObjectStore(info.objectStoreIdentifier());
502     ASSERT(objectStore);
503     objectStore-&gt;addExistingIndex(info);
504 }
505 
506 void IDBDatabase::didDeleteIndexInfo(const IDBIndexInfo&amp; info)
507 {
<span class="line-modified">508     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
509 
510     auto* objectStore = m_info.infoForExistingObjectStore(info.objectStoreIdentifier());
511     ASSERT(objectStore);
512     objectStore-&gt;deleteIndex(info.name());
513 }
514 
515 } // namespace WebCore
516 
517 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
 50 
 51 Ref&lt;IDBDatabase&gt; IDBDatabase::create(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBResultData&amp; resultData)
 52 {
 53     return adoptRef(*new IDBDatabase(context, connectionProxy, resultData));
 54 }
 55 
 56 IDBDatabase::IDBDatabase(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBResultData&amp; resultData)
 57     : IDBActiveDOMObject(&amp;context)
 58     , m_connectionProxy(connectionProxy)
 59     , m_info(resultData.databaseInfo())
 60     , m_databaseConnectionIdentifier(resultData.databaseConnectionIdentifier())
 61     , m_eventNames(eventNames())
 62 {
 63     LOG(IndexedDB, &quot;IDBDatabase::IDBDatabase - Creating database %s with version %&quot; PRIu64 &quot; connection %&quot; PRIu64 &quot; (%p)&quot;, m_info.name().utf8().data(), m_info.version(), m_databaseConnectionIdentifier, this);
 64     suspendIfNeeded();
 65     m_connectionProxy-&gt;registerDatabaseConnection(*this);
 66 }
 67 
 68 IDBDatabase::~IDBDatabase()
 69 {
<span class="line-modified"> 70     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
 71 
 72     if (!m_closedInServer)
 73         m_connectionProxy-&gt;databaseConnectionClosed(*this);
 74 
 75     m_connectionProxy-&gt;unregisterDatabaseConnection(*this);
 76 }
 77 
 78 bool IDBDatabase::hasPendingActivity() const
 79 {
<span class="line-modified"> 80     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()) || Thread::mayBeGCThread());</span>
 81 
 82     if (m_closedInServer || isContextStopped())
 83         return false;
 84 
 85     if (!m_activeTransactions.isEmpty() || !m_committingTransactions.isEmpty() || !m_abortingTransactions.isEmpty())
 86         return true;
 87 
 88     return hasEventListeners(m_eventNames.abortEvent) || hasEventListeners(m_eventNames.errorEvent) || hasEventListeners(m_eventNames.versionchangeEvent);
 89 }
 90 
 91 const String IDBDatabase::name() const
 92 {
<span class="line-modified"> 93     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
 94     return m_info.name();
 95 }
 96 
 97 uint64_t IDBDatabase::version() const
 98 {
<span class="line-modified"> 99     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
100     return m_info.version();
101 }
102 
103 Ref&lt;DOMStringList&gt; IDBDatabase::objectStoreNames() const
104 {
<span class="line-modified">105     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
106 
107     auto objectStoreNames = DOMStringList::create();
108     for (auto&amp; name : m_info.objectStoreNames())
109         objectStoreNames-&gt;append(name);
110     objectStoreNames-&gt;sort();
111     return objectStoreNames;
112 }
113 
114 void IDBDatabase::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
115 {
<span class="line-modified">116     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
117     ASSERT(m_versionChangeTransaction);
118     ASSERT(m_info.hasObjectStore(objectStore.info().name()));
119 
120     m_info.renameObjectStore(objectStore.info().identifier(), newName);
121 
122     m_versionChangeTransaction-&gt;renameObjectStore(objectStore, newName);
123 }
124 
125 void IDBDatabase::renameIndex(IDBIndex&amp; index, const String&amp; newName)
126 {
<span class="line-modified">127     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
128     ASSERT(m_versionChangeTransaction);
129     ASSERT(m_info.hasObjectStore(index.objectStore().info().name()));
130     ASSERT(m_info.infoForExistingObjectStore(index.objectStore().info().name())-&gt;hasIndex(index.info().name()));
131 
132     m_info.infoForExistingObjectStore(index.objectStore().info().name())-&gt;infoForExistingIndex(index.info().identifier())-&gt;rename(newName);
133 
134     m_versionChangeTransaction-&gt;renameIndex(index, newName);
135 }
136 
137 ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBDatabase::createObjectStore(const String&amp; name, ObjectStoreParameters&amp;&amp; parameters)
138 {
139     LOG(IndexedDB, &quot;IDBDatabase::createObjectStore - (%s %s)&quot;, m_info.name().utf8().data(), name.utf8().data());
140 
<span class="line-modified">141     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
142     ASSERT(!m_versionChangeTransaction || m_versionChangeTransaction-&gt;isVersionChange());
143 
144     if (!m_versionChangeTransaction)
145         return Exception { InvalidStateError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: The database is not running a version change transaction.&quot;_s };
146 
147     if (!m_versionChangeTransaction-&gt;isActive())
148         return Exception { TransactionInactiveError };
149 
150     auto&amp; keyPath = parameters.keyPath;
151     if (keyPath &amp;&amp; !isIDBKeyPathValid(keyPath.value()))
152         return Exception { SyntaxError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: The keyPath option is not a valid key path.&quot;_s };
153 
154     if (m_info.hasObjectStore(name))
155         return Exception { ConstraintError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: An object store with the specified name already exists.&quot;_s };
156 
157     if (keyPath &amp;&amp; parameters.autoIncrement &amp;&amp; ((WTF::holds_alternative&lt;String&gt;(keyPath.value()) &amp;&amp; WTF::get&lt;String&gt;(keyPath.value()).isEmpty()) || WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(keyPath.value())))
158         return Exception { InvalidAccessError, &quot;Failed to execute &#39;createObjectStore&#39; on &#39;IDBDatabase&#39;: The autoIncrement option was set but the keyPath option was empty or an array.&quot;_s };
159 
160     // Install the new ObjectStore into the connection&#39;s metadata.
161     auto info = m_info.createNewObjectStore(name, WTFMove(keyPath), parameters.autoIncrement);
162 
163     // Create the actual IDBObjectStore from the transaction, which also schedules the operation server side.
164     return m_versionChangeTransaction-&gt;createObjectStore(info);
165 }
166 
167 ExceptionOr&lt;Ref&lt;IDBTransaction&gt;&gt; IDBDatabase::transaction(StringOrVectorOfStrings&amp;&amp; storeNames, IDBTransactionMode mode)
168 {
169     LOG(IndexedDB, &quot;IDBDatabase::transaction&quot;);
170 
<span class="line-modified">171     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
172 
173     if (m_versionChangeTransaction &amp;&amp; !m_versionChangeTransaction-&gt;isFinishedOrFinishing())
174         return Exception { InvalidStateError, &quot;Failed to execute &#39;transaction&#39; on &#39;IDBDatabase&#39;: A version change transaction is running.&quot;_s };
175 
176     if (m_closePending)
177         return Exception { InvalidStateError, &quot;Failed to execute &#39;transaction&#39; on &#39;IDBDatabase&#39;: The database connection is closing.&quot;_s };
178 
179     Vector&lt;String&gt; objectStores;
180     if (WTF::holds_alternative&lt;Vector&lt;String&gt;&gt;(storeNames))
181         objectStores = WTFMove(WTF::get&lt;Vector&lt;String&gt;&gt;(storeNames));
182     else
183         objectStores.append(WTFMove(WTF::get&lt;String&gt;(storeNames)));
184 
185     // It is valid for javascript to pass in a list of object store names with the same name listed twice,
186     // so we need to put them all in a set to get a unique list.
187     HashSet&lt;String&gt; objectStoreSet;
188     for (auto&amp; objectStore : objectStores)
189         objectStoreSet.add(objectStore);
190 
191     objectStores = copyToVector(objectStoreSet);
</pre>
<hr />
<pre>
201 
202     if (mode != IDBTransactionMode::Readonly &amp;&amp; mode != IDBTransactionMode::Readwrite)
203         return Exception { TypeError };
204 
205     auto info = IDBTransactionInfo::clientTransaction(m_connectionProxy.get(), objectStores, mode);
206 
207     LOG(IndexedDBOperations, &quot;IDB creating transaction: %s&quot;, info.loggingString().utf8().data());
208     auto transaction = IDBTransaction::create(*this, info);
209 
210     LOG(IndexedDB, &quot;IDBDatabase::transaction - Added active transaction %s&quot;, info.identifier().loggingString().utf8().data());
211 
212     m_activeTransactions.set(info.identifier(), transaction.ptr());
213 
214     return transaction;
215 }
216 
217 ExceptionOr&lt;void&gt; IDBDatabase::deleteObjectStore(const String&amp; objectStoreName)
218 {
219     LOG(IndexedDB, &quot;IDBDatabase::deleteObjectStore&quot;);
220 
<span class="line-modified">221     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
222 
223     if (!m_versionChangeTransaction)
224         return Exception { InvalidStateError, &quot;Failed to execute &#39;deleteObjectStore&#39; on &#39;IDBDatabase&#39;: The database is not running a version change transaction.&quot;_s };
225 
226     if (!m_versionChangeTransaction-&gt;isActive())
227         return Exception { TransactionInactiveError };
228 
229     if (!m_info.hasObjectStore(objectStoreName))
230         return Exception { NotFoundError, &quot;Failed to execute &#39;deleteObjectStore&#39; on &#39;IDBDatabase&#39;: The specified object store was not found.&quot;_s };
231 
232     m_info.deleteObjectStore(objectStoreName);
233     m_versionChangeTransaction-&gt;deleteObjectStore(objectStoreName);
234 
235     return { };
236 }
237 
238 void IDBDatabase::close()
239 {
240     LOG(IndexedDB, &quot;IDBDatabase::close - %&quot; PRIu64, m_databaseConnectionIdentifier);
241 
<span class="line-modified">242     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
243 
244     if (!m_closePending) {
245         m_closePending = true;
246         m_connectionProxy-&gt;databaseConnectionPendingClose(*this);
247     }
248 
249     maybeCloseInServer();
250 }
251 
252 void IDBDatabase::didCloseFromServer(const IDBError&amp; error)
253 {
254     LOG(IndexedDB, &quot;IDBDatabase::didCloseFromServer - %&quot; PRIu64, m_databaseConnectionIdentifier);
255 
256     connectionToServerLost(error);


257 }
258 
259 void IDBDatabase::connectionToServerLost(const IDBError&amp; error)
260 {
261     LOG(IndexedDB, &quot;IDBDatabase::connectionToServerLost - %&quot; PRIu64, m_databaseConnectionIdentifier);
262 
<span class="line-modified">263     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
264 
265     m_closePending = true;
266     m_closedInServer = true;
267 
268     auto activeTransactions = copyToVector(m_activeTransactions.values());
269     for (auto&amp; transaction : activeTransactions)
270         transaction-&gt;connectionClosedFromServer(error);
271 
272     auto committingTransactions = copyToVector(m_committingTransactions.values());
273     for (auto&amp; transaction : committingTransactions)
274         transaction-&gt;connectionClosedFromServer(error);
275 
276     auto errorEvent = Event::create(m_eventNames.errorEvent, Event::CanBubble::Yes, Event::IsCancelable::No);
277     errorEvent-&gt;setTarget(this);
278 
<span class="line-modified">279     if (scriptExecutionContext())</span>
<span class="line-modified">280         queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(errorEvent));</span>
281 
282     auto closeEvent = Event::create(m_eventNames.closeEvent, Event::CanBubble::Yes, Event::IsCancelable::No);
283     closeEvent-&gt;setTarget(this);
284 
<span class="line-modified">285     if (scriptExecutionContext())</span>
<span class="line-modified">286         queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(closeEvent));</span>
287 }
288 
289 void IDBDatabase::maybeCloseInServer()
290 {
291     LOG(IndexedDB, &quot;IDBDatabase::maybeCloseInServer - %&quot; PRIu64, m_databaseConnectionIdentifier);
292 
<span class="line-modified">293     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
294 
295     if (m_closedInServer)
296         return;
297 
298     // 3.3.9 Database closing steps
299     // Wait for all transactions created using this connection to complete.
300     // Once they are complete, this connection is closed.
301     if (!m_activeTransactions.isEmpty() || !m_committingTransactions.isEmpty())
302         return;
303 
304     m_closedInServer = true;
305     m_connectionProxy-&gt;databaseConnectionClosed(*this);
306 }
307 
308 const char* IDBDatabase::activeDOMObjectName() const
309 {
<span class="line-modified">310     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
311     return &quot;IDBDatabase&quot;;
312 }
313 









314 void IDBDatabase::stop()
315 {
316     LOG(IndexedDB, &quot;IDBDatabase::stop - %&quot; PRIu64, m_databaseConnectionIdentifier);
317 
<span class="line-modified">318     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
319 
320     removeAllEventListeners();
321 
322     Vector&lt;IDBResourceIdentifier&gt; transactionIdentifiers;
323     transactionIdentifiers.reserveInitialCapacity(m_activeTransactions.size());
324 
325     for (auto&amp; id : m_activeTransactions.keys())
326         transactionIdentifiers.uncheckedAppend(id);
327 
328     for (auto&amp; id : transactionIdentifiers) {
329         IDBTransaction* transaction = m_activeTransactions.get(id);
330         if (transaction)
331             transaction-&gt;stop();
332     }
333 
334     close();
335 }
336 
337 Ref&lt;IDBTransaction&gt; IDBDatabase::startVersionChangeTransaction(const IDBTransactionInfo&amp; info, IDBOpenDBRequest&amp; request)
338 {
339     LOG(IndexedDB, &quot;IDBDatabase::startVersionChangeTransaction %s&quot;, info.identifier().loggingString().utf8().data());
340 
<span class="line-modified">341     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
342     ASSERT(!m_versionChangeTransaction);
343     ASSERT(info.mode() == IDBTransactionMode::Versionchange);
344     ASSERT(!m_closePending);
345     ASSERT(scriptExecutionContext());
346 
347     Ref&lt;IDBTransaction&gt; transaction = IDBTransaction::create(*this, info, request);
348     m_versionChangeTransaction = &amp;transaction.get();
349 
350     m_activeTransactions.set(transaction-&gt;info().identifier(), &amp;transaction.get());
351 
352     return transaction;
353 }
354 
355 void IDBDatabase::didStartTransaction(IDBTransaction&amp; transaction)
356 {
357     LOG(IndexedDB, &quot;IDBDatabase::didStartTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
358     ASSERT(!m_versionChangeTransaction);
<span class="line-modified">359     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
360 
361     // It is possible for the client to have aborted a transaction before the server replies back that it has started.
362     if (m_abortingTransactions.contains(transaction.info().identifier()))
363         return;
364 
365     m_activeTransactions.set(transaction.info().identifier(), &amp;transaction);
366 }
367 
368 void IDBDatabase::willCommitTransaction(IDBTransaction&amp; transaction)
369 {
370     LOG(IndexedDB, &quot;IDBDatabase::willCommitTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
371 
<span class="line-modified">372     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
373 
374     auto refTransaction = m_activeTransactions.take(transaction.info().identifier());
375     ASSERT(refTransaction);
376     m_committingTransactions.set(transaction.info().identifier(), WTFMove(refTransaction));
377 }
378 
379 void IDBDatabase::didCommitTransaction(IDBTransaction&amp; transaction)
380 {
381     LOG(IndexedDB, &quot;IDBDatabase::didCommitTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
382 
<span class="line-modified">383     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
384 
385     if (m_versionChangeTransaction == &amp;transaction)
386         m_info.setVersion(transaction.info().newVersion());
387 
388     didCommitOrAbortTransaction(transaction);
389 }
390 
391 void IDBDatabase::willAbortTransaction(IDBTransaction&amp; transaction)
392 {
393     LOG(IndexedDB, &quot;IDBDatabase::willAbortTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
394 
<span class="line-modified">395     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
396 
397     auto refTransaction = m_activeTransactions.take(transaction.info().identifier());
398     if (!refTransaction)
399         refTransaction = m_committingTransactions.take(transaction.info().identifier());
400 
401     ASSERT(refTransaction);
402     m_abortingTransactions.set(transaction.info().identifier(), WTFMove(refTransaction));
403 
404     if (transaction.isVersionChange()) {
405         ASSERT(transaction.originalDatabaseInfo());
406         m_info = *transaction.originalDatabaseInfo();
407         m_closePending = true;
408     }
409 }
410 
411 void IDBDatabase::didAbortTransaction(IDBTransaction&amp; transaction)
412 {
413     LOG(IndexedDB, &quot;IDBDatabase::didAbortTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
414 
<span class="line-modified">415     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
416 
417     if (transaction.isVersionChange()) {
418         ASSERT(transaction.originalDatabaseInfo());
419         ASSERT(m_info.version() == transaction.originalDatabaseInfo()-&gt;version());
420         m_closePending = true;
421         maybeCloseInServer();
422     }
423 
424     didCommitOrAbortTransaction(transaction);
425 }
426 
427 void IDBDatabase::didCommitOrAbortTransaction(IDBTransaction&amp; transaction)
428 {
429     LOG(IndexedDB, &quot;IDBDatabase::didCommitOrAbortTransaction %s&quot;, transaction.info().identifier().loggingString().utf8().data());
430 
<span class="line-modified">431     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
432 
433     if (m_versionChangeTransaction == &amp;transaction)
434         m_versionChangeTransaction = nullptr;
435 
436 #ifndef NDBEBUG
437     unsigned count = 0;
438     if (m_activeTransactions.contains(transaction.info().identifier()))
439         ++count;
440     if (m_committingTransactions.contains(transaction.info().identifier()))
441         ++count;
442     if (m_abortingTransactions.contains(transaction.info().identifier()))
443         ++count;
444 
445     ASSERT(count == 1);
446 #endif
447 
448     m_activeTransactions.remove(transaction.info().identifier());
449     m_committingTransactions.remove(transaction.info().identifier());
450     m_abortingTransactions.remove(transaction.info().identifier());
451 
452     if (m_closePending)
453         maybeCloseInServer();
454 }
455 
456 void IDBDatabase::fireVersionChangeEvent(const IDBResourceIdentifier&amp; requestIdentifier, uint64_t requestedVersion)
457 {
458     uint64_t currentVersion = m_info.version();
459     LOG(IndexedDB, &quot;IDBDatabase::fireVersionChangeEvent - current version %&quot; PRIu64 &quot;, requested version %&quot; PRIu64 &quot;, connection %&quot; PRIu64 &quot; (%p)&quot;, currentVersion, requestedVersion, m_databaseConnectionIdentifier, this);
460 
<span class="line-modified">461     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
462 
463     if (!scriptExecutionContext() || m_closePending) {
464         connectionProxy().didFireVersionChangeEvent(m_databaseConnectionIdentifier, requestIdentifier);
465         return;
466     }
467 
468     Ref&lt;Event&gt; event = IDBVersionChangeEvent::create(requestIdentifier, currentVersion, requestedVersion, m_eventNames.versionchangeEvent);
<span class="line-modified">469     queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));</span>

470 }
471 
472 void IDBDatabase::dispatchEvent(Event&amp; event)
473 {
474     LOG(IndexedDB, &quot;IDBDatabase::dispatchEvent (%&quot; PRIu64 &quot;) (%p)&quot;, m_databaseConnectionIdentifier, this);
<span class="line-modified">475     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
476 
477     auto protectedThis = makeRef(*this);
478 
479     EventTargetWithInlineData::dispatchEvent(event);
480 
481     if (event.isVersionChangeEvent() &amp;&amp; event.type() == m_eventNames.versionchangeEvent)
482         m_connectionProxy-&gt;didFireVersionChangeEvent(m_databaseConnectionIdentifier, downcast&lt;IDBVersionChangeEvent&gt;(event).requestIdentifier());
483 }
484 
485 void IDBDatabase::didCreateIndexInfo(const IDBIndexInfo&amp; info)
486 {
<span class="line-modified">487     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
488 
489     auto* objectStore = m_info.infoForExistingObjectStore(info.objectStoreIdentifier());
490     ASSERT(objectStore);
491     objectStore-&gt;addExistingIndex(info);
492 }
493 
494 void IDBDatabase::didDeleteIndexInfo(const IDBIndexInfo&amp; info)
495 {
<span class="line-modified">496     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
497 
498     auto* objectStore = m_info.infoForExistingObjectStore(info.objectStoreIdentifier());
499     ASSERT(objectStore);
500     objectStore-&gt;deleteIndex(info.name());
501 }
502 
503 } // namespace WebCore
504 
505 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="IDBCursor.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBDatabase.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/PCToCodeOriginMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSInterfaceJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PCToCodeOriginMap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/PCToCodeOriginMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 #pragma warning(disable: 4333)
 39 #endif
 40 
 41 namespace JSC {
 42 
 43 namespace {
 44 
 45 class DeltaCompressionBuilder {
 46 public:
 47     DeltaCompressionBuilder(size_t maxSize)
 48         : m_offset(0)
 49         , m_maxSize(maxSize)
 50     {
 51         m_buffer = static_cast&lt;uint8_t*&gt;(fastMalloc(m_maxSize));
 52     }
 53 
 54     template &lt;typename T&gt;
 55     void write(T item)
 56     {
 57         RELEASE_ASSERT(m_offset + sizeof(T) &lt;= m_maxSize);
<span class="line-modified"> 58         static const uint8_t mask = std::numeric_limits&lt;uint8_t&gt;::max();</span>
 59         for (unsigned i = 0; i &lt; sizeof(T); i++) {
 60             *(m_buffer + m_offset) = static_cast&lt;uint8_t&gt;(item &amp; mask);
 61             item = item &gt;&gt; (sizeof(uint8_t) * 8);
 62             m_offset += 1;
 63         }
 64     }
 65 
 66     uint8_t* m_buffer;
 67     size_t m_offset;
 68     size_t m_maxSize;
 69 };
 70 
 71 class DeltaCompresseionReader {
 72 public:
 73     DeltaCompresseionReader(uint8_t* buffer, size_t size)
 74         : m_buffer(buffer)
 75         , m_size(size)
 76         , m_offset(0)
 77     { }
 78 
</pre>
<hr />
<pre>
128 }
129 #endif
130 
131 void PCToCodeOriginMapBuilder::appendItem(MacroAssembler::Label label, const CodeOrigin&amp; codeOrigin)
132 {
133     if (!m_shouldBuildMapping)
134         return;
135 
136     if (m_codeRanges.size()) {
137         if (m_codeRanges.last().end == label)
138             return;
139         m_codeRanges.last().end = label;
140         if (m_codeRanges.last().codeOrigin == codeOrigin || !codeOrigin)
141             return;
142     }
143 
144     m_codeRanges.append(CodeRange{label, label, codeOrigin});
145 }
146 
147 
<span class="line-modified">148 static const uint8_t sentinelPCDelta = 0;</span>
<span class="line-modified">149 static const int8_t sentinelBytecodeDelta = 0;</span>
150 
151 PCToCodeOriginMap::PCToCodeOriginMap(PCToCodeOriginMapBuilder&amp;&amp; builder, LinkBuffer&amp; linkBuffer)
152 {
153     RELEASE_ASSERT(builder.didBuildMapping());
154 
155     if (!builder.m_codeRanges.size()) {
156         m_pcRangeStart = std::numeric_limits&lt;uintptr_t&gt;::max();
157         m_pcRangeEnd = std::numeric_limits&lt;uintptr_t&gt;::max();
158 
159         m_compressedPCBufferSize = 0;
160         m_compressedPCs = nullptr;
161 
162         m_compressedCodeOriginsSize = 0;
163         m_compressedCodeOrigins = nullptr;
164 
165         return;
166     }
167 
168     // We do a final touch-up on the last range here because of how we generate the table.
169     // The final range (if non empty) would be ignored if we didn&#39;t append any (arbitrary)
</pre>
<hr />
<pre>
172     if (!(last.start == last.end))
173         builder.m_codeRanges.append(PCToCodeOriginMapBuilder::CodeRange{ last.end, last.end, last.codeOrigin }); // This range will never actually be found, but it ensures the real last range is found.
174 
175     DeltaCompressionBuilder pcCompressor((sizeof(uintptr_t) + sizeof(uint8_t)) * builder.m_codeRanges.size());
176     void* lastPCValue = nullptr;
177     auto buildPCTable = [&amp;] (void* pcValue) {
178         RELEASE_ASSERT(pcValue &gt; lastPCValue);
179         uintptr_t delta = bitwise_cast&lt;uintptr_t&gt;(pcValue) - bitwise_cast&lt;uintptr_t&gt;(lastPCValue);
180         RELEASE_ASSERT(delta != sentinelPCDelta);
181         lastPCValue = pcValue;
182         if (delta &gt; std::numeric_limits&lt;uint8_t&gt;::max()) {
183             pcCompressor.write&lt;uint8_t&gt;(sentinelPCDelta);
184             pcCompressor.write&lt;uintptr_t&gt;(delta);
185             return;
186         }
187 
188         pcCompressor.write&lt;uint8_t&gt;(static_cast&lt;uint8_t&gt;(delta));
189     };
190 
191     DeltaCompressionBuilder codeOriginCompressor((sizeof(intptr_t) + sizeof(int8_t) + sizeof(int8_t) + sizeof(InlineCallFrame*)) * builder.m_codeRanges.size());
<span class="line-modified">192     CodeOrigin lastCodeOrigin(0, nullptr);</span>
193     auto buildCodeOriginTable = [&amp;] (const CodeOrigin&amp; codeOrigin) {
<span class="line-modified">194         intptr_t delta = static_cast&lt;intptr_t&gt;(codeOrigin.bytecodeIndex()) - static_cast&lt;intptr_t&gt;(lastCodeOrigin.bytecodeIndex());</span>
195         lastCodeOrigin = codeOrigin;
196         if (delta &gt; std::numeric_limits&lt;int8_t&gt;::max() || delta &lt; std::numeric_limits&lt;int8_t&gt;::min() || delta == sentinelBytecodeDelta) {
197             codeOriginCompressor.write&lt;int8_t&gt;(sentinelBytecodeDelta);
198             codeOriginCompressor.write&lt;intptr_t&gt;(delta);
199         } else
200             codeOriginCompressor.write&lt;int8_t&gt;(static_cast&lt;int8_t&gt;(delta));
201 
202         int8_t hasInlineCallFrameByte = codeOrigin.inlineCallFrame() ? 1 : 0;
203         codeOriginCompressor.write&lt;int8_t&gt;(hasInlineCallFrameByte);
204         if (hasInlineCallFrameByte)
205             codeOriginCompressor.write&lt;uintptr_t&gt;(bitwise_cast&lt;uintptr_t&gt;(codeOrigin.inlineCallFrame()));
206     };
207 
208     m_pcRangeStart = linkBuffer.locationOf&lt;NoPtrTag&gt;(builder.m_codeRanges.first().start).dataLocation&lt;uintptr_t&gt;();
209     m_pcRangeEnd = linkBuffer.locationOf&lt;NoPtrTag&gt;(builder.m_codeRanges.last().end).dataLocation&lt;uintptr_t&gt;();
210     m_pcRangeEnd -= 1;
211 
212     for (unsigned i = 0; i &lt; builder.m_codeRanges.size(); i++) {
213         PCToCodeOriginMapBuilder::CodeRange&amp; codeRange = builder.m_codeRanges[i];
214         void* start = linkBuffer.locationOf&lt;NoPtrTag&gt;(codeRange.start).dataLocation();
</pre>
<hr />
<pre>
237         fastFree(m_compressedPCs);
238     if (m_compressedCodeOrigins)
239         fastFree(m_compressedCodeOrigins);
240 }
241 
242 double PCToCodeOriginMap::memorySize()
243 {
244     double size = 0;
245     size += m_compressedPCBufferSize;
246     size += m_compressedCodeOriginsSize;
247     return size;
248 }
249 
250 Optional&lt;CodeOrigin&gt; PCToCodeOriginMap::findPC(void* pc) const
251 {
252     uintptr_t pcAsInt = bitwise_cast&lt;uintptr_t&gt;(pc);
253     if (!(m_pcRangeStart &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= m_pcRangeEnd))
254         return WTF::nullopt;
255 
256     uintptr_t currentPC = 0;
<span class="line-modified">257     unsigned currentBytecodeIndex = 0;</span>
258     InlineCallFrame* currentInlineCallFrame = nullptr;
259 
260     DeltaCompresseionReader pcReader(m_compressedPCs, m_compressedPCBufferSize);
261     DeltaCompresseionReader codeOriginReader(m_compressedCodeOrigins, m_compressedCodeOriginsSize);
262     while (true) {
263         uintptr_t previousPC = currentPC;
264         {
265             uint8_t value = pcReader.read&lt;uint8_t&gt;();
266             uintptr_t delta;
267             if (value == sentinelPCDelta)
268                 delta = pcReader.read&lt;uintptr_t&gt;();
269             else
270                 delta = value;
271             currentPC += delta;
272         }
273 
274         CodeOrigin previousOrigin = CodeOrigin(currentBytecodeIndex, currentInlineCallFrame);
275         {
276             int8_t value = codeOriginReader.read&lt;int8_t&gt;();
277             intptr_t delta;
278             if (value == sentinelBytecodeDelta)
279                 delta = codeOriginReader.read&lt;intptr_t&gt;();
280             else
281                 delta = static_cast&lt;intptr_t&gt;(value);
282 
<span class="line-modified">283             currentBytecodeIndex = static_cast&lt;unsigned&gt;(static_cast&lt;intptr_t&gt;(currentBytecodeIndex) + delta);</span>
284 
285             int8_t hasInlineFrame = codeOriginReader.read&lt;int8_t&gt;();
286             ASSERT(hasInlineFrame == 0 || hasInlineFrame == 1);
287             if (hasInlineFrame)
288                 currentInlineCallFrame = bitwise_cast&lt;InlineCallFrame*&gt;(codeOriginReader.read&lt;uintptr_t&gt;());
289             else
290                 currentInlineCallFrame = nullptr;
291         }
292 
293         if (previousPC) {
294             uintptr_t startOfRange = previousPC;
295             // We subtract 1 because we generate end points inclusively in this table, even though we are interested in ranges of the form: [previousPC, currentPC)
296             uintptr_t endOfRange = currentPC - 1;
297             if (startOfRange &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= endOfRange)
298                 return Optional&lt;CodeOrigin&gt;(previousOrigin); // We return previousOrigin here because CodeOrigin&#39;s are mapped to the startValue of the range.
299         }
300     }
301 
302     RELEASE_ASSERT_NOT_REACHED();
303     return WTF::nullopt;
</pre>
</td>
<td>
<hr />
<pre>
 38 #pragma warning(disable: 4333)
 39 #endif
 40 
 41 namespace JSC {
 42 
 43 namespace {
 44 
 45 class DeltaCompressionBuilder {
 46 public:
 47     DeltaCompressionBuilder(size_t maxSize)
 48         : m_offset(0)
 49         , m_maxSize(maxSize)
 50     {
 51         m_buffer = static_cast&lt;uint8_t*&gt;(fastMalloc(m_maxSize));
 52     }
 53 
 54     template &lt;typename T&gt;
 55     void write(T item)
 56     {
 57         RELEASE_ASSERT(m_offset + sizeof(T) &lt;= m_maxSize);
<span class="line-modified"> 58         static constexpr uint8_t mask = std::numeric_limits&lt;uint8_t&gt;::max();</span>
 59         for (unsigned i = 0; i &lt; sizeof(T); i++) {
 60             *(m_buffer + m_offset) = static_cast&lt;uint8_t&gt;(item &amp; mask);
 61             item = item &gt;&gt; (sizeof(uint8_t) * 8);
 62             m_offset += 1;
 63         }
 64     }
 65 
 66     uint8_t* m_buffer;
 67     size_t m_offset;
 68     size_t m_maxSize;
 69 };
 70 
 71 class DeltaCompresseionReader {
 72 public:
 73     DeltaCompresseionReader(uint8_t* buffer, size_t size)
 74         : m_buffer(buffer)
 75         , m_size(size)
 76         , m_offset(0)
 77     { }
 78 
</pre>
<hr />
<pre>
128 }
129 #endif
130 
131 void PCToCodeOriginMapBuilder::appendItem(MacroAssembler::Label label, const CodeOrigin&amp; codeOrigin)
132 {
133     if (!m_shouldBuildMapping)
134         return;
135 
136     if (m_codeRanges.size()) {
137         if (m_codeRanges.last().end == label)
138             return;
139         m_codeRanges.last().end = label;
140         if (m_codeRanges.last().codeOrigin == codeOrigin || !codeOrigin)
141             return;
142     }
143 
144     m_codeRanges.append(CodeRange{label, label, codeOrigin});
145 }
146 
147 
<span class="line-modified">148 static constexpr uint8_t sentinelPCDelta = 0;</span>
<span class="line-modified">149 static constexpr int8_t sentinelBytecodeDelta = 0;</span>
150 
151 PCToCodeOriginMap::PCToCodeOriginMap(PCToCodeOriginMapBuilder&amp;&amp; builder, LinkBuffer&amp; linkBuffer)
152 {
153     RELEASE_ASSERT(builder.didBuildMapping());
154 
155     if (!builder.m_codeRanges.size()) {
156         m_pcRangeStart = std::numeric_limits&lt;uintptr_t&gt;::max();
157         m_pcRangeEnd = std::numeric_limits&lt;uintptr_t&gt;::max();
158 
159         m_compressedPCBufferSize = 0;
160         m_compressedPCs = nullptr;
161 
162         m_compressedCodeOriginsSize = 0;
163         m_compressedCodeOrigins = nullptr;
164 
165         return;
166     }
167 
168     // We do a final touch-up on the last range here because of how we generate the table.
169     // The final range (if non empty) would be ignored if we didn&#39;t append any (arbitrary)
</pre>
<hr />
<pre>
172     if (!(last.start == last.end))
173         builder.m_codeRanges.append(PCToCodeOriginMapBuilder::CodeRange{ last.end, last.end, last.codeOrigin }); // This range will never actually be found, but it ensures the real last range is found.
174 
175     DeltaCompressionBuilder pcCompressor((sizeof(uintptr_t) + sizeof(uint8_t)) * builder.m_codeRanges.size());
176     void* lastPCValue = nullptr;
177     auto buildPCTable = [&amp;] (void* pcValue) {
178         RELEASE_ASSERT(pcValue &gt; lastPCValue);
179         uintptr_t delta = bitwise_cast&lt;uintptr_t&gt;(pcValue) - bitwise_cast&lt;uintptr_t&gt;(lastPCValue);
180         RELEASE_ASSERT(delta != sentinelPCDelta);
181         lastPCValue = pcValue;
182         if (delta &gt; std::numeric_limits&lt;uint8_t&gt;::max()) {
183             pcCompressor.write&lt;uint8_t&gt;(sentinelPCDelta);
184             pcCompressor.write&lt;uintptr_t&gt;(delta);
185             return;
186         }
187 
188         pcCompressor.write&lt;uint8_t&gt;(static_cast&lt;uint8_t&gt;(delta));
189     };
190 
191     DeltaCompressionBuilder codeOriginCompressor((sizeof(intptr_t) + sizeof(int8_t) + sizeof(int8_t) + sizeof(InlineCallFrame*)) * builder.m_codeRanges.size());
<span class="line-modified">192     CodeOrigin lastCodeOrigin(BytecodeIndex(0));</span>
193     auto buildCodeOriginTable = [&amp;] (const CodeOrigin&amp; codeOrigin) {
<span class="line-modified">194         intptr_t delta = static_cast&lt;intptr_t&gt;(codeOrigin.bytecodeIndex().offset()) - static_cast&lt;intptr_t&gt;(lastCodeOrigin.bytecodeIndex().offset());</span>
195         lastCodeOrigin = codeOrigin;
196         if (delta &gt; std::numeric_limits&lt;int8_t&gt;::max() || delta &lt; std::numeric_limits&lt;int8_t&gt;::min() || delta == sentinelBytecodeDelta) {
197             codeOriginCompressor.write&lt;int8_t&gt;(sentinelBytecodeDelta);
198             codeOriginCompressor.write&lt;intptr_t&gt;(delta);
199         } else
200             codeOriginCompressor.write&lt;int8_t&gt;(static_cast&lt;int8_t&gt;(delta));
201 
202         int8_t hasInlineCallFrameByte = codeOrigin.inlineCallFrame() ? 1 : 0;
203         codeOriginCompressor.write&lt;int8_t&gt;(hasInlineCallFrameByte);
204         if (hasInlineCallFrameByte)
205             codeOriginCompressor.write&lt;uintptr_t&gt;(bitwise_cast&lt;uintptr_t&gt;(codeOrigin.inlineCallFrame()));
206     };
207 
208     m_pcRangeStart = linkBuffer.locationOf&lt;NoPtrTag&gt;(builder.m_codeRanges.first().start).dataLocation&lt;uintptr_t&gt;();
209     m_pcRangeEnd = linkBuffer.locationOf&lt;NoPtrTag&gt;(builder.m_codeRanges.last().end).dataLocation&lt;uintptr_t&gt;();
210     m_pcRangeEnd -= 1;
211 
212     for (unsigned i = 0; i &lt; builder.m_codeRanges.size(); i++) {
213         PCToCodeOriginMapBuilder::CodeRange&amp; codeRange = builder.m_codeRanges[i];
214         void* start = linkBuffer.locationOf&lt;NoPtrTag&gt;(codeRange.start).dataLocation();
</pre>
<hr />
<pre>
237         fastFree(m_compressedPCs);
238     if (m_compressedCodeOrigins)
239         fastFree(m_compressedCodeOrigins);
240 }
241 
242 double PCToCodeOriginMap::memorySize()
243 {
244     double size = 0;
245     size += m_compressedPCBufferSize;
246     size += m_compressedCodeOriginsSize;
247     return size;
248 }
249 
250 Optional&lt;CodeOrigin&gt; PCToCodeOriginMap::findPC(void* pc) const
251 {
252     uintptr_t pcAsInt = bitwise_cast&lt;uintptr_t&gt;(pc);
253     if (!(m_pcRangeStart &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= m_pcRangeEnd))
254         return WTF::nullopt;
255 
256     uintptr_t currentPC = 0;
<span class="line-modified">257     BytecodeIndex currentBytecodeIndex = BytecodeIndex(0);</span>
258     InlineCallFrame* currentInlineCallFrame = nullptr;
259 
260     DeltaCompresseionReader pcReader(m_compressedPCs, m_compressedPCBufferSize);
261     DeltaCompresseionReader codeOriginReader(m_compressedCodeOrigins, m_compressedCodeOriginsSize);
262     while (true) {
263         uintptr_t previousPC = currentPC;
264         {
265             uint8_t value = pcReader.read&lt;uint8_t&gt;();
266             uintptr_t delta;
267             if (value == sentinelPCDelta)
268                 delta = pcReader.read&lt;uintptr_t&gt;();
269             else
270                 delta = value;
271             currentPC += delta;
272         }
273 
274         CodeOrigin previousOrigin = CodeOrigin(currentBytecodeIndex, currentInlineCallFrame);
275         {
276             int8_t value = codeOriginReader.read&lt;int8_t&gt;();
277             intptr_t delta;
278             if (value == sentinelBytecodeDelta)
279                 delta = codeOriginReader.read&lt;intptr_t&gt;();
280             else
281                 delta = static_cast&lt;intptr_t&gt;(value);
282 
<span class="line-modified">283             currentBytecodeIndex = BytecodeIndex(static_cast&lt;intptr_t&gt;(currentBytecodeIndex.offset()) + delta);</span>
284 
285             int8_t hasInlineFrame = codeOriginReader.read&lt;int8_t&gt;();
286             ASSERT(hasInlineFrame == 0 || hasInlineFrame == 1);
287             if (hasInlineFrame)
288                 currentInlineCallFrame = bitwise_cast&lt;InlineCallFrame*&gt;(codeOriginReader.read&lt;uintptr_t&gt;());
289             else
290                 currentInlineCallFrame = nullptr;
291         }
292 
293         if (previousPC) {
294             uintptr_t startOfRange = previousPC;
295             // We subtract 1 because we generate end points inclusively in this table, even though we are interested in ranges of the form: [previousPC, currentPC)
296             uintptr_t endOfRange = currentPC - 1;
297             if (startOfRange &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= endOfRange)
298                 return Optional&lt;CodeOrigin&gt;(previousOrigin); // We return previousOrigin here because CodeOrigin&#39;s are mapped to the startValue of the range.
299         }
300     }
301 
302     RELEASE_ASSERT_NOT_REACHED();
303     return WTF::nullopt;
</pre>
</td>
</tr>
</table>
<center><a href="JSInterfaceJIT.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PCToCodeOriginMap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
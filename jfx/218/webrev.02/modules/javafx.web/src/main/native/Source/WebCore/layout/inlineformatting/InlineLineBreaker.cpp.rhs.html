<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBreaker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineLineBreaker.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;FontCascade.h&quot;</span>
 32 #include &quot;Hyphenation.h&quot;
 33 #include &quot;InlineItem.h&quot;
 34 #include &quot;InlineTextItem.h&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 35 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added"> 36 #include &quot;TextUtil.h&quot;</span>
 37 
 38 namespace WebCore {
 39 namespace Layout {
 40 
<a name="3" id="anc3"></a><span class="line-modified"> 41 static inline bool isWrappingAllowed(const RenderStyle&amp; style)</span>
 42 {
<a name="4" id="anc4"></a><span class="line-modified"> 43     // Do not try to push overflown &#39;pre&#39; and &#39;no-wrap&#39; content to next line.</span>
<span class="line-modified"> 44     return style.whiteSpace() != WhiteSpace::Pre &amp;&amp; style.whiteSpace() != WhiteSpace::NoWrap;</span>
<span class="line-modified"> 45 }</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 static inline bool shouldKeepBeginningOfLineWhitespace(const RenderStyle&amp; style)</span>
<span class="line-added"> 48 {</span>
<span class="line-added"> 49     auto whitespace = style.whiteSpace();</span>
<span class="line-added"> 50     return whitespace == WhiteSpace::Pre || whitespace == WhiteSpace::PreWrap || whitespace == WhiteSpace::BreakSpaces;</span>
<span class="line-added"> 51 }</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53 static inline Optional&lt;size_t&gt; lastWrapOpportunityIndex(const LineBreaker::RunList&amp; runList)</span>
<span class="line-added"> 54 {</span>
<span class="line-added"> 55     // &lt;span style=&quot;white-space: pre&quot;&gt;no_wrap&lt;/span&gt;&lt;span&gt;yes wrap&lt;/span&gt;&lt;span style=&quot;white-space: pre&quot;&gt;no_wrap&lt;/span&gt;.</span>
<span class="line-added"> 56     // [container start][no_wrap][container end][container start][yes] &lt;- continuous content</span>
<span class="line-added"> 57     // [ ] &lt;- continuous content</span>
<span class="line-added"> 58     // [wrap][container end][container start][no_wrap][container end] &lt;- continuous content</span>
<span class="line-added"> 59     // Return #0 as the index where the second continuous content can wrap at.</span>
<span class="line-added"> 60     ASSERT(!runList.isEmpty());</span>
<span class="line-added"> 61     auto lastItemIndex = runList.size() - 1;</span>
<span class="line-added"> 62     return isWrappingAllowed(runList[lastItemIndex].inlineItem.style()) ? makeOptional(lastItemIndex) : WTF::nullopt;</span>
<span class="line-added"> 63 }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65 struct ContinuousContent {</span>
<span class="line-added"> 66     ContinuousContent(const LineBreaker::RunList&amp;, InlineLayoutUnit contentLogicalWidth);</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68     const LineBreaker::RunList&amp; runs() const { return m_runs; }</span>
<span class="line-added"> 69     bool isEmpty() const { return m_runs.isEmpty(); }</span>
<span class="line-added"> 70     bool hasTextContentOnly() const;</span>
<span class="line-added"> 71     bool isVisuallyEmptyWhitespaceContentOnly() const;</span>
<span class="line-added"> 72     bool hasNonContentRunsOnly() const;</span>
<span class="line-added"> 73     size_t size() const { return m_runs.size(); }</span>
<span class="line-added"> 74     InlineLayoutUnit width() const { return m_width; }</span>
<span class="line-added"> 75     InlineLayoutUnit nonCollapsibleWidth() const { return m_width - m_trailingCollapsibleContent.width; }</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77     bool hasTrailingCollapsibleContent() const { return !!m_trailingCollapsibleContent.width; }</span>
<span class="line-added"> 78     bool isTrailingContentFullyCollapsible() const { return m_trailingCollapsibleContent.isFullyCollapsible; }</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80     Optional&lt;size_t&gt; firstTextRunIndex() const;</span>
<span class="line-added"> 81     Optional&lt;size_t&gt; lastContentRunIndex() const;</span>
<span class="line-added"> 82 </span>
<span class="line-added"> 83 private:</span>
<span class="line-added"> 84     const LineBreaker::RunList&amp; m_runs;</span>
<span class="line-added"> 85     struct TrailingCollapsibleContent {</span>
<span class="line-added"> 86         void reset();</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88         bool isFullyCollapsible { false };</span>
<span class="line-added"> 89         InlineLayoutUnit width { 0 };</span>
<span class="line-added"> 90     };</span>
<span class="line-added"> 91     TrailingCollapsibleContent m_trailingCollapsibleContent;</span>
<span class="line-added"> 92     InlineLayoutUnit m_width { 0 };</span>
<span class="line-added"> 93 };</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95 struct WrappedTextContent {</span>
<span class="line-added"> 96     unsigned trailingRunIndex { 0 };</span>
<span class="line-added"> 97     bool contentOverflows { false };</span>
<span class="line-added"> 98     Optional&lt;LineBreaker::PartialRun&gt; partialTrailingRun;</span>
<span class="line-added"> 99 };</span>
<span class="line-added">100 </span>
<span class="line-added">101 bool LineBreaker::isContentWrappingAllowed(const ContinuousContent&amp; candidateRuns) const</span>
<span class="line-added">102 {</span>
<span class="line-added">103     // Use the last inline item with content (where we would be wrapping) to decide if content wrapping is allowed.</span>
<span class="line-added">104     auto runIndex = candidateRuns.lastContentRunIndex().valueOr(candidateRuns.size() - 1);</span>
<span class="line-added">105     return isWrappingAllowed(candidateRuns.runs()[runIndex].inlineItem.style());</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
<span class="line-added">108 bool LineBreaker::shouldKeepEndOfLineWhitespace(const ContinuousContent&amp; candidateRuns) const</span>
<span class="line-added">109 {</span>
<span class="line-added">110     // Grab the style and check for white-space property to decided whether we should let this whitespace content overflow the current line.</span>
<span class="line-added">111     // Note that the &quot;keep&quot; in the context means we let the whitespace content sit on the current line.</span>
<span class="line-added">112     // It might very well get collapsed when we close the line (normal/nowrap/pre-line).</span>
<span class="line-added">113     // See https://www.w3.org/TR/css-text-3/#white-space-property</span>
<span class="line-added">114     auto whitespace = candidateRuns.runs()[*candidateRuns.firstTextRunIndex()].inlineItem.style().whiteSpace();</span>
<span class="line-added">115     return whitespace == WhiteSpace::Normal || whitespace == WhiteSpace::NoWrap || whitespace == WhiteSpace::PreWrap || whitespace == WhiteSpace::PreLine;</span>
<span class="line-added">116 }</span>
<span class="line-added">117 </span>
<span class="line-added">118 LineBreaker::Result LineBreaker::shouldWrapInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp; lineStatus)</span>
<span class="line-added">119 {</span>
<span class="line-added">120     auto inlineContentWrapping = [&amp;] {</span>
<span class="line-added">121         if (candidateContentLogicalWidth &lt;= lineStatus.availableWidth)</span>
<span class="line-added">122             return Result { Result::Action::Keep };</span>
<span class="line-added">123 #if USE_FLOAT_AS_INLINE_LAYOUT_UNIT</span>
<span class="line-added">124         // Preferred width computation sums up floats while line breaker substracts them. This can lead to epsilon-scale differences.</span>
<span class="line-added">125         if (WTF::areEssentiallyEqual(candidateContentLogicalWidth, lineStatus.availableWidth))</span>
<span class="line-added">126             return Result { Result::Action::Keep };</span>
<span class="line-added">127 #endif</span>
<span class="line-added">128         return tryWrappingInlineContent(candidateRuns, candidateContentLogicalWidth, lineStatus);</span>
<span class="line-added">129     };</span>
<span class="line-added">130 </span>
<span class="line-added">131     auto result = inlineContentWrapping();</span>
<span class="line-added">132     if (result.action == Result::Action::Keep) {</span>
<span class="line-added">133         // If this is not the end of the line, hold on to the last eligible line wrap opportunity so that we could revert back</span>
<span class="line-added">134         // to this position if no other line breaking opportunity exists in this content.</span>
<span class="line-added">135         if (auto lastLineWrapOpportunityIndex = lastWrapOpportunityIndex(candidateRuns)) {</span>
<span class="line-added">136             auto isEligibleLineWrapOpportunity = [&amp;] (auto&amp; candidateItem) {</span>
<span class="line-added">137                 // Just check for leading collapsible whitespace for now.</span>
<span class="line-added">138                 if (!lineStatus.lineIsEmpty || !candidateItem.isText() || !downcast&lt;InlineTextItem&gt;(candidateItem).isWhitespace())</span>
<span class="line-added">139                     return true;</span>
<span class="line-added">140                 return shouldKeepBeginningOfLineWhitespace(candidateItem.style());</span>
<span class="line-added">141             };</span>
<span class="line-added">142             auto&amp; inlineItem = candidateRuns[*lastLineWrapOpportunityIndex].inlineItem;</span>
<span class="line-added">143             if (isEligibleLineWrapOpportunity(inlineItem))</span>
<span class="line-added">144                 m_lastWrapOpportunity = &amp;inlineItem;</span>
<span class="line-added">145         }</span>
<span class="line-added">146     }</span>
<span class="line-added">147     return result;</span>
<span class="line-added">148 }</span>
<span class="line-added">149 </span>
<span class="line-added">150 LineBreaker::Result LineBreaker::tryWrappingInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp; lineStatus) const</span>
<span class="line-added">151 {</span>
<span class="line-added">152     auto candidateContent = ContinuousContent { candidateRuns, candidateContentLogicalWidth };</span>
<span class="line-added">153     ASSERT(!candidateContent.isEmpty());</span>
<span class="line-added">154 </span>
<span class="line-added">155     ASSERT(candidateContent.width() &gt; lineStatus.availableWidth);</span>
<span class="line-added">156     if (candidateContent.hasTrailingCollapsibleContent()) {</span>
<span class="line-added">157         ASSERT(candidateContent.hasTextContentOnly());</span>
<span class="line-added">158         auto IsEndOfLine = isContentWrappingAllowed(candidateContent) ? IsEndOfLine::Yes : IsEndOfLine::No;</span>
<span class="line-added">159         // First check if the content fits without the trailing collapsible part.</span>
<span class="line-added">160         if (candidateContent.nonCollapsibleWidth() &lt;= lineStatus.availableWidth)</span>
<span class="line-added">161             return { Result::Action::Keep, IsEndOfLine };</span>
<span class="line-added">162         // Now check if we can trim the line too.</span>
<span class="line-added">163         if (lineStatus.lineHasFullyCollapsibleTrailingRun &amp;&amp; candidateContent.isTrailingContentFullyCollapsible()) {</span>
<span class="line-added">164             // If this new content is fully collapsible, it should surely fit.</span>
<span class="line-added">165             return { Result::Action::Keep, IsEndOfLine };</span>
<span class="line-added">166         }</span>
<span class="line-added">167     } else if (lineStatus.collapsibleWidth &amp;&amp; candidateContent.hasNonContentRunsOnly()) {</span>
<span class="line-added">168         // Let&#39;s see if the non-content runs fit when the line has trailing collapsible content.</span>
<span class="line-added">169         // &quot;text content &lt;span style=&quot;padding: 1px&quot;&gt;&lt;/span&gt;&quot; &lt;- the &lt;span&gt;&lt;/span&gt; runs could fit after collapsing the trailing whitespace.</span>
<span class="line-added">170         if (candidateContent.width() &lt;= lineStatus.availableWidth + lineStatus.collapsibleWidth)</span>
<span class="line-added">171             return { Result::Action::Keep };</span>
<span class="line-added">172     }</span>
<span class="line-added">173     if (candidateContent.isVisuallyEmptyWhitespaceContentOnly() &amp;&amp; shouldKeepEndOfLineWhitespace(candidateContent)) {</span>
<span class="line-added">174         // This overflowing content apparently falls into the remove/hang end-of-line-spaces category.</span>
<span class="line-added">175         // see https://www.w3.org/TR/css-text-3/#white-space-property matrix</span>
<span class="line-added">176         return { Result::Action::Keep };</span>
<span class="line-added">177     }</span>
<span class="line-added">178 </span>
<span class="line-added">179     if (candidateContent.hasTextContentOnly()) {</span>
<span class="line-added">180         auto&amp; runs = candidateContent.runs();</span>
<span class="line-added">181         if (auto wrappedTextContent = wrapTextContent(runs, lineStatus)) {</span>
<span class="line-added">182             if (!wrappedTextContent-&gt;trailingRunIndex &amp;&amp; wrappedTextContent-&gt;contentOverflows) {</span>
<span class="line-added">183                 // We tried to split the content but the available space can&#39;t even accommodate the first character.</span>
<span class="line-added">184                 // 1. Push the content over to the next line when we&#39;ve got content on the line already.</span>
<span class="line-added">185                 // 2. Keep the first character on the empty line (or keep the whole run if it has only one character).</span>
<span class="line-added">186                 if (!lineStatus.lineIsEmpty)</span>
<span class="line-added">187                     return { Result::Action::Push, IsEndOfLine::Yes, { } };</span>
<span class="line-added">188                 auto firstTextRunIndex = *candidateContent.firstTextRunIndex();</span>
<span class="line-added">189                 auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(runs[firstTextRunIndex].inlineItem);</span>
<span class="line-added">190                 ASSERT(inlineTextItem.length());</span>
<span class="line-added">191                 if (inlineTextItem.length() == 1)</span>
<span class="line-added">192                     return Result { Result::Action::Keep, IsEndOfLine::Yes };</span>
<span class="line-added">193                 auto firstCharacterWidth = TextUtil::width(inlineTextItem, inlineTextItem.start(), inlineTextItem.start() + 1);</span>
<span class="line-added">194                 auto firstCharacterRun = PartialRun { 1, firstCharacterWidth, false };</span>
<span class="line-added">195                 return { Result::Action::Split, IsEndOfLine::Yes, Result::PartialTrailingContent { firstTextRunIndex, firstCharacterRun } };</span>
<span class="line-added">196             }</span>
<span class="line-added">197             auto splitContent = Result::PartialTrailingContent { wrappedTextContent-&gt;trailingRunIndex, wrappedTextContent-&gt;partialTrailingRun };</span>
<span class="line-added">198             return { Result::Action::Split, IsEndOfLine::Yes, splitContent };</span>
<span class="line-added">199         }</span>
<span class="line-added">200     }</span>
<span class="line-added">201     // If we are not allowed to break this overflowing content, we still need to decide whether keep it or push it to the next line.</span>
<span class="line-added">202     if (lineStatus.lineIsEmpty) {</span>
<span class="line-added">203         ASSERT(!m_lastWrapOpportunity);</span>
<span class="line-added">204         return { Result::Action::Keep, IsEndOfLine::No };</span>
<span class="line-added">205     }</span>
<span class="line-added">206     // Now either wrap here or at an earlier position, or not wrap at all.</span>
<span class="line-added">207     if (isContentWrappingAllowed(candidateContent))</span>
<span class="line-added">208         return { Result::Action::Push, IsEndOfLine::Yes };</span>
<span class="line-added">209     if (m_lastWrapOpportunity)</span>
<span class="line-added">210         return { Result::Action::Revert, IsEndOfLine::Yes, { }, m_lastWrapOpportunity };</span>
<span class="line-added">211     return { Result::Action::Keep, IsEndOfLine::No };</span>
<span class="line-added">212 }</span>
213 
<a name="5" id="anc5"></a><span class="line-modified">214 bool LineBreaker::shouldWrapFloatBox(InlineLayoutUnit floatLogicalWidth, InlineLayoutUnit availableWidth, bool lineIsEmpty)</span>
<span class="line-modified">215 {</span>
<span class="line-added">216     return !lineIsEmpty &amp;&amp; floatLogicalWidth &gt; availableWidth;</span>
<span class="line-added">217 }</span>
218 
<a name="6" id="anc6"></a><span class="line-modified">219 Optional&lt;WrappedTextContent&gt; LineBreaker::wrapTextContent(const RunList&amp; runs, const LineStatus&amp; lineStatus) const</span>
<span class="line-modified">220 {</span>
<span class="line-added">221     auto isContentSplitAllowed = [] (auto&amp; run) {</span>
<span class="line-added">222         ASSERT(run.inlineItem.isText() || run.inlineItem.isContainerStart() || run.inlineItem.isContainerEnd());</span>
<span class="line-added">223         if (!run.inlineItem.isText()) {</span>
<span class="line-added">224             // Can&#39;t split horizontal spacing -&gt; e.g. &lt;span style=&quot;padding-right: 100px;&quot;&gt;textcontent&lt;/span&gt;, if the [container end] is the overflown inline item</span>
<span class="line-added">225             // we need to check if there&#39;s another inline item beyond the [container end] to split.</span>
<span class="line-added">226             return false;</span>
<span class="line-added">227         }</span>
<span class="line-added">228         return isWrappingAllowed(run.inlineItem.style());</span>
<span class="line-added">229     };</span>
230 
<a name="7" id="anc7"></a><span class="line-modified">231     // Check where the overflow occurs and use the corresponding style to figure out the breaking behaviour.</span>
<span class="line-modified">232     // &lt;span style=&quot;word-break: normal&quot;&gt;first&lt;/span&gt;&lt;span style=&quot;word-break: break-all&quot;&gt;second&lt;/span&gt;&lt;span style=&quot;word-break: normal&quot;&gt;third&lt;/span&gt;</span>
<span class="line-modified">233     InlineLayoutUnit accumulatedRunWidth = 0;</span>
<span class="line-modified">234     unsigned index = 0;</span>
<span class="line-modified">235     while (index &lt; runs.size()) {</span>
<span class="line-added">236         auto&amp; run = runs[index];</span>
<span class="line-added">237         ASSERT(run.inlineItem.isText() || run.inlineItem.isContainerStart() || run.inlineItem.isContainerEnd());</span>
<span class="line-added">238         if (accumulatedRunWidth + run.logicalWidth &gt; lineStatus.availableWidth &amp;&amp; isContentSplitAllowed(run)) {</span>
<span class="line-added">239             // At this point the available width can very well be negative e.g. when some part of the continuous text content can not be broken into parts -&gt;</span>
<span class="line-added">240             // &lt;span style=&quot;word-break: keep-all&quot;&gt;textcontentwithnobreak&lt;/span&gt;&lt;span&gt;textcontentwithyesbreak&lt;/span&gt;</span>
<span class="line-added">241             // When the first span computes longer than the available space, by the time we get to the second span, the adjusted available space becomes negative.</span>
<span class="line-added">242             auto adjustedAvailableWidth = std::max&lt;InlineLayoutUnit&gt;(0, lineStatus.availableWidth - accumulatedRunWidth);</span>
<span class="line-added">243             if (auto partialRun = tryBreakingTextRun(run, adjustedAvailableWidth)) {</span>
<span class="line-added">244                  if (partialRun-&gt;length)</span>
<span class="line-added">245                      return WrappedTextContent { index, false, partialRun };</span>
<span class="line-added">246                  // When the content is wrapped at the run boundary, the trailing run is the previous run.</span>
<span class="line-added">247                  if (index)</span>
<span class="line-added">248                      return WrappedTextContent { index - 1, false, { } };</span>
<span class="line-added">249                  // Sometimes we can&#39;t accommodate even the very first character.</span>
<span class="line-added">250                  return WrappedTextContent { 0, true, { } };</span>
<span class="line-added">251              }</span>
<span class="line-added">252             // If this run is not breakable, we need to check if any previous run is breakable</span>
<span class="line-added">253             break;</span>
<span class="line-added">254         }</span>
<span class="line-added">255         accumulatedRunWidth += run.logicalWidth;</span>
<span class="line-added">256         ++index;</span>
<span class="line-added">257     }</span>
<span class="line-added">258     // We did not manage to break the run that actually overflows the line.</span>
<span class="line-added">259     // Let&#39;s try to find the first breakable run and wrap it at the content boundary (as it surely fits).</span>
<span class="line-added">260     while (index--) {</span>
<span class="line-added">261         auto&amp; run = runs[index];</span>
<span class="line-added">262         if (isContentSplitAllowed(run)) {</span>
<span class="line-added">263             ASSERT(run.inlineItem.isText());</span>
<span class="line-added">264             if (auto partialRun = tryBreakingTextRun(run, maxInlineLayoutUnit())) {</span>
<span class="line-added">265                  // We know this run fits, so if wrapping is allowed on the run, it should return a non-empty left-side.</span>
<span class="line-added">266                  ASSERT(partialRun-&gt;length);</span>
<span class="line-added">267                  return WrappedTextContent { index, false, partialRun };</span>
<span class="line-added">268             }</span>
<span class="line-added">269         }</span>
<span class="line-added">270     }</span>
<span class="line-added">271     // Give up, there&#39;s no breakable run in here.</span>
<span class="line-added">272     return { };</span>
273 }
274 
<a name="8" id="anc8"></a><span class="line-modified">275 LineBreaker::WordBreakRule LineBreaker::wordBreakBehavior(const RenderStyle&amp; style) const</span>
276 {
<a name="9" id="anc9"></a><span class="line-modified">277     // Disregard any prohibition against line breaks mandated by the word-break property.</span>
<span class="line-modified">278     // The different wrapping opportunities must not be prioritized. Hyphenation is not applied.</span>
<span class="line-modified">279     if (style.lineBreak() == LineBreak::Anywhere)</span>
<span class="line-modified">280         return WordBreakRule::AtArbitraryPosition;</span>
<span class="line-modified">281     // Breaking is allowed within “words”.</span>
<span class="line-modified">282     if (style.wordBreak() == WordBreak::BreakAll)</span>
<span class="line-modified">283         return WordBreakRule::AtArbitraryPosition;</span>
<span class="line-modified">284     // Breaking is forbidden within “words”.</span>
<span class="line-added">285     if (style.wordBreak() == WordBreak::KeepAll)</span>
<span class="line-added">286         return WordBreakRule::NoBreak;</span>
<span class="line-added">287     // For compatibility with legacy content, the word-break property also supports a deprecated break-word keyword.</span>
<span class="line-added">288     // When specified, this has the same effect as word-break: normal and overflow-wrap: anywhere, regardless of the actual value of the overflow-wrap property.</span>
<span class="line-added">289     if (style.wordBreak() == WordBreak::BreakWord &amp;&amp; !m_lastWrapOpportunity)</span>
<span class="line-added">290         return WordBreakRule::AtArbitraryPosition;</span>
<span class="line-added">291     // OverflowWrap::Break: An otherwise unbreakable sequence of characters may be broken at an arbitrary point if there are no otherwise-acceptable break points in the line.</span>
<span class="line-added">292     if (style.overflowWrap() == OverflowWrap::Break &amp;&amp; !m_lastWrapOpportunity)</span>
<span class="line-added">293         return WordBreakRule::AtArbitraryPosition;</span>
<span class="line-added">294 </span>
<span class="line-added">295     if (!n_hyphenationIsDisabled &amp;&amp; style.hyphens() == Hyphens::Auto &amp;&amp; canHyphenate(style.locale()))</span>
<span class="line-added">296         return WordBreakRule::OnlyHyphenationAllowed;</span>
<span class="line-added">297 </span>
<span class="line-added">298     return WordBreakRule::NoBreak;</span>
<span class="line-added">299 }</span>
<span class="line-added">300 </span>
<span class="line-added">301 Optional&lt;LineBreaker::PartialRun&gt; LineBreaker::tryBreakingTextRun(const Run&amp; overflowRun, InlineLayoutUnit availableWidth) const</span>
<span class="line-added">302 {</span>
<span class="line-added">303     ASSERT(overflowRun.inlineItem.isText());</span>
<span class="line-added">304     auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(overflowRun.inlineItem);</span>
<span class="line-added">305     auto&amp; style = inlineTextItem.style();</span>
<span class="line-added">306     auto findLastBreakablePosition = availableWidth == maxInlineLayoutUnit();</span>
<span class="line-added">307 </span>
<span class="line-added">308     auto breakRule = wordBreakBehavior(style);</span>
<span class="line-added">309     if (breakRule == WordBreakRule::AtArbitraryPosition) {</span>
<span class="line-added">310         if (findLastBreakablePosition) {</span>
<span class="line-added">311             // When the run can be split at arbitrary position,</span>
<span class="line-added">312             // let&#39;s just return the entire run when it is intended to fit on the line.</span>
<span class="line-added">313             return PartialRun { inlineTextItem.length(), overflowRun.logicalWidth, false };</span>
<span class="line-added">314         }</span>
<span class="line-added">315         // FIXME: Pass in the content logical left to be able to measure tabs.</span>
<span class="line-added">316         auto splitData = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), inlineTextItem.length(), overflowRun.logicalWidth, availableWidth, { });</span>
<span class="line-added">317         return PartialRun { splitData.length, splitData.logicalWidth, false };</span>
<span class="line-added">318     }</span>
<span class="line-added">319 </span>
<span class="line-added">320     if (breakRule == WordBreakRule::OnlyHyphenationAllowed) {</span>
<span class="line-added">321         // Find the hyphen position as follows:</span>
<span class="line-added">322         // 1. Split the text by taking the hyphen width into account</span>
<span class="line-added">323         // 2. Find the last hyphen position before the split position</span>
<span class="line-added">324         auto runLength = inlineTextItem.length();</span>
<span class="line-added">325         unsigned limitBefore = style.hyphenationLimitBefore() == RenderStyle::initialHyphenationLimitBefore() ? 0 : style.hyphenationLimitBefore();</span>
<span class="line-added">326         unsigned limitAfter = style.hyphenationLimitAfter() == RenderStyle::initialHyphenationLimitAfter() ? 0 : style.hyphenationLimitAfter();</span>
<span class="line-added">327         // Check if this run can accommodate the before/after limits at all before start measuring text.</span>
<span class="line-added">328         if (limitBefore &gt;= runLength || limitAfter &gt;= runLength || limitBefore + limitAfter &gt; runLength)</span>
<span class="line-added">329             return { };</span>
<span class="line-added">330 </span>
<span class="line-added">331         unsigned leftSideLength = runLength;</span>
<span class="line-added">332         // FIXME: We might want to cache the hyphen width.</span>
<span class="line-added">333         auto&amp; fontCascade = style.fontCascade();</span>
<span class="line-added">334         auto hyphenWidth = InlineLayoutUnit { fontCascade.width(TextRun { StringView { style.hyphenString() } }) };</span>
<span class="line-added">335         if (!findLastBreakablePosition) {</span>
<span class="line-added">336             auto availableWidthExcludingHyphen = availableWidth - hyphenWidth;</span>
<span class="line-added">337             if (availableWidthExcludingHyphen &lt;= 0 || !enoughWidthForHyphenation(availableWidthExcludingHyphen, fontCascade.pixelSize()))</span>
<span class="line-added">338                 return { };</span>
<span class="line-added">339             leftSideLength = TextUtil::split(inlineTextItem.layoutBox(), inlineTextItem.start(), runLength, overflowRun.logicalWidth, availableWidthExcludingHyphen, { }).length;</span>
<span class="line-added">340         }</span>
<span class="line-added">341         if (leftSideLength &lt; limitBefore)</span>
<span class="line-added">342             return { };</span>
<span class="line-added">343         auto textContent = inlineTextItem.layoutBox().textContext()-&gt;content;</span>
<span class="line-added">344         // Adjust before index to accommodate the limit-after value (it&#39;s the last potential hyphen location in this run).</span>
<span class="line-added">345         auto hyphenBefore = std::min(leftSideLength, runLength - limitAfter) + 1;</span>
<span class="line-added">346         unsigned hyphenLocation = lastHyphenLocation(StringView(textContent).substring(inlineTextItem.start(), inlineTextItem.length()), hyphenBefore, style.locale());</span>
<span class="line-added">347         if (!hyphenLocation || hyphenLocation &lt; limitBefore)</span>
<span class="line-added">348             return { };</span>
<span class="line-added">349         // hyphenLocation is relative to the start of this InlineItemText.</span>
<span class="line-added">350         auto trailingPartialRunWidthWithHyphen = TextUtil::width(inlineTextItem, inlineTextItem.start(), inlineTextItem.start() + hyphenLocation) + hyphenWidth;</span>
<span class="line-added">351         return PartialRun { hyphenLocation, trailingPartialRunWidthWithHyphen, true };</span>
<span class="line-added">352     }</span>
<span class="line-added">353 </span>
<span class="line-added">354     ASSERT(breakRule == WordBreakRule::NoBreak);</span>
<span class="line-added">355     return { };</span>
<span class="line-added">356 }</span>
357 
<a name="10" id="anc10"></a><span class="line-modified">358 ContinuousContent::ContinuousContent(const LineBreaker::RunList&amp; runs, InlineLayoutUnit contentLogicalWidth)</span>
<span class="line-modified">359     : m_runs(runs)</span>
<span class="line-added">360     , m_width(contentLogicalWidth)</span>
<span class="line-added">361 {</span>
<span class="line-added">362     // Figure out the trailing collapsible state.</span>
<span class="line-added">363     for (auto&amp; run : WTF::makeReversedRange(m_runs)) {</span>
<span class="line-added">364         auto&amp; inlineItem = run.inlineItem;</span>
<span class="line-added">365         if (inlineItem.isBox()) {</span>
<span class="line-added">366             // We did reach a non-collapsible content. We have all the trailing whitespace now.</span>
<span class="line-added">367             break;</span>
<span class="line-added">368         }</span>
<span class="line-added">369         if (inlineItem.isText()) {</span>
<span class="line-added">370             auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);</span>
<span class="line-added">371             auto isFullyCollapsible = [&amp;] {</span>
<span class="line-added">372                 return inlineTextItem.isWhitespace() &amp;&amp; !TextUtil::shouldPreserveTrailingWhitespace(inlineTextItem.style());</span>
<span class="line-added">373             };</span>
<span class="line-added">374             if (isFullyCollapsible()) {</span>
<span class="line-added">375                 m_trailingCollapsibleContent.width += run.logicalWidth;</span>
<span class="line-added">376                 m_trailingCollapsibleContent.isFullyCollapsible = true;</span>
<span class="line-added">377                 // Let&#39;s see if we&#39;ve got more trailing whitespace content.</span>
<span class="line-added">378                 continue;</span>
<span class="line-added">379             }</span>
<span class="line-added">380             if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {</span>
<span class="line-added">381                 // A run with trailing letter spacing is partially collapsible.</span>
<span class="line-added">382                 if (auto collapsibleWidth = inlineTextItem.style().letterSpacing()) {</span>
<span class="line-added">383                     m_trailingCollapsibleContent.width += collapsibleWidth;</span>
<span class="line-added">384                     m_trailingCollapsibleContent.isFullyCollapsible = false;</span>
<span class="line-added">385                 }</span>
<span class="line-added">386             }</span>
<span class="line-added">387             // End of whitespace content.</span>
<span class="line-added">388             break;</span>
<span class="line-added">389         }</span>
<span class="line-added">390     }</span>
<span class="line-added">391 }</span>
392 
<a name="11" id="anc11"></a><span class="line-modified">393 bool ContinuousContent::hasTextContentOnly() const</span>
<span class="line-modified">394 {</span>
<span class="line-modified">395     // &lt;span&gt;text&lt;/span&gt; is considered a text run even with the [container start][container end] inline items.</span>
<span class="line-added">396     // Due to commit boundary rules, we just need to check the first non-typeless inline item (can&#39;t have both [img] and [text])</span>
<span class="line-added">397     for (auto&amp; run : m_runs) {</span>
<span class="line-added">398         auto&amp; inlineItem = run.inlineItem;</span>
<span class="line-added">399         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())</span>
<span class="line-added">400             continue;</span>
<span class="line-added">401         return inlineItem.isText();</span>
<span class="line-added">402     }</span>
<span class="line-added">403     return false;</span>
<span class="line-added">404 }</span>
405 
<a name="12" id="anc12"></a><span class="line-modified">406 bool ContinuousContent::isVisuallyEmptyWhitespaceContentOnly() const</span>
<span class="line-modified">407 {</span>
<span class="line-modified">408     // [&lt;span&gt;&lt;/span&gt; ] [&lt;span&gt; &lt;/span&gt;] [ &lt;span style=&quot;padding: 0px;&quot;&gt;&lt;/span&gt;] are all considered visually empty whitespace content.</span>
<span class="line-modified">409     // [&lt;span style=&quot;border: 1px solid red&quot;&gt;&lt;/span&gt; ] while this is whitespace content only, it is not considered visually empty.</span>
<span class="line-added">410     // Due to commit boundary rules, we just need to check the first non-typeless inline item (can&#39;t have both [img] and [text])</span>
<span class="line-added">411     for (auto&amp; run : m_runs) {</span>
<span class="line-added">412         auto&amp; inlineItem = run.inlineItem;</span>
<span class="line-added">413         // FIXME: check for padding border etc.</span>
<span class="line-added">414         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())</span>
<span class="line-added">415             continue;</span>
<span class="line-added">416         return inlineItem.isText() &amp;&amp; downcast&lt;InlineTextItem&gt;(inlineItem).isWhitespace();</span>
<span class="line-added">417     }</span>
<span class="line-added">418     return false;</span>
<span class="line-added">419 }</span>
420 
<a name="13" id="anc13"></a><span class="line-modified">421 Optional&lt;size_t&gt; ContinuousContent::firstTextRunIndex() const</span>
<span class="line-modified">422 {</span>
<span class="line-modified">423     for (size_t index = 0; index &lt; m_runs.size(); ++index) {</span>
<span class="line-added">424         if (m_runs[index].inlineItem.isText())</span>
<span class="line-added">425             return index;</span>
426     }
<a name="14" id="anc14"></a><span class="line-added">427     return { };</span>
<span class="line-added">428 }</span>
429 
<a name="15" id="anc15"></a><span class="line-modified">430 Optional&lt;size_t&gt; ContinuousContent::lastContentRunIndex() const</span>
<span class="line-modified">431 {</span>
<span class="line-added">432     for (size_t index = m_runs.size(); index--;) {</span>
<span class="line-added">433         if (m_runs[index].inlineItem.isText() || m_runs[index].inlineItem.isBox())</span>
<span class="line-added">434             return index;</span>
<span class="line-added">435     }</span>
<span class="line-added">436     return { };</span>
437 }
438 
<a name="16" id="anc16"></a><span class="line-modified">439 bool ContinuousContent::hasNonContentRunsOnly() const</span>
440 {
<a name="17" id="anc17"></a><span class="line-modified">441     // &lt;span&gt;&lt;/span&gt; &lt;- non content runs.</span>
<span class="line-modified">442     for (auto&amp; run : m_runs) {</span>
<span class="line-added">443         auto&amp; inlineItem = run.inlineItem;</span>
<span class="line-added">444         if (inlineItem.isContainerStart() || inlineItem.isContainerEnd())</span>
<span class="line-added">445             continue;</span>
<span class="line-added">446         return false;</span>
<span class="line-added">447     }</span>
<span class="line-added">448     return true;</span>
<span class="line-added">449 }</span>
450 
<a name="18" id="anc18"></a><span class="line-modified">451 void ContinuousContent::TrailingCollapsibleContent::reset()</span>
<span class="line-modified">452 {</span>
<span class="line-modified">453     isFullyCollapsible = false;</span>
<span class="line-added">454     width = 0_lu;</span>
455 }
456 
457 }
458 }
459 #endif
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
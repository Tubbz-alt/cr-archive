<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBackingStore.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Color.h&quot;
 29 #include &quot;IntRect.h&quot;
 30 #include &quot;IntSize.h&quot;
 31 #include &quot;NativeImage.h&quot;
 32 #include &quot;SharedBuffer.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 #if USE(CAIRO)
 37 // Due to the pixman 16.16 floating point representation, cairo is not able to handle
 38 // images whose size is bigger than 32768.
 39 static const int cairoMaxImageSize = 32768;
 40 #endif
 41 
 42 class ImageBackingStore {
 43     WTF_MAKE_FAST_ALLOCATED;
 44 public:
 45     static std::unique_ptr&lt;ImageBackingStore&gt; create(const IntSize&amp; size, bool premultiplyAlpha = true)
 46     {
 47         return std::unique_ptr&lt;ImageBackingStore&gt;(new ImageBackingStore(size, premultiplyAlpha));
 48     }
 49 
 50     static std::unique_ptr&lt;ImageBackingStore&gt; create(const ImageBackingStore&amp; other)
 51     {
 52         return std::unique_ptr&lt;ImageBackingStore&gt;(new ImageBackingStore(other));
 53     }
 54 
 55     NativeImagePtr image() const;
 56 
 57     bool setSize(const IntSize&amp; size)
 58     {
 59         if (size.isEmpty())
 60             return false;
 61 
 62         Vector&lt;char&gt; buffer;
<a name="1" id="anc1"></a><span class="line-modified"> 63         size_t bufferSize = size.area().unsafeGet() * sizeof(uint32_t);</span>
 64 
 65         if (!buffer.tryReserveCapacity(bufferSize))
 66             return false;
 67 
 68         buffer.grow(bufferSize);
 69         m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<a name="2" id="anc2"></a><span class="line-modified"> 70         m_pixelsPtr = reinterpret_cast&lt;uint32_t*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
 71         m_size = size;
 72         m_frameRect = IntRect(IntPoint(), m_size);
 73         clear();
 74         return true;
 75     }
 76 
 77     void setFrameRect(const IntRect&amp; frameRect)
 78     {
 79         ASSERT(!m_size.isEmpty());
 80         ASSERT(inBounds(frameRect));
 81         m_frameRect = frameRect;
 82     }
 83 
 84     const IntSize&amp; size() const { return m_size; }
 85     const IntRect&amp; frameRect() const { return m_frameRect; }
 86 
 87     void clear()
 88     {
<a name="3" id="anc3"></a><span class="line-modified"> 89         memset(m_pixelsPtr, 0, (m_size.area() * sizeof(uint32_t)).unsafeGet());</span>
 90     }
 91 
 92     void clearRect(const IntRect&amp; rect)
 93     {
 94         if (rect.isEmpty() || !inBounds(rect))
 95             return;
 96 
<a name="4" id="anc4"></a><span class="line-modified"> 97         size_t rowBytes = rect.width() * sizeof(uint32_t);</span>
<span class="line-modified"> 98         uint32_t* start = pixelAt(rect.x(), rect.y());</span>
 99         for (int i = 0; i &lt; rect.height(); ++i) {
100             memset(start, 0, rowBytes);
101             start += m_size.width();
102         }
103     }
104 
105     void fillRect(const IntRect &amp;rect, unsigned r, unsigned g, unsigned b, unsigned a)
106     {
107         if (rect.isEmpty() || !inBounds(rect))
108             return;
109 
<a name="5" id="anc5"></a><span class="line-modified">110         uint32_t* start = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">111         uint32_t pixelValue = this-&gt;pixelValue(r, g, b, a);</span>
112         for (int i = 0; i &lt; rect.height(); ++i) {
113             for (int j = 0; j &lt; rect.width(); ++j)
114                 start[j] = pixelValue;
115             start += m_size.width();
116         }
117     }
118 
119     void repeatFirstRow(const IntRect&amp; rect)
120     {
121         if (rect.isEmpty() || !inBounds(rect))
122             return;
123 
<a name="6" id="anc6"></a><span class="line-modified">124         size_t rowBytes = rect.width() * sizeof(uint32_t);</span>
<span class="line-modified">125         uint32_t* src = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">126         uint32_t* dest = src + m_size.width();</span>
127         for (int i = 1; i &lt; rect.height(); ++i) {
128             memcpy(dest, src, rowBytes);
129             dest += m_size.width();
130         }
131     }
132 
<a name="7" id="anc7"></a><span class="line-modified">133     uint32_t* pixelAt(int x, int y) const</span>
134     {
135         ASSERT(inBounds(IntPoint(x, y)));
136         return m_pixelsPtr + y * m_size.width() + x;
137     }
138 
<a name="8" id="anc8"></a><span class="line-modified">139     void setPixel(uint32_t* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
140     {
141         ASSERT(dest);
142         *dest = pixelValue(r, g, b, a);
143     }
144 
145     void setPixel(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
146     {
147         setPixel(pixelAt(x, y), r, g, b, a);
148     }
149 
<a name="9" id="anc9"></a><span class="line-modified">150     void blendPixel(uint32_t* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
151     {
152         if (!a)
153             return;
154 
<a name="10" id="anc10"></a><span class="line-modified">155         SimpleColor pixel { *dest };</span>
<span class="line-added">156 </span>
<span class="line-added">157         if (a &gt;= 255 || !pixel.isVisible()) {</span>
158             setPixel(dest, r, g, b, a);
159             return;
160         }
161 
162         if (!m_premultiplyAlpha)
<a name="11" id="anc11"></a><span class="line-modified">163             pixel = makePremultipliedRGBA(pixel.redComponent(), pixel.greenComponent(), pixel.blueComponent(), pixel.alphaComponent(), false);</span>
164 
165         unsigned d = 255 - a;
166 
<a name="12" id="anc12"></a><span class="line-modified">167         r = fastDivideBy255(r * a + pixel.redComponent() * d);</span>
<span class="line-modified">168         g = fastDivideBy255(g * a + pixel.greenComponent() * d);</span>
<span class="line-modified">169         b = fastDivideBy255(b * a + pixel.blueComponent() * d);</span>
<span class="line-modified">170         a += fastDivideBy255(d * pixel.alphaComponent());</span>
171 
172         if (m_premultiplyAlpha)
<a name="13" id="anc13"></a><span class="line-modified">173             *dest = makeRGBA(r, g, b, a).value();</span>
174         else
<a name="14" id="anc14"></a><span class="line-modified">175             *dest = makeUnPremultipliedRGBA(r, g, b, a).value();</span>
176     }
177 
178     static bool isOverSize(const IntSize&amp; size)
179     {
180 #if USE(CAIRO)
181         // FIXME: this is a workaround to avoid the cairo image size limit, but we should implement support for
182         // bigger images. See https://bugs.webkit.org/show_bug.cgi?id=177227.
183         //
184         // If the image is bigger than the cairo limit it can&#39;t be displayed, so we don&#39;t even try to decode it.
185         if (size.width() &gt; cairoMaxImageSize || size.height() &gt; cairoMaxImageSize)
186             return true;
187 #endif
188         static unsigned long long MaxPixels = ((1 &lt;&lt; 29) - 1);
189         unsigned long long pixels = static_cast&lt;unsigned long long&gt;(size.width()) * static_cast&lt;unsigned long long&gt;(size.height());
190         return pixels &gt; MaxPixels;
191     }
192 
193 private:
194     ImageBackingStore(const IntSize&amp; size, bool premultiplyAlpha = true)
195         : m_premultiplyAlpha(premultiplyAlpha)
196     {
197         ASSERT(!size.isEmpty() &amp;&amp; !isOverSize(size));
198         setSize(size);
199     }
200 
201     ImageBackingStore(const ImageBackingStore&amp; other)
202         : m_size(other.m_size)
203         , m_premultiplyAlpha(other.m_premultiplyAlpha)
204     {
205         ASSERT(!m_size.isEmpty() &amp;&amp; !isOverSize(m_size));
206         Vector&lt;char&gt; buffer;
207         buffer.append(other.m_pixels-&gt;data(), other.m_pixels-&gt;size());
208         m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<a name="15" id="anc15"></a><span class="line-modified">209         m_pixelsPtr = reinterpret_cast&lt;uint32_t*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
210     }
211 
212     bool inBounds(const IntPoint&amp; point) const
213     {
214         return IntRect(IntPoint(), m_size).contains(point);
215     }
216 
217     bool inBounds(const IntRect&amp; rect) const
218     {
219         return IntRect(IntPoint(), m_size).contains(rect);
220     }
221 
<a name="16" id="anc16"></a><span class="line-modified">222     uint32_t pixelValue(unsigned r, unsigned g, unsigned b, unsigned a) const</span>
223     {
224         if (m_premultiplyAlpha &amp;&amp; !a)
225             return 0;
226 
227         if (m_premultiplyAlpha &amp;&amp; a &lt; 255)
<a name="17" id="anc17"></a><span class="line-modified">228             return makePremultipliedRGBA(r, g, b, a, false).value();</span>
229 
<a name="18" id="anc18"></a><span class="line-modified">230         return makeRGBA(r, g, b, a).value();</span>
231     }
232 
233     RefPtr&lt;SharedBuffer::DataSegment&gt; m_pixels;
<a name="19" id="anc19"></a><span class="line-modified">234     uint32_t* m_pixelsPtr { nullptr };</span>
235     IntSize m_size;
236     IntRect m_frameRect; // This will always just be the entire buffer except for GIF and PNG frames
237     bool m_premultiplyAlpha { true };
238 };
239 
240 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
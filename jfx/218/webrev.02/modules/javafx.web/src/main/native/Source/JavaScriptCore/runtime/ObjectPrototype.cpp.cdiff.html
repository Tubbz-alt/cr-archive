<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ObjectPropertyChangeAdaptiveWatchpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPrototype.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,19 ***</span>
  #include &quot;StructureInlines.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncValueOf(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncHasOwnProperty(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncIsPrototypeOf(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineGetter(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineSetter(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupGetter(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupSetter(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncPropertyIsEnumerable(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncToLocaleString(ExecState*);</span>
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(ObjectPrototype);
  
  const ClassInfo ObjectPrototype::s_info = { &quot;Object&quot;, &amp;JSNonFinalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ObjectPrototype) };
  
<span class="line-new-header">--- 31,19 ---</span>
  #include &quot;StructureInlines.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncValueOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncHasOwnProperty(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncIsPrototypeOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineGetter(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineSetter(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupGetter(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupSetter(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncPropertyIsEnumerable(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL objectProtoFuncToLocaleString(JSGlobalObject*, CallFrame*);</span>
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(ObjectPrototype);
  
  const ClassInfo ObjectPrototype::s_info = { &quot;Object&quot;, &amp;JSNonFinalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ObjectPrototype) };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,278 ***</span>
      return prototype;
  }
  
  // ------------------------------ Functions --------------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncValueOf(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
<span class="line-modified">!     JSObject* valueObj = thisValue.toObject(exec);</span>
      if (UNLIKELY(!valueObj))
          return encodedJSValue();
      return JSValue::encode(valueObj);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncHasOwnProperty(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
<span class="line-modified">!     auto propertyName = exec-&gt;argument(0).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return encodedJSValue();
  
      Structure* structure = thisObject-&gt;structure(vm);
      HasOwnPropertyCache* hasOwnPropertyCache = vm.ensureHasOwnPropertyCache();
      if (Optional&lt;bool&gt; result = hasOwnPropertyCache-&gt;get(structure, propertyName)) {
<span class="line-modified">!         ASSERT(*result == thisObject-&gt;hasOwnProperty(exec, propertyName));</span>
          scope.assertNoException();
          return JSValue::encode(jsBoolean(*result));
      }
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool result = thisObject-&gt;hasOwnProperty(exec, propertyName, slot);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName, result);
      return JSValue::encode(jsBoolean(result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncIsPrototypeOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
<span class="line-modified">!     JSObject* thisObj = thisValue.toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
  
<span class="line-modified">!     if (!exec-&gt;argument(0).isObject())</span>
<span class="line-removed">-         return JSValue::encode(jsBoolean(false));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSValue v = asObject(exec-&gt;argument(0))-&gt;getPrototype(vm, exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      while (true) {
          if (!v.isObject())
              return JSValue::encode(jsBoolean(false));
          if (v == thisObj)
              return JSValue::encode(jsBoolean(true));
<span class="line-modified">!         v = asObject(v)-&gt;getPrototype(vm, exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineGetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue get = exec-&gt;argument(1);</span>
      CallData callData;
      if (getCallData(vm, get, callData) == CallType::None)
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;invalid getter usage&quot;_s);</span>
  
<span class="line-modified">!     auto propertyName = exec-&gt;argument(0).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertyDescriptor descriptor;
      descriptor.setGetter(get);
      descriptor.setEnumerable(true);
      descriptor.setConfigurable(true);
  
      bool shouldThrow = true;
      scope.release();
<span class="line-modified">!     thisObject-&gt;methodTable(vm)-&gt;defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineSetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue set = exec-&gt;argument(1);</span>
      CallData callData;
      if (getCallData(vm, set, callData) == CallType::None)
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;invalid setter usage&quot;_s);</span>
  
<span class="line-modified">!     auto propertyName = exec-&gt;argument(0).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertyDescriptor descriptor;
      descriptor.setSetter(set);
      descriptor.setEnumerable(true);
      descriptor.setConfigurable(true);
  
      bool shouldThrow = true;
      scope.release();
<span class="line-modified">!     thisObject-&gt;methodTable(vm)-&gt;defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupGetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     auto propertyName = exec-&gt;argument(0).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool hasProperty = thisObject-&gt;getPropertySlot(exec, propertyName, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
          if (slot.isAccessor()) {
              GetterSetter* getterSetter = slot.getterSetter();
              return getterSetter-&gt;isGetterNull() ? JSValue::encode(jsUndefined()) : JSValue::encode(getterSetter-&gt;getter());
          }
          if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
              PropertyDescriptor descriptor;
              ASSERT(slot.slotBase());
<span class="line-modified">!             if (slot.slotBase()-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor))</span>
                  return descriptor.getterPresent() ? JSValue::encode(descriptor.getter()) : JSValue::encode(jsUndefined());
          }
      }
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupSetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     auto propertyName = exec-&gt;argument(0).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool hasProperty = thisObject-&gt;getPropertySlot(exec, propertyName, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
          if (slot.isAccessor()) {
              GetterSetter* getterSetter = slot.getterSetter();
              return getterSetter-&gt;isSetterNull() ? JSValue::encode(jsUndefined()) : JSValue::encode(getterSetter-&gt;setter());
          }
          if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
              PropertyDescriptor descriptor;
              ASSERT(slot.slotBase());
<span class="line-modified">!             if (slot.slotBase()-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor))</span>
                  return descriptor.setterPresent() ? JSValue::encode(descriptor.setter()) : JSValue::encode(jsUndefined());
          }
      }
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncPropertyIsEnumerable(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto propertyName = exec-&gt;argument(0).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      scope.release();
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool enumerable = thisObject-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor) &amp;&amp; descriptor.enumerable();</span>
      return JSValue::encode(jsBoolean(enumerable));
  }
  
  // 15.2.4.3 Object.prototype.toLocaleString()
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncToLocaleString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Let V be the this value.
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue();</span>
  
      // 2. Invoke(V, &quot;toString&quot;)
  
      // Let O be the result of calling ToObject passing the this value as the argument.
<span class="line-modified">!     JSObject* object = thisValue.toThis(exec, StrictMode).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // Let toString be the O.[[Get]](&quot;toString&quot;, V)
      PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     bool hasProperty = object-&gt;getPropertySlot(exec, vm.propertyNames-&gt;toString, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
<span class="line-modified">!     JSValue toString = hasProperty ? slot.getValue(exec, vm.propertyNames-&gt;toString) : jsUndefined();</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // If IsCallable(toString) is false, throw a TypeError exception.
      CallData callData;
      CallType callType = getCallData(vm, toString, callData);
      if (callType == CallType::None)
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
  
      // Return the result of calling the [[Call]] internal method of toString passing the this value and no arguments.
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, toString, callType, callData, thisValue, *vm.emptyList)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncToString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
          return JSValue::encode(thisValue.isUndefined() ? vm.smallStrings.undefinedObjectString() : vm.smallStrings.nullObjectString());
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (!thisObject)
          return JSValue::encode(jsUndefined());
  
      auto result = thisObject-&gt;structure(vm)-&gt;objectToStringValue();
      if (result)
          return JSValue::encode(result);
  
      PropertyName toStringTagSymbol = vm.propertyNames-&gt;toStringTagSymbol;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPropertySlot(exec, toStringTagSymbol, [&amp;] (bool found, PropertySlot&amp; toStringTagSlot) -&gt; JSValue {</span>
          if (found) {
<span class="line-modified">!             JSValue stringTag = toStringTagSlot.getValue(exec, toStringTagSymbol);</span>
              RETURN_IF_EXCEPTION(scope, { });
              if (stringTag.isString()) {
<span class="line-modified">!                 JSString* result = jsString(exec, vm.smallStrings.objectStringStart(), asString(stringTag), vm.smallStrings.singleCharacterString(&#39;]&#39;));</span>
                  RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!                 thisObject-&gt;structure(vm)-&gt;setObjectToStringValue(exec, vm, result, toStringTagSlot);</span>
                  return result;
              }
          }
  
<span class="line-modified">!         String tag = thisObject-&gt;methodTable(vm)-&gt;toStringName(thisObject, exec);</span>
          RETURN_IF_EXCEPTION(scope, { });
          String newString = tryMakeString(&quot;[object &quot;, WTFMove(tag), &quot;]&quot;);
          if (!newString)
<span class="line-modified">!             return throwOutOfMemoryError(exec, scope);</span>
  
          auto result = jsNontrivialString(vm, newString);
<span class="line-modified">!         thisObject-&gt;structure(vm)-&gt;setObjectToStringValue(exec, vm, result, toStringTagSlot);</span>
          return result;
      })));
  }
  
  } // namespace JSC
<span class="line-new-header">--- 76,278 ---</span>
      return prototype;
  }
  
  // ------------------------------ Functions --------------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncValueOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
<span class="line-modified">!     JSObject* valueObj = thisValue.toObject(globalObject);</span>
      if (UNLIKELY(!valueObj))
          return encodedJSValue();
      return JSValue::encode(valueObj);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncHasOwnProperty(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return encodedJSValue();
  
      Structure* structure = thisObject-&gt;structure(vm);
      HasOwnPropertyCache* hasOwnPropertyCache = vm.ensureHasOwnPropertyCache();
      if (Optional&lt;bool&gt; result = hasOwnPropertyCache-&gt;get(structure, propertyName)) {
<span class="line-modified">!         ASSERT(*result == thisObject-&gt;hasOwnProperty(globalObject, propertyName));</span>
          scope.assertNoException();
          return JSValue::encode(jsBoolean(*result));
      }
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool result = thisObject-&gt;hasOwnProperty(globalObject, propertyName, slot);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      hasOwnPropertyCache-&gt;tryAdd(vm, slot, thisObject, propertyName, result);
      return JSValue::encode(jsBoolean(result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncIsPrototypeOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (!callFrame-&gt;argument(0).isObject())</span>
<span class="line-modified">!         return JSValue::encode(jsBoolean(false));</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
<span class="line-added">+     JSObject* thisObj = thisValue.toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
  
<span class="line-modified">!     JSValue v = asObject(callFrame-&gt;argument(0))-&gt;getPrototype(vm, globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      while (true) {
          if (!v.isObject())
              return JSValue::encode(jsBoolean(false));
          if (v == thisObj)
              return JSValue::encode(jsBoolean(true));
<span class="line-modified">!         v = asObject(v)-&gt;getPrototype(vm, globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineGetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue get = callFrame-&gt;argument(1);</span>
      CallData callData;
      if (getCallData(vm, get, callData) == CallType::None)
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;invalid getter usage&quot;_s);</span>
  
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertyDescriptor descriptor;
      descriptor.setGetter(get);
      descriptor.setEnumerable(true);
      descriptor.setConfigurable(true);
  
      bool shouldThrow = true;
      scope.release();
<span class="line-modified">!     thisObject-&gt;methodTable(vm)-&gt;defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);</span>
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncDefineSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSValue set = callFrame-&gt;argument(1);</span>
      CallData callData;
      if (getCallData(vm, set, callData) == CallType::None)
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;invalid setter usage&quot;_s);</span>
  
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertyDescriptor descriptor;
      descriptor.setSetter(set);
      descriptor.setEnumerable(true);
      descriptor.setConfigurable(true);
  
      bool shouldThrow = true;
      scope.release();
<span class="line-modified">!     thisObject-&gt;methodTable(vm)-&gt;defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow);</span>
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupGetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool hasProperty = thisObject-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
          if (slot.isAccessor()) {
              GetterSetter* getterSetter = slot.getterSetter();
              return getterSetter-&gt;isGetterNull() ? JSValue::encode(jsUndefined()) : JSValue::encode(getterSetter-&gt;getter());
          }
          if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
              PropertyDescriptor descriptor;
              ASSERT(slot.slotBase());
<span class="line-modified">!             if (slot.slotBase()-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor))</span>
                  return descriptor.getterPresent() ? JSValue::encode(descriptor.getter()) : JSValue::encode(jsUndefined());
          }
      }
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncLookupSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertySlot slot(thisObject, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!     bool hasProperty = thisObject-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
          if (slot.isAccessor()) {
              GetterSetter* getterSetter = slot.getterSetter();
              return getterSetter-&gt;isSetterNull() ? JSValue::encode(jsUndefined()) : JSValue::encode(getterSetter-&gt;setter());
          }
          if (slot.attributes() &amp; PropertyAttribute::CustomAccessor) {
              PropertyDescriptor descriptor;
              ASSERT(slot.slotBase());
<span class="line-modified">!             if (slot.slotBase()-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor))</span>
                  return descriptor.setterPresent() ? JSValue::encode(descriptor.setter()) : JSValue::encode(jsUndefined());
          }
      }
  
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncPropertyIsEnumerable(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      scope.release();
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool enumerable = thisObject-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor) &amp;&amp; descriptor.enumerable();</span>
      return JSValue::encode(jsBoolean(enumerable));
  }
  
  // 15.2.4.3 Object.prototype.toLocaleString()
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncToLocaleString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Let V be the this value.
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue();</span>
  
      // 2. Invoke(V, &quot;toString&quot;)
  
      // Let O be the result of calling ToObject passing the this value as the argument.
<span class="line-modified">!     JSObject* object = thisValue.toThis(globalObject, StrictMode).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // Let toString be the O.[[Get]](&quot;toString&quot;, V)
      PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     bool hasProperty = object-&gt;getPropertySlot(globalObject, vm.propertyNames-&gt;toString, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
<span class="line-modified">!     JSValue toString = hasProperty ? slot.getValue(globalObject, vm.propertyNames-&gt;toString) : jsUndefined();</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // If IsCallable(toString) is false, throw a TypeError exception.
      CallData callData;
      CallType callType = getCallData(vm, toString, callData);
      if (callType == CallType::None)
<span class="line-modified">!         return throwVMTypeError(globalObject, scope);</span>
  
      // Return the result of calling the [[Call]] internal method of toString passing the this value and no arguments.
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, toString, callType, callData, thisValue, *vm.emptyList)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
      if (thisValue.isUndefinedOrNull())
          return JSValue::encode(thisValue.isUndefined() ? vm.smallStrings.undefinedObjectString() : vm.smallStrings.nullObjectString());
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (!thisObject)
          return JSValue::encode(jsUndefined());
  
      auto result = thisObject-&gt;structure(vm)-&gt;objectToStringValue();
      if (result)
          return JSValue::encode(result);
  
      PropertyName toStringTagSymbol = vm.propertyNames-&gt;toStringTagSymbol;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(thisObject-&gt;getPropertySlot(globalObject, toStringTagSymbol, [&amp;] (bool found, PropertySlot&amp; toStringTagSlot) -&gt; JSValue {</span>
          if (found) {
<span class="line-modified">!             JSValue stringTag = toStringTagSlot.getValue(globalObject, toStringTagSymbol);</span>
              RETURN_IF_EXCEPTION(scope, { });
              if (stringTag.isString()) {
<span class="line-modified">!                 JSString* result = jsString(globalObject, vm.smallStrings.objectStringStart(), asString(stringTag), vm.smallStrings.singleCharacterString(&#39;]&#39;));</span>
                  RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!                 thisObject-&gt;structure(vm)-&gt;setObjectToStringValue(globalObject, vm, result, toStringTagSlot);</span>
                  return result;
              }
          }
  
<span class="line-modified">!         String tag = thisObject-&gt;methodTable(vm)-&gt;toStringName(thisObject, globalObject);</span>
          RETURN_IF_EXCEPTION(scope, { });
          String newString = tryMakeString(&quot;[object &quot;, WTFMove(tag), &quot;]&quot;);
          if (!newString)
<span class="line-modified">!             return throwOutOfMemoryError(globalObject, scope);</span>
  
          auto result = jsNontrivialString(vm, newString);
<span class="line-modified">!         thisObject-&gt;structure(vm)-&gt;setObjectToStringValue(globalObject, vm, result, toStringTagSlot);</span>
          return result;
      })));
  }
  
  } // namespace JSC
</pre>
<center><a href="ObjectPropertyChangeAdaptiveWatchpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectPrototype.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCast.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSCell.h&quot;
 29 
 30 namespace JSC {
 31 
 32 template&lt;typename To, typename From&gt;
 33 inline To jsCast(From* from)
 34 {
 35     static_assert(std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;To&gt;::type&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
 36     ASSERT_WITH_SECURITY_IMPLICATION(!from || from-&gt;JSCell::inherits(from-&gt;JSCell::vm(), std::remove_pointer&lt;To&gt;::type::info()));
 37     return static_cast&lt;To&gt;(from);
 38 }
 39 
 40 template&lt;typename To&gt;
 41 inline To jsCast(JSValue from)
 42 {
 43     static_assert(std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;To&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to is a subclass of JSCell&quot;);
 44     ASSERT_WITH_SECURITY_IMPLICATION(from.isCell() &amp;&amp; from.asCell()-&gt;JSCell::inherits(from.asCell()-&gt;vm(), std::remove_pointer&lt;To&gt;::type::info()));
 45     return static_cast&lt;To&gt;(from.asCell());
 46 }
 47 
 48 // Specific type overloads.
 49 #define FOR_EACH_JS_DYNAMIC_CAST_JS_TYPE_OVERLOAD(macro) \
 50     macro(JSImmutableButterfly, JSType::JSImmutableButterflyType, JSType::JSImmutableButterflyType) \
 51     macro(JSArrayIterator, JSType::JSArrayIteratorType, JSType::JSArrayIteratorType) \
 52     macro(JSStringIterator, JSType::JSStringIteratorType, JSType::JSStringIteratorType) \
 53     macro(JSObject, FirstObjectType, LastObjectType) \
 54     macro(JSFinalObject, JSType::FinalObjectType, JSType::FinalObjectType) \
 55     macro(JSFunction, JSType::JSFunctionType, JSType::JSFunctionType) \
 56     macro(InternalFunction, JSType::InternalFunctionType, JSType::InternalFunctionType) \
 57     macro(JSArray, JSType::ArrayType, JSType::DerivedArrayType) \
 58     macro(JSArrayBuffer, JSType::ArrayBufferType, JSType::ArrayBufferType) \
 59     macro(JSArrayBufferView, FirstTypedArrayType, LastTypedArrayType) \
 60     macro(JSPromise, JSType::JSPromiseType, JSType::JSPromiseType) \
 61     macro(JSSet, JSType::JSSetType, JSType::JSSetType) \
 62     macro(JSMap, JSType::JSMapType, JSType::JSMapType) \
 63     macro(JSWeakSet, JSType::JSWeakSetType, JSType::JSWeakSetType) \
 64     macro(JSWeakMap, JSType::JSWeakMapType, JSType::JSWeakMapType) \
 65     macro(NumberObject, JSType::NumberObjectType, JSType::NumberObjectType) \
 66     macro(ProxyObject, JSType::ProxyObjectType, JSType::ProxyObjectType) \
 67     macro(RegExpObject, JSType::RegExpObjectType, JSType::RegExpObjectType) \
 68     macro(JSWebAssemblyModule, JSType::WebAssemblyModuleType, JSType::WebAssemblyModuleType) \
 69     macro(DirectArguments, JSType::DirectArgumentsType, JSType::DirectArgumentsType) \
 70     macro(ScopedArguments, JSType::ScopedArgumentsType, JSType::ScopedArgumentsType) \
 71     macro(ClonedArguments, JSType::ClonedArgumentsType, JSType::ClonedArgumentsType) \
 72     macro(JSGlobalObject, JSType::GlobalObjectType, JSType::GlobalObjectType) \
 73     macro(JSGlobalLexicalEnvironment, JSType::GlobalLexicalEnvironmentType, JSType::GlobalLexicalEnvironmentType) \
 74     macro(JSSegmentedVariableObject, JSType::GlobalObjectType, JSType::GlobalLexicalEnvironmentType) \
 75     macro(JSModuleEnvironment, JSType::ModuleEnvironmentType, JSType::ModuleEnvironmentType) \
 76     macro(JSLexicalEnvironment, JSType::LexicalEnvironmentType, JSType::ModuleEnvironmentType) \
 77     macro(JSSymbolTableObject, JSType::GlobalObjectType, JSType::ModuleEnvironmentType) \
 78     macro(JSScope, JSType::GlobalObjectType, JSType::WithScopeType) \
 79     macro(StringObject, JSType::StringObjectType, JSType::DerivedStringObjectType) \
 80 
 81 
 82 // Forward declare the classes because they may not already exist.
 83 #define FORWARD_DECLARE_OVERLOAD_CLASS(className, jsType, op) class className;
 84 FOR_EACH_JS_DYNAMIC_CAST_JS_TYPE_OVERLOAD(FORWARD_DECLARE_OVERLOAD_CLASS)
 85 #undef FORWARD_DECLARE_OVERLOAD_CLASS
 86 
 87 namespace JSCastingHelpers {
 88 
 89 template&lt;bool isFinal&gt;
 90 struct FinalTypeDispatcher {
 91     template&lt;typename Target, typename From&gt;
 92     static inline bool inheritsGeneric(VM&amp; vm, From* from)
 93     {
 94         static_assert(!std::is_same&lt;JSObject*, Target*&gt;::value, &quot;This ensures our overloads work&quot;);
 95         static_assert(std::is_base_of&lt;JSCell, Target&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
 96         // Do not use inherits&lt;Target&gt;(vm) since inherits&lt;T&gt; depends on this function.
 97         return from-&gt;JSCell::inherits(vm, Target::info());
 98     }
 99 };
100 
101 template&lt;&gt;
102 struct FinalTypeDispatcher&lt;/* isFinal */ true&gt; {
103     template&lt;typename Target, typename From&gt;
104     static inline bool inheritsGeneric(VM&amp; vm, From* from)
105     {
106         static_assert(!std::is_same&lt;JSObject*, Target*&gt;::value, &quot;This ensures our overloads work&quot;);
107         static_assert(std::is_base_of&lt;JSCell, Target&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
108         static_assert(std::is_final&lt;Target&gt;::value, &quot;Target is a final type&quot;);
109         bool canCast = from-&gt;JSCell::classInfo(vm) == Target::info();
110         // Do not use inherits&lt;Target&gt;(vm) since inherits&lt;T&gt; depends on this function.
111         ASSERT_UNUSED(vm, canCast == from-&gt;JSCell::inherits(vm, Target::info()));
112         return canCast;
113     }
114 };
115 
116 template&lt;typename Target, typename From&gt;
117 inline bool inheritsJSTypeImpl(VM&amp; vm, From* from, JSType firstType, JSType lastType)
118 {
119     static_assert(std::is_base_of&lt;JSCell, Target&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
120     bool canCast = firstType &lt;= from-&gt;type() &amp;&amp; from-&gt;type() &lt;= lastType;
121     // Do not use inherits&lt;Target&gt;(vm) since inherits&lt;T&gt; depends on this function.
122     ASSERT_UNUSED(vm, canCast == from-&gt;JSCell::inherits(vm, Target::info()));
123     return canCast;
124 }
125 
126 // C++ has bad syntax so we need to use this struct because C++ doesn&#39;t have a
127 // way to say that we are overloading just the first type in a template list...
128 template&lt;typename Target&gt;
129 struct InheritsTraits {
130     template&lt;typename From&gt;
131     static inline bool inherits(VM&amp; vm, From* from) { return FinalTypeDispatcher&lt;std::is_final&lt;Target&gt;::value&gt;::template inheritsGeneric&lt;Target&gt;(vm, from); }
132 };
133 
134 #define DEFINE_TRAITS_FOR_JS_TYPE_OVERLOAD(className, firstJSType, lastJSType) \
135     template&lt;&gt; \
136     struct InheritsTraits&lt;className&gt; { \
137         template&lt;typename From&gt; \
138         static inline bool inherits(VM&amp; vm, From* from) { return inheritsJSTypeImpl&lt;className, From&gt;(vm, from, static_cast&lt;JSType&gt;(firstJSType), static_cast&lt;JSType&gt;(lastJSType)); } \
139     }; \
140 
141 FOR_EACH_JS_DYNAMIC_CAST_JS_TYPE_OVERLOAD(DEFINE_TRAITS_FOR_JS_TYPE_OVERLOAD)
142 
143 #undef DEFINE_TRAITS_FOR_JS_TYPE_OVERLOAD
144 
145 
146 template&lt;typename Target, typename From&gt;
147 bool inherits(VM&amp; vm, From* from)
148 {
149     using Dispatcher = InheritsTraits&lt;Target&gt;;
150     return Dispatcher::template inherits(vm, from);
151 }
152 
153 } // namespace JSCastingHelpers
154 
155 template&lt;typename To, typename From&gt;
156 To jsDynamicCast(VM&amp; vm, From* from)
157 {
158     using Dispatcher = JSCastingHelpers::InheritsTraits&lt;typename std::remove_cv&lt;typename std::remove_pointer&lt;To&gt;::type&gt;::type&gt;;
159     if (LIKELY(Dispatcher::template inherits(vm, from)))
160         return static_cast&lt;To&gt;(from);
161     return nullptr;
162 }
163 
164 template&lt;typename To&gt;
165 To jsDynamicCast(VM&amp; vm, JSValue from)
166 {
167     if (UNLIKELY(!from.isCell()))
168         return nullptr;
169     return jsDynamicCast&lt;To&gt;(vm, from.asCell());
170 }
171 
172 template&lt;typename To, typename From&gt;
173 To jsSecureCast(VM&amp; vm, From from)
174 {
175     auto* result = jsDynamicCast&lt;To&gt;(vm, from);
176     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(result);
177     return result;
178 }
179 
180 }
    </pre>
  </body>
</html>
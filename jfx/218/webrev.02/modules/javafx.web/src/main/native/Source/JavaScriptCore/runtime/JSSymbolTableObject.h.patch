diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSymbolTableObject.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSymbolTableObject.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSymbolTableObject.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSSymbolTableObject.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2012, 2014-2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -36,17 +36,17 @@
 
 namespace JSC {
 
 class JSSymbolTableObject : public JSScope {
 public:
-    typedef JSScope Base;
-    static const unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames;
+    using Base = JSScope;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames;
 
     SymbolTable* symbolTable() const { return m_symbolTable.get(); }
 
-    JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, ExecState*, PropertyName);
-    JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&, EnumerationMode);
+    JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);
+    JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&, EnumerationMode);
 
     static ptrdiff_t offsetOfSymbolTable() { return OBJECT_OFFSETOF(JSSymbolTableObject, m_symbolTable); }
 
     DECLARE_EXPORT_INFO;
 
@@ -161,13 +161,13 @@
     Touch,
     Invalidate
 };
 
 template<SymbolTablePutMode symbolTablePutMode, typename SymbolTableObjectType>
-inline bool symbolTablePut(SymbolTableObjectType* object, ExecState* exec, PropertyName propertyName, JSValue value, bool shouldThrowReadOnlyError, bool ignoreReadOnlyErrors, bool& putResult)
+inline bool symbolTablePut(SymbolTableObjectType* object, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, bool shouldThrowReadOnlyError, bool ignoreReadOnlyErrors, bool& putResult)
 {
-    VM& vm = exec->vm();
+    VM& vm = getVM(globalObject);
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     WatchpointSet* set = nullptr;
     WriteBarrierBase<Unknown>* reg;
     {
@@ -181,11 +181,11 @@
         bool wasFat;
         SymbolTableEntry::Fast fastEntry = iter->value.getFast(wasFat);
         ASSERT(!fastEntry.isNull());
         if (fastEntry.isReadOnly() && !ignoreReadOnlyErrors) {
             if (shouldThrowReadOnlyError)
-                throwTypeError(exec, scope, ReadonlyPropertyWriteError);
+                throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);
             putResult = false;
             return true;
         }
 
         ScopeOffset offset = fastEntry.scopeOffset();
@@ -208,22 +208,22 @@
     return true;
 }
 
 template<typename SymbolTableObjectType>
 inline bool symbolTablePutTouchWatchpointSet(
-    SymbolTableObjectType* object, ExecState* exec, PropertyName propertyName, JSValue value,
+    SymbolTableObjectType* object, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,
     bool shouldThrowReadOnlyError, bool ignoreReadOnlyErrors, bool& putResult)
 {
     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(object));
-    return symbolTablePut<SymbolTablePutMode::Touch>(object, exec, propertyName, value, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);
+    return symbolTablePut<SymbolTablePutMode::Touch>(object, globalObject, propertyName, value, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);
 }
 
 template<typename SymbolTableObjectType>
 inline bool symbolTablePutInvalidateWatchpointSet(
-    SymbolTableObjectType* object, ExecState* exec, PropertyName propertyName, JSValue value,
+    SymbolTableObjectType* object, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,
     bool shouldThrowReadOnlyError, bool ignoreReadOnlyErrors, bool& putResult)
 {
     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(object));
-    return symbolTablePut<SymbolTablePutMode::Invalidate>(object, exec, propertyName, value, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);
+    return symbolTablePut<SymbolTablePutMode::Invalidate>(object, globalObject, propertyName, value, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);
 }
 
 } // namespace JSC

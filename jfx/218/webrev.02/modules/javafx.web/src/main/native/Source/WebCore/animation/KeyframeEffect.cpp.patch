diff a/modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp b/modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.cpp
@@ -37,24 +37,31 @@
 #include "CSSTransition.h"
 #include "Element.h"
 #include "FontCascade.h"
 #include "FrameView.h"
 #include "GeometryUtilities.h"
+#include "InspectorInstrumentation.h"
 #include "JSCompositeOperation.h"
 #include "JSCompositeOperationOrAuto.h"
+#include "JSDOMConvert.h"
 #include "JSKeyframeEffect.h"
+#include "KeyframeEffectStack.h"
+#include "Logging.h"
 #include "RenderBox.h"
 #include "RenderBoxModelObject.h"
 #include "RenderElement.h"
 #include "RenderStyle.h"
+#include "RuntimeEnabledFeatures.h"
+#include "StyleAdjuster.h"
 #include "StylePendingResources.h"
 #include "StyleResolver.h"
 #include "TimingFunction.h"
 #include "TranslateTransformOperation.h"
 #include "WillChangeData.h"
 #include <JavaScriptCore/Exception.h>
 #include <wtf/UUID.h>
+#include <wtf/text/TextStream.h>
 
 namespace WebCore {
 using namespace JSC;
 
 static inline void invalidateElement(Element* element)
@@ -155,15 +162,15 @@
         }
         indexOfLastKeyframeWithNonNullOffset = i;
     }
 }
 
-static inline ExceptionOr<KeyframeEffect::KeyframeLikeObject> processKeyframeLikeObject(ExecState& state, Strong<JSObject>&& keyframesInput, bool allowLists)
+static inline ExceptionOr<KeyframeEffect::KeyframeLikeObject> processKeyframeLikeObject(JSGlobalObject& lexicalGlobalObject, Strong<JSObject>&& keyframesInput, bool allowLists)
 {
     // https://drafts.csswg.org/web-animations-1/#process-a-keyframe-like-object
 
-    VM& vm = state.vm();
+    VM& vm = lexicalGlobalObject.vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 1. Run the procedure to convert an ECMAScript value to a dictionary type [WEBIDL] with keyframe input as the ECMAScript value as follows:
     //
     //    If allow lists is true, use the following dictionary type:
@@ -183,19 +190,20 @@
     //    };
     //
     //    Store the result of this procedure as keyframe output.
     KeyframeEffect::BasePropertyIndexedKeyframe baseProperties;
     if (allowLists)
-        baseProperties = convert<IDLDictionary<KeyframeEffect::BasePropertyIndexedKeyframe>>(state, keyframesInput.get());
+        baseProperties = convert<IDLDictionary<KeyframeEffect::BasePropertyIndexedKeyframe>>(lexicalGlobalObject, keyframesInput.get());
     else {
-        auto baseKeyframe = convert<IDLDictionary<KeyframeEffect::BaseKeyframe>>(state, keyframesInput.get());
+        auto baseKeyframe = convert<IDLDictionary<KeyframeEffect::BaseKeyframe>>(lexicalGlobalObject, keyframesInput.get());
         if (baseKeyframe.offset)
             baseProperties.offset = baseKeyframe.offset.value();
         else
             baseProperties.offset = nullptr;
         baseProperties.easing = baseKeyframe.easing;
-        baseProperties.composite = baseKeyframe.composite;
+        if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())
+            baseProperties.composite = baseKeyframe.composite;
     }
     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 
     KeyframeEffect::KeyframeLikeObject keyframeOuput;
     keyframeOuput.baseProperties = baseProperties;
@@ -207,11 +215,11 @@
     //    2. Convert each property name in animatable properties to the equivalent IDL attribute by applying the animation property
     //       name to IDL attribute name algorithm.
 
     // 3. Let input properties be the result of calling the EnumerableOwnNames operation with keyframe input as the object.
     PropertyNameArray inputProperties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
-    JSObject::getOwnPropertyNames(keyframesInput.get(), &state, inputProperties, EnumerationMode());
+    JSObject::getOwnPropertyNames(keyframesInput.get(), &lexicalGlobalObject, inputProperties, EnumerationMode());
 
     // 4. Make up a new list animation properties that consists of all of the properties that are in both input properties and animatable
     //    properties, or which are in input properties and conform to the <custom-property-name> production.
     Vector<JSC::Identifier> animationProperties;
     size_t numberOfProperties = inputProperties.size();
@@ -228,11 +236,11 @@
     // 6. For each property name in animation properties,
     size_t numberOfAnimationProperties = animationProperties.size();
     for (size_t i = 0; i < numberOfAnimationProperties; ++i) {
         // 1. Let raw value be the result of calling the [[Get]] internal method on keyframe input, with property name as the property
         //    key and keyframe input as the receiver.
-        auto rawValue = keyframesInput->get(&state, animationProperties[i]);
+        auto rawValue = keyframesInput->get(&lexicalGlobalObject, animationProperties[i]);
 
         // 2. Check the completion record of raw value.
         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 
         // 3. Convert raw value to a DOMString or sequence of DOMStrings property values as follows:
@@ -241,18 +249,18 @@
             // If allow lists is true,
             // Let property values be the result of converting raw value to IDL type (DOMString or sequence<DOMString>)
             // using the procedures defined for converting an ECMAScript value to an IDL value [WEBIDL].
             // If property values is a single DOMString, replace property values with a sequence of DOMStrings with the original value of property
             // Values as the only element.
-            if (rawValue.isString())
-                propertyValues = { rawValue.toWTFString(&state) };
-            else if (rawValue.isObject())
-                propertyValues = convert<IDLSequence<IDLDOMString>>(state, rawValue);
+            if (rawValue.isObject())
+                propertyValues = convert<IDLSequence<IDLDOMString>>(lexicalGlobalObject, rawValue);
+            else
+                propertyValues = { rawValue.toWTFString(&lexicalGlobalObject) };
         } else {
             // Otherwise,
             // Let property values be the result of converting raw value to a DOMString using the procedure for converting an ECMAScript value to a DOMString.
-            propertyValues = { convert<IDLDOMString>(state, rawValue) };
+            propertyValues = { convert<IDLDOMString>(lexicalGlobalObject, rawValue) };
         }
         RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 
         // 4. Calculate the normalized property name as the result of applying the IDL attribute name to animation property name algorithm to property name.
         auto cssPropertyID = IDLAttributeNameToAnimationPropertyName(animationProperties[i].string());
@@ -263,24 +271,24 @@
 
     // 7. Return keyframe output.
     return { WTFMove(keyframeOuput) };
 }
 
-static inline ExceptionOr<void> processIterableKeyframes(ExecState& state, Strong<JSObject>&& keyframesInput, JSValue method, Vector<KeyframeEffect::ParsedKeyframe>& parsedKeyframes)
+static inline ExceptionOr<void> processIterableKeyframes(JSGlobalObject& lexicalGlobalObject, Strong<JSObject>&& keyframesInput, JSValue method, Vector<KeyframeEffect::ParsedKeyframe>& parsedKeyframes)
 {
     // 1. Let iter be GetIterator(object, method).
-    forEachInIterable(state, keyframesInput.get(), method, [&parsedKeyframes](VM& vm, ExecState& state, JSValue nextValue) -> ExceptionOr<void> {
+    forEachInIterable(lexicalGlobalObject, keyframesInput.get(), method, [&parsedKeyframes](VM& vm, JSGlobalObject& lexicalGlobalObject, JSValue nextValue) -> ExceptionOr<void> {
         // Steps 2 through 6 are already implemented by forEachInIterable().
         auto scope = DECLARE_THROW_SCOPE(vm);
         if (!nextValue || !nextValue.isObject()) {
-            throwException(&state, scope, JSC::Exception::create(vm, createTypeError(&state)));
+            throwException(&lexicalGlobalObject, scope, JSC::Exception::create(vm, createTypeError(&lexicalGlobalObject)));
             return { };
         }
 
         // 7. Append to processed keyframes the result of running the procedure to process a keyframe-like object passing nextItem
         // as the keyframe input and with the allow lists flag set to false.
-        auto processKeyframeLikeObjectResult = processKeyframeLikeObject(state, Strong<JSObject>(vm, nextValue.toObject(&state)), false);
+        auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, Strong<JSObject>(vm, nextValue.toObject(&lexicalGlobalObject)), false);
         if (processKeyframeLikeObjectResult.hasException())
             return processKeyframeLikeObjectResult.releaseException();
         auto keyframeLikeObject = processKeyframeLikeObjectResult.returnValue();
 
         KeyframeEffect::ParsedKeyframe keyframeOutput;
@@ -297,12 +305,14 @@
         ASSERT(WTF::holds_alternative<String>(keyframeLikeObject.baseProperties.easing));
         keyframeOutput.easing = WTF::get<String>(keyframeLikeObject.baseProperties.easing);
 
         // When calling processKeyframeLikeObject() with the "allow lists" flag set to false, the only composite
         // alternatives we should expect is CompositeOperationAuto.
-        ASSERT(WTF::holds_alternative<CompositeOperationOrAuto>(keyframeLikeObject.baseProperties.composite));
-        keyframeOutput.composite = WTF::get<CompositeOperationOrAuto>(keyframeLikeObject.baseProperties.composite);
+        if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {
+            ASSERT(WTF::holds_alternative<CompositeOperationOrAuto>(keyframeLikeObject.baseProperties.composite));
+            keyframeOutput.composite = WTF::get<CompositeOperationOrAuto>(keyframeLikeObject.baseProperties.composite);
+        }
 
         for (auto& propertyAndValue : keyframeLikeObject.propertiesAndValues) {
             auto cssPropertyId = propertyAndValue.property;
             // When calling processKeyframeLikeObject() with the "allow lists" flag set to false,
             // there should only ever be a single value for a given property.
@@ -318,14 +328,14 @@
     });
 
     return { };
 }
 
-static inline ExceptionOr<void> processPropertyIndexedKeyframes(ExecState& state, Strong<JSObject>&& keyframesInput, Vector<KeyframeEffect::ParsedKeyframe>& parsedKeyframes, Vector<String>& unusedEasings)
+static inline ExceptionOr<void> processPropertyIndexedKeyframes(JSGlobalObject& lexicalGlobalObject, Strong<JSObject>&& keyframesInput, Vector<KeyframeEffect::ParsedKeyframe>& parsedKeyframes, Vector<String>& unusedEasings)
 {
     // 1. Let property-indexed keyframe be the result of running the procedure to process a keyframe-like object passing object as the keyframe input.
-    auto processKeyframeLikeObjectResult = processKeyframeLikeObject(state, WTFMove(keyframesInput), true);
+    auto processKeyframeLikeObjectResult = processKeyframeLikeObject(lexicalGlobalObject, WTFMove(keyframesInput), true);
     if (processKeyframeLikeObjectResult.hasException())
         return processKeyframeLikeObjectResult.releaseException();
     auto propertyIndexedKeyframe = processKeyframeLikeObjectResult.returnValue();
 
     // 2. For each member, m, in property-indexed keyframe, perform the following steps:
@@ -433,37 +443,39 @@
     //     is reached.
     for (size_t i = 0; i < parsedKeyframes.size(); ++i)
         parsedKeyframes[i].easing = easings[i];
 
     // 12. If the “composite” member of the property-indexed keyframe is not an empty sequence:
-    Vector<CompositeOperationOrAuto> compositeModes;
-    if (WTF::holds_alternative<Vector<CompositeOperationOrAuto>>(propertyIndexedKeyframe.baseProperties.composite))
-        compositeModes = WTF::get<Vector<CompositeOperationOrAuto>>(propertyIndexedKeyframe.baseProperties.composite);
-    else if (WTF::holds_alternative<CompositeOperationOrAuto>(propertyIndexedKeyframe.baseProperties.composite))
-        compositeModes.append(WTF::get<CompositeOperationOrAuto>(propertyIndexedKeyframe.baseProperties.composite));
-    if (!compositeModes.isEmpty()) {
-        // 1. Let composite modes be a sequence of CompositeOperationOrAuto values assigned from the “composite” member of property-indexed keyframe. If that member is a single
-        //    CompositeOperationOrAuto value operation, let composite modes be a sequence of length one, with the value of the “composite” as its single item.
-        // 2. As with easings, if composite modes has fewer items than processed keyframes, repeat the elements in composite modes successively starting from the beginning of
-        //    the list until composite modes has as many items as processed keyframes.
-        if (compositeModes.size() < parsedKeyframes.size()) {
-            size_t initialNumberOfCompositeModes = compositeModes.size();
-            for (i = initialNumberOfCompositeModes; i < parsedKeyframes.size(); ++i)
-                compositeModes.append(compositeModes[i % initialNumberOfCompositeModes]);
-        }
-        // 3. Assign each value in composite modes that is not auto to the keyframe-specific composite operation on the keyframe with the corresponding position in processed
-        //    keyframes until the end of processed keyframes is reached.
-        for (size_t i = 0; i < compositeModes.size() && i < parsedKeyframes.size(); ++i) {
-            if (compositeModes[i] != CompositeOperationOrAuto::Auto)
-                parsedKeyframes[i].composite = compositeModes[i];
+    if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled()) {
+        Vector<CompositeOperationOrAuto> compositeModes;
+        if (WTF::holds_alternative<Vector<CompositeOperationOrAuto>>(propertyIndexedKeyframe.baseProperties.composite))
+            compositeModes = WTF::get<Vector<CompositeOperationOrAuto>>(propertyIndexedKeyframe.baseProperties.composite);
+        else if (WTF::holds_alternative<CompositeOperationOrAuto>(propertyIndexedKeyframe.baseProperties.composite))
+            compositeModes.append(WTF::get<CompositeOperationOrAuto>(propertyIndexedKeyframe.baseProperties.composite));
+        if (!compositeModes.isEmpty()) {
+            // 1. Let composite modes be a sequence of CompositeOperationOrAuto values assigned from the “composite” member of property-indexed keyframe. If that member is a single
+            //    CompositeOperationOrAuto value operation, let composite modes be a sequence of length one, with the value of the “composite” as its single item.
+            // 2. As with easings, if composite modes has fewer items than processed keyframes, repeat the elements in composite modes successively starting from the beginning of
+            //    the list until composite modes has as many items as processed keyframes.
+            if (compositeModes.size() < parsedKeyframes.size()) {
+                size_t initialNumberOfCompositeModes = compositeModes.size();
+                for (i = initialNumberOfCompositeModes; i < parsedKeyframes.size(); ++i)
+                    compositeModes.append(compositeModes[i % initialNumberOfCompositeModes]);
+            }
+            // 3. Assign each value in composite modes that is not auto to the keyframe-specific composite operation on the keyframe with the corresponding position in processed
+            //    keyframes until the end of processed keyframes is reached.
+            for (size_t i = 0; i < compositeModes.size() && i < parsedKeyframes.size(); ++i) {
+                if (compositeModes[i] != CompositeOperationOrAuto::Auto)
+                    parsedKeyframes[i].composite = compositeModes[i];
+            }
         }
     }
 
     return { };
 }
 
-ExceptionOr<Ref<KeyframeEffect>> KeyframeEffect::create(ExecState& state, Element* target, Strong<JSObject>&& keyframes, Optional<Variant<double, KeyframeEffectOptions>>&& options)
+ExceptionOr<Ref<KeyframeEffect>> KeyframeEffect::create(JSGlobalObject& lexicalGlobalObject, Element* target, Strong<JSObject>&& keyframes, Optional<Variant<double, KeyframeEffectOptions>>&& options)
 {
     auto keyframeEffect = adoptRef(*new KeyframeEffect(target));
 
     if (options) {
         OptionalEffectTiming timing;
@@ -487,18 +499,18 @@
         auto updateTimingResult = keyframeEffect->updateTiming(timing);
         if (updateTimingResult.hasException())
             return updateTimingResult.releaseException();
     }
 
-    auto processKeyframesResult = keyframeEffect->processKeyframes(state, WTFMove(keyframes));
+    auto processKeyframesResult = keyframeEffect->processKeyframes(lexicalGlobalObject, WTFMove(keyframes));
     if (processKeyframesResult.hasException())
         return processKeyframesResult.releaseException();
 
     return keyframeEffect;
 }
 
-ExceptionOr<Ref<KeyframeEffect>> KeyframeEffect::create(JSC::ExecState&, Ref<KeyframeEffect>&& source)
+ExceptionOr<Ref<KeyframeEffect>> KeyframeEffect::create(JSC::JSGlobalObject&, Ref<KeyframeEffect>&& source)
 {
     auto keyframeEffect = adoptRef(*new KeyframeEffect(nullptr));
     keyframeEffect->copyPropertiesFromSource(WTFMove(source));
     return keyframeEffect;
 }
@@ -507,11 +519,11 @@
 {
     return adoptRef(*new KeyframeEffect(const_cast<Element*>(&target)));
 }
 
 KeyframeEffect::KeyframeEffect(Element* target)
-    : m_target(target)
+    : m_target(makeWeakPtr(target))
 {
 }
 
 void KeyframeEffect::copyPropertiesFromSource(Ref<KeyframeEffect>&& source)
 {
@@ -539,10 +551,11 @@
     setDirection(source->direction());
     setIterations(source->iterations());
     setTimingFunction(source->timingFunction());
     setIterationStart(source->iterationStart());
     setIterationDuration(source->iterationDuration());
+    updateStaticTimingProperties();
 
     KeyframeList keyframeList("keyframe-effect-" + createCanonicalUUIDString());
     for (auto& keyframe : source->m_blendingKeyframes.keyframes()) {
         KeyframeValue keyframeValue(keyframe.key(), RenderStyle::clonePtr(*keyframe.style()));
         for (auto propertyId : keyframe.properties())
@@ -550,15 +563,15 @@
         keyframeList.insert(WTFMove(keyframeValue));
     }
     setBlendingKeyframes(keyframeList);
 }
 
-Vector<Strong<JSObject>> KeyframeEffect::getKeyframes(ExecState& state)
+Vector<Strong<JSObject>> KeyframeEffect::getKeyframes(JSGlobalObject& lexicalGlobalObject)
 {
     // https://drafts.csswg.org/web-animations-1/#dom-keyframeeffectreadonly-getkeyframes
 
-    auto lock = JSLockHolder { &state };
+    auto lock = JSLockHolder { &lexicalGlobalObject };
 
     // Since keyframes are represented by a partially open-ended dictionary type that is not currently able to be expressed with WebIDL,
     // the procedure used to prepare the result of this method is defined in prose below:
     //
     // 1. Let result be an empty sequence of objects.
@@ -566,10 +579,11 @@
 
     // 2. Let keyframes be the result of applying the procedure to compute missing keyframe offsets to the keyframes for this keyframe effect.
 
     // 3. For each keyframe in keyframes perform the following steps:
     if (is<DeclarativeAnimation>(animation())) {
+        auto* renderer = m_target->renderer();
         auto computedStyleExtractor = ComputedStyleExtractor(m_target.get());
         for (size_t i = 0; i < m_blendingKeyframes.size(); ++i) {
             // 1. Initialize a dictionary object, output keyframe, using the following definition:
             //
             // dictionary BaseComputedKeyframe {
@@ -584,36 +598,35 @@
             // 2. Set offset, computedOffset, easing members of output keyframe to the respective values keyframe offset, computed keyframe offset,
             // and keyframe-specific timing function of keyframe.
             BaseComputedKeyframe computedKeyframe;
             computedKeyframe.offset = keyframe.key();
             computedKeyframe.computedOffset = keyframe.key();
-            // For CSS transitions, there are only two keyframes and the second keyframe should always report "linear". In practice, this value
-            // has no bearing since, as the last keyframe, its value will never be used.
-            computedKeyframe.easing = is<CSSTransition>(animation()) && i == 1 ? "linear" : timingFunctionForKeyframeAtIndex(0)->cssText();
+            // For CSS transitions, all keyframes should return "linear" since the effect's global timing function applies.
+            computedKeyframe.easing = is<CSSTransition>(animation()) ? "linear" : timingFunctionForKeyframeAtIndex(i)->cssText();
 
-            auto outputKeyframe = convertDictionaryToJS(state, *jsCast<JSDOMGlobalObject*>(state.lexicalGlobalObject()), computedKeyframe);
+            auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast<JSDOMGlobalObject*>(&lexicalGlobalObject), computedKeyframe);
 
             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
             auto& style = *keyframe.style();
             for (auto cssPropertyId : keyframe.properties()) {
                 if (cssPropertyId == CSSPropertyCustom)
                     continue;
                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
                 auto propertyName = CSSPropertyIDToIDLAttributeName(cssPropertyId);
                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
                 String idlValue = "";
-                if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId))
+                if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId, renderer))
                     idlValue = cssValue->cssText();
                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
-                auto value = toJS<IDLDOMString>(state, idlValue);
+                auto value = toJS<IDLDOMString>(lexicalGlobalObject, idlValue);
                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
-                JSObject::defineOwnProperty(outputKeyframe, &state, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);
+                JSObject::defineOwnProperty(outputKeyframe, &lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);
             }
 
             // 5. Append output keyframe to result.
-            result.append(JSC::Strong<JSC::JSObject> { state.vm(), outputKeyframe });
+            result.append(JSC::Strong<JSC::JSObject> { lexicalGlobalObject.vm(), outputKeyframe });
         }
     } else {
         for (size_t i = 0; i < m_parsedKeyframes.size(); ++i) {
             // 1. Initialize a dictionary object, output keyframe, using the following definition:
             //
@@ -630,64 +643,68 @@
             // offset, keyframe-specific timing function and keyframe-specific composite operation of keyframe.
             BaseComputedKeyframe computedKeyframe;
             computedKeyframe.offset = parsedKeyframe.offset;
             computedKeyframe.computedOffset = parsedKeyframe.computedOffset;
             computedKeyframe.easing = timingFunctionForKeyframeAtIndex(i)->cssText();
-            computedKeyframe.composite = parsedKeyframe.composite;
+            if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCompositeOperationsEnabled())
+                computedKeyframe.composite = parsedKeyframe.composite;
 
-            auto outputKeyframe = convertDictionaryToJS(state, *jsCast<JSDOMGlobalObject*>(state.lexicalGlobalObject()), computedKeyframe);
+            auto outputKeyframe = convertDictionaryToJS(lexicalGlobalObject, *jsCast<JSDOMGlobalObject*>(&lexicalGlobalObject), computedKeyframe);
 
             // 3. For each animation property-value pair specified on keyframe, declaration, perform the following steps:
             for (auto it = parsedKeyframe.unparsedStyle.begin(), end = parsedKeyframe.unparsedStyle.end(); it != end; ++it) {
                 // 1. Let property name be the result of applying the animation property name to IDL attribute name algorithm to the property name of declaration.
                 auto propertyName = CSSPropertyIDToIDLAttributeName(it->key);
                 // 2. Let IDL value be the result of serializing the property value of declaration by passing declaration to the algorithm to serialize a CSS value.
                 // 3. Let value be the result of converting IDL value to an ECMAScript String value.
-                auto value = toJS<IDLDOMString>(state, it->value);
+                auto value = toJS<IDLDOMString>(lexicalGlobalObject, it->value);
                 // 4. Call the [[DefineOwnProperty]] internal method on output keyframe with property name property name,
                 //    Property Descriptor { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true, [[Value]]: value } and Boolean flag false.
-                JSObject::defineOwnProperty(outputKeyframe, &state, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);
+                JSObject::defineOwnProperty(outputKeyframe, &lexicalGlobalObject, AtomString(propertyName).impl(), PropertyDescriptor(value, 0), false);
             }
 
             // 4. Append output keyframe to result.
-            result.append(JSC::Strong<JSC::JSObject> { state.vm(), outputKeyframe });
+            result.append(JSC::Strong<JSC::JSObject> { lexicalGlobalObject.vm(), outputKeyframe });
         }
     }
 
     // 4. Return result.
     return result;
 }
 
-ExceptionOr<void> KeyframeEffect::setKeyframes(ExecState& state, Strong<JSObject>&& keyframesInput)
+ExceptionOr<void> KeyframeEffect::setKeyframes(JSGlobalObject& lexicalGlobalObject, Strong<JSObject>&& keyframesInput)
 {
-    return processKeyframes(state, WTFMove(keyframesInput));
+    auto processKeyframesResult = processKeyframes(lexicalGlobalObject, WTFMove(keyframesInput));
+    if (!processKeyframesResult.hasException() && animation())
+        animation()->effectTimingDidChange();
+    return processKeyframesResult;
 }
 
-ExceptionOr<void> KeyframeEffect::processKeyframes(ExecState& state, Strong<JSObject>&& keyframesInput)
+ExceptionOr<void> KeyframeEffect::processKeyframes(JSGlobalObject& lexicalGlobalObject, Strong<JSObject>&& keyframesInput)
 {
     // 1. If object is null, return an empty sequence of keyframes.
     if (!keyframesInput.get())
         return { };
 
-    VM& vm = state.vm();
+    VM& vm = lexicalGlobalObject.vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 2. Let processed keyframes be an empty sequence of keyframes.
     Vector<ParsedKeyframe> parsedKeyframes;
 
     // 3. Let method be the result of GetMethod(object, @@iterator).
-    auto method = keyframesInput.get()->get(&state, vm.propertyNames->iteratorSymbol);
+    auto method = keyframesInput.get()->get(&lexicalGlobalObject, vm.propertyNames->iteratorSymbol);
 
     // 4. Check the completion record of method.
     RETURN_IF_EXCEPTION(scope, Exception { TypeError });
 
     // 5. Perform the steps corresponding to the first matching condition from below,
     Vector<String> unusedEasings;
     if (!method.isUndefined())
-        processIterableKeyframes(state, WTFMove(keyframesInput), WTFMove(method), parsedKeyframes);
+        processIterableKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), WTFMove(method), parsedKeyframes);
     else
-        processPropertyIndexedKeyframes(state, WTFMove(keyframesInput), parsedKeyframes, unusedEasings);
+        processPropertyIndexedKeyframes(lexicalGlobalObject, WTFMove(keyframesInput), parsedKeyframes, unusedEasings);
 
     // 6. If processed keyframes is not loosely sorted by offset, throw a TypeError and abort these steps.
     // 7. If there exist any keyframe in processed keyframes whose keyframe offset is non-null and less than
     //    zero or greater than one, throw a TypeError and abort these steps.
     double lastNonNullOffset = -1;
@@ -724,39 +741,52 @@
             return timingFunctionResult.releaseException();
     }
 
     m_parsedKeyframes = WTFMove(parsedKeyframes);
 
-    m_blendingKeyframes.clear();
+    clearBlendingKeyframes();
 
     return { };
 }
 
 void KeyframeEffect::updateBlendingKeyframes(RenderStyle& elementStyle)
 {
     if (!m_blendingKeyframes.isEmpty() || !m_target)
         return;
 
     KeyframeList keyframeList("keyframe-effect-" + createCanonicalUUIDString());
-    StyleResolver& styleResolver = m_target->styleResolver();
+    auto& styleResolver = m_target->styleResolver();
 
     for (auto& keyframe : m_parsedKeyframes) {
-        styleResolver.setNewStateWithElement(*m_target);
         KeyframeValue keyframeValue(keyframe.computedOffset, nullptr);
 
         auto styleProperties = keyframe.style->immutableCopyIfNeeded();
         for (unsigned i = 0; i < styleProperties->propertyCount(); ++i)
             keyframeList.addProperty(styleProperties->propertyAt(i).id());
 
         auto keyframeRule = StyleRuleKeyframe::create(WTFMove(styleProperties));
-        keyframeValue.setStyle(styleResolver.styleForKeyframe(&elementStyle, keyframeRule.ptr(), keyframeValue));
+        keyframeValue.setStyle(styleResolver.styleForKeyframe(*m_target, &elementStyle, keyframeRule.ptr(), keyframeValue));
         keyframeList.insert(WTFMove(keyframeValue));
     }
 
     setBlendingKeyframes(keyframeList);
 }
 
+bool KeyframeEffect::animatesProperty(CSSPropertyID property) const
+{
+    if (!m_blendingKeyframes.isEmpty())
+        return m_blendingKeyframes.properties().contains(property);
+
+    for (auto& keyframe : m_parsedKeyframes) {
+        for (auto keyframeProperty : keyframe.unparsedStyle.keys()) {
+            if (keyframeProperty == property)
+                return true;
+        }
+    }
+    return false;
+}
+
 bool KeyframeEffect::forceLayoutIfNeeded()
 {
     if (!m_needsForcedLayout || !m_target)
         return false;
 
@@ -770,17 +800,25 @@
 
     frameView->forceLayout();
     return true;
 }
 
+
+void KeyframeEffect::clearBlendingKeyframes()
+{
+    m_blendingKeyframesSource = BlendingKeyframesSource::WebAnimation;
+    m_unanimatedStyle = nullptr;
+    m_blendingKeyframes.clear();
+}
+
 void KeyframeEffect::setBlendingKeyframes(KeyframeList& blendingKeyframes)
 {
     m_blendingKeyframes = WTFMove(blendingKeyframes);
 
     computedNeedsForcedLayout();
     computeStackingContextImpact();
-    computeShouldRunAccelerated();
+    computeAcceleratedPropertiesState();
 
     checkForMatchingTransformFunctionLists();
     checkForMatchingFilterFunctionLists();
 #if ENABLE(FILTERS_LEVEL_2)
     checkForMatchingBackdropFilterFunctionLists();
@@ -885,32 +923,33 @@
 
 void KeyframeEffect::computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle& newStyle)
 {
     ASSERT(is<DeclarativeAnimation>(animation()));
     if (is<CSSAnimation>(animation()))
-        computeCSSAnimationBlendingKeyframes();
+        computeCSSAnimationBlendingKeyframes(newStyle);
     else if (is<CSSTransition>(animation()))
         computeCSSTransitionBlendingKeyframes(oldStyle, newStyle);
 }
 
-void KeyframeEffect::computeCSSAnimationBlendingKeyframes()
+void KeyframeEffect::computeCSSAnimationBlendingKeyframes(const RenderStyle& unanimatedStyle)
 {
     ASSERT(is<CSSAnimation>(animation()));
 
     auto cssAnimation = downcast<CSSAnimation>(animation());
     auto& backingAnimation = cssAnimation->backingAnimation();
 
     KeyframeList keyframeList(backingAnimation.name());
     if (auto* styleScope = Style::Scope::forOrdinal(*m_target, backingAnimation.nameStyleScopeOrdinal()))
-        styleScope->resolver().keyframeStylesForAnimation(*m_target, &cssAnimation->unanimatedStyle(), keyframeList);
+        styleScope->resolver().keyframeStylesForAnimation(*m_target, &unanimatedStyle, keyframeList);
 
     // Ensure resource loads for all the frames.
     for (auto& keyframe : keyframeList.keyframes()) {
         if (auto* style = const_cast<RenderStyle*>(keyframe.style()))
             Style::loadPendingResources(*style, m_target->document(), m_target.get());
     }
 
+    m_blendingKeyframesSource = BlendingKeyframesSource::CSSAnimation;
     setBlendingKeyframes(keyframeList);
 }
 
 void KeyframeEffect::computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle& newStyle)
 {
@@ -934,10 +973,11 @@
 
     KeyframeValue toKeyframeValue(1, WTFMove(toStyle));
     toKeyframeValue.addProperty(property);
     keyframeList.insert(WTFMove(toKeyframeValue));
 
+    m_blendingKeyframesSource = BlendingKeyframesSource::CSSTransition;
     setBlendingKeyframes(keyframeList);
 }
 
 void KeyframeEffect::computedNeedsForcedLayout()
 {
@@ -976,75 +1016,155 @@
             break;
         }
     }
 }
 
+void KeyframeEffect::animationTimelineDidChange(AnimationTimeline* timeline)
+{
+    if (!m_target)
+        return;
+
+    if (timeline)
+        m_inTargetEffectStack = m_target->ensureKeyframeEffectStack().addEffect(*this);
+    else {
+        m_target->ensureKeyframeEffectStack().removeEffect(*this);
+        m_inTargetEffectStack = false;
+    }
+}
+
+void KeyframeEffect::animationTimingDidChange()
+{
+    updateEffectStackMembership();
+}
+
+void KeyframeEffect::updateEffectStackMembership()
+{
+    if (!m_target)
+        return;
+
+    bool isRelevant = animation() && animation()->isRelevant();
+    if (isRelevant && !m_inTargetEffectStack)
+        m_inTargetEffectStack = m_target->ensureKeyframeEffectStack().addEffect(*this);
+    else if (!isRelevant && m_inTargetEffectStack) {
+        m_target->ensureKeyframeEffectStack().removeEffect(*this);
+        m_inTargetEffectStack = false;
+    }
+}
+
+void KeyframeEffect::setAnimation(WebAnimation* animation)
+{
+    bool animationChanged = animation != this->animation();
+    AnimationEffect::setAnimation(animation);
+
+    if (!animationChanged)
+        return;
+
+    if (animation)
+        animation->updateRelevance();
+    updateEffectStackMembership();
+}
+
 void KeyframeEffect::setTarget(RefPtr<Element>&& newTarget)
 {
-    if (m_target == newTarget)
+    if (m_target.get() == newTarget.get())
         return;
 
-    auto previousTarget = std::exchange(m_target, WTFMove(newTarget));
+    auto previousTarget = std::exchange(m_target, makeWeakPtr(newTarget.get()));
 
     if (auto* effectAnimation = animation())
         effectAnimation->effectTargetDidChange(previousTarget.get(), m_target.get());
 
-    m_blendingKeyframes.clear();
+    clearBlendingKeyframes();
 
     // We need to invalidate the effect now that the target has changed
     // to ensure the effect's styles are applied to the new target right away.
     invalidate();
 
     // Likewise, we need to invalidate styles on the previous target so that
     // any animated styles are removed immediately.
     invalidateElement(previousTarget.get());
+
+    if (previousTarget) {
+        previousTarget->ensureKeyframeEffectStack().removeEffect(*this);
+        m_inTargetEffectStack = false;
+    }
+    if (m_target)
+        m_inTargetEffectStack = m_target->ensureKeyframeEffectStack().addEffect(*this);
 }
 
 void KeyframeEffect::apply(RenderStyle& targetStyle)
 {
     if (!m_target)
         return;
 
     updateBlendingKeyframes(targetStyle);
 
-    updateAcceleratedAnimationState();
+    auto computedTiming = getComputedTiming();
+    m_phaseAtLastApplication = computedTiming.phase;
 
-    auto progress = getComputedTiming().progress;
-    if (!progress)
+    InspectorInstrumentation::willApplyKeyframeEffect(*m_target, *this, computedTiming);
+
+    if (!computedTiming.progress)
         return;
 
-    setAnimatedPropertiesInStyle(targetStyle, progress.value());
+    if (!m_unanimatedStyle)
+        m_unanimatedStyle = RenderStyle::clonePtr(targetStyle);
+
+    setAnimatedPropertiesInStyle(targetStyle, computedTiming.progress.value());
+}
+
+bool KeyframeEffect::isCurrentlyAffectingProperty(CSSPropertyID property, Accelerated accelerated) const
+{
+    if (accelerated == Accelerated::Yes && !isRunningAccelerated() && !isAboutToRunAccelerated())
+        return false;
 
-    // https://w3c.github.io/web-animations/#side-effects-section
-    // For every property targeted by at least one animation effect that is current or in effect, the user agent
-    // must act as if the will-change property ([css-will-change-1]) on the target element includes the property.
-    if (m_triggersStackingContext && targetStyle.hasAutoZIndex())
-        targetStyle.setZIndex(0);
+    if (!m_blendingKeyframes.properties().contains(property))
+        return false;
+
+    return m_phaseAtLastApplication == AnimationEffectPhase::Active;
+}
+
+bool KeyframeEffect::isRunningAcceleratedAnimationForProperty(CSSPropertyID property) const
+{
+    return m_isRunningAccelerated && CSSPropertyAnimation::animationOfPropertyIsAccelerated(property) && m_blendingKeyframes.properties().contains(property);
 }
 
 void KeyframeEffect::invalidate()
 {
     invalidateElement(m_target.get());
 }
 
-void KeyframeEffect::computeShouldRunAccelerated()
+void KeyframeEffect::computeAcceleratedPropertiesState()
 {
-    m_shouldRunAccelerated = hasBlendingKeyframes();
+    bool hasSomeAcceleratedProperties = false;
+    bool hasSomeUnacceleratedProperties = false;
+
     for (auto cssPropertyId : m_blendingKeyframes.properties()) {
-        if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId)) {
-            m_shouldRunAccelerated = false;
-            return;
-        }
+        // If any animated property can be accelerated, then the animation should run accelerated.
+        if (CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId))
+            hasSomeAcceleratedProperties = true;
+        else
+            hasSomeUnacceleratedProperties = true;
+        if (hasSomeAcceleratedProperties && hasSomeUnacceleratedProperties)
+            break;
     }
+
+    if (!hasSomeAcceleratedProperties)
+        m_acceleratedPropertiesState = AcceleratedProperties::None;
+    else if (hasSomeUnacceleratedProperties)
+        m_acceleratedPropertiesState = AcceleratedProperties::Some;
+    else
+        m_acceleratedPropertiesState = AcceleratedProperties::All;
 }
 
 void KeyframeEffect::getAnimatedStyle(std::unique_ptr<RenderStyle>& animatedStyle)
 {
     if (!m_target || !animation())
         return;
 
     auto progress = getComputedTiming().progress;
+    LOG_WITH_STREAM(Animations, stream << "KeyframeEffect " << this << " getAnimatedStyle - progress " << progress);
     if (!progress)
         return;
 
     if (!animatedStyle)
         animatedStyle = RenderStyle::clonePtr(renderer()->style());
@@ -1052,23 +1172,32 @@
     setAnimatedPropertiesInStyle(*animatedStyle.get(), progress.value());
 }
 
 void KeyframeEffect::setAnimatedPropertiesInStyle(RenderStyle& targetStyle, double iterationProgress)
 {
+    auto& properties = m_blendingKeyframes.properties();
+
+    // In the case of CSS Transitions we already know that there are only two keyframes, one where offset=0 and one where offset=1,
+    // and only a single CSS property so we can simply blend based on the style available on those keyframes with the provided iteration
+    // progress which already accounts for the transition's timing function.
+    if (m_blendingKeyframesSource == BlendingKeyframesSource::CSSTransition) {
+        ASSERT(properties.size() == 1);
+        CSSPropertyAnimation::blendProperties(this, *properties.begin(), &targetStyle, m_blendingKeyframes[0].style(), m_blendingKeyframes[1].style(), iterationProgress);
+        return;
+    }
+
     // 4.4.3. The effect value of a keyframe effect
     // https://drafts.csswg.org/web-animations-1/#the-effect-value-of-a-keyframe-animation-effect
     //
     // The effect value of a single property referenced by a keyframe effect as one of its target properties,
     // for a given iteration progress, current iteration and underlying value is calculated as follows.
 
     updateBlendingKeyframes(targetStyle);
     if (m_blendingKeyframes.isEmpty())
         return;
 
-    bool isCSSAnimation = is<CSSAnimation>(animation());
-
-    for (auto cssPropertyId : m_blendingKeyframes.properties()) {
+    for (auto cssPropertyId : properties) {
         // 1. If iteration progress is unresolved abort this procedure.
         // 2. Let target property be the longhand property for which the effect value is to be calculated.
         // 3. If animation type of the target property is not animatable abort this procedure since the effect cannot be applied.
         // 4. Define the neutral value for composition as a value which, when combined with an underlying value using the add composite operation,
         //    produces the underlying value.
@@ -1082,11 +1211,11 @@
             auto& keyframe = m_blendingKeyframes[i];
             auto offset = keyframe.key();
             if (!keyframe.containsProperty(cssPropertyId)) {
                 // If we're dealing with a CSS animation, we consider the first and last keyframes to always have the property listed
                 // since the underlying style was provided and should be captured.
-                if (!isCSSAnimation || (offset && offset < 1))
+                if (m_blendingKeyframesSource == BlendingKeyframesSource::WebAnimation || (offset && offset < 1))
                     continue;
             }
             if (!offset)
                 numberOfKeyframesWithZeroOffset++;
             if (offset == 1)
@@ -1219,80 +1348,94 @@
     }
 
     return nullptr;
 }
 
-void KeyframeEffect::updateAcceleratedAnimationState()
+void KeyframeEffect::updateAcceleratedActions()
 {
-    if (!m_shouldRunAccelerated)
+    if (m_acceleratedPropertiesState == AcceleratedProperties::None)
         return;
 
-    if (!renderer()) {
-        if (isRunningAccelerated())
-            addPendingAcceleratedAction(AcceleratedAction::Stop);
+    auto computedTiming = getComputedTiming();
+
+    // If we're not already running accelerated, the only thing we're interested in is whether we need to start the animation
+    // which we need to do once we're in the active phase. Otherwise, there's no change in accelerated state to consider.
+    bool isActive = computedTiming.phase == AnimationEffectPhase::Active;
+    if (!m_isRunningAccelerated) {
+        if (isActive && animation()->playState() == WebAnimation::PlayState::Running)
+            addPendingAcceleratedAction(AcceleratedAction::Play);
         return;
     }
 
-    auto localTime = animation()->currentTime();
-
-    // If we don't have a localTime or localTime < 0, we either don't have a start time or we're before the startTime
-    // so we shouldn't be running.
-    if (!localTime || localTime.value() < 0_s) {
-        if (isRunningAccelerated())
-            addPendingAcceleratedAction(AcceleratedAction::Stop);
+    // If we're no longer active, we need to remove the accelerated animation.
+    if (!isActive) {
+        addPendingAcceleratedAction(AcceleratedAction::Stop);
         return;
     }
 
     auto playState = animation()->playState();
+    // The only thing left to consider is whether we need to pause or resume the animation following a change of play-state.
     if (playState == WebAnimation::PlayState::Paused) {
         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Pause) {
             if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop)
                 addPendingAcceleratedAction(AcceleratedAction::Play);
             addPendingAcceleratedAction(AcceleratedAction::Pause);
         }
-        return;
-    }
-
-    if (playState == WebAnimation::PlayState::Finished) {
-        if (isRunningAccelerated())
-            addPendingAcceleratedAction(AcceleratedAction::Stop);
-        else {
-            m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;
-            m_pendingAcceleratedActions.clear();
-            animation()->acceleratedStateDidChange();
-        }
-        return;
-    }
-
-    if (playState == WebAnimation::PlayState::Running && localTime >= 0_s) {
+    } else if (playState == WebAnimation::PlayState::Running && isActive) {
         if (m_lastRecordedAcceleratedAction != AcceleratedAction::Play)
             addPendingAcceleratedAction(AcceleratedAction::Play);
-        return;
     }
 }
 
 void KeyframeEffect::addPendingAcceleratedAction(AcceleratedAction action)
 {
+    if (action == m_lastRecordedAcceleratedAction)
+        return;
+
     if (action == AcceleratedAction::Stop)
         m_pendingAcceleratedActions.clear();
     m_pendingAcceleratedActions.append(action);
     if (action != AcceleratedAction::Seek)
         m_lastRecordedAcceleratedAction = action;
     animation()->acceleratedStateDidChange();
 }
 
+void KeyframeEffect::animationDidTick()
+{
+    invalidate();
+    updateAcceleratedActions();
+}
+
+void KeyframeEffect::animationDidPlay()
+{
+    if (m_acceleratedPropertiesState != AcceleratedProperties::None)
+        addPendingAcceleratedAction(AcceleratedAction::Play);
+}
+
 void KeyframeEffect::animationDidSeek()
 {
     // There is no need to seek if we're not playing an animation already. If seeking
-    // means we're moving into an active state, we'll pick this up in apply().
-    if (m_shouldRunAccelerated && isRunningAccelerated())
+    // means we're moving into an active lexicalGlobalObject, we'll pick this up in apply().
+    if (m_isRunningAccelerated || isAboutToRunAccelerated())
         addPendingAcceleratedAction(AcceleratedAction::Seek);
 }
 
+void KeyframeEffect::animationWasCanceled()
+{
+    if (m_isRunningAccelerated || isAboutToRunAccelerated())
+        addPendingAcceleratedAction(AcceleratedAction::Stop);
+}
+
+void KeyframeEffect::willChangeRenderer()
+{
+    if (m_isRunningAccelerated || isAboutToRunAccelerated())
+        addPendingAcceleratedAction(AcceleratedAction::Stop);
+}
+
 void KeyframeEffect::animationSuspensionStateDidChange(bool animationIsSuspended)
 {
-    if (m_shouldRunAccelerated)
+    if (m_isRunningAccelerated || isAboutToRunAccelerated())
         addPendingAcceleratedAction(animationIsSuspended ? AcceleratedAction::Pause : AcceleratedAction::Play);
 }
 
 void KeyframeEffect::applyPendingAcceleratedActions()
 {
@@ -1303,41 +1446,46 @@
 
     if (m_pendingAcceleratedActions.isEmpty())
         return;
 
     auto* renderer = this->renderer();
-    if (!renderer || !renderer->isComposited())
+    if (!renderer || !renderer->isComposited()) {
+        // The renderer may no longer be composited because the accelerated animation ended before we had a chance to update it,
+        // in which case if we asked for the animation to stop, we can discard the current set of accelerated actions.
+        if (m_lastRecordedAcceleratedAction == AcceleratedAction::Stop) {
+            m_pendingAcceleratedActions.clear();
+            m_isRunningAccelerated = false;
+        }
         return;
+    }
 
     auto pendingAcceleratedActions = m_pendingAcceleratedActions;
     m_pendingAcceleratedActions.clear();
 
-    auto* compositedRenderer = downcast<RenderBoxModelObject>(renderer);
-
     // To simplify the code we use a default of 0s for an unresolved current time since for a Stop action that is acceptable.
     auto timeOffset = animation()->currentTime().valueOr(0_s).seconds() - delay().seconds();
 
     for (const auto& action : pendingAcceleratedActions) {
         switch (action) {
         case AcceleratedAction::Play:
-            if (!compositedRenderer->startAnimation(timeOffset, backingAnimationForCompositedRenderer(), m_blendingKeyframes)) {
-                m_shouldRunAccelerated = false;
+            m_isRunningAccelerated = renderer->startAnimation(timeOffset, backingAnimationForCompositedRenderer(), m_blendingKeyframes);
+            if (!m_isRunningAccelerated) {
                 m_lastRecordedAcceleratedAction = AcceleratedAction::Stop;
-                animation()->acceleratedStateDidChange();
                 return;
             }
             break;
         case AcceleratedAction::Pause:
-            compositedRenderer->animationPaused(timeOffset, m_blendingKeyframes.animationName());
+            renderer->animationPaused(timeOffset, m_blendingKeyframes.animationName());
             break;
         case AcceleratedAction::Seek:
-            compositedRenderer->animationSeeked(timeOffset, m_blendingKeyframes.animationName());
+            renderer->animationSeeked(timeOffset, m_blendingKeyframes.animationName());
             break;
         case AcceleratedAction::Stop:
-            compositedRenderer->animationFinished(m_blendingKeyframes.animationName());
+            renderer->animationFinished(m_blendingKeyframes.animationName());
             if (!m_target->document().renderTreeBeingDestroyed())
                 m_target->invalidateStyleAndLayerComposition();
+            m_isRunningAccelerated = false;
             break;
         }
     }
 }
 
@@ -1409,11 +1557,11 @@
         return true; // Non-boxes don't get transformed;
 
     auto& box = downcast<RenderBox>(*renderer());
     auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
 
-    auto cumulativeBounds = bounds;
+    LayoutRect cumulativeBounds;
 
     for (const auto& keyframe : m_blendingKeyframes.keyframes()) {
         const auto* keyframeStyle = keyframe.style();
 
         // FIXME: maybe for declarative animations we always say it's true for the first and last keyframe.

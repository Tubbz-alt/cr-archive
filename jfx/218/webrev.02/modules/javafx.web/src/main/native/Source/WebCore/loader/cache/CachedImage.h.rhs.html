<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller &lt;mueller@kde.org&gt;
  4     Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  5     Copyright (C) 2004, 2005, 2006, 2007 Apple Inc. All rights reserved.
  6 
  7     This library is free software; you can redistribute it and/or
  8     modify it under the terms of the GNU Library General Public
  9     License as published by the Free Software Foundation; either
 10     version 2 of the License, or (at your option) any later version.
 11 
 12     This library is distributed in the hope that it will be useful,
 13     but WITHOUT ANY WARRANTY; without even the implied warranty of
 14     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15     Library General Public License for more details.
 16 
 17     You should have received a copy of the GNU Library General Public License
 18     along with this library; see the file COPYING.LIB.  If not, write to
 19     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20     Boston, MA 02110-1301, USA.
 21 */
 22 
 23 #pragma once
 24 
 25 #include &quot;CachedResource.h&quot;
 26 #include &quot;Image.h&quot;
 27 #include &quot;ImageObserver.h&quot;
 28 #include &quot;IntRect.h&quot;
 29 #include &quot;IntSizeHash.h&quot;
 30 #include &quot;LayoutSize.h&quot;
 31 #include &quot;SVGImageCache.h&quot;
 32 #include &lt;wtf/HashMap.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 class CachedImageClient;
 37 class CachedResourceLoader;
 38 class FloatSize;
 39 class MemoryCache;
 40 class RenderElement;
 41 class RenderObject;
 42 class SecurityOrigin;
 43 
 44 struct Length;
 45 
 46 class CachedImage final : public CachedResource {
 47     friend class MemoryCache;
 48 
 49 public:
 50     CachedImage(CachedResourceRequest&amp;&amp;, const PAL::SessionID&amp;, const CookieJar*);
 51     CachedImage(Image*, const PAL::SessionID&amp;, const CookieJar*);
 52     // Constructor to use for manually cached images.
 53     CachedImage(const URL&amp;, Image*, const PAL::SessionID&amp;, const CookieJar*, const String&amp; domainForCachePartition);
 54     virtual ~CachedImage();
 55 
 56     WEBCORE_EXPORT Image* image(); // Returns the nullImage() if the image is not available yet.
 57     WEBCORE_EXPORT Image* imageForRenderer(const RenderObject*); // Returns the nullImage() if the image is not available yet.
 58     bool hasImage() const { return m_image.get(); }
 59     bool currentFrameKnownToBeOpaque(const RenderElement*);
 60 
 61     std::pair&lt;Image*, float&gt; brokenImage(float deviceScaleFactor) const; // Returns an image and the image&#39;s resolution scale factor.
 62     bool willPaintBrokenImage() const;
 63 
 64     bool canRender(const RenderElement* renderer, float multiplier) { return !errorOccurred() &amp;&amp; !imageSizeForRenderer(renderer, multiplier).isEmpty(); }
 65 
 66     void setContainerContextForClient(const CachedImageClient&amp;, const LayoutSize&amp;, float, const URL&amp;);
 67     bool usesImageContainerSize() const { return m_image &amp;&amp; m_image-&gt;usesContainerSize(); }
 68     bool imageHasRelativeWidth() const { return m_image &amp;&amp; m_image-&gt;hasRelativeWidth(); }
 69     bool imageHasRelativeHeight() const { return m_image &amp;&amp; m_image-&gt;hasRelativeHeight(); }
 70 
 71     void updateBuffer(SharedBuffer&amp;) override;
 72     void finishLoading(SharedBuffer*) override;
 73 
 74     enum SizeType {
 75         UsedSize,
 76         IntrinsicSize
 77     };
 78     WEBCORE_EXPORT FloatSize imageSizeForRenderer(const RenderElement* renderer, SizeType = UsedSize) const;
 79     // This method takes a zoom multiplier that can be used to increase the natural size of the image by the zoom.
 80     LayoutSize imageSizeForRenderer(const RenderElement*, float multiplier, SizeType = UsedSize) const; // returns the size of the complete image.
<a name="1" id="anc1"></a><span class="line-added"> 81     LayoutSize unclampedImageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType = UsedSize) const;</span>
 82     void computeIntrinsicDimensions(Length&amp; intrinsicWidth, Length&amp; intrinsicHeight, FloatSize&amp; intrinsicRatio);
 83 
 84     bool isManuallyCached() const { return m_isManuallyCached; }
 85     RevalidationDecision makeRevalidationDecision(CachePolicy) const override;
 86     void load(CachedResourceLoader&amp;) override;
 87 
 88     bool isOriginClean(SecurityOrigin*);
 89 
 90     bool isClientWaitingForAsyncDecoding(CachedImageClient&amp;) const;
 91     void addClientWaitingForAsyncDecoding(CachedImageClient&amp;);
 92     void removeAllClientsWaitingForAsyncDecoding();
 93 
 94     void setForceUpdateImageDataEnabledForTesting(bool enabled) { m_forceUpdateImageDataEnabledForTesting =  enabled; }
 95 
 96 private:
 97     void clear();
 98 
 99     CachedImage(CachedImage&amp;, const ResourceRequest&amp;, PAL::SessionID);
100 
101     void setBodyDataFrom(const CachedResource&amp;) final;
102 
103     bool isPDFResource() const;
104     bool isPostScriptResource() const;
105 
106     void createImage();
107     void clearImage();
108     // If not null, changeRect is the changed part of the image.
109     void notifyObservers(const IntRect* changeRect = nullptr);
110     void checkShouldPaintBrokenImage();
111 
112     void switchClientsToRevalidatedResource() final;
113     bool mayTryReplaceEncodedData() const final { return true; }
114 
115     void didAddClient(CachedResourceClient&amp;) final;
116     void didRemoveClient(CachedResourceClient&amp;) final;
117 
118     void allClientsRemoved() override;
119     void destroyDecodedData() override;
120 
121     bool shouldDeferUpdateImageData() const;
122     RefPtr&lt;SharedBuffer&gt; convertedDataIfNeeded(SharedBuffer* data) const;
123     void didUpdateImageData();
124     EncodedDataStatus updateImageData(bool allDataReceived);
125     void updateData(const char* data, unsigned length) override;
126     void error(CachedResource::Status) override;
127     void responseReceived(const ResourceResponse&amp;) override;
128 
129     // For compatibility, images keep loading even if there are HTTP errors.
130     bool shouldIgnoreHTTPStatusCodeErrors() const override { return true; }
131 
132     bool stillNeedsLoad() const override { return !errorOccurred() &amp;&amp; status() == Unknown &amp;&amp; !isLoading(); }
133 
134     class CachedImageObserver final : public RefCounted&lt;CachedImageObserver&gt;, public ImageObserver {
135     public:
136         static Ref&lt;CachedImageObserver&gt; create(CachedImage&amp; image) { return adoptRef(*new CachedImageObserver(image)); }
137         HashSet&lt;CachedImage*&gt;&amp; cachedImages() { return m_cachedImages; }
138         const HashSet&lt;CachedImage*&gt;&amp; cachedImages() const { return m_cachedImages; }
139 
140     private:
141         explicit CachedImageObserver(CachedImage&amp;);
142 
143         // ImageObserver API
144         URL sourceUrl() const override { return !m_cachedImages.isEmpty() ? (*m_cachedImages.begin())-&gt;url() : URL(); }
145         String mimeType() const override { return !m_cachedImages.isEmpty() ? (*m_cachedImages.begin())-&gt;mimeType() : emptyString(); }
146         long long expectedContentLength() const override { return !m_cachedImages.isEmpty() ? (*m_cachedImages.begin())-&gt;expectedContentLength() : 0; }
147 
148         void encodedDataStatusChanged(const Image&amp;, EncodedDataStatus) final;
149         void decodedSizeChanged(const Image&amp;, long long delta) final;
150         void didDraw(const Image&amp;) final;
151 
152         bool canDestroyDecodedData(const Image&amp;) final;
153         void imageFrameAvailable(const Image&amp;, ImageAnimatingState, const IntRect* changeRect = nullptr, DecodingStatus = DecodingStatus::Invalid) final;
154         void changedInRect(const Image&amp;, const IntRect*) final;
155 
156         HashSet&lt;CachedImage*&gt; m_cachedImages;
157     };
158 
159     void encodedDataStatusChanged(const Image&amp;, EncodedDataStatus);
160     void decodedSizeChanged(const Image&amp;, long long delta);
161     void didDraw(const Image&amp;);
162     bool canDestroyDecodedData(const Image&amp;);
163     void imageFrameAvailable(const Image&amp;, ImageAnimatingState, const IntRect* changeRect = nullptr, DecodingStatus = DecodingStatus::Invalid);
164     void changedInRect(const Image&amp;, const IntRect*);
165 
166     void updateBufferInternal(SharedBuffer&amp;);
167 
168     void didReplaceSharedBufferContents() override;
169 
170     struct ContainerContext {
171         LayoutSize containerSize;
172         float containerZoom;
173         URL imageURL;
174     };
175 
176     using ContainerContextRequests = HashMap&lt;const CachedImageClient*, ContainerContext&gt;;
177     ContainerContextRequests m_pendingContainerContextRequests;
178 
179     HashSet&lt;CachedImageClient*&gt; m_clientsWaitingForAsyncDecoding;
180 
181     RefPtr&lt;CachedImageObserver&gt; m_imageObserver;
182     RefPtr&lt;Image&gt; m_image;
183     std::unique_ptr&lt;SVGImageCache&gt; m_svgImageCache;
184 
185     MonotonicTime m_lastUpdateImageDataTime;
186 
<a name="2" id="anc2"></a><span class="line-modified">187     static constexpr unsigned maxUpdateImageDataCount = 4;</span>
<span class="line-modified">188     unsigned m_updateImageDataCount : 3;</span>
<span class="line-modified">189     bool m_isManuallyCached : 1;</span>
<span class="line-modified">190     bool m_shouldPaintBrokenImage : 1;</span>
<span class="line-added">191     bool m_forceUpdateImageDataEnabledForTesting : 1;</span>
192 };
193 
194 } // namespace WebCore
195 
196 SPECIALIZE_TYPE_TRAITS_CACHED_RESOURCE(CachedImage, CachedResource::Type::ImageResource)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
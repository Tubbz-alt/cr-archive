<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ExecutableAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallFrameShuffler64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExecutableAllocator.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ExecutableAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -90,59 +90,59 @@</span>
  namespace JSC {
  
  using namespace WTF;
  
  #if defined(FIXED_EXECUTABLE_MEMORY_POOL_SIZE_IN_MB) &amp;&amp; FIXED_EXECUTABLE_MEMORY_POOL_SIZE_IN_MB &gt; 0
<span class="udiff-line-modified-removed">- static const size_t fixedExecutableMemoryPoolSize = FIXED_EXECUTABLE_MEMORY_POOL_SIZE_IN_MB * 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t fixedExecutableMemoryPoolSize = FIXED_EXECUTABLE_MEMORY_POOL_SIZE_IN_MB * 1024 * 1024;</span>
  #elif CPU(ARM)
<span class="udiff-line-modified-removed">- static const size_t fixedExecutableMemoryPoolSize = 16 * 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t fixedExecutableMemoryPoolSize = 16 * 1024 * 1024;</span>
  #elif CPU(ARM64)
<span class="udiff-line-modified-removed">- static const size_t fixedExecutableMemoryPoolSize = 128 * 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t fixedExecutableMemoryPoolSize = 128 * 1024 * 1024;</span>
  #elif CPU(X86_64)
<span class="udiff-line-modified-removed">- static const size_t fixedExecutableMemoryPoolSize = 1024 * 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t fixedExecutableMemoryPoolSize = 1024 * 1024 * 1024;</span>
  #else
<span class="udiff-line-modified-removed">- static const size_t fixedExecutableMemoryPoolSize = 32 * 1024 * 1024;</span>
<span class="udiff-line-modified-added">+ static constexpr size_t fixedExecutableMemoryPoolSize = 32 * 1024 * 1024;</span>
  #endif
  
  #if CPU(ARM)
<span class="udiff-line-modified-removed">- static const double executablePoolReservationFraction = 0.15;</span>
<span class="udiff-line-modified-added">+ static constexpr double executablePoolReservationFraction = 0.15;</span>
  #else
<span class="udiff-line-modified-removed">- static const double executablePoolReservationFraction = 0.25;</span>
<span class="udiff-line-modified-added">+ static constexpr double executablePoolReservationFraction = 0.25;</span>
  #endif
  
<span class="udiff-line-removed">- #if ENABLE(SEPARATED_WX_HEAP)</span>
<span class="udiff-line-removed">- JS_EXPORT_PRIVATE bool useFastPermisionsJITCopy { false };</span>
<span class="udiff-line-removed">- JS_EXPORT_PRIVATE JITWriteSeparateHeapsFunction jitWriteSeparateHeapsFunction;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if !USE(EXECUTE_ONLY_JIT_WRITE_FUNCTION) &amp;&amp; HAVE(REMAP_JIT)</span>
<span class="udiff-line-removed">- static uintptr_t startOfFixedWritableMemoryPool;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- class FixedVMPoolExecutableAllocator;</span>
<span class="udiff-line-removed">- static FixedVMPoolExecutableAllocator* allocator = nullptr;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static bool s_isJITEnabled = true;</span>
  static bool isJITEnabled()
  {
<span class="udiff-line-added">+     bool jitEnabled = !g_jscConfig.jitDisabled;</span>
  #if PLATFORM(IOS_FAMILY) &amp;&amp; (CPU(ARM64) || CPU(ARM))
<span class="udiff-line-modified-removed">-     return processHasEntitlement(&quot;dynamic-codesigning&quot;) &amp;&amp; s_isJITEnabled;</span>
<span class="udiff-line-modified-added">+     return processHasEntitlement(&quot;dynamic-codesigning&quot;) &amp;&amp; jitEnabled;</span>
  #else
<span class="udiff-line-modified-removed">-     return s_isJITEnabled;</span>
<span class="udiff-line-modified-added">+     return jitEnabled;</span>
  #endif
  }
  
  void ExecutableAllocator::setJITEnabled(bool enabled)
  {
<span class="udiff-line-modified-removed">-     ASSERT(!allocator);</span>
<span class="udiff-line-modified-removed">-     if (s_isJITEnabled == enabled)</span>
<span class="udiff-line-modified-added">+     bool jitEnabled = !g_jscConfig.jitDisabled;</span>
<span class="udiff-line-modified-added">+     ASSERT(!g_jscConfig.fixedVMPoolExecutableAllocator);</span>
<span class="udiff-line-added">+     if (jitEnabled == enabled)</span>
          return;
  
<span class="udiff-line-modified-removed">-     s_isJITEnabled = enabled;</span>
<span class="udiff-line-modified-added">+     g_jscConfig.jitDisabled = !enabled;</span>
  
  #if PLATFORM(IOS_FAMILY) &amp;&amp; (CPU(ARM64) || CPU(ARM))
      if (!enabled) {
<span class="udiff-line-added">+         // Because of an OS quirk, even after the JIT region has been unmapped,</span>
<span class="udiff-line-added">+         // the OS thinks that region is reserved, and as such, can cause Gigacage</span>
<span class="udiff-line-added">+         // allocation to fail. We work around this by initializing the Gigacage</span>
<span class="udiff-line-added">+         // first.</span>
<span class="udiff-line-added">+         // Note: when called, setJITEnabled() is always called extra early in the</span>
<span class="udiff-line-added">+         // process bootstrap. Under normal operation (when setJITEnabled() isn&#39;t</span>
<span class="udiff-line-added">+         // called at all), we will naturally initialize the Gigacage before we</span>
<span class="udiff-line-added">+         // allocate the JIT region. Hence, this workaround is merely ensuring the</span>
<span class="udiff-line-added">+         // same behavior of allocation ordering.</span>
<span class="udiff-line-added">+         Gigacage::ensureGigacage();</span>
<span class="udiff-line-added">+ </span>
          constexpr size_t size = 1;
          constexpr int protection = PROT_READ | PROT_WRITE | PROT_EXEC;
          constexpr int flags = MAP_PRIVATE | MAP_ANON | MAP_JIT;
          constexpr int fd = OSAllocator::JSJITCodePages;
          void* allocation = mmap(nullptr, size, protection, flags, fd, 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -191,11 +191,11 @@</span>
              os_thread_self_restrict_rwx_to_rx();
  
  #else // not ENABLE(FAST_JIT_PERMISSIONS) or ENABLE(SEPARATED_WX_HEAP)
  #if ENABLE(FAST_JIT_PERMISSIONS)
              if (os_thread_self_restrict_rwx_is_supported()) {
<span class="udiff-line-modified-removed">-                 useFastPermisionsJITCopy = true;</span>
<span class="udiff-line-modified-added">+                 g_jscConfig.useFastPermisionsJITCopy = true;</span>
                  os_thread_self_restrict_rwx_to_rx();
              } else
  #endif
              if (Options::useSeparatedWXHeap()) {
                  // First page of our JIT allocation is reserved.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -210,19 +210,19 @@</span>
  
              ASSERT(bytesReserved() == reservationSize); // Since our executable memory is fixed-sized, bytesReserved is never changed after initialization.
  
              void* reservationEnd = reinterpret_cast&lt;uint8_t*&gt;(reservationBase) + reservationSize;
  
<span class="udiff-line-modified-removed">-             m_memoryStart = MacroAssemblerCodePtr&lt;ExecutableMemoryPtrTag&gt;(tagCodePtr&lt;ExecutableMemoryPtrTag&gt;(reservationBase));</span>
<span class="udiff-line-modified-removed">-             m_memoryEnd = MacroAssemblerCodePtr&lt;ExecutableMemoryPtrTag&gt;(tagCodePtr&lt;ExecutableMemoryPtrTag&gt;(reservationEnd));</span>
<span class="udiff-line-modified-added">+             g_jscConfig.startExecutableMemory = tagCodePtr&lt;ExecutableMemoryPtrTag&gt;(reservationBase);</span>
<span class="udiff-line-modified-added">+             g_jscConfig.endExecutableMemory = tagCodePtr&lt;ExecutableMemoryPtrTag&gt;(reservationEnd);</span>
          }
      }
  
      virtual ~FixedVMPoolExecutableAllocator();
  
<span class="udiff-line-modified-removed">-     void* memoryStart() { return m_memoryStart.untaggedExecutableAddress(); }</span>
<span class="udiff-line-modified-removed">-     void* memoryEnd() { return m_memoryEnd.untaggedExecutableAddress(); }</span>
<span class="udiff-line-modified-added">+     void* memoryStart() { return untagCodePtr&lt;ExecutableMemoryPtrTag&gt;(g_jscConfig.startExecutableMemory); }</span>
<span class="udiff-line-modified-added">+     void* memoryEnd() { return untagCodePtr&lt;ExecutableMemoryPtrTag&gt;(g_jscConfig.endExecutableMemory); }</span>
      bool isJITPC(void* pc) { return memoryStart() &lt;= pc &amp;&amp; pc &lt; memoryEnd(); }
  
  protected:
      FreeSpacePtr allocateNewSpace(size_t&amp;) override
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -300,11 +300,11 @@</span>
  
          // Zero out writableAddr to avoid leaking the address of the writable mapping.
          memset_s(&amp;writableAddr, sizeof(writableAddr), 0, sizeof(writableAddr));
  
  #if ENABLE(SEPARATED_WX_HEAP)
<span class="udiff-line-modified-removed">-         jitWriteSeparateHeapsFunction = reinterpret_cast&lt;JITWriteSeparateHeapsFunction&gt;(writeThunk.code().executableAddress());</span>
<span class="udiff-line-modified-added">+         g_jscConfig.jitWriteSeparateHeaps = reinterpret_cast&lt;JITWriteSeparateHeapsFunction&gt;(writeThunk.code().executableAddress());</span>
  #endif
      }
  
  #if CPU(ARM64) &amp;&amp; USE(EXECUTE_ONLY_JIT_WRITE_FUNCTION)
      MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; jitWriteThunkGenerator(void* writableAddr, void* stubBase, size_t stubSize)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,16 +379,16 @@</span>
          return linkBuffer.finalizeCodeWithoutDisassembly&lt;JITThunkPtrTag&gt;();
      }
  #else // not CPU(ARM64) &amp;&amp; USE(EXECUTE_ONLY_JIT_WRITE_FUNCTION)
      static void genericWriteToJITRegion(off_t offset, const void* data, size_t dataSize)
      {
<span class="udiff-line-modified-removed">-         memcpy((void*)(startOfFixedWritableMemoryPool + offset), data, dataSize);</span>
<span class="udiff-line-modified-added">+         memcpy((void*)(g_jscConfig.startOfFixedWritableMemoryPool + offset), data, dataSize);</span>
      }
  
      MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; jitWriteThunkGenerator(void* address, void*, size_t)
      {
<span class="udiff-line-modified-removed">-         startOfFixedWritableMemoryPool = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
<span class="udiff-line-modified-added">+         g_jscConfig.startOfFixedWritableMemoryPool = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
          void* function = reinterpret_cast&lt;void*&gt;(&amp;genericWriteToJITRegion);
  #if CPU(ARM_THUMB2)
          // Handle thumb offset
          uintptr_t functionAsInt = reinterpret_cast&lt;uintptr_t&gt;(function);
          functionAsInt -= 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,42 +405,47 @@</span>
      }
  #endif
  
  private:
      PageReservation m_reservation;
<span class="udiff-line-removed">-     MacroAssemblerCodePtr&lt;ExecutableMemoryPtrTag&gt; m_memoryStart;</span>
<span class="udiff-line-removed">-     MacroAssemblerCodePtr&lt;ExecutableMemoryPtrTag&gt; m_memoryEnd;</span>
  };
  
  FixedVMPoolExecutableAllocator::~FixedVMPoolExecutableAllocator()
  {
      m_reservation.deallocate();
  }
  
<span class="udiff-line-added">+ // Keep this pointer in a mutable global variable to help Leaks find it.</span>
<span class="udiff-line-added">+ // But we do not use this pointer.</span>
<span class="udiff-line-added">+ static FixedVMPoolExecutableAllocator* globalFixedVMPoolExecutableAllocatorToWorkAroundLeaks = nullptr;</span>
  void ExecutableAllocator::initializeUnderlyingAllocator()
  {
<span class="udiff-line-modified-removed">-     ASSERT(!allocator);</span>
<span class="udiff-line-modified-removed">-     allocator = new FixedVMPoolExecutableAllocator();</span>
<span class="udiff-line-modified-removed">-     CodeProfiling::notifyAllocator(allocator);</span>
<span class="udiff-line-modified-added">+     RELEASE_ASSERT(!g_jscConfig.fixedVMPoolExecutableAllocator);</span>
<span class="udiff-line-modified-added">+     g_jscConfig.fixedVMPoolExecutableAllocator = new FixedVMPoolExecutableAllocator();</span>
<span class="udiff-line-modified-added">+     globalFixedVMPoolExecutableAllocatorToWorkAroundLeaks = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
<span class="udiff-line-added">+     CodeProfiling::notifyAllocator(g_jscConfig.fixedVMPoolExecutableAllocator);</span>
  }
  
  bool ExecutableAllocator::isValid() const
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return Base::isValid();
      return !!allocator-&gt;bytesReserved();
  }
  
  bool ExecutableAllocator::underMemoryPressure()
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return Base::underMemoryPressure();
      return allocator-&gt;bytesAllocated() &gt; allocator-&gt;bytesReserved() / 2;
  }
  
  double ExecutableAllocator::memoryPressureMultiplier(size_t addedMemoryUsage)
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return Base::memoryPressureMultiplier(addedMemoryUsage);
      ASSERT(allocator-&gt;bytesAllocated() &lt;= allocator-&gt;bytesReserved());
      size_t bytesAllocated = allocator-&gt;bytesAllocated() + addedMemoryUsage;
      size_t bytesAvailable = static_cast&lt;size_t&gt;(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,10 +461,11 @@</span>
      return result;
  }
  
  RefPtr&lt;ExecutableMemoryHandle&gt; ExecutableAllocator::allocate(size_t sizeInBytes, void* ownerUID, JITCompilationEffort effort)
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return Base::allocate(sizeInBytes, ownerUID, effort);
      if (Options::logExecutableAllocation()) {
          MetaAllocator::Statistics stats = allocator-&gt;currentStatistics();
          dataLog(&quot;Allocating &quot;, sizeInBytes, &quot; bytes of executable memory with &quot;, stats.bytesAllocated, &quot; bytes allocated, &quot;, stats.bytesReserved, &quot; bytes reserved, and &quot;, stats.bytesCommitted, &quot; committed.\n&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -493,73 +499,78 @@</span>
              CRASH();
          }
          return nullptr;
      }
  
<span class="udiff-line-removed">- #if CPU(ARM64E)</span>
      void* start = allocator-&gt;memoryStart();
      void* end = allocator-&gt;memoryEnd();
      void* resultStart = result-&gt;start().untaggedPtr();
      void* resultEnd = result-&gt;end().untaggedPtr();
      RELEASE_ASSERT(start &lt;= resultStart &amp;&amp; resultStart &lt; end);
      RELEASE_ASSERT(start &lt; resultEnd &amp;&amp; resultEnd &lt;= end);
<span class="udiff-line-removed">- #endif</span>
      return result;
  }
  
  bool ExecutableAllocator::isValidExecutableMemory(const AbstractLocker&amp; locker, void* address)
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return Base::isValidExecutableMemory(locker, address);
      return allocator-&gt;isInAllocatedMemory(locker, address);
  }
  
  Lock&amp; ExecutableAllocator::getLock() const
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return Base::getLock();
      return allocator-&gt;getLock();
  }
  
  size_t ExecutableAllocator::committedByteCount()
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return Base::committedByteCount();
      return allocator-&gt;bytesCommitted();
  }
  
  #if ENABLE(META_ALLOCATOR_PROFILE)
  void ExecutableAllocator::dumpProfile()
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return;
      allocator-&gt;dumpProfile();
  }
  #endif
  
  void* startOfFixedExecutableMemoryPoolImpl()
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return nullptr;
      return allocator-&gt;memoryStart();
  }
  
  void* endOfFixedExecutableMemoryPoolImpl()
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      if (!allocator)
          return nullptr;
      return allocator-&gt;memoryEnd();
  }
  
  bool isJITPC(void* pc)
  {
<span class="udiff-line-added">+     auto* allocator = g_jscConfig.fixedVMPoolExecutableAllocator;</span>
      return allocator &amp;&amp; allocator-&gt;isJITPC(pc);
  }
  
  void dumpJITMemory(const void* dst, const void* src, size_t size)
  {
<span class="udiff-line-modified-removed">-     ASSERT(Options::dumpJITMemoryPath());</span>
<span class="udiff-line-modified-added">+     RELEASE_ASSERT(Options::dumpJITMemoryPath());</span>
  
  #if OS(DARWIN)
      static int fd = -1;
      static uint8_t* buffer;
      static constexpr size_t bufferSize = fixedExecutableMemoryPoolSize;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -633,19 +644,21 @@</span>
  
  #endif // ENABLE(JIT)
  
  namespace JSC {
  
<span class="udiff-line-modified-removed">- static ExecutableAllocator* executableAllocator;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ // Keep this pointer in a mutable global variable to help Leaks find it.</span>
<span class="udiff-line-modified-added">+ // But we do not use this pointer.</span>
<span class="udiff-line-added">+ static ExecutableAllocator* globalExecutableAllocatorToWorkAroundLeaks = nullptr;</span>
  void ExecutableAllocator::initialize()
  {
<span class="udiff-line-modified-removed">-     executableAllocator = new ExecutableAllocator;</span>
<span class="udiff-line-modified-added">+     g_jscConfig.executableAllocator = new ExecutableAllocator;</span>
<span class="udiff-line-added">+     globalExecutableAllocatorToWorkAroundLeaks = g_jscConfig.executableAllocator;</span>
  }
  
  ExecutableAllocator&amp; ExecutableAllocator::singleton()
  {
<span class="udiff-line-modified-removed">-     ASSERT(executableAllocator);</span>
<span class="udiff-line-modified-removed">-     return *executableAllocator;</span>
<span class="udiff-line-modified-added">+     ASSERT(g_jscConfig.executableAllocator);</span>
<span class="udiff-line-modified-added">+     return *g_jscConfig.executableAllocator;</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="CallFrameShuffler64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExecutableAllocator.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InjectedScriptModule.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorEnvironment.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 228,22 ***</span>
          let parsedObjectId = this._parseObjectId(objectId);
          let object = this._objectForId(parsedObjectId);
          return RemoteObject.createObjectPreviewForValue(object, true);
      }
  
<span class="line-modified">!     getProperties(objectId, ownProperties, generatePreview)</span>
      {
<span class="line-removed">-         let nativeGettersAsValues = false;</span>
          let collectionMode = ownProperties ? InjectedScript.CollectionMode.OwnProperties : InjectedScript.CollectionMode.AllProperties;
<span class="line-modified">!         return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);</span>
      }
  
<span class="line-modified">!     getDisplayableProperties(objectId, generatePreview)</span>
      {
<span class="line-removed">-         let nativeGettersAsValues = true;</span>
          let collectionMode = InjectedScript.CollectionMode.OwnProperties | InjectedScript.CollectionMode.NativeGetterProperties;
<span class="line-modified">!         return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);</span>
      }
  
      getInternalProperties(objectId, generatePreview)
      {
          let parsedObjectId = this._parseObjectId(objectId);
<span class="line-new-header">--- 228,20 ---</span>
          let parsedObjectId = this._parseObjectId(objectId);
          let object = this._objectForId(parsedObjectId);
          return RemoteObject.createObjectPreviewForValue(object, true);
      }
  
<span class="line-modified">!     getProperties(objectId, ownProperties, fetchStart, fetchCount, generatePreview)</span>
      {
          let collectionMode = ownProperties ? InjectedScript.CollectionMode.OwnProperties : InjectedScript.CollectionMode.AllProperties;
<span class="line-modified">!         return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview});</span>
      }
  
<span class="line-modified">!     getDisplayableProperties(objectId, fetchStart, fetchCount, generatePreview)</span>
      {
          let collectionMode = InjectedScript.CollectionMode.OwnProperties | InjectedScript.CollectionMode.NativeGetterProperties;
<span class="line-modified">!         return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues: true});</span>
      }
  
      getInternalProperties(objectId, generatePreview)
      {
          let parsedObjectId = this._parseObjectId(objectId);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,11 ***</span>
          }
  
          return descriptors;
      }
  
<span class="line-modified">!     getCollectionEntries(objectId, objectGroupName, startIndex, numberToFetch)</span>
      {
          let parsedObjectId = this._parseObjectId(objectId);
          let object = this._objectForId(parsedObjectId);
          objectGroupName = objectGroupName || this._idToObjectGroupName[parsedObjectId.id];
  
<span class="line-new-header">--- 265,11 ---</span>
          }
  
          return descriptors;
      }
  
<span class="line-modified">!     getCollectionEntries(objectId, objectGroupName, fetchStart, fetchCount)</span>
      {
          let parsedObjectId = this._parseObjectId(objectId);
          let object = this._objectForId(parsedObjectId);
          objectGroupName = objectGroupName || this._idToObjectGroupName[parsedObjectId.id];
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,11 ***</span>
              return;
  
          if (typeof object !== &quot;object&quot;)
              return;
  
<span class="line-modified">!         let entries = this._entries(object, InjectedScriptHost.subtype(object), startIndex, numberToFetch);</span>
          return entries.map(function(entry) {
              entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
              if (&quot;key&quot; in entry)
                  entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
              return entry;
<span class="line-new-header">--- 277,11 ---</span>
              return;
  
          if (typeof object !== &quot;object&quot;)
              return;
  
<span class="line-modified">!         let entries = this._entries(object, InjectedScriptHost.subtype(object), fetchStart, fetchCount);</span>
          return entries.map(function(entry) {
              entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
              if (&quot;key&quot; in entry)
                  entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
              return entry;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 579,11 ***</span>
          while (--ordinal &gt;= 0 &amp;&amp; callFrame)
              callFrame = callFrame.caller;
          return callFrame;
      }
  
<span class="line-modified">!     _getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues)</span>
      {
          let parsedObjectId = this._parseObjectId(objectId);
          let object = this._objectForId(parsedObjectId);
          let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
  
<span class="line-new-header">--- 577,11 ---</span>
          while (--ordinal &gt;= 0 &amp;&amp; callFrame)
              callFrame = callFrame.caller;
          return callFrame;
      }
  
<span class="line-modified">!     _getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues})</span>
      {
          let parsedObjectId = this._parseObjectId(objectId);
          let object = this._objectForId(parsedObjectId);
          let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 591,28 ***</span>
              return false;
  
          if (isSymbol(object))
              return false;
  
<span class="line-modified">!         let descriptors = this._propertyDescriptors(object, collectionMode, nativeGettersAsValues);</span>
  
<span class="line-removed">-         for (let i = 0; i &lt; descriptors.length; ++i) {</span>
<span class="line-removed">-             let descriptor = descriptors[i];</span>
              if (&quot;get&quot; in descriptor)
                  descriptor.get = RemoteObject.create(descriptor.get, objectGroupName);
              if (&quot;set&quot; in descriptor)
                  descriptor.set = RemoteObject.create(descriptor.set, objectGroupName);
              if (&quot;value&quot; in descriptor)
                  descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
<span class="line-removed">-             if (!(&quot;configurable&quot; in descriptor))</span>
<span class="line-removed">-                 descriptor.configurable = false;</span>
<span class="line-removed">-             if (!(&quot;enumerable&quot; in descriptor))</span>
<span class="line-removed">-                 descriptor.enumerable = false;</span>
              if (&quot;symbol&quot; in descriptor)
                  descriptor.symbol = RemoteObject.create(descriptor.symbol, objectGroupName);
<span class="line-modified">!         }</span>
  
          return descriptors;
      }
  
      _internalPropertyDescriptors(object, completeDescriptor)
      {
<span class="line-new-header">--- 589,43 ---</span>
              return false;
  
          if (isSymbol(object))
              return false;
  
<span class="line-modified">!         let start = fetchStart || 0;</span>
<span class="line-added">+         if (start &lt; 0)</span>
<span class="line-added">+             start = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         let count = fetchCount || 0;</span>
<span class="line-added">+         if (count &lt; 0)</span>
<span class="line-added">+             count = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Always include __proto__ at the end, but only for the first fetch.</span>
<span class="line-added">+         let includeProto = !start;</span>
<span class="line-added">+ </span>
<span class="line-added">+         let descriptors = [];</span>
<span class="line-added">+         this._forEachPropertyDescriptor(object, collectionMode, (descriptor) =&gt; {</span>
<span class="line-added">+             if (start &gt; 0) {</span>
<span class="line-added">+                 --start;</span>
<span class="line-added">+                 return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-added">+             }</span>
  
              if (&quot;get&quot; in descriptor)
                  descriptor.get = RemoteObject.create(descriptor.get, objectGroupName);
              if (&quot;set&quot; in descriptor)
                  descriptor.set = RemoteObject.create(descriptor.set, objectGroupName);
              if (&quot;value&quot; in descriptor)
                  descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
              if (&quot;symbol&quot; in descriptor)
                  descriptor.symbol = RemoteObject.create(descriptor.symbol, objectGroupName);
<span class="line-modified">!             descriptors.push(descriptor);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (includeProto &amp;&amp; count &amp;&amp; descriptors.length &gt;= count &amp;&amp; descriptor.name !== &quot;__proto__&quot;)</span>
<span class="line-added">+                 return InjectedScript.PropertyFetchAction.Stop;</span>
  
<span class="line-added">+             return (count &amp;&amp; descriptors.length &gt;= count) ? InjectedScript.PropertyFetchAction.Stop : InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-added">+         }, {nativeGettersAsValues, includeProto});</span>
          return descriptors;
      }
  
      _internalPropertyDescriptors(object, completeDescriptor)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,33 ***</span>
  
          let descriptors = [];
          for (let i = 0; i &lt; internalProperties.length; i++) {
              let property = internalProperties[i];
              let descriptor = {name: property.name, value: property.value};
<span class="line-modified">!             if (completeDescriptor) {</span>
<span class="line-removed">-                 descriptor.writable = false;</span>
<span class="line-removed">-                 descriptor.configurable = false;</span>
<span class="line-removed">-                 descriptor.enumerable = false;</span>
                  descriptor.isOwn = true;
<span class="line-removed">-             }</span>
              descriptors.push(descriptor);
          }
          return descriptors;
      }
  
<span class="line-modified">!     _propertyDescriptors(object, collectionMode, nativeGettersAsValues)</span>
      {
          if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
<span class="line-modified">!             return [];</span>
  
<span class="line-removed">-         let descriptors = [];</span>
          let nameProcessed = new Set;
  
          function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
          {
              try {
<span class="line-modified">!                 let fakeDescriptor = {name, value: object[name], writable: descriptor.writable || false, configurable: descriptor.configurable || false, enumerable: descriptor.enumerable || false};</span>
                  if (possibleNativeBindingGetter)
                      fakeDescriptor.nativeGetter = true;
                  if (isOwnProperty)
                      fakeDescriptor.isOwn = true;
                  if (symbol)
<span class="line-new-header">--- 635,39 ---</span>
  
          let descriptors = [];
          for (let i = 0; i &lt; internalProperties.length; i++) {
              let property = internalProperties[i];
              let descriptor = {name: property.name, value: property.value};
<span class="line-modified">!             if (completeDescriptor)</span>
                  descriptor.isOwn = true;
              descriptors.push(descriptor);
          }
          return descriptors;
      }
  
<span class="line-modified">!     _forEachPropertyDescriptor(object, collectionMode, callback, {nativeGettersAsValues, includeProto})</span>
      {
          if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
<span class="line-modified">!             return;</span>
  
          let nameProcessed = new Set;
  
<span class="line-added">+         // Handled below when `includeProto`.</span>
<span class="line-added">+         nameProcessed.add(&quot;__proto__&quot;);</span>
<span class="line-added">+ </span>
          function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
          {
              try {
<span class="line-modified">!                 let fakeDescriptor = {name, value: object[name]};</span>
<span class="line-added">+                 if (descriptor) {</span>
<span class="line-added">+                     if (descriptor.writable)</span>
<span class="line-added">+                         fakeDescriptor.writable = true;</span>
<span class="line-added">+                     if (descriptor.configurable)</span>
<span class="line-added">+                         fakeDescriptor.configurable = true;</span>
<span class="line-added">+                     if (descriptor.enumerable)</span>
<span class="line-added">+                         fakeDescriptor.enumerable = true;</span>
<span class="line-added">+                 }</span>
                  if (possibleNativeBindingGetter)
                      fakeDescriptor.nativeGetter = true;
                  if (isOwnProperty)
                      fakeDescriptor.isOwn = true;
                  if (symbol)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 668,178 ***</span>
          }
  
          function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
          {
              // All properties.
<span class="line-modified">!             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties) {</span>
<span class="line-modified">!                 descriptors.push(descriptor);</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
  
              // Own properties.
<span class="line-modified">!             if (collectionMode &amp; InjectedScript.CollectionMode.OwnProperties &amp;&amp; isOwnProperty) {</span>
<span class="line-modified">!                 descriptors.push(descriptor);</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
  
              // Native Getter properties.
              if (collectionMode &amp; InjectedScript.CollectionMode.NativeGetterProperties) {
<span class="line-modified">!                 if (possibleNativeBindingGetter) {</span>
<span class="line-modified">!                     descriptors.push(descriptor);</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">-                 }</span>
              }
          }
  
<span class="line-modified">!         function processProperties(o, properties, isOwnProperty)</span>
          {
<span class="line-modified">!             for (let i = 0; i &lt; properties.length; ++i) {</span>
<span class="line-modified">!                 let property = properties[i];</span>
<span class="line-removed">-                 if (nameProcessed.has(property) || property === &quot;__proto__&quot;)</span>
<span class="line-removed">-                     continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 nameProcessed.add(property);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 let name = toString(property);</span>
<span class="line-removed">-                 let symbol = isSymbol(property) ? property : null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 let descriptor = Object.getOwnPropertyDescriptor(o, property);</span>
<span class="line-removed">-                 if (!descriptor) {</span>
<span class="line-removed">-                     // FIXME: Bad descriptor. Can we get here?</span>
<span class="line-removed">-                     // Fall back to very restrictive settings.</span>
<span class="line-removed">-                     let fakeDescriptor = createFakeValueDescriptor(name, symbol, {writable: false, configurable: false, enumerable: false}, isOwnProperty);</span>
<span class="line-removed">-                     processDescriptor(fakeDescriptor, isOwnProperty);</span>
<span class="line-removed">-                     continue;</span>
<span class="line-removed">-                 }</span>
  
<span class="line-modified">!                 if (nativeGettersAsValues) {</span>
<span class="line-removed">-                     if (String(descriptor.get).endsWith(&quot;[native code]\n}&quot;) || (!descriptor.get &amp;&amp; descriptor.hasOwnProperty(&quot;get&quot;) &amp;&amp; !descriptor.set &amp;&amp; descriptor.hasOwnProperty(&quot;set&quot;))) {</span>
<span class="line-removed">-                         // Developers may create such a descriptor, so we should be resilient:</span>
<span class="line-removed">-                         // let x = {}; Object.defineProperty(x, &quot;p&quot;, {get:undefined}); Object.getOwnPropertyDescriptor(x, &quot;p&quot;)</span>
<span class="line-removed">-                         let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);</span>
<span class="line-removed">-                         processDescriptor(fakeDescriptor, isOwnProperty, true);</span>
<span class="line-removed">-                         continue;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
  
<span class="line-modified">!                 descriptor.name = name;</span>
<span class="line-modified">!                 if (isOwnProperty)</span>
<span class="line-modified">!                     descriptor.isOwn = true;</span>
<span class="line-modified">!                 if (symbol)</span>
<span class="line-modified">!                     descriptor.symbol = symbol;</span>
<span class="line-modified">!                 processDescriptor(descriptor, isOwnProperty);</span>
              }
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         function arrayIndexPropertyNames(o, length)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             let array = [];</span>
<span class="line-modified">!             for (let i = 0; i &lt; length; ++i) {</span>
<span class="line-modified">!                 if (i in o)</span>
<span class="line-modified">!                     array.push(&quot;&quot; + i);</span>
              }
<span class="line-modified">!             return array;</span>
          }
  
<span class="line-removed">-         // FIXME: &lt;https://webkit.org/b/143589&gt; Web Inspector: Better handling for large collections in Object Trees</span>
<span class="line-removed">-         // For array types with a large length we attempt to skip getOwnPropertyNames and instead just sublist of indexes.</span>
          let isArrayLike = false;
          try {
              isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
          } catch { }
  
          for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
              let isOwnProperty = o === object;
  
<span class="line-modified">!             if (isArrayLike &amp;&amp; isOwnProperty)</span>
<span class="line-modified">!                 processProperties(o, arrayIndexPropertyNames(o, Math.min(object.length, 100)), isOwnProperty);</span>
<span class="line-modified">!             else {</span>
<span class="line-modified">!                 processProperties(o, Object.getOwnPropertyNames(o), isOwnProperty);</span>
<span class="line-modified">!                 if (Object.getOwnPropertySymbols)</span>
<span class="line-modified">!                     processProperties(o, Object.getOwnPropertySymbols(o), isOwnProperty);</span>
              }
  
              if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
                  break;
          }
  
<span class="line-modified">!         // Always include __proto__ at the end.</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             if (object.__proto__)</span>
<span class="line-modified">!                 descriptors.push({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, enumerable: false, isOwn: true});</span>
<span class="line-modified">!         } catch { }</span>
<span class="line-modified">! </span>
<span class="line-removed">-         return descriptors;</span>
      }
  
<span class="line-modified">!     _getSetEntries(object, skip, numberToFetch)</span>
      {
          let entries = [];
  
          // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
          for (let value of object) {
<span class="line-modified">!             if (skip &gt; 0) {</span>
<span class="line-modified">!                 skip--;</span>
                  continue;
              }
  
              entries.push({value});
  
<span class="line-modified">!             if (numberToFetch &amp;&amp; entries.length === numberToFetch)</span>
                  break;
          }
  
          return entries;
      }
  
<span class="line-modified">!     _getMapEntries(object, skip, numberToFetch)</span>
      {
          let entries = [];
  
          // FIXME: This is observable if the page overrides Map.prototype[Symbol.iterator].
          for (let [key, value] of object) {
<span class="line-modified">!             if (skip &gt; 0) {</span>
<span class="line-modified">!                 skip--;</span>
                  continue;
              }
  
              entries.push({key, value});
  
<span class="line-modified">!             if (numberToFetch &amp;&amp; entries.length === numberToFetch)</span>
                  break;
          }
  
          return entries;
      }
  
<span class="line-modified">!     _getWeakMapEntries(object, numberToFetch)</span>
      {
<span class="line-modified">!         return InjectedScriptHost.weakMapEntries(object, numberToFetch);</span>
      }
  
<span class="line-modified">!     _getWeakSetEntries(object, numberToFetch)</span>
      {
<span class="line-modified">!         return InjectedScriptHost.weakSetEntries(object, numberToFetch);</span>
      }
  
<span class="line-modified">!     _getIteratorEntries(object, numberToFetch)</span>
      {
<span class="line-modified">!         return InjectedScriptHost.iteratorEntries(object, numberToFetch);</span>
      }
  
<span class="line-modified">!     _entries(object, subtype, startIndex, numberToFetch)</span>
      {
          if (subtype === &quot;set&quot;)
<span class="line-modified">!             return this._getSetEntries(object, startIndex, numberToFetch);</span>
          if (subtype === &quot;map&quot;)
<span class="line-modified">!             return this._getMapEntries(object, startIndex, numberToFetch);</span>
          if (subtype === &quot;weakmap&quot;)
<span class="line-modified">!             return this._getWeakMapEntries(object, numberToFetch);</span>
          if (subtype === &quot;weakset&quot;)
<span class="line-modified">!             return this._getWeakSetEntries(object, numberToFetch);</span>
          if (subtype === &quot;iterator&quot;)
<span class="line-modified">!             return this._getIteratorEntries(object, numberToFetch);</span>
  
          throw &quot;unexpected type&quot;;
      }
  
      _saveResult(result)
<span class="line-new-header">--- 687,184 ---</span>
          }
  
          function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
          {
              // All properties.
<span class="line-modified">!             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties)</span>
<span class="line-modified">!                 return callback(descriptor);</span>
  
              // Own properties.
<span class="line-modified">!             if (collectionMode &amp; InjectedScript.CollectionMode.OwnProperties &amp;&amp; isOwnProperty)</span>
<span class="line-modified">!                 return callback(descriptor);</span>
  
              // Native Getter properties.
              if (collectionMode &amp; InjectedScript.CollectionMode.NativeGetterProperties) {
<span class="line-modified">!                 if (possibleNativeBindingGetter)</span>
<span class="line-modified">!                     return callback(descriptor);</span>
              }
          }
  
<span class="line-modified">!         function processProperty(o, propertyName, isOwnProperty)</span>
          {
<span class="line-modified">!             if (nameProcessed.has(propertyName))</span>
<span class="line-modified">!                 return InjectedScript.PropertyFetchAction.Continue;</span>
  
<span class="line-modified">!             nameProcessed.add(propertyName);</span>
  
<span class="line-modified">!             let name = toString(propertyName);</span>
<span class="line-modified">!             let symbol = isSymbol(propertyName) ? propertyName : null;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             let descriptor = Object.getOwnPropertyDescriptor(o, propertyName);</span>
<span class="line-modified">!             if (!descriptor) {</span>
<span class="line-modified">!                 // FIXME: Bad descriptor. Can we get here?</span>
<span class="line-added">+                 // Fall back to very restrictive settings.</span>
<span class="line-added">+                 let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty);</span>
<span class="line-added">+                 return processDescriptor(fakeDescriptor, isOwnProperty);</span>
              }
  
<span class="line-modified">!             if (nativeGettersAsValues) {</span>
<span class="line-modified">!                 if (String(descriptor.get).endsWith(&quot;[native code]\n}&quot;) || (!descriptor.get &amp;&amp; descriptor.hasOwnProperty(&quot;get&quot;) &amp;&amp; !descriptor.set &amp;&amp; descriptor.hasOwnProperty(&quot;set&quot;))) {</span>
<span class="line-modified">!                     // Developers may create such a descriptor, so we should be resilient:</span>
<span class="line-modified">!                     // let x = {}; Object.defineProperty(x, &quot;p&quot;, {get:undefined}); Object.getOwnPropertyDescriptor(x, &quot;p&quot;)</span>
<span class="line-modified">!                     let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);</span>
<span class="line-modified">!                     return processDescriptor(fakeDescriptor, isOwnProperty, true);</span>
<span class="line-added">+                 }</span>
              }
<span class="line-modified">! </span>
<span class="line-added">+             descriptor.name = name;</span>
<span class="line-added">+             if (isOwnProperty)</span>
<span class="line-added">+                 descriptor.isOwn = true;</span>
<span class="line-added">+             if (symbol)</span>
<span class="line-added">+                 descriptor.symbol = symbol;</span>
<span class="line-added">+             return processDescriptor(descriptor, isOwnProperty);</span>
          }
  
          let isArrayLike = false;
          try {
              isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
          } catch { }
  
          for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
              let isOwnProperty = o === object;
<span class="line-added">+             let shouldBreak = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // FIXME: &lt;https://webkit.org/b/201861&gt; Web Inspector: show autocomplete entries for non-index properties on arrays</span>
<span class="line-added">+             if (isArrayLike &amp;&amp; isOwnProperty) {</span>
<span class="line-added">+                 for (let i = 0; i &lt; o.length; ++i) {</span>
<span class="line-added">+                     if (!(i in o))</span>
<span class="line-added">+                         continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+                     let result = processProperty(o, toString(i), isOwnProperty);</span>
<span class="line-added">+                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;</span>
<span class="line-added">+                     if (shouldBreak)</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 let propertyNames = Object.getOwnPropertyNames(o);</span>
<span class="line-added">+                 for (let i = 0; i &lt; propertyNames.length; ++i) {</span>
<span class="line-added">+                     let result = processProperty(o, propertyNames[i], isOwnProperty);</span>
<span class="line-added">+                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;</span>
<span class="line-added">+                     if (shouldBreak)</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (shouldBreak)</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (Object.getOwnPropertySymbols) {</span>
<span class="line-modified">!                 let propertySymbols = Object.getOwnPropertySymbols(o);</span>
<span class="line-modified">!                 for (let i = 0; i &lt; propertySymbols.length; ++i) {</span>
<span class="line-added">+                     let result = processProperty(o, propertySymbols[i], isOwnProperty);</span>
<span class="line-added">+                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;</span>
<span class="line-added">+                     if (shouldBreak)</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                 }</span>
              }
  
<span class="line-added">+             if (shouldBreak)</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
              if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
                  break;
          }
  
<span class="line-modified">!         if (includeProto) {</span>
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 if (object.__proto__)</span>
<span class="line-modified">!                     callback({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, isOwn: true});</span>
<span class="line-modified">!             } catch { }</span>
<span class="line-modified">!         }</span>
      }
  
<span class="line-modified">!     _getSetEntries(object, fetchStart, fetchCount)</span>
      {
          let entries = [];
  
          // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
          for (let value of object) {
<span class="line-modified">!             if (fetchStart &gt; 0) {</span>
<span class="line-modified">!                 fetchStart--;</span>
                  continue;
              }
  
              entries.push({value});
  
<span class="line-modified">!             if (fetchCount &amp;&amp; entries.length === fetchCount)</span>
                  break;
          }
  
          return entries;
      }
  
<span class="line-modified">!     _getMapEntries(object, fetchStart, fetchCount)</span>
      {
          let entries = [];
  
          // FIXME: This is observable if the page overrides Map.prototype[Symbol.iterator].
          for (let [key, value] of object) {
<span class="line-modified">!             if (fetchStart &gt; 0) {</span>
<span class="line-modified">!                 fetchStart--;</span>
                  continue;
              }
  
              entries.push({key, value});
  
<span class="line-modified">!             if (fetchCount &amp;&amp; entries.length === fetchCount)</span>
                  break;
          }
  
          return entries;
      }
  
<span class="line-modified">!     _getWeakMapEntries(object, fetchCount)</span>
      {
<span class="line-modified">!         return InjectedScriptHost.weakMapEntries(object, fetchCount);</span>
      }
  
<span class="line-modified">!     _getWeakSetEntries(object, fetchCount)</span>
      {
<span class="line-modified">!         return InjectedScriptHost.weakSetEntries(object, fetchCount);</span>
      }
  
<span class="line-modified">!     _getIteratorEntries(object, fetchCount)</span>
      {
<span class="line-modified">!         return InjectedScriptHost.iteratorEntries(object, fetchCount);</span>
      }
  
<span class="line-modified">!     _entries(object, subtype, fetchStart, fetchCount)</span>
      {
          if (subtype === &quot;set&quot;)
<span class="line-modified">!             return this._getSetEntries(object, fetchStart, fetchCount);</span>
          if (subtype === &quot;map&quot;)
<span class="line-modified">!             return this._getMapEntries(object, fetchStart, fetchCount);</span>
          if (subtype === &quot;weakmap&quot;)
<span class="line-modified">!             return this._getWeakMapEntries(object, fetchCount);</span>
          if (subtype === &quot;weakset&quot;)
<span class="line-modified">!             return this._getWeakSetEntries(object, fetchCount);</span>
          if (subtype === &quot;iterator&quot;)
<span class="line-modified">!             return this._getIteratorEntries(object, fetchCount);</span>
  
          throw &quot;unexpected type&quot;;
      }
  
      _saveResult(result)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 868,10 ***</span>
<span class="line-new-header">--- 893,15 ---</span>
      OwnProperties: 1 &lt;&lt; 0,          // own properties.
      NativeGetterProperties: 1 &lt;&lt; 1, // native getter properties in the prototype chain.
      AllProperties: 1 &lt;&lt; 2,          // all properties in the prototype chain.
  };
  
<span class="line-added">+ InjectedScript.PropertyFetchAction = {</span>
<span class="line-added">+     Continue: Symbol(&quot;continue&quot;),</span>
<span class="line-added">+     Stop: Symbol(&quot;stop&quot;),</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  var injectedScript = new InjectedScript;
  
  // -------
  
  let RemoteObject = class RemoteObject
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1119,170 ***</span>
              preview.properties = [];
  
              // Internal Properties.
              let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
              if (internalPropertyDescriptors) {
<span class="line-modified">!                 this._appendPropertyPreviews(object, preview, internalPropertyDescriptors, true, propertiesThreshold, firstLevelKeys, secondLevelKeys);</span>
<span class="line-modified">!                 if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)</span>
<span class="line-modified">!                     return preview;</span>
              }
  
              if (preview.entries)
                  return preview;
  
              // Properties.
<span class="line-modified">!             let nativeGettersAsValues = true;</span>
<span class="line-modified">!             let descriptors = injectedScript._propertyDescriptors(object, InjectedScript.CollectionMode.AllProperties, nativeGettersAsValues);</span>
<span class="line-modified">!             this._appendPropertyPreviews(object, preview, descriptors, false, propertiesThreshold, firstLevelKeys, secondLevelKeys);</span>
<span class="line-removed">-             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)</span>
<span class="line-removed">-                 return preview;</span>
          } catch {
              preview.lossless = false;
          }
  
          return preview;
      }
  
<span class="line-modified">!     _appendPropertyPreviews(object, preview, descriptors, internal, propertiesThreshold, firstLevelKeys, secondLevelKeys)</span>
      {
<span class="line-modified">!         for (let i = 0; i &lt; descriptors.length; ++i) {</span>
<span class="line-modified">!             let descriptor = descriptors[i];</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Seen enough.</span>
<span class="line-modified">!             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)</span>
<span class="line-removed">-                 break;</span>
  
<span class="line-modified">!             // Error in descriptor.</span>
<span class="line-modified">!             if (descriptor.wasThrown) {</span>
                  preview.lossless = false;
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             // Do not show &quot;__proto__&quot; in preview.</span>
<span class="line-modified">!             let name = descriptor.name;</span>
<span class="line-modified">!             if (name === &quot;__proto__&quot;) {</span>
<span class="line-removed">-                 // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.</span>
<span class="line-removed">-                 if (descriptor.value &amp;&amp; descriptor.value.constructor</span>
<span class="line-removed">-                     &amp;&amp; descriptor.value.constructor !== Object</span>
<span class="line-removed">-                     &amp;&amp; descriptor.value.constructor !== Array</span>
<span class="line-removed">-                     &amp;&amp; descriptor.value.constructor !== RegExp)</span>
<span class="line-removed">-                     preview.lossless = false;</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // For arrays, only allow indexes.</span>
<span class="line-modified">!             if (this.subtype === &quot;array&quot; &amp;&amp; !isUInt32(name))</span>
<span class="line-modified">!                 continue;</span>
  
<span class="line-modified">!             // Do not show non-enumerable non-own properties.</span>
<span class="line-modified">!             // Special case to allow array indexes that may be on the prototype.</span>
<span class="line-modified">!             // Special case to allow native getters on non-RegExp objects.</span>
<span class="line-modified">!             if (!descriptor.enumerable &amp;&amp; !descriptor.isOwn &amp;&amp; !(this.subtype === &quot;array&quot; || (this.subtype !== &quot;regexp&quot; &amp;&amp; descriptor.nativeGetter)))</span>
<span class="line-removed">-                 continue;</span>
  
<span class="line-modified">!             // If we have a filter, only show properties in the filter.</span>
<span class="line-modified">!             // FIXME: Currently these filters do nothing on the backend.</span>
<span class="line-modified">!             if (firstLevelKeys &amp;&amp; !firstLevelKeys.includes(name))</span>
<span class="line-modified">!                 continue;</span>
  
<span class="line-modified">!             // Getter/setter.</span>
<span class="line-modified">!             if (!(&quot;value&quot; in descriptor)) {</span>
                  preview.lossless = false;
<span class="line-modified">!                 this._appendPropertyPreview(preview, internal, {name, type: &quot;accessor&quot;}, propertiesThreshold);</span>
<span class="line-removed">-                 continue;</span>
              }
  
<span class="line-modified">!             // Null value.</span>
<span class="line-modified">!             let value = descriptor.value;</span>
<span class="line-removed">-             if (value === null) {</span>
<span class="line-removed">-                 this._appendPropertyPreview(preview, internal, {name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;}, propertiesThreshold);</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // Ignore non-enumerable functions.</span>
<span class="line-modified">!             let type = typeof value;</span>
<span class="line-modified">!             if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)</span>
<span class="line-removed">-                 continue;</span>
  
<span class="line-modified">!             // Fix type of document.all.</span>
<span class="line-modified">!             if (InjectedScriptHost.isHTMLAllCollection(value))</span>
<span class="line-modified">!                 type = &quot;object&quot;;</span>
  
<span class="line-modified">!             // Primitive.</span>
<span class="line-modified">!             const maxLength = 100;</span>
<span class="line-modified">!             if (isPrimitiveValue(value) || isBigInt(value)) {</span>
<span class="line-modified">!                 if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {</span>
<span class="line-removed">-                     value = this._abbreviateString(value, maxLength, true);</span>
<span class="line-removed">-                     preview.lossless = false;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 this._appendPropertyPreview(preview, internal, {name, type, value: toStringDescription(value)}, propertiesThreshold);</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // Symbol.</span>
<span class="line-modified">!             if (isSymbol(value)) {</span>
<span class="line-modified">!                 let symbolString = toString(value);</span>
<span class="line-modified">!                 if (symbolString.length &gt; maxLength) {</span>
<span class="line-removed">-                     symbolString = this._abbreviateString(symbolString, maxLength, true);</span>
<span class="line-removed">-                     preview.lossless = false;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 this._appendPropertyPreview(preview, internal, {name, type, value: symbolString}, propertiesThreshold);</span>
<span class="line-removed">-                 continue;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             // Object.</span>
<span class="line-modified">!             let property = {name, type};</span>
<span class="line-modified">!             let subtype = RemoteObject.subtype(value);</span>
<span class="line-modified">!             if (subtype)</span>
<span class="line-modified">!                 property.subtype = subtype;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Second level.</span>
<span class="line-modified">!             if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {</span>
<span class="line-modified">!                 // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.</span>
<span class="line-removed">-                 let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);</span>
<span class="line-removed">-                 property.valuePreview = subPreview;</span>
<span class="line-removed">-                 if (!subPreview.lossless)</span>
<span class="line-removed">-                     preview.lossless = false;</span>
<span class="line-removed">-                 if (subPreview.overflow)</span>
<span class="line-removed">-                     preview.overflow = true;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 let description = &quot;&quot;;</span>
<span class="line-removed">-                 if (type !== &quot;function&quot; || subtype === &quot;class&quot;) {</span>
<span class="line-removed">-                     let fullDescription;</span>
<span class="line-removed">-                     if (subtype === &quot;class&quot;)</span>
<span class="line-removed">-                         fullDescription = &quot;class &quot; + value.name;</span>
<span class="line-removed">-                     else if (subtype === &quot;node&quot;)</span>
<span class="line-removed">-                         fullDescription = RemoteObject.nodePreview(value);</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         fullDescription = RemoteObject.describe(value);</span>
<span class="line-removed">-                     description = this._abbreviateString(fullDescription, maxLength, subtype === &quot;regexp&quot;);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 property.value = description;</span>
                  preview.lossless = false;
              }
  
<span class="line-modified">!             this._appendPropertyPreview(preview, internal, property, propertiesThreshold);</span>
          }
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     _appendPropertyPreview(preview, internal, property, propertiesThreshold)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         if (toString(property.name &gt;&gt;&gt; 0) === property.name)</span>
<span class="line-modified">!             propertiesThreshold.indexes--;</span>
<span class="line-modified">!         else</span>
<span class="line-removed">-             propertiesThreshold.properties--;</span>
  
<span class="line-modified">!         if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0) {</span>
<span class="line-modified">!             preview.overflow = true;</span>
              preview.lossless = false;
<span class="line-removed">-             return;</span>
          }
  
<span class="line-modified">!         if (internal)</span>
<span class="line-removed">-             property.internal = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         preview.properties.push(property);</span>
      }
  
      _appendEntryPreviews(object, preview)
      {
          // Fetch 6, but only return 5, so we can tell if we overflowed.
<span class="line-new-header">--- 1149,157 ---</span>
              preview.properties = [];
  
              // Internal Properties.
              let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
              if (internalPropertyDescriptors) {
<span class="line-modified">!                 for (let i = 0; i &lt; internalPropertyDescriptors.length; ++i) {</span>
<span class="line-modified">!                     let result = this._appendPropertyPreview(object, preview, internalPropertyDescriptors[i], propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal: true});</span>
<span class="line-modified">!                     if (result === InjectedScript.PropertyFetchAction.Stop)</span>
<span class="line-added">+                         return preview;</span>
<span class="line-added">+                 }</span>
              }
  
              if (preview.entries)
                  return preview;
  
              // Properties.
<span class="line-modified">!             injectedScript._forEachPropertyDescriptor(object, InjectedScript.CollectionMode.AllProperties, (descriptor) =&gt; {</span>
<span class="line-modified">!                 return this._appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys);</span>
<span class="line-modified">!             }, {nativeGettersAsValues: true, includeProto: true})</span>
          } catch {
              preview.lossless = false;
          }
  
          return preview;
      }
  
<span class="line-modified">!     _appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal} = {})</span>
      {
<span class="line-modified">!         // Error in descriptor.</span>
<span class="line-modified">!         if (descriptor.wasThrown) {</span>
<span class="line-modified">!             preview.lossless = false;</span>
<span class="line-modified">!             return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // Do not show &quot;__proto__&quot; in preview.</span>
<span class="line-modified">!         let name = descriptor.name;</span>
<span class="line-added">+         if (name === &quot;__proto__&quot;) {</span>
<span class="line-added">+             // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.</span>
<span class="line-added">+             if (descriptor.value &amp;&amp; descriptor.value.constructor</span>
<span class="line-added">+                 &amp;&amp; descriptor.value.constructor !== Object</span>
<span class="line-added">+                 &amp;&amp; descriptor.value.constructor !== Array</span>
<span class="line-added">+                 &amp;&amp; descriptor.value.constructor !== RegExp)</span>
                  preview.lossless = false;
<span class="line-modified">!             return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // For arrays, only allow indexes.</span>
<span class="line-modified">!         if (this.subtype === &quot;array&quot; &amp;&amp; !isUInt32(name))</span>
<span class="line-modified">!             return InjectedScript.PropertyFetchAction.Continue;</span>
  
<span class="line-modified">!         // Do not show non-enumerable non-own properties.</span>
<span class="line-modified">!         // Special case to allow array indexes that may be on the prototype.</span>
<span class="line-modified">!         // Special case to allow native getters on non-RegExp objects.</span>
<span class="line-added">+         if (!descriptor.enumerable &amp;&amp; !descriptor.isOwn &amp;&amp; !(this.subtype === &quot;array&quot; || (this.subtype !== &quot;regexp&quot; &amp;&amp; descriptor.nativeGetter)))</span>
<span class="line-added">+             return InjectedScript.PropertyFetchAction.Continue;</span>
  
<span class="line-modified">!         // If we have a filter, only show properties in the filter.</span>
<span class="line-modified">!         // FIXME: Currently these filters do nothing on the backend.</span>
<span class="line-modified">!         if (firstLevelKeys &amp;&amp; !firstLevelKeys.includes(name))</span>
<span class="line-modified">!             return InjectedScript.PropertyFetchAction.Continue;</span>
  
<span class="line-modified">!         function appendPreview(property) {</span>
<span class="line-modified">!             if (toString(property.name &gt;&gt;&gt; 0) === property.name)</span>
<span class="line-modified">!                 propertiesThreshold.indexes--;</span>
<span class="line-modified">!             else</span>
<span class="line-added">+                 propertiesThreshold.properties--;</span>
  
<span class="line-modified">!             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0) {</span>
<span class="line-modified">!                 preview.overflow = true;</span>
                  preview.lossless = false;
<span class="line-modified">!                 return InjectedScript.PropertyFetchAction.Stop;</span>
              }
  
<span class="line-modified">!             if (internal)</span>
<span class="line-modified">!                 property.internal = true;</span>
  
<span class="line-modified">!             preview.properties.push(property);</span>
<span class="line-modified">!             return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         // Getter/setter.</span>
<span class="line-modified">!         if (!(&quot;value&quot; in descriptor)) {</span>
<span class="line-modified">!             preview.lossless = false;</span>
<span class="line-added">+             return appendPreview({name, type: &quot;accessor&quot;});</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Null value.</span>
<span class="line-modified">!         let value = descriptor.value;</span>
<span class="line-modified">!         if (value === null)</span>
<span class="line-modified">!             return appendPreview({name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;});</span>
  
<span class="line-modified">!         // Ignore non-enumerable functions.</span>
<span class="line-modified">!         let type = typeof value;</span>
<span class="line-modified">!         if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)</span>
<span class="line-modified">!             return InjectedScript.PropertyFetchAction.Continue;</span>
  
<span class="line-modified">!         // Fix type of document.all.</span>
<span class="line-modified">!         if (InjectedScriptHost.isHTMLAllCollection(value))</span>
<span class="line-modified">!             type = &quot;object&quot;;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Primitive.</span>
<span class="line-modified">!         const maxLength = 100;</span>
<span class="line-modified">!         if (isPrimitiveValue(value) || isBigInt(value)) {</span>
<span class="line-modified">!             if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {</span>
<span class="line-modified">!                 value = this._abbreviateString(value, maxLength, true);</span>
                  preview.lossless = false;
              }
<span class="line-added">+             return appendPreview({name, type, value: toStringDescription(value)});</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // Symbol.</span>
<span class="line-added">+         if (isSymbol(value)) {</span>
<span class="line-added">+             let symbolString = toString(value);</span>
<span class="line-added">+             if (symbolString.length &gt; maxLength) {</span>
<span class="line-added">+                 symbolString = this._abbreviateString(symbolString, maxLength, true);</span>
<span class="line-added">+                 preview.lossless = false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return appendPreview({name, type, value: symbolString});</span>
          }
  
<span class="line-modified">!         // Object.</span>
<span class="line-modified">!         let property = {name, type};</span>
<span class="line-modified">!         let subtype = RemoteObject.subtype(value);</span>
<span class="line-modified">!         if (subtype)</span>
<span class="line-modified">!             property.subtype = subtype;</span>
  
<span class="line-modified">!         // Second level.</span>
<span class="line-modified">!         if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {</span>
<span class="line-added">+             // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.</span>
<span class="line-added">+             let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);</span>
<span class="line-added">+             property.valuePreview = subPreview;</span>
<span class="line-added">+             if (!subPreview.lossless)</span>
<span class="line-added">+                 preview.lossless = false;</span>
<span class="line-added">+             if (subPreview.overflow)</span>
<span class="line-added">+                 preview.overflow = true;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             let description = &quot;&quot;;</span>
<span class="line-added">+             if (type !== &quot;function&quot; || subtype === &quot;class&quot;) {</span>
<span class="line-added">+                 let fullDescription;</span>
<span class="line-added">+                 if (subtype === &quot;class&quot;)</span>
<span class="line-added">+                     fullDescription = &quot;class &quot; + value.name;</span>
<span class="line-added">+                 else if (subtype === &quot;node&quot;)</span>
<span class="line-added">+                     fullDescription = RemoteObject.nodePreview(value);</span>
<span class="line-added">+                 else</span>
<span class="line-added">+                     fullDescription = RemoteObject.describe(value);</span>
<span class="line-added">+                 description = this._abbreviateString(fullDescription, maxLength, subtype === &quot;regexp&quot;);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             property.value = description;</span>
              preview.lossless = false;
          }
  
<span class="line-modified">!         return appendPreview(property);</span>
      }
  
      _appendEntryPreviews(object, preview)
      {
          // Fetch 6, but only return 5, so we can tell if we overflowed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1447,33 ***</span>
  
  function CommandLineAPI(callFrame)
  {
      let savedResultAlias = InjectedScriptHost.savedResultAlias;
  
<span class="line-modified">!     let defineGetter = (key, value) =&gt; {</span>
<span class="line-modified">!         if (typeof value !== &quot;function&quot;) {</span>
              let originalValue = value;
              value = function() { return originalValue; };
          }
  
          this.__defineGetter__(&quot;$&quot; + key, value);
          if (savedResultAlias &amp;&amp; savedResultAlias !== &quot;$&quot;)
              this.__defineGetter__(savedResultAlias + key, value);
      };
  
      if (&quot;_lastResult&quot; in injectedScript)
<span class="line-modified">!         defineGetter(&quot;_&quot;, injectedScript._lastResult);</span>
  
      if (&quot;_exceptionValue&quot; in injectedScript)
<span class="line-modified">!         defineGetter(&quot;exception&quot;, injectedScript._exceptionValue);</span>
  
      if (&quot;_eventValue&quot; in injectedScript)
<span class="line-modified">!         defineGetter(&quot;event&quot;, injectedScript._eventValue);</span>
  
      // $1-$99
      for (let i = 1; i &lt; injectedScript._savedResults.length; ++i)
<span class="line-modified">!         defineGetter(i, injectedScript._savedResults[i]);</span>
  
      for (let name in CommandLineAPI.getters)
          defineGetter(name, CommandLineAPI.getters[name]);
  
      for (let name in CommandLineAPI.methods)
<span class="line-new-header">--- 1464,33 ---</span>
  
  function CommandLineAPI(callFrame)
  {
      let savedResultAlias = InjectedScriptHost.savedResultAlias;
  
<span class="line-modified">!     let defineGetter = (key, value, wrap) =&gt; {</span>
<span class="line-modified">!         if (wrap) {</span>
              let originalValue = value;
              value = function() { return originalValue; };
          }
  
          this.__defineGetter__(&quot;$&quot; + key, value);
          if (savedResultAlias &amp;&amp; savedResultAlias !== &quot;$&quot;)
              this.__defineGetter__(savedResultAlias + key, value);
      };
  
      if (&quot;_lastResult&quot; in injectedScript)
<span class="line-modified">!         defineGetter(&quot;_&quot;, injectedScript._lastResult, true);</span>
  
      if (&quot;_exceptionValue&quot; in injectedScript)
<span class="line-modified">!         defineGetter(&quot;exception&quot;, injectedScript._exceptionValue, true);</span>
  
      if (&quot;_eventValue&quot; in injectedScript)
<span class="line-modified">!         defineGetter(&quot;event&quot;, injectedScript._eventValue, true);</span>
  
      // $1-$99
      for (let i = 1; i &lt; injectedScript._savedResults.length; ++i)
<span class="line-modified">!         defineGetter(i, injectedScript._savedResults[i], true);</span>
  
      for (let name in CommandLineAPI.getters)
          defineGetter(name, CommandLineAPI.getters[name]);
  
      for (let name in CommandLineAPI.methods)
</pre>
<center><a href="InjectedScriptModule.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorEnvironment.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
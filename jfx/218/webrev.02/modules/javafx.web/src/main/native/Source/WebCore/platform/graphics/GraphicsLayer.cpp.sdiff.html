<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GraphicsContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GraphicsLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 182     if (m_replicaLayer)
 183         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 184 
 185     if (m_replicatedLayer)
 186         m_replicatedLayer-&gt;setReplicatedByLayer(nullptr);
 187 
 188     if (m_maskLayer) {
 189         m_maskLayer-&gt;setParent(nullptr);
 190         m_maskLayer-&gt;setIsMaskLayer(false);
 191     }
 192 
 193     removeAllChildren();
 194     removeFromParent();
 195 }
 196 
 197 void GraphicsLayer::clearClient()
 198 {
 199     m_client = &amp;EmptyGraphicsLayerClient::singleton();
 200 }
 201 





 202 void GraphicsLayer::setClient(GraphicsLayerClient&amp; client)
 203 {
 204     m_client = &amp;client;
 205 }
 206 
 207 void GraphicsLayer::setParent(GraphicsLayer* layer)
 208 {
 209     ASSERT(!layer || !layer-&gt;hasAncestor(this));
 210     m_parent = layer;
 211 }
 212 
 213 bool GraphicsLayer::hasAncestor(GraphicsLayer* ancestor) const
 214 {
 215     for (GraphicsLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
 216         if (curr == ancestor)
 217             return true;
 218     }
 219 
 220     return false;
 221 }
</pre>
<hr />
<pre>
 491     m_backgroundColor = color;
 492 }
 493 
 494 void GraphicsLayer::setPaintingPhase(OptionSet&lt;GraphicsLayerPaintingPhase&gt; phase)
 495 {
 496     if (phase == m_paintingPhase)
 497         return;
 498 
 499     setNeedsDisplay();
 500     m_paintingPhase = phase;
 501 }
 502 
 503 void GraphicsLayer::paintGraphicsLayerContents(GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 504 {
 505     FloatSize offset = offsetFromRenderer() - toFloatSize(scrollOffset());
 506     context.translate(-offset);
 507 
 508     FloatRect clipRect(clip);
 509     clipRect.move(offset);
 510 
<span class="line-modified"> 511     client().paintContents(this, context, m_paintingPhase, clipRect, layerPaintBehavior);</span>
 512 }
 513 
 514 FloatRect GraphicsLayer::adjustCoverageRectForMovement(const FloatRect&amp; coverageRect, const FloatRect&amp; previousVisibleRect, const FloatRect&amp; currentVisibleRect)
 515 {
 516     // If the old visible rect is empty, we have no information about how the visible area is changing
 517     // (maybe the layer was just created), so don&#39;t attempt to expand. Also don&#39;t attempt to expand if the rects don&#39;t overlap.
 518     if (previousVisibleRect.isEmpty() || !currentVisibleRect.intersects(previousVisibleRect))
 519         return unionRect(coverageRect, currentVisibleRect);
 520 
 521     const float paddingMultiplier = 2;
 522 
 523     float leftEdgeDelta = paddingMultiplier * (currentVisibleRect.x() - previousVisibleRect.x());
 524     float rightEdgeDelta = paddingMultiplier * (currentVisibleRect.maxX() - previousVisibleRect.maxX());
 525 
 526     float topEdgeDelta = paddingMultiplier * (currentVisibleRect.y() - previousVisibleRect.y());
 527     float bottomEdgeDelta = paddingMultiplier * (currentVisibleRect.maxY() - previousVisibleRect.maxY());
 528 
 529     FloatRect expandedRect = currentVisibleRect;
 530 
 531     // More exposed on left side.
</pre>
<hr />
<pre>
 876         ts &lt;&lt; indent &lt;&lt; &quot;(approximate position &quot; &lt;&lt; m_approximatePosition.value().x() &lt;&lt; &quot; &quot; &lt;&lt; m_approximatePosition.value().y() &lt;&lt; &quot;)\n&quot;;
 877 
 878     if (m_boundsOrigin != FloatPoint())
 879         ts &lt;&lt; indent &lt;&lt; &quot;(bounds origin &quot; &lt;&lt; m_boundsOrigin.x() &lt;&lt; &quot; &quot; &lt;&lt; m_boundsOrigin.y() &lt;&lt; &quot;)\n&quot;;
 880 
 881     if (m_anchorPoint != FloatPoint3D(0.5f, 0.5f, 0)) {
 882         ts &lt;&lt; indent &lt;&lt; &quot;(anchor &quot; &lt;&lt; m_anchorPoint.x() &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.y();
 883         if (m_anchorPoint.z())
 884             ts &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.z();
 885         ts &lt;&lt; &quot;)\n&quot;;
 886     }
 887 
 888     if (m_size != IntSize())
 889         ts &lt;&lt; indent &lt;&lt; &quot;(bounds &quot; &lt;&lt; m_size.width() &lt;&lt; &quot; &quot; &lt;&lt; m_size.height() &lt;&lt; &quot;)\n&quot;;
 890 
 891     if (m_opacity != 1)
 892         ts &lt;&lt; indent &lt;&lt; &quot;(opacity &quot; &lt;&lt; m_opacity &lt;&lt; &quot;)\n&quot;;
 893 
 894 #if ENABLE(CSS_COMPOSITING)
 895     if (m_blendMode != BlendMode::Normal)
<span class="line-modified"> 896         ts &lt;&lt; indent &lt;&lt; &quot;(blendMode &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, m_blendMode) &lt;&lt; &quot;)\n&quot;;</span>
 897 #endif
 898 
 899     if (type() == Type::Normal &amp;&amp; tiledBacking())
 900         ts &lt;&lt; indent &lt;&lt; &quot;(usingTiledLayer 1)\n&quot;;
 901 
 902     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack = client().needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(*this);
 903     if (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack)
 904         ts &lt;&lt; indent &lt;&lt; &quot;(contentsOpaque &quot; &lt;&lt; (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack) &lt;&lt; &quot;)\n&quot;;
 905 
 906     if (m_supportsSubpixelAntialiasedText)
 907         ts &lt;&lt; indent &lt;&lt; &quot;(supports subpixel antialiased text &quot; &lt;&lt; m_supportsSubpixelAntialiasedText &lt;&lt; &quot;)\n&quot;;
 908 
 909     if (m_masksToBounds &amp;&amp; behavior &amp; LayerTreeAsTextIncludeClipping)
 910         ts &lt;&lt; indent &lt;&lt; &quot;(clips &quot; &lt;&lt; m_masksToBounds &lt;&lt; &quot;)\n&quot;;
 911 
 912     if (m_preserves3D)
 913         ts &lt;&lt; indent &lt;&lt; &quot;(preserves3D &quot; &lt;&lt; m_preserves3D &lt;&lt; &quot;)\n&quot;;
 914 
 915     if (m_drawsContent &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;drawsContent&quot;, behavior))
 916         ts &lt;&lt; indent &lt;&lt; &quot;(drawsContent &quot; &lt;&lt; m_drawsContent &lt;&lt; &quot;)\n&quot;;
</pre>
</td>
<td>
<hr />
<pre>
 182     if (m_replicaLayer)
 183         m_replicaLayer-&gt;setReplicatedLayer(nullptr);
 184 
 185     if (m_replicatedLayer)
 186         m_replicatedLayer-&gt;setReplicatedByLayer(nullptr);
 187 
 188     if (m_maskLayer) {
 189         m_maskLayer-&gt;setParent(nullptr);
 190         m_maskLayer-&gt;setIsMaskLayer(false);
 191     }
 192 
 193     removeAllChildren();
 194     removeFromParent();
 195 }
 196 
 197 void GraphicsLayer::clearClient()
 198 {
 199     m_client = &amp;EmptyGraphicsLayerClient::singleton();
 200 }
 201 
<span class="line-added"> 202 String GraphicsLayer::debugName() const</span>
<span class="line-added"> 203 {</span>
<span class="line-added"> 204     return name();</span>
<span class="line-added"> 205 }</span>
<span class="line-added"> 206 </span>
 207 void GraphicsLayer::setClient(GraphicsLayerClient&amp; client)
 208 {
 209     m_client = &amp;client;
 210 }
 211 
 212 void GraphicsLayer::setParent(GraphicsLayer* layer)
 213 {
 214     ASSERT(!layer || !layer-&gt;hasAncestor(this));
 215     m_parent = layer;
 216 }
 217 
 218 bool GraphicsLayer::hasAncestor(GraphicsLayer* ancestor) const
 219 {
 220     for (GraphicsLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
 221         if (curr == ancestor)
 222             return true;
 223     }
 224 
 225     return false;
 226 }
</pre>
<hr />
<pre>
 496     m_backgroundColor = color;
 497 }
 498 
 499 void GraphicsLayer::setPaintingPhase(OptionSet&lt;GraphicsLayerPaintingPhase&gt; phase)
 500 {
 501     if (phase == m_paintingPhase)
 502         return;
 503 
 504     setNeedsDisplay();
 505     m_paintingPhase = phase;
 506 }
 507 
 508 void GraphicsLayer::paintGraphicsLayerContents(GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 509 {
 510     FloatSize offset = offsetFromRenderer() - toFloatSize(scrollOffset());
 511     context.translate(-offset);
 512 
 513     FloatRect clipRect(clip);
 514     clipRect.move(offset);
 515 
<span class="line-modified"> 516     client().paintContents(this, context, clipRect, layerPaintBehavior);</span>
 517 }
 518 
 519 FloatRect GraphicsLayer::adjustCoverageRectForMovement(const FloatRect&amp; coverageRect, const FloatRect&amp; previousVisibleRect, const FloatRect&amp; currentVisibleRect)
 520 {
 521     // If the old visible rect is empty, we have no information about how the visible area is changing
 522     // (maybe the layer was just created), so don&#39;t attempt to expand. Also don&#39;t attempt to expand if the rects don&#39;t overlap.
 523     if (previousVisibleRect.isEmpty() || !currentVisibleRect.intersects(previousVisibleRect))
 524         return unionRect(coverageRect, currentVisibleRect);
 525 
 526     const float paddingMultiplier = 2;
 527 
 528     float leftEdgeDelta = paddingMultiplier * (currentVisibleRect.x() - previousVisibleRect.x());
 529     float rightEdgeDelta = paddingMultiplier * (currentVisibleRect.maxX() - previousVisibleRect.maxX());
 530 
 531     float topEdgeDelta = paddingMultiplier * (currentVisibleRect.y() - previousVisibleRect.y());
 532     float bottomEdgeDelta = paddingMultiplier * (currentVisibleRect.maxY() - previousVisibleRect.maxY());
 533 
 534     FloatRect expandedRect = currentVisibleRect;
 535 
 536     // More exposed on left side.
</pre>
<hr />
<pre>
 881         ts &lt;&lt; indent &lt;&lt; &quot;(approximate position &quot; &lt;&lt; m_approximatePosition.value().x() &lt;&lt; &quot; &quot; &lt;&lt; m_approximatePosition.value().y() &lt;&lt; &quot;)\n&quot;;
 882 
 883     if (m_boundsOrigin != FloatPoint())
 884         ts &lt;&lt; indent &lt;&lt; &quot;(bounds origin &quot; &lt;&lt; m_boundsOrigin.x() &lt;&lt; &quot; &quot; &lt;&lt; m_boundsOrigin.y() &lt;&lt; &quot;)\n&quot;;
 885 
 886     if (m_anchorPoint != FloatPoint3D(0.5f, 0.5f, 0)) {
 887         ts &lt;&lt; indent &lt;&lt; &quot;(anchor &quot; &lt;&lt; m_anchorPoint.x() &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.y();
 888         if (m_anchorPoint.z())
 889             ts &lt;&lt; &quot; &quot; &lt;&lt; m_anchorPoint.z();
 890         ts &lt;&lt; &quot;)\n&quot;;
 891     }
 892 
 893     if (m_size != IntSize())
 894         ts &lt;&lt; indent &lt;&lt; &quot;(bounds &quot; &lt;&lt; m_size.width() &lt;&lt; &quot; &quot; &lt;&lt; m_size.height() &lt;&lt; &quot;)\n&quot;;
 895 
 896     if (m_opacity != 1)
 897         ts &lt;&lt; indent &lt;&lt; &quot;(opacity &quot; &lt;&lt; m_opacity &lt;&lt; &quot;)\n&quot;;
 898 
 899 #if ENABLE(CSS_COMPOSITING)
 900     if (m_blendMode != BlendMode::Normal)
<span class="line-modified"> 901         ts &lt;&lt; indent &lt;&lt; &quot;(blendMode &quot; &lt;&lt; compositeOperatorName(CompositeOperator::SourceOver, m_blendMode) &lt;&lt; &quot;)\n&quot;;</span>
 902 #endif
 903 
 904     if (type() == Type::Normal &amp;&amp; tiledBacking())
 905         ts &lt;&lt; indent &lt;&lt; &quot;(usingTiledLayer 1)\n&quot;;
 906 
 907     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack = client().needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(*this);
 908     if (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack)
 909         ts &lt;&lt; indent &lt;&lt; &quot;(contentsOpaque &quot; &lt;&lt; (m_contentsOpaque || needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack) &lt;&lt; &quot;)\n&quot;;
 910 
 911     if (m_supportsSubpixelAntialiasedText)
 912         ts &lt;&lt; indent &lt;&lt; &quot;(supports subpixel antialiased text &quot; &lt;&lt; m_supportsSubpixelAntialiasedText &lt;&lt; &quot;)\n&quot;;
 913 
 914     if (m_masksToBounds &amp;&amp; behavior &amp; LayerTreeAsTextIncludeClipping)
 915         ts &lt;&lt; indent &lt;&lt; &quot;(clips &quot; &lt;&lt; m_masksToBounds &lt;&lt; &quot;)\n&quot;;
 916 
 917     if (m_preserves3D)
 918         ts &lt;&lt; indent &lt;&lt; &quot;(preserves3D &quot; &lt;&lt; m_preserves3D &lt;&lt; &quot;)\n&quot;;
 919 
 920     if (m_drawsContent &amp;&amp; client().shouldDumpPropertyForLayer(this, &quot;drawsContent&quot;, behavior))
 921         ts &lt;&lt; indent &lt;&lt; &quot;(drawsContent &quot; &lt;&lt; m_drawsContent &lt;&lt; &quot;)\n&quot;;
</pre>
</td>
</tr>
</table>
<center><a href="GraphicsContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GraphicsLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
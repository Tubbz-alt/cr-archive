<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMPromise.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMPromiseDeferred.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,215 ***</span>
  #include &quot;JSDOMWindow.h&quot;
  #include &lt;JavaScriptCore/BuiltinNames.h&gt;
  #include &lt;JavaScriptCore/Exception.h&gt;
  #include &lt;JavaScriptCore/JSONObject.h&gt;
  #include &lt;JavaScriptCore/JSPromiseConstructor.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  
  JSC::JSValue DeferredPromise::promise() const
  {
      ASSERT(deferred());
<span class="line-modified">!     return deferred()-&gt;promise();</span>
  }
  
<span class="line-modified">! void DeferredPromise::callFunction(ExecState&amp; exec, JSValue function, JSValue resolution)</span>
  {
<span class="line-modified">!     if (!canInvokeCallback())</span>
          return;
  
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="line-modified">!     CallData callData;</span>
<span class="line-modified">!     CallType callType = getCallData(vm, function, callData);</span>
<span class="line-modified">!     ASSERT(callType != CallType::None);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     MarkedArgumentBuffer arguments;</span>
<span class="line-modified">!     arguments.append(resolution);</span>
<span class="line-removed">-     ASSERT(!arguments.hasOverflowed());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     call(&amp;exec, function, callType, callData, jsUndefined(), arguments);</span>
  
<span class="line-modified">!     // DeferredPromise should only be used by internal implementations that are well behaved.</span>
<span class="line-modified">!     // In practice, the only exception we should ever see here is the TerminatedExecutionException.</span>
<span class="line-modified">!     EXCEPTION_ASSERT_UNUSED(scope, !scope.exception() || isTerminatedExecutionException(vm, scope.exception()));</span>
  
      if (m_mode == Mode::ClearPromiseOnResolve)
          clear();
  }
  
<span class="line-modified">! void DeferredPromise::whenSettled(std::function&lt;void()&gt;&amp;&amp; callback)</span>
  {
<span class="line-modified">!     DOMPromise::whenPromiseIsSettled(globalObject(), deferred()-&gt;promise(), WTFMove(callback));</span>
  }
  
  void DeferredPromise::reject()
  {
<span class="line-modified">!     if (isSuspended())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; state = *m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;state);</span>
<span class="line-modified">!     reject(state, JSC::jsUndefined());</span>
  }
  
  void DeferredPromise::reject(std::nullptr_t)
  {
<span class="line-modified">!     if (isSuspended())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; state = *m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;state);</span>
<span class="line-modified">!     reject(state, JSC::jsNull());</span>
  }
  
  void DeferredPromise::reject(Exception exception)
  {
<span class="line-modified">!     if (isSuspended())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; state = *m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;state);</span>
  
      if (exception.code() == ExistingExceptionError) {
<span class="line-modified">!         auto scope = DECLARE_CATCH_SCOPE(state.vm());</span>
  
          EXCEPTION_ASSERT(scope.exception());
  
          auto error = scope.exception()-&gt;value();
          scope.clearException();
  
          reject&lt;IDLAny&gt;(error);
          return;
      }
  
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(state.vm());</span>
<span class="line-modified">!     auto error = createDOMException(state, WTFMove(exception));</span>
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         ASSERT(isTerminatedExecutionException(state.vm(), scope.exception()));</span>
          return;
      }
  
<span class="line-modified">!     reject(state, error);</span>
  }
  
  void DeferredPromise::reject(ExceptionCode ec, const String&amp; message)
  {
<span class="line-modified">!     if (isSuspended())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; state = *m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;state);</span>
  
      if (ec == ExistingExceptionError) {
<span class="line-modified">!         auto scope = DECLARE_CATCH_SCOPE(state.vm());</span>
  
          EXCEPTION_ASSERT(scope.exception());
  
          auto error = scope.exception()-&gt;value();
          scope.clearException();
  
          reject&lt;IDLAny&gt;(error);
          return;
      }
  
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(state.vm());</span>
<span class="line-modified">!     auto error = createDOMException(&amp;state, ec, message);</span>
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         ASSERT(isTerminatedExecutionException(state.vm(), scope.exception()));</span>
          return;
      }
  
  
<span class="line-modified">!     reject(state, error);</span>
  }
  
  void DeferredPromise::reject(const JSC::PrivateName&amp; privateName)
  {
<span class="line-modified">!     if (isSuspended())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     JSC::ExecState* state = m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     JSC::JSLockHolder locker(state);</span>
<span class="line-modified">!     reject(*state, JSC::Symbol::create(state-&gt;vm(), privateName.uid()));</span>
  }
  
<span class="line-modified">! void rejectPromiseWithExceptionIfAny(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSPromiseDeferred&amp; promiseDeferred)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      if (LIKELY(!scope.exception()))
          return;
  
      JSValue error = scope.exception()-&gt;value();
      scope.clearException();
  
<span class="line-modified">!     DeferredPromise::create(globalObject, promiseDeferred)-&gt;reject&lt;IDLAny&gt;(error);</span>
  }
  
<span class="line-modified">! Ref&lt;DeferredPromise&gt; createDeferredPromise(JSC::ExecState&amp; state, JSDOMWindow&amp; domWindow)</span>
  {
<span class="line-modified">!     JSC::JSPromiseDeferred* deferred = JSC::JSPromiseDeferred::tryCreate(&amp;state, &amp;domWindow);</span>
<span class="line-modified">!     // deferred can only be null in workers.</span>
<span class="line-modified">!     RELEASE_ASSERT(deferred);</span>
<span class="line-removed">-     return DeferredPromise::create(domWindow, *deferred);</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::ExecState&amp; state, const String&amp; errorMessage, RejectedPromiseWithTypeErrorCause cause)</span>
  {
<span class="line-modified">!     ASSERT(state.lexicalGlobalObject());</span>
<span class="line-removed">-     auto&amp; globalObject = *state.lexicalGlobalObject();</span>
  
      auto promiseConstructor = globalObject.promiseConstructor();
<span class="line-modified">!     auto rejectFunction = promiseConstructor-&gt;get(&amp;state, state.vm().propertyNames-&gt;builtinNames().rejectPrivateName());</span>
<span class="line-modified">!     auto* rejectionValue = static_cast&lt;ErrorInstance*&gt;(createTypeError(&amp;state, errorMessage));</span>
      if (cause == RejectedPromiseWithTypeErrorCause::NativeGetter)
          rejectionValue-&gt;setNativeGetterTypeError();
  
      CallData callData;
<span class="line-modified">!     auto callType = getCallData(state.vm(), rejectFunction, callData);</span>
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer arguments;
      arguments.append(rejectionValue);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     return JSValue::encode(call(&amp;state, rejectFunction, callType, callData, promiseConstructor, arguments));</span>
  }
  
<span class="line-modified">! static inline JSC::JSValue parseAsJSON(JSC::ExecState* state, const String&amp; data)</span>
  {
<span class="line-modified">!     JSC::JSLockHolder lock(state);</span>
<span class="line-modified">!     return JSC::JSONParse(state, data);</span>
  }
  
  void fulfillPromiseWithJSON(Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; data)
  {
<span class="line-modified">!     JSC::JSValue value = parseAsJSON(promise-&gt;globalObject()-&gt;globalExec(), data);</span>
      if (!value)
          promise-&gt;reject(SyntaxError);
      else
          promise-&gt;resolve&lt;IDLAny&gt;(value);
  }
  
  void fulfillPromiseWithArrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp; promise, ArrayBuffer* arrayBuffer)
  {
      if (!arrayBuffer) {
<span class="line-modified">!         promise-&gt;reject&lt;IDLAny&gt;(createOutOfMemoryError(promise-&gt;globalObject()-&gt;globalExec()));</span>
          return;
      }
      promise-&gt;resolve&lt;IDLInterface&lt;ArrayBuffer&gt;&gt;(*arrayBuffer);
  }
  
<span class="line-new-header">--- 31,231 ---</span>
  #include &quot;JSDOMWindow.h&quot;
  #include &lt;JavaScriptCore/BuiltinNames.h&gt;
  #include &lt;JavaScriptCore/Exception.h&gt;
  #include &lt;JavaScriptCore/JSONObject.h&gt;
  #include &lt;JavaScriptCore/JSPromiseConstructor.h&gt;
<span class="line-added">+ #include &lt;JavaScriptCore/Strong.h&gt;</span>
  
  namespace WebCore {
  using namespace JSC;
  
  JSC::JSValue DeferredPromise::promise() const
  {
      ASSERT(deferred());
<span class="line-modified">!     return deferred();</span>
  }
  
<span class="line-modified">! void DeferredPromise::callFunction(JSGlobalObject&amp; lexicalGlobalObject, ResolveMode mode, JSValue resolution)</span>
  {
<span class="line-modified">!     if (shouldIgnoreRequestToFulfill())</span>
          return;
  
<span class="line-modified">!     if (activeDOMObjectsAreSuspended()) {</span>
<span class="line-modified">!         JSC::Strong&lt;JSC::Unknown, ShouldStrongDestructorGrabLock::Yes&gt; strongResolution(lexicalGlobalObject.vm(), resolution);</span>
<span class="line-added">+         scriptExecutionContext()-&gt;eventLoop().queueTask(TaskSource::Networking, [this, protectedThis = makeRef(*this), mode, strongResolution = WTFMove(strongResolution)]() mutable {</span>
<span class="line-added">+             if (shouldIgnoreRequestToFulfill())</span>
<span class="line-added">+                 return;</span>
  
<span class="line-modified">!             JSC::JSGlobalObject* lexicalGlobalObject = globalObject();</span>
<span class="line-modified">!             JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!             callFunction(*globalObject(), mode, strongResolution.get());</span>
<span class="line-modified">!         });</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     // FIXME: We could have error since any JS call can throw stack-overflow errors.</span>
<span class="line-modified">!     // https://bugs.webkit.org/show_bug.cgi?id=203402</span>
<span class="line-modified">!     switch (mode) {</span>
<span class="line-added">+     case ResolveMode::Resolve:</span>
<span class="line-added">+         deferred()-&gt;resolve(&amp;lexicalGlobalObject, resolution);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ResolveMode::Reject:</span>
<span class="line-added">+         deferred()-&gt;reject(&amp;lexicalGlobalObject, resolution);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
  
      if (m_mode == Mode::ClearPromiseOnResolve)
          clear();
  }
  
<span class="line-modified">! void DeferredPromise::whenSettled(Function&lt;void()&gt;&amp;&amp; callback)</span>
  {
<span class="line-modified">!     if (shouldIgnoreRequestToFulfill())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (activeDOMObjectsAreSuspended()) {</span>
<span class="line-added">+         scriptExecutionContext()-&gt;eventLoop().queueTask(TaskSource::Networking, [this, protectedThis = makeRef(*this), callback = WTFMove(callback)]() mutable {</span>
<span class="line-added">+             whenSettled(WTFMove(callback));</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     DOMPromise::whenPromiseIsSettled(globalObject(), deferred(), WTFMove(callback));</span>
  }
  
  void DeferredPromise::reject()
  {
<span class="line-modified">!     if (shouldIgnoreRequestToFulfill())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *m_globalObject;</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!     reject(lexicalGlobalObject, JSC::jsUndefined());</span>
  }
  
  void DeferredPromise::reject(std::nullptr_t)
  {
<span class="line-modified">!     if (shouldIgnoreRequestToFulfill())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *m_globalObject;</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;lexicalGlobalObject);</span>
<span class="line-modified">!     reject(lexicalGlobalObject, JSC::jsNull());</span>
  }
  
  void DeferredPromise::reject(Exception exception)
  {
<span class="line-modified">!     if (shouldIgnoreRequestToFulfill())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *m_globalObject;</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;lexicalGlobalObject);</span>
  
      if (exception.code() == ExistingExceptionError) {
<span class="line-modified">!         auto scope = DECLARE_CATCH_SCOPE(lexicalGlobalObject.vm());</span>
  
          EXCEPTION_ASSERT(scope.exception());
  
          auto error = scope.exception()-&gt;value();
          scope.clearException();
  
          reject&lt;IDLAny&gt;(error);
          return;
      }
  
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());</span>
<span class="line-modified">!     auto error = createDOMException(lexicalGlobalObject, WTFMove(exception));</span>
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         ASSERT(isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));</span>
          return;
      }
  
<span class="line-modified">!     reject(lexicalGlobalObject, error);</span>
  }
  
  void DeferredPromise::reject(ExceptionCode ec, const String&amp; message)
  {
<span class="line-modified">!     if (shouldIgnoreRequestToFulfill())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *m_globalObject;</span>
<span class="line-modified">!     JSC::JSLockHolder locker(&amp;lexicalGlobalObject);</span>
  
      if (ec == ExistingExceptionError) {
<span class="line-modified">!         auto scope = DECLARE_CATCH_SCOPE(lexicalGlobalObject.vm());</span>
  
          EXCEPTION_ASSERT(scope.exception());
  
          auto error = scope.exception()-&gt;value();
          scope.clearException();
  
          reject&lt;IDLAny&gt;(error);
          return;
      }
  
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject.vm());</span>
<span class="line-modified">!     auto error = createDOMException(&amp;lexicalGlobalObject, ec, message);</span>
      if (UNLIKELY(scope.exception())) {
<span class="line-modified">!         ASSERT(isTerminatedExecutionException(lexicalGlobalObject.vm(), scope.exception()));</span>
          return;
      }
  
  
<span class="line-modified">!     reject(lexicalGlobalObject, error);</span>
  }
  
  void DeferredPromise::reject(const JSC::PrivateName&amp; privateName)
  {
<span class="line-modified">!     if (shouldIgnoreRequestToFulfill())</span>
          return;
  
      ASSERT(deferred());
      ASSERT(m_globalObject);
<span class="line-modified">!     JSC::JSGlobalObject* lexicalGlobalObject = m_globalObject.get();</span>
<span class="line-modified">!     JSC::JSLockHolder locker(lexicalGlobalObject);</span>
<span class="line-modified">!     reject(*lexicalGlobalObject, JSC::Symbol::create(lexicalGlobalObject-&gt;vm(), privateName.uid()));</span>
  }
  
<span class="line-modified">! void rejectPromiseWithExceptionIfAny(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, JSPromise&amp; promise)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      if (LIKELY(!scope.exception()))
          return;
  
      JSValue error = scope.exception()-&gt;value();
      scope.clearException();
  
<span class="line-modified">!     DeferredPromise::create(globalObject, promise)-&gt;reject&lt;IDLAny&gt;(error);</span>
  }
  
<span class="line-modified">! Ref&lt;DeferredPromise&gt; createDeferredPromise(JSC::JSGlobalObject&amp;, JSDOMWindow&amp; domWindow)</span>
  {
<span class="line-modified">!     auto* promise = JSPromise::create(domWindow.vm(), domWindow.promiseStructure());</span>
<span class="line-modified">!     RELEASE_ASSERT(promise);</span>
<span class="line-modified">!     return DeferredPromise::create(domWindow, *promise);</span>
  }
  
<span class="line-modified">! JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::JSGlobalObject&amp; lexicalGlobalObject, const String&amp; errorMessage, RejectedPromiseWithTypeErrorCause cause)</span>
  {
<span class="line-modified">!     auto&amp; globalObject = lexicalGlobalObject;</span>
  
      auto promiseConstructor = globalObject.promiseConstructor();
<span class="line-modified">!     auto rejectFunction = promiseConstructor-&gt;get(&amp;lexicalGlobalObject, lexicalGlobalObject.vm().propertyNames-&gt;builtinNames().rejectPrivateName());</span>
<span class="line-modified">!     auto* rejectionValue = static_cast&lt;ErrorInstance*&gt;(createTypeError(&amp;lexicalGlobalObject, errorMessage));</span>
      if (cause == RejectedPromiseWithTypeErrorCause::NativeGetter)
          rejectionValue-&gt;setNativeGetterTypeError();
  
      CallData callData;
<span class="line-modified">!     auto callType = getCallData(lexicalGlobalObject.vm(), rejectFunction, callData);</span>
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer arguments;
      arguments.append(rejectionValue);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     return JSValue::encode(call(&amp;lexicalGlobalObject, rejectFunction, callType, callData, promiseConstructor, arguments));</span>
  }
  
<span class="line-modified">! static inline JSC::JSValue parseAsJSON(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; data)</span>
  {
<span class="line-modified">!     JSC::JSLockHolder lock(lexicalGlobalObject);</span>
<span class="line-modified">!     return JSC::JSONParse(lexicalGlobalObject, data);</span>
  }
  
  void fulfillPromiseWithJSON(Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; data)
  {
<span class="line-modified">!     JSC::JSValue value = parseAsJSON(promise-&gt;globalObject(), data);</span>
      if (!value)
          promise-&gt;reject(SyntaxError);
      else
          promise-&gt;resolve&lt;IDLAny&gt;(value);
  }
  
  void fulfillPromiseWithArrayBuffer(Ref&lt;DeferredPromise&gt;&amp;&amp; promise, ArrayBuffer* arrayBuffer)
  {
      if (!arrayBuffer) {
<span class="line-modified">!         promise-&gt;reject&lt;IDLAny&gt;(createOutOfMemoryError(promise-&gt;globalObject()));</span>
          return;
      }
      promise-&gt;resolve&lt;IDLInterface&lt;ArrayBuffer&gt;&gt;(*arrayBuffer);
  }
  
</pre>
<center><a href="JSDOMPromise.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMPromiseDeferred.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IsoAlignedMemoryAllocator.h&quot;
 28 #include &quot;MarkedBlock.h&quot;
 29 
 30 namespace JSC {
 31 
 32 IsoAlignedMemoryAllocator::IsoAlignedMemoryAllocator(CString name)
 33 #if ENABLE(MALLOC_HEAP_BREAKDOWN)
 34     : m_debugHeap(name.data())
 35 #endif
 36 {
 37     UNUSED_PARAM(name);
 38 }
 39 
 40 IsoAlignedMemoryAllocator::~IsoAlignedMemoryAllocator()
 41 {
 42 #if !ENABLE(MALLOC_HEAP_BREAKDOWN)
 43     for (unsigned i = 0; i &lt; m_blocks.size(); ++i) {
 44         void* block = m_blocks[i];
 45         if (!m_committed[i])
 46             WTF::fastCommitAlignedMemory(block, MarkedBlock::blockSize);
 47         fastAlignedFree(block);
 48     }
 49 #endif
 50 }
 51 
 52 void* IsoAlignedMemoryAllocator::tryAllocateAlignedMemory(size_t alignment, size_t size)
 53 {
 54     // Since this is designed specially for IsoSubspace, we know that we will only be asked to
 55     // allocate MarkedBlocks.
 56     RELEASE_ASSERT(alignment == MarkedBlock::blockSize);
 57     RELEASE_ASSERT(size == MarkedBlock::blockSize);
 58 
 59 #if ENABLE(MALLOC_HEAP_BREAKDOWN)
 60     return m_debugHeap.memalign(MarkedBlock::blockSize, MarkedBlock::blockSize, true);
 61 #else
 62     auto locker = holdLock(m_lock);
 63 
 64     m_firstUncommitted = m_committed.findBit(m_firstUncommitted, false);
 65     if (m_firstUncommitted &lt; m_blocks.size()) {
 66         m_committed[m_firstUncommitted] = true;
 67         void* result = m_blocks[m_firstUncommitted];
 68         WTF::fastCommitAlignedMemory(result, MarkedBlock::blockSize);
 69         return result;
 70     }
 71 
 72     void* result = tryFastAlignedMalloc(MarkedBlock::blockSize, MarkedBlock::blockSize);
 73     if (!result)
 74         return nullptr;
 75     unsigned index = m_blocks.size();
 76     m_blocks.append(result);
 77     m_blockIndices.add(result, index);
 78     if (m_blocks.capacity() != m_committed.size())
 79         m_committed.resize(m_blocks.capacity());
 80     m_committed[index] = true;
 81     return result;
 82 #endif
 83 }
 84 
 85 void IsoAlignedMemoryAllocator::freeAlignedMemory(void* basePtr)
 86 {
 87 #if ENABLE(MALLOC_HEAP_BREAKDOWN)
 88     m_debugHeap.free(basePtr);
 89 #else
 90     auto locker = holdLock(m_lock);
 91 
 92     auto iter = m_blockIndices.find(basePtr);
 93     RELEASE_ASSERT(iter != m_blockIndices.end());
 94     unsigned index = iter-&gt;value;
 95     m_committed[index] = false;
 96     m_firstUncommitted = std::min(index, m_firstUncommitted);
 97     WTF::fastDecommitAlignedMemory(basePtr, MarkedBlock::blockSize);
 98 #endif
 99 }
100 
101 void IsoAlignedMemoryAllocator::dump(PrintStream&amp; out) const
102 {
103     out.print(&quot;Iso(&quot;, RawPointer(this), &quot;)&quot;);
104 }
105 
106 void* IsoAlignedMemoryAllocator::tryAllocateMemory(size_t size)
107 {
108 #if ENABLE(MALLOC_HEAP_BREAKDOWN)
109     return m_debugHeap.malloc(size);
110 #else
111     return FastMalloc::tryMalloc(size);
112 #endif
113 }
114 
115 void IsoAlignedMemoryAllocator::freeMemory(void* pointer)
116 {
117 #if ENABLE(MALLOC_HEAP_BREAKDOWN)
118     m_debugHeap.free(pointer);
119 #else
120     FastMalloc::free(pointer);
121 #endif
122 }
123 
124 void* IsoAlignedMemoryAllocator::tryReallocateMemory(void*, size_t)
125 {
126     // In IsoSubspace-managed PreciseAllocation, we must not perform realloc.
127     RELEASE_ASSERT_NOT_REACHED();
128 }
129 
130 } // namespace JSC
131 
    </pre>
  </body>
</html>
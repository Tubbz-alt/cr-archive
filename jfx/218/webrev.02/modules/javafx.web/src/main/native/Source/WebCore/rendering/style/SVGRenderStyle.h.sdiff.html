<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/SVGRenderStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGRenderStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderStyleDefs.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/SVGRenderStyle.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13     This library is distributed in the hope that it will be useful,
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #pragma once
 25 
 26 #include &quot;DataRef.h&quot;
 27 #include &quot;RenderStyleConstants.h&quot;
 28 #include &quot;SVGRenderStyleDefs.h&quot;
 29 #include &quot;WindRule.h&quot;
 30 
 31 namespace WebCore {
 32 

 33 class SVGRenderStyle : public RefCounted&lt;SVGRenderStyle&gt; {

 34 public:
 35     static Ref&lt;SVGRenderStyle&gt; createDefaultStyle();
 36     static Ref&lt;SVGRenderStyle&gt; create() { return adoptRef(*new SVGRenderStyle); }
 37     Ref&lt;SVGRenderStyle&gt; copy() const;
 38     ~SVGRenderStyle();
 39 
<span class="line-modified"> 40     bool inheritedNotEqual(const SVGRenderStyle&amp;) const;</span>
 41     void inheritFrom(const SVGRenderStyle&amp;);
 42     void copyNonInheritedFrom(const SVGRenderStyle&amp;);
 43 
 44     StyleDifference diff(const SVGRenderStyle&amp;) const;
 45 
 46     bool operator==(const SVGRenderStyle&amp;) const;
 47     bool operator!=(const SVGRenderStyle&amp; other) const { return !(*this == other); }
 48 
 49     // Initial values for all the properties
 50     static AlignmentBaseline initialAlignmentBaseline() { return AlignmentBaseline::Auto; }
 51     static DominantBaseline initialDominantBaseline() { return DominantBaseline::Auto; }
 52     static BaselineShift initialBaselineShift() { return BaselineShift::Baseline; }
 53     static VectorEffect initialVectorEffect() { return VectorEffect::None; }
 54     static BufferedRendering initialBufferedRendering() { return BufferedRendering::Auto; }
 55     static WindRule initialClipRule() { return WindRule::NonZero; }
 56     static ColorInterpolation initialColorInterpolation() { return ColorInterpolation::SRGB; }
 57     static ColorInterpolation initialColorInterpolationFilters() { return ColorInterpolation::LinearRGB; }
 58     static ColorRendering initialColorRendering() { return ColorRendering::Auto; }
 59     static WindRule initialFillRule() { return WindRule::NonZero; }
 60     static ShapeRendering initialShapeRendering() { return ShapeRendering::Auto; }
 61     static TextAnchor initialTextAnchor() { return TextAnchor::Start; }
 62     static GlyphOrientation initialGlyphOrientationHorizontal() { return GlyphOrientation::Degrees0; }
 63     static GlyphOrientation initialGlyphOrientationVertical() { return GlyphOrientation::Auto; }
 64     static float initialFillOpacity() { return 1; }
 65     static SVGPaintType initialFillPaintType() { return SVGPaintType::RGBColor; }
 66     static Color initialFillPaintColor() { return Color::black; }
 67     static String initialFillPaintUri() { return String(); }
 68     static float initialStrokeOpacity() { return 1; }
 69     static SVGPaintType initialStrokePaintType() { return SVGPaintType::None; }
 70     static Color initialStrokePaintColor() { return Color(); }
 71     static String initialStrokePaintUri() { return String(); }
 72     static Vector&lt;SVGLengthValue&gt; initialStrokeDashArray() { return { }; }
 73     static float initialStopOpacity() { return 1; }
 74     static Color initialStopColor() { return Color(0, 0, 0); }
 75     static float initialFloodOpacity() { return 1; }
 76     static Color initialFloodColor() { return Color(0, 0, 0); }
 77     static Color initialLightingColor() { return Color(255, 255, 255); }
 78     static ShadowData* initialShadow() { return nullptr; }
<span class="line-removed"> 79     static String initialClipperResource() { return String(); }</span>
 80     static String initialMaskerResource() { return String(); }
 81     static String initialMarkerStartResource() { return String(); }
 82     static String initialMarkerMidResource() { return String(); }
 83     static String initialMarkerEndResource() { return String(); }
 84     static MaskType initialMaskType() { return MaskType::Luminance; }
<span class="line-modified"> 85     static SVGLengthValue initialBaselineShiftValue();</span>
<span class="line-modified"> 86     static SVGLengthValue initialKerning();</span>
 87 
 88     // SVG CSS Property setters
 89     void setAlignmentBaseline(AlignmentBaseline val) { m_nonInheritedFlags.flagBits.alignmentBaseline = static_cast&lt;unsigned&gt;(val); }
 90     void setDominantBaseline(DominantBaseline val) { m_nonInheritedFlags.flagBits.dominantBaseline = static_cast&lt;unsigned&gt;(val); }
 91     void setBaselineShift(BaselineShift val) { m_nonInheritedFlags.flagBits.baselineShift = static_cast&lt;unsigned&gt;(val); }
 92     void setVectorEffect(VectorEffect val) { m_nonInheritedFlags.flagBits.vectorEffect = static_cast&lt;unsigned&gt;(val); }
 93     void setBufferedRendering(BufferedRendering val) { m_nonInheritedFlags.flagBits.bufferedRendering = static_cast&lt;unsigned&gt;(val); }
 94     void setClipRule(WindRule val) { m_inheritedFlags.clipRule = static_cast&lt;unsigned&gt;(val); }
 95     void setColorInterpolation(ColorInterpolation val) { m_inheritedFlags.colorInterpolation = static_cast&lt;unsigned&gt;(val); }
 96     void setColorInterpolationFilters(ColorInterpolation val) { m_inheritedFlags.colorInterpolationFilters = static_cast&lt;unsigned&gt;(val); }
 97     void setColorRendering(ColorRendering val) { m_inheritedFlags.colorRendering = static_cast&lt;unsigned&gt;(val); }
 98     void setFillRule(WindRule val) { m_inheritedFlags.fillRule = static_cast&lt;unsigned&gt;(val); }
 99     void setShapeRendering(ShapeRendering val) { m_inheritedFlags.shapeRendering = static_cast&lt;unsigned&gt;(val); }
100     void setTextAnchor(TextAnchor val) { m_inheritedFlags.textAnchor = static_cast&lt;unsigned&gt;(val); }
101     void setGlyphOrientationHorizontal(GlyphOrientation val) { m_inheritedFlags.glyphOrientationHorizontal = static_cast&lt;unsigned&gt;(val); }
102     void setGlyphOrientationVertical(GlyphOrientation val) { m_inheritedFlags.glyphOrientationVertical = static_cast&lt;unsigned&gt;(val); }
103     void setMaskType(MaskType val) { m_nonInheritedFlags.flagBits.maskType = static_cast&lt;unsigned&gt;(val); }
104     void setCx(const Length&amp;);
105     void setCy(const Length&amp;);
106     void setR(const Length&amp;);
</pre>
<hr />
<pre>
109     void setX(const Length&amp;);
110     void setY(const Length&amp;);
111     void setFillOpacity(float);
112     void setFillPaint(SVGPaintType, const Color&amp;, const String&amp; uri, bool applyToRegularStyle = true, bool applyToVisitedLinkStyle = false);
113     void setStrokeOpacity(float);
114     void setStrokePaint(SVGPaintType, const Color&amp;, const String&amp; uri, bool applyToRegularStyle = true, bool applyToVisitedLinkStyle = false);
115 
116     void setStrokeDashArray(const Vector&lt;SVGLengthValue&gt;&amp;);
117     void setStrokeDashOffset(const Length&amp;);
118     void setKerning(const SVGLengthValue&amp;);
119     void setStopOpacity(float);
120     void setStopColor(const Color&amp;);
121     void setFloodOpacity(float);
122     void setFloodColor(const Color&amp;);
123     void setLightingColor(const Color&amp;);
124     void setBaselineShiftValue(const SVGLengthValue&amp;);
125 
126     void setShadow(std::unique_ptr&lt;ShadowData&gt;&amp;&amp; data) { m_shadowData.access().shadow = WTFMove(data); }
127 
128     // Setters for non-inherited resources
<span class="line-removed">129     void setClipperResource(const String&amp;);</span>
130     void setMaskerResource(const String&amp;);
131 
132     // Setters for inherited resources
133     void setMarkerStartResource(const String&amp;);
134     void setMarkerMidResource(const String&amp;);
135     void setMarkerEndResource(const String&amp;);
136 
137     // Read accessors for all the properties
138     AlignmentBaseline alignmentBaseline() const { return static_cast&lt;AlignmentBaseline&gt;(m_nonInheritedFlags.flagBits.alignmentBaseline); }
139     DominantBaseline dominantBaseline() const { return static_cast&lt;DominantBaseline&gt;(m_nonInheritedFlags.flagBits.dominantBaseline); }
140     BaselineShift baselineShift() const { return static_cast&lt;BaselineShift&gt;(m_nonInheritedFlags.flagBits.baselineShift); }
141     VectorEffect vectorEffect() const { return static_cast&lt;VectorEffect&gt;(m_nonInheritedFlags.flagBits.vectorEffect); }
142     BufferedRendering bufferedRendering() const { return static_cast&lt;BufferedRendering&gt;(m_nonInheritedFlags.flagBits.bufferedRendering); }
143     WindRule clipRule() const { return static_cast&lt;WindRule&gt;(m_inheritedFlags.clipRule); }
144     ColorInterpolation colorInterpolation() const { return static_cast&lt;ColorInterpolation&gt;(m_inheritedFlags.colorInterpolation); }
145     ColorInterpolation colorInterpolationFilters() const { return static_cast&lt;ColorInterpolation&gt;(m_inheritedFlags.colorInterpolationFilters); }
146     ColorRendering colorRendering() const { return static_cast&lt;ColorRendering&gt;(m_inheritedFlags.colorRendering); }
147     WindRule fillRule() const { return static_cast&lt;WindRule&gt;(m_inheritedFlags.fillRule); }
148     ShapeRendering shapeRendering() const { return static_cast&lt;ShapeRendering&gt;(m_inheritedFlags.shapeRendering); }
149     TextAnchor textAnchor() const { return static_cast&lt;TextAnchor&gt;(m_inheritedFlags.textAnchor); }
</pre>
<hr />
<pre>
157     SVGPaintType strokePaintType() const { return static_cast&lt;SVGPaintType&gt;(m_strokeData-&gt;paintType); }
158     const Color&amp; strokePaintColor() const { return m_strokeData-&gt;paintColor; }
159     const String&amp; strokePaintUri() const { return m_strokeData-&gt;paintUri; }
160     Vector&lt;SVGLengthValue&gt; strokeDashArray() const { return m_strokeData-&gt;dashArray; }
161     const Length&amp; strokeDashOffset() const { return m_strokeData-&gt;dashOffset; }
162     SVGLengthValue kerning() const { return m_textData-&gt;kerning; }
163     float stopOpacity() const { return m_stopData-&gt;opacity; }
164     const Color&amp; stopColor() const { return m_stopData-&gt;color; }
165     float floodOpacity() const { return m_miscData-&gt;floodOpacity; }
166     const Color&amp; floodColor() const { return m_miscData-&gt;floodColor; }
167     const Color&amp; lightingColor() const { return m_miscData-&gt;lightingColor; }
168     SVGLengthValue baselineShiftValue() const { return m_miscData-&gt;baselineShiftValue; }
169     ShadowData* shadow() const { return m_shadowData-&gt;shadow.get(); }
170     const Length&amp; cx() const { return m_layoutData-&gt;cx; }
171     const Length&amp; cy() const { return m_layoutData-&gt;cy; }
172     const Length&amp; r() const { return m_layoutData-&gt;r; }
173     const Length&amp; rx() const { return m_layoutData-&gt;rx; }
174     const Length&amp; ry() const { return m_layoutData-&gt;ry; }
175     const Length&amp; x() const { return m_layoutData-&gt;x; }
176     const Length&amp; y() const { return m_layoutData-&gt;y; }
<span class="line-removed">177     const String&amp; clipperResource() const { return m_nonInheritedResourceData-&gt;clipper; }</span>
178     const String&amp; maskerResource() const { return m_nonInheritedResourceData-&gt;masker; }
179     const String&amp; markerStartResource() const { return m_inheritedResourceData-&gt;markerStart; }
180     const String&amp; markerMidResource() const { return m_inheritedResourceData-&gt;markerMid; }
181     const String&amp; markerEndResource() const { return m_inheritedResourceData-&gt;markerEnd; }
182     MaskType maskType() const { return static_cast&lt;MaskType&gt;(m_nonInheritedFlags.flagBits.maskType); }
183 
184     SVGPaintType visitedLinkFillPaintType() const { return static_cast&lt;SVGPaintType&gt;(m_fillData-&gt;visitedLinkPaintType); }
185     const Color&amp; visitedLinkFillPaintColor() const { return m_fillData-&gt;visitedLinkPaintColor; }
186     const String&amp; visitedLinkFillPaintUri() const { return m_fillData-&gt;visitedLinkPaintUri; }
187     SVGPaintType visitedLinkStrokePaintType() const { return static_cast&lt;SVGPaintType&gt;(m_strokeData-&gt;visitedLinkPaintType); }
188     const Color&amp; visitedLinkStrokePaintColor() const { return m_strokeData-&gt;visitedLinkPaintColor; }
189     const String&amp; visitedLinkStrokePaintUri() const { return m_strokeData-&gt;visitedLinkPaintUri; }
190 
191     // convenience
<span class="line-removed">192     bool hasClipper() const { return !clipperResource().isEmpty(); }</span>
193     bool hasMasker() const { return !maskerResource().isEmpty(); }
194     bool hasMarkers() const { return !markerStartResource().isEmpty() || !markerMidResource().isEmpty() || !markerEndResource().isEmpty(); }
195     bool hasStroke() const { return strokePaintType() != SVGPaintType::None; }
196     bool hasFill() const { return fillPaintType() != SVGPaintType::None; }
197     bool isolatesBlending() const { return hasMasker() || shadow(); }
198 
199 private:
200     SVGRenderStyle();
201     SVGRenderStyle(const SVGRenderStyle&amp;);
202 
203     enum CreateDefaultType { CreateDefault };
204     SVGRenderStyle(CreateDefaultType); // Used to create the default style.
205 
206     void setBitDefaults();
207 
208     struct InheritedFlags {
209         bool operator==(const InheritedFlags&amp;) const;
210         bool operator!=(const InheritedFlags&amp; other) const { return !(*this == other); }
211 
212         unsigned colorRendering : 2; // ColorRendering
</pre>
<hr />
<pre>
239         };
240     };
241 
242     InheritedFlags m_inheritedFlags;
243     NonInheritedFlags m_nonInheritedFlags;
244 
245     // inherited attributes
246     DataRef&lt;StyleFillData&gt; m_fillData;
247     DataRef&lt;StyleStrokeData&gt; m_strokeData;
248     DataRef&lt;StyleTextData&gt; m_textData;
249     DataRef&lt;StyleInheritedResourceData&gt; m_inheritedResourceData;
250 
251     // non-inherited attributes
252     DataRef&lt;StyleStopData&gt; m_stopData;
253     DataRef&lt;StyleMiscData&gt; m_miscData;
254     DataRef&lt;StyleShadowSVGData&gt; m_shadowData;
255     DataRef&lt;StyleLayoutData&gt; m_layoutData;
256     DataRef&lt;StyleResourceData&gt; m_nonInheritedResourceData;
257 };
258 
<span class="line-removed">259 inline SVGLengthValue SVGRenderStyle::initialBaselineShiftValue()</span>
<span class="line-removed">260 {</span>
<span class="line-removed">261     SVGLengthValue length;</span>
<span class="line-removed">262     length.newValueSpecifiedUnits(LengthTypeNumber, 0);</span>
<span class="line-removed">263     return length;</span>
<span class="line-removed">264 }</span>
<span class="line-removed">265 </span>
<span class="line-removed">266 inline SVGLengthValue SVGRenderStyle::initialKerning()</span>
<span class="line-removed">267 {</span>
<span class="line-removed">268     SVGLengthValue length;</span>
<span class="line-removed">269     length.newValueSpecifiedUnits(LengthTypeNumber, 0);</span>
<span class="line-removed">270     return length;</span>
<span class="line-removed">271 }</span>
<span class="line-removed">272 </span>
273 inline void SVGRenderStyle::setCx(const Length&amp; length)
274 {
275     if (!(m_layoutData-&gt;cx == length))
276         m_layoutData.access().cx = length;
277 }
278 
279 inline void SVGRenderStyle::setCy(const Length&amp; length)
280 {
281     if (!(m_layoutData-&gt;cy == length))
282         m_layoutData.access().cy = length;
283 }
284 
285 inline void SVGRenderStyle::setR(const Length&amp; length)
286 {
287     if (!(m_layoutData-&gt;r == length))
288         m_layoutData.access().r = length;
289 }
290 
291 inline void SVGRenderStyle::setRx(const Length&amp; length)
292 {
</pre>
<hr />
<pre>
401 }
402 
403 inline void SVGRenderStyle::setFloodColor(const Color&amp; color)
404 {
405     if (!(m_miscData-&gt;floodColor == color))
406         m_miscData.access().floodColor = color;
407 }
408 
409 inline void SVGRenderStyle::setLightingColor(const Color&amp; color)
410 {
411     if (!(m_miscData-&gt;lightingColor == color))
412         m_miscData.access().lightingColor = color;
413 }
414 
415 inline void SVGRenderStyle::setBaselineShiftValue(const SVGLengthValue&amp; shiftValue)
416 {
417     if (!(m_miscData-&gt;baselineShiftValue == shiftValue))
418         m_miscData.access().baselineShiftValue = shiftValue;
419 }
420 
<span class="line-removed">421 inline void SVGRenderStyle::setClipperResource(const String&amp; resource)</span>
<span class="line-removed">422 {</span>
<span class="line-removed">423     if (!(m_nonInheritedResourceData-&gt;clipper == resource))</span>
<span class="line-removed">424         m_nonInheritedResourceData.access().clipper = resource;</span>
<span class="line-removed">425 }</span>
<span class="line-removed">426 </span>
427 inline void SVGRenderStyle::setMaskerResource(const String&amp; resource)
428 {
429     if (!(m_nonInheritedResourceData-&gt;masker == resource))
430         m_nonInheritedResourceData.access().masker = resource;
431 }
432 
433 inline void SVGRenderStyle::setMarkerStartResource(const String&amp; resource)
434 {
435     if (!(m_inheritedResourceData-&gt;markerStart == resource))
436         m_inheritedResourceData.access().markerStart = resource;
437 }
438 
439 inline void SVGRenderStyle::setMarkerMidResource(const String&amp; resource)
440 {
441     if (!(m_inheritedResourceData-&gt;markerMid == resource))
442         m_inheritedResourceData.access().markerMid = resource;
443 }
444 
445 inline void SVGRenderStyle::setMarkerEndResource(const String&amp; resource)
446 {
</pre>
</td>
<td>
<hr />
<pre>
 13     This library is distributed in the hope that it will be useful,
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #pragma once
 25 
 26 #include &quot;DataRef.h&quot;
 27 #include &quot;RenderStyleConstants.h&quot;
 28 #include &quot;SVGRenderStyleDefs.h&quot;
 29 #include &quot;WindRule.h&quot;
 30 
 31 namespace WebCore {
 32 
<span class="line-added"> 33 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SVGRenderStyle);</span>
 34 class SVGRenderStyle : public RefCounted&lt;SVGRenderStyle&gt; {
<span class="line-added"> 35     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(SVGRenderStyle);</span>
 36 public:
 37     static Ref&lt;SVGRenderStyle&gt; createDefaultStyle();
 38     static Ref&lt;SVGRenderStyle&gt; create() { return adoptRef(*new SVGRenderStyle); }
 39     Ref&lt;SVGRenderStyle&gt; copy() const;
 40     ~SVGRenderStyle();
 41 
<span class="line-modified"> 42     bool inheritedEqual(const SVGRenderStyle&amp;) const;</span>
 43     void inheritFrom(const SVGRenderStyle&amp;);
 44     void copyNonInheritedFrom(const SVGRenderStyle&amp;);
 45 
 46     StyleDifference diff(const SVGRenderStyle&amp;) const;
 47 
 48     bool operator==(const SVGRenderStyle&amp;) const;
 49     bool operator!=(const SVGRenderStyle&amp; other) const { return !(*this == other); }
 50 
 51     // Initial values for all the properties
 52     static AlignmentBaseline initialAlignmentBaseline() { return AlignmentBaseline::Auto; }
 53     static DominantBaseline initialDominantBaseline() { return DominantBaseline::Auto; }
 54     static BaselineShift initialBaselineShift() { return BaselineShift::Baseline; }
 55     static VectorEffect initialVectorEffect() { return VectorEffect::None; }
 56     static BufferedRendering initialBufferedRendering() { return BufferedRendering::Auto; }
 57     static WindRule initialClipRule() { return WindRule::NonZero; }
 58     static ColorInterpolation initialColorInterpolation() { return ColorInterpolation::SRGB; }
 59     static ColorInterpolation initialColorInterpolationFilters() { return ColorInterpolation::LinearRGB; }
 60     static ColorRendering initialColorRendering() { return ColorRendering::Auto; }
 61     static WindRule initialFillRule() { return WindRule::NonZero; }
 62     static ShapeRendering initialShapeRendering() { return ShapeRendering::Auto; }
 63     static TextAnchor initialTextAnchor() { return TextAnchor::Start; }
 64     static GlyphOrientation initialGlyphOrientationHorizontal() { return GlyphOrientation::Degrees0; }
 65     static GlyphOrientation initialGlyphOrientationVertical() { return GlyphOrientation::Auto; }
 66     static float initialFillOpacity() { return 1; }
 67     static SVGPaintType initialFillPaintType() { return SVGPaintType::RGBColor; }
 68     static Color initialFillPaintColor() { return Color::black; }
 69     static String initialFillPaintUri() { return String(); }
 70     static float initialStrokeOpacity() { return 1; }
 71     static SVGPaintType initialStrokePaintType() { return SVGPaintType::None; }
 72     static Color initialStrokePaintColor() { return Color(); }
 73     static String initialStrokePaintUri() { return String(); }
 74     static Vector&lt;SVGLengthValue&gt; initialStrokeDashArray() { return { }; }
 75     static float initialStopOpacity() { return 1; }
 76     static Color initialStopColor() { return Color(0, 0, 0); }
 77     static float initialFloodOpacity() { return 1; }
 78     static Color initialFloodColor() { return Color(0, 0, 0); }
 79     static Color initialLightingColor() { return Color(255, 255, 255); }
 80     static ShadowData* initialShadow() { return nullptr; }

 81     static String initialMaskerResource() { return String(); }
 82     static String initialMarkerStartResource() { return String(); }
 83     static String initialMarkerMidResource() { return String(); }
 84     static String initialMarkerEndResource() { return String(); }
 85     static MaskType initialMaskType() { return MaskType::Luminance; }
<span class="line-modified"> 86     static SVGLengthValue initialBaselineShiftValue() { return SVGLengthValue(0, SVGLengthType::Number); }</span>
<span class="line-modified"> 87     static SVGLengthValue initialKerning() { return SVGLengthValue(0, SVGLengthType::Number); }</span>
 88 
 89     // SVG CSS Property setters
 90     void setAlignmentBaseline(AlignmentBaseline val) { m_nonInheritedFlags.flagBits.alignmentBaseline = static_cast&lt;unsigned&gt;(val); }
 91     void setDominantBaseline(DominantBaseline val) { m_nonInheritedFlags.flagBits.dominantBaseline = static_cast&lt;unsigned&gt;(val); }
 92     void setBaselineShift(BaselineShift val) { m_nonInheritedFlags.flagBits.baselineShift = static_cast&lt;unsigned&gt;(val); }
 93     void setVectorEffect(VectorEffect val) { m_nonInheritedFlags.flagBits.vectorEffect = static_cast&lt;unsigned&gt;(val); }
 94     void setBufferedRendering(BufferedRendering val) { m_nonInheritedFlags.flagBits.bufferedRendering = static_cast&lt;unsigned&gt;(val); }
 95     void setClipRule(WindRule val) { m_inheritedFlags.clipRule = static_cast&lt;unsigned&gt;(val); }
 96     void setColorInterpolation(ColorInterpolation val) { m_inheritedFlags.colorInterpolation = static_cast&lt;unsigned&gt;(val); }
 97     void setColorInterpolationFilters(ColorInterpolation val) { m_inheritedFlags.colorInterpolationFilters = static_cast&lt;unsigned&gt;(val); }
 98     void setColorRendering(ColorRendering val) { m_inheritedFlags.colorRendering = static_cast&lt;unsigned&gt;(val); }
 99     void setFillRule(WindRule val) { m_inheritedFlags.fillRule = static_cast&lt;unsigned&gt;(val); }
100     void setShapeRendering(ShapeRendering val) { m_inheritedFlags.shapeRendering = static_cast&lt;unsigned&gt;(val); }
101     void setTextAnchor(TextAnchor val) { m_inheritedFlags.textAnchor = static_cast&lt;unsigned&gt;(val); }
102     void setGlyphOrientationHorizontal(GlyphOrientation val) { m_inheritedFlags.glyphOrientationHorizontal = static_cast&lt;unsigned&gt;(val); }
103     void setGlyphOrientationVertical(GlyphOrientation val) { m_inheritedFlags.glyphOrientationVertical = static_cast&lt;unsigned&gt;(val); }
104     void setMaskType(MaskType val) { m_nonInheritedFlags.flagBits.maskType = static_cast&lt;unsigned&gt;(val); }
105     void setCx(const Length&amp;);
106     void setCy(const Length&amp;);
107     void setR(const Length&amp;);
</pre>
<hr />
<pre>
110     void setX(const Length&amp;);
111     void setY(const Length&amp;);
112     void setFillOpacity(float);
113     void setFillPaint(SVGPaintType, const Color&amp;, const String&amp; uri, bool applyToRegularStyle = true, bool applyToVisitedLinkStyle = false);
114     void setStrokeOpacity(float);
115     void setStrokePaint(SVGPaintType, const Color&amp;, const String&amp; uri, bool applyToRegularStyle = true, bool applyToVisitedLinkStyle = false);
116 
117     void setStrokeDashArray(const Vector&lt;SVGLengthValue&gt;&amp;);
118     void setStrokeDashOffset(const Length&amp;);
119     void setKerning(const SVGLengthValue&amp;);
120     void setStopOpacity(float);
121     void setStopColor(const Color&amp;);
122     void setFloodOpacity(float);
123     void setFloodColor(const Color&amp;);
124     void setLightingColor(const Color&amp;);
125     void setBaselineShiftValue(const SVGLengthValue&amp;);
126 
127     void setShadow(std::unique_ptr&lt;ShadowData&gt;&amp;&amp; data) { m_shadowData.access().shadow = WTFMove(data); }
128 
129     // Setters for non-inherited resources

130     void setMaskerResource(const String&amp;);
131 
132     // Setters for inherited resources
133     void setMarkerStartResource(const String&amp;);
134     void setMarkerMidResource(const String&amp;);
135     void setMarkerEndResource(const String&amp;);
136 
137     // Read accessors for all the properties
138     AlignmentBaseline alignmentBaseline() const { return static_cast&lt;AlignmentBaseline&gt;(m_nonInheritedFlags.flagBits.alignmentBaseline); }
139     DominantBaseline dominantBaseline() const { return static_cast&lt;DominantBaseline&gt;(m_nonInheritedFlags.flagBits.dominantBaseline); }
140     BaselineShift baselineShift() const { return static_cast&lt;BaselineShift&gt;(m_nonInheritedFlags.flagBits.baselineShift); }
141     VectorEffect vectorEffect() const { return static_cast&lt;VectorEffect&gt;(m_nonInheritedFlags.flagBits.vectorEffect); }
142     BufferedRendering bufferedRendering() const { return static_cast&lt;BufferedRendering&gt;(m_nonInheritedFlags.flagBits.bufferedRendering); }
143     WindRule clipRule() const { return static_cast&lt;WindRule&gt;(m_inheritedFlags.clipRule); }
144     ColorInterpolation colorInterpolation() const { return static_cast&lt;ColorInterpolation&gt;(m_inheritedFlags.colorInterpolation); }
145     ColorInterpolation colorInterpolationFilters() const { return static_cast&lt;ColorInterpolation&gt;(m_inheritedFlags.colorInterpolationFilters); }
146     ColorRendering colorRendering() const { return static_cast&lt;ColorRendering&gt;(m_inheritedFlags.colorRendering); }
147     WindRule fillRule() const { return static_cast&lt;WindRule&gt;(m_inheritedFlags.fillRule); }
148     ShapeRendering shapeRendering() const { return static_cast&lt;ShapeRendering&gt;(m_inheritedFlags.shapeRendering); }
149     TextAnchor textAnchor() const { return static_cast&lt;TextAnchor&gt;(m_inheritedFlags.textAnchor); }
</pre>
<hr />
<pre>
157     SVGPaintType strokePaintType() const { return static_cast&lt;SVGPaintType&gt;(m_strokeData-&gt;paintType); }
158     const Color&amp; strokePaintColor() const { return m_strokeData-&gt;paintColor; }
159     const String&amp; strokePaintUri() const { return m_strokeData-&gt;paintUri; }
160     Vector&lt;SVGLengthValue&gt; strokeDashArray() const { return m_strokeData-&gt;dashArray; }
161     const Length&amp; strokeDashOffset() const { return m_strokeData-&gt;dashOffset; }
162     SVGLengthValue kerning() const { return m_textData-&gt;kerning; }
163     float stopOpacity() const { return m_stopData-&gt;opacity; }
164     const Color&amp; stopColor() const { return m_stopData-&gt;color; }
165     float floodOpacity() const { return m_miscData-&gt;floodOpacity; }
166     const Color&amp; floodColor() const { return m_miscData-&gt;floodColor; }
167     const Color&amp; lightingColor() const { return m_miscData-&gt;lightingColor; }
168     SVGLengthValue baselineShiftValue() const { return m_miscData-&gt;baselineShiftValue; }
169     ShadowData* shadow() const { return m_shadowData-&gt;shadow.get(); }
170     const Length&amp; cx() const { return m_layoutData-&gt;cx; }
171     const Length&amp; cy() const { return m_layoutData-&gt;cy; }
172     const Length&amp; r() const { return m_layoutData-&gt;r; }
173     const Length&amp; rx() const { return m_layoutData-&gt;rx; }
174     const Length&amp; ry() const { return m_layoutData-&gt;ry; }
175     const Length&amp; x() const { return m_layoutData-&gt;x; }
176     const Length&amp; y() const { return m_layoutData-&gt;y; }

177     const String&amp; maskerResource() const { return m_nonInheritedResourceData-&gt;masker; }
178     const String&amp; markerStartResource() const { return m_inheritedResourceData-&gt;markerStart; }
179     const String&amp; markerMidResource() const { return m_inheritedResourceData-&gt;markerMid; }
180     const String&amp; markerEndResource() const { return m_inheritedResourceData-&gt;markerEnd; }
181     MaskType maskType() const { return static_cast&lt;MaskType&gt;(m_nonInheritedFlags.flagBits.maskType); }
182 
183     SVGPaintType visitedLinkFillPaintType() const { return static_cast&lt;SVGPaintType&gt;(m_fillData-&gt;visitedLinkPaintType); }
184     const Color&amp; visitedLinkFillPaintColor() const { return m_fillData-&gt;visitedLinkPaintColor; }
185     const String&amp; visitedLinkFillPaintUri() const { return m_fillData-&gt;visitedLinkPaintUri; }
186     SVGPaintType visitedLinkStrokePaintType() const { return static_cast&lt;SVGPaintType&gt;(m_strokeData-&gt;visitedLinkPaintType); }
187     const Color&amp; visitedLinkStrokePaintColor() const { return m_strokeData-&gt;visitedLinkPaintColor; }
188     const String&amp; visitedLinkStrokePaintUri() const { return m_strokeData-&gt;visitedLinkPaintUri; }
189 
190     // convenience

191     bool hasMasker() const { return !maskerResource().isEmpty(); }
192     bool hasMarkers() const { return !markerStartResource().isEmpty() || !markerMidResource().isEmpty() || !markerEndResource().isEmpty(); }
193     bool hasStroke() const { return strokePaintType() != SVGPaintType::None; }
194     bool hasFill() const { return fillPaintType() != SVGPaintType::None; }
195     bool isolatesBlending() const { return hasMasker() || shadow(); }
196 
197 private:
198     SVGRenderStyle();
199     SVGRenderStyle(const SVGRenderStyle&amp;);
200 
201     enum CreateDefaultType { CreateDefault };
202     SVGRenderStyle(CreateDefaultType); // Used to create the default style.
203 
204     void setBitDefaults();
205 
206     struct InheritedFlags {
207         bool operator==(const InheritedFlags&amp;) const;
208         bool operator!=(const InheritedFlags&amp; other) const { return !(*this == other); }
209 
210         unsigned colorRendering : 2; // ColorRendering
</pre>
<hr />
<pre>
237         };
238     };
239 
240     InheritedFlags m_inheritedFlags;
241     NonInheritedFlags m_nonInheritedFlags;
242 
243     // inherited attributes
244     DataRef&lt;StyleFillData&gt; m_fillData;
245     DataRef&lt;StyleStrokeData&gt; m_strokeData;
246     DataRef&lt;StyleTextData&gt; m_textData;
247     DataRef&lt;StyleInheritedResourceData&gt; m_inheritedResourceData;
248 
249     // non-inherited attributes
250     DataRef&lt;StyleStopData&gt; m_stopData;
251     DataRef&lt;StyleMiscData&gt; m_miscData;
252     DataRef&lt;StyleShadowSVGData&gt; m_shadowData;
253     DataRef&lt;StyleLayoutData&gt; m_layoutData;
254     DataRef&lt;StyleResourceData&gt; m_nonInheritedResourceData;
255 };
256 














257 inline void SVGRenderStyle::setCx(const Length&amp; length)
258 {
259     if (!(m_layoutData-&gt;cx == length))
260         m_layoutData.access().cx = length;
261 }
262 
263 inline void SVGRenderStyle::setCy(const Length&amp; length)
264 {
265     if (!(m_layoutData-&gt;cy == length))
266         m_layoutData.access().cy = length;
267 }
268 
269 inline void SVGRenderStyle::setR(const Length&amp; length)
270 {
271     if (!(m_layoutData-&gt;r == length))
272         m_layoutData.access().r = length;
273 }
274 
275 inline void SVGRenderStyle::setRx(const Length&amp; length)
276 {
</pre>
<hr />
<pre>
385 }
386 
387 inline void SVGRenderStyle::setFloodColor(const Color&amp; color)
388 {
389     if (!(m_miscData-&gt;floodColor == color))
390         m_miscData.access().floodColor = color;
391 }
392 
393 inline void SVGRenderStyle::setLightingColor(const Color&amp; color)
394 {
395     if (!(m_miscData-&gt;lightingColor == color))
396         m_miscData.access().lightingColor = color;
397 }
398 
399 inline void SVGRenderStyle::setBaselineShiftValue(const SVGLengthValue&amp; shiftValue)
400 {
401     if (!(m_miscData-&gt;baselineShiftValue == shiftValue))
402         m_miscData.access().baselineShiftValue = shiftValue;
403 }
404 






405 inline void SVGRenderStyle::setMaskerResource(const String&amp; resource)
406 {
407     if (!(m_nonInheritedResourceData-&gt;masker == resource))
408         m_nonInheritedResourceData.access().masker = resource;
409 }
410 
411 inline void SVGRenderStyle::setMarkerStartResource(const String&amp; resource)
412 {
413     if (!(m_inheritedResourceData-&gt;markerStart == resource))
414         m_inheritedResourceData.access().markerStart = resource;
415 }
416 
417 inline void SVGRenderStyle::setMarkerMidResource(const String&amp; resource)
418 {
419     if (!(m_inheritedResourceData-&gt;markerMid == resource))
420         m_inheritedResourceData.access().markerMid = resource;
421 }
422 
423 inline void SVGRenderStyle::setMarkerEndResource(const String&amp; resource)
424 {
</pre>
</td>
</tr>
</table>
<center><a href="SVGRenderStyle.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderStyleDefs.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
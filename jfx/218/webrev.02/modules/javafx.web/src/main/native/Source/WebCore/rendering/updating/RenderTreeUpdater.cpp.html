<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeUpdater.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeUpdater.h&quot;
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;CSSAnimationController.h&quot;
 31 #include &quot;ComposedTreeAncestorIterator.h&quot;
 32 #include &quot;ComposedTreeIterator.h&quot;
 33 #include &quot;Document.h&quot;
 34 #include &quot;DocumentTimeline.h&quot;
 35 #include &quot;Element.h&quot;
 36 #include &quot;FullscreenManager.h&quot;
 37 #include &quot;HTMLParserIdioms.h&quot;
 38 #include &quot;HTMLSlotElement.h&quot;
 39 #include &quot;InspectorInstrumentation.h&quot;
 40 #include &quot;NodeRenderStyle.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderDescendantIterator.h&quot;
 43 #include &quot;RenderFullScreen.h&quot;
 44 #include &quot;RenderInline.h&quot;
 45 #include &quot;RenderMultiColumnFlow.h&quot;
 46 #include &quot;RenderMultiColumnSet.h&quot;
 47 #include &quot;RenderTreeUpdaterGeneratedContent.h&quot;
 48 #include &quot;RenderView.h&quot;
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;StyleResolver.h&quot;
 51 #include &quot;StyleTreeResolver.h&quot;
 52 #include &quot;TextManipulationController.h&quot;
 53 #include &lt;wtf/SystemTracing.h&gt;
 54 
 55 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 56 #include &quot;FrameView.h&quot;
 57 #include &quot;FrameViewLayoutContext.h&quot;
 58 #include &quot;LayoutState.h&quot;
 59 #include &quot;LayoutTreeBuilder.h&quot;
 60 #endif
 61 
 62 #if PLATFORM(IOS_FAMILY)
 63 #include &quot;ContentChangeObserver.h&quot;
 64 #endif
 65 
 66 namespace WebCore {
 67 
 68 RenderTreeUpdater::Parent::Parent(ContainerNode&amp; root)
 69     : element(is&lt;Document&gt;(root) ? nullptr : downcast&lt;Element&gt;(&amp;root))
 70     , renderTreePosition(RenderTreePosition(*root.renderer()))
 71 {
 72 }
 73 
 74 RenderTreeUpdater::Parent::Parent(Element&amp; element, const Style::ElementUpdates* updates)
 75     : element(&amp;element)
 76     , updates(updates)
 77     , renderTreePosition(element.renderer() ? makeOptional(RenderTreePosition(*element.renderer())) : WTF::nullopt)
 78 {
 79 }
 80 
 81 RenderTreeUpdater::RenderTreeUpdater(Document&amp; document)
 82     : m_document(document)
 83     , m_generatedContent(makeUnique&lt;GeneratedContent&gt;(*this))
 84     , m_builder(renderView())
 85 {
 86 }
 87 
 88 RenderTreeUpdater::~RenderTreeUpdater() = default;
 89 
 90 static ContainerNode* findRenderingRoot(ContainerNode&amp; node)
 91 {
 92     if (node.renderer())
 93         return &amp;node;
 94     for (auto&amp; ancestor : composedTreeAncestors(node)) {
 95         if (ancestor.renderer())
 96             return &amp;ancestor;
 97         if (!ancestor.hasDisplayContents())
 98             return nullptr;
 99     }
100     return &amp;node.document();
101 }
102 
103 static ListHashSet&lt;ContainerNode*&gt; findRenderingRoots(const Style::Update&amp; update)
104 {
105     ListHashSet&lt;ContainerNode*&gt; renderingRoots;
106     for (auto* root : update.roots()) {
107         auto* renderingRoot = findRenderingRoot(*root);
108         if (!renderingRoot)
109             continue;
110         renderingRoots.add(renderingRoot);
111     }
112     return renderingRoots;
113 }
114 
115 void RenderTreeUpdater::commit(std::unique_ptr&lt;const Style::Update&gt; styleUpdate)
116 {
117     ASSERT(&amp;m_document == &amp;styleUpdate-&gt;document());
118 
119     if (!m_document.shouldCreateRenderers() || !m_document.renderView())
120         return;
121 
122     TraceScope scope(RenderTreeBuildStart, RenderTreeBuildEnd);
123 
124     Style::PostResolutionCallbackDisabler callbackDisabler(m_document);
125 
126     m_styleUpdate = WTFMove(styleUpdate);
127 
128     for (auto* root : findRenderingRoots(*m_styleUpdate))
129         updateRenderTree(*root);
130 
131     generatedContent().updateRemainingQuotes();
132 
133     m_builder.updateAfterDescendants(renderView());
134 
135     m_styleUpdate = nullptr;
136 }
137 
138 static bool shouldCreateRenderer(const Element&amp; element, const RenderElement&amp; parentRenderer)
139 {
140     if (!parentRenderer.canHaveChildren() &amp;&amp; !(element.isPseudoElement() &amp;&amp; parentRenderer.canHaveGeneratedChildren()))
141         return false;
142     if (parentRenderer.element() &amp;&amp; !parentRenderer.element()-&gt;childShouldCreateRenderer(element))
143         return false;
144     return true;
145 }
146 
147 void RenderTreeUpdater::updateRenderTree(ContainerNode&amp; root)
148 {
149     ASSERT(root.renderer());
150     ASSERT(m_parentStack.isEmpty());
151 
152     m_parentStack.append(Parent(root));
153 
154     auto descendants = composedTreeDescendants(root);
155     auto it = descendants.begin();
156     auto end = descendants.end();
157 
158     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156172
159     it.dropAssertions();
160 
161     while (it != end) {
162         popParentsToDepth(it.depth());
163 
164         auto&amp; node = *it;
165 
166         if (auto* renderer = node.renderer())
167             renderTreePosition().invalidateNextSibling(*renderer);
168         else if (is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents())
169             renderTreePosition().invalidateNextSibling();
170 
171         if (is&lt;Text&gt;(node)) {
172             auto&amp; text = downcast&lt;Text&gt;(node);
173             auto* textUpdate = m_styleUpdate-&gt;textUpdate(text);
174             bool didCreateParent = parent().updates &amp;&amp; parent().updates-&gt;update.change == Style::Detach;
175             bool mayNeedUpdateWhitespaceOnlyRenderer = renderingParent().didCreateOrDestroyChildRenderer &amp;&amp; text.data().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
176             if (didCreateParent || textUpdate || mayNeedUpdateWhitespaceOnlyRenderer)
177                 updateTextRenderer(text, textUpdate);
178 
179             storePreviousRenderer(text);
180             it.traverseNextSkippingChildren();
181             continue;
182         }
183 
184         auto&amp; element = downcast&lt;Element&gt;(node);
185 
186         auto* elementUpdates = m_styleUpdate-&gt;elementUpdates(element);
187 
188         // We hop through display: contents elements in findRenderingRoot, so
189         // there may be other updates down the tree.
190         if (!elementUpdates &amp;&amp; !element.hasDisplayContents()) {
191             storePreviousRenderer(element);
192             it.traverseNextSkippingChildren();
193             continue;
194         }
195 
196         if (elementUpdates)
197             updateElementRenderer(element, elementUpdates-&gt;update);
198 
199         storePreviousRenderer(element);
200 
201         bool mayHaveRenderedDescendants = element.renderer() || (element.hasDisplayContents() &amp;&amp; shouldCreateRenderer(element, renderTreePosition().parent()));
202         if (!mayHaveRenderedDescendants) {
203             it.traverseNextSkippingChildren();
204             continue;
205         }
206 
207         pushParent(element, elementUpdates);
208 
209         it.traverseNext();
210     }
211 
212     popParentsToDepth(0);
213 }
214 
215 auto RenderTreeUpdater::renderingParent() -&gt; Parent&amp;
216 {
217     for (unsigned i = m_parentStack.size(); i--;) {
218         if (m_parentStack[i].renderTreePosition)
219             return m_parentStack[i];
220     }
221     ASSERT_NOT_REACHED();
222     return m_parentStack.last();
223 }
224 
225 RenderTreePosition&amp; RenderTreeUpdater::renderTreePosition()
226 {
227     return *renderingParent().renderTreePosition;
228 }
229 
230 void RenderTreeUpdater::pushParent(Element&amp; element, const Style::ElementUpdates* updates)
231 {
232     m_parentStack.append(Parent(element, updates));
233 
234     updateBeforeDescendants(element, updates);
235 }
236 
237 void RenderTreeUpdater::popParent()
238 {
239     auto&amp; parent = m_parentStack.last();
240     if (parent.element)
241         updateAfterDescendants(*parent.element, parent.updates);
242 
243     m_parentStack.removeLast();
244 }
245 
246 void RenderTreeUpdater::popParentsToDepth(unsigned depth)
247 {
248     ASSERT(m_parentStack.size() &gt;= depth);
249 
250     while (m_parentStack.size() &gt; depth)
251         popParent();
252 }
253 
254 void RenderTreeUpdater::updateBeforeDescendants(Element&amp; element, const Style::ElementUpdates* updates)
255 {
256     if (updates)
257         generatedContent().updatePseudoElement(element, updates-&gt;beforePseudoElementUpdate, PseudoId::Before);
258 }
259 
260 void RenderTreeUpdater::updateAfterDescendants(Element&amp; element, const Style::ElementUpdates* updates)
261 {
262     if (updates)
263         generatedContent().updatePseudoElement(element, updates-&gt;afterPseudoElementUpdate, PseudoId::After);
264 
265     auto* renderer = element.renderer();
266     if (!renderer)
267         return;
268 
269     m_builder.updateAfterDescendants(*renderer);
270 
271     if (element.hasCustomStyleResolveCallbacks() &amp;&amp; updates &amp;&amp; updates-&gt;update.change == Style::Detach)
272         element.didAttachRenderers();
273 }
274 
275 static bool pseudoStyleCacheIsInvalid(RenderElement* renderer, RenderStyle* newStyle)
276 {
277     const RenderStyle&amp; currentStyle = renderer-&gt;style();
278 
279     const PseudoStyleCache* pseudoStyleCache = currentStyle.cachedPseudoStyles();
280     if (!pseudoStyleCache)
281         return false;
282 
283     for (auto&amp; cache : *pseudoStyleCache) {
284         PseudoId pseudoId = cache-&gt;styleType();
285         std::unique_ptr&lt;RenderStyle&gt; newPseudoStyle = renderer-&gt;getUncachedPseudoStyle({ pseudoId }, newStyle, newStyle);
286         if (!newPseudoStyle)
287             return true;
288         if (*newPseudoStyle != *cache) {
289             newStyle-&gt;addCachedPseudoStyle(WTFMove(newPseudoStyle));
290             return true;
291         }
292     }
293     return false;
294 }
295 
296 void RenderTreeUpdater::updateRendererStyle(RenderElement&amp; renderer, RenderStyle&amp;&amp; newStyle, StyleDifference minimalStyleDifference)
297 {
298     auto oldStyle = RenderStyle::clone(renderer.style());
299     renderer.setStyle(WTFMove(newStyle), minimalStyleDifference);
300     m_builder.normalizeTreeAfterStyleChange(renderer, oldStyle);
301 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
302     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {
303         if (!m_document.view() || !m_document.view()-&gt;layoutContext().layoutTreeContent())
304             return;
305         if (auto* layoutBox = m_document.view()-&gt;layoutContext().layoutTreeContent()-&gt;layoutBoxForRenderer(renderer))
306             layoutBox-&gt;updateStyle(renderer.style());
307     }
308 #endif
309 }
310 
311 void RenderTreeUpdater::updateElementRenderer(Element&amp; element, const Style::ElementUpdate&amp; update)
312 {
313 #if PLATFORM(IOS_FAMILY)
314     ContentChangeObserver::StyleChangeScope observingScope(m_document, element);
315 #endif
316 
317     bool shouldTearDownRenderers = update.change == Style::Detach &amp;&amp; (element.renderer() || element.hasDisplayContents());
318     if (shouldTearDownRenderers) {
319         if (!element.renderer()) {
320             // We may be tearing down a descendant renderer cached in renderTreePosition.
321             renderTreePosition().invalidateNextSibling();
322         }
323 
324         // display:none cancels animations.
325         auto teardownType = update.style-&gt;display() == DisplayType::None ? TeardownType::RendererUpdateCancelingAnimations : TeardownType::RendererUpdate;
326         tearDownRenderers(element, teardownType, m_builder);
327 
328         renderingParent().didCreateOrDestroyChildRenderer = true;
329     }
330 
331     bool hasDisplayContents = update.style-&gt;display() == DisplayType::Contents;
332     if (hasDisplayContents)
333         element.storeDisplayContentsStyle(RenderStyle::clonePtr(*update.style));
334     else
335         element.resetComputedStyle();
336 
337     bool shouldCreateNewRenderer = !element.renderer() &amp;&amp; !hasDisplayContents;
338     if (shouldCreateNewRenderer) {
339         if (element.hasCustomStyleResolveCallbacks())
340             element.willAttachRenderers();
341         createRenderer(element, RenderStyle::clone(*update.style));
342 
343         renderingParent().didCreateOrDestroyChildRenderer = true;
344         return;
345     }
346 
347     if (!element.renderer())
348         return;
349     auto&amp; renderer = *element.renderer();
350 
351     if (update.recompositeLayer) {
352         updateRendererStyle(renderer, RenderStyle::clone(*update.style), StyleDifference::RecompositeLayer);
353         return;
354     }
355 
356     if (update.change == Style::NoChange) {
357         if (pseudoStyleCacheIsInvalid(&amp;renderer, update.style.get())) {
358             updateRendererStyle(renderer, RenderStyle::clone(*update.style), StyleDifference::Equal);
359             return;
360         }
361         return;
362     }
363 
364     updateRendererStyle(renderer, RenderStyle::clone(*update.style), StyleDifference::Equal);
365 }
366 
367 void RenderTreeUpdater::createRenderer(Element&amp; element, RenderStyle&amp;&amp; style)
368 {
369     auto computeInsertionPosition = [this, &amp;element] () {
370         renderTreePosition().computeNextSibling(element);
371         return renderTreePosition();
372     };
373 
374     if (!shouldCreateRenderer(element, renderTreePosition().parent()))
375         return;
376 
377     if (!element.rendererIsNeeded(style))
378         return;
379 
380     RenderTreePosition insertionPosition = computeInsertionPosition();
381     auto newRenderer = element.createElementRenderer(WTFMove(style), insertionPosition);
382     if (!newRenderer)
383         return;
384 
385     if (!insertionPosition.parent().isChildAllowed(*newRenderer, newRenderer-&gt;style()))
386         return;
387 
388     element.setRenderer(newRenderer.get());
389 
390     newRenderer-&gt;initializeStyle();
391 
392 #if ENABLE(FULLSCREEN_API)
393     if (m_document.fullscreenManager().isFullscreen() &amp;&amp; m_document.fullscreenManager().currentFullscreenElement() == &amp;element) {
394         newRenderer = RenderFullScreen::wrapNewRenderer(m_builder, WTFMove(newRenderer), insertionPosition.parent(), m_document);
395         if (!newRenderer)
396             return;
397     }
398 #endif
399 
400     m_builder.attach(insertionPosition, WTFMove(newRenderer));
401 
402     auto* textManipulationController = m_document.textManipulationControllerIfExists();
403     if (UNLIKELY(textManipulationController))
404         textManipulationController-&gt;didCreateRendererForElement(element);
405 
406     if (AXObjectCache* cache = m_document.axObjectCache())
407         cache-&gt;updateCacheAfterNodeIsAttached(&amp;element);
408 }
409 
410 bool RenderTreeUpdater::textRendererIsNeeded(const Text&amp; textNode)
411 {
412     auto&amp; renderingParent = this-&gt;renderingParent();
413     auto&amp; parentRenderer = renderingParent.renderTreePosition-&gt;parent();
414     if (!parentRenderer.canHaveChildren())
415         return false;
416     if (parentRenderer.element() &amp;&amp; !parentRenderer.element()-&gt;childShouldCreateRenderer(textNode))
417         return false;
418     if (textNode.isEditingText())
419         return true;
420     if (!textNode.length())
421         return false;
422     if (!textNode.data().isAllSpecialCharacters&lt;isHTMLSpace&gt;())
423         return true;
424     if (is&lt;RenderText&gt;(renderingParent.previousChildRenderer))
425         return true;
426     // This text node has nothing but white space. We may still need a renderer in some cases.
427     if (parentRenderer.isTable() || parentRenderer.isTableRow() || parentRenderer.isTableSection() || parentRenderer.isRenderTableCol() || parentRenderer.isFrameSet())
428         return false;
429     if (parentRenderer.isFlexibleBox() &amp;&amp; !parentRenderer.isRenderButton())
430         return false;
431     if (parentRenderer.style().preserveNewline()) // pre/pre-wrap/pre-line always make renderers.
432         return true;
433 
434     auto* previousRenderer = renderingParent.previousChildRenderer;
435     if (previousRenderer &amp;&amp; previousRenderer-&gt;isBR()) // &lt;span&gt;&lt;br/&gt; &lt;br/&gt;&lt;/span&gt;
436         return false;
437 
438     if (parentRenderer.isRenderInline()) {
439         // &lt;span&gt;&lt;div/&gt; &lt;div/&gt;&lt;/span&gt;
440         if (previousRenderer &amp;&amp; !previousRenderer-&gt;isInline())
441             return false;
442     } else {
443         if (parentRenderer.isRenderBlock() &amp;&amp; !parentRenderer.childrenInline() &amp;&amp; (!previousRenderer || !previousRenderer-&gt;isInline()))
444             return false;
445 
446         RenderObject* first = parentRenderer.firstChild();
447         while (first &amp;&amp; first-&gt;isFloatingOrOutOfFlowPositioned())
448             first = first-&gt;nextSibling();
449         RenderObject* nextRenderer = textNode.renderer() ? textNode.renderer() :  renderTreePosition().nextSiblingRenderer(textNode);
450         if (!first || nextRenderer == first) {
451             // Whitespace at the start of a block just goes away. Don&#39;t even make a render object for this text.
452             return false;
453         }
454     }
455     return true;
456 }
457 
458 void RenderTreeUpdater::createTextRenderer(Text&amp; textNode, const Style::TextUpdate* textUpdate)
459 {
460     ASSERT(!textNode.renderer());
461 
462     auto&amp; renderTreePosition = this-&gt;renderTreePosition();
463     auto textRenderer = textNode.createTextRenderer(renderTreePosition.parent().style());
464 
465     renderTreePosition.computeNextSibling(textNode);
466 
467     if (!renderTreePosition.parent().isChildAllowed(*textRenderer, renderTreePosition.parent().style()))
468         return;
469 
470     textNode.setRenderer(textRenderer.get());
471 
472     if (textUpdate &amp;&amp; textUpdate-&gt;inheritedDisplayContentsStyle &amp;&amp; *textUpdate-&gt;inheritedDisplayContentsStyle) {
473         // Wrap text renderer into anonymous inline so we can give it a style.
474         // This is to support &quot;&lt;div style=&#39;display:contents;color:green&#39;&gt;text&lt;/div&gt;&quot; type cases
475         auto newDisplayContentsAnonymousWrapper = WebCore::createRenderer&lt;RenderInline&gt;(textNode.document(), RenderStyle::clone(**textUpdate-&gt;inheritedDisplayContentsStyle));
476         newDisplayContentsAnonymousWrapper-&gt;initializeStyle();
477         auto&amp; displayContentsAnonymousWrapper = *newDisplayContentsAnonymousWrapper;
478         m_builder.attach(renderTreePosition, WTFMove(newDisplayContentsAnonymousWrapper));
479 
480         textRenderer-&gt;setInlineWrapperForDisplayContents(&amp;displayContentsAnonymousWrapper);
481         m_builder.attach(displayContentsAnonymousWrapper, WTFMove(textRenderer));
482         return;
483     }
484 
485     m_builder.attach(renderTreePosition, WTFMove(textRenderer));
486 }
487 
488 void RenderTreeUpdater::updateTextRenderer(Text&amp; text, const Style::TextUpdate* textUpdate)
489 {
490     auto* existingRenderer = text.renderer();
491     bool needsRenderer = textRendererIsNeeded(text);
492 
493     if (existingRenderer &amp;&amp; textUpdate &amp;&amp; textUpdate-&gt;inheritedDisplayContentsStyle) {
494         if (existingRenderer-&gt;inlineWrapperForDisplayContents() || *textUpdate-&gt;inheritedDisplayContentsStyle) {
495             // FIXME: We could update without teardown.
496             tearDownTextRenderer(text, m_builder);
497             existingRenderer = nullptr;
498         }
499     }
500 
501     if (existingRenderer) {
502         if (needsRenderer) {
503             if (textUpdate)
504                 existingRenderer-&gt;setTextWithOffset(text.data(), textUpdate-&gt;offset, textUpdate-&gt;length);
505             return;
506         }
507         tearDownTextRenderer(text, m_builder);
508         renderingParent().didCreateOrDestroyChildRenderer = true;
509         return;
510     }
511     if (!needsRenderer)
512         return;
513     createTextRenderer(text, textUpdate);
514     renderingParent().didCreateOrDestroyChildRenderer = true;
515 }
516 
517 void RenderTreeUpdater::storePreviousRenderer(Node&amp; node)
518 {
519     auto* renderer = node.renderer();
520     if (!renderer)
521         return;
522     ASSERT(renderingParent().previousChildRenderer != renderer);
523     renderingParent().previousChildRenderer = renderer;
524 }
525 
526 void RenderTreeUpdater::tearDownRenderers(Element&amp; root)
527 {
528     auto* view = root.document().renderView();
529     if (!view)
530         return;
531     RenderTreeBuilder builder(*view);
532     tearDownRenderers(root, TeardownType::Full, builder);
533 }
534 
535 void RenderTreeUpdater::tearDownRenderer(Text&amp; text)
536 {
537     auto* view = text.document().renderView();
538     if (!view)
539         return;
540     RenderTreeBuilder builder(*view);
541     tearDownTextRenderer(text, builder);
542 }
543 
544 void RenderTreeUpdater::tearDownRenderers(Element&amp; root, TeardownType teardownType, RenderTreeBuilder&amp; builder)
545 {
546     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
547 
548     Vector&lt;Element*, 30&gt; teardownStack;
549 
550     auto push = [&amp;] (Element&amp; element) {
551         if (element.hasCustomStyleResolveCallbacks())
552             element.willDetachRenderers();
553         teardownStack.append(&amp;element);
554     };
555 
556     auto&amp; document = root.document();
557     auto* timeline = document.existingTimeline();
558     auto&amp; animationController = document.frame()-&gt;animation();
559 
560     auto pop = [&amp;] (unsigned depth) {
561         while (teardownStack.size() &gt; depth) {
562             auto&amp; element = *teardownStack.takeLast();
563 
564             // Make sure we don&#39;t leave any renderers behind in nodes outside the composed tree.
565             if (element.shadowRoot())
566                 tearDownLeftoverShadowHostChildren(element, builder);
567 
568             switch (teardownType) {
569             case TeardownType::Full:
570             case TeardownType::RendererUpdateCancelingAnimations:
571                 if (timeline) {
572                     if (document.renderTreeBeingDestroyed())
573                         timeline-&gt;willDestroyRendererForElement(element);
574                     else if (teardownType == TeardownType::RendererUpdateCancelingAnimations)
575                         timeline-&gt;cancelDeclarativeAnimationsForElement(element);
576                 }
577                 animationController.cancelAnimations(element);
578                 break;
579             case TeardownType::RendererUpdate:
580                 if (timeline)
581                     timeline-&gt;willChangeRendererForElement(element);
582                 break;
583             }
584 
585             if (teardownType == TeardownType::Full)
586                 element.clearHoverAndActiveStatusBeforeDetachingRenderer();
587 
588             GeneratedContent::removeBeforePseudoElement(element, builder);
589             GeneratedContent::removeAfterPseudoElement(element, builder);
590 
591             if (auto* renderer = element.renderer()) {
592                 builder.destroyAndCleanUpAnonymousWrappers(*renderer);
593                 element.setRenderer(nullptr);
594             }
595 
596             if (element.hasCustomStyleResolveCallbacks())
597                 element.didDetachRenderers();
598         }
599     };
600 
601     push(root);
602 
603     auto descendants = composedTreeDescendants(root);
604     for (auto it = descendants.begin(), end = descendants.end(); it != end; ++it) {
605         pop(it.depth());
606 
607         if (is&lt;Text&gt;(*it)) {
608             tearDownTextRenderer(downcast&lt;Text&gt;(*it), builder);
609             continue;
610         }
611 
612         push(downcast&lt;Element&gt;(*it));
613     }
614 
615     pop(0);
616 
617     tearDownLeftoverPaginationRenderersIfNeeded(root, builder);
618 }
619 
620 void RenderTreeUpdater::tearDownTextRenderer(Text&amp; text, RenderTreeBuilder&amp; builder)
621 {
622     auto* renderer = text.renderer();
623     if (!renderer)
624         return;
625     builder.destroyAndCleanUpAnonymousWrappers(*renderer);
626     text.setRenderer(nullptr);
627 }
628 
629 void RenderTreeUpdater::tearDownLeftoverPaginationRenderersIfNeeded(Element&amp; root, RenderTreeBuilder&amp; builder)
630 {
631     if (&amp;root != root.document().documentElement())
632         return;
633     for (auto* child = root.document().renderView()-&gt;firstChild(); child;) {
634         auto* nextSibling = child-&gt;nextSibling();
635         if (is&lt;RenderMultiColumnFlow&gt;(*child) || is&lt;RenderMultiColumnSet&gt;(*child))
636             builder.destroyAndCleanUpAnonymousWrappers(*child);
637         child = nextSibling;
638     }
639 }
640 
641 void RenderTreeUpdater::tearDownLeftoverShadowHostChildren(Element&amp; host, RenderTreeBuilder&amp; builder)
642 {
643     for (auto* hostChild = host.firstChild(); hostChild; hostChild = hostChild-&gt;nextSibling()) {
644         if (!hostChild-&gt;renderer())
645             continue;
646         if (is&lt;Text&gt;(*hostChild)) {
647             tearDownTextRenderer(downcast&lt;Text&gt;(*hostChild), builder);
648             continue;
649         }
650         if (is&lt;Element&gt;(*hostChild))
651             tearDownRenderers(downcast&lt;Element&gt;(*hostChild), TeardownType::Full, builder);
652     }
653 }
654 
655 RenderView&amp; RenderTreeUpdater::renderView()
656 {
657     return *m_document.renderView();
658 }
659 
660 }
    </pre>
  </body>
</html>
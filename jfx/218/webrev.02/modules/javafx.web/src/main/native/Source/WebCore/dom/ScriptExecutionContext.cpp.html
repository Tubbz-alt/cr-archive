<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2012 Google Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ScriptExecutionContext.h&quot;
 30 
 31 #include &quot;CachedScript.h&quot;
 32 #include &quot;CommonVM.h&quot;
 33 #include &quot;DOMTimer.h&quot;
 34 #include &quot;DOMWindow.h&quot;
 35 #include &quot;DatabaseContext.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;ErrorEvent.h&quot;
 38 #include &quot;JSDOMExceptionHandling.h&quot;
 39 #include &quot;JSDOMWindow.h&quot;
 40 #include &quot;LegacySchemeRegistry.h&quot;
 41 #include &quot;MessagePort.h&quot;
 42 #include &quot;Navigator.h&quot;
 43 #include &quot;Page.h&quot;
 44 #include &quot;PublicURLManager.h&quot;
 45 #include &quot;RejectedPromiseTracker.h&quot;
 46 #include &quot;ResourceRequest.h&quot;
 47 #include &quot;SWClientConnection.h&quot;
 48 #include &quot;SWContextManager.h&quot;
 49 #include &quot;ScriptController.h&quot;
 50 #include &quot;ScriptDisallowedScope.h&quot;
 51 #include &quot;ScriptState.h&quot;
 52 #include &quot;ServiceWorker.h&quot;
 53 #include &quot;ServiceWorkerGlobalScope.h&quot;
 54 #include &quot;ServiceWorkerProvider.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;WorkerGlobalScope.h&quot;
 57 #include &quot;WorkerNavigator.h&quot;
 58 #include &quot;WorkerThread.h&quot;
 59 #include &quot;WorkletGlobalScope.h&quot;
 60 #include &quot;WorkletScriptController.h&quot;
 61 #include &lt;JavaScriptCore/CatchScope.h&gt;
 62 #include &lt;JavaScriptCore/Exception.h&gt;
 63 #include &lt;JavaScriptCore/JSPromise.h&gt;
 64 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 65 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 66 #include &lt;wtf/MainThread.h&gt;
 67 #include &lt;wtf/Ref.h&gt;
 68 #include &lt;wtf/SetForScope.h&gt;
 69 
 70 namespace WebCore {
 71 using namespace Inspector;
 72 
 73 static Lock allScriptExecutionContextsMapLock;
 74 static HashMap&lt;ScriptExecutionContextIdentifier, ScriptExecutionContext*&gt;&amp; allScriptExecutionContextsMap()
 75 {
 76     static NeverDestroyed&lt;HashMap&lt;ScriptExecutionContextIdentifier, ScriptExecutionContext*&gt;&gt; contexts;
 77     ASSERT(allScriptExecutionContextsMapLock.isLocked());
 78     return contexts;
 79 }
 80 
 81 struct ScriptExecutionContext::PendingException {
 82     WTF_MAKE_FAST_ALLOCATED;
 83 public:
 84     PendingException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack)
 85         : m_errorMessage(errorMessage)
 86         , m_lineNumber(lineNumber)
 87         , m_columnNumber(columnNumber)
 88         , m_sourceURL(sourceURL)
 89         , m_callStack(WTFMove(callStack))
 90     {
 91     }
 92     String m_errorMessage;
 93     int m_lineNumber;
 94     int m_columnNumber;
 95     String m_sourceURL;
 96     RefPtr&lt;ScriptCallStack&gt; m_callStack;
 97 };
 98 
 99 ScriptExecutionContext::ScriptExecutionContext()
100 {
101 }
102 
103 ScriptExecutionContextIdentifier ScriptExecutionContext::contextIdentifier() const
104 {
105     ASSERT(isContextThread());
106     if (!m_contextIdentifier) {
107         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
108 
109         m_contextIdentifier = ScriptExecutionContextIdentifier::generate();
110 
111         ASSERT(!allScriptExecutionContextsMap().contains(m_contextIdentifier));
112         allScriptExecutionContextsMap().add(m_contextIdentifier, const_cast&lt;ScriptExecutionContext*&gt;(this));
113     }
114     return m_contextIdentifier;
115 }
116 
117 void ScriptExecutionContext::removeFromContextsMap()
118 {
119     if (m_contextIdentifier) {
120         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
121         ASSERT(allScriptExecutionContextsMap().contains(m_contextIdentifier));
122         allScriptExecutionContextsMap().remove(m_contextIdentifier);
123     }
124 }
125 
126 #if !ASSERT_ENABLED
127 
128 inline void ScriptExecutionContext::checkConsistency() const
129 {
130 }
131 
132 #else // ASSERT_ENABLED
133 
134 void ScriptExecutionContext::checkConsistency() const
135 {
136     for (auto* messagePort : m_messagePorts)
137         ASSERT(messagePort-&gt;scriptExecutionContext() == this);
138 
139     for (auto* destructionObserver : m_destructionObservers)
140         ASSERT(destructionObserver-&gt;scriptExecutionContext() == this);
141 
142     for (auto* activeDOMObject : m_activeDOMObjects) {
143         ASSERT(activeDOMObject-&gt;scriptExecutionContext() == this);
144         activeDOMObject-&gt;assertSuspendIfNeededWasCalled();
145     }
146 }
147 
148 #endif // ASSERT_ENABLED
149 
150 ScriptExecutionContext::~ScriptExecutionContext()
151 {
152     checkConsistency();
153 
154 #if ASSERT_ENABLED
155     if (m_contextIdentifier) {
156         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
157         ASSERT_WITH_MESSAGE(!allScriptExecutionContextsMap().contains(m_contextIdentifier),
158             &quot;A ScriptExecutionContext subclass instance implementing postTask should have already removed itself from the map&quot;);
159     }
160 
161     m_inScriptExecutionContextDestructor = true;
162 #endif // ASSERT_ENABLED
163 
164 #if ENABLE(SERVICE_WORKER)
165     setActiveServiceWorker(nullptr);
166 #endif
167 
168     while (auto* destructionObserver = m_destructionObservers.takeAny())
169         destructionObserver-&gt;contextDestroyed();
170 
171 #if ASSERT_ENABLED
172     m_inScriptExecutionContextDestructor = false;
173 #endif
174 }
175 
176 void ScriptExecutionContext::processMessageWithMessagePortsSoon()
177 {
178     if (m_willprocessMessageWithMessagePortsSoon)
179         return;
180 
181     m_willprocessMessageWithMessagePortsSoon = true;
182     postTask([] (ScriptExecutionContext&amp; context) {
183         context.dispatchMessagePortEvents();
184     });
185 }
186 
187 void ScriptExecutionContext::dispatchMessagePortEvents()
188 {
189     checkConsistency();
190 
191     Ref&lt;ScriptExecutionContext&gt; protectedThis(*this);
192     ASSERT(m_willprocessMessageWithMessagePortsSoon);
193     m_willprocessMessageWithMessagePortsSoon = false;
194 
195     // Make a frozen copy of the ports so we can iterate while new ones might be added or destroyed.
196     for (auto* messagePort : copyToVector(m_messagePorts)) {
197         // The port may be destroyed, and another one created at the same address,
198         // but this is harmless. The worst that can happen as a result is that
199         // dispatchMessages() will be called needlessly.
200         if (m_messagePorts.contains(messagePort) &amp;&amp; messagePort-&gt;started())
201             messagePort-&gt;dispatchMessages();
202     }
203 }
204 
205 void ScriptExecutionContext::createdMessagePort(MessagePort&amp; messagePort)
206 {
207     ASSERT((is&lt;Document&gt;(*this) &amp;&amp; isMainThread())
208         || (is&lt;WorkerGlobalScope&gt;(*this) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*this).thread().thread() == &amp;Thread::current()));
209 
210     m_messagePorts.add(&amp;messagePort);
211 }
212 
213 void ScriptExecutionContext::destroyedMessagePort(MessagePort&amp; messagePort)
214 {
215     ASSERT((is&lt;Document&gt;(*this) &amp;&amp; isMainThread())
216         || (is&lt;WorkerGlobalScope&gt;(*this) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*this).thread().thread() == &amp;Thread::current()));
217 
218     m_messagePorts.remove(&amp;messagePort);
219 }
220 
221 void ScriptExecutionContext::didLoadResourceSynchronously()
222 {
223 }
224 
225 void ScriptExecutionContext::forEachActiveDOMObject(const Function&lt;ShouldContinue(ActiveDOMObject&amp;)&gt;&amp; apply) const
226 {
227     // It is not allowed to run arbitrary script or construct new ActiveDOMObjects while we are iterating over ActiveDOMObjects.
228     // An ASSERT_WITH_SECURITY_IMPLICATION or RELEASE_ASSERT will fire if this happens, but it&#39;s important to code
229     // suspend() / resume() / stop() functions so it will not happen!
230     ScriptDisallowedScope scriptDisallowedScope;
231     SetForScope&lt;bool&gt; activeDOMObjectAdditionForbiddenScope(m_activeDOMObjectAdditionForbidden, true);
232 
233     // Make a frozen copy of the objects so we can iterate while new ones might be destroyed.
234     auto possibleActiveDOMObjects = copyToVector(m_activeDOMObjects);
235 
236     for (auto* activeDOMObject : possibleActiveDOMObjects) {
237         // Check if this object was deleted already. If so, just skip it.
238         // Calling contains on a possibly-already-deleted object is OK because we guarantee
239         // no new object can be added, so even if a new object ends up allocated with the
240         // same address, that will be *after* this function exits.
241         if (!m_activeDOMObjects.contains(activeDOMObject))
242             continue;
243 
244         if (apply(*activeDOMObject) == ShouldContinue::No)
245             break;
246     }
247 }
248 
249 void ScriptExecutionContext::suspendActiveDOMObjects(ReasonForSuspension why)
250 {
251     checkConsistency();
252 
253     if (m_activeDOMObjectsAreSuspended) {
254         // A page may subsequently suspend DOM objects, say as part of entering the back/forward cache, after the embedding
255         // client requested the page be suspended. We ignore such requests so long as the embedding client requested
256         // the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
257         ASSERT(m_reasonForSuspendingActiveDOMObjects == ReasonForSuspension::PageWillBeSuspended);
258         return;
259     }
260 
261     m_activeDOMObjectsAreSuspended = true;
262 
263     forEachActiveDOMObject([why](auto&amp; activeDOMObject) {
264         activeDOMObject.suspend(why);
265         return ShouldContinue::Yes;
266     });
267 
268     m_reasonForSuspendingActiveDOMObjects = why;
269 }
270 
271 void ScriptExecutionContext::resumeActiveDOMObjects(ReasonForSuspension why)
272 {
273     checkConsistency();
274 
275     if (m_reasonForSuspendingActiveDOMObjects != why)
276         return;
277 
278     forEachActiveDOMObject([](auto&amp; activeDOMObject) {
279         activeDOMObject.resume();
280         return ShouldContinue::Yes;
281     });
282 
283     m_activeDOMObjectsAreSuspended = false;
284 
285     // In case there were pending messages at the time the script execution context entered the BackForwardCache,
286     // make sure those get dispatched shortly after restoring from the BackForwardCache.
287     processMessageWithMessagePortsSoon();
288 }
289 
290 void ScriptExecutionContext::stopActiveDOMObjects()
291 {
292     checkConsistency();
293 
294     if (m_activeDOMObjectsAreStopped)
295         return;
296     m_activeDOMObjectsAreStopped = true;
297 
298     forEachActiveDOMObject([](auto&amp; activeDOMObject) {
299         activeDOMObject.stop();
300         return ShouldContinue::Yes;
301     });
302 }
303 
304 void ScriptExecutionContext::suspendActiveDOMObjectIfNeeded(ActiveDOMObject&amp; activeDOMObject)
305 {
306     ASSERT(m_activeDOMObjects.contains(&amp;activeDOMObject));
307     if (m_activeDOMObjectsAreSuspended)
308         activeDOMObject.suspend(m_reasonForSuspendingActiveDOMObjects);
309     if (m_activeDOMObjectsAreStopped)
310         activeDOMObject.stop();
311 }
312 
313 void ScriptExecutionContext::didCreateActiveDOMObject(ActiveDOMObject&amp; activeDOMObject)
314 {
315     // The m_activeDOMObjectAdditionForbidden check is a RELEASE_ASSERT because of the
316     // consequences of having an ActiveDOMObject that is not correctly reflected in the set.
317     // If we do have one of those, it can possibly be a security vulnerability. So we&#39;d
318     // rather have a crash than continue running with the set possibly compromised.
319     ASSERT(!m_inScriptExecutionContextDestructor);
320     RELEASE_ASSERT(!m_activeDOMObjectAdditionForbidden);
321     m_activeDOMObjects.add(&amp;activeDOMObject);
322 }
323 
324 void ScriptExecutionContext::willDestroyActiveDOMObject(ActiveDOMObject&amp; activeDOMObject)
325 {
326     m_activeDOMObjects.remove(&amp;activeDOMObject);
327 }
328 
329 void ScriptExecutionContext::didCreateDestructionObserver(ContextDestructionObserver&amp; observer)
330 {
331     ASSERT(!m_inScriptExecutionContextDestructor);
332     m_destructionObservers.add(&amp;observer);
333 }
334 
335 void ScriptExecutionContext::willDestroyDestructionObserver(ContextDestructionObserver&amp; observer)
336 {
337     m_destructionObservers.remove(&amp;observer);
338 }
339 
340 // FIXME: Should this function be in SecurityContext or SecurityOrigin instead?
341 bool ScriptExecutionContext::canIncludeErrorDetails(CachedScript* script, const String&amp; sourceURL)
342 {
343     ASSERT(securityOrigin());
344     if (script) {
345         ASSERT(script-&gt;origin());
346         ASSERT(securityOrigin()-&gt;toString() == script-&gt;origin()-&gt;toString());
347         return script-&gt;isCORSSameOrigin();
348     }
349     return securityOrigin()-&gt;canRequest(completeURL(sourceURL));
350 }
351 
352 void ScriptExecutionContext::reportException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception* exception, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack, CachedScript* cachedScript)
353 {
354     if (m_inDispatchErrorEvent) {
355         if (!m_pendingExceptions)
356             m_pendingExceptions = makeUnique&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt;();
357         m_pendingExceptions-&gt;append(makeUnique&lt;PendingException&gt;(errorMessage, lineNumber, columnNumber, sourceURL, WTFMove(callStack)));
358         return;
359     }
360 
361     // First report the original exception and only then all the nested ones.
362     if (!dispatchErrorEvent(errorMessage, lineNumber, columnNumber, sourceURL, exception, cachedScript))
363         logExceptionToConsole(errorMessage, sourceURL, lineNumber, columnNumber, callStack.copyRef());
364 
365     if (!m_pendingExceptions)
366         return;
367 
368     auto pendingExceptions = WTFMove(m_pendingExceptions);
369     for (auto&amp; exception : *pendingExceptions)
370         logExceptionToConsole(exception-&gt;m_errorMessage, exception-&gt;m_sourceURL, exception-&gt;m_lineNumber, exception-&gt;m_columnNumber, WTFMove(exception-&gt;m_callStack));
371 }
372 
373 void ScriptExecutionContext::reportUnhandledPromiseRejection(JSC::JSGlobalObject&amp; state, JSC::JSPromise&amp; promise, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)
374 {
375     Page* page = nullptr;
376     if (is&lt;Document&gt;(this))
377         page = downcast&lt;Document&gt;(this)-&gt;page();
378     // FIXME: allow Workers to mute unhandled promise rejection messages.
379 
380     if (page &amp;&amp; !page-&gt;settings().unhandledPromiseRejectionToConsoleEnabled())
381         return;
382 
383     JSC::VM&amp; vm = state.vm();
384     auto scope = DECLARE_CATCH_SCOPE(vm);
385 
386     JSC::JSValue result = promise.result(vm);
387     String resultMessage = retrieveErrorMessage(state, vm, result, scope);
388     String errorMessage = makeString(&quot;Unhandled Promise Rejection: &quot;, resultMessage);
389     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
390     if (callStack)
391         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::JS, MessageType::Log, MessageLevel::Error, errorMessage, callStack.releaseNonNull());
392     else
393         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::JS, MessageType::Log, MessageLevel::Error, errorMessage);
394     addConsoleMessage(WTFMove(message));
395 }
396 
397 void ScriptExecutionContext::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::JSGlobalObject* state, unsigned long requestIdentifier)
398 {
399     addMessage(source, level, message, sourceURL, lineNumber, columnNumber, 0, state, requestIdentifier);
400 }
401 
402 bool ScriptExecutionContext::dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception* exception, CachedScript* cachedScript)
403 {
404     auto* target = errorEventTarget();
405     if (!target)
406         return false;
407 
408     RefPtr&lt;ErrorEvent&gt; errorEvent;
409     if (canIncludeErrorDetails(cachedScript, sourceURL))
410         errorEvent = ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { vm(), exception ? exception-&gt;value() : JSC::jsNull() });
411     else
412         errorEvent = ErrorEvent::create(&quot;Script error.&quot;_s, { }, 0, 0, { });
413 
414     ASSERT(!m_inDispatchErrorEvent);
415     m_inDispatchErrorEvent = true;
416     target-&gt;dispatchEvent(*errorEvent);
417     m_inDispatchErrorEvent = false;
418     return errorEvent-&gt;defaultPrevented();
419 }
420 
421 int ScriptExecutionContext::circularSequentialID()
422 {
423     ++m_circularSequentialID;
424     if (m_circularSequentialID &lt;= 0)
425         m_circularSequentialID = 1;
426     return m_circularSequentialID;
427 }
428 
429 PublicURLManager&amp; ScriptExecutionContext::publicURLManager()
430 {
431     if (!m_publicURLManager)
432         m_publicURLManager = PublicURLManager::create(this);
433     return *m_publicURLManager;
434 }
435 
436 void ScriptExecutionContext::adjustMinimumDOMTimerInterval(Seconds oldMinimumTimerInterval)
437 {
438     if (minimumDOMTimerInterval() != oldMinimumTimerInterval) {
439         for (auto&amp; timer : m_timeouts.values())
440             timer-&gt;updateTimerIntervalIfNecessary();
441     }
442 }
443 
444 Seconds ScriptExecutionContext::minimumDOMTimerInterval() const
445 {
446     // The default implementation returns the DOMTimer&#39;s default
447     // minimum timer interval. FIXME: to make it work with dedicated
448     // workers, we will have to override it in the appropriate
449     // subclass, and provide a way to enumerate a Document&#39;s dedicated
450     // workers so we can update them all.
451     return DOMTimer::defaultMinimumInterval();
452 }
453 
454 void ScriptExecutionContext::didChangeTimerAlignmentInterval()
455 {
456     for (auto&amp; timer : m_timeouts.values())
457         timer-&gt;didChangeAlignmentInterval();
458 }
459 
460 Seconds ScriptExecutionContext::domTimerAlignmentInterval(bool) const
461 {
462     return DOMTimer::defaultAlignmentInterval();
463 }
464 
465 JSC::VM&amp; ScriptExecutionContext::vm()
466 {
467     if (is&lt;Document&gt;(*this))
468         return commonVM();
469     if (is&lt;WorkerGlobalScope&gt;(*this))
470         return downcast&lt;WorkerGlobalScope&gt;(*this).script()-&gt;vm();
471 #if ENABLE(CSS_PAINTING_API)
472     if (is&lt;WorkletGlobalScope&gt;(*this))
473         return downcast&lt;WorkletGlobalScope&gt;(*this).script()-&gt;vm();
474 #endif
475 
476     RELEASE_ASSERT_NOT_REACHED();
477     return commonVM();
478 }
479 
480 RejectedPromiseTracker&amp; ScriptExecutionContext::ensureRejectedPromiseTrackerSlow()
481 {
482     // ScriptExecutionContext::vm() in Worker is only available after WorkerGlobalScope initialization is done.
483     // When initializing ScriptExecutionContext, vm() is not ready.
484 
485     ASSERT(!m_rejectedPromiseTracker);
486     m_rejectedPromiseTracker = makeUnique&lt;RejectedPromiseTracker&gt;(*this, vm());
487     return *m_rejectedPromiseTracker.get();
488 }
489 
490 void ScriptExecutionContext::removeRejectedPromiseTracker()
491 {
492     m_rejectedPromiseTracker = nullptr;
493 }
494 
495 void ScriptExecutionContext::setDatabaseContext(DatabaseContext* databaseContext)
496 {
497     m_databaseContext = databaseContext;
498 }
499 
500 bool ScriptExecutionContext::hasPendingActivity() const
501 {
502     checkConsistency();
503 
504     for (auto* activeDOMObject : m_activeDOMObjects) {
505         if (activeDOMObject-&gt;hasPendingActivity())
506             return true;
507     }
508 
509     return false;
510 }
511 
512 JSC::JSGlobalObject* ScriptExecutionContext::execState()
513 {
514     if (is&lt;Document&gt;(*this)) {
515         Document&amp; document = downcast&lt;Document&gt;(*this);
516         auto* frame = document.frame();
517         return frame ? frame-&gt;script().globalObject(mainThreadNormalWorld()) : nullptr;
518     }
519 
520     if (is&lt;WorkerGlobalScope&gt;(*this))
521         return execStateFromWorkerGlobalScope(downcast&lt;WorkerGlobalScope&gt;(*this));
522 #if ENABLE(CSS_PAINTING_API)
523     if (is&lt;WorkletGlobalScope&gt;(*this))
524         return execStateFromWorkletGlobalScope(downcast&lt;WorkletGlobalScope&gt;(*this));
525 #endif
526 
527     ASSERT_NOT_REACHED();
528     return nullptr;
529 }
530 
531 String ScriptExecutionContext::domainForCachePartition() const
532 {
533     return m_domainForCachePartition.isNull() ? topOrigin().domainForCachePartition() : m_domainForCachePartition;
534 }
535 
536 bool ScriptExecutionContext::allowsMediaDevices() const
537 {
538 #if ENABLE(MEDIA_STREAM)
539     if (!is&lt;Document&gt;(*this))
540         return false;
541     auto page = downcast&lt;Document&gt;(*this).page();
542     return page ? !page-&gt;settings().mediaCaptureRequiresSecureConnection() : false;
543 #else
544     return false;
545 #endif
546 }
547 
548 bool ScriptExecutionContext::hasServiceWorkerScheme() const
549 {
550     ASSERT(securityOrigin());
551     return LegacySchemeRegistry::isServiceWorkerContainerCustomScheme(securityOrigin()-&gt;protocol());
552 }
553 
554 #if ENABLE(SERVICE_WORKER)
555 
556 ServiceWorker* ScriptExecutionContext::activeServiceWorker() const
557 {
558     return m_activeServiceWorker.get();
559 }
560 
561 void ScriptExecutionContext::setActiveServiceWorker(RefPtr&lt;ServiceWorker&gt;&amp;&amp; serviceWorker)
562 {
563     m_activeServiceWorker = WTFMove(serviceWorker);
564 }
565 
566 void ScriptExecutionContext::registerServiceWorker(ServiceWorker&amp; serviceWorker)
567 {
568     auto addResult = m_serviceWorkers.add(serviceWorker.identifier(), &amp;serviceWorker);
569     ASSERT_UNUSED(addResult, addResult.isNewEntry);
570 }
571 
572 void ScriptExecutionContext::unregisterServiceWorker(ServiceWorker&amp; serviceWorker)
573 {
574     m_serviceWorkers.remove(serviceWorker.identifier());
575 }
576 
577 ServiceWorkerContainer* ScriptExecutionContext::serviceWorkerContainer()
578 {
579     NavigatorBase* navigator = nullptr;
580     if (is&lt;Document&gt;(*this)) {
581         if (auto* window = downcast&lt;Document&gt;(*this).domWindow())
582             navigator = window-&gt;optionalNavigator();
583     } else
584         navigator = downcast&lt;WorkerGlobalScope&gt;(*this).optionalNavigator();
585 
586     return navigator ? &amp;navigator-&gt;serviceWorker() : nullptr;
587 }
588 
589 ServiceWorkerContainer* ScriptExecutionContext::ensureServiceWorkerContainer()
590 {
591     NavigatorBase* navigator = nullptr;
592     if (is&lt;Document&gt;(*this)) {
593         if (auto* window = downcast&lt;Document&gt;(*this).domWindow())
594             navigator = &amp;window-&gt;navigator();
595     } else
596         navigator = &amp;downcast&lt;WorkerGlobalScope&gt;(*this).navigator();
597 
598     return navigator ? &amp;navigator-&gt;serviceWorker() : nullptr;
599 }
600 
601 #endif
602 
603 bool ScriptExecutionContext::postTaskTo(ScriptExecutionContextIdentifier identifier, Task&amp;&amp; task)
604 {
605     Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
606     auto* context = allScriptExecutionContextsMap().get(identifier);
607 
608     if (!context)
609         return false;
610 
611     context-&gt;postTask(WTFMove(task));
612     return true;
613 }
614 
615 } // namespace WebCore
    </pre>
  </body>
</html>
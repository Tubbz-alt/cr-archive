<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Copyright 2015 The Chromium Authors. All rights reserved.
   2 // Copyright (C) 2016 Apple Inc. All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //    * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //    * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //    * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyParser.h&quot;
  32 
  33 #include &quot;CSSAspectRatioValue.h&quot;
  34 #include &quot;CSSBasicShapes.h&quot;
  35 #include &quot;CSSBorderImage.h&quot;
  36 #include &quot;CSSBorderImageSliceValue.h&quot;
  37 #include &quot;CSSContentDistributionValue.h&quot;
  38 #include &quot;CSSCursorImageValue.h&quot;
  39 #include &quot;CSSCustomIdentValue.h&quot;
  40 #include &quot;CSSCustomPropertyValue.h&quot;
  41 #include &quot;CSSFontFaceSrcValue.h&quot;
  42 #include &quot;CSSFontFeatureValue.h&quot;
  43 #if ENABLE(VARIATION_FONTS)
  44 #include &quot;CSSFontVariationValue.h&quot;
  45 #endif
  46 #include &quot;CSSFontStyleRangeValue.h&quot;
  47 #include &quot;CSSFontStyleValue.h&quot;
  48 #include &quot;CSSFunctionValue.h&quot;
  49 #include &quot;CSSGridAutoRepeatValue.h&quot;
  50 #include &quot;CSSGridIntegerRepeatValue.h&quot;
  51 #include &quot;CSSGridLineNamesValue.h&quot;
  52 #include &quot;CSSGridTemplateAreasValue.h&quot;
  53 #include &quot;CSSLineBoxContainValue.h&quot;
  54 #include &quot;CSSParserFastPaths.h&quot;
  55 #include &quot;CSSParserIdioms.h&quot;
  56 #include &quot;CSSPendingSubstitutionValue.h&quot;
  57 #include &quot;CSSPrimitiveValueMappings.h&quot;
  58 #include &quot;CSSPropertyParserHelpers.h&quot;
  59 #include &quot;CSSReflectValue.h&quot;
  60 #include &quot;CSSShadowValue.h&quot;
  61 #include &quot;CSSTimingFunctionValue.h&quot;
  62 #include &quot;CSSUnicodeRangeValue.h&quot;
  63 #include &quot;CSSVariableParser.h&quot;
  64 #include &quot;CSSVariableReferenceValue.h&quot;
  65 #include &quot;Counter.h&quot;
  66 #include &quot;FontFace.h&quot;
  67 #include &quot;HashTools.h&quot;
  68 // FIXME-NEWPARSER: Replace Pair and Rect with actual CSSValue subclasses (CSSValuePair and CSSQuadValue).
  69 #include &quot;Pair.h&quot;
  70 #include &quot;Rect.h&quot;
  71 #include &quot;RenderTheme.h&quot;
  72 #include &quot;RuntimeEnabledFeatures.h&quot;
  73 #include &quot;SVGPathByteStream.h&quot;
  74 #include &quot;SVGPathUtilities.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  75 #include &quot;StyleBuilder.h&quot;</span>
  76 #include &quot;StyleBuilderConverter.h&quot;
  77 #include &quot;StylePropertyShorthand.h&quot;
  78 #include &quot;StylePropertyShorthandFunctions.h&quot;
<a name="2" id="anc2"></a>
  79 #include &lt;bitset&gt;
  80 #include &lt;memory&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 namespace WebCore {
  84 
  85 bool isCustomPropertyName(const String&amp; propertyName)
  86 {
  87     return propertyName.length() &gt; 2 &amp;&amp; propertyName.characterAt(0) == &#39;-&#39; &amp;&amp; propertyName.characterAt(1) == &#39;-&#39;;
  88 }
  89 
  90 static bool hasPrefix(const char* string, unsigned length, const char* prefix)
  91 {
  92     for (unsigned i = 0; i &lt; length; ++i) {
  93         if (!prefix[i])
  94             return true;
  95         if (string[i] != prefix[i])
  96             return false;
  97     }
  98     return false;
  99 }
 100 
 101 #if PLATFORM(IOS_FAMILY)
 102 void cssPropertyNameIOSAliasing(const char* propertyName, const char*&amp; propertyNameAlias, unsigned&amp; newLength)
 103 {
 104     if (!strcmp(propertyName, &quot;-webkit-hyphenate-locale&quot;)) {
 105         // Worked in iOS 4.2.
 106         static const char webkitLocale[] = &quot;-webkit-locale&quot;;
 107         propertyNameAlias = webkitLocale;
 108         newLength = strlen(webkitLocale);
 109     }
 110 }
 111 #endif
 112 
 113 template &lt;typename CharacterType&gt;
 114 static CSSPropertyID cssPropertyID(const CharacterType* propertyName, unsigned length)
 115 {
 116     char buffer[maxCSSPropertyNameLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 117 
 118     for (unsigned i = 0; i != length; ++i) {
 119         CharacterType c = propertyName[i];
 120         if (!c || c &gt;= 0x7F)
 121             return CSSPropertyInvalid; // illegal character
 122         buffer[i] = toASCIILower(c);
 123     }
 124     buffer[length] = &#39;\0&#39;;
 125 
 126     const char* name = buffer;
 127     if (buffer[0] == &#39;-&#39;) {
 128 #if ENABLE(LEGACY_CSS_VENDOR_PREFIXES)
 129         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 130         // This makes the string one character longer.
 131         if (RuntimeEnabledFeatures::sharedFeatures().legacyCSSVendorPrefixesEnabled()
 132             &amp;&amp; (hasPrefix(buffer, length, &quot;-apple-&quot;) || hasPrefix(buffer, length, &quot;-khtml-&quot;))) {
 133             memmove(buffer + 7, buffer + 6, length + 1 - 6);
 134             memcpy(buffer, &quot;-webkit&quot;, 7);
 135             ++length;
 136         }
 137 #endif
 138 #if PLATFORM(IOS_FAMILY)
 139         cssPropertyNameIOSAliasing(buffer, name, length);
 140 #endif
 141     }
 142 
 143     const Property* hashTableEntry = findProperty(name, length);
 144     if (hashTableEntry) {
 145         auto propertyID = static_cast&lt;CSSPropertyID&gt;(hashTableEntry-&gt;id);
 146         if (isEnabledCSSProperty(propertyID))
 147             return propertyID;
 148     }
 149     return CSSPropertyInvalid;
 150 }
 151 
 152 static bool isAppleLegacyCssValueKeyword(const char* valueKeyword, unsigned length)
 153 {
 154     static const char applePrefix[] = &quot;-apple-&quot;;
 155     static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
 156     static const char applePayPrefix[] = &quot;-apple-pay&quot;;
 157 
<a name="3" id="anc3"></a><span class="line-modified"> 158 #if PLATFORM(COCOA)</span>
 159     static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
 160 #endif
 161 
 162     return hasPrefix(valueKeyword, length, applePrefix)
 163     &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
 164     &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
<a name="4" id="anc4"></a><span class="line-modified"> 165 #if PLATFORM(COCOA)</span>
 166     &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length)
 167 #endif
 168     ;
 169 }
 170 
 171 template &lt;typename CharacterType&gt;
 172 static CSSValueID cssValueKeywordID(const CharacterType* valueKeyword, unsigned length)
 173 {
 174     char buffer[maxCSSValueKeywordLength + 1 + 1]; // 1 to turn &quot;apple&quot;/&quot;khtml&quot; into &quot;webkit&quot;, 1 for null character
 175 
 176     for (unsigned i = 0; i != length; ++i) {
 177         CharacterType c = valueKeyword[i];
 178         if (!c || c &gt;= 0x7F)
 179             return CSSValueInvalid; // illegal keyword.
 180         buffer[i] = WTF::toASCIILower(c);
 181     }
 182     buffer[length] = &#39;\0&#39;;
 183 
 184     if (buffer[0] == &#39;-&#39;) {
 185         // If the prefix is -apple- or -khtml-, change it to -webkit-.
 186         // This makes the string one character longer.
 187         // On iOS we don&#39;t want to change values starting with -apple-system to -webkit-system.
 188         // FIXME: Remove this mangling without breaking the web.
 189         if (isAppleLegacyCssValueKeyword(buffer, length) || hasPrefix(buffer, length, &quot;-khtml-&quot;)) {
 190             memmove(buffer + 7, buffer + 6, length + 1 - 6);
 191             memcpy(buffer, &quot;-webkit&quot;, 7);
 192             ++length;
 193         }
 194     }
 195 
 196     const Value* hashTableEntry = findValue(buffer, length);
 197     return hashTableEntry ? static_cast&lt;CSSValueID&gt;(hashTableEntry-&gt;id) : CSSValueInvalid;
 198 }
 199 
 200 CSSValueID cssValueKeywordID(StringView string)
 201 {
 202     unsigned length = string.length();
 203     if (!length)
 204         return CSSValueInvalid;
 205     if (length &gt; maxCSSValueKeywordLength)
 206         return CSSValueInvalid;
 207 
 208     return string.is8Bit() ? cssValueKeywordID(string.characters8(), length) : cssValueKeywordID(string.characters16(), length);
 209 }
 210 
 211 CSSPropertyID cssPropertyID(StringView string)
 212 {
 213     unsigned length = string.length();
 214 
 215     if (!length)
 216         return CSSPropertyInvalid;
 217     if (length &gt; maxCSSPropertyNameLength)
 218         return CSSPropertyInvalid;
 219 
 220     return string.is8Bit() ? cssPropertyID(string.characters8(), length) : cssPropertyID(string.characters16(), length);
 221 }
 222 
 223 using namespace CSSPropertyParserHelpers;
 224 
 225 CSSPropertyParser::CSSPropertyParser(const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, Vector&lt;CSSProperty, 256&gt;* parsedProperties, bool consumeWhitespace)
 226     : m_range(range)
 227     , m_context(context)
 228     , m_parsedProperties(parsedProperties)
 229 {
 230     if (consumeWhitespace)
 231         m_range.consumeWhitespace();
 232 }
 233 
 234 void CSSPropertyParser::addProperty(CSSPropertyID property, CSSPropertyID currentShorthand, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important, bool implicit)
 235 {
 236     if (!isEnabledCSSProperty(property))
 237         return;
 238 
 239     int shorthandIndex = 0;
 240     bool setFromShorthand = false;
 241 
 242     if (currentShorthand) {
 243         auto shorthands = matchingShorthandsForLonghand(property);
 244         setFromShorthand = true;
 245         if (shorthands.size() &gt; 1)
 246             shorthandIndex = indexOfShorthandForLonghand(currentShorthand, shorthands);
 247     }
 248 
 249     m_parsedProperties-&gt;append(CSSProperty(property, WTFMove(value), important, setFromShorthand, shorthandIndex, implicit));
 250 }
 251 
 252 void CSSPropertyParser::addExpandedPropertyForValue(CSSPropertyID property, Ref&lt;CSSValue&gt;&amp;&amp; value, bool important)
 253 {
 254     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(property);
 255     unsigned shorthandLength = shorthand.length();
 256     ASSERT(shorthandLength);
 257     const CSSPropertyID* longhands = shorthand.properties();
 258     for (unsigned i = 0; i &lt; shorthandLength; ++i)
 259         addProperty(longhands[i], property, value.copyRef(), important);
 260 }
 261 
<a name="5" id="anc5"></a><span class="line-modified"> 262 bool CSSPropertyParser::parseValue(CSSPropertyID propertyID, bool important, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, ParsedPropertyVector&amp; parsedProperties, StyleRuleType ruleType)</span>
 263 {
 264     int parsedPropertiesSize = parsedProperties.size();
 265 
 266     CSSPropertyParser parser(range, context, &amp;parsedProperties);
 267     bool parseSuccess;
 268 
 269 #if ENABLE(CSS_DEVICE_ADAPTATION)
<a name="6" id="anc6"></a><span class="line-modified"> 270     if (ruleType == StyleRuleType::Viewport)</span>
 271         parseSuccess = parser.parseViewportDescriptor(propertyID, important);
 272     else
 273 #endif
<a name="7" id="anc7"></a><span class="line-modified"> 274     if (ruleType == StyleRuleType::FontFace)</span>
 275         parseSuccess = parser.parseFontFaceDescriptor(propertyID);
 276     else
 277         parseSuccess = parser.parseValueStart(propertyID, important);
 278 
 279     if (!parseSuccess)
 280         parsedProperties.shrink(parsedPropertiesSize);
 281 
 282     return parseSuccess;
 283 }
 284 
 285 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
 286 {
 287     CSSPropertyParser parser(range, context, nullptr);
 288     RefPtr&lt;CSSValue&gt; value = parser.parseSingleValue(property);
 289     if (!value || !parser.m_range.atEnd())
 290         return nullptr;
 291     return value;
 292 }
 293 
 294 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 295 {
 296     CSSPropertyParser parser(tokens, context, nullptr);
 297     return parser.canParseTypedCustomPropertyValue(syntax);
 298 }
 299 
<a name="8" id="anc8"></a><span class="line-modified"> 300 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const Style::BuilderState&amp; builderState, const CSSParserContext&amp; context)</span>
 301 {
 302     CSSPropertyParser parser(tokens, context, nullptr, false);
<a name="9" id="anc9"></a><span class="line-modified"> 303     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, builderState);</span>
 304     if (!value || !parser.m_range.atEnd())
 305         return nullptr;
 306     return value;
 307 }
 308 
 309 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies, const CSSParserTokenRange&amp; tokens, const CSSParserContext&amp; context)
 310 {
 311     CSSPropertyParser parser(tokens, context, nullptr);
 312     parser.collectParsedCustomPropertyValueDependencies(syntax, isRoot, dependencies);
 313 }
 314 
 315 bool CSSPropertyParser::parseValueStart(CSSPropertyID propertyID, bool important)
 316 {
 317     if (consumeCSSWideKeyword(propertyID, important))
 318         return true;
 319 
 320     CSSParserTokenRange originalRange = m_range;
 321     bool isShorthand = isShorthandCSSProperty(propertyID);
 322 
 323     if (isShorthand) {
 324         // Variable references will fail to parse here and will fall out to the variable ref parser below.
 325         if (parseShorthand(propertyID, important))
 326             return true;
 327     } else {
 328         RefPtr&lt;CSSValue&gt; parsedValue = parseSingleValue(propertyID);
 329         if (parsedValue &amp;&amp; m_range.atEnd()) {
 330             addProperty(propertyID, CSSPropertyInvalid, *parsedValue, important);
 331             return true;
 332         }
 333     }
 334 
 335     if (CSSVariableParser::containsValidVariableReferences(originalRange, m_context)) {
 336         RefPtr&lt;CSSVariableReferenceValue&gt; variable = CSSVariableReferenceValue::create(originalRange);
 337 
 338         if (isShorthand) {
 339             RefPtr&lt;CSSPendingSubstitutionValue&gt; pendingValue = CSSPendingSubstitutionValue::create(propertyID, variable.releaseNonNull());
 340             addExpandedPropertyForValue(propertyID, pendingValue.releaseNonNull(), important);
 341         } else
 342             addProperty(propertyID, CSSPropertyInvalid, variable.releaseNonNull(), important);
 343         return true;
 344     }
 345 
 346     return false;
 347 }
 348 
 349 bool CSSPropertyParser::consumeCSSWideKeyword(CSSPropertyID propertyID, bool important)
 350 {
 351     CSSParserTokenRange rangeCopy = m_range;
 352     CSSValueID valueID = rangeCopy.consumeIncludingWhitespace().id();
 353     if (!rangeCopy.atEnd())
 354         return false;
 355 
 356     RefPtr&lt;CSSValue&gt; value;
 357     if (valueID == CSSValueInherit)
 358         value = CSSValuePool::singleton().createInheritedValue();
 359     else if (valueID == CSSValueInitial)
 360         value = CSSValuePool::singleton().createExplicitInitialValue();
 361     else if (valueID == CSSValueUnset)
 362         value = CSSValuePool::singleton().createUnsetValue();
 363     else if (valueID == CSSValueRevert)
 364         value = CSSValuePool::singleton().createRevertValue();
 365     else
 366         return false;
 367 
 368     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
 369     if (!shorthand.length()) {
 370         if (CSSProperty::isDescriptorOnly(propertyID))
 371             return false;
 372         addProperty(propertyID, CSSPropertyInvalid, value.releaseNonNull(), important);
 373     } else
 374         addExpandedPropertyForValue(propertyID, value.releaseNonNull(), important);
 375     m_range = rangeCopy;
 376     return true;
 377 }
 378 
 379 bool CSSPropertyParser::consumeTransformOrigin(bool important)
 380 {
 381     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 382     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 383     if (consumeOneOrTwoValuedPosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {
 384         m_range.consumeWhitespace();
 385         bool atEnd = m_range.atEnd();
 386         RefPtr&lt;CSSPrimitiveValue&gt; resultZ = consumeLength(m_range, m_context.mode, ValueRangeAll);
 387         bool hasZ = resultZ;
 388         if (!hasZ &amp;&amp; !atEnd)
 389             return false;
 390         addProperty(CSSPropertyTransformOriginX, CSSPropertyTransformOrigin, resultX.releaseNonNull(), important);
 391         addProperty(CSSPropertyTransformOriginY, CSSPropertyTransformOrigin, resultY.releaseNonNull(), important);
<a name="10" id="anc10"></a><span class="line-modified"> 392         addProperty(CSSPropertyTransformOriginZ, CSSPropertyTransformOrigin, resultZ ? resultZ.releaseNonNull() : CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_PX), important, !hasZ);</span>
 393 
 394         return true;
 395     }
 396     return false;
 397 }
 398 
 399 bool CSSPropertyParser::consumePerspectiveOrigin(bool important)
 400 {
 401     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 402     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
<a name="11" id="anc11"></a><span class="line-modified"> 403     if (consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, resultX, resultY)) {</span>
 404         addProperty(CSSPropertyPerspectiveOriginX, CSSPropertyPerspectiveOrigin, resultX.releaseNonNull(), important);
 405         addProperty(CSSPropertyPerspectiveOriginY, CSSPropertyPerspectiveOrigin, resultY.releaseNonNull(), important);
 406         return true;
 407     }
 408     return false;
 409 }
 410 
 411 // Methods for consuming non-shorthand properties starts here.
 412 static RefPtr&lt;CSSValue&gt; consumeWillChange(CSSParserTokenRange&amp; range)
 413 {
 414     if (range.peek().id() == CSSValueAuto)
 415         return consumeIdent(range);
 416 
 417     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
 418     // Every comma-separated list of identifiers is a valid will-change value,
 419     // unless the list includes an explicitly disallowed identifier.
 420     while (true) {
 421         if (range.peek().type() != IdentToken)
 422             return nullptr;
 423         CSSPropertyID propertyID = cssPropertyID(range.peek().value());
 424         if (propertyID != CSSPropertyInvalid) {
 425             // Now &quot;all&quot; is used by both CSSValue and CSSPropertyValue.
 426             // Need to return nullptr when currentValue is CSSPropertyAll.
 427             if (propertyID == CSSPropertyWillChange || propertyID == CSSPropertyAll)
 428                 return nullptr;
 429             // FIXME-NEWPARSER: Use CSSCustomIdentValue someday.
 430             values-&gt;append(CSSValuePool::singleton().createIdentifierValue(propertyID));
 431             range.consumeIncludingWhitespace();
 432         } else {
 433             switch (range.peek().id()) {
 434             case CSSValueNone:
 435             case CSSValueAll:
 436             case CSSValueAuto:
 437             case CSSValueDefault:
 438             case CSSValueInitial:
 439             case CSSValueInherit:
 440                 return nullptr;
 441             case CSSValueContents:
 442             case CSSValueScrollPosition:
 443                 values-&gt;append(consumeIdent(range).releaseNonNull());
 444                 break;
 445             default:
 446                 // Append properties we don&#39;t recognize, but that are legal, as strings.
 447                 values-&gt;append(consumeCustomIdent(range).releaseNonNull());
 448                 break;
 449             }
 450         }
 451 
 452         if (range.atEnd())
 453             break;
 454         if (!consumeCommaIncludingWhitespace(range))
 455             return nullptr;
 456     }
 457 
 458     return values;
 459 }
 460 
 461 static RefPtr&lt;CSSFontFeatureValue&gt; consumeFontFeatureTag(CSSParserTokenRange&amp; range)
 462 {
 463     // Feature tag name consists of 4-letter characters.
 464     static const unsigned tagNameLength = 4;
 465 
 466     const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
 467     // Feature tag name comes first
 468     if (token.type() != StringToken)
 469         return nullptr;
 470     if (token.value().length() != tagNameLength)
 471         return nullptr;
 472 
 473     FontTag tag;
 474     for (unsigned i = 0; i &lt; tag.size(); ++i) {
 475         // Limits the range of characters to 0x20-0x7E, following the tag name rules defiend in the OpenType specification.
 476         UChar character = token.value()[i];
 477         if (character &lt; 0x20 || character &gt; 0x7E)
 478             return nullptr;
 479         tag[i] = toASCIILower(character);
 480     }
 481 
 482     int tagValue = 1;
 483     if (!range.atEnd() &amp;&amp; range.peek().type() != CommaToken) {
 484         // Feature tag values could follow: &lt;integer&gt; | on | off
 485         if (auto primitiveValue = consumeInteger(range, 0))
 486             tagValue = primitiveValue-&gt;intValue();
 487         else if (range.peek().id() == CSSValueOn || range.peek().id() == CSSValueOff)
 488             tagValue = range.consumeIncludingWhitespace().id() == CSSValueOn;
 489         else
 490             return nullptr;
 491     }
 492     return CSSFontFeatureValue::create(WTFMove(tag), tagValue);
 493 }
 494 
 495 static RefPtr&lt;CSSValue&gt; consumeFontFeatureSettings(CSSParserTokenRange&amp; range)
 496 {
 497     if (range.peek().id() == CSSValueNormal)
 498         return consumeIdent(range);
 499     RefPtr&lt;CSSValueList&gt; settings = CSSValueList::createCommaSeparated();
 500     do {
 501         RefPtr&lt;CSSFontFeatureValue&gt; fontFeatureValue = consumeFontFeatureTag(range);
 502         if (!fontFeatureValue)
 503             return nullptr;
 504         settings-&gt;append(fontFeatureValue.releaseNonNull());
 505     } while (consumeCommaIncludingWhitespace(range));
 506     return settings;
 507 }
 508 
 509 #if ENABLE(VARIATION_FONTS)
 510 static RefPtr&lt;CSSValue&gt; consumeFontVariationTag(CSSParserTokenRange&amp; range)
 511 {
 512     if (range.peek().type() != StringToken)
 513         return nullptr;
 514 
 515     auto string = range.consumeIncludingWhitespace().value().toString();
 516 
 517     FontTag tag;
 518     if (string.length() != tag.size())
 519         return nullptr;
 520     for (unsigned i = 0; i &lt; tag.size(); ++i) {
 521         // Limits the range of characters to 0x20-0x7E, following the tag name rules defiend in the OpenType specification.
 522         UChar character = string[i];
 523         if (character &lt; 0x20 || character &gt; 0x7E)
 524             return nullptr;
 525         tag[i] = character;
 526     }
 527 
 528     if (range.atEnd())
 529         return nullptr;
 530 
 531     double tagValue = 0;
 532     auto success = consumeNumberRaw(range, tagValue);
 533     if (!success)
 534         return nullptr;
 535 
 536     return CSSFontVariationValue::create(tag, tagValue);
 537 }
 538 
 539 static RefPtr&lt;CSSValue&gt; consumeFontVariationSettings(CSSParserTokenRange&amp; range)
 540 {
 541     if (range.peek().id() == CSSValueNormal)
 542         return consumeIdent(range);
 543 
 544     auto settings = CSSValueList::createCommaSeparated();
 545     do {
 546         RefPtr&lt;CSSValue&gt; variationValue = consumeFontVariationTag(range);
 547         if (!variationValue)
 548             return nullptr;
 549         settings-&gt;append(variationValue.releaseNonNull());
 550     } while (consumeCommaIncludingWhitespace(range));
 551 
 552     if (!settings-&gt;length())
 553         return nullptr;
 554 
 555     return settings;
 556 }
 557 #endif // ENABLE(VARIATION_FONTS)
 558 
 559 static RefPtr&lt;CSSValue&gt; consumePage(CSSParserTokenRange&amp; range)
 560 {
 561     if (range.peek().id() == CSSValueAuto)
 562         return consumeIdent(range);
 563     return consumeCustomIdent(range);
 564 }
 565 
 566 static RefPtr&lt;CSSValue&gt; consumeQuotes(CSSParserTokenRange&amp; range)
 567 {
 568     if (range.peek().id() == CSSValueNone)
 569         return consumeIdent(range);
 570     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 571     while (!range.atEnd()) {
 572         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeString(range);
 573         if (!parsedValue)
 574             return nullptr;
 575         values-&gt;append(parsedValue.releaseNonNull());
 576     }
 577     if (values-&gt;length() &amp;&amp; values-&gt;length() % 2 == 0)
 578         return values;
 579     return nullptr;
 580 }
 581 
 582 class FontVariantLigaturesParser {
 583 public:
 584     FontVariantLigaturesParser()
 585         : m_sawCommonLigaturesValue(false)
 586         , m_sawDiscretionaryLigaturesValue(false)
 587         , m_sawHistoricalLigaturesValue(false)
 588         , m_sawContextualLigaturesValue(false)
 589         , m_result(CSSValueList::createSpaceSeparated())
 590     {
 591     }
 592 
 593     enum class ParseResult {
 594         ConsumedValue,
 595         DisallowedValue,
 596         UnknownValue
 597     };
 598 
 599     ParseResult consumeLigature(CSSParserTokenRange&amp; range)
 600     {
 601         CSSValueID valueID = range.peek().id();
 602         switch (valueID) {
 603         case CSSValueNoCommonLigatures:
 604         case CSSValueCommonLigatures:
 605             if (m_sawCommonLigaturesValue)
 606                 return ParseResult::DisallowedValue;
 607             m_sawCommonLigaturesValue = true;
 608             break;
 609         case CSSValueNoDiscretionaryLigatures:
 610         case CSSValueDiscretionaryLigatures:
 611             if (m_sawDiscretionaryLigaturesValue)
 612                 return ParseResult::DisallowedValue;
 613             m_sawDiscretionaryLigaturesValue = true;
 614             break;
 615         case CSSValueNoHistoricalLigatures:
 616         case CSSValueHistoricalLigatures:
 617             if (m_sawHistoricalLigaturesValue)
 618                 return ParseResult::DisallowedValue;
 619             m_sawHistoricalLigaturesValue = true;
 620             break;
 621         case CSSValueNoContextual:
 622         case CSSValueContextual:
 623             if (m_sawContextualLigaturesValue)
 624                 return ParseResult::DisallowedValue;
 625             m_sawContextualLigaturesValue = true;
 626             break;
 627         default:
 628             return ParseResult::UnknownValue;
 629         }
 630         m_result-&gt;append(consumeIdent(range).releaseNonNull());
 631         return ParseResult::ConsumedValue;
 632     }
 633 
 634     RefPtr&lt;CSSValue&gt; finalizeValue()
 635     {
 636         if (!m_result-&gt;length())
 637             return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
 638         return WTFMove(m_result);
 639     }
 640 
 641 private:
 642     bool m_sawCommonLigaturesValue;
 643     bool m_sawDiscretionaryLigaturesValue;
 644     bool m_sawHistoricalLigaturesValue;
 645     bool m_sawContextualLigaturesValue;
 646     RefPtr&lt;CSSValueList&gt; m_result;
 647 };
 648 
 649 static RefPtr&lt;CSSValue&gt; consumeFontVariantLigatures(CSSParserTokenRange&amp; range)
 650 {
 651     if (range.peek().id() == CSSValueNormal || range.peek().id() == CSSValueNone)
 652         return consumeIdent(range);
 653 
 654     FontVariantLigaturesParser ligaturesParser;
 655     do {
 656         if (ligaturesParser.consumeLigature(range) !=
 657             FontVariantLigaturesParser::ParseResult::ConsumedValue)
 658             return nullptr;
 659     } while (!range.atEnd());
 660 
 661     return ligaturesParser.finalizeValue();
 662 }
 663 
 664 static RefPtr&lt;CSSValue&gt; consumeFontVariantEastAsian(CSSParserTokenRange&amp; range)
 665 {
 666     if (range.peek().id() == CSSValueNormal)
 667         return consumeIdent(range);
 668 
 669     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
 670     FontVariantEastAsianVariant variant = FontVariantEastAsianVariant::Normal;
 671     FontVariantEastAsianWidth width = FontVariantEastAsianWidth::Normal;
 672     FontVariantEastAsianRuby ruby = FontVariantEastAsianRuby::Normal;
 673 
 674     while (!range.atEnd()) {
 675         if (range.peek().type() != IdentToken)
 676             return nullptr;
 677 
 678         auto id = range.peek().id();
 679 
 680         switch (id) {
 681         case CSSValueJis78:
 682             variant = FontVariantEastAsianVariant::Jis78;
 683             break;
 684         case CSSValueJis83:
 685             variant = FontVariantEastAsianVariant::Jis83;
 686             break;
 687         case CSSValueJis90:
 688             variant = FontVariantEastAsianVariant::Jis90;
 689             break;
 690         case CSSValueJis04:
 691             variant = FontVariantEastAsianVariant::Jis04;
 692             break;
 693         case CSSValueSimplified:
 694             variant = FontVariantEastAsianVariant::Simplified;
 695             break;
 696         case CSSValueTraditional:
 697             variant = FontVariantEastAsianVariant::Traditional;
 698             break;
 699         case CSSValueFullWidth:
 700             width = FontVariantEastAsianWidth::Full;
 701             break;
 702         case CSSValueProportionalWidth:
 703             width = FontVariantEastAsianWidth::Proportional;
 704             break;
 705         case CSSValueRuby:
 706             ruby = FontVariantEastAsianRuby::Yes;
 707             break;
 708         default:
 709             return nullptr;
 710         }
 711 
 712         range.consumeIncludingWhitespace();
 713     }
 714 
 715     switch (variant) {
 716     case FontVariantEastAsianVariant::Normal:
 717         break;
 718     case FontVariantEastAsianVariant::Jis78:
 719         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis78));
 720         break;
 721     case FontVariantEastAsianVariant::Jis83:
 722         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis83));
 723         break;
 724     case FontVariantEastAsianVariant::Jis90:
 725         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis90));
 726         break;
 727     case FontVariantEastAsianVariant::Jis04:
 728         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis04));
 729         break;
 730     case FontVariantEastAsianVariant::Simplified:
 731         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSimplified));
 732         break;
 733     case FontVariantEastAsianVariant::Traditional:
 734         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTraditional));
 735         break;
 736     }
 737 
 738     switch (width) {
 739     case FontVariantEastAsianWidth::Normal:
 740         break;
 741     case FontVariantEastAsianWidth::Full:
 742         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
 743         break;
 744     case FontVariantEastAsianWidth::Proportional:
 745         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
 746         break;
 747     }
 748 
 749     switch (ruby) {
 750     case FontVariantEastAsianRuby::Normal:
 751         break;
 752     case FontVariantEastAsianRuby::Yes:
 753         values-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
 754     }
 755 
 756     if (!values-&gt;length())
 757         return nullptr;
 758 
 759     return values;
 760 }
 761 
 762 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantCaps(CSSParserTokenRange&amp; range)
 763 {
 764     return consumeIdent&lt;CSSValueNormal, CSSValueSmallCaps, CSSValueAllSmallCaps,
 765         CSSValuePetiteCaps, CSSValueAllPetiteCaps,
 766         CSSValueUnicase, CSSValueTitlingCaps&gt;(range);
 767 }
 768 
 769 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantAlternates(CSSParserTokenRange&amp; range)
 770 {
 771     return consumeIdent&lt;CSSValueNormal, CSSValueHistoricalForms&gt;(range);
 772 }
 773 
 774 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantPosition(CSSParserTokenRange&amp; range)
 775 {
 776     return consumeIdent&lt;CSSValueNormal, CSSValueSub, CSSValueSuper&gt;(range);
 777 }
 778 
 779 class FontVariantNumericParser {
 780 public:
 781     FontVariantNumericParser()
 782         : m_sawNumericFigureValue(false)
 783         , m_sawNumericSpacingValue(false)
 784         , m_sawNumericFractionValue(false)
 785         , m_sawOrdinalValue(false)
 786         , m_sawSlashedZeroValue(false)
 787         , m_result(CSSValueList::createSpaceSeparated())
 788     {
 789     }
 790 
 791     enum class ParseResult {
 792         ConsumedValue,
 793         DisallowedValue,
 794         UnknownValue
 795     };
 796 
 797     ParseResult consumeNumeric(CSSParserTokenRange&amp; range)
 798     {
 799         CSSValueID valueID = range.peek().id();
 800         switch (valueID) {
 801         case CSSValueLiningNums:
 802         case CSSValueOldstyleNums:
 803             if (m_sawNumericFigureValue)
 804                 return ParseResult::DisallowedValue;
 805             m_sawNumericFigureValue = true;
 806             break;
 807         case CSSValueProportionalNums:
 808         case CSSValueTabularNums:
 809             if (m_sawNumericSpacingValue)
 810                 return ParseResult::DisallowedValue;
 811             m_sawNumericSpacingValue = true;
 812             break;
 813         case CSSValueDiagonalFractions:
 814         case CSSValueStackedFractions:
 815             if (m_sawNumericFractionValue)
 816                 return ParseResult::DisallowedValue;
 817             m_sawNumericFractionValue = true;
 818             break;
 819         case CSSValueOrdinal:
 820             if (m_sawOrdinalValue)
 821                 return ParseResult::DisallowedValue;
 822             m_sawOrdinalValue = true;
 823             break;
 824         case CSSValueSlashedZero:
 825             if (m_sawSlashedZeroValue)
 826                 return ParseResult::DisallowedValue;
 827             m_sawSlashedZeroValue = true;
 828             break;
 829         default:
 830             return ParseResult::UnknownValue;
 831         }
 832         m_result-&gt;append(consumeIdent(range).releaseNonNull());
 833         return ParseResult::ConsumedValue;
 834     }
 835 
 836     RefPtr&lt;CSSValue&gt; finalizeValue()
 837     {
 838         if (!m_result-&gt;length())
 839             return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
 840         return WTFMove(m_result);
 841     }
 842 
 843 
 844 private:
 845     bool m_sawNumericFigureValue;
 846     bool m_sawNumericSpacingValue;
 847     bool m_sawNumericFractionValue;
 848     bool m_sawOrdinalValue;
 849     bool m_sawSlashedZeroValue;
 850     RefPtr&lt;CSSValueList&gt; m_result;
 851 };
 852 
 853 static RefPtr&lt;CSSValue&gt; consumeFontVariantNumeric(CSSParserTokenRange&amp; range)
 854 {
 855     if (range.peek().id() == CSSValueNormal)
 856         return consumeIdent(range);
 857 
 858     FontVariantNumericParser numericParser;
 859     do {
 860         if (numericParser.consumeNumeric(range) !=
 861             FontVariantNumericParser::ParseResult::ConsumedValue)
 862             return nullptr;
 863     } while (!range.atEnd());
 864 
 865     return numericParser.finalizeValue();
 866 }
 867 
 868 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontVariantCSS21(CSSParserTokenRange&amp; range)
 869 {
 870     return consumeIdent&lt;CSSValueNormal, CSSValueSmallCaps&gt;(range);
 871 }
 872 
 873 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeightKeywordValue(CSSParserTokenRange&amp; range)
 874 {
 875     return consumeIdent&lt;CSSValueNormal, CSSValueBold, CSSValueBolder, CSSValueLighter&gt;(range);
 876 }
 877 
 878 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeight(CSSParserTokenRange&amp; range)
 879 {
 880     if (auto result = consumeFontWeightKeywordValue(range))
 881         return result;
 882     return consumeFontWeightNumber(range);
 883 }
 884 
 885 #if ENABLE(VARIATION_FONTS)
 886 static RefPtr&lt;CSSValue&gt; consumeFontWeightRange(CSSParserTokenRange&amp; range)
 887 {
 888     if (auto result = consumeFontWeightKeywordValue(range))
 889         return result;
 890     auto firstNumber = consumeFontWeightNumber(range);
 891     if (!firstNumber)
 892         return nullptr;
 893     if (range.atEnd())
 894         return firstNumber;
 895     auto secondNumber = consumeFontWeightNumber(range);
 896     if (!secondNumber || firstNumber-&gt;floatValue() &gt; secondNumber-&gt;floatValue())
 897         return nullptr;
 898     auto result = CSSValueList::createSpaceSeparated();
 899     result-&gt;append(firstNumber.releaseNonNull());
 900     result-&gt;append(secondNumber.releaseNonNull());
 901     return RefPtr&lt;CSSValue&gt;(WTFMove(result));
 902 }
 903 #endif
 904 
 905 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStretchKeywordValue(CSSParserTokenRange&amp; range)
 906 {
 907     return consumeIdent&lt;CSSValueUltraCondensed, CSSValueExtraCondensed, CSSValueCondensed, CSSValueSemiCondensed, CSSValueNormal, CSSValueSemiExpanded, CSSValueExpanded, CSSValueExtraExpanded, CSSValueUltraExpanded&gt;(range);
 908 }
 909 
 910 #if ENABLE(VARIATION_FONTS)
 911 static bool fontStretchIsWithinRange(float stretch)
 912 {
 913     return stretch &gt; 0;
 914 }
 915 #endif
 916 
 917 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStretch(CSSParserTokenRange&amp; range)
 918 {
 919     if (auto result = consumeFontStretchKeywordValue(range))
 920         return result;
 921 #if ENABLE(VARIATION_FONTS)
 922     if (auto percent = consumePercent(range, ValueRangeNonNegative))
 923         return fontStretchIsWithinRange(percent-&gt;value&lt;float&gt;()) ? percent : nullptr;
 924 #endif
 925     return nullptr;
 926 }
 927 
 928 #if ENABLE(VARIATION_FONTS)
 929 static RefPtr&lt;CSSValue&gt; consumeFontStretchRange(CSSParserTokenRange&amp; range)
 930 {
 931     if (auto result = consumeFontStretchKeywordValue(range))
 932         return result;
 933     auto firstPercent = consumePercent(range, ValueRangeNonNegative);
 934     if (!firstPercent || !fontStretchIsWithinRange(firstPercent-&gt;value&lt;float&gt;()))
 935         return nullptr;
 936     if (range.atEnd())
 937         return firstPercent;
 938     auto secondPercent = consumePercent(range, ValueRangeNonNegative);
 939     if (!secondPercent || !fontStretchIsWithinRange(secondPercent-&gt;value&lt;float&gt;()) || firstPercent-&gt;floatValue() &gt; secondPercent-&gt;floatValue())
 940         return nullptr;
 941     auto result = CSSValueList::createSpaceSeparated();
 942     result-&gt;append(firstPercent.releaseNonNull());
 943     result-&gt;append(secondPercent.releaseNonNull());
 944     return RefPtr&lt;CSSValue&gt;(WTFMove(result));
 945 }
 946 #endif
 947 
 948 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontStyleKeywordValue(CSSParserTokenRange&amp; range)
 949 {
 950     return consumeIdent&lt;CSSValueNormal, CSSValueItalic, CSSValueOblique&gt;(range);
 951 }
 952 
 953 #if ENABLE(VARIATION_FONTS)
 954 static bool fontStyleIsWithinRange(float oblique)
 955 {
 956     return oblique &gt; -90 &amp;&amp; oblique &lt; 90;
 957 }
 958 #endif
 959 
 960 static RefPtr&lt;CSSFontStyleValue&gt; consumeFontStyle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 961 {
 962     auto result = consumeFontStyleKeywordValue(range);
 963     if (!result)
 964         return nullptr;
 965 
 966     auto valueID = result-&gt;valueID();
 967     if (valueID == CSSValueNormal || valueID == CSSValueItalic)
 968         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(valueID));
 969     ASSERT(result-&gt;valueID() == CSSValueOblique);
 970 #if ENABLE(VARIATION_FONTS)
 971     if (!range.atEnd()) {
 972         if (auto angle = consumeAngle(range, cssParserMode)) {
<a name="12" id="anc12"></a><span class="line-modified"> 973             if (fontStyleIsWithinRange(angle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)))</span>
 974                 return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), WTFMove(angle));
 975             return nullptr;
 976         }
 977     }
 978 #else
 979     UNUSED_PARAM(cssParserMode);
 980 #endif
 981     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique));
 982 }
 983 
 984 #if ENABLE(VARIATION_FONTS)
 985 static RefPtr&lt;CSSFontStyleRangeValue&gt; consumeFontStyleRange(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 986 {
 987     auto keyword = consumeFontStyleKeywordValue(range);
 988     if (!keyword)
 989         return nullptr;
 990 
 991     if (keyword-&gt;valueID() != CSSValueOblique || range.atEnd())
 992         return CSSFontStyleRangeValue::create(keyword.releaseNonNull());
 993 
 994     if (auto firstAngle = consumeAngle(range, cssParserMode)) {
<a name="13" id="anc13"></a><span class="line-modified"> 995         if (!fontStyleIsWithinRange(firstAngle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)))</span>
 996             return nullptr;
 997         if (range.atEnd()) {
 998             auto result = CSSValueList::createSpaceSeparated();
 999             result-&gt;append(firstAngle.releaseNonNull());
1000             return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1001         }
1002         auto secondAngle = consumeAngle(range, cssParserMode);
<a name="14" id="anc14"></a><span class="line-modified">1003         if (!secondAngle || !fontStyleIsWithinRange(secondAngle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)) || firstAngle-&gt;floatValue(CSSUnitType::CSS_DEG) &gt; secondAngle-&gt;floatValue(CSSUnitType::CSS_DEG))</span>
1004             return nullptr;
1005         auto result = CSSValueList::createSpaceSeparated();
1006         result-&gt;append(firstAngle.releaseNonNull());
1007         result-&gt;append(secondAngle.releaseNonNull());
1008         return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
1009     }
1010 
1011     return nullptr;
1012 }
1013 #endif
1014 
1015 static String concatenateFamilyName(CSSParserTokenRange&amp; range)
1016 {
1017     StringBuilder builder;
1018     bool addedSpace = false;
1019     const CSSParserToken&amp; firstToken = range.peek();
1020     while (range.peek().type() == IdentToken) {
1021         if (!builder.isEmpty()) {
1022             builder.append(&#39; &#39;);
1023             addedSpace = true;
1024         }
1025         builder.append(range.consumeIncludingWhitespace().value());
1026     }
1027     if (!addedSpace &amp;&amp; isCSSWideKeyword(firstToken.id()))
1028         return String();
1029     return builder.toString();
1030 }
1031 
1032 static RefPtr&lt;CSSValue&gt; consumeFamilyName(CSSParserTokenRange&amp; range)
1033 {
1034     if (range.peek().type() == StringToken)
1035         return CSSValuePool::singleton().createFontFamilyValue(range.consumeIncludingWhitespace().value().toString());
1036     if (range.peek().type() != IdentToken)
1037         return nullptr;
1038     String familyName = concatenateFamilyName(range);
1039     if (familyName.isNull())
1040         return nullptr;
1041     return CSSValuePool::singleton().createFontFamilyValue(familyName);
1042 }
1043 
1044 static RefPtr&lt;CSSValue&gt; consumeGenericFamily(CSSParserTokenRange&amp; range)
1045 {
1046     return consumeIdentRange(range, CSSValueSerif, CSSValueWebkitBody);
1047 }
1048 
1049 static RefPtr&lt;CSSValueList&gt; consumeFontFamily(CSSParserTokenRange&amp; range)
1050 {
1051     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1052     do {
1053         if (auto parsedValue = consumeGenericFamily(range))
1054             list-&gt;append(parsedValue.releaseNonNull());
1055         else {
1056             if (auto parsedValue = consumeFamilyName(range))
1057                 list-&gt;append(parsedValue.releaseNonNull());
1058             else
1059                 return nullptr;
1060         }
1061     } while (consumeCommaIncludingWhitespace(range));
1062     return list;
1063 }
1064 
1065 static RefPtr&lt;CSSValueList&gt; consumeFontFamilyDescriptor(CSSParserTokenRange&amp; range)
1066 {
1067     // FIXME-NEWPARSER: https://bugs.webkit.org/show_bug.cgi?id=196381 For compatibility with the old parser, we have to make
1068     // a list here, even though the list always contains only a single family name.
1069     // Once the old parser is gone, we can delete this function, make the caller
1070     // use consumeFamilyName instead, and then patch the @font-face code to
1071     // not expect a list with a single name in it.
1072     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createCommaSeparated();
1073     RefPtr&lt;CSSValue&gt; parsedValue = consumeFamilyName(range);
1074     if (parsedValue)
1075         list-&gt;append(parsedValue.releaseNonNull());
1076 
1077     if (!range.atEnd() || !list-&gt;length())
1078         return nullptr;
1079 
1080     return list;
1081 }
1082 
1083 static RefPtr&lt;CSSValue&gt; consumeFontSynthesis(CSSParserTokenRange&amp; range)
1084 {
1085     // none | [ weight || style || small-caps ]
1086     CSSValueID id = range.peek().id();
1087     if (id == CSSValueNone)
1088         return consumeIdent(range);
1089 
1090     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1091     while (true) {
1092         auto ident = consumeIdent&lt;CSSValueWeight, CSSValueStyle, CSSValueSmallCaps&gt;(range);
1093         if (!ident)
1094             break;
1095         if (list-&gt;hasValue(ident.get()))
1096             return nullptr;
1097         list-&gt;append(ident.releaseNonNull());
1098     }
1099 
1100     if (!list-&gt;length())
1101         return nullptr;
1102     return list;
1103 }
1104 
1105 static RefPtr&lt;CSSValue&gt; consumeLetterSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1106 {
1107     if (range.peek().id() == CSSValueNormal)
1108         return consumeIdent(range);
1109 
1110     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1111 }
1112 
1113 static RefPtr&lt;CSSValue&gt; consumeWordSpacing(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1114 {
1115     if (range.peek().id() == CSSValueNormal)
1116         return consumeIdent(range);
1117 
1118     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1119 }
1120 
1121 static RefPtr&lt;CSSValue&gt; consumeTabSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1122 {
1123     auto tabSize = consumeNumber(range, ValueRangeNonNegative);
1124     if (tabSize)
1125         return tabSize;
1126     return consumeLength(range, cssParserMode, ValueRangeNonNegative);
1127 }
1128 
1129 #if ENABLE(TEXT_AUTOSIZING)
1130 static RefPtr&lt;CSSValue&gt; consumeTextSizeAdjust(CSSParserTokenRange&amp; range, CSSParserMode /* cssParserMode */)
1131 {
1132     if (range.peek().id() == CSSValueAuto)
1133         return consumeIdent(range);
1134     if (range.peek().id() == CSSValueNone)
1135         return consumeIdent(range);
1136     return consumePercent(range, ValueRangeNonNegative);
1137 }
1138 #endif
1139 
1140 static RefPtr&lt;CSSValue&gt; consumeFontSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1141 {
1142     if (range.peek().id() &gt;= CSSValueXxSmall &amp;&amp; range.peek().id() &lt;= CSSValueLarger)
1143         return consumeIdent(range);
1144     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, unitless);
1145 }
1146 
1147 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineHeight(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1148 {
1149     if (range.peek().id() == CSSValueNormal)
1150         return consumeIdent(range);
1151 
1152     RefPtr&lt;CSSPrimitiveValue&gt; lineHeight = consumeNumber(range, ValueRangeNonNegative);
1153     if (lineHeight)
1154         return lineHeight;
1155     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1156 }
1157 
1158 template&lt;typename... Args&gt;
1159 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
1160 {
1161     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
1162 }
1163 
1164 
1165 static RefPtr&lt;CSSValue&gt; consumeCounter(CSSParserTokenRange&amp; range, int defaultValue)
1166 {
1167     if (range.peek().id() == CSSValueNone)
1168         return consumeIdent(range);
1169 
1170     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1171     do {
1172         RefPtr&lt;CSSPrimitiveValue&gt; counterName = consumeCustomIdent(range);
1173         if (!counterName)
1174             return nullptr;
1175         int i = defaultValue;
1176         if (RefPtr&lt;CSSPrimitiveValue&gt; counterValue = consumeInteger(range))
1177             i = counterValue-&gt;intValue();
<a name="15" id="anc15"></a><span class="line-modified">1178         list-&gt;append(createPrimitiveValuePair(counterName.releaseNonNull(), CSSPrimitiveValue::create(i, CSSUnitType::CSS_NUMBER), Pair::IdenticalValueEncoding::Coalesce));</span>
1179     } while (!range.atEnd());
1180     return list;
1181 }
1182 
1183 static RefPtr&lt;CSSValue&gt; consumePageSize(CSSParserTokenRange&amp; range)
1184 {
1185     return consumeIdent&lt;CSSValueA3, CSSValueA4, CSSValueA5, CSSValueB4, CSSValueB5, CSSValueLedger, CSSValueLegal, CSSValueLetter&gt;(range);
1186 }
1187 
1188 static RefPtr&lt;CSSValueList&gt; consumeSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1189 {
1190     RefPtr&lt;CSSValueList&gt; result = CSSValueList::createSpaceSeparated();
1191 
1192     if (range.peek().id() == CSSValueAuto) {
1193         result-&gt;append(consumeIdent(range).releaseNonNull());
1194         return result;
1195     }
1196 
1197     if (RefPtr&lt;CSSValue&gt; width = consumeLength(range, cssParserMode, ValueRangeNonNegative)) {
1198         RefPtr&lt;CSSValue&gt; height = consumeLength(range, cssParserMode, ValueRangeNonNegative);
1199         result-&gt;append(width.releaseNonNull());
1200         if (height)
1201             result-&gt;append(height.releaseNonNull());
1202         return result;
1203     }
1204 
1205     RefPtr&lt;CSSValue&gt; pageSize = consumePageSize(range);
1206     RefPtr&lt;CSSValue&gt; orientation = consumeIdent&lt;CSSValuePortrait, CSSValueLandscape&gt;(range);
1207     if (!pageSize)
1208         pageSize = consumePageSize(range);
1209 
1210     if (!orientation &amp;&amp; !pageSize)
1211         return nullptr;
1212     if (pageSize)
1213         result-&gt;append(pageSize.releaseNonNull());
1214     if (orientation)
1215         result-&gt;append(orientation.releaseNonNull());
1216     return result;
1217 }
1218 
1219 static RefPtr&lt;CSSValue&gt; consumeTextIndent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1220 {
1221     // [ &lt;length&gt; | &lt;percentage&gt; ] &amp;&amp; hanging? &amp;&amp; each-line?
1222     // Keywords only allowed when css3Text is enabled.
1223     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1224 
1225     bool hasLengthOrPercentage = false;
1226 //    bool hasEachLine = false;
1227     bool hasHanging = false;
1228 
1229     do {
1230         if (!hasLengthOrPercentage) {
1231             if (RefPtr&lt;CSSValue&gt; textIndent = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow)) {
1232                 list-&gt;append(*textIndent);
1233                 hasLengthOrPercentage = true;
1234                 continue;
1235             }
1236         }
1237 
1238         CSSValueID id = range.peek().id();
1239  /* FIXME-NEWPARSER: We don&#39;t support this yet.
1240         if (!hasEachLine &amp;&amp; id == CSSValueEachLine) {
1241             list-&gt;append(*consumeIdent(range));
1242             hasEachLine = true;
1243             continue;
1244         }
1245 */
1246 
1247         if (!hasHanging &amp;&amp; id == CSSValueHanging) {
1248             list-&gt;append(consumeIdent(range).releaseNonNull());
1249             hasHanging = true;
1250             continue;
1251         }
1252 
1253         return nullptr;
1254     } while (!range.atEnd());
1255 
1256     if (!hasLengthOrPercentage)
1257         return nullptr;
1258 
1259     return list;
1260 }
1261 
1262 static bool validWidthOrHeightKeyword(CSSValueID id, const CSSParserContext&amp; /*context*/)
1263 {
1264     if (id == CSSValueIntrinsic || id == CSSValueMinIntrinsic || id == CSSValueMinContent || id == CSSValueWebkitMinContent || id == CSSValueMaxContent || id == CSSValueWebkitMaxContent || id == CSSValueWebkitFillAvailable || id == CSSValueFitContent || id == CSSValueWebkitFitContent) {
1265         return true;
1266     }
1267     return false;
1268 }
1269 
1270 static RefPtr&lt;CSSValue&gt; consumeMaxWidthOrHeight(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1271 {
1272     if (range.peek().id() == CSSValueNone || validWidthOrHeightKeyword(range.peek().id(), context))
1273         return consumeIdent(range);
1274     return consumeLengthOrPercent(range, context.mode, ValueRangeNonNegative, unitless);
1275 }
1276 
1277 static RefPtr&lt;CSSValue&gt; consumeWidthOrHeight(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless = UnitlessQuirk::Forbid)
1278 {
1279     if (range.peek().id() == CSSValueAuto || validWidthOrHeightKeyword(range.peek().id(), context))
1280         return consumeIdent(range);
1281     return consumeLengthOrPercent(range, context.mode, ValueRangeNonNegative, unitless);
1282 }
1283 
1284 static RefPtr&lt;CSSValue&gt; consumeMarginOrOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1285 {
1286     if (range.peek().id() == CSSValueAuto)
1287         return consumeIdent(range);
1288     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, unitless);
1289 }
1290 
1291 static RefPtr&lt;CSSPrimitiveValue&gt; consumeClipComponent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1292 {
1293     if (range.peek().id() == CSSValueAuto)
1294         return consumeIdent(range);
1295     return consumeLength(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
1296 }
1297 
1298 static RefPtr&lt;CSSValue&gt; consumeClip(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1299 {
1300     if (range.peek().id() == CSSValueAuto)
1301         return consumeIdent(range);
1302 
1303     if (range.peek().functionId() != CSSValueRect)
1304         return nullptr;
1305 
1306     CSSParserTokenRange args = consumeFunction(range);
1307     // rect(t, r, b, l) || rect(t r b l)
1308     RefPtr&lt;CSSPrimitiveValue&gt; top = consumeClipComponent(args, cssParserMode);
1309     if (!top)
1310         return nullptr;
1311     bool needsComma = consumeCommaIncludingWhitespace(args);
1312     RefPtr&lt;CSSPrimitiveValue&gt; right = consumeClipComponent(args, cssParserMode);
1313     if (!right || (needsComma &amp;&amp; !consumeCommaIncludingWhitespace(args)))
1314         return nullptr;
1315     RefPtr&lt;CSSPrimitiveValue&gt; bottom = consumeClipComponent(args, cssParserMode);
1316     if (!bottom || (needsComma &amp;&amp; !consumeCommaIncludingWhitespace(args)))
1317         return nullptr;
1318     RefPtr&lt;CSSPrimitiveValue&gt; left = consumeClipComponent(args, cssParserMode);
1319     if (!left || !args.atEnd())
1320         return nullptr;
1321 
1322     auto rect = Rect::create();
1323     rect-&gt;setLeft(left.releaseNonNull());
1324     rect-&gt;setTop(top.releaseNonNull());
1325     rect-&gt;setRight(right.releaseNonNull());
1326     rect-&gt;setBottom(bottom.releaseNonNull());
1327     return CSSValuePool::singleton().createValue(WTFMove(rect));
1328 }
1329 
1330 #if ENABLE(POINTER_EVENTS)
1331 static RefPtr&lt;CSSValue&gt; consumeTouchAction(CSSParserTokenRange&amp; range)
1332 {
1333     CSSValueID id = range.peek().id();
1334     if (id == CSSValueNone || id == CSSValueAuto || id == CSSValueManipulation)
1335         return consumeIdent(range);
1336 
1337     auto list = CSSValueList::createSpaceSeparated();
1338     while (true) {
1339         auto ident = consumeIdent&lt;CSSValuePanX, CSSValuePanY, CSSValuePinchZoom&gt;(range);
1340         if (!ident)
1341             break;
1342         if (list-&gt;hasValue(ident.get()))
1343             return nullptr;
1344         list-&gt;append(ident.releaseNonNull());
1345     }
1346 
1347     if (!list-&gt;length())
1348         return nullptr;
1349     return list;
1350 }
1351 #endif
1352 
1353 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineClamp(CSSParserTokenRange&amp; range)
1354 {
1355     RefPtr&lt;CSSPrimitiveValue&gt; clampValue = consumePercent(range, ValueRangeNonNegative);
1356     if (clampValue)
1357         return clampValue;
1358     // When specifying number of lines, don&#39;t allow 0 as a valid value.
1359     return consumePositiveInteger(range);
1360 }
1361 
1362 static RefPtr&lt;CSSValue&gt; consumeAutoOrString(CSSParserTokenRange&amp; range)
1363 {
1364     if (range.peek().id() == CSSValueAuto)
1365         return consumeIdent(range);
1366     return consumeString(range);
1367 }
1368 
1369 static RefPtr&lt;CSSValue&gt; consumeHyphenateLimit(CSSParserTokenRange&amp; range, CSSValueID valueID)
1370 {
1371     if (range.peek().id() == valueID)
1372         return consumeIdent(range);
1373     return consumeNumber(range, ValueRangeNonNegative);
1374 }
1375 
1376 static RefPtr&lt;CSSValue&gt; consumeColumnWidth(CSSParserTokenRange&amp; range)
1377 {
1378     if (range.peek().id() == CSSValueAuto)
1379         return consumeIdent(range);
1380     // Always parse lengths in strict mode here, since it would be ambiguous otherwise when used in
1381     // the &#39;columns&#39; shorthand property.
1382     RefPtr&lt;CSSPrimitiveValue&gt; columnWidth = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
<a name="16" id="anc16"></a><span class="line-modified">1383     if (!columnWidth || columnWidth-&gt;isZero().valueOr(false))</span>
1384         return nullptr;
<a name="17" id="anc17"></a><span class="line-added">1385 </span>
1386     return columnWidth;
1387 }
1388 
1389 static RefPtr&lt;CSSValue&gt; consumeColumnCount(CSSParserTokenRange&amp; range)
1390 {
1391     if (range.peek().id() == CSSValueAuto)
1392         return consumeIdent(range);
1393     return consumePositiveInteger(range);
1394 }
1395 
1396 static RefPtr&lt;CSSValue&gt; consumeGapLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1397 {
1398     if (range.peek().id() == CSSValueNormal)
1399         return consumeIdent(range);
1400     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
1401 }
1402 
1403 static RefPtr&lt;CSSValue&gt; consumeColumnSpan(CSSParserTokenRange&amp; range)
1404 {
1405     return consumeIdent&lt;CSSValueAll, CSSValueNone&gt;(range);
1406 }
1407 
1408 static RefPtr&lt;CSSValue&gt; consumeZoom(CSSParserTokenRange&amp; range, const CSSParserContext&amp; /*context*/)
1409 {
1410     const CSSParserToken&amp; token = range.peek();
1411     RefPtr&lt;CSSPrimitiveValue&gt; zoom;
1412     if (token.type() == IdentToken)
1413         zoom = consumeIdent&lt;CSSValueNormal, CSSValueReset, CSSValueDocument&gt;(range);
1414     else {
1415         zoom = consumePercent(range, ValueRangeNonNegative);
1416         if (!zoom)
1417             zoom = consumeNumber(range, ValueRangeNonNegative);
1418     }
1419     return zoom;
1420 }
1421 
1422 static RefPtr&lt;CSSValue&gt; consumeAnimationIterationCount(CSSParserTokenRange&amp; range)
1423 {
1424     if (range.peek().id() == CSSValueInfinite)
1425         return consumeIdent(range);
1426     return consumeNumber(range, ValueRangeNonNegative);
1427 }
1428 
1429 static RefPtr&lt;CSSValue&gt; consumeAnimationName(CSSParserTokenRange&amp; range)
1430 {
1431     if (range.peek().id() == CSSValueNone)
1432         return consumeIdent(range);
1433 
1434     if (range.peek().type() == StringToken) {
1435         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
1436         if (equalIgnoringASCIICase(token.value(), &quot;none&quot;))
1437             return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1438         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
<a name="18" id="anc18"></a><span class="line-modified">1439         return CSSValuePool::singleton().createValue(token.value().toString(), CSSUnitType::CSS_STRING);</span>
1440     }
1441 
1442     return consumeCustomIdent(range);
1443 }
1444 
1445 static RefPtr&lt;CSSValue&gt; consumeTransitionProperty(CSSParserTokenRange&amp; range)
1446 {
1447     const CSSParserToken&amp; token = range.peek();
1448     if (token.type() != IdentToken)
1449         return nullptr;
1450     if (token.id() == CSSValueNone)
1451         return consumeIdent(range);
1452 
1453     if (CSSPropertyID property = token.parseAsCSSPropertyID()) {
1454         range.consumeIncludingWhitespace();
1455 
1456         // FIXME-NEWPARSER: No reason why we can&#39;t use the &quot;all&quot; property now that it exists.
1457         // The old parser used a value keyword for &quot;all&quot;, though, since it predated support for
1458         // the property.
1459         if (property == CSSPropertyAll)
1460             return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
1461 
1462         // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
1463         return CSSValuePool::singleton().createIdentifierValue(property);
1464     }
1465     return consumeCustomIdent(range);
1466 }
1467 
1468 
1469 static RefPtr&lt;CSSValue&gt; consumeSteps(CSSParserTokenRange&amp; range)
1470 {
1471     ASSERT(range.peek().functionId() == CSSValueSteps);
1472     CSSParserTokenRange rangeCopy = range;
1473     CSSParserTokenRange args = consumeFunction(rangeCopy);
1474 
1475     RefPtr&lt;CSSPrimitiveValue&gt; steps = consumePositiveInteger(args);
1476     if (!steps)
1477         return nullptr;
1478 
1479     // FIXME-NEWPARSER: Support the middle value and change from a boolean to an enum.
1480     bool stepAtStart = false;
1481     if (consumeCommaIncludingWhitespace(args)) {
1482         switch (args.consumeIncludingWhitespace().id()) {
1483             case CSSValueStart:
1484                 stepAtStart = true;
1485             break;
1486             case CSSValueEnd:
1487                 stepAtStart = false;
1488                 break;
1489             default:
1490                 return nullptr;
1491         }
1492     }
1493 
1494     if (!args.atEnd())
1495         return nullptr;
1496 
1497     range = rangeCopy;
1498     return CSSStepsTimingFunctionValue::create(steps-&gt;intValue(), stepAtStart);
1499 }
1500 
1501 static RefPtr&lt;CSSValue&gt; consumeCubicBezier(CSSParserTokenRange&amp; range)
1502 {
1503     ASSERT(range.peek().functionId() == CSSValueCubicBezier);
1504     CSSParserTokenRange rangeCopy = range;
1505     CSSParserTokenRange args = consumeFunction(rangeCopy);
1506 
1507     double x1, y1, x2, y2;
1508     if (consumeNumberRaw(args, x1)
1509         &amp;&amp; x1 &gt;= 0 &amp;&amp; x1 &lt;= 1
1510         &amp;&amp; consumeCommaIncludingWhitespace(args)
1511         &amp;&amp; consumeNumberRaw(args, y1)
1512         &amp;&amp; consumeCommaIncludingWhitespace(args)
1513         &amp;&amp; consumeNumberRaw(args, x2)
1514         &amp;&amp; x2 &gt;= 0 &amp;&amp; x2 &lt;= 1
1515         &amp;&amp; consumeCommaIncludingWhitespace(args)
1516         &amp;&amp; consumeNumberRaw(args, y2)
1517         &amp;&amp; args.atEnd()) {
1518         range = rangeCopy;
1519         return CSSCubicBezierTimingFunctionValue::create(x1, y1, x2, y2);
1520     }
1521 
1522     return nullptr;
1523 }
1524 
1525 static RefPtr&lt;CSSValue&gt; consumeSpringFunction(CSSParserTokenRange&amp; range)
1526 {
1527     ASSERT(range.peek().functionId() == CSSValueSpring);
1528     CSSParserTokenRange rangeCopy = range;
1529     CSSParserTokenRange args = consumeFunction(rangeCopy);
1530 
1531     // Mass must be greater than 0.
1532     double mass;
1533     if (!consumeNumberRaw(args, mass) || mass &lt;= 0)
1534         return nullptr;
1535 
1536     // Stiffness must be greater than 0.
1537     double stiffness;
1538     if (!consumeNumberRaw(args, stiffness) || stiffness &lt;= 0)
1539         return nullptr;
1540 
1541     // Damping coefficient must be greater than or equal to 0.
1542     double damping;
1543     if (!consumeNumberRaw(args, damping) || damping &lt; 0)
1544         return nullptr;
1545 
1546     // Initial velocity may have any value.
1547     double initialVelocity;
1548     if (!consumeNumberRaw(args, initialVelocity))
1549         return nullptr;
1550 
1551     if (!args.atEnd())
1552         return nullptr;
1553 
1554     range = rangeCopy;
1555 
1556     return CSSSpringTimingFunctionValue::create(mass, stiffness, damping, initialVelocity);
1557 }
1558 
1559 static RefPtr&lt;CSSValue&gt; consumeAnimationTimingFunction(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1560 {
1561     CSSValueID id = range.peek().id();
1562     if (id == CSSValueEase || id == CSSValueLinear || id == CSSValueEaseIn
1563         || id == CSSValueEaseOut || id == CSSValueEaseInOut || id == CSSValueStepStart || id == CSSValueStepEnd)
1564         return consumeIdent(range);
1565 
1566     CSSValueID function = range.peek().functionId();
1567     if (function == CSSValueCubicBezier)
1568         return consumeCubicBezier(range);
1569     if (function == CSSValueSteps)
1570         return consumeSteps(range);
1571     if (context.springTimingFunctionEnabled &amp;&amp; function == CSSValueSpring)
1572         return consumeSpringFunction(range);
1573     return nullptr;
1574 }
1575 
1576 static RefPtr&lt;CSSValue&gt; consumeAnimationValue(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1577 {
1578     switch (property) {
1579     case CSSPropertyAnimationDelay:
1580     case CSSPropertyTransitionDelay:
1581         return consumeTime(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
1582     case CSSPropertyAnimationDirection:
1583         return consumeIdent&lt;CSSValueNormal, CSSValueAlternate, CSSValueReverse, CSSValueAlternateReverse&gt;(range);
1584     case CSSPropertyAnimationDuration:
1585     case CSSPropertyTransitionDuration:
1586         return consumeTime(range, context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
1587     case CSSPropertyAnimationFillMode:
1588         return consumeIdent&lt;CSSValueNone, CSSValueForwards, CSSValueBackwards, CSSValueBoth&gt;(range);
1589     case CSSPropertyAnimationIterationCount:
1590         return consumeAnimationIterationCount(range);
1591     case CSSPropertyAnimationName:
1592         return consumeAnimationName(range);
1593     case CSSPropertyAnimationPlayState:
1594         return consumeIdent&lt;CSSValueRunning, CSSValuePaused&gt;(range);
1595     case CSSPropertyTransitionProperty:
1596         return consumeTransitionProperty(range);
1597     case CSSPropertyAnimationTimingFunction:
1598     case CSSPropertyTransitionTimingFunction:
1599         return consumeAnimationTimingFunction(range, context);
1600     default:
1601         ASSERT_NOT_REACHED();
1602         return nullptr;
1603     }
1604 }
1605 
1606 static bool isValidAnimationPropertyList(CSSPropertyID property, const CSSValueList&amp; valueList)
1607 {
1608     if (property != CSSPropertyTransitionProperty || valueList.length() &lt; 2)
1609         return true;
1610     for (auto&amp; value : valueList) {
1611         if (value-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get()).isValueID()
1612             &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get()).valueID() == CSSValueNone)
1613             return false;
1614     }
1615     return true;
1616 }
1617 
1618 static RefPtr&lt;CSSValue&gt; consumeAnimationPropertyList(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
1619 {
1620     RefPtr&lt;CSSValueList&gt; list;
1621     RefPtr&lt;CSSValue&gt; singleton;
1622     do {
1623         RefPtr&lt;CSSValue&gt; currentValue = consumeAnimationValue(property, range, context);
1624         if (!currentValue)
1625             return nullptr;
1626 
1627         if (singleton &amp;&amp; !list) {
1628             list = CSSValueList::createCommaSeparated();
1629             list-&gt;append(singleton.releaseNonNull());
1630         }
1631 
1632         if (list)
1633             list-&gt;append(currentValue.releaseNonNull());
1634         else
1635             singleton = WTFMove(currentValue);
1636 
1637     } while (consumeCommaIncludingWhitespace(range));
1638 
1639     if (list) {
1640         if (!isValidAnimationPropertyList(property, *list))
1641             return nullptr;
1642 
1643         ASSERT(list-&gt;length());
1644         return list;
1645     }
1646 
1647     return singleton;
1648 }
1649 
1650 bool CSSPropertyParser::consumeAnimationShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
1651 {
1652     const unsigned longhandCount = shorthand.length();
1653     RefPtr&lt;CSSValueList&gt; longhands[8];
1654     ASSERT(longhandCount &lt;= 8);
1655     for (size_t i = 0; i &lt; longhandCount; ++i)
1656         longhands[i] = CSSValueList::createCommaSeparated();
1657 
1658     do {
1659         bool parsedLonghand[8] = { false };
1660         do {
1661             bool foundProperty = false;
1662             for (size_t i = 0; i &lt; longhandCount; ++i) {
1663                 if (parsedLonghand[i])
1664                     continue;
1665 
1666                 if (RefPtr&lt;CSSValue&gt; value = consumeAnimationValue(shorthand.properties()[i], m_range, m_context)) {
1667                     parsedLonghand[i] = true;
1668                     foundProperty = true;
1669                     longhands[i]-&gt;append(*value);
1670                     break;
1671                 }
1672             }
1673             if (!foundProperty)
1674                 return false;
1675         } while (!m_range.atEnd() &amp;&amp; m_range.peek().type() != CommaToken);
1676 
1677         // FIXME: This will make invalid longhands, see crbug.com/386459
1678         for (size_t i = 0; i &lt; longhandCount; ++i) {
1679             if (!parsedLonghand[i])
1680                 longhands[i]-&gt;append(CSSValuePool::singleton().createImplicitInitialValue());
1681             parsedLonghand[i] = false;
1682         }
1683     } while (consumeCommaIncludingWhitespace(m_range));
1684 
1685     for (size_t i = 0; i &lt; longhandCount; ++i) {
1686         if (!isValidAnimationPropertyList(shorthand.properties()[i], *longhands[i]))
1687             return false;
1688     }
1689 
1690     for (size_t i = 0; i &lt; longhandCount; ++i)
1691         addProperty(shorthand.properties()[i], shorthand.id(), *longhands[i], important);
1692 
1693     return m_range.atEnd();
1694 }
1695 
1696 static RefPtr&lt;CSSValue&gt; consumeZIndex(CSSParserTokenRange&amp; range)
1697 {
1698     if (range.peek().id() == CSSValueAuto)
1699         return consumeIdent(range);
1700     return consumeInteger(range);
1701 }
1702 
1703 static RefPtr&lt;CSSValue&gt; consumeShadow(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool isBoxShadowProperty)
1704 {
1705     if (range.peek().id() == CSSValueNone)
1706         return consumeIdent(range);
1707 
1708     RefPtr&lt;CSSValueList&gt; shadowValueList = CSSValueList::createCommaSeparated();
1709     do {
1710         if (RefPtr&lt;CSSShadowValue&gt; shadowValue = consumeSingleShadow(range, cssParserMode, isBoxShadowProperty, isBoxShadowProperty))
1711             shadowValueList-&gt;append(*shadowValue);
1712         else
1713             return nullptr;
1714     } while (consumeCommaIncludingWhitespace(range));
1715     return shadowValueList;
1716 }
1717 
1718 static RefPtr&lt;CSSValue&gt; consumeTextDecorationLine(CSSParserTokenRange&amp; range)
1719 {
1720     CSSValueID id = range.peek().id();
1721     if (id == CSSValueNone)
1722         return consumeIdent(range);
1723 
1724     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1725     while (true) {
1726 #if ENABLE(LETTERPRESS)
1727         RefPtr&lt;CSSPrimitiveValue&gt; ident = consumeIdent&lt;CSSValueBlink, CSSValueUnderline, CSSValueOverline, CSSValueLineThrough, CSSValueWebkitLetterpress&gt;(range);
1728 #else
1729         RefPtr&lt;CSSPrimitiveValue&gt; ident = consumeIdent&lt;CSSValueBlink, CSSValueUnderline, CSSValueOverline, CSSValueLineThrough&gt;(range);
1730 #endif
1731         if (!ident)
1732             break;
1733         if (list-&gt;hasValue(ident.get()))
1734             return nullptr;
1735         list-&gt;append(ident.releaseNonNull());
1736     }
1737 
1738     if (!list-&gt;length())
1739         return nullptr;
1740     return list;
1741 }
1742 
1743 static RefPtr&lt;CSSValue&gt; consumeTextDecorationSkip(CSSParserTokenRange&amp; range)
1744 {
1745     CSSValueID id = range.peek().id();
1746     if (id == CSSValueNone)
1747         return consumeIdent(range);
1748 
1749     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1750     while (true) {
1751         auto ident = consumeIdent&lt;CSSValueAuto, CSSValueInk, CSSValueObjects&gt;(range);
1752         if (!ident)
1753             break;
1754         if (list-&gt;hasValue(ident.get()))
1755             return nullptr;
1756         list-&gt;append(ident.releaseNonNull());
1757     }
1758 
1759     if (!list-&gt;length())
1760         return nullptr;
1761     return list;
1762 }
1763 
1764 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisStyle(CSSParserTokenRange&amp; range)
1765 {
1766     CSSValueID id = range.peek().id();
1767     if (id == CSSValueNone)
1768         return consumeIdent(range);
1769 
1770     if (RefPtr&lt;CSSValue&gt; textEmphasisStyle = consumeString(range))
1771         return textEmphasisStyle;
1772 
1773     RefPtr&lt;CSSPrimitiveValue&gt; fill = consumeIdent&lt;CSSValueFilled, CSSValueOpen&gt;(range);
1774     RefPtr&lt;CSSPrimitiveValue&gt; shape = consumeIdent&lt;CSSValueDot, CSSValueCircle, CSSValueDoubleCircle, CSSValueTriangle, CSSValueSesame&gt;(range);
1775     if (!fill)
1776         fill = consumeIdent&lt;CSSValueFilled, CSSValueOpen&gt;(range);
1777     if (fill &amp;&amp; shape) {
1778         RefPtr&lt;CSSValueList&gt; parsedValues = CSSValueList::createSpaceSeparated();
1779         parsedValues-&gt;append(fill.releaseNonNull());
1780         parsedValues-&gt;append(shape.releaseNonNull());
1781         return parsedValues;
1782     }
1783     if (fill)
1784         return fill;
1785     if (shape)
1786         return shape;
1787     return nullptr;
1788 }
1789 
1790 static RefPtr&lt;CSSPrimitiveValue&gt; consumeCaretColor(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1791 {
1792     if (range.peek().id() == CSSValueAuto)
1793         return consumeIdent(range);
1794     return consumeColor(range, cssParserMode);
1795 }
1796 
1797 static RefPtr&lt;CSSValue&gt; consumeOutlineColor(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1798 {
1799     // Allow the special focus color even in HTML Standard parsing mode.
1800     if (range.peek().id() == CSSValueWebkitFocusRingColor)
1801         return consumeIdent(range);
1802     return consumeColor(range, cssParserMode);
1803 }
1804 
1805 static RefPtr&lt;CSSPrimitiveValue&gt; consumeLineWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1806 {
1807     CSSValueID id = range.peek().id();
1808     if (id == CSSValueThin || id == CSSValueMedium || id == CSSValueThick)
1809         return consumeIdent(range);
1810     return consumeLength(range, cssParserMode, ValueRangeNonNegative, unitless);
1811 }
1812 
1813 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBorderWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
1814 {
1815     return consumeLineWidth(range, cssParserMode, unitless);
1816 }
1817 
1818 static RefPtr&lt;CSSPrimitiveValue&gt; consumeTextStrokeWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1819 {
1820     return consumeLineWidth(range, cssParserMode, UnitlessQuirk::Forbid);
1821 }
1822 
1823 static RefPtr&lt;CSSPrimitiveValue&gt; consumeColumnRuleWidth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1824 {
1825     return consumeLineWidth(range, cssParserMode, UnitlessQuirk::Forbid);
1826 }
1827 
1828 static bool consumeTranslate3d(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1829 {
1830     unsigned numberOfArguments = 2;
1831     RefPtr&lt;CSSValue&gt; parsedValue;
1832     do {
1833         parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1834         if (!parsedValue)
1835             return false;
1836         transformValue-&gt;append(*parsedValue);
1837         if (!consumeCommaIncludingWhitespace(args))
1838             return false;
1839     } while (--numberOfArguments);
1840     parsedValue = consumeLength(args, cssParserMode, ValueRangeAll);
1841     if (!parsedValue)
1842         return false;
1843     transformValue-&gt;append(*parsedValue);
1844     return true;
1845 }
1846 
1847 static bool consumeNumbers(CSSParserTokenRange&amp; args, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue, unsigned numberOfArguments)
1848 {
1849     do {
1850         RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeNumber(args, ValueRangeAll);
1851         if (!parsedValue)
1852             return false;
1853         transformValue-&gt;append(parsedValue.releaseNonNull());
1854         if (--numberOfArguments &amp;&amp; !consumeCommaIncludingWhitespace(args))
1855             return false;
1856     } while (numberOfArguments);
1857     return true;
1858 }
1859 
1860 static bool consumePerspective(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, RefPtr&lt;CSSFunctionValue&gt;&amp; transformValue)
1861 {
1862     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(args, cssParserMode, ValueRangeNonNegative);
1863     if (!parsedValue) {
1864         double perspective;
1865         if (!consumeNumberRaw(args, perspective) || perspective &lt; 0)
1866             return false;
<a name="19" id="anc19"></a><span class="line-modified">1867         parsedValue = CSSPrimitiveValue::create(perspective, CSSUnitType::CSS_PX);</span>
1868     }
1869     if (!parsedValue)
1870         return false;
1871     transformValue-&gt;append(parsedValue.releaseNonNull());
1872     return true;
1873 }
1874 
1875 static RefPtr&lt;CSSValue&gt; consumeTransformValue(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1876 {
1877     CSSValueID functionId = range.peek().functionId();
1878     if (functionId == CSSValueInvalid)
1879         return nullptr;
1880     CSSParserTokenRange args = consumeFunction(range);
1881     if (args.atEnd())
1882         return nullptr;
1883 
1884     RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(functionId);
1885     RefPtr&lt;CSSValue&gt; parsedValue;
1886     switch (functionId) {
1887     case CSSValueRotate:
1888     case CSSValueRotateX:
1889     case CSSValueRotateY:
1890     case CSSValueRotateZ:
1891     case CSSValueSkewX:
1892     case CSSValueSkewY:
1893     case CSSValueSkew:
1894         parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1895         if (!parsedValue)
1896             return nullptr;
1897         if (functionId == CSSValueSkew &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1898             transformValue-&gt;append(*parsedValue);
1899             parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1900             if (!parsedValue)
1901                 return nullptr;
1902         }
1903         break;
1904     case CSSValueScaleX:
1905     case CSSValueScaleY:
1906     case CSSValueScaleZ:
1907     case CSSValueScale:
1908         parsedValue = consumeNumber(args, ValueRangeAll);
1909         if (!parsedValue)
1910             return nullptr;
1911         if (functionId == CSSValueScale &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1912             transformValue-&gt;append(*parsedValue);
1913             parsedValue = consumeNumber(args, ValueRangeAll);
1914             if (!parsedValue)
1915                 return nullptr;
1916         }
1917         break;
1918     case CSSValuePerspective:
1919         if (!consumePerspective(args, cssParserMode, transformValue))
1920             return nullptr;
1921         break;
1922     case CSSValueTranslateX:
1923     case CSSValueTranslateY:
1924     case CSSValueTranslate:
1925         parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1926         if (!parsedValue)
1927             return nullptr;
1928         if (functionId == CSSValueTranslate &amp;&amp; consumeCommaIncludingWhitespace(args)) {
1929             transformValue-&gt;append(*parsedValue);
1930             parsedValue = consumeLengthOrPercent(args, cssParserMode, ValueRangeAll);
1931             if (!parsedValue)
1932                 return nullptr;
1933         }
1934         break;
1935     case CSSValueTranslateZ:
1936         parsedValue = consumeLength(args, cssParserMode, ValueRangeAll);
1937         break;
1938     case CSSValueMatrix:
1939     case CSSValueMatrix3d:
1940         if (!consumeNumbers(args, transformValue, (functionId == CSSValueMatrix3d) ? 16 : 6))
1941             return nullptr;
1942         break;
1943     case CSSValueScale3d:
1944         if (!consumeNumbers(args, transformValue, 3))
1945             return nullptr;
1946         break;
1947     case CSSValueRotate3d:
1948         if (!consumeNumbers(args, transformValue, 3) || !consumeCommaIncludingWhitespace(args))
1949             return nullptr;
1950         parsedValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1951         if (!parsedValue)
1952             return nullptr;
1953         break;
1954     case CSSValueTranslate3d:
1955         if (!consumeTranslate3d(args, cssParserMode, transformValue))
1956             return nullptr;
1957         break;
1958     default:
1959         return nullptr;
1960     }
1961     if (parsedValue)
1962         transformValue-&gt;append(*parsedValue);
1963     if (!args.atEnd())
1964         return nullptr;
1965     return transformValue;
1966 }
1967 
1968 static RefPtr&lt;CSSValue&gt; consumeTransform(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1969 {
1970     if (range.peek().id() == CSSValueNone)
1971         return consumeIdent(range);
1972 
1973     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
1974     do {
1975         RefPtr&lt;CSSValue&gt; parsedTransformValue = consumeTransformValue(range, cssParserMode);
1976         if (!parsedTransformValue)
1977             return nullptr;
1978         list-&gt;append(parsedTransformValue.releaseNonNull());
1979     } while (!range.atEnd());
1980 
1981     return list;
1982 }
1983 
1984 template &lt;CSSValueID start, CSSValueID end&gt;
1985 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionLonghand(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
1986 {
1987     if (range.peek().type() == IdentToken) {
1988         CSSValueID id = range.peek().id();
1989         int percent;
1990         if (id == start)
1991             percent = 0;
1992         else if (id == CSSValueCenter)
1993             percent = 50;
1994         else if (id == end)
1995             percent = 100;
1996         else
1997             return nullptr;
1998         range.consumeIncludingWhitespace();
<a name="20" id="anc20"></a><span class="line-modified">1999         return CSSPrimitiveValue::create(percent, CSSUnitType::CSS_PERCENTAGE);</span>
2000     }
2001     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
2002 }
2003 
2004 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionX(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2005 {
2006     return consumePositionLonghand&lt;CSSValueLeft, CSSValueRight&gt;(range, cssParserMode);
2007 }
2008 
2009 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionY(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2010 {
2011     return consumePositionLonghand&lt;CSSValueTop, CSSValueBottom&gt;(range, cssParserMode);
2012 }
2013 
2014 static RefPtr&lt;CSSValue&gt; consumePaintStroke(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2015 {
2016     if (range.peek().id() == CSSValueNone)
2017         return consumeIdent(range);
2018     RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range);
2019     if (url) {
2020         RefPtr&lt;CSSValue&gt; parsedValue;
2021         if (range.peek().id() == CSSValueNone)
2022             parsedValue = consumeIdent(range);
2023         else
2024             parsedValue = consumeColor(range, cssParserMode);
2025         if (parsedValue) {
2026             RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
2027             values-&gt;append(url.releaseNonNull());
2028             values-&gt;append(parsedValue.releaseNonNull());
2029             return values;
2030         }
2031         return url;
2032     }
2033     return consumeColor(range, cssParserMode);
2034 }
2035 
2036 static RefPtr&lt;CSSValue&gt; consumeGlyphOrientation(CSSParserTokenRange&amp; range, CSSParserMode mode, CSSPropertyID property)
2037 {
2038     if (range.peek().id() == CSSValueAuto) {
2039         if (property == CSSPropertyGlyphOrientationVertical)
2040             return consumeIdent(range);
2041         return nullptr;
2042     }
2043 
2044     return consumeAngle(range, mode, UnitlessQuirk::Allow);
2045 }
2046 
2047 static RefPtr&lt;CSSValue&gt; consumePaintOrder(CSSParserTokenRange&amp; range)
2048 {
2049     if (range.peek().id() == CSSValueNormal)
2050         return consumeIdent(range);
2051 
2052     Vector&lt;CSSValueID, 3&gt; paintTypeList;
2053     RefPtr&lt;CSSPrimitiveValue&gt; fill;
2054     RefPtr&lt;CSSPrimitiveValue&gt; stroke;
2055     RefPtr&lt;CSSPrimitiveValue&gt; markers;
2056     do {
2057         CSSValueID id = range.peek().id();
2058         if (id == CSSValueFill &amp;&amp; !fill)
2059             fill = consumeIdent(range);
2060         else if (id == CSSValueStroke &amp;&amp; !stroke)
2061             stroke = consumeIdent(range);
2062         else if (id == CSSValueMarkers &amp;&amp; !markers)
2063             markers = consumeIdent(range);
2064         else
2065             return nullptr;
2066         paintTypeList.append(id);
2067     } while (!range.atEnd());
2068 
2069     // After parsing we serialize the paint-order list. Since it is not possible to
2070     // pop a last list items from CSSValueList without bigger cost, we create the
2071     // list after parsing.
2072     CSSValueID firstPaintOrderType = paintTypeList.at(0);
2073     RefPtr&lt;CSSValueList&gt; paintOrderList = CSSValueList::createSpaceSeparated();
2074     switch (firstPaintOrderType) {
2075     case CSSValueFill:
2076     case CSSValueStroke:
2077         paintOrderList-&gt;append(firstPaintOrderType == CSSValueFill ? fill.releaseNonNull() : stroke.releaseNonNull());
2078         if (paintTypeList.size() &gt; 1) {
2079             if (paintTypeList.at(1) == CSSValueMarkers)
2080                 paintOrderList-&gt;append(markers.releaseNonNull());
2081         }
2082         break;
2083     case CSSValueMarkers:
2084         paintOrderList-&gt;append(markers.releaseNonNull());
2085         if (paintTypeList.size() &gt; 1) {
2086             if (paintTypeList.at(1) == CSSValueStroke)
2087                 paintOrderList-&gt;append(stroke.releaseNonNull());
2088         }
2089         break;
2090     default:
2091         ASSERT_NOT_REACHED();
2092     }
2093 
2094     return paintOrderList;
2095 }
2096 
2097 static RefPtr&lt;CSSValue&gt; consumeNoneOrURI(CSSParserTokenRange&amp; range)
2098 {
2099     if (range.peek().id() == CSSValueNone)
2100         return consumeIdent(range);
2101     return consumeUrl(range);
2102 }
2103 
2104 static RefPtr&lt;CSSValue&gt; consumeFlexBasis(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2105 {
2106     // FIXME: Support intrinsic dimensions too.
2107     if (range.peek().id() == CSSValueAuto)
2108         return consumeIdent(range);
2109     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2110 }
2111 
2112 static RefPtr&lt;CSSValue&gt; consumeKerning(CSSParserTokenRange&amp; range, CSSParserMode mode)
2113 {
2114     RefPtr&lt;CSSValue&gt; result = consumeIdent&lt;CSSValueAuto, CSSValueNormal&gt;(range);
2115     if (result)
2116         return result;
2117     return consumeLength(range, mode, ValueRangeAll, UnitlessQuirk::Allow);
2118 }
2119 
2120 static RefPtr&lt;CSSValue&gt; consumeStrokeDasharray(CSSParserTokenRange&amp; range)
2121 {
2122     CSSValueID id = range.peek().id();
2123     if (id == CSSValueNone)
2124         return consumeIdent(range);
2125 
2126     RefPtr&lt;CSSValueList&gt; dashes = CSSValueList::createCommaSeparated();
2127     do {
2128         RefPtr&lt;CSSPrimitiveValue&gt; dash = consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeNonNegative);
2129         if (!dash || (consumeCommaIncludingWhitespace(range) &amp;&amp; range.atEnd()))
2130             return nullptr;
2131         dashes-&gt;append(dash.releaseNonNull());
2132     } while (!range.atEnd());
2133     return dashes;
2134 }
2135 
2136 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBaselineShift(CSSParserTokenRange&amp; range)
2137 {
2138     CSSValueID id = range.peek().id();
2139     if (id == CSSValueBaseline || id == CSSValueSub || id == CSSValueSuper)
2140         return consumeIdent(range);
2141     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll);
2142 }
2143 
<a name="21" id="anc21"></a><span class="line-modified">2144 static RefPtr&lt;CSSPrimitiveValue&gt; consumeRxOrRy(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)</span>
2145 {
<a name="22" id="anc22"></a><span class="line-modified">2146     if (range.peek().id() == CSSValueAuto)</span>
<span class="line-modified">2147         return consumeIdent(range);</span>
<span class="line-modified">2148     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Forbid);</span>


2149 }
2150 
2151 static RefPtr&lt;CSSValue&gt; consumeCursor(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, bool inQuirksMode)
2152 {
2153     RefPtr&lt;CSSValueList&gt; list;
<a name="23" id="anc23"></a><span class="line-modified">2154     while (RefPtr&lt;CSSValue&gt; image = consumeImage(range, context, { AllowedImageType::URLFunction, AllowedImageType::ImageSet })) {</span>
2155         double num;
2156         IntPoint hotSpot(-1, -1);
2157         bool hotSpotSpecified = false;
2158         if (consumeNumberRaw(range, num)) {
2159             hotSpot.setX(int(num));
2160             if (!consumeNumberRaw(range, num))
2161                 return nullptr;
2162             hotSpot.setY(int(num));
2163             hotSpotSpecified = true;
2164         }
2165 
2166         if (!list)
2167             list = CSSValueList::createCommaSeparated();
2168 
2169         list-&gt;append(CSSCursorImageValue::create(image.releaseNonNull(), hotSpotSpecified, hotSpot, context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No));
2170         if (!consumeCommaIncludingWhitespace(range))
2171             return nullptr;
2172     }
2173 
2174     CSSValueID id = range.peek().id();
2175     RefPtr&lt;CSSValue&gt; cursorType;
2176     if (id == CSSValueHand) {
2177         if (!inQuirksMode) // Non-standard behavior
2178             return nullptr;
2179         cursorType = CSSValuePool::singleton().createIdentifierValue(CSSValuePointer);
2180         range.consumeIncludingWhitespace();
2181     } else if ((id &gt;= CSSValueAuto &amp;&amp; id &lt;= CSSValueWebkitZoomOut) || id == CSSValueCopy || id == CSSValueNone) {
2182         cursorType = consumeIdent(range);
2183     } else {
2184         return nullptr;
2185     }
2186 
2187     if (!list)
2188         return cursorType;
2189     list-&gt;append(cursorType.releaseNonNull());
2190     return list;
2191 }
2192 
2193 static RefPtr&lt;CSSValue&gt; consumeAttr(CSSParserTokenRange args, CSSParserContext context)
2194 {
2195     if (args.peek().type() != IdentToken)
2196         return nullptr;
2197 
2198     CSSParserToken token = args.consumeIncludingWhitespace();
2199     auto attrName = token.value().toAtomString();
2200     if (context.isHTMLDocument)
2201         attrName = attrName.convertToASCIILowercase();
2202 
2203     if (!args.atEnd())
2204         return nullptr;
2205 
2206     // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
2207     // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
2208     // attr() primitive value.
<a name="24" id="anc24"></a><span class="line-modified">2209     return CSSValuePool::singleton().createValue(attrName, CSSUnitType::CSS_ATTR);</span>
2210 }
2211 
2212 static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
2213 {
2214     RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
2215     if (!identifier)
2216         return nullptr;
2217 
2218     RefPtr&lt;CSSPrimitiveValue&gt; separator;
2219     if (!counters)
<a name="25" id="anc25"></a><span class="line-modified">2220         separator = CSSPrimitiveValue::create(String(), CSSUnitType::CSS_STRING);</span>
2221     else {
2222         if (!consumeCommaIncludingWhitespace(args) || args.peek().type() != StringToken)
2223             return nullptr;
<a name="26" id="anc26"></a><span class="line-modified">2224         separator = CSSPrimitiveValue::create(args.consumeIncludingWhitespace().value().toString(), CSSUnitType::CSS_STRING);</span>
2225     }
2226 
2227     RefPtr&lt;CSSPrimitiveValue&gt; listStyle;
2228     if (consumeCommaIncludingWhitespace(args)) {
2229         CSSValueID id = args.peek().id();
2230         if ((id != CSSValueNone &amp;&amp; (id &lt; CSSValueDisc || id &gt; CSSValueKatakanaIroha)))
2231             return nullptr;
2232         listStyle = consumeIdent(args);
2233     } else
2234         listStyle = CSSValuePool::singleton().createIdentifierValue(CSSValueDecimal);
2235 
2236     if (!args.atEnd())
2237         return nullptr;
2238 
2239     // FIXME-NEWPARSER: Should just have a CSSCounterValue.
2240     return CSSValuePool::singleton().createValue(Counter::create(identifier.releaseNonNull(), listStyle.releaseNonNull(), separator.releaseNonNull()));
2241 }
2242 
2243 static RefPtr&lt;CSSValue&gt; consumeContent(CSSParserTokenRange&amp; range, CSSParserContext context)
2244 {
2245     if (identMatches&lt;CSSValueNone, CSSValueNormal&gt;(range.peek().id()))
2246         return consumeIdent(range);
2247 
2248     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
2249 
2250     do {
2251         RefPtr&lt;CSSValue&gt; parsedValue = consumeImage(range, context);
2252         if (!parsedValue)
2253             parsedValue = consumeIdent&lt;CSSValueOpenQuote, CSSValueCloseQuote, CSSValueNoOpenQuote, CSSValueNoCloseQuote&gt;(range);
2254         if (!parsedValue)
2255             parsedValue = consumeString(range);
2256         if (!parsedValue) {
2257             if (range.peek().functionId() == CSSValueAttr)
2258                 parsedValue = consumeAttr(consumeFunction(range), context);
2259             else if (range.peek().functionId() == CSSValueCounter)
2260                 parsedValue = consumeCounterContent(consumeFunction(range), false);
2261             else if (range.peek().functionId() == CSSValueCounters)
2262                 parsedValue = consumeCounterContent(consumeFunction(range), true);
2263             if (!parsedValue)
2264                 return nullptr;
2265         }
2266         values-&gt;append(parsedValue.releaseNonNull());
2267     } while (!range.atEnd());
2268 
2269     return values;
2270 }
2271 
2272 static RefPtr&lt;CSSPrimitiveValue&gt; consumePerspective(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2273 {
2274     if (range.peek().id() == CSSValueNone)
2275         return consumeIdent(range);
2276     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(range, cssParserMode, ValueRangeAll);
2277     if (!parsedValue) {
2278         // FIXME: Make this quirk only apply to the webkit prefixed version of the property.
2279         double perspective;
2280         if (!consumeNumberRaw(range, perspective))
2281             return nullptr;
<a name="27" id="anc27"></a><span class="line-modified">2282         parsedValue = CSSPrimitiveValue::create(perspective, CSSUnitType::CSS_PX);</span>
2283     }
<a name="28" id="anc28"></a><span class="line-modified">2284 </span>
<span class="line-added">2285     if (!parsedValue)</span>
<span class="line-added">2286         return nullptr;</span>
<span class="line-added">2287 </span>
<span class="line-added">2288     if (parsedValue-&gt;isPositive().valueOr(true))</span>
2289         return parsedValue;
<a name="29" id="anc29"></a><span class="line-added">2290 </span>
2291     return nullptr;
2292 }
2293 
2294 #if ENABLE(CSS_SCROLL_SNAP)
2295 
2296 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapAlign(CSSParserTokenRange&amp; range)
2297 {
2298     RefPtr&lt;CSSValueList&gt; alignmentValue = CSSValueList::createSpaceSeparated();
2299     if (RefPtr&lt;CSSPrimitiveValue&gt; firstValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range)) {
2300         alignmentValue-&gt;append(firstValue.releaseNonNull());
2301         if (auto secondValue = consumeIdent&lt;CSSValueNone, CSSValueStart, CSSValueCenter, CSSValueEnd&gt;(range))
2302             alignmentValue-&gt;append(secondValue.releaseNonNull());
2303     }
2304     return alignmentValue-&gt;length() ? alignmentValue : nullptr;
2305 }
2306 
2307 static RefPtr&lt;CSSValueList&gt; consumeScrollSnapType(CSSParserTokenRange&amp; range)
2308 {
2309     RefPtr&lt;CSSValueList&gt; typeValue = CSSValueList::createSpaceSeparated();
2310     RefPtr&lt;CSSPrimitiveValue&gt; secondValue;
2311 
2312     auto firstValue = consumeIdent&lt;CSSValueX, CSSValueY, CSSValueBlock, CSSValueInline, CSSValueBoth&gt;(range);
2313     if (firstValue)
2314         secondValue = consumeIdent&lt;CSSValueProximity, CSSValueMandatory&gt;(range);
2315     else
2316         firstValue = consumeIdent&lt;CSSValueNone, CSSValueProximity, CSSValueMandatory&gt;(range);
2317 
2318     if (!firstValue)
2319         return nullptr;
2320 
2321     typeValue-&gt;append(firstValue.releaseNonNull());
2322     if (secondValue)
2323         typeValue-&gt;append(secondValue.releaseNonNull());
2324 
2325     return typeValue;
2326 }
2327 
2328 #endif
2329 
<a name="30" id="anc30"></a><span class="line-added">2330 static RefPtr&lt;CSSPrimitiveValue&gt; consumeScrollBehavior(CSSParserTokenRange&amp; range)</span>
<span class="line-added">2331 {</span>
<span class="line-added">2332     auto valueID = range.peek().id();</span>
<span class="line-added">2333     if (valueID != CSSValueAuto &amp;&amp; valueID != CSSValueSmooth)</span>
<span class="line-added">2334         return nullptr;</span>
<span class="line-added">2335     return consumeIdent(range);</span>
<span class="line-added">2336 }</span>
<span class="line-added">2337 </span>
2338 static RefPtr&lt;CSSValue&gt; consumeBorderRadiusCorner(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2339 {
2340     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue1 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2341     if (!parsedValue1)
2342         return nullptr;
2343     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue2 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2344     if (!parsedValue2)
2345         parsedValue2 = parsedValue1;
2346     return createPrimitiveValuePair(parsedValue1.releaseNonNull(), parsedValue2.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2347 }
2348 
2349 static RefPtr&lt;CSSValue&gt; consumeTextUnderlineOffset(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2350 {
2351     if (auto value = consumeIdent&lt;CSSValueAuto&gt;(range))
2352         return value;
2353     return consumeLength(range, cssParserMode, ValueRangeAll);
2354 }
2355 
2356 static RefPtr&lt;CSSValue&gt; consumeTextDecorationThickness(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2357 {
2358     if (auto value = consumeIdent&lt;CSSValueAuto, CSSValueFromFont&gt;(range))
2359         return value;
2360     return consumeLength(range, cssParserMode, ValueRangeAll);
2361 }
2362 
2363 static RefPtr&lt;CSSPrimitiveValue&gt; consumeVerticalAlign(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2364 {
2365     RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeIdentRange(range, CSSValueBaseline, CSSValueWebkitBaselineMiddle);
2366     if (!parsedValue)
2367         parsedValue = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2368     return parsedValue;
2369 }
2370 
2371 static RefPtr&lt;CSSPrimitiveValue&gt; consumeShapeRadius(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
2372 {
2373     if (identMatches&lt;CSSValueClosestSide, CSSValueFarthestSide&gt;(args.peek().id()))
2374         return consumeIdent(args);
2375     return consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
2376 }
2377 
2378 static RefPtr&lt;CSSBasicShapeCircle&gt; consumeBasicShapeCircle(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2379 {
2380     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2381     // circle( [&lt;shape-radius&gt;]? [at &lt;position&gt;]? )
2382     RefPtr&lt;CSSBasicShapeCircle&gt; shape = CSSBasicShapeCircle::create();
2383     if (RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeShapeRadius(args, context.mode))
2384         shape-&gt;setRadius(radius.releaseNonNull());
2385     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2386         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2387         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<a name="31" id="anc31"></a><span class="line-modified">2388         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY))</span>
2389             return nullptr;
2390         shape-&gt;setCenterX(centerX.releaseNonNull());
2391         shape-&gt;setCenterY(centerY.releaseNonNull());
2392     }
2393     return shape;
2394 }
2395 
2396 static RefPtr&lt;CSSBasicShapeEllipse&gt; consumeBasicShapeEllipse(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2397 {
2398     // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
2399     // ellipse( [&lt;shape-radius&gt;{2}]? [at &lt;position&gt;]? )
<a name="32" id="anc32"></a><span class="line-modified">2400     auto shape = CSSBasicShapeEllipse::create();</span>
<span class="line-modified">2401     if (auto radiusX = consumeShapeRadius(args, context.mode)) {</span>
<span class="line-added">2402         auto radiusY = consumeShapeRadius(args, context.mode);</span>
<span class="line-added">2403         if (!radiusY)</span>
<span class="line-added">2404             return nullptr;</span>
2405         shape-&gt;setRadiusX(radiusX.releaseNonNull());
<a name="33" id="anc33"></a><span class="line-modified">2406         shape-&gt;setRadiusY(radiusY.releaseNonNull());</span>

2407     }
2408     if (consumeIdent&lt;CSSValueAt&gt;(args)) {
2409         RefPtr&lt;CSSPrimitiveValue&gt; centerX;
2410         RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<a name="34" id="anc34"></a><span class="line-modified">2411         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY))</span>
2412             return nullptr;
2413         shape-&gt;setCenterX(centerX.releaseNonNull());
2414         shape-&gt;setCenterY(centerY.releaseNonNull());
2415     }
2416     return shape;
2417 }
2418 
2419 static RefPtr&lt;CSSBasicShapePolygon&gt; consumeBasicShapePolygon(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2420 {
2421     RefPtr&lt;CSSBasicShapePolygon&gt; shape = CSSBasicShapePolygon::create();
2422     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2423         shape-&gt;setWindRule(args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero);
2424         if (!consumeCommaIncludingWhitespace(args))
2425             return nullptr;
2426     }
2427 
2428     do {
2429         RefPtr&lt;CSSPrimitiveValue&gt; xLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2430         if (!xLength)
2431             return nullptr;
2432         RefPtr&lt;CSSPrimitiveValue&gt; yLength = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2433         if (!yLength)
2434             return nullptr;
2435         shape-&gt;appendPoint(xLength.releaseNonNull(), yLength.releaseNonNull());
2436     } while (consumeCommaIncludingWhitespace(args));
2437     return shape;
2438 }
2439 
2440 static RefPtr&lt;CSSBasicShapePath&gt; consumeBasicShapePath(CSSParserTokenRange&amp; args)
2441 {
2442     WindRule windRule = WindRule::NonZero;
2443     if (identMatches&lt;CSSValueEvenodd, CSSValueNonzero&gt;(args.peek().id())) {
2444         windRule = args.consumeIncludingWhitespace().id() == CSSValueEvenodd ? WindRule::EvenOdd : WindRule::NonZero;
2445         if (!consumeCommaIncludingWhitespace(args))
2446             return nullptr;
2447     }
2448 
2449     if (args.peek().type() != StringToken)
2450         return nullptr;
2451 
2452     auto byteStream = makeUnique&lt;SVGPathByteStream&gt;();
2453     if (!buildSVGPathByteStreamFromString(args.consumeIncludingWhitespace().value().toString(), *byteStream, UnalteredParsing))
2454         return nullptr;
2455 
2456     auto shape = CSSBasicShapePath::create(WTFMove(byteStream));
2457     shape-&gt;setWindRule(windRule);
2458 
2459     return shape;
2460 }
2461 
2462 static void complete4Sides(RefPtr&lt;CSSPrimitiveValue&gt; side[4])
2463 {
2464     if (side[3])
2465         return;
2466     if (!side[2]) {
2467         if (!side[1])
2468             side[1] = side[0];
2469         side[2] = side[0];
2470     }
2471     side[3] = side[1];
2472 }
2473 
2474 static bool consumeRadii(RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4], RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4], CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool useLegacyParsing)
2475 {
2476     unsigned i = 0;
2477     for (; i &lt; 4 &amp;&amp; !range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken; ++i) {
2478         horizontalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2479         if (!horizontalRadii[i])
2480             return false;
2481     }
2482     if (!horizontalRadii[0])
2483         return false;
2484     if (range.atEnd()) {
2485         // Legacy syntax: -webkit-border-radius: l1 l2; is equivalent to border-radius: l1 / l2;
2486         if (useLegacyParsing &amp;&amp; i == 2) {
2487             verticalRadii[0] = horizontalRadii[1];
2488             horizontalRadii[1] = nullptr;
2489         } else {
2490             complete4Sides(horizontalRadii);
2491             for (unsigned i = 0; i &lt; 4; ++i)
2492                 verticalRadii[i] = horizontalRadii[i];
2493             return true;
2494         }
2495     } else {
2496         if (!consumeSlashIncludingWhitespace(range))
2497             return false;
2498         for (i = 0; i &lt; 4 &amp;&amp; !range.atEnd(); ++i) {
2499             verticalRadii[i] = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
2500             if (!verticalRadii[i])
2501                 return false;
2502         }
2503         if (!verticalRadii[0] || !range.atEnd())
2504             return false;
2505     }
2506     complete4Sides(horizontalRadii);
2507     complete4Sides(verticalRadii);
2508     return true;
2509 }
2510 
2511 static RefPtr&lt;CSSBasicShapeInset&gt; consumeBasicShapeInset(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
2512 {
2513     RefPtr&lt;CSSBasicShapeInset&gt; shape = CSSBasicShapeInset::create();
2514     RefPtr&lt;CSSPrimitiveValue&gt; top = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2515     if (!top)
2516         return nullptr;
2517     RefPtr&lt;CSSPrimitiveValue&gt; right = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2518     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
2519     RefPtr&lt;CSSPrimitiveValue&gt; left;
2520     if (right) {
2521         bottom = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2522         if (bottom)
2523             left = consumeLengthOrPercent(args, context.mode, ValueRangeAll);
2524     }
2525     if (left)
2526         shape-&gt;updateShapeSize4Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull(), left.releaseNonNull());
2527     else if (bottom)
2528         shape-&gt;updateShapeSize3Values(top.releaseNonNull(), right.releaseNonNull(), bottom.releaseNonNull());
2529     else if (right)
2530         shape-&gt;updateShapeSize2Values(top.releaseNonNull(), right.releaseNonNull());
2531     else
2532         shape-&gt;updateShapeSize1Value(top.releaseNonNull());
2533 
2534     if (consumeIdent&lt;CSSValueRound&gt;(args)) {
2535         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4] = { 0 };
2536         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4] = { 0 };
2537         if (!consumeRadii(horizontalRadii, verticalRadii, args, context.mode, false))
2538             return nullptr;
2539         shape-&gt;setTopLeftRadius(createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2540         shape-&gt;setTopRightRadius(createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2541         shape-&gt;setBottomRightRadius(createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2542         shape-&gt;setBottomLeftRadius(createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
2543     }
2544     return shape;
2545 }
2546 
<a name="35" id="anc35"></a><span class="line-modified">2547 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBasicShape(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
2548 {
<a name="36" id="anc36"></a>
2549     if (range.peek().type() != FunctionToken)
2550         return nullptr;
2551     CSSValueID id = range.peek().functionId();
2552     CSSParserTokenRange rangeCopy = range;
2553     CSSParserTokenRange args = consumeFunction(rangeCopy);
2554 
2555     // FIXME-NEWPARSER: CSSBasicShape should be a CSSValue, and shapes should not be primitive values.
2556     RefPtr&lt;CSSBasicShape&gt; shape;
2557     if (id == CSSValueCircle)
2558         shape = consumeBasicShapeCircle(args, context);
2559     else if (id == CSSValueEllipse)
2560         shape = consumeBasicShapeEllipse(args, context);
2561     else if (id == CSSValuePolygon)
2562         shape = consumeBasicShapePolygon(args, context);
2563     else if (id == CSSValueInset)
2564         shape = consumeBasicShapeInset(args, context);
2565     else if (id == CSSValuePath)
2566         shape = consumeBasicShapePath(args);
2567     if (!shape)
2568         return nullptr;
2569     range = rangeCopy;
2570 
2571     if (!args.atEnd())
2572         return nullptr;
2573 
2574     return CSSValuePool::singleton().createValue(shape.releaseNonNull());
2575 }
2576 
2577 static RefPtr&lt;CSSValue&gt; consumeBasicShapeOrBox(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2578 {
2579     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2580     bool shapeFound = false;
2581     bool boxFound = false;
2582     while (!range.atEnd() &amp;&amp; !(shapeFound &amp;&amp; boxFound)) {
2583         RefPtr&lt;CSSValue&gt; componentValue;
2584         if (range.peek().type() == FunctionToken &amp;&amp; !shapeFound) {
2585             componentValue = consumeBasicShape(range, context);
2586             shapeFound = true;
2587         } else if (range.peek().type() == IdentToken &amp;&amp; !boxFound) {
2588             componentValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueViewBox&gt;(range);
2589             boxFound = true;
2590         }
2591         if (!componentValue)
2592             return nullptr;
2593         list-&gt;append(componentValue.releaseNonNull());
2594     }
2595 
2596     if (!range.atEnd() || !list-&gt;length())
2597         return nullptr;
2598 
2599     return list;
2600 }
2601 
<a name="37" id="anc37"></a><span class="line-modified">2602 static RefPtr&lt;CSSValue&gt; consumeClipPath(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
2603 {
2604     if (range.peek().id() == CSSValueNone)
2605         return consumeIdent(range);
2606     if (RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range))
2607         return url;
2608     return consumeBasicShapeOrBox(range, context);
2609 }
2610 
2611 static RefPtr&lt;CSSValue&gt; consumeShapeOutside(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2612 {
2613     if (RefPtr&lt;CSSValue&gt; imageValue = consumeImageOrNone(range, context))
2614         return imageValue;
2615     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
2616     if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2617         list-&gt;append(boxValue.releaseNonNull());
<a name="38" id="anc38"></a><span class="line-modified">2618     if (RefPtr&lt;CSSPrimitiveValue&gt; shapeValue = consumeBasicShape(range, context)) {</span>
<span class="line-added">2619         if (shapeValue-&gt;shapeValue()-&gt;type() == CSSBasicShapeCircle::CSSBasicShapePathType)</span>
<span class="line-added">2620             return nullptr;</span>
2621         list-&gt;append(shapeValue.releaseNonNull());
2622         if (list-&gt;length() &lt; 2) {
2623             if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
2624                 list-&gt;append(boxValue.releaseNonNull());
2625         }
2626     }
2627     if (!list-&gt;length())
2628         return nullptr;
2629     return list;
2630 }
2631 
2632 static bool isAuto(CSSValueID id)
2633 {
2634     return identMatches&lt;CSSValueAuto&gt;(id);
2635 }
2636 
2637 static bool isNormalOrStretch(CSSValueID id)
2638 {
2639     return identMatches&lt;CSSValueNormal, CSSValueStretch&gt;(id);
2640 }
2641 
2642 static bool isLeftOrRightKeyword(CSSValueID id)
2643 {
2644     return identMatches&lt;CSSValueLeft, CSSValueRight&gt;(id);
2645 }
2646 
2647 static bool isContentDistributionKeyword(CSSValueID id)
2648 {
2649     return identMatches&lt;CSSValueSpaceBetween, CSSValueSpaceAround, CSSValueSpaceEvenly, CSSValueStretch&gt;(id);
2650 }
2651 
2652 static bool isContentPositionKeyword(CSSValueID id)
2653 {
2654     return identMatches&lt;CSSValueStart, CSSValueEnd, CSSValueCenter, CSSValueFlexStart, CSSValueFlexEnd&gt;(id);
2655 }
2656 
2657 static bool isContentPositionOrLeftOrRightKeyword(CSSValueID id)
2658 {
2659     return isContentPositionKeyword(id) || isLeftOrRightKeyword(id);
2660 }
2661 
2662 static bool isOverflowKeyword(CSSValueID id)
2663 {
2664     return CSSPropertyParserHelpers::identMatches&lt;CSSValueUnsafe, CSSValueSafe&gt;(id);
2665 }
2666 
2667 static bool isBaselineKeyword(CSSValueID id)
2668 {
2669     return identMatches&lt;CSSValueFirst, CSSValueLast, CSSValueBaseline&gt;(id);
2670 }
2671 
2672 static RefPtr&lt;CSSPrimitiveValue&gt; consumeOverflowPositionKeyword(CSSParserTokenRange&amp; range)
2673 {
2674     return isOverflowKeyword(range.peek().id()) ? consumeIdent(range) : nullptr;
2675 }
2676 
2677 static CSSValueID getBaselineKeyword(RefPtr&lt;CSSValue&gt; value)
2678 {
2679     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
2680     if (primitiveValue.pairValue()) {
2681         ASSERT(primitiveValue.pairValue()-&gt;first()-&gt;valueID() == CSSValueLast);
2682         ASSERT(primitiveValue.pairValue()-&gt;second()-&gt;valueID() == CSSValueBaseline);
2683         return CSSValueLastBaseline;
2684     }
2685     ASSERT(primitiveValue.valueID() == CSSValueBaseline);
2686     return CSSValueBaseline;
2687 }
2688 
2689 static RefPtr&lt;CSSValue&gt; consumeBaselineKeyword(CSSParserTokenRange&amp; range)
2690 {
2691     RefPtr&lt;CSSPrimitiveValue&gt; preference = consumeIdent&lt;CSSValueFirst, CSSValueLast&gt;(range);
2692     RefPtr&lt;CSSPrimitiveValue&gt; baseline = consumeIdent&lt;CSSValueBaseline&gt;(range);
2693     if (!baseline)
2694         return nullptr;
2695     if (preference &amp;&amp; preference-&gt;valueID() == CSSValueLast)
2696         return createPrimitiveValuePair(preference.releaseNonNull(), baseline.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2697     return baseline;
2698 }
2699 
2700 using IsPositionKeyword = bool (*)(CSSValueID);
2701 
2702 static RefPtr&lt;CSSValue&gt; consumeContentDistributionOverflowPosition(CSSParserTokenRange&amp; range, IsPositionKeyword isPositionKeyword)
2703 {
2704     ASSERT(isPositionKeyword);
2705     CSSValueID id = range.peek().id();
2706     if (identMatches&lt;CSSValueNormal&gt;(id))
2707         return CSSContentDistributionValue::create(CSSValueInvalid, range.consumeIncludingWhitespace().id(), CSSValueInvalid);
2708 
2709     if (isBaselineKeyword(id)) {
2710         RefPtr&lt;CSSValue&gt; baseline = consumeBaselineKeyword(range);
2711         if (!baseline)
2712             return nullptr;
2713         return CSSContentDistributionValue::create(CSSValueInvalid, getBaselineKeyword(baseline), CSSValueInvalid);
2714     }
2715 
2716     if (isContentDistributionKeyword(id))
2717         return CSSContentDistributionValue::create(range.consumeIncludingWhitespace().id(), CSSValueInvalid, CSSValueInvalid);
2718 
2719     CSSValueID overflow = isOverflowKeyword(id) ? range.consumeIncludingWhitespace().id() : CSSValueInvalid;
2720     if (isPositionKeyword(range.peek().id()))
2721         return CSSContentDistributionValue::create(CSSValueInvalid, range.consumeIncludingWhitespace().id(), overflow);
2722 
2723     return nullptr;
2724 }
2725 
2726 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBorderImageRepeatKeyword(CSSParserTokenRange&amp; range)
2727 {
2728     return consumeIdent&lt;CSSValueStretch, CSSValueRepeat, CSSValueSpace, CSSValueRound&gt;(range);
2729 }
2730 
2731 static RefPtr&lt;CSSValue&gt; consumeBorderImageRepeat(CSSParserTokenRange&amp; range)
2732 {
2733     RefPtr&lt;CSSPrimitiveValue&gt; horizontal = consumeBorderImageRepeatKeyword(range);
2734     if (!horizontal)
2735         return nullptr;
2736     RefPtr&lt;CSSPrimitiveValue&gt; vertical = consumeBorderImageRepeatKeyword(range);
2737     if (!vertical)
2738         vertical = horizontal;
2739     return createPrimitiveValuePair(horizontal.releaseNonNull(), vertical.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
2740 }
2741 
2742 static RefPtr&lt;CSSValue&gt; consumeBorderImageSlice(CSSPropertyID property, CSSParserTokenRange&amp; range)
2743 {
2744     bool fill = consumeIdent&lt;CSSValueFill&gt;(range);
2745     RefPtr&lt;CSSPrimitiveValue&gt; slices[4] = { 0 };
2746 
2747     for (size_t index = 0; index &lt; 4; ++index) {
2748         RefPtr&lt;CSSPrimitiveValue&gt; value = consumePercent(range, ValueRangeNonNegative);
2749         if (!value)
2750             value = consumeNumber(range, ValueRangeNonNegative);
2751         if (!value)
2752             break;
2753         slices[index] = value;
2754     }
2755     if (!slices[0])
2756         return nullptr;
2757     if (consumeIdent&lt;CSSValueFill&gt;(range)) {
2758         if (fill)
2759             return nullptr;
2760         fill = true;
2761     }
2762     complete4Sides(slices);
2763     // FIXME: For backwards compatibility, -webkit-border-image, -webkit-mask-box-image and -webkit-box-reflect have to do a fill by default.
2764     // FIXME: What do we do with -webkit-box-reflect and -webkit-mask-box-image? Probably just have to leave them filling...
2765     if (property == CSSPropertyWebkitBorderImage || property == CSSPropertyWebkitMaskBoxImage || property == CSSPropertyWebkitBoxReflect)
2766         fill = true;
2767 
2768     // Now build a rect value to hold all four of our primitive values.
2769     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2770     auto quad = Quad::create();
2771     quad-&gt;setTop(slices[0].releaseNonNull());
2772     quad-&gt;setRight(slices[1].releaseNonNull());
2773     quad-&gt;setBottom(slices[2].releaseNonNull());
2774     quad-&gt;setLeft(slices[3].releaseNonNull());
2775 
2776     // Make our new border image value now.
2777     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), fill);
2778 }
2779 
2780 static RefPtr&lt;CSSValue&gt; consumeBorderImageOutset(CSSParserTokenRange&amp; range)
2781 {
2782     RefPtr&lt;CSSPrimitiveValue&gt; outsets[4] = { 0 };
2783 
2784     RefPtr&lt;CSSPrimitiveValue&gt; value;
2785     for (size_t index = 0; index &lt; 4; ++index) {
2786         value = consumeNumber(range, ValueRangeNonNegative);
2787         if (!value)
2788             value = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
2789         if (!value)
2790             break;
2791         outsets[index] = value;
2792     }
2793     if (!outsets[0])
2794         return nullptr;
2795     complete4Sides(outsets);
2796 
2797     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2798     auto quad = Quad::create();
2799     quad-&gt;setTop(outsets[0].releaseNonNull());
2800     quad-&gt;setRight(outsets[1].releaseNonNull());
2801     quad-&gt;setBottom(outsets[2].releaseNonNull());
2802     quad-&gt;setLeft(outsets[3].releaseNonNull());
2803 
2804     return CSSValuePool::singleton().createValue(WTFMove(quad));
2805 }
2806 
2807 static RefPtr&lt;CSSValue&gt; consumeBorderImageWidth(CSSParserTokenRange&amp; range)
2808 {
2809     RefPtr&lt;CSSPrimitiveValue&gt; widths[4];
2810 
2811     RefPtr&lt;CSSPrimitiveValue&gt; value;
2812     for (size_t index = 0; index &lt; 4; ++index) {
2813         value = consumeNumber(range, ValueRangeNonNegative);
2814         if (!value)
2815             value = consumeLengthOrPercent(range, HTMLStandardMode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
2816         if (!value)
2817             value = consumeIdent&lt;CSSValueAuto&gt;(range);
2818         if (!value)
2819             break;
2820         widths[index] = value;
2821     }
2822     if (!widths[0])
2823         return nullptr;
2824     complete4Sides(widths);
2825 
2826     // FIXME-NEWPARSER: Should just have a CSSQuadValue.
2827     auto quad = Quad::create();
2828     quad-&gt;setTop(widths[0].releaseNonNull());
2829     quad-&gt;setRight(widths[1].releaseNonNull());
2830     quad-&gt;setBottom(widths[2].releaseNonNull());
2831     quad-&gt;setLeft(widths[3].releaseNonNull());
2832 
2833     return CSSValuePool::singleton().createValue(WTFMove(quad));
2834 }
2835 
2836 static bool consumeBorderImageComponents(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, RefPtr&lt;CSSValue&gt;&amp; source,
2837     RefPtr&lt;CSSValue&gt;&amp; slice, RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; outset, RefPtr&lt;CSSValue&gt;&amp; repeat)
2838 {
2839     do {
2840         if (!source) {
2841             source = consumeImageOrNone(range, context);
2842             if (source)
2843                 continue;
2844         }
2845         if (!repeat) {
2846             repeat = consumeBorderImageRepeat(range);
2847             if (repeat)
2848                 continue;
2849         }
2850         if (!slice) {
2851             slice = consumeBorderImageSlice(property, range);
2852             if (slice) {
2853                 ASSERT(!width &amp;&amp; !outset);
2854                 if (consumeSlashIncludingWhitespace(range)) {
2855                     width = consumeBorderImageWidth(range);
2856                     if (consumeSlashIncludingWhitespace(range)) {
2857                         outset = consumeBorderImageOutset(range);
2858                         if (!outset)
2859                             return false;
2860                     } else if (!width) {
2861                         return false;
2862                     }
2863                 }
2864             } else {
2865                 return false;
2866             }
2867         } else {
2868             return false;
2869         }
2870     } while (!range.atEnd());
2871     return true;
2872 }
2873 
2874 static RefPtr&lt;CSSValue&gt; consumeWebkitBorderImage(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2875 {
2876     RefPtr&lt;CSSValue&gt; source;
2877     RefPtr&lt;CSSValue&gt; slice;
2878     RefPtr&lt;CSSValue&gt; width;
2879     RefPtr&lt;CSSValue&gt; outset;
2880     RefPtr&lt;CSSValue&gt; repeat;
2881     if (consumeBorderImageComponents(property, range, context, source, slice, width, outset, repeat))
2882         return createBorderImageValue(WTFMove(source), WTFMove(slice), WTFMove(width), WTFMove(outset), WTFMove(repeat));
2883     return nullptr;
2884 }
2885 
2886 static RefPtr&lt;CSSValue&gt; consumeReflect(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2887 {
2888     if (range.peek().id() == CSSValueNone)
2889         return consumeIdent(range);
2890 
2891     RefPtr&lt;CSSPrimitiveValue&gt; direction = consumeIdent&lt;CSSValueAbove, CSSValueBelow, CSSValueLeft, CSSValueRight&gt;(range);
2892     if (!direction)
2893         return nullptr;
2894 
2895     RefPtr&lt;CSSPrimitiveValue&gt; offset;
2896     if (range.atEnd())
<a name="39" id="anc39"></a><span class="line-modified">2897         offset = CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_PX);</span>
2898     else {
2899         offset = consumeLengthOrPercent(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
2900         if (!offset)
2901             return nullptr;
2902     }
2903 
2904     RefPtr&lt;CSSValue&gt; mask;
2905     if (!range.atEnd()) {
2906         mask = consumeWebkitBorderImage(CSSPropertyWebkitBoxReflect, range, context);
2907         if (!mask)
2908             return nullptr;
2909     }
2910     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), WTFMove(mask));
2911 }
2912 
<a name="40" id="anc40"></a>











2913 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBlendMode(CSSParserTokenRange&amp; range)
2914 {
2915     CSSValueID id = range.peek().id();
2916     if (id == CSSValueNormal || id == CSSValueOverlay || (id &gt;= CSSValueMultiply &amp;&amp; id &lt;= CSSValueLuminosity))
2917         return consumeIdent(range);
2918     return nullptr;
2919 }
2920 
2921 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundAttachment(CSSParserTokenRange&amp; range)
2922 {
2923     return consumeIdent&lt;CSSValueScroll, CSSValueFixed, CSSValueLocal&gt;(range);
2924 }
2925 
2926 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBox(CSSParserTokenRange&amp; range)
2927 {
2928     return consumeIdent&lt;CSSValueBorderBox, CSSValuePaddingBox, CSSValueContentBox, CSSValueWebkitText&gt;(range);
2929 }
2930 
2931 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundComposite(CSSParserTokenRange&amp; range)
2932 {
2933     return consumeIdentRange(range, CSSValueClear, CSSValuePlusLighter);
2934 }
2935 
2936 static RefPtr&lt;CSSPrimitiveValue&gt; consumeWebkitMaskSourceType(CSSParserTokenRange&amp; range)
2937 {
2938     return consumeIdent&lt;CSSValueAuto, CSSValueAlpha, CSSValueLuminance&gt;(range);
2939 }
2940 
2941 static RefPtr&lt;CSSPrimitiveValue&gt; consumePrefixedBackgroundBox(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; /*context*/)
2942 {
2943     // The values &#39;border&#39;, &#39;padding&#39; and &#39;content&#39; are deprecated and do not apply to the version of the property that has the -webkit- prefix removed.
2944     if (RefPtr&lt;CSSPrimitiveValue&gt; value = consumeIdentRange(range, CSSValueBorder, CSSValuePaddingBox))
2945         return value;
2946     if (range.peek().id() == CSSValueWebkitText || ((property == CSSPropertyWebkitBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; range.peek().id() == CSSValueText))
2947         return consumeIdent(range);
2948     return nullptr;
2949 }
2950 
2951 static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundSize(CSSPropertyID property, CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
2952 {
2953     if (identMatches&lt;CSSValueContain, CSSValueCover&gt;(range.peek().id()))
2954         return consumeIdent(range);
2955 
2956     // FIXME: We&#39;re allowing the unitless quirk on this property because our
2957     // tests assume that. Other browser engines don&#39;t allow it though.
2958     RefPtr&lt;CSSPrimitiveValue&gt; horizontal = consumeIdent&lt;CSSValueAuto&gt;(range);
2959     if (!horizontal)
2960         horizontal = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2961 
2962     RefPtr&lt;CSSPrimitiveValue&gt; vertical;
2963     if (!range.atEnd()) {
2964         if (range.peek().id() == CSSValueAuto) // `auto&#39; is the default
2965             range.consumeIncludingWhitespace();
2966         else
2967             vertical = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
2968     } else if (!vertical &amp;&amp; property == CSSPropertyWebkitBackgroundSize) {
2969         // Legacy syntax: &quot;-webkit-background-size: 10px&quot; is equivalent to &quot;background-size: 10px 10px&quot;.
2970         vertical = horizontal;
2971     }
2972     if (!vertical)
2973         return horizontal;
2974     return createPrimitiveValuePair(horizontal.releaseNonNull(), vertical.releaseNonNull(), property == CSSPropertyWebkitBackgroundSize ? Pair::IdenticalValueEncoding::Coalesce : Pair::IdenticalValueEncoding::DoNotCoalesce);
2975 }
2976 
2977 static RefPtr&lt;CSSValueList&gt; consumeGridAutoFlow(CSSParserTokenRange&amp; range)
2978 {
2979     RefPtr&lt;CSSPrimitiveValue&gt; rowOrColumnValue = consumeIdent&lt;CSSValueRow, CSSValueColumn&gt;(range);
2980     RefPtr&lt;CSSPrimitiveValue&gt; denseAlgorithm = consumeIdent&lt;CSSValueDense&gt;(range);
2981     if (!rowOrColumnValue) {
2982         rowOrColumnValue = consumeIdent&lt;CSSValueRow, CSSValueColumn&gt;(range);
2983         if (!rowOrColumnValue &amp;&amp; !denseAlgorithm)
2984             return nullptr;
2985     }
2986     RefPtr&lt;CSSValueList&gt; parsedValues = CSSValueList::createSpaceSeparated();
2987     if (rowOrColumnValue)
2988         parsedValues-&gt;append(rowOrColumnValue.releaseNonNull());
2989     if (denseAlgorithm)
2990         parsedValues-&gt;append(denseAlgorithm.releaseNonNull());
2991     return parsedValues;
2992 }
2993 
2994 static RefPtr&lt;CSSValue&gt; consumeBackgroundComponent(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
2995 {
2996     switch (property) {
2997     case CSSPropertyBackgroundClip:
2998         return consumeBackgroundBox(range);
2999     case CSSPropertyBackgroundBlendMode:
3000         return consumeBackgroundBlendMode(range);
3001     case CSSPropertyBackgroundAttachment:
3002         return consumeBackgroundAttachment(range);
3003     case CSSPropertyBackgroundOrigin:
3004         return consumeBackgroundBox(range);
3005     case CSSPropertyWebkitMaskComposite:
3006     case CSSPropertyWebkitBackgroundComposite:
3007         return consumeBackgroundComposite(range);
3008     case CSSPropertyWebkitBackgroundClip:
3009     case CSSPropertyWebkitBackgroundOrigin:
3010     case CSSPropertyWebkitMaskClip:
3011     case CSSPropertyWebkitMaskOrigin:
3012         return consumePrefixedBackgroundBox(property, range, context);
3013     case CSSPropertyBackgroundImage:
3014     case CSSPropertyWebkitMaskImage:
3015         return consumeImageOrNone(range, context);
3016     case CSSPropertyWebkitMaskSourceType:
3017         return consumeWebkitMaskSourceType(range);
3018     case CSSPropertyBackgroundPositionX:
3019     case CSSPropertyWebkitMaskPositionX:
3020         return consumePositionX(range, context.mode);
3021     case CSSPropertyBackgroundPositionY:
3022     case CSSPropertyWebkitMaskPositionY:
3023         return consumePositionY(range, context.mode);
3024     case CSSPropertyBackgroundSize:
3025     case CSSPropertyWebkitBackgroundSize:
3026     case CSSPropertyWebkitMaskSize:
3027         return consumeBackgroundSize(property, range, context.mode);
3028     case CSSPropertyBackgroundColor:
3029         return consumeColor(range, context.mode);
3030     default:
3031         break;
3032     };
3033     return nullptr;
3034 }
3035 
3036 static void addBackgroundValue(RefPtr&lt;CSSValue&gt;&amp; list, Ref&lt;CSSValue&gt;&amp;&amp; value)
3037 {
3038     if (list) {
3039         if (!list-&gt;isBaseValueList()) {
3040             RefPtr&lt;CSSValue&gt; firstValue = list;
3041             list = CSSValueList::createCommaSeparated();
3042             downcast&lt;CSSValueList&gt;(*list).append(firstValue.releaseNonNull());
3043         }
3044         downcast&lt;CSSValueList&gt;(*list).append(WTFMove(value));
3045     } else {
3046         // To conserve memory we don&#39;t actually wrap a single value in a list.
3047         list = WTFMove(value);
3048     }
3049 }
3050 
3051 static RefPtr&lt;CSSValue&gt; consumeCommaSeparatedBackgroundComponent(CSSPropertyID property, CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3052 {
3053     RefPtr&lt;CSSValue&gt; result;
3054     do {
3055         RefPtr&lt;CSSValue&gt; value = consumeBackgroundComponent(property, range, context);
3056         if (!value)
3057             return nullptr;
3058         addBackgroundValue(result, value.releaseNonNull());
3059     } while (consumeCommaIncludingWhitespace(range));
3060     return result;
3061 }
3062 
3063 static bool isSelfPositionKeyword(CSSValueID id)
3064 {
3065     return identMatches&lt;CSSValueStart, CSSValueEnd, CSSValueCenter, CSSValueSelfStart, CSSValueSelfEnd, CSSValueFlexStart, CSSValueFlexEnd&gt;(id);
3066 }
3067 
3068 static bool isSelfPositionOrLeftOrRightKeyword(CSSValueID id)
3069 {
3070     return isSelfPositionKeyword(id) || isLeftOrRightKeyword(id);
3071 }
3072 
3073 static RefPtr&lt;CSSValue&gt; consumeSelfPositionOverflowPosition(CSSParserTokenRange&amp; range, IsPositionKeyword isPositionKeyword)
3074 {
3075     ASSERT(isPositionKeyword);
3076     CSSValueID id = range.peek().id();
3077     if (isAuto(id) || isNormalOrStretch(id))
3078         return consumeIdent(range);
3079 
3080     if (isBaselineKeyword(id))
3081         return consumeBaselineKeyword(range);
3082 
3083     RefPtr&lt;CSSPrimitiveValue&gt; overflowPosition = consumeOverflowPositionKeyword(range);
3084     if (!isPositionKeyword(range.peek().id()))
3085         return nullptr;
3086     RefPtr&lt;CSSPrimitiveValue&gt; selfPosition = consumeIdent(range);
3087     if (overflowPosition)
3088         return createPrimitiveValuePair(overflowPosition.releaseNonNull(), selfPosition.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
3089     return selfPosition;
3090 }
3091 
3092 static RefPtr&lt;CSSValue&gt; consumeAlignItems(CSSParserTokenRange&amp; range)
3093 {
3094     // align-items property does not allow the &#39;auto&#39; value.
3095     if (identMatches&lt;CSSValueAuto&gt;(range.peek().id()))
3096         return nullptr;
3097     return consumeSelfPositionOverflowPosition(range, isSelfPositionKeyword);
3098 }
3099 
3100 static RefPtr&lt;CSSValue&gt; consumeJustifyItems(CSSParserTokenRange&amp; range)
3101 {
3102     // justify-items property does not allow the &#39;auto&#39; value.
3103     if (identMatches&lt;CSSValueAuto&gt;(range.peek().id()))
3104         return nullptr;
3105     CSSParserTokenRange rangeCopy = range;
3106     RefPtr&lt;CSSPrimitiveValue&gt; legacy = consumeIdent&lt;CSSValueLegacy&gt;(rangeCopy);
3107     RefPtr&lt;CSSPrimitiveValue&gt; positionKeyword = consumeIdent&lt;CSSValueCenter, CSSValueLeft, CSSValueRight&gt;(rangeCopy);
3108     if (!legacy)
3109         legacy = consumeIdent&lt;CSSValueLegacy&gt;(rangeCopy);
3110     if (legacy) {
3111         range = rangeCopy;
3112         if (positionKeyword)
3113             return createPrimitiveValuePair(legacy.releaseNonNull(), positionKeyword.releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce);
3114         return legacy;
3115     }
3116     return consumeSelfPositionOverflowPosition(range, isSelfPositionOrLeftOrRightKeyword);
3117 }
3118 
3119 static RefPtr&lt;CSSValue&gt; consumeFitContent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3120 {
3121     CSSParserTokenRange rangeCopy = range;
3122     CSSParserTokenRange args = consumeFunction(rangeCopy);
3123     RefPtr&lt;CSSPrimitiveValue&gt; length = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3124     if (!length || !args.atEnd())
3125         return nullptr;
3126     range = rangeCopy;
3127     RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueFitContent);
3128     result-&gt;append(length.releaseNonNull());
3129     return result;
3130 }
3131 
3132 static RefPtr&lt;CSSPrimitiveValue&gt; consumeCustomIdentForGridLine(CSSParserTokenRange&amp; range)
3133 {
3134     if (range.peek().id() == CSSValueAuto || range.peek().id() == CSSValueSpan)
3135         return nullptr;
3136     return consumeCustomIdent(range);
3137 }
3138 
3139 static RefPtr&lt;CSSValue&gt; consumeGridLine(CSSParserTokenRange&amp; range)
3140 {
3141     if (range.peek().id() == CSSValueAuto)
3142         return consumeIdent(range);
3143 
3144     RefPtr&lt;CSSPrimitiveValue&gt; spanValue;
3145     RefPtr&lt;CSSPrimitiveValue&gt; gridLineName;
3146     RefPtr&lt;CSSPrimitiveValue&gt; numericValue = consumeInteger(range);
3147     if (numericValue) {
3148         gridLineName = consumeCustomIdentForGridLine(range);
3149         spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3150     } else {
3151         spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3152         if (spanValue) {
3153             numericValue = consumeInteger(range);
3154             gridLineName = consumeCustomIdentForGridLine(range);
3155             if (!numericValue)
3156                 numericValue = consumeInteger(range);
3157         } else {
3158             gridLineName = consumeCustomIdentForGridLine(range);
3159             if (gridLineName) {
3160                 numericValue = consumeInteger(range);
3161                 spanValue = consumeIdent&lt;CSSValueSpan&gt;(range);
3162                 if (!spanValue &amp;&amp; !numericValue)
3163                     return gridLineName;
3164             } else {
3165                 return nullptr;
3166             }
3167         }
3168     }
3169 
3170     if (spanValue &amp;&amp; !numericValue &amp;&amp; !gridLineName)
3171         return nullptr; // &quot;span&quot; keyword alone is invalid.
3172     if (spanValue &amp;&amp; numericValue &amp;&amp; numericValue-&gt;intValue() &lt; 0)
3173         return nullptr; // Negative numbers are not allowed for span.
3174     if (numericValue &amp;&amp; numericValue-&gt;intValue() == 0)
3175         return nullptr; // An &lt;integer&gt; value of zero makes the declaration invalid.
3176 
3177     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
3178     if (spanValue)
3179         values-&gt;append(spanValue.releaseNonNull());
3180     if (numericValue)
3181         values-&gt;append(numericValue.releaseNonNull());
3182     if (gridLineName)
3183         values-&gt;append(gridLineName.releaseNonNull());
3184     ASSERT(values-&gt;length());
3185     return values;
3186 }
3187 
3188 static bool isGridTrackFixedSized(const CSSPrimitiveValue&amp; primitiveValue)
3189 {
3190     CSSValueID valueID = primitiveValue.valueID();
3191     if (valueID == CSSValueMinContent || valueID == CSSValueWebkitMinContent || valueID == CSSValueMaxContent || valueID == CSSValueWebkitMaxContent || valueID == CSSValueAuto || primitiveValue.isFlex())
3192         return false;
3193 
3194     return true;
3195 }
3196 
3197 static bool isGridTrackFixedSized(const CSSValue&amp; value)
3198 {
3199     if (value.isPrimitiveValue())
3200         return isGridTrackFixedSized(downcast&lt;CSSPrimitiveValue&gt;(value));
3201 
3202     ASSERT(value.isFunctionValue());
3203     auto&amp; function = downcast&lt;CSSFunctionValue&gt;(value);
3204     if (function.name() == CSSValueFitContent || function.length() &lt; 2)
3205         return false;
3206 
3207     const CSSValue* minPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(function.item(0));
3208     const CSSValue* maxPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(function.item(1));
3209     return isGridTrackFixedSized(*minPrimitiveValue) || isGridTrackFixedSized(*maxPrimitiveValue);
3210 }
3211 
3212 static Vector&lt;String&gt; parseGridTemplateAreasColumnNames(const String&amp; gridRowNames)
3213 {
3214     ASSERT(!gridRowNames.isEmpty());
3215     Vector&lt;String&gt; columnNames;
3216     // Using StringImpl to avoid checks and indirection in every call to String::operator[].
3217     StringImpl&amp; text = *gridRowNames.impl();
3218 
3219     StringBuilder areaName;
3220     for (unsigned i = 0; i &lt; text.length(); ++i) {
3221         if (isCSSSpace(text[i])) {
3222             if (!areaName.isEmpty()) {
3223                 columnNames.append(areaName.toString());
3224                 areaName.clear();
3225             }
3226             continue;
3227         }
3228         if (text[i] == &#39;.&#39;) {
3229             if (areaName == &quot;.&quot;)
3230                 continue;
3231             if (!areaName.isEmpty()) {
3232                 columnNames.append(areaName.toString());
3233                 areaName.clear();
3234             }
3235         } else {
3236             if (!isNameCodePoint(text[i]))
3237                 return Vector&lt;String&gt;();
3238             if (areaName == &quot;.&quot;) {
3239                 columnNames.append(areaName.toString());
3240                 areaName.clear();
3241             }
3242         }
3243 
3244         areaName.append(text[i]);
3245     }
3246 
3247     if (!areaName.isEmpty())
3248         columnNames.append(areaName.toString());
3249 
3250     return columnNames;
3251 }
3252 
3253 static bool parseGridTemplateAreasRow(const String&amp; gridRowNames, NamedGridAreaMap&amp; gridAreaMap, const size_t rowCount, size_t&amp; columnCount)
3254 {
3255     if (gridRowNames.isAllSpecialCharacters&lt;isCSSSpace&gt;())
3256         return false;
3257 
3258     Vector&lt;String&gt; columnNames = parseGridTemplateAreasColumnNames(gridRowNames);
3259     if (rowCount == 0) {
3260         columnCount = columnNames.size();
3261         if (columnCount == 0)
3262             return false;
3263     } else if (columnCount != columnNames.size()) {
3264         // The declaration is invalid if all the rows don&#39;t have the number of columns.
3265         return false;
3266     }
3267 
3268     for (size_t currentColumn = 0; currentColumn &lt; columnCount; ++currentColumn) {
3269         const String&amp; gridAreaName = columnNames[currentColumn];
3270 
3271         // Unamed areas are always valid (we consider them to be 1x1).
3272         if (gridAreaName == &quot;.&quot;)
3273             continue;
3274 
3275         size_t lookAheadColumn = currentColumn + 1;
3276         while (lookAheadColumn &lt; columnCount &amp;&amp; columnNames[lookAheadColumn] == gridAreaName)
3277             lookAheadColumn++;
3278 
3279         NamedGridAreaMap::iterator gridAreaIt = gridAreaMap.find(gridAreaName);
3280         if (gridAreaIt == gridAreaMap.end()) {
3281             gridAreaMap.add(gridAreaName, GridArea(GridSpan::translatedDefiniteGridSpan(rowCount, rowCount + 1), GridSpan::translatedDefiniteGridSpan(currentColumn, lookAheadColumn)));
3282         } else {
3283             GridArea&amp; gridArea = gridAreaIt-&gt;value;
3284 
3285             // The following checks test that the grid area is a single filled-in rectangle.
3286             // 1. The new row is adjacent to the previously parsed row.
3287             if (rowCount != gridArea.rows.endLine())
3288                 return false;
3289 
3290             // 2. The new area starts at the same position as the previously parsed area.
3291             if (currentColumn != gridArea.columns.startLine())
3292                 return false;
3293 
3294             // 3. The new area ends at the same position as the previously parsed area.
3295             if (lookAheadColumn != gridArea.columns.endLine())
3296                 return false;
3297 
3298             gridArea.rows = GridSpan::translatedDefiniteGridSpan(gridArea.rows.startLine(), gridArea.rows.endLine() + 1);
3299         }
3300         currentColumn = lookAheadColumn - 1;
3301     }
3302 
3303     return true;
3304 }
3305 
3306 static RefPtr&lt;CSSPrimitiveValue&gt; consumeGridBreadth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3307 {
3308     const CSSParserToken&amp; token = range.peek();
3309     if (identMatches&lt;CSSValueMinContent, CSSValueWebkitMinContent, CSSValueMaxContent, CSSValueWebkitMaxContent, CSSValueAuto&gt;(token.id()))
3310         return consumeIdent(range);
<a name="41" id="anc41"></a><span class="line-modified">3311     if (token.type() == DimensionToken &amp;&amp; token.unitType() == CSSUnitType::CSS_FR) {</span>
3312         if (range.peek().numericValue() &lt; 0)
3313             return nullptr;
<a name="42" id="anc42"></a><span class="line-modified">3314         return CSSPrimitiveValue::create(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_FR);</span>
3315     }
3316     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3317 }
3318 
3319 static RefPtr&lt;CSSValue&gt; consumeGridTrackSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3320 {
3321     const CSSParserToken&amp; token = range.peek();
3322     if (identMatches&lt;CSSValueAuto&gt;(token.id()))
3323         return consumeIdent(range);
3324 
3325     if (token.functionId() == CSSValueMinmax) {
3326         CSSParserTokenRange rangeCopy = range;
3327         CSSParserTokenRange args = consumeFunction(rangeCopy);
3328         RefPtr&lt;CSSPrimitiveValue&gt; minTrackBreadth = consumeGridBreadth(args, cssParserMode);
3329         if (!minTrackBreadth || minTrackBreadth-&gt;isFlex() || !consumeCommaIncludingWhitespace(args))
3330             return nullptr;
3331         RefPtr&lt;CSSPrimitiveValue&gt; maxTrackBreadth = consumeGridBreadth(args, cssParserMode);
3332         if (!maxTrackBreadth || !args.atEnd())
3333             return nullptr;
3334         range = rangeCopy;
3335         RefPtr&lt;CSSFunctionValue&gt; result = CSSFunctionValue::create(CSSValueMinmax);
3336         result-&gt;append(minTrackBreadth.releaseNonNull());
3337         result-&gt;append(maxTrackBreadth.releaseNonNull());
3338         return result;
3339     }
3340 
3341     if (token.functionId() == CSSValueFitContent)
3342         return consumeFitContent(range, cssParserMode);
3343 
3344     return consumeGridBreadth(range, cssParserMode);
3345 }
3346 
<a name="43" id="anc43"></a><span class="line-modified">3347 // Appends to the passed in CSSGridLineNamesValue if any, otherwise creates a new one. Returns nullptr if an empty list is consumed.</span>
3348 static RefPtr&lt;CSSGridLineNamesValue&gt; consumeGridLineNames(CSSParserTokenRange&amp; range, CSSGridLineNamesValue* lineNames = nullptr)
3349 {
3350     CSSParserTokenRange rangeCopy = range;
3351     if (rangeCopy.consumeIncludingWhitespace().type() != LeftBracketToken)
3352         return nullptr;
3353 
3354     RefPtr&lt;CSSGridLineNamesValue&gt; result = lineNames;
3355     if (!result)
3356         result = CSSGridLineNamesValue::create();
3357     while (RefPtr&lt;CSSPrimitiveValue&gt; lineName = consumeCustomIdentForGridLine(rangeCopy))
3358         result-&gt;append(lineName.releaseNonNull());
3359     if (rangeCopy.consumeIncludingWhitespace().type() != RightBracketToken)
3360         return nullptr;
3361     range = rangeCopy;
<a name="44" id="anc44"></a><span class="line-modified">3362     return result-&gt;length() ? result : nullptr;</span>
3363 }
3364 
3365 static bool consumeGridTrackRepeatFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSValueList&amp; list, bool&amp; isAutoRepeat, bool&amp; allTracksAreFixedSized)
3366 {
3367     CSSParserTokenRange args = consumeFunction(range);
3368     // The number of repetitions for &lt;auto-repeat&gt; is not important at parsing level
3369     // because it will be computed later, let&#39;s set it to 1.
3370     size_t repetitions = 1;
3371     isAutoRepeat = identMatches&lt;CSSValueAutoFill, CSSValueAutoFit&gt;(args.peek().id());
3372     RefPtr&lt;CSSValueList&gt; repeatedValues;
3373     if (isAutoRepeat)
3374         repeatedValues = CSSGridAutoRepeatValue::create(args.consumeIncludingWhitespace().id());
3375     else {
3376         // FIXME: a consumeIntegerRaw would be more efficient here.
3377         RefPtr&lt;CSSPrimitiveValue&gt; repetition = consumePositiveInteger(args);
3378         if (!repetition)
3379             return false;
3380         repetitions = clampTo&lt;size_t&gt;(repetition-&gt;doubleValue(), 0, GridPosition::max());
3381         repeatedValues = CSSValueList::createSpaceSeparated();
3382     }
3383     if (!consumeCommaIncludingWhitespace(args))
3384         return false;
3385     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(args);
3386     if (lineNames)
3387         repeatedValues-&gt;append(lineNames.releaseNonNull());
3388 
3389     size_t numberOfTracks = 0;
3390     while (!args.atEnd()) {
3391         RefPtr&lt;CSSValue&gt; trackSize = consumeGridTrackSize(args, cssParserMode);
3392         if (!trackSize)
3393             return false;
3394         if (allTracksAreFixedSized)
3395             allTracksAreFixedSized = isGridTrackFixedSized(*trackSize);
3396         repeatedValues-&gt;append(trackSize.releaseNonNull());
3397         ++numberOfTracks;
3398         lineNames = consumeGridLineNames(args);
3399         if (lineNames)
3400             repeatedValues-&gt;append(lineNames.releaseNonNull());
3401     }
3402     // We should have found at least one &lt;track-size&gt; or else it is not a valid &lt;track-list&gt;.
3403     if (!numberOfTracks)
3404         return false;
3405 
3406     if (isAutoRepeat)
3407         list.append(repeatedValues.releaseNonNull());
3408     else {
3409         // We clamp the repetitions to a multiple of the repeat() track list&#39;s size, while staying below the max grid size.
3410         repetitions = std::min(repetitions, GridPosition::max() / numberOfTracks);
3411         RefPtr&lt;CSSValueList&gt; integerRepeatedValues = CSSGridIntegerRepeatValue::create(repetitions);
3412         for (size_t i = 0; i &lt; repeatedValues-&gt;length(); ++i)
3413             integerRepeatedValues-&gt;append(*repeatedValues-&gt;itemWithoutBoundsCheck(i));
3414         list.append(integerRepeatedValues.releaseNonNull());
3415     }
3416     return true;
3417 }
3418 
3419 enum TrackListType { GridTemplate, GridTemplateNoRepeat, GridAuto };
3420 
3421 static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
3422 {
3423     bool allowGridLineNames = trackListType != GridAuto;
3424     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
<a name="45" id="anc45"></a><span class="line-added">3425     if (!allowGridLineNames &amp;&amp; range.peek().type() == LeftBracketToken)</span>
<span class="line-added">3426         return nullptr;</span>
3427     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
<a name="46" id="anc46"></a><span class="line-modified">3428     if (lineNames)</span>


3429         values-&gt;append(lineNames.releaseNonNull());
<a name="47" id="anc47"></a>
3430 
3431     bool allowRepeat = trackListType == GridTemplate;
3432     bool seenAutoRepeat = false;
3433     bool allTracksAreFixedSized = true;
3434     do {
3435         bool isAutoRepeat;
3436         if (range.peek().functionId() == CSSValueRepeat) {
3437             if (!allowRepeat)
3438                 return nullptr;
3439             if (!consumeGridTrackRepeatFunction(range, cssParserMode, *values, isAutoRepeat, allTracksAreFixedSized))
3440                 return nullptr;
3441             if (isAutoRepeat &amp;&amp; seenAutoRepeat)
3442                 return nullptr;
3443             seenAutoRepeat = seenAutoRepeat || isAutoRepeat;
3444         } else if (RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(range, cssParserMode)) {
3445             if (allTracksAreFixedSized)
3446                 allTracksAreFixedSized = isGridTrackFixedSized(*value);
3447             values-&gt;append(value.releaseNonNull());
3448         } else {
3449             return nullptr;
3450         }
3451         if (seenAutoRepeat &amp;&amp; !allTracksAreFixedSized)
3452             return nullptr;
<a name="48" id="anc48"></a><span class="line-added">3453         if (!allowGridLineNames &amp;&amp; range.peek().type() == LeftBracketToken)</span>
<span class="line-added">3454             return nullptr;</span>
3455         lineNames = consumeGridLineNames(range);
<a name="49" id="anc49"></a><span class="line-modified">3456         if (lineNames)</span>


3457             values-&gt;append(lineNames.releaseNonNull());
<a name="50" id="anc50"></a>
3458     } while (!range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken);
3459     return values;
3460 }
3461 
3462 static RefPtr&lt;CSSValue&gt; consumeGridTemplatesRowsOrColumns(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3463 {
3464     if (range.peek().id() == CSSValueNone)
3465         return consumeIdent(range);
3466     return consumeGridTrackList(range, cssParserMode, GridTemplate);
3467 }
3468 
3469 static RefPtr&lt;CSSValue&gt; consumeGridTemplateAreas(CSSParserTokenRange&amp; range)
3470 {
3471     if (range.peek().id() == CSSValueNone)
3472         return consumeIdent(range);
3473 
3474     NamedGridAreaMap gridAreaMap;
3475     size_t rowCount = 0;
3476     size_t columnCount = 0;
3477 
3478     while (range.peek().type() == StringToken) {
3479         if (!parseGridTemplateAreasRow(range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
3480             return nullptr;
3481         ++rowCount;
3482     }
3483 
3484     if (rowCount == 0)
3485         return nullptr;
3486     ASSERT(columnCount);
3487     return CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount);
3488 }
3489 
3490 static RefPtr&lt;CSSValue&gt; consumeLineBoxContain(CSSParserTokenRange&amp; range)
3491 {
3492     if (range.peek().id() == CSSValueNone)
3493         return consumeIdent(range);
3494 
<a name="51" id="anc51"></a><span class="line-modified">3495     OptionSet&lt;LineBoxContain&gt; lineBoxContain;</span>
3496 
3497     while (range.peek().type() == IdentToken) {
3498         auto id = range.peek().id();
3499         if (id == CSSValueBlock) {
<a name="52" id="anc52"></a><span class="line-modified">3500             if (lineBoxContain.contains(LineBoxContain::Block))</span>
3501                 return nullptr;
<a name="53" id="anc53"></a><span class="line-modified">3502             lineBoxContain.add(LineBoxContain::Block);</span>
3503         } else if (id == CSSValueInline) {
<a name="54" id="anc54"></a><span class="line-modified">3504             if (lineBoxContain.contains(LineBoxContain::Inline))</span>
3505                 return nullptr;
<a name="55" id="anc55"></a><span class="line-modified">3506             lineBoxContain.add(LineBoxContain::Inline);</span>
3507         } else if (id == CSSValueFont) {
<a name="56" id="anc56"></a><span class="line-modified">3508             if (lineBoxContain.contains(LineBoxContain::Font))</span>
3509                 return nullptr;
<a name="57" id="anc57"></a><span class="line-modified">3510             lineBoxContain.add(LineBoxContain::Font);</span>
3511         } else if (id == CSSValueGlyphs) {
<a name="58" id="anc58"></a><span class="line-modified">3512             if (lineBoxContain.contains(LineBoxContain::Glyphs))</span>
3513                 return nullptr;
<a name="59" id="anc59"></a><span class="line-modified">3514             lineBoxContain.add(LineBoxContain::Glyphs);</span>
3515         } else if (id == CSSValueReplaced) {
<a name="60" id="anc60"></a><span class="line-modified">3516             if (lineBoxContain.contains(LineBoxContain::Replaced))</span>
3517                 return nullptr;
<a name="61" id="anc61"></a><span class="line-modified">3518             lineBoxContain.add(LineBoxContain::Replaced);</span>
3519         } else if (id == CSSValueInlineBox) {
<a name="62" id="anc62"></a><span class="line-modified">3520             if (lineBoxContain.contains(LineBoxContain::InlineBox))</span>
3521                 return nullptr;
<a name="63" id="anc63"></a><span class="line-modified">3522             lineBoxContain.add(LineBoxContain::InlineBox);</span>
3523         } else if (id == CSSValueInitialLetter) {
<a name="64" id="anc64"></a><span class="line-modified">3524             if (lineBoxContain.contains(LineBoxContain::InitialLetter))</span>
3525                 return nullptr;
<a name="65" id="anc65"></a><span class="line-modified">3526             lineBoxContain.add(LineBoxContain::InitialLetter);</span>
3527         } else
3528             return nullptr;
3529         range.consumeIncludingWhitespace();
3530     }
3531 
3532     if (!lineBoxContain)
3533         return nullptr;
3534 
3535     return CSSLineBoxContainValue::create(lineBoxContain);
3536 }
3537 
3538 static RefPtr&lt;CSSValue&gt; consumeLineGrid(CSSParserTokenRange&amp; range)
3539 {
3540     if (range.peek().id() == CSSValueNone)
3541         return consumeIdent(range);
3542     return consumeCustomIdent(range);
3543 }
3544 
3545 static RefPtr&lt;CSSValue&gt; consumeInitialLetter(CSSParserTokenRange&amp; range)
3546 {
3547     RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueNormal&gt;(range);
3548     if (ident)
3549         return ident;
3550 
3551     RefPtr&lt;CSSPrimitiveValue&gt; height = consumeNumber(range, ValueRangeNonNegative);
3552     if (!height)
3553         return nullptr;
3554 
3555     RefPtr&lt;CSSPrimitiveValue&gt; position;
3556     if (!range.atEnd()) {
3557         position = consumeNumber(range, ValueRangeNonNegative);
3558         if (!position || !range.atEnd())
3559             return nullptr;
3560     } else
3561         position = height.copyRef();
3562 
3563     return createPrimitiveValuePair(position.releaseNonNull(), WTFMove(height));
3564 }
3565 
3566 static RefPtr&lt;CSSValue&gt; consumeSpeakAs(CSSParserTokenRange&amp; range)
3567 {
3568     if (range.peek().id() == CSSValueNone)
3569         return consumeIdent(range);
3570 
3571     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3572 
3573     bool seenNormal = false;
3574     bool seenSpellOut = false;
3575     bool seenLiteralPunctuation = false;
3576     bool seenNoPunctuation = false;
3577 
3578     // normal | spell-out || digits || [ literal-punctuation | no-punctuation ]
3579     while (!range.atEnd()) {
3580         CSSValueID valueID = range.peek().id();
3581         if ((valueID == CSSValueNormal &amp;&amp; seenSpellOut)
3582             || (valueID == CSSValueSpellOut &amp;&amp; seenNormal)
3583             || (valueID == CSSValueLiteralPunctuation &amp;&amp; seenNoPunctuation)
3584             || (valueID == CSSValueNoPunctuation &amp;&amp; seenLiteralPunctuation))
3585             return nullptr;
3586         RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueNormal, CSSValueSpellOut, CSSValueDigits, CSSValueLiteralPunctuation, CSSValueNoPunctuation&gt;(range);
3587         if (!ident)
3588             return nullptr;
3589         switch (valueID) {
3590         case CSSValueNormal:
3591             seenNormal = true;
3592             break;
3593         case CSSValueSpellOut:
3594             seenSpellOut = true;
3595             break;
3596         case CSSValueLiteralPunctuation:
3597             seenLiteralPunctuation = true;
3598             break;
3599         case CSSValueNoPunctuation:
3600             seenNoPunctuation = true;
3601             break;
3602         default:
3603             break;
3604         }
3605         list-&gt;append(ident.releaseNonNull());
3606     }
3607 
3608     return list-&gt;length() ? list : nullptr;
3609 }
3610 
3611 static RefPtr&lt;CSSValue&gt; consumeHangingPunctuation(CSSParserTokenRange&amp; range)
3612 {
3613     if (range.peek().id() == CSSValueNone)
3614         return consumeIdent(range);
3615 
3616     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3617 
3618     bool seenForceEnd = false;
3619     bool seenAllowEnd = false;
3620     bool seenFirst = false;
3621     bool seenLast = false;
3622 
3623     while (!range.atEnd()) {
3624         CSSValueID valueID = range.peek().id();
3625         if ((valueID == CSSValueFirst &amp;&amp; seenFirst)
3626             || (valueID == CSSValueLast &amp;&amp; seenLast)
3627             || (valueID == CSSValueAllowEnd &amp;&amp; (seenAllowEnd || seenForceEnd))
3628             || (valueID == CSSValueForceEnd &amp;&amp; (seenAllowEnd || seenForceEnd)))
3629             return nullptr;
3630         RefPtr&lt;CSSValue&gt; ident = consumeIdent&lt;CSSValueAllowEnd, CSSValueForceEnd, CSSValueFirst, CSSValueLast&gt;(range);
3631         if (!ident)
3632             return nullptr;
3633         switch (valueID) {
3634         case CSSValueAllowEnd:
3635             seenAllowEnd = true;
3636             break;
3637         case CSSValueForceEnd:
3638             seenForceEnd = true;
3639             break;
3640         case CSSValueFirst:
3641             seenFirst = true;
3642             break;
3643         case CSSValueLast:
3644             seenLast = true;
3645             break;
3646         default:
3647             break;
3648         }
3649         list-&gt;append(ident.releaseNonNull());
3650     }
3651 
3652     return list-&gt;length() ? list : nullptr;
3653 }
3654 
3655 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeIncrement(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3656 {
<a name="66" id="anc66"></a>

3657     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
3658 }
3659 
3660 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeRepetition(CSSParserTokenRange&amp; range)
3661 {
<a name="67" id="anc67"></a>

3662     return consumeNumber(range, ValueRangeNonNegative);
3663 }
3664 
3665 static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeSpeed(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
3666 {
<a name="68" id="anc68"></a>

3667     return consumeTime(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3668 }
3669 
3670 static RefPtr&lt;CSSValue&gt; consumeAlt(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
3671 {
3672     if (range.peek().type() == StringToken)
3673         return consumeString(range);
3674 
3675     if (range.peek().functionId() != CSSValueAttr)
3676         return nullptr;
3677 
3678     return consumeAttr(consumeFunction(range), context);
3679 }
3680 
3681 static RefPtr&lt;CSSValue&gt; consumeWebkitAspectRatio(CSSParserTokenRange&amp; range)
3682 {
3683     if (range.peek().type() == IdentToken)
3684         return consumeIdent&lt;CSSValueAuto, CSSValueFromDimensions, CSSValueFromIntrinsic&gt;(range);
3685 
3686     RefPtr&lt;CSSPrimitiveValue&gt; leftValue = consumeNumber(range, ValueRangeNonNegative);
<a name="69" id="anc69"></a><span class="line-modified">3687     if (!leftValue || leftValue-&gt;isZero().valueOr(false) || range.atEnd() || !consumeSlashIncludingWhitespace(range))</span>
3688         return nullptr;
<a name="70" id="anc70"></a><span class="line-added">3689 </span>
3690     RefPtr&lt;CSSPrimitiveValue&gt; rightValue = consumeNumber(range, ValueRangeNonNegative);
<a name="71" id="anc71"></a><span class="line-modified">3691     if (!rightValue || rightValue-&gt;isZero().valueOr(false))</span>
3692         return nullptr;
3693 
3694     return CSSAspectRatioValue::create(leftValue-&gt;floatValue(), rightValue-&gt;floatValue());
3695 }
3696 
3697 static RefPtr&lt;CSSValue&gt; consumeTextEmphasisPosition(CSSParserTokenRange&amp; range)
3698 {
3699     bool foundOverOrUnder = false;
3700     CSSValueID overUnderValueID = CSSValueOver;
3701     bool foundLeftOrRight = false;
3702     CSSValueID leftRightValueID = CSSValueRight;
3703     while (!range.atEnd()) {
3704         switch (range.peek().id()) {
3705         case CSSValueOver:
3706             if (foundOverOrUnder)
3707                 return nullptr;
3708             foundOverOrUnder = true;
3709             overUnderValueID = CSSValueOver;
3710             break;
3711         case CSSValueUnder:
3712             if (foundOverOrUnder)
3713                 return nullptr;
3714             foundOverOrUnder = true;
3715             overUnderValueID = CSSValueUnder;
3716             break;
3717         case CSSValueLeft:
3718             if (foundLeftOrRight)
3719                 return nullptr;
3720             foundLeftOrRight = true;
3721             leftRightValueID = CSSValueLeft;
3722             break;
3723         case CSSValueRight:
3724             if (foundLeftOrRight)
3725                 return nullptr;
3726             foundLeftOrRight = true;
3727             leftRightValueID = CSSValueRight;
3728             break;
3729         default:
3730             return nullptr;
3731         }
3732 
3733         range.consumeIncludingWhitespace();
3734     }
3735     if (!foundOverOrUnder)
3736         return nullptr;
3737     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3738     list-&gt;append(CSSValuePool::singleton().createIdentifierValue(overUnderValueID));
3739     if (foundLeftOrRight)
3740         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(leftRightValueID));
3741     return list;
3742 }
3743 
3744 #if ENABLE(DARK_MODE_CSS)
3745 
3746 static RefPtr&lt;CSSValue&gt; consumeColorScheme(CSSParserTokenRange&amp; range)
3747 {
3748     if (isAuto(range.peek().id()))
3749         return consumeIdent(range);
3750 
3751     Vector&lt;CSSValueID, 3&gt; identifiers;
3752 
3753     while (!range.atEnd()) {
3754         if (range.peek().type() != IdentToken)
3755             return nullptr;
3756 
3757         CSSValueID id = range.peek().id();
3758 
3759         switch (id) {
3760         case CSSValueAuto:
3761             // Auto is only allowed as a single value, and was handled earlier.
3762             // Don&#39;t allow it in the list.
3763             return nullptr;
3764 
3765         case CSSValueOnly:
3766         case CSSValueLight:
3767         case CSSValueDark:
3768             if (!identifiers.appendIfNotContains(id))
3769                 return nullptr;
3770             break;
3771 
3772         default:
3773             // Unknown identifiers are allowed and ignored.
3774             break;
3775         }
3776 
3777         range.consumeIncludingWhitespace();
3778     }
3779 
3780     RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
3781     for (auto id : identifiers)
3782         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(id));
3783     return list;
3784 }
3785 
3786 #endif
3787 
3788 RefPtr&lt;CSSValue&gt; CSSPropertyParser::parseSingleValue(CSSPropertyID property, CSSPropertyID currentShorthand)
3789 {
3790     if (CSSParserFastPaths::isKeywordPropertyID(property)) {
3791         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(property, m_range.peek().id(), m_context))
3792             return nullptr;
3793 
3794         return consumeIdent(m_range);
3795     }
3796     switch (property) {
3797     case CSSPropertyWillChange:
3798         return consumeWillChange(m_range);
3799     case CSSPropertyPage:
3800         return consumePage(m_range);
3801     case CSSPropertyQuotes:
3802         return consumeQuotes(m_range);
3803     case CSSPropertyFontVariantCaps:
3804         return consumeFontVariantCaps(m_range);
3805     case CSSPropertyFontVariantLigatures:
3806         return consumeFontVariantLigatures(m_range);
3807     case CSSPropertyFontVariantNumeric:
3808         return consumeFontVariantNumeric(m_range);
3809     case CSSPropertyFontVariantEastAsian:
3810         return consumeFontVariantEastAsian(m_range);
3811     case CSSPropertyFontFeatureSettings:
3812         return consumeFontFeatureSettings(m_range);
3813     case CSSPropertyFontFamily:
3814         return consumeFontFamily(m_range);
3815     case CSSPropertyFontWeight:
3816         return consumeFontWeight(m_range);
3817     case CSSPropertyFontStretch:
3818         return consumeFontStretch(m_range);
3819     case CSSPropertyFontStyle:
3820         return consumeFontStyle(m_range, m_context.mode);
3821     case CSSPropertyFontSynthesis:
3822         return consumeFontSynthesis(m_range);
3823 #if ENABLE(VARIATION_FONTS)
3824     case CSSPropertyFontVariationSettings:
3825         return consumeFontVariationSettings(m_range);
3826 #endif
3827     case CSSPropertyLetterSpacing:
3828         return consumeLetterSpacing(m_range, m_context.mode);
3829     case CSSPropertyWordSpacing:
3830         return consumeWordSpacing(m_range, m_context.mode);
3831     case CSSPropertyTabSize:
3832         return consumeTabSize(m_range, m_context.mode);
3833 #if ENABLE(TEXT_AUTOSIZING)
3834     case CSSPropertyWebkitTextSizeAdjust:
3835         // FIXME: Support toggling the validation of this property via a runtime setting that is independent of
3836         // whether isTextAutosizingEnabled() is true. We want to enable this property on iOS, when simulating
3837         // a iOS device in Safari&#39;s responsive design mode and when optionally enabled in DRT/WTR. Otherwise,
3838         // this property should be disabled by default.
3839 #if !PLATFORM(IOS_FAMILY)
3840         if (!m_context.textAutosizingEnabled)
3841             return nullptr;
3842 #endif
3843         return consumeTextSizeAdjust(m_range, m_context.mode);
3844 #endif
3845     case CSSPropertyFontSize:
3846         return consumeFontSize(m_range, m_context.mode, UnitlessQuirk::Allow);
3847     case CSSPropertyLineHeight:
3848         return consumeLineHeight(m_range, m_context.mode);
3849     case CSSPropertyWebkitBorderHorizontalSpacing:
3850     case CSSPropertyWebkitBorderVerticalSpacing:
3851         return consumeLength(m_range, m_context.mode, ValueRangeNonNegative);
3852     case CSSPropertyCounterIncrement:
3853     case CSSPropertyCounterReset:
3854         return consumeCounter(m_range, property == CSSPropertyCounterIncrement ? 1 : 0);
3855     case CSSPropertySize:
3856         return consumeSize(m_range, m_context.mode);
3857     case CSSPropertyTextIndent:
3858         return consumeTextIndent(m_range, m_context.mode);
3859     case CSSPropertyMaxWidth:
3860     case CSSPropertyMaxHeight:
3861         return consumeMaxWidthOrHeight(m_range, m_context, UnitlessQuirk::Allow);
3862     case CSSPropertyMaxInlineSize:
3863     case CSSPropertyMaxBlockSize:
3864         return consumeMaxWidthOrHeight(m_range, m_context);
3865     case CSSPropertyMinWidth:
3866     case CSSPropertyMinHeight:
3867     case CSSPropertyWidth:
3868     case CSSPropertyHeight:
3869         return consumeWidthOrHeight(m_range, m_context, UnitlessQuirk::Allow);
3870     case CSSPropertyMinInlineSize:
3871     case CSSPropertyMinBlockSize:
3872     case CSSPropertyInlineSize:
3873     case CSSPropertyBlockSize:
3874         return consumeWidthOrHeight(m_range, m_context);
3875     case CSSPropertyMarginTop:
3876     case CSSPropertyMarginRight:
3877     case CSSPropertyMarginBottom:
3878     case CSSPropertyMarginLeft:
3879     case CSSPropertyBottom:
3880     case CSSPropertyLeft:
3881     case CSSPropertyRight:
3882     case CSSPropertyTop: {
3883         UnitlessQuirk unitless = currentShorthand != CSSPropertyInset ? UnitlessQuirk::Allow : UnitlessQuirk::Forbid;
3884         return consumeMarginOrOffset(m_range, m_context.mode, unitless);
3885     }
3886     case CSSPropertyInsetInlineStart:
3887     case CSSPropertyInsetInlineEnd:
3888     case CSSPropertyInsetBlockStart:
3889     case CSSPropertyInsetBlockEnd:
3890     case CSSPropertyMarginInlineStart:
3891     case CSSPropertyMarginInlineEnd:
3892     case CSSPropertyMarginBlockStart:
3893     case CSSPropertyMarginBlockEnd:
3894         return consumeMarginOrOffset(m_range, m_context.mode, UnitlessQuirk::Forbid);
3895     case CSSPropertyPaddingTop:
3896     case CSSPropertyPaddingRight:
3897     case CSSPropertyPaddingBottom:
3898     case CSSPropertyPaddingLeft:
3899         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
3900     case CSSPropertyPaddingInlineStart:
3901     case CSSPropertyPaddingInlineEnd:
3902     case CSSPropertyPaddingBlockStart:
3903     case CSSPropertyPaddingBlockEnd:
3904         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);
3905 #if ENABLE(CSS_SCROLL_SNAP)
3906     case CSSPropertyScrollSnapMarginBottom:
3907     case CSSPropertyScrollSnapMarginLeft:
3908     case CSSPropertyScrollSnapMarginRight:
3909     case CSSPropertyScrollSnapMarginTop:
3910         return consumeLength(m_range, m_context.mode, ValueRangeAll);
3911     case CSSPropertyScrollPaddingBottom:
3912     case CSSPropertyScrollPaddingLeft:
3913     case CSSPropertyScrollPaddingRight:
3914     case CSSPropertyScrollPaddingTop:
3915         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeAll);
3916     case CSSPropertyScrollSnapAlign:
3917         return consumeScrollSnapAlign(m_range);
3918     case CSSPropertyScrollSnapType:
3919         return consumeScrollSnapType(m_range);
3920 #endif
<a name="72" id="anc72"></a><span class="line-added">3921     case CSSPropertyScrollBehavior:</span>
<span class="line-added">3922         if (!m_context.scrollBehaviorEnabled)</span>
<span class="line-added">3923             return nullptr;</span>
<span class="line-added">3924         return consumeScrollBehavior(m_range);</span>
3925     case CSSPropertyClip:
3926         return consumeClip(m_range, m_context.mode);
3927 #if ENABLE(POINTER_EVENTS)
3928     case CSSPropertyTouchAction:
3929         return consumeTouchAction(m_range);
3930 #endif
3931     case CSSPropertyObjectPosition:
<a name="73" id="anc73"></a><span class="line-modified">3932         return consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position);</span>
3933     case CSSPropertyWebkitLineClamp:
3934         return consumeLineClamp(m_range);
3935     case CSSPropertyWebkitFontSizeDelta:
3936         return consumeLength(m_range, m_context.mode, ValueRangeAll, UnitlessQuirk::Allow);
3937     case CSSPropertyWebkitHyphenateCharacter:
3938     case CSSPropertyWebkitLocale:
3939         return consumeAutoOrString(m_range);
3940     case CSSPropertyWebkitHyphenateLimitBefore:
3941     case CSSPropertyWebkitHyphenateLimitAfter:
3942         return consumeHyphenateLimit(m_range, CSSValueAuto);
3943     case CSSPropertyWebkitHyphenateLimitLines:
3944         return consumeHyphenateLimit(m_range, CSSValueNoLimit);
3945     case CSSPropertyColumnWidth:
3946         return consumeColumnWidth(m_range);
3947     case CSSPropertyColumnCount:
3948         return consumeColumnCount(m_range);
3949     case CSSPropertyColumnGap:
3950         return consumeGapLength(m_range, m_context.mode);
3951     case CSSPropertyRowGap:
3952         return consumeGapLength(m_range, m_context.mode);
3953     case CSSPropertyColumnSpan:
3954         return consumeColumnSpan(m_range);
3955     case CSSPropertyZoom:
3956         return consumeZoom(m_range, m_context);
3957     case CSSPropertyAnimationDelay:
3958     case CSSPropertyTransitionDelay:
3959     case CSSPropertyAnimationDirection:
3960     case CSSPropertyAnimationDuration:
3961     case CSSPropertyTransitionDuration:
3962     case CSSPropertyAnimationFillMode:
3963     case CSSPropertyAnimationIterationCount:
3964     case CSSPropertyAnimationName:
3965     case CSSPropertyAnimationPlayState:
3966     case CSSPropertyTransitionProperty:
3967     case CSSPropertyAnimationTimingFunction:
3968     case CSSPropertyTransitionTimingFunction:
3969         return consumeAnimationPropertyList(property, m_range, m_context);
3970     case CSSPropertyShapeMargin:
3971         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
3972     case CSSPropertyShapeImageThreshold:
3973         return consumeNumber(m_range, ValueRangeAll);
3974     case CSSPropertyWebkitBoxOrdinalGroup:
3975     case CSSPropertyOrphans:
3976     case CSSPropertyWidows:
3977         return consumePositiveInteger(m_range);
3978     case CSSPropertyTextDecorationColor:
3979         return consumeColor(m_range, m_context.mode);
3980     case CSSPropertyTextDecorationSkip:
3981         return consumeTextDecorationSkip(m_range);
3982     case CSSPropertyWebkitTextStrokeWidth:
3983         return consumeTextStrokeWidth(m_range, m_context.mode);
3984     case CSSPropertyWebkitTextFillColor:
3985 #if ENABLE(TOUCH_EVENTS)
3986     case CSSPropertyWebkitTapHighlightColor:
3987 #endif
3988     case CSSPropertyWebkitTextEmphasisColor:
3989     case CSSPropertyBorderInlineStartColor:
3990     case CSSPropertyBorderInlineEndColor:
3991     case CSSPropertyBorderBlockStartColor:
3992     case CSSPropertyBorderBlockEndColor:
3993     case CSSPropertyWebkitTextStrokeColor:
3994     case CSSPropertyStrokeColor:
3995     case CSSPropertyStopColor:
3996     case CSSPropertyFloodColor:
3997     case CSSPropertyLightingColor:
3998     case CSSPropertyColumnRuleColor:
3999         return consumeColor(m_range, m_context.mode);
4000     case CSSPropertyCaretColor:
4001         return consumeCaretColor(m_range, m_context.mode);
4002     case CSSPropertyColor:
4003     case CSSPropertyBackgroundColor:
4004         return consumeColor(m_range, m_context.mode, inQuirksMode());
4005     case CSSPropertyBorderInlineStartWidth:
4006     case CSSPropertyBorderInlineEndWidth:
4007     case CSSPropertyBorderBlockStartWidth:
4008     case CSSPropertyBorderBlockEndWidth:
4009         return consumeBorderWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4010     case CSSPropertyBorderBottomColor:
4011     case CSSPropertyBorderLeftColor:
4012     case CSSPropertyBorderRightColor:
4013     case CSSPropertyBorderTopColor: {
4014         bool allowQuirkyColors = inQuirksMode()
4015             &amp;&amp; (currentShorthand == CSSPropertyInvalid || currentShorthand == CSSPropertyBorderColor);
4016         return consumeColor(m_range, m_context.mode, allowQuirkyColors);
4017     }
4018     case CSSPropertyBorderBottomWidth:
4019     case CSSPropertyBorderLeftWidth:
4020     case CSSPropertyBorderRightWidth:
4021     case CSSPropertyBorderTopWidth: {
4022         bool allowQuirkyLengths = inQuirksMode()
4023             &amp;&amp; (currentShorthand == CSSPropertyInvalid || currentShorthand == CSSPropertyBorderWidth);
4024         UnitlessQuirk unitless = allowQuirkyLengths ? UnitlessQuirk::Allow : UnitlessQuirk::Forbid;
4025         return consumeBorderWidth(m_range, m_context.mode, unitless);
4026     }
4027     case CSSPropertyZIndex:
4028         return consumeZIndex(m_range);
4029     case CSSPropertyTextShadow: // CSS2 property, dropped in CSS2.1, back in CSS3, so treat as CSS3
4030     case CSSPropertyBoxShadow:
4031     case CSSPropertyWebkitBoxShadow:
4032         return consumeShadow(m_range, m_context.mode, property == CSSPropertyBoxShadow || property == CSSPropertyWebkitBoxShadow);
4033     case CSSPropertyFilter:
4034 #if ENABLE(FILTERS_LEVEL_2)
4035     case CSSPropertyWebkitBackdropFilter:
4036 #endif
4037         return consumeFilter(m_range, m_context, AllowedFilterFunctions::PixelFilters);
4038     case CSSPropertyAppleColorFilter:
4039         if (!m_context.colorFilterEnabled)
4040             return nullptr;
4041         return consumeFilter(m_range, m_context, AllowedFilterFunctions::ColorFilters);
4042     case CSSPropertyTextDecoration:
4043     case CSSPropertyWebkitTextDecorationsInEffect:
4044     case CSSPropertyTextDecorationLine:
4045         return consumeTextDecorationLine(m_range);
4046     case CSSPropertyWebkitTextEmphasisStyle:
4047         return consumeTextEmphasisStyle(m_range);
4048     case CSSPropertyOutlineColor:
4049         return consumeOutlineColor(m_range, m_context.mode);
4050     case CSSPropertyOutlineOffset:
4051         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4052     case CSSPropertyOutlineWidth:
4053         return consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4054     case CSSPropertyTransform:
4055         return consumeTransform(m_range, m_context.mode);
4056     case CSSPropertyTransformBox:
<a name="74" id="anc74"></a><span class="line-modified">4057         return consumeIdent&lt;CSSValueBorderBox, CSSValueViewBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueContentBox&gt;(m_range);</span>
4058     case CSSPropertyTransformOriginX:
4059     case CSSPropertyPerspectiveOriginX:
4060         return consumePositionX(m_range, m_context.mode);
4061     case CSSPropertyTransformOriginY:
4062     case CSSPropertyPerspectiveOriginY:
4063         return consumePositionY(m_range, m_context.mode);
4064     case CSSPropertyTransformOriginZ:
4065         return consumeLength(m_range, m_context.mode, ValueRangeAll);
4066     case CSSPropertyFill:
4067     case CSSPropertyStroke:
4068         return consumePaintStroke(m_range, m_context.mode);
4069     case CSSPropertyGlyphOrientationVertical:
4070     case CSSPropertyGlyphOrientationHorizontal:
4071         return consumeGlyphOrientation(m_range, m_context.mode, property);
4072     case CSSPropertyPaintOrder:
4073         return consumePaintOrder(m_range);
4074     case CSSPropertyMarkerStart:
4075     case CSSPropertyMarkerMid:
4076     case CSSPropertyMarkerEnd:
<a name="75" id="anc75"></a>
4077     case CSSPropertyMask:
4078         return consumeNoneOrURI(m_range);
4079     case CSSPropertyFlexBasis:
4080         return consumeFlexBasis(m_range, m_context.mode);
4081     case CSSPropertyFlexGrow:
4082     case CSSPropertyFlexShrink:
4083         return consumeNumber(m_range, ValueRangeNonNegative);
4084     case CSSPropertyStrokeDasharray:
4085         return consumeStrokeDasharray(m_range);
4086     case CSSPropertyColumnRuleWidth:
4087         return consumeColumnRuleWidth(m_range, m_context.mode);
4088     case CSSPropertyStrokeOpacity:
4089     case CSSPropertyFillOpacity:
4090     case CSSPropertyStopOpacity:
4091     case CSSPropertyFloodOpacity:
4092     case CSSPropertyOpacity:
<a name="76" id="anc76"></a><span class="line-added">4093     {</span>
<span class="line-added">4094         RefPtr&lt;CSSValue&gt; parsedValue = consumeNumber(m_range, ValueRangeAll);</span>
<span class="line-added">4095         if (parsedValue)</span>
<span class="line-added">4096             return parsedValue;</span>
<span class="line-added">4097         return consumePercent(m_range, ValueRangeAll);</span>
<span class="line-added">4098     }</span>
4099     case CSSPropertyWebkitBoxFlex:
4100         return consumeNumber(m_range, ValueRangeAll);
4101     case CSSPropertyBaselineShift:
4102         return consumeBaselineShift(m_range);
4103     case CSSPropertyKerning:
4104         return consumeKerning(m_range, m_context.mode);
4105     case CSSPropertyStrokeMiterlimit:
4106         return consumeNumber(m_range, ValueRangeNonNegative);
4107     case CSSPropertyStrokeWidth:
4108     case CSSPropertyStrokeDashoffset:
4109     case CSSPropertyCx:
4110     case CSSPropertyCy:
4111     case CSSPropertyX:
4112     case CSSPropertyY:
<a name="77" id="anc77"></a>
4113         return consumeLengthOrPercent(m_range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
<a name="78" id="anc78"></a><span class="line-added">4114     case CSSPropertyR:</span>
<span class="line-added">4115         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);</span>
4116     case CSSPropertyRx:
4117     case CSSPropertyRy:
<a name="79" id="anc79"></a><span class="line-modified">4118         return consumeRxOrRy(m_range, m_context.mode);</span>
4119     case CSSPropertyCursor:
4120         return consumeCursor(m_range, m_context, inQuirksMode());
4121     case CSSPropertyContent:
4122         return consumeContent(m_range, m_context);
4123     case CSSPropertyListStyleImage:
4124     case CSSPropertyBorderImageSource:
4125     case CSSPropertyWebkitMaskBoxImageSource:
4126         return consumeImageOrNone(m_range, m_context);
4127     case CSSPropertyPerspective:
4128         return consumePerspective(m_range, m_context.mode);
4129     case CSSPropertyBorderTopRightRadius:
4130     case CSSPropertyBorderTopLeftRadius:
4131     case CSSPropertyBorderBottomLeftRadius:
4132     case CSSPropertyBorderBottomRightRadius:
4133         return consumeBorderRadiusCorner(m_range, m_context.mode);
4134     case CSSPropertyWebkitBoxFlexGroup:
4135         return consumeInteger(m_range, 0);
4136     case CSSPropertyOrder:
4137         return consumeInteger(m_range);
4138     case CSSPropertyTextUnderlinePosition:
4139         // auto | [ [ under | from-font ] || [ left | right ] ], but we only support auto | under | from-font for now
4140         return consumeIdent&lt;CSSValueAuto, CSSValueUnder, CSSValueFromFont&gt;(m_range);
4141     case CSSPropertyTextUnderlineOffset:
4142         return consumeTextUnderlineOffset(m_range, m_context.mode);
4143     case CSSPropertyTextDecorationThickness:
4144         return consumeTextDecorationThickness(m_range, m_context.mode);
4145     case CSSPropertyVerticalAlign:
4146         return consumeVerticalAlign(m_range, m_context.mode);
4147     case CSSPropertyShapeOutside:
4148         return consumeShapeOutside(m_range, m_context);
<a name="80" id="anc80"></a><span class="line-modified">4149     case CSSPropertyClipPath:</span>
<span class="line-modified">4150         return consumeClipPath(m_range, m_context);</span>
4151     case CSSPropertyJustifyContent:
4152         // justify-content property does not allow the &lt;baseline-position&gt; values.
4153         if (isBaselineKeyword(m_range.peek().id()))
4154             return nullptr;
4155         return consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
4156     case CSSPropertyAlignContent:
4157         return consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
4158     case CSSPropertyBorderImageRepeat:
4159     case CSSPropertyWebkitMaskBoxImageRepeat:
4160         return consumeBorderImageRepeat(m_range);
4161     case CSSPropertyBorderImageSlice:
4162     case CSSPropertyWebkitMaskBoxImageSlice:
4163         return consumeBorderImageSlice(property, m_range);
4164     case CSSPropertyBorderImageOutset:
4165     case CSSPropertyWebkitMaskBoxImageOutset:
4166         return consumeBorderImageOutset(m_range);
4167     case CSSPropertyBorderImageWidth:
4168     case CSSPropertyWebkitMaskBoxImageWidth:
4169         return consumeBorderImageWidth(m_range);
4170     case CSSPropertyWebkitBorderImage:
4171     case CSSPropertyWebkitMaskBoxImage:
4172         return consumeWebkitBorderImage(property, m_range, m_context);
4173     case CSSPropertyWebkitBoxReflect:
4174         return consumeReflect(m_range, m_context);
4175     case CSSPropertyWebkitLineBoxContain:
4176         return consumeLineBoxContain(m_range);
<a name="81" id="anc81"></a>



4177     case CSSPropertyBackgroundAttachment:
4178     case CSSPropertyBackgroundBlendMode:
4179     case CSSPropertyBackgroundClip:
4180     case CSSPropertyBackgroundImage:
4181     case CSSPropertyBackgroundOrigin:
4182     case CSSPropertyBackgroundPositionX:
4183     case CSSPropertyBackgroundPositionY:
4184     case CSSPropertyBackgroundSize:
4185     case CSSPropertyWebkitBackgroundClip:
4186     case CSSPropertyWebkitBackgroundOrigin:
4187     case CSSPropertyWebkitBackgroundComposite:
4188     case CSSPropertyWebkitBackgroundSize:
4189     case CSSPropertyWebkitMaskClip:
4190     case CSSPropertyWebkitMaskComposite:
4191     case CSSPropertyWebkitMaskImage:
4192     case CSSPropertyWebkitMaskOrigin:
4193     case CSSPropertyWebkitMaskPositionX:
4194     case CSSPropertyWebkitMaskPositionY:
4195     case CSSPropertyWebkitMaskSize:
4196     case CSSPropertyWebkitMaskSourceType:
4197         return consumeCommaSeparatedBackgroundComponent(property, m_range, m_context);
4198     case CSSPropertyWebkitMaskRepeatX:
4199     case CSSPropertyWebkitMaskRepeatY:
4200         return nullptr;
4201     case CSSPropertyAlignItems:
4202         return consumeAlignItems(m_range);
4203     case CSSPropertyJustifySelf:
4204         return consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
4205     case CSSPropertyAlignSelf:
4206         return consumeSelfPositionOverflowPosition(m_range, isSelfPositionKeyword);
4207     case CSSPropertyJustifyItems:
4208         return consumeJustifyItems(m_range);
4209     case CSSPropertyGridColumnEnd:
4210     case CSSPropertyGridColumnStart:
4211     case CSSPropertyGridRowEnd:
4212     case CSSPropertyGridRowStart:
4213         return consumeGridLine(m_range);
4214     case CSSPropertyGridAutoColumns:
4215     case CSSPropertyGridAutoRows:
4216         return consumeGridTrackList(m_range, m_context.mode, GridAuto);
4217     case CSSPropertyGridTemplateColumns:
4218     case CSSPropertyGridTemplateRows:
4219         return consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
4220     case CSSPropertyGridTemplateAreas:
4221         return consumeGridTemplateAreas(m_range);
4222     case CSSPropertyGridAutoFlow:
4223         return consumeGridAutoFlow(m_range);
4224     case CSSPropertyWebkitLineGrid:
4225         return consumeLineGrid(m_range);
4226     case CSSPropertyWebkitInitialLetter:
4227         return consumeInitialLetter(m_range);
4228     case CSSPropertySpeakAs:
4229         return consumeSpeakAs(m_range);
4230     case CSSPropertyHangingPunctuation:
4231         return consumeHangingPunctuation(m_range);
4232     case CSSPropertyWebkitMarqueeIncrement:
4233         return consumeWebkitMarqueeIncrement(m_range, m_context.mode);
4234     case CSSPropertyWebkitMarqueeRepetition:
4235         return consumeWebkitMarqueeRepetition(m_range);
4236     case CSSPropertyWebkitMarqueeSpeed:
4237         return consumeWebkitMarqueeSpeed(m_range, m_context.mode);
4238     case CSSPropertyAlt:
4239         return consumeAlt(m_range, m_context);
4240     case CSSPropertyWebkitAspectRatio:
4241         return consumeWebkitAspectRatio(m_range);
4242     case CSSPropertyWebkitTextEmphasisPosition:
4243         return consumeTextEmphasisPosition(m_range);
4244 #if ENABLE(DARK_MODE_CSS)
4245     case CSSPropertyColorScheme:
4246         return consumeColorScheme(m_range);
4247 #endif
4248     default:
4249         return nullptr;
4250     }
4251 }
4252 
4253 bool CSSPropertyParser::canParseTypedCustomPropertyValue(const String&amp; syntax)
4254 {
4255     if (syntax != &quot;*&quot;) {
4256         m_range.consumeWhitespace();
4257 
4258         // First check for keywords
4259         CSSValueID id = m_range.peek().id();
4260         if (id == CSSValueInherit || id == CSSValueInitial || id == CSSValueRevert)
4261             return true;
4262 
4263         auto localRange = m_range;
4264         while (!localRange.atEnd()) {
4265             auto id = localRange.consume().functionId();
4266             if (id == CSSValueVar || id == CSSValueEnv)
4267                 return true; // For variables, we just permit everything
4268         }
4269 
4270         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4271         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; m_range.atEnd())
4272             return true;
4273         return false;
4274     }
4275 
4276     return true;
4277 }
4278 
4279 void CSSPropertyParser::collectParsedCustomPropertyValueDependencies(const String&amp; syntax, bool isRoot, HashSet&lt;CSSPropertyID&gt;&amp; dependencies)
4280 {
4281     if (syntax != &quot;*&quot;) {
4282         m_range.consumeWhitespace();
4283         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4284         if (!m_range.atEnd())
4285             return;
4286         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue()) {
4287             primitiveVal-&gt;collectDirectComputationalDependencies(dependencies);
4288             if (isRoot)
4289                 primitiveVal-&gt;collectDirectRootComputationalDependencies(dependencies);
4290         }
4291     }
4292 }
4293 
<a name="82" id="anc82"></a><span class="line-modified">4294 RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const Style::BuilderState&amp; builderState)</span>
4295 {
4296     if (syntax != &quot;*&quot;) {
4297         m_range.consumeWhitespace();
4298         auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
4299         if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*primitiveVal).isLength()) {
<a name="83" id="anc83"></a><span class="line-modified">4300             auto length = Style::BuilderConverter::convertLength(builderState, *primitiveVal);</span>
4301             if (!length.isCalculated() &amp;&amp; !length.isUndefined())
4302                 return CSSCustomPropertyValue::createSyntaxLength(name, WTFMove(length));
4303         }
4304     } else {
4305         auto propertyValue = CSSCustomPropertyValue::createSyntaxAll(name, CSSVariableData::create(m_range));
4306         while (!m_range.atEnd())
4307             m_range.consume();
4308         return { WTFMove(propertyValue) };
4309     }
4310 
4311     return nullptr;
4312 }
4313 
4314 static RefPtr&lt;CSSValueList&gt; consumeFontFaceUnicodeRange(CSSParserTokenRange&amp; range)
4315 {
4316     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4317 
4318     do {
4319         const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
4320         if (token.type() != UnicodeRangeToken)
4321             return nullptr;
4322 
4323         UChar32 start = token.unicodeRangeStart();
4324         UChar32 end = token.unicodeRangeEnd();
4325         if (start &gt; end)
4326             return nullptr;
4327         values-&gt;append(CSSUnicodeRangeValue::create(start, end));
4328     } while (consumeCommaIncludingWhitespace(range));
4329 
4330     return values;
4331 }
4332 
4333 static RefPtr&lt;CSSPrimitiveValue&gt; consumeFontFaceFontDisplay(CSSParserTokenRange&amp; range)
4334 {
4335     return consumeIdent&lt;CSSValueAuto, CSSValueBlock, CSSValueSwap, CSSValueFallback, CSSValueOptional&gt;(range);
4336 }
4337 
4338 static RefPtr&lt;CSSValue&gt; consumeFontFaceSrcURI(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
4339 {
4340     String url = consumeUrlAsStringView(range).toString();
4341     if (url.isNull())
4342         return nullptr;
4343 
4344     RefPtr&lt;CSSFontFaceSrcValue&gt; uriValue = CSSFontFaceSrcValue::create(context.completeURL(url), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);
4345 
4346     if (range.peek().functionId() != CSSValueFormat)
4347         return uriValue;
4348 
4349     // FIXME: https://drafts.csswg.org/css-fonts says that format() contains a comma-separated list of strings,
4350     // but CSSFontFaceSrcValue stores only one format. Allowing one format for now.
4351     // FIXME: We&#39;re allowing the format to be an identifier as well as a string, because the old
4352     // parser did. It&#39;s not clear if we need to continue to support this behavior, but we have lots of
4353     // layout tests that rely on it.
4354     CSSParserTokenRange args = consumeFunction(range);
4355     const CSSParserToken&amp; arg = args.consumeIncludingWhitespace();
4356     if ((arg.type() != StringToken &amp;&amp; arg.type() != IdentToken) || !args.atEnd())
4357         return nullptr;
4358     uriValue-&gt;setFormat(arg.value().toString());
4359     return uriValue;
4360 }
4361 
4362 static RefPtr&lt;CSSValue&gt; consumeFontFaceSrcLocal(CSSParserTokenRange&amp; range)
4363 {
4364     CSSParserTokenRange args = consumeFunction(range);
4365     if (args.peek().type() == StringToken) {
4366         const CSSParserToken&amp; arg = args.consumeIncludingWhitespace();
4367         if (!args.atEnd())
4368             return nullptr;
4369         return CSSFontFaceSrcValue::createLocal(arg.value().toString());
4370     }
4371     if (args.peek().type() == IdentToken) {
4372         String familyName = concatenateFamilyName(args);
4373         if (!args.atEnd())
4374             return nullptr;
4375         return CSSFontFaceSrcValue::createLocal(familyName);
4376     }
4377     return nullptr;
4378 }
4379 
4380 static RefPtr&lt;CSSValueList&gt; consumeFontFaceSrc(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
4381 {
4382     RefPtr&lt;CSSValueList&gt; values = CSSValueList::createCommaSeparated();
4383 
4384     do {
4385         const CSSParserToken&amp; token = range.peek();
4386         RefPtr&lt;CSSValue&gt; parsedValue;
4387         if (token.functionId() == CSSValueLocal)
4388             parsedValue = consumeFontFaceSrcLocal(range);
4389         else
4390             parsedValue = consumeFontFaceSrcURI(range, context);
4391         if (!parsedValue)
4392             return nullptr;
4393         values-&gt;append(parsedValue.releaseNonNull());
4394     } while (consumeCommaIncludingWhitespace(range));
4395     return values;
4396 }
4397 
4398 bool CSSPropertyParser::parseFontFaceDescriptor(CSSPropertyID propId)
4399 {
4400     RefPtr&lt;CSSValue&gt; parsedValue;
4401     switch (propId) {
4402     case CSSPropertyFontFamily:
4403         parsedValue = consumeFontFamilyDescriptor(m_range);
4404         break;
4405     case CSSPropertySrc: // This is a list of urls or local references.
4406         parsedValue = consumeFontFaceSrc(m_range, m_context);
4407         break;
4408     case CSSPropertyUnicodeRange:
4409         parsedValue = consumeFontFaceUnicodeRange(m_range);
4410         break;
4411     case CSSPropertyFontDisplay:
4412         parsedValue = consumeFontFaceFontDisplay(m_range);
4413         break;
4414     case CSSPropertyFontWeight:
4415 #if ENABLE(VARIATION_FONTS)
4416         parsedValue = consumeFontWeightRange(m_range);
4417 #else
4418         parsedValue = consumeFontWeight(m_range);
4419 #endif
4420         break;
4421     case CSSPropertyFontStretch:
4422 #if ENABLE(VARIATION_FONTS)
4423         parsedValue = consumeFontStretchRange(m_range);
4424 #else
4425         parsedValue = consumeFontStretch(m_range);
4426 #endif
4427         break;
4428     case CSSPropertyFontStyle:
4429 #if ENABLE(VARIATION_FONTS)
4430         parsedValue = consumeFontStyleRange(m_range, m_context.mode);
4431 #else
4432         parsedValue = consumeFontStyle(m_range, m_context.mode);
4433 #endif
4434         break;
4435     case CSSPropertyFontVariantCaps:
4436         parsedValue = consumeFontVariantCaps(m_range);
4437         break;
4438     case CSSPropertyFontVariantLigatures:
4439         parsedValue = consumeFontVariantLigatures(m_range);
4440         break;
4441     case CSSPropertyFontVariantNumeric:
4442         parsedValue = consumeFontVariantNumeric(m_range);
4443         break;
4444     case CSSPropertyFontVariantEastAsian:
4445         parsedValue = consumeFontVariantEastAsian(m_range);
4446         break;
4447     case CSSPropertyFontVariantAlternates:
4448         parsedValue = consumeFontVariantAlternates(m_range);
4449         break;
4450     case CSSPropertyFontVariantPosition:
4451         parsedValue = consumeFontVariantPosition(m_range);
4452         break;
4453     case CSSPropertyFontVariant:
4454         return consumeFontVariantShorthand(false);
4455     case CSSPropertyFontFeatureSettings:
4456         parsedValue = consumeFontFeatureSettings(m_range);
4457         break;
4458     default:
4459         break;
4460     }
4461 
4462     if (!parsedValue || !m_range.atEnd())
4463         return false;
4464 
4465     addProperty(propId, CSSPropertyInvalid, *parsedValue, false);
4466     return true;
4467 }
4468 
4469 bool CSSPropertyParser::consumeSystemFont(bool important)
4470 {
4471     CSSValueID systemFontID = m_range.consumeIncludingWhitespace().id();
4472     ASSERT(systemFontID &gt;= CSSValueCaption &amp;&amp; systemFontID &lt;= CSSValueStatusBar);
4473     if (!m_range.atEnd())
4474         return false;
4475 
4476     FontCascadeDescription fontDescription;
4477     RenderTheme::singleton().systemFont(systemFontID, fontDescription);
4478     if (!fontDescription.isAbsoluteSize())
4479         return false;
4480 
4481     addProperty(CSSPropertyFontStyle, CSSPropertyFont, CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(isItalic(fontDescription.italic()) ? CSSValueItalic : CSSValueNormal)), important);
4482     addProperty(CSSPropertyFontWeight, CSSPropertyFont, CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(fontDescription.weight())), important);
<a name="84" id="anc84"></a><span class="line-modified">4483     addProperty(CSSPropertyFontSize, CSSPropertyFont, CSSValuePool::singleton().createValue(fontDescription.specifiedSize(), CSSUnitType::CSS_PX), important);</span>
4484     Ref&lt;CSSValueList&gt; fontFamilyList = CSSValueList::createCommaSeparated();
4485     fontFamilyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(fontDescription.familyAt(0), FromSystemFontID::Yes));
4486     addProperty(CSSPropertyFontFamily, CSSPropertyFont, WTFMove(fontFamilyList), important);
4487     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4488     addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4489 
4490     // FIXME_NEWPARSER: What about FontVariantNumeric and FontVariantLigatures?
4491 
4492     return true;
4493 }
4494 
4495 bool CSSPropertyParser::consumeFont(bool important)
4496 {
4497     // Let&#39;s check if there is an inherit or initial somewhere in the shorthand.
4498     CSSParserTokenRange range = m_range;
4499     while (!range.atEnd()) {
4500         CSSValueID id = range.consumeIncludingWhitespace().id();
4501         if (id == CSSValueInherit || id == CSSValueInitial)
4502             return false;
4503     }
4504     // Optional font-style, font-variant, font-stretch and font-weight.
4505     RefPtr&lt;CSSFontStyleValue&gt; fontStyle;
4506     RefPtr&lt;CSSPrimitiveValue&gt; fontVariantCaps;
4507     RefPtr&lt;CSSPrimitiveValue&gt; fontWeight;
4508     RefPtr&lt;CSSPrimitiveValue&gt; fontStretch;
4509 
4510     while (!m_range.atEnd()) {
4511         CSSValueID id = m_range.peek().id();
4512         if (!fontStyle) {
4513             fontStyle = consumeFontStyle(m_range, m_context.mode);
4514             if (fontStyle)
4515                 continue;
4516         }
4517         if (!fontVariantCaps &amp;&amp; (id == CSSValueNormal || id == CSSValueSmallCaps)) {
4518             // Font variant in the shorthand is particular, it only accepts normal or small-caps.
4519             // See https://drafts.csswg.org/css-fonts/#propdef-font
4520             fontVariantCaps = consumeFontVariantCSS21(m_range);
4521             if (fontVariantCaps)
4522                 continue;
4523         }
4524         if (!fontWeight) {
4525             fontWeight = consumeFontWeight(m_range);
4526             if (fontWeight)
4527                 continue;
4528         }
4529         if (!fontStretch) {
4530             fontStretch = consumeFontStretchKeywordValue(m_range);
4531             if (fontStretch)
4532                 continue;
4533         }
4534         break;
4535     }
4536 
4537     if (m_range.atEnd())
4538         return false;
4539 
4540     bool hasStyle = fontStyle;
4541     bool hasVariant = fontVariantCaps;
4542     bool hasWeight = fontWeight;
4543     bool hasStretch = fontStretch;
4544 
4545     if (!fontStyle)
4546         fontStyle = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueNormal));
4547 
4548     addProperty(CSSPropertyFontStyle, CSSPropertyFont, fontStyle.releaseNonNull(), important, !hasStyle);
4549     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, fontVariantCaps ? fontVariantCaps.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasVariant);
4550 /*
4551     // FIXME-NEWPARSER: What do we do with these? They aren&#39;t part of our fontShorthand().
4552     addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4553     addProperty(CSSPropertyFontVariantNumeric, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4554 */
4555 
4556     addProperty(CSSPropertyFontWeight, CSSPropertyFont, fontWeight ? fontWeight.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasWeight);
4557     addProperty(CSSPropertyFontStretch, CSSPropertyFont, fontStretch ? fontStretch.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, !hasStretch);
4558 
4559     // Now a font size _must_ come.
4560     RefPtr&lt;CSSValue&gt; fontSize = consumeFontSize(m_range, m_context.mode);
4561     if (!fontSize || m_range.atEnd())
4562         return false;
4563 
4564     addProperty(CSSPropertyFontSize, CSSPropertyFont, *fontSize, important);
4565 
4566     if (consumeSlashIncludingWhitespace(m_range)) {
4567         RefPtr&lt;CSSPrimitiveValue&gt; lineHeight = consumeLineHeight(m_range, m_context.mode);
4568         if (!lineHeight)
4569             return false;
4570         addProperty(CSSPropertyLineHeight, CSSPropertyFont, lineHeight.releaseNonNull(), important);
4571     } else
4572         addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important, true);
4573 
4574     // Font family must come now.
4575     RefPtr&lt;CSSValue&gt; parsedFamilyValue = consumeFontFamily(m_range);
4576     if (!parsedFamilyValue)
4577         return false;
4578 
4579     addProperty(CSSPropertyFontFamily, CSSPropertyFont, parsedFamilyValue.releaseNonNull(), important);
4580 
4581     return m_range.atEnd();
4582 }
4583 
4584 bool CSSPropertyParser::consumeFontVariantShorthand(bool important)
4585 {
4586     if (identMatches&lt;CSSValueNormal, CSSValueNone&gt;(m_range.peek().id())) {
4587         addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFontVariant, consumeIdent(m_range).releaseNonNull(), important);
4588         addProperty(CSSPropertyFontVariantCaps, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4589         addProperty(CSSPropertyFontVariantEastAsian, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4590         addProperty(CSSPropertyFontVariantPosition, CSSPropertyFontVariant, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4591         return m_range.atEnd();
4592     }
4593 
4594     RefPtr&lt;CSSPrimitiveValue&gt; capsValue;
4595     RefPtr&lt;CSSPrimitiveValue&gt; alternatesValue;
4596     RefPtr&lt;CSSPrimitiveValue&gt; positionValue;
4597 
4598     RefPtr&lt;CSSValue&gt; eastAsianValue;
4599     FontVariantLigaturesParser ligaturesParser;
4600     FontVariantNumericParser numericParser;
4601     do {
4602         if (!capsValue) {
4603             capsValue = consumeFontVariantCaps(m_range);
4604             if (capsValue)
4605                 continue;
4606         }
4607 
4608         if (!positionValue) {
4609             positionValue = consumeFontVariantPosition(m_range);
4610             if (positionValue)
4611                 continue;
4612         }
4613 
4614         if (!alternatesValue) {
4615             alternatesValue = consumeFontVariantAlternates(m_range);
4616             if (alternatesValue)
4617                 continue;
4618         }
4619 
4620         FontVariantLigaturesParser::ParseResult ligaturesParseResult = ligaturesParser.consumeLigature(m_range);
4621         FontVariantNumericParser::ParseResult numericParseResult = numericParser.consumeNumeric(m_range);
4622         if (ligaturesParseResult == FontVariantLigaturesParser::ParseResult::ConsumedValue
4623             || numericParseResult == FontVariantNumericParser::ParseResult::ConsumedValue)
4624             continue;
4625 
4626         if (ligaturesParseResult == FontVariantLigaturesParser::ParseResult::DisallowedValue
4627             || numericParseResult == FontVariantNumericParser::ParseResult::DisallowedValue)
4628             return false;
4629 
4630         if (!eastAsianValue) {
4631             eastAsianValue = consumeFontVariantEastAsian(m_range);
4632             if (eastAsianValue)
4633             continue;
4634         }
4635 
4636         // Saw some value that didn&#39;t match anything else.
4637         return false;
4638 
4639     } while (!m_range.atEnd());
4640 
4641     addProperty(CSSPropertyFontVariantLigatures, CSSPropertyFontVariant, ligaturesParser.finalizeValue().releaseNonNull(), important);
4642     addProperty(CSSPropertyFontVariantNumeric, CSSPropertyFontVariant, numericParser.finalizeValue().releaseNonNull(), important);
4643     addProperty(CSSPropertyFontVariantCaps, CSSPropertyFontVariant, capsValue ? capsValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4644     addProperty(CSSPropertyFontVariantAlternates, CSSPropertyFontVariant, alternatesValue ? alternatesValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4645     addProperty(CSSPropertyFontVariantPosition, CSSPropertyFontVariant, positionValue ? positionValue.releaseNonNull() : CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
4646 
4647     if (!eastAsianValue)
4648         eastAsianValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
4649     addProperty(CSSPropertyFontVariantEastAsian, CSSPropertyFontVariant, eastAsianValue.releaseNonNull(), important);
4650 
4651     return true;
4652 }
4653 
4654 bool CSSPropertyParser::consumeBorderSpacing(bool important)
4655 {
4656     RefPtr&lt;CSSValue&gt; horizontalSpacing = consumeLength(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
4657     if (!horizontalSpacing)
4658         return false;
4659     RefPtr&lt;CSSValue&gt; verticalSpacing = horizontalSpacing;
4660     if (!m_range.atEnd())
4661         verticalSpacing = consumeLength(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Allow);
4662     if (!verticalSpacing || !m_range.atEnd())
4663         return false;
4664     addProperty(CSSPropertyWebkitBorderHorizontalSpacing, CSSPropertyBorderSpacing, horizontalSpacing.releaseNonNull(), important);
4665     addProperty(CSSPropertyWebkitBorderVerticalSpacing, CSSPropertyBorderSpacing, verticalSpacing.releaseNonNull(), important);
4666     return true;
4667 }
4668 
4669 #if ENABLE(CSS_DEVICE_ADAPTATION)
4670 
4671 static RefPtr&lt;CSSValue&gt; consumeSingleViewportDescriptor(CSSParserTokenRange&amp; range, CSSPropertyID propId, CSSParserMode cssParserMode)
4672 {
4673     CSSValueID id = range.peek().id();
4674     switch (propId) {
4675     case CSSPropertyMinWidth:
4676     case CSSPropertyMaxWidth:
4677     case CSSPropertyMinHeight:
4678     case CSSPropertyMaxHeight:
4679         if (id == CSSValueAuto)
4680             return consumeIdent(range);
4681         return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
4682     case CSSPropertyMinZoom:
4683     case CSSPropertyMaxZoom:
4684     case CSSPropertyZoom: {
4685         if (id == CSSValueAuto)
4686             return consumeIdent(range);
4687         RefPtr&lt;CSSValue&gt; parsedValue = consumeNumber(range, ValueRangeNonNegative);
4688         if (parsedValue)
4689             return parsedValue;
4690         return consumePercent(range, ValueRangeNonNegative);
4691     }
4692     case CSSPropertyUserZoom:
4693         return consumeIdent&lt;CSSValueZoom, CSSValueFixed&gt;(range);
4694     case CSSPropertyOrientation:
4695         return consumeIdent&lt;CSSValueAuto, CSSValuePortrait, CSSValueLandscape&gt;(range);
4696     default:
4697         ASSERT_NOT_REACHED();
4698         break;
4699     }
4700 
4701     ASSERT_NOT_REACHED();
4702     return nullptr;
4703 }
4704 
4705 bool CSSPropertyParser::parseViewportDescriptor(CSSPropertyID propId, bool important)
4706 {
4707     switch (propId) {
4708     case CSSPropertyWidth: {
4709         RefPtr&lt;CSSValue&gt; minWidth = consumeSingleViewportDescriptor(m_range, CSSPropertyMinWidth, m_context.mode);
4710         if (!minWidth)
4711             return false;
4712         RefPtr&lt;CSSValue&gt; maxWidth = minWidth;
4713         if (!m_range.atEnd())
4714             maxWidth = consumeSingleViewportDescriptor(m_range, CSSPropertyMaxWidth, m_context.mode);
4715         if (!maxWidth || !m_range.atEnd())
4716             return false;
4717         addProperty(CSSPropertyMinWidth, CSSPropertyInvalid, *minWidth, important);
4718         addProperty(CSSPropertyMaxWidth, CSSPropertyInvalid, *maxWidth, important);
4719         return true;
4720     }
4721     case CSSPropertyHeight: {
4722         RefPtr&lt;CSSValue&gt; minHeight = consumeSingleViewportDescriptor(m_range, CSSPropertyMinHeight, m_context.mode);
4723         if (!minHeight)
4724             return false;
4725         RefPtr&lt;CSSValue&gt; maxHeight = minHeight;
4726         if (!m_range.atEnd())
4727             maxHeight = consumeSingleViewportDescriptor(m_range, CSSPropertyMaxHeight, m_context.mode);
4728         if (!maxHeight || !m_range.atEnd())
4729             return false;
4730         addProperty(CSSPropertyMinHeight, CSSPropertyInvalid, *minHeight, important);
4731         addProperty(CSSPropertyMaxHeight, CSSPropertyInvalid, *maxHeight, important);
4732         return true;
4733     }
4734     case CSSPropertyMinWidth:
4735     case CSSPropertyMaxWidth:
4736     case CSSPropertyMinHeight:
4737     case CSSPropertyMaxHeight:
4738     case CSSPropertyMinZoom:
4739     case CSSPropertyMaxZoom:
4740     case CSSPropertyZoom:
4741     case CSSPropertyUserZoom:
4742     case CSSPropertyOrientation: {
4743         RefPtr&lt;CSSValue&gt; parsedValue = consumeSingleViewportDescriptor(m_range, propId, m_context.mode);
4744         if (!parsedValue || !m_range.atEnd())
4745             return false;
4746         addProperty(propId, CSSPropertyInvalid, parsedValue.releaseNonNull(), important);
4747         return true;
4748     }
4749     default:
4750         return false;
4751     }
4752 }
4753 
4754 #endif
4755 
4756 bool CSSPropertyParser::consumeColumns(bool important)
4757 {
4758     RefPtr&lt;CSSValue&gt; columnWidth;
4759     RefPtr&lt;CSSValue&gt; columnCount;
4760     bool hasPendingExplicitAuto = false;
4761 
4762     for (unsigned propertiesParsed = 0; propertiesParsed &lt; 2 &amp;&amp; !m_range.atEnd(); ++propertiesParsed) {
4763         if (!propertiesParsed &amp;&amp; m_range.peek().id() == CSSValueAuto) {
4764             // &#39;auto&#39; is a valid value for any of the two longhands, and at this point
4765             // we don&#39;t know which one(s) it is meant for. We need to see if there are other values first.
4766             consumeIdent(m_range);
4767             hasPendingExplicitAuto = true;
4768         } else {
4769             if (!columnWidth) {
4770                 if ((columnWidth = consumeColumnWidth(m_range)))
4771                     continue;
4772             }
4773             if (!columnCount) {
4774                 if ((columnCount = consumeColumnCount(m_range)))
4775                     continue;
4776             }
4777             // If we didn&#39;t find at least one match, this is an invalid shorthand and we have to ignore it.
4778             return false;
4779         }
4780     }
4781 
4782     if (!m_range.atEnd())
4783         return false;
4784 
4785     // Any unassigned property at this point will become implicit &#39;auto&#39;.
4786     if (columnWidth)
4787         addProperty(CSSPropertyColumnWidth, CSSPropertyInvalid, columnWidth.releaseNonNull(), important);
4788     else {
4789         addProperty(CSSPropertyColumnWidth, CSSPropertyInvalid, CSSValuePool::singleton().createIdentifierValue(CSSValueAuto), important, !hasPendingExplicitAuto /* implicit */);
4790         hasPendingExplicitAuto = false;
4791     }
4792 
4793     if (columnCount)
4794         addProperty(CSSPropertyColumnCount, CSSPropertyInvalid, columnCount.releaseNonNull(), important);
4795     else
4796         addProperty(CSSPropertyColumnCount, CSSPropertyInvalid, CSSValuePool::singleton().createIdentifierValue(CSSValueAuto), important, !hasPendingExplicitAuto /* implicit */);
4797 
4798     return true;
4799 }
4800 
4801 bool CSSPropertyParser::consumeShorthandGreedily(const StylePropertyShorthand&amp; shorthand, bool important)
4802 {
4803     ASSERT(shorthand.length() &lt;= 6); // Existing shorthands have at most 6 longhands.
4804     RefPtr&lt;CSSValue&gt; longhands[6];
4805     const CSSPropertyID* shorthandProperties = shorthand.properties();
4806     do {
4807         bool foundLonghand = false;
4808         for (size_t i = 0; !foundLonghand &amp;&amp; i &lt; shorthand.length(); ++i) {
4809             if (longhands[i])
4810                 continue;
4811             longhands[i] = parseSingleValue(shorthandProperties[i], shorthand.id());
4812             if (longhands[i])
4813                 foundLonghand = true;
4814         }
4815         if (!foundLonghand)
4816             return false;
4817     } while (!m_range.atEnd());
4818 
4819     for (size_t i = 0; i &lt; shorthand.length(); ++i) {
4820         if (longhands[i])
4821             addProperty(shorthandProperties[i], shorthand.id(), longhands[i].releaseNonNull(), important);
4822         else
4823             addProperty(shorthandProperties[i], shorthand.id(), CSSValuePool::singleton().createImplicitInitialValue(), important);
4824     }
4825     return true;
4826 }
4827 
4828 bool CSSPropertyParser::consumeFlex(bool important)
4829 {
4830     static const double unsetValue = -1;
4831     double flexGrow = unsetValue;
4832     double flexShrink = unsetValue;
4833     RefPtr&lt;CSSPrimitiveValue&gt; flexBasis;
4834 
4835     if (m_range.peek().id() == CSSValueNone) {
4836         flexGrow = 0;
4837         flexShrink = 0;
4838         flexBasis = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
4839         m_range.consumeIncludingWhitespace();
4840     } else {
4841         unsigned index = 0;
4842         while (!m_range.atEnd() &amp;&amp; index++ &lt; 3) {
4843             double num;
4844             if (consumeNumberRaw(m_range, num)) {
4845                 if (num &lt; 0)
4846                     return false;
4847                 if (flexGrow == unsetValue)
4848                     flexGrow = num;
4849                 else if (flexShrink == unsetValue)
4850                     flexShrink = num;
4851                 else if (!num) // flex only allows a basis of 0 (sans units) if flex-grow and flex-shrink values have already been set.
<a name="85" id="anc85"></a><span class="line-modified">4852                     flexBasis = CSSPrimitiveValue::create(0, CSSUnitType::CSS_PX);</span>
4853                 else
4854                     return false;
4855             } else if (!flexBasis) {
4856                 if (m_range.peek().id() == CSSValueAuto)
4857                     flexBasis = consumeIdent(m_range);
4858                 if (!flexBasis)
4859                     flexBasis = consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative);
4860                 if (index == 2 &amp;&amp; !m_range.atEnd())
4861                     return false;
4862             }
4863         }
4864         if (index == 0)
4865             return false;
4866         if (flexGrow == unsetValue)
4867             flexGrow = 1;
4868         if (flexShrink == unsetValue)
4869             flexShrink = 1;
4870 
4871         // FIXME: Using % here is a hack to work around intrinsic sizing implementation being
4872         // a mess (e.g., turned off for nested column flexboxes, failing to relayout properly even
4873         // if turned back on for nested columns, etc.). We have layout test coverage of both
4874         // scenarios.
4875         if (!flexBasis)
<a name="86" id="anc86"></a><span class="line-modified">4876             flexBasis = CSSPrimitiveValue::create(0, CSSUnitType::CSS_PERCENTAGE);</span>
4877     }
4878 
4879     if (!m_range.atEnd())
4880         return false;
<a name="87" id="anc87"></a><span class="line-modified">4881     addProperty(CSSPropertyFlexGrow, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexGrow), CSSUnitType::CSS_NUMBER), important);</span>
<span class="line-modified">4882     addProperty(CSSPropertyFlexShrink, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexShrink), CSSUnitType::CSS_NUMBER), important);</span>
4883     addProperty(CSSPropertyFlexBasis, CSSPropertyFlex, flexBasis.releaseNonNull(), important);
4884     return true;
4885 }
4886 
4887 bool CSSPropertyParser::consumeBorder(RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; style, RefPtr&lt;CSSValue&gt;&amp; color)
4888 {
4889     while (!width || !style || !color) {
4890         if (!width) {
4891             width = consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
4892             if (width)
4893                 continue;
4894         }
4895         if (!style) {
4896             style = parseSingleValue(CSSPropertyBorderLeftStyle, CSSPropertyBorder);
4897             if (style)
4898                 continue;
4899         }
4900         if (!color) {
4901             color = consumeColor(m_range, m_context.mode);
4902             if (color)
4903                 continue;
4904         }
4905         break;
4906     }
4907 
4908     if (!width &amp;&amp; !style &amp;&amp; !color)
4909         return false;
4910 
4911     if (!width)
4912         width = CSSValuePool::singleton().createImplicitInitialValue();
4913     if (!style)
4914         style = CSSValuePool::singleton().createImplicitInitialValue();
4915     if (!color)
4916         color = CSSValuePool::singleton().createImplicitInitialValue();
4917 
4918     return m_range.atEnd();
4919 }
4920 
4921 bool CSSPropertyParser::consume2ValueShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
4922 {
4923     ASSERT(shorthand.length() == 2);
4924     const CSSPropertyID* longhands = shorthand.properties();
4925     RefPtr&lt;CSSValue&gt; start = parseSingleValue(longhands[0], shorthand.id());
4926     if (!start)
4927         return false;
4928 
4929     RefPtr&lt;CSSValue&gt; end = parseSingleValue(longhands[1], shorthand.id());
4930     bool endImplicit = !end;
4931     if (endImplicit)
4932         end = start;
4933     addProperty(longhands[0], shorthand.id(), start.releaseNonNull(), important);
4934     addProperty(longhands[1], shorthand.id(), end.releaseNonNull(), important, endImplicit);
4935 
4936     return m_range.atEnd();
4937 }
4938 
4939 bool CSSPropertyParser::consume4ValueShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
4940 {
4941     ASSERT(shorthand.length() == 4);
4942     const CSSPropertyID* longhands = shorthand.properties();
4943     RefPtr&lt;CSSValue&gt; top = parseSingleValue(longhands[0], shorthand.id());
4944     if (!top)
4945         return false;
4946 
4947     RefPtr&lt;CSSValue&gt; right = parseSingleValue(longhands[1], shorthand.id());
4948     RefPtr&lt;CSSValue&gt; bottom;
4949     RefPtr&lt;CSSValue&gt; left;
4950     if (right) {
4951         bottom = parseSingleValue(longhands[2], shorthand.id());
4952         if (bottom)
4953             left = parseSingleValue(longhands[3], shorthand.id());
4954     }
4955 
4956     bool rightImplicit = !right;
4957     bool bottomImplicit = !bottom;
4958     bool leftImplicit = !left;
4959 
4960     if (!right)
4961         right = top;
4962     if (!bottom)
4963         bottom = top;
4964     if (!left)
4965         left = right;
4966 
4967     addProperty(longhands[0], shorthand.id(), top.releaseNonNull(), important);
4968     addProperty(longhands[1], shorthand.id(), right.releaseNonNull(), important, rightImplicit);
4969     addProperty(longhands[2], shorthand.id(), bottom.releaseNonNull(), important, bottomImplicit);
4970     addProperty(longhands[3], shorthand.id(), left.releaseNonNull(), important, leftImplicit);
4971 
4972     return m_range.atEnd();
4973 }
4974 
4975 bool CSSPropertyParser::consumeBorderImage(CSSPropertyID property, bool important)
4976 {
4977     RefPtr&lt;CSSValue&gt; source;
4978     RefPtr&lt;CSSValue&gt; slice;
4979     RefPtr&lt;CSSValue&gt; width;
4980     RefPtr&lt;CSSValue&gt; outset;
4981     RefPtr&lt;CSSValue&gt; repeat;
4982 
4983     if (consumeBorderImageComponents(property, m_range, m_context, source, slice, width, outset, repeat)) {
4984         if (!source)
4985             source = CSSValuePool::singleton().createImplicitInitialValue();
4986         if (!slice)
4987             slice = CSSValuePool::singleton().createImplicitInitialValue();
4988         if (!width)
4989             width = CSSValuePool::singleton().createImplicitInitialValue();
4990         if (!outset)
4991             outset = CSSValuePool::singleton().createImplicitInitialValue();
4992         if (!repeat)
4993             repeat = CSSValuePool::singleton().createImplicitInitialValue();
4994         switch (property) {
4995         case CSSPropertyWebkitMaskBoxImage:
4996             addProperty(CSSPropertyWebkitMaskBoxImageSource, CSSPropertyWebkitMaskBoxImage, source.releaseNonNull(), important);
4997             addProperty(CSSPropertyWebkitMaskBoxImageSlice, CSSPropertyWebkitMaskBoxImage, slice.releaseNonNull(), important);
4998             addProperty(CSSPropertyWebkitMaskBoxImageWidth, CSSPropertyWebkitMaskBoxImage, width.releaseNonNull(), important);
4999             addProperty(CSSPropertyWebkitMaskBoxImageOutset, CSSPropertyWebkitMaskBoxImage, outset.releaseNonNull(), important);
5000             addProperty(CSSPropertyWebkitMaskBoxImageRepeat, CSSPropertyWebkitMaskBoxImage, repeat.releaseNonNull(), important);
5001             return true;
5002         case CSSPropertyBorderImage:
5003             addProperty(CSSPropertyBorderImageSource, CSSPropertyBorderImage, source.releaseNonNull(), important);
5004             addProperty(CSSPropertyBorderImageSlice, CSSPropertyBorderImage, slice.releaseNonNull(), important);
5005             addProperty(CSSPropertyBorderImageWidth, CSSPropertyBorderImage, width.releaseNonNull() , important);
5006             addProperty(CSSPropertyBorderImageOutset, CSSPropertyBorderImage, outset.releaseNonNull(), important);
5007             addProperty(CSSPropertyBorderImageRepeat, CSSPropertyBorderImage, repeat.releaseNonNull(), important);
5008             return true;
5009         default:
5010             ASSERT_NOT_REACHED();
5011             return false;
5012         }
5013     }
5014     return false;
5015 }
5016 
5017 static inline CSSValueID mapFromPageBreakBetween(CSSValueID value)
5018 {
5019     if (value == CSSValueAlways)
5020         return CSSValuePage;
5021     if (value == CSSValueAuto || value == CSSValueAvoid || value == CSSValueLeft || value == CSSValueRight)
5022         return value;
5023     return CSSValueInvalid;
5024 }
5025 
5026 static inline CSSValueID mapFromColumnBreakBetween(CSSValueID value)
5027 {
5028     if (value == CSSValueAlways)
5029         return CSSValueColumn;
5030     if (value == CSSValueAuto)
5031         return value;
5032     if (value == CSSValueAvoid)
5033         return CSSValueAvoidColumn;
5034     return CSSValueInvalid;
5035 }
5036 
5037 static inline CSSValueID mapFromColumnRegionOrPageBreakInside(CSSValueID value)
5038 {
5039     if (value == CSSValueAuto || value == CSSValueAvoid)
5040         return value;
5041     return CSSValueInvalid;
5042 }
5043 
5044 static inline CSSPropertyID mapFromLegacyBreakProperty(CSSPropertyID property)
5045 {
5046     if (property == CSSPropertyPageBreakAfter || property == CSSPropertyWebkitColumnBreakAfter)
5047         return CSSPropertyBreakAfter;
5048     if (property == CSSPropertyPageBreakBefore || property == CSSPropertyWebkitColumnBreakBefore)
5049         return CSSPropertyBreakBefore;
5050     ASSERT(property == CSSPropertyPageBreakInside || property == CSSPropertyWebkitColumnBreakInside);
5051     return CSSPropertyBreakInside;
5052 }
5053 
5054 bool CSSPropertyParser::consumeLegacyBreakProperty(CSSPropertyID property, bool important)
5055 {
5056     // The fragmentation spec says that page-break-(after|before|inside) are to be treated as
5057     // shorthands for their break-(after|before|inside) counterparts. We&#39;ll do the same for the
5058     // non-standard properties -webkit-column-break-(after|before|inside).
5059     RefPtr&lt;CSSPrimitiveValue&gt; keyword = consumeIdent(m_range);
5060     if (!keyword)
5061         return false;
5062     if (!m_range.atEnd())
5063         return false;
5064     CSSValueID value = keyword-&gt;valueID();
5065     switch (property) {
5066     case CSSPropertyPageBreakAfter:
5067     case CSSPropertyPageBreakBefore:
5068         value = mapFromPageBreakBetween(value);
5069         break;
5070     case CSSPropertyWebkitColumnBreakAfter:
5071     case CSSPropertyWebkitColumnBreakBefore:
5072         value = mapFromColumnBreakBetween(value);
5073         break;
5074     case CSSPropertyPageBreakInside:
5075     case CSSPropertyWebkitColumnBreakInside:
5076         value = mapFromColumnRegionOrPageBreakInside(value);
5077         break;
5078     default:
5079         ASSERT_NOT_REACHED();
5080     }
5081     if (value == CSSValueInvalid)
5082         return false;
5083 
5084     CSSPropertyID genericBreakProperty = mapFromLegacyBreakProperty(property);
5085     addProperty(genericBreakProperty, property, CSSValuePool::singleton().createIdentifierValue(value), important);
5086     return true;
5087 }
5088 
5089 static bool consumeBackgroundPosition(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY)
5090 {
5091     do {
5092         RefPtr&lt;CSSPrimitiveValue&gt; positionX;
5093         RefPtr&lt;CSSPrimitiveValue&gt; positionY;
<a name="88" id="anc88"></a><span class="line-modified">5094         if (!consumePosition(range, context.mode, unitless, PositionSyntax::BackgroundPosition, positionX, positionY))</span>
5095             return false;
5096         addBackgroundValue(resultX, positionX.releaseNonNull());
5097         addBackgroundValue(resultY, positionY.releaseNonNull());
5098     } while (consumeCommaIncludingWhitespace(range));
5099     return true;
5100 }
5101 
5102 static bool consumeRepeatStyleComponent(CSSParserTokenRange&amp; range, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value1, RefPtr&lt;CSSPrimitiveValue&gt;&amp; value2, bool&amp; implicit)
5103 {
5104     if (consumeIdent&lt;CSSValueRepeatX&gt;(range)) {
5105         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5106         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5107         implicit = true;
5108         return true;
5109     }
5110     if (consumeIdent&lt;CSSValueRepeatY&gt;(range)) {
5111         value1 = CSSValuePool::singleton().createIdentifierValue(CSSValueNoRepeat);
5112         value2 = CSSValuePool::singleton().createIdentifierValue(CSSValueRepeat);
5113         implicit = true;
5114         return true;
5115     }
5116     value1 = consumeIdent&lt;CSSValueRepeat, CSSValueNoRepeat, CSSValueRound, CSSValueSpace&gt;(range);
5117     if (!value1)
5118         return false;
5119 
5120     value2 = consumeIdent&lt;CSSValueRepeat, CSSValueNoRepeat, CSSValueRound, CSSValueSpace&gt;(range);
5121     if (!value2) {
5122         value2 = value1;
5123         implicit = true;
5124     }
5125     return true;
5126 }
5127 
5128 static bool consumeRepeatStyle(CSSParserTokenRange&amp; range, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY, bool&amp; implicit)
5129 {
5130     do {
5131         RefPtr&lt;CSSPrimitiveValue&gt; repeatX;
5132         RefPtr&lt;CSSPrimitiveValue&gt; repeatY;
5133         if (!consumeRepeatStyleComponent(range, repeatX, repeatY, implicit))
5134             return false;
5135         addBackgroundValue(resultX, repeatX.releaseNonNull());
5136         addBackgroundValue(resultY, repeatY.releaseNonNull());
5137     } while (consumeCommaIncludingWhitespace(range));
5138     return true;
5139 }
5140 
5141 // Note: consumeBackgroundShorthand assumes y properties (for example background-position-y) follow
5142 // the x properties in the shorthand array.
5143 bool CSSPropertyParser::consumeBackgroundShorthand(const StylePropertyShorthand&amp; shorthand, bool important)
5144 {
5145     const unsigned longhandCount = shorthand.length();
5146     RefPtr&lt;CSSValue&gt; longhands[10];
5147     ASSERT(longhandCount &lt;= 10);
5148 
5149     bool implicit = false;
5150     do {
5151         bool parsedLonghand[10] = { false };
5152         RefPtr&lt;CSSValue&gt; originValue;
5153         do {
5154             bool foundProperty = false;
5155             for (size_t i = 0; i &lt; longhandCount; ++i) {
5156                 if (parsedLonghand[i])
5157                     continue;
5158 
5159                 RefPtr&lt;CSSValue&gt; value;
5160                 RefPtr&lt;CSSValue&gt; valueY;
5161                 CSSPropertyID property = shorthand.properties()[i];
5162                 if (property == CSSPropertyBackgroundRepeatX || property == CSSPropertyWebkitMaskRepeatX) {
5163                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5164                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
5165                     consumeRepeatStyleComponent(m_range, primitiveValue, primitiveValueY, implicit);
5166                     value = primitiveValue;
5167                     valueY = primitiveValueY;
5168                 } else if (property == CSSPropertyBackgroundPositionX || property == CSSPropertyWebkitMaskPositionX) {
5169                     CSSParserTokenRange rangeCopy = m_range;
5170                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
5171                     RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
<a name="89" id="anc89"></a><span class="line-modified">5172                     if (!consumePosition(rangeCopy, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::BackgroundPosition, primitiveValue, primitiveValueY))</span>
5173                         continue;
5174                     value = primitiveValue;
5175                     valueY = primitiveValueY;
5176                     m_range = rangeCopy;
5177                 } else if (property == CSSPropertyBackgroundSize || property == CSSPropertyWebkitMaskSize) {
5178                     if (!consumeSlashIncludingWhitespace(m_range))
5179                         continue;
5180                     value = consumeBackgroundSize(property, m_range, m_context.mode);
5181                     if (!value || !parsedLonghand[i - 1]) // Position must have been parsed in the current layer.
5182                         return false;
5183                 } else if (property == CSSPropertyBackgroundPositionY || property == CSSPropertyBackgroundRepeatY
5184                     || property == CSSPropertyWebkitMaskPositionY || property == CSSPropertyWebkitMaskRepeatY) {
5185                     continue;
5186                 } else {
5187                     value = consumeBackgroundComponent(property, m_range, m_context);
5188                 }
5189                 if (value) {
5190                     if (property == CSSPropertyBackgroundOrigin || property == CSSPropertyWebkitMaskOrigin)
5191                         originValue = value;
5192                     parsedLonghand[i] = true;
5193                     foundProperty = true;
5194                     addBackgroundValue(longhands[i], value.releaseNonNull());
5195                     if (valueY) {
5196                         parsedLonghand[i + 1] = true;
5197                         addBackgroundValue(longhands[i + 1], valueY.releaseNonNull());
5198                     }
5199                 }
5200             }
5201             if (!foundProperty)
5202                 return false;
5203         } while (!m_range.atEnd() &amp;&amp; m_range.peek().type() != CommaToken);
5204 
5205         // FIXME: This will make invalid longhands, see crbug.com/386459
5206         for (size_t i = 0; i &lt; longhandCount; ++i) {
5207             CSSPropertyID property = shorthand.properties()[i];
5208             if (property == CSSPropertyBackgroundColor &amp;&amp; !m_range.atEnd()) {
5209                 if (parsedLonghand[i])
5210                     return false; // Colors are only allowed in the last layer.
5211                 continue;
5212             }
5213             if ((property == CSSPropertyBackgroundClip || property == CSSPropertyWebkitMaskClip) &amp;&amp; !parsedLonghand[i] &amp;&amp; originValue) {
5214                 addBackgroundValue(longhands[i], originValue.releaseNonNull());
5215                 continue;
5216             }
5217             if (!parsedLonghand[i])
5218                 addBackgroundValue(longhands[i], CSSValuePool::singleton().createImplicitInitialValue());
5219         }
5220     } while (consumeCommaIncludingWhitespace(m_range));
5221     if (!m_range.atEnd())
5222         return false;
5223 
5224     for (size_t i = 0; i &lt; longhandCount; ++i) {
5225         CSSPropertyID property = shorthand.properties()[i];
5226         if (property == CSSPropertyBackgroundSize &amp;&amp; longhands[i] &amp;&amp; m_context.useLegacyBackgroundSizeShorthandBehavior)
5227             continue;
5228         addProperty(property, shorthand.id(), *longhands[i], important, implicit);
5229     }
5230     return true;
5231 }
5232 
<a name="90" id="anc90"></a><span class="line-added">5233 bool CSSPropertyParser::consumeOverflowShorthand(bool important)</span>
<span class="line-added">5234 {</span>
<span class="line-added">5235     CSSValueID xValueID = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-added">5236     if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, xValueID, m_context))</span>
<span class="line-added">5237         return false;</span>
<span class="line-added">5238 </span>
<span class="line-added">5239     CSSValueID yValueID;</span>
<span class="line-added">5240     if (m_range.atEnd()) {</span>
<span class="line-added">5241         yValueID = xValueID;</span>
<span class="line-added">5242 </span>
<span class="line-added">5243         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been</span>
<span class="line-added">5244         // set using the shorthand, then for now overflow-x will default to auto, but once we implement</span>
<span class="line-added">5245         // pagination controls, it should default to hidden. If the overflow-y value is anything but</span>
<span class="line-added">5246         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.</span>
<span class="line-added">5247         if (xValueID == CSSValueWebkitPagedX || xValueID == CSSValueWebkitPagedY)</span>
<span class="line-added">5248             xValueID = CSSValueAuto;</span>
<span class="line-added">5249     } else</span>
<span class="line-added">5250         yValueID = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-added">5251 </span>
<span class="line-added">5252     if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, yValueID, m_context))</span>
<span class="line-added">5253         return false;</span>
<span class="line-added">5254     if (!m_range.atEnd())</span>
<span class="line-added">5255         return false;</span>
<span class="line-added">5256 </span>
<span class="line-added">5257     addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, CSSValuePool::singleton().createIdentifierValue(xValueID), important);</span>
<span class="line-added">5258     addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, CSSValuePool::singleton().createIdentifierValue(yValueID), important);</span>
<span class="line-added">5259     return true;</span>
<span class="line-added">5260 }</span>
<span class="line-added">5261 </span>
5262 // FIXME-NEWPARSER: Hack to work around the fact that we aren&#39;t using CSSCustomIdentValue
5263 // for stuff yet. This can be replaced by CSSValue::isCustomIdentValue() once we switch
5264 // to using CSSCustomIdentValue everywhere.
5265 static bool isCustomIdentValue(const CSSValue&amp; value)
5266 {
5267     return is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).isString();
5268 }
5269 
5270 bool CSSPropertyParser::consumeGridItemPositionShorthand(CSSPropertyID shorthandId, bool important)
5271 {
5272     const StylePropertyShorthand&amp; shorthand = shorthandForProperty(shorthandId);
5273     ASSERT(shorthand.length() == 2);
5274     RefPtr&lt;CSSValue&gt; startValue = consumeGridLine(m_range);
5275     if (!startValue)
5276         return false;
5277 
5278     RefPtr&lt;CSSValue&gt; endValue;
5279     if (consumeSlashIncludingWhitespace(m_range)) {
5280         endValue = consumeGridLine(m_range);
5281         if (!endValue)
5282             return false;
5283     } else {
5284         endValue = isCustomIdentValue(*startValue) ? startValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5285     }
5286     if (!m_range.atEnd())
5287         return false;
5288     addProperty(shorthand.properties()[0], shorthandId, startValue.releaseNonNull(), important);
5289     addProperty(shorthand.properties()[1], shorthandId, endValue.releaseNonNull(), important);
5290     return true;
5291 }
5292 
5293 bool CSSPropertyParser::consumeGridAreaShorthand(bool important)
5294 {
5295     RefPtr&lt;CSSValue&gt; rowStartValue = consumeGridLine(m_range);
5296     if (!rowStartValue)
5297         return false;
5298     RefPtr&lt;CSSValue&gt; columnStartValue;
5299     RefPtr&lt;CSSValue&gt; rowEndValue;
5300     RefPtr&lt;CSSValue&gt; columnEndValue;
5301     if (consumeSlashIncludingWhitespace(m_range)) {
5302         columnStartValue = consumeGridLine(m_range);
5303         if (!columnStartValue)
5304             return false;
5305         if (consumeSlashIncludingWhitespace(m_range)) {
5306             rowEndValue = consumeGridLine(m_range);
5307             if (!rowEndValue)
5308                 return false;
5309             if (consumeSlashIncludingWhitespace(m_range)) {
5310                 columnEndValue = consumeGridLine(m_range);
5311                 if (!columnEndValue)
5312                     return false;
5313             }
5314         }
5315     }
5316     if (!m_range.atEnd())
5317         return false;
5318     if (!columnStartValue)
5319         columnStartValue = isCustomIdentValue(*rowStartValue) ? rowStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5320     if (!rowEndValue)
5321         rowEndValue = isCustomIdentValue(*rowStartValue) ? rowStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5322     if (!columnEndValue)
5323         columnEndValue = isCustomIdentValue(*columnStartValue) ? columnStartValue : CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5324 
5325     addProperty(CSSPropertyGridRowStart, CSSPropertyGridArea, rowStartValue.releaseNonNull(), important);
5326     addProperty(CSSPropertyGridColumnStart, CSSPropertyGridArea, columnStartValue.releaseNonNull(), important);
5327     addProperty(CSSPropertyGridRowEnd, CSSPropertyGridArea, rowEndValue.releaseNonNull(), important);
5328     addProperty(CSSPropertyGridColumnEnd, CSSPropertyGridArea, columnEndValue.releaseNonNull(), important);
5329     return true;
5330 }
5331 
5332 bool CSSPropertyParser::consumeGridTemplateRowsAndAreasAndColumns(CSSPropertyID shorthandId, bool important)
5333 {
5334     NamedGridAreaMap gridAreaMap;
5335     size_t rowCount = 0;
5336     size_t columnCount = 0;
5337     RefPtr&lt;CSSValueList&gt; templateRows = CSSValueList::createSpaceSeparated();
5338 
5339     // Persists between loop iterations so we can use the same value for
5340     // consecutive &lt;line-names&gt; values
5341     RefPtr&lt;CSSGridLineNamesValue&gt; lineNames;
5342 
5343     do {
5344         // Handle leading &lt;custom-ident&gt;*.
5345         bool hasPreviousLineNames = lineNames;
5346         lineNames = consumeGridLineNames(m_range, lineNames.get());
5347         if (lineNames &amp;&amp; !hasPreviousLineNames)
5348             templateRows-&gt;append(*lineNames);
5349 
5350         // Handle a template-area&#39;s row.
5351         if (m_range.peek().type() != StringToken || !parseGridTemplateAreasRow(m_range.consumeIncludingWhitespace().value().toString(), gridAreaMap, rowCount, columnCount))
5352             return false;
5353         ++rowCount;
5354 
5355         // Handle template-rows&#39;s track-size.
5356         RefPtr&lt;CSSValue&gt; value = consumeGridTrackSize(m_range, m_context.mode);
5357         if (!value)
5358             value = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
5359         templateRows-&gt;append(*value);
5360 
5361         // This will handle the trailing/leading &lt;custom-ident&gt;* in the grammar.
5362         lineNames = consumeGridLineNames(m_range);
5363         if (lineNames)
5364             templateRows-&gt;append(lineNames.releaseNonNull());
5365     } while (!m_range.atEnd() &amp;&amp; !(m_range.peek().type() == DelimiterToken &amp;&amp; m_range.peek().delimiter() == &#39;/&#39;));
5366 
5367     RefPtr&lt;CSSValue&gt; columnsValue;
5368     if (!m_range.atEnd()) {
5369         if (!consumeSlashIncludingWhitespace(m_range))
5370             return false;
5371         columnsValue = consumeGridTrackList(m_range, m_context.mode, GridTemplateNoRepeat);
5372         if (!columnsValue || !m_range.atEnd())
5373             return false;
5374     } else {
5375         columnsValue = CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
5376     }
5377     addProperty(CSSPropertyGridTemplateRows, shorthandId, templateRows.releaseNonNull(), important);
5378     addProperty(CSSPropertyGridTemplateColumns, shorthandId, columnsValue.releaseNonNull(), important);
5379     addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSGridTemplateAreasValue::create(gridAreaMap, rowCount, columnCount), important);
5380     return true;
5381 }
5382 
5383 bool CSSPropertyParser::consumeGridTemplateShorthand(CSSPropertyID shorthandId, bool important)
5384 {
5385     CSSParserTokenRange rangeCopy = m_range;
5386     RefPtr&lt;CSSValue&gt; rowsValue = consumeIdent&lt;CSSValueNone&gt;(m_range);
5387 
5388     // 1- &#39;none&#39; case.
5389     if (rowsValue &amp;&amp; m_range.atEnd()) {
5390         addProperty(CSSPropertyGridTemplateRows, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5391         addProperty(CSSPropertyGridTemplateColumns, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5392         addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5393         return true;
5394     }
5395 
5396     // 2- &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;
5397     if (!rowsValue)
5398         rowsValue = consumeGridTrackList(m_range, m_context.mode, GridTemplate);
5399 
5400     if (rowsValue) {
5401         if (!consumeSlashIncludingWhitespace(m_range))
5402             return false;
5403         RefPtr&lt;CSSValue&gt; columnsValue = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5404         if (!columnsValue || !m_range.atEnd())
5405             return false;
5406 
5407         addProperty(CSSPropertyGridTemplateRows, shorthandId, rowsValue.releaseNonNull(), important);
5408         addProperty(CSSPropertyGridTemplateColumns, shorthandId, columnsValue.releaseNonNull(), important);
5409         addProperty(CSSPropertyGridTemplateAreas, shorthandId, CSSValuePool::singleton().createIdentifierValue(CSSValueNone), important);
5410         return true;
5411     }
5412 
5413     // 3- [ &lt;line-names&gt;? &lt;string&gt; &lt;track-size&gt;? &lt;line-names&gt;? ]+ [ / &lt;track-list&gt; ]?
5414     m_range = rangeCopy;
5415     return consumeGridTemplateRowsAndAreasAndColumns(shorthandId, important);
5416 }
5417 
5418 static RefPtr&lt;CSSValue&gt; consumeImplicitGridAutoFlow(CSSParserTokenRange&amp; range, Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; flowDirection)
5419 {
5420     // [ auto-flow &amp;&amp; dense? ]
5421     if (range.atEnd())
5422         return nullptr;
5423     auto list = CSSValueList::createSpaceSeparated();
5424     list-&gt;append(WTFMove(flowDirection));
5425     if (range.peek().id() == CSSValueAutoFlow) {
5426         range.consumeIncludingWhitespace();
5427         RefPtr&lt;CSSValue&gt; denseIdent = consumeIdent&lt;CSSValueDense&gt;(range);
5428         if (denseIdent)
5429             list-&gt;append(denseIdent.releaseNonNull());
5430     } else {
5431         // Dense case
5432         if (range.peek().id() != CSSValueDense)
5433             return nullptr;
5434         range.consumeIncludingWhitespace();
5435         if (range.atEnd() || range.peek().id() != CSSValueAutoFlow)
5436             return nullptr;
5437         range.consumeIncludingWhitespace();
5438         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDense));
5439     }
5440 
5441     return list;
5442 }
5443 
5444 bool CSSPropertyParser::consumeGridShorthand(bool important)
5445 {
5446     ASSERT(shorthandForProperty(CSSPropertyGrid).length() == 6);
5447 
5448     CSSParserTokenRange rangeCopy = m_range;
5449 
5450     // 1- &lt;grid-template&gt;
5451     if (consumeGridTemplateShorthand(CSSPropertyGrid, important)) {
5452         // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5453         // The sub-properties not specified are set to their initial value, as normal for shorthands.
5454         addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5455         addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5456         addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5457         return true;
5458     }
5459 
5460     m_range = rangeCopy;
5461 
5462     RefPtr&lt;CSSValue&gt; autoColumnsValue;
5463     RefPtr&lt;CSSValue&gt; autoRowsValue;
5464     RefPtr&lt;CSSValue&gt; templateRows;
5465     RefPtr&lt;CSSValue&gt; templateColumns;
5466     RefPtr&lt;CSSValue&gt; gridAutoFlow;
5467 
5468     if (m_range.peek().id() == CSSValueAutoFlow || m_range.peek().id() == CSSValueDense) {
5469         // 2- [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-rows&gt;? / &lt;grid-template-columns&gt;
5470         gridAutoFlow = consumeImplicitGridAutoFlow(m_range, CSSValuePool::singleton().createIdentifierValue(CSSValueRow));
5471         if (!gridAutoFlow || m_range.atEnd())
5472             return false;
5473         if (consumeSlashIncludingWhitespace(m_range))
5474             autoRowsValue = CSSValuePool::singleton().createImplicitInitialValue();
5475         else {
5476             autoRowsValue = consumeGridTrackList(m_range, m_context.mode, GridAuto);
5477             if (!autoRowsValue)
5478                 return false;
5479             if (!consumeSlashIncludingWhitespace(m_range))
5480                 return false;
5481         }
5482         if (m_range.atEnd())
5483             return false;
5484         templateColumns = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5485         if (!templateColumns)
5486             return false;
5487         templateRows = CSSValuePool::singleton().createImplicitInitialValue();
5488         autoColumnsValue = CSSValuePool::singleton().createImplicitInitialValue();
5489     } else {
5490         // 3- &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;?
5491         templateRows = consumeGridTemplatesRowsOrColumns(m_range, m_context.mode);
5492         if (!templateRows)
5493             return false;
5494         if (!consumeSlashIncludingWhitespace(m_range) || m_range.atEnd())
5495             return false;
5496         gridAutoFlow = consumeImplicitGridAutoFlow(m_range, CSSValuePool::singleton().createIdentifierValue(CSSValueColumn));
5497         if (!gridAutoFlow)
5498             return false;
5499         if (m_range.atEnd())
5500             autoColumnsValue = CSSValuePool::singleton().createImplicitInitialValue();
5501         else {
5502             autoColumnsValue = consumeGridTrackList(m_range, m_context.mode, GridAuto);
5503             if (!autoColumnsValue)
5504                 return false;
5505         }
5506         templateColumns = CSSValuePool::singleton().createImplicitInitialValue();
5507         autoRowsValue = CSSValuePool::singleton().createImplicitInitialValue();
5508     }
5509 
5510     if (!m_range.atEnd())
5511         return false;
5512 
5513     // It can only be specified the explicit or the implicit grid properties in a single grid declaration.
5514     // The sub-properties not specified are set to their initial value, as normal for shorthands.
5515     addProperty(CSSPropertyGridTemplateColumns, CSSPropertyGrid, templateColumns.releaseNonNull(), important);
5516     addProperty(CSSPropertyGridTemplateRows, CSSPropertyGrid, templateRows.releaseNonNull(), important);
5517     addProperty(CSSPropertyGridTemplateAreas, CSSPropertyGrid, CSSValuePool::singleton().createImplicitInitialValue(), important);
5518     addProperty(CSSPropertyGridAutoFlow, CSSPropertyGrid, gridAutoFlow.releaseNonNull(), important);
5519     addProperty(CSSPropertyGridAutoColumns, CSSPropertyGrid, autoColumnsValue.releaseNonNull(), important);
5520     addProperty(CSSPropertyGridAutoRows, CSSPropertyGrid, autoRowsValue.releaseNonNull(), important);
5521 
5522     return true;
5523 }
5524 
5525 bool CSSPropertyParser::consumePlaceContentShorthand(bool important)
5526 {
5527     ASSERT(shorthandForProperty(CSSPropertyPlaceContent).length() == 2);
5528 
5529     if (m_range.atEnd())
5530         return false;
5531 
5532     CSSParserTokenRange rangeCopy = m_range;
5533     bool isBaseline = isBaselineKeyword(m_range.peek().id());
5534     RefPtr&lt;CSSValue&gt; alignContentValue = consumeContentDistributionOverflowPosition(m_range, isContentPositionKeyword);
5535     if (!alignContentValue)
5536         return false;
5537 
5538     // justify-content property does not allow the &lt;baseline-position&gt; values.
5539     if (m_range.atEnd() &amp;&amp; isBaseline)
5540         return false;
5541     if (isBaselineKeyword(m_range.peek().id()))
5542         return false;
5543 
5544     if (m_range.atEnd())
5545         m_range = rangeCopy;
5546     RefPtr&lt;CSSValue&gt; justifyContentValue = consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
5547     if (!justifyContentValue)
5548         return false;
5549     if (!m_range.atEnd())
5550         return false;
5551 
5552     addProperty(CSSPropertyAlignContent, CSSPropertyPlaceContent, alignContentValue.releaseNonNull(), important);
5553     addProperty(CSSPropertyJustifyContent, CSSPropertyPlaceContent, justifyContentValue.releaseNonNull(), important);
5554     return true;
5555 }
5556 
5557 bool CSSPropertyParser::consumePlaceItemsShorthand(bool important)
5558 {
5559     ASSERT(shorthandForProperty(CSSPropertyPlaceItems).length() == 2);
5560 
5561     CSSParserTokenRange rangeCopy = m_range;
5562     RefPtr&lt;CSSValue&gt; alignItemsValue = consumeAlignItems(m_range);
5563     if (!alignItemsValue)
5564         return false;
5565 
5566     if (m_range.atEnd())
5567         m_range = rangeCopy;
5568     RefPtr&lt;CSSValue&gt; justifyItemsValue = consumeJustifyItems(m_range);
5569     if (!justifyItemsValue)
5570         return false;
5571 
5572     if (!m_range.atEnd())
5573         return false;
5574 
5575     addProperty(CSSPropertyAlignItems, CSSPropertyPlaceItems, alignItemsValue.releaseNonNull(), important);
5576     addProperty(CSSPropertyJustifyItems, CSSPropertyPlaceItems, justifyItemsValue.releaseNonNull(), important);
5577     return true;
5578 }
5579 
5580 bool CSSPropertyParser::consumePlaceSelfShorthand(bool important)
5581 {
5582     ASSERT(shorthandForProperty(CSSPropertyPlaceSelf).length() == 2);
5583 
5584     CSSParserTokenRange rangeCopy = m_range;
5585     RefPtr&lt;CSSValue&gt; alignSelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionKeyword);
5586     if (!alignSelfValue)
5587         return false;
5588 
5589     if (m_range.atEnd())
5590         m_range = rangeCopy;
5591     RefPtr&lt;CSSValue&gt; justifySelfValue = consumeSelfPositionOverflowPosition(m_range, isSelfPositionOrLeftOrRightKeyword);
5592     if (!justifySelfValue)
5593         return false;
5594 
5595     if (!m_range.atEnd())
5596         return false;
5597 
5598     addProperty(CSSPropertyAlignSelf, CSSPropertyPlaceSelf, alignSelfValue.releaseNonNull(), important);
5599     addProperty(CSSPropertyJustifySelf, CSSPropertyPlaceSelf, justifySelfValue.releaseNonNull(), important);
5600     return true;
5601 }
5602 
5603 bool CSSPropertyParser::parseShorthand(CSSPropertyID property, bool important)
5604 {
5605     switch (property) {
5606     case CSSPropertyWebkitMarginCollapse: {
5607         CSSValueID id = m_range.consumeIncludingWhitespace().id();
5608         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginBeforeCollapse, id, m_context))
5609             return false;
5610         addProperty(CSSPropertyWebkitMarginBeforeCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5611         if (m_range.atEnd()) {
5612             addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5613             return true;
5614         }
5615         id = m_range.consumeIncludingWhitespace().id();
5616         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context))
5617             return false;
5618         addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
5619         return true;
5620     }
<a name="91" id="anc91"></a><span class="line-modified">5621     case CSSPropertyOverflow:</span>
<span class="line-modified">5622         return consumeOverflowShorthand(important);</span>



















5623     case CSSPropertyFont: {
5624         const CSSParserToken&amp; token = m_range.peek();
5625         if (token.id() &gt;= CSSValueCaption &amp;&amp; token.id() &lt;= CSSValueStatusBar)
5626             return consumeSystemFont(important);
5627         return consumeFont(important);
5628     }
5629     case CSSPropertyFontVariant:
5630         return consumeFontVariantShorthand(important);
5631     case CSSPropertyBorderSpacing:
5632         return consumeBorderSpacing(important);
5633     case CSSPropertyColumns:
5634         return consumeColumns(important);
5635     case CSSPropertyAnimation:
5636         return consumeAnimationShorthand(animationShorthandForParsing(), important);
5637     case CSSPropertyTransition:
5638         return consumeAnimationShorthand(transitionShorthandForParsing(), important);
5639     case CSSPropertyTextDecoration:
5640     case CSSPropertyWebkitTextDecoration:
5641         // FIXME-NEWPARSER: We need to unprefix -line/-style/-color ASAP and get rid
5642         // of -webkit-text-decoration completely.
5643         return consumeShorthandGreedily(webkitTextDecorationShorthand(), important);
5644     case CSSPropertyInset:
5645         return consume4ValueShorthand(insetShorthand(), important);
5646     case CSSPropertyInsetBlock:
5647         return consume2ValueShorthand(insetBlockShorthand(), important);
5648     case CSSPropertyInsetInline:
5649         return consume2ValueShorthand(insetInlineShorthand(), important);
5650     case CSSPropertyMargin:
5651         return consume4ValueShorthand(marginShorthand(), important);
5652     case CSSPropertyMarginBlock:
5653         return consume2ValueShorthand(marginBlockShorthand(), important);
5654     case CSSPropertyMarginInline:
5655         return consume2ValueShorthand(marginInlineShorthand(), important);
5656     case CSSPropertyPadding:
5657         return consume4ValueShorthand(paddingShorthand(), important);
5658     case CSSPropertyPaddingBlock:
5659         return consume2ValueShorthand(paddingBlockShorthand(), important);
5660     case CSSPropertyPaddingInline:
5661         return consume2ValueShorthand(paddingInlineShorthand(), important);
5662 #if ENABLE(CSS_SCROLL_SNAP)
5663     case CSSPropertyScrollSnapMargin:
5664         return consume4ValueShorthand(scrollSnapMarginShorthand(), important);
5665     case CSSPropertyScrollPadding:
5666         return consume4ValueShorthand(scrollPaddingShorthand(), important);
5667 #endif
5668     case CSSPropertyWebkitTextEmphasis:
5669         return consumeShorthandGreedily(webkitTextEmphasisShorthand(), important);
5670     case CSSPropertyOutline:
5671         return consumeShorthandGreedily(outlineShorthand(), important);
5672     case CSSPropertyBorderInline: {
5673         RefPtr&lt;CSSValue&gt; width;
5674         RefPtr&lt;CSSValue&gt; style;
5675         RefPtr&lt;CSSValue&gt; color;
5676         if (!consumeBorder(width, style, color))
5677             return false;
5678 
5679         addExpandedPropertyForValue(CSSPropertyBorderInlineWidth, width.releaseNonNull(), important);
5680         addExpandedPropertyForValue(CSSPropertyBorderInlineStyle, style.releaseNonNull(), important);
5681         addExpandedPropertyForValue(CSSPropertyBorderInlineColor, color.releaseNonNull(), important);
5682         return true;
5683     }
5684     case CSSPropertyBorderInlineColor:
5685         return consume2ValueShorthand(borderInlineColorShorthand(), important);
5686     case CSSPropertyBorderInlineStyle:
5687         return consume2ValueShorthand(borderInlineStyleShorthand(), important);
5688     case CSSPropertyBorderInlineWidth:
5689         return consume2ValueShorthand(borderInlineWidthShorthand(), important);
5690     case CSSPropertyBorderInlineStart:
5691         return consumeShorthandGreedily(borderInlineStartShorthand(), important);
5692     case CSSPropertyBorderInlineEnd:
5693         return consumeShorthandGreedily(borderInlineEndShorthand(), important);
5694     case CSSPropertyBorderBlock: {
5695         RefPtr&lt;CSSValue&gt; width;
5696         RefPtr&lt;CSSValue&gt; style;
5697         RefPtr&lt;CSSValue&gt; color;
5698         if (!consumeBorder(width, style, color))
5699             return false;
5700 
5701         addExpandedPropertyForValue(CSSPropertyBorderBlockWidth, width.releaseNonNull(), important);
5702         addExpandedPropertyForValue(CSSPropertyBorderBlockStyle, style.releaseNonNull(), important);
5703         addExpandedPropertyForValue(CSSPropertyBorderBlockColor, color.releaseNonNull(), important);
5704         return true;
5705     }
5706     case CSSPropertyBorderBlockColor:
5707         return consume2ValueShorthand(borderBlockColorShorthand(), important);
5708     case CSSPropertyBorderBlockStyle:
5709         return consume2ValueShorthand(borderBlockStyleShorthand(), important);
5710     case CSSPropertyBorderBlockWidth:
5711         return consume2ValueShorthand(borderBlockWidthShorthand(), important);
5712     case CSSPropertyBorderBlockStart:
5713         return consumeShorthandGreedily(borderBlockStartShorthand(), important);
5714     case CSSPropertyBorderBlockEnd:
5715         return consumeShorthandGreedily(borderBlockEndShorthand(), important);
5716     case CSSPropertyWebkitTextStroke:
5717         return consumeShorthandGreedily(webkitTextStrokeShorthand(), important);
5718     case CSSPropertyMarker: {
5719         RefPtr&lt;CSSValue&gt; marker = parseSingleValue(CSSPropertyMarkerStart);
5720         if (!marker || !m_range.atEnd())
5721             return false;
5722         auto markerRef = marker.releaseNonNull();
5723         addProperty(CSSPropertyMarkerStart, CSSPropertyMarker, markerRef.copyRef(), important);
5724         addProperty(CSSPropertyMarkerMid, CSSPropertyMarker, markerRef.copyRef(), important);
5725         addProperty(CSSPropertyMarkerEnd, CSSPropertyMarker, markerRef.copyRef(), important);
5726         return true;
5727     }
5728     case CSSPropertyFlex:
5729         return consumeFlex(important);
5730     case CSSPropertyFlexFlow:
5731         return consumeShorthandGreedily(flexFlowShorthand(), important);
5732     case CSSPropertyColumnRule:
5733         return consumeShorthandGreedily(columnRuleShorthand(), important);
5734     case CSSPropertyListStyle:
5735         return consumeShorthandGreedily(listStyleShorthand(), important);
5736     case CSSPropertyBorderRadius:
5737     case CSSPropertyWebkitBorderRadius: {
5738         RefPtr&lt;CSSPrimitiveValue&gt; horizontalRadii[4];
5739         RefPtr&lt;CSSPrimitiveValue&gt; verticalRadii[4];
5740         if (!consumeRadii(horizontalRadii, verticalRadii, m_range, m_context.mode, property == CSSPropertyWebkitBorderRadius))
5741             return false;
5742         addProperty(CSSPropertyBorderTopLeftRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[0].releaseNonNull(), verticalRadii[0].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5743         addProperty(CSSPropertyBorderTopRightRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[1].releaseNonNull(), verticalRadii[1].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5744         addProperty(CSSPropertyBorderBottomRightRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[2].releaseNonNull(), verticalRadii[2].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5745         addProperty(CSSPropertyBorderBottomLeftRadius, CSSPropertyBorderRadius, createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce), important);
5746         return true;
5747     }
5748     case CSSPropertyBorderColor:
5749         return consume4ValueShorthand(borderColorShorthand(), important);
5750     case CSSPropertyBorderStyle:
5751         return consume4ValueShorthand(borderStyleShorthand(), important);
5752     case CSSPropertyBorderWidth:
5753         return consume4ValueShorthand(borderWidthShorthand(), important);
5754     case CSSPropertyBorderTop:
5755         return consumeShorthandGreedily(borderTopShorthand(), important);
5756     case CSSPropertyBorderRight:
5757         return consumeShorthandGreedily(borderRightShorthand(), important);
5758     case CSSPropertyBorderBottom:
5759         return consumeShorthandGreedily(borderBottomShorthand(), important);
5760     case CSSPropertyBorderLeft:
5761         return consumeShorthandGreedily(borderLeftShorthand(), important);
5762     case CSSPropertyBorder: {
5763         RefPtr&lt;CSSValue&gt; width;
5764         RefPtr&lt;CSSValue&gt; style;
5765         RefPtr&lt;CSSValue&gt; color;
5766         if (!consumeBorder(width, style, color))
5767             return false;
5768 
5769         addExpandedPropertyForValue(CSSPropertyBorderWidth, width.releaseNonNull(), important);
5770         addExpandedPropertyForValue(CSSPropertyBorderStyle, style.releaseNonNull(), important);
5771         addExpandedPropertyForValue(CSSPropertyBorderColor, color.releaseNonNull(), important);
5772         addExpandedPropertyForValue(CSSPropertyBorderImage, CSSValuePool::singleton().createImplicitInitialValue(), important);
5773         return true;
5774     }
5775     case CSSPropertyBorderImage:
5776         return consumeBorderImage(property, important);
5777     case CSSPropertyPageBreakAfter:
5778     case CSSPropertyPageBreakBefore:
5779     case CSSPropertyPageBreakInside:
5780     case CSSPropertyWebkitColumnBreakAfter:
5781     case CSSPropertyWebkitColumnBreakBefore:
5782     case CSSPropertyWebkitColumnBreakInside:
5783         return consumeLegacyBreakProperty(property, important);
5784     case CSSPropertyWebkitMaskPosition:
5785     case CSSPropertyBackgroundPosition: {
5786         RefPtr&lt;CSSValue&gt; resultX;
5787         RefPtr&lt;CSSValue&gt; resultY;
5788         if (!consumeBackgroundPosition(m_range, m_context, UnitlessQuirk::Allow, resultX, resultY) || !m_range.atEnd())
5789             return false;
5790         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionX : CSSPropertyWebkitMaskPositionX, property, resultX.releaseNonNull(), important);
5791         addProperty(property == CSSPropertyBackgroundPosition ? CSSPropertyBackgroundPositionY : CSSPropertyWebkitMaskPositionY, property, resultY.releaseNonNull(), important);
5792         return true;
5793     }
5794     case CSSPropertyBackgroundRepeat:
5795     case CSSPropertyWebkitMaskRepeat: {
5796         RefPtr&lt;CSSValue&gt; resultX;
5797         RefPtr&lt;CSSValue&gt; resultY;
5798         bool implicit = false;
5799         if (!consumeRepeatStyle(m_range, resultX, resultY, implicit) || !m_range.atEnd())
5800             return false;
5801         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatX : CSSPropertyWebkitMaskRepeatX, property, resultX.releaseNonNull(), important, implicit);
5802         addProperty(property == CSSPropertyBackgroundRepeat ? CSSPropertyBackgroundRepeatY : CSSPropertyWebkitMaskRepeatY, property, resultY.releaseNonNull(), important, implicit);
5803         return true;
5804     }
5805     case CSSPropertyBackground:
5806         return consumeBackgroundShorthand(backgroundShorthand(), important);
5807     case CSSPropertyWebkitMask:
5808         return consumeBackgroundShorthand(webkitMaskShorthand(), important);
5809     case CSSPropertyTransformOrigin:
5810         return consumeTransformOrigin(important);
5811     case CSSPropertyPerspectiveOrigin:
5812         return consumePerspectiveOrigin(important);
5813     case CSSPropertyGap: {
5814         RefPtr&lt;CSSValue&gt; rowGap = consumeGapLength(m_range, m_context.mode);
5815         RefPtr&lt;CSSValue&gt; columnGap = consumeGapLength(m_range, m_context.mode);
5816         if (!rowGap || !m_range.atEnd())
5817             return false;
5818         if (!columnGap)
5819             columnGap = rowGap;
5820         addProperty(CSSPropertyRowGap, CSSPropertyGap, rowGap.releaseNonNull(), important);
5821         addProperty(CSSPropertyColumnGap, CSSPropertyGap, columnGap.releaseNonNull(), important);
5822         return true;
5823     }
5824     case CSSPropertyGridColumn:
5825     case CSSPropertyGridRow:
5826         return consumeGridItemPositionShorthand(property, important);
5827     case CSSPropertyGridArea:
5828         return consumeGridAreaShorthand(important);
5829     case CSSPropertyGridTemplate:
5830         return consumeGridTemplateShorthand(CSSPropertyGridTemplate, important);
5831     case CSSPropertyGrid:
5832         return consumeGridShorthand(important);
5833     case CSSPropertyPlaceContent:
5834         return consumePlaceContentShorthand(important);
5835     case CSSPropertyPlaceItems:
5836         return consumePlaceItemsShorthand(important);
5837     case CSSPropertyPlaceSelf:
5838         return consumePlaceSelfShorthand(important);
<a name="92" id="anc92"></a>

5839     default:
5840         return false;
5841     }
5842 }
5843 
5844 } // namespace WebCore
<a name="93" id="anc93"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="93" type="hidden" />
</body>
</html>
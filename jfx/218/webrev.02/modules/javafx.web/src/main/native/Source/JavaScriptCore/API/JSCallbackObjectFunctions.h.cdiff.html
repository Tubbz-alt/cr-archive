<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSCallbackObjectFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCallbackObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSCallbackObjectFunctions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 22,10 ***</span>
<span class="line-new-header">--- 22,12 ---</span>
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
<span class="line-added">+ #pragma once</span>
<span class="line-added">+ </span>
  #include &quot;APICast.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
  #include &quot;JSCallbackFunction.h&quot;
  #include &quot;JSClassRef.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,12 ***</span>
      ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
      return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! JSCallbackObject&lt;Parent&gt;::JSCallbackObject(ExecState* exec, Structure* structure, JSClassRef jsClass, void* data)</span>
<span class="line-modified">!     : Parent(exec-&gt;vm(), structure)</span>
      , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(data, jsClass))
  {
  }
  
  // Global object constructor.
<span class="line-new-header">--- 56,12 ---</span>
      ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
      return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! JSCallbackObject&lt;Parent&gt;::JSCallbackObject(JSGlobalObject* globalObject, Structure* structure, JSClassRef jsClass, void* data)</span>
<span class="line-modified">!     : Parent(getVM(globalObject), structure)</span>
      , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(data, jsClass))
  {
  }
  
  // Global object constructor.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,48 ***</span>
      vm.currentlyDestructingCallbackObject = nullptr;
      vm.currentlyDestructingCallbackObjectClassInfo = nullptr;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! void JSCallbackObject&lt;Parent&gt;::finishCreation(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      Base::finishCreation(vm);
      ASSERT(Parent::inherits(vm, info()));
<span class="line-modified">!     init(exec);</span>
  }
  
  // This is just for Global object, so we can assume that Base::finishCreation is JSGlobalObject::finishCreation.
  template &lt;class Parent&gt;
  void JSCallbackObject&lt;Parent&gt;::finishCreation(VM&amp; vm)
  {
      ASSERT(Parent::inherits(vm, info()));
      ASSERT(Parent::isGlobalObject());
      Base::finishCreation(vm);
<span class="line-modified">!     init(jsCast&lt;JSGlobalObject*&gt;(this)-&gt;globalExec());</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! void JSCallbackObject&lt;Parent&gt;::init(ExecState* exec)</span>
  {
<span class="line-modified">!     ASSERT(exec);</span>
  
      Vector&lt;JSObjectInitializeCallback, 16&gt; initRoutines;
      JSClassRef jsClass = classRef();
      do {
          if (JSObjectInitializeCallback initialize = jsClass-&gt;initialize)
              initRoutines.append(initialize);
      } while ((jsClass = jsClass-&gt;parentClass));
  
      // initialize from base to derived
      for (int i = static_cast&lt;int&gt;(initRoutines.size()) - 1; i &gt;= 0; i--) {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(exec);</span>
          JSObjectInitializeCallback initialize = initRoutines[i];
<span class="line-modified">!         initialize(toRef(exec), toRef(this));</span>
      }
  
<span class="line-modified">!     m_classInfo = this-&gt;classInfo();</span>
  }
  
  template &lt;class Parent&gt;
  String JSCallbackObject&lt;Parent&gt;::className(const JSObject* object, VM&amp; vm)
  {
<span class="line-new-header">--- 88,48 ---</span>
      vm.currentlyDestructingCallbackObject = nullptr;
      vm.currentlyDestructingCallbackObjectClassInfo = nullptr;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! void JSCallbackObject&lt;Parent&gt;::finishCreation(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      Base::finishCreation(vm);
      ASSERT(Parent::inherits(vm, info()));
<span class="line-modified">!     init(globalObject);</span>
  }
  
  // This is just for Global object, so we can assume that Base::finishCreation is JSGlobalObject::finishCreation.
  template &lt;class Parent&gt;
  void JSCallbackObject&lt;Parent&gt;::finishCreation(VM&amp; vm)
  {
      ASSERT(Parent::inherits(vm, info()));
      ASSERT(Parent::isGlobalObject());
      Base::finishCreation(vm);
<span class="line-modified">!     init(jsCast&lt;JSGlobalObject*&gt;(this));</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! void JSCallbackObject&lt;Parent&gt;::init(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     ASSERT(globalObject);</span>
  
      Vector&lt;JSObjectInitializeCallback, 16&gt; initRoutines;
      JSClassRef jsClass = classRef();
      do {
          if (JSObjectInitializeCallback initialize = jsClass-&gt;initialize)
              initRoutines.append(initialize);
      } while ((jsClass = jsClass-&gt;parentClass));
  
      // initialize from base to derived
      for (int i = static_cast&lt;int&gt;(initRoutines.size()) - 1; i &gt;= 0; i--) {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(globalObject);</span>
          JSObjectInitializeCallback initialize = initRoutines[i];
<span class="line-modified">!         initialize(toRef(globalObject), toRef(jsCast&lt;JSObject*&gt;(this)));</span>
      }
  
<span class="line-modified">!     m_classInfo = this-&gt;classInfo(getVM(globalObject));</span>
  }
  
  template &lt;class Parent&gt;
  String JSCallbackObject&lt;Parent&gt;::className(const JSObject* object, VM&amp; vm)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,295 ***</span>
  
      return Parent::className(object, vm);
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! String JSCallbackObject&lt;Parent&gt;::toStringName(const JSObject* object, ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      const ClassInfo* info = object-&gt;classInfo(vm);
      ASSERT(info);
      return info-&gt;methodTable.className(object, vm);
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObject);</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              // optional optimization to bypass getProperty in cases when we only need to know if the property exists
              if (JSObjectHasPropertyCallback hasProperty = jsClass-&gt;hasProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(exec);</span>
                  if (hasProperty(ctx, thisRef, propertyNameRef.get())) {
                      slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, callbackGetter);
                      return true;
                  }
              } else if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  JSValueRef value;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(exec);</span>
                      value = getProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
                  }
                  if (exception) {
<span class="line-modified">!                     throwException(exec, scope, toJS(exec, exception));</span>
                      slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, jsUndefined());
                      return true;
                  }
                  if (value) {
<span class="line-modified">!                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, toJS(exec, value));</span>
                      return true;
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
                  if (staticValues-&gt;contains(name)) {
<span class="line-modified">!                     JSValue value = thisObject-&gt;getStaticValue(exec, propertyName);</span>
                      if (value) {
                          slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, value);
                          return true;
                      }
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
                  if (staticFunctions-&gt;contains(name)) {
                      slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, staticFunctionGetter);
                      return true;
                  }
              }
          }
      }
  
<span class="line-modified">!     return Parent::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     return object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, exec, Identifier::from(vm, propertyName), slot);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! JSValue JSCallbackObject&lt;Parent&gt;::defaultValue(const JSObject* object, ExecState* exec, PreferredPrimitiveType hint)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObject);</span>
      ::JSType jsHint = hint == PreferString ? kJSTypeString : kJSTypeNumber;
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectConvertToTypeCallback convertToType = jsClass-&gt;convertToType) {
              JSValueRef exception = 0;
              JSValueRef result = convertToType(ctx, thisRef, jsHint, &amp;exception);
              if (exception) {
<span class="line-modified">!                 throwException(exec, scope, toJS(exec, exception));</span>
                  return jsUndefined();
              }
              if (result)
<span class="line-modified">!                 return toJS(exec, result);</span>
          }
      }
  
<span class="line-modified">!     return Parent::defaultValue(object, exec, hint);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObject);</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">!     JSValueRef valueRef = toRef(exec, value);</span>
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  bool result;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(exec);</span>
                      result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
                  }
                  if (exception)
<span class="line-modified">!                     throwException(exec, scope, toJS(exec, exception));</span>
                  if (result || exception)
                      return result;
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
                  if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                          return false;
                      if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
                          JSValueRef exception = 0;
                          bool result;
                          {
<span class="line-modified">!                             JSLock::DropAllLocks dropAllLocks(exec);</span>
                              result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
                          }
                          if (exception)
<span class="line-modified">!                             throwException(exec, scope, toJS(exec, exception));</span>
                          if (result || exception)
                              return result;
                      }
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
                  if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
                      PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!                     if (Parent::getOwnPropertySlot(thisObject, exec, propertyName, getSlot))</span>
<span class="line-modified">!                         return Parent::put(thisObject, exec, propertyName, value, slot);</span>
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                          return false;
                      return thisObject-&gt;JSCallbackObject&lt;Parent&gt;::putDirect(vm, propertyName, value); // put as override property
                  }
              }
          }
      }
  
<span class="line-modified">!     return Parent::put(thisObject, exec, propertyName, value, slot);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyIndex, JSValue value, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObject);</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">!     JSValueRef valueRef = toRef(exec, value);</span>
      Identifier propertyName = Identifier::from(vm, propertyIndex);
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
              if (!propertyNameRef)
                  propertyNameRef = OpaqueJSString::tryCreate(propertyName.impl());
              JSValueRef exception = 0;
              bool result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(exec);</span>
                  result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
              }
              if (exception)
<span class="line-modified">!                 throwException(exec, scope, toJS(exec, exception));</span>
              if (result || exception)
                  return result;
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
              if (StaticValueEntry* entry = staticValues-&gt;get(propertyName.impl())) {
                  if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                      return false;
                  if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
                      JSValueRef exception = 0;
                      bool result;
                      {
<span class="line-modified">!                         JSLock::DropAllLocks dropAllLocks(exec);</span>
                          result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
                      }
                      if (exception)
<span class="line-modified">!                         throwException(exec, scope, toJS(exec, exception));</span>
                      if (result || exception)
                          return result;
                  }
              }
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
              if (StaticFunctionEntry* entry = staticFunctions-&gt;get(propertyName.impl())) {
                  if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                      return false;
                  break;
              }
          }
      }
  
<span class="line-modified">!     return Parent::putByIndex(thisObject, exec, propertyIndex, value, shouldThrow);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObject);</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              if (JSObjectDeletePropertyCallback deleteProperty = jsClass-&gt;deleteProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  bool result;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(exec);</span>
                      result = deleteProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
                  }
                  if (exception)
<span class="line-modified">!                     throwException(exec, scope, toJS(exec, exception));</span>
                  if (result || exception)
                      return true;
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
                  if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
                          return false;
                      return true;
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
                  if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
                          return false;
                      return true;
                  }
              }
          }
      }
  
<span class="line-modified">!     return Parent::deleteProperty(thisObject, exec, propertyName);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(vm, propertyName));</span>
  }
  
  template &lt;class Parent&gt;
  ConstructType JSCallbackObject&lt;Parent&gt;::getConstructData(JSCell* cell, ConstructData&amp; constructData)
  {
<span class="line-new-header">--- 140,295 ---</span>
  
      return Parent::className(object, vm);
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! String JSCallbackObject&lt;Parent&gt;::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      const ClassInfo* info = object-&gt;classInfo(vm);
      ASSERT(info);
      return info-&gt;methodTable.className(object, vm);
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              // optional optimization to bypass getProperty in cases when we only need to know if the property exists
              if (JSObjectHasPropertyCallback hasProperty = jsClass-&gt;hasProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                  if (hasProperty(ctx, thisRef, propertyNameRef.get())) {
                      slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, callbackGetter);
                      return true;
                  }
              } else if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  JSValueRef value;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                      value = getProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
                  }
                  if (exception) {
<span class="line-modified">!                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
                      slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, jsUndefined());
                      return true;
                  }
                  if (value) {
<span class="line-modified">!                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, toJS(globalObject, value));</span>
                      return true;
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
                  if (staticValues-&gt;contains(name)) {
<span class="line-modified">!                     JSValue value = thisObject-&gt;getStaticValue(globalObject, propertyName);</span>
                      if (value) {
                          slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, value);
                          return true;
                      }
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
                  if (staticFunctions-&gt;contains(name)) {
                      slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, staticFunctionGetter);
                      return true;
                  }
              }
          }
      }
  
<span class="line-modified">!     return Parent::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
<span class="line-modified">!     return object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, globalObject, Identifier::from(vm, propertyName), slot);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! JSValue JSCallbackObject&lt;Parent&gt;::defaultValue(const JSObject* object, JSGlobalObject* globalObject, PreferredPrimitiveType hint)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;const JSObject*&gt;(thisObject));</span>
      ::JSType jsHint = hint == PreferString ? kJSTypeString : kJSTypeNumber;
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectConvertToTypeCallback convertToType = jsClass-&gt;convertToType) {
              JSValueRef exception = 0;
              JSValueRef result = convertToType(ctx, thisRef, jsHint, &amp;exception);
              if (exception) {
<span class="line-modified">!                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
                  return jsUndefined();
              }
              if (result)
<span class="line-modified">!                 return toJS(globalObject, result);</span>
          }
      }
  
<span class="line-modified">!     return Parent::defaultValue(object, globalObject, hint);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">!     JSValueRef valueRef = toRef(globalObject, value);</span>
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  bool result;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                      result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
                  }
                  if (exception)
<span class="line-modified">!                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
                  if (result || exception)
                      return result;
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
                  if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                          return false;
                      if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
                          JSValueRef exception = 0;
                          bool result;
                          {
<span class="line-modified">!                             JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                              result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
                          }
                          if (exception)
<span class="line-modified">!                             throwException(globalObject, scope, toJS(globalObject, exception));</span>
                          if (result || exception)
                              return result;
                      }
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
                  if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
                      PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!                     if (Parent::getOwnPropertySlot(thisObject, globalObject, propertyName, getSlot))</span>
<span class="line-modified">!                         return Parent::put(thisObject, globalObject, propertyName, value, slot);</span>
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                          return false;
                      return thisObject-&gt;JSCallbackObject&lt;Parent&gt;::putDirect(vm, propertyName, value); // put as override property
                  }
              }
          }
      }
  
<span class="line-modified">!     return Parent::put(thisObject, globalObject, propertyName, value, slot);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyIndex, JSValue value, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">!     JSValueRef valueRef = toRef(globalObject, value);</span>
      Identifier propertyName = Identifier::from(vm, propertyIndex);
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
              if (!propertyNameRef)
                  propertyNameRef = OpaqueJSString::tryCreate(propertyName.impl());
              JSValueRef exception = 0;
              bool result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                  result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
              }
              if (exception)
<span class="line-modified">!                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
              if (result || exception)
                  return result;
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
              if (StaticValueEntry* entry = staticValues-&gt;get(propertyName.impl())) {
                  if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                      return false;
                  if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
                      JSValueRef exception = 0;
                      bool result;
                      {
<span class="line-modified">!                         JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                          result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
                      }
                      if (exception)
<span class="line-modified">!                         throwException(globalObject, scope, toJS(globalObject, exception));</span>
                      if (result || exception)
                          return result;
                  }
              }
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
              if (StaticFunctionEntry* entry = staticFunctions-&gt;get(propertyName.impl())) {
                  if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
                      return false;
                  break;
              }
          }
      }
  
<span class="line-modified">!     return Parent::putByIndex(thisObject, globalObject, propertyIndex, value, shouldThrow);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              if (JSObjectDeletePropertyCallback deleteProperty = jsClass-&gt;deleteProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  bool result;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                      result = deleteProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
                  }
                  if (exception)
<span class="line-modified">!                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
                  if (result || exception)
                      return true;
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
                  if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
                          return false;
                      return true;
                  }
              }
  
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
                  if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
                      if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
                          return false;
                      return true;
                  }
              }
          }
      }
  
<span class="line-modified">!     return Parent::deleteProperty(thisObject, globalObject, propertyName);</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, globalObject, Identifier::from(vm, propertyName));</span>
  }
  
  template &lt;class Parent&gt;
  ConstructType JSCallbackObject&lt;Parent&gt;::getConstructData(JSCell* cell, ConstructData&amp; constructData)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 439,63 ***</span>
      }
      return ConstructType::None;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::construct(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* constructor = exec-&gt;jsCallee();</span>
<span class="line-modified">!     JSContextRef execRef = toRef(exec);</span>
      JSObjectRef constructorRef = toRef(constructor);
  
      for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(constructor)-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectCallAsConstructorCallback callAsConstructor = jsClass-&gt;callAsConstructor) {
<span class="line-modified">!             size_t argumentCount = exec-&gt;argumentCount();</span>
              Vector&lt;JSValueRef, 16&gt; arguments;
              arguments.reserveInitialCapacity(argumentCount);
              for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!                 arguments.uncheckedAppend(toRef(exec, exec-&gt;uncheckedArgument(i)));</span>
              JSValueRef exception = 0;
              JSObject* result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(exec);</span>
                  result = toJS(callAsConstructor(execRef, constructorRef, argumentCount, arguments.data(), &amp;exception));
              }
              if (exception)
<span class="line-modified">!                 throwException(exec, scope, toJS(exec, exception));</span>
              return JSValue::encode(result);
          }
      }
  
      RELEASE_ASSERT_NOT_REACHED(); // getConstructData should prevent us from reaching here
      return JSValue::encode(JSValue());
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::customHasInstance(JSObject* object, ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef execRef = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObject);</span>
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectHasInstanceCallback hasInstance = jsClass-&gt;hasInstance) {
<span class="line-modified">!             JSValueRef valueRef = toRef(exec, value);</span>
              JSValueRef exception = 0;
              bool result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(exec);</span>
                  result = hasInstance(execRef, thisRef, valueRef, &amp;exception);
              }
              if (exception)
<span class="line-modified">!                 throwException(exec, scope, toJS(exec, exception));</span>
              return result;
          }
      }
      return false;
  }
<span class="line-new-header">--- 441,63 ---</span>
      }
      return ConstructType::None;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::construct(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* constructor = callFrame-&gt;jsCallee();</span>
<span class="line-modified">!     JSContextRef execRef = toRef(globalObject);</span>
      JSObjectRef constructorRef = toRef(constructor);
  
      for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(constructor)-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectCallAsConstructorCallback callAsConstructor = jsClass-&gt;callAsConstructor) {
<span class="line-modified">!             size_t argumentCount = callFrame-&gt;argumentCount();</span>
              Vector&lt;JSValueRef, 16&gt; arguments;
              arguments.reserveInitialCapacity(argumentCount);
              for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!                 arguments.uncheckedAppend(toRef(globalObject, callFrame-&gt;uncheckedArgument(i)));</span>
              JSValueRef exception = 0;
              JSObject* result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                  result = toJS(callAsConstructor(execRef, constructorRef, argumentCount, arguments.data(), &amp;exception));
              }
              if (exception)
<span class="line-modified">!                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
              return JSValue::encode(result);
          }
      }
  
      RELEASE_ASSERT_NOT_REACHED(); // getConstructData should prevent us from reaching here
      return JSValue::encode(JSValue());
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! bool JSCallbackObject&lt;Parent&gt;::customHasInstance(JSObject* object, JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef execRef = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectHasInstanceCallback hasInstance = jsClass-&gt;hasInstance) {
<span class="line-modified">!             JSValueRef valueRef = toRef(globalObject, value);</span>
              JSValueRef exception = 0;
              bool result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
                  result = hasInstance(execRef, thisRef, valueRef, &amp;exception);
              }
              if (exception)
<span class="line-modified">!                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
              return result;
          }
      }
      return false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 512,57 ***</span>
      }
      return CallType::None;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::call(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSContextRef execRef = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef functionRef = toRef(exec-&gt;jsCallee());</span>
<span class="line-modified">!     JSObjectRef thisObjRef = toRef(jsCast&lt;JSObject*&gt;(exec-&gt;thisValue().toThis(exec, NotStrictMode)));</span>
  
      for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(toJS(functionRef))-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectCallAsFunctionCallback callAsFunction = jsClass-&gt;callAsFunction) {
<span class="line-modified">!             size_t argumentCount = exec-&gt;argumentCount();</span>
              Vector&lt;JSValueRef, 16&gt; arguments;
              arguments.reserveInitialCapacity(argumentCount);
              for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!                 arguments.uncheckedAppend(toRef(exec, exec-&gt;uncheckedArgument(i)));</span>
              JSValueRef exception = 0;
              JSValue result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(exec);</span>
<span class="line-modified">!                 result = toJS(exec, callAsFunction(execRef, functionRef, thisObjRef, argumentCount, arguments.data(), &amp;exception));</span>
              }
              if (exception)
<span class="line-modified">!                 throwException(exec, scope, toJS(exec, exception));</span>
              return JSValue::encode(result);
          }
      }
  
      RELEASE_ASSERT_NOT_REACHED(); // getCallData should prevent us from reaching here
      return JSValue::encode(JSValue());
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! void JSCallbackObject&lt;Parent&gt;::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef execRef = toRef(exec);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObject);</span>
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectGetPropertyNamesCallback getPropertyNames = jsClass-&gt;getPropertyNames) {
<span class="line-modified">!             JSLock::DropAllLocks dropAllLocks(exec);</span>
              getPropertyNames(execRef, thisRef, toRef(&amp;propertyNames));
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
              typedef OpaqueJSClassStaticValuesTable::const_iterator iterator;
              iterator end = staticValues-&gt;end();
              for (iterator it = staticValues-&gt;begin(); it != end; ++it) {
                  StringImpl* name = it-&gt;key.get();
                  StaticValueEntry* entry = it-&gt;value.get();
<span class="line-new-header">--- 514,57 ---</span>
      }
      return CallType::None;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::call(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSContextRef execRef = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef functionRef = toRef(callFrame-&gt;jsCallee());</span>
<span class="line-modified">!     JSObjectRef thisObjRef = toRef(jsCast&lt;JSObject*&gt;(callFrame-&gt;thisValue().toThis(globalObject, NotStrictMode)));</span>
  
      for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(toJS(functionRef))-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectCallAsFunctionCallback callAsFunction = jsClass-&gt;callAsFunction) {
<span class="line-modified">!             size_t argumentCount = callFrame-&gt;argumentCount();</span>
              Vector&lt;JSValueRef, 16&gt; arguments;
              arguments.reserveInitialCapacity(argumentCount);
              for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">!                 arguments.uncheckedAppend(toRef(globalObject, callFrame-&gt;uncheckedArgument(i)));</span>
              JSValueRef exception = 0;
              JSValue result;
              {
<span class="line-modified">!                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
<span class="line-modified">!                 result = toJS(globalObject, callAsFunction(execRef, functionRef, thisObjRef, argumentCount, arguments.data(), &amp;exception));</span>
              }
              if (exception)
<span class="line-modified">!                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
              return JSValue::encode(result);
          }
      }
  
      RELEASE_ASSERT_NOT_REACHED(); // getCallData should prevent us from reaching here
      return JSValue::encode(JSValue());
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! void JSCallbackObject&lt;Parent&gt;::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">!     JSContextRef execRef = toRef(globalObject);</span>
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
  
      for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
          if (JSObjectGetPropertyNamesCallback getPropertyNames = jsClass-&gt;getPropertyNames) {
<span class="line-modified">!             JSLock::DropAllLocks dropAllLocks(globalObject);</span>
              getPropertyNames(execRef, thisRef, toRef(&amp;propertyNames));
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
              typedef OpaqueJSClassStaticValuesTable::const_iterator iterator;
              iterator end = staticValues-&gt;end();
              for (iterator it = staticValues-&gt;begin(); it != end; ++it) {
                  StringImpl* name = it-&gt;key.get();
                  StaticValueEntry* entry = it-&gt;value.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,11 ***</span>
                      propertyNames.add(Identifier::fromString(vm, String(name)));
                  }
              }
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
              typedef OpaqueJSClassStaticFunctionsTable::const_iterator iterator;
              iterator end = staticFunctions-&gt;end();
              for (iterator it = staticFunctions-&gt;begin(); it != end; ++it) {
                  StringImpl* name = it-&gt;key.get();
                  StaticFunctionEntry* entry = it-&gt;value.get();
<span class="line-new-header">--- 573,11 ---</span>
                      propertyNames.add(Identifier::fromString(vm, String(name)));
                  }
              }
          }
  
<span class="line-modified">!         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
              typedef OpaqueJSClassStaticFunctionsTable::const_iterator iterator;
              iterator end = staticFunctions-&gt;end();
              for (iterator it = staticFunctions-&gt;begin(); it != end; ++it) {
                  StringImpl* name = it-&gt;key.get();
                  StaticFunctionEntry* entry = it-&gt;value.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,11 ***</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     Parent::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);</span>
  }
  
  template &lt;class Parent&gt;
  void JSCallbackObject&lt;Parent&gt;::setPrivate(void* data)
  {
<span class="line-new-header">--- 587,11 ---</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     Parent::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode);</span>
  }
  
  template &lt;class Parent&gt;
  void JSCallbackObject&lt;Parent&gt;::setPrivate(void* data)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,59 ***</span>
      }
      return false;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! JSValue JSCallbackObject&lt;Parent&gt;::getStaticValue(ExecState* exec, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObjectRef thisRef = toRef(this);</span>
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
                  if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
                      if (JSObjectGetPropertyCallback getProperty = entry-&gt;getProperty) {
                          JSValueRef exception = 0;
                          JSValueRef value;
                          {
<span class="line-modified">!                             JSLock::DropAllLocks dropAllLocks(exec);</span>
<span class="line-modified">!                             value = getProperty(toRef(exec), thisRef, entry-&gt;propertyNameRef.get(), &amp;exception);</span>
                          }
                          if (exception) {
<span class="line-modified">!                             throwException(exec, scope, toJS(exec, exception));</span>
                              return jsUndefined();
                          }
                          if (value)
<span class="line-modified">!                             return toJS(exec, value);</span>
                      }
                  }
              }
          }
      }
  
      return JSValue();
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::staticFunctionGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObj = asCallbackObject(thisValue);
  
      // Check for cached or override property.
      PropertySlot slot2(thisObj, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     if (Parent::getOwnPropertySlot(thisObj, exec, propertyName, slot2))</span>
<span class="line-modified">!         return JSValue::encode(slot2.getValue(exec, propertyName));</span>
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
                  if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
                      if (JSObjectCallAsFunctionCallback callAsFunction = entry-&gt;callAsFunction) {
                          JSObject* o = JSCallbackFunction::create(vm, thisObj-&gt;globalObject(vm), callAsFunction, name);
                          thisObj-&gt;putDirect(vm, propertyName, o, entry-&gt;attributes);
                          return JSValue::encode(o);
<span class="line-new-header">--- 613,59 ---</span>
      }
      return false;
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! JSValue JSCallbackObject&lt;Parent&gt;::getStaticValue(JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(this));</span>
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">!             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
                  if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
                      if (JSObjectGetPropertyCallback getProperty = entry-&gt;getProperty) {
                          JSValueRef exception = 0;
                          JSValueRef value;
                          {
<span class="line-modified">!                             JSLock::DropAllLocks dropAllLocks(globalObject);</span>
<span class="line-modified">!                             value = getProperty(toRef(globalObject), thisRef, entry-&gt;propertyNameRef.get(), &amp;exception);</span>
                          }
                          if (exception) {
<span class="line-modified">!                             throwException(globalObject, scope, toJS(globalObject, exception));</span>
                              return jsUndefined();
                          }
                          if (value)
<span class="line-modified">!                             return toJS(globalObject, value);</span>
                      }
                  }
              }
          }
      }
  
      return JSValue();
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::staticFunctionGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObj = asCallbackObject(thisValue);
  
      // Check for cached or override property.
      PropertySlot slot2(thisObj, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     if (Parent::getOwnPropertySlot(thisObj, globalObject, propertyName, slot2))</span>
<span class="line-modified">!         return JSValue::encode(slot2.getValue(globalObject, propertyName));</span>
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">!             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
                  if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
                      if (JSObjectCallAsFunctionCallback callAsFunction = entry-&gt;callAsFunction) {
                          JSObject* o = JSCallbackFunction::create(vm, thisObj-&gt;globalObject(vm), callAsFunction, name);
                          thisObj-&gt;putDirect(vm, propertyName, o, entry-&gt;attributes);
                          return JSValue::encode(o);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,44 ***</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     return JSValue::encode(throwException(exec, scope, createReferenceError(exec, &quot;Static function property defined with NULL callAsFunction callback.&quot;_s)));</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::callbackGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObj = asCallbackObject(thisValue);
  
<span class="line-modified">!     JSObjectRef thisRef = toRef(thisObj);</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  JSValueRef value;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(exec);</span>
<span class="line-modified">!                     value = getProperty(toRef(exec), thisRef, propertyNameRef.get(), &amp;exception);</span>
                  }
                  if (exception) {
<span class="line-modified">!                     throwException(exec, scope, toJS(exec, exception));</span>
                      return JSValue::encode(jsUndefined());
                  }
                  if (value)
<span class="line-modified">!                     return JSValue::encode(toJS(exec, value));</span>
              }
          }
      }
  
<span class="line-modified">!     return JSValue::encode(throwException(exec, scope, createReferenceError(exec, &quot;hasProperty callback returned true for a property that doesn&#39;t exist.&quot;_s)));</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 673,44 ---</span>
                  }
              }
          }
      }
  
<span class="line-modified">!     return JSValue::encode(throwException(globalObject, scope, createReferenceError(globalObject, &quot;Static function property defined with NULL callAsFunction callback.&quot;_s)));</span>
  }
  
  template &lt;class Parent&gt;
<span class="line-modified">! EncodedJSValue JSCallbackObject&lt;Parent&gt;::callbackGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSCallbackObject* thisObj = asCallbackObject(thisValue);
  
<span class="line-modified">!     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObj));</span>
      RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
  
      if (StringImpl* name = propertyName.uid()) {
          for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
              if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
                  if (!propertyNameRef)
                      propertyNameRef = OpaqueJSString::tryCreate(name);
                  JSValueRef exception = 0;
                  JSValueRef value;
                  {
<span class="line-modified">!                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
<span class="line-modified">!                     value = getProperty(toRef(globalObject), thisRef, propertyNameRef.get(), &amp;exception);</span>
                  }
                  if (exception) {
<span class="line-modified">!                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
                      return JSValue::encode(jsUndefined());
                  }
                  if (value)
<span class="line-modified">!                     return JSValue::encode(toJS(globalObject, value));</span>
              }
          }
      }
  
<span class="line-modified">!     return JSValue::encode(throwException(globalObject, scope, createReferenceError(globalObject, &quot;hasProperty callback returned true for a property that doesn&#39;t exist.&quot;_s)));</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="JSCallbackObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontTaggedSettings.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2016 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &lt;array&gt;
 30 #include &lt;wtf/HashTraits.h&gt;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace WTF {
 34 class TextStream;
 35 }
 36 
 37 namespace WebCore {
 38 
 39 typedef std::array&lt;char, 4&gt; FontTag;
 40 
 41 inline FontTag fontFeatureTag(const char arr[4]) { return {{ arr[0], arr[1], arr[2], arr[3] }}; }
 42 
 43 struct FourCharacterTagHash {
 44     static unsigned hash(const FontTag&amp; characters) { return (characters[0] &lt;&lt; 24) | (characters[1] &lt;&lt; 16) | (characters[2] &lt;&lt; 8) | characters[3]; }
 45     static bool equal(const FontTag&amp; a, const FontTag&amp; b) { return a == b; }
 46     static const bool safeToCompareToEmptyOrDeleted = true;
 47 };
 48 
 49 struct FourCharacterTagHashTraits : WTF::GenericHashTraits&lt;FontTag&gt; {
 50     static const bool emptyValueIsZero = true;
 51     static void constructDeletedValue(FontTag&amp; slot) { new (NotNull, std::addressof(slot)) FontTag({{ ff, ff, ff, ff }}); }
 52     static bool isDeletedValue(const FontTag&amp; value) { return value == FontTag({{ ff, ff, ff, ff }}); }
 53 
 54 private:
 55     static constexpr char ff = static_cast&lt;char&gt;(0xFF);
 56 };
 57 
 58 template &lt;typename T&gt;
 59 class FontTaggedSetting {
 60 public:
 61     FontTaggedSetting() = delete;
 62     FontTaggedSetting(const FontTag&amp;, T value);
 63     FontTaggedSetting(FontTag&amp;&amp;, T value);
 64 
 65     bool operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 66     bool operator!=(const FontTaggedSetting&lt;T&gt;&amp; other) const { return !(*this == other); }
 67     bool operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const;
 68 
 69     const FontTag&amp; tag() const { return m_tag; }
 70     T value() const { return m_value; }
 71     bool enabled() const { return value(); }
 72 
 73     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 74     template&lt;class Decoder&gt; static Optional&lt;FontTaggedSetting&lt;T&gt;&gt; decode(Decoder&amp;);
 75 
 76 private:
 77     FontTag m_tag;
 78     T m_value;
 79 };
 80 
 81 template &lt;typename T&gt;
 82 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(const FontTag&amp; tag, T value)
 83     : m_tag(tag)
 84     , m_value(value)
 85 {
 86 }
 87 
 88 template &lt;typename T&gt;
 89 FontTaggedSetting&lt;T&gt;::FontTaggedSetting(FontTag&amp;&amp; tag, T value)
 90     : m_tag(WTFMove(tag))
 91     , m_value(value)
 92 {
 93 }
 94 
 95 template &lt;typename T&gt;
 96 bool FontTaggedSetting&lt;T&gt;::operator==(const FontTaggedSetting&lt;T&gt;&amp; other) const
 97 {
 98     return m_tag == other.m_tag &amp;&amp; m_value == other.m_value;
 99 }
100 
101 template &lt;typename T&gt;
102 bool FontTaggedSetting&lt;T&gt;::operator&lt;(const FontTaggedSetting&lt;T&gt;&amp; other) const
103 {
104     return (m_tag &lt; other.m_tag) || (m_tag == other.m_tag &amp;&amp; m_value &lt; other.m_value);
105 }
106 
107 template &lt;typename T&gt;
108 template &lt;class Encoder&gt;
109 void FontTaggedSetting&lt;T&gt;::encode(Encoder&amp; encoder) const
110 {
111     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[0]);
112     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[1]);
113     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[2]);
114     encoder &lt;&lt; static_cast&lt;uint8_t&gt;(m_tag[3]);
115     encoder &lt;&lt; m_value;
116 }
117 
118 template &lt;typename T&gt;
119 template &lt;class Decoder&gt;
120 Optional&lt;FontTaggedSetting&lt;T&gt;&gt; FontTaggedSetting&lt;T&gt;::decode(Decoder&amp; decoder)
121 {
122     Optional&lt;uint8_t&gt; char0;
123     decoder &gt;&gt; char0;
124     if (!char0)
125         return WTF::nullopt;
126 
127     Optional&lt;uint8_t&gt; char1;
128     decoder &gt;&gt; char1;
129     if (!char1)
130         return WTF::nullopt;
131 
132     Optional&lt;uint8_t&gt; char2;
133     decoder &gt;&gt; char2;
134     if (!char2)
135         return WTF::nullopt;
136 
137     Optional&lt;uint8_t&gt; char3;
138     decoder &gt;&gt; char3;
139     if (!char3)
140         return WTF::nullopt;
141 
142     Optional&lt;T&gt; value;
143     decoder &gt;&gt; value;
144     if (!value)
145         return WTF::nullopt;
146 
147     return FontTaggedSetting&lt;T&gt;({{
148         static_cast&lt;char&gt;(*char0),
149         static_cast&lt;char&gt;(*char1),
150         static_cast&lt;char&gt;(*char2),
151         static_cast&lt;char&gt;(*char3)
152     }}, *value);
153 }
154 
155 template &lt;typename T&gt;
156 class FontTaggedSettings {
157 public:
158     void insert(FontTaggedSetting&lt;T&gt;&amp;&amp;);
159     bool operator==(const FontTaggedSettings&lt;T&gt;&amp; other) const { return m_list == other.m_list; }
160     bool operator!=(const FontTaggedSettings&lt;T&gt;&amp; other) const { return !(*this == other); }
161 
162     bool isEmpty() const { return !size(); }
163     size_t size() const { return m_list.size(); }
164     const FontTaggedSetting&lt;T&gt;&amp; operator[](int index) const { return m_list[index]; }
165     const FontTaggedSetting&lt;T&gt;&amp; at(size_t index) const { return m_list.at(index); }
166 
167     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator begin() const { return m_list.begin(); }
168     typename Vector&lt;FontTaggedSetting&lt;T&gt;&gt;::const_iterator end() const { return m_list.end(); }
169 
170     unsigned hash() const;
171 
172     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
173     template&lt;class Decoder&gt; static Optional&lt;FontTaggedSettings&lt;T&gt;&gt; decode(Decoder&amp;);
174 
175 private:
176     Vector&lt;FontTaggedSetting&lt;T&gt;&gt; m_list;
177 };
178 
179 template &lt;typename T&gt;
180 void FontTaggedSettings&lt;T&gt;::insert(FontTaggedSetting&lt;T&gt;&amp;&amp; feature)
181 {
182     // This vector will almost always have 0 or 1 items in it. Don&#39;t bother with the overhead of a binary search or a hash set.
183     size_t i;
184     for (i = 0; i &lt; m_list.size(); ++i) {
185         if (!(feature &lt; m_list[i]))
186             break;
187     }
188     if (i &lt; m_list.size() &amp;&amp; feature.tag() == m_list[i].tag())
189         m_list.remove(i);
190     m_list.insert(i, WTFMove(feature));
191 }
192 
193 template &lt;typename T&gt;
194 template &lt;class Encoder&gt;
195 void FontTaggedSettings&lt;T&gt;::encode(Encoder&amp; encoder) const
196 {
197     encoder &lt;&lt; m_list;
198 }
199 
200 template &lt;typename T&gt;
201 template &lt;class Decoder&gt;
202 Optional&lt;FontTaggedSettings&lt;T&gt;&gt; FontTaggedSettings&lt;T&gt;::decode(Decoder&amp; decoder)
203 {
204     Optional&lt;Vector&lt;FontTaggedSetting&lt;T&gt;&gt;&gt; list;
205     decoder &gt;&gt; list;
206     if (!list)
207         return WTF::nullopt;
208 
209     FontTaggedSettings result;
210     result.m_list = WTFMove(*list);
211     return result;
212 }
213 
214 typedef FontTaggedSetting&lt;int&gt; FontFeature;
215 typedef FontTaggedSettings&lt;int&gt; FontFeatureSettings;
216 
217 template &lt;&gt; unsigned FontFeatureSettings::hash() const;
218 
219 #if ENABLE(VARIATION_FONTS)
220 
221 typedef FontTaggedSettings&lt;float&gt; FontVariationSettings;
222 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const FontVariationSettings&amp;);
223 
224 template &lt;&gt; unsigned FontVariationSettings::hash() const;
225 
226 #else
227 
228 struct FontVariationSettings {
229     bool isEmpty() const { return true; }
230 };
231 
232 #endif
233 
234 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/preprocess-idls.pl</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #!/usr/bin/env perl
  2 #
  3 # Copyright (C) 2011 Google Inc.  All rights reserved.
  4 #
  5 # This library is free software; you can redistribute it and/or
  6 # modify it under the terms of the GNU Library General Public
  7 # License as published by the Free Software Foundation; either
  8 # version 2 of the License, or (at your option) any later version.
  9 #
 10 # This library is distributed in the hope that it will be useful,
 11 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 12 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13 # Library General Public License for more details.
 14 #
 15 # You should have received a copy of the GNU Library General Public License
 16 # along with this library; see the file COPYING.LIB.  If not, write to
 17 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18 # Boston, MA 02110-1301, USA.
 19 #
 20 
 21 use strict;
 22 use warnings;
 23 use FindBin;
 24 use lib $FindBin::Bin;
 25 
 26 use File::Basename;
 27 use Getopt::Long;
 28 use Cwd;
 29 use Config;
 30 
 31 my $defines;
 32 my $preprocessor;
 33 my $idlFilesList;
 34 my $testGlobalContextName;
 35 my $supplementalDependencyFile;
 36 my $windowConstructorsFile;
 37 my $workerGlobalScopeConstructorsFile;
 38 my $dedicatedWorkerGlobalScopeConstructorsFile;
 39 my $serviceWorkerGlobalScopeConstructorsFile;
 40 my $workletGlobalScopeConstructorsFile;
 41 my $paintWorkletGlobalScopeConstructorsFile;
 42 my $testGlobalScopeConstructorsFile;
 43 my $supplementalMakefileDeps;
 44 
 45 GetOptions(&#39;defines=s&#39; =&gt; \$defines,
 46            &#39;preprocessor=s&#39; =&gt; \$preprocessor,
 47            &#39;idlFilesList=s&#39; =&gt; \$idlFilesList,
 48            &#39;testGlobalContextName=s&#39; =&gt; \$testGlobalContextName,
 49            &#39;supplementalDependencyFile=s&#39; =&gt; \$supplementalDependencyFile,
 50            &#39;windowConstructorsFile=s&#39; =&gt; \$windowConstructorsFile,
 51            &#39;workerGlobalScopeConstructorsFile=s&#39; =&gt; \$workerGlobalScopeConstructorsFile,
 52            &#39;dedicatedWorkerGlobalScopeConstructorsFile=s&#39; =&gt; \$dedicatedWorkerGlobalScopeConstructorsFile,
 53            &#39;serviceWorkerGlobalScopeConstructorsFile=s&#39; =&gt; \$serviceWorkerGlobalScopeConstructorsFile,
 54            &#39;workletGlobalScopeConstructorsFile=s&#39; =&gt; \$workletGlobalScopeConstructorsFile,
 55            &#39;paintWorkletGlobalScopeConstructorsFile=s&#39; =&gt; \$paintWorkletGlobalScopeConstructorsFile,
 56            &#39;testGlobalScopeConstructorsFile=s&#39; =&gt; \$testGlobalScopeConstructorsFile,
 57            &#39;supplementalMakefileDeps=s&#39; =&gt; \$supplementalMakefileDeps);
 58 
 59 die(&#39;Must specify #define macros using --defines.&#39;) unless defined($defines);
 60 die(&#39;Must specify an output file using --supplementalDependencyFile.&#39;) unless defined($supplementalDependencyFile);
 61 die(&#39;Must specify an output file using --windowConstructorsFile.&#39;) unless defined($windowConstructorsFile);
 62 die(&#39;Must specify an output file using --workerGlobalScopeConstructorsFile.&#39;) unless defined($workerGlobalScopeConstructorsFile);
 63 die(&#39;Must specify an output file using --dedicatedWorkerGlobalScopeConstructorsFile.&#39;) unless defined($dedicatedWorkerGlobalScopeConstructorsFile);
 64 die(&#39;Must specify an output file using --serviceWorkerGlobalScopeConstructorsFile.&#39;) unless defined($serviceWorkerGlobalScopeConstructorsFile);
 65 die(&#39;Must specify an output file using --workletGlobalScopeConstructorsFile.&#39;) unless defined($workletGlobalScopeConstructorsFile);
 66 die(&#39;Must specify an output file using --paintWorkletGlobalScopeConstructorsFile.&#39;) unless defined($paintWorkletGlobalScopeConstructorsFile);
 67 die(&#39;Must specify an output file using --testGlobalScopeConstructorsFile.&#39;) unless defined($testGlobalScopeConstructorsFile) || !defined($testGlobalContextName);
 68 die(&#39;Must specify the file listing all IDLs using --idlFilesList.&#39;) unless defined($idlFilesList);
 69 
 70 $supplementalDependencyFile = CygwinPathIfNeeded($supplementalDependencyFile);
 71 $windowConstructorsFile = CygwinPathIfNeeded($windowConstructorsFile);
 72 $workerGlobalScopeConstructorsFile = CygwinPathIfNeeded($workerGlobalScopeConstructorsFile);
 73 $dedicatedWorkerGlobalScopeConstructorsFile = CygwinPathIfNeeded($dedicatedWorkerGlobalScopeConstructorsFile);
 74 $serviceWorkerGlobalScopeConstructorsFile = CygwinPathIfNeeded($serviceWorkerGlobalScopeConstructorsFile);
 75 $workletGlobalScopeConstructorsFile = CygwinPathIfNeeded($workletGlobalScopeConstructorsFile);
 76 $paintWorkletGlobalScopeConstructorsFile = CygwinPathIfNeeded($paintWorkletGlobalScopeConstructorsFile);
<a name="1" id="anc1"></a><span class="line-modified"> 77 $supplementalMakefileDeps = CygwinPathIfNeeded($supplementalMakefileDeps) if defined($supplementalMakefileDeps);</span>
 78 
<a name="2" id="anc2"></a><span class="line-modified"> 79 my @idlFiles;</span>
<span class="line-modified"> 80 open(my $fh, &#39;&lt;&#39;, $idlFilesList) or die &quot;Cannot open $idlFilesList&quot;;</span>
<span class="line-modified"> 81 @idlFiles = map { CygwinPathIfNeeded(s/\r?\n?$//r) } &lt;$fh&gt;;</span>
<span class="line-modified"> 82 close($fh) or die;</span>




 83 
 84 my %interfaceNameToIdlFile;
 85 my %idlFileToInterfaceName;
 86 my %supplementalDependencies;
 87 my %supplementals;
 88 my $windowConstructorsCode = &quot;&quot;;
 89 my $workerGlobalScopeConstructorsCode = &quot;&quot;;
 90 my $dedicatedWorkerGlobalScopeConstructorsCode = &quot;&quot;;
 91 my $serviceWorkerGlobalScopeConstructorsCode = &quot;&quot;;
 92 my $workletGlobalScopeConstructorsCode = &quot;&quot;;
 93 my $paintWorkletGlobalScopeConstructorsCode = &quot;&quot;;
 94 my $testGlobalScopeConstructorsCode = &quot;&quot;;
 95 
 96 # Get rid of duplicates in idlFiles array.
 97 my %idlFileHash = map { $_, 1 } @idlFiles;
 98 
 99 # Populate $idlFileToInterfaceName and $interfaceNameToIdlFile.
100 foreach my $idlFile (sort keys %idlFileHash) {
<a name="3" id="anc3"></a><span class="line-added">101     $idlFile =~ s/\s*$//g;</span>
102     my $fullPath = Cwd::realpath($idlFile);
103     my $interfaceName = fileparse(basename($idlFile), &quot;.idl&quot;);
104     $idlFileToInterfaceName{$fullPath} = $interfaceName;
105     $interfaceNameToIdlFile{$interfaceName} = $fullPath;
106 }
107 
108 # Parse all IDL files.
109 foreach my $idlFile (sort keys %idlFileHash) {
<a name="4" id="anc4"></a><span class="line-added">110     $idlFile =~ s/\s*$//g;</span>
111     my $fullPath = Cwd::realpath($idlFile);
112     my $idlFileContents = getFileContents($fullPath);
113     # Handle partial names.
114     my $partialNames = getPartialNamesFromIDL($idlFileContents);
115     if (@{$partialNames}) {
116         $supplementalDependencies{$fullPath} = $partialNames;
117         next;
118     }
119 
120     $supplementals{$fullPath} = [];
121 
122     # Skip if the IDL file does not contain an interface, a callback interface or an exception.
123     # The IDL may contain a dictionary.
124     next unless containsInterfaceOrExceptionFromIDL($idlFileContents);
125 
126     my $interfaceName = fileparse(basename($idlFile), &quot;.idl&quot;);
127     # Handle implements statements.
128     my $implementedInterfaces = getImplementedInterfacesFromIDL($idlFileContents, $interfaceName);
129     foreach my $implementedInterface (@{$implementedInterfaces}) {
130         my $implementedIdlFile = $interfaceNameToIdlFile{$implementedInterface};
131         die &quot;Could not find a the IDL file where the following implemented interface is defined: $implementedInterface&quot; unless $implementedIdlFile;
132         if ($supplementalDependencies{$implementedIdlFile}) {
133             push(@{$supplementalDependencies{$implementedIdlFile}}, $interfaceName);
134         } else {
135             $supplementalDependencies{$implementedIdlFile} = [$interfaceName];
136         }
137     }
138 
139     # For every interface that is exposed in a given ECMAScript global environment and:
140     # - is a callback interface that has constants declared on it, or
141     # - is a non-callback interface that is not declared with the [NoInterfaceObject] extended attribute, a corresponding
142     #   property must exist on the ECMAScript environment&#39;s global object.
143     # See https://heycam.github.io/webidl/#es-interfaces
144     my $extendedAttributes = getInterfaceExtendedAttributesFromIDL($idlFileContents);
145     if (shouldExposeInterface($extendedAttributes)) {
146         if (!isCallbackInterfaceFromIDL($idlFileContents) || interfaceHasConstantAttribute($idlFileContents)) {
147             my $exposedAttribute = $extendedAttributes-&gt;{&quot;Exposed&quot;} || $testGlobalContextName || &quot;Window&quot;;
148             $exposedAttribute = substr($exposedAttribute, 1, -1) if substr($exposedAttribute, 0, 1) eq &quot;(&quot;;
149             my @globalContexts = split(&quot;,&quot;, $exposedAttribute);
150             my ($attributeCode, $windowAliases) = GenerateConstructorAttributes($interfaceName, $extendedAttributes);
151             foreach my $globalContext (@globalContexts) {
152                 if ($globalContext eq &quot;Window&quot;) {
153                     $windowConstructorsCode .= $attributeCode;
154                 } elsif ($globalContext eq &quot;Worker&quot;) {
155                     $workerGlobalScopeConstructorsCode .= $attributeCode;
156                 } elsif ($globalContext eq &quot;DedicatedWorker&quot;) {
157                     $dedicatedWorkerGlobalScopeConstructorsCode .= $attributeCode;
158                 } elsif ($globalContext eq &quot;ServiceWorker&quot;) {
159                     $serviceWorkerGlobalScopeConstructorsCode .= $attributeCode;
160                 } elsif ($globalContext eq &quot;Worklet&quot;) {
161                     $workletGlobalScopeConstructorsCode .= $attributeCode;
162                 } elsif ($globalContext eq &quot;PaintWorklet&quot;) {
163                     $paintWorkletGlobalScopeConstructorsCode .= $attributeCode;
164                 } elsif ($globalContext eq $testGlobalContextName) {
165                     $testGlobalScopeConstructorsCode .= $attributeCode;
166                 } else {
167                     die &quot;Unsupported global context &#39;$globalContext&#39; used in [Exposed] at $idlFile&quot;;
168                 }
169             }
170             $windowConstructorsCode .= $windowAliases if $windowAliases;
171         }
172     }
173 }
174 
175 # Generate partial interfaces for Constructors.
176 GeneratePartialInterface(&quot;DOMWindow&quot;, $windowConstructorsCode, $windowConstructorsFile);
177 GeneratePartialInterface(&quot;WorkerGlobalScope&quot;, $workerGlobalScopeConstructorsCode, $workerGlobalScopeConstructorsFile);
178 GeneratePartialInterface(&quot;DedicatedWorkerGlobalScope&quot;, $dedicatedWorkerGlobalScopeConstructorsCode, $dedicatedWorkerGlobalScopeConstructorsFile);
179 GeneratePartialInterface(&quot;ServiceWorkerGlobalScope&quot;, $serviceWorkerGlobalScopeConstructorsCode, $serviceWorkerGlobalScopeConstructorsFile);
180 GeneratePartialInterface(&quot;WorkletGlobalScope&quot;, $workletGlobalScopeConstructorsCode, $workletGlobalScopeConstructorsFile);
181 GeneratePartialInterface(&quot;PaintWorkletGlobalScope&quot;, $paintWorkletGlobalScopeConstructorsCode, $paintWorkletGlobalScopeConstructorsFile);
182 GeneratePartialInterface($testGlobalContextName, $testGlobalScopeConstructorsCode, $testGlobalScopeConstructorsFile) if defined($testGlobalContextName);
183 
184 # Resolves partial interfaces and implements dependencies.
185 foreach my $idlFile (sort keys %supplementalDependencies) {
186     my $baseFiles = $supplementalDependencies{$idlFile};
187     foreach my $baseFile (@{$baseFiles}) {
188         my $targetIdlFile = $interfaceNameToIdlFile{$baseFile} or die &quot;${baseFile}.idl not found, but it is supplemented by $idlFile&quot;;
189         push(@{$supplementals{$targetIdlFile}}, $idlFile);
190     }
191     delete $supplementals{$idlFile};
192 }
193 
194 # Outputs the dependency.
195 # The format of a supplemental dependency file:
196 #
197 # DOMWindow.idl P.idl Q.idl R.idl
198 # Document.idl S.idl
199 # Event.idl
200 # ...
201 #
202 # The above indicates that DOMWindow.idl is supplemented by P.idl, Q.idl and R.idl,
203 # Document.idl is supplemented by S.idl, and Event.idl is supplemented by no IDLs.
204 # The IDL that supplements another IDL (e.g. P.idl) never appears in the dependency file.
205 my $dependencies = &quot;&quot;;
206 foreach my $idlFile (sort keys %supplementals) {
207     $dependencies .= &quot;$idlFile @{$supplementals{$idlFile}}\n&quot;;
208 }
209 WriteFileIfChanged($supplementalDependencyFile, $dependencies);
210 
211 if ($supplementalMakefileDeps) {
212     my $makefileDeps = &quot;&quot;;
213     foreach my $idlFile (sort keys %supplementals) {
214         my $basename = $idlFileToInterfaceName{$idlFile};
215 
216         my @dependencies = map { basename($_) } @{$supplementals{$idlFile}};
217 
218         $makefileDeps .= &quot;JS${basename}.h: @{dependencies}\n&quot;;
219         $makefileDeps .= &quot;DOM${basename}.h: @{dependencies}\n&quot;;
220         $makefileDeps .= &quot;WebDOM${basename}.h: @{dependencies}\n&quot;;
221         foreach my $dependency (@dependencies) {
222             $makefileDeps .= &quot;${dependency}:\n&quot;;
223         }
224     }
225 
226     WriteFileIfChanged($supplementalMakefileDeps, $makefileDeps);
227 }
228 
<a name="5" id="anc5"></a>
229 sub CygwinPathIfNeeded
230 {
231     my $path = shift;
<a name="6" id="anc6"></a><span class="line-modified">232     return Cygwin::win_to_posix_path($path) if ($^O eq &#39;cygwin&#39;);</span>







233     return $path;
234 }
235 
236 sub WriteFileIfChanged
237 {
238     my $fileName = shift;
239     my $contents = shift;
240 
241     if (-f $fileName) {
242         open FH, &quot;&lt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
243         my @lines = &lt;FH&gt;;
244         my $oldContents = join &quot;&quot;, @lines;
245         close FH;
246         return if $contents eq $oldContents;
247     }
248     open FH, &quot;&gt;&quot;, $fileName or die &quot;Couldn&#39;t open $fileName: $!\n&quot;;
249     print FH $contents;
250     close FH;
251 }
252 
253 sub GeneratePartialInterface
254 {
255     my $interfaceName = shift;
256     my $attributesCode = shift;
257     my $destinationFile = shift;
258 
259     my $contents = &quot;partial interface ${interfaceName} {\n$attributesCode};\n&quot;;
260     WriteFileIfChanged($destinationFile, $contents);
261 
262     my $fullPath = Cwd::realpath($destinationFile);
263     $supplementalDependencies{$fullPath} = [$interfaceName] if $interfaceNameToIdlFile{$interfaceName};
264 }
265 
266 sub GenerateConstructorAttributes
267 {
268     my $interfaceName = shift;
269     my $extendedAttributes = shift;
270 
271     my $code = &quot;    &quot;;
272     my @extendedAttributesList;
273     foreach my $attributeName (sort keys %{$extendedAttributes}) {
274       next unless ($attributeName eq &quot;Conditional&quot; || $attributeName eq &quot;EnabledAtRuntime&quot; || $attributeName eq &quot;EnabledForWorld&quot;
275         || $attributeName eq &quot;EnabledBySetting&quot; || $attributeName eq &quot;SecureContext&quot; || $attributeName eq &quot;PrivateIdentifier&quot;
<a name="7" id="anc7"></a><span class="line-modified">276         || $attributeName eq &quot;PublicIdentifier&quot; || $attributeName eq &quot;DisabledByQuirk&quot; || $attributeName eq &quot;EnabledByQuirk&quot;</span>
<span class="line-added">277         || $attributeName eq &quot;EnabledForContext&quot; || $attributeName eq &quot;CustomEnabled&quot;) || $attributeName eq &quot;ConstructorEnabledBySetting&quot;;</span>
278       my $extendedAttribute = $attributeName;
279       $extendedAttribute .= &quot;=&quot; . $extendedAttributes-&gt;{$attributeName} unless $extendedAttributes-&gt;{$attributeName} eq &quot;VALUE_IS_MISSING&quot;;
280       push(@extendedAttributesList, $extendedAttribute);
281     }
282     $code .= &quot;[&quot; . join(&#39;, &#39;, @extendedAttributesList) . &quot;] &quot; if @extendedAttributesList;
283 
284     my $originalInterfaceName = $interfaceName;
285     $interfaceName = $extendedAttributes-&gt;{&quot;InterfaceName&quot;} if $extendedAttributes-&gt;{&quot;InterfaceName&quot;};
286     $code .= &quot;attribute &quot; . $originalInterfaceName . &quot;Constructor $interfaceName;\n&quot;;
287 
288     # In addition to the regular property, for every [NamedConstructor] extended attribute on an interface,
289     # a corresponding property MUST exist on the ECMAScript global object.
290     if ($extendedAttributes-&gt;{&quot;NamedConstructor&quot;}) {
291         my $constructorName = $extendedAttributes-&gt;{&quot;NamedConstructor&quot;};
292         $constructorName =~ s/\(.*//g; # Extract function name.
293         $code .= &quot;    &quot;;
294         $code .= &quot;[&quot; . join(&#39;, &#39;, @extendedAttributesList) . &quot;] &quot; if @extendedAttributesList;
295         $code .= &quot;attribute &quot; . $originalInterfaceName . &quot;NamedConstructor $constructorName;\n&quot;;
296     }
297     
298     my $windowAliasesCode;
299     if ($extendedAttributes-&gt;{&quot;LegacyWindowAlias&quot;}) {
300         my $attributeValue = $extendedAttributes-&gt;{&quot;LegacyWindowAlias&quot;};
301         $attributeValue = substr($attributeValue, 1, -1) if substr($attributeValue, 0, 1) eq &quot;(&quot;;
302         my @windowAliases = split(&quot;,&quot;, $attributeValue);
303         foreach my $windowAlias (@windowAliases) {
304             $windowAliasesCode .= &quot;    &quot;;
305             $windowAliasesCode .= &quot;[&quot; . join(&#39;, &#39;, @extendedAttributesList) . &quot;] &quot; if @extendedAttributesList;
306             $windowAliasesCode .= &quot;attribute &quot; . $originalInterfaceName . &quot;Constructor $windowAlias; // Legacy Window alias.\n&quot;;
307         }
308     }
309     
310     return ($code, $windowAliasesCode);
311 }
312 
313 sub getFileContents
314 {
315     my $idlFile = shift;
316 
317     open FILE, &quot;&lt;&quot;, $idlFile;
318     my @lines = &lt;FILE&gt;;
319     close FILE;
320 
321     # Filter out preprocessor lines.
322     @lines = grep(!/^\s*#/, @lines);
323 
324     return join(&#39;&#39;, @lines);
325 }
326 
327 sub getPartialNamesFromIDL
328 {
329     my $fileContents = shift;
330     my @partialNames = ();
331     while ($fileContents =~ /partial\s+(interface|dictionary)\s+(\w+)/mg) {
332         push(@partialNames, $2);
333     }
334     return \@partialNames;
335 }
336 
337 # identifier-A implements identifier-B;
338 # http://www.w3.org/TR/WebIDL/#idl-implements-statements
339 sub getImplementedInterfacesFromIDL
340 {
341     my $fileContents = shift;
342     my $interfaceName = shift;
343 
344     my @implementedInterfaces = ();
345     while ($fileContents =~ /^\s*(\w+)\s+implements\s+(\w+)\s*;/mg) {
346         die &quot;Identifier on the left of the &#39;implements&#39; statement should be $interfaceName in $interfaceName.idl, but found $1&quot; if $1 ne $interfaceName;
347         push(@implementedInterfaces, $2);
348     }
349     return \@implementedInterfaces
350 }
351 
352 sub isCallbackInterfaceFromIDL
353 {
354     my $fileContents = shift;
355     return ($fileContents =~ /callback\s+interface\s+\w+/gs);
356 }
357 
358 sub containsInterfaceOrExceptionFromIDL
359 {
360     my $fileContents = shift;
361 
362     return 1 if $fileContents =~ /\bcallback\s+interface\s+\w+/gs;
363     return 1 if $fileContents =~ /\binterface\s+\w+/gs;
364     return 1 if $fileContents =~ /\bexception\s+\w+/gs;
365     return 0;
366 }
367 
368 sub trim
369 {
370     my $string = shift;
371     $string =~ s/^\s+|\s+$//g;
372     return $string;
373 }
374 
375 sub getInterfaceExtendedAttributesFromIDL
376 {
377     my $fileContents = shift;
378 
379     my $extendedAttributes = {};
380 
381     # Remove comments from fileContents before processing.
382     # FIX: Preference to use Regex::Common::comment, however it is not available on
383     # all build systems.
384     $fileContents =~ s/(?:(?:(?:\/\/)(?:[^\n]*)(?:\n))|(?:(?:\/\*)(?:(?:[^\*]+|\*(?!\/))*)(?:\*\/)))//g;
385 
386     if ($fileContents =~ /\[(.*)\]\s+(callback interface|interface|exception)\s+(\w+)/gs) {
387         my @parts = split(m/,(?![^()]*\))/, $1);
388         foreach my $part (@parts) {
389             my @keyValue = split(&#39;=&#39;, $part);
390             my $key = trim($keyValue[0]);
391             next unless length($key);
392             my $value = &quot;VALUE_IS_MISSING&quot;;
393             $value = trim($keyValue[1]) if @keyValue &gt; 1;
394             $extendedAttributes-&gt;{$key} = $value;
395         }
396     }
397 
398     return $extendedAttributes;
399 }
400 
401 sub interfaceHasConstantAttribute
402 {
403     my $fileContents = shift;
404 
405     return $fileContents =~ /\s+const[\s\w]+=\s+[\w]+;/gs;
406 }
407 
408 sub shouldExposeInterface
409 {
410     my $extendedAttributes = shift;
411 
412     return !$extendedAttributes-&gt;{&quot;NoInterfaceObject&quot;};
413 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
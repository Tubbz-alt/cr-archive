diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediacapabilities/MediaCapabilities.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediacapabilities/MediaCapabilities.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediacapabilities/MediaCapabilities.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediacapabilities/MediaCapabilities.cpp
@@ -26,19 +26,23 @@
 #include "config.h"
 #include "MediaCapabilities.h"
 
 #include "ContentType.h"
 #include "Document.h"
+#include "JSDOMPromiseDeferred.h"
 #include "JSMediaCapabilitiesDecodingInfo.h"
 #include "JSMediaCapabilitiesEncodingInfo.h"
+#include "Logging.h"
 #include "MediaCapabilitiesDecodingInfo.h"
 #include "MediaCapabilitiesEncodingInfo.h"
+#include "MediaCapabilitiesLogging.h"
 #include "MediaDecodingConfiguration.h"
 #include "MediaEncodingConfiguration.h"
 #include "MediaEngineConfigurationFactory.h"
 #include "Settings.h"
 #include <wtf/HashSet.h>
+#include <wtf/Logger.h>
 
 namespace WebCore {
 
 static const HashSet<String>& bucketMIMETypes()
 {
@@ -164,28 +168,34 @@
 void MediaCapabilities::decodingInfo(Document& document, MediaDecodingConfiguration&& configuration, Ref<DeferredPromise>&& promise)
 {
     // 2.4 Media Capabilities Interface
     // https://wicg.github.io/media-capabilities/#media-capabilities-interface
 
+    auto identifier = WTF::Logger::LogSiteIdentifier("MediaCapabilities", __func__, this);
+    Ref<Logger> logger = document.logger();
+
     // 1. If configuration is not a valid MediaConfiguration, return a Promise rejected with a TypeError.
     // 2. If configuration.video is present and is not a valid video configuration, return a Promise rejected with a TypeError.
     // 3. If configuration.audio is present and is not a valid audio configuration, return a Promise rejected with a TypeError.
     if (!isValidMediaConfiguration(configuration)) {
+#if !RELEASE_LOG_DISABLED
+        logger->info(LogMedia, identifier, " - Rejected. configuration: ", configuration);
+#endif
         promise->reject(TypeError);
         return;
     }
 
     if (!document.settings().mediaCapabilitiesExtensionsEnabled() && configuration.video)
         configuration.video.value().alphaChannel.reset();
 
     // 4. Let p be a new promise.
     // 5. In parallel, run the create a MediaCapabilitiesInfo algorithm with configuration and resolve p with its result.
     // 6. Return p.
-    m_taskQueue.enqueueTask([configuration = WTFMove(configuration), promise = WTFMove(promise)] () mutable {
+    m_taskQueue.enqueueTask([configuration = WTFMove(configuration), promise = WTFMove(promise), logger = WTFMove(logger), identifier = WTFMove(identifier)] () mutable {
 
         // 2.2.3 If configuration is of type MediaDecodingConfiguration, run the following substeps:
-        MediaEngineConfigurationFactory::DecodingConfigurationCallback callback = [promise = WTFMove(promise)] (auto info) mutable {
+        MediaEngineConfigurationFactory::DecodingConfigurationCallback callback = [promise = WTFMove(promise), logger = WTFMove(logger), identifier = WTFMove(identifier)] (auto info) mutable {
             // 2.2.3.1. If the user agent is able to decode the media represented by
             // configuration, set supported to true. Otherwise set it to false.
             // 2.2.3.2. If the user agent is able to decode the media represented by
             // configuration at a pace that allows a smooth playback, set smooth to
             // true. Otherwise set it to false.
@@ -193,10 +203,13 @@
             // configuration in a power efficient manner, set powerEfficient to
             // true. Otherwise set it to false. The user agent SHOULD NOT take into
             // consideration the current power source in order to determine the
             // decoding power efficiency unless the deviceâ€™s power source has side
             // effects such as enabling different decoding modules.
+#if !RELEASE_LOG_DISABLED
+            logger->info(LogMedia, identifier, "::callback() - Resolved. info: ", info);
+#endif
             promise->resolve<IDLDictionary<MediaCapabilitiesDecodingInfo>>(WTFMove(info));
         };
 
         MediaEngineConfigurationFactory::createDecodingConfiguration(WTFMove(configuration), WTFMove(callback));
     });

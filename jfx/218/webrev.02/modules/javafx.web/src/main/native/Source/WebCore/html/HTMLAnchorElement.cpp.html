<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLAnchorElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Simon Hausmann &lt;hausmann@kde.org&gt;
  5  * Copyright (C) 2003-2016 Apple Inc. All rights reserved.
  6  *           (C) 2006 Graham Dennis (graham.dennis@gmail.com)
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;HTMLAnchorElement.h&quot;
 26 
 27 #include &quot;AdClickAttribution.h&quot;
 28 #include &quot;DOMTokenList.h&quot;
 29 #include &quot;ElementIterator.h&quot;
 30 #include &quot;EventHandler.h&quot;
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Frame.h&quot;
 33 #include &quot;FrameLoader.h&quot;
 34 #include &quot;FrameLoaderClient.h&quot;
 35 #include &quot;FrameLoaderTypes.h&quot;
 36 #include &quot;FrameSelection.h&quot;
 37 #include &quot;HTMLCanvasElement.h&quot;
 38 #include &quot;HTMLImageElement.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;HTMLPictureElement.h&quot;
 41 #include &quot;KeyboardEvent.h&quot;
 42 #include &quot;MouseEvent.h&quot;
 43 #include &quot;PingLoader.h&quot;
 44 #include &quot;PlatformMouseEvent.h&quot;
 45 #include &quot;RegistrableDomain.h&quot;
 46 #include &quot;RenderImage.h&quot;
 47 #include &quot;ResourceRequest.h&quot;
 48 #include &quot;RuntimeEnabledFeatures.h&quot;
 49 #include &quot;SVGImage.h&quot;
 50 #include &quot;ScriptController.h&quot;
 51 #include &quot;SecurityOrigin.h&quot;
 52 #include &quot;SecurityPolicy.h&quot;
 53 #include &quot;Settings.h&quot;
 54 #include &quot;URLUtils.h&quot;
 55 #include &quot;UserGestureIndicator.h&quot;
 56 #include &lt;wtf/IsoMallocInlines.h&gt;
 57 #include &lt;wtf/Optional.h&gt;
 58 #include &lt;wtf/text/StringBuilder.h&gt;
 59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 60 
 61 namespace WebCore {
 62 
 63 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLAnchorElement);
 64 
 65 using namespace HTMLNames;
 66 
 67 HTMLAnchorElement::HTMLAnchorElement(const QualifiedName&amp; tagName, Document&amp; document)
 68     : HTMLElement(tagName, document)
 69     , m_hasRootEditableElementForSelectionOnMouseDown(false)
 70     , m_wasShiftKeyDownOnMouseDown(false)
 71 {
 72 }
 73 
 74 Ref&lt;HTMLAnchorElement&gt; HTMLAnchorElement::create(Document&amp; document)
 75 {
 76     return adoptRef(*new HTMLAnchorElement(aTag, document));
 77 }
 78 
 79 Ref&lt;HTMLAnchorElement&gt; HTMLAnchorElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 80 {
 81     return adoptRef(*new HTMLAnchorElement(tagName, document));
 82 }
 83 
 84 HTMLAnchorElement::~HTMLAnchorElement()
 85 {
 86     clearRootEditableElementForSelectionOnMouseDown();
 87 }
 88 
 89 bool HTMLAnchorElement::supportsFocus() const
 90 {
 91     if (hasEditableStyle())
 92         return HTMLElement::supportsFocus();
 93     // If not a link we should still be able to focus the element if it has tabIndex.
 94     return isLink() || HTMLElement::supportsFocus();
 95 }
 96 
 97 bool HTMLAnchorElement::isMouseFocusable() const
 98 {
 99     // Only allow links with tabIndex or contentEditable to be mouse focusable.
100     if (isLink())
101         return HTMLElement::supportsFocus();
102 
103     return HTMLElement::isMouseFocusable();
104 }
105 
106 bool HTMLAnchorElement::isInteractiveContent() const
107 {
108     return isLink();
109 }
110 
111 static bool hasNonEmptyBox(RenderBoxModelObject* renderer)
112 {
113     if (!renderer)
114         return false;
115 
116     // Before calling absoluteRects, check for the common case where borderBoundingBox
117     // is non-empty, since this is a faster check and almost always returns true.
118     // FIXME: Why do we need to call absoluteRects at all?
119     if (!renderer-&gt;borderBoundingBox().isEmpty())
120         return true;
121 
122     // FIXME: Since all we are checking is whether the rects are empty, could we just
123     // pass in 0,0 for the layout point instead of calling localToAbsolute?
124     Vector&lt;IntRect&gt; rects;
125     renderer-&gt;absoluteRects(rects, flooredLayoutPoint(renderer-&gt;localToAbsolute()));
126     for (auto&amp; rect : rects) {
127         if (!rect.isEmpty())
128             return true;
129     }
130 
131     return false;
132 }
133 
134 bool HTMLAnchorElement::isKeyboardFocusable(KeyboardEvent* event) const
135 {
136     if (!isLink())
137         return HTMLElement::isKeyboardFocusable(event);
138 
139     if (!isFocusable())
140         return false;
141 
142     if (!document().frame())
143         return false;
144 
145     if (!document().frame()-&gt;eventHandler().tabsToLinks(event))
146         return false;
147 
148     if (!renderer() &amp;&amp; ancestorsOfType&lt;HTMLCanvasElement&gt;(*this).first())
149         return true;
150 
151     return hasNonEmptyBox(renderBoxModelObject());
152 }
153 
154 static void appendServerMapMousePosition(StringBuilder&amp; url, Event&amp; event)
155 {
156     if (!is&lt;MouseEvent&gt;(event))
157         return;
158     auto&amp; mouseEvent = downcast&lt;MouseEvent&gt;(event);
159 
160     if (!is&lt;HTMLImageElement&gt;(mouseEvent.target()))
161         return;
162 
163     auto&amp; imageElement = downcast&lt;HTMLImageElement&gt;(*mouseEvent.target());
164     if (!imageElement.isServerMap())
165         return;
166 
167     auto* renderer = imageElement.renderer();
168     if (!is&lt;RenderImage&gt;(renderer))
169         return;
170 
171     // FIXME: This should probably pass UseTransforms in the MapCoordinatesFlags.
172     auto absolutePosition = downcast&lt;RenderImage&gt;(*renderer).absoluteToLocal(FloatPoint(mouseEvent.pageX(), mouseEvent.pageY()));
173     url.append(&#39;?&#39;);
174     url.appendNumber(std::lround(absolutePosition.x()));
175     url.append(&#39;,&#39;);
176     url.appendNumber(std::lround(absolutePosition.y()));
177 }
178 
179 void HTMLAnchorElement::defaultEventHandler(Event&amp; event)
180 {
181     if (isLink()) {
182         if (focused() &amp;&amp; isEnterKeyKeydownEvent(event) &amp;&amp; treatLinkAsLiveForEventType(NonMouseEvent)) {
183             event.setDefaultHandled();
184             dispatchSimulatedClick(&amp;event);
185             return;
186         }
187 
188         if (MouseEvent::canTriggerActivationBehavior(event) &amp;&amp; treatLinkAsLiveForEventType(eventType(event))) {
189             handleClick(event);
190             return;
191         }
192 
193         if (hasEditableStyle()) {
194             // This keeps track of the editable block that the selection was in (if it was in one) just before the link was clicked
195             // for the LiveWhenNotFocused editable link behavior
196             if (event.type() == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() != RightButton &amp;&amp; document().frame()) {
197                 setRootEditableElementForSelectionOnMouseDown(document().frame()-&gt;selection().selection().rootEditableElement());
198                 m_wasShiftKeyDownOnMouseDown = downcast&lt;MouseEvent&gt;(event).shiftKey();
199             } else if (event.type() == eventNames().mouseoverEvent) {
200                 // These are cleared on mouseover and not mouseout because their values are needed for drag events,
201                 // but drag events happen after mouse out events.
202                 clearRootEditableElementForSelectionOnMouseDown();
203                 m_wasShiftKeyDownOnMouseDown = false;
204             }
205         }
206     }
207 
208     HTMLElement::defaultEventHandler(event);
209 }
210 
211 void HTMLAnchorElement::setActive(bool down, bool pause)
212 {
213     if (hasEditableStyle()) {
214         EditableLinkBehavior editableLinkBehavior = document().settings().editableLinkBehavior();
215 
216         switch (editableLinkBehavior) {
217             default:
218             case EditableLinkDefaultBehavior:
219             case EditableLinkAlwaysLive:
220                 break;
221 
222             case EditableLinkNeverLive:
223                 return;
224 
225             // Don&#39;t set the link to be active if the current selection is in the same editable block as
226             // this link
227             case EditableLinkLiveWhenNotFocused:
228                 if (down &amp;&amp; document().frame() &amp;&amp; document().frame()-&gt;selection().selection().rootEditableElement() == rootEditableElement())
229                     return;
230                 break;
231 
232             case EditableLinkOnlyLiveWithShiftKey:
233                 return;
234         }
235 
236     }
237 
238     HTMLElement::setActive(down, pause);
239 }
240 
241 void HTMLAnchorElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
242 {
243     if (name == hrefAttr) {
244         bool wasLink = isLink();
245         setIsLink(!value.isNull() &amp;&amp; !shouldProhibitLinks(this));
246         if (wasLink != isLink())
247             invalidateStyleForSubtree();
248         if (isLink()) {
249             String parsedURL = stripLeadingAndTrailingHTMLSpaces(value);
250             if (document().isDNSPrefetchEnabled() &amp;&amp; document().frame()) {
251                 if (protocolIsInHTTPFamily(parsedURL) || parsedURL.startsWith(&quot;//&quot;))
252                     document().frame()-&gt;loader().client().prefetchDNS(document().completeURL(parsedURL).host().toString());
253             }
254         }
255     } else if (name == nameAttr || name == titleAttr) {
256         // Do nothing.
257     } else if (name == relAttr) {
258         // Update HTMLAnchorElement::relList() if more rel attributes values are supported.
259         static NeverDestroyed&lt;AtomString&gt; noReferrer(&quot;noreferrer&quot;, AtomString::ConstructFromLiteral);
260         static NeverDestroyed&lt;AtomString&gt; noOpener(&quot;noopener&quot;, AtomString::ConstructFromLiteral);
261         static NeverDestroyed&lt;AtomString&gt; opener(&quot;opener&quot;, AtomString::ConstructFromLiteral);
262         const bool shouldFoldCase = true;
263         SpaceSplitString relValue(value, shouldFoldCase);
264         if (relValue.contains(noReferrer))
265             m_linkRelations.add(Relation::NoReferrer);
266         if (relValue.contains(noOpener))
267             m_linkRelations.add(Relation::NoOpener);
268         if (relValue.contains(opener))
269             m_linkRelations.add(Relation::Opener);
270         if (m_relList)
271             m_relList-&gt;associatedAttributeValueChanged(value);
272     }
273     else
274         HTMLElement::parseAttribute(name, value);
275 }
276 
277 void HTMLAnchorElement::accessKeyAction(bool sendMouseEvents)
278 {
279     dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
280 }
281 
282 bool HTMLAnchorElement::isURLAttribute(const Attribute&amp; attribute) const
283 {
284     return attribute.name().localName() == hrefAttr || HTMLElement::isURLAttribute(attribute);
285 }
286 
287 bool HTMLAnchorElement::canStartSelection() const
288 {
289     if (!isLink())
290         return HTMLElement::canStartSelection();
291     return hasEditableStyle();
292 }
293 
294 bool HTMLAnchorElement::draggable() const
295 {
296     const AtomString&amp; value = attributeWithoutSynchronization(draggableAttr);
297     if (equalLettersIgnoringASCIICase(value, &quot;true&quot;))
298         return true;
299     if (equalLettersIgnoringASCIICase(value, &quot;false&quot;))
300         return false;
301     return hasAttributeWithoutSynchronization(hrefAttr);
302 }
303 
304 URL HTMLAnchorElement::href() const
305 {
306     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(attributeWithoutSynchronization(hrefAttr)));
307 }
308 
309 void HTMLAnchorElement::setHref(const AtomString&amp; value)
310 {
311     setAttributeWithoutSynchronization(hrefAttr, value);
312 }
313 
314 bool HTMLAnchorElement::hasRel(Relation relation) const
315 {
316     return m_linkRelations.contains(relation);
317 }
318 
319 DOMTokenList&amp; HTMLAnchorElement::relList() const
320 {
321     if (!m_relList) {
322         m_relList = makeUnique&lt;DOMTokenList&gt;(const_cast&lt;HTMLAnchorElement&amp;&gt;(*this), HTMLNames::relAttr, [](Document&amp;, StringView token) {
323 #if USE(SYSTEM_PREVIEW)
324             return equalIgnoringASCIICase(token, &quot;noreferrer&quot;) || equalIgnoringASCIICase(token, &quot;noopener&quot;) || equalIgnoringASCIICase(token, &quot;ar&quot;);
325 #else
326             return equalIgnoringASCIICase(token, &quot;noreferrer&quot;) || equalIgnoringASCIICase(token, &quot;noopener&quot;);
327 #endif
328         });
329     }
330     return *m_relList;
331 }
332 
333 const AtomString&amp; HTMLAnchorElement::name() const
334 {
335     return getNameAttribute();
336 }
337 
338 int HTMLAnchorElement::defaultTabIndex() const
339 {
340     return 0;
341 }
342 
343 String HTMLAnchorElement::target() const
344 {
345     return attributeWithoutSynchronization(targetAttr);
346 }
347 
348 String HTMLAnchorElement::origin() const
349 {
350     return SecurityOrigin::create(href()).get().toString();
351 }
352 
353 String HTMLAnchorElement::text()
354 {
355     return textContent();
356 }
357 
358 void HTMLAnchorElement::setText(const String&amp; text)
359 {
360     setTextContent(text);
361 }
362 
363 bool HTMLAnchorElement::isLiveLink() const
364 {
365     return isLink() &amp;&amp; treatLinkAsLiveForEventType(m_wasShiftKeyDownOnMouseDown ? MouseEventWithShiftKey : MouseEventWithoutShiftKey);
366 }
367 
368 void HTMLAnchorElement::sendPings(const URL&amp; destinationURL)
369 {
370     if (!document().frame())
371         return;
372 
373     if (!hasAttributeWithoutSynchronization(pingAttr) || !document().settings().hyperlinkAuditingEnabled())
374         return;
375 
376     SpaceSplitString pingURLs(attributeWithoutSynchronization(pingAttr), false);
377     for (unsigned i = 0; i &lt; pingURLs.size(); i++)
378         PingLoader::sendPing(*document().frame(), document().completeURL(pingURLs[i]), destinationURL);
379 }
380 
381 #if USE(SYSTEM_PREVIEW)
382 bool HTMLAnchorElement::isSystemPreviewLink() const
383 {
384     if (!RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
385         return false;
386 
387     static NeverDestroyed&lt;AtomString&gt; systemPreviewRelValue(&quot;ar&quot;, AtomString::ConstructFromLiteral);
388 
389     if (!relList().contains(systemPreviewRelValue))
390         return false;
391 
392     if (auto* child = firstElementChild()) {
393         if (is&lt;HTMLImageElement&gt;(child) || is&lt;HTMLPictureElement&gt;(child)) {
394             auto numChildren = childElementCount();
395             // FIXME: We&#39;ve documented that it should be the only child, but some early demos have two children.
396             return numChildren == 1 || numChildren == 2;
397         }
398     }
399 
400     return false;
401 }
402 #endif
403 
404 Optional&lt;AdClickAttribution&gt; HTMLAnchorElement::parseAdClickAttribution() const
405 {
406     using Campaign = AdClickAttribution::Campaign;
407     using Source = AdClickAttribution::Source;
408     using Destination = AdClickAttribution::Destination;
409 
410     auto* page = document().page();
411     if (!page || page-&gt;sessionID().isEphemeral()
412         || !RuntimeEnabledFeatures::sharedFeatures().adClickAttributionEnabled()
413         || !UserGestureIndicator::processingUserGesture())
414         return WTF::nullopt;
415 
416     if (!hasAttributeWithoutSynchronization(adcampaignidAttr) &amp;&amp; !hasAttributeWithoutSynchronization(addestinationAttr))
417         return WTF::nullopt;
418 
419     auto adCampaignIDAttr = attributeWithoutSynchronization(adcampaignidAttr);
420     auto adDestinationAttr = attributeWithoutSynchronization(addestinationAttr);
421 
422     if (adCampaignIDAttr.isEmpty() || adDestinationAttr.isEmpty()) {
423         document().addConsoleMessage(MessageSource::Other, MessageLevel::Warning, &quot;Both adcampaignid and addestination need to be set for Ad Click Attribution to work.&quot;_s);
424         return WTF::nullopt;
425     }
426 
427     RefPtr&lt;Frame&gt; frame = document().frame();
428     if (!frame || !frame-&gt;isMainFrame()) {
429         document().addConsoleMessage(MessageSource::Other, MessageLevel::Warning, &quot;Ad Click Attribution is only supported in the main frame.&quot;_s);
430         return WTF::nullopt;
431     }
432 
433     auto adCampaignID = parseHTMLNonNegativeInteger(adCampaignIDAttr);
434     if (!adCampaignID) {
435         document().addConsoleMessage(MessageSource::Other, MessageLevel::Warning, &quot;adcampaignid can not be converted to a non-negative integer which is required for Ad Click Attribution.&quot;_s);
436         return WTF::nullopt;
437     }
438 
439     if (adCampaignID.value() &gt; AdClickAttribution::MaxEntropy) {
440         document().addConsoleMessage(MessageSource::Other, MessageLevel::Warning, makeString(&quot;adcampaignid must have a non-negative value less than or equal to &quot;, AdClickAttribution::MaxEntropy, &quot; for Ad Click Attribution.&quot;));
441         return WTF::nullopt;
442     }
443 
444     URL adDestinationURL { URL(), adDestinationAttr };
445     if (!adDestinationURL.isValid() || !adDestinationURL.protocolIsInHTTPFamily()) {
446         document().addConsoleMessage(MessageSource::Other, MessageLevel::Warning, &quot;addestination could not be converted to a valid HTTP-family URL.&quot;_s);
447         return WTF::nullopt;
448     }
449 
450     RegistrableDomain documentRegistrableDomain { document().url() };
451     if (documentRegistrableDomain.matches(adDestinationURL)) {
452         document().addConsoleMessage(MessageSource::Other, MessageLevel::Warning, &quot;addestination can not be the same site as the current website.&quot;_s);
453         return WTF::nullopt;
454     }
455 
456     return AdClickAttribution { Campaign(adCampaignID.value()), Source(documentRegistrableDomain), Destination(adDestinationURL) };
457 }
458 
459 void HTMLAnchorElement::handleClick(Event&amp; event)
460 {
461     event.setDefaultHandled();
462 
463     RefPtr&lt;Frame&gt; frame = document().frame();
464     if (!frame)
465         return;
466 
467     StringBuilder url;
468     url.append(stripLeadingAndTrailingHTMLSpaces(attributeWithoutSynchronization(hrefAttr)));
469     appendServerMapMousePosition(url, event);
470     URL completedURL = document().completeURL(url.toString());
471 
472     String downloadAttribute;
473 #if ENABLE(DOWNLOAD_ATTRIBUTE)
474     if (RuntimeEnabledFeatures::sharedFeatures().downloadAttributeEnabled()) {
475         // Ignore the download attribute completely if the href URL is cross origin.
476         bool isSameOrigin = completedURL.protocolIsData() || document().securityOrigin().canRequest(completedURL);
477         if (isSameOrigin)
478             downloadAttribute = ResourceResponse::sanitizeSuggestedFilename(attributeWithoutSynchronization(downloadAttr));
479         else if (hasAttributeWithoutSynchronization(downloadAttr))
480             document().addConsoleMessage(MessageSource::Security, MessageLevel::Warning, &quot;The download attribute on anchor was ignored because its href URL has a different security origin.&quot;);
481     }
482 #endif
483 
484     SystemPreviewInfo systemPreviewInfo;
485 #if USE(SYSTEM_PREVIEW)
486     systemPreviewInfo.isPreview = isSystemPreviewLink() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled();
487 
488     if (systemPreviewInfo.isPreview) {
489         systemPreviewInfo.element.elementIdentifier = document().identifierForElement(*this);
490         systemPreviewInfo.element.documentIdentifier = document().identifier();
491         systemPreviewInfo.element.webPageIdentifier = document().frame()-&gt;loader().client().pageID().valueOr(PageIdentifier { });
492         if (auto* child = firstElementChild())
493             systemPreviewInfo.previewRect = child-&gt;boundsInRootViewSpace();
494     }
495 #endif
496 
497     ShouldSendReferrer shouldSendReferrer = hasRel(Relation::NoReferrer) ? NeverSendReferrer : MaybeSendReferrer;
498 
499     auto effectiveTarget = this-&gt;effectiveTarget();
500     Optional&lt;NewFrameOpenerPolicy&gt; newFrameOpenerPolicy;
501     if (hasRel(Relation::Opener))
502         newFrameOpenerPolicy = NewFrameOpenerPolicy::Allow;
503     else if (hasRel(Relation::NoOpener) || (RuntimeEnabledFeatures::sharedFeatures().blankAnchorTargetImpliesNoOpenerEnabled() &amp;&amp; equalIgnoringASCIICase(effectiveTarget, &quot;_blank&quot;)))
504         newFrameOpenerPolicy = NewFrameOpenerPolicy::Suppress;
505 
506     auto adClickAttribution = parseAdClickAttribution();
507     // A matching conversion event needs to happen before the complete ad click attributionURL can be
508     // created. Thus, it should be empty for now.
509     ASSERT(!adClickAttribution || adClickAttribution-&gt;url().isNull());
510 
511     frame-&gt;loader().urlSelected(completedURL, effectiveTarget, &amp;event, LockHistory::No, LockBackForwardList::No, shouldSendReferrer, document().shouldOpenExternalURLsPolicyToPropagate(), newFrameOpenerPolicy, downloadAttribute, systemPreviewInfo, WTFMove(adClickAttribution));
512 
513     sendPings(completedURL);
514 }
515 
516 // Falls back to using &lt;base&gt; element&#39;s target if the anchor does not have one.
517 String HTMLAnchorElement::effectiveTarget() const
518 {
519     auto effectiveTarget = target();
520     if (effectiveTarget.isEmpty())
521         effectiveTarget = document().baseTarget();
522     return effectiveTarget;
523 }
524 
525 HTMLAnchorElement::EventType HTMLAnchorElement::eventType(Event&amp; event)
526 {
527     if (!is&lt;MouseEvent&gt;(event))
528         return NonMouseEvent;
529     return downcast&lt;MouseEvent&gt;(event).shiftKey() ? MouseEventWithShiftKey : MouseEventWithoutShiftKey;
530 }
531 
532 bool HTMLAnchorElement::treatLinkAsLiveForEventType(EventType eventType) const
533 {
534     if (!hasEditableStyle())
535         return true;
536 
537     switch (document().settings().editableLinkBehavior()) {
538     case EditableLinkDefaultBehavior:
539     case EditableLinkAlwaysLive:
540         return true;
541 
542     case EditableLinkNeverLive:
543         return false;
544 
545     // If the selection prior to clicking on this link resided in the same editable block as this link,
546     // and the shift key isn&#39;t pressed, we don&#39;t want to follow the link.
547     case EditableLinkLiveWhenNotFocused:
548         return eventType == MouseEventWithShiftKey || (eventType == MouseEventWithoutShiftKey &amp;&amp; rootEditableElementForSelectionOnMouseDown() != rootEditableElement());
549 
550     case EditableLinkOnlyLiveWithShiftKey:
551         return eventType == MouseEventWithShiftKey;
552     }
553 
554     ASSERT_NOT_REACHED();
555     return false;
556 }
557 
558 bool isEnterKeyKeydownEvent(Event&amp; event)
559 {
560     return event.type() == eventNames().keydownEvent &amp;&amp; is&lt;KeyboardEvent&gt;(event) &amp;&amp; downcast&lt;KeyboardEvent&gt;(event).keyIdentifier() == &quot;Enter&quot;;
561 }
562 
563 bool shouldProhibitLinks(Element* element)
564 {
565     return isInSVGImage(element);
566 }
567 
568 bool HTMLAnchorElement::willRespondToMouseClickEvents()
569 {
570     return isLink() || HTMLElement::willRespondToMouseClickEvents();
571 }
572 
573 typedef HashMap&lt;const HTMLAnchorElement*, RefPtr&lt;Element&gt;&gt; RootEditableElementMap;
574 
575 static RootEditableElementMap&amp; rootEditableElementMap()
576 {
577     static NeverDestroyed&lt;RootEditableElementMap&gt; map;
578     return map;
579 }
580 
581 Element* HTMLAnchorElement::rootEditableElementForSelectionOnMouseDown() const
582 {
583     if (!m_hasRootEditableElementForSelectionOnMouseDown)
584         return 0;
585     return rootEditableElementMap().get(this);
586 }
587 
588 void HTMLAnchorElement::clearRootEditableElementForSelectionOnMouseDown()
589 {
590     if (!m_hasRootEditableElementForSelectionOnMouseDown)
591         return;
592     rootEditableElementMap().remove(this);
593     m_hasRootEditableElementForSelectionOnMouseDown = false;
594 }
595 
596 void HTMLAnchorElement::setRootEditableElementForSelectionOnMouseDown(Element* element)
597 {
598     if (!element) {
599         clearRootEditableElementForSelectionOnMouseDown();
600         return;
601     }
602 
603     rootEditableElementMap().set(this, element);
604     m_hasRootEditableElementForSelectionOnMouseDown = true;
605 }
606 
607 }
    </pre>
  </body>
</html>
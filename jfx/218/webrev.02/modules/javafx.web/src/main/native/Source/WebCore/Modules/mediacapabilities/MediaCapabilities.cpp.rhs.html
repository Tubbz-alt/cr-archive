<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediacapabilities/MediaCapabilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MediaCapabilities.h&quot;
 28 
 29 #include &quot;ContentType.h&quot;
 30 #include &quot;Document.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 32 #include &quot;JSMediaCapabilitiesDecodingInfo.h&quot;
 33 #include &quot;JSMediaCapabilitiesEncodingInfo.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 34 #include &quot;Logging.h&quot;</span>
 35 #include &quot;MediaCapabilitiesDecodingInfo.h&quot;
 36 #include &quot;MediaCapabilitiesEncodingInfo.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 37 #include &quot;MediaCapabilitiesLogging.h&quot;</span>
 38 #include &quot;MediaDecodingConfiguration.h&quot;
 39 #include &quot;MediaEncodingConfiguration.h&quot;
 40 #include &quot;MediaEngineConfigurationFactory.h&quot;
 41 #include &quot;Settings.h&quot;
 42 #include &lt;wtf/HashSet.h&gt;
<a name="4" id="anc4"></a><span class="line-added"> 43 #include &lt;wtf/Logger.h&gt;</span>
 44 
 45 namespace WebCore {
 46 
 47 static const HashSet&lt;String&gt;&amp; bucketMIMETypes()
 48 {
 49     // A &quot;bucket&quot; MIME types is one whose container type does not uniquely specify a codec.
 50     // See: https://tools.ietf.org/html/rfc6381
 51     static NeverDestroyed&lt;HashSet&lt;String&gt;&gt; bucketMIMETypes = HashSet&lt;String&gt;({
 52         &quot;audio/3gpp&quot;,
 53         &quot;video/3gpp&quot;,
 54         &quot;audio/3gpp2&quot;,
 55         &quot;video/3gpp2&quot;,
 56         &quot;audio/mp4&quot;,
 57         &quot;video/mp4&quot;,
 58         &quot;application/mp4&quot;,
 59         &quot;video/quicktime&quot;,
 60         &quot;application/mp21&quot;,
 61         &quot;audio/vnd.apple.mpegurl&quot;,
 62         &quot;video/vnd.apple.mpegurl&quot;,
 63         &quot;audio/ogg&quot;,
 64         &quot;video/ogg&quot;,
 65         &quot;video/webm&quot;,
 66         &quot;audio/webm&quot;,
 67     });
 68     return bucketMIMETypes;
 69 }
 70 
 71 static bool isValidMediaMIMEType(const ContentType&amp; contentType)
 72 {
 73     // 2.1.4. MIME types
 74     // https://wicg.github.io/media-capabilities/#valid-media-mime-type
 75     // A valid media MIME type is a string that is a valid MIME type per [mimesniff]. If the MIME type does
 76     // not imply a codec, the string MUST also have one and only one parameter that is named codecs with a
 77     // value describing a single media codec. Otherwise, it MUST contain no parameters.
 78     if (contentType.isEmpty())
 79         return false;
 80 
 81     auto codecs = contentType.codecs();
 82 
 83     // FIXME: The spec requires that the &quot;codecs&quot; parameter is the only parameter present.
 84     if (bucketMIMETypes().contains(contentType.containerType()))
 85         return codecs.size() == 1;
 86     return !codecs.size();
 87 }
 88 
 89 static bool isValidVideoMIMEType(const ContentType&amp; contentType)
 90 {
 91     // 2.1.4 MIME Types
 92     // https://wicg.github.io/media-capabilities/#valid-video-mime-type
 93     // A valid video MIME type is a string that is a valid media MIME type and for which the type per [RFC7231]
 94     // is either video or application.
 95     if (!isValidMediaMIMEType(contentType))
 96         return false;
 97 
 98     auto containerType = contentType.containerType();
 99     if (!startsWithLettersIgnoringASCIICase(containerType, &quot;video/&quot;) &amp;&amp; !startsWithLettersIgnoringASCIICase(containerType, &quot;application/&quot;))
100         return false;
101 
102     return true;
103 }
104 
105 static bool isValidAudioMIMEType(const ContentType&amp; contentType)
106 {
107     // 2.1.4 MIME Types
108     // https://wicg.github.io/media-capabilities/#valid-audio-mime-type
109     // A valid audio MIME type is a string that is a valid media MIME type and for which the type per [RFC7231]
110     // is either audio or application.
111     if (!isValidMediaMIMEType(contentType))
112         return false;
113 
114     auto containerType = contentType.containerType();
115     if (!startsWithLettersIgnoringASCIICase(containerType, &quot;audio/&quot;) &amp;&amp; !startsWithLettersIgnoringASCIICase(containerType, &quot;application/&quot;))
116         return false;
117 
118     return true;
119 }
120 
121 static bool isValidVideoConfiguration(const VideoConfiguration&amp; configuration)
122 {
123     // 2.1.5. VideoConfiguration
124     // https://wicg.github.io/media-capabilities/#valid-video-configuration
125     // 1. If configuration’s contentType is not a valid video MIME type, return false and abort these steps.
126     if (!isValidVideoMIMEType(ContentType(configuration.contentType)))
127         return false;
128 
129     // 2. If none of the following is true, return false and abort these steps:
130     //   o. Applying the rules for parsing floating-point number values to configuration’s framerate
131     //      results in a number that is finite and greater than 0.
132     if (!std::isfinite(configuration.framerate) || configuration.framerate &lt;= 0)
133         return false;
134 
135     // 3. Return true.
136     return true;
137 }
138 
139 static bool isValidAudioConfiguration(const AudioConfiguration&amp; configuration)
140 {
141     // 2.1.6. AudioConfiguration
142     // https://wicg.github.io/media-capabilities/#audioconfiguration
143     // 1. If configuration’s contentType is not a valid audio MIME type, return false and abort these steps.
144     if (!isValidAudioMIMEType(ContentType(configuration.contentType)))
145         return false;
146 
147     // 2. Return true.
148     return true;
149 }
150 
151 static bool isValidMediaConfiguration(const MediaConfiguration&amp; configuration)
152 {
153     // 2.1.1. MediaConfiguration
154     // https://wicg.github.io/media-capabilities/#mediaconfiguration
155     // For a MediaConfiguration to be a valid MediaConfiguration, audio or video MUST be present.
156     if (!configuration.video &amp;&amp; !configuration.audio)
157         return false;
158 
159     if (configuration.video &amp;&amp; !isValidVideoConfiguration(configuration.video.value()))
160         return false;
161 
162     if (configuration.audio &amp;&amp; !isValidAudioConfiguration(configuration.audio.value()))
163         return false;
164 
165     return true;
166 }
167 
168 void MediaCapabilities::decodingInfo(Document&amp; document, MediaDecodingConfiguration&amp;&amp; configuration, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
169 {
170     // 2.4 Media Capabilities Interface
171     // https://wicg.github.io/media-capabilities/#media-capabilities-interface
172 
<a name="5" id="anc5"></a><span class="line-added">173     auto identifier = WTF::Logger::LogSiteIdentifier(&quot;MediaCapabilities&quot;, __func__, this);</span>
<span class="line-added">174     Ref&lt;Logger&gt; logger = document.logger();</span>
<span class="line-added">175 </span>
176     // 1. If configuration is not a valid MediaConfiguration, return a Promise rejected with a TypeError.
177     // 2. If configuration.video is present and is not a valid video configuration, return a Promise rejected with a TypeError.
178     // 3. If configuration.audio is present and is not a valid audio configuration, return a Promise rejected with a TypeError.
179     if (!isValidMediaConfiguration(configuration)) {
<a name="6" id="anc6"></a><span class="line-added">180 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">181         logger-&gt;info(LogMedia, identifier, &quot; - Rejected. configuration: &quot;, configuration);</span>
<span class="line-added">182 #endif</span>
183         promise-&gt;reject(TypeError);
184         return;
185     }
186 
187     if (!document.settings().mediaCapabilitiesExtensionsEnabled() &amp;&amp; configuration.video)
188         configuration.video.value().alphaChannel.reset();
189 
190     // 4. Let p be a new promise.
191     // 5. In parallel, run the create a MediaCapabilitiesInfo algorithm with configuration and resolve p with its result.
192     // 6. Return p.
<a name="7" id="anc7"></a><span class="line-modified">193     m_taskQueue.enqueueTask([configuration = WTFMove(configuration), promise = WTFMove(promise), logger = WTFMove(logger), identifier = WTFMove(identifier)] () mutable {</span>
194 
195         // 2.2.3 If configuration is of type MediaDecodingConfiguration, run the following substeps:
<a name="8" id="anc8"></a><span class="line-modified">196         MediaEngineConfigurationFactory::DecodingConfigurationCallback callback = [promise = WTFMove(promise), logger = WTFMove(logger), identifier = WTFMove(identifier)] (auto info) mutable {</span>
197             // 2.2.3.1. If the user agent is able to decode the media represented by
198             // configuration, set supported to true. Otherwise set it to false.
199             // 2.2.3.2. If the user agent is able to decode the media represented by
200             // configuration at a pace that allows a smooth playback, set smooth to
201             // true. Otherwise set it to false.
202             // 2.2.3.3. If the user agent is able to decode the media represented by
203             // configuration in a power efficient manner, set powerEfficient to
204             // true. Otherwise set it to false. The user agent SHOULD NOT take into
205             // consideration the current power source in order to determine the
206             // decoding power efficiency unless the device’s power source has side
207             // effects such as enabling different decoding modules.
<a name="9" id="anc9"></a><span class="line-added">208 #if !RELEASE_LOG_DISABLED</span>
<span class="line-added">209             logger-&gt;info(LogMedia, identifier, &quot;::callback() - Resolved. info: &quot;, info);</span>
<span class="line-added">210 #endif</span>
211             promise-&gt;resolve&lt;IDLDictionary&lt;MediaCapabilitiesDecodingInfo&gt;&gt;(WTFMove(info));
212         };
213 
214         MediaEngineConfigurationFactory::createDecodingConfiguration(WTFMove(configuration), WTFMove(callback));
215     });
216 }
217 
218 void MediaCapabilities::encodingInfo(MediaEncodingConfiguration&amp;&amp; configuration, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
219 {
220     // 2.4 Media Capabilities Interface
221     // https://wicg.github.io/media-capabilities/#media-capabilities-interface
222 
223     // 1. If configuration is not a valid MediaConfiguration, return a Promise rejected with a TypeError.
224     // 2. If configuration.video is present and is not a valid video configuration, return a Promise rejected with a TypeError.
225     // 3. If configuration.audio is present and is not a valid audio configuration, return a Promise rejected with a TypeError.
226     if (!isValidMediaConfiguration(configuration)) {
227         promise-&gt;reject(TypeError);
228         return;
229     }
230 
231     // 4. Let p be a new promise.
232     // 5. In parallel, run the create a MediaCapabilitiesInfo algorithm with configuration and resolve p with its result.
233     // 6. Return p.
234     m_taskQueue.enqueueTask([configuration = WTFMove(configuration), promise = WTFMove(promise)] () mutable {
235 
236         // 2.2.4. If configuration is of type MediaEncodingConfiguration, run the following substeps:
237         MediaEngineConfigurationFactory::EncodingConfigurationCallback callback = [promise = WTFMove(promise)] (auto info) mutable {
238             // 2.2.4.1. If the user agent is able to encode the media
239             // represented by configuration, set supported to true. Otherwise
240             // set it to false.
241             // 2.2.4.2. If the user agent is able to encode the media
242             // represented by configuration at a pace that allows encoding
243             // frames at the same pace as they are sent to the encoder, set
244             // smooth to true. Otherwise set it to false.
245             // 2.2.4.3. If the user agent is able to encode the media
246             // represented by configuration in a power efficient manner, set
247             // powerEfficient to true. Otherwise set it to false. The user agent
248             // SHOULD NOT take into consideration the current power source in
249             // order to determine the encoding power efficiency unless the
250             // device’s power source has side effects such as enabling different
251             // encoding modules.
252             promise-&gt;resolve&lt;IDLDictionary&lt;MediaCapabilitiesEncodingInfo&gt;&gt;(WTFMove(info));
253         };
254 
255         MediaEngineConfigurationFactory::createEncodingConfiguration(WTFMove(configuration), WTFMove(callback));
256 
257     });
258 }
259 
260 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
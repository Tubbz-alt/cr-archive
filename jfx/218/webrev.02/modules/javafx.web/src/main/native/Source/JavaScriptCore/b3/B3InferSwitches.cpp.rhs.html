<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3InferSwitches.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;B3InferSwitches.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;B3BasicBlockInlines.h&quot;
 32 #include &quot;B3CaseCollectionInlines.h&quot;
 33 #include &quot;B3InsertionSetInlines.h&quot;
 34 #include &quot;B3PhaseScope.h&quot;
 35 #include &quot;B3ProcedureInlines.h&quot;
 36 #include &quot;B3SwitchValue.h&quot;
 37 #include &quot;B3UseCounts.h&quot;
 38 #include &quot;B3ValueInlines.h&quot;
 39 #include &lt;wtf/ListDump.h&gt;
 40 
 41 namespace JSC { namespace B3 {
 42 
 43 namespace {
 44 
 45 namespace B3InferSwitchesInternal {
<a name="2" id="anc2"></a><span class="line-modified"> 46 static constexpr bool verbose = false;</span>
 47 }
 48 
 49 class InferSwitches {
 50 public:
 51     InferSwitches(Procedure&amp; proc)
 52         : m_proc(proc)
 53         , m_insertionSet(proc)
 54         , m_useCounts(proc)
 55     {
 56     }
 57 
 58     bool run()
 59     {
 60         if (B3InferSwitchesInternal::verbose)
 61             dataLog(&quot;B3 before inferSwitches:\n&quot;, m_proc);
 62 
 63         bool changed = true;
 64         bool everChanged = false;
 65         while (changed) {
 66             changed = false;
 67 
 68             if (B3InferSwitchesInternal::verbose)
 69                 dataLog(&quot;Performing fixpoint iteration:\n&quot;);
 70 
 71             for (BasicBlock* block : m_proc)
 72                 changed |= attemptToMergeWithPredecessor(block);
 73 
 74             everChanged |= changed;
 75         }
 76 
 77         if (everChanged) {
 78             m_proc.resetReachability();
 79             m_proc.invalidateCFG();
 80 
 81             m_proc.deleteOrphans();
 82 
 83             if (B3InferSwitchesInternal::verbose)
 84                 dataLog(&quot;B3 after inferSwitches:\n&quot;, m_proc);
 85             return true;
 86         }
 87 
 88         return false;
 89     }
 90 
 91 private:
 92     bool attemptToMergeWithPredecessor(BasicBlock* block)
 93     {
 94         // No point in considering the root block. We also don&#39;t consider blocks with multiple
 95         // predecessors, but we could handle this if we made this code a bit more general and we were
 96         // not afraid of code bloat.
 97         if (block-&gt;numPredecessors() != 1)
 98             return false;
 99 
100         SwitchDescription description = describe(block);
101         if (B3InferSwitchesInternal::verbose)
102             dataLog(&quot;Description of primary block &quot;, *block, &quot;: &quot;, description, &quot;\n&quot;);
103         if (!description) {
104             if (B3InferSwitchesInternal::verbose)
105                 dataLog(&quot;    Bailing because not switch-like.\n&quot;);
106             return false;
107         }
108 
109         // We know that this block behaves like a switch. But we need to verify that it doesn&#39;t also
110         // perform any effects or do expensive things. We don&#39;t want to create a switch if that will
111         // make expensive things execute unconditionally. We&#39;re very conservative about how we define
112         // &quot;expensive&quot;.
113         for (Value* value : *block) {
114             if (value-&gt;isFree())
115                 continue;
116             if (value == description.extra)
117                 continue;
118             if (value == description.branch)
119                 continue;
120             if (B3InferSwitchesInternal::verbose)
121                 dataLog(&quot;    Bailing because of &quot;, deepDump(m_proc, value), &quot;\n&quot;);
122             return false;
123         }
124 
125         BasicBlock* predecessor = block-&gt;predecessor(0);
126         SwitchDescription predecessorDescription = describe(predecessor);
127         if (B3InferSwitchesInternal::verbose)
128             dataLog(&quot;    Description of predecessor block &quot;, *predecessor, &quot;: &quot;, predecessorDescription, &quot;\n&quot;);
129         if (!predecessorDescription) {
130             if (B3InferSwitchesInternal::verbose)
131                 dataLog(&quot;    Bailing because not switch-like.\n&quot;);
132             return false;
133         }
134 
135         // Both us and the predecessor are switch-like, but that doesn&#39;t mean that we&#39;re compatible.
136         // We may be switching on different values!
137         if (description.source != predecessorDescription.source) {
138             if (B3InferSwitchesInternal::verbose)
139                 dataLog(&quot;    Bailing because sources don&#39;t match.\n&quot;);
140             return false;
141         }
142 
143         // We expect that we are the fall-through destination of the predecessor. This is a bit of a
144         // goofy condition. If we were not the fall-through destination then our switch is probably
145         // just totally redundant and we should be getting rid of it. But we don&#39;t handle that here,
146         // yet.
147         if (predecessorDescription.fallThrough.block() != block) {
148             if (B3InferSwitchesInternal::verbose)
149                 dataLog(&quot;    Bailing because fall-through of predecessor is not the primary block.\n&quot;);
150             return false;
151         }
152 
153         // Make sure that there ain&#39;t no loops.
154         if (description.fallThrough.block() == block
155             || description.fallThrough.block() == predecessor) {
156             if (B3InferSwitchesInternal::verbose)
157                 dataLog(&quot;    Bailing because of fall-through loop.\n&quot;);
158             return false;
159         }
160         for (SwitchCase switchCase : description.cases) {
161             if (switchCase.targetBlock() == block
162                 || switchCase.targetBlock() == predecessor) {
163                 if (B3InferSwitchesInternal::verbose)
164                     dataLog(&quot;    Bailing because of loop in primary cases.\n&quot;);
165                 return false;
166             }
167         }
168         for (SwitchCase switchCase : predecessorDescription.cases) {
169             if (switchCase.targetBlock() == block
170                 || switchCase.targetBlock() == predecessor) {
171                 if (B3InferSwitchesInternal::verbose)
172                     dataLog(&quot;    Bailing because of loop in predecessor cases.\n&quot;);
173                 return false;
174             }
175         }
176 
177         if (B3InferSwitchesInternal::verbose)
178             dataLog(&quot;    Doing it!\n&quot;);
179         // We&#39;re committed to doing the thing.
180 
181         // Delete the extra value from the predecessor, since that would break downstream inference
182         // on the next fixpoint iteration. We would think that this block is too expensive to merge
183         // because of the Equal or NotEqual value even though that value is dead! We know it&#39;s dead
184         // so we kill it ourselves.
185         for (Value* value : *predecessor) {
186             if (value == predecessorDescription.extra)
187                 value-&gt;replaceWithNopIgnoringType();
188         }
189 
190         // Insert all non-terminal values from our block into our predecessor. We definitely need to
191         // do this for constants. We must not do it for the extra value, since that would break
192         // downstream inference on the next fixpoint iteration. As a bonus, we don&#39;t do it for nops,
193         // so that we limit how big blocks get in this phase.
194         for (unsigned i = 0; i &lt; block-&gt;size() - 1; ++i) {
195             Value* value = block-&gt;at(i);
196             if (value != description.extra &amp;&amp; value-&gt;opcode() != Nop)
197                 m_insertionSet.insertValue(predecessor-&gt;size() - 1, value);
198         }
199         m_insertionSet.execute(predecessor);
200         block-&gt;values().shrink(0);
201         block-&gt;appendNew&lt;Value&gt;(m_proc, Oops, description.branch-&gt;origin());
202         block-&gt;removePredecessor(predecessor);
203 
204         for (BasicBlock* successorBlock : description.block-&gt;successorBlocks())
205             successorBlock-&gt;replacePredecessor(block, predecessor);
206 
207         block-&gt;clearSuccessors();
208 
209         SwitchValue* switchValue = predecessor-&gt;replaceLastWithNew&lt;SwitchValue&gt;(
210             m_proc, predecessor-&gt;last()-&gt;origin(), description.source);
211         predecessor-&gt;clearSuccessors();
212         switchValue-&gt;setFallThrough(description.fallThrough);
213 
214         Vector&lt;int64_t&gt; predecessorCases;
215         for (SwitchCase switchCase : predecessorDescription.cases) {
216             switchValue-&gt;appendCase(switchCase);
217             predecessorCases.append(switchCase.caseValue());
218         }
219         std::sort(predecessorCases.begin(), predecessorCases.end());
220         auto isPredecessorCase = [&amp;] (int64_t value) -&gt; bool {
221             return !!tryBinarySearch&lt;int64_t&gt;(
222                 predecessorCases, predecessorCases.size(), value,
223                 [] (int64_t* element) -&gt; int64_t { return *element; });
224         };
225 
226         for (SwitchCase switchCase : description.cases) {
227             if (!isPredecessorCase(switchCase.caseValue()))
228                 switchValue-&gt;appendCase(switchCase);
229         }
230         return true;
231     }
232 
233     struct SwitchDescription {
234         SwitchDescription()
235         {
236         }
237 
238         explicit operator bool() { return !!block; }
239 
240         void dump(PrintStream&amp; out) const
241         {
242             out.print(
243                 &quot;{block = &quot;, pointerDump(block),
244                 &quot;, branch = &quot;, pointerDump(branch),
245                 &quot;, extra = &quot;, pointerDump(extra),
246                 &quot;, source = &quot;, pointerDump(source),
247                 &quot;, cases = &quot;, listDump(cases),
248                 &quot;, fallThrough = &quot;, fallThrough, &quot;}&quot;);
249         }
250 
251         BasicBlock* block { nullptr };
252         Value* branch { nullptr };
253         Value* extra { nullptr }; // This is the Equal or NotEqual value, if applicable.
254         Value* source { nullptr };
255         Vector&lt;SwitchCase, 1&gt; cases;
256         FrequentedBlock fallThrough;
257     };
258 
259     SwitchDescription describe(BasicBlock* block)
260     {
261         SwitchDescription result;
262         result.block = block;
263         result.branch = block-&gt;last();
264 
265         switch (result.branch-&gt;opcode()) {
266         case Branch: {
267             Value* predicate = result.branch-&gt;child(0);
268             FrequentedBlock taken = result.block-&gt;taken();
269             FrequentedBlock notTaken = result.block-&gt;notTaken();
270             bool handled = false;
271             // NOTE: This uses UseCounts that we computed before any transformation. This is fine
272             // because although we may have mutated the IR, we would not have added any new
273             // predicates.
274             if (predicate-&gt;numChildren() == 2
275                 &amp;&amp; predicate-&gt;child(1)-&gt;hasInt()
276                 &amp;&amp; m_useCounts.numUses(predicate) == 1) {
277                 switch (predicate-&gt;opcode()) {
278                 case Equal:
279                     result.source = predicate-&gt;child(0);
280                     result.extra = predicate;
281                     result.cases.append(SwitchCase(predicate-&gt;child(1)-&gt;asInt(), taken));
282                     result.fallThrough = notTaken;
283                     handled = true;
284                     break;
285                 case NotEqual:
286                     result.source = predicate-&gt;child(0);
287                     result.extra = predicate;
288                     result.cases.append(SwitchCase(predicate-&gt;child(1)-&gt;asInt(), notTaken));
289                     result.fallThrough = taken;
290                     handled = true;
291                     break;
292                 default:
293                     break;
294                 }
295             }
296             if (handled)
297                 break;
298             result.source = predicate;
299             result.cases.append(SwitchCase(0, notTaken));
300             result.fallThrough = taken;
301             break;
302         }
303 
304         case Switch: {
305             SwitchValue* switchValue = result.branch-&gt;as&lt;SwitchValue&gt;();
306             result.source = switchValue-&gt;child(0);
307             for (SwitchCase switchCase : switchValue-&gt;cases(result.block))
308                 result.cases.append(switchCase);
309             result.fallThrough = result.block-&gt;fallThrough();
310             break;
311         }
312 
313         default:
314             result.block = nullptr;
315             result.branch = nullptr;
316             break;
317         }
318 
319         return result;
320     }
321 
322     Procedure&amp; m_proc;
323     InsertionSet m_insertionSet;
324     UseCounts m_useCounts;
325 };
326 
327 } // anonymous namespace
328 
329 bool inferSwitches(Procedure&amp; proc)
330 {
331     PhaseScope phaseScope(proc, &quot;inferSwitches&quot;);
332     InferSwitches inferSwitches(proc);
333     return inferSwitches.run();
334 }
335 
336 } } // namespace JSC::B3
337 
338 #endif // ENABLE(B3_JIT)
339 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
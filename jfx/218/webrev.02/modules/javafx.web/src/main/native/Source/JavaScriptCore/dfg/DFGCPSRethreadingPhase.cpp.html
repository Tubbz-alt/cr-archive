<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCPSRethreadingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGCPSRethreadingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGPhase.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 class CPSRethreadingPhase : public Phase {
 39 public:
 40     CPSRethreadingPhase(Graph&amp; graph)
 41         : Phase(graph, &quot;CPS rethreading&quot;)
 42     {
 43     }
 44 
 45     bool run()
 46     {
 47         RELEASE_ASSERT(m_graph.m_refCountState == EverythingIsLive);
 48 
 49         if (m_graph.m_form == ThreadedCPS)
 50             return false;
 51 
 52         clearIsLoadedFrom();
 53         freeUnnecessaryNodes();
 54         m_graph.clearReplacements();
 55         canonicalizeLocalsInBlocks();
 56         specialCaseArguments();
 57         propagatePhis&lt;OperandKind::Local&gt;();
 58         propagatePhis&lt;OperandKind::Argument&gt;();
 59         propagatePhis&lt;OperandKind::Tmp&gt;();
 60         computeIsFlushed();
 61 
 62         m_graph.m_form = ThreadedCPS;
 63         return true;
 64     }
 65 
 66 private:
 67 
 68     void clearIsLoadedFrom()
 69     {
 70         for (unsigned i = 0; i &lt; m_graph.m_variableAccessData.size(); ++i)
 71             m_graph.m_variableAccessData[i].setIsLoadedFrom(false);
 72     }
 73 
 74     void freeUnnecessaryNodes()
 75     {
 76         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 77             BasicBlock* block = m_graph.block(blockIndex);
 78             if (!block)
 79                 continue;
 80             ASSERT(block-&gt;isReachable);
 81 
 82             unsigned fromIndex = 0;
 83             unsigned toIndex = 0;
 84             while (fromIndex &lt; block-&gt;size()) {
 85                 Node* node = block-&gt;at(fromIndex++);
 86                 switch (node-&gt;op()) {
 87                 case GetLocal:
 88                 case Flush:
 89                 case PhantomLocal:
 90                     node-&gt;children.setChild1(Edge());
 91                     break;
 92                 case Phantom:
 93                     if (!node-&gt;child1()) {
 94                         m_graph.deleteNode(node);
 95                         continue;
 96                     }
 97                     switch (node-&gt;child1()-&gt;op()) {
 98                     case SetArgumentMaybe:
 99                         DFG_CRASH(m_graph, node, &quot;Invalid Phantom(@SetArgumentMaybe)&quot;);
100                         break;
101                     case Phi:
102                     case SetArgumentDefinitely:
103                     case SetLocal:
104                         node-&gt;convertPhantomToPhantomLocal();
105                         break;
106                     default:
107                         ASSERT(node-&gt;child1()-&gt;hasResult());
108                         break;
109                     }
110                     break;
111                 default:
112                     break;
113                 }
114                 block-&gt;at(toIndex++) = node;
115             }
116             block-&gt;resize(toIndex);
117 
118             for (unsigned phiIndex = block-&gt;phis.size(); phiIndex--;)
119                 m_graph.deleteNode(block-&gt;phis[phiIndex]);
120             block-&gt;phis.resize(0);
121         }
122     }
123 
124     template&lt;OperandKind operandKind&gt;
125     void clearVariables()
126     {
127         ASSERT(
128             m_block-&gt;variablesAtHead.sizeFor&lt;operandKind&gt;()
129             == m_block-&gt;variablesAtTail.sizeFor&lt;operandKind&gt;());
130 
131         for (unsigned i = m_block-&gt;variablesAtHead.sizeFor&lt;operandKind&gt;(); i--;) {
132             m_block-&gt;variablesAtHead.atFor&lt;operandKind&gt;(i) = nullptr;
133             m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(i) = nullptr;
134         }
135     }
136 
137     ALWAYS_INLINE Node* addPhiSilently(BasicBlock* block, const NodeOrigin&amp; origin, VariableAccessData* variable)
138     {
139         Node* result = m_graph.addNode(Phi, origin, OpInfo(variable));
140         block-&gt;phis.append(result);
141         return result;
142     }
143 
144     template&lt;OperandKind operandKind&gt;
145     ALWAYS_INLINE Node* addPhi(BasicBlock* block, const NodeOrigin&amp; origin, VariableAccessData* variable, size_t index)
146     {
147         Node* result = addPhiSilently(block, origin, variable);
148         phiStackFor&lt;operandKind&gt;().append(PhiStackEntry(block, index, result));
149         return result;
150     }
151 
152     template&lt;OperandKind operandKind&gt;
153     ALWAYS_INLINE Node* addPhi(const NodeOrigin&amp; origin, VariableAccessData* variable, size_t index)
154     {
155         return addPhi&lt;operandKind&gt;(m_block, origin, variable, index);
156     }
157 
158     template&lt;OperandKind operandKind&gt;
159     void canonicalizeGetLocalFor(Node* node, VariableAccessData* variable, size_t idx)
160     {
161         ASSERT(!node-&gt;child1());
162 
163         if (Node* otherNode = m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx)) {
164             ASSERT(otherNode-&gt;variableAccessData() == variable);
165 
166             switch (otherNode-&gt;op()) {
167             case Flush:
168             case PhantomLocal:
169                 otherNode = otherNode-&gt;child1().node();
170                 if (otherNode-&gt;op() == Phi) {
171                     // We need to have a GetLocal, so this might as well be the one.
172                     node-&gt;children.setChild1(Edge(otherNode));
173                     m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
174                     return;
175                 }
176                 ASSERT(otherNode-&gt;op() != SetArgumentMaybe);
177                 ASSERT(otherNode-&gt;op() == SetLocal || otherNode-&gt;op() == SetArgumentDefinitely);
178                 break;
179             default:
180                 break;
181             }
182 
183             ASSERT(otherNode-&gt;op() != SetArgumentMaybe);
184             ASSERT(otherNode-&gt;op() == SetLocal || otherNode-&gt;op() == SetArgumentDefinitely || otherNode-&gt;op() == GetLocal);
185             ASSERT(otherNode-&gt;variableAccessData() == variable);
186 
187             if (otherNode-&gt;op() == SetArgumentDefinitely) {
188                 variable-&gt;setIsLoadedFrom(true);
189                 node-&gt;children.setChild1(Edge(otherNode));
190                 m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
191                 return;
192             }
193 
194             if (otherNode-&gt;op() == GetLocal) {
195                 // Replace all references to this GetLocal with otherNode.
196                 node-&gt;replaceWith(m_graph, otherNode);
197                 return;
198             }
199 
200             ASSERT(otherNode-&gt;op() == SetLocal);
201             node-&gt;replaceWith(m_graph, otherNode-&gt;child1().node());
202             return;
203         }
204 
205         variable-&gt;setIsLoadedFrom(true);
206         Node* phi = addPhi&lt;operandKind&gt;(node-&gt;origin, variable, idx);
207         node-&gt;children.setChild1(Edge(phi));
208         m_block-&gt;variablesAtHead.atFor&lt;operandKind&gt;(idx) = phi;
209         m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
210     }
211 
212     void canonicalizeGetLocal(Node* node)
213     {
214         VariableAccessData* variable = node-&gt;variableAccessData();
215         switch (variable-&gt;operand().kind()) {
216         case OperandKind::Argument: {
217             canonicalizeGetLocalFor&lt;OperandKind::Argument&gt;(node, variable, variable-&gt;operand().toArgument());
218             break;
219         }
220         case OperandKind::Local: {
221             canonicalizeGetLocalFor&lt;OperandKind::Local&gt;(node, variable, variable-&gt;operand().toLocal());
222             break;
223         }
224         case OperandKind::Tmp: {
225             canonicalizeGetLocalFor&lt;OperandKind::Tmp&gt;(node, variable, variable-&gt;operand().value());
226             break;
227         }
228         }
229     }
230 
231     template&lt;NodeType nodeType, OperandKind operandKind&gt;
232     void canonicalizeFlushOrPhantomLocalFor(Node* node, VariableAccessData* variable, size_t idx)
233     {
234         ASSERT(!node-&gt;child1());
235 
236         if (Node* otherNode = m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx)) {
237             ASSERT(otherNode-&gt;variableAccessData() == variable);
238 
239             switch (otherNode-&gt;op()) {
240             case Flush:
241             case PhantomLocal:
242             case GetLocal:
243                 ASSERT(otherNode-&gt;child1().node());
244                 otherNode = otherNode-&gt;child1().node();
245                 break;
246             default:
247                 break;
248             }
249 
250             ASSERT(otherNode-&gt;op() == Phi || otherNode-&gt;op() == SetLocal || otherNode-&gt;op() == SetArgumentDefinitely || otherNode-&gt;op() == SetArgumentMaybe);
251 
252             if (nodeType == PhantomLocal &amp;&amp; otherNode-&gt;op() == SetLocal) {
253                 // PhantomLocal(SetLocal) doesn&#39;t make sense. PhantomLocal means: at this
254                 // point I know I would have been interested in the value of this variable
255                 // for the purpose of OSR. PhantomLocal(SetLocal) means: at this point I
256                 // know that I would have read the value written by that SetLocal. This is
257                 // redundant and inefficient, since really it just means that we want to
258                 // keep the last MovHinted value of that local alive.
259 
260                 node-&gt;remove(m_graph);
261                 return;
262             }
263 
264             variable-&gt;setIsLoadedFrom(true);
265             // There is nothing wrong with having redundant Flush&#39;s. It just needs to
266             // be linked appropriately. Note that if there had already been a previous
267             // use at tail then we don&#39;t override it. It&#39;s fine for variablesAtTail to
268             // omit Flushes and PhantomLocals. On the other hand, having it refer to a
269             // Flush or a PhantomLocal if just before it the last use was a GetLocal would
270             // seriously confuse the CFA.
271             node-&gt;children.setChild1(Edge(otherNode));
272             return;
273         }
274 
275         variable-&gt;setIsLoadedFrom(true);
276         node-&gt;children.setChild1(Edge(addPhi&lt;operandKind&gt;(node-&gt;origin, variable, idx)));
277         m_block-&gt;variablesAtHead.atFor&lt;operandKind&gt;(idx) = node;
278         m_block-&gt;variablesAtTail.atFor&lt;operandKind&gt;(idx) = node;
279     }
280 
281     template&lt;NodeType nodeType&gt;
282     void canonicalizeFlushOrPhantomLocal(Node* node)
283     {
284         VariableAccessData* variable = node-&gt;variableAccessData();
285         switch (variable-&gt;operand().kind()) {
286         case OperandKind::Argument: {
287             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Argument&gt;(node, variable, variable-&gt;operand().toArgument());
288             break;
289         }
290         case OperandKind::Local: {
291             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Local&gt;(node, variable, variable-&gt;operand().toLocal());
292             break;
293         }
294         case OperandKind::Tmp: {
295             canonicalizeFlushOrPhantomLocalFor&lt;nodeType, OperandKind::Tmp&gt;(node, variable, variable-&gt;operand().value());
296             break;
297         }
298         }
299     }
300 
301     void canonicalizeSet(Node* node)
302     {
303         m_block-&gt;variablesAtTail.setOperand(node-&gt;operand(), node);
304     }
305 
306     void canonicalizeLocalsInBlock()
307     {
308         if (!m_block)
309             return;
310         ASSERT(m_block-&gt;isReachable);
311 
312         clearVariables&lt;OperandKind::Argument&gt;();
313         clearVariables&lt;OperandKind::Local&gt;();
314         clearVariables&lt;OperandKind::Tmp&gt;();
315 
316         // Assumes that all phi references have been removed. Assumes that things that
317         // should be live have a non-zero ref count, but doesn&#39;t assume that the ref
318         // counts are correct beyond that (more formally !!logicalRefCount == !!actualRefCount
319         // but not logicalRefCount == actualRefCount). Assumes that it can break ref
320         // counts.
321 
322         for (auto* node : *m_block) {
323             m_graph.performSubstitution(node);
324 
325             // The rules for threaded CPS form:
326             //
327             // Head variable: describes what is live at the head of the basic block.
328             // Head variable links may refer to Flush, PhantomLocal, Phi, or SetArgumentDefinitely/SetArgumentMaybe.
329             // SetArgumentDefinitely/SetArgumentMaybe may only appear in the root block.
330             //
331             // Tail variable: the last thing that happened to the variable in the block.
332             // It may be a Flush, PhantomLocal, GetLocal, SetLocal, SetArgumentDefinitely/SetArgumentMaybe, or Phi.
333             // SetArgumentDefinitely/SetArgumentMaybe may only appear in the root block. Note that if there ever
334             // was a GetLocal to the variable, and it was followed by PhantomLocals and
335             // Flushes but not SetLocals, then the tail variable will be the GetLocal.
336             // This reflects the fact that you only care that the tail variable is a
337             // Flush or PhantomLocal if nothing else interesting happened. Likewise, if
338             // there ever was a SetLocal and it was followed by Flushes, then the tail
339             // variable will be a SetLocal and not those subsequent Flushes.
340             //
341             // Child of GetLocal: the operation that the GetLocal keeps alive. It may be
342             // a Phi from the current block. For arguments, it may be a SetArgumentDefinitely
343             // but it can&#39;t be a SetArgumentMaybe.
344             //
345             // Child of SetLocal: must be a value producing node.
346             //
347             // Child of Flush: it may be a Phi from the current block or a SetLocal. For
348             // arguments it may also be a SetArgumentDefinitely/SetArgumentMaybe.
349             //
350             // Child of PhantomLocal: it may be a Phi from the current block. For
351             // arguments it may also be a SetArgumentDefinitely/SetArgumentMaybe.
352             //
353             // Children of Phi: other Phis in the same basic block, or any of the
354             // following from predecessor blocks: SetLocal, Phi, or SetArgumentDefinitely/SetArgumentMaybe.
355             // These are computed by looking at the tail variables of the predecessor blocks
356             // and either using it directly (if it&#39;s a SetLocal, Phi, or SetArgumentDefinitely/SetArgumentMaybe) or
357             // loading that nodes child (if it&#39;s a GetLocal, PhanomLocal, or Flush - all
358             // of these will have children that are SetLocal, Phi, or SetArgumentDefinitely/SetArgumentMaybe).
359 
360             switch (node-&gt;op()) {
361             case GetLocal:
362                 canonicalizeGetLocal(node);
363                 break;
364 
365             case SetLocal:
366                 canonicalizeSet(node);
367                 break;
368 
369             case Flush:
370                 canonicalizeFlushOrPhantomLocal&lt;Flush&gt;(node);
371                 break;
372 
373             case PhantomLocal:
374                 canonicalizeFlushOrPhantomLocal&lt;PhantomLocal&gt;(node);
375                 break;
376 
377             case SetArgumentDefinitely:
378             case SetArgumentMaybe:
379                 canonicalizeSet(node);
380                 break;
381 
382             default:
383                 break;
384             }
385         }
386     }
387 
388     void canonicalizeLocalsInBlocks()
389     {
390         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
391             m_block = m_graph.block(blockIndex);
392             canonicalizeLocalsInBlock();
393         }
394     }
395 
396     void specialCaseArguments()
397     {
398         // Normally, a SetArgumentDefinitely denotes the start of a live range for a local&#39;s value on the stack.
399         // But those SetArguments used for the actual arguments to the machine CodeBlock get
400         // special-cased. We could have instead used two different node types - one for the arguments
401         // at the prologue case, and another for the other uses. But this seemed like IR overkill.
402 
403         for (auto&amp; pair : m_graph.m_rootToArguments) {
404             BasicBlock* entrypoint = pair.key;
405             const ArgumentsVector&amp; arguments = pair.value;
406             for (unsigned i = arguments.size(); i--;)
407                 entrypoint-&gt;variablesAtHead.setArgumentFirstTime(i, arguments[i]);
408         }
409     }
410 
411     template&lt;OperandKind operandKind&gt;
412     void propagatePhis()
413     {
414         Vector&lt;PhiStackEntry, 128&gt;&amp; phiStack = phiStackFor&lt;operandKind&gt;();
415 
416         // Ensure that attempts to use this fail instantly.
417         m_block = 0;
418 
419         while (!phiStack.isEmpty()) {
420             PhiStackEntry entry = phiStack.last();
421             phiStack.removeLast();
422 
423             BasicBlock* block = entry.m_block;
424             PredecessorList&amp; predecessors = block-&gt;predecessors;
425             Node* currentPhi = entry.m_phi;
426             VariableAccessData* variable = currentPhi-&gt;variableAccessData();
427             size_t index = entry.m_index;
428 
429             for (size_t i = predecessors.size(); i--;) {
430                 BasicBlock* predecessorBlock = predecessors[i];
431 
432                 Node* variableInPrevious = predecessorBlock-&gt;variablesAtTail.atFor&lt;operandKind&gt;(index);
433                 if (!variableInPrevious) {
434                     variableInPrevious = addPhi&lt;operandKind&gt;(predecessorBlock, currentPhi-&gt;origin, variable, index);
435                     predecessorBlock-&gt;variablesAtTail.atFor&lt;operandKind&gt;(index) = variableInPrevious;
436                     predecessorBlock-&gt;variablesAtHead.atFor&lt;operandKind&gt;(index) = variableInPrevious;
437                 } else {
438                     switch (variableInPrevious-&gt;op()) {
439                     case GetLocal:
440                     case PhantomLocal:
441                     case Flush:
442                         ASSERT(variableInPrevious-&gt;variableAccessData() == variableInPrevious-&gt;child1()-&gt;variableAccessData());
443                         variableInPrevious = variableInPrevious-&gt;child1().node();
444                         break;
445                     default:
446                         break;
447                     }
448                 }
449 
450                 ASSERT(
451                     variableInPrevious-&gt;op() == SetLocal
452                     || variableInPrevious-&gt;op() == Phi
453                     || variableInPrevious-&gt;op() == SetArgumentDefinitely
454                     || variableInPrevious-&gt;op() == SetArgumentMaybe);
455 
456                 if (!currentPhi-&gt;child1()) {
457                     currentPhi-&gt;children.setChild1(Edge(variableInPrevious));
458                     continue;
459                 }
460                 if (!currentPhi-&gt;child2()) {
461                     currentPhi-&gt;children.setChild2(Edge(variableInPrevious));
462                     continue;
463                 }
464                 if (!currentPhi-&gt;child3()) {
465                     currentPhi-&gt;children.setChild3(Edge(variableInPrevious));
466                     continue;
467                 }
468 
469                 Node* newPhi = addPhiSilently(block, currentPhi-&gt;origin, variable);
470                 newPhi-&gt;children = currentPhi-&gt;children;
471                 currentPhi-&gt;children.initialize(newPhi, variableInPrevious, 0);
472             }
473         }
474     }
475 
476     struct PhiStackEntry {
477         PhiStackEntry(BasicBlock* block, size_t index, Node* phi)
478             : m_block(block)
479             , m_index(index)
480             , m_phi(phi)
481         {
482         }
483 
484         BasicBlock* m_block;
485         size_t m_index;
486         Node* m_phi;
487     };
488 
489     template&lt;OperandKind operandKind&gt;
490     Vector&lt;PhiStackEntry, 128&gt;&amp; phiStackFor()
491     {
492         switch (operandKind) {
493         case OperandKind::Argument: return m_argumentPhiStack;
494         case OperandKind::Local: return m_localPhiStack;
495         case OperandKind::Tmp: return m_tmpPhiStack;
496         }
497         RELEASE_ASSERT_NOT_REACHED();
498     }
499 
500     void computeIsFlushed()
501     {
502         m_graph.clearFlagsOnAllNodes(NodeIsFlushed);
503 
504         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
505             BasicBlock* block = m_graph.block(blockIndex);
506             if (!block)
507                 continue;
508             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
509                 Node* node = block-&gt;at(nodeIndex);
510                 if (node-&gt;op() != Flush)
511                     continue;
512                 addFlushedLocalOp(node);
513             }
514         }
515         while (!m_flushedLocalOpWorklist.isEmpty()) {
516             Node* node = m_flushedLocalOpWorklist.takeLast();
517             switch (node-&gt;op()) {
518             case SetLocal:
519             case SetArgumentDefinitely:
520             case SetArgumentMaybe:
521                 break;
522 
523             case Flush:
524             case Phi:
525                 ASSERT(node-&gt;flags() &amp; NodeIsFlushed);
526                 DFG_NODE_DO_TO_CHILDREN(m_graph, node, addFlushedLocalEdge);
527                 break;
528 
529             default:
530                 DFG_CRASH(m_graph, node, &quot;Invalid node in flush graph&quot;);
531                 break;
532             }
533         }
534     }
535 
536     void addFlushedLocalOp(Node* node)
537     {
538         if (node-&gt;mergeFlags(NodeIsFlushed))
539             m_flushedLocalOpWorklist.append(node);
540     }
541 
542     void addFlushedLocalEdge(Node*, Edge edge)
543     {
544         addFlushedLocalOp(edge.node());
545     }
546 
547     BasicBlock* m_block;
548     Vector&lt;PhiStackEntry, 128&gt; m_argumentPhiStack;
549     Vector&lt;PhiStackEntry, 128&gt; m_localPhiStack;
550     Vector&lt;PhiStackEntry, 128&gt; m_tmpPhiStack;
551     Vector&lt;Node*, 128&gt; m_flushedLocalOpWorklist;
552 };
553 
554 bool performCPSRethreading(Graph&amp; graph)
555 {
556     return runPhase&lt;CPSRethreadingPhase&gt;(graph);
557 }
558 
559 } } // namespace JSC::DFG
560 
561 #endif // ENABLE(DFG_JIT)
562 
    </pre>
  </body>
</html>
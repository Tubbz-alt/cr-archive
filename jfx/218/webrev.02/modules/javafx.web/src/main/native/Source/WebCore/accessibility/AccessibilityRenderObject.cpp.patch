diff a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp
@@ -131,13 +131,13 @@
 Ref<AccessibilityRenderObject> AccessibilityRenderObject::create(RenderObject* renderer)
 {
     return adoptRef(*new AccessibilityRenderObject(renderer));
 }
 
-void AccessibilityRenderObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)
+void AccessibilityRenderObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)
 {
-    AccessibilityNodeObject::detach(detachmentType, cache);
+    AccessibilityNodeObject::detachRemoteParts(detachmentType);
 
     detachRemoteSVGRoot();
 
 #ifndef NDEBUG
     if (m_renderer)
@@ -974,11 +974,11 @@
         return AccessibilityObject::speakAsProperty();
 
     return m_renderer->style().speakAs();
 }
 
-void AccessibilityRenderObject::addRadioButtonGroupChildren(AccessibilityObject* parent, AccessibilityChildrenVector& linkedUIElements) const
+void AccessibilityRenderObject::addRadioButtonGroupChildren(AXCoreObject* parent, AccessibilityChildrenVector& linkedUIElements) const
 {
     for (const auto& child : parent->children()) {
         if (child->roleValue() == AccessibilityRole::RadioButton)
             linkedUIElements.append(child);
         else
@@ -993,11 +993,11 @@
 
     Node* node = this->node();
     if (is<HTMLInputElement>(node)) {
         HTMLInputElement& input = downcast<HTMLInputElement>(*node);
         for (auto& radioSibling : input.radioButtonGroup()) {
-            if (AccessibilityObject* object = axObjectCache()->getOrCreate(radioSibling))
+            if (AccessibilityObject* object = axObjectCache()->getOrCreate(radioSibling.ptr()))
                 linkedUIElements.append(object);
         }
     } else {
         // If we didn't find any radio button siblings with the traditional naming, lets search for a radio group role and find its children.
         for (AccessibilityObject* parent = parentObject(); parent; parent = parent->parentObject()) {
@@ -1031,11 +1031,11 @@
 }
 
 bool AccessibilityRenderObject::hasPopup() const
 {
     // Return true if this has the aria-haspopup attribute, or if it has an ancestor of type link with the aria-haspopup attribute.
-    return AccessibilityObject::matchedParent(*this, true, [this] (const AccessibilityObject& object) {
+    return Accessibility::findAncestor<AccessibilityObject>(*this, true, [this] (const AccessibilityObject& object) {
         return (this == &object) ? !equalLettersIgnoringASCIICase(object.popupValue(), "false")
             : object.isLink() && !equalLettersIgnoringASCIICase(object.popupValue(), "false");
     });
 }
 
@@ -1279,11 +1279,11 @@
     if (m_renderer->isBR())
         return true;
 
     if (is<RenderText>(*m_renderer)) {
         // static text beneath MenuItems and MenuButtons are just reported along with the menu item, so it's ignored on an individual level
-        AccessibilityObject* parent = parentObjectUnignored();
+        AXCoreObject* parent = parentObjectUnignored();
         if (parent && (parent->isMenuItem() || parent->ariaRoleAttribute() == AccessibilityRole::MenuButton))
             return true;
         auto& renderText = downcast<RenderText>(*m_renderer);
         if (!renderText.hasRenderedText())
             return true;
@@ -1431,11 +1431,11 @@
         }
         // Otherwise fall through; use presence of help text, title, or description to decide.
     }
 
     if (m_renderer->isListMarker()) {
-        AccessibilityObject* parent = parentObjectUnignored();
+        AXCoreObject* parent = parentObjectUnignored();
         return parent && !parent->isListItem();
     }
 
     if (isWebArea())
         return false;
@@ -1568,11 +1568,11 @@
     }
 
     return doAXStringForRange(documentBasedSelectedTextRange());
 }
 
-const AtomString& AccessibilityRenderObject::accessKey() const
+String AccessibilityRenderObject::accessKey() const
 {
     Node* node = m_renderer->node();
     if (!is<Element>(node))
         return nullAtom();
     return downcast<Element>(*node).attributeWithoutSynchronization(accesskeyAttr);
@@ -2368,11 +2368,11 @@
     if (allowsTextRanges())
         return boundsForRange(rangeForPlainTextRange(range));
     return IntRect();
 }
 
-AccessibilityObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint& point) const
+AXCoreObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint& point) const
 {
     if (!area)
         return nullptr;
 
     AccessibilityObject* parent = nullptr;
@@ -2391,21 +2391,21 @@
     }
 
     return nullptr;
 }
 
-AccessibilityObjectInterface* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint& point) const
+AXCoreObject* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint& point) const
 {
     AccessibilityObject* remote = remoteSVGRootElement(Create);
     if (!remote)
         return nullptr;
 
     IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
     return remote->accessibilityHitTest(IntPoint(offset));
 }
 
-AccessibilityObjectInterface* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint& point) const
+AXCoreObject* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint& point) const
 {
     if (isSVGImage())
         return remoteSVGElementHitTest(point);
 
     return AccessibilityObject::elementAccessibilityHitTest(point);
@@ -2415,11 +2415,11 @@
 {
     // We need to allow automation of mouse events on video tags.
     return shadowHost && !shadowHost->hasTagName(videoTag);
 }
 
-AccessibilityObjectInterface* AccessibilityRenderObject::accessibilityHitTest(const IntPoint& point) const
+AXCoreObject* AccessibilityRenderObject::accessibilityHitTest(const IntPoint& point) const
 {
     if (!m_renderer || !m_renderer->hasLayer())
         return nullptr;
 
     m_renderer->document().updateLayout();
@@ -2448,19 +2448,19 @@
 
     RenderObject* obj = node->renderer();
     if (!obj)
         return nullptr;
 
-    AccessibilityObject* result = obj->document().axObjectCache()->getOrCreate(obj);
+    AXCoreObject* result = obj->document().axObjectCache()->getOrCreate(obj);
     result->updateChildrenIfNecessary();
 
     // Allow the element to perform any hit-testing it might need to do to reach non-render children.
     result = static_cast<AccessibilityObject*>(result->elementAccessibilityHitTest(point));
 
     if (result && result->accessibilityIsIgnored()) {
         // If this element is the label of a control, a hit test should return the control.
-        AccessibilityObject* controlObject = result->correspondingControlForLabelElement();
+        AXCoreObject* controlObject = result->correspondingControlForLabelElement();
         if (controlObject && !controlObject->exposesTitleUIElement())
             return controlObject;
 
         result = result->parentObjectUnignored();
     }
@@ -3134,11 +3134,11 @@
         areaObject.setHTMLMapElement(map);
         areaObject.setParent(this);
         if (!areaObject.accessibilityIsIgnored())
             m_children.append(&areaObject);
         else
-            axObjectCache()->remove(areaObject.axObjectID());
+            axObjectCache()->remove(areaObject.objectID());
     }
 }
 
 void AccessibilityRenderObject::updateChildrenIfNecessary()
 {
@@ -3306,11 +3306,11 @@
     // try to insert hidden nodes in the correct place in the DOM order.
     unsigned insertionIndex = 0;
     for (Node* child = node->firstChild(); child; child = child->nextSibling()) {
         if (child->renderer()) {
             // Find out where the last render sibling is located within m_children.
-            AccessibilityObject* childObject = axObjectCache()->get(child->renderer());
+            AXCoreObject* childObject = axObjectCache()->get(child->renderer());
             if (childObject && childObject->accessibilityIsIgnored()) {
                 auto& children = childObject->children();
                 if (children.size())
                     childObject = children.last().get();
                 else
@@ -3523,11 +3523,11 @@
     case AccessibilityRole::Tree:
     case AccessibilityRole::TreeGrid:
         ariaSelectedRows(result);
         return;
     case AccessibilityRole::TabList:
-        if (AccessibilityObject* selectedTab = selectedTabItem())
+        if (AXCoreObject* selectedTab = selectedTabItem())
             result.append(selectedTab);
         return;
     case AccessibilityRole::List:
         if (auto* selectedListItemChild = selectedListItem())
             result.append(selectedListItemChild);
@@ -3561,30 +3561,29 @@
 
 void AccessibilityRenderObject::visibleChildren(AccessibilityChildrenVector& result)
 {
     ASSERT(result.isEmpty());
 
-    // only listboxes are asked for their visible children.
-    if (ariaRoleAttribute() != AccessibilityRole::ListBox) {
-        // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes
-        ASSERT_NOT_REACHED();
+    // Only listboxes are asked for their visible children.
+    // Native list boxes would be AccessibilityListBoxes, so only check for aria list boxes.
+    if (ariaRoleAttribute() != AccessibilityRole::ListBox)
         return;
-    }
     return ariaListboxVisibleChildren(result);
 }
 
 void AccessibilityRenderObject::tabChildren(AccessibilityChildrenVector& result)
 {
-    ASSERT(roleValue() == AccessibilityRole::TabList);
+    if (roleValue() != AccessibilityRole::TabList)
+        return;
 
     for (const auto& child : children()) {
         if (child->isTabItem())
             result.append(child);
     }
 }
 
-const String& AccessibilityRenderObject::actionVerb() const
+String AccessibilityRenderObject::actionVerb() const
 {
 #if !PLATFORM(IOS_FAMILY)
     // FIXME: Need to add verbs for select elements.
     static NeverDestroyed<const String> buttonAction(AXButtonActionVerb());
     static NeverDestroyed<const String> textFieldAction(AXTextFieldActionVerb());

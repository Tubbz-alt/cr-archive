<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFormat.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;B3Type.h&quot;
 31 #include &quot;CodeLocation.h&quot;
 32 #include &quot;Identifier.h&quot;
 33 #include &quot;MacroAssemblerCodeRef.h&quot;
 34 #include &quot;RegisterAtOffsetList.h&quot;
 35 #include &quot;WasmMemoryInformation.h&quot;
 36 #include &quot;WasmName.h&quot;
 37 #include &quot;WasmNameSection.h&quot;
 38 #include &quot;WasmOps.h&quot;
 39 #include &quot;WasmPageCount.h&quot;
 40 #include &quot;WasmSignature.h&quot;
 41 #include &lt;limits&gt;
 42 #include &lt;memory&gt;
 43 #include &lt;wtf/Optional.h&gt;
 44 #include &lt;wtf/Vector.h&gt;
 45 
 46 namespace JSC {
 47 
 48 namespace B3 {
 49 class Compilation;
 50 }
 51 
 52 namespace Wasm {
 53 
 54 struct CompilationContext;
 55 struct ModuleInformation;
 56 
 57 using BlockSignature = const Signature*;
 58 
 59 enum class TableElementType : uint8_t {
 60     Anyref,
 61     Funcref
 62 };
 63 
 64 inline bool isValueType(Type type)
 65 {
 66     switch (type) {
 67     case I32:
 68     case I64:
 69     case F32:
 70     case F64:
 71         return true;
 72     case Anyref:
 73     case Funcref:
 74         return Options::useWebAssemblyReferences();
 75     default:
 76         break;
 77     }
 78     return false;
 79 }
 80 
 81 inline bool isSubtype(Type sub, Type parent)
 82 {
 83     if (sub == parent)
 84         return true;
 85     return sub == Funcref &amp;&amp; parent == Anyref;
 86 }
 87 
 88 enum class ExternalKind : uint8_t {
 89     // FIXME auto-generate this. https://bugs.webkit.org/show_bug.cgi?id=165231
 90     Function = 0,
 91     Table = 1,
 92     Memory = 2,
 93     Global = 3,
 94 };
 95 
 96 template&lt;typename Int&gt;
 97 inline bool isValidExternalKind(Int val)
 98 {
 99     switch (val) {
100     case static_cast&lt;Int&gt;(ExternalKind::Function):
101     case static_cast&lt;Int&gt;(ExternalKind::Table):
102     case static_cast&lt;Int&gt;(ExternalKind::Memory):
103     case static_cast&lt;Int&gt;(ExternalKind::Global):
104         return true;
105     }
106     return false;
107 }
108 
109 static_assert(static_cast&lt;int&gt;(ExternalKind::Function) == 0, &quot;Wasm needs Function to have the value 0&quot;);
110 static_assert(static_cast&lt;int&gt;(ExternalKind::Table)    == 1, &quot;Wasm needs Table to have the value 1&quot;);
111 static_assert(static_cast&lt;int&gt;(ExternalKind::Memory)   == 2, &quot;Wasm needs Memory to have the value 2&quot;);
112 static_assert(static_cast&lt;int&gt;(ExternalKind::Global)   == 3, &quot;Wasm needs Global to have the value 3&quot;);
113 
114 inline const char* makeString(ExternalKind kind)
115 {
116     switch (kind) {
117     case ExternalKind::Function: return &quot;function&quot;;
118     case ExternalKind::Table: return &quot;table&quot;;
119     case ExternalKind::Memory: return &quot;memory&quot;;
120     case ExternalKind::Global: return &quot;global&quot;;
121     }
122     RELEASE_ASSERT_NOT_REACHED();
123     return &quot;?&quot;;
124 }
125 
126 struct Import {
127     WTF_MAKE_STRUCT_FAST_ALLOCATED;
128     const Name module;
129     const Name field;
130     ExternalKind kind;
131     unsigned kindIndex; // Index in the vector of the corresponding kind.
132 };
133 
134 struct Export {
135     WTF_MAKE_STRUCT_FAST_ALLOCATED;
136     const Name field;
137     ExternalKind kind;
138     unsigned kindIndex; // Index in the vector of the corresponding kind.
139 };
140 
141 String makeString(const Name&amp; characters);
142 
143 struct GlobalInformation {
144     WTF_MAKE_STRUCT_FAST_ALLOCATED;
145     enum Mutability : uint8_t {
146         // FIXME auto-generate this. https://bugs.webkit.org/show_bug.cgi?id=165231
147         Mutable = 1,
148         Immutable = 0
149     };
150 
151     enum InitializationType : uint8_t {
152         IsImport,
153         FromGlobalImport,
154         FromRefFunc,
155         FromExpression
156     };
157 
158     enum class BindingMode : uint8_t {
159         EmbeddedInInstance = 0,
160         Portable,
161     };
162 
163     Mutability mutability;
164     Type type;
165     InitializationType initializationType { IsImport };
166     BindingMode bindingMode { BindingMode::EmbeddedInInstance };
167     uint64_t initialBitsOrImportNumber { 0 };
168 };
169 
170 struct FunctionData {
171     WTF_MAKE_STRUCT_FAST_ALLOCATED;
172     size_t start;
173     size_t end;
174     Vector&lt;uint8_t&gt; data;
175 };
176 
177 class I32InitExpr {
178     WTF_MAKE_FAST_ALLOCATED;
179     enum Type : uint8_t {
180         Global,
181         Const
182     };
183 
184     I32InitExpr(Type type, uint32_t bits)
185         : m_bits(bits)
186         , m_type(type)
187     { }
188 
189 public:
190     I32InitExpr() = delete;
191 
192     static I32InitExpr globalImport(uint32_t globalImportNumber) { return I32InitExpr(Global, globalImportNumber); }
193     static I32InitExpr constValue(uint32_t constValue) { return I32InitExpr(Const, constValue); }
194 
195     bool isConst() const { return m_type == Const; }
196     bool isGlobalImport() const { return m_type == Global; }
197     uint32_t constValue() const
198     {
199         RELEASE_ASSERT(isConst());
200         return m_bits;
201     }
202     uint32_t globalImportIndex() const
203     {
204         RELEASE_ASSERT(isGlobalImport());
205         return m_bits;
206     }
207 
208 private:
209     uint32_t m_bits;
210     Type m_type;
211 };
212 
213 struct Segment {
214     WTF_MAKE_STRUCT_FAST_ALLOCATED;
215     uint32_t sizeInBytes;
216     I32InitExpr offset;
217     // Bytes are allocated at the end.
218     uint8_t&amp; byte(uint32_t pos)
219     {
220         ASSERT(pos &lt; sizeInBytes);
221         return *reinterpret_cast&lt;uint8_t*&gt;(reinterpret_cast&lt;char*&gt;(this) + sizeof(Segment) + pos);
222     }
223     static Segment* create(I32InitExpr, uint32_t);
224     static void destroy(Segment*);
225     typedef std::unique_ptr&lt;Segment, decltype(&amp;Segment::destroy)&gt; Ptr;
226     static Ptr adoptPtr(Segment*);
227 };
228 
229 struct Element {
230     WTF_MAKE_STRUCT_FAST_ALLOCATED;
231     Element(uint32_t tableIndex, I32InitExpr offset)
232         : tableIndex(tableIndex)
233         , offset(offset)
234     { }
235 
236     uint32_t tableIndex;
237     I32InitExpr offset;
238     Vector&lt;uint32_t&gt; functionIndices;
239 };
240 
241 class TableInformation {
242     WTF_MAKE_FAST_ALLOCATED;
243 public:
244     TableInformation()
245     {
246         ASSERT(!*this);
247     }
248 
249     TableInformation(uint32_t initial, Optional&lt;uint32_t&gt; maximum, bool isImport, TableElementType type)
250         : m_initial(initial)
251         , m_maximum(maximum)
252         , m_isImport(isImport)
253         , m_isValid(true)
254         , m_type(type)
255     {
256         ASSERT(*this);
257     }
258 
259     explicit operator bool() const { return m_isValid; }
260     bool isImport() const { return m_isImport; }
261     uint32_t initial() const { return m_initial; }
262     Optional&lt;uint32_t&gt; maximum() const { return m_maximum; }
263     TableElementType type() const { return m_type; }
264     Wasm::Type wasmType() const { return m_type == TableElementType::Funcref ? Type::Funcref : Type::Anyref; }
265 
266 private:
267     uint32_t m_initial;
268     Optional&lt;uint32_t&gt; m_maximum;
269     bool m_isImport { false };
270     bool m_isValid { false };
271     TableElementType m_type;
272 };
273 
274 struct CustomSection {
275     WTF_MAKE_STRUCT_FAST_ALLOCATED;
276     Name name;
277     Vector&lt;uint8_t&gt; payload;
278 };
279 
280 enum class NameType : uint8_t {
281     Module = 0,
282     Function = 1,
283     Local = 2,
284 };
285 
286 template&lt;typename Int&gt;
287 inline bool isValidNameType(Int val)
288 {
289     switch (val) {
290     case static_cast&lt;Int&gt;(NameType::Module):
291     case static_cast&lt;Int&gt;(NameType::Function):
292     case static_cast&lt;Int&gt;(NameType::Local):
293         return true;
294     }
295     return false;
296 }
297 
298 struct UnlinkedWasmToWasmCall {
299     WTF_MAKE_STRUCT_FAST_ALLOCATED;
300     CodeLocationNearCall&lt;WasmEntryPtrTag&gt; callLocation;
301     size_t functionIndexSpace;
302 };
303 
304 struct Entrypoint {
305     WTF_MAKE_STRUCT_FAST_ALLOCATED;
306     std::unique_ptr&lt;B3::Compilation&gt; compilation;
307     RegisterAtOffsetList calleeSaveRegisters;
308 };
309 
310 struct InternalFunction {
311     WTF_MAKE_STRUCT_FAST_ALLOCATED;
312     CodeLocationDataLabelPtr&lt;WasmEntryPtrTag&gt; calleeMoveLocation;
313     Entrypoint entrypoint;
314 };
315 
316 // WebAssembly direct calls and call_indirect use indices into &quot;function index space&quot;. This space starts
317 // with all imports, and then all internal functions. WasmToWasmImportableFunction and FunctionIndexSpace are only
318 // meant as fast lookup tables for these opcodes and do not own code.
319 struct WasmToWasmImportableFunction {
320     WTF_MAKE_STRUCT_FAST_ALLOCATED;
321     using LoadLocation = MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt;*;
322     static ptrdiff_t offsetOfSignatureIndex() { return OBJECT_OFFSETOF(WasmToWasmImportableFunction, signatureIndex); }
323     static ptrdiff_t offsetOfEntrypointLoadLocation() { return OBJECT_OFFSETOF(WasmToWasmImportableFunction, entrypointLoadLocation); }
324 
325     // FIXME: Pack signature index and code pointer into one 64-bit value. See &lt;https://bugs.webkit.org/show_bug.cgi?id=165511&gt;.
326     SignatureIndex signatureIndex { Signature::invalidIndex };
327     LoadLocation entrypointLoadLocation;
328 };
329 using FunctionIndexSpace = Vector&lt;WasmToWasmImportableFunction&gt;;
330 
331 } } // namespace JSC::Wasm
332 
333 #endif // ENABLE(WEBASSEMBLY)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGEpoch.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGForAllKills.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -32,10 +32,11 @@</span>
  #include &quot;DFGGraph.h&quot;
  #include &quot;DFGInsertionSet.h&quot;
  #include &quot;DFGPhase.h&quot;
  #include &quot;DFGPredictionPropagationPhase.h&quot;
  #include &quot;DFGVariableAccessDataDump.h&quot;
<span class="udiff-line-added">+ #include &quot;GetterSetter.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;TypeLocation.h&quot;
  
  namespace JSC { namespace DFG {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -182,10 +183,55 @@</span>
          case SetLocal: {
              // This gets handled by fixupGetAndSetLocalsInBlock().
              return;
          }
  
<span class="udiff-line-added">+         case Inc:</span>
<span class="udiff-line-added">+         case Dec: {</span>
<span class="udiff-line-added">+             if (node-&gt;child1()-&gt;shouldSpeculateUntypedForArithmetic()) {</span>
<span class="udiff-line-added">+                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Node* nodeConstantOne;</span>
<span class="udiff-line-added">+             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {</span>
<span class="udiff-line-added">+                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="udiff-line-added">+                 node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="udiff-line-added">+                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecInt32Only, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="udiff-line-added">+                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="udiff-line-added">+                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());</span>
<span class="udiff-line-added">+                 node-&gt;setResult(NodeResultInt32);</span>
<span class="udiff-line-added">+             } else if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {</span>
<span class="udiff-line-added">+                 // FIXME: the freezing does not appear useful (since the JSCell is kept alive by vm), but it refuses to compile otherwise.</span>
<span class="udiff-line-added">+                 node-&gt;setOp(op == Inc ? ValueAdd : ValueSub);</span>
<span class="udiff-line-added">+                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecBigInt, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(vm().bigIntConstantOne.get())));</span>
<span class="udiff-line-added">+                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="udiff-line-added">+                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());</span>
<span class="udiff-line-added">+                 // BigInts are currently cells, so the default of NodeResultJS is good here</span>
<span class="udiff-line-added">+             } else if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
<span class="udiff-line-added">+                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="udiff-line-added">+                 node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="udiff-line-added">+                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecInt32AsInt52, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="udiff-line-added">+                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="udiff-line-added">+                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());</span>
<span class="udiff-line-added">+                 node-&gt;setResult(NodeResultInt52);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="udiff-line-added">+                 node-&gt;setArithMode(Arith::Unchecked);</span>
<span class="udiff-line-added">+                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="udiff-line-added">+                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="udiff-line-added">+                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());</span>
<span class="udiff-line-added">+                 node-&gt;setResult(NodeResultDouble);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case ValueSub: {
              Edge&amp; child1 = node-&gt;child1();
              Edge&amp; child2 = node-&gt;child2();
  
              if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -214,10 +260,11 @@</span>
  
              break;
          }
  
          case ValueBitLShift:
<span class="udiff-line-added">+         case ValueBitRShift:</span>
          case ValueBitXor:
          case ValueBitOr:
          case ValueBitAnd: {
              if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
                  fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -243,10 +290,13 @@</span>
                  node-&gt;setOp(ArithBitAnd);
                  break;
              case ValueBitLShift:
                  node-&gt;setOp(ArithBitLShift);
                  break;
<span class="udiff-line-added">+             case ValueBitRShift:</span>
<span class="udiff-line-added">+                 node-&gt;setOp(ArithBitRShift);</span>
<span class="udiff-line-added">+                 break;</span>
              default:
                  DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
                  break;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,20 +329,20 @@</span>
  
              fixIntConvertingEdge(operandEdge);
              break;
          }
  
<span class="udiff-line-added">+         case ArithBitRShift:</span>
          case ArithBitLShift:
          case ArithBitXor:
          case ArithBitOr:
          case ArithBitAnd: {
              fixIntConvertingEdge(node-&gt;child1());
              fixIntConvertingEdge(node-&gt;child2());
              break;
          }
  
<span class="udiff-line-removed">-         case BitRShift:</span>
          case BitURShift: {
              if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -833,11 +883,12 @@</span>
              } else
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
              break;
  
          case StringCharAt:
<span class="udiff-line-modified-removed">-         case StringCharCodeAt: {</span>
<span class="udiff-line-modified-added">+         case StringCharCodeAt:</span>
<span class="udiff-line-added">+         case StringCodePointAt: {</span>
              // Currently we have no good way of refining these.
              ASSERT(node-&gt;arrayMode() == ArrayMode(Array::String, Array::Read));
              blessArrayOperation(node-&gt;child1(), node-&gt;child2(), node-&gt;child3());
              fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
              fixEdge&lt;Int32Use&gt;(node-&gt;child2());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1338,15 +1389,52 @@</span>
          case ToPrimitive: {
              fixupToPrimitive(node);
              break;
          }
  
<span class="udiff-line-added">+         case ToPropertyKey: {</span>
<span class="udiff-line-added">+             if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="udiff-line-added">+                 fixEdge&lt;StringUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 node-&gt;convertToIdentity();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {</span>
<span class="udiff-line-added">+                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 node-&gt;convertToIdentity();</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (node-&gt;child1()-&gt;shouldSpeculateStringObject()</span>
<span class="udiff-line-added">+                 &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {</span>
<span class="udiff-line-added">+                 addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());</span>
<span class="udiff-line-added">+                 fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 node-&gt;convertToToString();</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()</span>
<span class="udiff-line-added">+                 &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {</span>
<span class="udiff-line-added">+                 addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());</span>
<span class="udiff-line-added">+                 fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+                 node-&gt;convertToToString();</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case ToNumber: {
              fixupToNumber(node);
              break;
          }
  
<span class="udiff-line-added">+         case ToNumeric: {</span>
<span class="udiff-line-added">+             fixupToNumeric(node);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case ToString:
          case CallStringConstructor: {
              fixupToStringOrCallStringConstructor(node);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1481,17 +1569,19 @@</span>
              fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
              break;
          }
  
          case GetClosureVar:
<span class="udiff-line-modified-removed">-         case GetFromArguments: {</span>
<span class="udiff-line-modified-added">+         case GetFromArguments:</span>
<span class="udiff-line-added">+         case GetInternalField: {</span>
              fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
              break;
          }
  
          case PutClosureVar:
<span class="udiff-line-modified-removed">-         case PutToArguments: {</span>
<span class="udiff-line-modified-added">+         case PutToArguments:</span>
<span class="udiff-line-added">+         case PutInternalField: {</span>
              fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
              speculateForBarrier(node-&gt;child2());
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1641,10 +1731,13 @@</span>
  
          case OverridesHasInstance:
          case CheckStructure:
          case CheckCell:
          case CreateThis:
<span class="udiff-line-added">+         case CreatePromise:</span>
<span class="udiff-line-added">+         case CreateGenerator:</span>
<span class="udiff-line-added">+         case CreateAsyncGenerator:</span>
          case GetButterfly: {
              fixEdge&lt;CellUse&gt;(node-&gt;child1());
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1663,12 +1756,15 @@</span>
                  fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
              }
              break;
          }
  
<span class="udiff-line-modified-removed">-         case CheckStringIdent: {</span>
<span class="udiff-line-modified-removed">-             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-modified-added">+         case CheckIdent: {</span>
<span class="udiff-line-modified-added">+             if (node-&gt;uidOperand()-&gt;isSymbol())</span>
<span class="udiff-line-added">+                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());</span>
              break;
          }
  
          case Arrayify:
          case ArrayifyToStructure: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1741,21 +1837,16 @@</span>
              break;
          }
  
          case HasOwnProperty: {
              fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
<span class="udiff-line-removed">- #if CPU(X86)</span>
<span class="udiff-line-removed">-             // We don&#39;t have enough registers to do anything interesting on x86 and mips.</span>
<span class="udiff-line-removed">-             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());</span>
<span class="udiff-line-removed">- #else</span>
              if (node-&gt;child2()-&gt;shouldSpeculateString())
                  fixEdge&lt;StringUse&gt;(node-&gt;child2());
              else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
                  fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
              else
                  fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
<span class="udiff-line-removed">- #endif</span>
              break;
          }
  
          case CheckVarargs:
          case Check: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1808,19 +1899,24 @@</span>
          case GetPrototypeOf: {
              fixupGetPrototypeOf(node);
              break;
          }
  
<span class="udiff-line-added">+         case CheckNeutered:</span>
<span class="udiff-line-added">+         case CheckArray: {</span>
<span class="udiff-line-added">+             fixEdge&lt;CellUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case Phi:
          case Upsilon:
          case EntrySwitch:
          case GetIndexedPropertyStorage:
          case LastNodeType:
          case CheckTierUpInLoop:
          case CheckTierUpAtReturn:
          case CheckTierUpAndOSREnter:
<span class="udiff-line-removed">-         case CheckArray:</span>
          case CheckInBounds:
          case ConstantStoragePointer:
          case DoubleAsInt32:
          case ValueToInt32:
          case DoubleRep:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1832,10 +1928,11 @@</span>
          case PhantomNewObject:
          case PhantomNewFunction:
          case PhantomNewGeneratorFunction:
          case PhantomNewAsyncGeneratorFunction:
          case PhantomNewAsyncFunction:
<span class="udiff-line-added">+         case PhantomNewArrayIterator:</span>
          case PhantomCreateActivation:
          case PhantomDirectArguments:
          case PhantomCreateRest:
          case PhantomSpread:
          case PhantomNewArrayWithSpread:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1846,12 +1943,14 @@</span>
          case GetMyArgumentByValOutOfBounds:
          case GetVectorLength:
          case PutHint:
          case CheckStructureImmediate:
          case CheckStructureOrEmpty:
<span class="udiff-line-added">+         case CheckArrayOrEmpty:</span>
          case MaterializeNewObject:
          case MaterializeCreateActivation:
<span class="udiff-line-added">+         case MaterializeNewInternalFieldObject:</span>
          case PutStack:
          case KillStack:
          case GetStack:
          case StoreBarrier:
          case FencedStoreBarrier:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2312,10 +2411,15 @@</span>
  
          case SetCallee:
              fixEdge&lt;CellUse&gt;(node-&gt;child1());
              break;
  
<span class="udiff-line-added">+         case DateGetInt32OrNaN:</span>
<span class="udiff-line-added">+         case DateGetTime:</span>
<span class="udiff-line-added">+             fixEdge&lt;DateObjectUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+ </span>
          case DataViewGetInt:
          case DataViewGetFloat: {
              fixEdge&lt;DataViewObjectUse&gt;(node-&gt;child1());
              fixEdge&lt;Int32Use&gt;(node-&gt;child2());
              if (node-&gt;child3())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2366,11 +2470,17 @@</span>
                  }
              }
              break;
          }
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+         case ForwardVarargs:</span>
<span class="udiff-line-added">+         case LoadVarargs: {</span>
<span class="udiff-line-added">+             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if ASSERT_ENABLED</span>
          // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
          case SetArgumentDefinitely:
          case SetArgumentMaybe:
          case JSConstant:
          case LazyJSConstant:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2398,14 +2508,17 @@</span>
          case ConstructVarargs:
          case CallForwardVarargs:
          case ConstructForwardVarargs:
          case TailCallForwardVarargs:
          case TailCallForwardVarargsInlinedCaller:
<span class="udiff-line-modified-removed">-         case LoadVarargs:</span>
<span class="udiff-line-removed">-         case ForwardVarargs:</span>
<span class="udiff-line-modified-added">+         case VarargsLength:</span>
          case ProfileControlFlow:
          case NewObject:
<span class="udiff-line-added">+         case NewPromise:</span>
<span class="udiff-line-added">+         case NewGenerator:</span>
<span class="udiff-line-added">+         case NewAsyncGenerator:</span>
<span class="udiff-line-added">+         case NewArrayIterator:</span>
          case NewRegexp:
          case DeleteById:
          case DeleteByVal:
          case IsTypedArrayView:
          case IsEmpty:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2448,19 +2561,20 @@</span>
          case NumberToStringWithValidRadixConstant:
          case GetGlobalThis:
          case ExtractValueFromWeakMapGet:
          case CPUIntrinsic:
          case FilterCallLinkStatus:
<span class="udiff-line-modified-removed">-         case FilterGetByIdStatus:</span>
<span class="udiff-line-modified-added">+         case FilterGetByStatus:</span>
          case FilterPutByIdStatus:
          case FilterInByIdStatus:
          case InvalidationPoint:
<span class="udiff-line-added">+         case CreateArgumentsButterfly:</span>
              break;
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-modified-added">+ #else // not ASSERT_ENABLED</span>
          default:
              break;
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // not ASSERT_ENABLED</span>
          }
      }
  
      void watchHavingABadTime(Node* node)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2572,65 +2686,68 @@</span>
          }
      }
  
      void fixupIsCellWithType(Node* node)
      {
<span class="udiff-line-modified-removed">-         switch (node-&gt;speculatedTypeForQuery()) {</span>
<span class="udiff-line-modified-removed">-         case SpecString:</span>
<span class="udiff-line-modified-removed">-             if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="udiff-line-modified-removed">-                 m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-removed">-                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-removed">-                     Edge(node-&gt;child1().node(), StringUse));</span>
<span class="udiff-line-modified-removed">-                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-removed">-                 observeUseKindOnNode&lt;StringUse&gt;(node);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+         Optional&lt;SpeculatedType&gt; filter = node-&gt;speculatedTypeForQuery();</span>
<span class="udiff-line-modified-added">+         if (filter) {</span>
<span class="udiff-line-modified-added">+             switch (filter.value()) {</span>
<span class="udiff-line-modified-added">+             case SpecString:</span>
<span class="udiff-line-modified-added">+                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="udiff-line-modified-added">+                     m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-added">+                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-added">+                         Edge(node-&gt;child1().node(), StringUse));</span>
<span class="udiff-line-modified-added">+                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-added">+                     observeUseKindOnNode&lt;StringUse&gt;(node);</span>
<span class="udiff-line-modified-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
  
<span class="udiff-line-modified-removed">-         case SpecProxyObject:</span>
<span class="udiff-line-modified-removed">-             if (node-&gt;child1()-&gt;shouldSpeculateProxyObject()) {</span>
<span class="udiff-line-modified-removed">-                 m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-removed">-                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-removed">-                     Edge(node-&gt;child1().node(), ProxyObjectUse));</span>
<span class="udiff-line-modified-removed">-                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-removed">-                 observeUseKindOnNode&lt;ProxyObjectUse&gt;(node);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             case SpecProxyObject:</span>
<span class="udiff-line-modified-added">+                 if (node-&gt;child1()-&gt;shouldSpeculateProxyObject()) {</span>
<span class="udiff-line-modified-added">+                     m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-added">+                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-added">+                         Edge(node-&gt;child1().node(), ProxyObjectUse));</span>
<span class="udiff-line-modified-added">+                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-added">+                     observeUseKindOnNode&lt;ProxyObjectUse&gt;(node);</span>
<span class="udiff-line-modified-added">+                     return;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+                 break;</span>
  
<span class="udiff-line-modified-removed">-         case SpecRegExpObject:</span>
<span class="udiff-line-modified-removed">-             if (node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {</span>
<span class="udiff-line-modified-removed">-                 m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-removed">-                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-removed">-                     Edge(node-&gt;child1().node(), RegExpObjectUse));</span>
<span class="udiff-line-modified-removed">-                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-removed">-                 observeUseKindOnNode&lt;RegExpObjectUse&gt;(node);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             case SpecRegExpObject:</span>
<span class="udiff-line-modified-added">+                 if (node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {</span>
<span class="udiff-line-modified-added">+                     m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-added">+                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-added">+                         Edge(node-&gt;child1().node(), RegExpObjectUse));</span>
<span class="udiff-line-modified-added">+                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-added">+                     observeUseKindOnNode&lt;RegExpObjectUse&gt;(node);</span>
<span class="udiff-line-modified-added">+                     return;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+                 break;</span>
  
<span class="udiff-line-modified-removed">-         case SpecArray:</span>
<span class="udiff-line-modified-removed">-             if (node-&gt;child1()-&gt;shouldSpeculateArray()) {</span>
<span class="udiff-line-modified-removed">-                 m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-removed">-                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-removed">-                     Edge(node-&gt;child1().node(), ArrayUse));</span>
<span class="udiff-line-modified-removed">-                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-removed">-                 observeUseKindOnNode&lt;ArrayUse&gt;(node);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-removed">-             }</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-added">+             case SpecArray:</span>
<span class="udiff-line-modified-added">+                 if (node-&gt;child1()-&gt;shouldSpeculateArray()) {</span>
<span class="udiff-line-modified-added">+                     m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-added">+                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-added">+                         Edge(node-&gt;child1().node(), ArrayUse));</span>
<span class="udiff-line-modified-added">+                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-added">+                     observeUseKindOnNode&lt;ArrayUse&gt;(node);</span>
<span class="udiff-line-modified-added">+                     return;</span>
<span class="udiff-line-modified-added">+                 }</span>
<span class="udiff-line-modified-added">+                 break;</span>
  
<span class="udiff-line-modified-removed">-         case SpecDerivedArray:</span>
<span class="udiff-line-modified-removed">-             if (node-&gt;child1()-&gt;shouldSpeculateDerivedArray()) {</span>
<span class="udiff-line-modified-removed">-                 m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-removed">-                     m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-removed">-                     Edge(node-&gt;child1().node(), DerivedArrayUse));</span>
<span class="udiff-line-modified-removed">-                 m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-removed">-                 observeUseKindOnNode&lt;DerivedArrayUse&gt;(node);</span>
<span class="udiff-line-modified-removed">-                 return;</span>
<span class="udiff-line-modified-added">+             case SpecDerivedArray:</span>
<span class="udiff-line-modified-added">+                 if (node-&gt;child1()-&gt;shouldSpeculateDerivedArray()) {</span>
<span class="udiff-line-modified-added">+                     m_insertionSet.insertNode(</span>
<span class="udiff-line-modified-added">+                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="udiff-line-modified-added">+                         Edge(node-&gt;child1().node(), DerivedArrayUse));</span>
<span class="udiff-line-modified-added">+                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="udiff-line-modified-added">+                     observeUseKindOnNode&lt;DerivedArrayUse&gt;(node);</span>
<span class="udiff-line-modified-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 break;</span>
              }
<span class="udiff-line-removed">-             break;</span>
          }
  
          if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
              fixEdge&lt;CellUse&gt;(node-&gt;child1());
              return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2816,10 +2933,22 @@</span>
              node-&gt;convertToToString();
              return;
          }
      }
  
<span class="udiff-line-added">+     void fixupToNumeric(Node* node)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         // If the prediction of the child is BigInt, we attempt to convert ToNumeric to Identity, since it can only return a BigInt when fed a BigInt.</span>
<span class="udiff-line-added">+         if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {</span>
<span class="udiff-line-added">+             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="udiff-line-added">+             node-&gt;convertToIdentity();</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         fixupToNumber(node);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      void fixupToNumber(Node* node)
      {
          // At first, attempt to fold Boolean or Int32 to Int32.
          if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()) {
              if (isInt32Speculation(node-&gt;getHeapPrediction())) {
</pre>
<center><a href="DFGEpoch.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGForAllKills.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  * 1.  Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  * 2.  Redistributions in binary form must reproduce the above copyright
  11  *     notice, this list of conditions and the following disclaimer in the
  12  *     documentation and/or other materials provided with the distribution.
  13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  14  *     its contributors may be used to endorse or promote products derived
  15  *     from this software without specific prior written permission.
  16  *
  17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;VM.h&quot;
  31 
  32 #include &quot;ArgList.h&quot;
  33 #include &quot;BigIntObject.h&quot;
  34 #include &quot;BooleanObject.h&quot;
  35 #include &quot;BuiltinExecutables.h&quot;
  36 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  37 #include &quot;CheckpointOSRExitSideState.h&quot;
  38 #include &quot;ClonedArguments.h&quot;
  39 #include &quot;CodeBlock.h&quot;
  40 #include &quot;CodeCache.h&quot;
  41 #include &quot;CommonIdentifiers.h&quot;
  42 #include &quot;CommonSlowPaths.h&quot;
  43 #include &quot;CustomGetterSetter.h&quot;
  44 #include &quot;DFGWorklist.h&quot;
  45 #include &quot;DOMAttributeGetterSetter.h&quot;
  46 #include &quot;DateInstance.h&quot;
  47 #include &quot;DebuggerScope.h&quot;
  48 #include &quot;DirectEvalExecutable.h&quot;
  49 #include &quot;Disassembler.h&quot;
  50 #include &quot;DoublePredictionFuzzerAgent.h&quot;
  51 #include &quot;Error.h&quot;
  52 #include &quot;ErrorConstructor.h&quot;
  53 #include &quot;ErrorInstance.h&quot;
  54 #include &quot;EvalCodeBlock.h&quot;
  55 #include &quot;Exception.h&quot;
  56 #include &quot;ExecutableToCodeBlockEdge.h&quot;
  57 #include &quot;FTLThunks.h&quot;
  58 #include &quot;FastMallocAlignedMemoryAllocator.h&quot;
  59 #include &quot;FileBasedFuzzerAgent.h&quot;
  60 #include &quot;FunctionCodeBlock.h&quot;
  61 #include &quot;FunctionConstructor.h&quot;
  62 #include &quot;FunctionExecutable.h&quot;
  63 #include &quot;GCActivityCallback.h&quot;
  64 #include &quot;GetterSetter.h&quot;
  65 #include &quot;GigacageAlignedMemoryAllocator.h&quot;
  66 #include &quot;HasOwnPropertyCache.h&quot;
  67 #include &quot;Heap.h&quot;
  68 #include &quot;HeapIterationScope.h&quot;
  69 #include &quot;HeapProfiler.h&quot;
  70 #include &quot;HostCallReturnValue.h&quot;
  71 #include &quot;Identifier.h&quot;
  72 #include &quot;IncrementalSweeper.h&quot;
  73 #include &quot;IndirectEvalExecutable.h&quot;
  74 #include &quot;Interpreter.h&quot;
  75 #include &quot;IntlCollatorConstructor.h&quot;
  76 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  77 #include &quot;IntlNumberFormatConstructor.h&quot;
  78 #include &quot;IntlPluralRulesConstructor.h&quot;
  79 #include &quot;IsoHeapCellType.h&quot;
  80 #include &quot;IsoInlinedHeapCellType.h&quot;
  81 #include &quot;JITCode.h&quot;
  82 #include &quot;JITWorklist.h&quot;
  83 #include &quot;JSAPIGlobalObject.h&quot;
  84 #include &quot;JSAPIValueWrapper.h&quot;
  85 #include &quot;JSAPIWrapperObject.h&quot;
  86 #include &quot;JSArray.h&quot;
  87 #include &quot;JSArrayBuffer.h&quot;
  88 #include &quot;JSArrayBufferConstructor.h&quot;
  89 #include &quot;JSArrayIterator.h&quot;
  90 #include &quot;JSAsyncFunction.h&quot;
  91 #include &quot;JSAsyncGenerator.h&quot;
  92 #include &quot;JSBigInt.h&quot;
  93 #include &quot;JSBoundFunction.h&quot;
  94 #include &quot;JSCInlines.h&quot;
  95 #include &quot;JSCallbackConstructor.h&quot;
  96 #include &quot;JSCallbackFunction.h&quot;
  97 #include &quot;JSCallbackObject.h&quot;
  98 #include &quot;JSCallee.h&quot;
  99 #include &quot;JSCustomGetterSetterFunction.h&quot;
 100 #include &quot;JSDestructibleObjectHeapCellType.h&quot;
 101 #include &quot;JSFunction.h&quot;
 102 #include &quot;JSGlobalLexicalEnvironment.h&quot;
 103 #include &quot;JSGlobalObject.h&quot;
 104 #include &quot;JSGlobalObjectFunctions.h&quot;
 105 #include &quot;JSImmutableButterfly.h&quot;
 106 #include &quot;JSInternalPromise.h&quot;
 107 #include &quot;JSLock.h&quot;
 108 #include &quot;JSMap.h&quot;
 109 #include &quot;JSMapIterator.h&quot;
 110 #include &quot;JSModuleNamespaceObject.h&quot;
 111 #include &quot;JSModuleRecord.h&quot;
 112 #include &quot;JSNativeStdFunction.h&quot;
 113 #include &quot;JSPromise.h&quot;
 114 #include &quot;JSPropertyNameEnumerator.h&quot;
 115 #include &quot;JSProxy.h&quot;
 116 #include &quot;JSScriptFetchParameters.h&quot;
 117 #include &quot;JSScriptFetcher.h&quot;
 118 #include &quot;JSSet.h&quot;
 119 #include &quot;JSSetIterator.h&quot;
 120 #include &quot;JSSourceCode.h&quot;
 121 #include &quot;JSStringIterator.h&quot;
 122 #include &quot;JSTemplateObjectDescriptor.h&quot;
 123 #include &quot;JSToWasmICCallee.h&quot;
 124 #include &quot;JSTypedArrays.h&quot;
 125 #include &quot;JSWeakMap.h&quot;
 126 #include &quot;JSWeakObjectRef.h&quot;
 127 #include &quot;JSWeakSet.h&quot;
 128 #include &quot;JSWebAssembly.h&quot;
 129 #include &quot;JSWebAssemblyCodeBlock.h&quot;
 130 #include &quot;JSWebAssemblyGlobal.h&quot;
 131 #include &quot;JSWebAssemblyInstance.h&quot;
 132 #include &quot;JSWebAssemblyMemory.h&quot;
 133 #include &quot;JSWebAssemblyModule.h&quot;
 134 #include &quot;JSWebAssemblyTable.h&quot;
 135 #include &quot;JSWithScope.h&quot;
 136 #include &quot;LLIntData.h&quot;
 137 #include &quot;Lexer.h&quot;
 138 #include &quot;Lookup.h&quot;
 139 #include &quot;MinimumReservedZoneSize.h&quot;
 140 #include &quot;ModuleProgramCodeBlock.h&quot;
 141 #include &quot;ModuleProgramExecutable.h&quot;
 142 #include &quot;NarrowingNumberPredictionFuzzerAgent.h&quot;
 143 #include &quot;NativeErrorConstructor.h&quot;
 144 #include &quot;NativeExecutable.h&quot;
 145 #include &quot;Nodes.h&quot;
 146 #include &quot;NumberObject.h&quot;
 147 #include &quot;Parser.h&quot;
 148 #include &quot;PredictionFileCreatingFuzzerAgent.h&quot;
 149 #include &quot;ProfilerDatabase.h&quot;
 150 #include &quot;ProgramCodeBlock.h&quot;
 151 #include &quot;ProgramExecutable.h&quot;
 152 #include &quot;PromiseTimer.h&quot;
 153 #include &quot;PropertyMapHashTable.h&quot;
 154 #include &quot;ProxyRevoke.h&quot;
 155 #include &quot;RandomizingFuzzerAgent.h&quot;
 156 #include &quot;RegExpCache.h&quot;
 157 #include &quot;RegExpObject.h&quot;
 158 #include &quot;RegisterAtOffsetList.h&quot;
 159 #include &quot;RuntimeType.h&quot;
 160 #include &quot;SamplingProfiler.h&quot;
 161 #include &quot;ScopedArguments.h&quot;
 162 #include &quot;ShadowChicken.h&quot;
 163 #include &quot;SimpleTypedArrayController.h&quot;
 164 #include &quot;SourceProviderCache.h&quot;
 165 #include &quot;StackVisitor.h&quot;
 166 #include &quot;StrictEvalActivation.h&quot;
 167 #include &quot;StringObject.h&quot;
 168 #include &quot;StrongInlines.h&quot;
 169 #include &quot;StructureChain.h&quot;
 170 #include &quot;StructureInlines.h&quot;
 171 #include &quot;SymbolObject.h&quot;
 172 #include &quot;TestRunnerUtils.h&quot;
 173 #include &quot;ThunkGenerators.h&quot;
 174 #include &quot;TypeProfiler.h&quot;
 175 #include &quot;TypeProfilerLog.h&quot;
 176 #include &quot;UnlinkedCodeBlock.h&quot;
 177 #include &quot;VMEntryScope.h&quot;
 178 #include &quot;VMInlines.h&quot;
 179 #include &quot;VMInspector.h&quot;
 180 #include &quot;VariableEnvironment.h&quot;
 181 #include &quot;WasmWorklist.h&quot;
 182 #include &quot;Watchdog.h&quot;
 183 #include &quot;WeakGCMapInlines.h&quot;
 184 #include &quot;WebAssemblyFunction.h&quot;
 185 #include &quot;WebAssemblyModuleRecord.h&quot;
 186 #include &quot;WebAssemblyWrapperFunction.h&quot;
 187 #include &quot;WideningNumberPredictionFuzzerAgent.h&quot;
 188 #include &lt;wtf/ProcessID.h&gt;
 189 #include &lt;wtf/ReadWriteLock.h&gt;
 190 #include &lt;wtf/SimpleStats.h&gt;
 191 #include &lt;wtf/StringPrintStream.h&gt;
 192 #include &lt;wtf/Threading.h&gt;
 193 #include &lt;wtf/text/AtomStringTable.h&gt;
 194 #include &lt;wtf/text/SymbolRegistry.h&gt;
 195 
 196 #if ENABLE(C_LOOP)
 197 #include &quot;CLoopStack.h&quot;
 198 #include &quot;CLoopStackInlines.h&quot;
 199 #endif
 200 
 201 #if ENABLE(DFG_JIT)
 202 #include &quot;ConservativeRoots.h&quot;
 203 #endif
 204 
 205 #if ENABLE(REGEXP_TRACING)
 206 #include &quot;RegExp.h&quot;
 207 #endif
 208 
 209 #if JSC_OBJC_API_ENABLED
 210 #include &quot;ObjCCallbackFunction.h&quot;
 211 #endif
 212 
 213 #ifdef JSC_GLIB_API_ENABLED
 214 #include &quot;JSAPIWrapperGlobalObject.h&quot;
 215 #include &quot;JSCCallbackFunction.h&quot;
 216 #endif
 217 
 218 #if ENABLE(INTL)
 219 #include &quot;IntlCollator.h&quot;
 220 #include &quot;IntlDateTimeFormat.h&quot;
 221 #include &quot;IntlNumberFormat.h&quot;
 222 #include &quot;IntlPluralRules.h&quot;
 223 #endif
 224 
 225 namespace JSC {
 226 
 227 #if ENABLE(JIT)
 228 #if ASSERT_ENABLED
 229 bool VM::s_canUseJITIsSet = false;
 230 #endif
 231 bool VM::s_canUseJIT = false;
 232 #endif
 233 
 234 Atomic&lt;unsigned&gt; VM::s_numberOfIDs;
 235 
 236 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(VM);
 237 
 238 // Note: Platform.h will enforce that ENABLE(ASSEMBLER) is true if either
 239 // ENABLE(JIT) or ENABLE(YARR_JIT) or both are enabled. The code below
 240 // just checks for ENABLE(JIT) or ENABLE(YARR_JIT) with this premise in mind.
 241 
 242 #if ENABLE(ASSEMBLER)
 243 static bool enableAssembler()
 244 {
 245     if (!Options::useJIT())
 246         return false;
 247 
 248     char* canUseJITString = getenv(&quot;JavaScriptCoreUseJIT&quot;);
 249     if (canUseJITString &amp;&amp; !atoi(canUseJITString))
 250         return false;
 251 
 252     ExecutableAllocator::initializeUnderlyingAllocator();
 253     if (!ExecutableAllocator::singleton().isValid()) {
 254         if (Options::crashIfCantAllocateJITMemory())
 255             CRASH();
 256         return false;
 257     }
 258 
 259     return true;
 260 }
 261 #endif // ENABLE(!ASSEMBLER)
 262 
 263 bool VM::canUseAssembler()
 264 {
 265 #if ENABLE(ASSEMBLER)
 266     static std::once_flag onceKey;
 267     static bool enabled = false;
 268     std::call_once(onceKey, [] {
 269         enabled = enableAssembler();
 270     });
 271     return enabled;
 272 #else
 273     return false; // interpreter only
 274 #endif
 275 }
 276 
 277 void VM::computeCanUseJIT()
 278 {
 279 #if ENABLE(JIT)
 280 #if ASSERT_ENABLED
 281     RELEASE_ASSERT(!s_canUseJITIsSet);
 282     s_canUseJITIsSet = true;
 283 #endif
 284     s_canUseJIT = VM::canUseAssembler() &amp;&amp; Options::useJIT();
 285 #endif
 286 }
 287 
 288 inline unsigned VM::nextID()
 289 {
 290     for (;;) {
 291         unsigned currentNumberOfIDs = s_numberOfIDs.load();
 292         unsigned newID = currentNumberOfIDs + 1;
 293         if (s_numberOfIDs.compareExchangeWeak(currentNumberOfIDs, newID))
 294             return newID;
 295     }
 296 }
 297 
 298 static bool vmCreationShouldCrash = false;
 299 
 300 VM::VM(VMType vmType, HeapType heapType)
 301     : m_id(nextID())
 302     , m_apiLock(adoptRef(new JSLock(this)))
 303 #if USE(CF)
 304     , m_runLoop(CFRunLoopGetCurrent())
 305 #endif // USE(CF)
 306     , m_random(Options::seedOfVMRandomForFuzzer() ? Options::seedOfVMRandomForFuzzer() : cryptographicallyRandomNumber())
 307     , m_integrityRandom(*this)
 308     , heap(*this, heapType)
 309     , fastMallocAllocator(makeUnique&lt;FastMallocAlignedMemoryAllocator&gt;())
 310     , primitiveGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::Primitive))
 311     , jsValueGigacageAllocator(makeUnique&lt;GigacageAlignedMemoryAllocator&gt;(Gigacage::JSValue))
 312     , auxiliaryHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::Auxiliary)))
 313     , immutableButterflyHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCellWithInteriorPointers)))
 314     , cellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(DoesNotNeedDestruction, HeapCell::JSCell)))
 315     , destructibleCellHeapCellType(makeUnique&lt;HeapCellType&gt;(CellAttributes(NeedsDestruction, HeapCell::JSCell)))
 316     , apiGlobalObjectHeapCellType(IsoHeapCellType::create&lt;JSAPIGlobalObject&gt;())
 317     , callbackConstructorHeapCellType(IsoHeapCellType::create&lt;JSCallbackConstructor&gt;())
 318     , callbackGlobalObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;())
 319     , callbackObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;())
 320     , dateInstanceHeapCellType(IsoHeapCellType::create&lt;DateInstance&gt;())
 321     , errorInstanceHeapCellType(IsoHeapCellType::create&lt;ErrorInstance&gt;())
 322     , globalLexicalEnvironmentHeapCellType(IsoHeapCellType::create&lt;JSGlobalLexicalEnvironment&gt;())
 323     , globalObjectHeapCellType(IsoHeapCellType::create&lt;JSGlobalObject&gt;())
 324     , jsModuleRecordHeapCellType(IsoHeapCellType::create&lt;JSModuleRecord&gt;())
 325     , moduleNamespaceObjectHeapCellType(IsoHeapCellType::create&lt;JSModuleNamespaceObject&gt;())
 326     , nativeStdFunctionHeapCellType(IsoHeapCellType::create&lt;JSNativeStdFunction&gt;())
 327     , stringHeapCellType(makeUnique&lt;IsoInlinedHeapCellType&lt;JSString&gt;&gt;())
 328     , weakMapHeapCellType(IsoHeapCellType::create&lt;JSWeakMap&gt;())
 329     , weakSetHeapCellType(IsoHeapCellType::create&lt;JSWeakSet&gt;())
 330     , destructibleObjectHeapCellType(makeUnique&lt;JSDestructibleObjectHeapCellType&gt;())
 331 #if JSC_OBJC_API_ENABLED
 332     , apiWrapperObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;())
 333     , objCCallbackFunctionHeapCellType(IsoHeapCellType::create&lt;ObjCCallbackFunction&gt;())
 334 #endif
 335 #ifdef JSC_GLIB_API_ENABLED
 336     , apiWrapperObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;())
 337     , callbackAPIWrapperGlobalObjectHeapCellType(IsoHeapCellType::create&lt;JSCallbackObject&lt;JSAPIWrapperGlobalObject&gt;&gt;())
 338     , jscCallbackFunctionHeapCellType(IsoHeapCellType::create&lt;JSCCallbackFunction&gt;())
 339 #endif
 340 #if ENABLE(INTL)
 341     , intlCollatorHeapCellType(IsoHeapCellType::create&lt;IntlCollator&gt;())
 342     , intlDateTimeFormatHeapCellType(IsoHeapCellType::create&lt;IntlDateTimeFormat&gt;())
 343     , intlNumberFormatHeapCellType(IsoHeapCellType::create&lt;IntlNumberFormat&gt;())
 344     , intlPluralRulesHeapCellType(IsoHeapCellType::create&lt;IntlPluralRules&gt;())
 345 #endif
 346 #if ENABLE(WEBASSEMBLY)
 347     , webAssemblyCodeBlockHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyCodeBlock&gt;())
 348     , webAssemblyFunctionHeapCellType(IsoHeapCellType::create&lt;WebAssemblyFunction&gt;())
 349     , webAssemblyGlobalHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyGlobal&gt;())
 350     , webAssemblyInstanceHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyInstance&gt;())
 351     , webAssemblyMemoryHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyMemory&gt;())
 352     , webAssemblyModuleHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyModule&gt;())
 353     , webAssemblyModuleRecordHeapCellType(IsoHeapCellType::create&lt;WebAssemblyModuleRecord&gt;())
 354     , webAssemblyTableHeapCellType(IsoHeapCellType::create&lt;JSWebAssemblyTable&gt;())
 355 #endif
 356     , primitiveGigacageAuxiliarySpace(&quot;Primitive Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), primitiveGigacageAllocator.get()) // Hash:0x3e7cd762
 357     , jsValueGigacageAuxiliarySpace(&quot;JSValue Gigacage Auxiliary&quot;, heap, auxiliaryHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x241e946
 358     , immutableButterflyJSValueGigacageAuxiliarySpace(&quot;ImmutableButterfly Gigacage JSCellWithInteriorPointers&quot;, heap, immutableButterflyHeapCellType.get(), jsValueGigacageAllocator.get()) // Hash:0x7a945300
 359     , cellSpace(&quot;JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xadfb5a79
 360     , variableSizedCellSpace(&quot;Variable Sized JSCell&quot;, heap, cellHeapCellType.get(), fastMallocAllocator.get()) // Hash:0xbcd769cc
 361     , destructibleObjectSpace(&quot;JSDestructibleObject&quot;, heap, destructibleObjectHeapCellType.get(), fastMallocAllocator.get()) // Hash:0x4f5ed7a9
 362     , bigIntSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), JSBigInt)
 363     , calleeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSCallee)
 364     , clonedArgumentsSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ClonedArguments)
 365     , customGetterSetterSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), CustomGetterSetter)
 366     , dateInstanceSpace ISO_SUBSPACE_INIT(heap, dateInstanceHeapCellType.get(), DateInstance)
 367     , domAttributeGetterSetterSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), DOMAttributeGetterSetter)
 368     , exceptionSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Exception)
 369     , executableToCodeBlockEdgeSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ExecutableToCodeBlockEdge) // Hash:0x7b730b20
 370     , functionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSFunction) // Hash:0x800fca72
 371     , getterSetterSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), GetterSetter)
 372     , globalLexicalEnvironmentSpace ISO_SUBSPACE_INIT(heap, globalLexicalEnvironmentHeapCellType.get(), JSGlobalLexicalEnvironment)
 373     , internalFunctionSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), InternalFunction) // Hash:0xf845c464
 374     , jsProxySpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSProxy)
 375     , nativeExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), NativeExecutable) // Hash:0x67567f95
 376     , numberObjectSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), NumberObject)
 377     , promiseSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSPromise)
 378     , propertyNameEnumeratorSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), JSPropertyNameEnumerator)
 379     , propertyTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), PropertyTable) // Hash:0xc6bc9f12
 380     , regExpSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), RegExp)
 381     , regExpObjectSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), RegExpObject)
 382     , ropeStringSpace ISO_SUBSPACE_INIT(heap, stringHeapCellType.get(), JSRopeString)
 383     , scopedArgumentsSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), ScopedArguments)
 384     , sparseArrayValueMapSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SparseArrayValueMap)
 385     , stringSpace ISO_SUBSPACE_INIT(heap, stringHeapCellType.get(), JSString) // Hash:0x90cf758f
 386     , stringObjectSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), StringObject)
 387     , structureChainSpace ISO_SUBSPACE_INIT(heap, cellHeapCellType.get(), StructureChain)
 388     , structureRareDataSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), StructureRareData) // Hash:0xaca4e62d
 389     , structureSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), Structure) // Hash:0x1f1bcdca
 390     , symbolTableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), SymbolTable) // Hash:0xc5215afd
 391     , executableToCodeBlockEdgesWithConstraints(executableToCodeBlockEdgeSpace)
 392     , executableToCodeBlockEdgesWithFinalizers(executableToCodeBlockEdgeSpace)
 393     , codeBlockSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), CodeBlock) // Hash:0x77e66ec9
 394     , functionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), FunctionExecutable) // Hash:0x5d158f3
 395     , programExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), ProgramExecutable) // Hash:0x527c77e7
 396     , unlinkedFunctionExecutableSpace ISO_SUBSPACE_INIT(heap, destructibleCellHeapCellType.get(), UnlinkedFunctionExecutable) // Hash:0xf6b828d9
 397     , vmType(vmType)
 398     , clientData(0)
 399     , topEntryFrame(nullptr)
 400     , topCallFrame(CallFrame::noCaller())
 401     , promiseTimer(PromiseTimer::create(*this))
 402     , m_atomStringTable(vmType == Default ? Thread::current().atomStringTable() : new AtomStringTable)
 403     , propertyNames(nullptr)
 404     , emptyList(new ArgList)
 405     , machineCodeBytesPerBytecodeWordForBaselineJIT(makeUnique&lt;SimpleStats&gt;())
 406     , customGetterSetterFunctionMap(*this)
 407     , stringCache(*this)
 408     , symbolImplToSymbolMap(*this)
 409     , structureCache(*this)
 410     , interpreter(0)
 411     , entryScope(0)
 412     , m_regExpCache(new RegExpCache(this))
 413     , m_compactVariableMap(adoptRef(*(new CompactVariableMap)))
 414 #if ENABLE(REGEXP_TRACING)
 415     , m_rtTraceList(new RTTraceList())
 416 #endif
 417 #if ENABLE(GC_VALIDATION)
 418     , m_initializingObjectClass(0)
 419 #endif
 420     , m_stackPointerAtVMEntry(0)
 421     , m_codeCache(makeUnique&lt;CodeCache&gt;())
 422     , m_builtinExecutables(makeUnique&lt;BuiltinExecutables&gt;(*this))
 423     , m_typeProfilerEnabledCount(0)
 424     , m_primitiveGigacageEnabled(IsWatched)
 425     , m_controlFlowProfilerEnabledCount(0)
 426 {
 427     if (UNLIKELY(vmCreationShouldCrash))
 428         CRASH_WITH_INFO(0x4242424220202020, 0xbadbeef0badbeef, 0x1234123412341234, 0x1337133713371337);
 429 
 430     interpreter = new Interpreter(*this);
 431     StackBounds stack = Thread::current().stack();
 432     updateSoftReservedZoneSize(Options::softReservedZoneSize());
 433     setLastStackTop(stack.origin());
 434 
 435     JSRunLoopTimer::Manager::shared().registerVM(*this);
 436 
 437     // Need to be careful to keep everything consistent here
 438     JSLockHolder lock(this);
 439     AtomStringTable* existingEntryAtomStringTable = Thread::current().setCurrentAtomStringTable(m_atomStringTable);
 440     structureStructure.set(*this, Structure::createStructure(*this));
 441     structureRareDataStructure.set(*this, StructureRareData::createStructure(*this, 0, jsNull()));
 442     stringStructure.set(*this, JSString::createStructure(*this, 0, jsNull()));
 443 
 444     smallStrings.initializeCommonStrings(*this);
 445 
 446     propertyNames = new CommonIdentifiers(*this);
 447     terminatedExecutionErrorStructure.set(*this, TerminatedExecutionError::createStructure(*this, 0, jsNull()));
 448     propertyNameEnumeratorStructure.set(*this, JSPropertyNameEnumerator::createStructure(*this, 0, jsNull()));
 449     getterSetterStructure.set(*this, GetterSetter::createStructure(*this, 0, jsNull()));
 450     customGetterSetterStructure.set(*this, CustomGetterSetter::createStructure(*this, 0, jsNull()));
 451     domAttributeGetterSetterStructure.set(*this, DOMAttributeGetterSetter::createStructure(*this, 0, jsNull()));
 452     scopedArgumentsTableStructure.set(*this, ScopedArgumentsTable::createStructure(*this, 0, jsNull()));
 453     apiWrapperStructure.set(*this, JSAPIValueWrapper::createStructure(*this, 0, jsNull()));
 454     nativeExecutableStructure.set(*this, NativeExecutable::createStructure(*this, 0, jsNull()));
 455     evalExecutableStructure.set(*this, EvalExecutable::createStructure(*this, 0, jsNull()));
 456     programExecutableStructure.set(*this, ProgramExecutable::createStructure(*this, 0, jsNull()));
 457     functionExecutableStructure.set(*this, FunctionExecutable::createStructure(*this, 0, jsNull()));
 458 #if ENABLE(WEBASSEMBLY)
 459     webAssemblyCodeBlockStructure.set(*this, JSWebAssemblyCodeBlock::createStructure(*this, 0, jsNull()));
 460 #endif
 461     moduleProgramExecutableStructure.set(*this, ModuleProgramExecutable::createStructure(*this, 0, jsNull()));
 462     regExpStructure.set(*this, RegExp::createStructure(*this, 0, jsNull()));
 463     symbolStructure.set(*this, Symbol::createStructure(*this, 0, jsNull()));
 464     symbolTableStructure.set(*this, SymbolTable::createStructure(*this, 0, jsNull()));
 465 
 466     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithInt32) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithInt32));
 467     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithDouble) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithDouble));
 468     immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].set(*this, JSImmutableButterfly::createStructure(*this, 0, jsNull(), CopyOnWriteArrayWithContiguous));
 469 
 470     sourceCodeStructure.set(*this, JSSourceCode::createStructure(*this, 0, jsNull()));
 471     scriptFetcherStructure.set(*this, JSScriptFetcher::createStructure(*this, 0, jsNull()));
 472     scriptFetchParametersStructure.set(*this, JSScriptFetchParameters::createStructure(*this, 0, jsNull()));
 473     structureChainStructure.set(*this, StructureChain::createStructure(*this, 0, jsNull()));
 474     sparseArrayValueMapStructure.set(*this, SparseArrayValueMap::createStructure(*this, 0, jsNull()));
 475     templateObjectDescriptorStructure.set(*this, JSTemplateObjectDescriptor::createStructure(*this, 0, jsNull()));
 476     unlinkedFunctionExecutableStructure.set(*this, UnlinkedFunctionExecutable::createStructure(*this, 0, jsNull()));
 477     unlinkedProgramCodeBlockStructure.set(*this, UnlinkedProgramCodeBlock::createStructure(*this, 0, jsNull()));
 478     unlinkedEvalCodeBlockStructure.set(*this, UnlinkedEvalCodeBlock::createStructure(*this, 0, jsNull()));
 479     unlinkedFunctionCodeBlockStructure.set(*this, UnlinkedFunctionCodeBlock::createStructure(*this, 0, jsNull()));
 480     unlinkedModuleProgramCodeBlockStructure.set(*this, UnlinkedModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 481     propertyTableStructure.set(*this, PropertyTable::createStructure(*this, 0, jsNull()));
 482     functionRareDataStructure.set(*this, FunctionRareData::createStructure(*this, 0, jsNull()));
 483     exceptionStructure.set(*this, Exception::createStructure(*this, 0, jsNull()));
 484     programCodeBlockStructure.set(*this, ProgramCodeBlock::createStructure(*this, 0, jsNull()));
 485     moduleProgramCodeBlockStructure.set(*this, ModuleProgramCodeBlock::createStructure(*this, 0, jsNull()));
 486     evalCodeBlockStructure.set(*this, EvalCodeBlock::createStructure(*this, 0, jsNull()));
 487     functionCodeBlockStructure.set(*this, FunctionCodeBlock::createStructure(*this, 0, jsNull()));
 488     hashMapBucketSetStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKey&gt;::createStructure(*this, 0, jsNull()));
 489     hashMapBucketMapStructure.set(*this, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::createStructure(*this, 0, jsNull()));
 490     bigIntStructure.set(*this, JSBigInt::createStructure(*this, 0, jsNull()));
 491     executableToCodeBlockEdgeStructure.set(*this, ExecutableToCodeBlockEdge::createStructure(*this, nullptr, jsNull()));
 492 
 493     // Eagerly initialize constant cells since the concurrent compiler can access them.
 494     if (canUseJIT()) {
 495         sentinelMapBucket();
 496         sentinelSetBucket();
 497     }
 498     bigIntConstantOne.set(*this, JSBigInt::createFrom(*this, 1));
 499 
 500     Thread::current().setCurrentAtomStringTable(existingEntryAtomStringTable);
 501 
 502 #if !ENABLE(C_LOOP)
 503     initializeHostCallReturnValue(); // This is needed to convince the linker not to drop host call return support.
 504 #endif
 505 
 506     Gigacage::addPrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 507 
 508     heap.notifyIsSafeToCollect();
 509 
 510     LLInt::Data::performAssertions(*this);
 511 
 512     if (UNLIKELY(Options::useProfiler())) {
 513         m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(*this);
 514 
 515         StringPrintStream pathOut;
 516         const char* profilerPath = getenv(&quot;JSC_PROFILER_PATH&quot;);
 517         if (profilerPath)
 518             pathOut.print(profilerPath, &quot;/&quot;);
 519         pathOut.print(&quot;JSCProfile-&quot;, getCurrentProcessID(), &quot;-&quot;, m_perBytecodeProfiler-&gt;databaseID(), &quot;.json&quot;);
 520         m_perBytecodeProfiler-&gt;registerToSaveAtExit(pathOut.toCString().data());
 521     }
 522 
 523     callFrameForCatch = nullptr;
 524 
 525     // Initialize this last, as a free way of asserting that VM initialization itself
 526     // won&#39;t use this.
 527     m_typedArrayController = adoptRef(new SimpleTypedArrayController());
 528 
 529     m_bytecodeIntrinsicRegistry = makeUnique&lt;BytecodeIntrinsicRegistry&gt;(*this);
 530 
 531     if (Options::useTypeProfiler())
 532         enableTypeProfiler();
 533     if (Options::useControlFlowProfiler())
 534         enableControlFlowProfiler();
 535 #if ENABLE(SAMPLING_PROFILER)
 536     if (Options::useSamplingProfiler()) {
 537         setShouldBuildPCToCodeOriginMapping();
 538         Ref&lt;Stopwatch&gt; stopwatch = Stopwatch::create();
 539         stopwatch-&gt;start();
 540         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 541         if (Options::samplingProfilerPath())
 542             m_samplingProfiler-&gt;registerForReportAtExit();
 543         m_samplingProfiler-&gt;start();
 544     }
 545 #endif // ENABLE(SAMPLING_PROFILER)
 546 
 547     if (Options::useRandomizingFuzzerAgent())
 548         setFuzzerAgent(makeUnique&lt;RandomizingFuzzerAgent&gt;(*this));
 549     if (Options::useDoublePredictionFuzzerAgent())
 550         setFuzzerAgent(makeUnique&lt;DoublePredictionFuzzerAgent&gt;(*this));
 551     if (Options::useFileBasedFuzzerAgent())
 552         setFuzzerAgent(makeUnique&lt;FileBasedFuzzerAgent&gt;(*this));
 553     if (Options::usePredictionFileCreatingFuzzerAgent())
 554         setFuzzerAgent(makeUnique&lt;PredictionFileCreatingFuzzerAgent&gt;(*this));
 555     if (Options::useNarrowingNumberPredictionFuzzerAgent())
 556         setFuzzerAgent(makeUnique&lt;NarrowingNumberPredictionFuzzerAgent&gt;(*this));
 557     if (Options::useWideningNumberPredictionFuzzerAgent())
 558         setFuzzerAgent(makeUnique&lt;WideningNumberPredictionFuzzerAgent&gt;(*this));
 559 
 560     if (Options::alwaysGeneratePCToCodeOriginMap())
 561         setShouldBuildPCToCodeOriginMapping();
 562 
 563     if (Options::watchdog()) {
 564         Watchdog&amp; watchdog = ensureWatchdog();
 565         watchdog.setTimeLimit(Seconds::fromMilliseconds(Options::watchdog()));
 566     }
 567 
 568 #if ENABLE(JIT)
 569     // Make sure that any stubs that the JIT is going to use are initialized in non-compilation threads.
 570     if (canUseJIT()) {
 571         jitStubs = makeUnique&lt;JITThunks&gt;();
 572 #if ENABLE(FTL_JIT)
 573         ftlThunks = makeUnique&lt;FTL::Thunks&gt;();
 574 #endif // ENABLE(FTL_JIT)
 575         getCTIInternalFunctionTrampolineFor(CodeForCall);
 576         getCTIInternalFunctionTrampolineFor(CodeForConstruct);
 577     }
 578 #endif
 579 
 580     if (Options::forceDebuggerBytecodeGeneration() || Options::alwaysUseShadowChicken())
 581         ensureShadowChicken();
 582 
 583     VMInspector::instance().add(this);
 584 
 585     if (!g_jscConfig.disabledFreezingForTesting)
 586         Config::permanentlyFreeze();
 587 }
 588 
 589 static ReadWriteLock s_destructionLock;
 590 
 591 void waitForVMDestruction()
 592 {
 593     auto locker = holdLock(s_destructionLock.write());
 594 }
 595 
 596 VM::~VM()
 597 {
 598     auto destructionLocker = holdLock(s_destructionLock.read());
 599 
 600     Gigacage::removePrimitiveDisableCallback(primitiveGigacageDisabledCallback, this);
 601     promiseTimer-&gt;stopRunningTasks();
 602 #if ENABLE(WEBASSEMBLY)
 603     if (Wasm::Worklist* worklist = Wasm::existingWorklistOrNull())
 604         worklist-&gt;stopAllPlansForContext(wasmContext);
 605 #endif
 606     if (UNLIKELY(m_watchdog))
 607         m_watchdog-&gt;willDestroyVM(this);
 608     m_traps.willDestroyVM();
 609     VMInspector::instance().remove(this);
 610 
 611     // Never GC, ever again.
 612     heap.incrementDeferralDepth();
 613 
 614 #if ENABLE(SAMPLING_PROFILER)
 615     if (m_samplingProfiler) {
 616         m_samplingProfiler-&gt;reportDataToOptionFile();
 617         m_samplingProfiler-&gt;shutdown();
 618     }
 619 #endif // ENABLE(SAMPLING_PROFILER)
 620 
 621 #if ENABLE(JIT)
 622     if (JITWorklist* worklist = JITWorklist::existingGlobalWorklistOrNull())
 623         worklist-&gt;completeAllForVM(*this);
 624 #endif // ENABLE(JIT)
 625 
 626 #if ENABLE(DFG_JIT)
 627     // Make sure concurrent compilations are done, but don&#39;t install them, since there is
 628     // no point to doing so.
 629     for (unsigned i = DFG::numberOfWorklists(); i--;) {
 630         if (DFG::Worklist* worklist = DFG::existingWorklistForIndexOrNull(i)) {
 631             worklist-&gt;removeNonCompilingPlansForVM(*this);
 632             worklist-&gt;waitUntilAllPlansForVMAreReady(*this);
 633             worklist-&gt;removeAllReadyPlansForVM(*this);
 634         }
 635     }
 636 #endif // ENABLE(DFG_JIT)
 637 
 638     waitForAsynchronousDisassembly();
 639 
 640     // Clear this first to ensure that nobody tries to remove themselves from it.
 641     m_perBytecodeProfiler = nullptr;
 642 
 643     ASSERT(currentThreadIsHoldingAPILock());
 644     m_apiLock-&gt;willDestroyVM(this);
 645     smallStrings.setIsInitialized(false);
 646     heap.lastChanceToFinalize();
 647 
 648     JSRunLoopTimer::Manager::shared().unregisterVM(*this);
 649 
 650     delete interpreter;
 651 #ifndef NDEBUG
 652     interpreter = reinterpret_cast&lt;Interpreter*&gt;(0xbbadbeef);
 653 #endif
 654 
 655     delete emptyList;
 656 
 657     delete propertyNames;
 658     if (vmType != Default)
 659         delete m_atomStringTable;
 660 
 661     delete clientData;
 662     delete m_regExpCache;
 663 
 664 #if ENABLE(REGEXP_TRACING)
 665     delete m_rtTraceList;
 666 #endif
 667 
 668 #if ENABLE(DFG_JIT)
 669     for (unsigned i = 0; i &lt; m_scratchBuffers.size(); ++i)
 670         VMMalloc::free(m_scratchBuffers[i]);
 671 #endif
 672 }
 673 
 674 void VM::primitiveGigacageDisabledCallback(void* argument)
 675 {
 676     static_cast&lt;VM*&gt;(argument)-&gt;primitiveGigacageDisabled();
 677 }
 678 
 679 void VM::primitiveGigacageDisabled()
 680 {
 681     if (m_apiLock-&gt;currentThreadIsHoldingLock()) {
 682         m_primitiveGigacageEnabled.fireAll(*this, &quot;Primitive gigacage disabled&quot;);
 683         return;
 684     }
 685 
 686     // This is totally racy, and that&#39;s OK. The point is, it&#39;s up to the user to ensure that they pass the
 687     // uncaged buffer in a nicely synchronized manner.
 688     m_needToFirePrimitiveGigacageEnabled = true;
 689 }
 690 
 691 void VM::setLastStackTop(void* lastStackTop)
 692 {
 693     m_lastStackTop = lastStackTop;
 694 }
 695 
 696 Ref&lt;VM&gt; VM::createContextGroup(HeapType heapType)
 697 {
 698     return adoptRef(*new VM(APIContextGroup, heapType));
 699 }
 700 
 701 Ref&lt;VM&gt; VM::create(HeapType heapType)
 702 {
 703     return adoptRef(*new VM(Default, heapType));
 704 }
 705 
 706 bool VM::sharedInstanceExists()
 707 {
 708     return sharedInstanceInternal();
 709 }
 710 
 711 VM&amp; VM::sharedInstance()
 712 {
 713     GlobalJSLock globalLock;
 714     VM*&amp; instance = sharedInstanceInternal();
 715     if (!instance)
 716         instance = adoptRef(new VM(APIShared, SmallHeap)).leakRef();
 717     return *instance;
 718 }
 719 
 720 VM*&amp; VM::sharedInstanceInternal()
 721 {
 722     static VM* sharedInstance;
 723     return sharedInstance;
 724 }
 725 
 726 Watchdog&amp; VM::ensureWatchdog()
 727 {
 728     if (!m_watchdog)
 729         m_watchdog = adoptRef(new Watchdog(this));
 730     return *m_watchdog;
 731 }
 732 
 733 HeapProfiler&amp; VM::ensureHeapProfiler()
 734 {
 735     if (!m_heapProfiler)
 736         m_heapProfiler = makeUnique&lt;HeapProfiler&gt;(*this);
 737     return *m_heapProfiler;
 738 }
 739 
 740 #if ENABLE(SAMPLING_PROFILER)
 741 SamplingProfiler&amp; VM::ensureSamplingProfiler(RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 742 {
 743     if (!m_samplingProfiler)
 744         m_samplingProfiler = adoptRef(new SamplingProfiler(*this, WTFMove(stopwatch)));
 745     return *m_samplingProfiler;
 746 }
 747 #endif // ENABLE(SAMPLING_PROFILER)
 748 
 749 #if ENABLE(JIT)
 750 static ThunkGenerator thunkGeneratorForIntrinsic(Intrinsic intrinsic)
 751 {
 752     switch (intrinsic) {
 753     case CharCodeAtIntrinsic:
 754         return charCodeAtThunkGenerator;
 755     case CharAtIntrinsic:
 756         return charAtThunkGenerator;
 757     case StringPrototypeCodePointAtIntrinsic:
 758         return stringPrototypeCodePointAtThunkGenerator;
 759     case Clz32Intrinsic:
 760         return clz32ThunkGenerator;
 761     case FromCharCodeIntrinsic:
 762         return fromCharCodeThunkGenerator;
 763     case SqrtIntrinsic:
 764         return sqrtThunkGenerator;
 765     case AbsIntrinsic:
 766         return absThunkGenerator;
 767     case FloorIntrinsic:
 768         return floorThunkGenerator;
 769     case CeilIntrinsic:
 770         return ceilThunkGenerator;
 771     case TruncIntrinsic:
 772         return truncThunkGenerator;
 773     case RoundIntrinsic:
 774         return roundThunkGenerator;
 775     case ExpIntrinsic:
 776         return expThunkGenerator;
 777     case LogIntrinsic:
 778         return logThunkGenerator;
 779     case IMulIntrinsic:
 780         return imulThunkGenerator;
 781     case RandomIntrinsic:
 782         return randomThunkGenerator;
 783     case BoundFunctionCallIntrinsic:
 784         return boundFunctionCallGenerator;
 785     default:
 786         return nullptr;
 787     }
 788 }
 789 
 790 #endif // ENABLE(JIT)
 791 
 792 NativeExecutable* VM::getHostFunction(NativeFunction function, NativeFunction constructor, const String&amp; name)
 793 {
 794     return getHostFunction(function, NoIntrinsic, constructor, nullptr, name);
 795 }
 796 
 797 static Ref&lt;NativeJITCode&gt; jitCodeForCallTrampoline()
 798 {
 799     static NativeJITCode* result;
 800     static std::once_flag onceKey;
 801     std::call_once(onceKey, [&amp;] {
 802         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_call_trampoline), JITType::HostCallThunk, NoIntrinsic);
 803     });
 804     return makeRef(*result);
 805 }
 806 
 807 static Ref&lt;NativeJITCode&gt; jitCodeForConstructTrampoline()
 808 {
 809     static NativeJITCode* result;
 810     static std::once_flag onceKey;
 811     std::call_once(onceKey, [&amp;] {
 812         result = new NativeJITCode(LLInt::getCodeRef&lt;JSEntryPtrTag&gt;(llint_native_construct_trampoline), JITType::HostCallThunk, NoIntrinsic);
 813     });
 814     return makeRef(*result);
 815 }
 816 
 817 NativeExecutable* VM::getHostFunction(NativeFunction function, Intrinsic intrinsic, NativeFunction constructor, const DOMJIT::Signature* signature, const String&amp; name)
 818 {
 819 #if ENABLE(JIT)
 820     if (canUseJIT()) {
 821         return jitStubs-&gt;hostFunctionStub(
 822             *this, function, constructor,
 823             intrinsic != NoIntrinsic ? thunkGeneratorForIntrinsic(intrinsic) : 0,
 824             intrinsic, signature, name);
 825     }
 826 #endif // ENABLE(JIT)
 827     UNUSED_PARAM(intrinsic);
 828     UNUSED_PARAM(signature);
 829     return NativeExecutable::create(*this, jitCodeForCallTrampoline(), function, jitCodeForConstructTrampoline(), constructor, name);
 830 }
 831 
 832 NativeExecutable* VM::getBoundFunction(bool isJSFunction, bool canConstruct)
 833 {
 834     bool slowCase = !isJSFunction;
 835 
 836     auto getOrCreate = [&amp;] (Weak&lt;NativeExecutable&gt;&amp; slot) -&gt; NativeExecutable* {
 837         if (auto* cached = slot.get())
 838             return cached;
 839         NativeExecutable* result = getHostFunction(
 840             slowCase ? boundFunctionCall : boundThisNoArgsFunctionCall,
 841             slowCase ? NoIntrinsic : BoundFunctionCallIntrinsic,
 842             canConstruct ? (slowCase ? boundFunctionConstruct : boundThisNoArgsFunctionConstruct) : callHostFunctionAsConstructor, nullptr, String());
 843         slot = Weak&lt;NativeExecutable&gt;(result);
 844         return result;
 845     };
 846 
 847     if (slowCase) {
 848         if (canConstruct)
 849             return getOrCreate(m_slowCanConstructBoundExecutable);
 850         return getOrCreate(m_slowBoundExecutable);
 851     }
 852     if (canConstruct)
 853         return getOrCreate(m_fastCanConstructBoundExecutable);
 854     return getOrCreate(m_fastBoundExecutable);
 855 }
 856 
 857 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; VM::getCTIInternalFunctionTrampolineFor(CodeSpecializationKind kind)
 858 {
 859 #if ENABLE(JIT)
 860     if (canUseJIT()) {
 861         if (kind == CodeForCall)
 862             return jitStubs-&gt;ctiInternalFunctionCall(*this).retagged&lt;JSEntryPtrTag&gt;();
 863         return jitStubs-&gt;ctiInternalFunctionConstruct(*this).retagged&lt;JSEntryPtrTag&gt;();
 864     }
 865 #endif
 866     if (kind == CodeForCall)
 867         return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_call_trampoline);
 868     return LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_internal_function_construct_trampoline);
 869 }
 870 
 871 VM::ClientData::~ClientData()
 872 {
 873 }
 874 
 875 void VM::resetDateCache()
 876 {
 877     utcTimeOffsetCache.reset();
 878     localTimeOffsetCache.reset();
 879     cachedDateString = String();
 880     cachedDateStringValue = std::numeric_limits&lt;double&gt;::quiet_NaN();
 881     dateInstanceCache.reset();
 882 }
 883 
 884 void VM::whenIdle(Function&lt;void()&gt;&amp;&amp; callback)
 885 {
 886     if (!entryScope) {
 887         callback();
 888         return;
 889     }
 890 
 891     entryScope-&gt;addDidPopListener(WTFMove(callback));
 892 }
 893 
 894 void VM::deleteAllLinkedCode(DeleteAllCodeEffort effort)
 895 {
 896     whenIdle([=] () {
 897         heap.deleteAllCodeBlocks(effort);
 898     });
 899 }
 900 
 901 void VM::deleteAllCode(DeleteAllCodeEffort effort)
 902 {
 903     whenIdle([=] () {
 904         m_codeCache-&gt;clear();
 905         m_regExpCache-&gt;deleteAllCode();
 906         heap.deleteAllCodeBlocks(effort);
 907         heap.deleteAllUnlinkedCodeBlocks(effort);
 908         heap.reportAbandonedObjectGraph();
 909     });
 910 }
 911 
 912 void VM::shrinkFootprintWhenIdle()
 913 {
 914     whenIdle([=] () {
 915         sanitizeStackForVM(*this);
 916         deleteAllCode(DeleteAllCodeIfNotCollecting);
 917         heap.collectNow(Synchronousness::Sync, CollectionScope::Full);
 918         // FIXME: Consider stopping various automatic threads here.
 919         // https://bugs.webkit.org/show_bug.cgi?id=185447
 920         WTF::releaseFastMallocFreeMemory();
 921     });
 922 }
 923 
 924 SourceProviderCache* VM::addSourceProviderCache(SourceProvider* sourceProvider)
 925 {
 926     auto addResult = sourceProviderCacheMap.add(sourceProvider, nullptr);
 927     if (addResult.isNewEntry)
 928         addResult.iterator-&gt;value = adoptRef(new SourceProviderCache);
 929     return addResult.iterator-&gt;value.get();
 930 }
 931 
 932 void VM::clearSourceProviderCaches()
 933 {
 934     sourceProviderCacheMap.clear();
 935 }
 936 
 937 Exception* VM::throwException(JSGlobalObject* globalObject, Exception* exception)
 938 {
 939     CallFrame* throwOriginFrame = topJSCallFrame();
 940     if (!throwOriginFrame)
 941         throwOriginFrame = globalObject-&gt;deprecatedCallFrameForDebugger();
 942 
 943     if (UNLIKELY(Options::breakOnThrow())) {
 944         CodeBlock* codeBlock = throwOriginFrame ? throwOriginFrame-&gt;codeBlock() : nullptr;
 945         dataLog(&quot;Throwing exception in call frame &quot;, RawPointer(throwOriginFrame), &quot; for code block &quot;, codeBlock, &quot;\n&quot;);
 946         CRASH();
 947     }
 948 
 949     interpreter-&gt;notifyDebuggerOfExceptionToBeThrown(*this, globalObject, throwOriginFrame, exception);
 950 
 951     setException(exception);
 952 
 953 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
 954     m_nativeStackTraceOfLastThrow = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
 955     m_throwingThread = &amp;Thread::current();
 956 #endif
 957     return exception;
 958 }
 959 
 960 Exception* VM::throwException(JSGlobalObject* globalObject, JSValue thrownValue)
 961 {
 962     VM&amp; vm = *this;
 963     Exception* exception = jsDynamicCast&lt;Exception*&gt;(vm, thrownValue);
 964     if (!exception)
 965         exception = Exception::create(*this, thrownValue);
 966 
 967     return throwException(globalObject, exception);
 968 }
 969 
 970 Exception* VM::throwException(JSGlobalObject* globalObject, JSObject* error)
 971 {
 972     return throwException(globalObject, JSValue(error));
 973 }
 974 
 975 void VM::setStackPointerAtVMEntry(void* sp)
 976 {
 977     m_stackPointerAtVMEntry = sp;
 978     updateStackLimits();
 979 }
 980 
 981 size_t VM::updateSoftReservedZoneSize(size_t softReservedZoneSize)
 982 {
 983     size_t oldSoftReservedZoneSize = m_currentSoftReservedZoneSize;
 984     m_currentSoftReservedZoneSize = softReservedZoneSize;
 985 #if ENABLE(C_LOOP)
 986     interpreter-&gt;cloopStack().setSoftReservedZoneSize(softReservedZoneSize);
 987 #endif
 988 
 989     updateStackLimits();
 990 
 991     return oldSoftReservedZoneSize;
 992 }
 993 
 994 #if OS(WINDOWS)
 995 // On Windows the reserved stack space consists of committed memory, a guard page, and uncommitted memory,
 996 // where the guard page is a barrier between committed and uncommitted memory.
 997 // When data from the guard page is read or written, the guard page is moved, and memory is committed.
 998 // This is how the system grows the stack.
 999 // When using the C stack on Windows we need to precommit the needed stack space.
1000 // Otherwise we might crash later if we access uncommitted stack memory.
1001 // This can happen if we allocate stack space larger than the page guard size (4K).
1002 // The system does not get the chance to move the guard page, and commit more memory,
1003 // and we crash if uncommitted memory is accessed.
1004 // The MSVC compiler fixes this by inserting a call to the _chkstk() function,
1005 // when needed, see http://support.microsoft.com/kb/100775.
1006 // By touching every page up to the stack limit with a dummy operation,
1007 // we force the system to move the guard page, and commit memory.
1008 
1009 static void preCommitStackMemory(void* stackLimit)
1010 {
1011     const int pageSize = 4096;
1012     for (volatile char* p = reinterpret_cast&lt;char*&gt;(&amp;stackLimit); p &gt; stackLimit; p -= pageSize) {
1013         char ch = *p;
1014         *p = ch;
1015     }
1016 }
1017 #endif
1018 
1019 void VM::updateStackLimits()
1020 {
1021 #if OS(WINDOWS)
1022     void* lastSoftStackLimit = m_softStackLimit;
1023 #endif
1024 
1025     const StackBounds&amp; stack = Thread::current().stack();
1026     size_t reservedZoneSize = Options::reservedZoneSize();
1027     // We should have already ensured that Options::reservedZoneSize() &gt;= minimumReserveZoneSize at
1028     // options initialization time, and the option value should not have been changed thereafter.
1029     // We don&#39;t have the ability to assert here that it hasn&#39;t changed, but we can at least assert
1030     // that the value is sane.
1031     RELEASE_ASSERT(reservedZoneSize &gt;= minimumReservedZoneSize);
1032 
1033     if (m_stackPointerAtVMEntry) {
1034         char* startOfStack = reinterpret_cast&lt;char*&gt;(m_stackPointerAtVMEntry);
1035         m_softStackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), m_currentSoftReservedZoneSize);
1036         m_stackLimit = stack.recursionLimit(startOfStack, Options::maxPerThreadStackUsage(), reservedZoneSize);
1037     } else {
1038         m_softStackLimit = stack.recursionLimit(m_currentSoftReservedZoneSize);
1039         m_stackLimit = stack.recursionLimit(reservedZoneSize);
1040     }
1041 
1042 #if OS(WINDOWS)
1043     // We only need to precommit stack memory dictated by the VM::m_softStackLimit limit.
1044     // This is because VM::m_softStackLimit applies to stack usage by LLINT asm or JIT
1045     // generated code which can allocate stack space that the C++ compiler does not know
1046     // about. As such, we have to precommit that stack memory manually.
1047     //
1048     // In contrast, we do not need to worry about VM::m_stackLimit because that limit is
1049     // used exclusively by C++ code, and the C++ compiler will automatically commit the
1050     // needed stack pages.
1051     if (lastSoftStackLimit != m_softStackLimit)
1052         preCommitStackMemory(m_softStackLimit);
1053 #endif
1054 }
1055 
1056 #if ENABLE(DFG_JIT)
1057 void VM::gatherScratchBufferRoots(ConservativeRoots&amp; conservativeRoots)
1058 {
1059     auto lock = holdLock(m_scratchBufferLock);
1060     for (auto* scratchBuffer : m_scratchBuffers) {
1061         if (scratchBuffer-&gt;activeLength()) {
1062             void* bufferStart = scratchBuffer-&gt;dataBuffer();
1063             conservativeRoots.add(bufferStart, static_cast&lt;void*&gt;(static_cast&lt;char*&gt;(bufferStart) + scratchBuffer-&gt;activeLength()));
1064         }
1065     }
1066 }
1067 
1068 void VM::scanSideState(ConservativeRoots&amp; roots) const
1069 {
1070     ASSERT(heap.worldIsStopped());
1071     for (const auto&amp; iter : m_checkpointSideState) {
1072         static_assert(sizeof(iter.value-&gt;tmps) / sizeof(JSValue) == maxNumCheckpointTmps);
1073         roots.add(iter.value-&gt;tmps, iter.value-&gt;tmps + maxNumCheckpointTmps);
1074     }
1075 }
1076 #endif
1077 
1078 void VM::addCheckpointOSRSideState(CallFrame* callFrame, std::unique_ptr&lt;CheckpointOSRExitSideState&gt;&amp;&amp; payload)
1079 {
1080     ASSERT(currentThreadIsHoldingAPILock());
1081     auto addResult = m_checkpointSideState.add(callFrame, WTFMove(payload));
1082     ASSERT_UNUSED(addResult, addResult.isNewEntry);
1083 }
1084 
1085 std::unique_ptr&lt;CheckpointOSRExitSideState&gt; VM::findCheckpointOSRSideState(CallFrame* callFrame)
1086 {
1087     ASSERT(currentThreadIsHoldingAPILock());
1088     auto sideState = m_checkpointSideState.take(callFrame);
1089     return sideState;
1090 }
1091 
1092 void logSanitizeStack(VM&amp; vm)
1093 {
1094     if (Options::verboseSanitizeStack() &amp;&amp; vm.topCallFrame) {
1095         int dummy;
1096         auto&amp; stackBounds = Thread::current().stack();
1097         dataLog(
1098             &quot;Sanitizing stack for VM = &quot;, RawPointer(&amp;vm), &quot; with top call frame at &quot;, RawPointer(vm.topCallFrame),
1099             &quot;, current stack pointer at &quot;, RawPointer(&amp;dummy), &quot;, in &quot;,
1100             pointerDump(vm.topCallFrame-&gt;codeBlock()), &quot;, last code origin = &quot;,
1101             vm.topCallFrame-&gt;codeOrigin(), &quot;, last stack top = &quot;, RawPointer(vm.lastStackTop()), &quot;, in stack range [&quot;, RawPointer(stackBounds.origin()), &quot;, &quot;, RawPointer(stackBounds.end()), &quot;]\n&quot;);
1102     }
1103 }
1104 
1105 #if ENABLE(YARR_JIT_ALL_PARENS_EXPRESSIONS)
1106 char* VM::acquireRegExpPatternContexBuffer()
1107 {
1108     m_regExpPatternContextLock.lock();
1109     ASSERT(m_regExpPatternContextLock.isLocked());
1110     if (!m_regExpPatternContexBuffer)
1111         m_regExpPatternContexBuffer = makeUniqueArray&lt;char&gt;(VM::patternContextBufferSize);
1112     return m_regExpPatternContexBuffer.get();
1113 }
1114 
1115 void VM::releaseRegExpPatternContexBuffer()
1116 {
1117     ASSERT(m_regExpPatternContextLock.isLocked());
1118 
1119     m_regExpPatternContextLock.unlock();
1120 }
1121 #endif
1122 
1123 #if ENABLE(REGEXP_TRACING)
1124 void VM::addRegExpToTrace(RegExp* regExp)
1125 {
1126     gcProtect(regExp);
1127     m_rtTraceList-&gt;add(regExp);
1128 }
1129 
1130 void VM::dumpRegExpTrace()
1131 {
1132     // The first RegExp object is ignored.  It is create by the RegExpPrototype ctor and not used.
1133     RTTraceList::iterator iter = ++m_rtTraceList-&gt;begin();
1134 
1135     if (iter != m_rtTraceList-&gt;end()) {
1136         dataLogF(&quot;\nRegExp Tracing\n&quot;);
1137         dataLogF(&quot;Regular Expression                              8 Bit          16 Bit        match()    Matches    Average\n&quot;);
1138         dataLogF(&quot; &lt;Match only / Match&gt;                         JIT Addr      JIT Address       calls      found   String len\n&quot;);
1139         dataLogF(&quot;----------------------------------------+----------------+----------------+----------+----------+-----------\n&quot;);
1140 
1141         unsigned reCount = 0;
1142 
1143         for (; iter != m_rtTraceList-&gt;end(); ++iter, ++reCount) {
1144             (*iter)-&gt;printTraceData();
1145             gcUnprotect(*iter);
1146         }
1147 
1148         dataLogF(&quot;%d Regular Expressions\n&quot;, reCount);
1149     }
1150 
1151     m_rtTraceList-&gt;clear();
1152 }
1153 #else
1154 void VM::dumpRegExpTrace()
1155 {
1156 }
1157 #endif
1158 
1159 WatchpointSet* VM::ensureWatchpointSetForImpureProperty(UniquedStringImpl* propertyName)
1160 {
1161     auto result = m_impurePropertyWatchpointSets.add(propertyName, nullptr);
1162     if (result.isNewEntry)
1163         result.iterator-&gt;value = adoptRef(new WatchpointSet(IsWatched));
1164     return result.iterator-&gt;value.get();
1165 }
1166 
1167 void VM::addImpureProperty(UniquedStringImpl* propertyName)
1168 {
1169     if (RefPtr&lt;WatchpointSet&gt; watchpointSet = m_impurePropertyWatchpointSets.take(propertyName))
1170         watchpointSet-&gt;fireAll(*this, &quot;Impure property added&quot;);
1171 }
1172 
1173 template&lt;typename Func&gt;
1174 static bool enableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doEnableWork)
1175 {
1176     bool needsToRecompile = false;
1177     if (!counter) {
1178         doEnableWork();
1179         needsToRecompile = true;
1180     }
1181     counter++;
1182 
1183     return needsToRecompile;
1184 }
1185 
1186 template&lt;typename Func&gt;
1187 static bool disableProfilerWithRespectToCount(unsigned&amp; counter, const Func&amp; doDisableWork)
1188 {
1189     RELEASE_ASSERT(counter &gt; 0);
1190     bool needsToRecompile = false;
1191     counter--;
1192     if (!counter) {
1193         doDisableWork();
1194         needsToRecompile = true;
1195     }
1196 
1197     return needsToRecompile;
1198 }
1199 
1200 bool VM::enableTypeProfiler()
1201 {
1202     auto enableTypeProfiler = [this] () {
1203         this-&gt;m_typeProfiler = makeUnique&lt;TypeProfiler&gt;();
1204         this-&gt;m_typeProfilerLog = makeUnique&lt;TypeProfilerLog&gt;(*this);
1205     };
1206 
1207     return enableProfilerWithRespectToCount(m_typeProfilerEnabledCount, enableTypeProfiler);
1208 }
1209 
1210 bool VM::disableTypeProfiler()
1211 {
1212     auto disableTypeProfiler = [this] () {
1213         this-&gt;m_typeProfiler.reset(nullptr);
1214         this-&gt;m_typeProfilerLog.reset(nullptr);
1215     };
1216 
1217     return disableProfilerWithRespectToCount(m_typeProfilerEnabledCount, disableTypeProfiler);
1218 }
1219 
1220 bool VM::enableControlFlowProfiler()
1221 {
1222     auto enableControlFlowProfiler = [this] () {
1223         this-&gt;m_controlFlowProfiler = makeUnique&lt;ControlFlowProfiler&gt;();
1224     };
1225 
1226     return enableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, enableControlFlowProfiler);
1227 }
1228 
1229 bool VM::disableControlFlowProfiler()
1230 {
1231     auto disableControlFlowProfiler = [this] () {
1232         this-&gt;m_controlFlowProfiler.reset(nullptr);
1233     };
1234 
1235     return disableProfilerWithRespectToCount(m_controlFlowProfilerEnabledCount, disableControlFlowProfiler);
1236 }
1237 
1238 void VM::dumpTypeProfilerData()
1239 {
1240     if (!typeProfiler())
1241         return;
1242 
1243     typeProfilerLog()-&gt;processLogEntries(*this, &quot;VM Dump Types&quot;_s);
1244     typeProfiler()-&gt;dumpTypeProfilerData(*this);
1245 }
1246 
1247 void VM::queueMicrotask(JSGlobalObject&amp; globalObject, Ref&lt;Microtask&gt;&amp;&amp; task)
1248 {
1249     m_microtaskQueue.append(makeUnique&lt;QueuedTask&gt;(*this, &amp;globalObject, WTFMove(task)));
1250 }
1251 
1252 void VM::callPromiseRejectionCallback(Strong&lt;JSPromise&gt;&amp; promise)
1253 {
1254     JSObject* callback = promise-&gt;globalObject()-&gt;unhandledRejectionCallback();
1255     if (!callback)
1256         return;
1257 
1258     auto scope = DECLARE_CATCH_SCOPE(*this);
1259 
1260     CallData callData;
1261     CallType callType = getCallData(*this, callback, callData);
1262     ASSERT(callType != CallType::None);
1263 
1264     MarkedArgumentBuffer args;
1265     args.append(promise.get());
1266     args.append(promise-&gt;result(*this));
1267     call(promise-&gt;globalObject(), callback, callType, callData, jsNull(), args);
1268     scope.clearException();
1269 }
1270 
1271 void VM::didExhaustMicrotaskQueue()
1272 {
1273     auto unhandledRejections = WTFMove(m_aboutToBeNotifiedRejectedPromises);
1274     for (auto&amp; promise : unhandledRejections) {
1275         if (promise-&gt;isHandled(*this))
1276             continue;
1277 
1278         callPromiseRejectionCallback(promise);
1279     }
1280 }
1281 
1282 void VM::promiseRejected(JSPromise* promise)
1283 {
1284     m_aboutToBeNotifiedRejectedPromises.constructAndAppend(*this, promise);
1285 }
1286 
1287 void VM::drainMicrotasks()
1288 {
1289     do {
1290         while (!m_microtaskQueue.isEmpty()) {
1291             m_microtaskQueue.takeFirst()-&gt;run();
1292             if (m_onEachMicrotaskTick)
1293                 m_onEachMicrotaskTick(*this);
1294         }
1295         didExhaustMicrotaskQueue();
1296     } while (!m_microtaskQueue.isEmpty());
1297     finalizeSynchronousJSExecution();
1298 }
1299 
1300 void QueuedTask::run()
1301 {
1302     m_microtask-&gt;run(m_globalObject.get());
1303 }
1304 
1305 void sanitizeStackForVM(VM&amp; vm)
1306 {
1307     logSanitizeStack(vm);
1308     if (vm.topCallFrame) {
1309         auto&amp; stackBounds = Thread::current().stack();
1310         ASSERT(vm.currentThreadIsHoldingAPILock());
1311         ASSERT_UNUSED(stackBounds, stackBounds.contains(vm.lastStackTop()));
1312     }
1313 #if ENABLE(C_LOOP)
1314     vm.interpreter-&gt;cloopStack().sanitizeStack();
1315 #else
1316     sanitizeStackForVMImpl(&amp;vm);
1317 #endif
1318 }
1319 
1320 size_t VM::committedStackByteCount()
1321 {
1322 #if !ENABLE(C_LOOP)
1323     // When using the C stack, we don&#39;t know how many stack pages are actually
1324     // committed. So, we use the current stack usage as an estimate.
1325     uint8_t* current = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());
1326     uint8_t* high = bitwise_cast&lt;uint8_t*&gt;(Thread::current().stack().origin());
1327     return high - current;
1328 #else
1329     return CLoopStack::committedByteCount();
1330 #endif
1331 }
1332 
1333 #if ENABLE(C_LOOP)
1334 bool VM::ensureStackCapacityForCLoop(Register* newTopOfStack)
1335 {
1336     return interpreter-&gt;cloopStack().ensureCapacityFor(newTopOfStack);
1337 }
1338 
1339 bool VM::isSafeToRecurseSoftCLoop() const
1340 {
1341     return interpreter-&gt;cloopStack().isSafeToRecurse();
1342 }
1343 
1344 void* VM::currentCLoopStackPointer() const
1345 {
1346     return interpreter-&gt;cloopStack().currentStackPointer();
1347 }
1348 #endif // ENABLE(C_LOOP)
1349 
1350 #if ENABLE(EXCEPTION_SCOPE_VERIFICATION)
1351 void VM::verifyExceptionCheckNeedIsSatisfied(unsigned recursionDepth, ExceptionEventLocation&amp; location)
1352 {
1353     if (!Options::validateExceptionChecks())
1354         return;
1355 
1356     if (UNLIKELY(m_needExceptionCheck)) {
1357         auto throwDepth = m_simulatedThrowPointRecursionDepth;
1358         auto&amp; throwLocation = m_simulatedThrowPointLocation;
1359 
1360         dataLog(
1361             &quot;ERROR: Unchecked JS exception:\n&quot;
1362             &quot;    This scope can throw a JS exception: &quot;, throwLocation, &quot;\n&quot;
1363             &quot;        (ExceptionScope::m_recursionDepth was &quot;, throwDepth, &quot;)\n&quot;
1364             &quot;    But the exception was unchecked as of this scope: &quot;, location, &quot;\n&quot;
1365             &quot;        (ExceptionScope::m_recursionDepth was &quot;, recursionDepth, &quot;)\n&quot;
1366             &quot;\n&quot;);
1367 
1368         StringPrintStream out;
1369         std::unique_ptr&lt;StackTrace&gt; currentTrace = StackTrace::captureStackTrace(Options::unexpectedExceptionStackTraceLimit());
1370 
1371         if (Options::dumpSimulatedThrows()) {
1372             out.println(&quot;The simulated exception was thrown at:&quot;);
1373             m_nativeStackTraceOfLastSimulatedThrow-&gt;dump(out, &quot;    &quot;);
1374             out.println();
1375         }
1376         out.println(&quot;Unchecked exception detected at:&quot;);
1377         currentTrace-&gt;dump(out, &quot;    &quot;);
1378         out.println();
1379 
1380         dataLog(out.toCString());
1381         RELEASE_ASSERT(!m_needExceptionCheck);
1382     }
1383 }
1384 #endif
1385 
1386 #if USE(CF)
1387 void VM::setRunLoop(CFRunLoopRef runLoop)
1388 {
1389     ASSERT(runLoop);
1390     m_runLoop = runLoop;
1391     JSRunLoopTimer::Manager::shared().didChangeRunLoop(*this, runLoop);
1392 }
1393 #endif // USE(CF)
1394 
1395 ScratchBuffer* VM::scratchBufferForSize(size_t size)
1396 {
1397     if (!size)
1398         return nullptr;
1399 
1400     auto locker = holdLock(m_scratchBufferLock);
1401 
1402     if (size &gt; m_sizeOfLastScratchBuffer) {
1403         // Protect against a N^2 memory usage pathology by ensuring
1404         // that at worst, we get a geometric series, meaning that the
1405         // total memory usage is somewhere around
1406         // max(scratch buffer size) * 4.
1407         m_sizeOfLastScratchBuffer = size * 2;
1408 
1409         ScratchBuffer* newBuffer = ScratchBuffer::create(m_sizeOfLastScratchBuffer);
1410         RELEASE_ASSERT(newBuffer);
1411         m_scratchBuffers.append(newBuffer);
1412     }
1413 
1414     ScratchBuffer* result = m_scratchBuffers.last();
1415     return result;
1416 }
1417 
1418 void VM::clearScratchBuffers()
1419 {
1420     auto lock = holdLock(m_scratchBufferLock);
1421     for (auto* scratchBuffer : m_scratchBuffers)
1422         scratchBuffer-&gt;setActiveLength(0);
1423 }
1424 
1425 void VM::ensureShadowChicken()
1426 {
1427     if (m_shadowChicken)
1428         return;
1429     m_shadowChicken = makeUnique&lt;ShadowChicken&gt;();
1430 }
1431 
1432 #define DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1433     IsoSubspace* VM::name##Slow() \
1434     { \
1435         ASSERT(!m_##name); \
1436         auto space = makeUnique&lt;IsoSubspace&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \
1437         WTF::storeStoreFence(); \
1438         m_##name = WTFMove(space); \
1439         return m_##name.get(); \
1440     }
1441 
1442 
1443 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiGlobalObjectSpace, apiGlobalObjectHeapCellType.get(), JSAPIGlobalObject)
1444 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiValueWrapperSpace, cellHeapCellType.get(), JSAPIValueWrapper)
1445 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(arrayBufferSpace, cellHeapCellType.get(), JSArrayBuffer)
1446 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(arrayIteratorSpace, cellHeapCellType.get(), JSArrayIterator)
1447 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(asyncGeneratorSpace, cellHeapCellType.get(), JSAsyncGenerator)
1448 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(bigIntObjectSpace, cellHeapCellType.get(), BigIntObject)
1449 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(booleanObjectSpace, cellHeapCellType.get(), BooleanObject)
1450 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(boundFunctionSpace, cellHeapCellType.get(), JSBoundFunction) // Hash:0xd7916d41
1451 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackConstructorSpace, callbackConstructorHeapCellType.get(), JSCallbackConstructor)
1452 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackGlobalObjectSpace, callbackGlobalObjectHeapCellType.get(), JSCallbackObject&lt;JSGlobalObject&gt;)
1453 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackFunctionSpace, cellHeapCellType.get(), JSCallbackFunction) // Hash:0xe7648ebc
1454 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackObjectSpace, callbackObjectHeapCellType.get(), JSCallbackObject&lt;JSNonFinalObject&gt;)
1455 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(customGetterSetterFunctionSpace, cellHeapCellType.get(), JSCustomGetterSetterFunction) // Hash:0x18091000
1456 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(dataViewSpace, cellHeapCellType.get(), JSDataView)
1457 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(debuggerScopeSpace, cellHeapCellType.get(), DebuggerScope)
1458 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(errorInstanceSpace, errorInstanceHeapCellType.get(), ErrorInstance) // Hash:0x3f40d4a
1459 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(float32ArraySpace, cellHeapCellType.get(), JSFloat32Array)
1460 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(float64ArraySpace, cellHeapCellType.get(), JSFloat64Array)
1461 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(functionRareDataSpace, destructibleCellHeapCellType.get(), FunctionRareData)
1462 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(generatorSpace, cellHeapCellType.get(), JSGenerator)
1463 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(globalObjectSpace, globalObjectHeapCellType.get(), JSGlobalObject)
1464 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(jsModuleRecordSpace, jsModuleRecordHeapCellType.get(), JSModuleRecord)
1465 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(int8ArraySpace, cellHeapCellType.get(), JSInt8Array)
1466 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(int16ArraySpace, cellHeapCellType.get(), JSInt16Array)
1467 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(int32ArraySpace, cellHeapCellType.get(), JSInt32Array)
1468 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(mapBucketSpace, cellHeapCellType.get(), JSMap::BucketType)
1469 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(mapIteratorSpace, cellHeapCellType.get(), JSMapIterator)
1470 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(mapSpace, cellHeapCellType.get(), JSMap)
1471 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(moduleNamespaceObjectSpace, moduleNamespaceObjectHeapCellType.get(), JSModuleNamespaceObject)
1472 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(nativeStdFunctionSpace, nativeStdFunctionHeapCellType.get(), JSNativeStdFunction) // Hash:0x70ed61e4
1473 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyObjectSpace, cellHeapCellType.get(), ProxyObject)
1474 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(proxyRevokeSpace, cellHeapCellType.get(), ProxyRevoke) // Hash:0xb506a939
1475 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(scopedArgumentsTableSpace, destructibleCellHeapCellType.get(), ScopedArgumentsTable)
1476 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(scriptFetchParametersSpace, destructibleCellHeapCellType.get(), JSScriptFetchParameters)
1477 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(scriptFetcherSpace, destructibleCellHeapCellType.get(), JSScriptFetcher)
1478 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(setBucketSpace, cellHeapCellType.get(), JSSet::BucketType)
1479 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(setIteratorSpace, cellHeapCellType.get(), JSSetIterator)
1480 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(setSpace, cellHeapCellType.get(), JSSet)
1481 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(strictEvalActivationSpace, cellHeapCellType.get(), StrictEvalActivation)
1482 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(stringIteratorSpace, cellHeapCellType.get(), JSStringIterator)
1483 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(sourceCodeSpace, destructibleCellHeapCellType.get(), JSSourceCode)
1484 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(symbolSpace, destructibleCellHeapCellType.get(), Symbol)
1485 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(symbolObjectSpace, cellHeapCellType.get(), SymbolObject)
1486 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(templateObjectDescriptorSpace, destructibleCellHeapCellType.get(), JSTemplateObjectDescriptor)
1487 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint8ArraySpace, cellHeapCellType.get(), JSUint8Array)
1488 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint8ClampedArraySpace, cellHeapCellType.get(), JSUint8ClampedArray)
1489 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint16ArraySpace, cellHeapCellType.get(), JSUint16Array)
1490 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(uint32ArraySpace, cellHeapCellType.get(), JSUint32Array)
1491 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedEvalCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedEvalCodeBlock)
1492 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedFunctionCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedFunctionCodeBlock)
1493 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedModuleProgramCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedModuleProgramCodeBlock)
1494 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(unlinkedProgramCodeBlockSpace, destructibleCellHeapCellType.get(), UnlinkedProgramCodeBlock)
1495 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakMapSpace, weakMapHeapCellType.get(), JSWeakMap) // Hash:0x662b12a3
1496 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakSetSpace, weakSetHeapCellType.get(), JSWeakSet) // Hash:0x4c781b30
1497 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(weakObjectRefSpace, cellHeapCellType.get(), JSWeakObjectRef) // Hash:0x8ec68f1f
1498 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(withScopeSpace, cellHeapCellType.get(), JSWithScope)
1499 #if JSC_OBJC_API_ENABLED
1500 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiWrapperObjectSpace, apiWrapperObjectHeapCellType.get(), JSCallbackObject&lt;JSAPIWrapperObject&gt;)
1501 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(objCCallbackFunctionSpace, objCCallbackFunctionHeapCellType.get(), ObjCCallbackFunction) // Hash:0x10f610b8
1502 #endif
1503 #ifdef JSC_GLIB_API_ENABLED
1504 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(apiWrapperObjectSpace, apiWrapperObjectHeapCellType.get(), JSCallbackObject&lt;JSAPIWrapperObject&gt;)
1505 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(jscCallbackFunctionSpace, jscCallbackFunctionHeapCellType.get(), JSCCallbackFunction)
1506 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(callbackAPIWrapperGlobalObjectSpace, callbackAPIWrapperGlobalObjectHeapCellType.get(), JSCallbackObject&lt;JSAPIWrapperGlobalObject&gt;)
1507 #endif
1508 #if ENABLE(INTL)
1509 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlCollatorSpace, intlCollatorHeapCellType.get(), IntlCollator)
1510 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlDateTimeFormatSpace, intlDateTimeFormatHeapCellType.get(), IntlDateTimeFormat)
1511 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlNumberFormatSpace, intlNumberFormatHeapCellType.get(), IntlNumberFormat)
1512 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(intlPluralRulesSpace, intlPluralRulesHeapCellType.get(), IntlPluralRules)
1513 #endif
1514 #if ENABLE(WEBASSEMBLY)
1515 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(jsToWasmICCalleeSpace, cellHeapCellType.get(), JSToWasmICCallee)
1516 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyCodeBlockSpace, webAssemblyCodeBlockHeapCellType.get(), JSWebAssemblyCodeBlock) // Hash:0x9ad995cd
1517 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyFunctionSpace, webAssemblyFunctionHeapCellType.get(), WebAssemblyFunction) // Hash:0x8b7c32db
1518 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyGlobalSpace, webAssemblyGlobalHeapCellType.get(), JSWebAssemblyGlobal)
1519 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyInstanceSpace, webAssemblyInstanceHeapCellType.get(), JSWebAssemblyInstance)
1520 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyMemorySpace, webAssemblyMemoryHeapCellType.get(), JSWebAssemblyMemory)
1521 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyModuleSpace, webAssemblyModuleHeapCellType.get(), JSWebAssemblyModule)
1522 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyModuleRecordSpace, webAssemblyModuleRecordHeapCellType.get(), WebAssemblyModuleRecord)
1523 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyTableSpace, webAssemblyTableHeapCellType.get(), JSWebAssemblyTable)
1524 DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW(webAssemblyWrapperFunctionSpace, cellHeapCellType.get(), WebAssemblyWrapperFunction) // Hash:0xd4a5ff01
1525 #endif
1526 
1527 #undef DYNAMIC_ISO_SUBSPACE_DEFINE_MEMBER_SLOW
1528 
1529 #define DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(name, heapCellType, type) \
1530     IsoSubspace* VM::name##Slow() \
1531     { \
1532         ASSERT(!m_##name); \
1533         auto space = makeUnique&lt;SpaceAndSet&gt; ISO_SUBSPACE_INIT(heap, heapCellType, type); \
1534         WTF::storeStoreFence(); \
1535         m_##name = WTFMove(space); \
1536         return &amp;m_##name-&gt;space; \
1537     }
1538 
1539 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(evalExecutableSpace, destructibleCellHeapCellType.get(), EvalExecutable) // Hash:0x958e3e9d
1540 DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW(moduleProgramExecutableSpace, destructibleCellHeapCellType.get(), ModuleProgramExecutable) // Hash:0x6506fa3c
1541 
1542 #undef DYNAMIC_SPACE_AND_SET_DEFINE_MEMBER_SLOW
1543 
1544 Structure* VM::setIteratorStructureSlow()
1545 {
1546     ASSERT(!m_setIteratorStructure);
1547     m_setIteratorStructure.set(*this, JSSetIterator::createStructure(*this, 0, jsNull()));
1548     return m_setIteratorStructure.get();
1549 }
1550 
1551 Structure* VM::mapIteratorStructureSlow()
1552 {
1553     ASSERT(!m_mapIteratorStructure);
1554     m_mapIteratorStructure.set(*this, JSMapIterator::createStructure(*this, 0, jsNull()));
1555     return m_mapIteratorStructure.get();
1556 }
1557 
1558 JSCell* VM::sentinelSetBucketSlow()
1559 {
1560     ASSERT(!m_sentinelSetBucket);
1561     auto* sentinel = JSSet::BucketType::createSentinel(*this);
1562     m_sentinelSetBucket.set(*this, sentinel);
1563     return sentinel;
1564 }
1565 
1566 JSCell* VM::sentinelMapBucketSlow()
1567 {
1568     ASSERT(!m_sentinelMapBucket);
1569     auto* sentinel = JSMap::BucketType::createSentinel(*this);
1570     m_sentinelMapBucket.set(*this, sentinel);
1571     return sentinel;
1572 }
1573 
1574 JSPropertyNameEnumerator* VM::emptyPropertyNameEnumeratorSlow()
1575 {
1576     ASSERT(!m_emptyPropertyNameEnumerator);
1577     PropertyNameArray propertyNames(*this, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
1578     auto* enumerator = JSPropertyNameEnumerator::create(*this, nullptr, 0, 0, WTFMove(propertyNames));
1579     m_emptyPropertyNameEnumerator.set(*this, enumerator);
1580     return enumerator;
1581 }
1582 
1583 JSGlobalObject* VM::deprecatedVMEntryGlobalObject(JSGlobalObject* globalObject) const
1584 {
1585     if (entryScope)
1586         return entryScope-&gt;globalObject();
1587     return globalObject;
1588 }
1589 
1590 void VM::setCrashOnVMCreation(bool shouldCrash)
1591 {
1592     vmCreationShouldCrash = shouldCrash;
1593 }
1594 
1595 } // namespace JSC
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp
@@ -87,19 +87,26 @@
 #include <wtf/CompletionHandler.h>
 #include <wtf/MainThread.h>
 #include <wtf/RunLoop.h>
 #include <wtf/Vector.h>
 
+#if ENABLE(OFFSCREEN_CANVAS)
+#include "JSOffscreenCanvas.h"
+#include "OffscreenCanvas.h"
+#endif
+
 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
 #define ASSUME_LITTLE_ENDIAN 0
 #else
 #define ASSUME_LITTLE_ENDIAN 1
 #endif
 
 namespace WebCore {
 using namespace JSC;
 
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SerializedScriptValue);
+
 static const unsigned maximumFilterRecursion = 40000;
 
 enum class SerializationReturnCode {
     SuccessfullyCompleted,
     StackOverflowError,
@@ -165,10 +172,14 @@
     DOMMatrixTag = 41,
     DOMQuadTag = 42,
     ImageBitmapTransferTag = 43,
 #if ENABLE(WEB_RTC)
     RTCCertificateTag = 44,
+#endif
+    ImageBitmapTag = 45,
+#if ENABLE(OFFSCREEN_CANVAS)
+    OffscreenCanvasTransferTag = 46,
 #endif
     ErrorTag = 255
 };
 
 enum ArrayBufferViewSubtag {
@@ -348,10 +359,12 @@
  *    | DOMRect
  *    | DOMMatrix
  *    | DOMQuad
  *    | ImageBitmapTransferTag <value:uint32_t>
  *    | RTCCertificateTag
+ *    | ImageBitmapTag <originClean:uint8_t> <logicalWidth:int32_t> <logicalHeight:int32_t> <resolutionScale:double> <byteLength:uint32_t>(<imageByteData:uint8_t>)
+ *    | OffscreenCanvasTransferTag <value:uint32_t>
  *
  * Inside certificate, data is serialized in this format as per spec:
  *
  * <expires:double> <certificate:StringData> <origin:StringData> <keyingMaterial:StringData>
  * We also add fingerprints to make sure we expose to JavaScript the same information.
@@ -456,45 +469,45 @@
 
 using DeserializationResult = std::pair<JSC::JSValue, SerializationReturnCode>;
 
 class CloneBase {
 protected:
-    CloneBase(ExecState* exec)
-        : m_exec(exec)
+    CloneBase(JSGlobalObject* lexicalGlobalObject)
+        : m_lexicalGlobalObject(lexicalGlobalObject)
         , m_failed(false)
     {
     }
 
     bool shouldTerminate()
     {
-        VM& vm = m_exec->vm();
+        VM& vm = m_lexicalGlobalObject->vm();
         auto scope = DECLARE_THROW_SCOPE(vm);
         return scope.exception();
     }
 
     void fail()
     {
         m_failed = true;
     }
 
-    ExecState* m_exec;
+    JSGlobalObject* m_lexicalGlobalObject;
     bool m_failed;
     MarkedArgumentBuffer m_gcBuffer;
 };
 
 #if ENABLE(WEB_CRYPTO)
-static bool wrapCryptoKey(ExecState* exec, const Vector<uint8_t>& key, Vector<uint8_t>& wrappedKey)
+static bool wrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector<uint8_t>& key, Vector<uint8_t>& wrappedKey)
 {
-    ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);
+    ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);
     if (!scriptExecutionContext)
         return false;
     return scriptExecutionContext->wrapCryptoKey(key, wrappedKey);
 }
 
-static bool unwrapCryptoKey(ExecState* exec, const Vector<uint8_t>& wrappedKey, Vector<uint8_t>& key)
+static bool unwrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector<uint8_t>& wrappedKey, Vector<uint8_t>& key)
 {
-    ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);
+    ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);
     if (!scriptExecutionContext)
         return false;
     return scriptExecutionContext->unwrapCryptoKey(wrappedKey, key);
 }
 #endif
@@ -544,17 +557,23 @@
     return true;
 }
 
 class CloneSerializer : CloneBase {
 public:
-    static SerializationReturnCode serialize(ExecState* exec, JSValue value, Vector<RefPtr<MessagePort>>& messagePorts, Vector<RefPtr<JSC::ArrayBuffer>>& arrayBuffers, const Vector<RefPtr<ImageBitmap>>& imageBitmaps,
+    static SerializationReturnCode serialize(JSGlobalObject* lexicalGlobalObject, JSValue value, Vector<RefPtr<MessagePort>>& messagePorts, Vector<RefPtr<JSC::ArrayBuffer>>& arrayBuffers, const Vector<RefPtr<ImageBitmap>>& imageBitmaps,
+#if ENABLE(OFFSCREEN_CANVAS)
+            const Vector<RefPtr<OffscreenCanvas>>& offscreenCanvases,
+#endif
 #if ENABLE(WEBASSEMBLY)
             WasmModuleArray& wasmModules,
 #endif
         Vector<String>& blobURLs, Vector<uint8_t>& out, SerializationContext context, ArrayBufferContentsArray& sharedBuffers)
     {
-        CloneSerializer serializer(exec, messagePorts, arrayBuffers, imageBitmaps,
+        CloneSerializer serializer(lexicalGlobalObject, messagePorts, arrayBuffers, imageBitmaps,
+#if ENABLE(OFFSCREEN_CANVAS)
+            offscreenCanvases,
+#endif
 #if ENABLE(WEBASSEMBLY)
             wasmModules,
 #endif
             blobURLs, out, context, sharedBuffers);
         return serializer.serialize(value);
@@ -577,39 +596,45 @@
     }
 
 private:
     typedef HashMap<JSObject*, uint32_t> ObjectPool;
 
-    CloneSerializer(ExecState* exec, Vector<RefPtr<MessagePort>>& messagePorts, Vector<RefPtr<JSC::ArrayBuffer>>& arrayBuffers, const Vector<RefPtr<ImageBitmap>>& imageBitmaps,
+    CloneSerializer(JSGlobalObject* lexicalGlobalObject, Vector<RefPtr<MessagePort>>& messagePorts, Vector<RefPtr<JSC::ArrayBuffer>>& arrayBuffers, const Vector<RefPtr<ImageBitmap>>& imageBitmaps,
+#if ENABLE(OFFSCREEN_CANVAS)
+            const Vector<RefPtr<OffscreenCanvas>>& offscreenCanvases,
+#endif
 #if ENABLE(WEBASSEMBLY)
             WasmModuleArray& wasmModules,
 #endif
         Vector<String>& blobURLs, Vector<uint8_t>& out, SerializationContext context, ArrayBufferContentsArray& sharedBuffers)
-        : CloneBase(exec)
+        : CloneBase(lexicalGlobalObject)
         , m_buffer(out)
         , m_blobURLs(blobURLs)
-        , m_emptyIdentifier(Identifier::fromString(exec->vm(), emptyString()))
+        , m_emptyIdentifier(Identifier::fromString(lexicalGlobalObject->vm(), emptyString()))
         , m_context(context)
         , m_sharedBuffers(sharedBuffers)
 #if ENABLE(WEBASSEMBLY)
         , m_wasmModules(wasmModules)
 #endif
     {
         write(CurrentVersion);
         fillTransferMap(messagePorts, m_transferredMessagePorts);
         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
+#if ENABLE(OFFSCREEN_CANVAS)
+        fillTransferMap(offscreenCanvases, m_transferredOffscreenCanvases);
+#endif
     }
 
     template <class T>
     void fillTransferMap(const Vector<RefPtr<T>>& input, ObjectPool& result)
     {
         if (input.isEmpty())
             return;
-        JSDOMGlobalObject* globalObject = jsCast<JSDOMGlobalObject*>(m_exec->lexicalGlobalObject());
+        JSDOMGlobalObject* globalObject = jsCast<JSDOMGlobalObject*>(m_lexicalGlobalObject);
         for (size_t i = 0; i < input.size(); i++) {
-            JSC::JSValue value = toJS(m_exec, globalObject, input[i].get());
+            JSC::JSValue value = toJS(m_lexicalGlobalObject, globalObject, input[i].get());
             JSC::JSObject* obj = value.getObject();
             if (obj && !result.contains(obj))
                 result.add(obj, i);
         }
     }
@@ -712,12 +737,12 @@
     }
 
     JSValue getProperty(VM& vm, JSObject* object, const Identifier& propertyName)
     {
         PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
-        if (object->methodTable(vm)->getOwnPropertySlot(object, m_exec, propertyName, slot))
-            return slot.getValue(m_exec, propertyName);
+        if (object->methodTable(vm)->getOwnPropertySlot(object, m_lexicalGlobalObject, propertyName, slot))
+            return slot.getValue(m_lexicalGlobalObject, propertyName);
         return JSValue();
     }
 
     void dumpImmediate(JSValue value)
     {
@@ -767,24 +792,24 @@
         }
     }
 
     JSC::JSValue toJSArrayBuffer(ArrayBuffer& arrayBuffer)
     {
-        auto& vm = m_exec->vm();
-        auto* globalObject = m_exec->lexicalGlobalObject();
+        auto& vm = m_lexicalGlobalObject->vm();
+        auto* globalObject = m_lexicalGlobalObject;
         if (globalObject->inherits<JSDOMGlobalObject>(vm))
-            return toJS(m_exec, jsCast<JSDOMGlobalObject*>(globalObject), &arrayBuffer);
+            return toJS(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(globalObject), &arrayBuffer);
 
         if (auto* buffer = arrayBuffer.m_wrapper.get())
             return buffer;
 
         return JSC::JSArrayBuffer::create(vm, globalObject->arrayBufferStructure(arrayBuffer.sharingMode()), &arrayBuffer);
     }
 
     bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode& code)
     {
-        VM& vm = m_exec->vm();
+        VM& vm = m_lexicalGlobalObject->vm();
         write(ArrayBufferViewTag);
         if (obj->inherits<JSDataView>(vm))
             write(DataViewTag);
         else if (obj->inherits<JSUint8ClampedArray>(vm))
             write(Uint8ClampedArrayTag);
@@ -827,22 +852,22 @@
         write(point.w());
     }
 
     void dumpDOMPoint(JSObject* obj)
     {
-        VM& vm = m_exec->vm();
+        VM& vm = m_lexicalGlobalObject->vm();
         if (obj->inherits<JSDOMPoint>(vm))
             write(DOMPointTag);
         else
             write(DOMPointReadOnlyTag);
 
         dumpDOMPoint(jsCast<JSDOMPointReadOnly*>(obj)->wrapped());
     }
 
     void dumpDOMRect(JSObject* obj)
     {
-        VM& vm = m_exec->vm();
+        VM& vm = m_lexicalGlobalObject->vm();
         if (obj->inherits<JSDOMRect>(vm))
             write(DOMRectTag);
         else
             write(DOMRectReadOnlyTag);
 
@@ -853,11 +878,11 @@
         write(rect.height());
     }
 
     void dumpDOMMatrix(JSObject* obj)
     {
-        VM& vm = m_exec->vm();
+        VM& vm = m_lexicalGlobalObject->vm();
         if (obj->inherits<JSDOMMatrix>(vm))
             write(DOMMatrixTag);
         else
             write(DOMMatrixReadOnlyTag);
 
@@ -909,33 +934,74 @@
             write(ImageBitmapTransferTag);
             write(index->value);
             return;
         }
 
-        // Copying ImageBitmaps is not yet supported.
-        code = SerializationReturnCode::ValidationError;
+        auto& imageBitmap = jsCast<JSImageBitmap*>(obj)->wrapped();
+        auto* buffer = imageBitmap.buffer();
+
+        if (!buffer) {
+            code = SerializationReturnCode::ValidationError;
+            return;
+        }
+
+        const IntSize& logicalSize = buffer->logicalSize();
+        auto imageData = buffer->getPremultipliedImageData(IntRect(0, 0, logicalSize.width(), logicalSize.height()));
+        if (!imageData) {
+            code = SerializationReturnCode::ValidationError;
+            return;
+        }
+
+        RefPtr<ArrayBuffer> arrayBuffer = imageData->possiblySharedBuffer();
+        if (!arrayBuffer) {
+            code = SerializationReturnCode::ValidationError;
+            return;
+        }
+
+        write(ImageBitmapTag);
+        write(static_cast<uint8_t>(imageBitmap.originClean()));
+        write(static_cast<int32_t>(logicalSize.width()));
+        write(static_cast<int32_t>(logicalSize.height()));
+        write(static_cast<double>(buffer->resolutionScale()));
+
+        write(static_cast<uint32_t>(arrayBuffer->byteLength()));
+        write(static_cast<const uint8_t*>(arrayBuffer->data()), arrayBuffer->byteLength());
     }
 
+#if ENABLE(OFFSCREEN_CANVAS)
+    void dumpOffscreenCanvas(JSObject* obj, SerializationReturnCode& code)
+    {
+        auto index = m_transferredOffscreenCanvases.find(obj);
+        if (index != m_transferredOffscreenCanvases.end()) {
+            write(OffscreenCanvasTransferTag);
+            write(index->value);
+            return;
+        }
+
+        code = SerializationReturnCode::DataCloneError;
+    }
+#endif
+
     bool dumpIfTerminal(JSValue value, SerializationReturnCode& code)
     {
         if (!value.isCell()) {
             dumpImmediate(value);
             return true;
         }
         ASSERT(value.isCell());
 
         if (value.isString()) {
-            dumpString(asString(value)->value(m_exec));
+            dumpString(asString(value)->value(m_lexicalGlobalObject));
             return true;
         }
 
         if (value.isSymbol()) {
             code = SerializationReturnCode::DataCloneError;
             return true;
         }
 
-        VM& vm = m_exec->vm();
+        VM& vm = m_lexicalGlobalObject->vm();
         if (isArray(vm, value))
             return false;
 
         if (value.isObject()) {
             auto* obj = asObject(value);
@@ -945,17 +1011,17 @@
                 return true;
             }
             if (auto* booleanObject = jsDynamicCast<BooleanObject*>(vm, obj)) {
                 if (!startObjectInternal(booleanObject)) // handle duplicates
                     return true;
-                write(booleanObject->internalValue().toBoolean(m_exec) ? TrueObjectTag : FalseObjectTag);
+                write(booleanObject->internalValue().toBoolean(m_lexicalGlobalObject) ? TrueObjectTag : FalseObjectTag);
                 return true;
             }
             if (auto* stringObject = jsDynamicCast<StringObject*>(vm, obj)) {
                 if (!startObjectInternal(stringObject)) // handle duplicates
                     return true;
-                String str = asString(stringObject->internalValue())->value(m_exec);
+                String str = asString(stringObject->internalValue())->value(m_lexicalGlobalObject);
                 dumpStringObject(str);
                 return true;
             }
             if (auto* numberObject = jsDynamicCast<NumberObject*>(vm, obj)) {
                 if (!startObjectInternal(numberObject)) // handle duplicates
@@ -1063,18 +1129,21 @@
                 Vector<RefPtr<JSC::ArrayBuffer>> dummyArrayBuffers;
 #if ENABLE(WEBASSEMBLY)
                 WasmModuleArray dummyModules;
 #endif
                 ArrayBufferContentsArray dummySharedBuffers;
-                CloneSerializer rawKeySerializer(m_exec, dummyMessagePorts, dummyArrayBuffers, { },
+                CloneSerializer rawKeySerializer(m_lexicalGlobalObject, dummyMessagePorts, dummyArrayBuffers, { },
+#if ENABLE(OFFSCREEN_CANVAS)
+                    { },
+#endif
 #if ENABLE(WEBASSEMBLY)
                     dummyModules,
 #endif
                     dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);
                 rawKeySerializer.write(key);
                 Vector<uint8_t> wrappedKey;
-                if (!wrapCryptoKey(m_exec, serializedKey, wrappedKey))
+                if (!wrapCryptoKey(m_lexicalGlobalObject, serializedKey, wrappedKey))
                     return false;
                 write(wrappedKey);
                 return true;
             }
 #endif
@@ -1123,10 +1192,16 @@
             }
             if (obj->inherits(vm, JSImageBitmap::info())) {
                 dumpImageBitmap(obj, code);
                 return true;
             }
+#if ENABLE(OFFSCREEN_CANVAS)
+            if (obj->inherits(vm, JSOffscreenCanvas::info())) {
+                dumpOffscreenCanvas(obj, code);
+                return true;
+            }
+#endif
             return false;
         }
         // Any other types are expected to serialize as null.
         write(NullTag);
         return true;
@@ -1257,11 +1332,11 @@
     void write(const String& str)
     {
         if (str.isNull())
             write(m_emptyIdentifier);
         else
-            write(Identifier::fromString(m_exec->vm(), str));
+            write(Identifier::fromString(m_lexicalGlobalObject->vm(), str));
     }
 
     void write(const Vector<uint8_t>& vector)
     {
         uint32_t size = vector.size();
@@ -1470,10 +1545,13 @@
     Vector<String>& m_blobURLs;
     ObjectPool m_objectPool;
     ObjectPool m_transferredMessagePorts;
     ObjectPool m_transferredArrayBuffers;
     ObjectPool m_transferredImageBitmaps;
+#if ENABLE(OFFSCREEN_CANVAS)
+    ObjectPool m_transferredOffscreenCanvases;
+#endif
     typedef HashMap<RefPtr<UniquedStringImpl>, uint32_t, IdentifierRepHash> StringConstantPool;
     StringConstantPool m_constantPool;
     Identifier m_emptyIdentifier;
     SerializationContext m_context;
     ArrayBufferContentsArray& m_sharedBuffers;
@@ -1482,23 +1560,23 @@
 #endif
 };
 
 SerializationReturnCode CloneSerializer::serialize(JSValue in)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_lexicalGlobalObject->vm();
     Vector<uint32_t, 16> indexStack;
     Vector<uint32_t, 16> lengthStack;
     Vector<PropertyNameArray, 16> propertyStack;
     Vector<JSObject*, 32> inputObjectStack;
     Vector<JSMapIterator*, 4> mapIteratorStack;
     Vector<JSSetIterator*, 4> setIteratorStack;
     Vector<JSValue, 4> mapIteratorValueStack;
     Vector<WalkerState, 16> stateStack;
-    WalkerState state = StateUnknown;
+    WalkerState lexicalGlobalObject = StateUnknown;
     JSValue inValue = in;
     while (1) {
-        switch (state) {
+        switch (lexicalGlobalObject) {
             arrayStartState:
             case ArrayStartState: {
                 ASSERT(isArray(vm, inValue));
                 if (inputObjectStack.size() > maximumFilterRecursion)
                     return SerializationReturnCode::StackOverflowError;
@@ -1519,11 +1597,11 @@
                 if (index == lengthStack.last()) {
                     indexStack.removeLast();
                     lengthStack.removeLast();
 
                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
-                    array->methodTable(vm)->getOwnNonIndexPropertyNames(array, m_exec, propertyStack.last(), EnumerationMode());
+                    array->methodTable(vm)->getOwnNonIndexPropertyNames(array, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
                     if (propertyStack.last().size()) {
                         write(NonIndexPropertiesTag);
                         indexStack.append(0);
                         goto objectStartVisitMember;
                     }
@@ -1531,11 +1609,11 @@
 
                     endObject();
                     inputObjectStack.removeLast();
                     break;
                 }
-                inValue = array->getDirectIndex(m_exec, index);
+                inValue = array->getDirectIndex(m_lexicalGlobalObject, index);
                 if (!inValue) {
                     indexStack.last()++;
                     goto arrayStartVisitMember;
                 }
 
@@ -1569,11 +1647,11 @@
                 if (inObject->classInfo(vm) != JSFinalObject::info())
                     return SerializationReturnCode::DataCloneError;
                 inputObjectStack.append(inObject);
                 indexStack.append(0);
                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
-                inObject->methodTable(vm)->getOwnPropertyNames(inObject, m_exec, propertyStack.last(), EnumerationMode());
+                inObject->methodTable(vm)->getOwnPropertyNames(inObject, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
             }
             objectStartVisitMember:
             FALLTHROUGH;
             case ObjectStartVisitMember: {
                 JSObject* object = inputObjectStack.last();
@@ -1621,27 +1699,27 @@
                 if (inputObjectStack.size() > maximumFilterRecursion)
                     return SerializationReturnCode::StackOverflowError;
                 JSMap* inMap = jsCast<JSMap*>(inValue);
                 if (!startMap(inMap))
                     break;
-                JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterateKeyValue);
+                JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterationKind::Entries);
                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
                 mapIteratorStack.append(iterator);
                 inputObjectStack.append(inMap);
                 goto mapDataStartVisitEntry;
             }
             mapDataStartVisitEntry:
             case MapDataStartVisitEntry: {
                 JSMapIterator* iterator = mapIteratorStack.last();
                 JSValue key, value;
-                if (!iterator->nextKeyValue(m_exec, key, value)) {
+                if (!iterator->nextKeyValue(m_lexicalGlobalObject, key, value)) {
                     mapIteratorStack.removeLast();
                     JSObject* object = inputObjectStack.last();
                     ASSERT(jsDynamicCast<JSMap*>(vm, object));
                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
-                    object->methodTable(vm)->getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
+                    object->methodTable(vm)->getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
                     write(NonMapPropertiesTag);
                     indexStack.append(0);
                     goto objectStartVisitMember;
                 }
                 inValue = key;
@@ -1665,27 +1743,27 @@
                 if (inputObjectStack.size() > maximumFilterRecursion)
                     return SerializationReturnCode::StackOverflowError;
                 JSSet* inSet = jsCast<JSSet*>(inValue);
                 if (!startSet(inSet))
                     break;
-                JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterateKey);
+                JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterationKind::Keys);
                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
                 setIteratorStack.append(iterator);
                 inputObjectStack.append(inSet);
                 goto setDataStartVisitEntry;
             }
             setDataStartVisitEntry:
             case SetDataStartVisitEntry: {
                 JSSetIterator* iterator = setIteratorStack.last();
                 JSValue key;
-                if (!iterator->next(m_exec, key)) {
+                if (!iterator->next(m_lexicalGlobalObject, key)) {
                     setIteratorStack.removeLast();
                     JSObject* object = inputObjectStack.last();
                     ASSERT(jsDynamicCast<JSSet*>(vm, object));
                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
-                    object->methodTable(vm)->getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());
+                    object->methodTable(vm)->getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());
                     write(NonSetPropertiesTag);
                     indexStack.append(0);
                     goto objectStartVisitMember;
                 }
                 inValue = key;
@@ -1715,11 +1793,11 @@
             }
         }
         if (stateStack.isEmpty())
             break;
 
-        state = stateStack.last();
+        lexicalGlobalObject = stateStack.last();
         stateStack.removeLast();
     }
     if (m_failed)
         return SerializationReturnCode::UnspecifiedError;
 
@@ -1749,19 +1827,26 @@
         if (!readString(ptr, end, str, length, is8Bit))
             return String();
         return str;
     }
 
-    static DeserializationResult deserialize(ExecState* exec, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>>&& imageBuffers, ArrayBufferContentsArray* arrayBufferContentsArray, const Vector<uint8_t>& buffer, const Vector<String>& blobURLs, const Vector<String> blobFilePaths, ArrayBufferContentsArray* sharedBuffers
+    static DeserializationResult deserialize(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>>&& imageBuffers
+#if ENABLE(OFFSCREEN_CANVAS)
+        , Vector<std::unique_ptr<DetachedOffscreenCanvas>>&& detachedOffscreenCanvases
+#endif
+        , ArrayBufferContentsArray* arrayBufferContentsArray, const Vector<uint8_t>& buffer, const Vector<String>& blobURLs, const Vector<String> blobFilePaths, ArrayBufferContentsArray* sharedBuffers
 #if ENABLE(WEBASSEMBLY)
         , WasmModuleArray* wasmModules
 #endif
         )
     {
         if (!buffer.size())
             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
-        CloneDeserializer deserializer(exec, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)
+        CloneDeserializer deserializer(lexicalGlobalObject, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)
+#if ENABLE(OFFSCREEN_CANVAS)
+            , WTFMove(detachedOffscreenCanvases)
+#endif
 #if ENABLE(WEBASSEMBLY)
             , wasmModules
 #endif
             );
         if (!deserializer.isValid())
@@ -1774,14 +1859,14 @@
         CachedString(const String& string)
             : m_string(string)
         {
         }
 
-        JSValue jsString(ExecState* exec)
+        JSValue jsString(JSGlobalObject* lexicalGlobalObject)
         {
             if (!m_jsString)
-                m_jsString = JSC::jsString(exec->vm(), m_string);
+                m_jsString = JSC::jsString(lexicalGlobalObject->vm(), m_string);
             return m_jsString;
         }
         const String& string() { return m_string; }
         String takeString() { return WTFMove(m_string); }
 
@@ -1807,40 +1892,50 @@
     private:
         Vector<CachedString>* m_base;
         size_t m_index;
     };
 
-    CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>>&& imageBuffers,
+    CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>>&& imageBuffers, const Vector<uint8_t>& buffer
+#if ENABLE(OFFSCREEN_CANVAS)
+        , Vector<std::unique_ptr<DetachedOffscreenCanvas>>&& detachedOffscreenCanvases = { }
+#endif
 #if ENABLE(WEBASSEMBLY)
-        WasmModuleArray* wasmModules,
+        , WasmModuleArray* wasmModules = nullptr
 #endif
-        const Vector<uint8_t>& buffer)
-        : CloneBase(exec)
+        )
+        : CloneBase(lexicalGlobalObject)
         , m_globalObject(globalObject)
         , m_isDOMGlobalObject(globalObject->inherits<JSDOMGlobalObject>(globalObject->vm()))
         , m_ptr(buffer.data())
         , m_end(buffer.data() + buffer.size())
         , m_version(0xFFFFFFFF)
         , m_messagePorts(messagePorts)
         , m_arrayBufferContents(arrayBufferContents)
         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents->size() : 0)
         , m_imageBuffers(WTFMove(imageBuffers))
         , m_imageBitmaps(m_imageBuffers.size())
+#if ENABLE(OFFSCREEN_CANVAS)
+        , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))
+        , m_offscreenCanvases(m_detachedOffscreenCanvases.size())
+#endif
 #if ENABLE(WEBASSEMBLY)
         , m_wasmModules(wasmModules)
 #endif
     {
         if (!read(m_version))
             m_version = 0xFFFFFFFF;
     }
 
-    CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector<uint8_t>& buffer, const Vector<String>& blobURLs, const Vector<String> blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>>&& imageBuffers
+    CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector<uint8_t>& buffer, const Vector<String>& blobURLs, const Vector<String> blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>>&& imageBuffers
+#if ENABLE(OFFSCREEN_CANVAS)
+        , Vector<std::unique_ptr<DetachedOffscreenCanvas>>&& detachedOffscreenCanvases
+#endif
 #if ENABLE(WEBASSEMBLY)
         , WasmModuleArray* wasmModules
 #endif
         )
-        : CloneBase(exec)
+        : CloneBase(lexicalGlobalObject)
         , m_globalObject(globalObject)
         , m_isDOMGlobalObject(globalObject->inherits<JSDOMGlobalObject>(globalObject->vm()))
         , m_ptr(buffer.data())
         , m_end(buffer.data() + buffer.size())
         , m_version(0xFFFFFFFF)
@@ -1850,10 +1945,14 @@
         , m_blobURLs(blobURLs)
         , m_blobFilePaths(blobFilePaths)
         , m_sharedBuffers(sharedBuffers)
         , m_imageBuffers(WTFMove(imageBuffers))
         , m_imageBitmaps(m_imageBuffers.size())
+#if ENABLE(OFFSCREEN_CANVAS)
+        , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))
+        , m_offscreenCanvases(m_detachedOffscreenCanvases.size())
+#endif
 #if ENABLE(WEBASSEMBLY)
         , m_wasmModules(wasmModules)
 #endif
     {
         if (!read(m_version))
@@ -2054,16 +2153,16 @@
         return true;
     }
 
     void putProperty(JSObject* object, unsigned index, JSValue value)
     {
-        object->putDirectIndex(m_exec, index, value);
+        object->putDirectIndex(m_lexicalGlobalObject, index, value);
     }
 
     void putProperty(JSObject* object, const Identifier& property, JSValue value)
     {
-        object->putDirectMayBeIndex(m_exec, property, value);
+        object->putDirectMayBeIndex(m_lexicalGlobalObject, property, value);
     }
 
     bool readFile(RefPtr<File>& file)
     {
         CachedStringRef path;
@@ -2091,11 +2190,11 @@
         String filePath = blobFilePathForBlobURL(url->string());
         if (filePath.isEmpty())
             filePath = path->string();
 
         if (m_isDOMGlobalObject)
-            file = File::deserialize(jsCast<JSDOMGlobalObject*>(m_globalObject)->scriptExecutionContext()->sessionID(), filePath, URL(URL(), url->string()), type->string(), name->string(), optionalLastModified);
+            file = File::deserialize(filePath, URL(URL(), url->string()), type->string(), name->string(), optionalLastModified);
         return true;
     }
 
     bool readArrayBuffer(RefPtr<ArrayBuffer>& arrayBuffer)
     {
@@ -2132,38 +2231,38 @@
             return false;
 
         RefPtr<ArrayBuffer> arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
         switch (arrayBufferViewSubtag) {
         case DataViewTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Int8ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Uint8ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Uint8ClampedArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Int16ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Uint16ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Int32ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Uint32ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Float32ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         case Float64ArrayTag:
-            arrayBufferView = toJS(m_exec, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
+            arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());
             return true;
         default:
             return false;
         }
     }
@@ -2315,11 +2414,11 @@
         CryptoAlgorithmIdentifier algorithm;
         if (!read(algorithm))
             return false;
 
         int32_t isRestrictedToHash;
-        CryptoAlgorithmIdentifier hash;
+        CryptoAlgorithmIdentifier hash = CryptoAlgorithmIdentifier::SHA_1;
         if (!read(isRestrictedToHash))
             return false;
         if (isRestrictedToHash && !read(hash))
             return false;
 
@@ -2508,17 +2607,17 @@
 #endif
 
     template<class T>
     JSValue getJSValue(T* nativeObj)
     {
-        return toJS(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), nativeObj);
+        return toJS(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), nativeObj);
     }
 
     template<class T>
     JSValue getJSValue(T& nativeObj)
     {
-        return toJS(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), nativeObj);
+        return toJS(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), nativeObj);
     }
 
     template<class T>
     JSValue readDOMPoint()
     {
@@ -2533,11 +2632,11 @@
             return { };
         double w;
         if (!read(w))
             return { };
 
-        return toJSNewlyCreated(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(x, y, z, w));
+        return toJSNewlyCreated(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(x, y, z, w));
     }
 
     template<class T>
     JSValue readDOMMatrix()
     {
@@ -2564,11 +2663,11 @@
             double m42;
             if (!read(m42))
                 return { };
 
             TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
-            return toJSNewlyCreated(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));
+            return toJSNewlyCreated(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));
         } else {
             double m11;
             if (!read(m11))
                 return { };
             double m12;
@@ -2616,11 +2715,11 @@
             double m44;
             if (!read(m44))
                 return { };
 
             TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
-            return toJSNewlyCreated(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));
+            return toJSNewlyCreated(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));
         }
     }
 
     template<class T>
     JSValue readDOMRect()
@@ -2636,11 +2735,11 @@
             return { };
         double height;
         if (!read(height))
             return { };
 
-        return toJSNewlyCreated(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(x, y, width, height));
+        return toJSNewlyCreated(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), T::create(x, y, width, height));
     }
 
     Optional<DOMPointInit> readDOMPointInit()
     {
         DOMPointInit point;
@@ -2669,14 +2768,14 @@
             return JSValue();
         auto p4 = readDOMPointInit();
         if (!p4)
             return JSValue();
 
-        return toJSNewlyCreated(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));
+        return toJSNewlyCreated(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));
     }
 
-    JSValue readImageBitmap()
+    JSValue readTransferredImageBitmap()
     {
         uint32_t index;
         bool indexSuccessfullyRead = read(index);
         if (!indexSuccessfullyRead || index >= m_imageBuffers.size()) {
             fail();
@@ -2688,10 +2787,28 @@
 
         auto bitmap = m_imageBitmaps[index].get();
         return getJSValue(bitmap);
     }
 
+#if ENABLE(OFFSCREEN_CANVAS)
+    JSValue readOffscreenCanvas()
+    {
+        uint32_t index;
+        bool indexSuccessfullyRead = read(index);
+        if (!indexSuccessfullyRead || index >= m_detachedOffscreenCanvases.size()) {
+            fail();
+            return JSValue();
+        }
+
+        if (!m_offscreenCanvases[index])
+            m_offscreenCanvases[index] = OffscreenCanvas::create(*scriptExecutionContextFromExecState(m_lexicalGlobalObject), WTFMove(m_detachedOffscreenCanvases.at(index)));
+
+        auto offscreenCanvas = m_offscreenCanvases[index].get();
+        return getJSValue(offscreenCanvas);
+    }
+#endif
+
 #if ENABLE(WEB_RTC)
     JSValue readRTCCertificate()
     {
         double expires;
         if (!read(expires)) {
@@ -2728,17 +2845,48 @@
                 return JSValue();
             fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm->string(), value->string() });
         }
 
         if (!m_isDOMGlobalObject)
-            return constructEmptyObject(m_exec, m_globalObject->objectPrototype());
+            return constructEmptyObject(m_lexicalGlobalObject, m_globalObject->objectPrototype());
 
         auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin->string()), expires, WTFMove(fingerprints), certificate->takeString(), keyedMaterial->takeString());
-        return toJSNewlyCreated(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), WTFMove(rtcCertificate));
+        return toJSNewlyCreated(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), WTFMove(rtcCertificate));
     }
 #endif
 
+    JSValue readImageBitmap()
+    {
+        uint8_t originClean;
+        int32_t logicalWidth;
+        int32_t logicalHeight;
+        double resolutionScale;
+        RefPtr<ArrayBuffer> arrayBuffer;
+
+        if (!read(originClean) || !read(logicalWidth) || !read(logicalHeight) || !read(resolutionScale) || !readArrayBuffer(arrayBuffer)) {
+            fail();
+            return JSValue();
+        }
+
+        auto imageData = Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), 0, arrayBuffer->byteLength());
+        if (!imageData) {
+            fail();
+            return JSValue();
+        }
+
+        auto buffer = ImageBuffer::create(FloatSize(logicalWidth, logicalHeight), RenderingMode::Unaccelerated, resolutionScale);
+        if (!buffer) {
+            fail();
+            return JSValue();
+        }
+
+        buffer->putByteArray(*imageData, AlphaPremultiplication::Premultiplied, IntSize(logicalWidth, logicalHeight), IntRect(0, 0, logicalWidth, logicalHeight), IntPoint());
+
+        auto bitmap = ImageBitmap::create({ WTFMove(buffer), static_cast<bool>(originClean) });
+        return getJSValue(bitmap);
+    }
+
     JSValue readTerminal()
     {
         SerializationTag tag = readTag();
         switch (tag) {
         case UndefinedTag:
@@ -2758,18 +2906,18 @@
         case FalseTag:
             return jsBoolean(false);
         case TrueTag:
             return jsBoolean(true);
         case FalseObjectTag: {
-            BooleanObject* obj = BooleanObject::create(m_exec->vm(), m_globalObject->booleanObjectStructure());
-            obj->setInternalValue(m_exec->vm(), jsBoolean(false));
+            BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject->vm(), m_globalObject->booleanObjectStructure());
+            obj->setInternalValue(m_lexicalGlobalObject->vm(), jsBoolean(false));
             m_gcBuffer.appendWithCrashOnOverflow(obj);
             return obj;
         }
         case TrueObjectTag: {
-            BooleanObject* obj = BooleanObject::create(m_exec->vm(), m_globalObject->booleanObjectStructure());
-            obj->setInternalValue(m_exec->vm(), jsBoolean(true));
+            BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject->vm(), m_globalObject->booleanObjectStructure());
+            obj->setInternalValue(m_lexicalGlobalObject->vm(), jsBoolean(true));
             m_gcBuffer.appendWithCrashOnOverflow(obj);
             return obj;
         }
         case DoubleTag: {
             double d;
@@ -2779,27 +2927,27 @@
         }
         case NumberObjectTag: {
             double d;
             if (!read(d))
                 return JSValue();
-            NumberObject* obj = constructNumber(m_exec, m_globalObject, jsNumber(d));
+            NumberObject* obj = constructNumber(m_globalObject, jsNumber(d));
             m_gcBuffer.appendWithCrashOnOverflow(obj);
             return obj;
         }
         case DateTag: {
             double d;
             if (!read(d))
                 return JSValue();
-            return DateInstance::create(m_exec->vm(), m_globalObject->dateStructure(), d);
+            return DateInstance::create(m_lexicalGlobalObject->vm(), m_globalObject->dateStructure(), d);
         }
         case FileTag: {
             RefPtr<File> file;
             if (!readFile(file))
                 return JSValue();
             if (!m_isDOMGlobalObject)
                 return jsNull();
-            return toJS(m_exec, jsCast<JSDOMGlobalObject*>(m_globalObject), file.get());
+            return toJS(m_lexicalGlobalObject, jsCast<JSDOMGlobalObject*>(m_globalObject), file.get());
         }
         case FileListTag: {
             unsigned length = 0;
             if (!read(length))
                 return JSValue();
@@ -2857,30 +3005,30 @@
             unsigned long long size = 0;
             if (!read(size))
                 return JSValue();
             if (!m_isDOMGlobalObject)
                 return jsNull();
-            return getJSValue(Blob::deserialize(jsCast<JSDOMGlobalObject*>(m_globalObject)->scriptExecutionContext()->sessionID(), URL(URL(), url->string()), type->string(), size, blobFilePathForBlobURL(url->string())).get());
+            return getJSValue(Blob::deserialize(URL(URL(), url->string()), type->string(), size, blobFilePathForBlobURL(url->string())).get());
         }
         case StringTag: {
             CachedStringRef cachedString;
             if (!readStringData(cachedString))
                 return JSValue();
-            return cachedString->jsString(m_exec);
+            return cachedString->jsString(m_lexicalGlobalObject);
         }
         case EmptyStringTag:
-            return jsEmptyString(m_exec->vm());
+            return jsEmptyString(m_lexicalGlobalObject->vm());
         case StringObjectTag: {
             CachedStringRef cachedString;
             if (!readStringData(cachedString))
                 return JSValue();
-            StringObject* obj = constructString(m_exec->vm(), m_globalObject, cachedString->jsString(m_exec));
+            StringObject* obj = constructString(m_lexicalGlobalObject->vm(), m_globalObject, cachedString->jsString(m_lexicalGlobalObject));
             m_gcBuffer.appendWithCrashOnOverflow(obj);
             return obj;
         }
         case EmptyStringObjectTag: {
-            VM& vm = m_exec->vm();
+            VM& vm = m_lexicalGlobalObject->vm();
             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));
             m_gcBuffer.appendWithCrashOnOverflow(obj);
             return obj;
         }
         case RegExpTag: {
@@ -2890,11 +3038,11 @@
             CachedStringRef flags;
             if (!readStringData(flags))
                 return JSValue();
             auto reFlags = Yarr::parseFlags(flags->string());
             ASSERT(reFlags.hasValue());
-            VM& vm = m_exec->vm();
+            VM& vm = m_lexicalGlobalObject->vm();
             RegExp* regExp = RegExp::create(vm, pattern->string(), reFlags.value());
             return RegExpObject::create(vm, m_globalObject->regExpStructure(), regExp);
         }
         case ObjectReferenceTag: {
             unsigned index = 0;
@@ -2919,12 +3067,12 @@
             bool indexSuccessfullyRead = read(index);
             if (!indexSuccessfullyRead || !m_wasmModules || index >= m_wasmModules->size()) {
                 fail();
                 return JSValue();
             }
-            auto scope = DECLARE_THROW_SCOPE(m_exec->vm());
-            JSValue result = JSC::JSWebAssemblyModule::createStub(m_exec->vm(), m_exec, m_globalObject->webAssemblyModuleStructure(), m_wasmModules->at(index));
+            auto scope = DECLARE_THROW_SCOPE(m_lexicalGlobalObject->vm());
+            JSValue result = JSC::JSWebAssemblyModule::createStub(m_lexicalGlobalObject->vm(), m_lexicalGlobalObject, m_globalObject->webAssemblyModuleStructure(), m_wasmModules->at(index));
             // Since we are cloning a JSWebAssemblyModule, it's impossible for that
             // module to not have been a valid module. Therefore, createStub should
             // not trow.
             scope.releaseAssertNoException();
             m_gcBuffer.appendWithCrashOnOverflow(result);
@@ -2942,11 +3090,11 @@
             // array buffers while the sender is. In that case, we would see a null structure here.
             if (!structure) {
                 fail();
                 return JSValue();
             }
-            JSValue result = JSArrayBuffer::create(m_exec->vm(), structure, WTFMove(arrayBuffer));
+            JSValue result = JSArrayBuffer::create(m_lexicalGlobalObject->vm(), structure, WTFMove(arrayBuffer));
             m_gcBuffer.appendWithCrashOnOverflow(result);
             return result;
         }
         case ArrayBufferTransferTag: {
             uint32_t index;
@@ -2975,11 +3123,11 @@
             m_gcBuffer.appendWithCrashOnOverflow(result);
             return result;
         }
         case ArrayBufferViewTag: {
             JSValue arrayBufferView;
-            if (!readArrayBufferView(m_exec->vm(), arrayBufferView)) {
+            if (!readArrayBufferView(m_lexicalGlobalObject->vm(), arrayBufferView)) {
                 fail();
                 return JSValue();
             }
             m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
             return arrayBufferView;
@@ -2990,21 +3138,17 @@
             if (!read(wrappedKey)) {
                 fail();
                 return JSValue();
             }
             Vector<uint8_t> serializedKey;
-            if (!unwrapCryptoKey(m_exec, wrappedKey, serializedKey)) {
+            if (!unwrapCryptoKey(m_lexicalGlobalObject, wrappedKey, serializedKey)) {
                 fail();
                 return JSValue();
             }
             JSValue cryptoKey;
             Vector<RefPtr<MessagePort>> dummyMessagePorts;
-            CloneDeserializer rawKeyDeserializer(m_exec, m_globalObject, dummyMessagePorts, nullptr, { },
-#if ENABLE(WEBASSEMBLY)
-                nullptr,
-#endif
-                serializedKey);
+            CloneDeserializer rawKeyDeserializer(m_lexicalGlobalObject, m_globalObject, dummyMessagePorts, nullptr, { }, serializedKey);
             if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
                 fail();
                 return JSValue();
             }
             m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
@@ -3024,15 +3168,21 @@
         case DOMMatrixTag:
             return readDOMMatrix<DOMMatrix>();
         case DOMQuadTag:
             return readDOMQuad();
         case ImageBitmapTransferTag:
-            return readImageBitmap();
+            return readTransferredImageBitmap();
 #if ENABLE(WEB_RTC)
         case RTCCertificateTag:
             return readRTCCertificate();
 
+#endif
+        case ImageBitmapTag:
+            return readImageBitmap();
+#if ENABLE(OFFSCREEN_CANVAS)
+        case OffscreenCanvasTransferTag:
+            return readOffscreenCanvas();
 #endif
         default:
             m_ptr--; // Push the tag back
             return JSValue();
         }
@@ -3059,10 +3209,14 @@
     Vector<String> m_blobURLs;
     Vector<String> m_blobFilePaths;
     ArrayBufferContentsArray* m_sharedBuffers;
     Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>> m_imageBuffers;
     Vector<RefPtr<ImageBitmap>> m_imageBitmaps;
+#if ENABLE(OFFSCREEN_CANVAS)
+    Vector<std::unique_ptr<DetachedOffscreenCanvas>> m_detachedOffscreenCanvases;
+    Vector<RefPtr<OffscreenCanvas>> m_offscreenCanvases;
+#endif
 #if ENABLE(WEBASSEMBLY)
     WasmModuleArray* m_wasmModules;
 #endif
 
     String blobFilePathForBlobURL(const String& blobURL)
@@ -3077,33 +3231,33 @@
     }
 };
 
 DeserializationResult CloneDeserializer::deserialize()
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_lexicalGlobalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     Vector<uint32_t, 16> indexStack;
     Vector<Identifier, 16> propertyNameStack;
     Vector<JSObject*, 32> outputObjectStack;
     Vector<JSValue, 4> mapKeyStack;
     Vector<JSMap*, 4> mapStack;
     Vector<JSSet*, 4> setStack;
     Vector<WalkerState, 16> stateStack;
-    WalkerState state = StateUnknown;
+    WalkerState lexicalGlobalObject = StateUnknown;
     JSValue outValue;
 
     while (1) {
-        switch (state) {
+        switch (lexicalGlobalObject) {
         arrayStartState:
         case ArrayStartState: {
             uint32_t length;
             if (!read(length)) {
                 fail();
                 goto error;
             }
-            JSArray* outArray = constructEmptyArray(m_exec, 0, m_globalObject, length);
+            JSArray* outArray = constructEmptyArray(m_globalObject, static_cast<JSC::ArrayAllocationProfile*>(nullptr), length);
             if (UNLIKELY(scope.exception()))
                 goto error;
             m_gcBuffer.appendWithCrashOnOverflow(outArray);
             outputObjectStack.append(outArray);
         }
@@ -3142,11 +3296,11 @@
         }
         objectStartState:
         case ObjectStartState: {
             if (outputObjectStack.size() > maximumFilterRecursion)
                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
-            JSObject* outObject = constructEmptyObject(m_exec, m_globalObject->objectPrototype());
+            JSObject* outObject = constructEmptyObject(m_lexicalGlobalObject, m_globalObject->objectPrototype());
             m_gcBuffer.appendWithCrashOnOverflow(outObject);
             outputObjectStack.append(outObject);
         }
         objectStartVisitMember:
         FALLTHROUGH;
@@ -3177,11 +3331,11 @@
             goto objectStartVisitMember;
         }
         mapObjectStartState: {
             if (outputObjectStack.size() > maximumFilterRecursion)
                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
-            JSMap* map = JSMap::create(m_exec, m_exec->vm(), m_globalObject->mapStructure());
+            JSMap* map = JSMap::create(m_lexicalGlobalObject, m_lexicalGlobalObject->vm(), m_globalObject->mapStructure());
             if (UNLIKELY(scope.exception()))
                 goto error;
             m_gcBuffer.appendWithCrashOnOverflow(map);
             outputObjectStack.append(map);
             mapStack.append(map);
@@ -3200,19 +3354,19 @@
             mapKeyStack.append(outValue);
             stateStack.append(MapDataEndVisitValue);
             goto stateUnknown;
         }
         case MapDataEndVisitValue: {
-            mapStack.last()->set(m_exec, mapKeyStack.last(), outValue);
+            mapStack.last()->set(m_lexicalGlobalObject, mapKeyStack.last(), outValue);
             mapKeyStack.removeLast();
             goto mapDataStartVisitEntry;
         }
 
         setObjectStartState: {
             if (outputObjectStack.size() > maximumFilterRecursion)
                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
-            JSSet* set = JSSet::create(m_exec, m_exec->vm(), m_globalObject->setStructure());
+            JSSet* set = JSSet::create(m_lexicalGlobalObject, m_lexicalGlobalObject->vm(), m_globalObject->setStructure());
             if (UNLIKELY(scope.exception()))
                 goto error;
             m_gcBuffer.appendWithCrashOnOverflow(set);
             outputObjectStack.append(set);
             setStack.append(set);
@@ -3227,11 +3381,11 @@
             stateStack.append(SetDataEndVisitKey);
             goto stateUnknown;
         }
         case SetDataEndVisitKey: {
             JSSet* set = setStack.last();
-            set->add(m_exec, outValue);
+            set->add(m_lexicalGlobalObject, outValue);
             goto setDataStartVisitEntry;
         }
 
         stateUnknown:
         case StateUnknown:
@@ -3251,11 +3405,11 @@
             goto error;
         }
         if (stateStack.isEmpty())
             break;
 
-        state = stateStack.last();
+        lexicalGlobalObject = stateStack.last();
         stateStack.removeLast();
     }
     ASSERT(outValue);
     ASSERT(!m_failed);
     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
@@ -3276,18 +3430,24 @@
     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
 {
 }
 
 SerializedScriptValue::SerializedScriptValue(Vector<uint8_t>&& buffer, const Vector<String>& blobURLs, std::unique_ptr<ArrayBufferContentsArray> arrayBufferContentsArray, std::unique_ptr<ArrayBufferContentsArray> sharedBufferContentsArray, Vector<std::pair<std::unique_ptr<ImageBuffer>, bool>>&& imageBuffers
+#if ENABLE(OFFSCREEN_CANVAS)
+        , Vector<std::unique_ptr<DetachedOffscreenCanvas>>&& detachedOffscreenCanvases
+#endif
 #if ENABLE(WEBASSEMBLY)
         , std::unique_ptr<WasmModuleArray> wasmModulesArray
 #endif
         )
     : m_data(WTFMove(buffer))
     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
     , m_imageBuffers(WTFMove(imageBuffers))
+#if ENABLE(OFFSCREEN_CANVAS)
+    , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))
+#endif
 #if ENABLE(WEBASSEMBLY)
     , m_wasmModulesArray(WTFMove(wasmModulesArray))
 #endif
 {
     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
@@ -3316,26 +3476,26 @@
     }
 
     return contents;
 }
 
-static void maybeThrowExceptionIfSerializationFailed(ExecState& state, SerializationReturnCode code)
+static void maybeThrowExceptionIfSerializationFailed(JSGlobalObject& lexicalGlobalObject, SerializationReturnCode code)
 {
-    auto& vm = state.vm();
+    auto& vm = lexicalGlobalObject.vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     switch (code) {
     case SerializationReturnCode::SuccessfullyCompleted:
         break;
     case SerializationReturnCode::StackOverflowError:
-        throwException(&state, scope, createStackOverflowError(&state));
+        throwException(&lexicalGlobalObject, scope, createStackOverflowError(&lexicalGlobalObject));
         break;
     case SerializationReturnCode::ValidationError:
-        throwTypeError(&state, scope, "Unable to deserialize data."_s);
+        throwTypeError(&lexicalGlobalObject, scope, "Unable to deserialize data."_s);
         break;
     case SerializationReturnCode::DataCloneError:
-        throwDataCloneError(state, scope);
+        throwDataCloneError(lexicalGlobalObject, scope);
         break;
     case SerializationReturnCode::ExistingExceptionError:
     case SerializationReturnCode::UnspecifiedError:
         break;
     case SerializationReturnCode::InterruptedExecutionError:
@@ -3365,42 +3525,44 @@
     }
     ASSERT_NOT_REACHED();
     return Exception { TypeError };
 }
 
-RefPtr<SerializedScriptValue> SerializedScriptValue::create(ExecState& exec, JSValue value, SerializationErrorMode throwExceptions)
+RefPtr<SerializedScriptValue> SerializedScriptValue::create(JSGlobalObject& lexicalGlobalObject, JSValue value, SerializationErrorMode throwExceptions)
 {
     Vector<uint8_t> buffer;
     Vector<String> blobURLs;
     Vector<RefPtr<MessagePort>> dummyMessagePorts;
     Vector<RefPtr<ImageBitmap>> dummyImageBitmaps;
+#if ENABLE(OFFSCREEN_CANVAS)
+    Vector<RefPtr<OffscreenCanvas>> dummyOffscreenCanvases;
+#endif
     Vector<RefPtr<JSC::ArrayBuffer>> dummyArrayBuffers;
 #if ENABLE(WEBASSEMBLY)
     WasmModuleArray dummyModules;
 #endif
     ArrayBufferContentsArray dummySharedBuffers;
-    auto code = CloneSerializer::serialize(&exec, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,
+    auto code = CloneSerializer::serialize(&lexicalGlobalObject, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,
+#if ENABLE(OFFSCREEN_CANVAS)
+        dummyOffscreenCanvases,
+#endif
 #if ENABLE(WEBASSEMBLY)
         dummyModules,
 #endif
         blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);
 
 #if ENABLE(WEBASSEMBLY)
     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), "Wasm::Module serialization is only allowed in the postMessage context");
 #endif
 
     if (throwExceptions == SerializationErrorMode::Throwing)
-        maybeThrowExceptionIfSerializationFailed(exec, code);
+        maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, code);
 
     if (code != SerializationReturnCode::SuccessfullyCompleted)
         return nullptr;
 
-    return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }
-#if ENABLE(WEBASSEMBLY)
-        , nullptr
-#endif
-            ));
+    return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }));
 }
 
 static bool containsDuplicates(const Vector<RefPtr<ImageBitmap>>& imageBitmaps)
 {
     HashSet<ImageBitmap*> visited;
@@ -3409,22 +3571,40 @@
             return true;
     }
     return false;
 }
 
-ExceptionOr<Ref<SerializedScriptValue>> SerializedScriptValue::create(ExecState& state, JSValue value, Vector<JSC::Strong<JSC::JSObject>>&& transferList, Vector<RefPtr<MessagePort>>& messagePorts, SerializationContext context)
+#if ENABLE(OFFSCREEN_CANVAS)
+static bool canOffscreenCanvasesDetach(const Vector<RefPtr<OffscreenCanvas>>& offscreenCanvases)
+{
+    HashSet<OffscreenCanvas*> visited;
+    for (auto& offscreenCanvas : offscreenCanvases) {
+        if (!offscreenCanvas->canDetach())
+            return false;
+        // Check the return value of add, we should not encounter duplicates.
+        if (!visited.add(offscreenCanvas.get()))
+            return false;
+    }
+    return true;
+}
+#endif
+
+ExceptionOr<Ref<SerializedScriptValue>> SerializedScriptValue::create(JSGlobalObject& lexicalGlobalObject, JSValue value, Vector<JSC::Strong<JSC::JSObject>>&& transferList, Vector<RefPtr<MessagePort>>& messagePorts, SerializationContext context)
 {
-    VM& vm = state.vm();
+    VM& vm = lexicalGlobalObject.vm();
     Vector<RefPtr<JSC::ArrayBuffer>> arrayBuffers;
     Vector<RefPtr<ImageBitmap>> imageBitmaps;
+#if ENABLE(OFFSCREEN_CANVAS)
+    Vector<RefPtr<OffscreenCanvas>> offscreenCanvases;
+#endif
     for (auto& transferable : transferList) {
         if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
             if (arrayBuffer->isNeutered())
                 return Exception { DataCloneError };
             if (arrayBuffer->isLocked()) {
                 auto scope = DECLARE_THROW_SCOPE(vm);
-                throwVMTypeError(&state, scope, errorMesasgeForTransfer(arrayBuffer));
+                throwVMTypeError(&lexicalGlobalObject, scope, errorMesasgeForTransfer(arrayBuffer));
                 return Exception { ExistingExceptionError };
             }
             arrayBuffers.append(WTFMove(arrayBuffer));
             continue;
         }
@@ -3440,23 +3620,37 @@
 
             imageBitmaps.append(WTFMove(imageBitmap));
             continue;
         }
 
+#if ENABLE(OFFSCREEN_CANVAS)
+        if (auto offscreenCanvas = JSOffscreenCanvas::toWrapped(vm, transferable.get())) {
+            offscreenCanvases.append(WTFMove(offscreenCanvas));
+            continue;
+        }
+#endif
+
         return Exception { DataCloneError };
     }
 
     if (containsDuplicates(imageBitmaps))
         return Exception { DataCloneError };
+#if ENABLE(OFFSCREEN_CANVAS)
+    if (!canOffscreenCanvasesDetach(offscreenCanvases))
+        return Exception { InvalidStateError };
+#endif
 
     Vector<uint8_t> buffer;
     Vector<String> blobURLs;
 #if ENABLE(WEBASSEMBLY)
     WasmModuleArray wasmModules;
 #endif
     std::unique_ptr<ArrayBufferContentsArray> sharedBuffers = makeUnique<ArrayBufferContentsArray>();
-    auto code = CloneSerializer::serialize(&state, value, messagePorts, arrayBuffers, imageBitmaps,
+    auto code = CloneSerializer::serialize(&lexicalGlobalObject, value, messagePorts, arrayBuffers, imageBitmaps,
+#if ENABLE(OFFSCREEN_CANVAS)
+        offscreenCanvases,
+#endif
 #if ENABLE(WEBASSEMBLY)
         wasmModules,
 #endif
         blobURLs, buffer, context, *sharedBuffers);
 
@@ -3467,11 +3661,20 @@
     if (arrayBufferContentsArray.hasException())
         return arrayBufferContentsArray.releaseException();
 
     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
 
+#if ENABLE(OFFSCREEN_CANVAS)
+    Vector<std::unique_ptr<DetachedOffscreenCanvas>> detachedCanvases;
+    for (auto offscreenCanvas : offscreenCanvases)
+        detachedCanvases.append(offscreenCanvas->detach());
+#endif
+
     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)
+#if ENABLE(OFFSCREEN_CANVAS)
+                , WTFMove(detachedCanvases)
+#endif
 #if ENABLE(WEBASSEMBLY)
                 , makeUnique<WasmModuleArray>(wasmModules)
 #endif
                 ));
 }
@@ -3484,20 +3687,20 @@
     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
 }
 
 RefPtr<SerializedScriptValue> SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
 {
-    ExecState* exec = toJS(originContext);
-    VM& vm = exec->vm();
+    JSGlobalObject* lexicalGlobalObject = toJS(originContext);
+    VM& vm = lexicalGlobalObject->vm();
     JSLockHolder locker(vm);
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
-    JSValue value = toJS(exec, apiValue);
-    auto serializedValue = SerializedScriptValue::create(*exec, value);
+    JSValue value = toJS(lexicalGlobalObject, apiValue);
+    auto serializedValue = SerializedScriptValue::create(*lexicalGlobalObject, value);
     if (UNLIKELY(scope.exception())) {
         if (exception)
-            *exception = toRef(exec, scope.exception()->value());
+            *exception = toRef(lexicalGlobalObject, scope.exception()->value());
         scope.clearException();
         return nullptr;
     }
     ASSERT(serializedValue);
     return serializedValue;
@@ -3506,50 +3709,54 @@
 String SerializedScriptValue::toString()
 {
     return CloneDeserializer::deserializeString(m_data);
 }
 
-JSValue SerializedScriptValue::deserialize(ExecState& exec, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)
+JSValue SerializedScriptValue::deserialize(JSGlobalObject& lexicalGlobalObject, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)
 {
-    return deserialize(exec, globalObject, { }, throwExceptions);
+    return deserialize(lexicalGlobalObject, globalObject, { }, throwExceptions);
 }
 
-JSValue SerializedScriptValue::deserialize(ExecState& exec, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, SerializationErrorMode throwExceptions)
+JSValue SerializedScriptValue::deserialize(JSGlobalObject& lexicalGlobalObject, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, SerializationErrorMode throwExceptions)
 {
     Vector<String> dummyBlobs;
     Vector<String> dummyPaths;
-    return deserialize(exec, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);
+    return deserialize(lexicalGlobalObject, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);
 }
 
-JSValue SerializedScriptValue::deserialize(ExecState& exec, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, const Vector<String>& blobURLs, const Vector<String>& blobFilePaths, SerializationErrorMode throwExceptions)
+JSValue SerializedScriptValue::deserialize(JSGlobalObject& lexicalGlobalObject, JSGlobalObject* globalObject, const Vector<RefPtr<MessagePort>>& messagePorts, const Vector<String>& blobURLs, const Vector<String>& blobFilePaths, SerializationErrorMode throwExceptions)
 {
-    DeserializationResult result = CloneDeserializer::deserialize(&exec, globalObject, messagePorts, WTFMove(m_imageBuffers), m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()
+    DeserializationResult result = CloneDeserializer::deserialize(&lexicalGlobalObject, globalObject, messagePorts, WTFMove(m_imageBuffers)
+#if ENABLE(OFFSCREEN_CANVAS)
+        , WTFMove(m_detachedOffscreenCanvases)
+#endif
+        , m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()
 #if ENABLE(WEBASSEMBLY)
         , m_wasmModulesArray.get()
 #endif
         );
     if (throwExceptions == SerializationErrorMode::Throwing)
-        maybeThrowExceptionIfSerializationFailed(exec, result.second);
+        maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, result.second);
     return result.first ? result.first : jsNull();
 }
 
 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
 {
-    ExecState* exec = toJS(destinationContext);
-    VM& vm = exec->vm();
+    JSGlobalObject* lexicalGlobalObject = toJS(destinationContext);
+    VM& vm = lexicalGlobalObject->vm();
     JSLockHolder locker(vm);
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
-    JSValue value = deserialize(*exec, exec->lexicalGlobalObject());
+    JSValue value = deserialize(*lexicalGlobalObject, lexicalGlobalObject);
     if (UNLIKELY(scope.exception())) {
         if (exception)
-            *exception = toRef(exec, scope.exception()->value());
+            *exception = toRef(lexicalGlobalObject, scope.exception()->value());
         scope.clearException();
         return nullptr;
     }
     ASSERT(value);
-    return toRef(exec, value);
+    return toRef(lexicalGlobalObject, value);
 }
 
 Ref<SerializedScriptValue> SerializedScriptValue::nullValue()
 {
     return adoptRef(*new SerializedScriptValue(Vector<uint8_t>()));
@@ -3569,16 +3776,16 @@
         result.uncheckedAppend(url.isolatedCopy());
 
     return result;
 }
 
-void SerializedScriptValue::writeBlobsToDiskForIndexedDB(PAL::SessionID sessionID, CompletionHandler<void(IDBValue&&)>&& completionHandler)
+void SerializedScriptValue::writeBlobsToDiskForIndexedDB(CompletionHandler<void(IDBValue&&)>&& completionHandler)
 {
     ASSERT(isMainThread());
     ASSERT(hasBlobURLs());
 
-    blobRegistry().writeBlobsToTemporaryFiles(sessionID, m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&& blobFilePaths) mutable {
+    blobRegistry().writeBlobsToTemporaryFiles(m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&& blobFilePaths) mutable {
         ASSERT(isMainThread());
 
         if (blobFilePaths.isEmpty()) {
             // We should have successfully written blobs to temporary files.
             // If we failed, then we can't successfully store this record.
@@ -3590,21 +3797,21 @@
 
         completionHandler({ *this, m_blobURLs, blobFilePaths });
     });
 }
 
-IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously(PAL::SessionID sessionID)
+IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously()
 {
     ASSERT(!isMainThread());
 
     IDBValue value;
     Lock lock;
     Condition condition;
     lock.lock();
 
-    RunLoop::main().dispatch([this, sessionID, conditionPtr = &condition, valuePtr = &value] {
-        writeBlobsToDiskForIndexedDB(sessionID, [conditionPtr, valuePtr](IDBValue&& result) {
+    RunLoop::main().dispatch([this, conditionPtr = &condition, valuePtr = &value] {
+        writeBlobsToDiskForIndexedDB([conditionPtr, valuePtr](IDBValue&& result) {
             ASSERT(isMainThread());
             valuePtr->setAsIsolatedCopy(result);
 
             conditionPtr->notifyAll();
         });

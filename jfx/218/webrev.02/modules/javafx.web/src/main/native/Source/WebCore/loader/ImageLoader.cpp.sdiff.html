<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/ImageLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HistoryController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/ImageLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;ImageLoader.h&quot;
 24 
 25 #include &quot;BitmapImage.h&quot;
 26 #include &quot;CachedImage.h&quot;
 27 #include &quot;CachedResourceLoader.h&quot;
 28 #include &quot;CachedResourceRequest.h&quot;
 29 #include &quot;CrossOriginAccessControl.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;EventSender.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;HTMLNames.h&quot;
 38 #include &quot;HTMLObjectElement.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;InspectorInstrumentation.h&quot;

 41 #include &quot;Page.h&quot;
 42 #include &quot;RenderImage.h&quot;
 43 #include &quot;RenderSVGImage.h&quot;
 44 #include &lt;wtf/NeverDestroyed.h&gt;
 45 
 46 #if ENABLE(VIDEO)
 47 #include &quot;RenderVideo.h&quot;
 48 #endif
 49 
<span class="line-modified"> 50 #if !ASSERT_DISABLED</span>
 51 // ImageLoader objects are allocated as members of other objects, so generic pointer check would always fail.
 52 namespace WTF {
 53 
 54 template&lt;&gt; struct ValueCheck&lt;WebCore::ImageLoader*&gt; {
 55     typedef WebCore::ImageLoader* TraitType;
 56     static void checkConsistency(const WebCore::ImageLoader* p)
 57     {
 58         if (!p)
 59             return;
 60         ValueCheck&lt;WebCore::Element*&gt;::checkConsistency(&amp;p-&gt;element());
 61     }
 62 };
 63 
<span class="line-modified"> 64 }</span>
<span class="line-modified"> 65 #endif</span>
 66 
 67 namespace WebCore {
 68 
 69 static ImageEventSender&amp; beforeLoadEventSender()
 70 {
 71     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().beforeloadEvent);
 72     return sender;
 73 }
 74 
 75 static ImageEventSender&amp; loadEventSender()
 76 {
 77     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().loadEvent);
 78     return sender;
 79 }
 80 
 81 static ImageEventSender&amp; errorEventSender()
 82 {
 83     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().errorEvent);
 84     return sender;
 85 }
</pre>
<hr />
<pre>
167 
168     AtomString attr = element().imageSourceURL();
169 
170     // Avoid loading a URL we already failed to load.
171     if (!m_failedLoadURL.isEmpty() &amp;&amp; attr == m_failedLoadURL)
172         return;
173 
174     // Do not load any image if the &#39;src&#39; attribute is missing or if it is
175     // an empty string.
176     CachedResourceHandle&lt;CachedImage&gt; newImage = nullptr;
177     if (!attr.isNull() &amp;&amp; !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
178         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
179         options.contentSecurityPolicyImposition = element().isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
180         options.sameOriginDataURLFlag = SameOriginDataURLFlag::Set;
181 
182         auto crossOriginAttribute = element().attributeWithoutSynchronization(HTMLNames::crossoriginAttr);
183 
184         ResourceRequest resourceRequest(document.completeURL(sourceURI(attr)));
185         resourceRequest.setInspectorInitiatorNodeIdentifier(InspectorInstrumentation::identifierForNode(m_element));
186 
<span class="line-modified">187         auto request = createPotentialAccessControlRequest(WTFMove(resourceRequest), document, crossOriginAttribute, WTFMove(options));</span>
188         request.setInitiator(element());
189 
190         if (m_loadManually) {
191             bool autoLoadOtherImages = document.cachedResourceLoader().autoLoadImages();
192             document.cachedResourceLoader().setAutoLoadImages(false);
193             auto* page = m_element.document().page();
194             newImage = new CachedImage(WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());
195             newImage-&gt;setStatus(CachedResource::Pending);
196             newImage-&gt;setLoading(true);
197             document.cachedResourceLoader().m_documentResources.set(newImage-&gt;url(), newImage.get());
198             document.cachedResourceLoader().setAutoLoadImages(autoLoadOtherImages);
199         } else
200             newImage = document.cachedResourceLoader().requestImage(WTFMove(request)).value_or(nullptr);
201 
202         // If we do not have an image here, it means that a cross-site
203         // violation occurred, or that the image was blocked via Content
204         // Security Policy, or the page is being dismissed. Trigger an
205         // error event if the page is not being dismissed.
206         if (!newImage &amp;&amp; !pageIsBeingDismissed(document)) {
207             m_failedLoadURL = attr;
</pre>
</td>
<td>
<hr />
<pre>
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;ImageLoader.h&quot;
 24 
 25 #include &quot;BitmapImage.h&quot;
 26 #include &quot;CachedImage.h&quot;
 27 #include &quot;CachedResourceLoader.h&quot;
 28 #include &quot;CachedResourceRequest.h&quot;
 29 #include &quot;CrossOriginAccessControl.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;EventSender.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;HTMLNames.h&quot;
 38 #include &quot;HTMLObjectElement.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added"> 41 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 42 #include &quot;Page.h&quot;
 43 #include &quot;RenderImage.h&quot;
 44 #include &quot;RenderSVGImage.h&quot;
 45 #include &lt;wtf/NeverDestroyed.h&gt;
 46 
 47 #if ENABLE(VIDEO)
 48 #include &quot;RenderVideo.h&quot;
 49 #endif
 50 
<span class="line-modified"> 51 #if ASSERT_ENABLED</span>
 52 // ImageLoader objects are allocated as members of other objects, so generic pointer check would always fail.
 53 namespace WTF {
 54 
 55 template&lt;&gt; struct ValueCheck&lt;WebCore::ImageLoader*&gt; {
 56     typedef WebCore::ImageLoader* TraitType;
 57     static void checkConsistency(const WebCore::ImageLoader* p)
 58     {
 59         if (!p)
 60             return;
 61         ValueCheck&lt;WebCore::Element*&gt;::checkConsistency(&amp;p-&gt;element());
 62     }
 63 };
 64 
<span class="line-modified"> 65 } // namespace WTF</span>
<span class="line-modified"> 66 #endif // ASSERT_ENABLED</span>
 67 
 68 namespace WebCore {
 69 
 70 static ImageEventSender&amp; beforeLoadEventSender()
 71 {
 72     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().beforeloadEvent);
 73     return sender;
 74 }
 75 
 76 static ImageEventSender&amp; loadEventSender()
 77 {
 78     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().loadEvent);
 79     return sender;
 80 }
 81 
 82 static ImageEventSender&amp; errorEventSender()
 83 {
 84     static NeverDestroyed&lt;ImageEventSender&gt; sender(eventNames().errorEvent);
 85     return sender;
 86 }
</pre>
<hr />
<pre>
168 
169     AtomString attr = element().imageSourceURL();
170 
171     // Avoid loading a URL we already failed to load.
172     if (!m_failedLoadURL.isEmpty() &amp;&amp; attr == m_failedLoadURL)
173         return;
174 
175     // Do not load any image if the &#39;src&#39; attribute is missing or if it is
176     // an empty string.
177     CachedResourceHandle&lt;CachedImage&gt; newImage = nullptr;
178     if (!attr.isNull() &amp;&amp; !stripLeadingAndTrailingHTMLSpaces(attr).isEmpty()) {
179         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
180         options.contentSecurityPolicyImposition = element().isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
181         options.sameOriginDataURLFlag = SameOriginDataURLFlag::Set;
182 
183         auto crossOriginAttribute = element().attributeWithoutSynchronization(HTMLNames::crossoriginAttr);
184 
185         ResourceRequest resourceRequest(document.completeURL(sourceURI(attr)));
186         resourceRequest.setInspectorInitiatorNodeIdentifier(InspectorInstrumentation::identifierForNode(m_element));
187 
<span class="line-modified">188         auto request = createPotentialAccessControlRequest(WTFMove(resourceRequest), WTFMove(options), document, crossOriginAttribute);</span>
189         request.setInitiator(element());
190 
191         if (m_loadManually) {
192             bool autoLoadOtherImages = document.cachedResourceLoader().autoLoadImages();
193             document.cachedResourceLoader().setAutoLoadImages(false);
194             auto* page = m_element.document().page();
195             newImage = new CachedImage(WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());
196             newImage-&gt;setStatus(CachedResource::Pending);
197             newImage-&gt;setLoading(true);
198             document.cachedResourceLoader().m_documentResources.set(newImage-&gt;url(), newImage.get());
199             document.cachedResourceLoader().setAutoLoadImages(autoLoadOtherImages);
200         } else
201             newImage = document.cachedResourceLoader().requestImage(WTFMove(request)).value_or(nullptr);
202 
203         // If we do not have an image here, it means that a cross-site
204         // violation occurred, or that the image was blocked via Content
205         // Security Policy, or the page is being dismissed. Trigger an
206         // error event if the page is not being dismissed.
207         if (!newImage &amp;&amp; !pageIsBeingDismissed(document)) {
208             m_failedLoadURL = attr;
</pre>
</td>
</tr>
</table>
<center><a href="HistoryController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ImageLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
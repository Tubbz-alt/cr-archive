<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/GCSegmentedArrayInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;GCSegmentedArray.h&quot;
 29 
 30 namespace JSC {
 31 
 32 template &lt;typename T&gt;
 33 GCSegmentedArray&lt;T&gt;::GCSegmentedArray()
 34     : m_top(0)
 35     , m_numberOfSegments(0)
 36 {
 37     m_segments.push(GCArraySegment&lt;T&gt;::create());
 38     m_numberOfSegments++;
 39 }
 40 
 41 template &lt;typename T&gt;
 42 GCSegmentedArray&lt;T&gt;::~GCSegmentedArray()
 43 {
 44     ASSERT(m_numberOfSegments == 1);
 45     ASSERT(m_segments.size() == 1);
 46     GCArraySegment&lt;T&gt;::destroy(m_segments.removeHead());
 47     m_numberOfSegments--;
 48     ASSERT(!m_numberOfSegments);
 49     ASSERT(!m_segments.size());
 50 }
 51 
 52 template &lt;typename T&gt;
 53 void GCSegmentedArray&lt;T&gt;::clear()
 54 {
 55     if (!m_segments.head())
 56         return;
 57     GCArraySegment&lt;T&gt;* next;
 58     for (GCArraySegment&lt;T&gt;* current = m_segments.head(); current-&gt;next(); current = next) {
 59         next = current-&gt;next();
 60         m_segments.remove(current);
 61         GCArraySegment&lt;T&gt;::destroy(current);
 62     }
 63     m_top = 0;
 64     m_numberOfSegments = 1;
<a name="1" id="anc1"></a><span class="line-modified"> 65 #if !ASSERT_DISABLED</span>
 66     m_segments.head()-&gt;m_top = 0;
 67 #endif
 68 }
 69 
 70 template &lt;typename T&gt;
 71 void GCSegmentedArray&lt;T&gt;::expand()
 72 {
 73     ASSERT(m_segments.head()-&gt;m_top == s_segmentCapacity);
 74 
 75     GCArraySegment&lt;T&gt;* nextSegment = GCArraySegment&lt;T&gt;::create();
 76     m_numberOfSegments++;
 77 
<a name="2" id="anc2"></a><span class="line-modified"> 78 #if !ASSERT_DISABLED</span>
 79     nextSegment-&gt;m_top = 0;
 80 #endif
 81 
 82     m_segments.push(nextSegment);
 83     setTopForEmptySegment();
 84     validatePrevious();
 85 }
 86 
 87 template &lt;typename T&gt;
 88 bool GCSegmentedArray&lt;T&gt;::refill()
 89 {
 90     validatePrevious();
 91     if (top())
 92         return true;
 93     GCArraySegment&lt;T&gt;::destroy(m_segments.removeHead());
 94     ASSERT(m_numberOfSegments &gt; 1);
 95     m_numberOfSegments--;
 96     setTopForFullSegment();
 97     validatePrevious();
 98     return true;
 99 }
100 
101 template &lt;typename T&gt;
102 void GCSegmentedArray&lt;T&gt;::fillVector(Vector&lt;T&gt;&amp; vector)
103 {
104     ASSERT(vector.size() == size());
105 
106     GCArraySegment&lt;T&gt;* currentSegment = m_segments.head();
107     if (!currentSegment)
108         return;
109 
110     unsigned count = 0;
111     for (unsigned i = 0; i &lt; m_top; ++i) {
112         ASSERT(currentSegment-&gt;data()[i]);
113         vector[count++] = currentSegment-&gt;data()[i];
114     }
115 
116     currentSegment = currentSegment-&gt;next();
117     while (currentSegment) {
118         for (unsigned i = 0; i &lt; s_segmentCapacity; ++i) {
119             ASSERT(currentSegment-&gt;data()[i]);
120             vector[count++] = currentSegment-&gt;data()[i];
121         }
122         currentSegment = currentSegment-&gt;next();
123     }
124 }
125 
126 template &lt;typename T&gt;
127 inline GCArraySegment&lt;T&gt;* GCArraySegment&lt;T&gt;::create()
128 {
<a name="3" id="anc3"></a><span class="line-modified">129     return new (NotNull, fastMalloc(blockSize)) GCArraySegment&lt;T&gt;();</span>
130 }
131 
132 template &lt;typename T&gt;
133 inline void GCArraySegment&lt;T&gt;::destroy(GCArraySegment* segment)
134 {
135     segment-&gt;~GCArraySegment();
<a name="4" id="anc4"></a><span class="line-modified">136     fastFree(segment);</span>
137 }
138 
139 template &lt;typename T&gt;
140 inline size_t GCSegmentedArray&lt;T&gt;::postIncTop()
141 {
142     size_t result = m_top++;
143     ASSERT(result == m_segments.head()-&gt;m_top++);
144     return result;
145 }
146 
147 template &lt;typename T&gt;
148 inline size_t GCSegmentedArray&lt;T&gt;::preDecTop()
149 {
150     size_t result = --m_top;
151     ASSERT(result == --m_segments.head()-&gt;m_top);
152     return result;
153 }
154 
155 template &lt;typename T&gt;
156 inline void GCSegmentedArray&lt;T&gt;::setTopForFullSegment()
157 {
158     ASSERT(m_segments.head()-&gt;m_top == s_segmentCapacity);
159     m_top = s_segmentCapacity;
160 }
161 
162 template &lt;typename T&gt;
163 inline void GCSegmentedArray&lt;T&gt;::setTopForEmptySegment()
164 {
165     ASSERT(!m_segments.head()-&gt;m_top);
166     m_top = 0;
167 }
168 
169 template &lt;typename T&gt;
170 inline size_t GCSegmentedArray&lt;T&gt;::top()
171 {
172     ASSERT(m_top == m_segments.head()-&gt;m_top);
173     return m_top;
174 }
175 
176 template &lt;typename T&gt;
<a name="5" id="anc5"></a><span class="line-modified">177 #if ASSERT_DISABLED</span>
<span class="line-removed">178 inline void GCSegmentedArray&lt;T&gt;::validatePrevious() { }</span>
<span class="line-removed">179 #else</span>
180 inline void GCSegmentedArray&lt;T&gt;::validatePrevious()
181 {
182     unsigned count = 0;
183     for (GCArraySegment&lt;T&gt;* current = m_segments.head(); current; current = current-&gt;next())
184         count++;
185     ASSERT(m_segments.size() == m_numberOfSegments);
186 }
<a name="6" id="anc6"></a><span class="line-modified">187 #endif</span>


188 
189 template &lt;typename T&gt;
190 inline void GCSegmentedArray&lt;T&gt;::append(T value)
191 {
192     if (m_top == s_segmentCapacity)
193         expand();
194     m_segments.head()-&gt;data()[postIncTop()] = value;
195 }
196 
197 template &lt;typename T&gt;
198 inline bool GCSegmentedArray&lt;T&gt;::canRemoveLast()
199 {
200     return !!m_top;
201 }
202 
203 template &lt;typename T&gt;
204 inline const T GCSegmentedArray&lt;T&gt;::removeLast()
205 {
206     return m_segments.head()-&gt;data()[preDecTop()];
207 }
208 
209 template &lt;typename T&gt;
210 inline bool GCSegmentedArray&lt;T&gt;::isEmpty()
211 {
212     // This happens to be safe to call concurrently. It&#39;s important to preserve that capability.
213     if (m_top)
214         return false;
215     if (m_segments.head()-&gt;next())
216         return false;
217     return true;
218 }
219 
220 template &lt;typename T&gt;
221 inline size_t GCSegmentedArray&lt;T&gt;::size()
222 {
223     return m_top + s_segmentCapacity * (m_numberOfSegments - 1);
224 }
225 
226 } // namespace JSC
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
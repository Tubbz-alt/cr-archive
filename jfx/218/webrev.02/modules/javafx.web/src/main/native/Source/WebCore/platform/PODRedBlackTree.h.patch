diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h
@@ -1,7 +1,8 @@
 /*
  * Copyright (C) 2010 Google Inc. All rights reserved.
+ * Copyright (C) 2019-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -30,100 +31,70 @@
 //
 //   Insertion: O(lg(n))
 //   Deletion:  O(lg(n))
 //   Querying:  O(lg(n))
 //
-// The data type T that is stored in this red-black tree must be only
-// Plain Old Data (POD), or bottom out into POD. It must _not_ rely on
-// having its destructor called. This implementation internally
-// allocates storage in large chunks and does not call the destructor
-// on each object.
-//
 // Type T must supply a default constructor, a copy constructor, and
 // the "<" and "==" operators.
 //
 // In debug mode, printing of the data contained in the tree is
-// enabled. This requires the template specialization to be available:
-//
-//   template<> struct WebCore::ValueToString<T> {
-//       static String string(const T& t);
-//   };
-//
-// Note that when complex types are stored in this red/black tree, it
-// is possible that single invocations of the "<" and "==" operators
-// will be insufficient to describe the ordering of elements in the
-// tree during queries. As a concrete example, consider the case where
-// intervals are stored in the tree sorted by low endpoint. The "<"
-// operator on the Interval class only compares the low endpoint, but
-// the "==" operator takes into account the high endpoint as well.
-// This makes the necessary logic for querying and deletion somewhat
-// more complex. In order to properly handle such situations, the
-// property "needsFullOrderingComparisons" must be set to true on
-// the tree.
+// enabled. This makes use of WTF::TextStream.
 //
 // This red-black tree is designed to be _augmented_; subclasses can
 // add additional and summary information to each node to efficiently
 // store and index more complex data structures. A concrete example is
 // the IntervalTree, which extends each node with a summary statistic
 // to efficiently store one-dimensional intervals.
 //
 // The design of this red-black tree comes from Cormen, Leiserson,
 // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
 
-#ifndef PODRedBlackTree_h
-#define PODRedBlackTree_h
+#pragma once
 
 #include <wtf/Assertions.h>
 #include <wtf/Noncopyable.h>
-#include <wtf/text/ValueToString.h>
+
 #ifndef NDEBUG
 #include <wtf/text/StringBuilder.h>
-#include <wtf/text/WTFString.h>
+#include <wtf/text/TextStream.h>
 #endif
 
+// FIXME: The prefix "POD" here isn't correct; this tree works with non-POD types too.
+// FIXME: Extend WTF::RedBlackTree and implement this on top of it rather than keeping two quite similar class templates around.
+
 namespace WebCore {
 
-template<class T>
-class PODRedBlackTree {
-    WTF_MAKE_FAST_ALLOCATED;
+template<typename T, typename NodeUpdaterType> class PODRedBlackTree {
+    WTF_MAKE_NONCOPYABLE(PODRedBlackTree);
 public:
-    class Node;
+    PODRedBlackTree() = default;
 
-    // Visitor interface for walking all of the tree's elements.
-    class Visitor {
-    public:
-        virtual void visit(const T& data) = 0;
-    protected:
-        virtual ~Visitor() = default;
-    };
-
-    PODRedBlackTree()
-        : m_root(0)
-        , m_needsFullOrderingComparisons(false)
-#ifndef NDEBUG
-        , m_verboseDebugging(false)
-#endif
-    {
-    }
-
-    virtual ~PODRedBlackTree()
+    ~PODRedBlackTree()
     {
         clear();
     }
 
-    // Clearing will delete the contents of the tree. After this call
-    // isInitialized will return false.
     void clear()
     {
-        markFree(m_root);
-        m_root = 0;
+        if (!m_root)
+            return;
+        Node* next;
+        for (Node* node = treeMinimum(m_root); node; node = next) {
+            next = treeSuccessorInPostOrder(node);
+            delete node;
+        }
+        m_root = nullptr;
     }
 
     void add(const T& data)
     {
-        Node* node = new Node(data);
-        insertNode(node);
+        add(T { data });
+    }
+
+    void add(T&& data)
+    {
+        insertNode(new Node(WTFMove(data)));
     }
 
     // Returns true if the datum was found in the tree.
     bool remove(const T& data)
     {
@@ -138,90 +109,57 @@
     bool contains(const T& data) const
     {
         return treeSearch(data);
     }
 
-    void visitInorder(Visitor* visitor) const
+    bool isEmpty() const
     {
-        if (!m_root)
-            return;
-        visitInorderImpl(m_root, visitor);
-    }
-
-    int size() const
-    {
-        Counter counter;
-        visitInorder(&counter);
-        return counter.count();
+        return !m_root;
     }
 
-    // See the class documentation for an explanation of this property.
-    void setNeedsFullOrderingComparisons(bool needsFullOrderingComparisons)
-    {
-        m_needsFullOrderingComparisons = needsFullOrderingComparisons;
-    }
+#ifndef NDEBUG
 
-    virtual bool checkInvariants() const
+    bool checkInvariants() const
     {
         int blackCount;
-        return checkInvariantsFromNode(m_root, &blackCount);
+        return checkInvariantsFromNode(m_root, blackCount);
     }
 
-#ifndef NDEBUG
-    // Dumps the tree's contents to the logging info stream for
-    // debugging purposes.
+    // Dumps the tree's contents to the logging info stream for debugging purposes.
     void dump() const
     {
-        dumpFromNode(m_root, 0);
+        dumpSubtree(m_root, 0);
     }
 
     // Turns on or off verbose debugging of the tree, causing many
     // messages to be logged during insertion and other operations in
     // debug mode.
     void setVerboseDebugging(bool verboseDebugging)
     {
         m_verboseDebugging = verboseDebugging;
     }
+
 #endif
 
-    enum Color {
-        Red = 1,
-        Black
-    };
+protected:
+    enum Color { Red, Black };
 
-    // The base Node class which is stored in the tree. Nodes are only
-    // an internal concept; users of the tree deal only with the data
-    // they store in it.
     class Node {
         WTF_MAKE_FAST_ALLOCATED;
         WTF_MAKE_NONCOPYABLE(Node);
     public:
-        // Constructor. Newly-created nodes are colored red.
-        explicit Node(const T& data)
-            : m_left(0)
-            , m_right(0)
-            , m_parent(0)
-            , m_color(Red)
-            , m_data(data)
+        explicit Node(T&& data)
+            : m_data(WTFMove(data))
         {
         }
 
-        virtual ~Node() = default;
-
         Color color() const { return m_color; }
         void setColor(Color color) { m_color = color; }
 
-        // Fetches the user data.
         T& data() { return m_data; }
 
-        // Copies all user-level fields from the source node, but not
-        // internal fields. For example, the base implementation of this
-        // method copies the "m_data" field, but not the child or parent
-        // fields. Any augmentation information also does not need to be
-        // copied, as it will be recomputed. Subclasses must call the
-        // superclass implementation.
-        virtual void copyFrom(Node* src) { m_data = src->data(); }
+        void moveDataFrom(Node& src) { m_data = WTFMove(src.m_data); }
 
         Node* left() const { return m_left; }
         void setLeft(Node* node) { m_left = node; }
 
         Node* right() const { return m_right; }
@@ -229,84 +167,51 @@
 
         Node* parent() const { return m_parent; }
         void setParent(Node* node) { m_parent = node; }
 
     private:
-        Node* m_left;
-        Node* m_right;
-        Node* m_parent;
-        Color m_color;
+        Node* m_left { nullptr };
+        Node* m_right { nullptr };
+        Node* m_parent { nullptr };
+        Color m_color { Red };
         T m_data;
     };
 
-protected:
     // Returns the root of the tree, which is needed by some subclasses.
     Node* root() const { return m_root; }
 
 private:
-    // This virtual method is the hook that subclasses should use when
+    // The update function is the hook that subclasses should use when
     // augmenting the red-black tree with additional per-node summary
     // information. For example, in the case of an interval tree, this
     // is used to compute the maximum endpoint of the subtree below the
     // given node based on the values in the left and right children. It
     // is guaranteed that this will be called in the correct order to
     // properly update such summary information based only on the values
-    // in the left and right children. This method should return true if
+    // in the left and right children. The function should return true if
     // the node's summary information changed.
-    virtual bool updateNode(Node*) { return false; }
-
-    //----------------------------------------------------------------------
-    // Generic binary search tree operations
-    //
-
-    // Searches the tree for the given datum.
-    Node* treeSearch(const T& data) const
+    static bool updateNode(Node& node)
     {
-        if (m_needsFullOrderingComparisons)
-            return treeSearchFullComparisons(m_root, data);
-
-        return treeSearchNormal(m_root, data);
+        return NodeUpdaterType::update(node);
     }
 
-    // Searches the tree using the normal comparison operations,
-    // suitable for simple data types such as numbers.
-    Node* treeSearchNormal(Node* current, const T& data) const
+    Node* treeSearch(const T& data) const
     {
-        while (current) {
+        for (auto* current = m_root; current; ) {
             if (current->data() == data)
                 return current;
             if (data < current->data())
                 current = current->left();
             else
                 current = current->right();
         }
-        return 0;
-    }
-
-    // Searches the tree using multiple comparison operations, required
-    // for data types with more complex behavior such as intervals.
-    Node* treeSearchFullComparisons(Node* current, const T& data) const
-    {
-        if (!current)
-            return 0;
-        if (data < current->data())
-            return treeSearchFullComparisons(current->left(), data);
-        if (current->data() < data)
-            return treeSearchFullComparisons(current->right(), data);
-        if (data == current->data())
-            return current;
-
-        // We may need to traverse both the left and right subtrees.
-        Node* result = treeSearchFullComparisons(current->left(), data);
-        if (!result)
-            result = treeSearchFullComparisons(current->right(), data);
-        return result;
+        return nullptr;
     }
 
     void treeInsert(Node* z)
     {
-        Node* y = 0;
+        Node* y = nullptr;
         Node* x = m_root;
         while (x) {
             y = x;
             if (z->data() < x->data())
                 x = x->left();
@@ -324,11 +229,11 @@
         }
     }
 
     // Finds the node following the given one in sequential ordering of
     // their data, or null if none exists.
-    Node* treeSuccessor(Node* x)
+    static Node* treeSuccessor(Node* x)
     {
         if (x->right())
             return treeMinimum(x->right());
         Node* y = x->parent();
         while (y && x == y->right()) {
@@ -336,27 +241,24 @@
             y = y->parent();
         }
         return y;
     }
 
-    // Finds the minimum element in the sub-tree rooted at the given
-    // node.
-    Node* treeMinimum(Node* x)
+    // Finds the minimum element in the sub-tree rooted at the given node.
+    static Node* treeMinimum(Node* x)
     {
         while (x->left())
             x = x->left();
         return x;
     }
 
-    // Helper for maintaining the augmented red-black tree.
-    void propagateUpdates(Node* start)
+    static Node* treeSuccessorInPostOrder(Node* x)
     {
-        bool shouldContinue = true;
-        while (start && shouldContinue) {
-            shouldContinue = updateNode(start);
-            start = start->parent();
-        }
+        Node* y = x->parent();
+        if (y && x == y->left() && y->right())
+            return treeMinimum(y->right());
+        return y;
     }
 
     //----------------------------------------------------------------------
     // Red-Black tree operations
     //
@@ -387,15 +289,21 @@
         // Put x on y's left.
         y->setLeft(x);
         x->setParent(y);
 
         // Update nodes lowest to highest.
-        updateNode(x);
-        updateNode(y);
+        updateNode(*x);
+        updateNode(*y);
         return y;
     }
 
+    static void propagateUpdates(Node* start)
+    {
+        while (start && updateNode(*start))
+            start = start->parent();
+    }
+
     // Right-rotates the subtree rooted at y.
     // Returns the new root of the subtree (y's left child).
     Node* rightRotate(Node* y)
     {
         // Set x.
@@ -420,21 +328,21 @@
         // Put y on x's right.
         x->setRight(y);
         y->setParent(x);
 
         // Update nodes lowest to highest.
-        updateNode(y);
-        updateNode(x);
+        updateNode(*y);
+        updateNode(*x);
         return x;
     }
 
     // Inserts the given node into the tree.
     void insertNode(Node* x)
     {
         treeInsert(x);
         x->setColor(Red);
-        updateNode(x);
+        updateNode(*x);
 
         logIfVerbose("  PODRedBlackTree::InsertNode");
 
         // The node from which to start propagating updates upwards.
         Node* updateStart = x->parent();
@@ -446,13 +354,13 @@
                     // Case 1
                     logIfVerbose("  Case 1/1");
                     x->parent()->setColor(Black);
                     y->setColor(Black);
                     x->parent()->parent()->setColor(Red);
-                    updateNode(x->parent());
+                    updateNode(*x->parent());
                     x = x->parent()->parent();
-                    updateNode(x);
+                    updateNode(*x);
                     updateStart = x->parent();
                 } else {
                     if (x == x->parent()->right()) {
                         logIfVerbose("  Case 1/2");
                         // Case 2
@@ -473,13 +381,13 @@
                     // Case 1
                     logIfVerbose("  Case 2/1");
                     x->parent()->setColor(Black);
                     y->setColor(Black);
                     x->parent()->parent()->setColor(Red);
-                    updateNode(x->parent());
+                    updateNode(*x->parent());
                     x = x->parent()->parent();
-                    updateNode(x);
+                    updateNode(*x);
                     updateStart = x->parent();
                 } else {
                     if (x == x->parent()->left()) {
                         // Case 2
                         logIfVerbose("  Case 2/2");
@@ -500,12 +408,11 @@
 
         m_root->setColor(Black);
     }
 
     // Restores the red-black property to the tree after splicing out
-    // a node. Note that x may be null, which is why xParent must be
-    // supplied.
+    // a node. Note that x may be null, which is why xParent must be supplied.
     void deleteFixup(Node* x, Node* xParent)
     {
         while (x != m_root && (!x || x->color() == Black)) {
             if (x == xParent->left()) {
                 // Note: the text points out that w can not be null.
@@ -625,13 +532,13 @@
                 y->parent()->setLeft(x);
             else
                 y->parent()->setRight(x);
         }
         if (y != z) {
-            z->copyFrom(y);
+            z->moveDataFrom(*y);
             // This node has changed location in the tree and must be updated.
-            updateNode(z);
+            updateNode(*z);
             // The parent and its parents may now be out of date.
             propagateUpdates(z->parent());
         }
 
         // If we haven't already updated starting from xParent, do so now.
@@ -641,60 +548,23 @@
             deleteFixup(x, xParent);
 
         delete y;
     }
 
-    // Visits the subtree rooted at the given node in order.
-    void visitInorderImpl(Node* node, Visitor* visitor) const
-    {
-        if (node->left())
-            visitInorderImpl(node->left(), visitor);
-        visitor->visit(node->data());
-        if (node->right())
-            visitInorderImpl(node->right(), visitor);
-    }
-
-    void markFree(Node *node)
-    {
-        if (!node)
-            return;
-
-        if (node->left())
-            markFree(node->left());
-        if (node->right())
-            markFree(node->right());
-        delete node;
-    }
-
-    //----------------------------------------------------------------------
-    // Helper class for size()
-
-    // A Visitor which simply counts the number of visited elements.
-    class Counter : public Visitor {
-        WTF_MAKE_NONCOPYABLE(Counter);
-    public:
-        Counter()
-            : m_count(0) { }
-
-        void visit(const T&) override { ++m_count; }
-        int count() const { return m_count; }
-
-    private:
-        int m_count;
-    };
-
     //----------------------------------------------------------------------
     // Verification and debugging routines
     //
 
+#ifndef NDEBUG
+
     // Returns in the "blackCount" parameter the number of black
     // children along all paths to all leaves of the given node.
-    bool checkInvariantsFromNode(Node* node, int* blackCount) const
+    bool checkInvariantsFromNode(Node* node, int& blackCount) const
     {
         // Base case is a leaf node.
         if (!node) {
-            *blackCount = 1;
+            blackCount = 1;
             return true;
         }
 
         // Each node is either red or black.
         if (!(node->color() == Red || node->color() == Black))
@@ -708,21 +578,22 @@
                 return false;
             if (!((!node->right() || node->right()->color() == Black)))
                 return false;
         }
 
-        // Every simple path to a leaf node contains the same number of
-        // black nodes.
+        // Every simple path to a leaf node contains the same number of black nodes.
         int leftCount = 0, rightCount = 0;
-        bool leftValid = checkInvariantsFromNode(node->left(), &leftCount);
-        bool rightValid = checkInvariantsFromNode(node->right(), &rightCount);
+        bool leftValid = checkInvariantsFromNode(node->left(), leftCount);
+        bool rightValid = checkInvariantsFromNode(node->right(), rightCount);
         if (!leftValid || !rightValid)
             return false;
-        *blackCount = leftCount + (node->color() == Black ? 1 : 0);
+        blackCount = leftCount + (node->color() == Black ? 1 : 0);
         return leftCount == rightCount;
     }
 
+#endif
+
 #ifdef NDEBUG
     void logIfVerbose(const char*) const { }
 #else
     void logIfVerbose(const char* output) const
     {
@@ -730,38 +601,35 @@
             LOG_ERROR("%s", output);
     }
 #endif
 
 #ifndef NDEBUG
-    // Dumps the subtree rooted at the given node.
-    void dumpFromNode(Node* node, int indentation) const
+
+    void dumpSubtree(Node* node, int indentation) const
     {
         StringBuilder builder;
         for (int i = 0; i < indentation; i++)
             builder.append(' ');
         builder.append('-');
         if (node) {
             builder.append(' ');
-            builder.append(ValueToString<T>::string(node->data()));
+            TextStream stream;
+            stream << node->data();
+            builder.append(stream.release());
             builder.append((node->color() == Black) ? " (black)" : " (red)");
         }
-        LOG_ERROR("%s", builder.toString().ascii().data());
+        LOG_ERROR("%s", builder.toString().utf8().data());
         if (node) {
-            dumpFromNode(node->left(), indentation + 2);
-            dumpFromNode(node->right(), indentation + 2);
+            dumpSubtree(node->left(), indentation + 2);
+            dumpSubtree(node->right(), indentation + 2);
         }
     }
-#endif
 
-    //----------------------------------------------------------------------
-    // Data members
+#endif
 
-    Node* m_root;
-    bool m_needsFullOrderingComparisons;
+    Node* m_root { nullptr };
 #ifndef NDEBUG
-    bool m_verboseDebugging;
+    bool m_verboseDebugging { false };
 #endif
 };
 
 } // namespace WebCore
-
-#endif // PODRedBlackTree_h

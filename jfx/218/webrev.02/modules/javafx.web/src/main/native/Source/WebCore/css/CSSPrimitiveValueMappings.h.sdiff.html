<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPrimitiveValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSProperties.json.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSPrimitiveValueMappings.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  *    notice, this list of conditions and the following disclaimer in the
  16  *    documentation and/or other materials provided with the distribution.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR
  19  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  20  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  21  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
  22  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  23  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  24  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  25  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #pragma once
  31 
  32 #include &quot;CSSCalculationValue.h&quot;
  33 #include &quot;CSSFontFamily.h&quot;
  34 #include &quot;CSSPrimitiveValue.h&quot;
<span class="line-removed">  35 #include &quot;CSSReflectionDirection.h&quot;</span>
  36 #include &quot;CSSToLengthConversionData.h&quot;
  37 #include &quot;CSSValueKeywords.h&quot;
  38 #include &quot;GraphicsTypes.h&quot;
  39 #include &quot;Length.h&quot;
  40 #include &quot;LineClampValue.h&quot;
  41 #include &quot;RenderStyleConstants.h&quot;
  42 #include &quot;SVGRenderStyleDefs.h&quot;
  43 #include &quot;TextFlags.h&quot;
  44 #include &quot;ThemeTypes.h&quot;
  45 #include &quot;TouchAction.h&quot;
  46 #include &quot;UnicodeBidi.h&quot;
  47 #include &quot;WritingMode.h&quot;
  48 #include &lt;wtf/MathExtras.h&gt;
  49 #include &lt;wtf/OptionSet.h&gt;
  50 
<span class="line-removed">  51 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">  52 #include &quot;ImageOrientation.h&quot;</span>
<span class="line-removed">  53 #endif</span>
<span class="line-removed">  54 </span>
  55 namespace WebCore {
  56 
  57 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(short i)
  58     : CSSValue(PrimitiveClass)
  59 {
<span class="line-modified">  60     m_primitiveUnitType = CSS_NUMBER;</span>
  61     m_value.num = static_cast&lt;double&gt;(i);
  62 }
  63 
  64 template&lt;&gt; inline CSSPrimitiveValue::operator short() const
  65 {
<span class="line-modified">  66     if (m_primitiveUnitType == CSS_NUMBER)</span>
  67         return clampTo&lt;short&gt;(m_value.num);
  68 
  69     ASSERT_NOT_REACHED();
  70     return 0;
  71 }
  72 
  73 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(unsigned short i)
  74     : CSSValue(PrimitiveClass)
  75 {
<span class="line-modified">  76     m_primitiveUnitType = CSS_NUMBER;</span>
  77     m_value.num = static_cast&lt;double&gt;(i);
  78 }
  79 
  80 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned short() const
  81 {
<span class="line-modified">  82     if (primitiveType() == CSS_NUMBER)</span>
  83         return value&lt;unsigned short&gt;();
  84 
  85     ASSERT_NOT_REACHED();
  86     return 0;
  87 }
  88 
  89 template&lt;&gt; inline CSSPrimitiveValue::operator int() const
  90 {
<span class="line-modified">  91     if (primitiveType() == CSS_NUMBER)</span>
  92         return value&lt;int&gt;();
  93 
  94     ASSERT_NOT_REACHED();
  95     return 0;
  96 }
  97 
  98 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned() const
  99 {
<span class="line-modified"> 100     if (primitiveType() == CSS_NUMBER)</span>
 101         return value&lt;unsigned&gt;();
 102 
 103     ASSERT_NOT_REACHED();
 104     return 0;
 105 }
 106 
 107 
 108 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(float i)
 109     : CSSValue(PrimitiveClass)
 110 {
<span class="line-modified"> 111     m_primitiveUnitType = CSS_NUMBER;</span>
 112     m_value.num = static_cast&lt;double&gt;(i);
 113 }
 114 
 115 template&lt;&gt; inline CSSPrimitiveValue::operator float() const
 116 {
<span class="line-modified"> 117     if (primitiveType() == CSS_NUMBER)</span>
 118         return value&lt;float&gt;();
 119 
 120     ASSERT_NOT_REACHED();
 121     return 0.0f;
 122 }
 123 
 124 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineClampValue i)
 125     : CSSValue(PrimitiveClass)
 126 {
<span class="line-modified"> 127     m_primitiveUnitType = i.isPercentage() ? CSS_PERCENTAGE : CSS_NUMBER;</span>
 128     m_value.num = static_cast&lt;double&gt;(i.value());
 129 }
 130 
 131 template&lt;&gt; inline CSSPrimitiveValue::operator LineClampValue() const
 132 {
<span class="line-modified"> 133     if (primitiveType() == CSS_NUMBER)</span>
 134         return LineClampValue(value&lt;int&gt;(), LineClamp::LineCount);
 135 
<span class="line-modified"> 136     if (primitiveType() == CSS_PERCENTAGE)</span>
 137         return LineClampValue(value&lt;int&gt;(), LineClamp::Percentage);
 138 
 139     ASSERT_NOT_REACHED();
 140     return LineClampValue();
 141 }
 142 
<span class="line-modified"> 143 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSReflectionDirection e)</span>
 144     : CSSValue(PrimitiveClass)
 145 {
<span class="line-modified"> 146     m_primitiveUnitType = CSS_VALUE_ID;</span>
<span class="line-modified"> 147     switch (e) {</span>
<span class="line-modified"> 148     case ReflectionAbove:</span>
 149         m_value.valueID = CSSValueAbove;
 150         break;
<span class="line-modified"> 151     case ReflectionBelow:</span>
 152         m_value.valueID = CSSValueBelow;
 153         break;
<span class="line-modified"> 154     case ReflectionLeft:</span>
 155         m_value.valueID = CSSValueLeft;
 156         break;
<span class="line-modified"> 157     case ReflectionRight:</span>
 158         m_value.valueID = CSSValueRight;
 159     }
 160 }
 161 
<span class="line-modified"> 162 template&lt;&gt; inline CSSPrimitiveValue::operator CSSReflectionDirection() const</span>
 163 {
 164     ASSERT(isValueID());
 165 
 166     switch (m_value.valueID) {
 167     case CSSValueAbove:
<span class="line-modified"> 168         return ReflectionAbove;</span>
 169     case CSSValueBelow:
<span class="line-modified"> 170         return ReflectionBelow;</span>
 171     case CSSValueLeft:
<span class="line-modified"> 172         return ReflectionLeft;</span>
 173     case CSSValueRight:
<span class="line-modified"> 174         return ReflectionRight;</span>
 175     default:
 176         break;
 177     }
 178 
 179     ASSERT_NOT_REACHED();
<span class="line-modified"> 180     return ReflectionBelow;</span>
 181 }
 182 
 183 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnFill columnFill)
 184     : CSSValue(PrimitiveClass)
 185 {
<span class="line-modified"> 186     m_primitiveUnitType = CSS_VALUE_ID;</span>
 187     switch (columnFill) {
 188     case ColumnFill::Auto:
 189         m_value.valueID = CSSValueAuto;
 190         break;
 191     case ColumnFill::Balance:
 192         m_value.valueID = CSSValueBalance;
 193         break;
 194     }
 195 }
 196 
 197 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnFill() const
 198 {
<span class="line-modified"> 199     if (m_primitiveUnitType == CSS_VALUE_ID) {</span>
 200         if (m_value.valueID == CSSValueBalance)
 201             return ColumnFill::Balance;
 202         if (m_value.valueID == CSSValueAuto)
 203             return ColumnFill::Auto;
 204     }
 205     ASSERT_NOT_REACHED();
 206     return ColumnFill::Balance;
 207 }
 208 
 209 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnSpan columnSpan)
 210     : CSSValue(PrimitiveClass)
 211 {
<span class="line-modified"> 212     m_primitiveUnitType = CSS_VALUE_ID;</span>
 213     switch (columnSpan) {
 214     case ColumnSpan::All:
 215         m_value.valueID = CSSValueAll;
 216         break;
 217     case ColumnSpan::None:
 218         m_value.valueID = CSSValueNone;
 219         break;
 220     }
 221 }
 222 
 223 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnSpan() const
 224 {
 225     // Map 1 to none for compatibility reasons.
<span class="line-modified"> 226     if (m_primitiveUnitType == CSS_NUMBER &amp;&amp; m_value.num == 1)</span>
 227         return ColumnSpan::None;
 228 
 229     ASSERT(isValueID());
 230 
 231     switch (m_value.valueID) {
 232     case CSSValueAll:
 233         return ColumnSpan::All;
 234     case CSSValueNone:
 235         return ColumnSpan::None;
 236     default:
 237         break;
 238     }
 239 
 240     ASSERT_NOT_REACHED();
 241     return ColumnSpan::None;
 242 }
 243 
 244 
 245 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PrintColorAdjust value)
 246     : CSSValue(PrimitiveClass)
 247 {
<span class="line-modified"> 248     m_primitiveUnitType = CSS_VALUE_ID;</span>
 249     switch (value) {
 250     case PrintColorAdjust::Exact:
 251         m_value.valueID = CSSValueExact;
 252         break;
 253     case PrintColorAdjust::Economy:
 254         m_value.valueID = CSSValueEconomy;
 255         break;
 256     }
 257 }
 258 
 259 template&lt;&gt; inline CSSPrimitiveValue::operator PrintColorAdjust() const
 260 {
 261     ASSERT(isValueID());
 262 
 263     switch (m_value.valueID) {
 264     case CSSValueEconomy:
 265         return PrintColorAdjust::Economy;
 266     case CSSValueExact:
 267         return PrintColorAdjust::Exact;
 268     default:
 269         break;
 270     }
 271 
 272     ASSERT_NOT_REACHED();
 273     return PrintColorAdjust::Economy;
 274 }
 275 
 276 
 277 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderStyle e)
 278     : CSSValue(PrimitiveClass)
 279 {
<span class="line-modified"> 280     m_primitiveUnitType = CSS_VALUE_ID;</span>
 281     switch (e) {
 282     case BorderStyle::None:
 283         m_value.valueID = CSSValueNone;
 284         break;
 285     case BorderStyle::Hidden:
 286         m_value.valueID = CSSValueHidden;
 287         break;
 288     case BorderStyle::Inset:
 289         m_value.valueID = CSSValueInset;
 290         break;
 291     case BorderStyle::Groove:
 292         m_value.valueID = CSSValueGroove;
 293         break;
 294     case BorderStyle::Ridge:
 295         m_value.valueID = CSSValueRidge;
 296         break;
 297     case BorderStyle::Outset:
 298         m_value.valueID = CSSValueOutset;
 299         break;
 300     case BorderStyle::Dotted:
</pre>
<hr />
<pre>
 316 {
 317     ASSERT(isValueID());
 318 
 319     if (m_value.valueID == CSSValueAuto) // Valid for CSS outline-style
 320         return BorderStyle::Dotted;
 321     return static_cast&lt;BorderStyle&gt;(m_value.valueID - CSSValueNone);
 322 }
 323 
 324 template&lt;&gt; inline CSSPrimitiveValue::operator OutlineIsAuto() const
 325 {
 326     ASSERT(isValueID());
 327 
 328     if (m_value.valueID == CSSValueAuto)
 329         return OutlineIsAuto::On;
 330     return OutlineIsAuto::Off;
 331 }
 332 
 333 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CompositeOperator e)
 334     : CSSValue(PrimitiveClass)
 335 {
<span class="line-modified"> 336     m_primitiveUnitType = CSS_VALUE_ID;</span>
 337     switch (e) {
<span class="line-modified"> 338     case CompositeClear:</span>
 339         m_value.valueID = CSSValueClear;
 340         break;
<span class="line-modified"> 341     case CompositeCopy:</span>
 342         m_value.valueID = CSSValueCopy;
 343         break;
<span class="line-modified"> 344     case CompositeSourceOver:</span>
 345         m_value.valueID = CSSValueSourceOver;
 346         break;
<span class="line-modified"> 347     case CompositeSourceIn:</span>
 348         m_value.valueID = CSSValueSourceIn;
 349         break;
<span class="line-modified"> 350     case CompositeSourceOut:</span>
 351         m_value.valueID = CSSValueSourceOut;
 352         break;
<span class="line-modified"> 353     case CompositeSourceAtop:</span>
 354         m_value.valueID = CSSValueSourceAtop;
 355         break;
<span class="line-modified"> 356     case CompositeDestinationOver:</span>
 357         m_value.valueID = CSSValueDestinationOver;
 358         break;
<span class="line-modified"> 359     case CompositeDestinationIn:</span>
 360         m_value.valueID = CSSValueDestinationIn;
 361         break;
<span class="line-modified"> 362     case CompositeDestinationOut:</span>
 363         m_value.valueID = CSSValueDestinationOut;
 364         break;
<span class="line-modified"> 365     case CompositeDestinationAtop:</span>
 366         m_value.valueID = CSSValueDestinationAtop;
 367         break;
<span class="line-modified"> 368     case CompositeXOR:</span>
 369         m_value.valueID = CSSValueXor;
 370         break;
<span class="line-modified"> 371     case CompositePlusDarker:</span>
 372         m_value.valueID = CSSValuePlusDarker;
 373         break;
<span class="line-modified"> 374     case CompositePlusLighter:</span>
 375         m_value.valueID = CSSValuePlusLighter;
 376         break;
<span class="line-modified"> 377     case CompositeDifference:</span>
 378         ASSERT_NOT_REACHED();
 379         break;
 380     }
 381 }
 382 
 383 template&lt;&gt; inline CSSPrimitiveValue::operator CompositeOperator() const
 384 {
 385     ASSERT(isValueID());
 386 
 387     switch (m_value.valueID) {
 388     case CSSValueClear:
<span class="line-modified"> 389         return CompositeClear;</span>
 390     case CSSValueCopy:
<span class="line-modified"> 391         return CompositeCopy;</span>
 392     case CSSValueSourceOver:
<span class="line-modified"> 393         return CompositeSourceOver;</span>
 394     case CSSValueSourceIn:
<span class="line-modified"> 395         return CompositeSourceIn;</span>
 396     case CSSValueSourceOut:
<span class="line-modified"> 397         return CompositeSourceOut;</span>
 398     case CSSValueSourceAtop:
<span class="line-modified"> 399         return CompositeSourceAtop;</span>
 400     case CSSValueDestinationOver:
<span class="line-modified"> 401         return CompositeDestinationOver;</span>
 402     case CSSValueDestinationIn:
<span class="line-modified"> 403         return CompositeDestinationIn;</span>
 404     case CSSValueDestinationOut:
<span class="line-modified"> 405         return CompositeDestinationOut;</span>
 406     case CSSValueDestinationAtop:
<span class="line-modified"> 407         return CompositeDestinationAtop;</span>
 408     case CSSValueXor:
<span class="line-modified"> 409         return CompositeXOR;</span>
 410     case CSSValuePlusDarker:
<span class="line-modified"> 411         return CompositePlusDarker;</span>
 412     case CSSValuePlusLighter:
<span class="line-modified"> 413         return CompositePlusLighter;</span>
 414     default:
 415         break;
 416     }
 417 
 418     ASSERT_NOT_REACHED();
<span class="line-modified"> 419     return CompositeClear;</span>
 420 }
 421 
 422 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ControlPart e)
 423     : CSSValue(PrimitiveClass)
 424 {
<span class="line-modified"> 425     m_primitiveUnitType = CSS_VALUE_ID;</span>
 426     switch (e) {
 427     case NoControlPart:
 428         m_value.valueID = CSSValueNone;
 429         break;
 430     case CheckboxPart:
 431         m_value.valueID = CSSValueCheckbox;
 432         break;
 433     case RadioPart:
 434         m_value.valueID = CSSValueRadio;
 435         break;
 436     case PushButtonPart:
 437         m_value.valueID = CSSValuePushButton;
 438         break;
 439     case SquareButtonPart:
 440         m_value.valueID = CSSValueSquareButton;
 441         break;
 442     case ButtonPart:
 443         m_value.valueID = CSSValueButton;
 444         break;
 445     case ButtonBevelPart:
</pre>
<hr />
<pre>
 630 #if ENABLE(DATALIST_ELEMENT)
 631     case ListButtonPart:
 632         m_value.valueID = CSSValueListButton;
 633         break;
 634 #endif
 635     }
 636 }
 637 
 638 template&lt;&gt; inline CSSPrimitiveValue::operator ControlPart() const
 639 {
 640     ASSERT(isValueID());
 641 
 642     if (m_value.valueID == CSSValueNone)
 643         return NoControlPart;
 644     return ControlPart(m_value.valueID - CSSValueCheckbox + 1);
 645 }
 646 
 647 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BackfaceVisibility e)
 648     : CSSValue(PrimitiveClass)
 649 {
<span class="line-modified"> 650     m_primitiveUnitType = CSS_VALUE_ID;</span>
 651     switch (e) {
 652     case BackfaceVisibility::Visible:
 653         m_value.valueID = CSSValueVisible;
 654         break;
 655     case BackfaceVisibility::Hidden:
 656         m_value.valueID = CSSValueHidden;
 657         break;
 658     }
 659 }
 660 
 661 template&lt;&gt; inline CSSPrimitiveValue::operator BackfaceVisibility() const
 662 {
 663     ASSERT(isValueID());
 664 
 665     switch (m_value.valueID) {
 666     case CSSValueVisible:
 667         return BackfaceVisibility::Visible;
 668     case CSSValueHidden:
 669         return BackfaceVisibility::Hidden;
 670     default:
 671         break;
 672     }
 673 
 674     ASSERT_NOT_REACHED();
 675     return BackfaceVisibility::Hidden;
 676 }
 677 
 678 
 679 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillAttachment e)
 680     : CSSValue(PrimitiveClass)
 681 {
<span class="line-modified"> 682     m_primitiveUnitType = CSS_VALUE_ID;</span>
 683     switch (e) {
 684     case FillAttachment::ScrollBackground:
 685         m_value.valueID = CSSValueScroll;
 686         break;
 687     case FillAttachment::LocalBackground:
 688         m_value.valueID = CSSValueLocal;
 689         break;
 690     case FillAttachment::FixedBackground:
 691         m_value.valueID = CSSValueFixed;
 692         break;
 693     }
 694 }
 695 
 696 template&lt;&gt; inline CSSPrimitiveValue::operator FillAttachment() const
 697 {
 698     ASSERT(isValueID());
 699 
 700     switch (m_value.valueID) {
 701     case CSSValueScroll:
 702         return FillAttachment::ScrollBackground;
 703     case CSSValueLocal:
 704         return FillAttachment::LocalBackground;
 705     case CSSValueFixed:
 706         return FillAttachment::FixedBackground;
 707     default:
 708         break;
 709     }
 710 
 711     ASSERT_NOT_REACHED();
 712     return FillAttachment::ScrollBackground;
 713 }
 714 
 715 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillBox e)
 716     : CSSValue(PrimitiveClass)
 717 {
<span class="line-modified"> 718     m_primitiveUnitType = CSS_VALUE_ID;</span>
 719     switch (e) {
 720     case FillBox::Border:
 721         m_value.valueID = CSSValueBorderBox;
 722         break;
 723     case FillBox::Padding:
 724         m_value.valueID = CSSValuePaddingBox;
 725         break;
 726     case FillBox::Content:
 727         m_value.valueID = CSSValueContentBox;
 728         break;
 729     case FillBox::Text:
 730         m_value.valueID = CSSValueText;
 731         break;
 732     }
 733 }
 734 
 735 template&lt;&gt; inline CSSPrimitiveValue::operator FillBox() const
 736 {
 737     ASSERT(isValueID());
 738 
</pre>
<hr />
<pre>
 743     case CSSValuePadding:
 744     case CSSValuePaddingBox:
 745         return FillBox::Padding;
 746     case CSSValueContent:
 747     case CSSValueContentBox:
 748         return FillBox::Content;
 749     case CSSValueText:
 750     case CSSValueWebkitText:
 751         return FillBox::Text;
 752     default:
 753         break;
 754     }
 755 
 756     ASSERT_NOT_REACHED();
 757     return FillBox::Border;
 758 }
 759 
 760 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillRepeat e)
 761     : CSSValue(PrimitiveClass)
 762 {
<span class="line-modified"> 763     m_primitiveUnitType = CSS_VALUE_ID;</span>
 764     switch (e) {
 765     case FillRepeat::Repeat:
 766         m_value.valueID = CSSValueRepeat;
 767         break;
 768     case FillRepeat::NoRepeat:
 769         m_value.valueID = CSSValueNoRepeat;
 770         break;
 771     case FillRepeat::Round:
 772         m_value.valueID = CSSValueRound;
 773         break;
 774     case FillRepeat::Space:
 775         m_value.valueID = CSSValueSpace;
 776         break;
 777     }
 778 }
 779 
 780 template&lt;&gt; inline CSSPrimitiveValue::operator FillRepeat() const
 781 {
 782     ASSERT(isValueID());
 783 
 784     switch (m_value.valueID) {
 785     case CSSValueRepeat:
 786         return FillRepeat::Repeat;
 787     case CSSValueNoRepeat:
 788         return FillRepeat::NoRepeat;
 789     case CSSValueRound:
 790         return FillRepeat::Round;
 791     case CSSValueSpace:
 792         return FillRepeat::Space;
 793     default:
 794         break;
 795     }
 796 
 797     ASSERT_NOT_REACHED();
 798     return FillRepeat::Repeat;
 799 }
 800 
 801 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxPack e)
 802     : CSSValue(PrimitiveClass)
 803 {
<span class="line-modified"> 804     m_primitiveUnitType = CSS_VALUE_ID;</span>
 805     switch (e) {
 806     case BoxPack::Start:
 807         m_value.valueID = CSSValueStart;
 808         break;
 809     case BoxPack::Center:
 810         m_value.valueID = CSSValueCenter;
 811         break;
 812     case BoxPack::End:
 813         m_value.valueID = CSSValueEnd;
 814         break;
 815     case BoxPack::Justify:
 816         m_value.valueID = CSSValueJustify;
 817         break;
 818     }
 819 }
 820 
 821 template&lt;&gt; inline CSSPrimitiveValue::operator BoxPack() const
 822 {
 823     ASSERT(isValueID());
 824 
 825     switch (m_value.valueID) {
 826     case CSSValueStart:
 827         return BoxPack::Start;
 828     case CSSValueEnd:
 829         return BoxPack::End;
 830     case CSSValueCenter:
 831         return BoxPack::Center;
 832     case CSSValueJustify:
 833         return BoxPack::Justify;
 834     default:
 835         break;
 836     }
 837 
 838     ASSERT_NOT_REACHED();
 839     return BoxPack::Justify;
 840 }
 841 
 842 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxAlignment e)
 843     : CSSValue(PrimitiveClass)
 844 {
<span class="line-modified"> 845     m_primitiveUnitType = CSS_VALUE_ID;</span>
 846     switch (e) {
 847     case BoxAlignment::Stretch:
 848         m_value.valueID = CSSValueStretch;
 849         break;
 850     case BoxAlignment::Start:
 851         m_value.valueID = CSSValueStart;
 852         break;
 853     case BoxAlignment::Center:
 854         m_value.valueID = CSSValueCenter;
 855         break;
 856     case BoxAlignment::End:
 857         m_value.valueID = CSSValueEnd;
 858         break;
 859     case BoxAlignment::Baseline:
 860         m_value.valueID = CSSValueBaseline;
 861         break;
 862     }
 863 }
 864 
 865 template&lt;&gt; inline CSSPrimitiveValue::operator BoxAlignment() const
</pre>
<hr />
<pre>
 872     case CSSValueStart:
 873         return BoxAlignment::Start;
 874     case CSSValueEnd:
 875         return BoxAlignment::End;
 876     case CSSValueCenter:
 877         return BoxAlignment::Center;
 878     case CSSValueBaseline:
 879         return BoxAlignment::Baseline;
 880     default:
 881         break;
 882     }
 883 
 884     ASSERT_NOT_REACHED();
 885     return BoxAlignment::Stretch;
 886 }
 887 
 888 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 889 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDecorationBreak e)
 890     : CSSValue(PrimitiveClass)
 891 {
<span class="line-modified"> 892     m_primitiveUnitType = CSS_VALUE_ID;</span>
 893     switch (e) {
 894     case BoxDecorationBreak::Slice:
 895         m_value.valueID = CSSValueSlice;
 896         break;
 897     case BoxDecorationBreak::Clone:
 898         m_value.valueID = CSSValueClone;
 899         break;
 900     }
 901 }
 902 
 903 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDecorationBreak() const
 904 {
 905     ASSERT(isValueID());
 906 
 907     switch (m_value.valueID) {
 908     case CSSValueSlice:
 909         return BoxDecorationBreak::Slice;
 910     case CSSValueClone:
 911         return BoxDecorationBreak::Clone;
 912     default:
 913         break;
 914     }
 915 
 916     ASSERT_NOT_REACHED();
 917     return BoxDecorationBreak::Slice;
 918 }
 919 #endif
 920 
 921 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Edge e)
 922     : CSSValue(PrimitiveClass)
 923 {
<span class="line-modified"> 924     m_primitiveUnitType = CSS_VALUE_ID;</span>
 925     switch (e) {
 926     case Edge::Top:
 927         m_value.valueID = CSSValueTop;
 928         break;
 929     case Edge::Right:
 930         m_value.valueID = CSSValueRight;
 931         break;
 932     case Edge::Bottom:
 933         m_value.valueID = CSSValueBottom;
 934         break;
 935     case Edge::Left:
 936         m_value.valueID = CSSValueLeft;
 937         break;
 938     }
 939 }
 940 
 941 template&lt;&gt; inline CSSPrimitiveValue::operator Edge() const
 942 {
 943     ASSERT(isValueID());
 944 
 945     switch (m_value.valueID) {
 946     case CSSValueTop:
 947         return Edge::Top;
 948     case CSSValueRight:
 949         return Edge::Right;
 950     case CSSValueBottom:
 951         return Edge::Bottom;
 952     case CSSValueLeft:
 953         return Edge::Left;
 954     default:
 955         break;
 956     }
 957 
 958     ASSERT_NOT_REACHED();
 959     return Edge::Top;
 960 }
 961 
 962 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxSizing e)
 963     : CSSValue(PrimitiveClass)
 964 {
<span class="line-modified"> 965     m_primitiveUnitType = CSS_VALUE_ID;</span>
 966     switch (e) {
 967     case BoxSizing::BorderBox:
 968         m_value.valueID = CSSValueBorderBox;
 969         break;
 970     case BoxSizing::ContentBox:
 971         m_value.valueID = CSSValueContentBox;
 972         break;
 973     }
 974 }
 975 
 976 template&lt;&gt; inline CSSPrimitiveValue::operator BoxSizing() const
 977 {
 978     ASSERT(isValueID());
 979 
 980     switch (m_value.valueID) {
 981     case CSSValueBorderBox:
 982         return BoxSizing::BorderBox;
 983     case CSSValueContentBox:
 984         return BoxSizing::ContentBox;
 985     default:
 986         break;
 987     }
 988 
 989     ASSERT_NOT_REACHED();
 990     return BoxSizing::BorderBox;
 991 }
 992 
 993 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDirection e)
 994     : CSSValue(PrimitiveClass)
 995 {
<span class="line-modified"> 996     m_primitiveUnitType = CSS_VALUE_ID;</span>
 997     switch (e) {
 998     case BoxDirection::Normal:
 999         m_value.valueID = CSSValueNormal;
1000         break;
1001     case BoxDirection::Reverse:
1002         m_value.valueID = CSSValueReverse;
1003         break;
1004     }
1005 }
1006 
1007 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDirection() const
1008 {
1009     ASSERT(isValueID());
1010 
1011     switch (m_value.valueID) {
1012     case CSSValueNormal:
1013         return BoxDirection::Normal;
1014     case CSSValueReverse:
1015         return BoxDirection::Reverse;
1016     default:
1017         break;
1018     }
1019 
1020     ASSERT_NOT_REACHED();
1021     return BoxDirection::Normal;
1022 }
1023 
1024 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxLines e)
1025     : CSSValue(PrimitiveClass)
1026 {
<span class="line-modified">1027     m_primitiveUnitType = CSS_VALUE_ID;</span>
1028     switch (e) {
1029     case BoxLines::Single:
1030         m_value.valueID = CSSValueSingle;
1031         break;
1032     case BoxLines::Multiple:
1033         m_value.valueID = CSSValueMultiple;
1034         break;
1035     }
1036 }
1037 
1038 template&lt;&gt; inline CSSPrimitiveValue::operator BoxLines() const
1039 {
1040     ASSERT(isValueID());
1041 
1042     switch (m_value.valueID) {
1043     case CSSValueSingle:
1044         return BoxLines::Single;
1045     case CSSValueMultiple:
1046         return BoxLines::Multiple;
1047     default:
1048         break;
1049     }
1050 
1051     ASSERT_NOT_REACHED();
1052     return BoxLines::Single;
1053 }
1054 
1055 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxOrient e)
1056     : CSSValue(PrimitiveClass)
1057 {
<span class="line-modified">1058     m_primitiveUnitType = CSS_VALUE_ID;</span>
1059     switch (e) {
1060     case BoxOrient::Horizontal:
1061         m_value.valueID = CSSValueHorizontal;
1062         break;
1063     case BoxOrient::Vertical:
1064         m_value.valueID = CSSValueVertical;
1065         break;
1066     }
1067 }
1068 
1069 template&lt;&gt; inline CSSPrimitiveValue::operator BoxOrient() const
1070 {
1071     ASSERT(isValueID());
1072 
1073     switch (m_value.valueID) {
1074     case CSSValueHorizontal:
1075     case CSSValueInlineAxis:
1076         return BoxOrient::Horizontal;
1077     case CSSValueVertical:
1078     case CSSValueBlockAxis:
1079         return BoxOrient::Vertical;
1080     default:
1081         break;
1082     }
1083 
1084     ASSERT_NOT_REACHED();
1085     return BoxOrient::Horizontal;
1086 }
1087 
1088 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CaptionSide e)
1089     : CSSValue(PrimitiveClass)
1090 {
<span class="line-modified">1091     m_primitiveUnitType = CSS_VALUE_ID;</span>
1092     switch (e) {
1093     case CaptionSide::Left:
1094         m_value.valueID = CSSValueLeft;
1095         break;
1096     case CaptionSide::Right:
1097         m_value.valueID = CSSValueRight;
1098         break;
1099     case CaptionSide::Top:
1100         m_value.valueID = CSSValueTop;
1101         break;
1102     case CaptionSide::Bottom:
1103         m_value.valueID = CSSValueBottom;
1104         break;
1105     }
1106 }
1107 
1108 template&lt;&gt; inline CSSPrimitiveValue::operator CaptionSide() const
1109 {
1110     ASSERT(isValueID());
1111 
1112     switch (m_value.valueID) {
1113     case CSSValueLeft:
1114         return CaptionSide::Left;
1115     case CSSValueRight:
1116         return CaptionSide::Right;
1117     case CSSValueTop:
1118         return CaptionSide::Top;
1119     case CSSValueBottom:
1120         return CaptionSide::Bottom;
1121     default:
1122         break;
1123     }
1124 
1125     ASSERT_NOT_REACHED();
1126     return CaptionSide::Top;
1127 }
1128 
1129 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Clear e)
1130     : CSSValue(PrimitiveClass)
1131 {
<span class="line-modified">1132     m_primitiveUnitType = CSS_VALUE_ID;</span>
1133     switch (e) {
1134     case Clear::None:
1135         m_value.valueID = CSSValueNone;
1136         break;
1137     case Clear::Left:
1138         m_value.valueID = CSSValueLeft;
1139         break;
1140     case Clear::Right:
1141         m_value.valueID = CSSValueRight;
1142         break;
1143     case Clear::Both:
1144         m_value.valueID = CSSValueBoth;
1145         break;
1146     }
1147 }
1148 
1149 template&lt;&gt; inline CSSPrimitiveValue::operator Clear() const
1150 {
1151     ASSERT(isValueID());
1152 
1153     switch (m_value.valueID) {
1154     case CSSValueNone:
1155         return Clear::None;
1156     case CSSValueLeft:
1157         return Clear::Left;
1158     case CSSValueRight:
1159         return Clear::Right;
1160     case CSSValueBoth:
1161         return Clear::Both;
1162     default:
1163         break;
1164     }
1165 
1166     ASSERT_NOT_REACHED();
1167     return Clear::None;
1168 }
1169 
1170 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorType e)
1171     : CSSValue(PrimitiveClass)
1172 {
<span class="line-modified">1173     m_primitiveUnitType = CSS_VALUE_ID;</span>
1174     switch (e) {
1175     case CursorType::Auto:
1176         m_value.valueID = CSSValueAuto;
1177         break;
1178     case CursorType::Default:
1179         m_value.valueID = CSSValueDefault;
1180         break;
1181     case CursorType::None:
1182         m_value.valueID = CSSValueNone;
1183         break;
1184     case CursorType::ContextMenu:
1185         m_value.valueID = CSSValueContextMenu;
1186         break;
1187     case CursorType::Help:
1188         m_value.valueID = CSSValueHelp;
1189         break;
1190     case CursorType::Pointer:
1191         m_value.valueID = CSSValuePointer;
1192         break;
1193     case CursorType::Progress:
</pre>
<hr />
<pre>
1291         return CursorType::Copy;
1292     case CSSValueWebkitGrab:
1293         return CursorType::Grab;
1294     case CSSValueWebkitGrabbing:
1295         return CursorType::Grabbing;
1296     case CSSValueWebkitZoomIn:
1297         return CursorType::ZoomIn;
1298     case CSSValueWebkitZoomOut:
1299         return CursorType::ZoomOut;
1300     case CSSValueNone:
1301         return CursorType::None;
1302     default:
1303         return static_cast&lt;CursorType&gt;(m_value.valueID - CSSValueAuto);
1304     }
1305 }
1306 
1307 #if ENABLE(CURSOR_VISIBILITY)
1308 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorVisibility e)
1309     : CSSValue(PrimitiveClass)
1310 {
<span class="line-modified">1311     m_primitiveUnitType = CSS_VALUE_ID;</span>
1312     switch (e) {
1313     case CursorVisibility::Auto:
1314         m_value.valueID = CSSValueAuto;
1315         break;
1316     case CursorVisibility::AutoHide:
1317         m_value.valueID = CSSValueAutoHide;
1318         break;
1319     }
1320 }
1321 
1322 template&lt;&gt; inline CSSPrimitiveValue::operator CursorVisibility() const
1323 {
1324     ASSERT(isValueID());
1325 
1326     if (m_value.valueID == CSSValueAuto)
1327         return CursorVisibility::Auto;
1328     if (m_value.valueID == CSSValueAutoHide)
1329         return CursorVisibility::AutoHide;
1330 
1331     ASSERT_NOT_REACHED();
1332     return CursorVisibility::Auto;
1333 }
1334 #endif
1335 
1336 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DisplayType e)
1337     : CSSValue(PrimitiveClass)
1338 {
<span class="line-modified">1339     m_primitiveUnitType = CSS_VALUE_ID;</span>
1340     switch (e) {
1341     case DisplayType::Inline:
1342         m_value.valueID = CSSValueInline;
1343         break;
1344     case DisplayType::Block:
1345         m_value.valueID = CSSValueBlock;
1346         break;
1347     case DisplayType::ListItem:
1348         m_value.valueID = CSSValueListItem;
1349         break;
<span class="line-removed">1350     case DisplayType::Compact:</span>
<span class="line-removed">1351         m_value.valueID = CSSValueCompact;</span>
<span class="line-removed">1352         break;</span>
1353     case DisplayType::InlineBlock:
1354         m_value.valueID = CSSValueInlineBlock;
1355         break;
1356     case DisplayType::Table:
1357         m_value.valueID = CSSValueTable;
1358         break;
1359     case DisplayType::InlineTable:
1360         m_value.valueID = CSSValueInlineTable;
1361         break;
1362     case DisplayType::TableRowGroup:
1363         m_value.valueID = CSSValueTableRowGroup;
1364         break;
1365     case DisplayType::TableHeaderGroup:
1366         m_value.valueID = CSSValueTableHeaderGroup;
1367         break;
1368     case DisplayType::TableFooterGroup:
1369         m_value.valueID = CSSValueTableFooterGroup;
1370         break;
1371     case DisplayType::TableRow:
1372         m_value.valueID = CSSValueTableRow;
</pre>
<hr />
<pre>
1417 
1418 template&lt;&gt; inline CSSPrimitiveValue::operator DisplayType() const
1419 {
1420     ASSERT(isValueID());
1421 
1422     if (m_value.valueID == CSSValueNone)
1423         return DisplayType::None;
1424 
1425     DisplayType display = static_cast&lt;DisplayType&gt;(m_value.valueID - CSSValueInline);
1426     ASSERT(display &gt;= DisplayType::Inline &amp;&amp; display &lt;= DisplayType::None);
1427     if (display == DisplayType::WebKitFlex)
1428         return DisplayType::Flex;
1429     if (display == DisplayType::WebKitInlineFlex)
1430         return DisplayType::InlineFlex;
1431     return display;
1432 }
1433 
1434 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EmptyCell e)
1435     : CSSValue(PrimitiveClass)
1436 {
<span class="line-modified">1437     m_primitiveUnitType = CSS_VALUE_ID;</span>
1438     switch (e) {
1439     case EmptyCell::Show:
1440         m_value.valueID = CSSValueShow;
1441         break;
1442     case EmptyCell::Hide:
1443         m_value.valueID = CSSValueHide;
1444         break;
1445     }
1446 }
1447 
1448 template&lt;&gt; inline CSSPrimitiveValue::operator EmptyCell() const
1449 {
1450     ASSERT(isValueID());
1451 
1452     switch (m_value.valueID) {
1453     case CSSValueShow:
1454         return EmptyCell::Show;
1455     case CSSValueHide:
1456         return EmptyCell::Hide;
1457     default:
1458         break;
1459     }
1460 
1461     ASSERT_NOT_REACHED();
1462     return EmptyCell::Show;
1463 }
1464 
1465 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexDirection e)
1466     : CSSValue(PrimitiveClass)
1467 {
<span class="line-modified">1468     m_primitiveUnitType = CSS_VALUE_ID;</span>
1469     switch (e) {
1470     case FlexDirection::Row:
1471         m_value.valueID = CSSValueRow;
1472         break;
1473     case FlexDirection::RowReverse:
1474         m_value.valueID = CSSValueRowReverse;
1475         break;
1476     case FlexDirection::Column:
1477         m_value.valueID = CSSValueColumn;
1478         break;
1479     case FlexDirection::ColumnReverse:
1480         m_value.valueID = CSSValueColumnReverse;
1481         break;
1482     }
1483 }
1484 
1485 template&lt;&gt; inline CSSPrimitiveValue::operator FlexDirection() const
1486 {
1487     ASSERT(isValueID());
1488 
1489     switch (m_value.valueID) {
1490     case CSSValueRow:
1491         return FlexDirection::Row;
1492     case CSSValueRowReverse:
1493         return FlexDirection::RowReverse;
1494     case CSSValueColumn:
1495         return FlexDirection::Column;
1496     case CSSValueColumnReverse:
1497         return FlexDirection::ColumnReverse;
1498     default:
1499         break;
1500     }
1501 
1502     ASSERT_NOT_REACHED();
1503     return FlexDirection::Row;
1504 }
1505 
1506 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignContent e)
1507     : CSSValue(PrimitiveClass)
1508 {
<span class="line-modified">1509     m_primitiveUnitType = CSS_VALUE_ID;</span>
1510     switch (e) {
1511     case AlignContent::FlexStart:
1512         m_value.valueID = CSSValueFlexStart;
1513         break;
1514     case AlignContent::FlexEnd:
1515         m_value.valueID = CSSValueFlexEnd;
1516         break;
1517     case AlignContent::Center:
1518         m_value.valueID = CSSValueCenter;
1519         break;
1520     case AlignContent::SpaceBetween:
1521         m_value.valueID = CSSValueSpaceBetween;
1522         break;
1523     case AlignContent::SpaceAround:
1524         m_value.valueID = CSSValueSpaceAround;
1525         break;
1526     case AlignContent::Stretch:
1527         m_value.valueID = CSSValueStretch;
1528         break;
1529     }
</pre>
<hr />
<pre>
1540         return AlignContent::FlexEnd;
1541     case CSSValueCenter:
1542         return AlignContent::Center;
1543     case CSSValueSpaceBetween:
1544         return AlignContent::SpaceBetween;
1545     case CSSValueSpaceAround:
1546         return AlignContent::SpaceAround;
1547     case CSSValueStretch:
1548         return AlignContent::Stretch;
1549     default:
1550         break;
1551     }
1552 
1553     ASSERT_NOT_REACHED();
1554     return AlignContent::Stretch;
1555 }
1556 
1557 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexWrap e)
1558     : CSSValue(PrimitiveClass)
1559 {
<span class="line-modified">1560     m_primitiveUnitType = CSS_VALUE_ID;</span>
1561     switch (e) {
1562     case FlexWrap::NoWrap:
1563         m_value.valueID = CSSValueNowrap;
1564         break;
1565     case FlexWrap::Wrap:
1566         m_value.valueID = CSSValueWrap;
1567         break;
1568     case FlexWrap::Reverse:
1569         m_value.valueID = CSSValueWrapReverse;
1570         break;
1571     }
1572 }
1573 
1574 template&lt;&gt; inline CSSPrimitiveValue::operator FlexWrap() const
1575 {
1576     ASSERT(isValueID());
1577 
1578     switch (m_value.valueID) {
1579     case CSSValueNowrap:
1580         return FlexWrap::NoWrap;
1581     case CSSValueWrap:
1582         return FlexWrap::Wrap;
1583     case CSSValueWrapReverse:
1584         return FlexWrap::Reverse;
1585     default:
1586         break;
1587     }
1588 
1589     ASSERT_NOT_REACHED();
1590     return FlexWrap::NoWrap;
1591 }
1592 
1593 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Float e)
1594     : CSSValue(PrimitiveClass)
1595 {
<span class="line-modified">1596     m_primitiveUnitType = CSS_VALUE_ID;</span>
1597     switch (e) {
1598     case Float::No:
1599         m_value.valueID = CSSValueNone;
1600         break;
1601     case Float::Left:
1602         m_value.valueID = CSSValueLeft;
1603         break;
1604     case Float::Right:
1605         m_value.valueID = CSSValueRight;
1606         break;
1607     }
1608 }
1609 
1610 template&lt;&gt; inline CSSPrimitiveValue::operator Float() const
1611 {
1612     ASSERT(isValueID());
1613 
1614     switch (m_value.valueID) {
1615     case CSSValueLeft:
1616         return Float::Left;
1617     case CSSValueRight:
1618         return Float::Right;
1619     case CSSValueNone:
1620     case CSSValueCenter: // Non-standard CSS value.
1621         return Float::No;
1622     default:
1623         break;
1624     }
1625 
1626     ASSERT_NOT_REACHED();
1627     return Float::No;
1628 }
1629 
1630 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineBreak e)
1631     : CSSValue(PrimitiveClass)
1632 {
<span class="line-modified">1633     m_primitiveUnitType = CSS_VALUE_ID;</span>
1634     switch (e) {
1635     case LineBreak::Auto:
1636         m_value.valueID = CSSValueAuto;
1637         break;
1638     case LineBreak::Loose:
1639         m_value.valueID = CSSValueLoose;
1640         break;
1641     case LineBreak::Normal:
1642         m_value.valueID = CSSValueNormal;
1643         break;
1644     case LineBreak::Strict:
1645         m_value.valueID = CSSValueStrict;
1646         break;
1647     case LineBreak::AfterWhiteSpace:
1648         m_value.valueID = CSSValueAfterWhiteSpace;
1649         break;
1650     case LineBreak::Anywhere:
1651         m_value.valueID = CSSValueAnywhere;
1652         break;
1653     }
</pre>
<hr />
<pre>
1687         return LineBreak::Loose;
1688     case CSSValueNormal:
1689         return LineBreak::Normal;
1690     case CSSValueStrict:
1691         return LineBreak::Strict;
1692     case CSSValueAfterWhiteSpace:
1693         return LineBreak::AfterWhiteSpace;
1694     case CSSValueAnywhere:
1695         return LineBreak::Anywhere;
1696     default:
1697         break;
1698     }
1699 
1700     ASSERT_NOT_REACHED();
1701     return LineBreak::Auto;
1702 }
1703 
1704 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStylePosition e)
1705     : CSSValue(PrimitiveClass)
1706 {
<span class="line-modified">1707     m_primitiveUnitType = CSS_VALUE_ID;</span>
1708     switch (e) {
1709     case ListStylePosition::Outside:
1710         m_value.valueID = CSSValueOutside;
1711         break;
1712     case ListStylePosition::Inside:
1713         m_value.valueID = CSSValueInside;
1714         break;
1715     }
1716 }
1717 
1718 template&lt;&gt; inline CSSPrimitiveValue::operator ListStylePosition() const
1719 {
1720     ASSERT(isValueID());
1721 
1722     switch (m_value.valueID) {
1723     case CSSValueOutside:
1724         return ListStylePosition::Outside;
1725     case CSSValueInside:
1726         return ListStylePosition::Inside;
1727     default:
1728         break;
1729     }
1730 
1731     ASSERT_NOT_REACHED();
1732     return ListStylePosition::Outside;
1733 }
1734 
1735 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStyleType e)
1736     : CSSValue(PrimitiveClass)
1737 {
<span class="line-modified">1738     m_primitiveUnitType = CSS_VALUE_ID;</span>
1739     switch (e) {
1740     case ListStyleType::Afar:
1741         m_value.valueID = CSSValueAfar;
1742         break;
1743     case ListStyleType::Amharic:
1744         m_value.valueID = CSSValueAmharic;
1745         break;
1746     case ListStyleType::AmharicAbegede:
1747         m_value.valueID = CSSValueAmharicAbegede;
1748         break;
1749     case ListStyleType::ArabicIndic:
1750         m_value.valueID = CSSValueArabicIndic;
1751         break;
1752     case ListStyleType::Armenian:
1753         m_value.valueID = CSSValueArmenian;
1754         break;
1755     case ListStyleType::Asterisks:
1756         m_value.valueID = CSSValueAsterisks;
1757         break;
1758     case ListStyleType::Binary:
</pre>
<hr />
<pre>
1981         m_value.valueID = CSSValueUrdu;
1982         break;
1983     }
1984 }
1985 
1986 template&lt;&gt; inline CSSPrimitiveValue::operator ListStyleType() const
1987 {
1988     ASSERT(isValueID());
1989 
1990     switch (m_value.valueID) {
1991     case CSSValueNone:
1992         return ListStyleType::None;
1993     default:
1994         return static_cast&lt;ListStyleType&gt;(m_value.valueID - CSSValueDisc);
1995     }
1996 }
1997 
1998 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarginCollapse e)
1999     : CSSValue(PrimitiveClass)
2000 {
<span class="line-modified">2001     m_primitiveUnitType = CSS_VALUE_ID;</span>
2002     switch (e) {
2003     case MarginCollapse::Collapse:
2004         m_value.valueID = CSSValueCollapse;
2005         break;
2006     case MarginCollapse::Separate:
2007         m_value.valueID = CSSValueSeparate;
2008         break;
2009     case MarginCollapse::Discard:
2010         m_value.valueID = CSSValueDiscard;
2011         break;
2012     }
2013 }
2014 
2015 template&lt;&gt; inline CSSPrimitiveValue::operator MarginCollapse() const
2016 {
2017     ASSERT(isValueID());
2018 
2019     switch (m_value.valueID) {
2020     case CSSValueCollapse:
2021         return MarginCollapse::Collapse;
2022     case CSSValueSeparate:
2023         return MarginCollapse::Separate;
2024     case CSSValueDiscard:
2025         return MarginCollapse::Discard;
2026     default:
2027         break;
2028     }
2029 
2030     ASSERT_NOT_REACHED();
2031     return MarginCollapse::Collapse;
2032 }
2033 
2034 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeBehavior e)
2035     : CSSValue(PrimitiveClass)
2036 {
<span class="line-modified">2037     m_primitiveUnitType = CSS_VALUE_ID;</span>
2038     switch (e) {
2039     case MarqueeBehavior::None:
2040         m_value.valueID = CSSValueNone;
2041         break;
2042     case MarqueeBehavior::Scroll:
2043         m_value.valueID = CSSValueScroll;
2044         break;
2045     case MarqueeBehavior::Slide:
2046         m_value.valueID = CSSValueSlide;
2047         break;
2048     case MarqueeBehavior::Alternate:
2049         m_value.valueID = CSSValueAlternate;
2050         break;
2051     }
2052 }
2053 
2054 template&lt;&gt; inline CSSPrimitiveValue::operator MarqueeBehavior() const
2055 {
2056     ASSERT(isValueID());
2057 
2058     switch (m_value.valueID) {
2059     case CSSValueNone:
2060         return MarqueeBehavior::None;
2061     case CSSValueScroll:
2062         return MarqueeBehavior::Scroll;
2063     case CSSValueSlide:
2064         return MarqueeBehavior::Slide;
2065     case CSSValueAlternate:
2066         return MarqueeBehavior::Alternate;
2067     default:
2068         break;
2069     }
2070 
2071     ASSERT_NOT_REACHED();
2072     return MarqueeBehavior::None;
2073 }
2074 
2075 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeDirection direction)
2076     : CSSValue(PrimitiveClass)
2077 {
<span class="line-modified">2078     m_primitiveUnitType = CSS_VALUE_ID;</span>
2079     switch (direction) {
2080     case MarqueeDirection::Forward:
2081         m_value.valueID = CSSValueForwards;
2082         break;
2083     case MarqueeDirection::Backward:
2084         m_value.valueID = CSSValueBackwards;
2085         break;
2086     case MarqueeDirection::Auto:
2087         m_value.valueID = CSSValueAuto;
2088         break;
2089     case MarqueeDirection::Up:
2090         m_value.valueID = CSSValueUp;
2091         break;
2092     case MarqueeDirection::Down:
2093         m_value.valueID = CSSValueDown;
2094         break;
2095     case MarqueeDirection::Left:
2096         m_value.valueID = CSSValueLeft;
2097         break;
2098     case MarqueeDirection::Right:
</pre>
<hr />
<pre>
2116     case CSSValueUp: // We don&#39;t support vertical languages, so AHEAD just maps to UP.
2117         return MarqueeDirection::Up;
2118     case CSSValueReverse:
2119     case CSSValueDown: // REVERSE just maps to DOWN, since we don&#39;t do vertical text.
2120         return MarqueeDirection::Down;
2121     case CSSValueLeft:
2122         return MarqueeDirection::Left;
2123     case CSSValueRight:
2124         return MarqueeDirection::Right;
2125     default:
2126         break;
2127     }
2128 
2129     ASSERT_NOT_REACHED();
2130     return MarqueeDirection::Auto;
2131 }
2132 
2133 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(NBSPMode e)
2134     : CSSValue(PrimitiveClass)
2135 {
<span class="line-modified">2136     m_primitiveUnitType = CSS_VALUE_ID;</span>
2137     switch (e) {
2138     case NBSPMode::Normal:
2139         m_value.valueID = CSSValueNormal;
2140         break;
2141     case NBSPMode::Space:
2142         m_value.valueID = CSSValueSpace;
2143         break;
2144     }
2145 }
2146 
2147 template&lt;&gt; inline CSSPrimitiveValue::operator NBSPMode() const
2148 {
2149     ASSERT(isValueID());
2150 
2151     switch (m_value.valueID) {
2152     case CSSValueSpace:
2153         return NBSPMode::Space;
2154     case CSSValueNormal:
2155         return NBSPMode::Normal;
2156     default:
2157         break;
2158     }
2159 
2160     ASSERT_NOT_REACHED();
2161     return NBSPMode::Normal;
2162 }
2163 
2164 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Overflow e)
2165     : CSSValue(PrimitiveClass)
2166 {
<span class="line-modified">2167     m_primitiveUnitType = CSS_VALUE_ID;</span>
2168     switch (e) {
2169     case Overflow::Visible:
2170         m_value.valueID = CSSValueVisible;
2171         break;
2172     case Overflow::Hidden:
2173         m_value.valueID = CSSValueHidden;
2174         break;
2175     case Overflow::Scroll:
2176         m_value.valueID = CSSValueScroll;
2177         break;
2178     case Overflow::Auto:
2179         m_value.valueID = CSSValueAuto;
2180         break;
2181     case Overflow::PagedX:
2182         m_value.valueID = CSSValueWebkitPagedX;
2183         break;
2184     case Overflow::PagedY:
2185         m_value.valueID = CSSValueWebkitPagedY;
2186         break;
2187     }
</pre>
<hr />
<pre>
2199     case CSSValueScroll:
2200         return Overflow::Scroll;
2201     case CSSValueOverlay:
2202     case CSSValueAuto:
2203         return Overflow::Auto;
2204     case CSSValueWebkitPagedX:
2205         return Overflow::PagedX;
2206     case CSSValueWebkitPagedY:
2207         return Overflow::PagedY;
2208     default:
2209         break;
2210     }
2211 
2212     ASSERT_NOT_REACHED();
2213     return Overflow::Visible;
2214 }
2215 
2216 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakBetween e)
2217     : CSSValue(PrimitiveClass)
2218 {
<span class="line-modified">2219     m_primitiveUnitType = CSS_VALUE_ID;</span>
2220     switch (e) {
2221     case BreakBetween::Auto:
2222         m_value.valueID = CSSValueAuto;
2223         break;
2224     case BreakBetween::Avoid:
2225         m_value.valueID = CSSValueAvoid;
2226         break;
2227     case BreakBetween::AvoidColumn:
2228         m_value.valueID = CSSValueAvoidColumn;
2229         break;
2230     case BreakBetween::AvoidPage:
2231         m_value.valueID = CSSValueAvoidPage;
2232         break;
2233     case BreakBetween::Column:
2234         m_value.valueID = CSSValueColumn;
2235         break;
2236     case BreakBetween::Page:
2237         m_value.valueID = CSSValuePage;
2238         break;
2239     case BreakBetween::LeftPage:
</pre>
<hr />
<pre>
2270         return BreakBetween::Page;
2271     case CSSValueLeft:
2272         return BreakBetween::LeftPage;
2273     case CSSValueRight:
2274         return BreakBetween::RightPage;
2275     case CSSValueRecto:
2276         return BreakBetween::RectoPage;
2277     case CSSValueVerso:
2278         return BreakBetween::VersoPage;
2279     default:
2280         break;
2281     }
2282 
2283     ASSERT_NOT_REACHED();
2284     return BreakBetween::Auto;
2285 }
2286 
2287 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakInside e)
2288     : CSSValue(PrimitiveClass)
2289 {
<span class="line-modified">2290     m_primitiveUnitType = CSS_VALUE_ID;</span>
2291     switch (e) {
2292     case BreakInside::Auto:
2293         m_value.valueID = CSSValueAuto;
2294         break;
2295     case BreakInside::Avoid:
2296         m_value.valueID = CSSValueAvoid;
2297         break;
2298     case BreakInside::AvoidColumn:
2299         m_value.valueID = CSSValueAvoidColumn;
2300         break;
2301     case BreakInside::AvoidPage:
2302         m_value.valueID = CSSValueAvoidPage;
2303         break;
2304     }
2305 }
2306 
2307 template&lt;&gt; inline CSSPrimitiveValue::operator BreakInside() const
2308 {
2309     ASSERT(isValueID());
2310 
2311     switch (m_value.valueID) {
2312     case CSSValueAuto:
2313         return BreakInside::Auto;
2314     case CSSValueAvoid:
2315         return BreakInside::Avoid;
2316     case CSSValueAvoidColumn:
2317         return BreakInside::AvoidColumn;
2318     case CSSValueAvoidPage:
2319         return BreakInside::AvoidPage;
2320     default:
2321         break;
2322     }
2323 
2324     ASSERT_NOT_REACHED();
2325     return BreakInside::Auto;
2326 }
2327 
2328 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PositionType e)
2329     : CSSValue(PrimitiveClass)
2330 {
<span class="line-modified">2331     m_primitiveUnitType = CSS_VALUE_ID;</span>
2332     switch (e) {
2333     case PositionType::Static:
2334         m_value.valueID = CSSValueStatic;
2335         break;
2336     case PositionType::Relative:
2337         m_value.valueID = CSSValueRelative;
2338         break;
2339     case PositionType::Absolute:
2340         m_value.valueID = CSSValueAbsolute;
2341         break;
2342     case PositionType::Fixed:
2343         m_value.valueID = CSSValueFixed;
2344         break;
2345     case PositionType::Sticky:
2346         m_value.valueID = CSSValueSticky;
2347         break;
2348     }
2349 }
2350 
2351 template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
</pre>
<hr />
<pre>
2358     case CSSValueRelative:
2359         return PositionType::Relative;
2360     case CSSValueAbsolute:
2361         return PositionType::Absolute;
2362     case CSSValueFixed:
2363         return PositionType::Fixed;
2364     case CSSValueSticky:
2365     case CSSValueWebkitSticky:
2366         return PositionType::Sticky;
2367     default:
2368         break;
2369     }
2370 
2371     ASSERT_NOT_REACHED();
2372     return PositionType::Static;
2373 }
2374 
2375 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Resize e)
2376     : CSSValue(PrimitiveClass)
2377 {
<span class="line-modified">2378     m_primitiveUnitType = CSS_VALUE_ID;</span>
2379     switch (e) {
2380     case Resize::Both:
2381         m_value.valueID = CSSValueBoth;
2382         break;
2383     case Resize::Horizontal:
2384         m_value.valueID = CSSValueHorizontal;
2385         break;
2386     case Resize::Vertical:
2387         m_value.valueID = CSSValueVertical;
2388         break;
2389     case Resize::None:
2390         m_value.valueID = CSSValueNone;
2391         break;
2392     }
2393 }
2394 
2395 template&lt;&gt; inline CSSPrimitiveValue::operator Resize() const
2396 {
2397     ASSERT(isValueID());
2398 
</pre>
<hr />
<pre>
2402     case CSSValueHorizontal:
2403         return Resize::Horizontal;
2404     case CSSValueVertical:
2405         return Resize::Vertical;
2406     case CSSValueAuto:
2407         ASSERT_NOT_REACHED(); // Depends on settings, thus should be handled by the caller.
2408         return Resize::None;
2409     case CSSValueNone:
2410         return Resize::None;
2411     default:
2412         break;
2413     }
2414 
2415     ASSERT_NOT_REACHED();
2416     return Resize::None;
2417 }
2418 
2419 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TableLayoutType e)
2420     : CSSValue(PrimitiveClass)
2421 {
<span class="line-modified">2422     m_primitiveUnitType = CSS_VALUE_ID;</span>
2423     switch (e) {
2424     case TableLayoutType::Auto:
2425         m_value.valueID = CSSValueAuto;
2426         break;
2427     case TableLayoutType::Fixed:
2428         m_value.valueID = CSSValueFixed;
2429         break;
2430     }
2431 }
2432 
2433 template&lt;&gt; inline CSSPrimitiveValue::operator TableLayoutType() const
2434 {
2435     ASSERT(isValueID());
2436 
2437     switch (m_value.valueID) {
2438     case CSSValueFixed:
2439         return TableLayoutType::Fixed;
2440     case CSSValueAuto:
2441         return TableLayoutType::Auto;
2442     default:
2443         break;
2444     }
2445 
2446     ASSERT_NOT_REACHED();
2447     return TableLayoutType::Auto;
2448 }
2449 
2450 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignMode e)
2451     : CSSValue(PrimitiveClass)
2452 {
<span class="line-modified">2453     m_primitiveUnitType = CSS_VALUE_ID;</span>
2454     switch (e) {
2455     case TextAlignMode::Start:
2456         m_value.valueID = CSSValueStart;
2457         break;
2458     case TextAlignMode::End:
2459         m_value.valueID = CSSValueEnd;
2460         break;
2461     case TextAlignMode::Left:
2462         m_value.valueID = CSSValueLeft;
2463         break;
2464     case TextAlignMode::Right:
2465         m_value.valueID = CSSValueRight;
2466         break;
2467     case TextAlignMode::Center:
2468         m_value.valueID = CSSValueCenter;
2469         break;
2470     case TextAlignMode::Justify:
2471         m_value.valueID = CSSValueJustify;
2472         break;
2473     case TextAlignMode::WebKitLeft:
</pre>
<hr />
<pre>
2484 
2485 template&lt;&gt; inline CSSPrimitiveValue::operator TextAlignMode() const
2486 {
2487     ASSERT(isValueID());
2488 
2489     switch (m_value.valueID) {
2490     case CSSValueWebkitAuto: // Legacy -webkit-auto. Eqiuvalent to start.
2491     case CSSValueStart:
2492         return TextAlignMode::Start;
2493     case CSSValueEnd:
2494         return TextAlignMode::End;
2495     default:
2496         return static_cast&lt;TextAlignMode&gt;(m_value.valueID - CSSValueLeft);
2497     }
2498 }
2499 
2500 #if ENABLE(CSS3_TEXT)
2501 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignLast e)
2502     : CSSValue(PrimitiveClass)
2503 {
<span class="line-modified">2504     m_primitiveUnitType = CSS_VALUE_ID;</span>
2505     switch (e) {
2506     case TextAlignLast::Start:
2507         m_value.valueID = CSSValueStart;
2508         break;
2509     case TextAlignLast::End:
2510         m_value.valueID = CSSValueEnd;
2511         break;
2512     case TextAlignLast::Left:
2513         m_value.valueID = CSSValueLeft;
2514         break;
2515     case TextAlignLast::Right:
2516         m_value.valueID = CSSValueRight;
2517         break;
2518     case TextAlignLast::Center:
2519         m_value.valueID = CSSValueCenter;
2520         break;
2521     case TextAlignLast::Justify:
2522         m_value.valueID = CSSValueJustify;
2523         break;
2524     case TextAlignLast::Auto:
</pre>
<hr />
<pre>
2540         return TextAlignLast::End;
2541     case CSSValueLeft:
2542         return TextAlignLast::Left;
2543     case CSSValueRight:
2544         return TextAlignLast::Right;
2545     case CSSValueCenter:
2546         return TextAlignLast::Center;
2547     case CSSValueJustify:
2548         return TextAlignLast::Justify;
2549     default:
2550         break;
2551     }
2552 
2553     ASSERT_NOT_REACHED();
2554     return TextAlignLast::Auto;
2555 }
2556 
2557 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextJustify e)
2558     : CSSValue(PrimitiveClass)
2559 {
<span class="line-modified">2560     m_primitiveUnitType = CSS_VALUE_ID;</span>
2561     switch (e) {
2562     case TextJustify::Auto:
2563         m_value.valueID = CSSValueAuto;
2564         break;
2565     case TextJustify::None:
2566         m_value.valueID = CSSValueNone;
2567         break;
2568     case TextJustify::InterWord:
2569         m_value.valueID = CSSValueInterWord;
2570         break;
2571     case TextJustify::Distribute:
2572         m_value.valueID = CSSValueDistribute;
2573         break;
2574     }
2575 }
2576 
2577 template&lt;&gt; inline CSSPrimitiveValue::operator TextJustify() const
2578 {
2579     ASSERT(isValueID());
2580 
</pre>
<hr />
<pre>
2632         return TextDecorationStyle::Solid;
2633     case CSSValueDouble:
2634         return TextDecorationStyle::Double;
2635     case CSSValueDotted:
2636         return TextDecorationStyle::Dotted;
2637     case CSSValueDashed:
2638         return TextDecorationStyle::Dashed;
2639     case CSSValueWavy:
2640         return TextDecorationStyle::Wavy;
2641     default:
2642         break;
2643     }
2644 
2645     ASSERT_NOT_REACHED();
2646     return TextDecorationStyle::Solid;
2647 }
2648 
2649 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextUnderlinePosition position)
2650     : CSSValue(PrimitiveClass)
2651 {
<span class="line-modified">2652     m_primitiveUnitType = CSS_VALUE_ID;</span>
2653     switch (position) {
2654     case TextUnderlinePosition::Auto:
2655         m_value.valueID = CSSValueAuto;
2656         break;
2657     case TextUnderlinePosition::Under:
2658         m_value.valueID = CSSValueUnder;
2659         break;
2660     case TextUnderlinePosition::FromFont:
2661         m_value.valueID = CSSValueFromFont;
2662         break;
2663     }
2664 
2665     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2666 }
2667 
2668 template&lt;&gt; inline CSSPrimitiveValue::operator TextUnderlinePosition() const
2669 {
2670     ASSERT(isValueID());
2671 
2672     switch (m_value.valueID) {
2673     case CSSValueAuto:
2674         return TextUnderlinePosition::Auto;
2675     case CSSValueUnder:
2676         return TextUnderlinePosition::Under;
2677     case CSSValueFromFont:
2678         return TextUnderlinePosition::FromFont;
2679     default:
2680         break;
2681     }
2682 
2683     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2684     ASSERT_NOT_REACHED();
2685     return TextUnderlinePosition::Auto;
2686 }
2687 
2688 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextSecurity e)
2689     : CSSValue(PrimitiveClass)
2690 {
<span class="line-modified">2691     m_primitiveUnitType = CSS_VALUE_ID;</span>
2692     switch (e) {
2693     case TextSecurity::None:
2694         m_value.valueID = CSSValueNone;
2695         break;
2696     case TextSecurity::Disc:
2697         m_value.valueID = CSSValueDisc;
2698         break;
2699     case TextSecurity::Circle:
2700         m_value.valueID = CSSValueCircle;
2701         break;
2702     case TextSecurity::Square:
2703         m_value.valueID = CSSValueSquare;
2704         break;
2705     }
2706 }
2707 
2708 template&lt;&gt; inline CSSPrimitiveValue::operator TextSecurity() const
2709 {
2710     ASSERT(isValueID());
2711 
2712     switch (m_value.valueID) {
2713     case CSSValueNone:
2714         return TextSecurity::None;
2715     case CSSValueDisc:
2716         return TextSecurity::Disc;
2717     case CSSValueCircle:
2718         return TextSecurity::Circle;
2719     case CSSValueSquare:
2720         return TextSecurity::Square;
2721     default:
2722         break;
2723     }
2724 
2725     ASSERT_NOT_REACHED();
2726     return TextSecurity::None;
2727 }
2728 
2729 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextTransform e)
2730     : CSSValue(PrimitiveClass)
2731 {
<span class="line-modified">2732     m_primitiveUnitType = CSS_VALUE_ID;</span>
2733     switch (e) {
2734     case TextTransform::Capitalize:
2735         m_value.valueID = CSSValueCapitalize;
2736         break;
2737     case TextTransform::Uppercase:
2738         m_value.valueID = CSSValueUppercase;
2739         break;
2740     case TextTransform::Lowercase:
2741         m_value.valueID = CSSValueLowercase;
2742         break;
2743     case TextTransform::None:
2744         m_value.valueID = CSSValueNone;
2745         break;
2746     }
2747 }
2748 
2749 template&lt;&gt; inline CSSPrimitiveValue::operator TextTransform() const
2750 {
2751     ASSERT(isValueID());
2752 
2753     switch (m_value.valueID) {
2754     case CSSValueCapitalize:
2755         return TextTransform::Capitalize;
2756     case CSSValueUppercase:
2757         return TextTransform::Uppercase;
2758     case CSSValueLowercase:
2759         return TextTransform::Lowercase;
2760     case CSSValueNone:
2761         return TextTransform::None;
2762     default:
2763         break;
2764     }
2765 
2766     ASSERT_NOT_REACHED();
2767     return TextTransform::None;
2768 }
2769 
2770 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EUnicodeBidi e)
2771     : CSSValue(PrimitiveClass)
2772 {
<span class="line-modified">2773     m_primitiveUnitType = CSS_VALUE_ID;</span>
2774     switch (e) {
2775     case UBNormal:
2776         m_value.valueID = CSSValueNormal;
2777         break;
2778     case Embed:
2779         m_value.valueID = CSSValueEmbed;
2780         break;
2781     case Override:
2782         m_value.valueID = CSSValueBidiOverride;
2783         break;
2784     case Isolate:
2785         m_value.valueID = CSSValueIsolate;
2786         break;
2787     case IsolateOverride:
2788         m_value.valueID = CSSValueIsolateOverride;
2789         break;
2790     case Plaintext:
2791         m_value.valueID = CSSValuePlaintext;
2792         break;
2793     }
</pre>
<hr />
<pre>
2807     case CSSValueIsolate:
2808     case CSSValueWebkitIsolate:
2809         return Isolate;
2810     case CSSValueIsolateOverride:
2811     case CSSValueWebkitIsolateOverride:
2812         return IsolateOverride;
2813     case CSSValuePlaintext:
2814     case CSSValueWebkitPlaintext:
2815         return Plaintext;
2816     default:
2817         break;
2818     }
2819 
2820     ASSERT_NOT_REACHED();
2821     return UBNormal;
2822 }
2823 
2824 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserDrag e)
2825     : CSSValue(PrimitiveClass)
2826 {
<span class="line-modified">2827     m_primitiveUnitType = CSS_VALUE_ID;</span>
2828     switch (e) {
2829     case UserDrag::Auto:
2830         m_value.valueID = CSSValueAuto;
2831         break;
2832     case UserDrag::None:
2833         m_value.valueID = CSSValueNone;
2834         break;
2835     case UserDrag::Element:
2836         m_value.valueID = CSSValueElement;
2837         break;
2838     default:
2839         break;
2840     }
2841 }
2842 
2843 template&lt;&gt; inline CSSPrimitiveValue::operator UserDrag() const
2844 {
2845     ASSERT(isValueID());
2846 
2847     switch (m_value.valueID) {
2848     case CSSValueAuto:
2849         return UserDrag::Auto;
2850     case CSSValueNone:
2851         return UserDrag::None;
2852     case CSSValueElement:
2853         return UserDrag::Element;
2854     default:
2855         break;
2856     }
2857 
2858     ASSERT_NOT_REACHED();
2859     return UserDrag::Auto;
2860 }
2861 
2862 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserModify e)
2863     : CSSValue(PrimitiveClass)
2864 {
<span class="line-modified">2865     m_primitiveUnitType = CSS_VALUE_ID;</span>
2866     switch (e) {
2867     case UserModify::ReadOnly:
2868         m_value.valueID = CSSValueReadOnly;
2869         break;
2870     case UserModify::ReadWrite:
2871         m_value.valueID = CSSValueReadWrite;
2872         break;
2873     case UserModify::ReadWritePlaintextOnly:
2874         m_value.valueID = CSSValueReadWritePlaintextOnly;
2875         break;
2876     }
2877 }
2878 
2879 template&lt;&gt; inline CSSPrimitiveValue::operator UserModify() const
2880 {
2881     ASSERT(isValueID());
2882 
2883     switch (m_value.valueID) {
2884     case CSSValueReadOnly:
2885         return UserModify::ReadOnly;
2886     case CSSValueReadWrite:
2887         return UserModify::ReadWrite;
2888     case CSSValueReadWritePlaintextOnly:
2889         return UserModify::ReadWritePlaintextOnly;
2890     default:
2891         break;
2892     }
2893 
2894     ASSERT_NOT_REACHED();
2895     return UserModify::ReadOnly;
2896 }
2897 
2898 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserSelect e)
2899     : CSSValue(PrimitiveClass)
2900 {
<span class="line-modified">2901     m_primitiveUnitType = CSS_VALUE_ID;</span>
2902     switch (e) {
2903     case UserSelect::None:
2904         m_value.valueID = CSSValueNone;
2905         break;
2906     case UserSelect::Text:
2907         m_value.valueID = CSSValueText;
2908         break;
2909     case UserSelect::All:
2910         m_value.valueID = CSSValueAll;
2911         break;
2912     }
2913 }
2914 
2915 template&lt;&gt; inline CSSPrimitiveValue::operator UserSelect() const
2916 {
2917     ASSERT(isValueID());
2918 
2919     switch (m_value.valueID) {
2920     case CSSValueAuto:
2921         return UserSelect::Text;
2922     case CSSValueNone:
2923         return UserSelect::None;
2924     case CSSValueText:
2925         return UserSelect::Text;
2926     case CSSValueAll:
2927         return UserSelect::All;
2928     default:
2929         break;
2930     }
2931 
2932     ASSERT_NOT_REACHED();
2933     return UserSelect::Text;
2934 }
2935 
2936 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VerticalAlign a)
2937     : CSSValue(PrimitiveClass)
2938 {
<span class="line-modified">2939     m_primitiveUnitType = CSS_VALUE_ID;</span>
2940     switch (a) {
2941     case VerticalAlign::Top:
2942         m_value.valueID = CSSValueTop;
2943         break;
2944     case VerticalAlign::Bottom:
2945         m_value.valueID = CSSValueBottom;
2946         break;
2947     case VerticalAlign::Middle:
2948         m_value.valueID = CSSValueMiddle;
2949         break;
2950     case VerticalAlign::Baseline:
2951         m_value.valueID = CSSValueBaseline;
2952         break;
2953     case VerticalAlign::TextBottom:
2954         m_value.valueID = CSSValueTextBottom;
2955         break;
2956     case VerticalAlign::TextTop:
2957         m_value.valueID = CSSValueTextTop;
2958         break;
2959     case VerticalAlign::Sub:
</pre>
<hr />
<pre>
2987         return VerticalAlign::TextBottom;
2988     case CSSValueTextTop:
2989         return VerticalAlign::TextTop;
2990     case CSSValueSub:
2991         return VerticalAlign::Sub;
2992     case CSSValueSuper:
2993         return VerticalAlign::Super;
2994     case CSSValueWebkitBaselineMiddle:
2995         return VerticalAlign::BaselineMiddle;
2996     default:
2997         break;
2998     }
2999 
3000     ASSERT_NOT_REACHED();
3001     return VerticalAlign::Top;
3002 }
3003 
3004 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Visibility e)
3005     : CSSValue(PrimitiveClass)
3006 {
<span class="line-modified">3007     m_primitiveUnitType = CSS_VALUE_ID;</span>
3008     switch (e) {
3009     case Visibility::Visible:
3010         m_value.valueID = CSSValueVisible;
3011         break;
3012     case Visibility::Hidden:
3013         m_value.valueID = CSSValueHidden;
3014         break;
3015     case Visibility::Collapse:
3016         m_value.valueID = CSSValueCollapse;
3017         break;
3018     }
3019 }
3020 
3021 template&lt;&gt; inline CSSPrimitiveValue::operator Visibility() const
3022 {
3023     ASSERT(isValueID());
3024 
3025     switch (m_value.valueID) {
3026     case CSSValueHidden:
3027         return Visibility::Hidden;
3028     case CSSValueVisible:
3029         return Visibility::Visible;
3030     case CSSValueCollapse:
3031         return Visibility::Collapse;
3032     default:
3033         break;
3034     }
3035 
3036     ASSERT_NOT_REACHED();
3037     return Visibility::Visible;
3038 }
3039 
3040 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WhiteSpace e)
3041     : CSSValue(PrimitiveClass)
3042 {
<span class="line-modified">3043     m_primitiveUnitType = CSS_VALUE_ID;</span>
3044     switch (e) {
3045     case WhiteSpace::Normal:
3046         m_value.valueID = CSSValueNormal;
3047         break;
3048     case WhiteSpace::Pre:
3049         m_value.valueID = CSSValuePre;
3050         break;
3051     case WhiteSpace::PreWrap:
3052         m_value.valueID = CSSValuePreWrap;
3053         break;
3054     case WhiteSpace::PreLine:
3055         m_value.valueID = CSSValuePreLine;
3056         break;
3057     case WhiteSpace::NoWrap:
3058         m_value.valueID = CSSValueNowrap;
3059         break;
3060     case WhiteSpace::KHTMLNoWrap:
3061         m_value.valueID = CSSValueWebkitNowrap;
3062         break;
3063     case WhiteSpace::BreakSpaces:
</pre>
<hr />
<pre>
3079         return WhiteSpace::Pre;
3080     case CSSValuePreWrap:
3081         return WhiteSpace::PreWrap;
3082     case CSSValuePreLine:
3083         return WhiteSpace::PreLine;
3084     case CSSValueNormal:
3085         return WhiteSpace::Normal;
3086     case CSSValueBreakSpaces:
3087         return WhiteSpace::BreakSpaces;
3088     default:
3089         break;
3090     }
3091 
3092     ASSERT_NOT_REACHED();
3093     return WhiteSpace::Normal;
3094 }
3095 
3096 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WordBreak e)
3097     : CSSValue(PrimitiveClass)
3098 {
<span class="line-modified">3099     m_primitiveUnitType = CSS_VALUE_ID;</span>
3100     switch (e) {
3101     case WordBreak::Normal:
3102         m_value.valueID = CSSValueNormal;
3103         break;
3104     case WordBreak::BreakAll:
3105         m_value.valueID = CSSValueBreakAll;
3106         break;
3107     case WordBreak::KeepAll:
3108         m_value.valueID = CSSValueKeepAll;
3109         break;
3110     case WordBreak::BreakWord:
3111         m_value.valueID = CSSValueBreakWord;
3112         break;
3113     }
3114 }
3115 
3116 template&lt;&gt; inline CSSPrimitiveValue::operator WordBreak() const
3117 {
3118     ASSERT(isValueID());
3119 
3120     switch (m_value.valueID) {
3121     case CSSValueBreakAll:
3122         return WordBreak::BreakAll;
3123     case CSSValueKeepAll:
3124         return WordBreak::KeepAll;
3125     case CSSValueBreakWord:
3126         return WordBreak::BreakWord;
3127     case CSSValueNormal:
3128         return WordBreak::Normal;
3129     default:
3130         break;
3131     }
3132 
3133     ASSERT_NOT_REACHED();
3134     return WordBreak::Normal;
3135 }
3136 
3137 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowWrap e)
3138     : CSSValue(PrimitiveClass)
3139 {
<span class="line-modified">3140     m_primitiveUnitType = CSS_VALUE_ID;</span>
3141     switch (e) {
3142     case OverflowWrap::Normal:
3143         m_value.valueID = CSSValueNormal;
3144         break;
3145     case OverflowWrap::Break:
3146         m_value.valueID = CSSValueBreakWord;
3147         break;
3148     }
3149 }
3150 
3151 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowWrap() const
3152 {
3153     ASSERT(isValueID());
3154 
3155     switch (m_value.valueID) {
3156     case CSSValueBreakWord:
3157         return OverflowWrap::Break;
3158     case CSSValueNormal:
3159         return OverflowWrap::Normal;
3160     default:
3161         break;
3162     }
3163 
3164     ASSERT_NOT_REACHED();
3165     return OverflowWrap::Normal;
3166 }
3167 
3168 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextDirection e)
3169     : CSSValue(PrimitiveClass)
3170 {
<span class="line-modified">3171     m_primitiveUnitType = CSS_VALUE_ID;</span>
3172     switch (e) {
3173     case TextDirection::LTR:
3174         m_value.valueID = CSSValueLtr;
3175         break;
3176     case TextDirection::RTL:
3177         m_value.valueID = CSSValueRtl;
3178         break;
3179     }
3180 }
3181 
3182 template&lt;&gt; inline CSSPrimitiveValue::operator TextDirection() const
3183 {
3184     ASSERT(isValueID());
3185 
3186     switch (m_value.valueID) {
3187     case CSSValueLtr:
3188         return TextDirection::LTR;
3189     case CSSValueRtl:
3190         return TextDirection::RTL;
3191     default:
3192         break;
3193     }
3194 
3195     ASSERT_NOT_REACHED();
3196     return TextDirection::LTR;
3197 }
3198 
3199 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WritingMode e)
3200     : CSSValue(PrimitiveClass)
3201 {
<span class="line-modified">3202     m_primitiveUnitType = CSS_VALUE_ID;</span>
3203     switch (e) {
3204     case TopToBottomWritingMode:
3205         m_value.valueID = CSSValueHorizontalTb;
3206         break;
3207     case RightToLeftWritingMode:
3208         m_value.valueID = CSSValueVerticalRl;
3209         break;
3210     case LeftToRightWritingMode:
3211         m_value.valueID = CSSValueVerticalLr;
3212         break;
3213     case BottomToTopWritingMode:
3214         m_value.valueID = CSSValueHorizontalBt;
3215         break;
3216     }
3217 }
3218 
3219 template&lt;&gt; inline CSSPrimitiveValue::operator WritingMode() const
3220 {
3221     ASSERT(isValueID());
3222 
</pre>
<hr />
<pre>
3229         return TopToBottomWritingMode;
3230     case CSSValueVerticalRl:
3231     case CSSValueTb:
3232     case CSSValueTbRl:
3233         return RightToLeftWritingMode;
3234     case CSSValueVerticalLr:
3235         return LeftToRightWritingMode;
3236     case CSSValueHorizontalBt:
3237         return BottomToTopWritingMode;
3238     default:
3239         break;
3240     }
3241 
3242     ASSERT_NOT_REACHED();
3243     return TopToBottomWritingMode;
3244 }
3245 
3246 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextCombine e)
3247     : CSSValue(PrimitiveClass)
3248 {
<span class="line-modified">3249     m_primitiveUnitType = CSS_VALUE_ID;</span>
3250     switch (e) {
3251     case TextCombine::None:
3252         m_value.valueID = CSSValueNone;
3253         break;
3254     case TextCombine::Horizontal:
3255         m_value.valueID = CSSValueHorizontal;
3256         break;
3257     }
3258 }
3259 
3260 template&lt;&gt; inline CSSPrimitiveValue::operator TextCombine() const
3261 {
3262     ASSERT(isValueID());
3263 
3264     switch (m_value.valueID) {
3265     case CSSValueNone:
3266         return TextCombine::None;
3267     case CSSValueHorizontal:
3268         return TextCombine::Horizontal;
3269     default:
3270         break;
3271     }
3272 
3273     ASSERT_NOT_REACHED();
3274     return TextCombine::None;
3275 }
3276 
3277 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(RubyPosition position)
3278     : CSSValue(PrimitiveClass)
3279 {
<span class="line-modified">3280     m_primitiveUnitType = CSS_VALUE_ID;</span>
3281     switch (position) {
3282     case RubyPosition::Before:
3283         m_value.valueID = CSSValueBefore;
3284         break;
3285     case RubyPosition::After:
3286         m_value.valueID = CSSValueAfter;
3287         break;
3288     case RubyPosition::InterCharacter:
3289         m_value.valueID = CSSValueInterCharacter;
3290         break;
3291     }
3292 }
3293 
3294 template&lt;&gt; inline CSSPrimitiveValue::operator RubyPosition() const
3295 {
3296     ASSERT(isValueID());
3297 
3298     switch (m_value.valueID) {
3299     case CSSValueBefore:
3300         return RubyPosition::Before;
3301     case CSSValueAfter:
3302         return RubyPosition::After;
3303     case CSSValueInterCharacter:
3304         return RubyPosition::InterCharacter;
3305     default:
3306         break;
3307     }
3308 
3309     ASSERT_NOT_REACHED();
3310     return RubyPosition::Before;
3311 }
3312 
3313 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOverflow overflow)
3314     : CSSValue(PrimitiveClass)
3315 {
<span class="line-modified">3316     m_primitiveUnitType = CSS_VALUE_ID;</span>
3317     switch (overflow) {
3318     case TextOverflow::Clip:
3319         m_value.valueID = CSSValueClip;
3320         break;
3321     case TextOverflow::Ellipsis:
3322         m_value.valueID = CSSValueEllipsis;
3323         break;
3324     }
3325 }
3326 
3327 template&lt;&gt; inline CSSPrimitiveValue::operator TextOverflow() const
3328 {
3329     ASSERT(isValueID());
3330 
3331     switch (m_value.valueID) {
3332     case CSSValueClip:
3333         return TextOverflow::Clip;
3334     case CSSValueEllipsis:
3335         return TextOverflow::Ellipsis;
3336     default:
3337         break;
3338     }
3339 
3340     ASSERT_NOT_REACHED();
3341     return TextOverflow::Clip;
3342 }
3343 
3344 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisFill fill)
3345     : CSSValue(PrimitiveClass)
3346 {
<span class="line-modified">3347     m_primitiveUnitType = CSS_VALUE_ID;</span>
3348     switch (fill) {
3349     case TextEmphasisFill::Filled:
3350         m_value.valueID = CSSValueFilled;
3351         break;
3352     case TextEmphasisFill::Open:
3353         m_value.valueID = CSSValueOpen;
3354         break;
3355     }
3356 }
3357 
3358 template&lt;&gt; inline CSSPrimitiveValue::operator TextEmphasisFill() const
3359 {
3360     ASSERT(isValueID());
3361 
3362     switch (m_value.valueID) {
3363     case CSSValueFilled:
3364         return TextEmphasisFill::Filled;
3365     case CSSValueOpen:
3366         return TextEmphasisFill::Open;
3367     default:
3368         break;
3369     }
3370 
3371     ASSERT_NOT_REACHED();
3372     return TextEmphasisFill::Filled;
3373 }
3374 
3375 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisMark mark)
3376     : CSSValue(PrimitiveClass)
3377 {
<span class="line-modified">3378     m_primitiveUnitType = CSS_VALUE_ID;</span>
3379     switch (mark) {
3380     case TextEmphasisMark::Dot:
3381         m_value.valueID = CSSValueDot;
3382         break;
3383     case TextEmphasisMark::Circle:
3384         m_value.valueID = CSSValueCircle;
3385         break;
3386     case TextEmphasisMark::DoubleCircle:
3387         m_value.valueID = CSSValueDoubleCircle;
3388         break;
3389     case TextEmphasisMark::Triangle:
3390         m_value.valueID = CSSValueTriangle;
3391         break;
3392     case TextEmphasisMark::Sesame:
3393         m_value.valueID = CSSValueSesame;
3394         break;
3395     case TextEmphasisMark::None:
3396     case TextEmphasisMark::Auto:
3397     case TextEmphasisMark::Custom:
3398         ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
3412         return TextEmphasisMark::Dot;
3413     case CSSValueCircle:
3414         return TextEmphasisMark::Circle;
3415     case CSSValueDoubleCircle:
3416         return TextEmphasisMark::DoubleCircle;
3417     case CSSValueTriangle:
3418         return TextEmphasisMark::Triangle;
3419     case CSSValueSesame:
3420         return TextEmphasisMark::Sesame;
3421     default:
3422         break;
3423     }
3424 
3425     ASSERT_NOT_REACHED();
3426     return TextEmphasisMark::None;
3427 }
3428 
3429 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOrientation e)
3430     : CSSValue(PrimitiveClass)
3431 {
<span class="line-modified">3432     m_primitiveUnitType = CSS_VALUE_ID;</span>
3433     switch (e) {
3434     case TextOrientation::Sideways:
3435         m_value.valueID = CSSValueSideways;
3436         break;
3437     case TextOrientation::Mixed:
3438         m_value.valueID = CSSValueMixed;
3439         break;
3440     case TextOrientation::Upright:
3441         m_value.valueID = CSSValueUpright;
3442         break;
3443     }
3444 }
3445 
3446 template&lt;&gt; inline CSSPrimitiveValue::operator TextOrientation() const
3447 {
3448     ASSERT(isValueID());
3449 
3450     switch (m_value.valueID) {
3451     case CSSValueSideways:
3452         return TextOrientation::Sideways;
3453     case CSSValueSidewaysRight:
3454         return TextOrientation::Sideways;
3455     case CSSValueVerticalRight:
3456         return TextOrientation::Mixed;
3457     case CSSValueMixed:
3458         return TextOrientation::Mixed;
3459     case CSSValueUpright:
3460         return TextOrientation::Upright;
3461     default:
3462         break;
3463     }
3464 
3465     ASSERT_NOT_REACHED();
3466     return TextOrientation::Mixed;
3467 }
3468 
3469 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PointerEvents e)
3470     : CSSValue(PrimitiveClass)
3471 {
<span class="line-modified">3472     m_primitiveUnitType = CSS_VALUE_ID;</span>
3473     switch (e) {
3474     case PointerEvents::None:
3475         m_value.valueID = CSSValueNone;
3476         break;
3477     case PointerEvents::Stroke:
3478         m_value.valueID = CSSValueStroke;
3479         break;
3480     case PointerEvents::Fill:
3481         m_value.valueID = CSSValueFill;
3482         break;
3483     case PointerEvents::Painted:
3484         m_value.valueID = CSSValuePainted;
3485         break;
3486     case PointerEvents::Visible:
3487         m_value.valueID = CSSValueVisible;
3488         break;
3489     case PointerEvents::VisibleStroke:
3490         m_value.valueID = CSSValueVisibleStroke;
3491         break;
3492     case PointerEvents::VisibleFill:
3493         m_value.valueID = CSSValueVisibleFill;
3494         break;
3495     case PointerEvents::VisiblePainted:
3496         m_value.valueID = CSSValueVisiblePainted;
3497         break;



3498     case PointerEvents::Auto:
3499         m_value.valueID = CSSValueAuto;
3500         break;
3501     case PointerEvents::All:
3502         m_value.valueID = CSSValueAll;
3503         break;
3504     }
3505 }
3506 
3507 template&lt;&gt; inline CSSPrimitiveValue::operator PointerEvents() const
3508 {
3509     ASSERT(isValueID());
3510 
3511     switch (m_value.valueID) {
3512     case CSSValueAll:
3513         return PointerEvents::All;
3514     case CSSValueAuto:
3515         return PointerEvents::Auto;
3516     case CSSValueNone:
3517         return PointerEvents::None;
3518     case CSSValueVisiblePainted:
3519         return PointerEvents::VisiblePainted;
3520     case CSSValueVisibleFill:
3521         return PointerEvents::VisibleFill;
3522     case CSSValueVisibleStroke:
3523         return PointerEvents::VisibleStroke;
3524     case CSSValueVisible:
3525         return PointerEvents::Visible;
3526     case CSSValuePainted:
3527         return PointerEvents::Painted;
3528     case CSSValueFill:
3529         return PointerEvents::Fill;
3530     case CSSValueStroke:
3531         return PointerEvents::Stroke;


3532     default:
3533         break;
3534     }
3535 
3536     ASSERT_NOT_REACHED();
3537     return PointerEvents::All;
3538 }
3539 
3540 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Kerning kerning)
3541     : CSSValue(PrimitiveClass)
3542 {
<span class="line-modified">3543     m_primitiveUnitType = CSS_VALUE_ID;</span>
3544     switch (kerning) {
3545     case Kerning::Auto:
3546         m_value.valueID = CSSValueAuto;
3547         return;
3548     case Kerning::Normal:
3549         m_value.valueID = CSSValueNormal;
3550         return;
3551     case Kerning::NoShift:
3552         m_value.valueID = CSSValueNone;
3553         return;
3554     }
3555 
3556     ASSERT_NOT_REACHED();
3557     m_value.valueID = CSSValueAuto;
3558 }
3559 
3560 template&lt;&gt; inline CSSPrimitiveValue::operator Kerning() const
3561 {
3562     ASSERT(isValueID());
3563 
3564     switch (m_value.valueID) {
3565     case CSSValueAuto:
3566         return Kerning::Auto;
3567     case CSSValueNormal:
3568         return Kerning::Normal;
3569     case CSSValueNone:
3570         return Kerning::NoShift;
3571     default:
3572         break;
3573     }
3574 
3575     ASSERT_NOT_REACHED();
3576     return Kerning::Auto;
3577 }
3578 
3579 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ObjectFit fit)
3580     : CSSValue(PrimitiveClass)
3581 {
<span class="line-modified">3582     m_primitiveUnitType = CSS_VALUE_ID;</span>
3583     switch (fit) {
3584     case ObjectFit::Fill:
3585         m_value.valueID = CSSValueFill;
3586         break;
3587     case ObjectFit::Contain:
3588         m_value.valueID = CSSValueContain;
3589         break;
3590     case ObjectFit::Cover:
3591         m_value.valueID = CSSValueCover;
3592         break;
3593     case ObjectFit::None:
3594         m_value.valueID = CSSValueNone;
3595         break;
3596     case ObjectFit::ScaleDown:
3597         m_value.valueID = CSSValueScaleDown;
3598         break;
3599     }
3600 }
3601 
3602 template&lt;&gt; inline CSSPrimitiveValue::operator ObjectFit() const
</pre>
<hr />
<pre>
3606     switch (m_value.valueID) {
3607     case CSSValueFill:
3608         return ObjectFit::Fill;
3609     case CSSValueContain:
3610         return ObjectFit::Contain;
3611     case CSSValueCover:
3612         return ObjectFit::Cover;
3613     case CSSValueNone:
3614         return ObjectFit::None;
3615     case CSSValueScaleDown:
3616         return ObjectFit::ScaleDown;
3617     default:
3618         ASSERT_NOT_REACHED();
3619         return ObjectFit::Fill;
3620     }
3621 }
3622 
3623 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmoothingMode smoothing)
3624     : CSSValue(PrimitiveClass)
3625 {
<span class="line-modified">3626     m_primitiveUnitType = CSS_VALUE_ID;</span>
3627     switch (smoothing) {
3628     case FontSmoothingMode::AutoSmoothing:
3629         m_value.valueID = CSSValueAuto;
3630         return;
3631     case FontSmoothingMode::NoSmoothing:
3632         m_value.valueID = CSSValueNone;
3633         return;
3634     case FontSmoothingMode::Antialiased:
3635         m_value.valueID = CSSValueAntialiased;
3636         return;
3637     case FontSmoothingMode::SubpixelAntialiased:
3638         m_value.valueID = CSSValueSubpixelAntialiased;
3639         return;
3640     }
3641 
3642     ASSERT_NOT_REACHED();
3643     m_value.valueID = CSSValueAuto;
3644 }
3645 
3646 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmoothingMode() const
</pre>
<hr />
<pre>
3650     switch (m_value.valueID) {
3651     case CSSValueAuto:
3652         return FontSmoothingMode::AutoSmoothing;
3653     case CSSValueNone:
3654         return FontSmoothingMode::NoSmoothing;
3655     case CSSValueAntialiased:
3656         return FontSmoothingMode::Antialiased;
3657     case CSSValueSubpixelAntialiased:
3658         return FontSmoothingMode::SubpixelAntialiased;
3659     default:
3660         break;
3661     }
3662 
3663     ASSERT_NOT_REACHED();
3664     return FontSmoothingMode::AutoSmoothing;
3665 }
3666 
3667 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmallCaps smallCaps)
3668     : CSSValue(PrimitiveClass)
3669 {
<span class="line-modified">3670     m_primitiveUnitType = CSS_VALUE_ID;</span>
3671     switch (smallCaps) {
3672     case FontSmallCaps::Off:
3673         m_value.valueID = CSSValueNormal;
3674         return;
3675     case FontSmallCaps::On:
3676         m_value.valueID = CSSValueSmallCaps;
3677         return;
3678     }
3679 
3680     ASSERT_NOT_REACHED();
3681     m_value.valueID = CSSValueNormal;
3682 }
3683 
3684 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmallCaps() const
3685 {
3686     ASSERT(isValueID());
3687 
3688     switch (m_value.valueID) {
3689     case CSSValueSmallCaps:
3690         return FontSmallCaps::On;
3691     case CSSValueNormal:
3692         return FontSmallCaps::Off;
3693     default:
3694         break;
3695     }
3696     ASSERT_NOT_REACHED();
3697     return FontSmallCaps::Off;
3698 }
3699 
3700 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextRenderingMode e)
3701     : CSSValue(PrimitiveClass)
3702 {
<span class="line-modified">3703     m_primitiveUnitType = CSS_VALUE_ID;</span>
3704     switch (e) {
3705     case TextRenderingMode::AutoTextRendering:
3706         m_value.valueID = CSSValueAuto;
3707         break;
3708     case TextRenderingMode::OptimizeSpeed:
3709         m_value.valueID = CSSValueOptimizeSpeed;
3710         break;
3711     case TextRenderingMode::OptimizeLegibility:
3712         m_value.valueID = CSSValueOptimizeLegibility;
3713         break;
3714     case TextRenderingMode::GeometricPrecision:
3715         m_value.valueID = CSSValueGeometricPrecision;
3716         break;
3717     }
3718 }
3719 
3720 template&lt;&gt; inline CSSPrimitiveValue::operator TextRenderingMode() const
3721 {
3722     ASSERT(isValueID());
3723 
3724     switch (m_value.valueID) {
3725     case CSSValueAuto:
3726         return TextRenderingMode::AutoTextRendering;
3727     case CSSValueOptimizeSpeed:
3728         return TextRenderingMode::OptimizeSpeed;
3729     case CSSValueOptimizeLegibility:
3730         return TextRenderingMode::OptimizeLegibility;
3731     case CSSValueGeometricPrecision:
3732         return TextRenderingMode::GeometricPrecision;
3733     default:
3734         break;
3735     }
3736 
3737     ASSERT_NOT_REACHED();
3738     return TextRenderingMode::AutoTextRendering;
3739 }
3740 
3741 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Hyphens hyphens)
3742     : CSSValue(PrimitiveClass)
3743 {
<span class="line-modified">3744     m_primitiveUnitType = CSS_VALUE_ID;</span>
3745     switch (hyphens) {
3746     case Hyphens::None:
3747         m_value.valueID = CSSValueNone;
3748         break;
3749     case Hyphens::Manual:
3750         m_value.valueID = CSSValueManual;
3751         break;
3752     case Hyphens::Auto:
3753         m_value.valueID = CSSValueAuto;
3754         break;
3755     }
3756 }
3757 
3758 template&lt;&gt; inline CSSPrimitiveValue::operator Hyphens() const
3759 {
3760     ASSERT(isValueID());
3761 
3762     switch (m_value.valueID) {
3763     case CSSValueNone:
3764         return Hyphens::None;
3765     case CSSValueManual:
3766         return Hyphens::Manual;
3767     case CSSValueAuto:
3768         return Hyphens::Auto;
3769     default:
3770         break;
3771     }
3772 
3773     ASSERT_NOT_REACHED();
3774     return Hyphens::Auto;
3775 }
3776 
3777 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineSnap gridSnap)
3778     : CSSValue(PrimitiveClass)
3779 {
<span class="line-modified">3780     m_primitiveUnitType = CSS_VALUE_ID;</span>
3781     switch (gridSnap) {
3782     case LineSnap::None:
3783         m_value.valueID = CSSValueNone;
3784         break;
3785     case LineSnap::Baseline:
3786         m_value.valueID = CSSValueBaseline;
3787         break;
3788     case LineSnap::Contain:
3789         m_value.valueID = CSSValueContain;
3790         break;
3791     }
3792 }
3793 
3794 template&lt;&gt; inline CSSPrimitiveValue::operator LineSnap() const
3795 {
3796     ASSERT(isValueID());
3797 
3798     switch (m_value.valueID) {
3799     case CSSValueNone:
3800         return LineSnap::None;
3801     case CSSValueBaseline:
3802         return LineSnap::Baseline;
3803     case CSSValueContain:
3804         return LineSnap::Contain;
3805     default:
3806         break;
3807     }
3808 
3809     ASSERT_NOT_REACHED();
3810     return LineSnap::None;
3811 }
3812 
3813 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineAlign lineAlign)
3814     : CSSValue(PrimitiveClass)
3815 {
<span class="line-modified">3816     m_primitiveUnitType = CSS_VALUE_ID;</span>
3817     switch (lineAlign) {
3818     case LineAlign::None:
3819         m_value.valueID = CSSValueNone;
3820         break;
3821     case LineAlign::Edges:
3822         m_value.valueID = CSSValueEdges;
3823         break;
3824     }
3825 }
3826 
3827 template&lt;&gt; inline CSSPrimitiveValue::operator LineAlign() const
3828 {
3829     ASSERT(isValueID());
3830 
3831     switch (m_value.valueID) {
3832     case CSSValueNone:
3833         return LineAlign::None;
3834     case CSSValueEdges:
3835         return LineAlign::Edges;
3836     default:
3837         break;
3838     }
3839 
3840     ASSERT_NOT_REACHED();
3841     return LineAlign::None;
3842 }
3843 
3844 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(SpeakAs e)
3845     : CSSValue(PrimitiveClass)
3846 {
<span class="line-modified">3847     m_primitiveUnitType = CSS_VALUE_ID;</span>
3848     switch (e) {
3849     case SpeakAs::Normal:
3850         m_value.valueID = CSSValueNormal;
3851         break;
3852     case SpeakAs::SpellOut:
3853         m_value.valueID = CSSValueSpellOut;
3854         break;
3855     case SpeakAs::Digits:
3856         m_value.valueID = CSSValueDigits;
3857         break;
3858     case SpeakAs::LiteralPunctuation:
3859         m_value.valueID = CSSValueLiteralPunctuation;
3860         break;
3861     case SpeakAs::NoPunctuation:
3862         m_value.valueID = CSSValueNoPunctuation;
3863         break;
3864     }
3865 }
3866 
3867 template&lt;&gt; inline CSSPrimitiveValue::operator Order() const
3868 {
3869     ASSERT(isValueID());
3870 
3871     switch (m_value.valueID) {
3872     case CSSValueLogical:
3873         return Order::Logical;
3874     case CSSValueVisual:
3875         return Order::Visual;
3876     default:
3877         break;
3878     }
3879 
3880     ASSERT_NOT_REACHED();
3881     return Order::Logical;
3882 }
3883 
3884 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Order e)
3885     : CSSValue(PrimitiveClass)
3886 {
<span class="line-modified">3887     m_primitiveUnitType = CSS_VALUE_ID;</span>
3888     switch (e) {
3889     case Order::Logical:
3890         m_value.valueID = CSSValueLogical;
3891         break;
3892     case Order::Visual:
3893         m_value.valueID = CSSValueVisual;
3894         break;
3895     }
3896 }
3897 
3898 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;SpeakAs&gt;() const
3899 {
3900     ASSERT(isValueID());
3901 
3902     switch (m_value.valueID) {
3903     case CSSValueNormal:
3904         return OptionSet&lt;SpeakAs&gt; { };
3905     case CSSValueSpellOut:
3906         return SpeakAs::SpellOut;
3907     case CSSValueDigits:
3908         return SpeakAs::Digits;
3909     case CSSValueLiteralPunctuation:
3910         return SpeakAs::LiteralPunctuation;
3911     case CSSValueNoPunctuation:
3912         return SpeakAs::NoPunctuation;
3913     default:
3914         break;
3915     }
3916 
3917     ASSERT_NOT_REACHED();
3918     return OptionSet&lt;SpeakAs&gt; { };
3919 }
3920 
3921 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BlendMode blendMode)
3922     : CSSValue(PrimitiveClass)
3923 {
<span class="line-modified">3924     m_primitiveUnitType = CSS_VALUE_ID;</span>
3925     switch (blendMode) {
3926     case BlendMode::Normal:
3927         m_value.valueID = CSSValueNormal;
3928         break;
3929     case BlendMode::Multiply:
3930         m_value.valueID = CSSValueMultiply;
3931         break;
3932     case BlendMode::Screen:
3933         m_value.valueID = CSSValueScreen;
3934         break;
3935     case BlendMode::Overlay:
3936         m_value.valueID = CSSValueOverlay;
3937         break;
3938     case BlendMode::Darken:
3939         m_value.valueID = CSSValueDarken;
3940         break;
3941     case BlendMode::Lighten:
3942         m_value.valueID = CSSValueLighten;
3943         break;
3944     case BlendMode::ColorDodge:
</pre>
<hr />
<pre>
4015         return BlendMode::Saturation;
4016     case CSSValueColor:
4017         return BlendMode::Color;
4018     case CSSValueLuminosity:
4019         return BlendMode::Luminosity;
4020     case CSSValuePlusDarker:
4021         return BlendMode::PlusDarker;
4022     case CSSValuePlusLighter:
4023         return BlendMode::PlusLighter;
4024     default:
4025         break;
4026     }
4027 
4028     ASSERT_NOT_REACHED();
4029     return BlendMode::Normal;
4030 }
4031 
4032 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Isolation isolation)
4033     : CSSValue(PrimitiveClass)
4034 {
<span class="line-modified">4035     m_primitiveUnitType = CSS_VALUE_ID;</span>
4036     switch (isolation) {
4037     case Isolation::Auto:
4038         m_value.valueID = CSSValueAuto;
4039         break;
4040     case Isolation::Isolate:
4041         m_value.valueID = CSSValueIsolate;
4042         break;
4043     default:
4044         ASSERT_NOT_REACHED();
4045     }
4046 }
4047 
4048 template&lt;&gt; inline CSSPrimitiveValue::operator Isolation() const
4049 {
4050     ASSERT(isValueID());
4051     switch (m_value.valueID) {
4052     case CSSValueAuto:
4053         return Isolation::Auto;
4054     case CSSValueIsolate:
4055         return Isolation::Isolate;
4056     default:
4057         break;
4058     }
4059 
4060     ASSERT_NOT_REACHED();
4061     return Isolation::Auto;
4062 }
4063 
4064 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineCap e)
4065     : CSSValue(PrimitiveClass)
4066 {
<span class="line-modified">4067     m_primitiveUnitType = CSS_VALUE_ID;</span>
4068     switch (e) {
4069     case ButtCap:
4070         m_value.valueID = CSSValueButt;
4071         break;
4072     case RoundCap:
4073         m_value.valueID = CSSValueRound;
4074         break;
4075     case SquareCap:
4076         m_value.valueID = CSSValueSquare;
4077         break;
4078     }
4079 }
4080 
4081 template&lt;&gt; inline CSSPrimitiveValue::operator LineCap() const
4082 {
4083     ASSERT(isValueID());
4084 
4085     switch (m_value.valueID) {
4086     case CSSValueButt:
4087         return ButtCap;
4088     case CSSValueRound:
4089         return RoundCap;
4090     case CSSValueSquare:
4091         return SquareCap;
4092     default:
4093         break;
4094     }
4095 
4096     ASSERT_NOT_REACHED();
4097     return ButtCap;
4098 }
4099 
4100 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineJoin e)
4101     : CSSValue(PrimitiveClass)
4102 {
<span class="line-modified">4103     m_primitiveUnitType = CSS_VALUE_ID;</span>
4104     switch (e) {
4105     case MiterJoin:
4106         m_value.valueID = CSSValueMiter;
4107         break;
4108     case RoundJoin:
4109         m_value.valueID = CSSValueRound;
4110         break;
4111     case BevelJoin:
4112         m_value.valueID = CSSValueBevel;
4113         break;
4114     }
4115 }
4116 
4117 template&lt;&gt; inline CSSPrimitiveValue::operator LineJoin() const
4118 {
4119     ASSERT(isValueID());
4120 
4121     switch (m_value.valueID) {
4122     case CSSValueMiter:
4123         return MiterJoin;
4124     case CSSValueRound:
4125         return RoundJoin;
4126     case CSSValueBevel:
4127         return BevelJoin;
4128     default:
4129         break;
4130     }
4131 
4132     ASSERT_NOT_REACHED();
4133     return MiterJoin;
4134 }
4135 
4136 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WindRule e)
4137     : CSSValue(PrimitiveClass)
4138 {
<span class="line-modified">4139     m_primitiveUnitType = CSS_VALUE_ID;</span>
4140     switch (e) {
4141     case WindRule::NonZero:
4142         m_value.valueID = CSSValueNonzero;
4143         break;
4144     case WindRule::EvenOdd:
4145         m_value.valueID = CSSValueEvenodd;
4146         break;
4147     }
4148 }
4149 
4150 template&lt;&gt; inline CSSPrimitiveValue::operator WindRule() const
4151 {
4152     ASSERT(isValueID());
4153 
4154     switch (m_value.valueID) {
4155     case CSSValueNonzero:
4156         return WindRule::NonZero;
4157     case CSSValueEvenodd:
4158         return WindRule::EvenOdd;
4159     default:
4160         break;
4161     }
4162 
4163     ASSERT_NOT_REACHED();
4164     return WindRule::NonZero;
4165 }
4166 
4167 
4168 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignmentBaseline e)
4169     : CSSValue(PrimitiveClass)
4170 {
<span class="line-modified">4171     m_primitiveUnitType = CSS_VALUE_ID;</span>
4172     switch (e) {
4173     case AlignmentBaseline::Auto:
4174         m_value.valueID = CSSValueAuto;
4175         break;
4176     case AlignmentBaseline::Baseline:
4177         m_value.valueID = CSSValueBaseline;
4178         break;
4179     case AlignmentBaseline::BeforeEdge:
4180         m_value.valueID = CSSValueBeforeEdge;
4181         break;
4182     case AlignmentBaseline::TextBeforeEdge:
4183         m_value.valueID = CSSValueTextBeforeEdge;
4184         break;
4185     case AlignmentBaseline::Middle:
4186         m_value.valueID = CSSValueMiddle;
4187         break;
4188     case AlignmentBaseline::Central:
4189         m_value.valueID = CSSValueCentral;
4190         break;
4191     case AlignmentBaseline::AfterEdge:
</pre>
<hr />
<pre>
4232         return AlignmentBaseline::TextAfterEdge;
4233     case CSSValueIdeographic:
4234         return AlignmentBaseline::Ideographic;
4235     case CSSValueAlphabetic:
4236         return AlignmentBaseline::Alphabetic;
4237     case CSSValueHanging:
4238         return AlignmentBaseline::Hanging;
4239     case CSSValueMathematical:
4240         return AlignmentBaseline::Mathematical;
4241     default:
4242         break;
4243     }
4244 
4245     ASSERT_NOT_REACHED();
4246     return AlignmentBaseline::Auto;
4247 }
4248 
4249 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderCollapse e)
4250     : CSSValue(PrimitiveClass)
4251 {
<span class="line-modified">4252     m_primitiveUnitType = CSS_VALUE_ID;</span>
4253     switch (e) {
4254     case BorderCollapse::Separate:
4255         m_value.valueID = CSSValueSeparate;
4256         break;
4257     case BorderCollapse::Collapse:
4258         m_value.valueID = CSSValueCollapse;
4259         break;
4260     }
4261 }
4262 
4263 template&lt;&gt; inline CSSPrimitiveValue::operator BorderCollapse() const
4264 {
4265     ASSERT(isValueID());
4266 
4267     switch (m_value.valueID) {
4268     case CSSValueSeparate:
4269         return BorderCollapse::Separate;
4270     case CSSValueCollapse:
4271         return BorderCollapse::Collapse;
4272     default:
4273         break;
4274     }
4275 
4276     ASSERT_NOT_REACHED();
4277     return BorderCollapse::Separate;
4278 }
4279 
4280 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderFit e)
4281     : CSSValue(PrimitiveClass)
4282 {
<span class="line-modified">4283     m_primitiveUnitType = CSS_VALUE_ID;</span>
4284     switch (e) {
4285     case BorderFit::Border:
4286         m_value.valueID = CSSValueBorder;
4287         break;
4288     case BorderFit::Lines:
4289         m_value.valueID = CSSValueLines;
4290         break;
4291     }
4292 }
4293 
4294 template&lt;&gt; inline CSSPrimitiveValue::operator BorderFit() const
4295 {
4296     ASSERT(isValueID());
4297 
4298     switch (m_value.valueID) {
4299     case CSSValueBorder:
4300         return BorderFit::Border;
4301     case CSSValueLines:
4302         return BorderFit::Lines;
4303     default:
4304         break;
4305     }
4306 
4307     ASSERT_NOT_REACHED();
4308     return BorderFit::Lines;
4309 }
4310 
4311 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageRendering imageRendering)
4312     : CSSValue(PrimitiveClass)
4313 {
<span class="line-modified">4314     m_primitiveUnitType = CSS_VALUE_ID;</span>
4315     switch (imageRendering) {
4316     case ImageRendering::Auto:
4317         m_value.valueID = CSSValueAuto;
4318         break;
4319     case ImageRendering::CrispEdges:
4320         m_value.valueID = CSSValueCrispEdges;
4321         break;
4322     case ImageRendering::Pixelated:
4323         m_value.valueID = CSSValuePixelated;
4324         break;
4325     case ImageRendering::OptimizeSpeed:
4326         m_value.valueID = CSSValueOptimizeSpeed;
4327         break;
4328     case ImageRendering::OptimizeQuality:
4329         m_value.valueID = CSSValueOptimizeQuality;
4330         break;
4331     }
4332 }
4333 
4334 template&lt;&gt; inline CSSPrimitiveValue::operator ImageRendering() const
</pre>
<hr />
<pre>
4342     case CSSValueCrispEdges:
4343     case CSSValueWebkitCrispEdges:
4344         return ImageRendering::CrispEdges;
4345     case CSSValuePixelated:
4346         return ImageRendering::Pixelated;
4347     case CSSValueOptimizeSpeed:
4348         return ImageRendering::OptimizeSpeed;
4349     case CSSValueOptimizeQuality:
4350         return ImageRendering::OptimizeQuality;
4351     default:
4352         break;
4353     }
4354 
4355     ASSERT_NOT_REACHED();
4356     return ImageRendering::Auto;
4357 }
4358 
4359 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformStyle3D e)
4360     : CSSValue(PrimitiveClass)
4361 {
<span class="line-modified">4362     m_primitiveUnitType = CSS_VALUE_ID;</span>
4363     switch (e) {
4364     case TransformStyle3D::Flat:
4365         m_value.valueID = CSSValueFlat;
4366         break;
4367     case TransformStyle3D::Preserve3D:
4368         m_value.valueID = CSSValuePreserve3d;
4369         break;
4370     }
4371 }
4372 
4373 template&lt;&gt; inline CSSPrimitiveValue::operator TransformStyle3D() const
4374 {
4375     ASSERT(isValueID());
4376 
4377     switch (m_value.valueID) {
4378     case CSSValueFlat:
4379         return TransformStyle3D::Flat;
4380     case CSSValuePreserve3d:
4381         return TransformStyle3D::Preserve3D;
4382     default:
4383         break;
4384     }
4385 
4386     ASSERT_NOT_REACHED();
4387     return TransformStyle3D::Flat;
4388 }
4389 
4390 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformBox box)
4391     : CSSValue(PrimitiveClass)
4392 {
<span class="line-modified">4393     m_primitiveUnitType = CSS_VALUE_ID;</span>
4394     switch (box) {






4395     case TransformBox::BorderBox:
4396         m_value.valueID = CSSValueBorderBox;
4397         break;
4398     case TransformBox::FillBox:
4399         m_value.valueID = CSSValueFillBox;
4400         break;
4401     case TransformBox::ViewBox:
4402         m_value.valueID = CSSValueViewBox;
4403         break;
4404     }
4405 }
4406 
4407 template&lt;&gt; inline CSSPrimitiveValue::operator TransformBox() const
4408 {
4409     ASSERT(isValueID());
4410 
4411     switch (m_value.valueID) {




4412     case CSSValueBorderBox:
4413         return TransformBox::BorderBox;
4414     case CSSValueFillBox:
4415         return TransformBox::FillBox;
4416     case CSSValueViewBox:
4417         return TransformBox::ViewBox;
4418     default:
4419         break;
4420     }
4421 
4422     ASSERT_NOT_REACHED();
4423     return TransformBox::BorderBox;
4424 }
4425 
4426 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnAxis e)
4427     : CSSValue(PrimitiveClass)
4428 {
<span class="line-modified">4429     m_primitiveUnitType = CSS_VALUE_ID;</span>
4430     switch (e) {
4431     case ColumnAxis::Horizontal:
4432         m_value.valueID = CSSValueHorizontal;
4433         break;
4434     case ColumnAxis::Vertical:
4435         m_value.valueID = CSSValueVertical;
4436         break;
4437     case ColumnAxis::Auto:
4438         m_value.valueID = CSSValueAuto;
4439         break;
4440     }
4441 }
4442 
4443 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnAxis() const
4444 {
4445     ASSERT(isValueID());
4446 
4447     switch (m_value.valueID) {
4448     case CSSValueHorizontal:
4449         return ColumnAxis::Horizontal;
4450     case CSSValueVertical:
4451         return ColumnAxis::Vertical;
4452     case CSSValueAuto:
4453         return ColumnAxis::Auto;
4454     default:
4455         break;
4456     }
4457 
4458     ASSERT_NOT_REACHED();
4459     return ColumnAxis::Auto;
4460 }
4461 
4462 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnProgression e)
4463     : CSSValue(PrimitiveClass)
4464 {
<span class="line-modified">4465     m_primitiveUnitType = CSS_VALUE_ID;</span>
4466     switch (e) {
4467     case ColumnProgression::Normal:
4468         m_value.valueID = CSSValueNormal;
4469         break;
4470     case ColumnProgression::Reverse:
4471         m_value.valueID = CSSValueReverse;
4472         break;
4473     }
4474 }
4475 
4476 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnProgression() const
4477 {
4478     ASSERT(isValueID());
4479 
4480     switch (m_value.valueID) {
4481     case CSSValueNormal:
4482         return ColumnProgression::Normal;
4483     case CSSValueReverse:
4484         return ColumnProgression::Reverse;
4485     default:
4486         break;
4487     }
4488 
4489     ASSERT_NOT_REACHED();
4490     return ColumnProgression::Normal;
4491 }
4492 
4493 enum LengthConversion {
4494     AnyConversion = ~0,
4495     FixedIntegerConversion = 1 &lt;&lt; 0,
4496     FixedFloatConversion = 1 &lt;&lt; 1,
4497     AutoConversion = 1 &lt;&lt; 2,
4498     PercentConversion = 1 &lt;&lt; 3,
4499     CalculatedConversion = 1 &lt;&lt; 4
4500 };
4501 
4502 inline bool CSSPrimitiveValue::convertingToLengthRequiresNonNullStyle(int lengthConversion) const
4503 {
4504     ASSERT(isFontRelativeLength());
4505     // This matches the implementation in CSSPrimitiveValue::computeLengthDouble().
<span class="line-modified">4506     switch (m_primitiveUnitType) {</span>
<span class="line-modified">4507     case CSS_EMS:</span>
<span class="line-modified">4508     case CSS_EXS:</span>
<span class="line-modified">4509     case CSS_CHS:</span>
4510         return lengthConversion &amp; (FixedIntegerConversion | FixedFloatConversion);
4511     default:
4512         return false;
4513     }
4514 }
4515 
4516 template&lt;int supported&gt; Length CSSPrimitiveValue::convertToLength(const CSSToLengthConversionData&amp; conversionData) const
4517 {
4518     if (isFontRelativeLength() &amp;&amp; convertingToLengthRequiresNonNullStyle(supported) &amp;&amp; !conversionData.style())
4519         return Length(Undefined);
4520     if ((supported &amp; FixedIntegerConversion) &amp;&amp; isLength())
4521         return computeLength&lt;Length&gt;(conversionData);
4522     if ((supported &amp; FixedFloatConversion) &amp;&amp; isLength())
4523         return Length(computeLength&lt;double&gt;(conversionData), Fixed);
4524     if ((supported &amp; PercentConversion) &amp;&amp; isPercentage())
4525         return Length(doubleValue(), Percent);
4526     if ((supported &amp; AutoConversion) &amp;&amp; valueID() == CSSValueAuto)
4527         return Length(Auto);
4528     if ((supported &amp; CalculatedConversion) &amp;&amp; isCalculated())
4529         return Length(cssCalcValue()-&gt;createCalculationValue(conversionData));
4530     return Length(Undefined);
4531 }
4532 
4533 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BufferedRendering e)
4534     : CSSValue(PrimitiveClass)
4535 {
<span class="line-modified">4536     m_primitiveUnitType = CSS_VALUE_ID;</span>
4537     switch (e) {
4538     case BufferedRendering::Auto:
4539         m_value.valueID = CSSValueAuto;
4540         break;
4541     case BufferedRendering::Dynamic:
4542         m_value.valueID = CSSValueDynamic;
4543         break;
4544     case BufferedRendering::Static:
4545         m_value.valueID = CSSValueStatic;
4546         break;
4547     }
4548 }
4549 
4550 template&lt;&gt; inline CSSPrimitiveValue::operator BufferedRendering() const
4551 {
4552     ASSERT(isValueID());
4553 
4554     switch (m_value.valueID) {
4555     case CSSValueAuto:
4556         return BufferedRendering::Auto;
4557     case CSSValueDynamic:
4558         return BufferedRendering::Dynamic;
4559     case CSSValueStatic:
4560         return BufferedRendering::Static;
4561     default:
4562         break;
4563     }
4564 
4565     ASSERT_NOT_REACHED();
4566     return BufferedRendering::Auto;
4567 }
4568 
4569 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorInterpolation e)
4570     : CSSValue(PrimitiveClass)
4571 {
<span class="line-modified">4572     m_primitiveUnitType = CSS_VALUE_ID;</span>
4573     switch (e) {
4574     case ColorInterpolation::Auto:
4575         m_value.valueID = CSSValueAuto;
4576         break;
4577     case ColorInterpolation::SRGB:
4578         m_value.valueID = CSSValueSRGB;
4579         break;
4580     case ColorInterpolation::LinearRGB:
4581         m_value.valueID = CSSValueLinearRGB;
4582         break;
4583     }
4584 }
4585 
4586 template&lt;&gt; inline CSSPrimitiveValue::operator ColorInterpolation() const
4587 {
4588     ASSERT(isValueID());
4589 
4590     switch (m_value.valueID) {
4591     case CSSValueSRGB:
4592         return ColorInterpolation::SRGB;
4593     case CSSValueLinearRGB:
4594         return ColorInterpolation::LinearRGB;
4595     case CSSValueAuto:
4596         return ColorInterpolation::Auto;
4597     default:
4598         break;
4599     }
4600 
4601     ASSERT_NOT_REACHED();
4602     return ColorInterpolation::Auto;
4603 }
4604 
4605 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorRendering e)
4606     : CSSValue(PrimitiveClass)
4607 {
<span class="line-modified">4608     m_primitiveUnitType = CSS_VALUE_ID;</span>
4609     switch (e) {
4610     case ColorRendering::Auto:
4611         m_value.valueID = CSSValueAuto;
4612         break;
4613     case ColorRendering::OptimizeSpeed:
4614         m_value.valueID = CSSValueOptimizeSpeed;
4615         break;
4616     case ColorRendering::OptimizeQuality:
4617         m_value.valueID = CSSValueOptimizeQuality;
4618         break;
4619     }
4620 }
4621 
4622 template&lt;&gt; inline CSSPrimitiveValue::operator ColorRendering() const
4623 {
4624     ASSERT(isValueID());
4625 
4626     switch (m_value.valueID) {
4627     case CSSValueOptimizeSpeed:
4628         return ColorRendering::OptimizeSpeed;
4629     case CSSValueOptimizeQuality:
4630         return ColorRendering::OptimizeQuality;
4631     case CSSValueAuto:
4632         return ColorRendering::Auto;
4633     default:
4634         break;
4635     }
4636 
4637     ASSERT_NOT_REACHED();
4638     return ColorRendering::Auto;
4639 }
4640 
4641 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DominantBaseline e)
4642     : CSSValue(PrimitiveClass)
4643 {
<span class="line-modified">4644     m_primitiveUnitType = CSS_VALUE_ID;</span>
4645     switch (e) {
4646     case DominantBaseline::Auto:
4647         m_value.valueID = CSSValueAuto;
4648         break;
4649     case DominantBaseline::UseScript:
4650         m_value.valueID = CSSValueUseScript;
4651         break;
4652     case DominantBaseline::NoChange:
4653         m_value.valueID = CSSValueNoChange;
4654         break;
4655     case DominantBaseline::ResetSize:
4656         m_value.valueID = CSSValueResetSize;
4657         break;
4658     case DominantBaseline::Central:
4659         m_value.valueID = CSSValueCentral;
4660         break;
4661     case DominantBaseline::Middle:
4662         m_value.valueID = CSSValueMiddle;
4663         break;
4664     case DominantBaseline::TextBeforeEdge:
</pre>
<hr />
<pre>
4705         return DominantBaseline::Mathematical;
4706     case CSSValueCentral:
4707         return DominantBaseline::Central;
4708     case CSSValueMiddle:
4709         return DominantBaseline::Middle;
4710     case CSSValueTextAfterEdge:
4711         return DominantBaseline::TextAfterEdge;
4712     case CSSValueTextBeforeEdge:
4713         return DominantBaseline::TextBeforeEdge;
4714     default:
4715         break;
4716     }
4717 
4718     ASSERT_NOT_REACHED();
4719     return DominantBaseline::Auto;
4720 }
4721 
4722 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ShapeRendering e)
4723     : CSSValue(PrimitiveClass)
4724 {
<span class="line-modified">4725     m_primitiveUnitType = CSS_VALUE_ID;</span>
4726     switch (e) {
4727     case ShapeRendering::Auto:
4728         m_value.valueID = CSSValueAuto;
4729         break;
4730     case ShapeRendering::OptimizeSpeed:
4731         m_value.valueID = CSSValueOptimizeSpeed;
4732         break;
4733     case ShapeRendering::CrispEdges:
4734         m_value.valueID = CSSValueCrispedges;
4735         break;
4736     case ShapeRendering::GeometricPrecision:
4737         m_value.valueID = CSSValueGeometricPrecision;
4738         break;
4739     }
4740 }
4741 
4742 template&lt;&gt; inline CSSPrimitiveValue::operator ShapeRendering() const
4743 {
4744     ASSERT(isValueID());
4745 
4746     switch (m_value.valueID) {
4747     case CSSValueAuto:
4748         return ShapeRendering::Auto;
4749     case CSSValueOptimizeSpeed:
4750         return ShapeRendering::OptimizeSpeed;
4751     case CSSValueCrispedges:
4752         return ShapeRendering::CrispEdges;
4753     case CSSValueGeometricPrecision:
4754         return ShapeRendering::GeometricPrecision;
4755     default:
4756         break;
4757     }
4758 
4759     ASSERT_NOT_REACHED();
4760     return ShapeRendering::Auto;
4761 }
4762 
4763 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAnchor e)
4764     : CSSValue(PrimitiveClass)
4765 {
<span class="line-modified">4766     m_primitiveUnitType = CSS_VALUE_ID;</span>
4767     switch (e) {
4768     case TextAnchor::Start:
4769         m_value.valueID = CSSValueStart;
4770         break;
4771     case TextAnchor::Middle:
4772         m_value.valueID = CSSValueMiddle;
4773         break;
4774     case TextAnchor::End:
4775         m_value.valueID = CSSValueEnd;
4776         break;
4777     }
4778 }
4779 
4780 template&lt;&gt; inline CSSPrimitiveValue::operator TextAnchor() const
4781 {
4782     ASSERT(isValueID());
4783 
4784     switch (m_value.valueID) {
4785     case CSSValueStart:
4786         return TextAnchor::Start;
4787     case CSSValueMiddle:
4788         return TextAnchor::Middle;
4789     case CSSValueEnd:
4790         return TextAnchor::End;
4791     default:
4792         break;
4793     }
4794 
4795     ASSERT_NOT_REACHED();
4796     return TextAnchor::Start;
4797 }
4798 
4799 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(const Color&amp; color)
4800     : CSSValue(PrimitiveClass)
4801 {
<span class="line-modified">4802     m_primitiveUnitType = CSS_RGBCOLOR;</span>
4803     m_value.color = new Color(color);
4804 }
4805 
4806 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSFontFamily fontFamily)
4807     : CSSValue(PrimitiveClass)
4808 {
<span class="line-modified">4809     m_primitiveUnitType = CSS_FONT_FAMILY;</span>
4810     m_value.fontFamily = new CSSFontFamily(WTFMove(fontFamily));
4811 }
4812 
4813 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VectorEffect e)
4814     : CSSValue(PrimitiveClass)
4815 {
<span class="line-modified">4816     m_primitiveUnitType = CSS_VALUE_ID;</span>
4817     switch (e) {
4818     case VectorEffect::None:
4819         m_value.valueID = CSSValueNone;
4820         break;
4821     case VectorEffect::NonScalingStroke:
4822         m_value.valueID = CSSValueNonScalingStroke;
4823         break;
4824     }
4825 }
4826 
4827 template&lt;&gt; inline CSSPrimitiveValue::operator VectorEffect() const
4828 {
4829     ASSERT(isValueID());
4830 
4831     switch (m_value.valueID) {
4832     case CSSValueNone:
4833         return VectorEffect::None;
4834     case CSSValueNonScalingStroke:
4835         return VectorEffect::NonScalingStroke;
4836     default:
4837         break;
4838     }
4839 
4840     ASSERT_NOT_REACHED();
4841     return VectorEffect::None;
4842 }
4843 
4844 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MaskType e)
4845     : CSSValue(PrimitiveClass)
4846 {
<span class="line-modified">4847     m_primitiveUnitType = CSS_VALUE_ID;</span>
4848     switch (e) {
4849     case MaskType::Luminance:
4850         m_value.valueID = CSSValueLuminance;
4851         break;
4852     case MaskType::Alpha:
4853         m_value.valueID = CSSValueAlpha;
4854         break;
4855     }
4856 }
4857 
4858 template&lt;&gt; inline CSSPrimitiveValue::operator MaskType() const
4859 {
4860     ASSERT(isValueID());
4861 
4862     switch (m_value.valueID) {
4863     case CSSValueLuminance:
4864         return MaskType::Luminance;
4865     case CSSValueAlpha:
4866         return MaskType::Alpha;
4867     default:
4868         break;
4869     }
4870 
4871     ASSERT_NOT_REACHED();
4872     return MaskType::Luminance;
4873 }
4874 
<span class="line-removed">4875 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">4876 </span>
<span class="line-removed">4877 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageOrientation e)</span>
<span class="line-removed">4878     : CSSValue(PrimitiveClass)</span>
<span class="line-removed">4879 {</span>
<span class="line-removed">4880     m_primitiveUnitType = CSS_DEG;</span>
<span class="line-removed">4881     switch (e) {</span>
<span class="line-removed">4882     case ImageOrientation::OriginTopLeft:</span>
<span class="line-removed">4883         m_value.num = 0;</span>
<span class="line-removed">4884         break;</span>
<span class="line-removed">4885     case ImageOrientation::OriginRightTop:</span>
<span class="line-removed">4886         m_value.num = 90;</span>
<span class="line-removed">4887         break;</span>
<span class="line-removed">4888     case ImageOrientation::OriginBottomRight:</span>
<span class="line-removed">4889         m_value.num = 180;</span>
<span class="line-removed">4890         break;</span>
<span class="line-removed">4891     case ImageOrientation::OriginLeftBottom:</span>
<span class="line-removed">4892         m_value.num = 270;</span>
<span class="line-removed">4893         break;</span>
<span class="line-removed">4894     case ImageOrientation::FromImage:</span>
<span class="line-removed">4895     case ImageOrientation::OriginTopRight:</span>
<span class="line-removed">4896     case ImageOrientation::OriginLeftTop:</span>
<span class="line-removed">4897     case ImageOrientation::OriginBottomLeft:</span>
<span class="line-removed">4898     case ImageOrientation::OriginRightBottom:</span>
<span class="line-removed">4899         ASSERT_NOT_REACHED();</span>
<span class="line-removed">4900     }</span>
<span class="line-removed">4901 }</span>
<span class="line-removed">4902 </span>
<span class="line-removed">4903 template&lt;&gt; inline CSSPrimitiveValue::operator ImageOrientation() const</span>
<span class="line-removed">4904 {</span>
<span class="line-removed">4905     ASSERT(isAngle());</span>
<span class="line-removed">4906     double quarters = 4 * doubleValue(CSS_TURN);</span>
<span class="line-removed">4907     int orientation = 3 &amp; static_cast&lt;int&gt;(quarters &lt; 0 ? floor(quarters) : ceil(quarters));</span>
<span class="line-removed">4908     switch (orientation) {</span>
<span class="line-removed">4909     case 0:</span>
<span class="line-removed">4910         return ImageOrientation::OriginTopLeft;</span>
<span class="line-removed">4911     case 1:</span>
<span class="line-removed">4912         return ImageOrientation::OriginRightTop;</span>
<span class="line-removed">4913     case 2:</span>
<span class="line-removed">4914         return ImageOrientation::OriginBottomRight;</span>
<span class="line-removed">4915     case 3:</span>
<span class="line-removed">4916         return ImageOrientation::OriginLeftBottom;</span>
<span class="line-removed">4917     }</span>
<span class="line-removed">4918 </span>
<span class="line-removed">4919     ASSERT_NOT_REACHED();</span>
<span class="line-removed">4920     return ImageOrientation::None;</span>
<span class="line-removed">4921 }</span>
<span class="line-removed">4922 </span>
<span class="line-removed">4923 #endif // ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">4924 </span>
4925 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
4926     : CSSValue(PrimitiveClass)
4927 {
<span class="line-modified">4928     m_primitiveUnitType = CSS_VALUE_ID;</span>
4929     switch (cssBox) {
4930     case CSSBoxType::MarginBox:
4931         m_value.valueID = CSSValueMarginBox;
4932         break;
4933     case CSSBoxType::BorderBox:
4934         m_value.valueID = CSSValueBorderBox;
4935         break;
4936     case CSSBoxType::PaddingBox:
4937         m_value.valueID = CSSValuePaddingBox;
4938         break;
4939     case CSSBoxType::ContentBox:
4940         m_value.valueID = CSSValueContentBox;
4941         break;
4942     case CSSBoxType::FillBox:
4943         m_value.valueID = CSSValueFillBox;
4944         break;
4945     case CSSBoxType::StrokeBox:
4946         m_value.valueID = CSSValueStrokeBox;
4947         break;
4948     case CSSBoxType::ViewBox:
</pre>
<hr />
<pre>
4966         return CSSBoxType::PaddingBox;
4967     case CSSValueContentBox:
4968         return CSSBoxType::ContentBox;
4969     // The following are used in an SVG context.
4970     case CSSValueFillBox:
4971         return CSSBoxType::FillBox;
4972     case CSSValueStrokeBox:
4973         return CSSBoxType::StrokeBox;
4974     case CSSValueViewBox:
4975         return CSSBoxType::ViewBox;
4976     default:
4977         break;
4978     }
4979     ASSERT_NOT_REACHED();
4980     return CSSBoxType::BoxMissing;
4981 }
4982 
4983 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ItemPosition itemPosition)
4984     : CSSValue(PrimitiveClass)
4985 {
<span class="line-modified">4986     m_primitiveUnitType = CSS_VALUE_ID;</span>
4987     switch (itemPosition) {
4988     case ItemPosition::Legacy:
4989         m_value.valueID = CSSValueLegacy;
4990         break;
4991     case ItemPosition::Auto:
4992         m_value.valueID = CSSValueAuto;
4993         break;
4994     case ItemPosition::Normal:
4995         m_value.valueID = CSSValueNormal;
4996         break;
4997     case ItemPosition::Stretch:
4998         m_value.valueID = CSSValueStretch;
4999         break;
5000     case ItemPosition::Baseline:
5001         m_value.valueID = CSSValueBaseline;
5002         break;
5003     case ItemPosition::LastBaseline:
5004         m_value.valueID = CSSValueLastBaseline;
5005         break;
5006     case ItemPosition::Center:
</pre>
<hr />
<pre>
5061     case CSSValueSelfEnd:
5062         return ItemPosition::SelfEnd;
5063     case CSSValueFlexStart:
5064         return ItemPosition::FlexStart;
5065     case CSSValueFlexEnd:
5066         return ItemPosition::FlexEnd;
5067     case CSSValueLeft:
5068         return ItemPosition::Left;
5069     case CSSValueRight:
5070         return ItemPosition::Right;
5071     default:
5072         break;
5073     }
5074     ASSERT_NOT_REACHED();
5075     return ItemPosition::Auto;
5076 }
5077 
5078 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowAlignment overflowAlignment)
5079     : CSSValue(PrimitiveClass)
5080 {
<span class="line-modified">5081     m_primitiveUnitType = CSS_VALUE_ID;</span>
5082     switch (overflowAlignment) {
5083     case OverflowAlignment::Default:
5084         m_value.valueID = CSSValueDefault;
5085         break;
5086     case OverflowAlignment::Unsafe:
5087         m_value.valueID = CSSValueUnsafe;
5088         break;
5089     case OverflowAlignment::Safe:
5090         m_value.valueID = CSSValueSafe;
5091         break;
5092     }
5093 }
5094 
5095 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowAlignment() const
5096 {
5097     switch (m_value.valueID) {
5098     case CSSValueUnsafe:
5099         return OverflowAlignment::Unsafe;
5100     case CSSValueSafe:
5101         return OverflowAlignment::Safe;
5102     default:
5103         break;
5104     }
5105     ASSERT_NOT_REACHED();
5106     return OverflowAlignment::Unsafe;
5107 }
5108 
5109 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentPosition contentPosition)
5110     : CSSValue(PrimitiveClass)
5111 {
<span class="line-modified">5112     m_primitiveUnitType = CSS_VALUE_ID;</span>
5113     switch (contentPosition) {
5114     case ContentPosition::Normal:
5115         m_value.valueID = CSSValueNormal;
5116         break;
5117     case ContentPosition::Baseline:
5118         m_value.valueID = CSSValueBaseline;
5119         break;
5120     case ContentPosition::LastBaseline:
5121         m_value.valueID = CSSValueLastBaseline;
5122         break;
5123     case ContentPosition::Center:
5124         m_value.valueID = CSSValueCenter;
5125         break;
5126     case ContentPosition::Start:
5127         m_value.valueID = CSSValueStart;
5128         break;
5129     case ContentPosition::End:
5130         m_value.valueID = CSSValueEnd;
5131         break;
5132     case ContentPosition::FlexStart:
</pre>
<hr />
<pre>
5162     case CSSValueEnd:
5163         return ContentPosition::End;
5164     case CSSValueFlexStart:
5165         return ContentPosition::FlexStart;
5166     case CSSValueFlexEnd:
5167         return ContentPosition::FlexEnd;
5168     case CSSValueLeft:
5169         return ContentPosition::Left;
5170     case CSSValueRight:
5171         return ContentPosition::Right;
5172     default:
5173         break;
5174     }
5175     ASSERT_NOT_REACHED();
5176     return ContentPosition::Normal;
5177 }
5178 
5179 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentDistribution contentDistribution)
5180     : CSSValue(PrimitiveClass)
5181 {
<span class="line-modified">5182     m_primitiveUnitType = CSS_VALUE_ID;</span>
5183     switch (contentDistribution) {
5184     case ContentDistribution::Default:
5185         m_value.valueID = CSSValueDefault;
5186         break;
5187     case ContentDistribution::SpaceBetween:
5188         m_value.valueID = CSSValueSpaceBetween;
5189         break;
5190     case ContentDistribution::SpaceAround:
5191         m_value.valueID = CSSValueSpaceAround;
5192         break;
5193     case ContentDistribution::SpaceEvenly:
5194         m_value.valueID = CSSValueSpaceEvenly;
5195         break;
5196     case ContentDistribution::Stretch:
5197         m_value.valueID = CSSValueStretch;
5198         break;
5199     }
5200 }
5201 
5202 template&lt;&gt; inline CSSPrimitiveValue::operator ContentDistribution() const
</pre>
<hr />
<pre>
5220 template&lt;&gt; inline CSSPrimitiveValue::operator TextZoom() const
5221 {
5222     ASSERT(isValueID());
5223 
5224     switch (m_value.valueID) {
5225     case CSSValueNormal:
5226         return TextZoom::Normal;
5227     case CSSValueReset:
5228         return TextZoom::Reset;
5229     default:
5230         break;
5231     }
5232 
5233     ASSERT_NOT_REACHED();
5234     return TextZoom::Normal;
5235 }
5236 
5237 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextZoom textZoom)
5238     : CSSValue(PrimitiveClass)
5239 {
<span class="line-modified">5240     m_primitiveUnitType = CSS_VALUE_ID;</span>
5241     switch (textZoom) {
5242     case TextZoom::Normal:
5243         m_value.valueID = CSSValueNormal;
5244         return;
5245     case TextZoom::Reset:
5246         m_value.valueID = CSSValueReset;
5247         return;
5248     }
5249 
5250     ASSERT_NOT_REACHED();
5251     m_value.valueID = CSSValueNormal;
5252 }
5253 
5254 #if ENABLE(POINTER_EVENTS)
5255 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TouchAction touchAction)
5256     : CSSValue(PrimitiveClass)
5257 {
<span class="line-modified">5258     m_primitiveUnitType = CSS_VALUE_ID;</span>
5259     switch (touchAction) {
5260     case TouchAction::Auto:
5261         m_value.valueID = CSSValueAuto;
5262         break;
5263     case TouchAction::Manipulation:
5264         m_value.valueID = CSSValueManipulation;
5265         break;
5266     case TouchAction::None:
5267         m_value.valueID = CSSValueNone;
5268         break;
5269     case TouchAction::PanX:
5270         m_value.valueID = CSSValuePanX;
5271         break;
5272     case TouchAction::PanY:
5273         m_value.valueID = CSSValuePanY;
5274         break;
5275     case TouchAction::PinchZoom:
5276         m_value.valueID = CSSValuePinchZoom;
5277         break;
5278     }
</pre>
<hr />
<pre>
5290         return TouchAction::None;
5291     case CSSValuePanX:
5292         return TouchAction::PanX;
5293     case CSSValuePanY:
5294         return TouchAction::PanY;
5295     case CSSValuePinchZoom:
5296         return TouchAction::PinchZoom;
5297     default:
5298         break;
5299     }
5300     ASSERT_NOT_REACHED();
5301     return TouchAction::Auto;
5302 }
5303 #endif
5304 
5305 #if ENABLE(CSS_SCROLL_SNAP)
5306 
5307 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapStrictness strictness)
5308     : CSSValue(PrimitiveClass)
5309 {
<span class="line-modified">5310     m_primitiveUnitType = CSS_VALUE_ID;</span>
5311     switch (strictness) {
5312     case ScrollSnapStrictness::None:
5313         m_value.valueID = CSSValueNone;
5314         break;
5315     case ScrollSnapStrictness::Proximity:
5316         m_value.valueID = CSSValueProximity;
5317         break;
5318     case ScrollSnapStrictness::Mandatory:
5319         m_value.valueID = CSSValueMandatory;
5320         break;
5321     }
5322 }
5323 
5324 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapStrictness() const
5325 {
5326     ASSERT(isValueID());
5327     switch (m_value.valueID) {
5328     case CSSValueNone:
5329         return ScrollSnapStrictness::None;
5330     case CSSValueProximity:
5331         return ScrollSnapStrictness::Proximity;
5332     case CSSValueMandatory:
5333         return ScrollSnapStrictness::Mandatory;
5334     default:
5335         ASSERT_NOT_REACHED();
5336         return ScrollSnapStrictness::None;
5337     }
5338 }
5339 
5340 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxis axis)
5341     : CSSValue(PrimitiveClass)
5342 {
<span class="line-modified">5343     m_primitiveUnitType = CSS_VALUE_ID;</span>
5344     switch (axis) {
5345     case ScrollSnapAxis::XAxis:
5346         m_value.valueID = CSSValueX;
5347         break;
5348     case ScrollSnapAxis::YAxis:
5349         m_value.valueID = CSSValueY;
5350         break;
5351     case ScrollSnapAxis::Block:
5352         m_value.valueID = CSSValueBlock;
5353         break;
5354     case ScrollSnapAxis::Inline:
5355         m_value.valueID = CSSValueInline;
5356         break;
5357     case ScrollSnapAxis::Both:
5358         m_value.valueID = CSSValueBoth;
5359         break;
5360     }
5361 }
5362 
5363 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxis() const
</pre>
<hr />
<pre>
5366     switch (m_value.valueID) {
5367     case CSSValueX:
5368         return ScrollSnapAxis::XAxis;
5369     case CSSValueY:
5370         return ScrollSnapAxis::YAxis;
5371     case CSSValueBlock:
5372         return ScrollSnapAxis::Block;
5373     case CSSValueInline:
5374         return ScrollSnapAxis::Inline;
5375     case CSSValueBoth:
5376         return ScrollSnapAxis::Both;
5377     default:
5378         ASSERT_NOT_REACHED();
5379         return ScrollSnapAxis::Both;
5380     }
5381 }
5382 
5383 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxisAlignType type)
5384     : CSSValue(PrimitiveClass)
5385 {
<span class="line-modified">5386     m_primitiveUnitType = CSS_VALUE_ID;</span>
5387     switch (type) {
5388     case ScrollSnapAxisAlignType::None:
5389         m_value.valueID = CSSValueNone;
5390         break;
5391     case ScrollSnapAxisAlignType::Start:
5392         m_value.valueID = CSSValueStart;
5393         break;
5394     case ScrollSnapAxisAlignType::Center:
5395         m_value.valueID = CSSValueCenter;
5396         break;
5397     case ScrollSnapAxisAlignType::End:
5398         m_value.valueID = CSSValueEnd;
5399         break;
5400     }
5401 }
5402 
5403 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxisAlignType() const
5404 {
5405     ASSERT(isValueID());
5406     switch (m_value.valueID) {
5407     case CSSValueNone:
5408         return ScrollSnapAxisAlignType::None;
5409     case CSSValueStart:
5410         return ScrollSnapAxisAlignType::Start;
5411     case CSSValueCenter:
5412         return ScrollSnapAxisAlignType::Center;
5413     case CSSValueEnd:
5414         return ScrollSnapAxisAlignType::End;
5415     default:
5416         ASSERT_NOT_REACHED();
5417         return ScrollSnapAxisAlignType::None;
5418     }
5419 }
5420 
5421 #endif
5422 
5423 #if ENABLE(CSS_TRAILING_WORD)
5424 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TrailingWord e)
5425     : CSSValue(PrimitiveClass)
5426 {
<span class="line-modified">5427     m_primitiveUnitType = CSS_VALUE_ID;</span>
5428     switch (e) {
5429     case TrailingWord::Auto:
5430         m_value.valueID = CSSValueAuto;
5431         break;
5432     case TrailingWord::PartiallyBalanced:
5433         m_value.valueID = CSSValueWebkitPartiallyBalanced;
5434         break;
5435     default:
5436         ASSERT_NOT_REACHED();
5437         break;
5438     }
5439 }
5440 
5441 template&lt;&gt; inline CSSPrimitiveValue::operator TrailingWord() const
5442 {
5443     ASSERT(isValueID());
5444     switch (m_value.valueID) {
5445     case CSSValueAuto:
5446         return TrailingWord::Auto;
5447     case CSSValueWebkitPartiallyBalanced:
5448         return TrailingWord::PartiallyBalanced;
5449     default:
5450         break;
5451     }
5452     ASSERT_NOT_REACHED();
5453     return TrailingWord::Auto;
5454 }
5455 #endif
5456 
5457 #if ENABLE(APPLE_PAY)
5458 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonStyle e)
5459     : CSSValue(PrimitiveClass)
5460 {
<span class="line-modified">5461     m_primitiveUnitType = CSS_VALUE_ID;</span>
5462     switch (e) {
5463     case ApplePayButtonStyle::White:
5464         m_value.valueID = CSSValueWhite;
5465         break;
5466     case ApplePayButtonStyle::WhiteOutline:
5467         m_value.valueID = CSSValueWhiteOutline;
5468         break;
5469     case ApplePayButtonStyle::Black:
5470         m_value.valueID = CSSValueBlack;
5471         break;
5472     default:
5473         ASSERT_NOT_REACHED();
5474         break;
5475     }
5476 }
5477 
5478 template&lt;&gt; inline CSSPrimitiveValue::operator ApplePayButtonStyle() const
5479 {
5480     ASSERT(isValueID());
5481     switch (m_value.valueID) {
5482     case CSSValueWhite:
5483         return ApplePayButtonStyle::White;
5484     case CSSValueWhiteOutline:
5485         return ApplePayButtonStyle::WhiteOutline;
5486     case CSSValueBlack:
5487         return ApplePayButtonStyle::Black;
5488     default:
5489         break;
5490     }
5491     ASSERT_NOT_REACHED();
5492     return ApplePayButtonStyle::Black;
5493 }
5494 
5495 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonType e)
5496     : CSSValue(PrimitiveClass)
5497 {
<span class="line-modified">5498     m_primitiveUnitType = CSS_VALUE_ID;</span>
5499     switch (e) {
5500     case ApplePayButtonType::Plain:
5501         m_value.valueID = CSSValuePlain;
5502         break;
5503     case ApplePayButtonType::Buy:
5504         m_value.valueID = CSSValueBuy;
5505         break;
5506     case ApplePayButtonType::SetUp:
5507         m_value.valueID = CSSValueSetUp;
5508         break;
5509     case ApplePayButtonType::Donate:
5510         m_value.valueID = CSSValueDonate;
5511         break;
5512 #if ENABLE(APPLE_PAY_SESSION_V4)
5513     case ApplePayButtonType::CheckOut:
5514         m_value.valueID = CSSValueCheckOut;
5515         break;
5516     case ApplePayButtonType::Book:
5517         m_value.valueID = CSSValueBook;
5518         break;
</pre>
<hr />
<pre>
5541         return ApplePayButtonType::Donate;
5542 #if ENABLE(APPLE_PAY_SESSION_V4)
5543     case CSSValueCheckOut:
5544         return ApplePayButtonType::CheckOut;
5545     case CSSValueBook:
5546         return ApplePayButtonType::Book;
5547     case CSSValueSubscribe:
5548         return ApplePayButtonType::Subscribe;
5549 #endif
5550     default:
5551         break;
5552     }
5553     ASSERT_NOT_REACHED();
5554     return ApplePayButtonType::Plain;
5555 }
5556 #endif
5557 
5558 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantPosition position)
5559     : CSSValue(PrimitiveClass)
5560 {
<span class="line-modified">5561     m_primitiveUnitType = CSS_VALUE_ID;</span>
5562     switch (position) {
5563     case FontVariantPosition::Normal:
5564         m_value.valueID = CSSValueNormal;
5565         break;
5566     case FontVariantPosition::Subscript:
5567         m_value.valueID = CSSValueSub;
5568         break;
5569     case FontVariantPosition::Superscript:
5570         m_value.valueID = CSSValueSuper;
5571         break;
5572     default:
5573         ASSERT_NOT_REACHED();
5574         break;
5575     }
5576 }
5577 
5578 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantPosition() const
5579 {
5580     ASSERT(isValueID());
5581     switch (m_value.valueID) {
5582     case CSSValueNormal:
5583         return FontVariantPosition::Normal;
5584     case CSSValueSub:
5585         return FontVariantPosition::Subscript;
5586     case CSSValueSuper:
5587         return FontVariantPosition::Superscript;
5588     default:
5589         break;
5590     }
5591     ASSERT_NOT_REACHED();
5592     return FontVariantPosition::Normal;
5593 }
5594 
5595 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantCaps caps)
5596     : CSSValue(PrimitiveClass)
5597 {
<span class="line-modified">5598     m_primitiveUnitType = CSS_VALUE_ID;</span>
5599     switch (caps) {
5600     case FontVariantCaps::Normal:
5601         m_value.valueID = CSSValueNormal;
5602         break;
5603     case FontVariantCaps::Small:
5604         m_value.valueID = CSSValueSmallCaps;
5605         break;
5606     case FontVariantCaps::AllSmall:
5607         m_value.valueID = CSSValueAllSmallCaps;
5608         break;
5609     case FontVariantCaps::Petite:
5610         m_value.valueID = CSSValuePetiteCaps;
5611         break;
5612     case FontVariantCaps::AllPetite:
5613         m_value.valueID = CSSValueAllPetiteCaps;
5614         break;
5615     case FontVariantCaps::Unicase:
5616         m_value.valueID = CSSValueUnicase;
5617         break;
5618     case FontVariantCaps::Titling:
</pre>
<hr />
<pre>
5635     case CSSValueAllSmallCaps:
5636         return FontVariantCaps::AllSmall;
5637     case CSSValuePetiteCaps:
5638         return FontVariantCaps::Petite;
5639     case CSSValueAllPetiteCaps:
5640         return FontVariantCaps::AllPetite;
5641     case CSSValueUnicase:
5642         return FontVariantCaps::Unicase;
5643     case CSSValueTitlingCaps:
5644         return FontVariantCaps::Titling;
5645     default:
5646         break;
5647     }
5648     ASSERT_NOT_REACHED();
5649     return FontVariantCaps::Normal;
5650 }
5651 
5652 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantAlternates alternates)
5653     : CSSValue(PrimitiveClass)
5654 {
<span class="line-modified">5655     m_primitiveUnitType = CSS_VALUE_ID;</span>
5656     switch (alternates) {
5657     case FontVariantAlternates::Normal:
5658         m_value.valueID = CSSValueNormal;
5659         break;
5660     case FontVariantAlternates::HistoricalForms:
5661         m_value.valueID = CSSValueHistoricalForms;
5662         break;
5663     default:
5664         ASSERT_NOT_REACHED();
5665         break;
5666     }
5667 }
5668 
5669 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantAlternates() const
5670 {
5671     ASSERT(isValueID());
5672     switch (m_value.valueID) {
5673     case CSSValueNormal:
5674         return FontVariantAlternates::Normal;
5675     case CSSValueHistoricalForms:
5676         return FontVariantAlternates::HistoricalForms;
5677     default:
5678         break;
5679     }
5680     ASSERT_NOT_REACHED();
5681     return FontVariantAlternates::Normal;
5682 }
5683 
5684 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontOpticalSizing sizing)
5685     : CSSValue(PrimitiveClass)
5686 {
<span class="line-modified">5687     m_primitiveUnitType = CSS_VALUE_ID;</span>
5688     switch (sizing) {
5689     case FontOpticalSizing::Enabled:
5690         m_value.valueID = CSSValueAuto;
5691         break;
5692     case FontOpticalSizing::Disabled:
5693         m_value.valueID = CSSValueNone;
5694         break;
5695     default:
5696         ASSERT_NOT_REACHED();
5697         break;
5698     }
5699 }
5700 
5701 template&lt;&gt; inline CSSPrimitiveValue::operator FontOpticalSizing() const
5702 {
5703     ASSERT(isValueID());
5704     switch (m_value.valueID) {
5705     case CSSValueAuto:
5706         return FontOpticalSizing::Enabled;
5707     case CSSValueNone:
5708         return FontOpticalSizing::Disabled;
5709     default:
5710         break;
5711     }
5712     ASSERT_NOT_REACHED();
5713     return FontOpticalSizing::Enabled;
5714 }
5715 
5716 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontLoadingBehavior behavior)
5717     : CSSValue(PrimitiveClass)
5718 {
<span class="line-modified">5719     m_primitiveUnitType = CSS_VALUE_ID;</span>
5720     switch (behavior) {
5721     case FontLoadingBehavior::Auto:
5722         m_value.valueID = CSSValueAuto;
5723         break;
5724     case FontLoadingBehavior::Block:
5725         m_value.valueID = CSSValueBlock;
5726         break;
5727     case FontLoadingBehavior::Swap:
5728         m_value.valueID = CSSValueSwap;
5729         break;
5730     case FontLoadingBehavior::Fallback:
5731         m_value.valueID = CSSValueFallback;
5732         break;
5733     case FontLoadingBehavior::Optional:
5734         m_value.valueID = CSSValueOptional;
5735         break;
5736     default:
5737         ASSERT_NOT_REACHED();
5738         break;
5739     }
</pre>
</td>
<td>
<hr />
<pre>
  15  *    notice, this list of conditions and the following disclaimer in the
  16  *    documentation and/or other materials provided with the distribution.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR
  19  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  20  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  21  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
  22  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  23  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  24  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  25  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #pragma once
  31 
  32 #include &quot;CSSCalculationValue.h&quot;
  33 #include &quot;CSSFontFamily.h&quot;
  34 #include &quot;CSSPrimitiveValue.h&quot;

  35 #include &quot;CSSToLengthConversionData.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;GraphicsTypes.h&quot;
  38 #include &quot;Length.h&quot;
  39 #include &quot;LineClampValue.h&quot;
  40 #include &quot;RenderStyleConstants.h&quot;
  41 #include &quot;SVGRenderStyleDefs.h&quot;
  42 #include &quot;TextFlags.h&quot;
  43 #include &quot;ThemeTypes.h&quot;
  44 #include &quot;TouchAction.h&quot;
  45 #include &quot;UnicodeBidi.h&quot;
  46 #include &quot;WritingMode.h&quot;
  47 #include &lt;wtf/MathExtras.h&gt;
  48 #include &lt;wtf/OptionSet.h&gt;
  49 




  50 namespace WebCore {
  51 
  52 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(short i)
  53     : CSSValue(PrimitiveClass)
  54 {
<span class="line-modified">  55     setPrimitiveUnitType(CSSUnitType::CSS_NUMBER);</span>
  56     m_value.num = static_cast&lt;double&gt;(i);
  57 }
  58 
  59 template&lt;&gt; inline CSSPrimitiveValue::operator short() const
  60 {
<span class="line-modified">  61     if (primitiveUnitType() == CSSUnitType::CSS_NUMBER)</span>
  62         return clampTo&lt;short&gt;(m_value.num);
  63 
  64     ASSERT_NOT_REACHED();
  65     return 0;
  66 }
  67 
  68 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(unsigned short i)
  69     : CSSValue(PrimitiveClass)
  70 {
<span class="line-modified">  71     setPrimitiveUnitType(CSSUnitType::CSS_NUMBER);</span>
  72     m_value.num = static_cast&lt;double&gt;(i);
  73 }
  74 
  75 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned short() const
  76 {
<span class="line-modified">  77     if (primitiveType() == CSSUnitType::CSS_NUMBER)</span>
  78         return value&lt;unsigned short&gt;();
  79 
  80     ASSERT_NOT_REACHED();
  81     return 0;
  82 }
  83 
  84 template&lt;&gt; inline CSSPrimitiveValue::operator int() const
  85 {
<span class="line-modified">  86     if (primitiveType() == CSSUnitType::CSS_NUMBER)</span>
  87         return value&lt;int&gt;();
  88 
  89     ASSERT_NOT_REACHED();
  90     return 0;
  91 }
  92 
  93 template&lt;&gt; inline CSSPrimitiveValue::operator unsigned() const
  94 {
<span class="line-modified">  95     if (primitiveType() == CSSUnitType::CSS_NUMBER)</span>
  96         return value&lt;unsigned&gt;();
  97 
  98     ASSERT_NOT_REACHED();
  99     return 0;
 100 }
 101 
 102 
 103 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(float i)
 104     : CSSValue(PrimitiveClass)
 105 {
<span class="line-modified"> 106     setPrimitiveUnitType(CSSUnitType::CSS_NUMBER);</span>
 107     m_value.num = static_cast&lt;double&gt;(i);
 108 }
 109 
 110 template&lt;&gt; inline CSSPrimitiveValue::operator float() const
 111 {
<span class="line-modified"> 112     if (primitiveType() == CSSUnitType::CSS_NUMBER)</span>
 113         return value&lt;float&gt;();
 114 
 115     ASSERT_NOT_REACHED();
 116     return 0.0f;
 117 }
 118 
 119 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineClampValue i)
 120     : CSSValue(PrimitiveClass)
 121 {
<span class="line-modified"> 122     setPrimitiveUnitType(i.isPercentage() ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);</span>
 123     m_value.num = static_cast&lt;double&gt;(i.value());
 124 }
 125 
 126 template&lt;&gt; inline CSSPrimitiveValue::operator LineClampValue() const
 127 {
<span class="line-modified"> 128     if (primitiveType() == CSSUnitType::CSS_NUMBER)</span>
 129         return LineClampValue(value&lt;int&gt;(), LineClamp::LineCount);
 130 
<span class="line-modified"> 131     if (primitiveType() == CSSUnitType::CSS_PERCENTAGE)</span>
 132         return LineClampValue(value&lt;int&gt;(), LineClamp::Percentage);
 133 
 134     ASSERT_NOT_REACHED();
 135     return LineClampValue();
 136 }
 137 
<span class="line-modified"> 138 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ReflectionDirection direction)</span>
 139     : CSSValue(PrimitiveClass)
 140 {
<span class="line-modified"> 141     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
<span class="line-modified"> 142     switch (direction) {</span>
<span class="line-modified"> 143     case ReflectionDirection::Above:</span>
 144         m_value.valueID = CSSValueAbove;
 145         break;
<span class="line-modified"> 146     case ReflectionDirection::Below:</span>
 147         m_value.valueID = CSSValueBelow;
 148         break;
<span class="line-modified"> 149     case ReflectionDirection::Left:</span>
 150         m_value.valueID = CSSValueLeft;
 151         break;
<span class="line-modified"> 152     case ReflectionDirection::Right:</span>
 153         m_value.valueID = CSSValueRight;
 154     }
 155 }
 156 
<span class="line-modified"> 157 template&lt;&gt; inline CSSPrimitiveValue::operator ReflectionDirection() const</span>
 158 {
 159     ASSERT(isValueID());
 160 
 161     switch (m_value.valueID) {
 162     case CSSValueAbove:
<span class="line-modified"> 163         return ReflectionDirection::Above;</span>
 164     case CSSValueBelow:
<span class="line-modified"> 165         return ReflectionDirection::Below;</span>
 166     case CSSValueLeft:
<span class="line-modified"> 167         return ReflectionDirection::Left;</span>
 168     case CSSValueRight:
<span class="line-modified"> 169         return ReflectionDirection::Right;</span>
 170     default:
 171         break;
 172     }
 173 
 174     ASSERT_NOT_REACHED();
<span class="line-modified"> 175     return ReflectionDirection::Below;</span>
 176 }
 177 
 178 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnFill columnFill)
 179     : CSSValue(PrimitiveClass)
 180 {
<span class="line-modified"> 181     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 182     switch (columnFill) {
 183     case ColumnFill::Auto:
 184         m_value.valueID = CSSValueAuto;
 185         break;
 186     case ColumnFill::Balance:
 187         m_value.valueID = CSSValueBalance;
 188         break;
 189     }
 190 }
 191 
 192 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnFill() const
 193 {
<span class="line-modified"> 194     if (primitiveUnitType() == CSSUnitType::CSS_VALUE_ID) {</span>
 195         if (m_value.valueID == CSSValueBalance)
 196             return ColumnFill::Balance;
 197         if (m_value.valueID == CSSValueAuto)
 198             return ColumnFill::Auto;
 199     }
 200     ASSERT_NOT_REACHED();
 201     return ColumnFill::Balance;
 202 }
 203 
 204 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnSpan columnSpan)
 205     : CSSValue(PrimitiveClass)
 206 {
<span class="line-modified"> 207     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 208     switch (columnSpan) {
 209     case ColumnSpan::All:
 210         m_value.valueID = CSSValueAll;
 211         break;
 212     case ColumnSpan::None:
 213         m_value.valueID = CSSValueNone;
 214         break;
 215     }
 216 }
 217 
 218 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnSpan() const
 219 {
 220     // Map 1 to none for compatibility reasons.
<span class="line-modified"> 221     if (primitiveUnitType() == CSSUnitType::CSS_NUMBER &amp;&amp; m_value.num == 1)</span>
 222         return ColumnSpan::None;
 223 
 224     ASSERT(isValueID());
 225 
 226     switch (m_value.valueID) {
 227     case CSSValueAll:
 228         return ColumnSpan::All;
 229     case CSSValueNone:
 230         return ColumnSpan::None;
 231     default:
 232         break;
 233     }
 234 
 235     ASSERT_NOT_REACHED();
 236     return ColumnSpan::None;
 237 }
 238 
 239 
 240 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PrintColorAdjust value)
 241     : CSSValue(PrimitiveClass)
 242 {
<span class="line-modified"> 243     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 244     switch (value) {
 245     case PrintColorAdjust::Exact:
 246         m_value.valueID = CSSValueExact;
 247         break;
 248     case PrintColorAdjust::Economy:
 249         m_value.valueID = CSSValueEconomy;
 250         break;
 251     }
 252 }
 253 
 254 template&lt;&gt; inline CSSPrimitiveValue::operator PrintColorAdjust() const
 255 {
 256     ASSERT(isValueID());
 257 
 258     switch (m_value.valueID) {
 259     case CSSValueEconomy:
 260         return PrintColorAdjust::Economy;
 261     case CSSValueExact:
 262         return PrintColorAdjust::Exact;
 263     default:
 264         break;
 265     }
 266 
 267     ASSERT_NOT_REACHED();
 268     return PrintColorAdjust::Economy;
 269 }
 270 
 271 
 272 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderStyle e)
 273     : CSSValue(PrimitiveClass)
 274 {
<span class="line-modified"> 275     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 276     switch (e) {
 277     case BorderStyle::None:
 278         m_value.valueID = CSSValueNone;
 279         break;
 280     case BorderStyle::Hidden:
 281         m_value.valueID = CSSValueHidden;
 282         break;
 283     case BorderStyle::Inset:
 284         m_value.valueID = CSSValueInset;
 285         break;
 286     case BorderStyle::Groove:
 287         m_value.valueID = CSSValueGroove;
 288         break;
 289     case BorderStyle::Ridge:
 290         m_value.valueID = CSSValueRidge;
 291         break;
 292     case BorderStyle::Outset:
 293         m_value.valueID = CSSValueOutset;
 294         break;
 295     case BorderStyle::Dotted:
</pre>
<hr />
<pre>
 311 {
 312     ASSERT(isValueID());
 313 
 314     if (m_value.valueID == CSSValueAuto) // Valid for CSS outline-style
 315         return BorderStyle::Dotted;
 316     return static_cast&lt;BorderStyle&gt;(m_value.valueID - CSSValueNone);
 317 }
 318 
 319 template&lt;&gt; inline CSSPrimitiveValue::operator OutlineIsAuto() const
 320 {
 321     ASSERT(isValueID());
 322 
 323     if (m_value.valueID == CSSValueAuto)
 324         return OutlineIsAuto::On;
 325     return OutlineIsAuto::Off;
 326 }
 327 
 328 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CompositeOperator e)
 329     : CSSValue(PrimitiveClass)
 330 {
<span class="line-modified"> 331     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 332     switch (e) {
<span class="line-modified"> 333     case CompositeOperator::Clear:</span>
 334         m_value.valueID = CSSValueClear;
 335         break;
<span class="line-modified"> 336     case CompositeOperator::Copy:</span>
 337         m_value.valueID = CSSValueCopy;
 338         break;
<span class="line-modified"> 339     case CompositeOperator::SourceOver:</span>
 340         m_value.valueID = CSSValueSourceOver;
 341         break;
<span class="line-modified"> 342     case CompositeOperator::SourceIn:</span>
 343         m_value.valueID = CSSValueSourceIn;
 344         break;
<span class="line-modified"> 345     case CompositeOperator::SourceOut:</span>
 346         m_value.valueID = CSSValueSourceOut;
 347         break;
<span class="line-modified"> 348     case CompositeOperator::SourceAtop:</span>
 349         m_value.valueID = CSSValueSourceAtop;
 350         break;
<span class="line-modified"> 351     case CompositeOperator::DestinationOver:</span>
 352         m_value.valueID = CSSValueDestinationOver;
 353         break;
<span class="line-modified"> 354     case CompositeOperator::DestinationIn:</span>
 355         m_value.valueID = CSSValueDestinationIn;
 356         break;
<span class="line-modified"> 357     case CompositeOperator::DestinationOut:</span>
 358         m_value.valueID = CSSValueDestinationOut;
 359         break;
<span class="line-modified"> 360     case CompositeOperator::DestinationAtop:</span>
 361         m_value.valueID = CSSValueDestinationAtop;
 362         break;
<span class="line-modified"> 363     case CompositeOperator::XOR:</span>
 364         m_value.valueID = CSSValueXor;
 365         break;
<span class="line-modified"> 366     case CompositeOperator::PlusDarker:</span>
 367         m_value.valueID = CSSValuePlusDarker;
 368         break;
<span class="line-modified"> 369     case CompositeOperator::PlusLighter:</span>
 370         m_value.valueID = CSSValuePlusLighter;
 371         break;
<span class="line-modified"> 372     case CompositeOperator::Difference:</span>
 373         ASSERT_NOT_REACHED();
 374         break;
 375     }
 376 }
 377 
 378 template&lt;&gt; inline CSSPrimitiveValue::operator CompositeOperator() const
 379 {
 380     ASSERT(isValueID());
 381 
 382     switch (m_value.valueID) {
 383     case CSSValueClear:
<span class="line-modified"> 384         return CompositeOperator::Clear;</span>
 385     case CSSValueCopy:
<span class="line-modified"> 386         return CompositeOperator::Copy;</span>
 387     case CSSValueSourceOver:
<span class="line-modified"> 388         return CompositeOperator::SourceOver;</span>
 389     case CSSValueSourceIn:
<span class="line-modified"> 390         return CompositeOperator::SourceIn;</span>
 391     case CSSValueSourceOut:
<span class="line-modified"> 392         return CompositeOperator::SourceOut;</span>
 393     case CSSValueSourceAtop:
<span class="line-modified"> 394         return CompositeOperator::SourceAtop;</span>
 395     case CSSValueDestinationOver:
<span class="line-modified"> 396         return CompositeOperator::DestinationOver;</span>
 397     case CSSValueDestinationIn:
<span class="line-modified"> 398         return CompositeOperator::DestinationIn;</span>
 399     case CSSValueDestinationOut:
<span class="line-modified"> 400         return CompositeOperator::DestinationOut;</span>
 401     case CSSValueDestinationAtop:
<span class="line-modified"> 402         return CompositeOperator::DestinationAtop;</span>
 403     case CSSValueXor:
<span class="line-modified"> 404         return CompositeOperator::XOR;</span>
 405     case CSSValuePlusDarker:
<span class="line-modified"> 406         return CompositeOperator::PlusDarker;</span>
 407     case CSSValuePlusLighter:
<span class="line-modified"> 408         return CompositeOperator::PlusLighter;</span>
 409     default:
 410         break;
 411     }
 412 
 413     ASSERT_NOT_REACHED();
<span class="line-modified"> 414     return CompositeOperator::Clear;</span>
 415 }
 416 
 417 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ControlPart e)
 418     : CSSValue(PrimitiveClass)
 419 {
<span class="line-modified"> 420     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 421     switch (e) {
 422     case NoControlPart:
 423         m_value.valueID = CSSValueNone;
 424         break;
 425     case CheckboxPart:
 426         m_value.valueID = CSSValueCheckbox;
 427         break;
 428     case RadioPart:
 429         m_value.valueID = CSSValueRadio;
 430         break;
 431     case PushButtonPart:
 432         m_value.valueID = CSSValuePushButton;
 433         break;
 434     case SquareButtonPart:
 435         m_value.valueID = CSSValueSquareButton;
 436         break;
 437     case ButtonPart:
 438         m_value.valueID = CSSValueButton;
 439         break;
 440     case ButtonBevelPart:
</pre>
<hr />
<pre>
 625 #if ENABLE(DATALIST_ELEMENT)
 626     case ListButtonPart:
 627         m_value.valueID = CSSValueListButton;
 628         break;
 629 #endif
 630     }
 631 }
 632 
 633 template&lt;&gt; inline CSSPrimitiveValue::operator ControlPart() const
 634 {
 635     ASSERT(isValueID());
 636 
 637     if (m_value.valueID == CSSValueNone)
 638         return NoControlPart;
 639     return ControlPart(m_value.valueID - CSSValueCheckbox + 1);
 640 }
 641 
 642 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BackfaceVisibility e)
 643     : CSSValue(PrimitiveClass)
 644 {
<span class="line-modified"> 645     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 646     switch (e) {
 647     case BackfaceVisibility::Visible:
 648         m_value.valueID = CSSValueVisible;
 649         break;
 650     case BackfaceVisibility::Hidden:
 651         m_value.valueID = CSSValueHidden;
 652         break;
 653     }
 654 }
 655 
 656 template&lt;&gt; inline CSSPrimitiveValue::operator BackfaceVisibility() const
 657 {
 658     ASSERT(isValueID());
 659 
 660     switch (m_value.valueID) {
 661     case CSSValueVisible:
 662         return BackfaceVisibility::Visible;
 663     case CSSValueHidden:
 664         return BackfaceVisibility::Hidden;
 665     default:
 666         break;
 667     }
 668 
 669     ASSERT_NOT_REACHED();
 670     return BackfaceVisibility::Hidden;
 671 }
 672 
 673 
 674 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillAttachment e)
 675     : CSSValue(PrimitiveClass)
 676 {
<span class="line-modified"> 677     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 678     switch (e) {
 679     case FillAttachment::ScrollBackground:
 680         m_value.valueID = CSSValueScroll;
 681         break;
 682     case FillAttachment::LocalBackground:
 683         m_value.valueID = CSSValueLocal;
 684         break;
 685     case FillAttachment::FixedBackground:
 686         m_value.valueID = CSSValueFixed;
 687         break;
 688     }
 689 }
 690 
 691 template&lt;&gt; inline CSSPrimitiveValue::operator FillAttachment() const
 692 {
 693     ASSERT(isValueID());
 694 
 695     switch (m_value.valueID) {
 696     case CSSValueScroll:
 697         return FillAttachment::ScrollBackground;
 698     case CSSValueLocal:
 699         return FillAttachment::LocalBackground;
 700     case CSSValueFixed:
 701         return FillAttachment::FixedBackground;
 702     default:
 703         break;
 704     }
 705 
 706     ASSERT_NOT_REACHED();
 707     return FillAttachment::ScrollBackground;
 708 }
 709 
 710 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillBox e)
 711     : CSSValue(PrimitiveClass)
 712 {
<span class="line-modified"> 713     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 714     switch (e) {
 715     case FillBox::Border:
 716         m_value.valueID = CSSValueBorderBox;
 717         break;
 718     case FillBox::Padding:
 719         m_value.valueID = CSSValuePaddingBox;
 720         break;
 721     case FillBox::Content:
 722         m_value.valueID = CSSValueContentBox;
 723         break;
 724     case FillBox::Text:
 725         m_value.valueID = CSSValueText;
 726         break;
 727     }
 728 }
 729 
 730 template&lt;&gt; inline CSSPrimitiveValue::operator FillBox() const
 731 {
 732     ASSERT(isValueID());
 733 
</pre>
<hr />
<pre>
 738     case CSSValuePadding:
 739     case CSSValuePaddingBox:
 740         return FillBox::Padding;
 741     case CSSValueContent:
 742     case CSSValueContentBox:
 743         return FillBox::Content;
 744     case CSSValueText:
 745     case CSSValueWebkitText:
 746         return FillBox::Text;
 747     default:
 748         break;
 749     }
 750 
 751     ASSERT_NOT_REACHED();
 752     return FillBox::Border;
 753 }
 754 
 755 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FillRepeat e)
 756     : CSSValue(PrimitiveClass)
 757 {
<span class="line-modified"> 758     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 759     switch (e) {
 760     case FillRepeat::Repeat:
 761         m_value.valueID = CSSValueRepeat;
 762         break;
 763     case FillRepeat::NoRepeat:
 764         m_value.valueID = CSSValueNoRepeat;
 765         break;
 766     case FillRepeat::Round:
 767         m_value.valueID = CSSValueRound;
 768         break;
 769     case FillRepeat::Space:
 770         m_value.valueID = CSSValueSpace;
 771         break;
 772     }
 773 }
 774 
 775 template&lt;&gt; inline CSSPrimitiveValue::operator FillRepeat() const
 776 {
 777     ASSERT(isValueID());
 778 
 779     switch (m_value.valueID) {
 780     case CSSValueRepeat:
 781         return FillRepeat::Repeat;
 782     case CSSValueNoRepeat:
 783         return FillRepeat::NoRepeat;
 784     case CSSValueRound:
 785         return FillRepeat::Round;
 786     case CSSValueSpace:
 787         return FillRepeat::Space;
 788     default:
 789         break;
 790     }
 791 
 792     ASSERT_NOT_REACHED();
 793     return FillRepeat::Repeat;
 794 }
 795 
 796 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxPack e)
 797     : CSSValue(PrimitiveClass)
 798 {
<span class="line-modified"> 799     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 800     switch (e) {
 801     case BoxPack::Start:
 802         m_value.valueID = CSSValueStart;
 803         break;
 804     case BoxPack::Center:
 805         m_value.valueID = CSSValueCenter;
 806         break;
 807     case BoxPack::End:
 808         m_value.valueID = CSSValueEnd;
 809         break;
 810     case BoxPack::Justify:
 811         m_value.valueID = CSSValueJustify;
 812         break;
 813     }
 814 }
 815 
 816 template&lt;&gt; inline CSSPrimitiveValue::operator BoxPack() const
 817 {
 818     ASSERT(isValueID());
 819 
 820     switch (m_value.valueID) {
 821     case CSSValueStart:
 822         return BoxPack::Start;
 823     case CSSValueEnd:
 824         return BoxPack::End;
 825     case CSSValueCenter:
 826         return BoxPack::Center;
 827     case CSSValueJustify:
 828         return BoxPack::Justify;
 829     default:
 830         break;
 831     }
 832 
 833     ASSERT_NOT_REACHED();
 834     return BoxPack::Justify;
 835 }
 836 
 837 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxAlignment e)
 838     : CSSValue(PrimitiveClass)
 839 {
<span class="line-modified"> 840     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 841     switch (e) {
 842     case BoxAlignment::Stretch:
 843         m_value.valueID = CSSValueStretch;
 844         break;
 845     case BoxAlignment::Start:
 846         m_value.valueID = CSSValueStart;
 847         break;
 848     case BoxAlignment::Center:
 849         m_value.valueID = CSSValueCenter;
 850         break;
 851     case BoxAlignment::End:
 852         m_value.valueID = CSSValueEnd;
 853         break;
 854     case BoxAlignment::Baseline:
 855         m_value.valueID = CSSValueBaseline;
 856         break;
 857     }
 858 }
 859 
 860 template&lt;&gt; inline CSSPrimitiveValue::operator BoxAlignment() const
</pre>
<hr />
<pre>
 867     case CSSValueStart:
 868         return BoxAlignment::Start;
 869     case CSSValueEnd:
 870         return BoxAlignment::End;
 871     case CSSValueCenter:
 872         return BoxAlignment::Center;
 873     case CSSValueBaseline:
 874         return BoxAlignment::Baseline;
 875     default:
 876         break;
 877     }
 878 
 879     ASSERT_NOT_REACHED();
 880     return BoxAlignment::Stretch;
 881 }
 882 
 883 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 884 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDecorationBreak e)
 885     : CSSValue(PrimitiveClass)
 886 {
<span class="line-modified"> 887     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 888     switch (e) {
 889     case BoxDecorationBreak::Slice:
 890         m_value.valueID = CSSValueSlice;
 891         break;
 892     case BoxDecorationBreak::Clone:
 893         m_value.valueID = CSSValueClone;
 894         break;
 895     }
 896 }
 897 
 898 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDecorationBreak() const
 899 {
 900     ASSERT(isValueID());
 901 
 902     switch (m_value.valueID) {
 903     case CSSValueSlice:
 904         return BoxDecorationBreak::Slice;
 905     case CSSValueClone:
 906         return BoxDecorationBreak::Clone;
 907     default:
 908         break;
 909     }
 910 
 911     ASSERT_NOT_REACHED();
 912     return BoxDecorationBreak::Slice;
 913 }
 914 #endif
 915 
 916 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Edge e)
 917     : CSSValue(PrimitiveClass)
 918 {
<span class="line-modified"> 919     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 920     switch (e) {
 921     case Edge::Top:
 922         m_value.valueID = CSSValueTop;
 923         break;
 924     case Edge::Right:
 925         m_value.valueID = CSSValueRight;
 926         break;
 927     case Edge::Bottom:
 928         m_value.valueID = CSSValueBottom;
 929         break;
 930     case Edge::Left:
 931         m_value.valueID = CSSValueLeft;
 932         break;
 933     }
 934 }
 935 
 936 template&lt;&gt; inline CSSPrimitiveValue::operator Edge() const
 937 {
 938     ASSERT(isValueID());
 939 
 940     switch (m_value.valueID) {
 941     case CSSValueTop:
 942         return Edge::Top;
 943     case CSSValueRight:
 944         return Edge::Right;
 945     case CSSValueBottom:
 946         return Edge::Bottom;
 947     case CSSValueLeft:
 948         return Edge::Left;
 949     default:
 950         break;
 951     }
 952 
 953     ASSERT_NOT_REACHED();
 954     return Edge::Top;
 955 }
 956 
 957 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxSizing e)
 958     : CSSValue(PrimitiveClass)
 959 {
<span class="line-modified"> 960     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 961     switch (e) {
 962     case BoxSizing::BorderBox:
 963         m_value.valueID = CSSValueBorderBox;
 964         break;
 965     case BoxSizing::ContentBox:
 966         m_value.valueID = CSSValueContentBox;
 967         break;
 968     }
 969 }
 970 
 971 template&lt;&gt; inline CSSPrimitiveValue::operator BoxSizing() const
 972 {
 973     ASSERT(isValueID());
 974 
 975     switch (m_value.valueID) {
 976     case CSSValueBorderBox:
 977         return BoxSizing::BorderBox;
 978     case CSSValueContentBox:
 979         return BoxSizing::ContentBox;
 980     default:
 981         break;
 982     }
 983 
 984     ASSERT_NOT_REACHED();
 985     return BoxSizing::BorderBox;
 986 }
 987 
 988 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxDirection e)
 989     : CSSValue(PrimitiveClass)
 990 {
<span class="line-modified"> 991     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
 992     switch (e) {
 993     case BoxDirection::Normal:
 994         m_value.valueID = CSSValueNormal;
 995         break;
 996     case BoxDirection::Reverse:
 997         m_value.valueID = CSSValueReverse;
 998         break;
 999     }
1000 }
1001 
1002 template&lt;&gt; inline CSSPrimitiveValue::operator BoxDirection() const
1003 {
1004     ASSERT(isValueID());
1005 
1006     switch (m_value.valueID) {
1007     case CSSValueNormal:
1008         return BoxDirection::Normal;
1009     case CSSValueReverse:
1010         return BoxDirection::Reverse;
1011     default:
1012         break;
1013     }
1014 
1015     ASSERT_NOT_REACHED();
1016     return BoxDirection::Normal;
1017 }
1018 
1019 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxLines e)
1020     : CSSValue(PrimitiveClass)
1021 {
<span class="line-modified">1022     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1023     switch (e) {
1024     case BoxLines::Single:
1025         m_value.valueID = CSSValueSingle;
1026         break;
1027     case BoxLines::Multiple:
1028         m_value.valueID = CSSValueMultiple;
1029         break;
1030     }
1031 }
1032 
1033 template&lt;&gt; inline CSSPrimitiveValue::operator BoxLines() const
1034 {
1035     ASSERT(isValueID());
1036 
1037     switch (m_value.valueID) {
1038     case CSSValueSingle:
1039         return BoxLines::Single;
1040     case CSSValueMultiple:
1041         return BoxLines::Multiple;
1042     default:
1043         break;
1044     }
1045 
1046     ASSERT_NOT_REACHED();
1047     return BoxLines::Single;
1048 }
1049 
1050 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BoxOrient e)
1051     : CSSValue(PrimitiveClass)
1052 {
<span class="line-modified">1053     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1054     switch (e) {
1055     case BoxOrient::Horizontal:
1056         m_value.valueID = CSSValueHorizontal;
1057         break;
1058     case BoxOrient::Vertical:
1059         m_value.valueID = CSSValueVertical;
1060         break;
1061     }
1062 }
1063 
1064 template&lt;&gt; inline CSSPrimitiveValue::operator BoxOrient() const
1065 {
1066     ASSERT(isValueID());
1067 
1068     switch (m_value.valueID) {
1069     case CSSValueHorizontal:
1070     case CSSValueInlineAxis:
1071         return BoxOrient::Horizontal;
1072     case CSSValueVertical:
1073     case CSSValueBlockAxis:
1074         return BoxOrient::Vertical;
1075     default:
1076         break;
1077     }
1078 
1079     ASSERT_NOT_REACHED();
1080     return BoxOrient::Horizontal;
1081 }
1082 
1083 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CaptionSide e)
1084     : CSSValue(PrimitiveClass)
1085 {
<span class="line-modified">1086     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1087     switch (e) {
1088     case CaptionSide::Left:
1089         m_value.valueID = CSSValueLeft;
1090         break;
1091     case CaptionSide::Right:
1092         m_value.valueID = CSSValueRight;
1093         break;
1094     case CaptionSide::Top:
1095         m_value.valueID = CSSValueTop;
1096         break;
1097     case CaptionSide::Bottom:
1098         m_value.valueID = CSSValueBottom;
1099         break;
1100     }
1101 }
1102 
1103 template&lt;&gt; inline CSSPrimitiveValue::operator CaptionSide() const
1104 {
1105     ASSERT(isValueID());
1106 
1107     switch (m_value.valueID) {
1108     case CSSValueLeft:
1109         return CaptionSide::Left;
1110     case CSSValueRight:
1111         return CaptionSide::Right;
1112     case CSSValueTop:
1113         return CaptionSide::Top;
1114     case CSSValueBottom:
1115         return CaptionSide::Bottom;
1116     default:
1117         break;
1118     }
1119 
1120     ASSERT_NOT_REACHED();
1121     return CaptionSide::Top;
1122 }
1123 
1124 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Clear e)
1125     : CSSValue(PrimitiveClass)
1126 {
<span class="line-modified">1127     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1128     switch (e) {
1129     case Clear::None:
1130         m_value.valueID = CSSValueNone;
1131         break;
1132     case Clear::Left:
1133         m_value.valueID = CSSValueLeft;
1134         break;
1135     case Clear::Right:
1136         m_value.valueID = CSSValueRight;
1137         break;
1138     case Clear::Both:
1139         m_value.valueID = CSSValueBoth;
1140         break;
1141     }
1142 }
1143 
1144 template&lt;&gt; inline CSSPrimitiveValue::operator Clear() const
1145 {
1146     ASSERT(isValueID());
1147 
1148     switch (m_value.valueID) {
1149     case CSSValueNone:
1150         return Clear::None;
1151     case CSSValueLeft:
1152         return Clear::Left;
1153     case CSSValueRight:
1154         return Clear::Right;
1155     case CSSValueBoth:
1156         return Clear::Both;
1157     default:
1158         break;
1159     }
1160 
1161     ASSERT_NOT_REACHED();
1162     return Clear::None;
1163 }
1164 
1165 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorType e)
1166     : CSSValue(PrimitiveClass)
1167 {
<span class="line-modified">1168     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1169     switch (e) {
1170     case CursorType::Auto:
1171         m_value.valueID = CSSValueAuto;
1172         break;
1173     case CursorType::Default:
1174         m_value.valueID = CSSValueDefault;
1175         break;
1176     case CursorType::None:
1177         m_value.valueID = CSSValueNone;
1178         break;
1179     case CursorType::ContextMenu:
1180         m_value.valueID = CSSValueContextMenu;
1181         break;
1182     case CursorType::Help:
1183         m_value.valueID = CSSValueHelp;
1184         break;
1185     case CursorType::Pointer:
1186         m_value.valueID = CSSValuePointer;
1187         break;
1188     case CursorType::Progress:
</pre>
<hr />
<pre>
1286         return CursorType::Copy;
1287     case CSSValueWebkitGrab:
1288         return CursorType::Grab;
1289     case CSSValueWebkitGrabbing:
1290         return CursorType::Grabbing;
1291     case CSSValueWebkitZoomIn:
1292         return CursorType::ZoomIn;
1293     case CSSValueWebkitZoomOut:
1294         return CursorType::ZoomOut;
1295     case CSSValueNone:
1296         return CursorType::None;
1297     default:
1298         return static_cast&lt;CursorType&gt;(m_value.valueID - CSSValueAuto);
1299     }
1300 }
1301 
1302 #if ENABLE(CURSOR_VISIBILITY)
1303 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CursorVisibility e)
1304     : CSSValue(PrimitiveClass)
1305 {
<span class="line-modified">1306     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1307     switch (e) {
1308     case CursorVisibility::Auto:
1309         m_value.valueID = CSSValueAuto;
1310         break;
1311     case CursorVisibility::AutoHide:
1312         m_value.valueID = CSSValueAutoHide;
1313         break;
1314     }
1315 }
1316 
1317 template&lt;&gt; inline CSSPrimitiveValue::operator CursorVisibility() const
1318 {
1319     ASSERT(isValueID());
1320 
1321     if (m_value.valueID == CSSValueAuto)
1322         return CursorVisibility::Auto;
1323     if (m_value.valueID == CSSValueAutoHide)
1324         return CursorVisibility::AutoHide;
1325 
1326     ASSERT_NOT_REACHED();
1327     return CursorVisibility::Auto;
1328 }
1329 #endif
1330 
1331 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DisplayType e)
1332     : CSSValue(PrimitiveClass)
1333 {
<span class="line-modified">1334     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1335     switch (e) {
1336     case DisplayType::Inline:
1337         m_value.valueID = CSSValueInline;
1338         break;
1339     case DisplayType::Block:
1340         m_value.valueID = CSSValueBlock;
1341         break;
1342     case DisplayType::ListItem:
1343         m_value.valueID = CSSValueListItem;
1344         break;



1345     case DisplayType::InlineBlock:
1346         m_value.valueID = CSSValueInlineBlock;
1347         break;
1348     case DisplayType::Table:
1349         m_value.valueID = CSSValueTable;
1350         break;
1351     case DisplayType::InlineTable:
1352         m_value.valueID = CSSValueInlineTable;
1353         break;
1354     case DisplayType::TableRowGroup:
1355         m_value.valueID = CSSValueTableRowGroup;
1356         break;
1357     case DisplayType::TableHeaderGroup:
1358         m_value.valueID = CSSValueTableHeaderGroup;
1359         break;
1360     case DisplayType::TableFooterGroup:
1361         m_value.valueID = CSSValueTableFooterGroup;
1362         break;
1363     case DisplayType::TableRow:
1364         m_value.valueID = CSSValueTableRow;
</pre>
<hr />
<pre>
1409 
1410 template&lt;&gt; inline CSSPrimitiveValue::operator DisplayType() const
1411 {
1412     ASSERT(isValueID());
1413 
1414     if (m_value.valueID == CSSValueNone)
1415         return DisplayType::None;
1416 
1417     DisplayType display = static_cast&lt;DisplayType&gt;(m_value.valueID - CSSValueInline);
1418     ASSERT(display &gt;= DisplayType::Inline &amp;&amp; display &lt;= DisplayType::None);
1419     if (display == DisplayType::WebKitFlex)
1420         return DisplayType::Flex;
1421     if (display == DisplayType::WebKitInlineFlex)
1422         return DisplayType::InlineFlex;
1423     return display;
1424 }
1425 
1426 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EmptyCell e)
1427     : CSSValue(PrimitiveClass)
1428 {
<span class="line-modified">1429     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1430     switch (e) {
1431     case EmptyCell::Show:
1432         m_value.valueID = CSSValueShow;
1433         break;
1434     case EmptyCell::Hide:
1435         m_value.valueID = CSSValueHide;
1436         break;
1437     }
1438 }
1439 
1440 template&lt;&gt; inline CSSPrimitiveValue::operator EmptyCell() const
1441 {
1442     ASSERT(isValueID());
1443 
1444     switch (m_value.valueID) {
1445     case CSSValueShow:
1446         return EmptyCell::Show;
1447     case CSSValueHide:
1448         return EmptyCell::Hide;
1449     default:
1450         break;
1451     }
1452 
1453     ASSERT_NOT_REACHED();
1454     return EmptyCell::Show;
1455 }
1456 
1457 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexDirection e)
1458     : CSSValue(PrimitiveClass)
1459 {
<span class="line-modified">1460     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1461     switch (e) {
1462     case FlexDirection::Row:
1463         m_value.valueID = CSSValueRow;
1464         break;
1465     case FlexDirection::RowReverse:
1466         m_value.valueID = CSSValueRowReverse;
1467         break;
1468     case FlexDirection::Column:
1469         m_value.valueID = CSSValueColumn;
1470         break;
1471     case FlexDirection::ColumnReverse:
1472         m_value.valueID = CSSValueColumnReverse;
1473         break;
1474     }
1475 }
1476 
1477 template&lt;&gt; inline CSSPrimitiveValue::operator FlexDirection() const
1478 {
1479     ASSERT(isValueID());
1480 
1481     switch (m_value.valueID) {
1482     case CSSValueRow:
1483         return FlexDirection::Row;
1484     case CSSValueRowReverse:
1485         return FlexDirection::RowReverse;
1486     case CSSValueColumn:
1487         return FlexDirection::Column;
1488     case CSSValueColumnReverse:
1489         return FlexDirection::ColumnReverse;
1490     default:
1491         break;
1492     }
1493 
1494     ASSERT_NOT_REACHED();
1495     return FlexDirection::Row;
1496 }
1497 
1498 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignContent e)
1499     : CSSValue(PrimitiveClass)
1500 {
<span class="line-modified">1501     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1502     switch (e) {
1503     case AlignContent::FlexStart:
1504         m_value.valueID = CSSValueFlexStart;
1505         break;
1506     case AlignContent::FlexEnd:
1507         m_value.valueID = CSSValueFlexEnd;
1508         break;
1509     case AlignContent::Center:
1510         m_value.valueID = CSSValueCenter;
1511         break;
1512     case AlignContent::SpaceBetween:
1513         m_value.valueID = CSSValueSpaceBetween;
1514         break;
1515     case AlignContent::SpaceAround:
1516         m_value.valueID = CSSValueSpaceAround;
1517         break;
1518     case AlignContent::Stretch:
1519         m_value.valueID = CSSValueStretch;
1520         break;
1521     }
</pre>
<hr />
<pre>
1532         return AlignContent::FlexEnd;
1533     case CSSValueCenter:
1534         return AlignContent::Center;
1535     case CSSValueSpaceBetween:
1536         return AlignContent::SpaceBetween;
1537     case CSSValueSpaceAround:
1538         return AlignContent::SpaceAround;
1539     case CSSValueStretch:
1540         return AlignContent::Stretch;
1541     default:
1542         break;
1543     }
1544 
1545     ASSERT_NOT_REACHED();
1546     return AlignContent::Stretch;
1547 }
1548 
1549 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FlexWrap e)
1550     : CSSValue(PrimitiveClass)
1551 {
<span class="line-modified">1552     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1553     switch (e) {
1554     case FlexWrap::NoWrap:
1555         m_value.valueID = CSSValueNowrap;
1556         break;
1557     case FlexWrap::Wrap:
1558         m_value.valueID = CSSValueWrap;
1559         break;
1560     case FlexWrap::Reverse:
1561         m_value.valueID = CSSValueWrapReverse;
1562         break;
1563     }
1564 }
1565 
1566 template&lt;&gt; inline CSSPrimitiveValue::operator FlexWrap() const
1567 {
1568     ASSERT(isValueID());
1569 
1570     switch (m_value.valueID) {
1571     case CSSValueNowrap:
1572         return FlexWrap::NoWrap;
1573     case CSSValueWrap:
1574         return FlexWrap::Wrap;
1575     case CSSValueWrapReverse:
1576         return FlexWrap::Reverse;
1577     default:
1578         break;
1579     }
1580 
1581     ASSERT_NOT_REACHED();
1582     return FlexWrap::NoWrap;
1583 }
1584 
1585 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Float e)
1586     : CSSValue(PrimitiveClass)
1587 {
<span class="line-modified">1588     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1589     switch (e) {
1590     case Float::No:
1591         m_value.valueID = CSSValueNone;
1592         break;
1593     case Float::Left:
1594         m_value.valueID = CSSValueLeft;
1595         break;
1596     case Float::Right:
1597         m_value.valueID = CSSValueRight;
1598         break;
1599     }
1600 }
1601 
1602 template&lt;&gt; inline CSSPrimitiveValue::operator Float() const
1603 {
1604     ASSERT(isValueID());
1605 
1606     switch (m_value.valueID) {
1607     case CSSValueLeft:
1608         return Float::Left;
1609     case CSSValueRight:
1610         return Float::Right;
1611     case CSSValueNone:
1612     case CSSValueCenter: // Non-standard CSS value.
1613         return Float::No;
1614     default:
1615         break;
1616     }
1617 
1618     ASSERT_NOT_REACHED();
1619     return Float::No;
1620 }
1621 
1622 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineBreak e)
1623     : CSSValue(PrimitiveClass)
1624 {
<span class="line-modified">1625     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1626     switch (e) {
1627     case LineBreak::Auto:
1628         m_value.valueID = CSSValueAuto;
1629         break;
1630     case LineBreak::Loose:
1631         m_value.valueID = CSSValueLoose;
1632         break;
1633     case LineBreak::Normal:
1634         m_value.valueID = CSSValueNormal;
1635         break;
1636     case LineBreak::Strict:
1637         m_value.valueID = CSSValueStrict;
1638         break;
1639     case LineBreak::AfterWhiteSpace:
1640         m_value.valueID = CSSValueAfterWhiteSpace;
1641         break;
1642     case LineBreak::Anywhere:
1643         m_value.valueID = CSSValueAnywhere;
1644         break;
1645     }
</pre>
<hr />
<pre>
1679         return LineBreak::Loose;
1680     case CSSValueNormal:
1681         return LineBreak::Normal;
1682     case CSSValueStrict:
1683         return LineBreak::Strict;
1684     case CSSValueAfterWhiteSpace:
1685         return LineBreak::AfterWhiteSpace;
1686     case CSSValueAnywhere:
1687         return LineBreak::Anywhere;
1688     default:
1689         break;
1690     }
1691 
1692     ASSERT_NOT_REACHED();
1693     return LineBreak::Auto;
1694 }
1695 
1696 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStylePosition e)
1697     : CSSValue(PrimitiveClass)
1698 {
<span class="line-modified">1699     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1700     switch (e) {
1701     case ListStylePosition::Outside:
1702         m_value.valueID = CSSValueOutside;
1703         break;
1704     case ListStylePosition::Inside:
1705         m_value.valueID = CSSValueInside;
1706         break;
1707     }
1708 }
1709 
1710 template&lt;&gt; inline CSSPrimitiveValue::operator ListStylePosition() const
1711 {
1712     ASSERT(isValueID());
1713 
1714     switch (m_value.valueID) {
1715     case CSSValueOutside:
1716         return ListStylePosition::Outside;
1717     case CSSValueInside:
1718         return ListStylePosition::Inside;
1719     default:
1720         break;
1721     }
1722 
1723     ASSERT_NOT_REACHED();
1724     return ListStylePosition::Outside;
1725 }
1726 
1727 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ListStyleType e)
1728     : CSSValue(PrimitiveClass)
1729 {
<span class="line-modified">1730     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1731     switch (e) {
1732     case ListStyleType::Afar:
1733         m_value.valueID = CSSValueAfar;
1734         break;
1735     case ListStyleType::Amharic:
1736         m_value.valueID = CSSValueAmharic;
1737         break;
1738     case ListStyleType::AmharicAbegede:
1739         m_value.valueID = CSSValueAmharicAbegede;
1740         break;
1741     case ListStyleType::ArabicIndic:
1742         m_value.valueID = CSSValueArabicIndic;
1743         break;
1744     case ListStyleType::Armenian:
1745         m_value.valueID = CSSValueArmenian;
1746         break;
1747     case ListStyleType::Asterisks:
1748         m_value.valueID = CSSValueAsterisks;
1749         break;
1750     case ListStyleType::Binary:
</pre>
<hr />
<pre>
1973         m_value.valueID = CSSValueUrdu;
1974         break;
1975     }
1976 }
1977 
1978 template&lt;&gt; inline CSSPrimitiveValue::operator ListStyleType() const
1979 {
1980     ASSERT(isValueID());
1981 
1982     switch (m_value.valueID) {
1983     case CSSValueNone:
1984         return ListStyleType::None;
1985     default:
1986         return static_cast&lt;ListStyleType&gt;(m_value.valueID - CSSValueDisc);
1987     }
1988 }
1989 
1990 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarginCollapse e)
1991     : CSSValue(PrimitiveClass)
1992 {
<span class="line-modified">1993     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
1994     switch (e) {
1995     case MarginCollapse::Collapse:
1996         m_value.valueID = CSSValueCollapse;
1997         break;
1998     case MarginCollapse::Separate:
1999         m_value.valueID = CSSValueSeparate;
2000         break;
2001     case MarginCollapse::Discard:
2002         m_value.valueID = CSSValueDiscard;
2003         break;
2004     }
2005 }
2006 
2007 template&lt;&gt; inline CSSPrimitiveValue::operator MarginCollapse() const
2008 {
2009     ASSERT(isValueID());
2010 
2011     switch (m_value.valueID) {
2012     case CSSValueCollapse:
2013         return MarginCollapse::Collapse;
2014     case CSSValueSeparate:
2015         return MarginCollapse::Separate;
2016     case CSSValueDiscard:
2017         return MarginCollapse::Discard;
2018     default:
2019         break;
2020     }
2021 
2022     ASSERT_NOT_REACHED();
2023     return MarginCollapse::Collapse;
2024 }
2025 
2026 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeBehavior e)
2027     : CSSValue(PrimitiveClass)
2028 {
<span class="line-modified">2029     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2030     switch (e) {
2031     case MarqueeBehavior::None:
2032         m_value.valueID = CSSValueNone;
2033         break;
2034     case MarqueeBehavior::Scroll:
2035         m_value.valueID = CSSValueScroll;
2036         break;
2037     case MarqueeBehavior::Slide:
2038         m_value.valueID = CSSValueSlide;
2039         break;
2040     case MarqueeBehavior::Alternate:
2041         m_value.valueID = CSSValueAlternate;
2042         break;
2043     }
2044 }
2045 
2046 template&lt;&gt; inline CSSPrimitiveValue::operator MarqueeBehavior() const
2047 {
2048     ASSERT(isValueID());
2049 
2050     switch (m_value.valueID) {
2051     case CSSValueNone:
2052         return MarqueeBehavior::None;
2053     case CSSValueScroll:
2054         return MarqueeBehavior::Scroll;
2055     case CSSValueSlide:
2056         return MarqueeBehavior::Slide;
2057     case CSSValueAlternate:
2058         return MarqueeBehavior::Alternate;
2059     default:
2060         break;
2061     }
2062 
2063     ASSERT_NOT_REACHED();
2064     return MarqueeBehavior::None;
2065 }
2066 
2067 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MarqueeDirection direction)
2068     : CSSValue(PrimitiveClass)
2069 {
<span class="line-modified">2070     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2071     switch (direction) {
2072     case MarqueeDirection::Forward:
2073         m_value.valueID = CSSValueForwards;
2074         break;
2075     case MarqueeDirection::Backward:
2076         m_value.valueID = CSSValueBackwards;
2077         break;
2078     case MarqueeDirection::Auto:
2079         m_value.valueID = CSSValueAuto;
2080         break;
2081     case MarqueeDirection::Up:
2082         m_value.valueID = CSSValueUp;
2083         break;
2084     case MarqueeDirection::Down:
2085         m_value.valueID = CSSValueDown;
2086         break;
2087     case MarqueeDirection::Left:
2088         m_value.valueID = CSSValueLeft;
2089         break;
2090     case MarqueeDirection::Right:
</pre>
<hr />
<pre>
2108     case CSSValueUp: // We don&#39;t support vertical languages, so AHEAD just maps to UP.
2109         return MarqueeDirection::Up;
2110     case CSSValueReverse:
2111     case CSSValueDown: // REVERSE just maps to DOWN, since we don&#39;t do vertical text.
2112         return MarqueeDirection::Down;
2113     case CSSValueLeft:
2114         return MarqueeDirection::Left;
2115     case CSSValueRight:
2116         return MarqueeDirection::Right;
2117     default:
2118         break;
2119     }
2120 
2121     ASSERT_NOT_REACHED();
2122     return MarqueeDirection::Auto;
2123 }
2124 
2125 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(NBSPMode e)
2126     : CSSValue(PrimitiveClass)
2127 {
<span class="line-modified">2128     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2129     switch (e) {
2130     case NBSPMode::Normal:
2131         m_value.valueID = CSSValueNormal;
2132         break;
2133     case NBSPMode::Space:
2134         m_value.valueID = CSSValueSpace;
2135         break;
2136     }
2137 }
2138 
2139 template&lt;&gt; inline CSSPrimitiveValue::operator NBSPMode() const
2140 {
2141     ASSERT(isValueID());
2142 
2143     switch (m_value.valueID) {
2144     case CSSValueSpace:
2145         return NBSPMode::Space;
2146     case CSSValueNormal:
2147         return NBSPMode::Normal;
2148     default:
2149         break;
2150     }
2151 
2152     ASSERT_NOT_REACHED();
2153     return NBSPMode::Normal;
2154 }
2155 
2156 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Overflow e)
2157     : CSSValue(PrimitiveClass)
2158 {
<span class="line-modified">2159     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2160     switch (e) {
2161     case Overflow::Visible:
2162         m_value.valueID = CSSValueVisible;
2163         break;
2164     case Overflow::Hidden:
2165         m_value.valueID = CSSValueHidden;
2166         break;
2167     case Overflow::Scroll:
2168         m_value.valueID = CSSValueScroll;
2169         break;
2170     case Overflow::Auto:
2171         m_value.valueID = CSSValueAuto;
2172         break;
2173     case Overflow::PagedX:
2174         m_value.valueID = CSSValueWebkitPagedX;
2175         break;
2176     case Overflow::PagedY:
2177         m_value.valueID = CSSValueWebkitPagedY;
2178         break;
2179     }
</pre>
<hr />
<pre>
2191     case CSSValueScroll:
2192         return Overflow::Scroll;
2193     case CSSValueOverlay:
2194     case CSSValueAuto:
2195         return Overflow::Auto;
2196     case CSSValueWebkitPagedX:
2197         return Overflow::PagedX;
2198     case CSSValueWebkitPagedY:
2199         return Overflow::PagedY;
2200     default:
2201         break;
2202     }
2203 
2204     ASSERT_NOT_REACHED();
2205     return Overflow::Visible;
2206 }
2207 
2208 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakBetween e)
2209     : CSSValue(PrimitiveClass)
2210 {
<span class="line-modified">2211     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2212     switch (e) {
2213     case BreakBetween::Auto:
2214         m_value.valueID = CSSValueAuto;
2215         break;
2216     case BreakBetween::Avoid:
2217         m_value.valueID = CSSValueAvoid;
2218         break;
2219     case BreakBetween::AvoidColumn:
2220         m_value.valueID = CSSValueAvoidColumn;
2221         break;
2222     case BreakBetween::AvoidPage:
2223         m_value.valueID = CSSValueAvoidPage;
2224         break;
2225     case BreakBetween::Column:
2226         m_value.valueID = CSSValueColumn;
2227         break;
2228     case BreakBetween::Page:
2229         m_value.valueID = CSSValuePage;
2230         break;
2231     case BreakBetween::LeftPage:
</pre>
<hr />
<pre>
2262         return BreakBetween::Page;
2263     case CSSValueLeft:
2264         return BreakBetween::LeftPage;
2265     case CSSValueRight:
2266         return BreakBetween::RightPage;
2267     case CSSValueRecto:
2268         return BreakBetween::RectoPage;
2269     case CSSValueVerso:
2270         return BreakBetween::VersoPage;
2271     default:
2272         break;
2273     }
2274 
2275     ASSERT_NOT_REACHED();
2276     return BreakBetween::Auto;
2277 }
2278 
2279 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BreakInside e)
2280     : CSSValue(PrimitiveClass)
2281 {
<span class="line-modified">2282     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2283     switch (e) {
2284     case BreakInside::Auto:
2285         m_value.valueID = CSSValueAuto;
2286         break;
2287     case BreakInside::Avoid:
2288         m_value.valueID = CSSValueAvoid;
2289         break;
2290     case BreakInside::AvoidColumn:
2291         m_value.valueID = CSSValueAvoidColumn;
2292         break;
2293     case BreakInside::AvoidPage:
2294         m_value.valueID = CSSValueAvoidPage;
2295         break;
2296     }
2297 }
2298 
2299 template&lt;&gt; inline CSSPrimitiveValue::operator BreakInside() const
2300 {
2301     ASSERT(isValueID());
2302 
2303     switch (m_value.valueID) {
2304     case CSSValueAuto:
2305         return BreakInside::Auto;
2306     case CSSValueAvoid:
2307         return BreakInside::Avoid;
2308     case CSSValueAvoidColumn:
2309         return BreakInside::AvoidColumn;
2310     case CSSValueAvoidPage:
2311         return BreakInside::AvoidPage;
2312     default:
2313         break;
2314     }
2315 
2316     ASSERT_NOT_REACHED();
2317     return BreakInside::Auto;
2318 }
2319 
2320 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PositionType e)
2321     : CSSValue(PrimitiveClass)
2322 {
<span class="line-modified">2323     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2324     switch (e) {
2325     case PositionType::Static:
2326         m_value.valueID = CSSValueStatic;
2327         break;
2328     case PositionType::Relative:
2329         m_value.valueID = CSSValueRelative;
2330         break;
2331     case PositionType::Absolute:
2332         m_value.valueID = CSSValueAbsolute;
2333         break;
2334     case PositionType::Fixed:
2335         m_value.valueID = CSSValueFixed;
2336         break;
2337     case PositionType::Sticky:
2338         m_value.valueID = CSSValueSticky;
2339         break;
2340     }
2341 }
2342 
2343 template&lt;&gt; inline CSSPrimitiveValue::operator PositionType() const
</pre>
<hr />
<pre>
2350     case CSSValueRelative:
2351         return PositionType::Relative;
2352     case CSSValueAbsolute:
2353         return PositionType::Absolute;
2354     case CSSValueFixed:
2355         return PositionType::Fixed;
2356     case CSSValueSticky:
2357     case CSSValueWebkitSticky:
2358         return PositionType::Sticky;
2359     default:
2360         break;
2361     }
2362 
2363     ASSERT_NOT_REACHED();
2364     return PositionType::Static;
2365 }
2366 
2367 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Resize e)
2368     : CSSValue(PrimitiveClass)
2369 {
<span class="line-modified">2370     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2371     switch (e) {
2372     case Resize::Both:
2373         m_value.valueID = CSSValueBoth;
2374         break;
2375     case Resize::Horizontal:
2376         m_value.valueID = CSSValueHorizontal;
2377         break;
2378     case Resize::Vertical:
2379         m_value.valueID = CSSValueVertical;
2380         break;
2381     case Resize::None:
2382         m_value.valueID = CSSValueNone;
2383         break;
2384     }
2385 }
2386 
2387 template&lt;&gt; inline CSSPrimitiveValue::operator Resize() const
2388 {
2389     ASSERT(isValueID());
2390 
</pre>
<hr />
<pre>
2394     case CSSValueHorizontal:
2395         return Resize::Horizontal;
2396     case CSSValueVertical:
2397         return Resize::Vertical;
2398     case CSSValueAuto:
2399         ASSERT_NOT_REACHED(); // Depends on settings, thus should be handled by the caller.
2400         return Resize::None;
2401     case CSSValueNone:
2402         return Resize::None;
2403     default:
2404         break;
2405     }
2406 
2407     ASSERT_NOT_REACHED();
2408     return Resize::None;
2409 }
2410 
2411 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TableLayoutType e)
2412     : CSSValue(PrimitiveClass)
2413 {
<span class="line-modified">2414     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2415     switch (e) {
2416     case TableLayoutType::Auto:
2417         m_value.valueID = CSSValueAuto;
2418         break;
2419     case TableLayoutType::Fixed:
2420         m_value.valueID = CSSValueFixed;
2421         break;
2422     }
2423 }
2424 
2425 template&lt;&gt; inline CSSPrimitiveValue::operator TableLayoutType() const
2426 {
2427     ASSERT(isValueID());
2428 
2429     switch (m_value.valueID) {
2430     case CSSValueFixed:
2431         return TableLayoutType::Fixed;
2432     case CSSValueAuto:
2433         return TableLayoutType::Auto;
2434     default:
2435         break;
2436     }
2437 
2438     ASSERT_NOT_REACHED();
2439     return TableLayoutType::Auto;
2440 }
2441 
2442 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignMode e)
2443     : CSSValue(PrimitiveClass)
2444 {
<span class="line-modified">2445     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2446     switch (e) {
2447     case TextAlignMode::Start:
2448         m_value.valueID = CSSValueStart;
2449         break;
2450     case TextAlignMode::End:
2451         m_value.valueID = CSSValueEnd;
2452         break;
2453     case TextAlignMode::Left:
2454         m_value.valueID = CSSValueLeft;
2455         break;
2456     case TextAlignMode::Right:
2457         m_value.valueID = CSSValueRight;
2458         break;
2459     case TextAlignMode::Center:
2460         m_value.valueID = CSSValueCenter;
2461         break;
2462     case TextAlignMode::Justify:
2463         m_value.valueID = CSSValueJustify;
2464         break;
2465     case TextAlignMode::WebKitLeft:
</pre>
<hr />
<pre>
2476 
2477 template&lt;&gt; inline CSSPrimitiveValue::operator TextAlignMode() const
2478 {
2479     ASSERT(isValueID());
2480 
2481     switch (m_value.valueID) {
2482     case CSSValueWebkitAuto: // Legacy -webkit-auto. Eqiuvalent to start.
2483     case CSSValueStart:
2484         return TextAlignMode::Start;
2485     case CSSValueEnd:
2486         return TextAlignMode::End;
2487     default:
2488         return static_cast&lt;TextAlignMode&gt;(m_value.valueID - CSSValueLeft);
2489     }
2490 }
2491 
2492 #if ENABLE(CSS3_TEXT)
2493 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAlignLast e)
2494     : CSSValue(PrimitiveClass)
2495 {
<span class="line-modified">2496     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2497     switch (e) {
2498     case TextAlignLast::Start:
2499         m_value.valueID = CSSValueStart;
2500         break;
2501     case TextAlignLast::End:
2502         m_value.valueID = CSSValueEnd;
2503         break;
2504     case TextAlignLast::Left:
2505         m_value.valueID = CSSValueLeft;
2506         break;
2507     case TextAlignLast::Right:
2508         m_value.valueID = CSSValueRight;
2509         break;
2510     case TextAlignLast::Center:
2511         m_value.valueID = CSSValueCenter;
2512         break;
2513     case TextAlignLast::Justify:
2514         m_value.valueID = CSSValueJustify;
2515         break;
2516     case TextAlignLast::Auto:
</pre>
<hr />
<pre>
2532         return TextAlignLast::End;
2533     case CSSValueLeft:
2534         return TextAlignLast::Left;
2535     case CSSValueRight:
2536         return TextAlignLast::Right;
2537     case CSSValueCenter:
2538         return TextAlignLast::Center;
2539     case CSSValueJustify:
2540         return TextAlignLast::Justify;
2541     default:
2542         break;
2543     }
2544 
2545     ASSERT_NOT_REACHED();
2546     return TextAlignLast::Auto;
2547 }
2548 
2549 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextJustify e)
2550     : CSSValue(PrimitiveClass)
2551 {
<span class="line-modified">2552     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2553     switch (e) {
2554     case TextJustify::Auto:
2555         m_value.valueID = CSSValueAuto;
2556         break;
2557     case TextJustify::None:
2558         m_value.valueID = CSSValueNone;
2559         break;
2560     case TextJustify::InterWord:
2561         m_value.valueID = CSSValueInterWord;
2562         break;
2563     case TextJustify::Distribute:
2564         m_value.valueID = CSSValueDistribute;
2565         break;
2566     }
2567 }
2568 
2569 template&lt;&gt; inline CSSPrimitiveValue::operator TextJustify() const
2570 {
2571     ASSERT(isValueID());
2572 
</pre>
<hr />
<pre>
2624         return TextDecorationStyle::Solid;
2625     case CSSValueDouble:
2626         return TextDecorationStyle::Double;
2627     case CSSValueDotted:
2628         return TextDecorationStyle::Dotted;
2629     case CSSValueDashed:
2630         return TextDecorationStyle::Dashed;
2631     case CSSValueWavy:
2632         return TextDecorationStyle::Wavy;
2633     default:
2634         break;
2635     }
2636 
2637     ASSERT_NOT_REACHED();
2638     return TextDecorationStyle::Solid;
2639 }
2640 
2641 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextUnderlinePosition position)
2642     : CSSValue(PrimitiveClass)
2643 {
<span class="line-modified">2644     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2645     switch (position) {
2646     case TextUnderlinePosition::Auto:
2647         m_value.valueID = CSSValueAuto;
2648         break;
2649     case TextUnderlinePosition::Under:
2650         m_value.valueID = CSSValueUnder;
2651         break;
2652     case TextUnderlinePosition::FromFont:
2653         m_value.valueID = CSSValueFromFont;
2654         break;
2655     }
2656 
2657     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2658 }
2659 
2660 template&lt;&gt; inline CSSPrimitiveValue::operator TextUnderlinePosition() const
2661 {
2662     ASSERT(isValueID());
2663 
2664     switch (m_value.valueID) {
2665     case CSSValueAuto:
2666         return TextUnderlinePosition::Auto;
2667     case CSSValueUnder:
2668         return TextUnderlinePosition::Under;
2669     case CSSValueFromFont:
2670         return TextUnderlinePosition::FromFont;
2671     default:
2672         break;
2673     }
2674 
2675     // FIXME: Implement support for &#39;under left&#39; and &#39;under right&#39; values.
2676     ASSERT_NOT_REACHED();
2677     return TextUnderlinePosition::Auto;
2678 }
2679 
2680 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextSecurity e)
2681     : CSSValue(PrimitiveClass)
2682 {
<span class="line-modified">2683     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2684     switch (e) {
2685     case TextSecurity::None:
2686         m_value.valueID = CSSValueNone;
2687         break;
2688     case TextSecurity::Disc:
2689         m_value.valueID = CSSValueDisc;
2690         break;
2691     case TextSecurity::Circle:
2692         m_value.valueID = CSSValueCircle;
2693         break;
2694     case TextSecurity::Square:
2695         m_value.valueID = CSSValueSquare;
2696         break;
2697     }
2698 }
2699 
2700 template&lt;&gt; inline CSSPrimitiveValue::operator TextSecurity() const
2701 {
2702     ASSERT(isValueID());
2703 
2704     switch (m_value.valueID) {
2705     case CSSValueNone:
2706         return TextSecurity::None;
2707     case CSSValueDisc:
2708         return TextSecurity::Disc;
2709     case CSSValueCircle:
2710         return TextSecurity::Circle;
2711     case CSSValueSquare:
2712         return TextSecurity::Square;
2713     default:
2714         break;
2715     }
2716 
2717     ASSERT_NOT_REACHED();
2718     return TextSecurity::None;
2719 }
2720 
2721 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextTransform e)
2722     : CSSValue(PrimitiveClass)
2723 {
<span class="line-modified">2724     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2725     switch (e) {
2726     case TextTransform::Capitalize:
2727         m_value.valueID = CSSValueCapitalize;
2728         break;
2729     case TextTransform::Uppercase:
2730         m_value.valueID = CSSValueUppercase;
2731         break;
2732     case TextTransform::Lowercase:
2733         m_value.valueID = CSSValueLowercase;
2734         break;
2735     case TextTransform::None:
2736         m_value.valueID = CSSValueNone;
2737         break;
2738     }
2739 }
2740 
2741 template&lt;&gt; inline CSSPrimitiveValue::operator TextTransform() const
2742 {
2743     ASSERT(isValueID());
2744 
2745     switch (m_value.valueID) {
2746     case CSSValueCapitalize:
2747         return TextTransform::Capitalize;
2748     case CSSValueUppercase:
2749         return TextTransform::Uppercase;
2750     case CSSValueLowercase:
2751         return TextTransform::Lowercase;
2752     case CSSValueNone:
2753         return TextTransform::None;
2754     default:
2755         break;
2756     }
2757 
2758     ASSERT_NOT_REACHED();
2759     return TextTransform::None;
2760 }
2761 
2762 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(EUnicodeBidi e)
2763     : CSSValue(PrimitiveClass)
2764 {
<span class="line-modified">2765     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2766     switch (e) {
2767     case UBNormal:
2768         m_value.valueID = CSSValueNormal;
2769         break;
2770     case Embed:
2771         m_value.valueID = CSSValueEmbed;
2772         break;
2773     case Override:
2774         m_value.valueID = CSSValueBidiOverride;
2775         break;
2776     case Isolate:
2777         m_value.valueID = CSSValueIsolate;
2778         break;
2779     case IsolateOverride:
2780         m_value.valueID = CSSValueIsolateOverride;
2781         break;
2782     case Plaintext:
2783         m_value.valueID = CSSValuePlaintext;
2784         break;
2785     }
</pre>
<hr />
<pre>
2799     case CSSValueIsolate:
2800     case CSSValueWebkitIsolate:
2801         return Isolate;
2802     case CSSValueIsolateOverride:
2803     case CSSValueWebkitIsolateOverride:
2804         return IsolateOverride;
2805     case CSSValuePlaintext:
2806     case CSSValueWebkitPlaintext:
2807         return Plaintext;
2808     default:
2809         break;
2810     }
2811 
2812     ASSERT_NOT_REACHED();
2813     return UBNormal;
2814 }
2815 
2816 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserDrag e)
2817     : CSSValue(PrimitiveClass)
2818 {
<span class="line-modified">2819     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2820     switch (e) {
2821     case UserDrag::Auto:
2822         m_value.valueID = CSSValueAuto;
2823         break;
2824     case UserDrag::None:
2825         m_value.valueID = CSSValueNone;
2826         break;
2827     case UserDrag::Element:
2828         m_value.valueID = CSSValueElement;
2829         break;
2830     default:
2831         break;
2832     }
2833 }
2834 
2835 template&lt;&gt; inline CSSPrimitiveValue::operator UserDrag() const
2836 {
2837     ASSERT(isValueID());
2838 
2839     switch (m_value.valueID) {
2840     case CSSValueAuto:
2841         return UserDrag::Auto;
2842     case CSSValueNone:
2843         return UserDrag::None;
2844     case CSSValueElement:
2845         return UserDrag::Element;
2846     default:
2847         break;
2848     }
2849 
2850     ASSERT_NOT_REACHED();
2851     return UserDrag::Auto;
2852 }
2853 
2854 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserModify e)
2855     : CSSValue(PrimitiveClass)
2856 {
<span class="line-modified">2857     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2858     switch (e) {
2859     case UserModify::ReadOnly:
2860         m_value.valueID = CSSValueReadOnly;
2861         break;
2862     case UserModify::ReadWrite:
2863         m_value.valueID = CSSValueReadWrite;
2864         break;
2865     case UserModify::ReadWritePlaintextOnly:
2866         m_value.valueID = CSSValueReadWritePlaintextOnly;
2867         break;
2868     }
2869 }
2870 
2871 template&lt;&gt; inline CSSPrimitiveValue::operator UserModify() const
2872 {
2873     ASSERT(isValueID());
2874 
2875     switch (m_value.valueID) {
2876     case CSSValueReadOnly:
2877         return UserModify::ReadOnly;
2878     case CSSValueReadWrite:
2879         return UserModify::ReadWrite;
2880     case CSSValueReadWritePlaintextOnly:
2881         return UserModify::ReadWritePlaintextOnly;
2882     default:
2883         break;
2884     }
2885 
2886     ASSERT_NOT_REACHED();
2887     return UserModify::ReadOnly;
2888 }
2889 
2890 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(UserSelect e)
2891     : CSSValue(PrimitiveClass)
2892 {
<span class="line-modified">2893     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2894     switch (e) {
2895     case UserSelect::None:
2896         m_value.valueID = CSSValueNone;
2897         break;
2898     case UserSelect::Text:
2899         m_value.valueID = CSSValueText;
2900         break;
2901     case UserSelect::All:
2902         m_value.valueID = CSSValueAll;
2903         break;
2904     }
2905 }
2906 
2907 template&lt;&gt; inline CSSPrimitiveValue::operator UserSelect() const
2908 {
2909     ASSERT(isValueID());
2910 
2911     switch (m_value.valueID) {
2912     case CSSValueAuto:
2913         return UserSelect::Text;
2914     case CSSValueNone:
2915         return UserSelect::None;
2916     case CSSValueText:
2917         return UserSelect::Text;
2918     case CSSValueAll:
2919         return UserSelect::All;
2920     default:
2921         break;
2922     }
2923 
2924     ASSERT_NOT_REACHED();
2925     return UserSelect::Text;
2926 }
2927 
2928 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VerticalAlign a)
2929     : CSSValue(PrimitiveClass)
2930 {
<span class="line-modified">2931     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
2932     switch (a) {
2933     case VerticalAlign::Top:
2934         m_value.valueID = CSSValueTop;
2935         break;
2936     case VerticalAlign::Bottom:
2937         m_value.valueID = CSSValueBottom;
2938         break;
2939     case VerticalAlign::Middle:
2940         m_value.valueID = CSSValueMiddle;
2941         break;
2942     case VerticalAlign::Baseline:
2943         m_value.valueID = CSSValueBaseline;
2944         break;
2945     case VerticalAlign::TextBottom:
2946         m_value.valueID = CSSValueTextBottom;
2947         break;
2948     case VerticalAlign::TextTop:
2949         m_value.valueID = CSSValueTextTop;
2950         break;
2951     case VerticalAlign::Sub:
</pre>
<hr />
<pre>
2979         return VerticalAlign::TextBottom;
2980     case CSSValueTextTop:
2981         return VerticalAlign::TextTop;
2982     case CSSValueSub:
2983         return VerticalAlign::Sub;
2984     case CSSValueSuper:
2985         return VerticalAlign::Super;
2986     case CSSValueWebkitBaselineMiddle:
2987         return VerticalAlign::BaselineMiddle;
2988     default:
2989         break;
2990     }
2991 
2992     ASSERT_NOT_REACHED();
2993     return VerticalAlign::Top;
2994 }
2995 
2996 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Visibility e)
2997     : CSSValue(PrimitiveClass)
2998 {
<span class="line-modified">2999     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3000     switch (e) {
3001     case Visibility::Visible:
3002         m_value.valueID = CSSValueVisible;
3003         break;
3004     case Visibility::Hidden:
3005         m_value.valueID = CSSValueHidden;
3006         break;
3007     case Visibility::Collapse:
3008         m_value.valueID = CSSValueCollapse;
3009         break;
3010     }
3011 }
3012 
3013 template&lt;&gt; inline CSSPrimitiveValue::operator Visibility() const
3014 {
3015     ASSERT(isValueID());
3016 
3017     switch (m_value.valueID) {
3018     case CSSValueHidden:
3019         return Visibility::Hidden;
3020     case CSSValueVisible:
3021         return Visibility::Visible;
3022     case CSSValueCollapse:
3023         return Visibility::Collapse;
3024     default:
3025         break;
3026     }
3027 
3028     ASSERT_NOT_REACHED();
3029     return Visibility::Visible;
3030 }
3031 
3032 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WhiteSpace e)
3033     : CSSValue(PrimitiveClass)
3034 {
<span class="line-modified">3035     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3036     switch (e) {
3037     case WhiteSpace::Normal:
3038         m_value.valueID = CSSValueNormal;
3039         break;
3040     case WhiteSpace::Pre:
3041         m_value.valueID = CSSValuePre;
3042         break;
3043     case WhiteSpace::PreWrap:
3044         m_value.valueID = CSSValuePreWrap;
3045         break;
3046     case WhiteSpace::PreLine:
3047         m_value.valueID = CSSValuePreLine;
3048         break;
3049     case WhiteSpace::NoWrap:
3050         m_value.valueID = CSSValueNowrap;
3051         break;
3052     case WhiteSpace::KHTMLNoWrap:
3053         m_value.valueID = CSSValueWebkitNowrap;
3054         break;
3055     case WhiteSpace::BreakSpaces:
</pre>
<hr />
<pre>
3071         return WhiteSpace::Pre;
3072     case CSSValuePreWrap:
3073         return WhiteSpace::PreWrap;
3074     case CSSValuePreLine:
3075         return WhiteSpace::PreLine;
3076     case CSSValueNormal:
3077         return WhiteSpace::Normal;
3078     case CSSValueBreakSpaces:
3079         return WhiteSpace::BreakSpaces;
3080     default:
3081         break;
3082     }
3083 
3084     ASSERT_NOT_REACHED();
3085     return WhiteSpace::Normal;
3086 }
3087 
3088 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WordBreak e)
3089     : CSSValue(PrimitiveClass)
3090 {
<span class="line-modified">3091     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3092     switch (e) {
3093     case WordBreak::Normal:
3094         m_value.valueID = CSSValueNormal;
3095         break;
3096     case WordBreak::BreakAll:
3097         m_value.valueID = CSSValueBreakAll;
3098         break;
3099     case WordBreak::KeepAll:
3100         m_value.valueID = CSSValueKeepAll;
3101         break;
3102     case WordBreak::BreakWord:
3103         m_value.valueID = CSSValueBreakWord;
3104         break;
3105     }
3106 }
3107 
3108 template&lt;&gt; inline CSSPrimitiveValue::operator WordBreak() const
3109 {
3110     ASSERT(isValueID());
3111 
3112     switch (m_value.valueID) {
3113     case CSSValueBreakAll:
3114         return WordBreak::BreakAll;
3115     case CSSValueKeepAll:
3116         return WordBreak::KeepAll;
3117     case CSSValueBreakWord:
3118         return WordBreak::BreakWord;
3119     case CSSValueNormal:
3120         return WordBreak::Normal;
3121     default:
3122         break;
3123     }
3124 
3125     ASSERT_NOT_REACHED();
3126     return WordBreak::Normal;
3127 }
3128 
3129 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowWrap e)
3130     : CSSValue(PrimitiveClass)
3131 {
<span class="line-modified">3132     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3133     switch (e) {
3134     case OverflowWrap::Normal:
3135         m_value.valueID = CSSValueNormal;
3136         break;
3137     case OverflowWrap::Break:
3138         m_value.valueID = CSSValueBreakWord;
3139         break;
3140     }
3141 }
3142 
3143 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowWrap() const
3144 {
3145     ASSERT(isValueID());
3146 
3147     switch (m_value.valueID) {
3148     case CSSValueBreakWord:
3149         return OverflowWrap::Break;
3150     case CSSValueNormal:
3151         return OverflowWrap::Normal;
3152     default:
3153         break;
3154     }
3155 
3156     ASSERT_NOT_REACHED();
3157     return OverflowWrap::Normal;
3158 }
3159 
3160 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextDirection e)
3161     : CSSValue(PrimitiveClass)
3162 {
<span class="line-modified">3163     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3164     switch (e) {
3165     case TextDirection::LTR:
3166         m_value.valueID = CSSValueLtr;
3167         break;
3168     case TextDirection::RTL:
3169         m_value.valueID = CSSValueRtl;
3170         break;
3171     }
3172 }
3173 
3174 template&lt;&gt; inline CSSPrimitiveValue::operator TextDirection() const
3175 {
3176     ASSERT(isValueID());
3177 
3178     switch (m_value.valueID) {
3179     case CSSValueLtr:
3180         return TextDirection::LTR;
3181     case CSSValueRtl:
3182         return TextDirection::RTL;
3183     default:
3184         break;
3185     }
3186 
3187     ASSERT_NOT_REACHED();
3188     return TextDirection::LTR;
3189 }
3190 
3191 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WritingMode e)
3192     : CSSValue(PrimitiveClass)
3193 {
<span class="line-modified">3194     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3195     switch (e) {
3196     case TopToBottomWritingMode:
3197         m_value.valueID = CSSValueHorizontalTb;
3198         break;
3199     case RightToLeftWritingMode:
3200         m_value.valueID = CSSValueVerticalRl;
3201         break;
3202     case LeftToRightWritingMode:
3203         m_value.valueID = CSSValueVerticalLr;
3204         break;
3205     case BottomToTopWritingMode:
3206         m_value.valueID = CSSValueHorizontalBt;
3207         break;
3208     }
3209 }
3210 
3211 template&lt;&gt; inline CSSPrimitiveValue::operator WritingMode() const
3212 {
3213     ASSERT(isValueID());
3214 
</pre>
<hr />
<pre>
3221         return TopToBottomWritingMode;
3222     case CSSValueVerticalRl:
3223     case CSSValueTb:
3224     case CSSValueTbRl:
3225         return RightToLeftWritingMode;
3226     case CSSValueVerticalLr:
3227         return LeftToRightWritingMode;
3228     case CSSValueHorizontalBt:
3229         return BottomToTopWritingMode;
3230     default:
3231         break;
3232     }
3233 
3234     ASSERT_NOT_REACHED();
3235     return TopToBottomWritingMode;
3236 }
3237 
3238 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextCombine e)
3239     : CSSValue(PrimitiveClass)
3240 {
<span class="line-modified">3241     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3242     switch (e) {
3243     case TextCombine::None:
3244         m_value.valueID = CSSValueNone;
3245         break;
3246     case TextCombine::Horizontal:
3247         m_value.valueID = CSSValueHorizontal;
3248         break;
3249     }
3250 }
3251 
3252 template&lt;&gt; inline CSSPrimitiveValue::operator TextCombine() const
3253 {
3254     ASSERT(isValueID());
3255 
3256     switch (m_value.valueID) {
3257     case CSSValueNone:
3258         return TextCombine::None;
3259     case CSSValueHorizontal:
3260         return TextCombine::Horizontal;
3261     default:
3262         break;
3263     }
3264 
3265     ASSERT_NOT_REACHED();
3266     return TextCombine::None;
3267 }
3268 
3269 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(RubyPosition position)
3270     : CSSValue(PrimitiveClass)
3271 {
<span class="line-modified">3272     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3273     switch (position) {
3274     case RubyPosition::Before:
3275         m_value.valueID = CSSValueBefore;
3276         break;
3277     case RubyPosition::After:
3278         m_value.valueID = CSSValueAfter;
3279         break;
3280     case RubyPosition::InterCharacter:
3281         m_value.valueID = CSSValueInterCharacter;
3282         break;
3283     }
3284 }
3285 
3286 template&lt;&gt; inline CSSPrimitiveValue::operator RubyPosition() const
3287 {
3288     ASSERT(isValueID());
3289 
3290     switch (m_value.valueID) {
3291     case CSSValueBefore:
3292         return RubyPosition::Before;
3293     case CSSValueAfter:
3294         return RubyPosition::After;
3295     case CSSValueInterCharacter:
3296         return RubyPosition::InterCharacter;
3297     default:
3298         break;
3299     }
3300 
3301     ASSERT_NOT_REACHED();
3302     return RubyPosition::Before;
3303 }
3304 
3305 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOverflow overflow)
3306     : CSSValue(PrimitiveClass)
3307 {
<span class="line-modified">3308     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3309     switch (overflow) {
3310     case TextOverflow::Clip:
3311         m_value.valueID = CSSValueClip;
3312         break;
3313     case TextOverflow::Ellipsis:
3314         m_value.valueID = CSSValueEllipsis;
3315         break;
3316     }
3317 }
3318 
3319 template&lt;&gt; inline CSSPrimitiveValue::operator TextOverflow() const
3320 {
3321     ASSERT(isValueID());
3322 
3323     switch (m_value.valueID) {
3324     case CSSValueClip:
3325         return TextOverflow::Clip;
3326     case CSSValueEllipsis:
3327         return TextOverflow::Ellipsis;
3328     default:
3329         break;
3330     }
3331 
3332     ASSERT_NOT_REACHED();
3333     return TextOverflow::Clip;
3334 }
3335 
3336 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisFill fill)
3337     : CSSValue(PrimitiveClass)
3338 {
<span class="line-modified">3339     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3340     switch (fill) {
3341     case TextEmphasisFill::Filled:
3342         m_value.valueID = CSSValueFilled;
3343         break;
3344     case TextEmphasisFill::Open:
3345         m_value.valueID = CSSValueOpen;
3346         break;
3347     }
3348 }
3349 
3350 template&lt;&gt; inline CSSPrimitiveValue::operator TextEmphasisFill() const
3351 {
3352     ASSERT(isValueID());
3353 
3354     switch (m_value.valueID) {
3355     case CSSValueFilled:
3356         return TextEmphasisFill::Filled;
3357     case CSSValueOpen:
3358         return TextEmphasisFill::Open;
3359     default:
3360         break;
3361     }
3362 
3363     ASSERT_NOT_REACHED();
3364     return TextEmphasisFill::Filled;
3365 }
3366 
3367 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextEmphasisMark mark)
3368     : CSSValue(PrimitiveClass)
3369 {
<span class="line-modified">3370     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3371     switch (mark) {
3372     case TextEmphasisMark::Dot:
3373         m_value.valueID = CSSValueDot;
3374         break;
3375     case TextEmphasisMark::Circle:
3376         m_value.valueID = CSSValueCircle;
3377         break;
3378     case TextEmphasisMark::DoubleCircle:
3379         m_value.valueID = CSSValueDoubleCircle;
3380         break;
3381     case TextEmphasisMark::Triangle:
3382         m_value.valueID = CSSValueTriangle;
3383         break;
3384     case TextEmphasisMark::Sesame:
3385         m_value.valueID = CSSValueSesame;
3386         break;
3387     case TextEmphasisMark::None:
3388     case TextEmphasisMark::Auto:
3389     case TextEmphasisMark::Custom:
3390         ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
3404         return TextEmphasisMark::Dot;
3405     case CSSValueCircle:
3406         return TextEmphasisMark::Circle;
3407     case CSSValueDoubleCircle:
3408         return TextEmphasisMark::DoubleCircle;
3409     case CSSValueTriangle:
3410         return TextEmphasisMark::Triangle;
3411     case CSSValueSesame:
3412         return TextEmphasisMark::Sesame;
3413     default:
3414         break;
3415     }
3416 
3417     ASSERT_NOT_REACHED();
3418     return TextEmphasisMark::None;
3419 }
3420 
3421 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextOrientation e)
3422     : CSSValue(PrimitiveClass)
3423 {
<span class="line-modified">3424     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3425     switch (e) {
3426     case TextOrientation::Sideways:
3427         m_value.valueID = CSSValueSideways;
3428         break;
3429     case TextOrientation::Mixed:
3430         m_value.valueID = CSSValueMixed;
3431         break;
3432     case TextOrientation::Upright:
3433         m_value.valueID = CSSValueUpright;
3434         break;
3435     }
3436 }
3437 
3438 template&lt;&gt; inline CSSPrimitiveValue::operator TextOrientation() const
3439 {
3440     ASSERT(isValueID());
3441 
3442     switch (m_value.valueID) {
3443     case CSSValueSideways:
3444         return TextOrientation::Sideways;
3445     case CSSValueSidewaysRight:
3446         return TextOrientation::Sideways;
3447     case CSSValueVerticalRight:
3448         return TextOrientation::Mixed;
3449     case CSSValueMixed:
3450         return TextOrientation::Mixed;
3451     case CSSValueUpright:
3452         return TextOrientation::Upright;
3453     default:
3454         break;
3455     }
3456 
3457     ASSERT_NOT_REACHED();
3458     return TextOrientation::Mixed;
3459 }
3460 
3461 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(PointerEvents e)
3462     : CSSValue(PrimitiveClass)
3463 {
<span class="line-modified">3464     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3465     switch (e) {
3466     case PointerEvents::None:
3467         m_value.valueID = CSSValueNone;
3468         break;
3469     case PointerEvents::Stroke:
3470         m_value.valueID = CSSValueStroke;
3471         break;
3472     case PointerEvents::Fill:
3473         m_value.valueID = CSSValueFill;
3474         break;
3475     case PointerEvents::Painted:
3476         m_value.valueID = CSSValuePainted;
3477         break;
3478     case PointerEvents::Visible:
3479         m_value.valueID = CSSValueVisible;
3480         break;
3481     case PointerEvents::VisibleStroke:
3482         m_value.valueID = CSSValueVisibleStroke;
3483         break;
3484     case PointerEvents::VisibleFill:
3485         m_value.valueID = CSSValueVisibleFill;
3486         break;
3487     case PointerEvents::VisiblePainted:
3488         m_value.valueID = CSSValueVisiblePainted;
3489         break;
<span class="line-added">3490     case PointerEvents::BoundingBox:</span>
<span class="line-added">3491         m_value.valueID = CSSValueBoundingBox;</span>
<span class="line-added">3492         break;</span>
3493     case PointerEvents::Auto:
3494         m_value.valueID = CSSValueAuto;
3495         break;
3496     case PointerEvents::All:
3497         m_value.valueID = CSSValueAll;
3498         break;
3499     }
3500 }
3501 
3502 template&lt;&gt; inline CSSPrimitiveValue::operator PointerEvents() const
3503 {
3504     ASSERT(isValueID());
3505 
3506     switch (m_value.valueID) {
3507     case CSSValueAll:
3508         return PointerEvents::All;
3509     case CSSValueAuto:
3510         return PointerEvents::Auto;
3511     case CSSValueNone:
3512         return PointerEvents::None;
3513     case CSSValueVisiblePainted:
3514         return PointerEvents::VisiblePainted;
3515     case CSSValueVisibleFill:
3516         return PointerEvents::VisibleFill;
3517     case CSSValueVisibleStroke:
3518         return PointerEvents::VisibleStroke;
3519     case CSSValueVisible:
3520         return PointerEvents::Visible;
3521     case CSSValuePainted:
3522         return PointerEvents::Painted;
3523     case CSSValueFill:
3524         return PointerEvents::Fill;
3525     case CSSValueStroke:
3526         return PointerEvents::Stroke;
<span class="line-added">3527     case CSSValueBoundingBox:</span>
<span class="line-added">3528         return PointerEvents::BoundingBox;</span>
3529     default:
3530         break;
3531     }
3532 
3533     ASSERT_NOT_REACHED();
3534     return PointerEvents::All;
3535 }
3536 
3537 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Kerning kerning)
3538     : CSSValue(PrimitiveClass)
3539 {
<span class="line-modified">3540     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3541     switch (kerning) {
3542     case Kerning::Auto:
3543         m_value.valueID = CSSValueAuto;
3544         return;
3545     case Kerning::Normal:
3546         m_value.valueID = CSSValueNormal;
3547         return;
3548     case Kerning::NoShift:
3549         m_value.valueID = CSSValueNone;
3550         return;
3551     }
3552 
3553     ASSERT_NOT_REACHED();
3554     m_value.valueID = CSSValueAuto;
3555 }
3556 
3557 template&lt;&gt; inline CSSPrimitiveValue::operator Kerning() const
3558 {
3559     ASSERT(isValueID());
3560 
3561     switch (m_value.valueID) {
3562     case CSSValueAuto:
3563         return Kerning::Auto;
3564     case CSSValueNormal:
3565         return Kerning::Normal;
3566     case CSSValueNone:
3567         return Kerning::NoShift;
3568     default:
3569         break;
3570     }
3571 
3572     ASSERT_NOT_REACHED();
3573     return Kerning::Auto;
3574 }
3575 
3576 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ObjectFit fit)
3577     : CSSValue(PrimitiveClass)
3578 {
<span class="line-modified">3579     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3580     switch (fit) {
3581     case ObjectFit::Fill:
3582         m_value.valueID = CSSValueFill;
3583         break;
3584     case ObjectFit::Contain:
3585         m_value.valueID = CSSValueContain;
3586         break;
3587     case ObjectFit::Cover:
3588         m_value.valueID = CSSValueCover;
3589         break;
3590     case ObjectFit::None:
3591         m_value.valueID = CSSValueNone;
3592         break;
3593     case ObjectFit::ScaleDown:
3594         m_value.valueID = CSSValueScaleDown;
3595         break;
3596     }
3597 }
3598 
3599 template&lt;&gt; inline CSSPrimitiveValue::operator ObjectFit() const
</pre>
<hr />
<pre>
3603     switch (m_value.valueID) {
3604     case CSSValueFill:
3605         return ObjectFit::Fill;
3606     case CSSValueContain:
3607         return ObjectFit::Contain;
3608     case CSSValueCover:
3609         return ObjectFit::Cover;
3610     case CSSValueNone:
3611         return ObjectFit::None;
3612     case CSSValueScaleDown:
3613         return ObjectFit::ScaleDown;
3614     default:
3615         ASSERT_NOT_REACHED();
3616         return ObjectFit::Fill;
3617     }
3618 }
3619 
3620 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmoothingMode smoothing)
3621     : CSSValue(PrimitiveClass)
3622 {
<span class="line-modified">3623     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3624     switch (smoothing) {
3625     case FontSmoothingMode::AutoSmoothing:
3626         m_value.valueID = CSSValueAuto;
3627         return;
3628     case FontSmoothingMode::NoSmoothing:
3629         m_value.valueID = CSSValueNone;
3630         return;
3631     case FontSmoothingMode::Antialiased:
3632         m_value.valueID = CSSValueAntialiased;
3633         return;
3634     case FontSmoothingMode::SubpixelAntialiased:
3635         m_value.valueID = CSSValueSubpixelAntialiased;
3636         return;
3637     }
3638 
3639     ASSERT_NOT_REACHED();
3640     m_value.valueID = CSSValueAuto;
3641 }
3642 
3643 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmoothingMode() const
</pre>
<hr />
<pre>
3647     switch (m_value.valueID) {
3648     case CSSValueAuto:
3649         return FontSmoothingMode::AutoSmoothing;
3650     case CSSValueNone:
3651         return FontSmoothingMode::NoSmoothing;
3652     case CSSValueAntialiased:
3653         return FontSmoothingMode::Antialiased;
3654     case CSSValueSubpixelAntialiased:
3655         return FontSmoothingMode::SubpixelAntialiased;
3656     default:
3657         break;
3658     }
3659 
3660     ASSERT_NOT_REACHED();
3661     return FontSmoothingMode::AutoSmoothing;
3662 }
3663 
3664 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontSmallCaps smallCaps)
3665     : CSSValue(PrimitiveClass)
3666 {
<span class="line-modified">3667     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3668     switch (smallCaps) {
3669     case FontSmallCaps::Off:
3670         m_value.valueID = CSSValueNormal;
3671         return;
3672     case FontSmallCaps::On:
3673         m_value.valueID = CSSValueSmallCaps;
3674         return;
3675     }
3676 
3677     ASSERT_NOT_REACHED();
3678     m_value.valueID = CSSValueNormal;
3679 }
3680 
3681 template&lt;&gt; inline CSSPrimitiveValue::operator FontSmallCaps() const
3682 {
3683     ASSERT(isValueID());
3684 
3685     switch (m_value.valueID) {
3686     case CSSValueSmallCaps:
3687         return FontSmallCaps::On;
3688     case CSSValueNormal:
3689         return FontSmallCaps::Off;
3690     default:
3691         break;
3692     }
3693     ASSERT_NOT_REACHED();
3694     return FontSmallCaps::Off;
3695 }
3696 
3697 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextRenderingMode e)
3698     : CSSValue(PrimitiveClass)
3699 {
<span class="line-modified">3700     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3701     switch (e) {
3702     case TextRenderingMode::AutoTextRendering:
3703         m_value.valueID = CSSValueAuto;
3704         break;
3705     case TextRenderingMode::OptimizeSpeed:
3706         m_value.valueID = CSSValueOptimizeSpeed;
3707         break;
3708     case TextRenderingMode::OptimizeLegibility:
3709         m_value.valueID = CSSValueOptimizeLegibility;
3710         break;
3711     case TextRenderingMode::GeometricPrecision:
3712         m_value.valueID = CSSValueGeometricPrecision;
3713         break;
3714     }
3715 }
3716 
3717 template&lt;&gt; inline CSSPrimitiveValue::operator TextRenderingMode() const
3718 {
3719     ASSERT(isValueID());
3720 
3721     switch (m_value.valueID) {
3722     case CSSValueAuto:
3723         return TextRenderingMode::AutoTextRendering;
3724     case CSSValueOptimizeSpeed:
3725         return TextRenderingMode::OptimizeSpeed;
3726     case CSSValueOptimizeLegibility:
3727         return TextRenderingMode::OptimizeLegibility;
3728     case CSSValueGeometricPrecision:
3729         return TextRenderingMode::GeometricPrecision;
3730     default:
3731         break;
3732     }
3733 
3734     ASSERT_NOT_REACHED();
3735     return TextRenderingMode::AutoTextRendering;
3736 }
3737 
3738 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Hyphens hyphens)
3739     : CSSValue(PrimitiveClass)
3740 {
<span class="line-modified">3741     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3742     switch (hyphens) {
3743     case Hyphens::None:
3744         m_value.valueID = CSSValueNone;
3745         break;
3746     case Hyphens::Manual:
3747         m_value.valueID = CSSValueManual;
3748         break;
3749     case Hyphens::Auto:
3750         m_value.valueID = CSSValueAuto;
3751         break;
3752     }
3753 }
3754 
3755 template&lt;&gt; inline CSSPrimitiveValue::operator Hyphens() const
3756 {
3757     ASSERT(isValueID());
3758 
3759     switch (m_value.valueID) {
3760     case CSSValueNone:
3761         return Hyphens::None;
3762     case CSSValueManual:
3763         return Hyphens::Manual;
3764     case CSSValueAuto:
3765         return Hyphens::Auto;
3766     default:
3767         break;
3768     }
3769 
3770     ASSERT_NOT_REACHED();
3771     return Hyphens::Auto;
3772 }
3773 
3774 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineSnap gridSnap)
3775     : CSSValue(PrimitiveClass)
3776 {
<span class="line-modified">3777     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3778     switch (gridSnap) {
3779     case LineSnap::None:
3780         m_value.valueID = CSSValueNone;
3781         break;
3782     case LineSnap::Baseline:
3783         m_value.valueID = CSSValueBaseline;
3784         break;
3785     case LineSnap::Contain:
3786         m_value.valueID = CSSValueContain;
3787         break;
3788     }
3789 }
3790 
3791 template&lt;&gt; inline CSSPrimitiveValue::operator LineSnap() const
3792 {
3793     ASSERT(isValueID());
3794 
3795     switch (m_value.valueID) {
3796     case CSSValueNone:
3797         return LineSnap::None;
3798     case CSSValueBaseline:
3799         return LineSnap::Baseline;
3800     case CSSValueContain:
3801         return LineSnap::Contain;
3802     default:
3803         break;
3804     }
3805 
3806     ASSERT_NOT_REACHED();
3807     return LineSnap::None;
3808 }
3809 
3810 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineAlign lineAlign)
3811     : CSSValue(PrimitiveClass)
3812 {
<span class="line-modified">3813     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3814     switch (lineAlign) {
3815     case LineAlign::None:
3816         m_value.valueID = CSSValueNone;
3817         break;
3818     case LineAlign::Edges:
3819         m_value.valueID = CSSValueEdges;
3820         break;
3821     }
3822 }
3823 
3824 template&lt;&gt; inline CSSPrimitiveValue::operator LineAlign() const
3825 {
3826     ASSERT(isValueID());
3827 
3828     switch (m_value.valueID) {
3829     case CSSValueNone:
3830         return LineAlign::None;
3831     case CSSValueEdges:
3832         return LineAlign::Edges;
3833     default:
3834         break;
3835     }
3836 
3837     ASSERT_NOT_REACHED();
3838     return LineAlign::None;
3839 }
3840 
3841 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(SpeakAs e)
3842     : CSSValue(PrimitiveClass)
3843 {
<span class="line-modified">3844     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3845     switch (e) {
3846     case SpeakAs::Normal:
3847         m_value.valueID = CSSValueNormal;
3848         break;
3849     case SpeakAs::SpellOut:
3850         m_value.valueID = CSSValueSpellOut;
3851         break;
3852     case SpeakAs::Digits:
3853         m_value.valueID = CSSValueDigits;
3854         break;
3855     case SpeakAs::LiteralPunctuation:
3856         m_value.valueID = CSSValueLiteralPunctuation;
3857         break;
3858     case SpeakAs::NoPunctuation:
3859         m_value.valueID = CSSValueNoPunctuation;
3860         break;
3861     }
3862 }
3863 
3864 template&lt;&gt; inline CSSPrimitiveValue::operator Order() const
3865 {
3866     ASSERT(isValueID());
3867 
3868     switch (m_value.valueID) {
3869     case CSSValueLogical:
3870         return Order::Logical;
3871     case CSSValueVisual:
3872         return Order::Visual;
3873     default:
3874         break;
3875     }
3876 
3877     ASSERT_NOT_REACHED();
3878     return Order::Logical;
3879 }
3880 
3881 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Order e)
3882     : CSSValue(PrimitiveClass)
3883 {
<span class="line-modified">3884     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3885     switch (e) {
3886     case Order::Logical:
3887         m_value.valueID = CSSValueLogical;
3888         break;
3889     case Order::Visual:
3890         m_value.valueID = CSSValueVisual;
3891         break;
3892     }
3893 }
3894 
3895 template&lt;&gt; inline CSSPrimitiveValue::operator OptionSet&lt;SpeakAs&gt;() const
3896 {
3897     ASSERT(isValueID());
3898 
3899     switch (m_value.valueID) {
3900     case CSSValueNormal:
3901         return OptionSet&lt;SpeakAs&gt; { };
3902     case CSSValueSpellOut:
3903         return SpeakAs::SpellOut;
3904     case CSSValueDigits:
3905         return SpeakAs::Digits;
3906     case CSSValueLiteralPunctuation:
3907         return SpeakAs::LiteralPunctuation;
3908     case CSSValueNoPunctuation:
3909         return SpeakAs::NoPunctuation;
3910     default:
3911         break;
3912     }
3913 
3914     ASSERT_NOT_REACHED();
3915     return OptionSet&lt;SpeakAs&gt; { };
3916 }
3917 
3918 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BlendMode blendMode)
3919     : CSSValue(PrimitiveClass)
3920 {
<span class="line-modified">3921     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
3922     switch (blendMode) {
3923     case BlendMode::Normal:
3924         m_value.valueID = CSSValueNormal;
3925         break;
3926     case BlendMode::Multiply:
3927         m_value.valueID = CSSValueMultiply;
3928         break;
3929     case BlendMode::Screen:
3930         m_value.valueID = CSSValueScreen;
3931         break;
3932     case BlendMode::Overlay:
3933         m_value.valueID = CSSValueOverlay;
3934         break;
3935     case BlendMode::Darken:
3936         m_value.valueID = CSSValueDarken;
3937         break;
3938     case BlendMode::Lighten:
3939         m_value.valueID = CSSValueLighten;
3940         break;
3941     case BlendMode::ColorDodge:
</pre>
<hr />
<pre>
4012         return BlendMode::Saturation;
4013     case CSSValueColor:
4014         return BlendMode::Color;
4015     case CSSValueLuminosity:
4016         return BlendMode::Luminosity;
4017     case CSSValuePlusDarker:
4018         return BlendMode::PlusDarker;
4019     case CSSValuePlusLighter:
4020         return BlendMode::PlusLighter;
4021     default:
4022         break;
4023     }
4024 
4025     ASSERT_NOT_REACHED();
4026     return BlendMode::Normal;
4027 }
4028 
4029 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(Isolation isolation)
4030     : CSSValue(PrimitiveClass)
4031 {
<span class="line-modified">4032     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4033     switch (isolation) {
4034     case Isolation::Auto:
4035         m_value.valueID = CSSValueAuto;
4036         break;
4037     case Isolation::Isolate:
4038         m_value.valueID = CSSValueIsolate;
4039         break;
4040     default:
4041         ASSERT_NOT_REACHED();
4042     }
4043 }
4044 
4045 template&lt;&gt; inline CSSPrimitiveValue::operator Isolation() const
4046 {
4047     ASSERT(isValueID());
4048     switch (m_value.valueID) {
4049     case CSSValueAuto:
4050         return Isolation::Auto;
4051     case CSSValueIsolate:
4052         return Isolation::Isolate;
4053     default:
4054         break;
4055     }
4056 
4057     ASSERT_NOT_REACHED();
4058     return Isolation::Auto;
4059 }
4060 
4061 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineCap e)
4062     : CSSValue(PrimitiveClass)
4063 {
<span class="line-modified">4064     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4065     switch (e) {
4066     case ButtCap:
4067         m_value.valueID = CSSValueButt;
4068         break;
4069     case RoundCap:
4070         m_value.valueID = CSSValueRound;
4071         break;
4072     case SquareCap:
4073         m_value.valueID = CSSValueSquare;
4074         break;
4075     }
4076 }
4077 
4078 template&lt;&gt; inline CSSPrimitiveValue::operator LineCap() const
4079 {
4080     ASSERT(isValueID());
4081 
4082     switch (m_value.valueID) {
4083     case CSSValueButt:
4084         return ButtCap;
4085     case CSSValueRound:
4086         return RoundCap;
4087     case CSSValueSquare:
4088         return SquareCap;
4089     default:
4090         break;
4091     }
4092 
4093     ASSERT_NOT_REACHED();
4094     return ButtCap;
4095 }
4096 
4097 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(LineJoin e)
4098     : CSSValue(PrimitiveClass)
4099 {
<span class="line-modified">4100     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4101     switch (e) {
4102     case MiterJoin:
4103         m_value.valueID = CSSValueMiter;
4104         break;
4105     case RoundJoin:
4106         m_value.valueID = CSSValueRound;
4107         break;
4108     case BevelJoin:
4109         m_value.valueID = CSSValueBevel;
4110         break;
4111     }
4112 }
4113 
4114 template&lt;&gt; inline CSSPrimitiveValue::operator LineJoin() const
4115 {
4116     ASSERT(isValueID());
4117 
4118     switch (m_value.valueID) {
4119     case CSSValueMiter:
4120         return MiterJoin;
4121     case CSSValueRound:
4122         return RoundJoin;
4123     case CSSValueBevel:
4124         return BevelJoin;
4125     default:
4126         break;
4127     }
4128 
4129     ASSERT_NOT_REACHED();
4130     return MiterJoin;
4131 }
4132 
4133 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(WindRule e)
4134     : CSSValue(PrimitiveClass)
4135 {
<span class="line-modified">4136     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4137     switch (e) {
4138     case WindRule::NonZero:
4139         m_value.valueID = CSSValueNonzero;
4140         break;
4141     case WindRule::EvenOdd:
4142         m_value.valueID = CSSValueEvenodd;
4143         break;
4144     }
4145 }
4146 
4147 template&lt;&gt; inline CSSPrimitiveValue::operator WindRule() const
4148 {
4149     ASSERT(isValueID());
4150 
4151     switch (m_value.valueID) {
4152     case CSSValueNonzero:
4153         return WindRule::NonZero;
4154     case CSSValueEvenodd:
4155         return WindRule::EvenOdd;
4156     default:
4157         break;
4158     }
4159 
4160     ASSERT_NOT_REACHED();
4161     return WindRule::NonZero;
4162 }
4163 
4164 
4165 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(AlignmentBaseline e)
4166     : CSSValue(PrimitiveClass)
4167 {
<span class="line-modified">4168     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4169     switch (e) {
4170     case AlignmentBaseline::Auto:
4171         m_value.valueID = CSSValueAuto;
4172         break;
4173     case AlignmentBaseline::Baseline:
4174         m_value.valueID = CSSValueBaseline;
4175         break;
4176     case AlignmentBaseline::BeforeEdge:
4177         m_value.valueID = CSSValueBeforeEdge;
4178         break;
4179     case AlignmentBaseline::TextBeforeEdge:
4180         m_value.valueID = CSSValueTextBeforeEdge;
4181         break;
4182     case AlignmentBaseline::Middle:
4183         m_value.valueID = CSSValueMiddle;
4184         break;
4185     case AlignmentBaseline::Central:
4186         m_value.valueID = CSSValueCentral;
4187         break;
4188     case AlignmentBaseline::AfterEdge:
</pre>
<hr />
<pre>
4229         return AlignmentBaseline::TextAfterEdge;
4230     case CSSValueIdeographic:
4231         return AlignmentBaseline::Ideographic;
4232     case CSSValueAlphabetic:
4233         return AlignmentBaseline::Alphabetic;
4234     case CSSValueHanging:
4235         return AlignmentBaseline::Hanging;
4236     case CSSValueMathematical:
4237         return AlignmentBaseline::Mathematical;
4238     default:
4239         break;
4240     }
4241 
4242     ASSERT_NOT_REACHED();
4243     return AlignmentBaseline::Auto;
4244 }
4245 
4246 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderCollapse e)
4247     : CSSValue(PrimitiveClass)
4248 {
<span class="line-modified">4249     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4250     switch (e) {
4251     case BorderCollapse::Separate:
4252         m_value.valueID = CSSValueSeparate;
4253         break;
4254     case BorderCollapse::Collapse:
4255         m_value.valueID = CSSValueCollapse;
4256         break;
4257     }
4258 }
4259 
4260 template&lt;&gt; inline CSSPrimitiveValue::operator BorderCollapse() const
4261 {
4262     ASSERT(isValueID());
4263 
4264     switch (m_value.valueID) {
4265     case CSSValueSeparate:
4266         return BorderCollapse::Separate;
4267     case CSSValueCollapse:
4268         return BorderCollapse::Collapse;
4269     default:
4270         break;
4271     }
4272 
4273     ASSERT_NOT_REACHED();
4274     return BorderCollapse::Separate;
4275 }
4276 
4277 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BorderFit e)
4278     : CSSValue(PrimitiveClass)
4279 {
<span class="line-modified">4280     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4281     switch (e) {
4282     case BorderFit::Border:
4283         m_value.valueID = CSSValueBorder;
4284         break;
4285     case BorderFit::Lines:
4286         m_value.valueID = CSSValueLines;
4287         break;
4288     }
4289 }
4290 
4291 template&lt;&gt; inline CSSPrimitiveValue::operator BorderFit() const
4292 {
4293     ASSERT(isValueID());
4294 
4295     switch (m_value.valueID) {
4296     case CSSValueBorder:
4297         return BorderFit::Border;
4298     case CSSValueLines:
4299         return BorderFit::Lines;
4300     default:
4301         break;
4302     }
4303 
4304     ASSERT_NOT_REACHED();
4305     return BorderFit::Lines;
4306 }
4307 
4308 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ImageRendering imageRendering)
4309     : CSSValue(PrimitiveClass)
4310 {
<span class="line-modified">4311     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4312     switch (imageRendering) {
4313     case ImageRendering::Auto:
4314         m_value.valueID = CSSValueAuto;
4315         break;
4316     case ImageRendering::CrispEdges:
4317         m_value.valueID = CSSValueCrispEdges;
4318         break;
4319     case ImageRendering::Pixelated:
4320         m_value.valueID = CSSValuePixelated;
4321         break;
4322     case ImageRendering::OptimizeSpeed:
4323         m_value.valueID = CSSValueOptimizeSpeed;
4324         break;
4325     case ImageRendering::OptimizeQuality:
4326         m_value.valueID = CSSValueOptimizeQuality;
4327         break;
4328     }
4329 }
4330 
4331 template&lt;&gt; inline CSSPrimitiveValue::operator ImageRendering() const
</pre>
<hr />
<pre>
4339     case CSSValueCrispEdges:
4340     case CSSValueWebkitCrispEdges:
4341         return ImageRendering::CrispEdges;
4342     case CSSValuePixelated:
4343         return ImageRendering::Pixelated;
4344     case CSSValueOptimizeSpeed:
4345         return ImageRendering::OptimizeSpeed;
4346     case CSSValueOptimizeQuality:
4347         return ImageRendering::OptimizeQuality;
4348     default:
4349         break;
4350     }
4351 
4352     ASSERT_NOT_REACHED();
4353     return ImageRendering::Auto;
4354 }
4355 
4356 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformStyle3D e)
4357     : CSSValue(PrimitiveClass)
4358 {
<span class="line-modified">4359     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4360     switch (e) {
4361     case TransformStyle3D::Flat:
4362         m_value.valueID = CSSValueFlat;
4363         break;
4364     case TransformStyle3D::Preserve3D:
4365         m_value.valueID = CSSValuePreserve3d;
4366         break;
4367     }
4368 }
4369 
4370 template&lt;&gt; inline CSSPrimitiveValue::operator TransformStyle3D() const
4371 {
4372     ASSERT(isValueID());
4373 
4374     switch (m_value.valueID) {
4375     case CSSValueFlat:
4376         return TransformStyle3D::Flat;
4377     case CSSValuePreserve3d:
4378         return TransformStyle3D::Preserve3D;
4379     default:
4380         break;
4381     }
4382 
4383     ASSERT_NOT_REACHED();
4384     return TransformStyle3D::Flat;
4385 }
4386 
4387 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TransformBox box)
4388     : CSSValue(PrimitiveClass)
4389 {
<span class="line-modified">4390     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4391     switch (box) {
<span class="line-added">4392     case TransformBox::StrokeBox:</span>
<span class="line-added">4393         m_value.valueID = CSSValueStrokeBox;</span>
<span class="line-added">4394         break;</span>
<span class="line-added">4395     case TransformBox::ContentBox:</span>
<span class="line-added">4396         m_value.valueID = CSSValueContentBox;</span>
<span class="line-added">4397         break;</span>
4398     case TransformBox::BorderBox:
4399         m_value.valueID = CSSValueBorderBox;
4400         break;
4401     case TransformBox::FillBox:
4402         m_value.valueID = CSSValueFillBox;
4403         break;
4404     case TransformBox::ViewBox:
4405         m_value.valueID = CSSValueViewBox;
4406         break;
4407     }
4408 }
4409 
4410 template&lt;&gt; inline CSSPrimitiveValue::operator TransformBox() const
4411 {
4412     ASSERT(isValueID());
4413 
4414     switch (m_value.valueID) {
<span class="line-added">4415     case CSSValueStrokeBox:</span>
<span class="line-added">4416         return TransformBox::StrokeBox;</span>
<span class="line-added">4417     case CSSValueContentBox:</span>
<span class="line-added">4418         return TransformBox::ContentBox;</span>
4419     case CSSValueBorderBox:
4420         return TransformBox::BorderBox;
4421     case CSSValueFillBox:
4422         return TransformBox::FillBox;
4423     case CSSValueViewBox:
4424         return TransformBox::ViewBox;
4425     default:
4426         break;
4427     }
4428 
4429     ASSERT_NOT_REACHED();
4430     return TransformBox::BorderBox;
4431 }
4432 
4433 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnAxis e)
4434     : CSSValue(PrimitiveClass)
4435 {
<span class="line-modified">4436     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4437     switch (e) {
4438     case ColumnAxis::Horizontal:
4439         m_value.valueID = CSSValueHorizontal;
4440         break;
4441     case ColumnAxis::Vertical:
4442         m_value.valueID = CSSValueVertical;
4443         break;
4444     case ColumnAxis::Auto:
4445         m_value.valueID = CSSValueAuto;
4446         break;
4447     }
4448 }
4449 
4450 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnAxis() const
4451 {
4452     ASSERT(isValueID());
4453 
4454     switch (m_value.valueID) {
4455     case CSSValueHorizontal:
4456         return ColumnAxis::Horizontal;
4457     case CSSValueVertical:
4458         return ColumnAxis::Vertical;
4459     case CSSValueAuto:
4460         return ColumnAxis::Auto;
4461     default:
4462         break;
4463     }
4464 
4465     ASSERT_NOT_REACHED();
4466     return ColumnAxis::Auto;
4467 }
4468 
4469 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColumnProgression e)
4470     : CSSValue(PrimitiveClass)
4471 {
<span class="line-modified">4472     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4473     switch (e) {
4474     case ColumnProgression::Normal:
4475         m_value.valueID = CSSValueNormal;
4476         break;
4477     case ColumnProgression::Reverse:
4478         m_value.valueID = CSSValueReverse;
4479         break;
4480     }
4481 }
4482 
4483 template&lt;&gt; inline CSSPrimitiveValue::operator ColumnProgression() const
4484 {
4485     ASSERT(isValueID());
4486 
4487     switch (m_value.valueID) {
4488     case CSSValueNormal:
4489         return ColumnProgression::Normal;
4490     case CSSValueReverse:
4491         return ColumnProgression::Reverse;
4492     default:
4493         break;
4494     }
4495 
4496     ASSERT_NOT_REACHED();
4497     return ColumnProgression::Normal;
4498 }
4499 
4500 enum LengthConversion {
4501     AnyConversion = ~0,
4502     FixedIntegerConversion = 1 &lt;&lt; 0,
4503     FixedFloatConversion = 1 &lt;&lt; 1,
4504     AutoConversion = 1 &lt;&lt; 2,
4505     PercentConversion = 1 &lt;&lt; 3,
4506     CalculatedConversion = 1 &lt;&lt; 4
4507 };
4508 
4509 inline bool CSSPrimitiveValue::convertingToLengthRequiresNonNullStyle(int lengthConversion) const
4510 {
4511     ASSERT(isFontRelativeLength());
4512     // This matches the implementation in CSSPrimitiveValue::computeLengthDouble().
<span class="line-modified">4513     switch (primitiveUnitType()) {</span>
<span class="line-modified">4514     case CSSUnitType::CSS_EMS:</span>
<span class="line-modified">4515     case CSSUnitType::CSS_EXS:</span>
<span class="line-modified">4516     case CSSUnitType::CSS_CHS:</span>
4517         return lengthConversion &amp; (FixedIntegerConversion | FixedFloatConversion);
4518     default:
4519         return false;
4520     }
4521 }
4522 
4523 template&lt;int supported&gt; Length CSSPrimitiveValue::convertToLength(const CSSToLengthConversionData&amp; conversionData) const
4524 {
4525     if (isFontRelativeLength() &amp;&amp; convertingToLengthRequiresNonNullStyle(supported) &amp;&amp; !conversionData.style())
4526         return Length(Undefined);
4527     if ((supported &amp; FixedIntegerConversion) &amp;&amp; isLength())
4528         return computeLength&lt;Length&gt;(conversionData);
4529     if ((supported &amp; FixedFloatConversion) &amp;&amp; isLength())
4530         return Length(computeLength&lt;double&gt;(conversionData), Fixed);
4531     if ((supported &amp; PercentConversion) &amp;&amp; isPercentage())
4532         return Length(doubleValue(), Percent);
4533     if ((supported &amp; AutoConversion) &amp;&amp; valueID() == CSSValueAuto)
4534         return Length(Auto);
4535     if ((supported &amp; CalculatedConversion) &amp;&amp; isCalculated())
4536         return Length(cssCalcValue()-&gt;createCalculationValue(conversionData));
4537     return Length(Undefined);
4538 }
4539 
4540 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(BufferedRendering e)
4541     : CSSValue(PrimitiveClass)
4542 {
<span class="line-modified">4543     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4544     switch (e) {
4545     case BufferedRendering::Auto:
4546         m_value.valueID = CSSValueAuto;
4547         break;
4548     case BufferedRendering::Dynamic:
4549         m_value.valueID = CSSValueDynamic;
4550         break;
4551     case BufferedRendering::Static:
4552         m_value.valueID = CSSValueStatic;
4553         break;
4554     }
4555 }
4556 
4557 template&lt;&gt; inline CSSPrimitiveValue::operator BufferedRendering() const
4558 {
4559     ASSERT(isValueID());
4560 
4561     switch (m_value.valueID) {
4562     case CSSValueAuto:
4563         return BufferedRendering::Auto;
4564     case CSSValueDynamic:
4565         return BufferedRendering::Dynamic;
4566     case CSSValueStatic:
4567         return BufferedRendering::Static;
4568     default:
4569         break;
4570     }
4571 
4572     ASSERT_NOT_REACHED();
4573     return BufferedRendering::Auto;
4574 }
4575 
4576 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorInterpolation e)
4577     : CSSValue(PrimitiveClass)
4578 {
<span class="line-modified">4579     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4580     switch (e) {
4581     case ColorInterpolation::Auto:
4582         m_value.valueID = CSSValueAuto;
4583         break;
4584     case ColorInterpolation::SRGB:
4585         m_value.valueID = CSSValueSRGB;
4586         break;
4587     case ColorInterpolation::LinearRGB:
4588         m_value.valueID = CSSValueLinearRGB;
4589         break;
4590     }
4591 }
4592 
4593 template&lt;&gt; inline CSSPrimitiveValue::operator ColorInterpolation() const
4594 {
4595     ASSERT(isValueID());
4596 
4597     switch (m_value.valueID) {
4598     case CSSValueSRGB:
4599         return ColorInterpolation::SRGB;
4600     case CSSValueLinearRGB:
4601         return ColorInterpolation::LinearRGB;
4602     case CSSValueAuto:
4603         return ColorInterpolation::Auto;
4604     default:
4605         break;
4606     }
4607 
4608     ASSERT_NOT_REACHED();
4609     return ColorInterpolation::Auto;
4610 }
4611 
4612 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ColorRendering e)
4613     : CSSValue(PrimitiveClass)
4614 {
<span class="line-modified">4615     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4616     switch (e) {
4617     case ColorRendering::Auto:
4618         m_value.valueID = CSSValueAuto;
4619         break;
4620     case ColorRendering::OptimizeSpeed:
4621         m_value.valueID = CSSValueOptimizeSpeed;
4622         break;
4623     case ColorRendering::OptimizeQuality:
4624         m_value.valueID = CSSValueOptimizeQuality;
4625         break;
4626     }
4627 }
4628 
4629 template&lt;&gt; inline CSSPrimitiveValue::operator ColorRendering() const
4630 {
4631     ASSERT(isValueID());
4632 
4633     switch (m_value.valueID) {
4634     case CSSValueOptimizeSpeed:
4635         return ColorRendering::OptimizeSpeed;
4636     case CSSValueOptimizeQuality:
4637         return ColorRendering::OptimizeQuality;
4638     case CSSValueAuto:
4639         return ColorRendering::Auto;
4640     default:
4641         break;
4642     }
4643 
4644     ASSERT_NOT_REACHED();
4645     return ColorRendering::Auto;
4646 }
4647 
4648 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(DominantBaseline e)
4649     : CSSValue(PrimitiveClass)
4650 {
<span class="line-modified">4651     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4652     switch (e) {
4653     case DominantBaseline::Auto:
4654         m_value.valueID = CSSValueAuto;
4655         break;
4656     case DominantBaseline::UseScript:
4657         m_value.valueID = CSSValueUseScript;
4658         break;
4659     case DominantBaseline::NoChange:
4660         m_value.valueID = CSSValueNoChange;
4661         break;
4662     case DominantBaseline::ResetSize:
4663         m_value.valueID = CSSValueResetSize;
4664         break;
4665     case DominantBaseline::Central:
4666         m_value.valueID = CSSValueCentral;
4667         break;
4668     case DominantBaseline::Middle:
4669         m_value.valueID = CSSValueMiddle;
4670         break;
4671     case DominantBaseline::TextBeforeEdge:
</pre>
<hr />
<pre>
4712         return DominantBaseline::Mathematical;
4713     case CSSValueCentral:
4714         return DominantBaseline::Central;
4715     case CSSValueMiddle:
4716         return DominantBaseline::Middle;
4717     case CSSValueTextAfterEdge:
4718         return DominantBaseline::TextAfterEdge;
4719     case CSSValueTextBeforeEdge:
4720         return DominantBaseline::TextBeforeEdge;
4721     default:
4722         break;
4723     }
4724 
4725     ASSERT_NOT_REACHED();
4726     return DominantBaseline::Auto;
4727 }
4728 
4729 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ShapeRendering e)
4730     : CSSValue(PrimitiveClass)
4731 {
<span class="line-modified">4732     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4733     switch (e) {
4734     case ShapeRendering::Auto:
4735         m_value.valueID = CSSValueAuto;
4736         break;
4737     case ShapeRendering::OptimizeSpeed:
4738         m_value.valueID = CSSValueOptimizeSpeed;
4739         break;
4740     case ShapeRendering::CrispEdges:
4741         m_value.valueID = CSSValueCrispedges;
4742         break;
4743     case ShapeRendering::GeometricPrecision:
4744         m_value.valueID = CSSValueGeometricPrecision;
4745         break;
4746     }
4747 }
4748 
4749 template&lt;&gt; inline CSSPrimitiveValue::operator ShapeRendering() const
4750 {
4751     ASSERT(isValueID());
4752 
4753     switch (m_value.valueID) {
4754     case CSSValueAuto:
4755         return ShapeRendering::Auto;
4756     case CSSValueOptimizeSpeed:
4757         return ShapeRendering::OptimizeSpeed;
4758     case CSSValueCrispedges:
4759         return ShapeRendering::CrispEdges;
4760     case CSSValueGeometricPrecision:
4761         return ShapeRendering::GeometricPrecision;
4762     default:
4763         break;
4764     }
4765 
4766     ASSERT_NOT_REACHED();
4767     return ShapeRendering::Auto;
4768 }
4769 
4770 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextAnchor e)
4771     : CSSValue(PrimitiveClass)
4772 {
<span class="line-modified">4773     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4774     switch (e) {
4775     case TextAnchor::Start:
4776         m_value.valueID = CSSValueStart;
4777         break;
4778     case TextAnchor::Middle:
4779         m_value.valueID = CSSValueMiddle;
4780         break;
4781     case TextAnchor::End:
4782         m_value.valueID = CSSValueEnd;
4783         break;
4784     }
4785 }
4786 
4787 template&lt;&gt; inline CSSPrimitiveValue::operator TextAnchor() const
4788 {
4789     ASSERT(isValueID());
4790 
4791     switch (m_value.valueID) {
4792     case CSSValueStart:
4793         return TextAnchor::Start;
4794     case CSSValueMiddle:
4795         return TextAnchor::Middle;
4796     case CSSValueEnd:
4797         return TextAnchor::End;
4798     default:
4799         break;
4800     }
4801 
4802     ASSERT_NOT_REACHED();
4803     return TextAnchor::Start;
4804 }
4805 
4806 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(const Color&amp; color)
4807     : CSSValue(PrimitiveClass)
4808 {
<span class="line-modified">4809     setPrimitiveUnitType(CSSUnitType::CSS_RGBCOLOR);</span>
4810     m_value.color = new Color(color);
4811 }
4812 
4813 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSFontFamily fontFamily)
4814     : CSSValue(PrimitiveClass)
4815 {
<span class="line-modified">4816     setPrimitiveUnitType(CSSUnitType::CSS_FONT_FAMILY);</span>
4817     m_value.fontFamily = new CSSFontFamily(WTFMove(fontFamily));
4818 }
4819 
4820 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(VectorEffect e)
4821     : CSSValue(PrimitiveClass)
4822 {
<span class="line-modified">4823     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4824     switch (e) {
4825     case VectorEffect::None:
4826         m_value.valueID = CSSValueNone;
4827         break;
4828     case VectorEffect::NonScalingStroke:
4829         m_value.valueID = CSSValueNonScalingStroke;
4830         break;
4831     }
4832 }
4833 
4834 template&lt;&gt; inline CSSPrimitiveValue::operator VectorEffect() const
4835 {
4836     ASSERT(isValueID());
4837 
4838     switch (m_value.valueID) {
4839     case CSSValueNone:
4840         return VectorEffect::None;
4841     case CSSValueNonScalingStroke:
4842         return VectorEffect::NonScalingStroke;
4843     default:
4844         break;
4845     }
4846 
4847     ASSERT_NOT_REACHED();
4848     return VectorEffect::None;
4849 }
4850 
4851 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(MaskType e)
4852     : CSSValue(PrimitiveClass)
4853 {
<span class="line-modified">4854     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4855     switch (e) {
4856     case MaskType::Luminance:
4857         m_value.valueID = CSSValueLuminance;
4858         break;
4859     case MaskType::Alpha:
4860         m_value.valueID = CSSValueAlpha;
4861         break;
4862     }
4863 }
4864 
4865 template&lt;&gt; inline CSSPrimitiveValue::operator MaskType() const
4866 {
4867     ASSERT(isValueID());
4868 
4869     switch (m_value.valueID) {
4870     case CSSValueLuminance:
4871         return MaskType::Luminance;
4872     case CSSValueAlpha:
4873         return MaskType::Alpha;
4874     default:
4875         break;
4876     }
4877 
4878     ASSERT_NOT_REACHED();
4879     return MaskType::Luminance;
4880 }
4881 


















































4882 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(CSSBoxType cssBox)
4883     : CSSValue(PrimitiveClass)
4884 {
<span class="line-modified">4885     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4886     switch (cssBox) {
4887     case CSSBoxType::MarginBox:
4888         m_value.valueID = CSSValueMarginBox;
4889         break;
4890     case CSSBoxType::BorderBox:
4891         m_value.valueID = CSSValueBorderBox;
4892         break;
4893     case CSSBoxType::PaddingBox:
4894         m_value.valueID = CSSValuePaddingBox;
4895         break;
4896     case CSSBoxType::ContentBox:
4897         m_value.valueID = CSSValueContentBox;
4898         break;
4899     case CSSBoxType::FillBox:
4900         m_value.valueID = CSSValueFillBox;
4901         break;
4902     case CSSBoxType::StrokeBox:
4903         m_value.valueID = CSSValueStrokeBox;
4904         break;
4905     case CSSBoxType::ViewBox:
</pre>
<hr />
<pre>
4923         return CSSBoxType::PaddingBox;
4924     case CSSValueContentBox:
4925         return CSSBoxType::ContentBox;
4926     // The following are used in an SVG context.
4927     case CSSValueFillBox:
4928         return CSSBoxType::FillBox;
4929     case CSSValueStrokeBox:
4930         return CSSBoxType::StrokeBox;
4931     case CSSValueViewBox:
4932         return CSSBoxType::ViewBox;
4933     default:
4934         break;
4935     }
4936     ASSERT_NOT_REACHED();
4937     return CSSBoxType::BoxMissing;
4938 }
4939 
4940 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ItemPosition itemPosition)
4941     : CSSValue(PrimitiveClass)
4942 {
<span class="line-modified">4943     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
4944     switch (itemPosition) {
4945     case ItemPosition::Legacy:
4946         m_value.valueID = CSSValueLegacy;
4947         break;
4948     case ItemPosition::Auto:
4949         m_value.valueID = CSSValueAuto;
4950         break;
4951     case ItemPosition::Normal:
4952         m_value.valueID = CSSValueNormal;
4953         break;
4954     case ItemPosition::Stretch:
4955         m_value.valueID = CSSValueStretch;
4956         break;
4957     case ItemPosition::Baseline:
4958         m_value.valueID = CSSValueBaseline;
4959         break;
4960     case ItemPosition::LastBaseline:
4961         m_value.valueID = CSSValueLastBaseline;
4962         break;
4963     case ItemPosition::Center:
</pre>
<hr />
<pre>
5018     case CSSValueSelfEnd:
5019         return ItemPosition::SelfEnd;
5020     case CSSValueFlexStart:
5021         return ItemPosition::FlexStart;
5022     case CSSValueFlexEnd:
5023         return ItemPosition::FlexEnd;
5024     case CSSValueLeft:
5025         return ItemPosition::Left;
5026     case CSSValueRight:
5027         return ItemPosition::Right;
5028     default:
5029         break;
5030     }
5031     ASSERT_NOT_REACHED();
5032     return ItemPosition::Auto;
5033 }
5034 
5035 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(OverflowAlignment overflowAlignment)
5036     : CSSValue(PrimitiveClass)
5037 {
<span class="line-modified">5038     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5039     switch (overflowAlignment) {
5040     case OverflowAlignment::Default:
5041         m_value.valueID = CSSValueDefault;
5042         break;
5043     case OverflowAlignment::Unsafe:
5044         m_value.valueID = CSSValueUnsafe;
5045         break;
5046     case OverflowAlignment::Safe:
5047         m_value.valueID = CSSValueSafe;
5048         break;
5049     }
5050 }
5051 
5052 template&lt;&gt; inline CSSPrimitiveValue::operator OverflowAlignment() const
5053 {
5054     switch (m_value.valueID) {
5055     case CSSValueUnsafe:
5056         return OverflowAlignment::Unsafe;
5057     case CSSValueSafe:
5058         return OverflowAlignment::Safe;
5059     default:
5060         break;
5061     }
5062     ASSERT_NOT_REACHED();
5063     return OverflowAlignment::Unsafe;
5064 }
5065 
5066 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentPosition contentPosition)
5067     : CSSValue(PrimitiveClass)
5068 {
<span class="line-modified">5069     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5070     switch (contentPosition) {
5071     case ContentPosition::Normal:
5072         m_value.valueID = CSSValueNormal;
5073         break;
5074     case ContentPosition::Baseline:
5075         m_value.valueID = CSSValueBaseline;
5076         break;
5077     case ContentPosition::LastBaseline:
5078         m_value.valueID = CSSValueLastBaseline;
5079         break;
5080     case ContentPosition::Center:
5081         m_value.valueID = CSSValueCenter;
5082         break;
5083     case ContentPosition::Start:
5084         m_value.valueID = CSSValueStart;
5085         break;
5086     case ContentPosition::End:
5087         m_value.valueID = CSSValueEnd;
5088         break;
5089     case ContentPosition::FlexStart:
</pre>
<hr />
<pre>
5119     case CSSValueEnd:
5120         return ContentPosition::End;
5121     case CSSValueFlexStart:
5122         return ContentPosition::FlexStart;
5123     case CSSValueFlexEnd:
5124         return ContentPosition::FlexEnd;
5125     case CSSValueLeft:
5126         return ContentPosition::Left;
5127     case CSSValueRight:
5128         return ContentPosition::Right;
5129     default:
5130         break;
5131     }
5132     ASSERT_NOT_REACHED();
5133     return ContentPosition::Normal;
5134 }
5135 
5136 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ContentDistribution contentDistribution)
5137     : CSSValue(PrimitiveClass)
5138 {
<span class="line-modified">5139     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5140     switch (contentDistribution) {
5141     case ContentDistribution::Default:
5142         m_value.valueID = CSSValueDefault;
5143         break;
5144     case ContentDistribution::SpaceBetween:
5145         m_value.valueID = CSSValueSpaceBetween;
5146         break;
5147     case ContentDistribution::SpaceAround:
5148         m_value.valueID = CSSValueSpaceAround;
5149         break;
5150     case ContentDistribution::SpaceEvenly:
5151         m_value.valueID = CSSValueSpaceEvenly;
5152         break;
5153     case ContentDistribution::Stretch:
5154         m_value.valueID = CSSValueStretch;
5155         break;
5156     }
5157 }
5158 
5159 template&lt;&gt; inline CSSPrimitiveValue::operator ContentDistribution() const
</pre>
<hr />
<pre>
5177 template&lt;&gt; inline CSSPrimitiveValue::operator TextZoom() const
5178 {
5179     ASSERT(isValueID());
5180 
5181     switch (m_value.valueID) {
5182     case CSSValueNormal:
5183         return TextZoom::Normal;
5184     case CSSValueReset:
5185         return TextZoom::Reset;
5186     default:
5187         break;
5188     }
5189 
5190     ASSERT_NOT_REACHED();
5191     return TextZoom::Normal;
5192 }
5193 
5194 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TextZoom textZoom)
5195     : CSSValue(PrimitiveClass)
5196 {
<span class="line-modified">5197     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5198     switch (textZoom) {
5199     case TextZoom::Normal:
5200         m_value.valueID = CSSValueNormal;
5201         return;
5202     case TextZoom::Reset:
5203         m_value.valueID = CSSValueReset;
5204         return;
5205     }
5206 
5207     ASSERT_NOT_REACHED();
5208     m_value.valueID = CSSValueNormal;
5209 }
5210 
5211 #if ENABLE(POINTER_EVENTS)
5212 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TouchAction touchAction)
5213     : CSSValue(PrimitiveClass)
5214 {
<span class="line-modified">5215     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5216     switch (touchAction) {
5217     case TouchAction::Auto:
5218         m_value.valueID = CSSValueAuto;
5219         break;
5220     case TouchAction::Manipulation:
5221         m_value.valueID = CSSValueManipulation;
5222         break;
5223     case TouchAction::None:
5224         m_value.valueID = CSSValueNone;
5225         break;
5226     case TouchAction::PanX:
5227         m_value.valueID = CSSValuePanX;
5228         break;
5229     case TouchAction::PanY:
5230         m_value.valueID = CSSValuePanY;
5231         break;
5232     case TouchAction::PinchZoom:
5233         m_value.valueID = CSSValuePinchZoom;
5234         break;
5235     }
</pre>
<hr />
<pre>
5247         return TouchAction::None;
5248     case CSSValuePanX:
5249         return TouchAction::PanX;
5250     case CSSValuePanY:
5251         return TouchAction::PanY;
5252     case CSSValuePinchZoom:
5253         return TouchAction::PinchZoom;
5254     default:
5255         break;
5256     }
5257     ASSERT_NOT_REACHED();
5258     return TouchAction::Auto;
5259 }
5260 #endif
5261 
5262 #if ENABLE(CSS_SCROLL_SNAP)
5263 
5264 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapStrictness strictness)
5265     : CSSValue(PrimitiveClass)
5266 {
<span class="line-modified">5267     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5268     switch (strictness) {
5269     case ScrollSnapStrictness::None:
5270         m_value.valueID = CSSValueNone;
5271         break;
5272     case ScrollSnapStrictness::Proximity:
5273         m_value.valueID = CSSValueProximity;
5274         break;
5275     case ScrollSnapStrictness::Mandatory:
5276         m_value.valueID = CSSValueMandatory;
5277         break;
5278     }
5279 }
5280 
5281 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapStrictness() const
5282 {
5283     ASSERT(isValueID());
5284     switch (m_value.valueID) {
5285     case CSSValueNone:
5286         return ScrollSnapStrictness::None;
5287     case CSSValueProximity:
5288         return ScrollSnapStrictness::Proximity;
5289     case CSSValueMandatory:
5290         return ScrollSnapStrictness::Mandatory;
5291     default:
5292         ASSERT_NOT_REACHED();
5293         return ScrollSnapStrictness::None;
5294     }
5295 }
5296 
5297 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxis axis)
5298     : CSSValue(PrimitiveClass)
5299 {
<span class="line-modified">5300     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5301     switch (axis) {
5302     case ScrollSnapAxis::XAxis:
5303         m_value.valueID = CSSValueX;
5304         break;
5305     case ScrollSnapAxis::YAxis:
5306         m_value.valueID = CSSValueY;
5307         break;
5308     case ScrollSnapAxis::Block:
5309         m_value.valueID = CSSValueBlock;
5310         break;
5311     case ScrollSnapAxis::Inline:
5312         m_value.valueID = CSSValueInline;
5313         break;
5314     case ScrollSnapAxis::Both:
5315         m_value.valueID = CSSValueBoth;
5316         break;
5317     }
5318 }
5319 
5320 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxis() const
</pre>
<hr />
<pre>
5323     switch (m_value.valueID) {
5324     case CSSValueX:
5325         return ScrollSnapAxis::XAxis;
5326     case CSSValueY:
5327         return ScrollSnapAxis::YAxis;
5328     case CSSValueBlock:
5329         return ScrollSnapAxis::Block;
5330     case CSSValueInline:
5331         return ScrollSnapAxis::Inline;
5332     case CSSValueBoth:
5333         return ScrollSnapAxis::Both;
5334     default:
5335         ASSERT_NOT_REACHED();
5336         return ScrollSnapAxis::Both;
5337     }
5338 }
5339 
5340 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ScrollSnapAxisAlignType type)
5341     : CSSValue(PrimitiveClass)
5342 {
<span class="line-modified">5343     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5344     switch (type) {
5345     case ScrollSnapAxisAlignType::None:
5346         m_value.valueID = CSSValueNone;
5347         break;
5348     case ScrollSnapAxisAlignType::Start:
5349         m_value.valueID = CSSValueStart;
5350         break;
5351     case ScrollSnapAxisAlignType::Center:
5352         m_value.valueID = CSSValueCenter;
5353         break;
5354     case ScrollSnapAxisAlignType::End:
5355         m_value.valueID = CSSValueEnd;
5356         break;
5357     }
5358 }
5359 
5360 template&lt;&gt; inline CSSPrimitiveValue::operator ScrollSnapAxisAlignType() const
5361 {
5362     ASSERT(isValueID());
5363     switch (m_value.valueID) {
5364     case CSSValueNone:
5365         return ScrollSnapAxisAlignType::None;
5366     case CSSValueStart:
5367         return ScrollSnapAxisAlignType::Start;
5368     case CSSValueCenter:
5369         return ScrollSnapAxisAlignType::Center;
5370     case CSSValueEnd:
5371         return ScrollSnapAxisAlignType::End;
5372     default:
5373         ASSERT_NOT_REACHED();
5374         return ScrollSnapAxisAlignType::None;
5375     }
5376 }
5377 
5378 #endif
5379 
5380 #if ENABLE(CSS_TRAILING_WORD)
5381 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(TrailingWord e)
5382     : CSSValue(PrimitiveClass)
5383 {
<span class="line-modified">5384     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5385     switch (e) {
5386     case TrailingWord::Auto:
5387         m_value.valueID = CSSValueAuto;
5388         break;
5389     case TrailingWord::PartiallyBalanced:
5390         m_value.valueID = CSSValueWebkitPartiallyBalanced;
5391         break;
5392     default:
5393         ASSERT_NOT_REACHED();
5394         break;
5395     }
5396 }
5397 
5398 template&lt;&gt; inline CSSPrimitiveValue::operator TrailingWord() const
5399 {
5400     ASSERT(isValueID());
5401     switch (m_value.valueID) {
5402     case CSSValueAuto:
5403         return TrailingWord::Auto;
5404     case CSSValueWebkitPartiallyBalanced:
5405         return TrailingWord::PartiallyBalanced;
5406     default:
5407         break;
5408     }
5409     ASSERT_NOT_REACHED();
5410     return TrailingWord::Auto;
5411 }
5412 #endif
5413 
5414 #if ENABLE(APPLE_PAY)
5415 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonStyle e)
5416     : CSSValue(PrimitiveClass)
5417 {
<span class="line-modified">5418     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5419     switch (e) {
5420     case ApplePayButtonStyle::White:
5421         m_value.valueID = CSSValueWhite;
5422         break;
5423     case ApplePayButtonStyle::WhiteOutline:
5424         m_value.valueID = CSSValueWhiteOutline;
5425         break;
5426     case ApplePayButtonStyle::Black:
5427         m_value.valueID = CSSValueBlack;
5428         break;
5429     default:
5430         ASSERT_NOT_REACHED();
5431         break;
5432     }
5433 }
5434 
5435 template&lt;&gt; inline CSSPrimitiveValue::operator ApplePayButtonStyle() const
5436 {
5437     ASSERT(isValueID());
5438     switch (m_value.valueID) {
5439     case CSSValueWhite:
5440         return ApplePayButtonStyle::White;
5441     case CSSValueWhiteOutline:
5442         return ApplePayButtonStyle::WhiteOutline;
5443     case CSSValueBlack:
5444         return ApplePayButtonStyle::Black;
5445     default:
5446         break;
5447     }
5448     ASSERT_NOT_REACHED();
5449     return ApplePayButtonStyle::Black;
5450 }
5451 
5452 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(ApplePayButtonType e)
5453     : CSSValue(PrimitiveClass)
5454 {
<span class="line-modified">5455     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5456     switch (e) {
5457     case ApplePayButtonType::Plain:
5458         m_value.valueID = CSSValuePlain;
5459         break;
5460     case ApplePayButtonType::Buy:
5461         m_value.valueID = CSSValueBuy;
5462         break;
5463     case ApplePayButtonType::SetUp:
5464         m_value.valueID = CSSValueSetUp;
5465         break;
5466     case ApplePayButtonType::Donate:
5467         m_value.valueID = CSSValueDonate;
5468         break;
5469 #if ENABLE(APPLE_PAY_SESSION_V4)
5470     case ApplePayButtonType::CheckOut:
5471         m_value.valueID = CSSValueCheckOut;
5472         break;
5473     case ApplePayButtonType::Book:
5474         m_value.valueID = CSSValueBook;
5475         break;
</pre>
<hr />
<pre>
5498         return ApplePayButtonType::Donate;
5499 #if ENABLE(APPLE_PAY_SESSION_V4)
5500     case CSSValueCheckOut:
5501         return ApplePayButtonType::CheckOut;
5502     case CSSValueBook:
5503         return ApplePayButtonType::Book;
5504     case CSSValueSubscribe:
5505         return ApplePayButtonType::Subscribe;
5506 #endif
5507     default:
5508         break;
5509     }
5510     ASSERT_NOT_REACHED();
5511     return ApplePayButtonType::Plain;
5512 }
5513 #endif
5514 
5515 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantPosition position)
5516     : CSSValue(PrimitiveClass)
5517 {
<span class="line-modified">5518     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5519     switch (position) {
5520     case FontVariantPosition::Normal:
5521         m_value.valueID = CSSValueNormal;
5522         break;
5523     case FontVariantPosition::Subscript:
5524         m_value.valueID = CSSValueSub;
5525         break;
5526     case FontVariantPosition::Superscript:
5527         m_value.valueID = CSSValueSuper;
5528         break;
5529     default:
5530         ASSERT_NOT_REACHED();
5531         break;
5532     }
5533 }
5534 
5535 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantPosition() const
5536 {
5537     ASSERT(isValueID());
5538     switch (m_value.valueID) {
5539     case CSSValueNormal:
5540         return FontVariantPosition::Normal;
5541     case CSSValueSub:
5542         return FontVariantPosition::Subscript;
5543     case CSSValueSuper:
5544         return FontVariantPosition::Superscript;
5545     default:
5546         break;
5547     }
5548     ASSERT_NOT_REACHED();
5549     return FontVariantPosition::Normal;
5550 }
5551 
5552 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantCaps caps)
5553     : CSSValue(PrimitiveClass)
5554 {
<span class="line-modified">5555     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5556     switch (caps) {
5557     case FontVariantCaps::Normal:
5558         m_value.valueID = CSSValueNormal;
5559         break;
5560     case FontVariantCaps::Small:
5561         m_value.valueID = CSSValueSmallCaps;
5562         break;
5563     case FontVariantCaps::AllSmall:
5564         m_value.valueID = CSSValueAllSmallCaps;
5565         break;
5566     case FontVariantCaps::Petite:
5567         m_value.valueID = CSSValuePetiteCaps;
5568         break;
5569     case FontVariantCaps::AllPetite:
5570         m_value.valueID = CSSValueAllPetiteCaps;
5571         break;
5572     case FontVariantCaps::Unicase:
5573         m_value.valueID = CSSValueUnicase;
5574         break;
5575     case FontVariantCaps::Titling:
</pre>
<hr />
<pre>
5592     case CSSValueAllSmallCaps:
5593         return FontVariantCaps::AllSmall;
5594     case CSSValuePetiteCaps:
5595         return FontVariantCaps::Petite;
5596     case CSSValueAllPetiteCaps:
5597         return FontVariantCaps::AllPetite;
5598     case CSSValueUnicase:
5599         return FontVariantCaps::Unicase;
5600     case CSSValueTitlingCaps:
5601         return FontVariantCaps::Titling;
5602     default:
5603         break;
5604     }
5605     ASSERT_NOT_REACHED();
5606     return FontVariantCaps::Normal;
5607 }
5608 
5609 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontVariantAlternates alternates)
5610     : CSSValue(PrimitiveClass)
5611 {
<span class="line-modified">5612     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5613     switch (alternates) {
5614     case FontVariantAlternates::Normal:
5615         m_value.valueID = CSSValueNormal;
5616         break;
5617     case FontVariantAlternates::HistoricalForms:
5618         m_value.valueID = CSSValueHistoricalForms;
5619         break;
5620     default:
5621         ASSERT_NOT_REACHED();
5622         break;
5623     }
5624 }
5625 
5626 template&lt;&gt; inline CSSPrimitiveValue::operator FontVariantAlternates() const
5627 {
5628     ASSERT(isValueID());
5629     switch (m_value.valueID) {
5630     case CSSValueNormal:
5631         return FontVariantAlternates::Normal;
5632     case CSSValueHistoricalForms:
5633         return FontVariantAlternates::HistoricalForms;
5634     default:
5635         break;
5636     }
5637     ASSERT_NOT_REACHED();
5638     return FontVariantAlternates::Normal;
5639 }
5640 
5641 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontOpticalSizing sizing)
5642     : CSSValue(PrimitiveClass)
5643 {
<span class="line-modified">5644     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5645     switch (sizing) {
5646     case FontOpticalSizing::Enabled:
5647         m_value.valueID = CSSValueAuto;
5648         break;
5649     case FontOpticalSizing::Disabled:
5650         m_value.valueID = CSSValueNone;
5651         break;
5652     default:
5653         ASSERT_NOT_REACHED();
5654         break;
5655     }
5656 }
5657 
5658 template&lt;&gt; inline CSSPrimitiveValue::operator FontOpticalSizing() const
5659 {
5660     ASSERT(isValueID());
5661     switch (m_value.valueID) {
5662     case CSSValueAuto:
5663         return FontOpticalSizing::Enabled;
5664     case CSSValueNone:
5665         return FontOpticalSizing::Disabled;
5666     default:
5667         break;
5668     }
5669     ASSERT_NOT_REACHED();
5670     return FontOpticalSizing::Enabled;
5671 }
5672 
5673 template&lt;&gt; inline CSSPrimitiveValue::CSSPrimitiveValue(FontLoadingBehavior behavior)
5674     : CSSValue(PrimitiveClass)
5675 {
<span class="line-modified">5676     setPrimitiveUnitType(CSSUnitType::CSS_VALUE_ID);</span>
5677     switch (behavior) {
5678     case FontLoadingBehavior::Auto:
5679         m_value.valueID = CSSValueAuto;
5680         break;
5681     case FontLoadingBehavior::Block:
5682         m_value.valueID = CSSValueBlock;
5683         break;
5684     case FontLoadingBehavior::Swap:
5685         m_value.valueID = CSSValueSwap;
5686         break;
5687     case FontLoadingBehavior::Fallback:
5688         m_value.valueID = CSSValueFallback;
5689         break;
5690     case FontLoadingBehavior::Optional:
5691         m_value.valueID = CSSValueOptional;
5692         break;
5693     default:
5694         ASSERT_NOT_REACHED();
5695         break;
5696     }
</pre>
</td>
</tr>
</table>
<center><a href="CSSPrimitiveValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSProperties.json.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSContextRef.h&quot;
 28 #include &quot;JSContextRefInternal.h&quot;
 29 
 30 #include &quot;APICast.h&quot;
 31 #include &quot;APIUtils.h&quot;
 32 #include &quot;CallFrame.h&quot;
 33 #include &quot;InitializeThreading.h&quot;
 34 #include &quot;JSAPIGlobalObject.h&quot;
 35 #include &quot;JSCallbackObject.h&quot;
 36 #include &quot;JSClassRef.h&quot;
 37 #include &quot;JSObject.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;SourceProvider.h&quot;
 40 #include &quot;StackVisitor.h&quot;
 41 #include &quot;StrongInlines.h&quot;
 42 #include &quot;Watchdog.h&quot;
 43 #include &lt;wtf/text/StringBuilder.h&gt;
 44 #include &lt;wtf/text/StringHash.h&gt;
 45 
 46 #if ENABLE(REMOTE_INSPECTOR)
 47 #include &quot;JSGlobalObjectDebuggable.h&quot;
 48 #include &quot;JSGlobalObjectInspectorController.h&quot;
 49 #include &quot;JSRemoteInspector.h&quot;
 50 #endif
 51 
 52 #if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
 53 #include &quot;JSContextRefInspectorSupport.h&quot;
 54 #endif
 55 
 56 #if OS(DARWIN)
 57 #include &lt;mach-o/dyld.h&gt;
 58 
<a name="2" id="anc2"></a><span class="line-modified"> 59 static constexpr int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0</span>
 60 #endif
 61 
 62 using namespace JSC;
 63 
 64 // From the API&#39;s perspective, a context group remains alive iff
 65 //     (a) it has been JSContextGroupRetained
 66 //     OR
 67 //     (b) one of its contexts has been JSContextRetained
 68 
 69 JSContextGroupRef JSContextGroupCreate()
 70 {
<a name="3" id="anc3"></a>
 71     initializeThreading();
 72     return toRef(&amp;VM::createContextGroup().leakRef());
 73 }
 74 
 75 JSContextGroupRef JSContextGroupRetain(JSContextGroupRef group)
 76 {
 77     toJS(group)-&gt;ref();
 78     return group;
 79 }
 80 
 81 void JSContextGroupRelease(JSContextGroupRef group)
 82 {
 83     VM&amp; vm = *toJS(group);
 84 
 85     JSLockHolder locker(&amp;vm);
 86     vm.deref();
 87 }
 88 
<a name="4" id="anc4"></a><span class="line-modified"> 89 static bool internalScriptTimeoutCallback(JSGlobalObject* globalObject, void* callbackPtr, void* callbackData)</span>
 90 {
 91     JSShouldTerminateCallback callback = reinterpret_cast&lt;JSShouldTerminateCallback&gt;(callbackPtr);
<a name="5" id="anc5"></a><span class="line-modified"> 92     JSContextRef contextRef = toRef(globalObject);</span>
 93     ASSERT(callback);
 94     return callback(contextRef, callbackData);
 95 }
 96 
 97 void JSContextGroupSetExecutionTimeLimit(JSContextGroupRef group, double limit, JSShouldTerminateCallback callback, void* callbackData)
 98 {
 99     VM&amp; vm = *toJS(group);
100     JSLockHolder locker(&amp;vm);
101     Watchdog&amp; watchdog = vm.ensureWatchdog();
102     if (callback) {
103         void* callbackPtr = reinterpret_cast&lt;void*&gt;(callback);
104         watchdog.setTimeLimit(Seconds { limit }, internalScriptTimeoutCallback, callbackPtr, callbackData);
105     } else
106         watchdog.setTimeLimit(Seconds { limit });
107 }
108 
109 void JSContextGroupClearExecutionTimeLimit(JSContextGroupRef group)
110 {
111     VM&amp; vm = *toJS(group);
112     JSLockHolder locker(&amp;vm);
113     if (vm.watchdog())
114         vm.watchdog()-&gt;setTimeLimit(Watchdog::noTimeLimit);
115 }
116 
117 // From the API&#39;s perspective, a global context remains alive iff it has been JSGlobalContextRetained.
118 
119 JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass)
120 {
<a name="6" id="anc6"></a>
121     initializeThreading();
122 
123 #if OS(DARWIN)
124     // If the application was linked before JSGlobalContextCreate was changed to use a unique VM,
125     // we use a shared one for backwards compatibility.
126     if (NSVersionOfLinkTimeLibrary(&quot;JavaScriptCore&quot;) &lt;= webkitFirstVersionWithConcurrentGlobalContexts) {
127         return JSGlobalContextCreateInGroup(toRef(&amp;VM::sharedInstance()), globalObjectClass);
128     }
129 #endif // OS(DARWIN)
130 
131     return JSGlobalContextCreateInGroup(0, globalObjectClass);
132 }
133 
134 JSGlobalContextRef JSGlobalContextCreateInGroup(JSContextGroupRef group, JSClassRef globalObjectClass)
135 {
<a name="7" id="anc7"></a>
136     initializeThreading();
137 
138     Ref&lt;VM&gt; vm = group ? Ref&lt;VM&gt;(*toJS(group)) : VM::createContextGroup();
139 
140     JSLockHolder locker(vm.ptr());
141 
142     if (!globalObjectClass) {
143         JSGlobalObject* globalObject = JSAPIGlobalObject::create(vm.get(), JSAPIGlobalObject::createStructure(vm.get(), jsNull()));
144 #if ENABLE(REMOTE_INSPECTOR)
145         if (JSRemoteInspectorGetInspectionEnabledByDefault())
146             globalObject-&gt;setRemoteDebuggingEnabled(true);
147 #endif
<a name="8" id="anc8"></a><span class="line-modified">148         return JSGlobalContextRetain(toGlobalRef(globalObject));</span>
149     }
150 
151     JSGlobalObject* globalObject = JSCallbackObject&lt;JSGlobalObject&gt;::create(vm.get(), globalObjectClass, JSCallbackObject&lt;JSGlobalObject&gt;::createStructure(vm.get(), 0, jsNull()));
<a name="9" id="anc9"></a><span class="line-modified">152     JSValue prototype = globalObjectClass-&gt;prototype(globalObject);</span>

153     if (!prototype)
154         prototype = jsNull();
155     globalObject-&gt;resetPrototype(vm.get(), prototype);
156 #if ENABLE(REMOTE_INSPECTOR)
157     if (JSRemoteInspectorGetInspectionEnabledByDefault())
158         globalObject-&gt;setRemoteDebuggingEnabled(true);
159 #endif
<a name="10" id="anc10"></a><span class="line-modified">160     return JSGlobalContextRetain(toGlobalRef(globalObject));</span>
161 }
162 
163 JSGlobalContextRef JSGlobalContextRetain(JSGlobalContextRef ctx)
164 {
<a name="11" id="anc11"></a><span class="line-modified">165     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">166     VM&amp; vm = globalObject-&gt;vm();</span>
167     JSLockHolder locker(vm);
168 
<a name="12" id="anc12"></a><span class="line-modified">169     gcProtect(globalObject);</span>
170     vm.ref();
171     return ctx;
172 }
173 
174 void JSGlobalContextRelease(JSGlobalContextRef ctx)
175 {
<a name="13" id="anc13"></a><span class="line-modified">176     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">177     VM&amp; vm = globalObject-&gt;vm();</span>
178     JSLockHolder locker(vm);
179 
<a name="14" id="anc14"></a><span class="line-modified">180     bool protectCountIsZero = vm.heap.unprotect(globalObject);</span>
181     if (protectCountIsZero)
182         vm.heap.reportAbandonedObjectGraph();
183     vm.deref();
184 }
185 
186 JSObjectRef JSContextGetGlobalObject(JSContextRef ctx)
187 {
188     if (!ctx) {
189         ASSERT_NOT_REACHED();
190         return 0;
191     }
<a name="15" id="anc15"></a><span class="line-modified">192     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">193     VM&amp; vm = globalObject-&gt;vm();</span>
194     JSLockHolder locker(vm);
195 
<a name="16" id="anc16"></a><span class="line-modified">196     return toRef(jsCast&lt;JSObject*&gt;(globalObject-&gt;methodTable(vm)-&gt;toThis(globalObject, globalObject, NotStrictMode)));</span>
197 }
198 
199 JSContextGroupRef JSContextGetGroup(JSContextRef ctx)
200 {
201     if (!ctx) {
202         ASSERT_NOT_REACHED();
203         return 0;
204     }
<a name="17" id="anc17"></a><span class="line-modified">205     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">206     return toRef(&amp;globalObject-&gt;vm());</span>
207 }
208 
209 JSGlobalContextRef JSContextGetGlobalContext(JSContextRef ctx)
210 {
211     if (!ctx) {
212         ASSERT_NOT_REACHED();
213         return 0;
214     }
<a name="18" id="anc18"></a><span class="line-modified">215     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">216     JSLockHolder locker(globalObject);</span>
217 
<a name="19" id="anc19"></a><span class="line-modified">218     return toGlobalRef(globalObject);</span>
219 }
220 
221 JSStringRef JSGlobalContextCopyName(JSGlobalContextRef ctx)
222 {
223     if (!ctx) {
224         ASSERT_NOT_REACHED();
225         return 0;
226     }
227 
<a name="20" id="anc20"></a><span class="line-modified">228     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">229     VM&amp; vm = globalObject-&gt;vm();</span>
230     JSLockHolder locker(vm);
231 
<a name="21" id="anc21"></a><span class="line-modified">232     String name = globalObject-&gt;name();</span>
233     if (name.isNull())
234         return 0;
235 
236     return OpaqueJSString::tryCreate(name).leakRef();
237 }
238 
239 void JSGlobalContextSetName(JSGlobalContextRef ctx, JSStringRef name)
240 {
241     if (!ctx) {
242         ASSERT_NOT_REACHED();
243         return;
244     }
245 
<a name="22" id="anc22"></a><span class="line-modified">246     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">247     VM&amp; vm = globalObject-&gt;vm();</span>
248     JSLockHolder locker(vm);
249 
<a name="23" id="anc23"></a><span class="line-modified">250     globalObject-&gt;setName(name ? name-&gt;string() : String());</span>
251 }
252 
253 void JSGlobalContextSetUnhandledRejectionCallback(JSGlobalContextRef ctx, JSObjectRef function, JSValueRef* exception)
254 {
255     if (!ctx) {
256         ASSERT_NOT_REACHED();
257         return;
258     }
259 
<a name="24" id="anc24"></a><span class="line-modified">260     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">261     VM&amp; vm = globalObject-&gt;vm();</span>
262     JSLockHolder locker(vm);
263 
264     JSObject* object = toJS(function);
265     if (!object-&gt;isFunction(vm)) {
<a name="25" id="anc25"></a><span class="line-modified">266         *exception = toRef(createTypeError(globalObject));</span>
267         return;
268     }
269 
<a name="26" id="anc26"></a><span class="line-modified">270     globalObject-&gt;setUnhandledRejectionCallback(vm, object);</span>
271 }
272 
273 class BacktraceFunctor {
274 public:
275     BacktraceFunctor(StringBuilder&amp; builder, unsigned remainingCapacityForFrameCapture)
276         : m_builder(builder)
277         , m_remainingCapacityForFrameCapture(remainingCapacityForFrameCapture)
278     {
279     }
280 
281     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
282     {
283         if (m_remainingCapacityForFrameCapture) {
284             // If callee is unknown, but we&#39;ve not added any frame yet, we should
285             // still add the frame, because something called us, and gave us arguments.
286             if (visitor-&gt;callee().isCell()) {
287                 JSCell* callee = visitor-&gt;callee().asCell();
288                 if (!callee &amp;&amp; visitor-&gt;index())
289                     return StackVisitor::Done;
290             }
291 
292             StringBuilder&amp; builder = m_builder;
293             if (!builder.isEmpty())
294                 builder.append(&#39;\n&#39;);
295             builder.append(&#39;#&#39;);
296             builder.appendNumber(visitor-&gt;index());
297             builder.append(&#39; &#39;);
298             builder.append(visitor-&gt;functionName());
299             builder.appendLiteral(&quot;() at &quot;);
300             builder.append(visitor-&gt;sourceURL());
301             if (visitor-&gt;hasLineAndColumnInfo()) {
302                 builder.append(&#39;:&#39;);
303                 unsigned lineNumber;
304                 unsigned unusedColumn;
305                 visitor-&gt;computeLineAndColumn(lineNumber, unusedColumn);
306                 builder.appendNumber(lineNumber);
307             }
308 
309             if (!visitor-&gt;callee().rawPtr())
310                 return StackVisitor::Done;
311 
312             m_remainingCapacityForFrameCapture--;
313             return StackVisitor::Continue;
314         }
315         return StackVisitor::Done;
316     }
317 
318 private:
319     StringBuilder&amp; m_builder;
320     mutable unsigned m_remainingCapacityForFrameCapture;
321 };
322 
323 JSStringRef JSContextCreateBacktrace(JSContextRef ctx, unsigned maxStackSize)
324 {
325     if (!ctx) {
326         ASSERT_NOT_REACHED();
327         return 0;
328     }
<a name="27" id="anc27"></a><span class="line-modified">329     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">330     VM&amp; vm = globalObject-&gt;vm();</span>
331     JSLockHolder lock(vm);
332     StringBuilder builder;
333     CallFrame* frame = vm.topCallFrame;
334 
335     ASSERT(maxStackSize);
336     BacktraceFunctor functor(builder, maxStackSize);
<a name="28" id="anc28"></a><span class="line-modified">337     frame-&gt;iterate(vm, functor);</span>
338 
339     return OpaqueJSString::tryCreate(builder.toString()).leakRef();
340 }
341 
342 bool JSGlobalContextGetRemoteInspectionEnabled(JSGlobalContextRef ctx)
343 {
344     if (!ctx) {
345         ASSERT_NOT_REACHED();
346         return false;
347     }
348 
<a name="29" id="anc29"></a><span class="line-modified">349     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">350     VM&amp; vm = globalObject-&gt;vm();</span>
351     JSLockHolder lock(vm);
352 
<a name="30" id="anc30"></a><span class="line-modified">353     return globalObject-&gt;remoteDebuggingEnabled();</span>
354 }
355 
356 void JSGlobalContextSetRemoteInspectionEnabled(JSGlobalContextRef ctx, bool enabled)
357 {
358     if (!ctx) {
359         ASSERT_NOT_REACHED();
360         return;
361     }
362 
<a name="31" id="anc31"></a><span class="line-modified">363     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">364     VM&amp; vm = globalObject-&gt;vm();</span>
365     JSLockHolder lock(vm);
366 
<a name="32" id="anc32"></a><span class="line-modified">367     globalObject-&gt;setRemoteDebuggingEnabled(enabled);</span>
368 }
369 
370 bool JSGlobalContextGetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx)
371 {
372 #if ENABLE(REMOTE_INSPECTOR)
373     if (!ctx) {
374         ASSERT_NOT_REACHED();
375         return false;
376     }
377 
<a name="33" id="anc33"></a><span class="line-modified">378     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">379     VM&amp; vm = globalObject-&gt;vm();</span>
380     JSLockHolder lock(vm);
381 
<a name="34" id="anc34"></a>
382     return globalObject-&gt;inspectorController().includesNativeCallStackWhenReportingExceptions();
383 #else
384     UNUSED_PARAM(ctx);
385     return false;
386 #endif
387 }
388 
389 void JSGlobalContextSetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx, bool includesNativeCallStack)
390 {
391 #if ENABLE(REMOTE_INSPECTOR)
392     if (!ctx) {
393         ASSERT_NOT_REACHED();
394         return;
395     }
396 
<a name="35" id="anc35"></a><span class="line-modified">397     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">398     VM&amp; vm = globalObject-&gt;vm();</span>
399     JSLockHolder lock(vm);
400 
<a name="36" id="anc36"></a>
401     globalObject-&gt;inspectorController().setIncludesNativeCallStackWhenReportingExceptions(includesNativeCallStack);
402 #else
403     UNUSED_PARAM(ctx);
404     UNUSED_PARAM(includesNativeCallStack);
405 #endif
406 }
407 
408 #if USE(CF)
409 CFRunLoopRef JSGlobalContextGetDebuggerRunLoop(JSGlobalContextRef ctx)
410 {
411 #if ENABLE(REMOTE_INSPECTOR)
412     if (!ctx) {
413         ASSERT_NOT_REACHED();
414         return nullptr;
415     }
416 
<a name="37" id="anc37"></a><span class="line-modified">417     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">418     VM&amp; vm = globalObject-&gt;vm();</span>
419     JSLockHolder lock(vm);
420 
<a name="38" id="anc38"></a><span class="line-modified">421     return globalObject-&gt;inspectorDebuggable().targetRunLoop();</span>
422 #else
423     UNUSED_PARAM(ctx);
424     return nullptr;
425 #endif
426 }
427 
428 void JSGlobalContextSetDebuggerRunLoop(JSGlobalContextRef ctx, CFRunLoopRef runLoop)
429 {
430 #if ENABLE(REMOTE_INSPECTOR)
431     if (!ctx) {
432         ASSERT_NOT_REACHED();
433         return;
434     }
435 
<a name="39" id="anc39"></a><span class="line-modified">436     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">437     VM&amp; vm = globalObject-&gt;vm();</span>
438     JSLockHolder lock(vm);
439 
<a name="40" id="anc40"></a><span class="line-modified">440     globalObject-&gt;inspectorDebuggable().setTargetRunLoop(runLoop);</span>
441 #else
442     UNUSED_PARAM(ctx);
443     UNUSED_PARAM(runLoop);
444 #endif
445 }
446 #endif // USE(CF)
447 
448 #if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
449 Inspector::AugmentableInspectorController* JSGlobalContextGetAugmentableInspectorController(JSGlobalContextRef ctx)
450 {
451     if (!ctx) {
452         ASSERT_NOT_REACHED();
453         return nullptr;
454     }
455 
<a name="41" id="anc41"></a><span class="line-modified">456     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">457     VM&amp; vm = globalObject-&gt;vm();</span>
458     JSLockHolder lock(vm);
459 
<a name="42" id="anc42"></a><span class="line-modified">460     return &amp;globalObject-&gt;inspectorController();</span>
461 }
462 #endif
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp
@@ -39,14 +39,10 @@
 #include <wtf/MathExtras.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/text/AtomStringHash.h>
 #include <wtf/text/StringBuilder.h>
 
-#if PLATFORM(WIN)
-#include "UniscribeController.h"
-#endif
-
 namespace WebCore {
 
 using namespace WTF::Unicode;
 
 static bool useBackslashAsYenSignForFamily(const AtomString& family)
@@ -267,37 +263,49 @@
     if (fontCascadeCache().size() > maximumEntries)
         fontCascadeCache().remove(fontCascadeCache().random());
     return glyphs;
 }
 
+bool FontCascade::isCurrent(const FontSelector& fontSelector) const
+{
+    if (!m_fonts)
+        return false;
+    if (m_fonts->generation() != FontCache::singleton().generation())
+        return false;
+    if (m_fonts->fontSelectorVersion() != fontSelector.version())
+        return false;
+
+    return true;
+}
+
 void FontCascade::update(RefPtr<FontSelector>&& fontSelector) const
 {
     m_fonts = retrieveOrAddCachedFonts(m_fontDescription, WTFMove(fontSelector));
     m_useBackslashAsYenSymbol = useBackslashAsYenSignForFamily(firstFamily());
     m_enableKerning = computeEnableKerning();
     m_requiresShaping = computeRequiresShaping();
 }
 
-float FontCascade::glyphBufferForTextRun(CodePath codePathToUse, const TextRun& run, unsigned from, unsigned to, GlyphBuffer& glyphBuffer) const
+FloatSize FontCascade::glyphBufferForTextRun(CodePath codePathToUse, const TextRun& run, unsigned from, unsigned to, GlyphBuffer& glyphBuffer) const
 {
     if (codePathToUse != Complex)
-        return getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer);
+        return { getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer), 0 };
     return getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer);
 }
 
 float FontCascade::drawText(GraphicsContext& context, const TextRun& run, const FloatPoint& point, unsigned from, Optional<unsigned> to, CustomFontNotReadyAction customFontNotReadyAction) const
 {
     unsigned destination = to.valueOr(run.length());
     GlyphBuffer glyphBuffer;
-    float startX = point.x() + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);
+    FloatPoint startPoint = point + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);
     // We couldn't generate any glyphs for the run. Give up.
     if (glyphBuffer.isEmpty())
         return 0;
     // Draw the glyph buffer now at the starting point returned in startX.
-    FloatPoint startPoint(startX, point.y());
+    float oldStartX = startPoint.x();
     drawGlyphBuffer(context, glyphBuffer, startPoint, customFontNotReadyAction);
-    return startPoint.x() - startX;
+    return startPoint.x() - oldStartX;
 }
 
 void FontCascade::drawEmphasisMarks(GraphicsContext& context, const TextRun& run, const AtomString& mark, const FloatPoint& point, unsigned from, Optional<unsigned> to) const
 {
     if (isLoadingCustomFonts())
@@ -319,21 +327,20 @@
     CodePath codePathToUse = codePath(run);
     if (codePathToUse != Complex && (enableKerning() || requiresShaping()) && (from || destination != run.length()))
         codePathToUse = Complex;
 
     GlyphBuffer glyphBuffer;
-    float startX = glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer);
+    FloatPoint startPoint = toFloatPoint(glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer));
     // We couldn't generate any glyphs for the run. Give up.
     if (glyphBuffer.isEmpty())
         return nullptr;
 
     std::unique_ptr<DisplayList::DisplayList> displayList = makeUnique<DisplayList::DisplayList>();
     GraphicsContext recordingContext([&](GraphicsContext& displayListContext) {
         return makeUnique<DisplayList::Recorder>(displayListContext, *displayList, context.state(), FloatRect(), AffineTransform());
     });
 
-    FloatPoint startPoint(startX, 0);
     drawGlyphBuffer(recordingContext, glyphBuffer, startPoint, customFontNotReadyAction);
     return displayList;
 }
 
 float FontCascade::widthOfTextRange(const TextRun& run, unsigned from, unsigned to, HashSet<const Font*>* fallbackFonts, float* outWidthBeforeRange, float* outWidthAfterRange) const
@@ -348,27 +355,17 @@
     float offsetAfterRange = 0;
     float totalWidth = 0;
 
     auto codePathToUse = codePath(run);
     if (codePathToUse == Complex) {
-#if PLATFORM(WIN)
-        UniscribeController it(this, run);
-        it.advance(from);
-        offsetBeforeRange = it.runWidthSoFar();
-        it.advance(to);
-        offsetAfterRange = it.runWidthSoFar();
-        it.advance(to);
-        totalWidth = it.runWidthSoFar();
-#else
         ComplexTextController complexIterator(*this, run, false, fallbackFonts);
         complexIterator.advance(from, nullptr, IncludePartialGlyphs, fallbackFonts);
         offsetBeforeRange = complexIterator.runWidthSoFar();
         complexIterator.advance(to, nullptr, IncludePartialGlyphs, fallbackFonts);
         offsetAfterRange = complexIterator.runWidthSoFar();
         complexIterator.advance(run.length(), nullptr, IncludePartialGlyphs, fallbackFonts);
         totalWidth = complexIterator.runWidthSoFar();
-#endif
     } else {
         WidthIterator simpleIterator(this, run, fallbackFonts);
         simpleIterator.advance(from, nullptr);
         offsetBeforeRange = simpleIterator.runWidthSoFar();
         simpleIterator.advance(to, nullptr);
@@ -428,10 +425,11 @@
     ASSERT(codePath(TextRun(text)) != FontCascade::Complex);
     float* cacheEntry = m_fonts->widthCache().add(text, std::numeric_limits<float>::quiet_NaN());
     if (cacheEntry && !std::isnan(*cacheEntry))
         return *cacheEntry;
 
+    GlyphBuffer glyphBuffer;
     Vector<GlyphBufferGlyph, 16> glyphs;
     Vector<GlyphBufferAdvance, 16> advances;
     bool hasKerningOrLigatures = enableKerning() || requiresShaping();
     float runWidth = 0;
     auto& font = primaryFont();
@@ -439,20 +437,19 @@
         auto glyph = glyphDataForCharacter(text[i], false).glyph;
         auto glyphWidth = font.widthForGlyph(glyph);
         runWidth += glyphWidth;
         if (!hasKerningOrLigatures)
             continue;
-        glyphs.append(glyph);
-        advances.append(FloatSize(glyphWidth, 0));
+        glyphBuffer.add(glyph, &font, glyphWidth);
     }
     if (hasKerningOrLigatures) {
-        font.applyTransforms(&glyphs[0], &advances[0], glyphs.size(), enableKerning(), requiresShaping());
+        font.applyTransforms(glyphBuffer, 0, enableKerning(), requiresShaping(), fontDescription().locale());
         // This is needed only to match the result of the slow path. Same glyph widths but different floating point arithmentics can
         // produce different run width.
         float runWidthDifferenceWithTransformApplied = -runWidth;
-        for (auto& advance : advances)
-            runWidthDifferenceWithTransformApplied += advance.width();
+        for (size_t i = 0; i < glyphBuffer.size(); ++i)
+            runWidthDifferenceWithTransformApplied += glyphBuffer.advanceAt(i).width();
         runWidth += runWidthDifferenceWithTransformApplied;
     }
 
     if (cacheEntry)
         *cacheEntry = runWidth;
@@ -1395,41 +1392,39 @@
         glyphBuffer.reverse(0, glyphBuffer.size());
 
     return initialAdvance;
 }
 
-#if !PLATFORM(WIN)
-float FontCascade::getGlyphsAndAdvancesForComplexText(const TextRun& run, unsigned from, unsigned to, GlyphBuffer& glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const
+FloatSize FontCascade::getGlyphsAndAdvancesForComplexText(const TextRun& run, unsigned from, unsigned to, GlyphBuffer& glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const
 {
-    float initialAdvance;
+    FloatSize initialAdvance;
 
     ComplexTextController controller(*this, run, false, 0, forTextEmphasis);
     GlyphBuffer dummyGlyphBuffer;
     controller.advance(from, &dummyGlyphBuffer);
     controller.advance(to, &glyphBuffer);
 
     if (glyphBuffer.isEmpty())
-        return 0;
+        return { };
 
     if (run.rtl()) {
         // Exploit the fact that the sum of the paint advances is equal to
         // the sum of the layout advances.
-        initialAdvance = controller.totalWidth();
+        initialAdvance = controller.totalAdvance();
         for (unsigned i = 0; i < dummyGlyphBuffer.size(); ++i)
-            initialAdvance -= dummyGlyphBuffer.advanceAt(i).width();
+            initialAdvance -= toFloatSize(dummyGlyphBuffer.advanceAt(i));
         for (unsigned i = 0; i < glyphBuffer.size(); ++i)
-            initialAdvance -= glyphBuffer.advanceAt(i).width();
+            initialAdvance -= toFloatSize(glyphBuffer.advanceAt(i));
         glyphBuffer.reverse(0, glyphBuffer.size());
     } else {
-        initialAdvance = dummyGlyphBuffer.initialAdvance().width();
+        initialAdvance = toFloatSize(dummyGlyphBuffer.initialAdvance());
         for (unsigned i = 0; i < dummyGlyphBuffer.size(); ++i)
-            initialAdvance += dummyGlyphBuffer.advanceAt(i).width();
+            initialAdvance += toFloatSize(dummyGlyphBuffer.advanceAt(i));
     }
 
     return initialAdvance;
 }
-#endif
 
 void FontCascade::drawEmphasisMarksForSimpleText(GraphicsContext& context, const TextRun& run, const AtomString& mark, const FloatPoint& point, unsigned from, unsigned to) const
 {
     GlyphBuffer glyphBuffer;
     float initialAdvance = getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer, ForTextEmphasis);
@@ -1450,17 +1445,11 @@
 
 void FontCascade::drawGlyphBuffer(GraphicsContext& context, const GlyphBuffer& glyphBuffer, FloatPoint& point, CustomFontNotReadyAction customFontNotReadyAction) const
 {
     // Draw each contiguous run of glyphs that use the same font data.
     const Font* fontData = glyphBuffer.fontAt(0);
-#if PLATFORM(WIN)
-    FloatPoint startPoint(point.x() + glyphBuffer.initialAdvance().width(), point.y() + glyphBuffer.initialAdvance().height());
-#else
-    // FIXME: Why do we subtract the initial advance's height but not its width???
-    // We should use the line above from Windows instead.
-    FloatPoint startPoint(point.x(), point.y() - glyphBuffer.initialAdvance().height());
-#endif
+    FloatPoint startPoint = point;
     float nextX = startPoint.x() + glyphBuffer.advanceAt(0).width();
     float nextY = startPoint.y() + glyphBuffer.advanceAt(0).height();
     unsigned lastFrom = 0;
     unsigned nextGlyph = 1;
     while (nextGlyph < glyphBuffer.size()) {
@@ -1543,23 +1532,21 @@
     }
 
     return it.m_runWidthSoFar;
 }
 
-#if !PLATFORM(WIN)
 float FontCascade::floatWidthForComplexText(const TextRun& run, HashSet<const Font*>* fallbackFonts, GlyphOverflow* glyphOverflow) const
 {
     ComplexTextController controller(*this, run, true, fallbackFonts);
     if (glyphOverflow) {
         glyphOverflow->top = std::max<int>(glyphOverflow->top, ceilf(-controller.minGlyphBoundingBoxY()) - (glyphOverflow->computeBounds ? 0 : fontMetrics().ascent()));
         glyphOverflow->bottom = std::max<int>(glyphOverflow->bottom, ceilf(controller.maxGlyphBoundingBoxY()) - (glyphOverflow->computeBounds ? 0 : fontMetrics().descent()));
         glyphOverflow->left = std::max<int>(0, ceilf(-controller.minGlyphBoundingBoxX()));
-        glyphOverflow->right = std::max<int>(0, ceilf(controller.maxGlyphBoundingBoxX() - controller.totalWidth()));
+        glyphOverflow->right = std::max<int>(0, ceilf(controller.maxGlyphBoundingBoxX() - controller.totalAdvance().width()));
     }
-    return controller.totalWidth();
+    return controller.totalAdvance().width();
 }
-#endif
 
 void FontCascade::adjustSelectionRectForSimpleText(const TextRun& run, LayoutRect& selectionRect, unsigned from, unsigned to) const
 {
     GlyphBuffer glyphBuffer;
     WidthIterator it(this, run);
@@ -1576,26 +1563,24 @@
     } else
         selectionRect.move(beforeWidth, 0);
     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
 }
 
-#if !PLATFORM(WIN)
 void FontCascade::adjustSelectionRectForComplexText(const TextRun& run, LayoutRect& selectionRect, unsigned from, unsigned to) const
 {
     ComplexTextController controller(*this, run);
     controller.advance(from);
     float beforeWidth = controller.runWidthSoFar();
     controller.advance(to);
     float afterWidth = controller.runWidthSoFar();
 
     if (run.rtl())
-        selectionRect.move(controller.totalWidth() - afterWidth, 0);
+        selectionRect.move(controller.totalAdvance().width() - afterWidth, 0);
     else
         selectionRect.move(beforeWidth, 0);
     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
 }
-#endif
 
 int FontCascade::offsetForPositionForSimpleText(const TextRun& run, float x, bool includePartialGlyphs) const
 {
     float delta = x;
 
@@ -1636,17 +1621,15 @@
     }
 
     return offset;
 }
 
-#if !PLATFORM(WIN)
 int FontCascade::offsetForPositionForComplexText(const TextRun& run, float x, bool includePartialGlyphs) const
 {
     ComplexTextController controller(*this, run);
     return controller.offsetForPosition(x, includePartialGlyphs);
 }
-#endif
 
 #if !PLATFORM(COCOA) && !USE(HARFBUZZ)
 // FIXME: Unify this with the macOS and iOS implementation.
 const Font* FontCascade::fontForCombiningCharacterSequence(const UChar* characters, size_t length) const
 {
@@ -1662,16 +1645,16 @@
 #endif
 
 void FontCascade::drawEmphasisMarksForComplexText(GraphicsContext& context, const TextRun& run, const AtomString& mark, const FloatPoint& point, unsigned from, unsigned to) const
 {
     GlyphBuffer glyphBuffer;
-    float initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);
+    auto initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);
 
     if (glyphBuffer.isEmpty())
         return;
 
-    drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
+    drawEmphasisMarks(context, glyphBuffer, mark, point + initialAdvance);
 }
 
 struct GlyphIterationState {
     FloatPoint startingPoint;
     FloatPoint currentPoint;
@@ -1704,27 +1687,27 @@
 static void findPathIntersections(GlyphIterationState& state, const PathElement& element)
 {
     bool doIntersection = false;
     FloatPoint point = FloatPoint();
     switch (element.type) {
-    case PathElementMoveToPoint:
+    case PathElement::Type::MoveToPoint:
         state.startingPoint = element.points[0];
         state.currentPoint = element.points[0];
         break;
-    case PathElementAddLineToPoint:
+    case PathElement::Type::AddLineToPoint:
         doIntersection = true;
         point = element.points[0];
         break;
-    case PathElementAddQuadCurveToPoint:
+    case PathElement::Type::AddQuadCurveToPoint:
         doIntersection = true;
         point = element.points[1];
         break;
-    case PathElementAddCurveToPoint:
+    case PathElement::Type::AddCurveToPoint:
         doIntersection = true;
         point = element.points[2];
         break;
-    case PathElementCloseSubpath:
+    case PathElement::Type::CloseSubpath:
         doIntersection = true;
         point = state.startingPoint;
         break;
     }
     if (!doIntersection)
@@ -1805,11 +1788,11 @@
     glyphBuffer.saveOffsetsInString();
     float deltaX;
     if (codePath(run) != FontCascade::Complex)
         deltaX = getGlyphsAndAdvancesForSimpleText(run, 0, run.length(), glyphBuffer);
     else
-        deltaX = getGlyphsAndAdvancesForComplexText(run, 0, run.length(), glyphBuffer);
+        deltaX = getGlyphsAndAdvancesForComplexText(run, 0, run.length(), glyphBuffer).width();
 
     if (!glyphBuffer.size())
         return DashArray();
 
     FloatPoint origin = FloatPoint(textOrigin.x() + deltaX, textOrigin.y());

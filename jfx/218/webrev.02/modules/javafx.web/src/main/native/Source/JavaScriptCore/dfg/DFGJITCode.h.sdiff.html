<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGJITCode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCompiler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 #include &quot;ExecutionCounter.h&quot;
 38 #include &quot;JITCode.h&quot;
 39 #include &lt;wtf/SegmentedVector.h&gt;
 40 
 41 namespace JSC {
 42 
 43 class TrackedReferences;
 44 
 45 namespace DFG {
 46 
 47 class JITCompiler;
 48 
 49 class JITCode : public DirectJITCode {
 50 public:
 51     JITCode();
 52     virtual ~JITCode();
 53 
 54     CommonData* dfgCommon() override;
 55     JITCode* dfg() override;
 56 
<span class="line-modified"> 57     OSREntryData* appendOSREntryData(unsigned bytecodeIndex, CodeLocationLabel&lt;OSREntryPtrTag&gt; machineCode)</span>
 58     {
 59         DFG::OSREntryData entry;
 60         entry.m_bytecodeIndex = bytecodeIndex;
 61         entry.m_machineCode = machineCode;
 62         osrEntry.append(entry);
 63         return &amp;osrEntry.last();
 64     }
 65 
<span class="line-modified"> 66     OSREntryData* osrEntryDataForBytecodeIndex(unsigned bytecodeIndex)</span>
 67     {
<span class="line-modified"> 68         return tryBinarySearch&lt;OSREntryData, unsigned&gt;(</span>
 69             osrEntry, osrEntry.size(), bytecodeIndex,
 70             getOSREntryDataBytecodeIndex);
 71     }
 72 
 73     void finalizeOSREntrypoints();
 74 
 75     unsigned appendOSRExit(const OSRExit&amp; exit)
 76     {
 77         unsigned result = osrExit.size();
 78         osrExit.append(exit);
 79         return result;
 80     }
 81 
 82     OSRExit&amp; lastOSRExit()
 83     {
 84         return osrExit.last();
 85     }
 86 
 87     unsigned appendSpeculationRecovery(const SpeculationRecovery&amp; recovery)
 88     {
 89         unsigned result = speculationRecovery.size();
 90         speculationRecovery.append(recovery);
 91         return result;
 92     }
 93 
 94     void reconstruct(
 95         CodeBlock*, CodeOrigin, unsigned streamIndex, Operands&lt;ValueRecovery&gt;&amp; result);
 96 
 97     // This is only applicable if we&#39;re at a point where all values are spilled to the
 98     // stack. Currently, it also has the restriction that the values must be in their
 99     // bytecode-designated stack slots.
100     void reconstruct(
<span class="line-modified">101         ExecState*, CodeBlock*, CodeOrigin, unsigned streamIndex, Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; result);</span>
102 
103 #if ENABLE(FTL_JIT)
104     // NB. All of these methods take CodeBlock* because they may want to use
105     // CodeBlock&#39;s logic about scaling thresholds. It should be a DFG CodeBlock.
106 
107     bool checkIfOptimizationThresholdReached(CodeBlock*);
108     void optimizeNextInvocation(CodeBlock*);
109     void dontOptimizeAnytimeSoon(CodeBlock*);
110     void optimizeAfterWarmUp(CodeBlock*);
111     void optimizeSoon(CodeBlock*);
112     void forceOptimizationSlowPathConcurrently(CodeBlock*);
113     void setOptimizationThresholdBasedOnCompilationResult(CodeBlock*, CompilationResult);
114 #endif // ENABLE(FTL_JIT)
115 
116     void validateReferences(const TrackedReferences&amp;) override;
117 
<span class="line-modified">118     void shrinkToFit();</span>
119 
120     RegisterSet liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock*, CallSiteIndex) override;
121 #if ENABLE(FTL_JIT)
122     CodeBlock* osrEntryBlock() { return m_osrEntryBlock.get(); }
123     void setOSREntryBlock(VM&amp;, const JSCell* owner, CodeBlock* osrEntryBlock);
124     void clearOSREntryBlockAndResetThresholds(CodeBlock* dfgCodeBlock);
125 #endif
126 
127     static ptrdiff_t commonDataOffset() { return OBJECT_OFFSETOF(JITCode, common); }
128 
129     Optional&lt;CodeOrigin&gt; findPC(CodeBlock*, void* pc) override;
130 
131     using DirectJITCode::initializeCodeRefForDFG;
132 
133 private:
134     friend class JITCompiler; // Allow JITCompiler to call setCodeRef().
135 
136 public:
137     CommonData common;
138     Vector&lt;DFG::OSREntryData&gt; osrEntry;
139     SegmentedVector&lt;DFG::OSRExit, 8&gt; osrExit;
140     Vector&lt;DFG::SpeculationRecovery&gt; speculationRecovery;
141     DFG::VariableEventStream variableEventStream;
142     DFG::MinifiedGraph minifiedDFG;
143 
144 #if ENABLE(FTL_JIT)
145     uint8_t neverExecutedEntry { 1 };
146 
147     UpperTierExecutionCounter tierUpCounter;
148 
149     // For osrEntryPoint that are in inner loop, this maps their bytecode to the bytecode
150     // of the outerloop entry points in order (from innermost to outermost).
151     //
152     // The key may not always be a target for OSR Entry but the list in the value is guaranteed
153     // to be usable for OSR Entry.
<span class="line-modified">154     HashMap&lt;unsigned, Vector&lt;unsigned&gt;&gt; tierUpInLoopHierarchy;</span>
155 
156     // Map each bytecode of CheckTierUpAndOSREnter to its stream index.
<span class="line-modified">157     HashMap&lt;unsigned, unsigned, WTF::IntHash&lt;unsigned&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; bytecodeIndexToStreamIndex;</span>
158 
159     enum class TriggerReason : uint8_t {
160         DontTrigger,
161         CompilationDone,
162         StartCompilation,
163     };
164 
165     // Map each bytecode of CheckTierUpAndOSREnter to its trigger forcing OSR Entry.
166     // This can never be modified after it has been initialized since the addresses of the triggers
167     // are used by the JIT.
<span class="line-modified">168     HashMap&lt;unsigned, TriggerReason&gt; tierUpEntryTriggers;</span>
169 
170     WriteBarrier&lt;CodeBlock&gt; m_osrEntryBlock;
171     unsigned osrEntryRetry;
172     bool abandonOSREntry;
173 #endif // ENABLE(FTL_JIT)
174 };
175 
176 } } // namespace JSC::DFG
177 
178 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
 37 #include &quot;ExecutionCounter.h&quot;
 38 #include &quot;JITCode.h&quot;
 39 #include &lt;wtf/SegmentedVector.h&gt;
 40 
 41 namespace JSC {
 42 
 43 class TrackedReferences;
 44 
 45 namespace DFG {
 46 
 47 class JITCompiler;
 48 
 49 class JITCode : public DirectJITCode {
 50 public:
 51     JITCode();
 52     virtual ~JITCode();
 53 
 54     CommonData* dfgCommon() override;
 55     JITCode* dfg() override;
 56 
<span class="line-modified"> 57     OSREntryData* appendOSREntryData(BytecodeIndex bytecodeIndex, CodeLocationLabel&lt;OSREntryPtrTag&gt; machineCode)</span>
 58     {
 59         DFG::OSREntryData entry;
 60         entry.m_bytecodeIndex = bytecodeIndex;
 61         entry.m_machineCode = machineCode;
 62         osrEntry.append(entry);
 63         return &amp;osrEntry.last();
 64     }
 65 
<span class="line-modified"> 66     OSREntryData* osrEntryDataForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
 67     {
<span class="line-modified"> 68         return tryBinarySearch&lt;OSREntryData, BytecodeIndex&gt;(</span>
 69             osrEntry, osrEntry.size(), bytecodeIndex,
 70             getOSREntryDataBytecodeIndex);
 71     }
 72 
 73     void finalizeOSREntrypoints();
 74 
 75     unsigned appendOSRExit(const OSRExit&amp; exit)
 76     {
 77         unsigned result = osrExit.size();
 78         osrExit.append(exit);
 79         return result;
 80     }
 81 
 82     OSRExit&amp; lastOSRExit()
 83     {
 84         return osrExit.last();
 85     }
 86 
 87     unsigned appendSpeculationRecovery(const SpeculationRecovery&amp; recovery)
 88     {
 89         unsigned result = speculationRecovery.size();
 90         speculationRecovery.append(recovery);
 91         return result;
 92     }
 93 
 94     void reconstruct(
 95         CodeBlock*, CodeOrigin, unsigned streamIndex, Operands&lt;ValueRecovery&gt;&amp; result);
 96 
 97     // This is only applicable if we&#39;re at a point where all values are spilled to the
 98     // stack. Currently, it also has the restriction that the values must be in their
 99     // bytecode-designated stack slots.
100     void reconstruct(
<span class="line-modified">101         CallFrame*, CodeBlock*, CodeOrigin, unsigned streamIndex, Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; result);</span>
102 
103 #if ENABLE(FTL_JIT)
104     // NB. All of these methods take CodeBlock* because they may want to use
105     // CodeBlock&#39;s logic about scaling thresholds. It should be a DFG CodeBlock.
106 
107     bool checkIfOptimizationThresholdReached(CodeBlock*);
108     void optimizeNextInvocation(CodeBlock*);
109     void dontOptimizeAnytimeSoon(CodeBlock*);
110     void optimizeAfterWarmUp(CodeBlock*);
111     void optimizeSoon(CodeBlock*);
112     void forceOptimizationSlowPathConcurrently(CodeBlock*);
113     void setOptimizationThresholdBasedOnCompilationResult(CodeBlock*, CompilationResult);
114 #endif // ENABLE(FTL_JIT)
115 
116     void validateReferences(const TrackedReferences&amp;) override;
117 
<span class="line-modified">118     void shrinkToFit(const ConcurrentJSLocker&amp;) override;</span>
119 
120     RegisterSet liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock*, CallSiteIndex) override;
121 #if ENABLE(FTL_JIT)
122     CodeBlock* osrEntryBlock() { return m_osrEntryBlock.get(); }
123     void setOSREntryBlock(VM&amp;, const JSCell* owner, CodeBlock* osrEntryBlock);
124     void clearOSREntryBlockAndResetThresholds(CodeBlock* dfgCodeBlock);
125 #endif
126 
127     static ptrdiff_t commonDataOffset() { return OBJECT_OFFSETOF(JITCode, common); }
128 
129     Optional&lt;CodeOrigin&gt; findPC(CodeBlock*, void* pc) override;
130 
131     using DirectJITCode::initializeCodeRefForDFG;
132 
133 private:
134     friend class JITCompiler; // Allow JITCompiler to call setCodeRef().
135 
136 public:
137     CommonData common;
138     Vector&lt;DFG::OSREntryData&gt; osrEntry;
139     SegmentedVector&lt;DFG::OSRExit, 8&gt; osrExit;
140     Vector&lt;DFG::SpeculationRecovery&gt; speculationRecovery;
141     DFG::VariableEventStream variableEventStream;
142     DFG::MinifiedGraph minifiedDFG;
143 
144 #if ENABLE(FTL_JIT)
145     uint8_t neverExecutedEntry { 1 };
146 
147     UpperTierExecutionCounter tierUpCounter;
148 
149     // For osrEntryPoint that are in inner loop, this maps their bytecode to the bytecode
150     // of the outerloop entry points in order (from innermost to outermost).
151     //
152     // The key may not always be a target for OSR Entry but the list in the value is guaranteed
153     // to be usable for OSR Entry.
<span class="line-modified">154     HashMap&lt;BytecodeIndex, Vector&lt;BytecodeIndex&gt;&gt; tierUpInLoopHierarchy;</span>
155 
156     // Map each bytecode of CheckTierUpAndOSREnter to its stream index.
<span class="line-modified">157     HashMap&lt;BytecodeIndex, unsigned&gt; bytecodeIndexToStreamIndex;</span>
158 
159     enum class TriggerReason : uint8_t {
160         DontTrigger,
161         CompilationDone,
162         StartCompilation,
163     };
164 
165     // Map each bytecode of CheckTierUpAndOSREnter to its trigger forcing OSR Entry.
166     // This can never be modified after it has been initialized since the addresses of the triggers
167     // are used by the JIT.
<span class="line-modified">168     HashMap&lt;BytecodeIndex, TriggerReason&gt; tierUpEntryTriggers;</span>
169 
170     WriteBarrier&lt;CodeBlock&gt; m_osrEntryBlock;
171     unsigned osrEntryRetry;
172     bool abandonOSREntry;
173 #endif // ENABLE(FTL_JIT)
174 };
175 
176 } } // namespace JSC::DFG
177 
178 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGJITCode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCompiler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
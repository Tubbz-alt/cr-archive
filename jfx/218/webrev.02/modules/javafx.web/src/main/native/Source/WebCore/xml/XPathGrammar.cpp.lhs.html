<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/xml/XPathGrammar.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* This file is generated using the following command:
   2    bison -d -p xpathyy XPathGrammar.y -o XPathGrammar.cpp
   3  */
   4 
   5 /* A Bison parser, made by GNU Bison 2.3.  */
   6 
   7 /* Skeleton implementation for Bison&#39;s Yacc-like parsers in C
   8 
   9    Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
  10    Free Software Foundation, Inc.
  11 
  12    This program is free software; you can redistribute it and/or modify
  13    it under the terms of the GNU General Public License as published by
  14    the Free Software Foundation; either version 2, or (at your option)
  15    any later version.
  16 
  17    This program is distributed in the hope that it will be useful,
  18    but WITHOUT ANY WARRANTY; without even the implied warranty of
  19    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  20    GNU General Public License for more details.
  21 
  22    You should have received a copy of the GNU General Public License
  23    along with this program; if not, write to the Free Software
  24    Foundation, Inc., 51 Franklin Street, Fifth Floor,
  25    Boston, MA 02110-1301, USA.  */
  26 
  27 /* As a special exception, you may create a larger work that contains
  28    part or all of the Bison parser skeleton and distribute that work
  29    under terms of your choice, so long as that work isn&#39;t itself a
  30    parser generator using the skeleton or a modified version thereof
  31    as a parser skeleton.  Alternatively, if you modify or redistribute
  32    the parser skeleton itself, you may (at your option) remove this
  33    special exception, which will cause the skeleton and the resulting
  34    Bison output files to be licensed under the GNU General Public
  35    License without this special exception.
  36 
  37    This special exception was added by the Free Software Foundation in
  38    version 2.2 of Bison.  */
  39 
  40 /* C LALR(1) parser skeleton written by Richard Stallman, by
  41    simplifying the original so-called &quot;semantic&quot; parser.  */
  42 
  43 /* All symbols defined below should begin with yy or YY, to avoid
  44    infringing on user name space.  This should be done even for local
  45    variables, as they might otherwise be expanded by user macros.
  46    There are some unavoidable exceptions within include files to
  47    define necessary library symbols; they are noted &quot;INFRINGES ON
  48    USER NAME SPACE&quot; below.  */
  49 
  50 /* Identify Bison output.  */
  51 #define YYBISON 1
  52 
  53 /* Bison version.  */
  54 #define YYBISON_VERSION &quot;2.3&quot;
  55 
  56 /* Skeleton name.  */
  57 #define YYSKELETON_NAME &quot;yacc.c&quot;
  58 
  59 /* Pure parsers.  */
  60 #define YYPURE 1
  61 
  62 /* Using locations.  */
  63 #define YYLSP_NEEDED 0
  64 
  65 /* Substitute the variable and function names.  */
  66 #define yyparse xpathyyparse
  67 #define yylex   xpathyylex
  68 #define yyerror xpathyyerror
  69 #define yylval  xpathyylval
  70 #define yychar  xpathyychar
  71 #define yydebug xpathyydebug
  72 #define yynerrs xpathyynerrs
  73 
  74 
  75 /* Tokens.  */
  76 #ifndef YYTOKENTYPE
  77 # define YYTOKENTYPE
  78    /* Put the tokens into the symbol table, so that GDB and other debuggers
  79       know about them.  */
  80    enum yytokentype {
  81      MULOP = 258,
  82      RELOP = 259,
  83      EQOP = 260,
  84      MINUS = 261,
  85      PLUS = 262,
  86      AND = 263,
  87      OR = 264,
  88      FUNCTIONNAME = 265,
  89      LITERAL = 266,
  90      NAMETEST = 267,
  91      NUMBER = 268,
  92      NODETYPE = 269,
  93      VARIABLEREFERENCE = 270,
  94      AXISNAME = 271,
  95      COMMENT = 272,
  96      DOTDOT = 273,
  97      PI = 274,
  98      NODE = 275,
  99      SLASHSLASH = 276,
 100      TEXT_ = 277,
 101      XPATH_ERROR = 278
 102    };
 103 #endif
 104 /* Tokens.  */
 105 #define MULOP 258
 106 #define RELOP 259
 107 #define EQOP 260
 108 #define MINUS 261
 109 #define PLUS 262
 110 #define AND 263
 111 #define OR 264
 112 #define FUNCTIONNAME 265
 113 #define LITERAL 266
 114 #define NAMETEST 267
 115 #define NUMBER 268
 116 #define NODETYPE 269
 117 #define VARIABLEREFERENCE 270
 118 #define AXISNAME 271
 119 #define COMMENT 272
 120 #define DOTDOT 273
 121 #define PI 274
 122 #define NODE 275
 123 #define SLASHSLASH 276
 124 #define TEXT_ 277
 125 #define XPATH_ERROR 278
 126 
 127 
 128 
 129 /* Copy the first part of user declarations.  */
 130 #line 28 &quot;WebCore/xml/XPathGrammar.y&quot;
 131 
 132 
 133 #include &quot;config.h&quot;
 134 
 135 #include &quot;XPathFunctions.h&quot;
 136 #include &quot;XPathParser.h&quot;
 137 #include &quot;XPathPath.h&quot;
 138 #include &quot;XPathStep.h&quot;
 139 #include &quot;XPathVariableReference.h&quot;
 140 
 141 
 142 #if COMPILER(MSVC)
 143 // See https://msdn.microsoft.com/en-us/library/1wea5zwe.aspx
 144 #pragma warning(disable: 4701)
 145 #endif
 146 
 147 #define YYMALLOC fastMalloc
 148 #define YYFREE fastFree
 149 
 150 #define YYENABLE_NLS 0
 151 #define YYLTYPE_IS_TRIVIAL 1
 152 #define YYDEBUG 0
 153 #define YYMAXDEPTH 10000
 154 
 155 using namespace WebCore;
 156 using namespace XPath;
 157 
 158 
 159 /* Enabling traces.  */
 160 #ifndef YYDEBUG
 161 # define YYDEBUG 0
 162 #endif
 163 
 164 /* Enabling verbose error messages.  */
 165 #ifdef YYERROR_VERBOSE
 166 # undef YYERROR_VERBOSE
 167 # define YYERROR_VERBOSE 1
 168 #else
 169 # define YYERROR_VERBOSE 0
 170 #endif
 171 
 172 /* Enabling the token table.  */
 173 #ifndef YYTOKEN_TABLE
 174 # define YYTOKEN_TABLE 0
 175 #endif
 176 
 177 #if ! defined YYSTYPE &amp;&amp; ! defined YYSTYPE_IS_DECLARED
 178 typedef union YYSTYPE
 179 #line 60 &quot;WebCore/xml/XPathGrammar.y&quot;
 180 {
 181     NumericOp::Opcode numericOpcode;
 182     EqTestOp::Opcode equalityTestOpcode;
 183     StringImpl* string;
 184     Step::Axis axis;
 185     LocationPath* locationPath;
 186     Step::NodeTest* nodeTest;
 187     Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;* expressionVector;
 188     Step* step;
 189     Expression* expression;
 190 }
 191 /* Line 193 of yacc.c.  */
 192 #line 190 &quot;./XPathGrammar.cpp&quot;
 193     YYSTYPE;
 194 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 195 # define YYSTYPE_IS_DECLARED 1
 196 # define YYSTYPE_IS_TRIVIAL 1
 197 #endif
 198 
 199 
 200 
 201 /* Copy the second part of user declarations.  */
 202 #line 104 &quot;WebCore/xml/XPathGrammar.y&quot;
 203 
 204 
 205 static int xpathyylex(YYSTYPE* yylval, Parser&amp; parser) { return parser.lex(*yylval); }
 206 static void xpathyyerror(Parser&amp;, const char*) { }
 207 
 208 
 209 
 210 /* Line 216 of yacc.c.  */
 211 #line 209 &quot;./XPathGrammar.cpp&quot;
 212 
 213 #ifdef short
 214 # undef short
 215 #endif
 216 
 217 #ifdef YYTYPE_UINT8
 218 typedef YYTYPE_UINT8 yytype_uint8;
 219 #else
 220 typedef unsigned char yytype_uint8;
 221 #endif
 222 
 223 #ifdef YYTYPE_INT8
 224 typedef YYTYPE_INT8 yytype_int8;
 225 #elif (defined __STDC__ || defined __C99__FUNC__ \
 226      || defined __cplusplus || defined _MSC_VER)
 227 typedef signed char yytype_int8;
 228 #else
 229 typedef short int yytype_int8;
 230 #endif
 231 
 232 #ifdef YYTYPE_UINT16
 233 typedef YYTYPE_UINT16 yytype_uint16;
 234 #else
 235 typedef unsigned short int yytype_uint16;
 236 #endif
 237 
 238 #ifdef YYTYPE_INT16
 239 typedef YYTYPE_INT16 yytype_int16;
 240 #else
 241 typedef short int yytype_int16;
 242 #endif
 243 
 244 #ifndef YYSIZE_T
 245 # ifdef __SIZE_TYPE__
 246 #  define YYSIZE_T __SIZE_TYPE__
 247 # elif defined size_t
 248 #  define YYSIZE_T size_t
 249 # elif ! defined YYSIZE_T &amp;&amp; (defined __STDC__ || defined __C99__FUNC__ \
 250      || defined __cplusplus || defined _MSC_VER)
 251 #  include &lt;stddef.h&gt; /* INFRINGES ON USER NAME SPACE */
 252 #  define YYSIZE_T size_t
 253 # else
 254 #  define YYSIZE_T unsigned int
 255 # endif
 256 #endif
 257 
 258 #define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 259 
 260 #ifndef YY_
 261 # if defined YYENABLE_NLS &amp;&amp; YYENABLE_NLS
 262 #  if ENABLE_NLS
 263 #   include &lt;libintl.h&gt; /* INFRINGES ON USER NAME SPACE */
 264 #   define YY_(msgid) dgettext (&quot;bison-runtime&quot;, msgid)
 265 #  endif
 266 # endif
 267 # ifndef YY_
 268 #  define YY_(msgid) msgid
 269 # endif
 270 #endif
 271 
 272 /* Suppress unused-variable warnings by &quot;using&quot; E.  */
 273 #if ! defined lint || defined __GNUC__
 274 # define YYUSE(e) ((void) (e))
 275 #else
 276 # define YYUSE(e) /* empty */
 277 #endif
 278 
 279 /* Identity function, used to suppress warnings about constant conditions.  */
 280 #ifndef lint
 281 # define YYID(n) (n)
 282 #else
 283 #if (defined __STDC__ || defined __C99__FUNC__ \
 284      || defined __cplusplus || defined _MSC_VER)
 285 static int
 286 YYID (int i)
 287 #else
 288 static int
 289 YYID (i)
 290     int i;
 291 #endif
 292 {
 293   return i;
 294 }
 295 #endif
 296 
 297 #if ! defined yyoverflow || YYERROR_VERBOSE
 298 
 299 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 300 
 301 # ifdef YYSTACK_USE_ALLOCA
 302 #  if YYSTACK_USE_ALLOCA
 303 #   ifdef __GNUC__
 304 #    define YYSTACK_ALLOC __builtin_alloca
 305 #   elif defined __BUILTIN_VA_ARG_INCR
 306 #    include &lt;alloca.h&gt; /* INFRINGES ON USER NAME SPACE */
 307 #   elif defined _AIX
 308 #    define YYSTACK_ALLOC __alloca
 309 #   elif defined _MSC_VER
 310 #    include &lt;malloc.h&gt; /* INFRINGES ON USER NAME SPACE */
 311 #    define alloca _alloca
 312 #   else
 313 #    define YYSTACK_ALLOC alloca
 314 #    if ! defined _ALLOCA_H &amp;&amp; ! defined _STDLIB_H &amp;&amp; (defined __STDC__ || defined __C99__FUNC__ \
 315      || defined __cplusplus || defined _MSC_VER)
 316 #     include &lt;stdlib.h&gt; /* INFRINGES ON USER NAME SPACE */
 317 #     ifndef _STDLIB_H
 318 #      define _STDLIB_H 1
 319 #     endif
 320 #    endif
 321 #   endif
 322 #  endif
 323 # endif
 324 
 325 # ifdef YYSTACK_ALLOC
 326    /* Pacify GCC&#39;s `empty if-body&#39; warning.  */
 327 #  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
 328 #  ifndef YYSTACK_ALLOC_MAXIMUM
 329     /* The OS might guarantee only one guard page at the bottom of the stack,
 330        and a page size can be as small as 4096 bytes.  So we cannot safely
 331        invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
 332        to allow for a few compiler-allocated temporary stack slots.  */
 333 #   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 334 #  endif
 335 # else
 336 #  define YYSTACK_ALLOC YYMALLOC
 337 #  define YYSTACK_FREE YYFREE
 338 #  ifndef YYSTACK_ALLOC_MAXIMUM
 339 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 340 #  endif
 341 #  if (defined __cplusplus &amp;&amp; ! defined _STDLIB_H \
 342        &amp;&amp; ! ((defined YYMALLOC || defined malloc) \
 343          &amp;&amp; (defined YYFREE || defined free)))
 344 #   include &lt;stdlib.h&gt; /* INFRINGES ON USER NAME SPACE */
 345 #   ifndef _STDLIB_H
 346 #    define _STDLIB_H 1
 347 #   endif
 348 #  endif
 349 #  ifndef YYMALLOC
 350 #   define YYMALLOC malloc
 351 #   if ! defined malloc &amp;&amp; ! defined _STDLIB_H &amp;&amp; (defined __STDC__ || defined __C99__FUNC__ \
 352      || defined __cplusplus || defined _MSC_VER)
 353 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 354 #   endif
 355 #  endif
 356 #  ifndef YYFREE
 357 #   define YYFREE free
 358 #   if ! defined free &amp;&amp; ! defined _STDLIB_H &amp;&amp; (defined __STDC__ || defined __C99__FUNC__ \
 359      || defined __cplusplus || defined _MSC_VER)
 360 void free (void *); /* INFRINGES ON USER NAME SPACE */
 361 #   endif
 362 #  endif
 363 # endif
 364 #endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 365 
 366 
 367 #if (! defined yyoverflow \
 368      &amp;&amp; (! defined __cplusplus \
 369      || (defined YYSTYPE_IS_TRIVIAL &amp;&amp; YYSTYPE_IS_TRIVIAL)))
 370 
 371 /* A type that is properly aligned for any stack member.  */
 372 union yyalloc
 373 {
 374   yytype_int16 yyss;
 375   YYSTYPE yyvs;
 376   };
 377 
 378 /* The size of the maximum gap between one aligned stack and the next.  */
 379 # define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
 380 
 381 /* The size of an array large to enough to hold all stacks, each with
 382    N elements.  */
 383 # define YYSTACK_BYTES(N) \
 384      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
 385       + YYSTACK_GAP_MAXIMUM)
 386 
 387 /* Copy COUNT objects from FROM to TO.  The source and destination do
 388    not overlap.  */
 389 # ifndef YYCOPY
 390 #  if defined __GNUC__ &amp;&amp; 1 &lt; __GNUC__
 391 #   define YYCOPY(To, From, Count) \
 392       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 393 #  else
 394 #   define YYCOPY(To, From, Count)        \
 395       do                    \
 396     {                    \
 397       YYSIZE_T yyi;                \
 398       for (yyi = 0; yyi &lt; (Count); yyi++)    \
 399         (To)[yyi] = (From)[yyi];        \
 400     }                    \
 401       while (YYID (0))
 402 #  endif
 403 # endif
 404 
 405 /* Relocate STACK from its old location to the new one.  The
 406    local variables YYSIZE and YYSTACKSIZE give the old and new number of
 407    elements in the stack, and YYPTR gives the new location of the
 408    stack.  Advance YYPTR to a properly aligned location for the next
 409    stack.  */
 410 # define YYSTACK_RELOCATE(Stack)                    \
 411     do                                    \
 412       {                                    \
 413     YYSIZE_T yynewbytes;                        \
 414     YYCOPY (&amp;yyptr-&gt;Stack, Stack, yysize);                \
 415     Stack = &amp;yyptr-&gt;Stack;                        \
 416     yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 417     yyptr += yynewbytes / sizeof (*yyptr);                \
 418       }                                    \
 419     while (YYID (0))
 420 
 421 #endif
 422 
 423 /* YYFINAL -- State number of the termination state.  */
 424 #define YYFINAL  52
 425 /* YYLAST -- Last index in YYTABLE.  */
 426 #define YYLAST   132
 427 
 428 /* YYNTOKENS -- Number of terminals.  */
 429 #define YYNTOKENS  33
 430 /* YYNNTS -- Number of nonterminals.  */
 431 #define YYNNTS  28
 432 /* YYNRULES -- Number of rules.  */
 433 #define YYNRULES  64
 434 /* YYNRULES -- Number of states.  */
 435 #define YYNSTATES  101
 436 
 437 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 438 #define YYUNDEFTOK  2
 439 #define YYMAXUTOK   278
 440 
 441 #define YYTRANSLATE(YYX)                        \
 442   ((unsigned int) (YYX) &lt;= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 443 
 444 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
 445 static const yytype_uint8 yytranslate[] =
 446 {
 447        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 448        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 449        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 450        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 451       26,    27,     2,     2,    31,     2,    30,    24,     2,     2,
 452        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 453        2,     2,     2,     2,    25,     2,     2,     2,     2,     2,
 454        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 455        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 456        2,    28,     2,    29,     2,     2,     2,     2,     2,     2,
 457        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 458        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 459        2,     2,     2,     2,    32,     2,     2,     2,     2,     2,
 460        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 461        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 462        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 463        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 464        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 465        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 466        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 467        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 468        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 469        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 470        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 471        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
 472        2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
 473        5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
 474       15,    16,    17,    18,    19,    20,    21,    22,    23
 475 };
 476 
 477 #if YYDEBUG
 478 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
 479    YYRHS.  */
 480 static const yytype_uint8 yyprhs[] =
 481 {
 482        0,     0,     3,     5,     7,     9,    11,    13,    16,    19,
 483       21,    25,    29,    32,    35,    39,    43,    45,    47,    49,
 484       53,    57,    61,    65,    70,    71,    73,    75,    78,    82,
 485       84,    86,    88,    90,    94,    96,    98,   100,   104,   109,
 486      111,   115,   117,   119,   123,   125,   127,   131,   135,   137,
 487      140,   142,   146,   148,   152,   154,   158,   160,   164,   166,
 488      170,   174,   176,   180,   182
 489 };
 490 
 491 /* YYRHS -- A `-1&#39;-separated list of the rules&#39; RHS.  */
 492 static const yytype_int8 yyrhs[] =
 493 {
 494       34,     0,    -1,    35,    -1,    54,    -1,    37,    -1,    38,
 495       -1,    24,    -1,    24,    38,    -1,    45,    38,    -1,    39,
 496       -1,    38,    24,    39,    -1,    38,    45,    39,    -1,    41,
 497       42,    -1,    12,    42,    -1,    40,    41,    42,    -1,    40,
 498       12,    42,    -1,    46,    -1,    16,    -1,    25,    -1,    20,
 499       26,    27,    -1,    22,    26,    27,    -1,    17,    26,    27,
 500       -1,    19,    26,    27,    -1,    19,    26,    11,    27,    -1,
 501       -1,    43,    -1,    44,    -1,    43,    44,    -1,    28,    35,
 502       29,    -1,    21,    -1,    30,    -1,    18,    -1,    15,    -1,
 503       26,    35,    27,    -1,    11,    -1,    13,    -1,    48,    -1,
 504       10,    26,    27,    -1,    10,    26,    49,    27,    -1,    50,
 505       -1,    49,    31,    50,    -1,    35,    -1,    52,    -1,    51,
 506       32,    52,    -1,    36,    -1,    53,    -1,    53,    24,    38,
 507       -1,    53,    45,    38,    -1,    47,    -1,    47,    43,    -1,
 508       55,    -1,    54,     9,    55,    -1,    56,    -1,    55,     8,
 509       56,    -1,    57,    -1,    56,     5,    57,    -1,    58,    -1,
 510       57,     4,    58,    -1,    59,    -1,    58,     7,    59,    -1,
 511       58,     6,    59,    -1,    60,    -1,    59,     3,    60,    -1,
 512       51,    -1,     6,    60,    -1
 513 };
 514 
 515 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 516 static const yytype_uint16 yyrline[] =
 517 {
 518        0,   114,   114,   121,   125,   131,   135,   140,   145,   153,
 519      159,   165,   174,   184,   202,   213,   231,   235,   237,   244,
 520      249,   254,   259,   264,   273,   277,   281,   287,   295,   302,
 521      309,   314,   321,   327,   332,   338,   344,   348,   356,   367,
 522      373,   381,   385,   387,   394,   399,   401,   407,   416,   418,
 523      426,   428,   435,   437,   444,   446,   453,   455,   462,   464,
 524      469,   476,   478,   485,   487
 525 };
 526 #endif
 527 
 528 #if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
 529 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
 530    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 531 static const char *const yytname[] =
 532 {
 533   &quot;$end&quot;, &quot;error&quot;, &quot;$undefined&quot;, &quot;MULOP&quot;, &quot;RELOP&quot;, &quot;EQOP&quot;, &quot;MINUS&quot;,
 534   &quot;PLUS&quot;, &quot;AND&quot;, &quot;OR&quot;, &quot;FUNCTIONNAME&quot;, &quot;LITERAL&quot;, &quot;NAMETEST&quot;, &quot;NUMBER&quot;,
 535   &quot;NODETYPE&quot;, &quot;VARIABLEREFERENCE&quot;, &quot;AXISNAME&quot;, &quot;COMMENT&quot;, &quot;DOTDOT&quot;, &quot;PI&quot;,
 536   &quot;NODE&quot;, &quot;SLASHSLASH&quot;, &quot;TEXT&quot;, &quot;XPATH_ERROR&quot;, &quot;&#39;/&#39;&quot;, &quot;&#39;@&#39;&quot;, &quot;&#39;(&#39;&quot;, &quot;&#39;)&#39;&quot;,
 537   &quot;&#39;[&#39;&quot;, &quot;&#39;]&#39;&quot;, &quot;&#39;.&#39;&quot;, &quot;&#39;,&#39;&quot;, &quot;&#39;|&#39;&quot;, &quot;$accept&quot;, &quot;Top&quot;, &quot;Expr&quot;,
 538   &quot;LocationPath&quot;, &quot;AbsoluteLocationPath&quot;, &quot;RelativeLocationPath&quot;, &quot;Step&quot;,
 539   &quot;AxisSpecifier&quot;, &quot;NodeTest&quot;, &quot;OptionalPredicateList&quot;, &quot;PredicateList&quot;,
 540   &quot;Predicate&quot;, &quot;DescendantOrSelf&quot;, &quot;AbbreviatedStep&quot;, &quot;PrimaryExpr&quot;,
 541   &quot;FunctionCall&quot;, &quot;ArgumentList&quot;, &quot;Argument&quot;, &quot;UnionExpr&quot;, &quot;PathExpr&quot;,
 542   &quot;FilterExpr&quot;, &quot;OrExpr&quot;, &quot;AndExpr&quot;, &quot;EqualityExpr&quot;, &quot;RelationalExpr&quot;,
 543   &quot;AdditiveExpr&quot;, &quot;MultiplicativeExpr&quot;, &quot;UnaryExpr&quot;, 0
 544 };
 545 #endif
 546 
 547 # ifdef YYPRINT
 548 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
 549    token YYLEX-NUM.  */
 550 static const yytype_uint16 yytoknum[] =
 551 {
 552        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
 553      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
 554      275,   276,   277,   278,    47,    64,    40,    41,    91,    93,
 555       46,    44,   124
 556 };
 557 # endif
 558 
 559 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
 560 static const yytype_uint8 yyr1[] =
 561 {
 562        0,    33,    34,    35,    36,    36,    37,    37,    37,    38,
 563       38,    38,    39,    39,    39,    39,    39,    40,    40,    41,
 564       41,    41,    41,    41,    42,    42,    43,    43,    44,    45,
 565       46,    46,    47,    47,    47,    47,    47,    48,    48,    49,
 566       49,    50,    51,    51,    52,    52,    52,    52,    53,    53,
 567       54,    54,    55,    55,    56,    56,    57,    57,    58,    58,
 568       58,    59,    59,    60,    60
 569 };
 570 
 571 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
 572 static const yytype_uint8 yyr2[] =
 573 {
 574        0,     2,     1,     1,     1,     1,     1,     2,     2,     1,
 575        3,     3,     2,     2,     3,     3,     1,     1,     1,     3,
 576        3,     3,     3,     4,     0,     1,     1,     2,     3,     1,
 577        1,     1,     1,     3,     1,     1,     1,     3,     4,     1,
 578        3,     1,     1,     3,     1,     1,     3,     3,     1,     2,
 579        1,     3,     1,     3,     1,     3,     1,     3,     1,     3,
 580        3,     1,     3,     1,     2
 581 };
 582 
 583 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
 584    STATE-NUM when YYTABLE doesn&#39;t specify something else to do.  Zero
 585    means the default is an error.  */
 586 static const yytype_uint8 yydefact[] =
 587 {
 588        0,     0,     0,    34,    24,    35,    32,    17,     0,    31,
 589        0,     0,    29,     0,     6,    18,     0,    30,     0,     2,
 590       44,     4,     5,     9,     0,    24,     0,    16,    48,    36,
 591       63,    42,    45,     3,    50,    52,    54,    56,    58,    61,
 592       64,     0,     0,    13,    25,    26,     0,     0,     0,     0,
 593        7,     0,     1,     0,     0,    24,    24,    12,     8,    49,
 594        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
 595       37,    41,     0,    39,     0,    27,    21,     0,    22,    19,
 596       20,    33,    10,    11,    15,    14,    43,    46,    47,    51,
 597       53,    55,    57,    60,    59,    62,    38,     0,    28,    23,
 598       40
 599 };
 600 
 601 /* YYDEFGOTO[NTERM-NUM].  */
 602 static const yytype_int8 yydefgoto[] =
 603 {
 604       -1,    18,    71,    20,    21,    22,    23,    24,    25,    43,
 605       44,    45,    26,    27,    28,    29,    72,    73,    30,    31,
 606       32,    33,    34,    35,    36,    37,    38,    39
 607 };
 608 
 609 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
 610    STATE-NUM.  */
 611 #define YYPACT_NINF -37
 612 static const yytype_int8 yypact[] =
 613 {
 614       81,    81,    -8,   -37,    -7,   -37,   -37,   -37,    14,   -37,
 615       17,    20,   -37,    21,     8,   -37,    81,   -37,    48,   -37,
 616      -37,   -37,   -17,   -37,    22,    -7,     8,   -37,    -7,   -37,
 617       23,   -37,    -9,     1,    45,    49,    52,    10,    54,   -37,
 618      -37,    59,    81,   -37,    -7,   -37,    31,    -5,    32,    33,
 619      -17,    34,   -37,     8,     8,    -7,    -7,   -37,   -17,    -7,
 620      102,     8,     8,    81,    81,    81,    81,    81,    81,    81,
 621      -37,   -37,   -18,   -37,    35,   -37,   -37,    36,   -37,   -37,
 622      -37,   -37,   -37,   -37,   -37,   -37,   -37,   -17,   -17,    45,
 623       49,    52,    10,    54,    54,   -37,   -37,    81,   -37,   -37,
 624      -37
 625 };
 626 
 627 /* YYPGOTO[NTERM-NUM].  */
 628 static const yytype_int8 yypgoto[] =
 629 {
 630      -37,   -37,     3,   -37,   -37,   -12,   -22,   -37,    38,   -20,
 631       60,   -36,   -21,   -37,   -37,   -37,   -37,   -24,   -37,    30,
 632      -37,   -37,    19,    40,    43,    29,   -16,    -1
 633 };
 634 
 635 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
 636    positive, shift that token.  If negative, reduce the rule which
 637    number is the opposite.  If zero, do what YYDEFACT says.
 638    If YYTABLE_NINF, syntax error.  */
 639 #define YYTABLE_NINF -1
 640 static const yytype_uint8 yytable[] =
 641 {
 642       40,    54,    50,    19,    12,    57,    77,    53,    75,    96,
 643       63,    62,    12,    97,    58,    61,    67,    68,    41,    51,
 644        4,    42,    78,    75,     7,     8,     9,    10,    11,    54,
 645       13,    82,    83,    15,    55,    84,    85,    54,    17,     8,
 646       46,    10,    11,    47,    13,    74,    48,    49,    52,    87,
 647       88,    93,    94,    64,    65,    60,    66,    69,    76,    79,
 648       80,    81,    56,    99,    98,     1,    54,    54,    95,     2,
 649        3,     4,     5,   100,     6,     7,     8,     9,    10,    11,
 650       12,    13,    89,    14,    15,    16,    70,     1,    59,    17,
 651       86,     2,     3,     4,     5,    92,     6,     7,     8,     9,
 652       10,    11,    12,    13,    90,    14,    15,    16,    91,     0,
 653        0,    17,     2,     3,     4,     5,     0,     6,     7,     8,
 654        9,    10,    11,    12,    13,     0,    14,    15,    16,     0,
 655        0,     0,    17
 656 };
 657 
 658 static const yytype_int8 yycheck[] =
 659 {
 660        1,    22,    14,     0,    21,    25,    11,    24,    44,    27,
 661        9,    32,    21,    31,    26,    24,     6,     7,    26,    16,
 662       12,    28,    27,    59,    16,    17,    18,    19,    20,    50,
 663       22,    53,    54,    25,    12,    55,    56,    58,    30,    17,
 664       26,    19,    20,    26,    22,    42,    26,    26,     0,    61,
 665       62,    67,    68,     8,     5,    32,     4,     3,    27,    27,
 666       27,    27,    24,    27,    29,     6,    87,    88,    69,    10,
 667       11,    12,    13,    97,    15,    16,    17,    18,    19,    20,
 668       21,    22,    63,    24,    25,    26,    27,     6,    28,    30,
 669       60,    10,    11,    12,    13,    66,    15,    16,    17,    18,
 670       19,    20,    21,    22,    64,    24,    25,    26,    65,    -1,
 671       -1,    30,    10,    11,    12,    13,    -1,    15,    16,    17,
 672       18,    19,    20,    21,    22,    -1,    24,    25,    26,    -1,
 673       -1,    -1,    30
 674 };
 675 
 676 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
 677    symbol of state STATE-NUM.  */
 678 static const yytype_uint8 yystos[] =
 679 {
 680        0,     6,    10,    11,    12,    13,    15,    16,    17,    18,
 681       19,    20,    21,    22,    24,    25,    26,    30,    34,    35,
 682       36,    37,    38,    39,    40,    41,    45,    46,    47,    48,
 683       51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
 684       60,    26,    28,    42,    43,    44,    26,    26,    26,    26,
 685       38,    35,     0,    24,    45,    12,    41,    42,    38,    43,
 686       32,    24,    45,     9,     8,     5,     4,     6,     7,     3,
 687       27,    35,    49,    50,    35,    44,    27,    11,    27,    27,
 688       27,    27,    39,    39,    42,    42,    52,    38,    38,    55,
 689       56,    57,    58,    59,    59,    60,    27,    31,    29,    27,
 690       50
 691 };
 692 
 693 #define yyerrok        (yyerrstatus = 0)
 694 #define yyclearin    (yychar = YYEMPTY)
 695 #define YYEMPTY        (-2)
 696 #define YYEOF        0
 697 
 698 #define YYACCEPT    goto yyacceptlab
 699 #define YYABORT        goto yyabortlab
 700 #define YYERROR        goto yyerrorlab
 701 
 702 
 703 /* Like YYERROR except do call yyerror.  This remains here temporarily
 704    to ease the transition to the new meaning of YYERROR, for GCC.
 705    Once GCC version 2 has supplanted version 1, this can go.  */
 706 
 707 #define YYFAIL        goto yyerrlab
 708 
 709 #define YYRECOVERING()  (!!yyerrstatus)
 710 
 711 #define YYBACKUP(Token, Value)                    \
 712 do                                \
 713   if (yychar == YYEMPTY &amp;&amp; yylen == 1)                \
 714     {                                \
 715       yychar = (Token);                        \
 716       yylval = (Value);                        \
 717       yytoken = YYTRANSLATE (yychar);                \
 718       YYPOPSTACK (1);                        \
 719       goto yybackup;                        \
 720     }                                \
 721   else                                \
 722     {                                \
 723       yyerror (parser, YY_(&quot;syntax error: cannot back up&quot;)); \
 724       YYERROR;                            \
 725     }                                \
 726 while (YYID (0))
 727 
 728 
 729 #define YYTERROR    1
 730 #define YYERRCODE    256
 731 
 732 
 733 /* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
 734    If N is 0, then set CURRENT to the empty location which ends
 735    the previous symbol: RHS[0] (always defined).  */
 736 
 737 #define YYRHSLOC(Rhs, K) ((Rhs)[K])
 738 #ifndef YYLLOC_DEFAULT
 739 # define YYLLOC_DEFAULT(Current, Rhs, N)                \
 740     do                                    \
 741       if (YYID (N))                                                    \
 742     {                                \
 743       (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;    \
 744       (Current).first_column = YYRHSLOC (Rhs, 1).first_column;    \
 745       (Current).last_line    = YYRHSLOC (Rhs, N).last_line;        \
 746       (Current).last_column  = YYRHSLOC (Rhs, N).last_column;    \
 747     }                                \
 748       else                                \
 749     {                                \
 750       (Current).first_line   = (Current).last_line   =        \
 751         YYRHSLOC (Rhs, 0).last_line;                \
 752       (Current).first_column = (Current).last_column =        \
 753         YYRHSLOC (Rhs, 0).last_column;                \
 754     }                                \
 755     while (YYID (0))
 756 #endif
 757 
 758 
 759 /* YY_LOCATION_PRINT -- Print the location on the stream.
 760    This macro was not mandated originally: define only if we know
 761    we won&#39;t break user code: when these are the locations we know.  */
 762 
 763 #ifndef YY_LOCATION_PRINT
 764 # if defined YYLTYPE_IS_TRIVIAL &amp;&amp; YYLTYPE_IS_TRIVIAL
 765 #  define YY_LOCATION_PRINT(File, Loc)            \
 766      fprintf (File, &quot;%d.%d-%d.%d&quot;,            \
 767           (Loc).first_line, (Loc).first_column,    \
 768           (Loc).last_line,  (Loc).last_column)
 769 # else
 770 #  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
 771 # endif
 772 #endif
 773 
 774 
 775 /* YYLEX -- calling `yylex&#39; with the right arguments.  */
 776 
 777 #ifdef YYLEX_PARAM
 778 # define YYLEX yylex (&amp;yylval, YYLEX_PARAM)
 779 #else
 780 # define YYLEX yylex (&amp;yylval, parser)
 781 #endif
 782 
 783 /* Enable debugging if requested.  */
 784 #if YYDEBUG
 785 
 786 # ifndef YYFPRINTF
 787 #  include &lt;stdio.h&gt; /* INFRINGES ON USER NAME SPACE */
 788 #  define YYFPRINTF fprintf
 789 # endif
 790 
 791 # define YYDPRINTF(Args)            \
 792 do {                        \
 793   if (yydebug)                    \
 794     YYFPRINTF Args;                \
 795 } while (YYID (0))
 796 
 797 # define YY_SYMBOL_PRINT(Title, Type, Value, Location)              \
 798 do {                                      \
 799   if (yydebug)                                  \
 800     {                                      \
 801       YYFPRINTF (stderr, &quot;%s &quot;, Title);                      \
 802       yy_symbol_print (stderr,                          \
 803           Type, Value, parser); \
 804       YYFPRINTF (stderr, &quot;\n&quot;);                          \
 805     }                                      \
 806 } while (YYID (0))
 807 
 808 
 809 /*--------------------------------.
 810 | Print this symbol on YYOUTPUT.  |
 811 `--------------------------------*/
 812 
 813 /*ARGSUSED*/
 814 #if (defined __STDC__ || defined __C99__FUNC__ \
 815      || defined __cplusplus || defined _MSC_VER)
 816 static void
 817 yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, Parser&amp; parser)
 818 #else
 819 static void
 820 yy_symbol_value_print (yyoutput, yytype, yyvaluep, parser)
 821     FILE *yyoutput;
 822     int yytype;
 823     YYSTYPE const * const yyvaluep;
 824     Parser&amp; parser;
 825 #endif
 826 {
 827   if (!yyvaluep)
 828     return;
 829   YYUSE (parser);
 830 # ifdef YYPRINT
 831   if (yytype &lt; YYNTOKENS)
 832     YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
 833 # else
 834   YYUSE (yyoutput);
 835 # endif
 836   switch (yytype)
 837     {
 838       default:
 839     break;
 840     }
 841 }
 842 
 843 
 844 /*--------------------------------.
 845 | Print this symbol on YYOUTPUT.  |
 846 `--------------------------------*/
 847 
 848 #if (defined __STDC__ || defined __C99__FUNC__ \
 849      || defined __cplusplus || defined _MSC_VER)
 850 static void
 851 yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, Parser&amp; parser)
 852 #else
 853 static void
 854 yy_symbol_print (yyoutput, yytype, yyvaluep, parser)
 855     FILE *yyoutput;
 856     int yytype;
 857     YYSTYPE const * const yyvaluep;
 858     Parser&amp; parser;
 859 #endif
 860 {
 861   if (yytype &lt; YYNTOKENS)
 862     YYFPRINTF (yyoutput, &quot;token %s (&quot;, yytname[yytype]);
 863   else
 864     YYFPRINTF (yyoutput, &quot;nterm %s (&quot;, yytname[yytype]);
 865 
 866   yy_symbol_value_print (yyoutput, yytype, yyvaluep, parser);
 867   YYFPRINTF (yyoutput, &quot;)&quot;);
 868 }
 869 
 870 /*------------------------------------------------------------------.
 871 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 872 | TOP (included).                                                   |
 873 `------------------------------------------------------------------*/
 874 
 875 #if (defined __STDC__ || defined __C99__FUNC__ \
 876      || defined __cplusplus || defined _MSC_VER)
 877 static void
 878 yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 879 #else
 880 static void
 881 yy_stack_print (bottom, top)
 882     yytype_int16 *bottom;
 883     yytype_int16 *top;
 884 #endif
 885 {
 886   YYFPRINTF (stderr, &quot;Stack now&quot;);
 887   for (; bottom &lt;= top; ++bottom)
 888     YYFPRINTF (stderr, &quot; %d&quot;, *bottom);
 889   YYFPRINTF (stderr, &quot;\n&quot;);
 890 }
 891 
 892 # define YY_STACK_PRINT(Bottom, Top)                \
 893 do {                                \
 894   if (yydebug)                            \
 895     yy_stack_print ((Bottom), (Top));                \
 896 } while (YYID (0))
 897 
 898 
 899 /*------------------------------------------------.
 900 | Report that the YYRULE is going to be reduced.  |
 901 `------------------------------------------------*/
 902 
 903 #if (defined __STDC__ || defined __C99__FUNC__ \
 904      || defined __cplusplus || defined _MSC_VER)
 905 static void
 906 yy_reduce_print (YYSTYPE *yyvsp, int yyrule, Parser&amp; parser)
 907 #else
 908 static void
 909 yy_reduce_print (yyvsp, yyrule, parser)
 910     YYSTYPE *yyvsp;
 911     int yyrule;
 912     Parser&amp; parser;
 913 #endif
 914 {
 915   int yynrhs = yyr2[yyrule];
 916   int yyi;
 917   unsigned long int yylno = yyrline[yyrule];
 918   YYFPRINTF (stderr, &quot;Reducing stack by rule %d (line %lu):\n&quot;,
 919          yyrule - 1, yylno);
 920   /* The symbols being reduced.  */
 921   for (yyi = 0; yyi &lt; yynrhs; yyi++)
 922     {
 923       fprintf (stderr, &quot;   $%d = &quot;, yyi + 1);
 924       yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
 925                &amp;(yyvsp[(yyi + 1) - (yynrhs)])
 926                               , parser);
 927       fprintf (stderr, &quot;\n&quot;);
 928     }
 929 }
 930 
 931 # define YY_REDUCE_PRINT(Rule)        \
 932 do {                    \
 933   if (yydebug)                \
 934     yy_reduce_print (yyvsp, Rule, parser); \
 935 } while (YYID (0))
 936 
 937 /* Nonzero means print parse trace.  It is left uninitialized so that
 938    multiple parsers can coexist.  */
 939 int yydebug;
 940 #else /* !YYDEBUG */
 941 # define YYDPRINTF(Args)
 942 # define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 943 # define YY_STACK_PRINT(Bottom, Top)
 944 # define YY_REDUCE_PRINT(Rule)
 945 #endif /* !YYDEBUG */
 946 
 947 
 948 /* YYINITDEPTH -- initial size of the parser&#39;s stacks.  */
 949 #ifndef    YYINITDEPTH
 950 # define YYINITDEPTH 200
 951 #endif
 952 
 953 /* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
 954    if the built-in stack extension method is used).
 955 
 956    Do not make this value too large; the results are undefined if
 957    YYSTACK_ALLOC_MAXIMUM &lt; YYSTACK_BYTES (YYMAXDEPTH)
 958    evaluated with infinite-precision integer arithmetic.  */
 959 
 960 #ifndef YYMAXDEPTH
 961 # define YYMAXDEPTH 10000
 962 #endif
 963 
<a name="1" id="anc1"></a><span class="line-modified"> 964 </span>
 965 
 966 #if YYERROR_VERBOSE
 967 
 968 # ifndef yystrlen
 969 #  if defined __GLIBC__ &amp;&amp; defined _STRING_H
 970 #   define yystrlen strlen
 971 #  else
 972 /* Return the length of YYSTR.  */
 973 #if (defined __STDC__ || defined __C99__FUNC__ \
 974      || defined __cplusplus || defined _MSC_VER)
 975 static YYSIZE_T
 976 yystrlen (const char *yystr)
 977 #else
 978 static YYSIZE_T
 979 yystrlen (yystr)
 980     const char *yystr;
 981 #endif
 982 {
 983   YYSIZE_T yylen;
 984   for (yylen = 0; yystr[yylen]; yylen++)
 985     continue;
 986   return yylen;
 987 }
 988 #  endif
 989 # endif
 990 
 991 # ifndef yystpcpy
 992 #  if defined __GLIBC__ &amp;&amp; defined _STRING_H &amp;&amp; defined _GNU_SOURCE
 993 #   define yystpcpy stpcpy
 994 #  else
 995 /* Copy YYSRC to YYDEST, returning the address of the terminating &#39;\0&#39; in
 996    YYDEST.  */
 997 #if (defined __STDC__ || defined __C99__FUNC__ \
 998      || defined __cplusplus || defined _MSC_VER)
 999 static char *
1000 yystpcpy (char *yydest, const char *yysrc)
1001 #else
1002 static char *
1003 yystpcpy (yydest, yysrc)
1004     char *yydest;
1005     const char *yysrc;
1006 #endif
1007 {
1008   char *yyd = yydest;
1009   const char *yys = yysrc;
1010 
1011   while ((*yyd++ = *yys++) != &#39;\0&#39;)
1012     continue;
1013 
1014   return yyd - 1;
1015 }
1016 #  endif
1017 # endif
1018 
1019 # ifndef yytnamerr
1020 /* Copy to YYRES the contents of YYSTR after stripping away unnecessary
1021    quotes and backslashes, so that it&#39;s suitable for yyerror.  The
1022    heuristic is that double-quoting is unnecessary unless the string
1023    contains an apostrophe, a comma, or backslash (other than
1024    backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
1025    null, do not copy; instead, return the length of what the result
1026    would have been.  */
1027 static YYSIZE_T
1028 yytnamerr (char *yyres, const char *yystr)
1029 {
1030   if (*yystr == &#39;&quot;&#39;)
1031     {
1032       YYSIZE_T yyn = 0;
1033       char const *yyp = yystr;
1034 
1035       for (;;)
1036     switch (*++yyp)
1037       {
1038       case &#39;\&#39;&#39;:
1039       case &#39;,&#39;:
1040         goto do_not_strip_quotes;
1041 
1042       case &#39;\\&#39;:
1043         if (*++yyp != &#39;\\&#39;)
1044           goto do_not_strip_quotes;
1045         /* Fall through.  */
1046       default:
1047         if (yyres)
1048           yyres[yyn] = *yyp;
1049         yyn++;
1050         break;
1051 
1052       case &#39;&quot;&#39;:
1053         if (yyres)
1054           yyres[yyn] = &#39;\0&#39;;
1055         return yyn;
1056       }
1057     do_not_strip_quotes: ;
1058     }
1059 
1060   if (! yyres)
1061     return yystrlen (yystr);
1062 
1063   return yystpcpy (yyres, yystr) - yyres;
1064 }
1065 # endif
1066 
1067 /* Copy into YYRESULT an error message about the unexpected token
1068    YYCHAR while in state YYSTATE.  Return the number of bytes copied,
1069    including the terminating null byte.  If YYRESULT is null, do not
1070    copy anything; just return the number of bytes that would be
1071    copied.  As a special case, return 0 if an ordinary &quot;syntax error&quot;
1072    message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
1073    size calculation.  */
1074 static YYSIZE_T
1075 yysyntax_error (char *yyresult, int yystate, int yychar)
1076 {
1077   int yyn = yypact[yystate];
1078 
1079   if (! (YYPACT_NINF &lt; yyn &amp;&amp; yyn &lt;= YYLAST))
1080     return 0;
1081   else
1082     {
1083       int yytype = YYTRANSLATE (yychar);
1084       YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
1085       YYSIZE_T yysize = yysize0;
1086       YYSIZE_T yysize1;
1087       int yysize_overflow = 0;
1088       enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
1089       char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
1090       int yyx;
1091 
1092 # if 0
1093       /* This is so xgettext sees the translatable formats that are
1094      constructed on the fly.  */
1095       YY_(&quot;syntax error, unexpected %s&quot;);
1096       YY_(&quot;syntax error, unexpected %s, expecting %s&quot;);
1097       YY_(&quot;syntax error, unexpected %s, expecting %s or %s&quot;);
1098       YY_(&quot;syntax error, unexpected %s, expecting %s or %s or %s&quot;);
1099       YY_(&quot;syntax error, unexpected %s, expecting %s or %s or %s or %s&quot;);
1100 # endif
1101       char *yyfmt;
1102       char const *yyf;
1103       static char const yyunexpected[] = &quot;syntax error, unexpected %s&quot;;
1104       static char const yyexpecting[] = &quot;, expecting %s&quot;;
1105       static char const yyor[] = &quot; or %s&quot;;
1106       char yyformat[sizeof yyunexpected
1107             + sizeof yyexpecting - 1
1108             + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
1109                * (sizeof yyor - 1))];
1110       char const *yyprefix = yyexpecting;
1111 
1112       /* Start YYX at -YYN if negative to avoid negative indexes in
1113      YYCHECK.  */
1114       int yyxbegin = yyn &lt; 0 ? -yyn : 0;
1115 
1116       /* Stay within bounds of both yycheck and yytname.  */
1117       int yychecklim = YYLAST - yyn + 1;
1118       int yyxend = yychecklim &lt; YYNTOKENS ? yychecklim : YYNTOKENS;
1119       int yycount = 1;
1120 
1121       yyarg[0] = yytname[yytype];
1122       yyfmt = yystpcpy (yyformat, yyunexpected);
1123 
1124       for (yyx = yyxbegin; yyx &lt; yyxend; ++yyx)
1125     if (yycheck[yyx + yyn] == yyx &amp;&amp; yyx != YYTERROR)
1126       {
1127         if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
1128           {
1129         yycount = 1;
1130         yysize = yysize0;
1131         yyformat[sizeof yyunexpected - 1] = &#39;\0&#39;;
1132         break;
1133           }
1134         yyarg[yycount++] = yytname[yyx];
1135         yysize1 = yysize + yytnamerr (0, yytname[yyx]);
1136         yysize_overflow |= (yysize1 &lt; yysize);
1137         yysize = yysize1;
1138         yyfmt = yystpcpy (yyfmt, yyprefix);
1139         yyprefix = yyor;
1140       }
1141 
1142       yyf = YY_(yyformat);
1143       yysize1 = yysize + yystrlen (yyf);
1144       yysize_overflow |= (yysize1 &lt; yysize);
1145       yysize = yysize1;
1146 
1147       if (yysize_overflow)
1148     return YYSIZE_MAXIMUM;
1149 
1150       if (yyresult)
1151     {
1152       /* Avoid sprintf, as that infringes on the user&#39;s name space.
1153          Don&#39;t have undefined behavior even if the translation
1154          produced a string with the wrong number of &quot;%s&quot;s.  */
1155       char *yyp = yyresult;
1156       int yyi = 0;
1157       while ((*yyp = *yyf) != &#39;\0&#39;)
1158         {
1159           if (*yyp == &#39;%&#39; &amp;&amp; yyf[1] == &#39;s&#39; &amp;&amp; yyi &lt; yycount)
1160         {
1161           yyp += yytnamerr (yyp, yyarg[yyi++]);
1162           yyf += 2;
1163         }
1164           else
1165         {
1166           yyp++;
1167           yyf++;
1168         }
1169         }
1170     }
1171       return yysize;
1172     }
1173 }
1174 #endif /* YYERROR_VERBOSE */
<a name="2" id="anc2"></a><span class="line-modified">1175 </span>
1176 
1177 /*-----------------------------------------------.
1178 | Release the memory associated to this symbol.  |
1179 `-----------------------------------------------*/
1180 
1181 /*ARGSUSED*/
1182 #if (defined __STDC__ || defined __C99__FUNC__ \
1183      || defined __cplusplus || defined _MSC_VER)
1184 static void
1185 yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, Parser&amp; parser)
1186 #else
1187 static void
1188 yydestruct (yymsg, yytype, yyvaluep, parser)
1189     const char *yymsg;
1190     int yytype;
1191     YYSTYPE *yyvaluep;
1192     Parser&amp; parser;
1193 #endif
1194 {
1195   YYUSE (yyvaluep);
1196   YYUSE (parser);
1197 
1198   if (!yymsg)
1199     yymsg = &quot;Deleting&quot;;
1200   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
1201 
1202   switch (yytype)
1203     {
1204       case 10: /* &quot;FUNCTIONNAME&quot; */
1205 #line 80 &quot;WebCore/xml/XPathGrammar.y&quot;
1206     { if ((yyvaluep-&gt;string)) (yyvaluep-&gt;string)-&gt;deref(); };
1207 #line 1205 &quot;./XPathGrammar.cpp&quot;
1208     break;
1209       case 11: /* &quot;LITERAL&quot; */
1210 #line 80 &quot;WebCore/xml/XPathGrammar.y&quot;
1211     { if ((yyvaluep-&gt;string)) (yyvaluep-&gt;string)-&gt;deref(); };
1212 #line 1210 &quot;./XPathGrammar.cpp&quot;
1213     break;
1214       case 12: /* &quot;NAMETEST&quot; */
1215 #line 80 &quot;WebCore/xml/XPathGrammar.y&quot;
1216     { if ((yyvaluep-&gt;string)) (yyvaluep-&gt;string)-&gt;deref(); };
1217 #line 1215 &quot;./XPathGrammar.cpp&quot;
1218     break;
1219       case 13: /* &quot;NUMBER&quot; */
1220 #line 80 &quot;WebCore/xml/XPathGrammar.y&quot;
1221     { if ((yyvaluep-&gt;string)) (yyvaluep-&gt;string)-&gt;deref(); };
1222 #line 1220 &quot;./XPathGrammar.cpp&quot;
1223     break;
1224       case 14: /* &quot;NODETYPE&quot; */
1225 #line 80 &quot;WebCore/xml/XPathGrammar.y&quot;
1226     { if ((yyvaluep-&gt;string)) (yyvaluep-&gt;string)-&gt;deref(); };
1227 #line 1225 &quot;./XPathGrammar.cpp&quot;
1228     break;
1229       case 15: /* &quot;VARIABLEREFERENCE&quot; */
1230 #line 80 &quot;WebCore/xml/XPathGrammar.y&quot;
1231     { if ((yyvaluep-&gt;string)) (yyvaluep-&gt;string)-&gt;deref(); };
1232 #line 1230 &quot;./XPathGrammar.cpp&quot;
1233     break;
1234       case 35: /* &quot;Expr&quot; */
1235 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1236     { delete (yyvaluep-&gt;expression); };
1237 #line 1235 &quot;./XPathGrammar.cpp&quot;
1238     break;
1239       case 36: /* &quot;LocationPath&quot; */
1240 #line 88 &quot;WebCore/xml/XPathGrammar.y&quot;
1241     { delete (yyvaluep-&gt;locationPath); };
1242 #line 1240 &quot;./XPathGrammar.cpp&quot;
1243     break;
1244       case 37: /* &quot;AbsoluteLocationPath&quot; */
1245 #line 88 &quot;WebCore/xml/XPathGrammar.y&quot;
1246     { delete (yyvaluep-&gt;locationPath); };
1247 #line 1245 &quot;./XPathGrammar.cpp&quot;
1248     break;
1249       case 38: /* &quot;RelativeLocationPath&quot; */
1250 #line 88 &quot;WebCore/xml/XPathGrammar.y&quot;
1251     { delete (yyvaluep-&gt;locationPath); };
1252 #line 1250 &quot;./XPathGrammar.cpp&quot;
1253     break;
1254       case 39: /* &quot;Step&quot; */
1255 #line 97 &quot;WebCore/xml/XPathGrammar.y&quot;
1256     { delete (yyvaluep-&gt;step); };
1257 #line 1255 &quot;./XPathGrammar.cpp&quot;
1258     break;
1259       case 41: /* &quot;NodeTest&quot; */
1260 #line 91 &quot;WebCore/xml/XPathGrammar.y&quot;
1261     { delete (yyvaluep-&gt;nodeTest); };
1262 #line 1260 &quot;./XPathGrammar.cpp&quot;
1263     break;
1264       case 42: /* &quot;OptionalPredicateList&quot; */
1265 #line 94 &quot;WebCore/xml/XPathGrammar.y&quot;
1266     { delete (yyvaluep-&gt;expressionVector); };
1267 #line 1265 &quot;./XPathGrammar.cpp&quot;
1268     break;
1269       case 43: /* &quot;PredicateList&quot; */
1270 #line 94 &quot;WebCore/xml/XPathGrammar.y&quot;
1271     { delete (yyvaluep-&gt;expressionVector); };
1272 #line 1270 &quot;./XPathGrammar.cpp&quot;
1273     break;
1274       case 44: /* &quot;Predicate&quot; */
1275 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1276     { delete (yyvaluep-&gt;expression); };
1277 #line 1275 &quot;./XPathGrammar.cpp&quot;
1278     break;
1279       case 45: /* &quot;DescendantOrSelf&quot; */
1280 #line 97 &quot;WebCore/xml/XPathGrammar.y&quot;
1281     { delete (yyvaluep-&gt;step); };
1282 #line 1280 &quot;./XPathGrammar.cpp&quot;
1283     break;
1284       case 46: /* &quot;AbbreviatedStep&quot; */
1285 #line 97 &quot;WebCore/xml/XPathGrammar.y&quot;
1286     { delete (yyvaluep-&gt;step); };
1287 #line 1285 &quot;./XPathGrammar.cpp&quot;
1288     break;
1289       case 47: /* &quot;PrimaryExpr&quot; */
1290 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1291     { delete (yyvaluep-&gt;expression); };
1292 #line 1290 &quot;./XPathGrammar.cpp&quot;
1293     break;
1294       case 48: /* &quot;FunctionCall&quot; */
1295 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1296     { delete (yyvaluep-&gt;expression); };
1297 #line 1295 &quot;./XPathGrammar.cpp&quot;
1298     break;
1299       case 49: /* &quot;ArgumentList&quot; */
1300 #line 94 &quot;WebCore/xml/XPathGrammar.y&quot;
1301     { delete (yyvaluep-&gt;expressionVector); };
1302 #line 1300 &quot;./XPathGrammar.cpp&quot;
1303     break;
1304       case 50: /* &quot;Argument&quot; */
1305 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1306     { delete (yyvaluep-&gt;expression); };
1307 #line 1305 &quot;./XPathGrammar.cpp&quot;
1308     break;
1309       case 51: /* &quot;UnionExpr&quot; */
1310 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1311     { delete (yyvaluep-&gt;expression); };
1312 #line 1310 &quot;./XPathGrammar.cpp&quot;
1313     break;
1314       case 52: /* &quot;PathExpr&quot; */
1315 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1316     { delete (yyvaluep-&gt;expression); };
1317 #line 1315 &quot;./XPathGrammar.cpp&quot;
1318     break;
1319       case 53: /* &quot;FilterExpr&quot; */
1320 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1321     { delete (yyvaluep-&gt;expression); };
1322 #line 1320 &quot;./XPathGrammar.cpp&quot;
1323     break;
1324       case 54: /* &quot;OrExpr&quot; */
1325 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1326     { delete (yyvaluep-&gt;expression); };
1327 #line 1325 &quot;./XPathGrammar.cpp&quot;
1328     break;
1329       case 55: /* &quot;AndExpr&quot; */
1330 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1331     { delete (yyvaluep-&gt;expression); };
1332 #line 1330 &quot;./XPathGrammar.cpp&quot;
1333     break;
1334       case 56: /* &quot;EqualityExpr&quot; */
1335 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1336     { delete (yyvaluep-&gt;expression); };
1337 #line 1335 &quot;./XPathGrammar.cpp&quot;
1338     break;
1339       case 57: /* &quot;RelationalExpr&quot; */
1340 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1341     { delete (yyvaluep-&gt;expression); };
1342 #line 1340 &quot;./XPathGrammar.cpp&quot;
1343     break;
1344       case 58: /* &quot;AdditiveExpr&quot; */
1345 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1346     { delete (yyvaluep-&gt;expression); };
1347 #line 1345 &quot;./XPathGrammar.cpp&quot;
1348     break;
1349       case 59: /* &quot;MultiplicativeExpr&quot; */
1350 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1351     { delete (yyvaluep-&gt;expression); };
1352 #line 1350 &quot;./XPathGrammar.cpp&quot;
1353     break;
1354       case 60: /* &quot;UnaryExpr&quot; */
1355 #line 100 &quot;WebCore/xml/XPathGrammar.y&quot;
1356     { delete (yyvaluep-&gt;expression); };
1357 #line 1355 &quot;./XPathGrammar.cpp&quot;
1358     break;
1359 
1360       default:
1361     break;
1362     }
1363 }
<a name="3" id="anc3"></a><span class="line-modified">1364 </span>
1365 
1366 /* Prevent warnings from -Wmissing-prototypes.  */
1367 
1368 #ifdef YYPARSE_PARAM
1369 #if defined __STDC__ || defined __cplusplus
1370 int yyparse (void *YYPARSE_PARAM);
1371 #else
1372 int yyparse ();
1373 #endif
1374 #else /* ! YYPARSE_PARAM */
1375 #if defined __STDC__ || defined __cplusplus
1376 int yyparse (Parser&amp; parser);
1377 #else
1378 int yyparse ();
1379 #endif
1380 #endif /* ! YYPARSE_PARAM */
1381 
1382 
1383 
1384 
1385 
1386 
1387 /*----------.
1388 | yyparse.  |
1389 `----------*/
1390 
1391 #ifdef YYPARSE_PARAM
1392 #if (defined __STDC__ || defined __C99__FUNC__ \
1393      || defined __cplusplus || defined _MSC_VER)
1394 int
1395 yyparse (void *YYPARSE_PARAM)
1396 #else
1397 int
1398 yyparse (YYPARSE_PARAM)
1399     void *YYPARSE_PARAM;
1400 #endif
1401 #else /* ! YYPARSE_PARAM */
1402 #if (defined __STDC__ || defined __C99__FUNC__ \
1403      || defined __cplusplus || defined _MSC_VER)
1404 int
1405 yyparse (Parser&amp; parser)
1406 #else
1407 int
1408 yyparse (parser)
1409     Parser&amp; parser;
1410 #endif
1411 #endif
1412 {
1413   /* The look-ahead symbol.  */
1414 int yychar;
1415 
1416 /* The semantic value of the look-ahead symbol.  */
1417 YYSTYPE yylval;
1418 
1419 /* Number of syntax errors so far.  */
1420 int yynerrs;
1421 
1422   int yystate;
1423   int yyn;
1424   int yyresult;
1425   /* Number of tokens to shift before error messages enabled.  */
1426   int yyerrstatus;
1427   /* Look-ahead token as an internal (translated) token number.  */
1428   int yytoken = 0;
1429 #if YYERROR_VERBOSE
1430   /* Buffer for error messages, and its allocated size.  */
1431   char yymsgbuf[128];
1432   char *yymsg = yymsgbuf;
1433   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
1434 #endif
1435 
1436   /* Three stacks and their tools:
1437      `yyss&#39;: related to states,
1438      `yyvs&#39;: related to semantic values,
1439      `yyls&#39;: related to locations.
1440 
1441      Refer to the stacks thru separate pointers, to allow yyoverflow
1442      to reallocate them elsewhere.  */
1443 
1444   /* The state stack.  */
1445   yytype_int16 yyssa[YYINITDEPTH];
1446   yytype_int16 *yyss = yyssa;
1447   yytype_int16 *yyssp;
1448 
1449   /* The semantic value stack.  */
1450   YYSTYPE yyvsa[YYINITDEPTH];
1451   YYSTYPE *yyvs = yyvsa;
1452   YYSTYPE *yyvsp;
1453 
1454 
1455 
1456 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
1457 
1458   YYSIZE_T yystacksize = YYINITDEPTH;
1459 
1460   /* The variables used to return semantic value and location from the
1461      action routines.  */
1462   YYSTYPE yyval;
1463 
1464 
1465   /* The number of symbols on the RHS of the reduced rule.
1466      Keep to zero when no symbol should be popped.  */
1467   int yylen = 0;
1468 
1469   YYDPRINTF ((stderr, &quot;Starting parse\n&quot;));
1470 
1471   yystate = 0;
1472   yyerrstatus = 0;
1473   yynerrs = 0;
1474   yychar = YYEMPTY;        /* Cause a token to be read.  */
1475 
1476   /* Initialize stack pointers.
1477      Waste one element of value and location stack
1478      so that they stay on the same level as the state stack.
1479      The wasted elements are never initialized.  */
1480 
1481   yyssp = yyss;
1482   yyvsp = yyvs;
1483 
1484   goto yysetstate;
1485 
1486 /*------------------------------------------------------------.
1487 | yynewstate -- Push a new state, which is found in yystate.  |
1488 `------------------------------------------------------------*/
1489  yynewstate:
1490   /* In all cases, when you get here, the value and location stacks
1491      have just been pushed.  So pushing a state here evens the stacks.  */
1492   yyssp++;
1493 
1494  yysetstate:
1495   *yyssp = yystate;
1496 
1497   if (yyss + yystacksize - 1 &lt;= yyssp)
1498     {
1499       /* Get the current used size of the three stacks, in elements.  */
1500       YYSIZE_T yysize = yyssp - yyss + 1;
1501 
1502 #ifdef yyoverflow
1503       {
1504     /* Give user a chance to reallocate the stack.  Use copies of
1505        these so that the &amp;&#39;s don&#39;t force the real ones into
1506        memory.  */
1507     YYSTYPE *yyvs1 = yyvs;
1508     yytype_int16 *yyss1 = yyss;
1509 
1510 
1511     /* Each stack pointer address is followed by the size of the
1512        data in use in that stack, in bytes.  This used to be a
1513        conditional around just the two extra args, but that might
1514        be undefined if yyoverflow is a macro.  */
1515     yyoverflow (YY_(&quot;memory exhausted&quot;),
1516             &amp;yyss1, yysize * sizeof (*yyssp),
1517             &amp;yyvs1, yysize * sizeof (*yyvsp),
1518 
1519             &amp;yystacksize);
1520 
1521     yyss = yyss1;
1522     yyvs = yyvs1;
1523       }
1524 #else /* no yyoverflow */
1525 # ifndef YYSTACK_RELOCATE
1526       goto yyexhaustedlab;
1527 # else
1528       /* Extend the stack our own way.  */
1529       if (YYMAXDEPTH &lt;= yystacksize)
1530     goto yyexhaustedlab;
1531       yystacksize *= 2;
1532       if (YYMAXDEPTH &lt; yystacksize)
1533     yystacksize = YYMAXDEPTH;
1534 
1535       {
1536     yytype_int16 *yyss1 = yyss;
1537     union yyalloc *yyptr =
1538       (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
1539     if (! yyptr)
1540       goto yyexhaustedlab;
1541     YYSTACK_RELOCATE (yyss);
1542     YYSTACK_RELOCATE (yyvs);
1543 
1544 #  undef YYSTACK_RELOCATE
1545     if (yyss1 != yyssa)
1546       YYSTACK_FREE (yyss1);
1547       }
1548 # endif
1549 #endif /* no yyoverflow */
1550 
1551       yyssp = yyss + yysize - 1;
1552       yyvsp = yyvs + yysize - 1;
1553 
1554 
1555       YYDPRINTF ((stderr, &quot;Stack size increased to %lu\n&quot;,
1556           (unsigned long int) yystacksize));
1557 
1558       if (yyss + yystacksize - 1 &lt;= yyssp)
1559     YYABORT;
1560     }
1561 
1562   YYDPRINTF ((stderr, &quot;Entering state %d\n&quot;, yystate));
1563 
1564   goto yybackup;
1565 
1566 /*-----------.
1567 | yybackup.  |
1568 `-----------*/
1569 yybackup:
1570 
1571   /* Do appropriate processing given the current state.  Read a
1572      look-ahead token if we need one and don&#39;t already have one.  */
1573 
1574   /* First try to decide what to do without reference to look-ahead token.  */
1575   yyn = yypact[yystate];
1576   if (yyn == YYPACT_NINF)
1577     goto yydefault;
1578 
1579   /* Not known =&gt; get a look-ahead token if don&#39;t already have one.  */
1580 
1581   /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
1582   if (yychar == YYEMPTY)
1583     {
1584       YYDPRINTF ((stderr, &quot;Reading a token: &quot;));
1585       yychar = YYLEX;
1586     }
1587 
1588   if (yychar &lt;= YYEOF)
1589     {
1590       yychar = yytoken = YYEOF;
1591       YYDPRINTF ((stderr, &quot;Now at end of input.\n&quot;));
1592     }
1593   else
1594     {
1595       yytoken = YYTRANSLATE (yychar);
1596       YY_SYMBOL_PRINT (&quot;Next token is&quot;, yytoken, &amp;yylval, &amp;yylloc);
1597     }
1598 
1599   /* If the proper action on seeing token YYTOKEN is to reduce or to
1600      detect an error, take that action.  */
1601   yyn += yytoken;
1602   if (yyn &lt; 0 || YYLAST &lt; yyn || yycheck[yyn] != yytoken)
1603     goto yydefault;
1604   yyn = yytable[yyn];
1605   if (yyn &lt;= 0)
1606     {
1607       if (yyn == 0 || yyn == YYTABLE_NINF)
1608     goto yyerrlab;
1609       yyn = -yyn;
1610       goto yyreduce;
1611     }
1612 
1613   if (yyn == YYFINAL)
1614     YYACCEPT;
1615 
1616   /* Count tokens shifted since error; after three, turn off error
1617      status.  */
1618   if (yyerrstatus)
1619     yyerrstatus--;
1620 
1621   /* Shift the look-ahead token.  */
1622   YY_SYMBOL_PRINT (&quot;Shifting&quot;, yytoken, &amp;yylval, &amp;yylloc);
1623 
1624   /* Discard the shifted token unless it is eof.  */
1625   if (yychar != YYEOF)
1626     yychar = YYEMPTY;
1627 
1628   yystate = yyn;
1629   *++yyvsp = yylval;
1630 
1631   goto yynewstate;
1632 
1633 
1634 /*-----------------------------------------------------------.
1635 | yydefault -- do the default action for the current state.  |
1636 `-----------------------------------------------------------*/
1637 yydefault:
1638   yyn = yydefact[yystate];
1639   if (yyn == 0)
1640     goto yyerrlab;
1641   goto yyreduce;
1642 
1643 
1644 /*-----------------------------.
1645 | yyreduce -- Do a reduction.  |
1646 `-----------------------------*/
1647 yyreduce:
1648   /* yyn is the number of a rule to reduce with.  */
1649   yylen = yyr2[yyn];
1650 
1651   /* If YYLEN is nonzero, implement the default value of the action:
1652      `$$ = $1&#39;.
1653 
1654      Otherwise, the following line sets YYVAL to garbage.
1655      This behavior is undocumented and Bison
1656      users should not rely upon it.  Assigning to YYVAL
1657      unconditionally makes the parser a bit smaller, and it avoids a
1658      GCC warning that YYVAL may be used uninitialized.  */
1659   yyval = yyvsp[1-yylen];
1660 
1661 
1662   YY_REDUCE_PRINT (yyn);
1663   switch (yyn)
1664     {
1665         case 2:
1666 #line 115 &quot;WebCore/xml/XPathGrammar.y&quot;
1667     {
1668         parser.setParseResult(std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (1)].expression)));
1669     ;}
1670     break;
1671 
1672   case 4:
1673 #line 126 &quot;WebCore/xml/XPathGrammar.y&quot;
1674     {
1675         (yyval.locationPath) = (yyvsp[(1) - (1)].locationPath);
1676         (yyval.locationPath)-&gt;setAbsolute();
1677     ;}
1678     break;
1679 
1680   case 6:
1681 #line 136 &quot;WebCore/xml/XPathGrammar.y&quot;
1682     {
1683         (yyval.locationPath) = new LocationPath;
1684     ;}
1685     break;
1686 
1687   case 7:
1688 #line 141 &quot;WebCore/xml/XPathGrammar.y&quot;
1689     {
1690         (yyval.locationPath) = (yyvsp[(2) - (2)].locationPath);
1691     ;}
1692     break;
1693 
1694   case 8:
1695 #line 146 &quot;WebCore/xml/XPathGrammar.y&quot;
1696     {
1697         (yyval.locationPath) = (yyvsp[(2) - (2)].locationPath);
1698         (yyval.locationPath)-&gt;prependStep(std::unique_ptr&lt;Step&gt;((yyvsp[(1) - (2)].step)));
1699     ;}
1700     break;
1701 
1702   case 9:
1703 #line 154 &quot;WebCore/xml/XPathGrammar.y&quot;
1704     {
1705         (yyval.locationPath) = new LocationPath;
1706         (yyval.locationPath)-&gt;appendStep(std::unique_ptr&lt;Step&gt;((yyvsp[(1) - (1)].step)));
1707     ;}
1708     break;
1709 
1710   case 10:
1711 #line 160 &quot;WebCore/xml/XPathGrammar.y&quot;
1712     {
1713         (yyval.locationPath) = (yyvsp[(1) - (3)].locationPath);
1714         (yyval.locationPath)-&gt;appendStep(std::unique_ptr&lt;Step&gt;((yyvsp[(3) - (3)].step)));
1715     ;}
1716     break;
1717 
1718   case 11:
1719 #line 166 &quot;WebCore/xml/XPathGrammar.y&quot;
1720     {
1721         (yyval.locationPath) = (yyvsp[(1) - (3)].locationPath);
1722         (yyval.locationPath)-&gt;appendStep(std::unique_ptr&lt;Step&gt;((yyvsp[(2) - (3)].step)));
1723         (yyval.locationPath)-&gt;appendStep(std::unique_ptr&lt;Step&gt;((yyvsp[(3) - (3)].step)));
1724     ;}
1725     break;
1726 
1727   case 12:
1728 #line 175 &quot;WebCore/xml/XPathGrammar.y&quot;
1729     {
1730         std::unique_ptr&lt;Step::NodeTest&gt; nodeTest((yyvsp[(1) - (2)].nodeTest));
1731         std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;&gt; predicateList((yyvsp[(2) - (2)].expressionVector));
1732         if (predicateList)
1733             (yyval.step) = new Step(Step::ChildAxis, WTFMove(*nodeTest), WTFMove(*predicateList));
1734         else
1735             (yyval.step) = new Step(Step::ChildAxis, WTFMove(*nodeTest));
1736     ;}
1737     break;
1738 
1739   case 13:
1740 #line 185 &quot;WebCore/xml/XPathGrammar.y&quot;
1741     {
1742         String nametest = adoptRef((yyvsp[(1) - (2)].string));
1743         std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;&gt; predicateList((yyvsp[(2) - (2)].expressionVector));
1744 
1745         String localName;
1746         String namespaceURI;
1747         if (!parser.expandQualifiedName(nametest, localName, namespaceURI)) {
1748             (yyval.step) = nullptr;
1749             YYABORT;
1750         }
1751 
1752         if (predicateList)
1753             (yyval.step) = new Step(Step::ChildAxis, Step::NodeTest(Step::NodeTest::NameTest, localName, namespaceURI), WTFMove(*predicateList));
1754         else
1755             (yyval.step) = new Step(Step::ChildAxis, Step::NodeTest(Step::NodeTest::NameTest, localName, namespaceURI));
1756     ;}
1757     break;
1758 
1759   case 14:
1760 #line 203 &quot;WebCore/xml/XPathGrammar.y&quot;
1761     {
1762         std::unique_ptr&lt;Step::NodeTest&gt; nodeTest((yyvsp[(2) - (3)].nodeTest));
1763         std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;&gt; predicateList((yyvsp[(3) - (3)].expressionVector));
1764 
1765         if (predicateList)
1766             (yyval.step) = new Step((yyvsp[(1) - (3)].axis), WTFMove(*nodeTest), WTFMove(*predicateList));
1767         else
1768             (yyval.step) = new Step((yyvsp[(1) - (3)].axis), WTFMove(*nodeTest));
1769     ;}
1770     break;
1771 
1772   case 15:
1773 #line 214 &quot;WebCore/xml/XPathGrammar.y&quot;
1774     {
1775         String nametest = adoptRef((yyvsp[(2) - (3)].string));
1776         std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;&gt; predicateList((yyvsp[(3) - (3)].expressionVector));
1777 
1778         String localName;
1779         String namespaceURI;
1780         if (!parser.expandQualifiedName(nametest, localName, namespaceURI)) {
1781             (yyval.step) = nullptr;
1782             YYABORT;
1783         }
1784 
1785         if (predicateList)
1786             (yyval.step) = new Step((yyvsp[(1) - (3)].axis), Step::NodeTest(Step::NodeTest::NameTest, localName, namespaceURI), WTFMove(*predicateList));
1787         else
1788             (yyval.step) = new Step((yyvsp[(1) - (3)].axis), Step::NodeTest(Step::NodeTest::NameTest, localName, namespaceURI));
1789     ;}
1790     break;
1791 
1792   case 18:
1793 #line 238 &quot;WebCore/xml/XPathGrammar.y&quot;
1794     {
1795         (yyval.axis) = Step::AttributeAxis;
1796     ;}
1797     break;
1798 
1799   case 19:
1800 #line 245 &quot;WebCore/xml/XPathGrammar.y&quot;
1801     {
1802         (yyval.nodeTest) = new Step::NodeTest(Step::NodeTest::AnyNodeTest);
1803     ;}
1804     break;
1805 
1806   case 20:
1807 #line 250 &quot;WebCore/xml/XPathGrammar.y&quot;
1808     {
1809         (yyval.nodeTest) = new Step::NodeTest(Step::NodeTest::TextNodeTest);
1810     ;}
1811     break;
1812 
1813   case 21:
1814 #line 255 &quot;WebCore/xml/XPathGrammar.y&quot;
1815     {
1816         (yyval.nodeTest) = new Step::NodeTest(Step::NodeTest::CommentNodeTest);
1817     ;}
1818     break;
1819 
1820   case 22:
1821 #line 260 &quot;WebCore/xml/XPathGrammar.y&quot;
1822     {
1823         (yyval.nodeTest) = new Step::NodeTest(Step::NodeTest::ProcessingInstructionNodeTest);
1824     ;}
1825     break;
1826 
1827   case 23:
1828 #line 265 &quot;WebCore/xml/XPathGrammar.y&quot;
1829     {
1830         String literal = adoptRef((yyvsp[(3) - (4)].string));
1831         (yyval.nodeTest) = new Step::NodeTest(Step::NodeTest::ProcessingInstructionNodeTest, literal.stripWhiteSpace());
1832     ;}
1833     break;
1834 
1835   case 24:
1836 #line 273 &quot;WebCore/xml/XPathGrammar.y&quot;
1837     {
1838         (yyval.expressionVector) = nullptr;
1839     ;}
1840     break;
1841 
1842   case 26:
1843 #line 282 &quot;WebCore/xml/XPathGrammar.y&quot;
1844     {
1845         (yyval.expressionVector) = new Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;;
1846         (yyval.expressionVector)-&gt;append(std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (1)].expression)));
1847     ;}
1848     break;
1849 
1850   case 27:
1851 #line 288 &quot;WebCore/xml/XPathGrammar.y&quot;
1852     {
1853         (yyval.expressionVector) = (yyvsp[(1) - (2)].expressionVector);
1854         (yyval.expressionVector)-&gt;append(std::unique_ptr&lt;Expression&gt;((yyvsp[(2) - (2)].expression)));
1855     ;}
1856     break;
1857 
1858   case 28:
1859 #line 296 &quot;WebCore/xml/XPathGrammar.y&quot;
1860     {
1861         (yyval.expression) = (yyvsp[(2) - (3)].expression);
1862     ;}
1863     break;
1864 
1865   case 29:
1866 #line 303 &quot;WebCore/xml/XPathGrammar.y&quot;
1867     {
1868         (yyval.step) = new Step(Step::DescendantOrSelfAxis, Step::NodeTest(Step::NodeTest::AnyNodeTest));
1869     ;}
1870     break;
1871 
1872   case 30:
1873 #line 310 &quot;WebCore/xml/XPathGrammar.y&quot;
1874     {
1875         (yyval.step) = new Step(Step::SelfAxis, Step::NodeTest(Step::NodeTest::AnyNodeTest));
1876     ;}
1877     break;
1878 
1879   case 31:
1880 #line 315 &quot;WebCore/xml/XPathGrammar.y&quot;
1881     {
1882         (yyval.step) = new Step(Step::ParentAxis, Step::NodeTest(Step::NodeTest::AnyNodeTest));
1883     ;}
1884     break;
1885 
1886   case 32:
1887 #line 322 &quot;WebCore/xml/XPathGrammar.y&quot;
1888     {
1889         String name = adoptRef((yyvsp[(1) - (1)].string));
1890         (yyval.expression) = new VariableReference(name);
1891     ;}
1892     break;
1893 
1894   case 33:
1895 #line 328 &quot;WebCore/xml/XPathGrammar.y&quot;
1896     {
1897         (yyval.expression) = (yyvsp[(2) - (3)].expression);
1898     ;}
1899     break;
1900 
1901   case 34:
1902 #line 333 &quot;WebCore/xml/XPathGrammar.y&quot;
1903     {
1904         String literal = adoptRef((yyvsp[(1) - (1)].string));
1905         (yyval.expression) = new StringExpression(WTFMove(literal));
1906     ;}
1907     break;
1908 
1909   case 35:
1910 #line 339 &quot;WebCore/xml/XPathGrammar.y&quot;
1911     {
1912         String numeral = adoptRef((yyvsp[(1) - (1)].string));
1913         (yyval.expression) = new Number(numeral.toDouble());
1914     ;}
1915     break;
1916 
1917   case 37:
1918 #line 349 &quot;WebCore/xml/XPathGrammar.y&quot;
1919     {
1920         String name = adoptRef((yyvsp[(1) - (3)].string));
1921         (yyval.expression) = XPath::Function::create(name).release();
1922         if (!(yyval.expression))
1923             YYABORT;
1924     ;}
1925     break;
1926 
1927   case 38:
1928 #line 357 &quot;WebCore/xml/XPathGrammar.y&quot;
1929     {
1930         String name = adoptRef((yyvsp[(1) - (4)].string));
1931         std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;&gt; argumentList((yyvsp[(3) - (4)].expressionVector));
1932         (yyval.expression) = XPath::Function::create(name, WTFMove(*argumentList)).release();
1933         if (!(yyval.expression))
1934             YYABORT;
1935     ;}
1936     break;
1937 
1938   case 39:
1939 #line 368 &quot;WebCore/xml/XPathGrammar.y&quot;
1940     {
1941         (yyval.expressionVector) = new Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;;
1942         (yyval.expressionVector)-&gt;append(std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (1)].expression)));
1943     ;}
1944     break;
1945 
1946   case 40:
1947 #line 374 &quot;WebCore/xml/XPathGrammar.y&quot;
1948     {
1949         (yyval.expressionVector) = (yyvsp[(1) - (3)].expressionVector);
1950         (yyval.expressionVector)-&gt;append(std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
1951     ;}
1952     break;
1953 
1954   case 43:
1955 #line 388 &quot;WebCore/xml/XPathGrammar.y&quot;
1956     {
1957         (yyval.expression) = new Union(std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
1958     ;}
1959     break;
1960 
1961   case 44:
1962 #line 395 &quot;WebCore/xml/XPathGrammar.y&quot;
1963     {
1964         (yyval.expression) = (yyvsp[(1) - (1)].locationPath);
1965     ;}
1966     break;
1967 
1968   case 46:
1969 #line 402 &quot;WebCore/xml/XPathGrammar.y&quot;
1970     {
1971         (yyvsp[(3) - (3)].locationPath)-&gt;setAbsolute();
<a name="4" id="anc4"></a><span class="line-modified">1972         (yyval.expression) = new Path(std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;LocationPath&gt;((yyvsp[(3) - (3)].locationPath)));</span>
1973     ;}
1974     break;
1975 
1976   case 47:
1977 #line 408 &quot;WebCore/xml/XPathGrammar.y&quot;
1978     {
1979         (yyvsp[(3) - (3)].locationPath)-&gt;prependStep(std::unique_ptr&lt;Step&gt;((yyvsp[(2) - (3)].step)));
1980         (yyvsp[(3) - (3)].locationPath)-&gt;setAbsolute();
<a name="5" id="anc5"></a><span class="line-modified">1981         (yyval.expression) = new Path(std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;LocationPath&gt;((yyvsp[(3) - (3)].locationPath)));</span>
1982     ;}
1983     break;
1984 
1985   case 49:
1986 #line 419 &quot;WebCore/xml/XPathGrammar.y&quot;
1987     {
1988         std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;Expression&gt;&gt;&gt; predicateList((yyvsp[(2) - (2)].expressionVector));
1989         (yyval.expression) = new Filter(std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (2)].expression)), WTFMove(*predicateList));
1990     ;}
1991     break;
1992 
1993   case 51:
1994 #line 429 &quot;WebCore/xml/XPathGrammar.y&quot;
1995     {
1996         (yyval.expression) = new LogicalOp(LogicalOp::OP_Or, std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
1997     ;}
1998     break;
1999 
2000   case 53:
2001 #line 438 &quot;WebCore/xml/XPathGrammar.y&quot;
2002     {
2003         (yyval.expression) = new LogicalOp(LogicalOp::OP_And, std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
2004     ;}
2005     break;
2006 
2007   case 55:
2008 #line 447 &quot;WebCore/xml/XPathGrammar.y&quot;
2009     {
2010         (yyval.expression) = new EqTestOp((yyvsp[(2) - (3)].equalityTestOpcode), std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
2011     ;}
2012     break;
2013 
2014   case 57:
2015 #line 456 &quot;WebCore/xml/XPathGrammar.y&quot;
2016     {
2017         (yyval.expression) = new EqTestOp((yyvsp[(2) - (3)].equalityTestOpcode), std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
2018     ;}
2019     break;
2020 
2021   case 59:
2022 #line 465 &quot;WebCore/xml/XPathGrammar.y&quot;
2023     {
2024         (yyval.expression) = new NumericOp(NumericOp::OP_Add, std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
2025     ;}
2026     break;
2027 
2028   case 60:
2029 #line 470 &quot;WebCore/xml/XPathGrammar.y&quot;
2030     {
2031         (yyval.expression) = new NumericOp(NumericOp::OP_Sub, std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
2032     ;}
2033     break;
2034 
2035   case 62:
2036 #line 479 &quot;WebCore/xml/XPathGrammar.y&quot;
2037     {
2038         (yyval.expression) = new NumericOp((yyvsp[(2) - (3)].numericOpcode), std::unique_ptr&lt;Expression&gt;((yyvsp[(1) - (3)].expression)), std::unique_ptr&lt;Expression&gt;((yyvsp[(3) - (3)].expression)));
2039     ;}
2040     break;
2041 
2042   case 64:
2043 #line 488 &quot;WebCore/xml/XPathGrammar.y&quot;
2044     {
2045         (yyval.expression) = new Negative(std::unique_ptr&lt;Expression&gt;((yyvsp[(2) - (2)].expression)));
2046     ;}
2047     break;
2048 
2049 
2050 /* Line 1267 of yacc.c.  */
2051 #line 2049 &quot;./XPathGrammar.cpp&quot;
2052       default: break;
2053     }
2054   YY_SYMBOL_PRINT (&quot;-&gt; $$ =&quot;, yyr1[yyn], &amp;yyval, &amp;yyloc);
2055 
2056   YYPOPSTACK (yylen);
2057   yylen = 0;
2058   YY_STACK_PRINT (yyss, yyssp);
2059 
2060   *++yyvsp = yyval;
2061 
2062 
2063   /* Now `shift&#39; the result of the reduction.  Determine what state
2064      that goes to, based on the state we popped back to and the rule
2065      number reduced by.  */
2066 
2067   yyn = yyr1[yyn];
2068 
2069   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
2070   if (0 &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)
2071     yystate = yytable[yystate];
2072   else
2073     yystate = yydefgoto[yyn - YYNTOKENS];
2074 
2075   goto yynewstate;
2076 
2077 
2078 /*------------------------------------.
2079 | yyerrlab -- here on detecting error |
2080 `------------------------------------*/
2081 yyerrlab:
2082   /* If not already recovering from an error, report this error.  */
2083   if (!yyerrstatus)
2084     {
2085       ++yynerrs;
2086 #if ! YYERROR_VERBOSE
2087       yyerror (parser, YY_(&quot;syntax error&quot;));
2088 #else
2089       {
2090     YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
2091     if (yymsg_alloc &lt; yysize &amp;&amp; yymsg_alloc &lt; YYSTACK_ALLOC_MAXIMUM)
2092       {
2093         YYSIZE_T yyalloc = 2 * yysize;
2094         if (! (yysize &lt;= yyalloc &amp;&amp; yyalloc &lt;= YYSTACK_ALLOC_MAXIMUM))
2095           yyalloc = YYSTACK_ALLOC_MAXIMUM;
2096         if (yymsg != yymsgbuf)
2097           YYSTACK_FREE (yymsg);
2098         yymsg = (char *) YYSTACK_ALLOC (yyalloc);
2099         if (yymsg)
2100           yymsg_alloc = yyalloc;
2101         else
2102           {
2103         yymsg = yymsgbuf;
2104         yymsg_alloc = sizeof yymsgbuf;
2105           }
2106       }
2107 
2108     if (0 &lt; yysize &amp;&amp; yysize &lt;= yymsg_alloc)
2109       {
2110         (void) yysyntax_error (yymsg, yystate, yychar);
2111         yyerror (parser, yymsg);
2112       }
2113     else
2114       {
2115         yyerror (parser, YY_(&quot;syntax error&quot;));
2116         if (yysize != 0)
2117           goto yyexhaustedlab;
2118       }
2119       }
2120 #endif
2121     }
2122 
2123 
2124 
2125   if (yyerrstatus == 3)
2126     {
2127       /* If just tried and failed to reuse look-ahead token after an
2128      error, discard it.  */
2129 
2130       if (yychar &lt;= YYEOF)
2131     {
2132       /* Return failure if at end of input.  */
2133       if (yychar == YYEOF)
2134         YYABORT;
2135     }
2136       else
2137     {
2138       yydestruct (&quot;Error: discarding&quot;,
2139               yytoken, &amp;yylval, parser);
2140       yychar = YYEMPTY;
2141     }
2142     }
2143 
2144   /* Else will try to reuse look-ahead token after shifting the error
2145      token.  */
2146   goto yyerrlab1;
2147 
2148 
2149 /*---------------------------------------------------.
2150 | yyerrorlab -- error raised explicitly by YYERROR.  |
2151 `---------------------------------------------------*/
2152 yyerrorlab:
2153 
2154   /* Pacify compilers like GCC when the user code never invokes
2155      YYERROR and the label yyerrorlab therefore never appears in user
2156      code.  */
2157   IGNORE_CLANG_WARNINGS_BEGIN(&quot;unreachable-code&quot;)
2158   if (/*CONSTCOND*/ 0)
2159      goto yyerrorlab;
2160   IGNORE_CLANG_WARNINGS_END
2161 
2162   /* Do not reclaim the symbols of the rule which action triggered
2163      this YYERROR.  */
2164   YYPOPSTACK (yylen);
2165   yylen = 0;
2166   YY_STACK_PRINT (yyss, yyssp);
2167   yystate = *yyssp;
2168   goto yyerrlab1;
2169 
2170 
2171 /*-------------------------------------------------------------.
2172 | yyerrlab1 -- common code for both syntax error and YYERROR.  |
2173 `-------------------------------------------------------------*/
2174 yyerrlab1:
2175   yyerrstatus = 3;    /* Each real token shifted decrements this.  */
2176 
2177   for (;;)
2178     {
2179       yyn = yypact[yystate];
2180       if (yyn != YYPACT_NINF)
2181     {
2182       yyn += YYTERROR;
2183       if (0 &lt;= yyn &amp;&amp; yyn &lt;= YYLAST &amp;&amp; yycheck[yyn] == YYTERROR)
2184         {
2185           yyn = yytable[yyn];
2186           if (0 &lt; yyn)
2187         break;
2188         }
2189     }
2190 
2191       /* Pop the current state because it cannot handle the error token.  */
2192       if (yyssp == yyss)
2193     YYABORT;
2194 
2195 
2196       yydestruct (&quot;Error: popping&quot;,
2197           yystos[yystate], yyvsp, parser);
2198       YYPOPSTACK (1);
2199       yystate = *yyssp;
2200       YY_STACK_PRINT (yyss, yyssp);
2201     }
2202 
2203   if (yyn == YYFINAL)
2204     YYACCEPT;
2205 
2206   *++yyvsp = yylval;
2207 
2208 
2209   /* Shift the error token.  */
2210   YY_SYMBOL_PRINT (&quot;Shifting&quot;, yystos[yyn], yyvsp, yylsp);
2211 
2212   yystate = yyn;
2213   goto yynewstate;
2214 
2215 
2216 /*-------------------------------------.
2217 | yyacceptlab -- YYACCEPT comes here.  |
2218 `-------------------------------------*/
2219 yyacceptlab:
2220   yyresult = 0;
2221   goto yyreturn;
2222 
2223 /*-----------------------------------.
2224 | yyabortlab -- YYABORT comes here.  |
2225 `-----------------------------------*/
2226 yyabortlab:
2227   yyresult = 1;
2228   goto yyreturn;
2229 
2230 #ifndef yyoverflow
2231 /*-------------------------------------------------.
2232 | yyexhaustedlab -- memory exhaustion comes here.  |
2233 `-------------------------------------------------*/
2234 yyexhaustedlab:
2235   yyerror (parser, YY_(&quot;memory exhausted&quot;));
2236   yyresult = 2;
2237   /* Fall through.  */
2238 #endif
2239 
2240 yyreturn:
2241   if (yychar != YYEOF &amp;&amp; yychar != YYEMPTY)
2242      yydestruct (&quot;Cleanup: discarding lookahead&quot;,
2243          yytoken, &amp;yylval, parser);
2244   /* Do not reclaim the symbols of the rule which action triggered
2245      this YYABORT or YYACCEPT.  */
2246   YYPOPSTACK (yylen);
2247   YY_STACK_PRINT (yyss, yyssp);
2248   while (yyssp != yyss)
2249     {
2250       yydestruct (&quot;Cleanup: popping&quot;,
2251           yystos[*yyssp], yyvsp, parser);
2252       YYPOPSTACK (1);
2253     }
2254 #ifndef yyoverflow
2255   if (yyss != yyssa)
2256     YYSTACK_FREE (yyss);
2257 #endif
2258 #if YYERROR_VERBOSE
2259   if (yymsg != yymsgbuf)
2260     YYSTACK_FREE (yymsg);
2261 #endif
2262   /* Make sure YYID is used.  */
2263   return YYID (yyresult);
2264 }
2265 
2266 
2267 #line 493 &quot;WebCore/xml/XPathGrammar.y&quot;
2268 
2269 
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
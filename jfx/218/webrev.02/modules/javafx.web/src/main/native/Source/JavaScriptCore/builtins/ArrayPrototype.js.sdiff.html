<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/ArrayPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayIteratorPrototype.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFromSyncIteratorPrototype.js.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/ArrayPrototype.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
<span class="line-removed"> 27 @constructor</span>
<span class="line-removed"> 28 @globalPrivate</span>
<span class="line-removed"> 29 function ArrayIterator(iteratedObject, kind, iterationFunction)</span>
<span class="line-removed"> 30 {</span>
<span class="line-removed"> 31     &quot;use strict&quot;;</span>
<span class="line-removed"> 32 </span>
<span class="line-removed"> 33     @putByIdDirectPrivate(this, &quot;iteratedObject&quot;, iteratedObject);</span>
<span class="line-removed"> 34     @putByIdDirectPrivate(this, &quot;arrayIteratorKind&quot;, kind);</span>
<span class="line-removed"> 35     @putByIdDirectPrivate(this, &quot;arrayIteratorNextIndex&quot;, 0);</span>
<span class="line-removed"> 36     @putByIdDirectPrivate(this, &quot;arrayIteratorNext&quot;, iterationFunction);</span>
<span class="line-removed"> 37     @putByIdDirectPrivate(this, &quot;arrayIteratorIsDone&quot;, false);</span>
<span class="line-removed"> 38 }</span>
<span class="line-removed"> 39 </span>
<span class="line-removed"> 40 function values()</span>
<span class="line-removed"> 41 {</span>
<span class="line-removed"> 42     &quot;use strict&quot;;</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44     return new @ArrayIterator(@toObject(this, &quot;Array.prototype.values requires that |this| not be null or undefined&quot;), &quot;value&quot;, @arrayIteratorValueNext);</span>
<span class="line-removed"> 45 }</span>
<span class="line-removed"> 46 </span>
<span class="line-removed"> 47 function keys()</span>
<span class="line-removed"> 48 {</span>
<span class="line-removed"> 49     &quot;use strict&quot;;</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51     return new @ArrayIterator(@toObject(this, &quot;Array.prototype.keys requires that |this| not be null or undefined&quot;), &quot;key&quot;, @arrayIteratorKeyNext);</span>
<span class="line-removed"> 52 }</span>
<span class="line-removed"> 53 </span>
<span class="line-removed"> 54 function entries()</span>
<span class="line-removed"> 55 {</span>
<span class="line-removed"> 56     &quot;use strict&quot;;</span>
<span class="line-removed"> 57 </span>
<span class="line-removed"> 58     return new @ArrayIterator(@toObject(this, &quot;Array.prototype.entries requires that |this| not be null or undefined&quot;), &quot;key+value&quot;, @arrayIteratorKeyValueNext);</span>
<span class="line-removed"> 59 }</span>
<span class="line-removed"> 60 </span>
 61 function reduce(callback /*, initialValue */)
 62 {
 63     &quot;use strict&quot;;
 64 
 65     var array = @toObject(this, &quot;Array.prototype.reduce requires that |this| not be null or undefined&quot;);
 66     var length = @toLength(array.length);
 67 
 68     if (typeof callback !== &quot;function&quot;)
 69         @throwTypeError(&quot;Array.prototype.reduce callback must be a function&quot;);
 70 
 71     var argumentCount = @argumentCount();
 72     if (length === 0 &amp;&amp; argumentCount &lt; 2)
 73         @throwTypeError(&quot;reduce of empty array with no initial value&quot;);
 74 
 75     var accumulator, k = 0;
 76     if (argumentCount &gt; 1)
 77         accumulator = @argument(1);
 78     else {
 79         while (k &lt; length &amp;&amp; !(k in array))
 80             k += 1;
</pre>
<hr />
<pre>
334     for (; index &lt; length; ++index) {
335         currentElement = array[index];
336         // Use SameValueZero comparison, rather than just StrictEquals.
337         if (searchElement === currentElement || (searchElement !== searchElement &amp;&amp; currentElement !== currentElement))
338             return true;
339     }
340     return false;
341 }
342 
343 function sort(comparator)
344 {
345     &quot;use strict&quot;;
346 
347     function min(a, b)
348     {
349         return a &lt; b ? a : b;
350     }
351 
352     function stringComparator(a, b)
353     {
<span class="line-modified">354         let aString = a.string;</span>
<span class="line-modified">355         let bString = b.string;</span>
356 
<span class="line-modified">357         let aLength = aString.length;</span>
<span class="line-modified">358         let bLength = bString.length;</span>
<span class="line-modified">359         let length = min(aLength, bLength);</span>
360 
<span class="line-modified">361         for (let i = 0; i &lt; length; ++i) {</span>
<span class="line-modified">362             let aCharCode = aString.@charCodeAt(i);</span>
<span class="line-modified">363             let bCharCode = bString.@charCodeAt(i);</span>
364 
365             if (aCharCode == bCharCode)
366                 continue;
367 
368             return aCharCode - bCharCode;
369         }
370 
371         return aLength - bLength;
372     }
373 
374     // Move undefineds and holes to the end of a sparse array. Result is [values..., undefineds..., holes...].
375     function compactSparse(array, dst, src, length)
376     {
<span class="line-modified">377         let values = [ ];</span>
<span class="line-modified">378         let seen = { };</span>
<span class="line-modified">379         let valueCount = 0;</span>
<span class="line-modified">380         let undefinedCount = 0;</span>
381 
382         // Clean up after the in-progress non-sparse compaction that failed.
<span class="line-modified">383         for (let i = dst; i &lt; src; ++i)</span>
384             delete array[i];
385 
<span class="line-modified">386         for (let object = array; object; object = @Object.@getPrototypeOf(object)) {</span>
<span class="line-modified">387             let propertyNames = @Object.@getOwnPropertyNames(object);</span>
<span class="line-modified">388             for (let i = 0; i &lt; propertyNames.length; ++i) {</span>
<span class="line-modified">389                 let index = propertyNames[i];</span>
390                 if (index &lt; length) { // Exclude non-numeric properties and properties past length.
391                     if (seen[index]) // Exclude duplicates.
392                         continue;
393                     seen[index] = 1;
394 
<span class="line-modified">395                     let value = array[index];</span>
396                     delete array[index];
397 
398                     if (value === @undefined) {
399                         ++undefinedCount;
400                         continue;
401                     }
402 
403                     array[valueCount++] = value;
404                 }
405             }
406         }
407 
<span class="line-modified">408         for (let i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
409             array[i] = @undefined;
410 
411         return valueCount;
412     }
413 
414     function compactSlow(array, length)
415     {
<span class="line-modified">416         let holeCount = 0;</span>
417 
<span class="line-modified">418         let dst = 0;</span>
<span class="line-modified">419         let src = 0;</span>
420         for (; src &lt; length; ++src) {
421             if (!(src in array)) {
422                 ++holeCount;
423                 if (holeCount &lt; 256)
424                     continue;
425                 return compactSparse(array, dst, src, length);
426             }
427 
<span class="line-modified">428             let value = array[src];</span>
429             if (value === @undefined)
430                 continue;
431 
432             array[dst++] = value;
433         }
434 
<span class="line-modified">435         let valueCount = dst;</span>
<span class="line-modified">436         let undefinedCount = length - valueCount - holeCount;</span>
437 
<span class="line-modified">438         for (let i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
439             array[i] = @undefined;
440 
<span class="line-modified">441         for (let i = valueCount + undefinedCount; i &lt; length; ++i)</span>
442             delete array[i];
443 
444         return valueCount;
445     }
446 
447     // Move undefineds and holes to the end of an array. Result is [values..., undefineds..., holes...].
448     function compact(array, length)
449     {
<span class="line-modified">450         for (let i = 0; i &lt; array.length; ++i) {</span>
451             if (array[i] === @undefined)
452                 return compactSlow(array, length);
453         }
454 
455         return length;
456     }
457 
458     function merge(dst, src, srcIndex, srcEnd, width, comparator)
459     {
<span class="line-modified">460         let left = srcIndex;</span>
<span class="line-modified">461         let leftEnd = min(left + width, srcEnd);</span>
<span class="line-modified">462         let right = leftEnd;</span>
<span class="line-modified">463         let rightEnd = min(right + width, srcEnd);</span>
464 
<span class="line-modified">465         for (let dstIndex = left; dstIndex &lt; rightEnd; ++dstIndex) {</span>
466             if (right &lt; rightEnd) {
467                 if (left &gt;= leftEnd) {
468                     dst[dstIndex] = src[right++];
469                     continue;
470                 }
471 
<span class="line-modified">472                 let comparisonResult = comparator(src[right], src[left]);</span>
473                 if ((typeof comparisonResult === &quot;boolean&quot; &amp;&amp; !comparisonResult) || comparisonResult &lt; 0) {
474                     dst[dstIndex] = src[right++];
475                     continue;
476                 }
477 
478             }
479 
480             dst[dstIndex] = src[left++];
481         }
482     }
483 
484     function mergeSort(array, valueCount, comparator)
485     {
<span class="line-modified">486         let buffer = [ ];</span>
487         buffer.length = valueCount;
488 
<span class="line-modified">489         let dst = buffer;</span>
<span class="line-modified">490         let src = array;</span>
<span class="line-modified">491         for (let width = 1; width &lt; valueCount; width *= 2) {</span>
<span class="line-modified">492             for (let srcIndex = 0; srcIndex &lt; valueCount; srcIndex += 2 * width)</span>
493                 merge(dst, src, srcIndex, valueCount, width, comparator);
494 
<span class="line-modified">495             let tmp = src;</span>
496             src = dst;
497             dst = tmp;
498         }
499 
500         if (src != array) {
<span class="line-modified">501             for(let i = 0; i &lt; valueCount; i++)</span>
502                 array[i] = src[i];
503         }
504     }
505 
506     function bucketSort(array, dst, bucket, depth)
507     {
508         if (bucket.length &lt; 32 || depth &gt; 32) {
509             mergeSort(bucket, bucket.length, stringComparator);
<span class="line-modified">510             for (let i = 0; i &lt; bucket.length; ++i)</span>
511                 array[dst++] = bucket[i].value;
512             return dst;
513         }
514 
<span class="line-modified">515         let buckets = [ ];</span>
<span class="line-modified">516         for (let i = 0; i &lt; bucket.length; ++i) {</span>
<span class="line-modified">517             let entry = bucket[i];</span>
<span class="line-modified">518             let string = entry.string;</span>
519             if (string.length == depth) {
520                 array[dst++] = entry.value;
521                 continue;
522             }
523 
<span class="line-modified">524             let c = string.@charCodeAt(depth);</span>
525             if (!buckets[c])
526                 buckets[c] = [ ];
527             buckets[c][buckets[c].length] = entry;
528         }
529 
<span class="line-modified">530         for (let i = 0; i &lt; buckets.length; ++i) {</span>
531             if (!buckets[i])
532                 continue;
533             dst = bucketSort(array, dst, buckets[i], depth + 1);
534         }
535 
536         return dst;
537     }
538 
539     function comparatorSort(array, length, comparator)
540     {
<span class="line-modified">541         let valueCount = compact(array, length);</span>
542         mergeSort(array, valueCount, comparator);
543     }
544 
545     function stringSort(array, length)
546     {
<span class="line-modified">547         let valueCount = compact(array, length);</span>
548 
<span class="line-modified">549         let strings = @newArrayWithSize(valueCount);</span>
<span class="line-modified">550         for (let i = 0; i &lt; valueCount; ++i)</span>
551             strings[i] = { string: @toString(array[i]), value: array[i] };
552 
553         bucketSort(array, 0, strings, 0);
554     }
555 
<span class="line-modified">556     let sortFunction;</span>
557     if (typeof comparator == &quot;function&quot;)
558         sortFunction = comparatorSort;
559     else if (comparator === @undefined)
560         sortFunction = stringSort;
561     else
562         @throwTypeError(&quot;Array.prototype.sort requires the comparsion function be a function or undefined&quot;);
563 
<span class="line-modified">564     let array = @toObject(this, &quot;Array.prototype.sort requires that |this| not be null or undefined&quot;);</span>
565 
<span class="line-modified">566     let length = @toLength(array.length);</span>
567 
568     // For compatibility with Firefox and Chrome, do nothing observable
569     // to the target array if it has 0 or 1 sortable properties.
570     if (length &lt; 2)
571         return array;
572 
573     sortFunction(array, length, comparator);
574     return array;
575 }
576 
577 @globalPrivate
578 function concatSlowPath()
579 {
580     &quot;use strict&quot;;
581 
582     var currentElement = @toObject(this, &quot;Array.prototype.concat requires that |this| not be null or undefined&quot;);
583     var argCount = arguments.length;
584 
585     var result = @arraySpeciesCreate(currentElement, 0);
586     var resultIsArray = @isJSArray(result);
587 
588     var resultIndex = 0;
589     var argIndex = 0;
590 
591     do {
<span class="line-modified">592         let spreadable = @isObject(currentElement) &amp;&amp; currentElement.@isConcatSpreadableSymbol;</span>
593         if ((spreadable === @undefined &amp;&amp; @isArray(currentElement)) || spreadable) {
<span class="line-modified">594             let length = @toLength(currentElement.length);</span>
595             if (length + resultIndex &gt; @MAX_ARRAY_INDEX)
596                 @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
597             if (resultIsArray &amp;&amp; @isJSArray(currentElement)) {
598                 @appendMemcpy(result, currentElement, resultIndex);
599                 resultIndex += length;
600             } else {
601                 for (var i = 0; i &lt; length; i++) {
602                     if (i in currentElement)
603                         @putByValDirect(result, resultIndex, currentElement[i]);
604                     resultIndex++;
605                 }
606             }
607         } else {
608             if (resultIndex &gt;= @MAX_ARRAY_INDEX)
609                 @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
610             @putByValDirect(result, resultIndex++, currentElement);
611         }
612         currentElement = arguments[argIndex];
613     } while (argIndex++ &lt; argCount);
614 
615     result.length = resultIndex;
616     return result;
617 }
618 
619 function concat(first)
620 {
621     &quot;use strict&quot;;
622 
623     if (@argumentCount() === 1
624         &amp;&amp; @isJSArray(this)
625         &amp;&amp; this.@isConcatSpreadableSymbol === @undefined
626         &amp;&amp; (!@isObject(first) || (!@isProxyObject(first) &amp;&amp; first.@isConcatSpreadableSymbol === @undefined))) {
627 
<span class="line-modified">628         let result = @concatMemcpy(this, first);</span>
629         if (result !== null)
630             return result;
631     }
632 
633     return @tailCallForwardArguments(@concatSlowPath, this);
634 }
635 
636 function copyWithin(target, start /*, end */)
637 {
638     &quot;use strict&quot;;
639 
640     function maxWithPositives(a, b)
641     {
642         return (a &lt; b) ? b : a;
643     }
644 
645     function minWithMaybeNegativeZeroAndPositive(maybeNegativeZero, positive)
646     {
647         return (maybeNegativeZero &lt; positive) ? maybeNegativeZero : positive;
648     }
</pre>
</td>
<td>
<hr />
<pre>
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 


































 27 function reduce(callback /*, initialValue */)
 28 {
 29     &quot;use strict&quot;;
 30 
 31     var array = @toObject(this, &quot;Array.prototype.reduce requires that |this| not be null or undefined&quot;);
 32     var length = @toLength(array.length);
 33 
 34     if (typeof callback !== &quot;function&quot;)
 35         @throwTypeError(&quot;Array.prototype.reduce callback must be a function&quot;);
 36 
 37     var argumentCount = @argumentCount();
 38     if (length === 0 &amp;&amp; argumentCount &lt; 2)
 39         @throwTypeError(&quot;reduce of empty array with no initial value&quot;);
 40 
 41     var accumulator, k = 0;
 42     if (argumentCount &gt; 1)
 43         accumulator = @argument(1);
 44     else {
 45         while (k &lt; length &amp;&amp; !(k in array))
 46             k += 1;
</pre>
<hr />
<pre>
300     for (; index &lt; length; ++index) {
301         currentElement = array[index];
302         // Use SameValueZero comparison, rather than just StrictEquals.
303         if (searchElement === currentElement || (searchElement !== searchElement &amp;&amp; currentElement !== currentElement))
304             return true;
305     }
306     return false;
307 }
308 
309 function sort(comparator)
310 {
311     &quot;use strict&quot;;
312 
313     function min(a, b)
314     {
315         return a &lt; b ? a : b;
316     }
317 
318     function stringComparator(a, b)
319     {
<span class="line-modified">320         var aString = a.string;</span>
<span class="line-modified">321         var bString = b.string;</span>
322 
<span class="line-modified">323         var aLength = aString.length;</span>
<span class="line-modified">324         var bLength = bString.length;</span>
<span class="line-modified">325         var length = min(aLength, bLength);</span>
326 
<span class="line-modified">327         for (var i = 0; i &lt; length; ++i) {</span>
<span class="line-modified">328             var aCharCode = aString.@charCodeAt(i);</span>
<span class="line-modified">329             var bCharCode = bString.@charCodeAt(i);</span>
330 
331             if (aCharCode == bCharCode)
332                 continue;
333 
334             return aCharCode - bCharCode;
335         }
336 
337         return aLength - bLength;
338     }
339 
340     // Move undefineds and holes to the end of a sparse array. Result is [values..., undefineds..., holes...].
341     function compactSparse(array, dst, src, length)
342     {
<span class="line-modified">343         var values = [ ];</span>
<span class="line-modified">344         var seen = { };</span>
<span class="line-modified">345         var valueCount = 0;</span>
<span class="line-modified">346         var undefinedCount = 0;</span>
347 
348         // Clean up after the in-progress non-sparse compaction that failed.
<span class="line-modified">349         for (var i = dst; i &lt; src; ++i)</span>
350             delete array[i];
351 
<span class="line-modified">352         for (var object = array; object; object = @Object.@getPrototypeOf(object)) {</span>
<span class="line-modified">353             var propertyNames = @Object.@getOwnPropertyNames(object);</span>
<span class="line-modified">354             for (var i = 0; i &lt; propertyNames.length; ++i) {</span>
<span class="line-modified">355                 var index = propertyNames[i];</span>
356                 if (index &lt; length) { // Exclude non-numeric properties and properties past length.
357                     if (seen[index]) // Exclude duplicates.
358                         continue;
359                     seen[index] = 1;
360 
<span class="line-modified">361                     var value = array[index];</span>
362                     delete array[index];
363 
364                     if (value === @undefined) {
365                         ++undefinedCount;
366                         continue;
367                     }
368 
369                     array[valueCount++] = value;
370                 }
371             }
372         }
373 
<span class="line-modified">374         for (var i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
375             array[i] = @undefined;
376 
377         return valueCount;
378     }
379 
380     function compactSlow(array, length)
381     {
<span class="line-modified">382         var holeCount = 0;</span>
383 
<span class="line-modified">384         var dst = 0;</span>
<span class="line-modified">385         var src = 0;</span>
386         for (; src &lt; length; ++src) {
387             if (!(src in array)) {
388                 ++holeCount;
389                 if (holeCount &lt; 256)
390                     continue;
391                 return compactSparse(array, dst, src, length);
392             }
393 
<span class="line-modified">394             var value = array[src];</span>
395             if (value === @undefined)
396                 continue;
397 
398             array[dst++] = value;
399         }
400 
<span class="line-modified">401         var valueCount = dst;</span>
<span class="line-modified">402         var undefinedCount = length - valueCount - holeCount;</span>
403 
<span class="line-modified">404         for (var i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
405             array[i] = @undefined;
406 
<span class="line-modified">407         for (var i = valueCount + undefinedCount; i &lt; length; ++i)</span>
408             delete array[i];
409 
410         return valueCount;
411     }
412 
413     // Move undefineds and holes to the end of an array. Result is [values..., undefineds..., holes...].
414     function compact(array, length)
415     {
<span class="line-modified">416         for (var i = 0; i &lt; array.length; ++i) {</span>
417             if (array[i] === @undefined)
418                 return compactSlow(array, length);
419         }
420 
421         return length;
422     }
423 
424     function merge(dst, src, srcIndex, srcEnd, width, comparator)
425     {
<span class="line-modified">426         var left = srcIndex;</span>
<span class="line-modified">427         var leftEnd = min(left + width, srcEnd);</span>
<span class="line-modified">428         var right = leftEnd;</span>
<span class="line-modified">429         var rightEnd = min(right + width, srcEnd);</span>
430 
<span class="line-modified">431         for (var dstIndex = left; dstIndex &lt; rightEnd; ++dstIndex) {</span>
432             if (right &lt; rightEnd) {
433                 if (left &gt;= leftEnd) {
434                     dst[dstIndex] = src[right++];
435                     continue;
436                 }
437 
<span class="line-modified">438                 var comparisonResult = comparator(src[right], src[left]);</span>
439                 if ((typeof comparisonResult === &quot;boolean&quot; &amp;&amp; !comparisonResult) || comparisonResult &lt; 0) {
440                     dst[dstIndex] = src[right++];
441                     continue;
442                 }
443 
444             }
445 
446             dst[dstIndex] = src[left++];
447         }
448     }
449 
450     function mergeSort(array, valueCount, comparator)
451     {
<span class="line-modified">452         var buffer = [ ];</span>
453         buffer.length = valueCount;
454 
<span class="line-modified">455         var dst = buffer;</span>
<span class="line-modified">456         var src = array;</span>
<span class="line-modified">457         for (var width = 1; width &lt; valueCount; width *= 2) {</span>
<span class="line-modified">458             for (var srcIndex = 0; srcIndex &lt; valueCount; srcIndex += 2 * width)</span>
459                 merge(dst, src, srcIndex, valueCount, width, comparator);
460 
<span class="line-modified">461             var tmp = src;</span>
462             src = dst;
463             dst = tmp;
464         }
465 
466         if (src != array) {
<span class="line-modified">467             for(var i = 0; i &lt; valueCount; i++)</span>
468                 array[i] = src[i];
469         }
470     }
471 
472     function bucketSort(array, dst, bucket, depth)
473     {
474         if (bucket.length &lt; 32 || depth &gt; 32) {
475             mergeSort(bucket, bucket.length, stringComparator);
<span class="line-modified">476             for (var i = 0; i &lt; bucket.length; ++i)</span>
477                 array[dst++] = bucket[i].value;
478             return dst;
479         }
480 
<span class="line-modified">481         var buckets = [ ];</span>
<span class="line-modified">482         for (var i = 0; i &lt; bucket.length; ++i) {</span>
<span class="line-modified">483             var entry = bucket[i];</span>
<span class="line-modified">484             var string = entry.string;</span>
485             if (string.length == depth) {
486                 array[dst++] = entry.value;
487                 continue;
488             }
489 
<span class="line-modified">490             var c = string.@charCodeAt(depth);</span>
491             if (!buckets[c])
492                 buckets[c] = [ ];
493             buckets[c][buckets[c].length] = entry;
494         }
495 
<span class="line-modified">496         for (var i = 0; i &lt; buckets.length; ++i) {</span>
497             if (!buckets[i])
498                 continue;
499             dst = bucketSort(array, dst, buckets[i], depth + 1);
500         }
501 
502         return dst;
503     }
504 
505     function comparatorSort(array, length, comparator)
506     {
<span class="line-modified">507         var valueCount = compact(array, length);</span>
508         mergeSort(array, valueCount, comparator);
509     }
510 
511     function stringSort(array, length)
512     {
<span class="line-modified">513         var valueCount = compact(array, length);</span>
514 
<span class="line-modified">515         var strings = @newArrayWithSize(valueCount);</span>
<span class="line-modified">516         for (var i = 0; i &lt; valueCount; ++i)</span>
517             strings[i] = { string: @toString(array[i]), value: array[i] };
518 
519         bucketSort(array, 0, strings, 0);
520     }
521 
<span class="line-modified">522     var sortFunction;</span>
523     if (typeof comparator == &quot;function&quot;)
524         sortFunction = comparatorSort;
525     else if (comparator === @undefined)
526         sortFunction = stringSort;
527     else
528         @throwTypeError(&quot;Array.prototype.sort requires the comparsion function be a function or undefined&quot;);
529 
<span class="line-modified">530     var array = @toObject(this, &quot;Array.prototype.sort requires that |this| not be null or undefined&quot;);</span>
531 
<span class="line-modified">532     var length = @toLength(array.length);</span>
533 
534     // For compatibility with Firefox and Chrome, do nothing observable
535     // to the target array if it has 0 or 1 sortable properties.
536     if (length &lt; 2)
537         return array;
538 
539     sortFunction(array, length, comparator);
540     return array;
541 }
542 
543 @globalPrivate
544 function concatSlowPath()
545 {
546     &quot;use strict&quot;;
547 
548     var currentElement = @toObject(this, &quot;Array.prototype.concat requires that |this| not be null or undefined&quot;);
549     var argCount = arguments.length;
550 
551     var result = @arraySpeciesCreate(currentElement, 0);
552     var resultIsArray = @isJSArray(result);
553 
554     var resultIndex = 0;
555     var argIndex = 0;
556 
557     do {
<span class="line-modified">558         var spreadable = @isObject(currentElement) &amp;&amp; currentElement.@isConcatSpreadableSymbol;</span>
559         if ((spreadable === @undefined &amp;&amp; @isArray(currentElement)) || spreadable) {
<span class="line-modified">560             var length = @toLength(currentElement.length);</span>
561             if (length + resultIndex &gt; @MAX_ARRAY_INDEX)
562                 @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
563             if (resultIsArray &amp;&amp; @isJSArray(currentElement)) {
564                 @appendMemcpy(result, currentElement, resultIndex);
565                 resultIndex += length;
566             } else {
567                 for (var i = 0; i &lt; length; i++) {
568                     if (i in currentElement)
569                         @putByValDirect(result, resultIndex, currentElement[i]);
570                     resultIndex++;
571                 }
572             }
573         } else {
574             if (resultIndex &gt;= @MAX_ARRAY_INDEX)
575                 @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
576             @putByValDirect(result, resultIndex++, currentElement);
577         }
578         currentElement = arguments[argIndex];
579     } while (argIndex++ &lt; argCount);
580 
581     result.length = resultIndex;
582     return result;
583 }
584 
585 function concat(first)
586 {
587     &quot;use strict&quot;;
588 
589     if (@argumentCount() === 1
590         &amp;&amp; @isJSArray(this)
591         &amp;&amp; this.@isConcatSpreadableSymbol === @undefined
592         &amp;&amp; (!@isObject(first) || (!@isProxyObject(first) &amp;&amp; first.@isConcatSpreadableSymbol === @undefined))) {
593 
<span class="line-modified">594         var result = @concatMemcpy(this, first);</span>
595         if (result !== null)
596             return result;
597     }
598 
599     return @tailCallForwardArguments(@concatSlowPath, this);
600 }
601 
602 function copyWithin(target, start /*, end */)
603 {
604     &quot;use strict&quot;;
605 
606     function maxWithPositives(a, b)
607     {
608         return (a &lt; b) ? b : a;
609     }
610 
611     function minWithMaybeNegativeZeroAndPositive(maybeNegativeZero, positive)
612     {
613         return (maybeNegativeZero &lt; positive) ? maybeNegativeZero : positive;
614     }
</pre>
</td>
</tr>
</table>
<center><a href="ArrayIteratorPrototype.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFromSyncIteratorPrototype.js.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
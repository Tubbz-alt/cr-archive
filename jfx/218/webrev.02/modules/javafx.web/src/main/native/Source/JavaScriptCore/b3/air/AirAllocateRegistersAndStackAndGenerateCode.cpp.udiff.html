<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersAndStackAndGenerateCode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../B3Width.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirAllocateRegistersAndStackAndGenerateCode.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersAndStackAndGenerateCode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -43,20 +43,50 @@</span>
  GenerateAndAllocateRegisters::GenerateAndAllocateRegisters(Code&amp; code)
      : m_code(code)
      , m_map(code)
  { }
  
<span class="udiff-line-added">+ ALWAYS_INLINE void GenerateAndAllocateRegisters::checkConsistency()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // This isn&#39;t exactly the right option for this but adding a new one for just this seems silly.</span>
<span class="udiff-line-added">+     if (Options::validateGraph() || Options::validateGraphAtEachPhase()) {</span>
<span class="udiff-line-added">+         m_code.forEachTmp([&amp;] (Tmp tmp) {</span>
<span class="udiff-line-added">+             Reg reg = m_map[tmp].reg;</span>
<span class="udiff-line-added">+             if (!reg)</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             ASSERT(!m_availableRegs[tmp.bank()].contains(reg));</span>
<span class="udiff-line-added">+             ASSERT(m_currentAllocation-&gt;at(reg) == tmp);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (Reg reg : RegisterSet::allRegisters()) {</span>
<span class="udiff-line-added">+             if (isDisallowedRegister(reg))</span>
<span class="udiff-line-added">+                 continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Tmp tmp = m_currentAllocation-&gt;at(reg);</span>
<span class="udiff-line-added">+             if (!tmp) {</span>
<span class="udiff-line-added">+                 ASSERT(m_availableRegs[bankForReg(reg)].contains(reg));</span>
<span class="udiff-line-added">+                 continue;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             ASSERT(!m_availableRegs[tmp.bank()].contains(reg));</span>
<span class="udiff-line-added">+             ASSERT(m_map[tmp].reg == reg);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void GenerateAndAllocateRegisters::buildLiveRanges(UnifiedTmpLiveness&amp; liveness)
  {
      m_liveRangeEnd = TmpMap&lt;size_t&gt;(m_code, 0);
  
      m_globalInstIndex = 0;
      for (BasicBlock* block : m_code) {
          for (Tmp tmp : liveness.liveAtHead(block)) {
              if (!tmp.isReg())
                  m_liveRangeEnd[tmp] = m_globalInstIndex;
          }
<span class="udiff-line-added">+         ++m_globalInstIndex;</span>
          for (Inst&amp; inst : *block) {
              inst.forEachTmpFast([&amp;] (Tmp tmp) {
                  if (!tmp.isReg())
                      m_liveRangeEnd[tmp] = m_globalInstIndex;
              });
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -64,10 +94,11 @@</span>
          }
          for (Tmp tmp : liveness.liveAtTail(block)) {
              if (!tmp.isReg())
                  m_liveRangeEnd[tmp] = m_globalInstIndex;
          }
<span class="udiff-line-added">+         ++m_globalInstIndex;</span>
      }
  }
  
  void GenerateAndAllocateRegisters::insertBlocksForFlushAfterTerminalPatchpoints()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -121,10 +152,22 @@</span>
      jit.move(CCallHelpers::TrustedImmPtr(offsetFromFP), reg);
      jit.add64(GPRInfo::callFrameRegister, reg);
      return CCallHelpers::Address(reg);
  }
  
<span class="udiff-line-added">+ ALWAYS_INLINE void GenerateAndAllocateRegisters::release(Tmp tmp, Reg reg)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(reg);</span>
<span class="udiff-line-added">+     ASSERT(m_currentAllocation-&gt;at(reg) == tmp);</span>
<span class="udiff-line-added">+     m_currentAllocation-&gt;at(reg) = Tmp();</span>
<span class="udiff-line-added">+     ASSERT(!m_availableRegs[tmp.bank()].contains(reg));</span>
<span class="udiff-line-added">+     m_availableRegs[tmp.bank()].set(reg);</span>
<span class="udiff-line-added">+     ASSERT(m_map[tmp].reg == reg);</span>
<span class="udiff-line-added">+     m_map[tmp].reg = Reg();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  ALWAYS_INLINE void GenerateAndAllocateRegisters::flush(Tmp tmp, Reg reg)
  {
      ASSERT(tmp);
      intptr_t offset = m_map[tmp].spillSlot-&gt;offsetFromFP();
      if (tmp.isGP())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135,14 +178,12 @@</span>
  
  ALWAYS_INLINE void GenerateAndAllocateRegisters::spill(Tmp tmp, Reg reg)
  {
      ASSERT(reg);
      ASSERT(m_map[tmp].reg == reg);
<span class="udiff-line-removed">-     m_availableRegs[tmp.bank()].set(reg);</span>
<span class="udiff-line-removed">-     m_currentAllocation-&gt;at(reg) = Tmp();</span>
      flush(tmp, reg);
<span class="udiff-line-modified-removed">-     m_map[tmp].reg = Reg();</span>
<span class="udiff-line-modified-added">+     release(tmp, reg);</span>
  }
  
  ALWAYS_INLINE void GenerateAndAllocateRegisters::alloc(Tmp tmp, Reg reg, bool isDef)
  {
      if (Tmp occupyingTmp = m_currentAllocation-&gt;at(reg))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -178,14 +219,11 @@</span>
          if (tmp.isReg())
              continue;
          if (m_liveRangeEnd[tmp] &gt;= m_globalInstIndex)
              continue;
  
<span class="udiff-line-modified-removed">-         Reg reg = Reg::fromIndex(i);</span>
<span class="udiff-line-removed">-         m_map[tmp].reg = Reg();</span>
<span class="udiff-line-removed">-         m_availableRegs[tmp.bank()].set(reg);</span>
<span class="udiff-line-removed">-         m_currentAllocation-&gt;at(i) = Tmp();</span>
<span class="udiff-line-modified-added">+         release(tmp, Reg::fromIndex(i));</span>
      }
  }
  
  ALWAYS_INLINE bool GenerateAndAllocateRegisters::assignTmp(Tmp&amp; tmp, Bank bank, bool isDef)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -242,34 +280,89 @@</span>
  {
      // We pessimistically assume we use all callee saves.
      handleCalleeSaves(m_code, RegisterSet::calleeSaveRegisters());
      allocateEscapedStackSlots(m_code);
  
<span class="udiff-line-modified-removed">-     // Each Tmp gets its own stack slot.</span>
<span class="udiff-line-removed">-     auto createStackSlot = [&amp;] (const Tmp&amp; tmp) {</span>
<span class="udiff-line-removed">-         TmpData data;</span>
<span class="udiff-line-removed">-         data.spillSlot = m_code.addStackSlot(8, StackSlotKind::Spill);</span>
<span class="udiff-line-removed">-         data.reg = Reg();</span>
<span class="udiff-line-removed">-         m_map[tmp] = data;</span>
<span class="udiff-line-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-removed">-         m_allTmps[tmp.bank()].append(tmp);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-modified-added">+     insertBlocksForFlushAfterTerminalPatchpoints();</span>
  
<span class="udiff-line-added">+ #if ASSERT_ENABLED</span>
      m_code.forEachTmp([&amp;] (Tmp tmp) {
          ASSERT(!tmp.isReg());
<span class="udiff-line-modified-removed">-         createStackSlot(tmp);</span>
<span class="udiff-line-modified-added">+         m_allTmps[tmp.bank()].append(tmp);</span>
      });
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_liveness = makeUnique&lt;UnifiedTmpLiveness&gt;(m_code);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         buildLiveRanges(*m_liveness);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Vector&lt;StackSlot*, 16&gt; freeSlots;</span>
<span class="udiff-line-added">+         Vector&lt;StackSlot*, 4&gt; toFree;</span>
<span class="udiff-line-added">+         m_globalInstIndex = 0;</span>
<span class="udiff-line-added">+         for (BasicBlock* block : m_code) {</span>
<span class="udiff-line-added">+             auto assignStackSlotToTmp = [&amp;] (Tmp tmp) {</span>
<span class="udiff-line-added">+                 if (tmp.isReg())</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 TmpData&amp; data = m_map[tmp];</span>
<span class="udiff-line-added">+                 if (data.spillSlot) {</span>
<span class="udiff-line-added">+                     if (m_liveRangeEnd[tmp] == m_globalInstIndex)</span>
<span class="udiff-line-added">+                         toFree.append(data.spillSlot);</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (freeSlots.size())</span>
<span class="udiff-line-added">+                     data.spillSlot = freeSlots.takeLast();</span>
<span class="udiff-line-added">+                 else</span>
<span class="udiff-line-added">+                     data.spillSlot = m_code.addStackSlot(8, StackSlotKind::Spill);</span>
<span class="udiff-line-added">+                 data.reg = Reg();</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             auto flushToFreeList = [&amp;] {</span>
<span class="udiff-line-added">+                 for (auto* stackSlot : toFree)</span>
<span class="udiff-line-added">+                     freeSlots.append(stackSlot);</span>
<span class="udiff-line-added">+                 toFree.clear();</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             for (Tmp tmp : m_liveness-&gt;liveAtHead(block))</span>
<span class="udiff-line-added">+                 assignStackSlotToTmp(tmp);</span>
<span class="udiff-line-added">+             flushToFreeList();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             ++m_globalInstIndex;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             for (Inst&amp; inst : *block) {</span>
<span class="udiff-line-added">+                 Vector&lt;Tmp, 4&gt; seenTmps;</span>
<span class="udiff-line-added">+                 inst.forEachTmpFast([&amp;] (Tmp tmp) {</span>
<span class="udiff-line-added">+                     if (seenTmps.contains(tmp))</span>
<span class="udiff-line-added">+                         return;</span>
<span class="udiff-line-added">+                     seenTmps.append(tmp);</span>
<span class="udiff-line-added">+                     assignStackSlotToTmp(tmp);</span>
<span class="udiff-line-added">+                 });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 flushToFreeList();</span>
<span class="udiff-line-added">+                 ++m_globalInstIndex;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             for (Tmp tmp : m_liveness-&gt;liveAtTail(block))</span>
<span class="udiff-line-added">+                 assignStackSlotToTmp(tmp);</span>
<span class="udiff-line-added">+             flushToFreeList();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             ++m_globalInstIndex;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
      m_allowedRegisters = RegisterSet();
  
      forEachBank([&amp;] (Bank bank) {
          m_registers[bank] = m_code.regsInPriorityOrder(bank);
  
          for (Reg reg : m_registers[bank]) {
              m_allowedRegisters.set(reg);
<span class="udiff-line-modified-removed">-             createStackSlot(Tmp(reg));</span>
<span class="udiff-line-modified-added">+             TmpData&amp; data = m_map[Tmp(reg)];</span>
<span class="udiff-line-added">+             data.spillSlot = m_code.addStackSlot(8, StackSlotKind::Spill);</span>
<span class="udiff-line-added">+             data.reg = Reg();</span>
          }
      });
  
      {
          unsigned nextIndex = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -285,30 +378,53 @@</span>
      updateFrameSizeBasedOnStackSlots(m_code);
      m_code.setStackIsAllocated(true);
  
      lowerStackArgs(m_code);
  
<span class="udiff-line-added">+ #if ASSERT_ENABLED</span>
      // Verify none of these passes add any tmps.
<span class="udiff-line-removed">- #if !ASSERT_DISABLED</span>
      forEachBank([&amp;] (Bank bank) {
<span class="udiff-line-modified-removed">-         ASSERT(m_allTmps[bank].size() - m_registers[bank].size() == m_code.numTmps(bank));</span>
<span class="udiff-line-modified-added">+         ASSERT(m_allTmps[bank].size() == m_code.numTmps(bank));</span>
      });
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         // Verify that lowerStackArgs didn&#39;t change Tmp liveness at the boundaries for the Tmps and Registers we model.</span>
<span class="udiff-line-added">+         UnifiedTmpLiveness liveness(m_code);</span>
<span class="udiff-line-added">+         for (BasicBlock* block : m_code) {</span>
<span class="udiff-line-added">+             auto assertLivenessAreEqual = [&amp;] (auto a, auto b) {</span>
<span class="udiff-line-added">+                 HashSet&lt;Tmp&gt; livenessA;</span>
<span class="udiff-line-added">+                 HashSet&lt;Tmp&gt; livenessB;</span>
<span class="udiff-line-added">+                 for (Tmp tmp : a) {</span>
<span class="udiff-line-added">+                     if (tmp.isReg() &amp;&amp; isDisallowedRegister(tmp.reg()))</span>
<span class="udiff-line-added">+                         continue;</span>
<span class="udiff-line-added">+                     livenessA.add(tmp);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 for (Tmp tmp : b) {</span>
<span class="udiff-line-added">+                     if (tmp.isReg() &amp;&amp; isDisallowedRegister(tmp.reg()))</span>
<span class="udiff-line-added">+                         continue;</span>
<span class="udiff-line-added">+                     livenessB.add(tmp);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 ASSERT(livenessA == livenessB);</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             assertLivenessAreEqual(m_liveness-&gt;liveAtHead(block), liveness.liveAtHead(block));</span>
<span class="udiff-line-added">+             assertLivenessAreEqual(m_liveness-&gt;liveAtTail(block), liveness.liveAtTail(block));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  #endif
  }
  
  void GenerateAndAllocateRegisters::generate(CCallHelpers&amp; jit)
  {
      m_jit = &amp;jit;
  
      TimingScope timingScope(&quot;Air::generateAndAllocateRegisters&quot;);
  
<span class="udiff-line-removed">-     insertBlocksForFlushAfterTerminalPatchpoints();</span>
<span class="udiff-line-removed">- </span>
      DisallowMacroScratchRegisterUsage disallowScratch(*m_jit);
  
<span class="udiff-line-modified-removed">-     UnifiedTmpLiveness liveness(m_code);</span>
<span class="udiff-line-removed">-     buildLiveRanges(liveness);</span>
<span class="udiff-line-modified-added">+     buildLiveRanges(*m_liveness);</span>
  
      IndexMap&lt;BasicBlock*, IndexMap&lt;Reg, Tmp&gt;&gt; currentAllocationMap(m_code.size());
      {
          IndexMap&lt;Reg, Tmp&gt; defaultCurrentAllocation(Reg::maxIndex() + 1);
          for (BasicBlock* block : m_code)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -317,11 +433,11 @@</span>
          // The only things live that are in registers at the root blocks are
          // the explicitly named registers that are live.
  
          for (unsigned i = m_code.numEntrypoints(); i--;) {
              BasicBlock* entrypoint = m_code.entrypoint(i).block();
<span class="udiff-line-modified-removed">-             for (Tmp tmp : liveness.liveAtHead(entrypoint)) {</span>
<span class="udiff-line-modified-added">+             for (Tmp tmp : m_liveness-&gt;liveAtHead(entrypoint)) {</span>
                  if (tmp.isReg())
                      currentAllocationMap[entrypoint][tmp.reg()] = tmp;
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -379,11 +495,11 @@</span>
                  data.continueLabel = m_jit-&gt;label();
              }
          }
  
          forEachBank([&amp;] (Bank bank) {
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
              // By default, everything is spilled at block boundaries. We do this after we process each block
              // so we don&#39;t have to walk all Tmps, since #Tmps &gt;&gt; #Available regs. Instead, we walk the register file at
              // each block boundary and clear entries in this map.
              for (Tmp tmp : m_allTmps[bank])
                  ASSERT(m_map[tmp].reg == Reg());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,12 +521,16 @@</span>
              Reg reg = Reg::fromIndex(i);
              m_map[tmp].reg = reg;
              m_availableRegs[tmp.bank()].clear(reg);
          }
  
<span class="udiff-line-added">+         ++m_globalInstIndex;</span>
<span class="udiff-line-added">+ </span>
          bool isReplayingSameInst = false;
          for (size_t instIndex = 0; instIndex &lt; block-&gt;size(); ++instIndex) {
<span class="udiff-line-added">+             checkConsistency();</span>
<span class="udiff-line-added">+ </span>
              if (instIndex &amp;&amp; !isReplayingSameInst)
                  startLabel = m_jit-&gt;labelIgnoringWatchpoints();
  
              context.indexInBlock = instIndex;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -419,10 +539,50 @@</span>
              m_didAlreadyFreeDeadSlots = false;
  
              m_namedUsedRegs = RegisterSet();
              m_namedDefdRegs = RegisterSet();
  
<span class="udiff-line-added">+             bool needsToGenerate = ([&amp;] () -&gt; bool {</span>
<span class="udiff-line-added">+                 // FIXME: We should consider trying to figure out if we can also elide Mov32s</span>
<span class="udiff-line-added">+                 if (!(inst.kind.opcode == Move || inst.kind.opcode == MoveDouble))</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 ASSERT(inst.args.size() &gt;= 2);</span>
<span class="udiff-line-added">+                 Arg source = inst.args[0];</span>
<span class="udiff-line-added">+                 Arg dest = inst.args[1];</span>
<span class="udiff-line-added">+                 if (!source.isTmp() || !dest.isTmp())</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // FIXME: We don&#39;t track where the last use of a reg is globally so we don&#39;t know where we can elide them.</span>
<span class="udiff-line-added">+                 ASSERT(source.isReg() || m_liveRangeEnd[source.tmp()] &gt;= m_globalInstIndex);</span>
<span class="udiff-line-added">+                 if (source.isReg() || m_liveRangeEnd[source.tmp()] != m_globalInstIndex)</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 // If we are doing a self move at the end of the temps liveness we can trivially elide the move.</span>
<span class="udiff-line-added">+                 if (source == dest)</span>
<span class="udiff-line-added">+                     return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 Reg sourceReg = m_map[source.tmp()].reg;</span>
<span class="udiff-line-added">+                 // If the value is not already materialized into a register we may still move it into one so let the normal generation code run.</span>
<span class="udiff-line-added">+                 if (!sourceReg)</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 ASSERT(m_currentAllocation-&gt;at(sourceReg) == source.tmp());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (dest.isReg() &amp;&amp; dest.reg() != sourceReg)</span>
<span class="udiff-line-added">+                     return true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (Reg oldReg = m_map[dest.tmp()].reg)</span>
<span class="udiff-line-added">+                     release(dest.tmp(), oldReg);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 m_map[dest.tmp()].reg = sourceReg;</span>
<span class="udiff-line-added">+                 m_currentAllocation-&gt;at(sourceReg) = dest.tmp();</span>
<span class="udiff-line-added">+                 m_map[source.tmp()].reg = Reg();</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             })();</span>
<span class="udiff-line-added">+             checkConsistency();</span>
<span class="udiff-line-added">+ </span>
              inst.forEachArg([&amp;] (Arg&amp; arg, Arg::Role role, Bank, Width) {
                  if (!arg.isTmp())
                      return;
  
                  Tmp tmp = arg.tmp();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -480,11 +640,11 @@</span>
              };
  
              allocNamed(m_namedUsedRegs, false); // Must come before the defd registers since we may use and def the same register.
              allocNamed(m_namedDefdRegs, true);
  
<span class="udiff-line-modified-removed">-             {</span>
<span class="udiff-line-modified-added">+             if (needsToGenerate) {</span>
                  auto tryAllocate = [&amp;] {
                      Vector&lt;Tmp*, 8&gt; usesToAlloc;
                      Vector&lt;Tmp*, 8&gt; defsToAlloc;
  
                      inst.forEachTmp([&amp;] (Tmp&amp; tmp, Arg::Role role, Bank, Width) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -593,32 +753,34 @@</span>
                          currentAllocationMap[successor] = currentAllocation;
                      else
                          everySuccessorGetsOurRegisterState = false;
                  }
                  if (!everySuccessorGetsOurRegisterState) {
<span class="udiff-line-modified-removed">-                     for (Tmp tmp : liveness.liveAtTail(block)) {</span>
<span class="udiff-line-modified-added">+                     for (Tmp tmp : m_liveness-&gt;liveAtTail(block)) {</span>
                          if (tmp.isReg() &amp;&amp; isDisallowedRegister(tmp.reg()))
                              continue;
                          if (Reg reg = m_map[tmp].reg)
                              flush(tmp, reg);
                      }
                  }
              }
  
              if (!inst.isTerminal()) {
<span class="udiff-line-modified-removed">-                 CCallHelpers::Jump jump = inst.generate(*m_jit, context);</span>
<span class="udiff-line-modified-added">+                 CCallHelpers::Jump jump;</span>
<span class="udiff-line-added">+                 if (needsToGenerate)</span>
<span class="udiff-line-added">+                     jump = inst.generate(*m_jit, context);</span>
                  ASSERT_UNUSED(jump, !jump.isSet());
  
                  for (Reg reg : clobberedRegisters) {
                      Tmp tmp(reg);
                      ASSERT(currentAllocation[reg] == tmp);
                      m_availableRegs[tmp.bank()].set(reg);
                      m_currentAllocation-&gt;at(reg) = Tmp();
                      m_map[tmp].reg = Reg();
                  }
              } else {
<span class="udiff-line-modified-removed">-                 bool needsToGenerate = true;</span>
<span class="udiff-line-modified-added">+                 ASSERT(needsToGenerate);</span>
                  if (inst.kind.opcode == Jump &amp;&amp; block-&gt;successorBlock(0) == m_code.findNextBlock(block))
                      needsToGenerate = false;
  
                  if (isReturn(inst.kind.opcode)) {
                      needsToGenerate = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -670,10 +832,12 @@</span>
          // null entries.
          for (size_t i = 0; i &lt; currentAllocation.size(); ++i) {
              if (Tmp tmp = currentAllocation[i])
                  m_map[tmp].reg = Reg();
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         ++m_globalInstIndex;</span>
      }
  
      for (auto&amp; entry : m_blocksAfterTerminalPatchForSpilling) {
          entry.value.jump.linkTo(m_jit-&gt;label(), m_jit);
          const HashMap&lt;Tmp, Arg*&gt;&amp; spills = entry.value.defdTmps;
</pre>
<center><a href="../B3Width.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirAllocateRegistersAndStackAndGenerateCode.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
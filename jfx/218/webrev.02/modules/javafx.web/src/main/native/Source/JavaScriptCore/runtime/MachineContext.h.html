<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/MachineContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  3  * Copyright (C) 2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;GPRInfo.h&quot;
 30 #include &quot;LLIntPCRanges.h&quot;
 31 #include &quot;MacroAssemblerCodeRef.h&quot;
 32 #include &lt;wtf/Optional.h&gt;
 33 #include &lt;wtf/PlatformRegisters.h&gt;
 34 #include &lt;wtf/PointerPreparations.h&gt;
 35 #include &lt;wtf/StdLibExtras.h&gt;
 36 
 37 namespace JSC {
 38 namespace MachineContext {
 39 
 40 template&lt;typename T = void*&gt; T stackPointer(const PlatformRegisters&amp;);
 41 
 42 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 43 template&lt;typename T = void*&gt; void setStackPointer(PlatformRegisters&amp;, T);
 44 template&lt;typename T = void*&gt; T framePointer(const PlatformRegisters&amp;);
 45 template&lt;typename T = void*&gt; void setFramePointer(PlatformRegisters&amp;, T);
 46 inline MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt; linkRegister(const PlatformRegisters&amp;);
 47 inline void setLinkRegister(PlatformRegisters&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 48 inline Optional&lt;MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;&gt; instructionPointer(const PlatformRegisters&amp;);
 49 inline void setInstructionPointer(PlatformRegisters&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 50 
 51 template&lt;size_t N&gt; void*&amp; argumentPointer(PlatformRegisters&amp;);
 52 template&lt;size_t N&gt; void* argumentPointer(const PlatformRegisters&amp;);
 53 #if !ENABLE(C_LOOP)
 54 void*&amp; llintInstructionPointer(PlatformRegisters&amp;);
 55 void* llintInstructionPointer(const PlatformRegisters&amp;);
 56 #endif // !ENABLE(C_LOOP)
 57 
 58 #if HAVE(MACHINE_CONTEXT)
 59 
 60 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)
 61 
 62 #if !USE(DARWIN_REGISTER_MACROS)
 63 static inline void*&amp; stackPointerImpl(mcontext_t&amp;);
 64 static inline void*&amp; instructionPointerImpl(mcontext_t&amp;);
 65 #endif // !USE(DARWIN_REGISTER_MACROS)
 66 
 67 static inline void*&amp; framePointerImpl(mcontext_t&amp;);
 68 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
 69 
 70 template&lt;typename T = void*&gt; T stackPointer(const mcontext_t&amp;);
 71 template&lt;typename T = void*&gt; void setStackPointer(mcontext_t&amp;, T);
 72 template&lt;typename T = void*&gt; T framePointer(const mcontext_t&amp;);
 73 template&lt;typename T = void*&gt; void setFramePointer(mcontext_t&amp;, T);
 74 inline MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt; instructionPointer(const mcontext_t&amp;);
 75 inline void setInstructionPointer(mcontext_t&amp;, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt;);
 76 
 77 template&lt;size_t N&gt; void*&amp; argumentPointer(mcontext_t&amp;);
 78 template&lt;size_t N&gt; void* argumentPointer(const mcontext_t&amp;);
 79 #if !ENABLE(C_LOOP)
 80 void*&amp; llintInstructionPointer(mcontext_t&amp;);
 81 void* llintInstructionPointer(const mcontext_t&amp;);
 82 #endif // !ENABLE(C_LOOP)
 83 #endif // HAVE(MACHINE_CONTEXT)
 84 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 85 
 86 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
 87 
 88 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)
 89 static inline void*&amp; stackPointerImpl(PlatformRegisters&amp; regs)
 90 {
 91 #if OS(DARWIN)
 92 #if __DARWIN_UNIX03
 93 
 94 #if CPU(X86)
 95     return reinterpret_cast&lt;void*&amp;&gt;(regs.__esp);
 96 #elif CPU(X86_64)
 97     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rsp);
 98 #elif CPU(PPC) || CPU(PPC64)
 99     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r1);
100 #elif CPU(ARM_THUMB2) || CPU(ARM)
101     return reinterpret_cast&lt;void*&amp;&gt;(regs.__sp);
102 #else
103 #error Unknown Architecture
104 #endif
105 
106 #else // !__DARWIN_UNIX03
107 
108 #if CPU(X86)
109     return reinterpret_cast&lt;void*&amp;&gt;(regs.esp);
110 #elif CPU(X86_64)
111     return reinterpret_cast&lt;void*&amp;&gt;(regs.rsp);
112 #elif CPU(PPC) || CPU(PPC64)
113     return reinterpret_cast&lt;void*&amp;&gt;(regs.r1);
114 #else
115 #error Unknown Architecture
116 #endif
117 
118 #endif // __DARWIN_UNIX03
119 
120 #elif OS(WINDOWS)
121 
122 #if CPU(ARM)
123     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Sp);
124 #elif CPU(MIPS)
125     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.IntSp);
126 #elif CPU(X86)
127     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Esp);
128 #elif CPU(X86_64)
129     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rsp);
130 #else
131 #error Unknown Architecture
132 #endif
133 
134 #elif HAVE(MACHINE_CONTEXT)
135     return stackPointerImpl(regs.machineContext);
136 #endif
137 }
138 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
139 
140 template&lt;typename T&gt;
141 inline T stackPointer(const PlatformRegisters&amp; regs)
142 {
143 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
144     void* value = WTF_READ_PLATFORM_REGISTERS_SP_WITH_PROFILE(regs);
145     assertIsNotTagged(value);
146     return bitwise_cast&lt;T&gt;(value);
147 #elif USE(DARWIN_REGISTER_MACROS)
148     return bitwise_cast&lt;T&gt;(reinterpret_cast&lt;void*&gt;(__darwin_arm_thread_state64_get_sp(regs)));
149 #else
150     return bitwise_cast&lt;T&gt;(stackPointerImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs)));
151 #endif
152 }
153 
154 template&lt;typename T&gt;
155 inline void setStackPointer(PlatformRegisters&amp; regs, T value)
156 {
157 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
158     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
159     WTF_WRITE_PLATFORM_REGISTERS_SP_WITH_PROFILE(regs, bitwise_cast&lt;void*&gt;(value));
160 #elif USE(DARWIN_REGISTER_MACROS)
161     __darwin_arm_thread_state64_set_sp(regs, value);
162 #else
163     stackPointerImpl(regs) = bitwise_cast&lt;void*&gt;(value);
164 #endif
165 }
166 
167 #else // not OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
168 
169 template&lt;typename T&gt;
170 inline T stackPointer(const PlatformRegisters&amp; regs)
171 {
172     return bitwise_cast&lt;T&gt;(regs.stackPointer);
173 }
174 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
175 
176 #if HAVE(MACHINE_CONTEXT)
177 
178 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)
179 static inline void*&amp; stackPointerImpl(mcontext_t&amp; machineContext)
180 {
181 #if OS(DARWIN)
182     return stackPointerImpl(machineContext-&gt;__ss);
183 #elif OS(FREEBSD)
184 
185 #if CPU(X86)
186     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_esp);
187 #elif CPU(X86_64)
188     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rsp);
189 #elif CPU(ARM)
190     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_SP]);
191 #elif CPU(ARM64)
192     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_sp);
193 #elif CPU(MIPS)
194     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_regs[29]);
195 #else
196 #error Unknown Architecture
197 #endif
198 
199 #elif OS(FUCHSIA) || defined(__GLIBC__) || defined(__BIONIC__)
200 
201 #if CPU(X86)
202     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_ESP]);
203 #elif CPU(X86_64)
204     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_RSP]);
205 #elif CPU(ARM)
206     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_sp);
207 #elif CPU(ARM64)
208     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.sp);
209 #elif CPU(MIPS)
210     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[29]);
211 #else
212 #error Unknown Architecture
213 #endif
214 #endif
215 }
216 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
217 
218 template&lt;typename T&gt;
219 inline T stackPointer(const mcontext_t&amp; machineContext)
220 {
221 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
222     void* value = WTF_READ_MACHINE_CONTEXT_SP_WITH_PROFILE(machineContext);
223     assertIsNotTagged(value);
224     return bitwise_cast&lt;T&gt;(value);
225 #elif USE(DARWIN_REGISTER_MACROS)
226     return stackPointer(machineContext-&gt;__ss);
227 #else
228     return bitwise_cast&lt;T&gt;(stackPointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext)));
229 #endif
230 }
231 
232 template&lt;typename T&gt;
233 inline void setStackPointer(mcontext_t&amp; machineContext, T value)
234 {
235 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
236     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
237     WTF_WRITE_MACHINE_CONTEXT_SP_WITH_PROFILE(machineContext, bitwise_cast&lt;void*&gt;(value));
238 #elif USE(DARWIN_REGISTER_MACROS)
239     return setStackPointer(machineContext-&gt;__ss, value);
240 #else
241     stackPointerImpl(machineContext) = bitwise_cast&lt;void*&gt;(value);
242 #endif
243 }
244 #endif // HAVE(MACHINE_CONTEXT)
245 
246 
247 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
248 
249 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)
250 static inline void*&amp; framePointerImpl(PlatformRegisters&amp; regs)
251 {
252 #if OS(DARWIN)
253 
254 #if __DARWIN_UNIX03
255 
256 #if CPU(X86)
257     return reinterpret_cast&lt;void*&amp;&gt;(regs.__ebp);
258 #elif CPU(X86_64)
259     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rbp);
260 #elif CPU(ARM_THUMB2)
261     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r[7]);
262 #elif CPU(ARM)
263     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r[11]);
264 #elif CPU(ARM64)
265     return reinterpret_cast&lt;void*&amp;&gt;(regs.__x[29]);
266 #else
267 #error Unknown Architecture
268 #endif
269 
270 #else // !__DARWIN_UNIX03
271 
272 #if CPU(X86)
273     return reinterpret_cast&lt;void*&amp;&gt;(regs.esp);
274 #elif CPU(X86_64)
275     return reinterpret_cast&lt;void*&amp;&gt;(regs.rsp);
276 #else
277 #error Unknown Architecture
278 #endif
279 
280 #endif // __DARWIN_UNIX03
281 
282 #elif OS(WINDOWS)
283 
284 #if CPU(ARM)
285     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.R11);
286 #elif CPU(MIPS)
287 #error Dont know what to do with mips. Do we even need this?
288 #elif CPU(X86)
289     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Ebp);
290 #elif CPU(X86_64)
291     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rbp);
292 #else
293 #error Unknown Architecture
294 #endif
295 
296 #elif HAVE(MACHINE_CONTEXT)
297     return framePointerImpl(regs.machineContext);
298 #endif
299 }
300 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
301 
302 template&lt;typename T&gt;
303 inline T framePointer(const PlatformRegisters&amp; regs)
304 {
305 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
306     void* value = WTF_READ_PLATFORM_REGISTERS_FP_WITH_PROFILE(regs);
307     assertIsNotTagged(value);
308     return bitwise_cast&lt;T&gt;(value);
309 #else
310     return bitwise_cast&lt;T&gt;(framePointerImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs)));
311 #endif
312 }
313 
314 template&lt;typename T&gt;
315 inline void setFramePointer(PlatformRegisters&amp; regs, T value)
316 {
317 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
318     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
319     WTF_WRITE_PLATFORM_REGISTERS_FP_WITH_PROFILE(regs, bitwise_cast&lt;void*&gt;(value));
320 #else
321     framePointerImpl(regs) = bitwise_cast&lt;void*&gt;(value);
322 #endif
323 }
324 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
325 
326 
327 #if HAVE(MACHINE_CONTEXT)
328 
329 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE)
330 static inline void*&amp; framePointerImpl(mcontext_t&amp; machineContext)
331 {
332 #if OS(DARWIN)
333     return framePointerImpl(machineContext-&gt;__ss);
334 #elif OS(FREEBSD)
335 
336 #if CPU(X86)
337     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_ebp);
338 #elif CPU(X86_64)
339     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rbp);
340 #elif CPU(ARM)
341     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_FP]);
342 #elif CPU(ARM64)
343     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_x[29]);
344 #elif CPU(MIPS)
345     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_regs[30]);
346 #else
347 #error Unknown Architecture
348 #endif
349 
350 #elif OS(FUCHSIA) || defined(__GLIBC__) || defined(__BIONIC__)
351 
352 // The following sequence depends on glibc&#39;s sys/ucontext.h.
353 #if CPU(X86)
354     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_EBP]);
355 #elif CPU(X86_64)
356     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_RBP]);
357 #elif CPU(ARM)
358     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_fp);
359 #elif CPU(ARM64)
360     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.regs[29]);
361 #elif CPU(MIPS)
362     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[30]);
363 #else
364 #error Unknown Architecture
365 #endif
366 
367 #else
368 #error Need a way to get the frame pointer for another thread on this platform
369 #endif
370 }
371 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
372 
373 template&lt;typename T&gt;
374 inline T framePointer(const mcontext_t&amp; machineContext)
375 {
376 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
377     void* value = WTF_READ_MACHINE_CONTEXT_FP_WITH_PROFILE(machineContext);
378     assertIsNotTagged(value);
379     return bitwise_cast&lt;T&gt;(value);
380 #else
381     return bitwise_cast&lt;T&gt;(framePointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext)));
382 #endif
383 }
384 
385 template&lt;typename T&gt;
386 inline void setFramePointer(mcontext_t&amp; machineContext, T value)
387 {
388 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
389     assertIsNotTagged(bitwise_cast&lt;void*&gt;(value));
390     WTF_WRITE_MACHINE_CONTEXT_FP_WITH_PROFILE(machineContext, bitwise_cast&lt;void*&gt;(value));
391 #else
392     framePointerImpl(machineContext) = bitwise_cast&lt;void*&gt;(value);
393 #endif
394 }
395 #endif // HAVE(MACHINE_CONTEXT)
396 
397 
398 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
399 
400 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)
401 static inline void*&amp; instructionPointerImpl(PlatformRegisters&amp; regs)
402 {
403 #if OS(DARWIN)
404 #if __DARWIN_UNIX03
405 
406 #if CPU(X86)
407     return reinterpret_cast&lt;void*&amp;&gt;(regs.__eip);
408 #elif CPU(X86_64)
409     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rip);
410 #elif CPU(ARM_THUMB2) || CPU(ARM)
411     return reinterpret_cast&lt;void*&amp;&gt;(regs.__pc);
412 #else
413 #error Unknown Architecture
414 #endif
415 
416 #else // !__DARWIN_UNIX03
417 #if CPU(X86)
418     return reinterpret_cast&lt;void*&amp;&gt;(regs.eip);
419 #elif CPU(X86_64)
420     return reinterpret_cast&lt;void*&amp;&gt;(regs.rip);
421 #else
422 #error Unknown Architecture
423 #endif
424 
425 #endif // __DARWIN_UNIX03
426 
427 #elif OS(WINDOWS)
428 
429 #if CPU(ARM)
430     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Pc);
431 #elif CPU(MIPS)
432 #error Dont know what to do with mips. Do we even need this?
433 #elif CPU(X86)
434     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Eip);
435 #elif CPU(X86_64)
436     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rip);
437 #else
438 #error Unknown Architecture
439 #endif
440 
441 #elif HAVE(MACHINE_CONTEXT)
442     return instructionPointerImpl(regs.machineContext);
443 #endif
444 }
445 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
446 
447 inline Optional&lt;MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;&gt; instructionPointer(const PlatformRegisters&amp; regs)
448 {
449 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
450     void* value = WTF_READ_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs);
451 #elif USE(DARWIN_REGISTER_MACROS)
452     void* value = __darwin_arm_thread_state64_get_pc_fptr(regs);
453 #else
454     void* value = instructionPointerImpl(const_cast&lt;PlatformRegisters&amp;&gt;(regs));
455 #endif
456     if (!value)
457         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(nullptr);
458     if (!usesPointerTagging())
459         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
460     if (isTaggedWith(value, PlatformRegistersPCPtrTag))
461         return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
462     return WTF::nullopt;
463 }
464 
465 inline void setInstructionPointer(PlatformRegisters&amp; regs, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
466 {
467 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
468     WTF_WRITE_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs, value.executableAddress());
469 #elif USE(DARWIN_REGISTER_MACROS)
470     __darwin_arm_thread_state64_set_pc_fptr(regs, value.executableAddress());
471 #else
472     instructionPointerImpl(regs) = value.executableAddress();
473 #endif
474 }
475 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
476 
477 
478 #if HAVE(MACHINE_CONTEXT)
479 
480 #if !USE(PLATFORM_REGISTERS_WITH_PROFILE) &amp;&amp; !USE(DARWIN_REGISTER_MACROS)
481 static inline void*&amp; instructionPointerImpl(mcontext_t&amp; machineContext)
482 {
483 #if OS(DARWIN)
484     return instructionPointerImpl(machineContext-&gt;__ss);
485 #elif OS(FREEBSD)
486 
487 #if CPU(X86)
488     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_eip);
489 #elif CPU(X86_64)
490     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rip);
491 #elif CPU(ARM)
492     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_PC]);
493 #elif CPU(ARM64)
494     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_elr);
495 #elif CPU(MIPS)
496     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_pc);
497 #else
498 #error Unknown Architecture
499 #endif
500 
501 #elif OS(FUCHSIA) || defined(__GLIBC__) || defined(__BIONIC__)
502 
503 // The following sequence depends on glibc&#39;s sys/ucontext.h.
504 #if CPU(X86)
505     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_EIP]);
506 #elif CPU(X86_64)
507     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_RIP]);
508 #elif CPU(ARM)
509     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_pc);
510 #elif CPU(ARM64)
511     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.pc);
512 #elif CPU(MIPS)
513     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.pc);
514 #else
515 #error Unknown Architecture
516 #endif
517 
518 #else
519 #error Need a way to get the instruction pointer for another thread on this platform
520 #endif
521 }
522 #endif // !USE(PLATFORM_REGISTERS_WITH_PROFILE)
523 
524 inline MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt; instructionPointer(const mcontext_t&amp; machineContext)
525 {
526 #if USE(DARWIN_REGISTER_MACROS)
527     return *instructionPointer(machineContext-&gt;__ss);
528 #else
529 
530 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
531     void* value = WTF_READ_MACHINE_CONTEXT_PC_WITH_PROFILE(machineContext);
532 #else
533     void* value = instructionPointerImpl(const_cast&lt;mcontext_t&amp;&gt;(machineContext));
534 #endif
535 
536     return MacroAssemblerCodePtr&lt;PlatformRegistersPCPtrTag&gt;(value);
537 #endif
538 }
539 
540 inline void setInstructionPointer(mcontext_t&amp; machineContext, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
541 {
542 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
543     WTF_WRITE_MACHINE_CONTEXT_PC_WITH_PROFILE(machineContext, value.executableAddress());
544 #elif USE(DARWIN_REGISTER_MACROS)
545     setInstructionPointer(machineContext-&gt;__ss, value);
546 #else
547     instructionPointerImpl(machineContext) = value.executableAddress();
548 #endif
549 }
550 #endif // HAVE(MACHINE_CONTEXT)
551 
552 
553 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
554 
555 #if OS(DARWIN) &amp;&amp; __DARWIN_UNIX03 &amp;&amp; CPU(ARM64)
556 
557 inline MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt; linkRegister(const PlatformRegisters&amp; regs)
558 {
559 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
560     void* value = WTF_READ_PLATFORM_REGISTERS_LR_WITH_PROFILE(regs);
561 #else
562     void* value = __darwin_arm_thread_state64_get_lr_fptr(regs);
563 #endif
564     return MacroAssemblerCodePtr&lt;PlatformRegistersLRPtrTag&gt;(value);
565 }
566 
567 inline void setLinkRegister(PlatformRegisters&amp; regs, MacroAssemblerCodePtr&lt;CFunctionPtrTag&gt; value)
568 {
569 #if USE(PLATFORM_REGISTERS_WITH_PROFILE)
570     WTF_WRITE_PLATFORM_REGISTERS_PC_WITH_PROFILE(regs, value.executableAddress());
571 #else
572     __darwin_arm_thread_state64_set_lr_fptr(regs, value.executableAddress());
573 #endif
574 }
575 #endif // OS(DARWIN) &amp;&amp; __DARWIN_UNIX03 &amp;&amp; CPU(ARM64)
576 
577 #if HAVE(MACHINE_CONTEXT)
578 template&lt;&gt; void*&amp; argumentPointer&lt;1&gt;(mcontext_t&amp;);
579 #endif
580 
581 template&lt;&gt;
582 inline void*&amp; argumentPointer&lt;1&gt;(PlatformRegisters&amp; regs)
583 {
584 #if OS(DARWIN)
585 #if __DARWIN_UNIX03
586 
587 #if CPU(X86)
588     return reinterpret_cast&lt;void*&amp;&gt;(regs.__edx);
589 #elif CPU(X86_64)
590     return reinterpret_cast&lt;void*&amp;&gt;(regs.__rsi);
591 #elif CPU(ARM_THUMB2) || CPU(ARM)
592     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r[1]);
593 #elif CPU(ARM64)
594     return reinterpret_cast&lt;void*&amp;&gt;(regs.__x[1]);
595 #else
596 #error Unknown Architecture
597 #endif
598 
599 #else // !__DARWIN_UNIX03
600 
601 #if CPU(X86)
602     return reinterpret_cast&lt;void*&amp;&gt;(regs.edx);
603 #elif CPU(X86_64)
604     return reinterpret_cast&lt;void*&amp;&gt;(regs.rsi);
605 #else
606 #error Unknown Architecture
607 #endif
608 
609 #endif // __DARWIN_UNIX03
610 
611 #elif OS(WINDOWS)
612 
613 #if CPU(ARM)
614     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.R1);
615 #elif CPU(MIPS)
616 #error Dont know what to do with mips. Do we even need this?
617 #elif CPU(X86)
618     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Edx);
619 #elif CPU(X86_64)
620     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Rdx);
621 #else
622 #error Unknown Architecture
623 #endif
624 
625 #elif HAVE(MACHINE_CONTEXT)
626     return argumentPointer&lt;1&gt;(regs.machineContext);
627 #endif
628 }
629 
630 template&lt;size_t N&gt;
631 inline void* argumentPointer(const PlatformRegisters&amp; regs)
632 {
633     return argumentPointer&lt;N&gt;(const_cast&lt;PlatformRegisters&amp;&gt;(regs));
634 }
635 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
636 
637 #if HAVE(MACHINE_CONTEXT)
638 template&lt;&gt;
639 inline void*&amp; argumentPointer&lt;1&gt;(mcontext_t&amp; machineContext)
640 {
641 #if OS(DARWIN)
642     return argumentPointer&lt;1&gt;(machineContext-&gt;__ss);
643 #elif OS(FREEBSD)
644 
645 #if CPU(X86)
646     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_edx);
647 #elif CPU(X86_64)
648     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_rsi);
649 #elif CPU(ARM)
650     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_R1]);
651 #elif CPU(ARM64)
652     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_x[1]);
653 #elif CPU(MIPS)
654     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_regs[5]);
655 #else
656 #error Unknown Architecture
657 #endif
658 
659 #elif OS(FUCHSIA) || defined(__GLIBC__) || defined(__BIONIC__)
660 
661 // The following sequence depends on glibc&#39;s sys/ucontext.h.
662 #if CPU(X86)
663     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_EDX]);
664 #elif CPU(X86_64)
665     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_RSI]);
666 #elif CPU(ARM)
667     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_r1);
668 #elif CPU(ARM64)
669     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.regs[1]);
670 #elif CPU(MIPS)
671     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[5]);
672 #else
673 #error Unknown Architecture
674 #endif
675 
676 #else
677 #error Need a way to get the frame pointer for another thread on this platform
678 #endif
679 }
680 
681 template&lt;unsigned N&gt;
682 inline void* argumentPointer(const mcontext_t&amp; machineContext)
683 {
684     return argumentPointer&lt;N&gt;(const_cast&lt;mcontext_t&amp;&gt;(machineContext));
685 }
686 #endif // HAVE(MACHINE_CONTEXT)
687 
688 #if !ENABLE(C_LOOP)
689 #if OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
690 inline void*&amp; llintInstructionPointer(PlatformRegisters&amp; regs)
691 {
692     // LLInt uses regT4 as PC.
693 #if OS(DARWIN)
694 #if __DARWIN_UNIX03
695 
696 #if CPU(X86)
697     static_assert(LLInt::LLIntPC == X86Registers::esi, &quot;Wrong LLInt PC.&quot;);
698     return reinterpret_cast&lt;void*&amp;&gt;(regs.__esi);
699 #elif CPU(X86_64)
700     static_assert(LLInt::LLIntPC == X86Registers::r8, &quot;Wrong LLInt PC.&quot;);
701     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r8);
702 #elif CPU(ARM)
703     static_assert(LLInt::LLIntPC == ARMRegisters::r8, &quot;Wrong LLInt PC.&quot;);
704     return reinterpret_cast&lt;void*&amp;&gt;(regs.__r[8]);
705 #elif CPU(ARM64)
706     static_assert(LLInt::LLIntPC == ARM64Registers::x4, &quot;Wrong LLInt PC.&quot;);
707     return reinterpret_cast&lt;void*&amp;&gt;(regs.__x[4]);
708 #else
709 #error Unknown Architecture
710 #endif
711 
712 #else // !__DARWIN_UNIX03
713 #if CPU(X86)
714     static_assert(LLInt::LLIntPC == X86Registers::esi, &quot;Wrong LLInt PC.&quot;);
715     return reinterpret_cast&lt;void*&amp;&gt;(regs.esi);
716 #elif CPU(X86_64)
717     static_assert(LLInt::LLIntPC == X86Registers::r8, &quot;Wrong LLInt PC.&quot;);
718     return reinterpret_cast&lt;void*&amp;&gt;(regs.r8);
719 #else
720 #error Unknown Architecture
721 #endif
722 
723 #endif // __DARWIN_UNIX03
724 
725 #elif OS(WINDOWS)
726 
727 #if CPU(ARM)
728     static_assert(LLInt::LLIntPC == ARMRegisters::r8, &quot;Wrong LLInt PC.&quot;);
729     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.R8);
730 #elif CPU(MIPS)
731 #error Dont know what to do with mips. Do we even need this?
732 #elif CPU(X86)
733     static_assert(LLInt::LLIntPC == X86Registers::esi, &quot;Wrong LLInt PC.&quot;);
734     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.Esi);
735 #elif CPU(X86_64)
736     static_assert(LLInt::LLIntPC == X86Registers::r10, &quot;Wrong LLInt PC.&quot;);
737     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) regs.R10);
738 #else
739 #error Unknown Architecture
740 #endif
741 
742 #elif HAVE(MACHINE_CONTEXT)
743     return llintInstructionPointer(regs.machineContext);
744 #endif
745 }
746 
747 inline void* llintInstructionPointer(const PlatformRegisters&amp; regs)
748 {
749     return llintInstructionPointer(const_cast&lt;PlatformRegisters&amp;&gt;(regs));
750 }
751 #endif // OS(WINDOWS) || HAVE(MACHINE_CONTEXT)
752 
753 
754 #if HAVE(MACHINE_CONTEXT)
755 inline void*&amp; llintInstructionPointer(mcontext_t&amp; machineContext)
756 {
757     // LLInt uses regT4 as PC.
758 #if OS(DARWIN)
759     return llintInstructionPointer(machineContext-&gt;__ss);
760 #elif OS(FREEBSD)
761 
762 #if CPU(X86)
763     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_esi);
764 #elif CPU(X86_64)
765     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_r8);
766 #elif CPU(ARM)
767     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.__gregs[_REG_R8]);
768 #elif CPU(ARM64)
769     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_gpregs.gp_x[4]);
770 #elif CPU(MIPS)
771     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.mc_regs[12]);
772 #else
773 #error Unknown Architecture
774 #endif
775 
776 #elif OS(FUCHSIA) || defined(__GLIBC__) || defined(__BIONIC__)
777 
778 // The following sequence depends on glibc&#39;s sys/ucontext.h.
779 #if CPU(X86)
780     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_ESI]);
781 #elif CPU(X86_64)
782     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[REG_R8]);
783 #elif CPU(ARM)
784     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.arm_r8);
785 #elif CPU(ARM64)
786     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.regs[4]);
787 #elif CPU(MIPS)
788     return reinterpret_cast&lt;void*&amp;&gt;((uintptr_t&amp;) machineContext.gregs[12]);
789 #else
790 #error Unknown Architecture
791 #endif
792 
793 #else
794 #error Need a way to get the LLIntPC for another thread on this platform
795 #endif
796 }
797 
798 inline void* llintInstructionPointer(const mcontext_t&amp; machineContext)
799 {
800     return llintInstructionPointer(const_cast&lt;mcontext_t&amp;&gt;(machineContext));
801 }
802 #endif // HAVE(MACHINE_CONTEXT)
803 #endif // !ENABLE(C_LOOP)
804 
805 }
806 }
    </pre>
  </body>
</html>
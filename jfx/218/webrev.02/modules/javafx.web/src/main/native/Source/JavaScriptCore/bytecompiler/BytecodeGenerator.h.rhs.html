<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #pragma once
  32 
<a name="1" id="anc1"></a><span class="line-added">  33 #include &quot;BytecodeGeneratorBase.h&quot;</span>
<span class="line-added">  34 #include &quot;BytecodeStructs.h&quot;</span>
  35 #include &quot;CodeBlock.h&quot;
  36 #include &quot;Instruction.h&quot;
  37 #include &quot;Interpreter.h&quot;
<a name="2" id="anc2"></a><span class="line-modified">  38 #include &quot;JSAsyncGenerator.h&quot;</span>
  39 #include &quot;JSBigInt.h&quot;
<a name="3" id="anc3"></a><span class="line-modified">  40 #include &quot;JSGenerator.h&quot;</span>
  41 #include &quot;JSTemplateObjectDescriptor.h&quot;
  42 #include &quot;Label.h&quot;
  43 #include &quot;LabelScope.h&quot;
  44 #include &quot;Nodes.h&quot;
  45 #include &quot;ParserError.h&quot;
  46 #include &quot;ProfileTypeBytecodeFlag.h&quot;
  47 #include &quot;RegisterID.h&quot;
  48 #include &quot;StaticPropertyAnalyzer.h&quot;
  49 #include &quot;SymbolTable.h&quot;
  50 #include &quot;UnlinkedCodeBlock.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  51 #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
  52 #include &lt;functional&gt;
  53 #include &lt;wtf/CheckedArithmetic.h&gt;
  54 #include &lt;wtf/HashFunctions.h&gt;
  55 #include &lt;wtf/Optional.h&gt;
  56 #include &lt;wtf/SegmentedVector.h&gt;
  57 #include &lt;wtf/SetForScope.h&gt;
  58 #include &lt;wtf/Vector.h&gt;
  59 
  60 namespace JSC {
  61 
  62     class JSImmutableButterfly;
  63     class Identifier;
  64     class IndexedForInContext;
  65     class StructureForInContext;
  66 
  67     enum ExpectedFunction {
  68         NoExpectedFunction,
  69         ExpectObjectConstructor,
  70         ExpectArrayConstructor
  71     };
  72 
  73     enum class EmitAwait { Yes, No };
  74 
  75     enum class DebuggableCall { Yes, No };
  76     enum class ThisResolutionType { Local, Scoped };
<a name="5" id="anc5"></a><span class="line-added">  77     enum class LinkTimeConstant : int32_t;</span>
  78 
  79     class CallArguments {
  80     public:
  81         CallArguments(BytecodeGenerator&amp;, ArgumentsNode*, unsigned additionalArguments = 0);
  82 
  83         RegisterID* thisRegister() { return m_argv[0].get(); }
  84         RegisterID* argumentRegister(unsigned i) { return m_argv[i + 1].get(); }
  85         unsigned stackOffset() { return -m_argv[0]-&gt;index() + CallFrame::headerSizeInRegisters; }
  86         unsigned argumentCountIncludingThis() { return m_argv.size() - m_padding; }
  87         ArgumentsNode* argumentsNode() { return m_argumentsNode; }
  88 
  89     private:
  90         ArgumentsNode* m_argumentsNode;
  91         Vector&lt;RefPtr&lt;RegisterID&gt;, 8, UnsafeVectorOverflow&gt; m_argv;
  92         unsigned m_padding;
  93     };
  94 
  95     // https://tc39.github.io/ecma262/#sec-completion-record-specification-type
  96     //
  97     // For the Break and Continue cases, instead of using the Break and Continue enum values
  98     // below, we use the unique jumpID of the break and continue statement as the encoding
  99     // for the CompletionType value. emitFinallyCompletion() uses this jumpID value later
 100     // to determine the appropriate jump target to jump to after executing the relevant finally
 101     // blocks. The jumpID is computed as:
 102     //     jumpID = bytecodeOffset (of the break/continue node) + CompletionType::NumberOfTypes.
 103     // Hence, there won&#39;t be any collision between jumpIDs and CompletionType enums.
 104     enum class CompletionType : int {
 105         Normal,
 106         Throw,
 107         Return,
 108         NumberOfTypes
 109     };
 110 
 111     inline CompletionType bytecodeOffsetToJumpID(unsigned offset)
 112     {
 113         int jumpIDAsInt = offset + static_cast&lt;int&gt;(CompletionType::NumberOfTypes);
 114         ASSERT(jumpIDAsInt &gt;= static_cast&lt;int&gt;(CompletionType::NumberOfTypes));
 115         return static_cast&lt;CompletionType&gt;(jumpIDAsInt);
 116     }
 117 
 118     struct FinallyJump {
 119         FinallyJump(CompletionType jumpID, int targetLexicalScopeIndex, Label&amp; targetLabel)
 120             : jumpID(jumpID)
 121             , targetLexicalScopeIndex(targetLexicalScopeIndex)
 122             , targetLabel(targetLabel)
 123         { }
 124 
 125         CompletionType jumpID;
 126         int targetLexicalScopeIndex;
 127         Ref&lt;Label&gt; targetLabel;
 128     };
 129 
 130     class FinallyContext {
 131     public:
 132         FinallyContext() { }
 133         FinallyContext(BytecodeGenerator&amp;, Label&amp; finallyLabel);
 134 
 135         FinallyContext* outerContext() const { return m_outerContext; }
 136         Label* finallyLabel() const { return m_finallyLabel; }
 137 
 138         RegisterID* completionTypeRegister() const { return m_completionRecord.typeRegister.get(); }
 139         RegisterID* completionValueRegister() const { return m_completionRecord.valueRegister.get(); }
 140 
 141         uint32_t numberOfBreaksOrContinues() const { return m_numberOfBreaksOrContinues.unsafeGet(); }
 142         void incNumberOfBreaksOrContinues() { m_numberOfBreaksOrContinues++; }
 143 
 144         bool handlesReturns() const { return m_handlesReturns; }
 145         void setHandlesReturns() { m_handlesReturns = true; }
 146 
 147         void registerJump(CompletionType jumpID, int lexicalScopeIndex, Label&amp; targetLabel)
 148         {
 149             m_jumps.append(FinallyJump(jumpID, lexicalScopeIndex, targetLabel));
 150         }
 151 
 152         size_t numberOfJumps() const { return m_jumps.size(); }
 153         FinallyJump&amp; jumps(size_t i) { return m_jumps[i]; }
 154 
 155     private:
 156         FinallyContext* m_outerContext { nullptr };
 157         Label* m_finallyLabel { nullptr };
 158         Checked&lt;uint32_t, WTF::CrashOnOverflow&gt; m_numberOfBreaksOrContinues;
 159         bool m_handlesReturns { false };
 160         Vector&lt;FinallyJump&gt; m_jumps;
 161         struct {
 162             RefPtr&lt;RegisterID&gt; typeRegister;
 163             RefPtr&lt;RegisterID&gt; valueRegister;
 164         } m_completionRecord;
 165     };
 166 
 167     struct ControlFlowScope {
 168         typedef uint8_t Type;
 169         enum {
 170             Label,
 171             Finally
 172         };
 173         ControlFlowScope(Type type, int lexicalScopeIndex, FinallyContext* finallyContext = nullptr)
 174             : type(type)
 175             , lexicalScopeIndex(lexicalScopeIndex)
 176             , finallyContext(finallyContext)
 177         { }
 178 
 179         bool isLabelScope() const { return type == Label; }
 180         bool isFinallyScope() const { return type == Finally; }
 181 
 182         Type type;
 183         int lexicalScopeIndex;
 184         FinallyContext* finallyContext;
 185     };
 186 
 187     class ForInContext : public RefCounted&lt;ForInContext&gt; {
 188         WTF_MAKE_FAST_ALLOCATED;
 189         WTF_MAKE_NONCOPYABLE(ForInContext);
 190     public:
 191         virtual ~ForInContext() = default;
 192 
 193         bool isValid() const { return m_isValid; }
 194         void invalidate() { m_isValid = false; }
 195 
 196         enum class Type : uint8_t {
 197             IndexedForIn,
 198             StructureForIn
 199         };
 200 
 201         Type type() const { return m_type; }
 202         bool isIndexedForInContext() const { return m_type == Type::IndexedForIn; }
 203         bool isStructureForInContext() const { return m_type == Type::StructureForIn; }
 204 
 205         IndexedForInContext&amp; asIndexedForInContext()
 206         {
 207             ASSERT(isIndexedForInContext());
 208             return *reinterpret_cast&lt;IndexedForInContext*&gt;(this);
 209         }
 210 
 211         StructureForInContext&amp; asStructureForInContext()
 212         {
 213             ASSERT(isStructureForInContext());
 214             return *reinterpret_cast&lt;StructureForInContext*&gt;(this);
 215         }
 216 
 217         RegisterID* local() const { return m_localRegister.get(); }
 218 
 219     protected:
 220         ForInContext(RegisterID* localRegister, Type type, unsigned bodyBytecodeStartOffset)
 221             : m_localRegister(localRegister)
 222             , m_type(type)
 223             , m_bodyBytecodeStartOffset(bodyBytecodeStartOffset)
 224         { }
 225 
 226         unsigned bodyBytecodeStartOffset() const { return m_bodyBytecodeStartOffset; }
 227 
<a name="6" id="anc6"></a><span class="line-modified"> 228         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlockGenerator*, unsigned bodyBytecodeEndOffset);</span>
 229 
 230     private:
 231         RefPtr&lt;RegisterID&gt; m_localRegister;
 232         bool m_isValid { true };
 233         Type m_type;
 234         unsigned m_bodyBytecodeStartOffset;
 235     };
 236 
 237     class StructureForInContext : public ForInContext {
 238         using Base = ForInContext;
 239     public:
 240         using GetInst = std::tuple&lt;unsigned, int&gt;;
 241 
 242         StructureForInContext(RegisterID* localRegister, RegisterID* indexRegister, RegisterID* propertyRegister, RegisterID* enumeratorRegister, unsigned bodyBytecodeStartOffset)
 243             : ForInContext(localRegister, Type::StructureForIn, bodyBytecodeStartOffset)
 244             , m_indexRegister(indexRegister)
 245             , m_propertyRegister(propertyRegister)
 246             , m_enumeratorRegister(enumeratorRegister)
 247         {
 248         }
 249 
 250         RegisterID* index() const { return m_indexRegister.get(); }
 251         RegisterID* property() const { return m_propertyRegister.get(); }
 252         RegisterID* enumerator() const { return m_enumeratorRegister.get(); }
 253 
 254         void addGetInst(unsigned instIndex, int propertyRegIndex)
 255         {
 256             m_getInsts.append(GetInst { instIndex, propertyRegIndex });
 257         }
 258 
<a name="7" id="anc7"></a><span class="line-modified"> 259         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlockGenerator*, unsigned bodyBytecodeEndOffset);</span>
 260 
 261     private:
 262         RefPtr&lt;RegisterID&gt; m_indexRegister;
 263         RefPtr&lt;RegisterID&gt; m_propertyRegister;
 264         RefPtr&lt;RegisterID&gt; m_enumeratorRegister;
 265         Vector&lt;GetInst&gt; m_getInsts;
 266     };
 267 
 268     class IndexedForInContext : public ForInContext {
 269         using Base = ForInContext;
 270     public:
 271         IndexedForInContext(RegisterID* localRegister, RegisterID* indexRegister, unsigned bodyBytecodeStartOffset)
 272             : ForInContext(localRegister, Type::IndexedForIn, bodyBytecodeStartOffset)
 273             , m_indexRegister(indexRegister)
 274         {
 275         }
 276 
 277         RegisterID* index() const { return m_indexRegister.get(); }
 278 
<a name="8" id="anc8"></a><span class="line-modified"> 279         void finalize(BytecodeGenerator&amp;, UnlinkedCodeBlockGenerator*, unsigned bodyBytecodeEndOffset);</span>
 280         void addGetInst(unsigned instIndex, int propertyIndex) { m_getInsts.append({ instIndex, propertyIndex }); }
 281 
 282     private:
 283         RefPtr&lt;RegisterID&gt; m_indexRegister;
 284         Vector&lt;std::pair&lt;unsigned, int&gt;&gt; m_getInsts;
 285     };
 286 
 287     struct TryData {
 288         Ref&lt;Label&gt; target;
 289         HandlerType handlerType;
 290     };
 291 
 292     struct TryContext {
 293         Ref&lt;Label&gt; start;
 294         TryData* tryData;
 295     };
 296 
 297     class Variable {
 298     public:
 299         enum VariableKind { NormalVariable, SpecialVariable };
 300 
 301         Variable()
 302             : m_offset()
 303             , m_local(nullptr)
 304             , m_attributes(0)
 305             , m_kind(NormalVariable)
 306             , m_symbolTableConstantIndex(0) // This is meaningless here for this kind of Variable.
 307             , m_isLexicallyScoped(false)
 308         {
 309         }
 310 
 311         Variable(const Identifier&amp; ident)
 312             : m_ident(ident)
 313             , m_local(nullptr)
 314             , m_attributes(0)
 315             , m_kind(NormalVariable) // This is somewhat meaningless here for this kind of Variable.
 316             , m_symbolTableConstantIndex(0) // This is meaningless here for this kind of Variable.
 317             , m_isLexicallyScoped(false)
 318         {
 319         }
 320 
 321         Variable(const Identifier&amp; ident, VarOffset offset, RegisterID* local, unsigned attributes, VariableKind kind, int symbolTableConstantIndex, bool isLexicallyScoped)
 322             : m_ident(ident)
 323             , m_offset(offset)
 324             , m_local(local)
 325             , m_attributes(attributes)
 326             , m_kind(kind)
 327             , m_symbolTableConstantIndex(symbolTableConstantIndex)
 328             , m_isLexicallyScoped(isLexicallyScoped)
 329         {
 330         }
 331 
 332         // If it&#39;s unset, then it is a non-locally-scoped variable. If it is set, then it could be
 333         // a stack variable, a scoped variable in a local scope, or a variable captured in the
 334         // direct arguments object.
 335         bool isResolved() const { return !!m_offset; }
 336         int symbolTableConstantIndex() const { ASSERT(isResolved() &amp;&amp; !isSpecial()); return m_symbolTableConstantIndex; }
 337 
 338         const Identifier&amp; ident() const { return m_ident; }
 339 
 340         VarOffset offset() const { return m_offset; }
 341         bool isLocal() const { return m_offset.isStack(); }
 342         RegisterID* local() const { return m_local; }
 343 
 344         bool isReadOnly() const { return m_attributes &amp; PropertyAttribute::ReadOnly; }
 345         bool isSpecial() const { return m_kind != NormalVariable; }
 346         bool isConst() const { return isReadOnly() &amp;&amp; m_isLexicallyScoped; }
 347         void setIsReadOnly() { m_attributes |= PropertyAttribute::ReadOnly; }
 348 
 349         void dump(PrintStream&amp;) const;
 350 
 351     private:
 352         Identifier m_ident;
 353         VarOffset m_offset;
 354         RegisterID* m_local;
 355         unsigned m_attributes;
 356         VariableKind m_kind;
 357         int m_symbolTableConstantIndex;
 358         bool m_isLexicallyScoped;
 359     };
 360 
 361     struct TryRange {
 362         Ref&lt;Label&gt; start;
 363         Ref&lt;Label&gt; end;
 364         TryData* tryData;
 365     };
 366 
<a name="9" id="anc9"></a><span class="line-modified"> 367 </span>
<span class="line-added"> 368     struct JSGeneratorTraits {</span>
<span class="line-added"> 369         using OpcodeTraits = JSOpcodeTraits;</span>
<span class="line-added"> 370         using OpcodeID = ::JSC::OpcodeID;</span>
<span class="line-added"> 371         using OpNop = ::JSC::OpNop;</span>
<span class="line-added"> 372         using CodeBlock = std::unique_ptr&lt;UnlinkedCodeBlockGenerator&gt;;</span>
<span class="line-added"> 373         static constexpr OpcodeID opcodeForDisablingOptimizations = op_end;</span>
<span class="line-added"> 374     };</span>
<span class="line-added"> 375 </span>
<span class="line-added"> 376     class BytecodeGenerator : public BytecodeGeneratorBase&lt;JSGeneratorTraits&gt; {</span>
 377         WTF_MAKE_FAST_ALLOCATED;
 378         WTF_MAKE_NONCOPYABLE(BytecodeGenerator);
 379 
<a name="10" id="anc10"></a>
 380         friend class FinallyContext;
<a name="11" id="anc11"></a>
 381         friend class IndexedForInContext;
 382         friend class StructureForInContext;
 383     public:
 384         typedef DeclarationStacks::FunctionStack FunctionStack;
 385 
 386         BytecodeGenerator(VM&amp;, ProgramNode*, UnlinkedProgramCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);
 387         BytecodeGenerator(VM&amp;, FunctionNode*, UnlinkedFunctionCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);
 388         BytecodeGenerator(VM&amp;, EvalNode*, UnlinkedEvalCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);
 389         BytecodeGenerator(VM&amp;, ModuleProgramNode*, UnlinkedModuleProgramCodeBlock*, OptionSet&lt;CodeGenerationMode&gt;, const VariableEnvironment*);
 390 
 391         ~BytecodeGenerator();
 392 
 393         VM&amp; vm() const { return m_vm; }
 394         ParserArena&amp; parserArena() const { return m_scopeNode-&gt;parserArena(); }
 395         const CommonIdentifiers&amp; propertyNames() const { return *m_vm.propertyNames; }
 396 
 397         bool isConstructor() const { return m_codeBlock-&gt;isConstructor(); }
 398         DerivedContextType derivedContextType() const { return m_derivedContextType; }
 399         bool usesArrowFunction() const { return m_scopeNode-&gt;usesArrowFunction(); }
 400         bool needsToUpdateArrowFunctionContext() const { return m_needsToUpdateArrowFunctionContext; }
 401         bool usesEval() const { return m_scopeNode-&gt;usesEval(); }
 402         bool usesThis() const { return m_scopeNode-&gt;usesThis(); }
 403         ConstructorKind constructorKind() const { return m_codeBlock-&gt;constructorKind(); }
 404         SuperBinding superBinding() const { return m_codeBlock-&gt;superBinding(); }
 405         JSParserScriptMode scriptMode() const { return m_codeBlock-&gt;scriptMode(); }
<a name="12" id="anc12"></a><span class="line-added"> 406         NeedsClassFieldInitializer needsClassFieldInitializer() const { return m_codeBlock-&gt;needsClassFieldInitializer(); }</span>
 407 
 408         template&lt;typename Node, typename UnlinkedCodeBlock&gt;
 409         static ParserError generate(VM&amp; vm, Node* node, const SourceCode&amp; sourceCode, UnlinkedCodeBlock* unlinkedCodeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* environment)
 410         {
 411             MonotonicTime before;
 412             if (UNLIKELY(Options::reportBytecodeCompileTimes()))
 413                 before = MonotonicTime::now();
 414 
 415             DeferGC deferGC(vm.heap);
 416             auto bytecodeGenerator = makeUnique&lt;BytecodeGenerator&gt;(vm, node, unlinkedCodeBlock, codeGenerationMode, environment);
 417             auto result = bytecodeGenerator-&gt;generate();
 418 
 419             if (UNLIKELY(Options::reportBytecodeCompileTimes())) {
 420                 MonotonicTime after = MonotonicTime::now();
 421                 dataLogLn(result.isValid() ? &quot;Failed to compile #&quot; : &quot;Compiled #&quot;, CodeBlockHash(sourceCode, unlinkedCodeBlock-&gt;isConstructor() ? CodeForConstruct : CodeForCall), &quot; into bytecode &quot;, bytecodeGenerator-&gt;instructions().size(), &quot; instructions in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
 422             }
 423             return result;
 424         }
 425 
 426         bool isArgumentNumber(const Identifier&amp;, int);
 427 
 428         Variable variable(const Identifier&amp;, ThisResolutionType = ThisResolutionType::Local);
 429 
 430         enum ExistingVariableMode { VerifyExisting, IgnoreExisting };
 431         void createVariable(const Identifier&amp;, VarKind, SymbolTable*, ExistingVariableMode = VerifyExisting); // Creates the variable, or asserts that the already-created variable is sufficiently compatible.
 432 
 433         // Returns the register storing &quot;this&quot;
 434         RegisterID* thisRegister() { return &amp;m_thisRegister; }
 435         RegisterID* argumentsRegister() { return m_argumentsRegister; }
 436         RegisterID* newTarget()
 437         {
 438             ASSERT(m_newTargetRegister);
 439             return m_newTargetRegister;
 440         }
 441 
 442         RegisterID* scopeRegister() { return m_scopeRegister; }
 443 
 444         RegisterID* generatorRegister() { return m_generatorRegister; }
 445 
<a name="13" id="anc13"></a><span class="line-modified"> 446         RegisterID* promiseRegister() { return m_promiseRegister; }</span>






 447 
 448         // The same as newTemporary(), but this function returns &quot;suggestion&quot; if
 449         // &quot;suggestion&quot; is a temporary. This function is helpful in situations
 450         // where you&#39;ve put &quot;suggestion&quot; in a RefPtr, but you&#39;d like to allow
 451         // the next instruction to overwrite it anyway.
 452         RegisterID* newTemporaryOr(RegisterID* suggestion) { return suggestion-&gt;isTemporary() ? suggestion : newTemporary(); }
 453 
 454         // Functions for handling of dst register
 455 
 456         RegisterID* ignoredResult() { return &amp;m_ignoredResultRegister; }
 457 
 458         // This will be allocated in the temporary region of registers, but it will
 459         // not be marked as a temporary. This will ensure that finalDestination() does
 460         // not overwrite a block scope variable that it mistakes as a temporary. These
 461         // registers can be (and are) reclaimed when the lexical scope they belong to
 462         // is no longer on the symbol table stack.
 463         RegisterID* newBlockScopeVariable();
 464 
 465         // Returns a place to write intermediate values of an operation
 466         // which reuses dst if it is safe to do so.
 467         RegisterID* tempDestination(RegisterID* dst)
 468         {
 469             return (dst &amp;&amp; dst != ignoredResult() &amp;&amp; dst-&gt;isTemporary()) ? dst : newTemporary();
 470         }
 471 
 472         // Returns the place to write the final output of an operation.
 473         RegisterID* finalDestination(RegisterID* originalDst, RegisterID* tempDst = 0)
 474         {
 475             if (originalDst &amp;&amp; originalDst != ignoredResult())
 476                 return originalDst;
 477             ASSERT(tempDst != ignoredResult());
 478             if (tempDst &amp;&amp; tempDst-&gt;isTemporary())
 479                 return tempDst;
 480             return newTemporary();
 481         }
 482 
 483         RegisterID* destinationForAssignResult(RegisterID* dst)
 484         {
 485             if (dst &amp;&amp; dst != ignoredResult())
 486                 return dst-&gt;isTemporary() ? dst : newTemporary();
 487             return 0;
 488         }
 489 
 490         // Moves src to dst if dst is not null and is different from src, otherwise just returns src.
 491         RegisterID* move(RegisterID* dst, RegisterID* src)
 492         {
 493             return dst == ignoredResult() ? nullptr : (dst &amp;&amp; dst != src) ? emitMove(dst, src) : src;
 494         }
 495 
 496         Ref&lt;LabelScope&gt; newLabelScope(LabelScope::Type, const Identifier* = 0);
<a name="14" id="anc14"></a>

 497 
 498         void emitNode(RegisterID* dst, StatementNode* n)
 499         {
 500             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 501             return emitNodeInTailPosition(dst, n);
 502         }
 503 
 504         void emitNodeInTailPosition(RegisterID* dst, StatementNode* n)
 505         {
 506             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 507             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
 508             if (UNLIKELY(!m_vm.isSafeToRecurse())) {
 509                 emitThrowExpressionTooDeepException();
 510                 return;
 511             }
 512             if (UNLIKELY(n-&gt;needsDebugHook()))
 513                 emitDebugHook(n);
 514             n-&gt;emitBytecode(*this, dst);
 515         }
 516 
<a name="15" id="anc15"></a>

 517         ALWAYS_INLINE unsigned addMetadataFor(OpcodeID opcodeID)
 518         {
 519             return m_codeBlock-&gt;metadata().addEntry(opcodeID);
 520         }
 521 
 522         void emitNode(StatementNode* n)
 523         {
 524             emitNode(nullptr, n);
 525         }
 526 
 527         void emitNodeInTailPosition(StatementNode* n)
 528         {
 529             emitNodeInTailPosition(nullptr, n);
 530         }
 531 
 532         RegisterID* emitNode(RegisterID* dst, ExpressionNode* n)
 533         {
 534             SetForScope&lt;bool&gt; tailPositionPoisoner(m_inTailPosition, false);
 535             return emitNodeInTailPosition(dst, n);
 536         }
 537 
 538         RegisterID* emitNodeInTailPosition(RegisterID* dst, ExpressionNode* n)
 539         {
 540             // Node::emitCode assumes that dst, if provided, is either a local or a referenced temporary.
 541             ASSERT(!dst || dst == ignoredResult() || !dst-&gt;isTemporary() || dst-&gt;refCount());
 542             if (UNLIKELY(!m_vm.isSafeToRecurse()))
 543                 return emitThrowExpressionTooDeepException();
 544             if (UNLIKELY(n-&gt;needsDebugHook()))
 545                 emitDebugHook(n);
 546             return n-&gt;emitBytecode(*this, dst);
 547         }
 548 
 549         RegisterID* emitNode(ExpressionNode* n)
 550         {
 551             return emitNode(nullptr, n);
 552         }
 553 
 554         RegisterID* emitNodeInTailPosition(ExpressionNode* n)
 555         {
 556             return emitNodeInTailPosition(nullptr, n);
 557         }
 558 
<a name="16" id="anc16"></a><span class="line-modified"> 559         RegisterID* emitDefineClassElements(PropertyListNode* n, RegisterID* constructor, RegisterID* prototype, Vector&lt;JSTextPosition&gt;&amp; instanceFieldLocations)</span>
 560         {
 561             ASSERT(constructor-&gt;refCount() &amp;&amp; prototype-&gt;refCount());
 562             if (UNLIKELY(!m_vm.isSafeToRecurse()))
 563                 return emitThrowExpressionTooDeepException();
 564             if (UNLIKELY(n-&gt;needsDebugHook()))
 565                 emitDebugHook(n);
<a name="17" id="anc17"></a><span class="line-modified"> 566             return n-&gt;emitBytecode(*this, constructor, prototype, &amp;instanceFieldLocations);</span>
 567         }
 568 
 569         RegisterID* emitNodeForProperty(RegisterID* dst, ExpressionNode* node)
 570         {
 571             if (node-&gt;isString()) {
 572                 if (Optional&lt;uint32_t&gt; index = parseIndex(static_cast&lt;StringNode*&gt;(node)-&gt;value()))
 573                     return emitLoad(dst, jsNumber(index.value()));
 574             }
 575             return emitNode(dst, node);
 576         }
 577 
 578         RegisterID* emitNodeForProperty(ExpressionNode* n)
 579         {
 580             return emitNodeForProperty(nullptr, n);
 581         }
 582 
 583         void emitNodeInConditionContext(ExpressionNode* n, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
 584         {
 585             if (UNLIKELY(!m_vm.isSafeToRecurse())) {
 586                 emitThrowExpressionTooDeepException();
 587                 return;
 588             }
 589             n-&gt;emitBytecodeInConditionContext(*this, trueTarget, falseTarget, fallThroughMode);
 590         }
 591 
 592         void emitExpressionInfo(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 593         {
 594             ASSERT(divot.offset &gt;= divotStart.offset);
 595             ASSERT(divotEnd.offset &gt;= divot.offset);
 596 
<a name="18" id="anc18"></a><span class="line-added"> 597             if (m_isBuiltinFunction)</span>
<span class="line-added"> 598                 return;</span>
<span class="line-added"> 599 </span>
 600             int sourceOffset = m_scopeNode-&gt;source().startOffset();
 601             unsigned firstLine = m_scopeNode-&gt;source().firstLine().oneBasedInt();
 602 
 603             int divotOffset = divot.offset - sourceOffset;
 604             int startOffset = divot.offset - divotStart.offset;
 605             int endOffset = divotEnd.offset - divot.offset;
 606 
 607             unsigned line = divot.line;
 608             ASSERT(line &gt;= firstLine);
 609             line -= firstLine;
 610 
 611             int lineStart = divot.lineStartOffset;
 612             if (lineStart &gt; sourceOffset)
 613                 lineStart -= sourceOffset;
 614             else
 615                 lineStart = 0;
 616 
 617             if (divotOffset &lt; lineStart)
 618                 return;
 619 
 620             unsigned column = divotOffset - lineStart;
 621 
 622             unsigned instructionOffset = instructions().size();
<a name="19" id="anc19"></a><span class="line-modified"> 623             m_codeBlock-&gt;addExpressionInfo(instructionOffset, divotOffset, startOffset, endOffset, line, column);</span>

 624         }
 625 
 626 
 627         ALWAYS_INLINE bool leftHandSideNeedsCopy(bool rightHasAssignments, bool rightIsPure)
 628         {
 629             return (m_codeType != FunctionCode || rightHasAssignments) &amp;&amp; !rightIsPure;
 630         }
 631 
 632         ALWAYS_INLINE RefPtr&lt;RegisterID&gt; emitNodeForLeftHandSide(ExpressionNode* n, bool rightHasAssignments, bool rightIsPure)
 633         {
 634             if (leftHandSideNeedsCopy(rightHasAssignments, rightIsPure)) {
 635                 RefPtr&lt;RegisterID&gt; dst = newTemporary();
 636                 emitNode(dst.get(), n);
 637                 return dst;
 638             }
 639 
 640             return emitNode(n);
 641         }
 642 
 643         ALWAYS_INLINE RefPtr&lt;RegisterID&gt; emitNodeForLeftHandSideForProperty(ExpressionNode* n, bool rightHasAssignments, bool rightIsPure)
 644         {
 645             if (leftHandSideNeedsCopy(rightHasAssignments, rightIsPure)) {
 646                 RefPtr&lt;RegisterID&gt; dst = newTemporary();
 647                 emitNodeForProperty(dst.get(), n);
 648                 return dst;
 649             }
 650 
 651             return emitNodeForProperty(n);
 652         }
 653 
 654         void hoistSloppyModeFunctionIfNecessary(const Identifier&amp; functionName);
 655 
 656     private:
 657         void emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 658     public:
 659 
 660         // This doesn&#39;t emit expression info. If using this, make sure you shouldn&#39;t be emitting text offset.
 661         void emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag);
 662         // These variables are associated with variables in a program. They could be Locals, LocalClosureVar, or ClosureVar.
 663         void emitProfileType(RegisterID* registerToProfile, const Variable&amp;, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 664 
 665         void emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 666         // These are not associated with variables and don&#39;t have a global id.
 667         void emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot);
 668 
 669         void emitProfileControlFlow(int);
 670 
 671         RegisterID* emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp;);
 672         RegisterID* ensureThis();
 673         void emitLoadThisFromArrowFunctionLexicalEnvironment();
 674         RegisterID* emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 675 
 676         unsigned addConstantIndex();
 677         RegisterID* emitLoad(RegisterID* dst, bool);
 678         RegisterID* emitLoad(RegisterID* dst, const Identifier&amp;);
 679         RegisterID* emitLoad(RegisterID* dst, JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
 680         RegisterID* emitLoad(RegisterID* dst, IdentifierSet&amp; excludedList);
 681 
 682         template&lt;typename UnaryOp, typename = std::enable_if_t&lt;UnaryOp::opcodeID != op_negate&gt;&gt;
 683         RegisterID* emitUnaryOp(RegisterID* dst, RegisterID* src)
 684         {
 685             UnaryOp::emit(this, dst, src);
 686             return dst;
 687         }
 688 
<a name="20" id="anc20"></a><span class="line-modified"> 689         RegisterID* emitUnaryOp(OpcodeID, RegisterID* dst, RegisterID* src, ResultType);</span>
 690 
 691         template&lt;typename BinaryOp&gt;
 692         std::enable_if_t&lt;
 693             BinaryOp::opcodeID != op_add
 694             &amp;&amp; BinaryOp::opcodeID != op_mul
 695             &amp;&amp; BinaryOp::opcodeID != op_sub
 696             &amp;&amp; BinaryOp::opcodeID != op_div,
 697             RegisterID*&gt;
 698         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes)
 699         {
 700             BinaryOp::emit(this, dst, src1, src2);
 701             return dst;
 702         }
 703 
 704         template&lt;typename BinaryOp&gt;
 705         std::enable_if_t&lt;
 706             BinaryOp::opcodeID == op_add
 707             || BinaryOp::opcodeID == op_mul
 708             || BinaryOp::opcodeID == op_sub
 709             || BinaryOp::opcodeID == op_div,
 710             RegisterID*&gt;
 711         emitBinaryOp(RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
 712         {
 713             BinaryOp::emit(this, dst, src1, src2, types);
 714             return dst;
 715         }
 716 
 717         RegisterID* emitBinaryOp(OpcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes);
 718 
 719         template&lt;typename EqOp&gt;
 720         RegisterID* emitEqualityOp(RegisterID* dst, RegisterID* src1, RegisterID* src2)
 721         {
 722             if (!emitEqualityOpImpl(dst, src1, src2))
 723                 EqOp::emit(this, dst, src1, src2);
 724             return dst;
 725         }
 726 
 727         bool emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2);
 728 
 729         RegisterID* emitCreateThis(RegisterID* dst);
<a name="21" id="anc21"></a><span class="line-added"> 730         RegisterID* emitCreatePromise(RegisterID* dst, RegisterID* newTarget, bool isInternalPromise);</span>
<span class="line-added"> 731         RegisterID* emitCreateGenerator(RegisterID* dst, RegisterID* newTarget);</span>
<span class="line-added"> 732         RegisterID* emitCreateAsyncGenerator(RegisterID* dst, RegisterID* newTarget);</span>
<span class="line-added"> 733         RegisterID* emitCreateArgumentsButterfly(RegisterID* dst);</span>
<span class="line-added"> 734         RegisterID* emitInstanceFieldInitializationIfNeeded(RegisterID* dst, RegisterID* constructor, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);</span>
 735         void emitTDZCheck(RegisterID* target);
 736         bool needsTDZCheck(const Variable&amp;);
 737         void emitTDZCheckIfNecessary(const Variable&amp;, RegisterID* target, RegisterID* scope);
 738         void liftTDZCheckIfPossible(const Variable&amp;);
 739         RegisterID* emitNewObject(RegisterID* dst);
<a name="22" id="anc22"></a><span class="line-added"> 740         RegisterID* emitNewPromise(RegisterID* dst, bool isInternalPromise);</span>
<span class="line-added"> 741         RegisterID* emitNewGenerator(RegisterID* dst);</span>
 742         RegisterID* emitNewArray(RegisterID* dst, ElementNode*, unsigned length, IndexingType recommendedIndexingType); // stops at first elision
 743         RegisterID* emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly*, IndexingType recommendedIndexingType);
 744         // FIXME: new_array_with_spread should use an array allocation profile and take a recommendedIndexingType
 745         RegisterID* emitNewArrayWithSpread(RegisterID* dst, ElementNode*);
 746         RegisterID* emitNewArrayWithSize(RegisterID* dst, RegisterID* length);
 747 
 748         RegisterID* emitNewFunction(RegisterID* dst, FunctionMetadataNode*);
 749         RegisterID* emitNewFunctionExpression(RegisterID* dst, FuncExprNode*);
<a name="23" id="anc23"></a><span class="line-modified"> 750         RegisterID* emitNewDefaultConstructor(RegisterID* dst, ConstructorKind, const Identifier&amp; name, const Identifier&amp; ecmaName, const SourceCode&amp; classSource, NeedsClassFieldInitializer);</span>
<span class="line-added"> 751         RegisterID* emitNewInstanceFieldInitializerFunction(RegisterID* dst, Vector&lt;JSTextPosition&gt;&amp;&amp; instanceFieldLocations, bool isDerived);</span>
 752         RegisterID* emitNewArrowFunctionExpression(RegisterID*, ArrowFuncExprNode*);
 753         RegisterID* emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode*);
 754         RegisterID* emitNewRegExp(RegisterID* dst, RegExp*);
 755 
 756         void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name);
<a name="24" id="anc24"></a><span class="line-added"> 757         void emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, const Identifier&amp;);</span>
 758 
 759         RegisterID* moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant);
 760         RegisterID* moveEmptyValue(RegisterID* dst);
 761 
 762         RegisterID* emitToNumber(RegisterID* dst, RegisterID* src);
<a name="25" id="anc25"></a><span class="line-added"> 763         RegisterID* emitToNumeric(RegisterID* dst, RegisterID* src);</span>
 764         RegisterID* emitToString(RegisterID* dst, RegisterID* src);
 765         RegisterID* emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message);
 766         RegisterID* emitInc(RegisterID* srcDst);
 767         RegisterID* emitDec(RegisterID* srcDst);
 768 
 769         RegisterID* emitOverridesHasInstance(RegisterID* dst, RegisterID* constructor, RegisterID* hasInstanceValue);
 770         RegisterID* emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype);
 771         RegisterID* emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue);
 772         RegisterID* emitTypeOf(RegisterID* dst, RegisterID* src);
 773         RegisterID* emitInByVal(RegisterID* dst, RegisterID* property, RegisterID* base);
 774         RegisterID* emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 775 
 776         RegisterID* emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 777         RegisterID* emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 778         RegisterID* emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property);
 779         RegisterID* emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property);
 780         RegisterID* emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value);
 781         RegisterID* emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value);
 782         RegisterID* emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType);
 783         RegisterID* emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp;);
 784         RegisterID* emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property);
 785         RegisterID* emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property);
 786         RegisterID* emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
 787         RegisterID* emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value);
 788         RegisterID* emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value);
 789         RegisterID* emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property);
 790 
<a name="26" id="anc26"></a><span class="line-added"> 791         RegisterID* emitGetInternalField(RegisterID* dst, RegisterID* base, unsigned index);</span>
<span class="line-added"> 792         RegisterID* emitPutInternalField(RegisterID* base, unsigned index, RegisterID* value);</span>
<span class="line-added"> 793 </span>
 794         void emitSuperSamplerBegin();
 795         void emitSuperSamplerEnd();
 796 
 797         RegisterID* emitIdWithProfile(RegisterID* src, SpeculatedType profile);
 798         void emitUnreachable();
 799 
 800         void emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned propertyDescriptorOptions, RegisterID* getter);
 801         void emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned propertyDescriptorOptions, RegisterID* setter);
 802         void emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter);
 803         void emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned propertyDescriptorOptions, RegisterID* getter);
 804         void emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned propertyDescriptorOptions, RegisterID* setter);
 805 
 806         RegisterID* emitGetArgument(RegisterID* dst, int32_t index);
 807 
 808         // Initialize object with generator fields (@generatorThis, @generatorNext, @generatorState, @generatorFrame)
 809         void emitPutGeneratorFields(RegisterID* nextFunction);
 810 
 811         void emitPutAsyncGeneratorFields(RegisterID* nextFunction);
 812 
 813         ExpectedFunction expectedFunctionForIdentifier(const Identifier&amp;);
 814         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 815         RegisterID* emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 816         RegisterID* emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 817         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 818         RegisterID* emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 819         RegisterID* emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
 820 
 821         enum PropertyDescriptorOption {
 822             PropertyConfigurable = 1,
 823             PropertyWritable     = 1 &lt;&lt; 1,
 824             PropertyEnumerable   = 1 &lt;&lt; 2,
 825         };
 826         void emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
 827             RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp;);
 828 
 829         void emitEnumeration(ThrowableExpressionData* enumerationNode, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* = nullptr, RegisterID* forLoopSymbolTable = nullptr);
 830 
 831         RegisterID* emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode*);
 832         RegisterID* emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property);
 833 
 834         enum class ReturnFrom { Normal, Finally };
 835         RegisterID* emitReturn(RegisterID* src, ReturnFrom = ReturnFrom::Normal);
 836         RegisterID* emitEnd(RegisterID* src);
 837 
 838         RegisterID* emitConstruct(RegisterID* dst, RegisterID* func, RegisterID* lazyThis, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 839         RegisterID* emitStrcat(RegisterID* dst, RegisterID* src, int count);
 840         void emitToPrimitive(RegisterID* dst, RegisterID* src);
<a name="27" id="anc27"></a><span class="line-added"> 841         RegisterID* emitToPropertyKey(RegisterID* dst, RegisterID* src);</span>
 842 
 843         ResolveType resolveType();
 844         RegisterID* emitResolveConstantLocal(RegisterID* dst, const Variable&amp;);
 845         RegisterID* emitResolveScope(RegisterID* dst, const Variable&amp;);
 846         RegisterID* emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp;, ResolveMode);
 847         RegisterID* emitPutToScope(RegisterID* scope, const Variable&amp;, RegisterID* value, ResolveMode, InitializationMode);
 848 
 849         RegisterID* emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp;);
 850 
 851         RegisterID* initializeVariable(const Variable&amp;, RegisterID* value);
 852 
<a name="28" id="anc28"></a>
 853         void emitLoopHint();
 854         void emitJump(Label&amp; target);
 855         void emitJumpIfTrue(RegisterID* cond, Label&amp; target);
 856         void emitJumpIfFalse(RegisterID* cond, Label&amp; target);
 857         void emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target);
 858         void emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target);
 859 
 860         template&lt;typename BinOp, typename JmpOp&gt;
 861         bool fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands = false);
 862 
 863         template&lt;typename UnaryOp, typename JmpOp&gt;
 864         bool fuseTestAndJmp(RegisterID* cond, Label&amp; target);
 865 
 866         void emitEnter();
<a name="29" id="anc29"></a><span class="line-added"> 867         void emitCheckTraps();</span>
 868 
 869         RegisterID* emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 870         RegisterID* emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator);
 871         RegisterID* emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName);
 872         RegisterID* emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base);
 873         RegisterID* emitGetEnumerableLength(RegisterID* dst, RegisterID* base);
 874         RegisterID* emitGetStructurePropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length);
 875         RegisterID* emitGetGenericPropertyEnumerator(RegisterID* dst, RegisterID* base, RegisterID* length, RegisterID* structureEnumerator);
 876         RegisterID* emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 877         RegisterID* emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index);
 878         RegisterID* emitToIndexString(RegisterID* dst, RegisterID* index);
 879 
 880         RegisterID* emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType);
<a name="30" id="anc30"></a><span class="line-added"> 881         RegisterID* emitIsGenerator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSGeneratorType); }</span>
<span class="line-added"> 882         RegisterID* emitIsAsyncGenerator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSAsyncGeneratorType); }</span>
 883         RegisterID* emitIsJSArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ArrayType); }
<a name="31" id="anc31"></a><span class="line-added"> 884         RegisterID* emitIsPromise(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSPromiseType); }</span>
 885         RegisterID* emitIsProxyObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, ProxyObjectType); }
 886         RegisterID* emitIsRegExpObject(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, RegExpObjectType); }
 887         RegisterID* emitIsMap(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSMapType); }
 888         RegisterID* emitIsSet(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSSetType); }
<a name="32" id="anc32"></a><span class="line-added"> 889         RegisterID* emitIsStringIterator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSStringIteratorType); }</span>
<span class="line-added"> 890         RegisterID* emitIsArrayIterator(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, JSArrayIteratorType); }</span>
 891         RegisterID* emitIsObject(RegisterID* dst, RegisterID* src);
 892         RegisterID* emitIsNumber(RegisterID* dst, RegisterID* src);
 893         RegisterID* emitIsUndefined(RegisterID* dst, RegisterID* src);
 894         RegisterID* emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src);
 895         RegisterID* emitIsEmpty(RegisterID* dst, RegisterID* src);
 896         RegisterID* emitIsDerivedArray(RegisterID* dst, RegisterID* src) { return emitIsCellWithType(dst, src, DerivedArrayType); }
 897         void emitRequireObjectCoercible(RegisterID* value, const String&amp; error);
 898 
 899         RegisterID* emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, JSC::EmitAwait = JSC::EmitAwait::No);
 900         RegisterID* emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node);
 901         void emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait = EmitAwait::No);
 902 
 903         RegisterID* emitRestParameter(RegisterID* result, unsigned numParametersToSkip);
 904 
 905         bool emitReadOnlyExceptionIfNeeded(const Variable&amp;);
 906 
 907         // Start a try block. &#39;start&#39; must have been emitted.
 908         TryData* pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType);
 909         // End a try block. &#39;end&#39; must have been emitted.
 910         void popTry(TryData*, Label&amp; end);
 911 
 912         void emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData*);
 913         void emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData*);
 914 
 915     private:
<a name="33" id="anc33"></a><span class="line-modified"> 916         static constexpr int CurrentLexicalScopeIndex = -2;</span>
<span class="line-modified"> 917         static constexpr int OutermostLexicalScopeIndex = -1;</span>
 918 
 919         int currentLexicalScopeIndex() const
 920         {
 921             int size = static_cast&lt;int&gt;(m_lexicalScopeStack.size());
 922             ASSERT(static_cast&lt;size_t&gt;(size) == m_lexicalScopeStack.size());
 923             ASSERT(size &gt;= 0);
 924             if (!size)
 925                 return OutermostLexicalScopeIndex;
 926             return size - 1;
 927         }
 928 
 929         void emitOutOfLineExceptionHandler(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData*);
 930 
 931     public:
 932         void restoreScopeRegister();
 933         void restoreScopeRegister(int lexicalScopeIndex);
 934 
 935         int labelScopeDepthToLexicalScopeIndex(int labelScopeDepth);
 936 
 937         void emitThrow(RegisterID*);
 938         RegisterID* emitArgumentCount(RegisterID*);
 939 
 940         void emitThrowStaticError(ErrorType, RegisterID*);
 941         void emitThrowStaticError(ErrorType, const Identifier&amp; message);
 942         void emitThrowReferenceError(const String&amp; message);
 943         void emitThrowTypeError(const String&amp; message);
 944         void emitThrowTypeError(const Identifier&amp; message);
 945         void emitThrowRangeError(const Identifier&amp; message);
 946         void emitThrowOutOfMemoryError();
 947 
 948         void emitPushCatchScope(VariableEnvironment&amp;);
 949         void emitPopCatchScope(VariableEnvironment&amp;);
 950 
 951         RegisterID* emitGetIterator(RegisterID*, ThrowableExpressionData*);
 952         RegisterID* emitGetAsyncIterator(RegisterID*, ThrowableExpressionData*);
 953 
 954         void emitAwait(RegisterID*);
 955         void emitGetScope();
 956         RegisterID* emitPushWithScope(RegisterID* objectScope);
 957         void emitPopWithScope();
 958         void emitPutThisToArrowFunctionContextScope();
 959         void emitPutNewTargetToArrowFunctionContextScope();
 960         void emitPutDerivedConstructorToArrowFunctionContextScope();
 961         RegisterID* emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
<a name="34" id="anc34"></a><span class="line-added"> 962         RegisterID* emitLoadDerivedConstructor();</span>
 963 
 964         void emitDebugHook(DebugHookType, const JSTextPosition&amp;);
 965         void emitDebugHook(DebugHookType, unsigned line, unsigned charOffset, unsigned lineStart);
 966         void emitDebugHook(StatementNode*);
 967         void emitDebugHook(ExpressionNode*);
 968         void emitWillLeaveCallFrameDebugHook();
 969 
 970         void emitLoad(RegisterID* completionTypeRegister, CompletionType type)
 971         {
 972             emitLoad(completionTypeRegister, JSValue(static_cast&lt;int&gt;(type)));
 973         }
 974 
 975         template&lt;typename CompareOp&gt;
 976         void emitJumpIf(RegisterID* completionTypeRegister, CompletionType, Label&amp; jumpTarget);
 977 
 978         bool emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget);
 979         bool emitReturnViaFinallyIfNeeded(RegisterID* returnRegister);
 980         void emitFinallyCompletion(FinallyContext&amp;, Label&amp; normalCompletionLabel);
 981 
<a name="35" id="anc35"></a><span class="line-added"> 982         template&lt;typename LazyNameRegisterFn&gt;</span>
<span class="line-added"> 983         void emitSetFunctionNameIfNeededImpl(ExpressionNode*, RegisterID*, const LazyNameRegisterFn&amp;);</span>
<span class="line-added"> 984 </span>
 985     public:
 986         void pushFinallyControlFlowScope(FinallyContext&amp;);
 987         void popFinallyControlFlowScope();
 988 
 989         void pushOptionalChainTarget();
 990         void popOptionalChainTarget();
 991         void popOptionalChainTarget(RegisterID* dst, bool isDelete);
 992         void emitOptionalCheck(RegisterID* src);
 993 
 994         void pushIndexedForInScope(RegisterID* local, RegisterID* index);
 995         void popIndexedForInScope(RegisterID* local);
 996         void pushStructureForInScope(RegisterID* local, RegisterID* index, RegisterID* property, RegisterID* enumerator);
 997         void popStructureForInScope(RegisterID* local);
 998 
 999         LabelScope* breakTarget(const Identifier&amp;);
1000         LabelScope* continueTarget(const Identifier&amp;);
1001 
1002         void beginSwitch(RegisterID*, SwitchInfo::SwitchType);
1003         void endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp;, ExpressionNode**, Label&amp; defaultLabel, int32_t min, int32_t range);
1004 
<a name="36" id="anc36"></a><span class="line-modified">1005         void emitYieldPoint(RegisterID*, JSAsyncGenerator::AsyncGeneratorSuspendReason);</span>
1006 
1007         void emitGeneratorStateLabel();
1008         void emitGeneratorStateChange(int32_t state);
<a name="37" id="anc37"></a><span class="line-modified">1009         RegisterID* emitYield(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason = JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
1010         RegisterID* emitDelegateYield(RegisterID* argument, ThrowableExpressionData*);
<a name="38" id="anc38"></a><span class="line-modified">1011         RegisterID* generatorStateRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::State)]; }</span>
<span class="line-modified">1012         RegisterID* generatorValueRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::Value)]; }</span>
<span class="line-modified">1013         RegisterID* generatorResumeModeRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::ResumeMode)]; }</span>
<span class="line-modified">1014         RegisterID* generatorFrameRegister() { return &amp;m_parameters[static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::Frame)]; }</span>
1015 
1016         CodeType codeType() const { return m_codeType; }
1017 
1018         bool shouldBeConcernedWithCompletionValue() const { return m_codeType != FunctionCode; }
1019 
1020         bool shouldEmitDebugHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger) &amp;&amp; !m_isBuiltinFunction; }
1021         bool shouldEmitTypeProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }
1022         bool shouldEmitControlFlowProfilerHooks() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }
1023 
1024         bool isStrictMode() const { return m_codeBlock-&gt;isStrictMode(); }
<a name="39" id="anc39"></a><span class="line-added">1025         void setUsesCheckpoints() { m_codeBlock-&gt;setHasCheckpoints(); }</span>
1026 
1027         SourceParseMode parseMode() const { return m_codeBlock-&gt;parseMode(); }
1028 
1029         bool isBuiltinFunction() const { return m_isBuiltinFunction; }
1030 
1031         OpcodeID lastOpcodeID() const { return m_lastOpcodeID; }
1032 
1033         bool isDerivedConstructorContext() { return m_derivedContextType == DerivedContextType::DerivedConstructorContext; }
1034         bool isDerivedClassContext() { return m_derivedContextType == DerivedContextType::DerivedMethodContext; }
1035         bool isArrowFunction() { return m_codeBlock-&gt;isArrowFunction(); }
1036 
1037         enum class TDZCheckOptimization { Optimize, DoNotOptimize };
1038         enum class NestedScopeType { IsNested, IsNotNested };
1039     private:
1040         enum class TDZRequirement { UnderTDZ, NotUnderTDZ };
1041         enum class ScopeType { CatchScope, LetConstScope, FunctionNameScope };
1042         enum class ScopeRegisterType { Var, Block };
1043         void pushLexicalScopeInternal(VariableEnvironment&amp;, TDZCheckOptimization, NestedScopeType, RegisterID** constantSymbolTableResult, TDZRequirement, ScopeType, ScopeRegisterType);
1044         void initializeBlockScopedFunctions(VariableEnvironment&amp;, FunctionStack&amp;, RegisterID* constantSymbolTable);
1045         void popLexicalScopeInternal(VariableEnvironment&amp;);
1046         template&lt;typename LookUpVarKindFunctor&gt;
1047         bool instantiateLexicalVariables(const VariableEnvironment&amp;, SymbolTable*, ScopeRegisterType, LookUpVarKindFunctor);
1048         void emitPrefillStackTDZVariables(const VariableEnvironment&amp;, SymbolTable*);
<a name="40" id="anc40"></a>
1049         RegisterID* emitGetParentScope(RegisterID* dst, RegisterID* scope);
1050         void emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* value, bool isCaptured);
1051         void emitNewFunctionExpressionCommon(RegisterID*, FunctionMetadataNode*);
1052 
1053         bool isNewTargetUsedInInnerArrowFunction();
1054         bool isArgumentsUsedInInnerArrowFunction();
1055 
1056         void emitToThis();
1057 
1058         RegisterID* emitMove(RegisterID* dst, RegisterID* src);
1059 
1060         bool canDoPeepholeOptimization() const { return m_lastOpcodeID != op_end; }
1061 
1062     public:
1063         bool isSuperUsedInInnerArrowFunction();
1064         bool isSuperCallUsedInInnerArrowFunction();
1065         bool isThisUsedInInnerArrowFunction();
1066         void pushLexicalScope(VariableEnvironmentNode*, TDZCheckOptimization, NestedScopeType = NestedScopeType::IsNotNested, RegisterID** constantSymbolTableResult = nullptr, bool shouldInitializeBlockScopedFunctions = true);
1067         void popLexicalScope(VariableEnvironmentNode*);
1068         void prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode*, RegisterID* loopSymbolTable);
1069         int labelScopeDepth() const;
1070         UnlinkedArrayProfile newArrayProfile();
1071 
1072     private:
1073         ParserError generate();
<a name="41" id="anc41"></a>
1074         Variable variableForLocalEntry(const Identifier&amp;, const SymbolTableEntry&amp;, int symbolTableConstantIndex, bool isLexicallyScoped);
1075 
1076         RegisterID* kill(RegisterID* dst)
1077         {
1078             m_staticPropertyAnalyzer.kill(dst);
1079             return dst;
1080         }
1081 
1082         void retrieveLastUnaryOp(int&amp; dstIndex, int&amp; srcIndex);
1083         ALWAYS_INLINE void rewind();
1084 
<a name="42" id="anc42"></a>
1085         void allocateAndEmitScope();
1086 
1087         template&lt;typename JumpOp&gt;
1088         void setTargetForJumpInstruction(InstructionStream::MutableRef&amp;, int target);
1089 
1090         using BigIntMapEntry = std::tuple&lt;UniquedStringImpl*, uint8_t, bool&gt;;
1091 
1092         using NumberMap = HashMap&lt;double, JSValue&gt;;
1093         using IdentifierStringMap = HashMap&lt;UniquedStringImpl*, JSString*, IdentifierRepHash&gt;;
1094         using IdentifierBigIntMap = HashMap&lt;BigIntMapEntry, JSBigInt*&gt;;
1095         using TemplateObjectDescriptorSet = HashSet&lt;Ref&lt;TemplateObjectDescriptor&gt;&gt;;
1096         using TemplateDescriptorMap = HashMap&lt;uint64_t, JSTemplateObjectDescriptor*, WTF::IntHash&lt;uint64_t&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;uint64_t&gt;&gt;;
1097 
1098         // Helper for emitCall() and emitConstruct(). This works because the set of
1099         // expected functions have identical behavior for both call and construct
1100         // (i.e. &quot;Object()&quot; is identical to &quot;new Object()&quot;).
1101         ExpectedFunction emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, Label&amp; done);
1102 
1103         template&lt;typename CallOp&gt;
1104         RegisterID* emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction, CallArguments&amp;, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1105 
1106         RegisterID* emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData*);
<a name="43" id="anc43"></a>










1107 
1108         // Initializes the stack form the parameter; does nothing for the symbol table.
1109         RegisterID* initializeNextParameter();
1110         UniquedStringImpl* visibleNameForParameter(DestructuringPatternNode*);
1111 
1112         RegisterID&amp; registerFor(VirtualRegister reg)
1113         {
1114             if (reg.isLocal())
1115                 return m_calleeLocals[reg.toLocal()];
1116 
1117             if (reg.offset() == CallFrameSlot::callee)
1118                 return m_calleeRegister;
1119 
1120             ASSERT(m_parameters.size());
1121             return m_parameters[reg.toArgument()];
1122         }
1123 
1124         bool hasConstant(const Identifier&amp;) const;
1125         unsigned addConstant(const Identifier&amp;);
1126         RegisterID* addConstantValue(JSValue, SourceCodeRepresentation = SourceCodeRepresentation::Other);
1127         RegisterID* addConstantEmptyValue();
1128 
1129         UnlinkedFunctionExecutable* makeFunction(FunctionMetadataNode* metadata)
1130         {
1131             DerivedContextType newDerivedContextType = DerivedContextType::None;
1132 
<a name="44" id="anc44"></a><span class="line-added">1133             NeedsClassFieldInitializer needsClassFieldInitializer = metadata-&gt;isConstructorAndNeedsClassFieldInitializer() ? NeedsClassFieldInitializer::Yes : NeedsClassFieldInitializer::No;</span>
1134             if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::AsyncArrowFunctionBodyMode).contains(metadata-&gt;parseMode())) {
<a name="45" id="anc45"></a><span class="line-modified">1135                 if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {</span>
1136                     newDerivedContextType = DerivedContextType::DerivedConstructorContext;
<a name="46" id="anc46"></a><span class="line-added">1137                     needsClassFieldInitializer = m_codeBlock-&gt;needsClassFieldInitializer();</span>
<span class="line-added">1138                 }</span>
1139                 else if (m_codeBlock-&gt;isClassContext() || isDerivedClassContext())
1140                     newDerivedContextType = DerivedContextType::DerivedMethodContext;
1141             }
1142 
1143             Optional&lt;CompactVariableMap::Handle&gt; optionalVariablesUnderTDZ = getVariablesUnderTDZ();
1144 
1145             // FIXME: These flags, ParserModes and propagation to XXXCodeBlocks should be reorganized.
1146             // https://bugs.webkit.org/show_bug.cgi?id=151547
1147             SourceParseMode parseMode = metadata-&gt;parseMode();
1148             ConstructAbility constructAbility = constructAbilityForParseMode(parseMode);
1149             if (parseMode == SourceParseMode::MethodMode &amp;&amp; metadata-&gt;constructorKind() != ConstructorKind::None)
1150                 constructAbility = ConstructAbility::CanConstruct;
1151 
<a name="47" id="anc47"></a><span class="line-modified">1152             return UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(optionalVariablesUnderTDZ), newDerivedContextType, needsClassFieldInitializer);</span>
1153         }
1154 
1155         Optional&lt;CompactVariableMap::Handle&gt; getVariablesUnderTDZ();
1156 
1157         RegisterID* emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1158         template&lt;typename CallOp&gt;
1159         RegisterID* emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall);
1160 
1161         void emitLogShadowChickenPrologueIfNecessary();
1162         void emitLogShadowChickenTailIfNecessary();
1163 
1164         void initializeParameters(FunctionParameters&amp;);
1165         void initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables);
1166         void initializeDefaultParameterValuesAndSetupFunctionScopeStack(FunctionParameters&amp;, bool isSimpleParameterList, FunctionNode*, SymbolTable*, int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope);
1167         void initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable = nullptr, bool canReuseLexicalEnvironment = false);
1168         bool needsDerivedConstructorInArrowFunctionLexicalEnvironment();
1169 
1170         enum class TDZNecessityLevel {
1171             NotNeeded,
1172             Optimize,
1173             DoNotOptimize
1174         };
1175         typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, TDZNecessityLevel, IdentifierRepHash&gt; TDZMap;
1176 
1177     public:
1178         JSString* addStringConstant(const Identifier&amp;);
1179         JSValue addBigIntConstant(const Identifier&amp;, uint8_t radix, bool sign);
1180         RegisterID* addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp;, int);
1181 
1182         const InstructionStream&amp; instructions() const { return m_writer; }
1183 
1184         RegisterID* emitThrowExpressionTooDeepException();
1185 
<a name="48" id="anc48"></a>








1186         class PreservedTDZStack {
1187         private:
1188             Vector&lt;TDZMap&gt; m_preservedTDZStack;
1189             friend class BytecodeGenerator;
1190         };
1191 
1192         void preserveTDZStack(PreservedTDZStack&amp;);
1193         void restoreTDZStack(const PreservedTDZStack&amp;);
1194 
1195         template&lt;typename Func&gt;
1196         void withWriter(InstructionStreamWriter&amp; writer, const Func&amp; fn)
1197         {
1198             auto prevLastOpcodeID = m_lastOpcodeID;
1199             auto prevLastInstruction = m_lastInstruction;
1200             m_writer.swap(writer);
1201             m_lastOpcodeID = op_end;
1202             m_lastInstruction = m_writer.ref();
1203             fn();
1204             m_writer.swap(writer);
1205             m_lastOpcodeID = prevLastOpcodeID;
1206             m_lastInstruction = prevLastInstruction;
1207         }
1208 
1209     private:
<a name="49" id="anc49"></a>

1210         OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
1211 
1212         struct LexicalScopeStackEntry {
1213             SymbolTable* m_symbolTable;
1214             RegisterID* m_scope;
1215             bool m_isWithScope;
1216             int m_symbolTableConstantIndex;
1217         };
1218         Vector&lt;LexicalScopeStackEntry&gt; m_lexicalScopeStack;
1219 
1220         Vector&lt;TDZMap&gt; m_TDZStack;
1221         Optional&lt;size_t&gt; m_varScopeLexicalScopeStackIndex;
1222         void pushTDZVariables(const VariableEnvironment&amp;, TDZCheckOptimization, TDZRequirement);
1223 
1224         ScopeNode* const m_scopeNode;
<a name="50" id="anc50"></a>
1225 
1226         // Some of these objects keep pointers to one another. They are arranged
1227         // to ensure a sane destruction order that avoids references to freed memory.
1228         HashSet&lt;RefPtr&lt;UniquedStringImpl&gt;, IdentifierRepHash&gt; m_functions;
1229         RegisterID m_ignoredResultRegister;
1230         RegisterID m_thisRegister;
1231         RegisterID m_calleeRegister;
1232         RegisterID* m_scopeRegister { nullptr };
1233         RegisterID* m_topMostScope { nullptr };
1234         RegisterID* m_argumentsRegister { nullptr };
1235         RegisterID* m_lexicalEnvironmentRegister { nullptr };
1236         RegisterID* m_generatorRegister { nullptr };
1237         RegisterID* m_emptyValueRegister { nullptr };
1238         RegisterID* m_newTargetRegister { nullptr };
1239         RegisterID* m_isDerivedConstuctor { nullptr };
<a name="51" id="anc51"></a><span class="line-modified">1240         HashMap&lt;LinkTimeConstant, RegisterID*, WTF::IntHash&lt;LinkTimeConstant&gt;, WTF::StrongEnumHashTraits&lt;LinkTimeConstant&gt;&gt; m_linkTimeConstantRegisters;</span>
1241         RegisterID* m_arrowFunctionContextLexicalEnvironmentRegister { nullptr };
<a name="52" id="anc52"></a><span class="line-modified">1242         RegisterID* m_promiseRegister { nullptr };</span>
1243 
1244         FinallyContext* m_currentFinallyContext { nullptr };
1245 
<a name="53" id="anc53"></a>


1246         SegmentedVector&lt;RegisterID, 32&gt; m_parameters;
<a name="54" id="anc54"></a>
1247         SegmentedVector&lt;LabelScope, 32&gt; m_labelScopes;
<a name="55" id="anc55"></a><span class="line-added">1248         SegmentedVector&lt;RegisterID, 32&gt; m_constantPoolRegisters;</span>
1249         unsigned m_finallyDepth { 0 };
1250         unsigned m_localScopeDepth { 0 };
1251         const CodeType m_codeType;
1252 
1253         unsigned localScopeDepth() const;
1254         void pushLocalControlFlowScope();
1255         void popLocalControlFlowScope();
1256 
1257         // FIXME: Restore overflow checking with UnsafeVectorOverflow once SegmentVector supports it.
1258         // https://bugs.webkit.org/show_bug.cgi?id=165980
1259         SegmentedVector&lt;ControlFlowScope, 16&gt; m_controlFlowScopeStack;
1260         Vector&lt;SwitchInfo&gt; m_switchContextStack;
1261         Vector&lt;Ref&lt;ForInContext&gt;&gt; m_forInContextStack;
1262         Vector&lt;TryContext&gt; m_tryContextStack;
1263         unsigned m_yieldPoints { 0 };
1264 
1265         Strong&lt;SymbolTable&gt; m_generatorFrameSymbolTable;
1266         int m_generatorFrameSymbolTableIndex { 0 };
1267 
1268         enum FunctionVariableType : uint8_t { NormalFunctionVariable, TopLevelFunctionVariable };
1269         Vector&lt;std::pair&lt;FunctionMetadataNode*, FunctionVariableType&gt;&gt; m_functionsToInitialize;
1270         bool m_needToInitializeArguments { false };
1271         RestParameterNode* m_restParameter { nullptr };
1272 
1273         Vector&lt;TryRange&gt; m_tryRanges;
1274         SegmentedVector&lt;TryData, 8&gt; m_tryData;
1275 
1276         Vector&lt;Ref&lt;Label&gt;&gt; m_optionalChainTargetStack;
1277 
1278         int m_nextConstantOffset { 0 };
1279 
1280         typedef HashMap&lt;FunctionMetadataNode*, unsigned&gt; FunctionOffsetMap;
1281         FunctionOffsetMap m_functionOffsets;
1282 
1283         // Constant pool
1284         IdentifierMap m_identifierMap;
1285 
1286         typedef HashMap&lt;EncodedJSValueWithRepresentation, unsigned, EncodedJSValueWithRepresentationHash, EncodedJSValueWithRepresentationHashTraits&gt; JSValueMap;
1287         JSValueMap m_jsValueMap;
1288         IdentifierStringMap m_stringMap;
1289         IdentifierBigIntMap m_bigIntMap;
1290         TemplateObjectDescriptorSet m_templateObjectDescriptorSet;
1291         TemplateDescriptorMap m_templateDescriptorMap;
1292 
1293         StaticPropertyAnalyzer m_staticPropertyAnalyzer;
1294 
1295         VM&amp; m_vm;
1296 
<a name="56" id="anc56"></a>


1297         bool m_usesExceptions { false };
1298         bool m_expressionTooDeep { false };
1299         bool m_isBuiltinFunction { false };
1300         bool m_usesNonStrictEval { false };
1301         bool m_inTailPosition { false };
1302         bool m_needsToUpdateArrowFunctionContext;
1303         bool m_hasCachedVariablesUnderTDZ { false };
1304         DerivedContextType m_derivedContextType { DerivedContextType::None };
1305 
1306         CompactVariableMap::Handle m_cachedVariablesUnderTDZ;
1307 
1308         struct CatchEntry {
1309             TryData* tryData;
1310             VirtualRegister exceptionRegister;
1311             VirtualRegister thrownValueRegister;
1312             VirtualRegister completionTypeRegister;
1313         };
1314         Vector&lt;CatchEntry&gt; m_exceptionHandlersToEmit;
1315     };
1316 
1317 } // namespace JSC
1318 
1319 namespace WTF {
1320 
1321 void printInternal(PrintStream&amp;, JSC::Variable::VariableKind);
1322 
1323 } // namespace WTF
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="57" type="hidden" />
</body>
</html>
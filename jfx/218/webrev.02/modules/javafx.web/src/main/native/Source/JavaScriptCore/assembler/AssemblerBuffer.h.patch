diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBuffer.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBuffer.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBuffer.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBuffer.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2008, 2012, 2014 Apple Inc. All rights reserved.
+ * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -41,10 +41,12 @@
 
 namespace JSC {
 
     class LinkBuffer;
 
+    DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AssemblerData);
+
     struct AssemblerLabel {
         AssemblerLabel()
             : m_offset(std::numeric_limits<uint32_t>::max())
         {
         }
@@ -66,11 +68,11 @@
         uint32_t m_offset;
     };
 
     class AssemblerData {
         WTF_MAKE_NONCOPYABLE(AssemblerData);
-        static const size_t InlineCapacity = 128;
+        static constexpr size_t InlineCapacity = 128;
     public:
         AssemblerData()
             : m_buffer(m_inlineBuffer)
             , m_capacity(InlineCapacity)
         {
@@ -81,11 +83,11 @@
             if (initialCapacity <= InlineCapacity) {
                 m_capacity = InlineCapacity;
                 m_buffer = m_inlineBuffer;
             } else {
                 m_capacity = initialCapacity;
-                m_buffer = static_cast<char*>(fastMalloc(m_capacity));
+                m_buffer = static_cast<char*>(AssemblerDataMalloc::malloc(m_capacity));
             }
         }
 
         AssemblerData(AssemblerData&& other)
         {
@@ -102,11 +104,11 @@
         }
 
         AssemblerData& operator=(AssemblerData&& other)
         {
             if (m_buffer && !isInlineBuffer())
-                fastFree(m_buffer);
+                AssemblerDataMalloc::free(m_buffer);
 
             if (other.isInlineBuffer()) {
                 ASSERT(other.m_capacity == InlineCapacity);
                 memcpy(m_inlineBuffer, other.m_inlineBuffer, InlineCapacity);
                 m_buffer = m_inlineBuffer;
@@ -120,25 +122,25 @@
         }
 
         ~AssemblerData()
         {
             if (m_buffer && !isInlineBuffer())
-                fastFree(m_buffer);
+                AssemblerDataMalloc::free(m_buffer);
         }
 
         char* buffer() const { return m_buffer; }
 
         unsigned capacity() const { return m_capacity; }
 
         void grow(unsigned extraCapacity = 0)
         {
             m_capacity = m_capacity + m_capacity / 2 + extraCapacity;
             if (isInlineBuffer()) {
-                m_buffer = static_cast<char*>(fastMalloc(m_capacity));
+                m_buffer = static_cast<char*>(AssemblerDataMalloc::malloc(m_capacity));
                 memcpy(m_buffer, m_inlineBuffer, InlineCapacity);
             } else
-                m_buffer = static_cast<char*>(fastRealloc(m_buffer, m_capacity));
+                m_buffer = static_cast<char*>(AssemblerDataMalloc::realloc(m_buffer, m_capacity));
         }
 
     private:
         bool isInlineBuffer() const { return m_buffer == m_inlineBuffer; }
         char* m_buffer;
@@ -243,11 +245,11 @@
                 : m_buffer(buffer)
             {
                 buffer.ensureSpace(requiredSpace);
                 m_storageBuffer = buffer.m_storage.buffer();
                 m_index = buffer.m_index;
-#if !defined(NDEBUG)
+#if ASSERT_ENABLED
                 m_initialIndex = m_index;
                 m_requiredSpace = requiredSpace;
 #endif
             }
 
@@ -272,11 +274,11 @@
                 m_index += sizeof(IntegralType);
             }
             AssemblerBuffer& m_buffer;
             char* m_storageBuffer;
             unsigned m_index;
-#if !defined(NDEBUG)
+#if ASSERT_ENABLED
             unsigned m_initialIndex;
             unsigned m_requiredSpace;
 #endif
         };
 #endif // !CPU(ARM64)

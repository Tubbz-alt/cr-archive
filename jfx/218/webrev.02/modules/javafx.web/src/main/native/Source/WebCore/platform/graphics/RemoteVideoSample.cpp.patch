diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/RemoteVideoSample.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/RemoteVideoSample.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/RemoteVideoSample.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/RemoteVideoSample.cpp
@@ -26,13 +26,18 @@
 #include "config.h"
 #include "RemoteVideoSample.h"
 
 #if ENABLE(MEDIA_STREAM) && PLATFORM(COCOA)
 
+#include "IOSurface.h"
 #include "Logging.h"
 #include "MediaSample.h"
 
+#if USE(ACCELERATE)
+#include <Accelerate/Accelerate.h>
+#endif
+
 #if HAVE(IOSURFACE)
 #include "GraphicsContextCG.h"
 #endif
 
 #include <pal/cf/CoreMediaSoftLink.h>
@@ -40,27 +45,92 @@
 
 namespace WebCore {
 using namespace PAL;
 
 #if HAVE(IOSURFACE)
-std::unique_ptr<RemoteVideoSample> RemoteVideoSample::create(MediaSample&& sample)
+static inline std::unique_ptr<IOSurface> transferBGRAPixelBufferToIOSurface(CVPixelBufferRef pixelBuffer)
+{
+#if USE(ACCELERATE)
+    ASSERT(CVPixelBufferGetPixelFormatType(pixelBuffer) == kCVPixelFormatType_32BGRA);
+
+    auto result = CVPixelBufferLockBaseAddress(pixelBuffer, kCVPixelBufferLock_ReadOnly);
+    ASSERT(result == kCVReturnSuccess);
+    if (result != kCVReturnSuccess) {
+        RELEASE_LOG_ERROR(Media, "transferBGRAPixelBufferToIOSurface CVPixelBufferLockBaseAddress() returned error code %d", result);
+        return nullptr;
+    }
+
+    IntSize size { static_cast<int>(CVPixelBufferGetWidth(pixelBuffer)), static_cast<int>(CVPixelBufferGetHeight(pixelBuffer)) };
+    auto ioSurface =  IOSurface::create(size, sRGBColorSpaceRef(), IOSurface::Format::RGBA);
+
+    IOSurface::Locker lock(*ioSurface);
+    vImage_Buffer src;
+    src.width = size.width();
+    src.height = size.height();
+    src.rowBytes = CVPixelBufferGetBytesPerRow(pixelBuffer);
+    src.data = CVPixelBufferGetBaseAddress(pixelBuffer);
+
+    vImage_Buffer dest;
+    dest.width = size.width();
+    dest.height = size.height();
+    dest.rowBytes = ioSurface->bytesPerRow();
+    dest.data = lock.surfaceBaseAddress();
+
+    vImageUnpremultiplyData_BGRA8888(&src, &dest, kvImageNoFlags);
+
+    result = CVPixelBufferUnlockBaseAddress(pixelBuffer, kCVPixelBufferLock_ReadOnly);
+    ASSERT(result == kCVReturnSuccess);
+    if (result != kCVReturnSuccess) {
+        RELEASE_LOG_ERROR(Media, "transferBGRAPixelBufferToIOSurface CVPixelBufferUnlockBaseAddress() returned error code %d", result);
+        return nullptr;
+    }
+    return ioSurface;
+#else
+    RELEASE_LOG_ERROR(Media, "transferBGRAPixelBufferToIOSurface cannot convert to IOSurface");
+    return nullptr;
+#endif
+}
+
+std::unique_ptr<RemoteVideoSample> RemoteVideoSample::create(MediaSample& sample)
 {
     ASSERT(sample.platformSample().type == PlatformSample::CMSampleBufferType);
 
     auto imageBuffer = CMSampleBufferGetImageBuffer(sample.platformSample().sample.cmSampleBuffer);
     if (!imageBuffer) {
         RELEASE_LOG_ERROR(Media, "RemoteVideoSample::create: CMSampleBufferGetImageBuffer returned nullptr");
         return nullptr;
     }
 
+    std::unique_ptr<IOSurface> ioSurface;
+    auto surface = CVPixelBufferGetIOSurface(imageBuffer);
+    if (!surface) {
+        // Special case for canvas data that is RGBA, not IOSurface backed.
+        auto pixelFormatType = CVPixelBufferGetPixelFormatType(imageBuffer);
+        if (pixelFormatType != kCVPixelFormatType_32BGRA) {
+            RELEASE_LOG_ERROR(Media, "RemoteVideoSample::create does not support non IOSurface backed samples that are not BGRA");
+            return nullptr;
+        }
+
+        ioSurface = transferBGRAPixelBufferToIOSurface(imageBuffer);
+        if (!ioSurface)
+            return nullptr;
+
+        surface = ioSurface->surface();
+    }
+
+    return std::unique_ptr<RemoteVideoSample>(new RemoteVideoSample(surface, sRGBColorSpaceRef(), sample.presentationTime(), sample.videoRotation(), sample.videoMirrored()));
+}
+
+std::unique_ptr<RemoteVideoSample> RemoteVideoSample::create(CVPixelBufferRef imageBuffer, MediaTime&& presentationTime, MediaSample::VideoRotation rotation)
+{
     auto surface = CVPixelBufferGetIOSurface(imageBuffer);
     if (!surface) {
         RELEASE_LOG_ERROR(Media, "RemoteVideoSample::create: CVPixelBufferGetIOSurface returned nullptr");
         return nullptr;
     }
 
-    return std::unique_ptr<RemoteVideoSample>(new RemoteVideoSample(surface, sRGBColorSpaceRef(), sample.presentationTime(), sample.videoRotation(), sample.videoMirrored()));
+    return std::unique_ptr<RemoteVideoSample>(new RemoteVideoSample(surface, sRGBColorSpaceRef(), WTFMove(presentationTime), rotation, false));
 }
 
 RemoteVideoSample::RemoteVideoSample(IOSurfaceRef surface, CGColorSpaceRef colorSpace, MediaTime&& time, MediaSample::VideoRotation rotation, bool mirrored)
     : m_ioSurface(WebCore::IOSurface::createFromSurface(surface, colorSpace))
     , m_rotation(rotation)
@@ -80,6 +150,6 @@
 }
 #endif
 
 }
 
-#endif // ENABLE(MEDIA_STREAM)
+#endif // ENABLE(MEDIA_STREAM) && PLATFORM(COCOA)

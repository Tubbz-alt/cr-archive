diff a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLVideoElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLVideoElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLVideoElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLVideoElement.cpp
@@ -37,10 +37,11 @@
 #include "HTMLImageLoader.h"
 #include "HTMLNames.h"
 #include "HTMLParserIdioms.h"
 #include "Logging.h"
 #include "Page.h"
+#include "PictureInPictureSupport.h"
 #include "RenderImage.h"
 #include "RenderVideo.h"
 #include "ScriptController.h"
 #include "Settings.h"
 #include <wtf/IsoMallocInlines.h>
@@ -48,10 +49,15 @@
 
 #if ENABLE(VIDEO_PRESENTATION_MODE)
 #include "VideoFullscreenModel.h"
 #endif
 
+#if ENABLE(PICTURE_IN_PICTURE_API)
+#include "HTMLVideoElementPictureInPicture.h"
+#include "PictureInPictureObserver.h"
+#endif
+
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLVideoElement);
 
 using namespace HTMLNames;
@@ -65,10 +71,15 @@
 }
 
 Ref<HTMLVideoElement> HTMLVideoElement::create(const QualifiedName& tagName, Document& document, bool createdByParser)
 {
     auto videoElement = adoptRef(*new HTMLVideoElement(tagName, document, createdByParser));
+
+#if ENABLE(PICTURE_IN_PICTURE_API)
+    HTMLVideoElementPictureInPicture::providePictureInPictureTo(videoElement);
+#endif
+
     videoElement->finishInitialization();
     videoElement->suspendIfNeeded();
     return videoElement;
 }
 
@@ -257,20 +268,10 @@
     } else if (oldMode != Video && player())
         player()->prepareForRendering();
 
     HTMLMediaElement::setDisplayMode(mode);
 
-    if (player() && player()->canLoadPoster()) {
-        bool canLoad = true;
-        if (!poster.isEmpty()) {
-            if (RefPtr<Frame> frame = document().frame())
-                canLoad = frame->loader().willLoadMediaElementURL(poster, *this);
-        }
-        if (canLoad)
-            player()->setPoster(poster);
-    }
-
     if (auto* renderer = this->renderer()) {
         if (displayMode() != oldMode)
             renderer->updateFromElement();
     }
 }
@@ -291,11 +292,11 @@
 
     player->setVisible(true); // Make player visible or it won't draw.
     player->paintCurrentFrameInContext(context, destRect);
 }
 
-bool HTMLVideoElement::copyVideoTextureToPlatformTexture(GraphicsContext3D* context, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)
+bool HTMLVideoElement::copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL* context, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)
 {
     if (!player())
         return false;
     return player()->copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
 }
@@ -411,14 +412,12 @@
 {
     if (mode == VideoPresentationMode::Fullscreen)
         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModeStandard);
 
     if (mode == VideoPresentationMode::PictureInPicture) {
-#if PLATFORM(COCOA)
         if (!supportsPictureInPicture())
             return false;
-#endif
 
         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModePictureInPicture);
     }
 
     if (mode == VideoPresentationMode::Inline)
@@ -441,18 +440,37 @@
     return HTMLMediaElementEnums::VideoFullscreenModeNone;
 }
 
 void HTMLVideoElement::webkitSetPresentationMode(VideoPresentationMode mode)
 {
-    ALWAYS_LOG(LOGIDENTIFIER, mode);
+    INFO_LOG(LOGIDENTIFIER, ", mode = ",  mode);
     setFullscreenMode(toFullscreenMode(mode));
 }
 
 void HTMLVideoElement::setFullscreenMode(HTMLMediaElementEnums::VideoFullscreenMode mode)
 {
-    if (mode == VideoFullscreenModeNone && isFullscreen()) {
-        exitFullscreen();
+    INFO_LOG(LOGIDENTIFIER, ", mode = ", mode);
+#if ENABLE(PICTURE_IN_PICTURE_API)
+    if (m_pictureInPictureAPITestEnabled) {
+        if (mode == VideoFullscreenModePictureInPicture) {
+            fullscreenModeChanged(mode);
+            didBecomeFullscreenElement();
+            setVideoFullscreenFrame({0, 0, 100, 100});
+            return;
+        }
+
+        if (mode == VideoFullscreenModeNone) {
+            fullscreenModeChanged(mode);
+            return;
+        }
+    }
+#endif
+
+    if (mode == VideoFullscreenModeNone) {
+        if (isFullscreen())
+            exitFullscreen();
+
         return;
     }
 
     if (!mediaSession().fullscreenPermitted() || !supportsFullscreen(mode))
         return;
@@ -481,20 +499,79 @@
 }
 
 void HTMLVideoElement::fullscreenModeChanged(VideoFullscreenMode mode)
 {
     if (mode != fullscreenMode()) {
-        ALWAYS_LOG(LOGIDENTIFIER, "changed from ", fullscreenMode(), ", to ", mode);
+        INFO_LOG(LOGIDENTIFIER, "changed from ", fullscreenMode(), ", to ", mode);
         scheduleEvent(eventNames().webkitpresentationmodechangedEvent);
+
+#if ENABLE(PICTURE_IN_PICTURE_API)
+        if (m_pictureInPictureObserver) {
+            HTMLVideoElement::VideoPresentationMode targetVideoPresentationMode = toPresentationMode(mode);
+            HTMLVideoElement::VideoPresentationMode sourceVideoPresentationMode = toPresentationMode(fullscreenMode());
+
+            if (targetVideoPresentationMode != HTMLVideoElement::VideoPresentationMode::PictureInPicture && sourceVideoPresentationMode == HTMLVideoElement::VideoPresentationMode::PictureInPicture) {
+                m_pictureInPictureObserver->didExitPictureInPicture();
+                m_isFullscreen = false;
+            }
+        }
+#endif
     }
 
     if (player())
         player()->setVideoFullscreenMode(mode);
 
     HTMLMediaElement::fullscreenModeChanged(mode);
 }
 
+#if ENABLE(PICTURE_IN_PICTURE_API)
+void HTMLVideoElement::didBecomeFullscreenElement()
+{
+    m_isFullscreen = true;
+    m_waitingForPictureInPictureWindowFrame = true;
+    HTMLMediaElement::didBecomeFullscreenElement();
+}
+
+void HTMLVideoElement::setPictureInPictureObserver(PictureInPictureObserver* observer)
+{
+    m_pictureInPictureObserver = observer;
+}
+
+void HTMLVideoElement::setPictureInPictureAPITestEnabled(bool enabled)
+{
+    m_pictureInPictureAPITestEnabled = enabled;
+}
+#endif
+
+#endif
+
+#if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) && ENABLE(VIDEO_PRESENTATION_MODE))
+void HTMLVideoElement::setVideoFullscreenFrame(FloatRect frame)
+{
+    HTMLMediaElement::setVideoFullscreenFrame(frame);
+
+#if ENABLE(PICTURE_IN_PICTURE_API)
+    // fullscreenMode() does not always provide the correct fullscreen mode
+    // when mode changing is happening (webkit.org/b/203443)
+    if (!m_isFullscreen)
+        return;
+
+    if (toPresentationMode(fullscreenMode()) != VideoPresentationMode::PictureInPicture)
+        return;
+
+    if (m_waitingForPictureInPictureWindowFrame) {
+        m_waitingForPictureInPictureWindowFrame = false;
+        if (m_pictureInPictureObserver)
+            m_pictureInPictureObserver->didEnterPictureInPicture(IntSize(frame.size()));
+
+        return;
+    }
+
+    if (m_pictureInPictureObserver)
+        m_pictureInPictureObserver->pictureInPictureWindowResized(IntSize(frame.size()));
+#endif
+}
 #endif
 
 #if PLATFORM(MAC) && ENABLE(VIDEO_PRESENTATION_MODE)
 void HTMLVideoElement::exitToFullscreenModeWithoutAnimationIfPossible(HTMLMediaElementEnums::VideoFullscreenMode fromMode, HTMLMediaElementEnums::VideoFullscreenMode toMode)
 {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedResource.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceClient.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 #include &lt;wtf/Vector.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 class CachedResourceClient;
 45 class CachedResourceHandleBase;
 46 class CachedResourceLoader;
 47 class CachedResourceRequest;
 48 class CookieJar;
 49 class LoadTiming;
 50 class MemoryCache;
 51 class SecurityOrigin;
 52 class SharedBuffer;
 53 class SubresourceLoader;
 54 class TextResourceDecoder;
 55 
 56 // A resource that is held in the cache. Classes who want to use this object should derive
 57 // from CachedResourceClient, to get the function calls in case the requested data has arrived.
 58 // This class also does the actual communication with the loader to obtain the resource from the network.

 59 class CachedResource {
<span class="line-modified"> 60     WTF_MAKE_NONCOPYABLE(CachedResource); WTF_MAKE_FAST_ALLOCATED;</span>

 61     friend class MemoryCache;
 62 
 63 public:
 64     enum class Type : uint8_t {
 65         MainResource,
 66         ImageResource,
 67         CSSStyleSheet,
 68         Script,
 69         FontResource,
 70 #if ENABLE(SVG_FONTS)
 71         SVGFontResource,
 72 #endif
 73         MediaResource,
 74         RawResource,
 75         Icon,
 76         Beacon,
 77         Ping,
<span class="line-removed"> 78         SVGDocumentResource</span>
 79 #if ENABLE(XSLT)
<span class="line-modified"> 80         , XSLStyleSheet</span>
 81 #endif
<span class="line-modified"> 82         , LinkPrefetch</span>
 83 #if ENABLE(VIDEO_TRACK)
<span class="line-modified"> 84         , TextTrackResource</span>
 85 #endif
 86 #if ENABLE(APPLICATION_MANIFEST)
<span class="line-modified"> 87         , ApplicationManifest</span>
 88 #endif


 89     };


 90 
<span class="line-modified"> 91     enum Status {</span>
 92         Unknown,      // let cache decide what to do with it
 93         Pending,      // only partially loaded
 94         Cached,       // regular case
 95         LoadError,
 96         DecodeError
 97     };


 98 
 99     CachedResource(CachedResourceRequest&amp;&amp;, Type, const PAL::SessionID&amp;, const CookieJar*);
100     virtual ~CachedResource();
101 
102     virtual void load(CachedResourceLoader&amp;);
103 
104     virtual void setEncoding(const String&amp;) { }
105     virtual String encoding() const { return String(); }
106     virtual const TextResourceDecoder* textResourceDecoder() const { return nullptr; }
107     virtual void updateBuffer(SharedBuffer&amp;);
108     virtual void updateData(const char* data, unsigned length);
109     virtual void finishLoading(SharedBuffer*);
110     virtual void error(CachedResource::Status);
111 
112     void setResourceError(const ResourceError&amp; error) { m_error = error; }
113     const ResourceError&amp; resourceError() const { return m_error; }
114 
115     virtual bool shouldIgnoreHTTPStatusCodeErrors() const { return false; }
116 
117     const ResourceRequest&amp; resourceRequest() const { return m_resourceRequest; }
</pre>
<hr />
<pre>
123     String mimeType() const { return m_response.mimeType(); }
124     long long expectedContentLength() const { return m_response.expectedContentLength(); }
125 
126     static bool shouldUsePingLoad(Type type) { return type == Type::Beacon || type == Type::Ping; }
127 
128     ResourceLoadPriority loadPriority() const { return m_loadPriority; }
129     void setLoadPriority(const Optional&lt;ResourceLoadPriority&gt;&amp;);
130 
131     WEBCORE_EXPORT void addClient(CachedResourceClient&amp;);
132     WEBCORE_EXPORT void removeClient(CachedResourceClient&amp;);
133     bool hasClients() const { return !m_clients.isEmpty() || !m_clientsAwaitingCallback.isEmpty(); }
134     bool hasClient(CachedResourceClient&amp; client) { return m_clients.contains(&amp;client) || m_clientsAwaitingCallback.contains(&amp;client); }
135     bool deleteIfPossible();
136 
137     enum class PreloadResult : uint8_t {
138         PreloadNotReferenced,
139         PreloadReferenced,
140         PreloadReferencedWhileLoading,
141         PreloadReferencedWhileComplete
142     };


143     PreloadResult preloadResult() const { return static_cast&lt;PreloadResult&gt;(m_preloadResult); }
144 
145     virtual void didAddClient(CachedResourceClient&amp;);
146     virtual void didRemoveClient(CachedResourceClient&amp;) { }
147     virtual void allClientsRemoved();
148     void destroyDecodedDataIfNeeded();
149 
150     unsigned numberOfClients() const { return m_clients.size(); }
151 
152     Status status() const { return static_cast&lt;Status&gt;(m_status); }
<span class="line-modified">153     void setStatus(Status status) { m_status = status; }</span>




154 
155     unsigned size() const { return encodedSize() + decodedSize() + overheadSize(); }
156     unsigned encodedSize() const { return m_encodedSize; }
157     unsigned decodedSize() const { return m_decodedSize; }
158     unsigned overheadSize() const;
159 
160     bool isLoaded() const { return !m_loading; } // FIXME. Method name is inaccurate. Loading might not have started yet.
161 
162     bool isLoading() const { return m_loading; }
163     void setLoading(bool b) { m_loading = b; }
164     virtual bool stillNeedsLoad() const { return false; }
165 
166     SubresourceLoader* loader() { return m_loader.get(); }
167 
<span class="line-removed">168     bool areAllClientsXMLHttpRequests() const;</span>
<span class="line-removed">169 </span>
170     bool isImage() const { return type() == Type::ImageResource; }
171     // FIXME: CachedRawResource could be a main resource, an audio/video resource, or a raw XHR/icon resource.
172     bool isMainOrMediaOrIconOrRawResource() const { return type() == Type::MainResource || type() == Type::MediaResource || type() == Type::Icon || type() == Type::RawResource || type() == Type::Beacon || type() == Type::Ping; }
173 
174     // Whether this request should impact request counting and delay window.onload.
175     bool ignoreForRequestCount() const
176     {
177         return m_ignoreForRequestCount
178             || type() == Type::MainResource
179             || type() == Type::LinkPrefetch
180             || type() == Type::Beacon
181             || type() == Type::Ping
182             || type() == Type::Icon
183             || type() == Type::RawResource;
184     }
185 
186     void setIgnoreForRequestCount(bool ignoreForRequestCount) { m_ignoreForRequestCount = ignoreForRequestCount; }
187 
188     unsigned accessCount() const { return m_accessCount; }
189     void increaseAccessCount() { m_accessCount++; }
</pre>
<hr />
<pre>
263     // HTTP revalidation support methods for CachedResourceLoader.
264     void setResourceToRevalidate(CachedResource*);
265     virtual void switchClientsToRevalidatedResource();
266     void clearResourceToRevalidate();
267     void updateResponseAfterRevalidation(const ResourceResponse&amp; validatingResponse);
268     bool validationInProgress() const { return m_proxyResource; }
269     bool validationCompleting() const { return m_proxyResource &amp;&amp; m_proxyResource-&gt;m_switchingClientsToRevalidatedResource; }
270 
271     virtual void didSendData(unsigned long long /* bytesSent */, unsigned long long /* totalBytesToBeSent */) { }
272 
273 #if USE(FOUNDATION) || USE(SOUP)
274     WEBCORE_EXPORT void tryReplaceEncodedData(SharedBuffer&amp;);
275 #endif
276 
277     unsigned long identifierForLoadWithoutResourceLoader() const { return m_identifierForLoadWithoutResourceLoader; }
278     static ResourceLoadPriority defaultPriorityForResourceType(Type);
279 
280     void setOriginalRequest(std::unique_ptr&lt;ResourceRequest&gt;&amp;&amp; originalRequest) { m_originalRequest = WTFMove(originalRequest); }
281     const std::unique_ptr&lt;ResourceRequest&gt;&amp; originalRequest() const { return m_originalRequest; }
282 




283 protected:
284     // CachedResource constructor that may be used when the CachedResource can already be filled with response data.
285     CachedResource(const URL&amp;, Type, const PAL::SessionID&amp;, const CookieJar*);
286 
287     void setEncodedSize(unsigned);
288     void setDecodedSize(unsigned);
289     void didAccessDecodedData(MonotonicTime timeStamp);
290 
291     virtual void didReplaceSharedBufferContents() { }
292 
293     virtual void setBodyDataFrom(const CachedResource&amp;);
294 
295 private:
296     class Callback;
297 
298     bool addClientToSet(CachedResourceClient&amp;);
299 
300     void decodedDataDeletionTimerFired();
301 
302     virtual void checkNotify();
</pre>
<hr />
<pre>
332     // These handles will need to be updated to point to the m_resourceToRevalidate in case we get 304 response.
333     HashSet&lt;CachedResourceHandleBase*&gt; m_handlesToRevalidate;
334 
335     Vector&lt;std::pair&lt;String, String&gt;&gt; m_varyingHeaderValues;
336 
337     // If this field is non-null we are using the resource as a proxy for checking whether an existing resource is still up to date
338     // using HTTP If-Modified-Since/If-None-Match headers. If the response is 304 all clients of this resource are moved
339     // to to be clients of m_resourceToRevalidate and the resource is deleted. If not, the field is zeroed and this
340     // resources becomes normal resource load.
341     CachedResource* m_resourceToRevalidate { nullptr };
342 
343     // If this field is non-null, the resource has a proxy for checking whether it is still up to date (see m_resourceToRevalidate).
344     CachedResource* m_proxyResource { nullptr };
345 
346     String m_fragmentIdentifierForRequest;
347 
348     ResourceError m_error;
349     RefPtr&lt;SecurityOrigin&gt; m_origin;
350     AtomString m_initiatorName;
351 
<span class="line-removed">352     RedirectChainCacheStatus m_redirectChainCacheStatus;</span>
<span class="line-removed">353 </span>
354     unsigned m_encodedSize { 0 };
355     unsigned m_decodedSize { 0 };
356     unsigned m_accessCount { 0 };
357     unsigned m_handleCount { 0 };
358     unsigned m_preloadCount { 0 };
359 
<span class="line-modified">360     unsigned m_status { Pending }; // Status</span>
<span class="line-removed">361 </span>
<span class="line-removed">362     PreloadResult m_preloadResult { PreloadResult::PreloadNotReferenced };</span>
363 
<span class="line-modified">364     ResourceResponse::Tainting m_responseTainting { ResourceResponse::Tainting::Basic };</span>
<span class="line-removed">365     ResourceLoadPriority m_loadPriority;</span>
366 
<span class="line-modified">367     Type m_type; // Type</span>


368 
<span class="line-modified">369     bool m_requestedFromNetworkingLayer { false };</span>
<span class="line-modified">370     bool m_inCache { false };</span>
<span class="line-modified">371     bool m_loading { false };</span>
<span class="line-modified">372     bool m_isLinkPreload { false };</span>
<span class="line-modified">373     bool m_hasUnknownEncoding { false };</span>
<span class="line-modified">374     bool m_switchingClientsToRevalidatedResource { false };</span>
<span class="line-modified">375     bool m_ignoreForRequestCount { false };</span>

376 
<span class="line-modified">377 #ifndef NDEBUG</span>
378     bool m_deleted { false };
379     unsigned m_lruIndex { 0 };
380 #endif
381 };
382 
383 class CachedResource::Callback {
384     WTF_MAKE_FAST_ALLOCATED;
385 public:
386     Callback(CachedResource&amp;, CachedResourceClient&amp;);
387 
388     void cancel();
389 
390 private:
391     void timerFired();
392 
393     CachedResource&amp; m_resource;
394     CachedResourceClient&amp; m_client;
395     Timer m_timer;
396 };
397 
</pre>
</td>
<td>
<hr />
<pre>
 39 #include &lt;wtf/Vector.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 class CachedResourceClient;
 45 class CachedResourceHandleBase;
 46 class CachedResourceLoader;
 47 class CachedResourceRequest;
 48 class CookieJar;
 49 class LoadTiming;
 50 class MemoryCache;
 51 class SecurityOrigin;
 52 class SharedBuffer;
 53 class SubresourceLoader;
 54 class TextResourceDecoder;
 55 
 56 // A resource that is held in the cache. Classes who want to use this object should derive
 57 // from CachedResourceClient, to get the function calls in case the requested data has arrived.
 58 // This class also does the actual communication with the loader to obtain the resource from the network.
<span class="line-added"> 59 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CachedResource);</span>
 60 class CachedResource {
<span class="line-modified"> 61     WTF_MAKE_NONCOPYABLE(CachedResource);</span>
<span class="line-added"> 62     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(CachedResource);</span>
 63     friend class MemoryCache;
 64 
 65 public:
 66     enum class Type : uint8_t {
 67         MainResource,
 68         ImageResource,
 69         CSSStyleSheet,
 70         Script,
 71         FontResource,
 72 #if ENABLE(SVG_FONTS)
 73         SVGFontResource,
 74 #endif
 75         MediaResource,
 76         RawResource,
 77         Icon,
 78         Beacon,
 79         Ping,

 80 #if ENABLE(XSLT)
<span class="line-modified"> 81         XSLStyleSheet,</span>
 82 #endif
<span class="line-modified"> 83         LinkPrefetch,</span>
 84 #if ENABLE(VIDEO_TRACK)
<span class="line-modified"> 85         TextTrackResource,</span>
 86 #endif
 87 #if ENABLE(APPLICATION_MANIFEST)
<span class="line-modified"> 88         ApplicationManifest,</span>
 89 #endif
<span class="line-added"> 90         SVGDocumentResource,</span>
<span class="line-added"> 91         LastType = SVGDocumentResource,</span>
 92     };
<span class="line-added"> 93     static constexpr unsigned bitWidthOfType = 5;</span>
<span class="line-added"> 94     static_assert(static_cast&lt;unsigned&gt;(Type::LastType) &lt;= ((1U &lt;&lt; bitWidthOfType) - 1));</span>
 95 
<span class="line-modified"> 96     enum Status : uint8_t {</span>
 97         Unknown,      // let cache decide what to do with it
 98         Pending,      // only partially loaded
 99         Cached,       // regular case
100         LoadError,
101         DecodeError
102     };
<span class="line-added">103     static constexpr unsigned bitWidthOfStatus = 3;</span>
<span class="line-added">104     static_assert(static_cast&lt;unsigned&gt;(DecodeError) &lt;= ((1ULL &lt;&lt; bitWidthOfStatus) - 1));</span>
105 
106     CachedResource(CachedResourceRequest&amp;&amp;, Type, const PAL::SessionID&amp;, const CookieJar*);
107     virtual ~CachedResource();
108 
109     virtual void load(CachedResourceLoader&amp;);
110 
111     virtual void setEncoding(const String&amp;) { }
112     virtual String encoding() const { return String(); }
113     virtual const TextResourceDecoder* textResourceDecoder() const { return nullptr; }
114     virtual void updateBuffer(SharedBuffer&amp;);
115     virtual void updateData(const char* data, unsigned length);
116     virtual void finishLoading(SharedBuffer*);
117     virtual void error(CachedResource::Status);
118 
119     void setResourceError(const ResourceError&amp; error) { m_error = error; }
120     const ResourceError&amp; resourceError() const { return m_error; }
121 
122     virtual bool shouldIgnoreHTTPStatusCodeErrors() const { return false; }
123 
124     const ResourceRequest&amp; resourceRequest() const { return m_resourceRequest; }
</pre>
<hr />
<pre>
130     String mimeType() const { return m_response.mimeType(); }
131     long long expectedContentLength() const { return m_response.expectedContentLength(); }
132 
133     static bool shouldUsePingLoad(Type type) { return type == Type::Beacon || type == Type::Ping; }
134 
135     ResourceLoadPriority loadPriority() const { return m_loadPriority; }
136     void setLoadPriority(const Optional&lt;ResourceLoadPriority&gt;&amp;);
137 
138     WEBCORE_EXPORT void addClient(CachedResourceClient&amp;);
139     WEBCORE_EXPORT void removeClient(CachedResourceClient&amp;);
140     bool hasClients() const { return !m_clients.isEmpty() || !m_clientsAwaitingCallback.isEmpty(); }
141     bool hasClient(CachedResourceClient&amp; client) { return m_clients.contains(&amp;client) || m_clientsAwaitingCallback.contains(&amp;client); }
142     bool deleteIfPossible();
143 
144     enum class PreloadResult : uint8_t {
145         PreloadNotReferenced,
146         PreloadReferenced,
147         PreloadReferencedWhileLoading,
148         PreloadReferencedWhileComplete
149     };
<span class="line-added">150     static constexpr unsigned bitWidthOfPreloadResult = 2;</span>
<span class="line-added">151 </span>
152     PreloadResult preloadResult() const { return static_cast&lt;PreloadResult&gt;(m_preloadResult); }
153 
154     virtual void didAddClient(CachedResourceClient&amp;);
155     virtual void didRemoveClient(CachedResourceClient&amp;) { }
156     virtual void allClientsRemoved();
157     void destroyDecodedDataIfNeeded();
158 
159     unsigned numberOfClients() const { return m_clients.size(); }
160 
161     Status status() const { return static_cast&lt;Status&gt;(m_status); }
<span class="line-modified">162     void setStatus(Status status)</span>
<span class="line-added">163     {</span>
<span class="line-added">164         m_status = status;</span>
<span class="line-added">165         ASSERT(this-&gt;status() == status);</span>
<span class="line-added">166     }</span>
167 
168     unsigned size() const { return encodedSize() + decodedSize() + overheadSize(); }
169     unsigned encodedSize() const { return m_encodedSize; }
170     unsigned decodedSize() const { return m_decodedSize; }
171     unsigned overheadSize() const;
172 
173     bool isLoaded() const { return !m_loading; } // FIXME. Method name is inaccurate. Loading might not have started yet.
174 
175     bool isLoading() const { return m_loading; }
176     void setLoading(bool b) { m_loading = b; }
177     virtual bool stillNeedsLoad() const { return false; }
178 
179     SubresourceLoader* loader() { return m_loader.get(); }
180 


181     bool isImage() const { return type() == Type::ImageResource; }
182     // FIXME: CachedRawResource could be a main resource, an audio/video resource, or a raw XHR/icon resource.
183     bool isMainOrMediaOrIconOrRawResource() const { return type() == Type::MainResource || type() == Type::MediaResource || type() == Type::Icon || type() == Type::RawResource || type() == Type::Beacon || type() == Type::Ping; }
184 
185     // Whether this request should impact request counting and delay window.onload.
186     bool ignoreForRequestCount() const
187     {
188         return m_ignoreForRequestCount
189             || type() == Type::MainResource
190             || type() == Type::LinkPrefetch
191             || type() == Type::Beacon
192             || type() == Type::Ping
193             || type() == Type::Icon
194             || type() == Type::RawResource;
195     }
196 
197     void setIgnoreForRequestCount(bool ignoreForRequestCount) { m_ignoreForRequestCount = ignoreForRequestCount; }
198 
199     unsigned accessCount() const { return m_accessCount; }
200     void increaseAccessCount() { m_accessCount++; }
</pre>
<hr />
<pre>
274     // HTTP revalidation support methods for CachedResourceLoader.
275     void setResourceToRevalidate(CachedResource*);
276     virtual void switchClientsToRevalidatedResource();
277     void clearResourceToRevalidate();
278     void updateResponseAfterRevalidation(const ResourceResponse&amp; validatingResponse);
279     bool validationInProgress() const { return m_proxyResource; }
280     bool validationCompleting() const { return m_proxyResource &amp;&amp; m_proxyResource-&gt;m_switchingClientsToRevalidatedResource; }
281 
282     virtual void didSendData(unsigned long long /* bytesSent */, unsigned long long /* totalBytesToBeSent */) { }
283 
284 #if USE(FOUNDATION) || USE(SOUP)
285     WEBCORE_EXPORT void tryReplaceEncodedData(SharedBuffer&amp;);
286 #endif
287 
288     unsigned long identifierForLoadWithoutResourceLoader() const { return m_identifierForLoadWithoutResourceLoader; }
289     static ResourceLoadPriority defaultPriorityForResourceType(Type);
290 
291     void setOriginalRequest(std::unique_ptr&lt;ResourceRequest&gt;&amp;&amp; originalRequest) { m_originalRequest = WTFMove(originalRequest); }
292     const std::unique_ptr&lt;ResourceRequest&gt;&amp; originalRequest() const { return m_originalRequest; }
293 
<span class="line-added">294 #if USE(QUICK_LOOK)</span>
<span class="line-added">295     virtual void previewResponseReceived(const ResourceResponse&amp;);</span>
<span class="line-added">296 #endif</span>
<span class="line-added">297 </span>
298 protected:
299     // CachedResource constructor that may be used when the CachedResource can already be filled with response data.
300     CachedResource(const URL&amp;, Type, const PAL::SessionID&amp;, const CookieJar*);
301 
302     void setEncodedSize(unsigned);
303     void setDecodedSize(unsigned);
304     void didAccessDecodedData(MonotonicTime timeStamp);
305 
306     virtual void didReplaceSharedBufferContents() { }
307 
308     virtual void setBodyDataFrom(const CachedResource&amp;);
309 
310 private:
311     class Callback;
312 
313     bool addClientToSet(CachedResourceClient&amp;);
314 
315     void decodedDataDeletionTimerFired();
316 
317     virtual void checkNotify();
</pre>
<hr />
<pre>
347     // These handles will need to be updated to point to the m_resourceToRevalidate in case we get 304 response.
348     HashSet&lt;CachedResourceHandleBase*&gt; m_handlesToRevalidate;
349 
350     Vector&lt;std::pair&lt;String, String&gt;&gt; m_varyingHeaderValues;
351 
352     // If this field is non-null we are using the resource as a proxy for checking whether an existing resource is still up to date
353     // using HTTP If-Modified-Since/If-None-Match headers. If the response is 304 all clients of this resource are moved
354     // to to be clients of m_resourceToRevalidate and the resource is deleted. If not, the field is zeroed and this
355     // resources becomes normal resource load.
356     CachedResource* m_resourceToRevalidate { nullptr };
357 
358     // If this field is non-null, the resource has a proxy for checking whether it is still up to date (see m_resourceToRevalidate).
359     CachedResource* m_proxyResource { nullptr };
360 
361     String m_fragmentIdentifierForRequest;
362 
363     ResourceError m_error;
364     RefPtr&lt;SecurityOrigin&gt; m_origin;
365     AtomString m_initiatorName;
366 


367     unsigned m_encodedSize { 0 };
368     unsigned m_decodedSize { 0 };
369     unsigned m_accessCount { 0 };
370     unsigned m_handleCount { 0 };
371     unsigned m_preloadCount { 0 };
372 
<span class="line-modified">373     RedirectChainCacheStatus m_redirectChainCacheStatus;</span>


374 
<span class="line-modified">375     Type m_type : bitWidthOfType;</span>

376 
<span class="line-modified">377     PreloadResult m_preloadResult : bitWidthOfPreloadResult;</span>
<span class="line-added">378     ResourceResponse::Tainting m_responseTainting : ResourceResponse::bitWidthOfTainting;</span>
<span class="line-added">379     ResourceLoadPriority m_loadPriority : bitWidthOfResourceLoadPriority;</span>
380 
<span class="line-modified">381     Status m_status : bitWidthOfStatus;</span>
<span class="line-modified">382     bool m_requestedFromNetworkingLayer : 1;</span>
<span class="line-modified">383     bool m_inCache : 1;</span>
<span class="line-modified">384     bool m_loading : 1;</span>
<span class="line-modified">385     bool m_isLinkPreload : 1;</span>
<span class="line-modified">386     bool m_hasUnknownEncoding : 1;</span>
<span class="line-modified">387     bool m_switchingClientsToRevalidatedResource : 1;</span>
<span class="line-added">388     bool m_ignoreForRequestCount : 1;</span>
389 
<span class="line-modified">390 #if ASSERT_ENABLED</span>
391     bool m_deleted { false };
392     unsigned m_lruIndex { 0 };
393 #endif
394 };
395 
396 class CachedResource::Callback {
397     WTF_MAKE_FAST_ALLOCATED;
398 public:
399     Callback(CachedResource&amp;, CachedResourceClient&amp;);
400 
401     void cancel();
402 
403 private:
404     void timerFired();
405 
406     CachedResource&amp; m_resource;
407     CachedResourceClient&amp; m_client;
408     Timer m_timer;
409 };
410 
</pre>
</td>
</tr>
</table>
<center><a href="CachedResource.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceClient.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
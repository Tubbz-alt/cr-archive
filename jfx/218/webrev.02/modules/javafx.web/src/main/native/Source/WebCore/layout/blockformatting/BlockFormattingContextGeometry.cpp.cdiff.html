<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContextGeometry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlockFormattingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingContextQuirks.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContextGeometry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,25 ***</span>
  #include &quot;config.h&quot;
  #include &quot;BlockFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;FormattingContext.h&quot;
  #include &quot;InlineFormattingState.h&quot;
  #include &quot;LayoutChildIterator.h&quot;
  #include &quot;Logging.h&quot;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
<span class="line-modified">! HeightAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
  {
      ASSERT(layoutBox.isInFlow() &amp;&amp; !layoutBox.replaced());
      ASSERT(layoutBox.isOverflowVisible());
  
<span class="line-modified">!     auto compute = [&amp;]() -&gt; HeightAndMargin {</span>
  
          // 10.6.3 Block-level non-replaced elements in normal flow when &#39;overflow&#39; computes to &#39;visible&#39;
          //
          // If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
          // If &#39;height&#39; is &#39;auto&#39;, the height depends on whether the element has any block-level children and whether it has padding or borders:
<span class="line-new-header">--- 26,28 ---</span>
  #include &quot;config.h&quot;
  #include &quot;BlockFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="line-added">+ #include &quot;BlockFormattingState.h&quot;</span>
<span class="line-added">+ #include &quot;DisplayBox.h&quot;</span>
  #include &quot;FormattingContext.h&quot;
  #include &quot;InlineFormattingState.h&quot;
  #include &quot;LayoutChildIterator.h&quot;
<span class="line-added">+ #include &quot;LayoutContext.h&quot;</span>
  #include &quot;Logging.h&quot;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
<span class="line-modified">! ContentHeightAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues)</span>
  {
      ASSERT(layoutBox.isInFlow() &amp;&amp; !layoutBox.replaced());
      ASSERT(layoutBox.isOverflowVisible());
  
<span class="line-modified">!     auto compute = [&amp;](const auto&amp; overrideVerticalValues) -&gt; ContentHeightAndMargin {</span>
  
          // 10.6.3 Block-level non-replaced elements in normal flow when &#39;overflow&#39; computes to &#39;visible&#39;
          //
          // If &#39;margin-top&#39;, or &#39;margin-bottom&#39; are &#39;auto&#39;, their used value is 0.
          // If &#39;height&#39; is &#39;auto&#39;, the height depends on whether the element has any block-level children and whether it has padding or borders:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 55,62 ***</span>
          // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
          // 4. zero, otherwise
          // Only children in the normal flow are taken into account (i.e., floating boxes and absolutely positioned boxes are ignored,
          // and relatively positioned boxes are considered without their offset). Note that the child box may be an anonymous block box.
  
<span class="line-modified">!         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!         auto containingBlockWidth = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth();</span>
<span class="line-removed">-         auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, UsedHorizontalValues { containingBlockWidth });</span>
          auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         auto borderAndPaddingTop = displayBox.borderTop() + displayBox.paddingTop().valueOr(0);</span>
<span class="line-modified">!         auto height = usedValues.height ? usedValues.height.value() : computedHeightValue(layoutState, layoutBox, HeightType::Normal);</span>
  
<span class="line-modified">!         if (height) {</span>
<span class="line-modified">!             auto borderAndPaddingBottom = displayBox.borderBottom() + displayBox.paddingBottom().valueOr(0);</span>
<span class="line-removed">-             auto contentHeight = layoutBox.style().boxSizing() == BoxSizing::ContentBox ? *height : *height - (borderAndPaddingTop + borderAndPaddingBottom);</span>
<span class="line-removed">-             return { contentHeight, nonCollapsedMargin };</span>
<span class="line-removed">-         }</span>
  
          if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
              return { 0, nonCollapsedMargin };
  
          // 1. the bottom edge of the last line box, if the box establishes a inline formatting context with one or more lines
<span class="line-modified">!         if (layoutBox.establishesInlineFormattingContext()) {</span>
<span class="line-modified">!             auto&amp; lineBoxes = downcast&lt;InlineFormattingState&gt;(layoutState.establishedFormattingState(layoutBox)).lineBoxes();</span>
              // Even empty containers generate one line.
              ASSERT(!lineBoxes.isEmpty());
<span class="line-modified">!             return { lineBoxes.last().logicalBottom() - borderAndPaddingTop, nonCollapsedMargin };</span>
          }
  
          // 2. the bottom edge of the bottom (possibly collapsed) margin of its last in-flow child, if the child&#39;s bottom margin...
<span class="line-modified">!         auto* lastInFlowChild = downcast&lt;Container&gt;(layoutBox).lastInFlowChild();</span>
          ASSERT(lastInFlowChild);
<span class="line-modified">!         if (!MarginCollapse::marginAfterCollapsesWithParentMarginAfter(layoutState, *lastInFlowChild)) {</span>
<span class="line-modified">!             auto&amp; lastInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*lastInFlowChild);</span>
<span class="line-modified">!             auto bottomEdgeOfBottomMargin = lastInFlowDisplayBox.bottom() + (lastInFlowDisplayBox.hasCollapsedThroughMargin() ? LayoutUnit() : lastInFlowDisplayBox.marginAfter());</span>
              return { bottomEdgeOfBottomMargin - borderAndPaddingTop, nonCollapsedMargin };
          }
  
          // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
          auto* inFlowChild = lastInFlowChild;
<span class="line-modified">!         while (inFlowChild &amp;&amp; MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(layoutState, *inFlowChild))</span>
              inFlowChild = inFlowChild-&gt;previousInFlowSibling();
          if (inFlowChild) {
<span class="line-modified">!             auto&amp; inFlowDisplayBox = layoutState.displayBoxForLayoutBox(*inFlowChild);</span>
<span class="line-modified">!             return { inFlowDisplayBox.top() + inFlowDisplayBox.borderBox().height() - borderAndPaddingTop, nonCollapsedMargin };</span>
          }
  
          // 4. zero, otherwise
          return { 0, nonCollapsedMargin };
      };
  
<span class="line-modified">!     auto heightAndMargin = compute();</span>
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow non-replaced -&gt; height(&quot; &lt;&lt; heightAndMargin.height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     return heightAndMargin;</span>
  }
  
<span class="line-modified">! WidthAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isInFlow());
  
      auto compute = [&amp;]() {
  
<span class="line-new-header">--- 58,61 ---</span>
          // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
          // 4. zero, otherwise
          // Only children in the normal flow are taken into account (i.e., floating boxes and absolutely positioned boxes are ignored,
          // and relatively positioned boxes are considered without their offset). Note that the child box may be an anonymous block box.
  
<span class="line-modified">!         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
<span class="line-modified">!         auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, horizontalConstraints);</span>
          auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
<span class="line-modified">!         auto borderAndPaddingTop = boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0);</span>
<span class="line-modified">!         auto height = overrideVerticalValues.height ? overrideVerticalValues.height.value() : computedContentHeight(layoutBox);</span>
  
<span class="line-modified">!         if (height)</span>
<span class="line-modified">!             return { *height, nonCollapsedMargin };</span>
  
          if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowChild())
              return { 0, nonCollapsedMargin };
  
          // 1. the bottom edge of the last line box, if the box establishes a inline formatting context with one or more lines
<span class="line-modified">!         auto&amp; layoutContainer = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified">!         if (layoutContainer.establishesInlineFormattingContext()) {</span>
<span class="line-added">+             auto&amp; lineBoxes = layoutState().establishedInlineFormattingState(layoutContainer).displayInlineContent()-&gt;lineBoxes;</span>
              // Even empty containers generate one line.
              ASSERT(!lineBoxes.isEmpty());
<span class="line-modified">!             return { toLayoutUnit(lineBoxes.last().bottom()) - borderAndPaddingTop, nonCollapsedMargin };</span>
          }
  
          // 2. the bottom edge of the bottom (possibly collapsed) margin of its last in-flow child, if the child&#39;s bottom margin...
<span class="line-modified">!         auto* lastInFlowChild = layoutContainer.lastInFlowChild();</span>
          ASSERT(lastInFlowChild);
<span class="line-modified">!         if (!formattingContext().marginCollapse().marginAfterCollapsesWithParentMarginAfter(*lastInFlowChild)) {</span>
<span class="line-modified">!             auto&amp; lastInFlowBoxGeometry = formattingContext().geometryForBox(*lastInFlowChild);</span>
<span class="line-modified">!             auto bottomEdgeOfBottomMargin = lastInFlowBoxGeometry.bottom() + (lastInFlowBoxGeometry.hasCollapsedThroughMargin() ? LayoutUnit() : lastInFlowBoxGeometry.marginAfter());</span>
              return { bottomEdgeOfBottomMargin - borderAndPaddingTop, nonCollapsedMargin };
          }
  
          // 3. the bottom border edge of the last in-flow child whose top margin doesn&#39;t collapse with the element&#39;s bottom margin
          auto* inFlowChild = lastInFlowChild;
<span class="line-modified">!         while (inFlowChild &amp;&amp; formattingContext().marginCollapse().marginBeforeCollapsesWithParentMarginAfter(*inFlowChild))</span>
              inFlowChild = inFlowChild-&gt;previousInFlowSibling();
          if (inFlowChild) {
<span class="line-modified">!             auto&amp; inFlowDisplayBoxGeometry = formattingContext().geometryForBox(*inFlowChild);</span>
<span class="line-modified">!             return { inFlowDisplayBoxGeometry.top() + inFlowDisplayBoxGeometry.borderBox().height() - borderAndPaddingTop, nonCollapsedMargin };</span>
          }
  
          // 4. zero, otherwise
          return { 0, nonCollapsedMargin };
      };
  
<span class="line-modified">!     // 10.6.7 &#39;Auto&#39; heights for block formatting context roots</span>
<span class="line-modified">!     auto isAutoHeight = !overrideVerticalValues.height &amp;&amp; !computedContentHeight(layoutBox);</span>
<span class="line-modified">!     if (isAutoHeight &amp;&amp; layoutBox.establishesBlockFormattingContext())</span>
<span class="line-added">+         return compute( OverrideVerticalValues { contentHeightForFormattingContextRoot(layoutBox) });</span>
<span class="line-added">+     return compute(overrideVerticalValues);</span>
  }
  
<span class="line-modified">! ContentWidthAndMargin BlockFormattingContext::Geometry::inFlowNonReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
  {
      ASSERT(layoutBox.isInFlow());
  
      auto compute = [&amp;]() {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,167 ***</span>
          // 4. If &#39;width&#39; is set to &#39;auto&#39;, any other &#39;auto&#39; values become &#39;0&#39; and &#39;width&#39; follows from the resulting equality.
          //
          // 5. If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, their used values are equal. This horizontally centers the element with respect to the
          //    edges of the containing block.
  
<span class="line-modified">!         auto&amp; style = layoutBox.style();</span>
<span class="line-modified">!         auto* containingBlock = layoutBox.containingBlock();</span>
<span class="line-removed">-         auto containingBlockWidth = usedValues.containingBlockWidth.valueOr(0);</span>
<span class="line-removed">-         auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
  
<span class="line-modified">!         auto width = computedValueIfNotAuto(usedValues.width ? Length { usedValues.width.value(), Fixed } : style.logicalWidth(), containingBlockWidth);</span>
<span class="line-modified">!         auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
          UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified">!         auto borderLeft = displayBox.borderLeft();</span>
<span class="line-modified">!         auto borderRight = displayBox.borderRight();</span>
<span class="line-modified">!         auto paddingLeft = displayBox.paddingLeft().valueOr(0);</span>
<span class="line-modified">!         auto paddingRight = displayBox.paddingRight().valueOr(0);</span>
<span class="line-removed">-         auto contentWidth = [&amp;] {</span>
<span class="line-removed">-             ASSERT(width);</span>
<span class="line-removed">-             return style.boxSizing() == BoxSizing::ContentBox ? *width : *width - (borderLeft + paddingLeft + paddingRight + borderRight);</span>
<span class="line-removed">-         };</span>
  
          // #1
          if (width) {
<span class="line-modified">!             auto horizontalSpaceForMargin = containingBlockWidth - (computedHorizontalMargin.start.valueOr(0) + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + computedHorizontalMargin.end.valueOr(0));</span>
              if (horizontalSpaceForMargin &lt; 0)
                  usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
          }
  
          // #2
          if (width &amp;&amp; computedHorizontalMargin.start &amp;&amp; computedHorizontalMargin.end) {
<span class="line-modified">!             if (containingBlock-&gt;style().isLeftToRightDirection()) {</span>
                  usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">!                 usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight);</span>
              } else {
                  usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">!                 usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
              }
          }
  
          // #3
          if (!computedHorizontalMargin.start &amp;&amp; width &amp;&amp; computedHorizontalMargin.end) {
              usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">!             usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft  + contentWidth() + paddingRight + borderRight + usedHorizontalMargin.end);</span>
          } else if (computedHorizontalMargin.start &amp;&amp; !width &amp;&amp; computedHorizontalMargin.end) {
              usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
              width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
          } else if (computedHorizontalMargin.start &amp;&amp; width &amp;&amp; !computedHorizontalMargin.end) {
              usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">!             usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + contentWidth() + paddingRight + borderRight);</span>
          }
  
          // #4
          if (!width) {
              usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
              width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
          }
  
          // #5
          if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified">!             auto horizontalSpaceForMargin = containingBlockWidth - (borderLeft + paddingLeft  + contentWidth() + paddingRight + borderRight);</span>
              usedHorizontalMargin = { horizontalSpaceForMargin / 2, horizontalSpaceForMargin / 2 };
          }
  
          ASSERT(width);
  
<span class="line-modified">!         return WidthAndMargin { contentWidth(), usedHorizontalMargin, computedHorizontalMargin };</span>
      };
  
<span class="line-modified">!     auto widthAndMargin = compute();</span>
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow non-replaced -&gt; width(&quot; &lt;&lt; widthAndMargin.width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; widthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; widthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     return widthAndMargin;</span>
  }
  
<span class="line-modified">! WidthAndMargin BlockFormattingContext::Geometry::inFlowReplacedWidthAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isInFlow() &amp;&amp; layoutBox.replaced());
  
      // 10.3.4 Block-level, replaced elements in normal flow
      //
      // 1. The used value of &#39;width&#39; is determined as for inline replaced elements.
      // 2. Then the rules for non-replaced block-level elements are applied to determine the margins.
  
      // #1
<span class="line-modified">!     usedValues.width = inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues).width;</span>
      // #2
<span class="line-modified">!     auto nonReplacedWidthAndMargin = inFlowNonReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
  
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; *usedValues.width &lt;&lt; &quot;px) margin(&quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     return { *usedValues.width, nonReplacedWidthAndMargin.usedMargin, nonReplacedWidthAndMargin.computedMargin };</span>
  }
  
<span class="line-modified">! LayoutUnit BlockFormattingContext::Geometry::staticVerticalPosition(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
      // In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block.
      // The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties.
      // Vertical margins between adjacent block-level boxes in a block formatting context collapse.
      if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
<span class="line-modified">!         auto&amp; previousInFlowDisplayBox = layoutState.displayBoxForLayoutBox(*previousInFlowSibling);</span>
<span class="line-modified">!         return previousInFlowDisplayBox.bottom() + previousInFlowDisplayBox.marginAfter();</span>
      }
<span class="line-modified">!     return layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxTop();</span>
  }
  
<span class="line-modified">! LayoutUnit BlockFormattingContext::Geometry::staticHorizontalPosition(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
      // In a block formatting context, each box&#39;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch).
<span class="line-modified">!     return layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxLeft() + layoutState.displayBoxForLayoutBox(layoutBox).marginStart();</span>
  }
  
<span class="line-modified">! Point BlockFormattingContext::Geometry::staticPosition(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
<span class="line-modified">!     return { staticHorizontalPosition(layoutState, layoutBox), staticVerticalPosition(layoutState, layoutBox) };</span>
  }
  
<span class="line-modified">! HeightAndMargin BlockFormattingContext::Geometry::inFlowHeightAndMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedVerticalValues usedValues)</span>
  {
      ASSERT(layoutBox.isInFlow());
  
      // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
      // replaced elements in normal flow and floating replaced elements
      if (layoutBox.replaced())
<span class="line-modified">!         return inlineReplacedHeightAndMargin(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     HeightAndMargin heightAndMargin;</span>
<span class="line-modified">!     // TODO: Figure out the case for the document element. Let&#39;s just complicated-case it for now.</span>
<span class="line-modified">!     if (layoutBox.isOverflowVisible() &amp;&amp; !layoutBox.isDocumentBox())</span>
<span class="line-modified">!         heightAndMargin = inFlowNonReplacedHeightAndMargin(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">!     else {</span>
          // 10.6.6 Complicated cases
          // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
<span class="line-modified">!         auto usedHorizontalValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };</span>
<span class="line-removed">-         heightAndMargin = complicatedCases(layoutState, layoutBox, usedValues, usedHorizontalValues);</span>
      }
  
<span class="line-modified">!     if (!Quirks::needsStretching(layoutState, layoutBox))</span>
<span class="line-modified">!         return heightAndMargin;</span>
  
<span class="line-modified">!     heightAndMargin = Quirks::stretchedInFlowHeight(layoutState, layoutBox, heightAndMargin);</span>
  
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow non-replaced -&gt; streched to viewport -&gt; height(&quot; &lt;&lt; heightAndMargin.height &lt;&lt; &quot;px) margin(&quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; heightAndMargin.nonCollapsedMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     return heightAndMargin;</span>
  }
  
<span class="line-modified">! WidthAndMargin BlockFormattingContext::Geometry::inFlowWidthAndMargin(LayoutState&amp; layoutState, const Box&amp; layoutBox, UsedHorizontalValues usedValues)</span>
  {
      ASSERT(layoutBox.isInFlow());
  
      if (!layoutBox.replaced()) {
<span class="line-modified">!         if (layoutBox.establishesTableFormattingContext()) {</span>
<span class="line-modified">!             // This is a special table &quot;fit-content size&quot; behavior handling. Not in the spec though.</span>
<span class="line-modified">!             // Table returns its final width as min/max. Use this final width value to computed horizontal margins etc.</span>
<span class="line-modified">!             usedValues.width = Geometry::shrinkToFitWidth(layoutState, layoutBox, usedValues);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         return inFlowNonReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
      }
<span class="line-modified">!     return inFlowReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints BlockFormattingContext::Geometry::intrinsicWidthConstraints(LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      auto fixedMarginBorderAndPadding = [&amp;](auto&amp; layoutBox) {
          auto&amp; style = layoutBox.style();
          return fixedValue(style.marginStart()).valueOr(0)
              + LayoutUnit { style.borderLeftWidth() }
<span class="line-new-header">--- 135,164 ---</span>
          // 4. If &#39;width&#39; is set to &#39;auto&#39;, any other &#39;auto&#39; values become &#39;0&#39; and &#39;width&#39; follows from the resulting equality.
          //
          // 5. If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, their used values are equal. This horizontally centers the element with respect to the
          //    edges of the containing block.
  
<span class="line-modified">!         auto containingBlockWidth = horizontalConstraints.logicalWidth;</span>
<span class="line-modified">!         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
  
<span class="line-modified">!         auto width = overrideHorizontalValues.width ? overrideHorizontalValues.width : computedContentWidth(layoutBox, containingBlockWidth);</span>
<span class="line-modified">!         auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
          UsedHorizontalMargin usedHorizontalMargin;
<span class="line-modified">!         auto borderLeft = boxGeometry.borderLeft();</span>
<span class="line-modified">!         auto borderRight = boxGeometry.borderRight();</span>
<span class="line-modified">!         auto paddingLeft = boxGeometry.paddingLeft().valueOr(0);</span>
<span class="line-modified">!         auto paddingRight = boxGeometry.paddingRight().valueOr(0);</span>
  
          // #1
          if (width) {
<span class="line-modified">!             auto horizontalSpaceForMargin = containingBlockWidth - (computedHorizontalMargin.start.valueOr(0) + borderLeft + paddingLeft + *width + paddingRight + borderRight + computedHorizontalMargin.end.valueOr(0));</span>
              if (horizontalSpaceForMargin &lt; 0)
                  usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
          }
  
          // #2
          if (width &amp;&amp; computedHorizontalMargin.start &amp;&amp; computedHorizontalMargin.end) {
<span class="line-modified">!             if (layoutBox.containingBlock()-&gt;style().isLeftToRightDirection()) {</span>
                  usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">!                 usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight);</span>
              } else {
                  usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">!                 usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
              }
          }
  
          // #3
          if (!computedHorizontalMargin.start &amp;&amp; width &amp;&amp; computedHorizontalMargin.end) {
              usedHorizontalMargin.end = *computedHorizontalMargin.end;
<span class="line-modified">!             usedHorizontalMargin.start = containingBlockWidth - (borderLeft + paddingLeft  + *width + paddingRight + borderRight + usedHorizontalMargin.end);</span>
          } else if (computedHorizontalMargin.start &amp;&amp; !width &amp;&amp; computedHorizontalMargin.end) {
              usedHorizontalMargin = { *computedHorizontalMargin.start, *computedHorizontalMargin.end };
              width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
          } else if (computedHorizontalMargin.start &amp;&amp; width &amp;&amp; !computedHorizontalMargin.end) {
              usedHorizontalMargin.start = *computedHorizontalMargin.start;
<span class="line-modified">!             usedHorizontalMargin.end = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + *width + paddingRight + borderRight);</span>
          }
  
          // #4
          if (!width) {
              usedHorizontalMargin = { computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) };
              width = containingBlockWidth - (usedHorizontalMargin.start + borderLeft + paddingLeft + paddingRight + borderRight + usedHorizontalMargin.end);
          }
  
          // #5
          if (!computedHorizontalMargin.start &amp;&amp; !computedHorizontalMargin.end) {
<span class="line-modified">!             auto horizontalSpaceForMargin = containingBlockWidth - (borderLeft + paddingLeft  + *width + paddingRight + borderRight);</span>
              usedHorizontalMargin = { horizontalSpaceForMargin / 2, horizontalSpaceForMargin / 2 };
          }
  
          ASSERT(width);
  
<span class="line-modified">!         return ContentWidthAndMargin { *width, usedHorizontalMargin, computedHorizontalMargin };</span>
      };
  
<span class="line-modified">!     auto contentWidthAndMargin = compute();</span>
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow non-replaced -&gt; width(&quot; &lt;&lt; contentWidthAndMargin.contentWidth &lt;&lt; &quot;px) margin(&quot; &lt;&lt; contentWidthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; contentWidthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     return contentWidthAndMargin;</span>
  }
  
<span class="line-modified">! ContentWidthAndMargin BlockFormattingContext::Geometry::inFlowReplacedWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues) const</span>
  {
      ASSERT(layoutBox.isInFlow() &amp;&amp; layoutBox.replaced());
  
      // 10.3.4 Block-level, replaced elements in normal flow
      //
      // 1. The used value of &#39;width&#39; is determined as for inline replaced elements.
      // 2. Then the rules for non-replaced block-level elements are applied to determine the margins.
  
      // #1
<span class="line-modified">!     auto usedWidth = inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues).contentWidth;</span>
      // #2
<span class="line-modified">!     auto nonReplacedWidthAndMargin = inFlowNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, OverrideHorizontalValues { usedWidth, overrideHorizontalValues.margin });</span>
  
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Width][Margin] -&gt; inflow replaced -&gt; width(&quot; &lt;&lt; usedWidth  &lt;&lt; &quot;px) margin(&quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.start &lt;&lt; &quot;px, &quot; &lt;&lt; nonReplacedWidthAndMargin.usedMargin.end &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     return { usedWidth, nonReplacedWidthAndMargin.usedMargin, nonReplacedWidthAndMargin.computedMargin };</span>
  }
  
<span class="line-modified">! LayoutUnit BlockFormattingContext::Geometry::staticVerticalPosition(const Box&amp; layoutBox, const VerticalConstraints&amp; verticalConstraints) const</span>
  {
      // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
      // In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block.
      // The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties.
      // Vertical margins between adjacent block-level boxes in a block formatting context collapse.
      if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
<span class="line-modified">!         auto&amp; previousInFlowBoxGeometry = formattingContext().geometryForBox(*previousInFlowSibling);</span>
<span class="line-modified">!         return previousInFlowBoxGeometry.bottom() + previousInFlowBoxGeometry.marginAfter();</span>
      }
<span class="line-modified">!     return verticalConstraints.logicalTop;</span>
  }
  
<span class="line-modified">! LayoutUnit BlockFormattingContext::Geometry::staticHorizontalPosition(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints) const</span>
  {
      // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
      // In a block formatting context, each box&#39;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch).
<span class="line-modified">!     return horizontalConstraints.logicalLeft + formattingContext().geometryForBox(layoutBox).marginStart();</span>
  }
  
<span class="line-modified">! Point BlockFormattingContext::Geometry::staticPosition(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints) const</span>
  {
<span class="line-modified">!     return { staticHorizontalPosition(layoutBox, horizontalConstraints), staticVerticalPosition(layoutBox, verticalConstraints) };</span>
  }
  
<span class="line-modified">! ContentHeightAndMargin BlockFormattingContext::Geometry::inFlowHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideVerticalValues&amp; overrideVerticalValues)</span>
  {
      ASSERT(layoutBox.isInFlow());
  
      // 10.6.2 Inline replaced elements, block-level replaced elements in normal flow, &#39;inline-block&#39;
      // replaced elements in normal flow and floating replaced elements
      if (layoutBox.replaced())
<span class="line-modified">!         return inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, overrideVerticalValues);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     ContentHeightAndMargin contentHeightAndMargin;</span>
<span class="line-modified">!     // FIXME: Let&#39;s special case the table height computation for now -&gt; figure out whether tables fall into the &quot;inFlowNonReplacedHeightAndMargin&quot; category.</span>
<span class="line-modified">!     if (layoutBox.establishesTableFormattingContext())</span>
<span class="line-modified">!         contentHeightAndMargin = complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
<span class="line-modified">!     else if (layoutBox.isOverflowVisible() &amp;&amp; !layoutBox.isDocumentBox()) {</span>
<span class="line-added">+         // TODO: Figure out the case for the document element. Let&#39;s just complicated-case it for now.</span>
<span class="line-added">+         contentHeightAndMargin = inFlowNonReplacedHeightAndMargin(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
<span class="line-added">+     } else {</span>
          // 10.6.6 Complicated cases
          // Block-level, non-replaced elements in normal flow when &#39;overflow&#39; does not compute to &#39;visible&#39; (except if the &#39;overflow&#39; property&#39;s value has been propagated to the viewport).
<span class="line-modified">!         contentHeightAndMargin = complicatedCases(layoutBox, horizontalConstraints, overrideVerticalValues);</span>
      }
  
<span class="line-modified">!     auto quirks = formattingContext().quirks();</span>
<span class="line-modified">!     if (!quirks.needsStretching(layoutBox))</span>
<span class="line-added">+         return contentHeightAndMargin;</span>
  
<span class="line-modified">!     contentHeightAndMargin = quirks.stretchedInFlowHeight(layoutBox, contentHeightAndMargin);</span>
  
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Height][Margin] -&gt; inflow non-replaced -&gt; streched to viewport -&gt; height(&quot; &lt;&lt; contentHeightAndMargin.contentHeight &lt;&lt; &quot;px) margin(&quot; &lt;&lt; contentHeightAndMargin.nonCollapsedMargin.before &lt;&lt; &quot;px, &quot; &lt;&lt; contentHeightAndMargin.nonCollapsedMargin.after &lt;&lt; &quot;px) -&gt; layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     return contentHeightAndMargin;</span>
  }
  
<span class="line-modified">! ContentWidthAndMargin BlockFormattingContext::Geometry::inFlowWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints, const OverrideHorizontalValues&amp; overrideHorizontalValues)</span>
  {
      ASSERT(layoutBox.isInFlow());
  
      if (!layoutBox.replaced()) {
<span class="line-modified">!         if (!layoutBox.establishesTableFormattingContext())</span>
<span class="line-modified">!             return inFlowNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
<span class="line-modified">!         // This is a special table &quot;fit-content size&quot; behavior handling. Not in the spec though.</span>
<span class="line-modified">!         // Table returns its final width as min/max. Use this final width value to computed horizontal margins etc.</span>
<span class="line-modified">!         auto usedWidth = overrideHorizontalValues.width ? overrideHorizontalValues.width : shrinkToFitWidth(layoutBox, horizontalConstraints.logicalWidth);</span>
<span class="line-modified">!         return inFlowNonReplacedWidthAndMargin(layoutBox, horizontalConstraints, OverrideHorizontalValues { usedWidth, overrideHorizontalValues.margin });</span>
      }
<span class="line-modified">!     return inFlowReplacedWidthAndMargin(layoutBox, horizontalConstraints, overrideHorizontalValues);</span>
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints BlockFormattingContext::Geometry::intrinsicWidthConstraints(const Box&amp; layoutBox)</span>
  {
      auto fixedMarginBorderAndPadding = [&amp;](auto&amp; layoutBox) {
          auto&amp; style = layoutBox.style();
          return fixedValue(style.marginStart()).valueOr(0)
              + LayoutUnit { style.borderLeftWidth() }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,18 ***</span>
                  return { replacedWidth, replacedWidth };
              }
              return { };
          }
  
<span class="line-removed">-         if (layoutBox.establishesFormattingContext())</span>
<span class="line-removed">-             return layoutState.createFormattingContext(layoutBox)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-removed">- </span>
          if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
              return { };
  
          auto intrinsicWidthConstraints = IntrinsicWidthConstraints { };
<span class="line-modified">!         auto&amp; formattingState = layoutState.formattingStateForBox(layoutBox);</span>
          for (auto&amp; child : childrenOfType&lt;Box&gt;(downcast&lt;Container&gt;(layoutBox))) {
              if (child.isOutOfFlowPositioned())
                  continue;
              auto childIntrinsicWidthConstraints = formattingState.intrinsicWidthConstraintsForBox(child);
              ASSERT(childIntrinsicWidthConstraints);
<span class="line-new-header">--- 317,18 ---</span>
                  return { replacedWidth, replacedWidth };
              }
              return { };
          }
  
          if (!is&lt;Container&gt;(layoutBox) || !downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())
              return { };
  
<span class="line-added">+         if (layoutBox.establishesFormattingContext())</span>
<span class="line-added">+             return LayoutContext::createFormattingContext(downcast&lt;Container&gt;(layoutBox), layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added">+ </span>
          auto intrinsicWidthConstraints = IntrinsicWidthConstraints { };
<span class="line-modified">!         auto&amp; formattingState = layoutState().formattingStateForBox(layoutBox);</span>
          for (auto&amp; child : childrenOfType&lt;Box&gt;(downcast&lt;Container&gt;(layoutBox))) {
              if (child.isOutOfFlowPositioned())
                  continue;
              auto childIntrinsicWidthConstraints = formattingState.intrinsicWidthConstraintsForBox(child);
              ASSERT(childIntrinsicWidthConstraints);
</pre>
<center><a href="BlockFormattingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingContextQuirks.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
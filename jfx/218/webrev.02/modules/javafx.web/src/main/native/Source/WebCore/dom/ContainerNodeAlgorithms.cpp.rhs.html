<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ContainerNodeAlgorithms.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2015 Apple Inc. All rights reserved.
  6  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  7  * Copyright (C) 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  8  * Copyright (C) 2012 Google Inc. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ContainerNodeAlgorithms.h&quot;
 28 
 29 #include &quot;HTMLFrameOwnerElement.h&quot;
 30 #include &quot;HTMLTextAreaElement.h&quot;
 31 #include &quot;InspectorInstrumentation.h&quot;
 32 #include &quot;ScriptDisallowedScope.h&quot;
 33 #include &quot;ShadowRoot.h&quot;
 34 #include &quot;TypedElementDescendantIterator.h&quot;
 35 
 36 namespace WebCore {
 37 
<a name="1" id="anc1"></a><span class="line-modified"> 38 #if ASSERT_ENABLED</span>
 39 ContainerChildRemovalScope* ContainerChildRemovalScope::s_scope = nullptr;
 40 #endif
 41 
 42 enum class TreeScopeChange { Changed, DidNotChange };
 43 
 44 static void notifyNodeInsertedIntoDocument(ContainerNode&amp; parentOfInsertedTree, Node&amp; node, TreeScopeChange treeScopeChange, NodeVector&amp; postInsertionNotificationTargets)
 45 {
 46     ASSERT(parentOfInsertedTree.isConnected());
 47     ASSERT(!node.isConnected());
 48     if (node.insertedIntoAncestor(Node::InsertionType { /* connectedToDocument */ true, treeScopeChange == TreeScopeChange::Changed }, parentOfInsertedTree) == Node::InsertedIntoAncestorResult::NeedsPostInsertionCallback)
 49         postInsertionNotificationTargets.append(node);
 50 
 51     if (!is&lt;ContainerNode&gt;(node))
 52         return;
 53 
 54     for (RefPtr&lt;Node&gt; child = downcast&lt;ContainerNode&gt;(node).firstChild(); child; child = child-&gt;nextSibling()) {
 55         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(node.isConnected() &amp;&amp; child-&gt;parentNode() == &amp;node);
 56         notifyNodeInsertedIntoDocument(parentOfInsertedTree, *child, treeScopeChange, postInsertionNotificationTargets);
 57     }
 58 
 59     if (!is&lt;Element&gt;(node))
 60         return;
 61 
 62     if (RefPtr&lt;ShadowRoot&gt; root = downcast&lt;Element&gt;(node).shadowRoot()) {
 63         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(node.isConnected() &amp;&amp; root-&gt;host() == &amp;node);
 64         notifyNodeInsertedIntoDocument(parentOfInsertedTree, *root, TreeScopeChange::DidNotChange, postInsertionNotificationTargets);
 65     }
 66 }
 67 
 68 static void notifyNodeInsertedIntoTree(ContainerNode&amp; parentOfInsertedTree, Node&amp; node, TreeScopeChange treeScopeChange, NodeVector&amp; postInsertionNotificationTargets)
 69 {
 70     ASSERT(!parentOfInsertedTree.isConnected());
 71     ASSERT(!node.isConnected());
 72 
 73     if (node.insertedIntoAncestor(Node::InsertionType { /* connectedToDocument */ false, treeScopeChange == TreeScopeChange::Changed }, parentOfInsertedTree) == Node::InsertedIntoAncestorResult::NeedsPostInsertionCallback)
 74         postInsertionNotificationTargets.append(node);
 75 
 76     if (!is&lt;ContainerNode&gt;(node))
 77         return;
 78 
 79     for (RefPtr&lt;Node&gt; child = downcast&lt;ContainerNode&gt;(node).firstChild(); child; child = child-&gt;nextSibling())
 80         notifyNodeInsertedIntoTree(parentOfInsertedTree, *child, treeScopeChange, postInsertionNotificationTargets);
 81 
 82     if (!is&lt;Element&gt;(node))
 83         return;
 84 
 85     if (RefPtr&lt;ShadowRoot&gt; root = downcast&lt;Element&gt;(node).shadowRoot())
 86         notifyNodeInsertedIntoTree(parentOfInsertedTree, *root, TreeScopeChange::DidNotChange, postInsertionNotificationTargets);
 87 }
 88 
 89 NodeVector notifyChildNodeInserted(ContainerNode&amp; parentOfInsertedTree, Node&amp; node)
 90 {
 91     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
 92 
 93     InspectorInstrumentation::didInsertDOMNode(node.document(), node);
 94 
 95     Ref&lt;Document&gt; protectDocument(node.document());
 96     Ref&lt;Node&gt; protectNode(node);
 97 
 98     NodeVector postInsertionNotificationTargets;
 99 
100     // Tree scope has changed if the container node into which &quot;node&quot; is inserted is in a document or a shadow root.
101     auto treeScopeChange = parentOfInsertedTree.isInTreeScope() ? TreeScopeChange::Changed : TreeScopeChange::DidNotChange;
102     if (parentOfInsertedTree.isConnected())
103         notifyNodeInsertedIntoDocument(parentOfInsertedTree, node, treeScopeChange, postInsertionNotificationTargets);
104     else
105         notifyNodeInsertedIntoTree(parentOfInsertedTree, node, treeScopeChange, postInsertionNotificationTargets);
106 
107     return postInsertionNotificationTargets;
108 }
109 
110 static void notifyNodeRemovedFromDocument(ContainerNode&amp; oldParentOfRemovedTree, TreeScopeChange treeScopeChange, Node&amp; node)
111 {
112     ASSERT(oldParentOfRemovedTree.isConnected());
113     ASSERT(node.isConnected());
114     node.removedFromAncestor(Node::RemovalType { /* disconnectedFromDocument */ true, treeScopeChange == TreeScopeChange::Changed }, oldParentOfRemovedTree);
115 
116     if (!is&lt;ContainerNode&gt;(node))
117         return;
118 
119     for (RefPtr&lt;Node&gt; child = downcast&lt;ContainerNode&gt;(node).firstChild(); child; child = child-&gt;nextSibling()) {
120         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!node.isConnected() &amp;&amp; child-&gt;parentNode() == &amp;node);
121         notifyNodeRemovedFromDocument(oldParentOfRemovedTree, treeScopeChange, *child.get());
122     }
123 
124     if (!is&lt;Element&gt;(node))
125         return;
126 
127     if (RefPtr&lt;ShadowRoot&gt; root = downcast&lt;Element&gt;(node).shadowRoot()) {
128         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!node.isConnected() &amp;&amp; root-&gt;host() == &amp;node);
129         notifyNodeRemovedFromDocument(oldParentOfRemovedTree, TreeScopeChange::DidNotChange, *root.get());
130     }
131 }
132 
133 static void notifyNodeRemovedFromTree(ContainerNode&amp; oldParentOfRemovedTree, TreeScopeChange treeScopeChange, Node&amp; node)
134 {
135     ASSERT(!oldParentOfRemovedTree.isConnected());
136 
137     node.removedFromAncestor(Node::RemovalType { /* disconnectedFromDocument */ false, treeScopeChange == TreeScopeChange::Changed }, oldParentOfRemovedTree);
138 
139     if (!is&lt;ContainerNode&gt;(node))
140         return;
141 
142     for (RefPtr&lt;Node&gt; child = downcast&lt;ContainerNode&gt;(node).firstChild(); child; child = child-&gt;nextSibling())
143         notifyNodeRemovedFromTree(oldParentOfRemovedTree, treeScopeChange, *child);
144 
145     if (!is&lt;Element&gt;(node))
146         return;
147 
148     if (RefPtr&lt;ShadowRoot&gt; root = downcast&lt;Element&gt;(node).shadowRoot())
149         notifyNodeRemovedFromTree(oldParentOfRemovedTree, TreeScopeChange::DidNotChange, *root);
150 }
151 
152 void notifyChildNodeRemoved(ContainerNode&amp; oldParentOfRemovedTree, Node&amp; child)
153 {
154     // Assert that the caller of this function has an instance of ScriptDisallowedScope.
155     ASSERT(!isMainThread() || ScriptDisallowedScope::InMainThread::hasDisallowedScope());
156     ContainerChildRemovalScope removalScope(oldParentOfRemovedTree, child);
157 
158     // Tree scope has changed if the container node from which &quot;node&quot; is removed is in a document or a shadow root.
159     auto treeScopeChange = oldParentOfRemovedTree.isInTreeScope() ? TreeScopeChange::Changed : TreeScopeChange::DidNotChange;
160     if (child.isConnected())
161         notifyNodeRemovedFromDocument(oldParentOfRemovedTree, treeScopeChange, child);
162     else
163         notifyNodeRemovedFromTree(oldParentOfRemovedTree, treeScopeChange, child);
164 }
165 
166 void addChildNodesToDeletionQueue(Node*&amp; head, Node*&amp; tail, ContainerNode&amp; container)
167 {
168     // We have to tell all children that their parent has died.
169     RefPtr&lt;Node&gt; next = nullptr;
170     for (RefPtr&lt;Node&gt; node = container.firstChild(); node; node = next) {
171         ASSERT(!node-&gt;m_deletionHasBegun);
172 
173         next = node-&gt;nextSibling();
174         node-&gt;setNextSibling(nullptr);
175         node-&gt;setParentNode(nullptr);
176         container.setFirstChild(next.get());
177         if (next)
178             next-&gt;setPreviousSibling(nullptr);
179 
180         if (!node-&gt;refCount()) {
181 #ifndef NDEBUG
182             node-&gt;m_deletionHasBegun = true;
183 #endif
184             // Add the node to the list of nodes to be deleted.
185             // Reuse the nextSibling pointer for this purpose.
186             if (tail)
187                 tail-&gt;setNextSibling(node.get());
188             else
189                 head = node.get();
190 
191             tail = node.get();
192         } else {
193             node-&gt;setTreeScopeRecursively(container.document());
194             if (node-&gt;isInTreeScope())
195                 notifyChildNodeRemoved(container, *node);
196             ASSERT_WITH_SECURITY_IMPLICATION(!node-&gt;isInTreeScope());
197         }
198     }
199 
200     container.setLastChild(nullptr);
201 }
202 
203 void removeDetachedChildrenInContainer(ContainerNode&amp; container)
204 {
205     // List of nodes to be deleted.
206     Node* head = nullptr;
207     Node* tail = nullptr;
208 
209     addChildNodesToDeletionQueue(head, tail, container);
210 
211     Node* node;
212     Node* next;
213     while ((node = head)) {
214         ASSERT(node-&gt;m_deletionHasBegun);
215 
216         next = node-&gt;nextSibling();
217         node-&gt;setNextSibling(nullptr);
218 
219         head = next;
220         if (!next)
221             tail = nullptr;
222 
223         if (is&lt;ContainerNode&gt;(*node))
224             addChildNodesToDeletionQueue(head, tail, downcast&lt;ContainerNode&gt;(*node));
225 
226         delete node;
227     }
228 }
229 
230 #ifndef NDEBUG
231 static unsigned assertConnectedSubrameCountIsConsistent(ContainerNode&amp; node)
232 {
233     unsigned count = 0;
234 
235     if (is&lt;Element&gt;(node)) {
236         if (is&lt;HTMLFrameOwnerElement&gt;(node) &amp;&amp; downcast&lt;HTMLFrameOwnerElement&gt;(node).contentFrame())
237             ++count;
238 
239         if (ShadowRoot* root = downcast&lt;Element&gt;(node).shadowRoot())
240             count += assertConnectedSubrameCountIsConsistent(*root);
241     }
242 
243     for (auto&amp; child : childrenOfType&lt;Element&gt;(node))
244         count += assertConnectedSubrameCountIsConsistent(child);
245 
246     // If we undercount there&#39;s possibly a security bug since we&#39;d leave frames
247     // in subtrees outside the document.
248     ASSERT(node.connectedSubframeCount() &gt;= count);
249 
250     // If we overcount it&#39;s safe, but not optimal because it means we&#39;ll traverse
251     // through the document in disconnectSubframes looking for frames that have
252     // already been disconnected.
253     ASSERT(node.connectedSubframeCount() == count);
254 
255     return count;
256 }
257 #endif
258 
259 static void collectFrameOwners(Vector&lt;Ref&lt;HTMLFrameOwnerElement&gt;&gt;&amp; frameOwners, ContainerNode&amp; root)
260 {
261     auto elementDescendants = descendantsOfType&lt;Element&gt;(root);
262     auto it = elementDescendants.begin();
263     auto end = elementDescendants.end();
264     while (it != end) {
265         Element&amp; element = *it;
266         if (!element.connectedSubframeCount()) {
267             it.traverseNextSkippingChildren();
268             continue;
269         }
270 
271         if (is&lt;HTMLFrameOwnerElement&gt;(element))
272             frameOwners.append(downcast&lt;HTMLFrameOwnerElement&gt;(element));
273 
274         if (ShadowRoot* shadowRoot = element.shadowRoot())
275             collectFrameOwners(frameOwners, *shadowRoot);
276         ++it;
277     }
278 }
279 
280 void disconnectSubframes(ContainerNode&amp; root, SubframeDisconnectPolicy policy)
281 {
282 #ifndef NDEBUG
283     assertConnectedSubrameCountIsConsistent(root);
284 #endif
285     ASSERT(root.connectedSubframeCount());
286 
287     Vector&lt;Ref&lt;HTMLFrameOwnerElement&gt;&gt; frameOwners;
288 
289     if (policy == RootAndDescendants) {
290         if (is&lt;HTMLFrameOwnerElement&gt;(root))
291             frameOwners.append(downcast&lt;HTMLFrameOwnerElement&gt;(root));
292     }
293 
294     collectFrameOwners(frameOwners, root);
295 
296     if (auto* shadowRoot = root.shadowRoot())
297         collectFrameOwners(frameOwners, *shadowRoot);
298 
299     // Must disable frame loading in the subtree so an unload handler cannot
300     // insert more frames and create loaded frames in detached subtrees.
301     SubframeLoadingDisabler disabler(&amp;root);
302 
303     bool isFirst = true;
304     for (auto&amp; owner : frameOwners) {
305         // Don&#39;t need to traverse up the tree for the first owner since no
306         // script could have moved it.
307         if (isFirst || root.containsIncludingShadowDOM(&amp;owner.get()))
308             owner.get().disconnectContentFrame();
309         isFirst = false;
310     }
311 }
312 
313 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSPropertyAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2007, 2008, 2009, 2013, 2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2012, 2013 Adobe Systems Incorporated. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyAnimation.h&quot;
  32 
  33 #include &quot;CSSComputedStyleDeclaration.h&quot;
  34 #include &quot;CSSCrossfadeValue.h&quot;
  35 #include &quot;CSSFilterImageValue.h&quot;
  36 #include &quot;CSSImageGeneratorValue.h&quot;
  37 #include &quot;CSSImageValue.h&quot;
  38 #include &quot;CSSPrimitiveValue.h&quot;
  39 #include &quot;CSSPropertyBlendingClient.h&quot;
  40 #include &quot;CSSPropertyNames.h&quot;
  41 #include &quot;CachedImage.h&quot;
  42 #include &quot;CalculationValue.h&quot;
  43 #include &quot;ClipPathOperation.h&quot;
  44 #include &quot;FloatConversion.h&quot;
  45 #include &quot;FontCascade.h&quot;
  46 #include &quot;FontSelectionAlgorithm.h&quot;
  47 #include &quot;FontTaggedSettings.h&quot;
  48 #include &quot;GapLength.h&quot;
  49 #include &quot;IdentityTransformOperation.h&quot;
  50 #include &quot;Logging.h&quot;
  51 #include &quot;Matrix3DTransformOperation.h&quot;
  52 #include &quot;MatrixTransformOperation.h&quot;
  53 #include &quot;RenderBox.h&quot;
  54 #include &quot;RenderStyle.h&quot;
  55 #include &quot;StyleCachedImage.h&quot;
  56 #include &quot;StyleGeneratedImage.h&quot;
  57 #include &quot;StylePropertyShorthand.h&quot;
  58 #include &quot;StyleResolver.h&quot;
  59 #include &lt;algorithm&gt;
  60 #include &lt;memory&gt;
  61 #include &lt;wtf/MathExtras.h&gt;
  62 #include &lt;wtf/NeverDestroyed.h&gt;
  63 #include &lt;wtf/Noncopyable.h&gt;
  64 #include &lt;wtf/PointerComparison.h&gt;
  65 #include &lt;wtf/RefCounted.h&gt;
  66 #include &lt;wtf/text/TextStream.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 static inline int blendFunc(const CSSPropertyBlendingClient*, int from, int to, double progress)
  71 {
  72     return blend(from, to, progress);
  73 }
  74 
  75 static inline double blendFunc(const CSSPropertyBlendingClient*, double from, double to, double progress)
  76 {
  77     return blend(from, to, progress);
  78 }
  79 
  80 static inline float blendFunc(const CSSPropertyBlendingClient*, float from, float to, double progress)
  81 {
  82     return narrowPrecisionToFloat(from + (to - from) * progress);
  83 }
  84 
  85 static inline Color blendFunc(const CSSPropertyBlendingClient*, const Color&amp; from, const Color&amp; to, double progress)
  86 {
  87     return blend(from, to, progress);
  88 }
  89 
  90 static inline Length blendFunc(const CSSPropertyBlendingClient*, const Length&amp; from, const Length&amp; to, double progress)
  91 {
  92     return blend(from, to, progress);
  93 }
  94 
  95 static inline GapLength blendFunc(const CSSPropertyBlendingClient*, const GapLength&amp; from, const GapLength&amp; to, double progress)
  96 {
  97     return (from.isNormal() || to.isNormal()) ? to : blend(from.length(), to.length(), progress);
  98 }
  99 
 100 static inline LengthSize blendFunc(const CSSPropertyBlendingClient* anim, const LengthSize&amp; from, const LengthSize&amp; to, double progress)
 101 {
 102     return { blendFunc(anim, from.width, to.width, progress), blendFunc(anim, from.height, to.height, progress) };
 103 }
 104 
 105 static inline ShadowStyle blendFunc(const CSSPropertyBlendingClient* anim, ShadowStyle from, ShadowStyle to, double progress)
 106 {
 107     if (from == to)
 108         return to;
 109 
 110     double fromVal = from == ShadowStyle::Normal ? 1 : 0;
 111     double toVal = to == ShadowStyle::Normal ? 1 : 0;
 112     double result = blendFunc(anim, fromVal, toVal, progress);
 113     return result &gt; 0 ? ShadowStyle::Normal : ShadowStyle::Inset;
 114 }
 115 
 116 static inline std::unique_ptr&lt;ShadowData&gt; blendFunc(const CSSPropertyBlendingClient* anim, const ShadowData* from, const ShadowData* to, double progress)
 117 {
 118     ASSERT(from &amp;&amp; to);
 119     if (from-&gt;style() != to-&gt;style())
 120         return makeUnique&lt;ShadowData&gt;(*to);
 121 
 122     return makeUnique&lt;ShadowData&gt;(blend(from-&gt;location(), to-&gt;location(), progress),
 123         blend(from-&gt;radius(), to-&gt;radius(), progress),
 124         blend(from-&gt;spread(), to-&gt;spread(), progress),
 125         blendFunc(anim, from-&gt;style(), to-&gt;style(), progress),
 126         from-&gt;isWebkitBoxShadow(),
 127         blend(from-&gt;color(), to-&gt;color(), progress));
 128 }
 129 
 130 static inline TransformOperations blendFunc(const CSSPropertyBlendingClient* animation, const TransformOperations&amp; from, const TransformOperations&amp; to, double progress)
 131 {
 132     if (animation-&gt;transformFunctionListsMatch())
 133         return to.blendByMatchingOperations(from, progress);
 134     return to.blendByUsingMatrixInterpolation(from, progress, is&lt;RenderBox&gt;(animation-&gt;renderer()) ? downcast&lt;RenderBox&gt;(*animation-&gt;renderer()).borderBoxRect().size() : LayoutSize());
 135 }
 136 
 137 static inline RefPtr&lt;ClipPathOperation&gt; blendFunc(const CSSPropertyBlendingClient*, ClipPathOperation* from, ClipPathOperation* to, double progress)
 138 {
 139     if (!from || !to)
 140         return to;
 141 
 142     // Other clip-path operations than BasicShapes can not be animated.
 143     if (from-&gt;type() != ClipPathOperation::Shape || to-&gt;type() != ClipPathOperation::Shape)
 144         return to;
 145 
 146     const BasicShape&amp; fromShape = downcast&lt;ShapeClipPathOperation&gt;(*from).basicShape();
 147     const BasicShape&amp; toShape = downcast&lt;ShapeClipPathOperation&gt;(*to).basicShape();
 148 
 149     if (!fromShape.canBlend(toShape))
 150         return to;
 151 
 152     return ShapeClipPathOperation::create(toShape.blend(fromShape, progress));
 153 }
 154 
 155 static inline RefPtr&lt;ShapeValue&gt; blendFunc(const CSSPropertyBlendingClient*, ShapeValue* from, ShapeValue* to, double progress)
 156 {
 157     if (!from || !to)
 158         return to;
 159 
 160     if (from-&gt;type() != ShapeValue::Type::Shape || to-&gt;type() != ShapeValue::Type::Shape)
 161         return to;
 162 
 163     if (from-&gt;cssBox() != to-&gt;cssBox())
 164         return to;
 165 
 166     const BasicShape&amp; fromShape = *from-&gt;shape();
 167     const BasicShape&amp; toShape = *to-&gt;shape();
 168 
 169     if (!fromShape.canBlend(toShape))
 170         return to;
 171 
 172     return ShapeValue::create(toShape.blend(fromShape, progress), to-&gt;cssBox());
 173 }
 174 
 175 static inline RefPtr&lt;FilterOperation&gt; blendFunc(const CSSPropertyBlendingClient*, FilterOperation* fromOp, FilterOperation* toOp, double progress, bool blendToPassthrough = false)
 176 {
 177     ASSERT(toOp);
 178     return toOp-&gt;blend(fromOp, progress, blendToPassthrough);
 179 }
 180 
 181 static inline FilterOperations blendFilterOperations(const CSSPropertyBlendingClient* anim,  const FilterOperations&amp; from, const FilterOperations&amp; to, double progress)
 182 {
 183     FilterOperations result;
 184     size_t fromSize = from.operations().size();
 185     size_t toSize = to.operations().size();
 186     size_t size = std::max(fromSize, toSize);
 187     for (size_t i = 0; i &lt; size; i++) {
 188         RefPtr&lt;FilterOperation&gt; fromOp = (i &lt; fromSize) ? from.operations()[i].get() : 0;
 189         RefPtr&lt;FilterOperation&gt; toOp = (i &lt; toSize) ? to.operations()[i].get() : 0;
 190         RefPtr&lt;FilterOperation&gt; blendedOp = toOp ? blendFunc(anim, fromOp.get(), toOp.get(), progress) : (fromOp ? blendFunc(anim, 0, fromOp.get(), progress, true) : 0);
 191         if (blendedOp)
 192             result.operations().append(blendedOp);
 193         else {
 194             auto identityOp = PassthroughFilterOperation::create();
 195             if (progress &gt; 0.5)
 196                 result.operations().append(toOp ? toOp : WTFMove(identityOp));
 197             else
 198                 result.operations().append(fromOp ? fromOp : WTFMove(identityOp));
 199         }
 200     }
 201     return result;
 202 }
 203 
 204 static inline FilterOperations blendFunc(const CSSPropertyBlendingClient* anim, const FilterOperations&amp; from, const FilterOperations&amp; to, double progress, CSSPropertyID propertyID = CSSPropertyFilter)
 205 {
 206     FilterOperations result;
 207 
 208     // If we have a filter function list, use that to do a per-function animation.
 209 
 210     bool listsMatch = false;
 211     switch (propertyID) {
 212     case CSSPropertyFilter:
 213         listsMatch = anim-&gt;filterFunctionListsMatch();
 214         break;
 215 #if ENABLE(FILTERS_LEVEL_2)
 216     case CSSPropertyWebkitBackdropFilter:
 217         listsMatch = anim-&gt;backdropFilterFunctionListsMatch();
 218         break;
 219 #endif
 220     case CSSPropertyAppleColorFilter:
 221         listsMatch = anim-&gt;colorFilterFunctionListsMatch();
 222         break;
 223     default:
 224         break;
 225     }
 226 
 227     if (listsMatch)
 228         result = blendFilterOperations(anim, from, to, progress);
 229     else {
 230         // If the filter function lists don&#39;t match, we could try to cross-fade, but don&#39;t yet have a way to represent that in CSS.
 231         // For now we&#39;ll just fail to animate.
 232         result = to;
 233     }
 234 
 235     return result;
 236 }
 237 
 238 static inline RefPtr&lt;StyleImage&gt; blendFilter(const CSSPropertyBlendingClient* anim, CachedImage* image, const FilterOperations&amp; from, const FilterOperations&amp; to, double progress)
 239 {
 240     ASSERT(image);
 241     FilterOperations filterResult = blendFilterOperations(anim, from, to, progress);
 242 
 243     auto imageValue = CSSImageValue::create(*image);
 244     auto filterValue = ComputedStyleExtractor::valueForFilter(anim-&gt;currentStyle(), filterResult, DoNotAdjustPixelValues);
 245 
 246     auto result = CSSFilterImageValue::create(WTFMove(imageValue), WTFMove(filterValue));
 247     result.get().setFilterOperations(filterResult);
 248     return StyleGeneratedImage::create(WTFMove(result));
 249 }
 250 
 251 static inline Visibility blendFunc(const CSSPropertyBlendingClient* anim, Visibility from, Visibility to, double progress)
 252 {
 253     // Any non-zero result means we consider the object to be visible. Only at 0 do we consider the object to be
 254     // invisible. The invisible value we use (Visibility::Hidden vs. Visibility::Collapse) depends on the specified from/to values.
 255     double fromVal = from == Visibility::Visible ? 1. : 0.;
 256     double toVal = to == Visibility::Visible ? 1. : 0.;
 257     if (fromVal == toVal)
 258         return to;
 259     double result = blendFunc(anim, fromVal, toVal, progress);
 260     return result &gt; 0. ? Visibility::Visible : (to != Visibility::Visible ? to : from);
 261 }
 262 
 263 static inline TextUnderlineOffset blendFunc(const CSSPropertyBlendingClient* anim, const TextUnderlineOffset&amp; from, const TextUnderlineOffset&amp; to, double progress)
 264 {
 265     if (from.isLength() &amp;&amp; to.isLength())
 266         return TextUnderlineOffset::createWithLength(blendFunc(anim, from.lengthValue(), to.lengthValue(), progress));
 267     return TextUnderlineOffset::createWithAuto();
 268 }
 269 
 270 static inline TextDecorationThickness blendFunc(const CSSPropertyBlendingClient* anim, const TextDecorationThickness&amp; from, const TextDecorationThickness&amp; to, double progress)
 271 {
 272     if (from.isLength() &amp;&amp; to.isLength())
 273         return TextDecorationThickness::createWithLength(blendFunc(anim, from.lengthValue(), to.lengthValue(), progress));
 274     return TextDecorationThickness::createWithAuto();
 275 }
 276 
 277 static inline LengthBox blendFunc(const CSSPropertyBlendingClient* anim, const LengthBox&amp; from, const LengthBox&amp; to, double progress)
 278 {
 279     LengthBox result(blendFunc(anim, from.top(), to.top(), progress),
 280                      blendFunc(anim, from.right(), to.right(), progress),
 281                      blendFunc(anim, from.bottom(), to.bottom(), progress),
 282                      blendFunc(anim, from.left(), to.left(), progress));
 283     return result;
 284 }
 285 
 286 static inline SVGLengthValue blendFunc(const CSSPropertyBlendingClient*, const SVGLengthValue&amp; from, const SVGLengthValue&amp; to, double progress)
 287 {
 288     return SVGLengthValue::blend(from, to, narrowPrecisionToFloat(progress));
 289 }
 290 
 291 static inline Vector&lt;SVGLengthValue&gt; blendFunc(const CSSPropertyBlendingClient*, const Vector&lt;SVGLengthValue&gt;&amp; from, const Vector&lt;SVGLengthValue&gt;&amp; to, double progress)
 292 {
 293     size_t fromLength = from.size();
 294     size_t toLength = to.size();
 295     if (!fromLength)
 296         return !progress ? from : to;
 297     if (!toLength)
 298         return progress == 1 ? from : to;
 299     size_t resultLength = fromLength;
 300     if (fromLength != toLength) {
 301         if (!remainder(std::max(fromLength, toLength), std::min(fromLength, toLength)))
 302             resultLength = std::max(fromLength, toLength);
 303         else
 304             resultLength = fromLength * toLength;
 305     }
 306     Vector&lt;SVGLengthValue&gt; result(resultLength);
 307     for (size_t i = 0; i &lt; resultLength; ++i)
 308         result[i] = SVGLengthValue::blend(from[i % fromLength], to[i % toLength], narrowPrecisionToFloat(progress));
 309     return result;
 310 }
 311 
 312 static inline RefPtr&lt;StyleImage&gt; crossfadeBlend(const CSSPropertyBlendingClient*, StyleCachedImage* fromStyleImage, StyleCachedImage* toStyleImage, double progress)
 313 {
 314     // If progress is at one of the extremes, we want getComputedStyle to show the image,
 315     // not a completed cross-fade, so we hand back one of the existing images.
 316     if (!progress)
 317         return fromStyleImage;
 318     if (progress == 1)
 319         return toStyleImage;
 320     if (!fromStyleImage-&gt;cachedImage() || !toStyleImage-&gt;cachedImage())
 321         return toStyleImage;
 322 
 323     auto fromImageValue = CSSImageValue::create(*fromStyleImage-&gt;cachedImage());
 324     auto toImageValue = CSSImageValue::create(*toStyleImage-&gt;cachedImage());
 325     auto percentageValue = CSSPrimitiveValue::create(progress, CSSUnitType::CSS_NUMBER);
 326 
 327     auto crossfadeValue = CSSCrossfadeValue::create(WTFMove(fromImageValue), WTFMove(toImageValue), WTFMove(percentageValue));
 328     return StyleGeneratedImage::create(WTFMove(crossfadeValue));
 329 }
 330 
 331 static inline RefPtr&lt;StyleImage&gt; blendFunc(const CSSPropertyBlendingClient* anim, StyleImage* from, StyleImage* to, double progress)
 332 {
 333     if (!from || !to)
 334         return to;
 335 
 336     from = from-&gt;selectedImage();
 337     to = to-&gt;selectedImage();
 338 
 339     if (!from || !to)
 340         return to;
 341 
 342     // Animation between two generated images. Cross fade for all other cases.
 343     if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
 344         CSSImageGeneratorValue&amp; fromGenerated = downcast&lt;StyleGeneratedImage&gt;(*from).imageValue();
 345         CSSImageGeneratorValue&amp; toGenerated = downcast&lt;StyleGeneratedImage&gt;(*to).imageValue();
 346 
 347         if (is&lt;CSSFilterImageValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSFilterImageValue&gt;(toGenerated)) {
 348             // Animation of generated images just possible if input images are equal.
 349             // Otherwise fall back to cross fade animation.
 350             CSSFilterImageValue&amp; fromFilter = downcast&lt;CSSFilterImageValue&gt;(fromGenerated);
 351             CSSFilterImageValue&amp; toFilter = downcast&lt;CSSFilterImageValue&gt;(toGenerated);
 352             if (fromFilter.equalInputImages(toFilter) &amp;&amp; fromFilter.cachedImage())
 353                 return blendFilter(anim, fromFilter.cachedImage(), fromFilter.filterOperations(), toFilter.filterOperations(), progress);
 354         }
 355 
 356         if (is&lt;CSSCrossfadeValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSCrossfadeValue&gt;(toGenerated)) {
 357             CSSCrossfadeValue&amp; fromCrossfade = downcast&lt;CSSCrossfadeValue&gt;(fromGenerated);
 358             CSSCrossfadeValue&amp; toCrossfade = downcast&lt;CSSCrossfadeValue&gt;(toGenerated);
 359             if (fromCrossfade.equalInputImages(toCrossfade)) {
 360                 if (auto crossfadeBlend = toCrossfade.blend(fromCrossfade, progress))
 361                     return StyleGeneratedImage::create(*crossfadeBlend);
 362             }
 363         }
 364 
 365         // FIXME: Add support for animation between two *gradient() functions.
 366         // https://bugs.webkit.org/show_bug.cgi?id=119956
 367     } else if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleCachedImage&gt;(*to)) {
 368         CSSImageGeneratorValue&amp; fromGenerated = downcast&lt;StyleGeneratedImage&gt;(*from).imageValue();
 369         if (is&lt;CSSFilterImageValue&gt;(fromGenerated)) {
 370             CSSFilterImageValue&amp; fromFilter = downcast&lt;CSSFilterImageValue&gt;(fromGenerated);
 371             if (fromFilter.cachedImage() &amp;&amp; downcast&lt;StyleCachedImage&gt;(*to).cachedImage() == fromFilter.cachedImage())
 372                 return blendFilter(anim, fromFilter.cachedImage(), fromFilter.filterOperations(), FilterOperations(), progress);
 373         }
 374         // FIXME: Add interpolation between cross-fade and image source.
 375     } else if (is&lt;StyleCachedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
 376         CSSImageGeneratorValue&amp; toGenerated = downcast&lt;StyleGeneratedImage&gt;(*to).imageValue();
 377         if (is&lt;CSSFilterImageValue&gt;(toGenerated)) {
 378             CSSFilterImageValue&amp; toFilter = downcast&lt;CSSFilterImageValue&gt;(toGenerated);
 379             if (toFilter.cachedImage() &amp;&amp; downcast&lt;StyleCachedImage&gt;(*from).cachedImage() == toFilter.cachedImage())
 380                 return blendFilter(anim, toFilter.cachedImage(), FilterOperations(), toFilter.filterOperations(), progress);
 381         }
 382         // FIXME: Add interpolation between image source and cross-fade.
 383     }
 384 
 385     // FIXME: Add support cross fade between cached and generated images.
 386     // https://bugs.webkit.org/show_bug.cgi?id=78293
 387     if (is&lt;StyleCachedImage&gt;(*from) &amp;&amp; is&lt;StyleCachedImage&gt;(*to))
 388         return crossfadeBlend(anim, downcast&lt;StyleCachedImage&gt;(from), downcast&lt;StyleCachedImage&gt;(to), progress);
 389 
 390     return to;
 391 }
 392 
 393 static inline NinePieceImage blendFunc(const CSSPropertyBlendingClient* anim, const NinePieceImage&amp; from, const NinePieceImage&amp; to, double progress)
 394 {
 395     if (!from.hasImage() || !to.hasImage())
 396         return to;
 397 
 398     // FIXME (74112): Support transitioning between NinePieceImages that differ by more than image content.
 399 
 400     if (from.imageSlices() != to.imageSlices() || from.borderSlices() != to.borderSlices() || from.outset() != to.outset() || from.fill() != to.fill() || from.horizontalRule() != to.horizontalRule() || from.verticalRule() != to.verticalRule())
 401         return to;
 402 
 403     if (auto* renderer = anim-&gt;renderer()) {
 404         if (from.image()-&gt;imageSize(renderer, 1.0) != to.image()-&gt;imageSize(renderer, 1.0))
 405             return to;
 406     }
 407 
 408     return NinePieceImage(blendFunc(anim, from.image(), to.image(), progress),
 409         from.imageSlices(), from.fill(), from.borderSlices(), from.outset(), from.horizontalRule(), from.verticalRule());
 410 }
 411 
 412 #if ENABLE(VARIATION_FONTS)
 413 
 414 static inline FontVariationSettings blendFunc(const CSSPropertyBlendingClient* anim, const FontVariationSettings&amp; from, const FontVariationSettings&amp; to, double progress)
 415 {
 416     if (from.size() != to.size())
 417         return FontVariationSettings();
 418     FontVariationSettings result;
 419     unsigned size = from.size();
 420     for (unsigned i = 0; i &lt; size; ++i) {
 421         auto&amp; fromItem = from.at(i);
 422         auto&amp; toItem = to.at(i);
 423         if (fromItem.tag() != toItem.tag())
 424             return FontVariationSettings();
 425         float interpolated = blendFunc(anim, fromItem.value(), toItem.value(), progress);
 426         result.insert({ fromItem.tag(), interpolated });
 427     }
 428     return result;
 429 }
 430 
 431 #endif
 432 
 433 static inline FontSelectionValue blendFunc(const CSSPropertyBlendingClient* anim, FontSelectionValue from, FontSelectionValue to, double progress)
 434 {
 435     return FontSelectionValue(blendFunc(anim, static_cast&lt;float&gt;(from), static_cast&lt;float&gt;(to), progress));
 436 }
 437 
 438 static inline Optional&lt;FontSelectionValue&gt; blendFunc(const CSSPropertyBlendingClient* anim, Optional&lt;FontSelectionValue&gt; from, Optional&lt;FontSelectionValue&gt; to, double progress)
 439 {
 440     return FontSelectionValue(blendFunc(anim, static_cast&lt;float&gt;(from.value()), static_cast&lt;float&gt;(to.value()), progress));
 441 }
 442 
 443 class AnimationPropertyWrapperBase {
 444     WTF_MAKE_NONCOPYABLE(AnimationPropertyWrapperBase);
 445     WTF_MAKE_FAST_ALLOCATED;
 446 public:
 447     explicit AnimationPropertyWrapperBase(CSSPropertyID prop)
 448         : m_prop(prop)
 449     {
 450     }
 451     virtual ~AnimationPropertyWrapperBase() = default;
 452 
 453     virtual bool isShorthandWrapper() const { return false; }
 454     virtual bool equals(const RenderStyle* a, const RenderStyle* b) const = 0;
 455     virtual bool canInterpolate(const RenderStyle*, const RenderStyle*) const { return true; }
 456     virtual void blend(const CSSPropertyBlendingClient*, RenderStyle*, const RenderStyle*, const RenderStyle*, double) const = 0;
 457 
 458 #if !LOG_DISABLED
 459     virtual void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double) const = 0;
 460 #endif
 461 
 462     CSSPropertyID property() const { return m_prop; }
 463 
 464     virtual bool animationIsAccelerated() const { return false; }
 465 
 466 private:
 467     CSSPropertyID m_prop;
 468 };
 469 
 470 template &lt;typename T&gt;
 471 class PropertyWrapperGetter : public AnimationPropertyWrapperBase {
 472     WTF_MAKE_FAST_ALLOCATED;
 473 public:
 474     PropertyWrapperGetter(CSSPropertyID prop, T (RenderStyle::*getter)() const)
 475         : AnimationPropertyWrapperBase(prop)
 476         , m_getter(getter)
 477     {
 478     }
 479 
 480     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 481     {
 482         if (a == b)
 483             return true;
 484         if (!a || !b)
 485             return false;
 486         return (a-&gt;*m_getter)() == (b-&gt;*m_getter)();
 487     }
 488 
 489     T value(const RenderStyle* a) const
 490     {
 491         return (a-&gt;*m_getter)();
 492     }
 493 
 494 #if !LOG_DISABLED
 495     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double progress) const final
 496     {
 497         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
 498     }
 499 #endif
 500 
 501 protected:
 502     T (RenderStyle::*m_getter)() const;
 503 };
 504 
 505 template &lt;typename T&gt;
 506 class PropertyWrapper : public PropertyWrapperGetter&lt;T&gt; {
 507     WTF_MAKE_FAST_ALLOCATED;
 508 public:
 509     PropertyWrapper(CSSPropertyID prop, T (RenderStyle::*getter)() const, void (RenderStyle::*setter)(T))
 510         : PropertyWrapperGetter&lt;T&gt;(prop, getter)
 511         , m_setter(setter)
 512     {
 513     }
 514 
 515     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 516     {
 517         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;T&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;T&gt;::m_getter)(), progress));
 518     }
 519 
 520 protected:
 521     void (RenderStyle::*m_setter)(T);
 522 };
 523 
 524 template &lt;typename T&gt;
 525 class RefCountedPropertyWrapper : public PropertyWrapperGetter&lt;T*&gt; {
 526     WTF_MAKE_FAST_ALLOCATED;
 527 public:
 528     RefCountedPropertyWrapper(CSSPropertyID prop, T* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;T&gt;&amp;&amp;))
 529         : PropertyWrapperGetter&lt;T*&gt;(prop, getter)
 530         , m_setter(setter)
 531     {
 532     }
 533 
 534     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 535     {
 536         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;T*&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;T*&gt;::m_getter)(), progress));
 537     }
 538 
 539 protected:
 540     void (RenderStyle::*m_setter)(RefPtr&lt;T&gt;&amp;&amp;);
 541 };
 542 
 543 class LengthPropertyWrapper : public PropertyWrapperGetter&lt;const Length&amp;&gt; {
 544     WTF_MAKE_FAST_ALLOCATED;
 545 public:
 546     LengthPropertyWrapper(CSSPropertyID prop, const Length&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(Length&amp;&amp;))
 547         : PropertyWrapperGetter&lt;const Length&amp;&gt;(prop, getter)
 548         , m_setter(setter)
 549     {
 550     }
 551 
 552     bool canInterpolate(const RenderStyle* a, const RenderStyle* b) const override
 553     {
 554         return !(a-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)().isAuto() &amp;&amp; !(b-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)().isAuto();
 555     }
 556 
 557     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 558     {
 559         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)(), progress));
 560     }
 561 
 562 protected:
 563     void (RenderStyle::*m_setter)(Length&amp;&amp;);
 564 };
 565 
 566 template &lt;typename T&gt;
 567 class LengthVariantPropertyWrapper : public PropertyWrapperGetter&lt;const T&amp;&gt; {
 568     WTF_MAKE_FAST_ALLOCATED;
 569 public:
 570     LengthVariantPropertyWrapper(CSSPropertyID prop, const T&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(T&amp;&amp;))
 571         : PropertyWrapperGetter&lt;const T&amp;&gt;(prop, getter)
 572         , m_setter(setter)
 573     {
 574     }
 575 
 576     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 577     {
 578         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), progress));
 579     }
 580 
 581 protected:
 582     void (RenderStyle::*m_setter)(T&amp;&amp;);
 583 };
 584 
 585 class PropertyWrapperClipPath : public RefCountedPropertyWrapper&lt;ClipPathOperation&gt; {
 586     WTF_MAKE_FAST_ALLOCATED;
 587 public:
 588     PropertyWrapperClipPath(CSSPropertyID prop, ClipPathOperation* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;ClipPathOperation&gt;&amp;&amp;))
 589         : RefCountedPropertyWrapper&lt;ClipPathOperation&gt;(prop, getter, setter)
 590     {
 591     }
 592 
 593     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 594     {
 595         // If the style pointers are the same, don&#39;t bother doing the test.
 596         // If either is null, return false. If both are null, return true.
 597         if (a == b)
 598             return true;
 599         if (!a || !b)
 600             return false;
 601 
 602         ClipPathOperation* clipPathA = (a-&gt;*m_getter)();
 603         ClipPathOperation* clipPathB = (b-&gt;*m_getter)();
 604         if (clipPathA == clipPathB)
 605             return true;
 606         if (!clipPathA || !clipPathB)
 607             return false;
 608         return *clipPathA == *clipPathB;
 609     }
 610 };
 611 
 612 #if ENABLE(VARIATION_FONTS)
 613 class PropertyWrapperFontVariationSettings : public PropertyWrapper&lt;FontVariationSettings&gt; {
 614     WTF_MAKE_FAST_ALLOCATED;
 615 public:
 616     PropertyWrapperFontVariationSettings(CSSPropertyID prop, FontVariationSettings (RenderStyle::*getter)() const, void (RenderStyle::*setter)(FontVariationSettings))
 617         : PropertyWrapper&lt;FontVariationSettings&gt;(prop, getter, setter)
 618     {
 619     }
 620 
 621     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 622     {
 623         // If the style pointers are the same, don&#39;t bother doing the test.
 624         // If either is null, return false. If both are null, return true.
 625         if (a == b)
 626             return true;
 627         if (!a || !b)
 628             return false;
 629 
 630         const FontVariationSettings&amp; variationSettingsA = (a-&gt;*m_getter)();
 631         const FontVariationSettings&amp; variationSettingsB = (b-&gt;*m_getter)();
 632         return variationSettingsA == variationSettingsB;
 633     }
 634 };
 635 #endif
 636 
 637 class PropertyWrapperShape : public RefCountedPropertyWrapper&lt;ShapeValue&gt; {
 638     WTF_MAKE_FAST_ALLOCATED;
 639 public:
 640     PropertyWrapperShape(CSSPropertyID prop, ShapeValue* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;ShapeValue&gt;&amp;&amp;))
 641         : RefCountedPropertyWrapper&lt;ShapeValue&gt;(prop, getter, setter)
 642     {
 643     }
 644 
 645     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 646     {
 647         // If the style pointers are the same, don&#39;t bother doing the test.
 648         // If either is null, return false. If both are null, return true.
 649         if (a == b)
 650             return true;
 651         if (!a || !b)
 652             return false;
 653 
 654         ShapeValue* shapeA = (a-&gt;*m_getter)();
 655         ShapeValue* shapeB = (b-&gt;*m_getter)();
 656         if (shapeA == shapeB)
 657             return true;
 658         if (!shapeA || !shapeB)
 659             return false;
 660         return *shapeA == *shapeB;
 661     }
 662 };
 663 
 664 class StyleImagePropertyWrapper : public RefCountedPropertyWrapper&lt;StyleImage&gt; {
 665     WTF_MAKE_FAST_ALLOCATED;
 666 public:
 667     StyleImagePropertyWrapper(CSSPropertyID prop, StyleImage* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(RefPtr&lt;StyleImage&gt;&amp;&amp;))
 668         : RefCountedPropertyWrapper&lt;StyleImage&gt;(prop, getter, setter)
 669     {
 670     }
 671 
 672     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 673     {
 674        if (a == b)
 675            return true;
 676        if (!a || !b)
 677             return false;
 678 
 679         StyleImage* imageA = (a-&gt;*m_getter)();
 680         StyleImage* imageB = (b-&gt;*m_getter)();
 681         return arePointingToEqualData(imageA, imageB);
 682     }
 683 };
 684 
 685 class PropertyWrapperColor : public PropertyWrapperGetter&lt;const Color&amp;&gt; {
 686     WTF_MAKE_FAST_ALLOCATED;
 687 public:
 688     PropertyWrapperColor(CSSPropertyID prop, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;))
 689         : PropertyWrapperGetter&lt;const Color&amp;&gt;(prop, getter)
 690         , m_setter(setter)
 691     {
 692     }
 693 
 694     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 695     {
 696         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const Color&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const Color&amp;&gt;::m_getter)(), progress));
 697     }
 698 
 699 protected:
 700     void (RenderStyle::*m_setter)(const Color&amp;);
 701 };
 702 
 703 class PropertyWrapperAcceleratedOpacity : public PropertyWrapper&lt;float&gt; {
 704     WTF_MAKE_FAST_ALLOCATED;
 705 public:
 706     PropertyWrapperAcceleratedOpacity()
 707         : PropertyWrapper&lt;float&gt;(CSSPropertyOpacity, &amp;RenderStyle::opacity, &amp;RenderStyle::setOpacity)
 708     {
 709     }
 710 
 711     bool animationIsAccelerated() const override { return true; }
 712 
 713     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 714     {
 715         dst-&gt;setOpacity(blendFunc(anim, a-&gt;opacity(), b-&gt;opacity(), progress));
 716     }
 717 };
 718 
 719 class PropertyWrapperAcceleratedTransform : public PropertyWrapper&lt;const TransformOperations&amp;&gt; {
 720     WTF_MAKE_FAST_ALLOCATED;
 721 public:
 722     PropertyWrapperAcceleratedTransform()
 723         : PropertyWrapper&lt;const TransformOperations&amp;&gt;(CSSPropertyTransform, &amp;RenderStyle::transform, &amp;RenderStyle::setTransform)
 724     {
 725     }
 726 
 727     bool animationIsAccelerated() const override { return true; }
 728 
 729     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 730     {
 731         dst-&gt;setTransform(blendFunc(anim, a-&gt;transform(), b-&gt;transform(), progress));
 732     }
 733 };
 734 
 735 class PropertyWrapperFilter : public PropertyWrapper&lt;const FilterOperations&amp;&gt; {
 736     WTF_MAKE_FAST_ALLOCATED;
 737 public:
 738     PropertyWrapperFilter(CSSPropertyID propertyID, const FilterOperations&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const FilterOperations&amp;))
 739         : PropertyWrapper&lt;const FilterOperations&amp;&gt;(propertyID, getter, setter)
 740     {
 741     }
 742 
 743     bool animationIsAccelerated() const override
 744     {
 745         return property() == CSSPropertyFilter
 746 #if ENABLE(FILTERS_LEVEL_2)
 747             || property() == CSSPropertyWebkitBackdropFilter
 748 #endif
 749             ;
 750     }
 751 
 752     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 753     {
 754         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), progress, property()));
 755     }
 756 };
 757 
 758 static inline size_t shadowListLength(const ShadowData* shadow)
 759 {
 760     size_t count;
 761     for (count = 0; shadow; shadow = shadow-&gt;next())
 762         ++count;
 763     return count;
 764 }
 765 
 766 static inline const ShadowData* shadowForBlending(const ShadowData* srcShadow, const ShadowData* otherShadow)
 767 {
 768     static NeverDestroyed&lt;ShadowData&gt; defaultShadowData(LayoutPoint(), 0, 0, ShadowStyle::Normal, false, Color::transparent);
 769     static NeverDestroyed&lt;ShadowData&gt; defaultInsetShadowData(LayoutPoint(), 0, 0, ShadowStyle::Inset, false, Color::transparent);
 770     static NeverDestroyed&lt;ShadowData&gt; defaultWebKitBoxShadowData(LayoutPoint(), 0, 0, ShadowStyle::Normal, true, Color::transparent);
 771     static NeverDestroyed&lt;ShadowData&gt; defaultInsetWebKitBoxShadowData(LayoutPoint(), 0, 0, ShadowStyle::Inset, true, Color::transparent);
 772 
 773     if (srcShadow)
 774         return srcShadow;
 775 
 776     if (otherShadow-&gt;style() == ShadowStyle::Inset)
 777         return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultInsetWebKitBoxShadowData.get() : &amp;defaultInsetShadowData.get();
 778 
 779     return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultWebKitBoxShadowData.get() : &amp;defaultShadowData.get();
 780 }
 781 
 782 class PropertyWrapperShadow : public AnimationPropertyWrapperBase {
 783     WTF_MAKE_FAST_ALLOCATED;
 784 public:
 785     PropertyWrapperShadow(CSSPropertyID prop, const ShadowData* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(std::unique_ptr&lt;ShadowData&gt;, bool))
 786         : AnimationPropertyWrapperBase(prop)
 787         , m_getter(getter)
 788         , m_setter(setter)
 789     {
 790     }
 791 
 792     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 793     {
 794         if (a == b)
 795             return true;
 796         if (!a || !b)
 797             return false;
 798 
 799         const ShadowData* shadowA = (a-&gt;*m_getter)();
 800         const ShadowData* shadowB = (b-&gt;*m_getter)();
 801 
 802         while (true) {
 803             // end of both lists
 804             if (!shadowA &amp;&amp; !shadowB)
 805                 return true;
 806 
 807             // end of just one of the lists
 808             if (!shadowA || !shadowB)
 809                 return false;
 810 
 811             if (*shadowA != *shadowB)
 812                 return false;
 813 
 814             shadowA = shadowA-&gt;next();
 815             shadowB = shadowB-&gt;next();
 816         }
 817 
 818         return true;
 819     }
 820 
 821     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 822     {
 823         const ShadowData* shadowA = (a-&gt;*m_getter)();
 824         const ShadowData* shadowB = (b-&gt;*m_getter)();
 825 
 826         int fromLength = shadowListLength(shadowA);
 827         int toLength = shadowListLength(shadowB);
 828 
 829         if (fromLength == toLength || (fromLength &lt;= 1 &amp;&amp; toLength &lt;= 1)) {
 830             (dst-&gt;*m_setter)(blendSimpleOrMatchedShadowLists(anim, progress, shadowA, shadowB), false);
 831             return;
 832         }
 833 
 834         (dst-&gt;*m_setter)(blendMismatchedShadowLists(anim, progress, shadowA, shadowB, fromLength, toLength), false);
 835     }
 836 
 837 #if !LOG_DISABLED
 838     void logBlend(const RenderStyle*, const RenderStyle*, const RenderStyle*, double progress) const final
 839     {
 840         // FIXME: better logging.
 841         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending ShadowData at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress));
 842     }
 843 #endif
 844 
 845 private:
 846     std::unique_ptr&lt;ShadowData&gt; blendSimpleOrMatchedShadowLists(const CSSPropertyBlendingClient* anim, double progress, const ShadowData* shadowA, const ShadowData* shadowB) const
 847     {
 848         std::unique_ptr&lt;ShadowData&gt; newShadowData;
 849         ShadowData* lastShadow = 0;
 850 
 851         while (shadowA || shadowB) {
 852             const ShadowData* srcShadow = shadowForBlending(shadowA, shadowB);
 853             const ShadowData* dstShadow = shadowForBlending(shadowB, shadowA);
 854 
 855             std::unique_ptr&lt;ShadowData&gt; blendedShadow = blendFunc(anim, srcShadow, dstShadow, progress);
 856             ShadowData* blendedShadowPtr = blendedShadow.get();
 857 
 858             if (!lastShadow)
 859                 newShadowData = WTFMove(blendedShadow);
 860             else
 861                 lastShadow-&gt;setNext(WTFMove(blendedShadow));
 862 
 863             lastShadow = blendedShadowPtr;
 864 
 865             shadowA = shadowA ? shadowA-&gt;next() : 0;
 866             shadowB = shadowB ? shadowB-&gt;next() : 0;
 867         }
 868 
 869         return newShadowData;
 870     }
 871 
 872     std::unique_ptr&lt;ShadowData&gt; blendMismatchedShadowLists(const CSSPropertyBlendingClient* anim, double progress, const ShadowData* shadowA, const ShadowData* shadowB, int fromLength, int toLength) const
 873     {
 874         // The shadows in ShadowData are stored in reverse order, so when animating mismatched lists,
 875         // reverse them and match from the end.
 876         Vector&lt;const ShadowData*, 4&gt; fromShadows(fromLength);
 877         for (int i = fromLength - 1; i &gt;= 0; --i) {
 878             fromShadows[i] = shadowA;
 879             shadowA = shadowA-&gt;next();
 880         }
 881 
 882         Vector&lt;const ShadowData*, 4&gt; toShadows(toLength);
 883         for (int i = toLength - 1; i &gt;= 0; --i) {
 884             toShadows[i] = shadowB;
 885             shadowB = shadowB-&gt;next();
 886         }
 887 
 888         std::unique_ptr&lt;ShadowData&gt; newShadowData;
 889 
 890         int maxLength = std::max(fromLength, toLength);
 891         for (int i = 0; i &lt; maxLength; ++i) {
 892             const ShadowData* fromShadow = i &lt; fromLength ? fromShadows[i] : 0;
 893             const ShadowData* toShadow = i &lt; toLength ? toShadows[i] : 0;
 894 
 895             const ShadowData* srcShadow = shadowForBlending(fromShadow, toShadow);
 896             const ShadowData* dstShadow = shadowForBlending(toShadow, fromShadow);
 897 
 898             std::unique_ptr&lt;ShadowData&gt; blendedShadow = blendFunc(anim, srcShadow, dstShadow, progress);
 899             // Insert at the start of the list to preserve the order.
 900             blendedShadow-&gt;setNext(WTFMove(newShadowData));
 901             newShadowData = WTFMove(blendedShadow);
 902         }
 903 
 904         return newShadowData;
 905     }
 906 
 907     const ShadowData* (RenderStyle::*m_getter)() const;
 908     void (RenderStyle::*m_setter)(std::unique_ptr&lt;ShadowData&gt;, bool);
 909 };
 910 
 911 class PropertyWrapperMaybeInvalidColor : public AnimationPropertyWrapperBase {
 912     WTF_MAKE_FAST_ALLOCATED;
 913 public:
 914     PropertyWrapperMaybeInvalidColor(CSSPropertyID prop, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;))
 915         : AnimationPropertyWrapperBase(prop)
 916         , m_getter(getter)
 917         , m_setter(setter)
 918     {
 919     }
 920 
 921     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 922     {
 923         if (a == b)
 924             return true;
 925         if (!a || !b)
 926             return false;
 927 
 928         Color fromColor = value(a);
 929         Color toColor = value(b);
 930 
 931         if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
 932             return true;
 933 
 934         if (!fromColor.isValid())
 935             fromColor = a-&gt;color();
 936         if (!toColor.isValid())
 937             toColor = b-&gt;color();
 938 
 939         return fromColor == toColor;
 940     }
 941 
 942     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 943     {
 944         Color fromColor = value(a);
 945         Color toColor = value(b);
 946 
 947         if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
 948             return;
 949 
 950         if (!fromColor.isValid())
 951             fromColor = a-&gt;color();
 952         if (!toColor.isValid())
 953             toColor = b-&gt;color();
 954         (dst-&gt;*m_setter)(blendFunc(anim, fromColor, toColor, progress));
 955     }
 956 
 957     Color value(const RenderStyle* a) const
 958     {
 959         return (a-&gt;*m_getter)();
 960     }
 961 
 962 #if !LOG_DISABLED
 963     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double progress) const final
 964     {
 965         // FIXME: better logging.
 966         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
 967     }
 968 #endif
 969 
 970 private:
 971     const Color&amp; (RenderStyle::*m_getter)() const;
 972     void (RenderStyle::*m_setter)(const Color&amp;);
 973 };
 974 
 975 
 976 enum MaybeInvalidColorTag { MaybeInvalidColor };
 977 class PropertyWrapperVisitedAffectedColor : public AnimationPropertyWrapperBase {
 978     WTF_MAKE_FAST_ALLOCATED;
 979 public:
 980     PropertyWrapperVisitedAffectedColor(CSSPropertyID prop, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;),
 981         const Color&amp; (RenderStyle::*visitedGetter)() const, void (RenderStyle::*visitedSetter)(const Color&amp;))
 982         : AnimationPropertyWrapperBase(prop)
 983         , m_wrapper(makeUnique&lt;PropertyWrapperColor&gt;(prop, getter, setter))
 984         , m_visitedWrapper(makeUnique&lt;PropertyWrapperColor&gt;(prop, visitedGetter, visitedSetter))
 985     {
 986     }
 987     PropertyWrapperVisitedAffectedColor(CSSPropertyID prop, MaybeInvalidColorTag, const Color&amp; (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;),
 988         const Color&amp; (RenderStyle::*visitedGetter)() const, void (RenderStyle::*visitedSetter)(const Color&amp;))
 989         : AnimationPropertyWrapperBase(prop)
 990         , m_wrapper(makeUnique&lt;PropertyWrapperMaybeInvalidColor&gt;(prop, getter, setter))
 991         , m_visitedWrapper(makeUnique&lt;PropertyWrapperMaybeInvalidColor&gt;(prop, visitedGetter, visitedSetter))
 992     {
 993     }
 994     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 995     {
 996         return m_wrapper-&gt;equals(a, b) &amp;&amp; m_visitedWrapper-&gt;equals(a, b);
 997     }
 998     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 999     {
1000         m_wrapper-&gt;blend(anim, dst, a, b, progress);
1001         m_visitedWrapper-&gt;blend(anim, dst, a, b, progress);
1002     }
1003 
1004 #if !LOG_DISABLED
1005     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* result, double progress) const final
1006     {
1007         m_wrapper-&gt;logBlend(a, b, result, progress);
1008         m_visitedWrapper-&gt;logBlend(a, b, result, progress);
1009     }
1010 #endif
1011 
1012 private:
1013     std::unique_ptr&lt;AnimationPropertyWrapperBase&gt; m_wrapper;
1014     std::unique_ptr&lt;AnimationPropertyWrapperBase&gt; m_visitedWrapper;
1015 };
1016 
1017 // Wrapper base class for an animatable property in a FillLayer
1018 class FillLayerAnimationPropertyWrapperBase {
1019     WTF_MAKE_FAST_ALLOCATED;
1020 public:
1021     FillLayerAnimationPropertyWrapperBase(CSSPropertyID property)
1022         : m_property(property)
1023     {
1024     }
1025     virtual ~FillLayerAnimationPropertyWrapperBase() = default;
1026 
1027     CSSPropertyID property() const { return m_property; }
1028 
1029     virtual bool equals(const FillLayer*, const FillLayer*) const = 0;
1030     virtual void blend(const CSSPropertyBlendingClient*, FillLayer*, const FillLayer*, const FillLayer*, double) const = 0;
1031 
1032 #if !LOG_DISABLED
1033     virtual void logBlend(const FillLayer* result, const FillLayer*, const FillLayer*, double) const = 0;
1034 #endif
1035 private:
1036     CSSPropertyID m_property;
1037 };
1038 
1039 template &lt;typename T&gt;
1040 class FillLayerPropertyWrapperGetter : public FillLayerAnimationPropertyWrapperBase {
1041     WTF_MAKE_FAST_ALLOCATED;
1042     WTF_MAKE_NONCOPYABLE(FillLayerPropertyWrapperGetter);
1043 public:
1044     FillLayerPropertyWrapperGetter(CSSPropertyID property, T (FillLayer::*getter)() const)
1045         : FillLayerAnimationPropertyWrapperBase(property)
1046         , m_getter(getter)
1047     {
1048     }
1049 
1050     bool equals(const FillLayer* a, const FillLayer* b) const override
1051     {
1052         if (a == b)
1053             return true;
1054         if (!a || !b)
1055             return false;
1056         return (a-&gt;*m_getter)() == (b-&gt;*m_getter)();
1057     }
1058 
1059     T value(const FillLayer* layer) const
1060     {
1061         return (layer-&gt;*m_getter)();
1062     }
1063 
1064 #if !LOG_DISABLED
1065     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1066     {
1067         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
1068     }
1069 #endif
1070 
1071 protected:
1072     T (FillLayer::*m_getter)() const;
1073 };
1074 
1075 template &lt;typename T&gt;
1076 class FillLayerPropertyWrapper : public FillLayerPropertyWrapperGetter&lt;const T&amp;&gt; {
1077     WTF_MAKE_FAST_ALLOCATED;
1078 public:
1079     FillLayerPropertyWrapper(CSSPropertyID property, const T&amp; (FillLayer::*getter)() const, void (FillLayer::*setter)(T))
1080         : FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;(property, getter)
1081         , m_setter(setter)
1082     {
1083     }
1084 
1085     void blend(const CSSPropertyBlendingClient* anim, FillLayer* dst, const FillLayer* a, const FillLayer* b, double progress) const override
1086     {
1087         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), (b-&gt;*FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::m_getter)(), progress));
1088     }
1089 
1090 #if !LOG_DISABLED
1091     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1092     {
1093         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::property())
1094             &lt;&lt; &quot; from &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::value(a)
1095             &lt;&lt; &quot; to &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::value(b)
1096             &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;const T&amp;&gt;::value(result));
1097     }
1098 #endif
1099 
1100 protected:
1101     void (FillLayer::*m_setter)(T);
1102 };
1103 
1104 class FillLayerPositionPropertyWrapper : public FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt; {
1105     WTF_MAKE_FAST_ALLOCATED;
1106 public:
1107     FillLayerPositionPropertyWrapper(CSSPropertyID property, const Length&amp; (FillLayer::*lengthGetter)() const, void (FillLayer::*lengthSetter)(Length), Edge (FillLayer::*originGetter)() const, void (FillLayer::*originSetter)(Edge), Edge farEdge)
1108         : FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;(property, lengthGetter)
1109         , m_lengthSetter(lengthSetter)
1110         , m_originGetter(originGetter)
1111         , m_originSetter(originSetter)
1112         , m_farEdge(farEdge)
1113     {
1114     }
1115 
1116     bool equals(const FillLayer* a, const FillLayer* b) const override
1117     {
1118         if (a == b)
1119             return true;
1120         if (!a || !b)
1121             return false;
1122 
1123         Length fromLength = (a-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1124         Length toLength = (b-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1125 
1126         Edge fromEdge = (a-&gt;*m_originGetter)();
1127         Edge toEdge = (b-&gt;*m_originGetter)();
1128 
1129         return fromLength == toLength &amp;&amp; fromEdge == toEdge;
1130     }
1131 
1132     void blend(const CSSPropertyBlendingClient* anim, FillLayer* dst, const FillLayer* a, const FillLayer* b, double progress) const override
1133     {
1134         Length fromLength = (a-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1135         Length toLength = (b-&gt;*FillLayerPropertyWrapperGetter&lt;const Length&amp;&gt;::m_getter)();
1136 
1137         Edge fromEdge = (a-&gt;*m_originGetter)();
1138         Edge toEdge = (b-&gt;*m_originGetter)();
1139 
1140         if (fromEdge != toEdge) {
1141             // Convert the right/bottom into a calc expression,
1142             if (fromEdge == m_farEdge)
1143                 fromLength = convertTo100PercentMinusLength(fromLength);
1144             else if (toEdge == m_farEdge) {
1145                 toLength = convertTo100PercentMinusLength(toLength);
1146                 (dst-&gt;*m_originSetter)(fromEdge); // Now we have a calc(100% - l), it&#39;s relative to the left/top edge.
1147             }
1148         }
1149 
1150         (dst-&gt;*m_lengthSetter)(blendFunc(anim, fromLength, toLength, progress));
1151     }
1152 
1153 #if !LOG_DISABLED
1154     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1155     {
1156         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
1157     }
1158 #endif
1159 
1160 protected:
1161     void (FillLayer::*m_lengthSetter)(Length);
1162     Edge (FillLayer::*m_originGetter)() const;
1163     void (FillLayer::*m_originSetter)(Edge);
1164     Edge m_farEdge;
1165 };
1166 
1167 template &lt;typename T&gt;
1168 class FillLayerRefCountedPropertyWrapper : public FillLayerPropertyWrapperGetter&lt;T*&gt; {
1169     WTF_MAKE_FAST_ALLOCATED;
1170 public:
1171     FillLayerRefCountedPropertyWrapper(CSSPropertyID property, T* (FillLayer::*getter)() const, void (FillLayer::*setter)(RefPtr&lt;T&gt;&amp;&amp;))
1172         : FillLayerPropertyWrapperGetter&lt;T*&gt;(property, getter)
1173         , m_setter(setter)
1174     {
1175     }
1176 
1177     void blend(const CSSPropertyBlendingClient* anim, FillLayer* dst, const FillLayer* a, const FillLayer* b, double progress) const override
1178     {
1179         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*FillLayerPropertyWrapperGetter&lt;T*&gt;::m_getter)(), (b-&gt;*FillLayerPropertyWrapperGetter&lt;T*&gt;::m_getter)(), progress));
1180     }
1181 
1182 #if !LOG_DISABLED
1183     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1184     {
1185         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(FillLayerPropertyWrapperGetter&lt;T*&gt;::property())
1186             &lt;&lt; &quot; from &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;T*&gt;::value(a)
1187             &lt;&lt; &quot; to &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;T*&gt;::value(b)
1188             &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; FillLayerPropertyWrapperGetter&lt;T*&gt;::value(result));
1189     }
1190 #endif
1191 
1192 protected:
1193     void (FillLayer::*m_setter)(RefPtr&lt;T&gt;&amp;&amp;);
1194 };
1195 
1196 class FillLayerStyleImagePropertyWrapper : public FillLayerRefCountedPropertyWrapper&lt;StyleImage&gt; {
1197     WTF_MAKE_FAST_ALLOCATED;
1198 public:
1199     FillLayerStyleImagePropertyWrapper(CSSPropertyID property, StyleImage* (FillLayer::*getter)() const, void (FillLayer::*setter)(RefPtr&lt;StyleImage&gt;&amp;&amp;))
1200         : FillLayerRefCountedPropertyWrapper&lt;StyleImage&gt;(property, getter, setter)
1201     {
1202     }
1203 
1204     bool equals(const FillLayer* a, const FillLayer* b) const override
1205     {
1206        if (a == b)
1207            return true;
1208        if (!a || !b)
1209             return false;
1210 
1211         StyleImage* imageA = (a-&gt;*m_getter)();
1212         StyleImage* imageB = (b-&gt;*m_getter)();
1213         return arePointingToEqualData(imageA, imageB);
1214     }
1215 
1216 #if !LOG_DISABLED
1217     void logBlend(const FillLayer* result, const FillLayer* a, const FillLayer* b, double progress) const override
1218     {
1219         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending &quot; &lt;&lt; getPropertyName(property()) &lt;&lt; &quot; from &quot; &lt;&lt; value(a) &lt;&lt; &quot; to &quot; &lt;&lt; value(b) &lt;&lt; &quot; at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress) &lt;&lt; &quot; -&gt; &quot; &lt;&lt; value(result));
1220     }
1221 #endif
1222 };
1223 
1224 class FillLayersPropertyWrapper : public AnimationPropertyWrapperBase {
1225     WTF_MAKE_FAST_ALLOCATED;
1226 public:
1227     typedef const FillLayer&amp; (RenderStyle::*LayersGetter)() const;
1228     typedef FillLayer&amp; (RenderStyle::*LayersAccessor)();
1229 
1230     FillLayersPropertyWrapper(CSSPropertyID property, LayersGetter getter, LayersAccessor accessor)
1231         : AnimationPropertyWrapperBase(property)
1232         , m_layersGetter(getter)
1233         , m_layersAccessor(accessor)
1234     {
1235         switch (property) {
1236         case CSSPropertyBackgroundPositionX:
1237         case CSSPropertyWebkitMaskPositionX:
1238             m_fillLayerPropertyWrapper = makeUnique&lt;FillLayerPositionPropertyWrapper&gt;(property, &amp;FillLayer::xPosition, &amp;FillLayer::setXPosition, &amp;FillLayer::backgroundXOrigin, &amp;FillLayer::setBackgroundXOrigin, Edge::Right);
1239             break;
1240         case CSSPropertyBackgroundPositionY:
1241         case CSSPropertyWebkitMaskPositionY:
1242             m_fillLayerPropertyWrapper = makeUnique&lt;FillLayerPositionPropertyWrapper&gt;(property, &amp;FillLayer::yPosition, &amp;FillLayer::setYPosition, &amp;FillLayer::backgroundYOrigin, &amp;FillLayer::setBackgroundYOrigin, Edge::Bottom);
1243             break;
1244         case CSSPropertyBackgroundSize:
1245         case CSSPropertyWebkitBackgroundSize:
1246         case CSSPropertyWebkitMaskSize:
1247             m_fillLayerPropertyWrapper = makeUnique&lt;FillLayerPropertyWrapper&lt;LengthSize&gt;&gt;(property, &amp;FillLayer::sizeLength, &amp;FillLayer::setSizeLength);
1248             break;
1249         case CSSPropertyBackgroundImage:
1250             m_fillLayerPropertyWrapper = makeUnique&lt;FillLayerStyleImagePropertyWrapper&gt;(property, &amp;FillLayer::image, &amp;FillLayer::setImage);
1251             break;
1252         default:
1253             break;
1254         }
1255     }
1256 
1257     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1258     {
1259         if (a == b)
1260             return true;
1261         if (!a || !b)
1262             return false;
1263 
1264         auto* fromLayer = &amp;(a-&gt;*m_layersGetter)();
1265         auto* toLayer = &amp;(b-&gt;*m_layersGetter)();
1266 
1267         while (fromLayer &amp;&amp; toLayer) {
1268             if (!m_fillLayerPropertyWrapper-&gt;equals(fromLayer, toLayer))
1269                 return false;
1270 
1271             fromLayer = fromLayer-&gt;next();
1272             toLayer = toLayer-&gt;next();
1273         }
1274 
1275         return true;
1276     }
1277 
1278     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1279     {
1280         auto* aLayer = &amp;(a-&gt;*m_layersGetter)();
1281         auto* bLayer = &amp;(b-&gt;*m_layersGetter)();
1282         auto* dstLayer = &amp;(dst-&gt;*m_layersAccessor)();
1283 
1284         while (aLayer &amp;&amp; bLayer &amp;&amp; dstLayer) {
1285             m_fillLayerPropertyWrapper-&gt;blend(anim, dstLayer, aLayer, bLayer, progress);
1286             aLayer = aLayer-&gt;next();
1287             bLayer = bLayer-&gt;next();
1288             dstLayer = dstLayer-&gt;next();
1289         }
1290     }
1291 
1292 #if !LOG_DISABLED
1293     void logBlend(const RenderStyle* from, const RenderStyle* to, const RenderStyle* result, double progress) const final
1294     {
1295         auto* aLayer = &amp;(from-&gt;*m_layersGetter)();
1296         auto* bLayer = &amp;(to-&gt;*m_layersGetter)();
1297         auto* dstLayer = &amp;(result-&gt;*m_layersGetter)();
1298 
1299         while (aLayer &amp;&amp; bLayer &amp;&amp; dstLayer) {
1300             m_fillLayerPropertyWrapper-&gt;logBlend(dstLayer, aLayer, bLayer, progress);
1301             aLayer = aLayer-&gt;next();
1302             bLayer = bLayer-&gt;next();
1303             dstLayer = dstLayer-&gt;next();
1304         }
1305     }
1306 #endif
1307 
1308 private:
1309     std::unique_ptr&lt;FillLayerAnimationPropertyWrapperBase&gt; m_fillLayerPropertyWrapper;
1310 
1311     LayersGetter m_layersGetter;
1312     LayersAccessor m_layersAccessor;
1313 };
1314 
1315 class ShorthandPropertyWrapper : public AnimationPropertyWrapperBase {
1316     WTF_MAKE_FAST_ALLOCATED;
1317 public:
1318     ShorthandPropertyWrapper(CSSPropertyID property, Vector&lt;AnimationPropertyWrapperBase*&gt; longhandWrappers)
1319         : AnimationPropertyWrapperBase(property)
1320         , m_propertyWrappers(WTFMove(longhandWrappers))
1321     {
1322     }
1323 
1324     bool isShorthandWrapper() const override { return true; }
1325 
1326     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1327     {
1328         if (a == b)
1329             return true;
1330         if (!a || !b)
1331             return false;
1332 
1333         for (auto&amp; wrapper : m_propertyWrappers) {
1334             if (!wrapper-&gt;equals(a, b))
1335                 return false;
1336         }
1337         return true;
1338     }
1339 
1340     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1341     {
1342         for (auto&amp; wrapper : m_propertyWrappers)
1343             wrapper-&gt;blend(anim, dst, a, b, progress);
1344     }
1345 
1346 #if !LOG_DISABLED
1347     void logBlend(const RenderStyle* a, const RenderStyle* b, const RenderStyle* dst, double progress) const final
1348     {
1349         for (auto&amp; wrapper : m_propertyWrappers)
1350             wrapper-&gt;logBlend(a, b, dst, progress);
1351     }
1352 #endif
1353 
1354     const Vector&lt;AnimationPropertyWrapperBase*&gt;&amp; propertyWrappers() const { return m_propertyWrappers; }
1355 
1356 private:
1357     Vector&lt;AnimationPropertyWrapperBase*&gt; m_propertyWrappers;
1358 };
1359 
1360 class PropertyWrapperFlex : public AnimationPropertyWrapperBase {
1361     WTF_MAKE_FAST_ALLOCATED;
1362 public:
1363     PropertyWrapperFlex()
1364         : AnimationPropertyWrapperBase(CSSPropertyFlex)
1365     {
1366     }
1367 
1368     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1369     {
1370         if (a == b)
1371             return true;
1372         if (!a || !b)
1373             return false;
1374 
1375         return a-&gt;flexBasis() == b-&gt;flexBasis() &amp;&amp; a-&gt;flexGrow() == b-&gt;flexGrow() &amp;&amp; a-&gt;flexShrink() == b-&gt;flexShrink();
1376     }
1377 
1378     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1379     {
1380         dst-&gt;setFlexBasis(blendFunc(anim, a-&gt;flexBasis(), b-&gt;flexBasis(), progress));
1381         dst-&gt;setFlexGrow(blendFunc(anim, a-&gt;flexGrow(), b-&gt;flexGrow(), progress));
1382         dst-&gt;setFlexShrink(blendFunc(anim, a-&gt;flexShrink(), b-&gt;flexShrink(), progress));
1383     }
1384 
1385 #if !LOG_DISABLED
1386     void logBlend(const RenderStyle*, const RenderStyle*, const RenderStyle*, double progress) const final
1387     {
1388         // FIXME: better logging.
1389         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending flex at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress));
1390     }
1391 #endif
1392 };
1393 
1394 class PropertyWrapperSVGPaint : public AnimationPropertyWrapperBase {
1395     WTF_MAKE_FAST_ALLOCATED;
1396 public:
1397     PropertyWrapperSVGPaint(CSSPropertyID prop, SVGPaintType (RenderStyle::*paintTypeGetter)() const, Color (RenderStyle::*getter)() const, void (RenderStyle::*setter)(const Color&amp;))
1398         : AnimationPropertyWrapperBase(prop)
1399         , m_paintTypeGetter(paintTypeGetter)
1400         , m_getter(getter)
1401         , m_setter(setter)
1402     {
1403     }
1404 
1405     bool equals(const RenderStyle* a, const RenderStyle* b) const override
1406     {
1407         if (a == b)
1408             return true;
1409         if (!a || !b)
1410             return false;
1411 
1412         if ((a-&gt;*m_paintTypeGetter)() != (b-&gt;*m_paintTypeGetter)())
1413             return false;
1414 
1415         // We only support animations between SVGPaints that are pure Color values.
1416         // For everything else we must return true for this method, otherwise
1417         // we will try to animate between values forever.
1418         if ((a-&gt;*m_paintTypeGetter)() == SVGPaintType::RGBColor) {
1419             Color fromColor = (a-&gt;*m_getter)();
1420             Color toColor = (b-&gt;*m_getter)();
1421 
1422             if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
1423                 return true;
1424 
1425             if (!fromColor.isValid())
1426                 fromColor = Color();
1427             if (!toColor.isValid())
1428                 toColor = Color();
1429 
1430             return fromColor == toColor;
1431         }
1432         return true;
1433     }
1434 
1435     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
1436     {
1437         if ((a-&gt;*m_paintTypeGetter)() != SVGPaintType::RGBColor
1438             || (b-&gt;*m_paintTypeGetter)() != SVGPaintType::RGBColor)
1439             return;
1440 
1441         Color fromColor = (a-&gt;*m_getter)();
1442         Color toColor = (b-&gt;*m_getter)();
1443 
1444         if (!fromColor.isValid() &amp;&amp; !toColor.isValid())
1445             return;
1446 
1447         if (!fromColor.isValid())
1448             fromColor = Color();
1449         if (!toColor.isValid())
1450             toColor = Color();
1451         (dst-&gt;*m_setter)(blendFunc(anim, fromColor, toColor, progress));
1452     }
1453 
1454 #if !LOG_DISABLED
1455     void logBlend(const RenderStyle*, const RenderStyle*, const RenderStyle*, double progress) const final
1456     {
1457         // FIXME: better logging.
1458         LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;  blending SVGPaint at &quot; &lt;&lt; TextStream::FormatNumberRespectingIntegers(progress));
1459     }
1460 #endif
1461 
1462 private:
1463     SVGPaintType (RenderStyle::*m_paintTypeGetter)() const;
1464     Color (RenderStyle::*m_getter)() const;
1465     void (RenderStyle::*m_setter)(const Color&amp;);
1466 };
1467 
1468 class PropertyWrapperFontStyle : public PropertyWrapper&lt;Optional&lt;FontSelectionValue&gt;&gt; {
1469     WTF_MAKE_FAST_ALLOCATED;
1470 public:
1471     PropertyWrapperFontStyle()
1472         : PropertyWrapper&lt;Optional&lt;FontSelectionValue&gt;&gt;(CSSPropertyFontStyle, &amp;RenderStyle::fontItalic, &amp;RenderStyle::setFontItalic)
1473     {
1474     }
1475 
1476     bool canInterpolate(const RenderStyle* from, const RenderStyle* to) const override
1477     {
1478         return from-&gt;fontItalic() &amp;&amp; to-&gt;fontItalic() &amp;&amp; from-&gt;fontDescription().fontStyleAxis() == FontStyleAxis::slnt &amp;&amp; to-&gt;fontDescription().fontStyleAxis() == FontStyleAxis::slnt;
1479     }
1480 
1481     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* from, const RenderStyle* to, double progress) const override
1482     {
1483         auto discrete = !canInterpolate(from, to);
1484 
1485         auto blendedStyleAxis = FontStyleAxis::slnt;
1486         if (discrete)
1487             blendedStyleAxis = (progress &lt; 0.5 ? from : to)-&gt;fontDescription().fontStyleAxis();
1488 
1489         auto fromFontItalic = from-&gt;fontItalic();
1490         auto toFontItalic = to-&gt;fontItalic();
1491         auto blendedFontItalic = progress &lt; 0.5 ? fromFontItalic : toFontItalic;
1492         if (!discrete)
1493             blendedFontItalic = blendFunc(anim, fromFontItalic, toFontItalic, progress);
1494 
1495         FontSelector* currentFontSelector = dst-&gt;fontCascade().fontSelector();
1496         auto description = dst-&gt;fontDescription();
1497         description.setItalic(blendedFontItalic);
1498         description.setFontStyleAxis(blendedStyleAxis);
1499         dst-&gt;setFontDescription(WTFMove(description));
1500         dst-&gt;fontCascade().update(currentFontSelector);
1501     }
1502 };
1503 
1504 class CSSPropertyAnimationWrapperMap {
1505     WTF_MAKE_FAST_ALLOCATED;
1506 public:
1507     static CSSPropertyAnimationWrapperMap&amp; singleton()
1508     {
1509         // FIXME: This data is never destroyed. Maybe we should ref count it and toss it when the last CSSAnimationController is destroyed?
1510         static NeverDestroyed&lt;CSSPropertyAnimationWrapperMap&gt; map;
1511         return map;
1512     }
1513 
1514     AnimationPropertyWrapperBase* wrapperForProperty(CSSPropertyID propertyID)
1515     {
1516         if (propertyID &lt; firstCSSProperty || propertyID &gt; lastCSSProperty)
1517             return nullptr;
1518 
1519         unsigned wrapperIndex = indexFromPropertyID(propertyID);
1520         if (wrapperIndex == cInvalidPropertyWrapperIndex)
1521             return nullptr;
1522 
1523         return m_propertyWrappers[wrapperIndex].get();
1524     }
1525 
1526     AnimationPropertyWrapperBase* wrapperForIndex(unsigned index)
1527     {
1528         ASSERT(index &lt; m_propertyWrappers.size());
1529         return m_propertyWrappers[index].get();
1530     }
1531 
1532     unsigned size()
1533     {
1534         return m_propertyWrappers.size();
1535     }
1536 
1537 private:
1538     CSSPropertyAnimationWrapperMap();
1539     ~CSSPropertyAnimationWrapperMap() = delete;
1540 
1541     unsigned char&amp; indexFromPropertyID(CSSPropertyID propertyID)
1542     {
1543         return m_propertyToIdMap[propertyID - firstCSSProperty];
1544     }
1545 
1546     Vector&lt;std::unique_ptr&lt;AnimationPropertyWrapperBase&gt;&gt; m_propertyWrappers;
1547     unsigned char m_propertyToIdMap[numCSSProperties];
1548 
1549     static const unsigned char cInvalidPropertyWrapperIndex = UCHAR_MAX;
1550 
1551     friend class WTF::NeverDestroyed&lt;CSSPropertyAnimationWrapperMap&gt;;
1552 };
1553 
1554 CSSPropertyAnimationWrapperMap::CSSPropertyAnimationWrapperMap()
1555 {
1556     // build the list of property wrappers to do the comparisons and blends
1557     AnimationPropertyWrapperBase* animatableLonghandPropertyWrappers[] = {
1558         new LengthPropertyWrapper(CSSPropertyLeft, &amp;RenderStyle::left, &amp;RenderStyle::setLeft),
1559         new LengthPropertyWrapper(CSSPropertyRight, &amp;RenderStyle::right, &amp;RenderStyle::setRight),
1560         new LengthPropertyWrapper(CSSPropertyTop, &amp;RenderStyle::top, &amp;RenderStyle::setTop),
1561         new LengthPropertyWrapper(CSSPropertyBottom, &amp;RenderStyle::bottom, &amp;RenderStyle::setBottom),
1562 
1563         new LengthPropertyWrapper(CSSPropertyWidth, &amp;RenderStyle::width, &amp;RenderStyle::setWidth),
1564         new LengthPropertyWrapper(CSSPropertyMinWidth, &amp;RenderStyle::minWidth, &amp;RenderStyle::setMinWidth),
1565         new LengthPropertyWrapper(CSSPropertyMaxWidth, &amp;RenderStyle::maxWidth, &amp;RenderStyle::setMaxWidth),
1566 
1567         new LengthPropertyWrapper(CSSPropertyHeight, &amp;RenderStyle::height, &amp;RenderStyle::setHeight),
1568         new LengthPropertyWrapper(CSSPropertyMinHeight, &amp;RenderStyle::minHeight, &amp;RenderStyle::setMinHeight),
1569         new LengthPropertyWrapper(CSSPropertyMaxHeight, &amp;RenderStyle::maxHeight, &amp;RenderStyle::setMaxHeight),
1570 
1571         new PropertyWrapperFlex(),
1572 
1573         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderLeftWidth, &amp;RenderStyle::borderLeftWidth, &amp;RenderStyle::setBorderLeftWidth),
1574         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderRightWidth, &amp;RenderStyle::borderRightWidth, &amp;RenderStyle::setBorderRightWidth),
1575         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderTopWidth, &amp;RenderStyle::borderTopWidth, &amp;RenderStyle::setBorderTopWidth),
1576         new PropertyWrapper&lt;float&gt;(CSSPropertyBorderBottomWidth, &amp;RenderStyle::borderBottomWidth, &amp;RenderStyle::setBorderBottomWidth),
1577         new LengthPropertyWrapper(CSSPropertyMarginLeft, &amp;RenderStyle::marginLeft, &amp;RenderStyle::setMarginLeft),
1578         new LengthPropertyWrapper(CSSPropertyMarginRight, &amp;RenderStyle::marginRight, &amp;RenderStyle::setMarginRight),
1579         new LengthPropertyWrapper(CSSPropertyMarginTop, &amp;RenderStyle::marginTop, &amp;RenderStyle::setMarginTop),
1580         new LengthPropertyWrapper(CSSPropertyMarginBottom, &amp;RenderStyle::marginBottom, &amp;RenderStyle::setMarginBottom),
1581         new LengthPropertyWrapper(CSSPropertyPaddingLeft, &amp;RenderStyle::paddingLeft, &amp;RenderStyle::setPaddingLeft),
1582         new LengthPropertyWrapper(CSSPropertyPaddingRight, &amp;RenderStyle::paddingRight, &amp;RenderStyle::setPaddingRight),
1583         new LengthPropertyWrapper(CSSPropertyPaddingTop, &amp;RenderStyle::paddingTop, &amp;RenderStyle::setPaddingTop),
1584         new LengthPropertyWrapper(CSSPropertyPaddingBottom, &amp;RenderStyle::paddingBottom, &amp;RenderStyle::setPaddingBottom),
1585 
1586         new PropertyWrapperVisitedAffectedColor(CSSPropertyCaretColor, &amp;RenderStyle::caretColor, &amp;RenderStyle::setCaretColor, &amp;RenderStyle::visitedLinkCaretColor, &amp;RenderStyle::setVisitedLinkCaretColor),
1587 
1588         new PropertyWrapperVisitedAffectedColor(CSSPropertyColor, &amp;RenderStyle::color, &amp;RenderStyle::setColor, &amp;RenderStyle::visitedLinkColor, &amp;RenderStyle::setVisitedLinkColor),
1589 
1590         new PropertyWrapperVisitedAffectedColor(CSSPropertyBackgroundColor, &amp;RenderStyle::backgroundColor, &amp;RenderStyle::setBackgroundColor, &amp;RenderStyle::visitedLinkBackgroundColor, &amp;RenderStyle::setVisitedLinkBackgroundColor),
1591 
1592         new FillLayersPropertyWrapper(CSSPropertyBackgroundImage, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1593         new StyleImagePropertyWrapper(CSSPropertyListStyleImage, &amp;RenderStyle::listStyleImage, &amp;RenderStyle::setListStyleImage),
1594         new StyleImagePropertyWrapper(CSSPropertyWebkitMaskImage, &amp;RenderStyle::maskImage, &amp;RenderStyle::setMaskImage),
1595 
1596         new StyleImagePropertyWrapper(CSSPropertyBorderImageSource, &amp;RenderStyle::borderImageSource, &amp;RenderStyle::setBorderImageSource),
1597         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyBorderImageSlice, &amp;RenderStyle::borderImageSlices, &amp;RenderStyle::setBorderImageSlices),
1598         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyBorderImageWidth, &amp;RenderStyle::borderImageWidth, &amp;RenderStyle::setBorderImageWidth),
1599         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyBorderImageOutset, &amp;RenderStyle::borderImageOutset, &amp;RenderStyle::setBorderImageOutset),
1600 
1601         new StyleImagePropertyWrapper(CSSPropertyWebkitMaskBoxImageSource, &amp;RenderStyle::maskBoxImageSource, &amp;RenderStyle::setMaskBoxImageSource),
1602         new PropertyWrapper&lt;const NinePieceImage&amp;&gt;(CSSPropertyWebkitMaskBoxImage, &amp;RenderStyle::maskBoxImage, &amp;RenderStyle::setMaskBoxImage),
1603 
1604         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionX, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1605         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionY, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1606         new FillLayersPropertyWrapper(CSSPropertyBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1607         new FillLayersPropertyWrapper(CSSPropertyWebkitBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1608 
1609         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionX, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1610         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionY, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1611         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskSize, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1612 
1613         new PropertyWrapper&lt;float&gt;(CSSPropertyFontSize, &amp;RenderStyle::computedFontSize, &amp;RenderStyle::setFontSize),
1614         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnRuleWidth, &amp;RenderStyle::columnRuleWidth, &amp;RenderStyle::setColumnRuleWidth),
1615         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyColumnGap, &amp;RenderStyle::columnGap, &amp;RenderStyle::setColumnGap),
1616         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyRowGap, &amp;RenderStyle::rowGap, &amp;RenderStyle::setRowGap),
1617         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnCount, &amp;RenderStyle::columnCount, &amp;RenderStyle::setColumnCount),
1618         new PropertyWrapper&lt;float&gt;(CSSPropertyColumnWidth, &amp;RenderStyle::columnWidth, &amp;RenderStyle::setColumnWidth),
1619         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderHorizontalSpacing, &amp;RenderStyle::horizontalBorderSpacing, &amp;RenderStyle::setHorizontalBorderSpacing),
1620         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderVerticalSpacing, &amp;RenderStyle::verticalBorderSpacing, &amp;RenderStyle::setVerticalBorderSpacing),
1621         new PropertyWrapper&lt;int&gt;(CSSPropertyZIndex, &amp;RenderStyle::specifiedZIndex, &amp;RenderStyle::setSpecifiedZIndex),
1622         new PropertyWrapper&lt;short&gt;(CSSPropertyOrphans, &amp;RenderStyle::orphans, &amp;RenderStyle::setOrphans),
1623         new PropertyWrapper&lt;short&gt;(CSSPropertyWidows, &amp;RenderStyle::widows, &amp;RenderStyle::setWidows),
1624         new LengthPropertyWrapper(CSSPropertyLineHeight, &amp;RenderStyle::specifiedLineHeight, &amp;RenderStyle::setLineHeight),
1625         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineOffset, &amp;RenderStyle::outlineOffset, &amp;RenderStyle::setOutlineOffset),
1626         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineWidth, &amp;RenderStyle::outlineWidth, &amp;RenderStyle::setOutlineWidth),
1627         new PropertyWrapper&lt;float&gt;(CSSPropertyLetterSpacing, &amp;RenderStyle::letterSpacing, &amp;RenderStyle::setLetterSpacing),
1628         new LengthPropertyWrapper(CSSPropertyWordSpacing, &amp;RenderStyle::wordSpacing, &amp;RenderStyle::setWordSpacing),
1629         new LengthPropertyWrapper(CSSPropertyTextIndent, &amp;RenderStyle::textIndent, &amp;RenderStyle::setTextIndent),
1630 
1631         new PropertyWrapper&lt;float&gt;(CSSPropertyPerspective, &amp;RenderStyle::perspective, &amp;RenderStyle::setPerspective),
1632         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginX, &amp;RenderStyle::perspectiveOriginX, &amp;RenderStyle::setPerspectiveOriginX),
1633         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginY, &amp;RenderStyle::perspectiveOriginY, &amp;RenderStyle::setPerspectiveOriginY),
1634         new LengthPropertyWrapper(CSSPropertyTransformOriginX, &amp;RenderStyle::transformOriginX, &amp;RenderStyle::setTransformOriginX),
1635         new LengthPropertyWrapper(CSSPropertyTransformOriginY, &amp;RenderStyle::transformOriginY, &amp;RenderStyle::setTransformOriginY),
1636         new PropertyWrapper&lt;float&gt;(CSSPropertyTransformOriginZ, &amp;RenderStyle::transformOriginZ, &amp;RenderStyle::setTransformOriginZ),
1637         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopLeftRadius, &amp;RenderStyle::borderTopLeftRadius, &amp;RenderStyle::setBorderTopLeftRadius),
1638         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopRightRadius, &amp;RenderStyle::borderTopRightRadius, &amp;RenderStyle::setBorderTopRightRadius),
1639         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomLeftRadius, &amp;RenderStyle::borderBottomLeftRadius, &amp;RenderStyle::setBorderBottomLeftRadius),
1640         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomRightRadius, &amp;RenderStyle::borderBottomRightRadius, &amp;RenderStyle::setBorderBottomRightRadius),
1641         new PropertyWrapper&lt;Visibility&gt;(CSSPropertyVisibility, &amp;RenderStyle::visibility, &amp;RenderStyle::setVisibility),
1642         new PropertyWrapper&lt;float&gt;(CSSPropertyZoom, &amp;RenderStyle::zoom, &amp;RenderStyle::setZoomWithoutReturnValue),
1643 
1644         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyClip, &amp;RenderStyle::clip, &amp;RenderStyle::setClip),
1645 
1646         new PropertyWrapperAcceleratedOpacity(),
1647         new PropertyWrapperAcceleratedTransform(),
1648 
1649         new PropertyWrapperFilter(CSSPropertyFilter, &amp;RenderStyle::filter, &amp;RenderStyle::setFilter),
1650 #if ENABLE(FILTERS_LEVEL_2)
1651         new PropertyWrapperFilter(CSSPropertyWebkitBackdropFilter, &amp;RenderStyle::backdropFilter, &amp;RenderStyle::setBackdropFilter),
1652 #endif
1653         new PropertyWrapperFilter(CSSPropertyAppleColorFilter, &amp;RenderStyle::appleColorFilter, &amp;RenderStyle::setAppleColorFilter),
1654 
1655         new PropertyWrapperClipPath(CSSPropertyClipPath, &amp;RenderStyle::clipPath, &amp;RenderStyle::setClipPath),
1656 
1657         new PropertyWrapperShape(CSSPropertyShapeOutside, &amp;RenderStyle::shapeOutside, &amp;RenderStyle::setShapeOutside),
1658         new LengthPropertyWrapper(CSSPropertyShapeMargin, &amp;RenderStyle::shapeMargin, &amp;RenderStyle::setShapeMargin),
1659         new PropertyWrapper&lt;float&gt;(CSSPropertyShapeImageThreshold, &amp;RenderStyle::shapeImageThreshold, &amp;RenderStyle::setShapeImageThreshold),
1660 
1661         new PropertyWrapperVisitedAffectedColor(CSSPropertyColumnRuleColor, MaybeInvalidColor, &amp;RenderStyle::columnRuleColor, &amp;RenderStyle::setColumnRuleColor, &amp;RenderStyle::visitedLinkColumnRuleColor, &amp;RenderStyle::setVisitedLinkColumnRuleColor),
1662         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextStrokeColor, MaybeInvalidColor, &amp;RenderStyle::textStrokeColor, &amp;RenderStyle::setTextStrokeColor, &amp;RenderStyle::visitedLinkTextStrokeColor, &amp;RenderStyle::setVisitedLinkTextStrokeColor),
1663         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextFillColor, MaybeInvalidColor, &amp;RenderStyle::textFillColor, &amp;RenderStyle::setTextFillColor, &amp;RenderStyle::visitedLinkTextFillColor, &amp;RenderStyle::setVisitedLinkTextFillColor),
1664         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderLeftColor, MaybeInvalidColor, &amp;RenderStyle::borderLeftColor, &amp;RenderStyle::setBorderLeftColor, &amp;RenderStyle::visitedLinkBorderLeftColor, &amp;RenderStyle::setVisitedLinkBorderLeftColor),
1665         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderRightColor, MaybeInvalidColor, &amp;RenderStyle::borderRightColor, &amp;RenderStyle::setBorderRightColor, &amp;RenderStyle::visitedLinkBorderRightColor, &amp;RenderStyle::setVisitedLinkBorderRightColor),
1666         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderTopColor, MaybeInvalidColor, &amp;RenderStyle::borderTopColor, &amp;RenderStyle::setBorderTopColor, &amp;RenderStyle::visitedLinkBorderTopColor, &amp;RenderStyle::setVisitedLinkBorderTopColor),
1667         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderBottomColor, MaybeInvalidColor, &amp;RenderStyle::borderBottomColor, &amp;RenderStyle::setBorderBottomColor, &amp;RenderStyle::visitedLinkBorderBottomColor, &amp;RenderStyle::setVisitedLinkBorderBottomColor),
1668         new PropertyWrapperVisitedAffectedColor(CSSPropertyOutlineColor, MaybeInvalidColor, &amp;RenderStyle::outlineColor, &amp;RenderStyle::setOutlineColor, &amp;RenderStyle::visitedLinkOutlineColor, &amp;RenderStyle::setVisitedLinkOutlineColor),
1669 
1670         new PropertyWrapperShadow(CSSPropertyBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1671         new PropertyWrapperShadow(CSSPropertyWebkitBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1672         new PropertyWrapperShadow(CSSPropertyTextShadow, &amp;RenderStyle::textShadow, &amp;RenderStyle::setTextShadow),
1673 
1674         new PropertyWrapperSVGPaint(CSSPropertyFill, &amp;RenderStyle::fillPaintType, &amp;RenderStyle::fillPaintColor, &amp;RenderStyle::setFillPaintColor),
1675         new PropertyWrapper&lt;float&gt;(CSSPropertyFillOpacity, &amp;RenderStyle::fillOpacity, &amp;RenderStyle::setFillOpacity),
1676 
1677         new PropertyWrapperSVGPaint(CSSPropertyStroke, &amp;RenderStyle::strokePaintType, &amp;RenderStyle::strokePaintColor, &amp;RenderStyle::setStrokePaintColor),
1678         new PropertyWrapper&lt;float&gt;(CSSPropertyStrokeOpacity, &amp;RenderStyle::strokeOpacity, &amp;RenderStyle::setStrokeOpacity),
1679         new PropertyWrapper&lt;Vector&lt;SVGLengthValue&gt;&gt;(CSSPropertyStrokeDasharray, &amp;RenderStyle::strokeDashArray, &amp;RenderStyle::setStrokeDashArray),
1680         new PropertyWrapper&lt;float&gt;(CSSPropertyStrokeMiterlimit, &amp;RenderStyle::strokeMiterLimit, &amp;RenderStyle::setStrokeMiterLimit),
1681 
1682         new LengthPropertyWrapper(CSSPropertyCx, &amp;RenderStyle::cx, &amp;RenderStyle::setCx),
1683         new LengthPropertyWrapper(CSSPropertyCy, &amp;RenderStyle::cy, &amp;RenderStyle::setCy),
1684         new LengthPropertyWrapper(CSSPropertyR, &amp;RenderStyle::r, &amp;RenderStyle::setR),
1685         new LengthPropertyWrapper(CSSPropertyRx, &amp;RenderStyle::rx, &amp;RenderStyle::setRx),
1686         new LengthPropertyWrapper(CSSPropertyRy, &amp;RenderStyle::ry, &amp;RenderStyle::setRy),
1687         new LengthPropertyWrapper(CSSPropertyStrokeDashoffset, &amp;RenderStyle::strokeDashOffset, &amp;RenderStyle::setStrokeDashOffset),
1688         new LengthPropertyWrapper(CSSPropertyStrokeWidth, &amp;RenderStyle::strokeWidth, &amp;RenderStyle::setStrokeWidth),
1689         new LengthPropertyWrapper(CSSPropertyX, &amp;RenderStyle::x, &amp;RenderStyle::setX),
1690         new LengthPropertyWrapper(CSSPropertyY, &amp;RenderStyle::y, &amp;RenderStyle::setY),
1691 
1692         new PropertyWrapper&lt;float&gt;(CSSPropertyFloodOpacity, &amp;RenderStyle::floodOpacity, &amp;RenderStyle::setFloodOpacity),
1693         new PropertyWrapperMaybeInvalidColor(CSSPropertyFloodColor, &amp;RenderStyle::floodColor, &amp;RenderStyle::setFloodColor),
1694 
1695         new PropertyWrapper&lt;float&gt;(CSSPropertyStopOpacity, &amp;RenderStyle::stopOpacity, &amp;RenderStyle::setStopOpacity),
1696         new PropertyWrapperMaybeInvalidColor(CSSPropertyStopColor, &amp;RenderStyle::stopColor, &amp;RenderStyle::setStopColor),
1697 
1698         new PropertyWrapperMaybeInvalidColor(CSSPropertyLightingColor, &amp;RenderStyle::lightingColor, &amp;RenderStyle::setLightingColor),
1699 
1700         new PropertyWrapper&lt;SVGLengthValue&gt;(CSSPropertyBaselineShift, &amp;RenderStyle::baselineShiftValue, &amp;RenderStyle::setBaselineShiftValue),
1701         new PropertyWrapper&lt;SVGLengthValue&gt;(CSSPropertyKerning, &amp;RenderStyle::kerning, &amp;RenderStyle::setKerning),
1702 #if ENABLE(VARIATION_FONTS)
1703         new PropertyWrapperFontVariationSettings(CSSPropertyFontVariationSettings, &amp;RenderStyle::fontVariationSettings, &amp;RenderStyle::setFontVariationSettings),
1704 #endif
1705         new PropertyWrapper&lt;FontSelectionValue&gt;(CSSPropertyFontWeight, &amp;RenderStyle::fontWeight, &amp;RenderStyle::setFontWeight),
1706         new PropertyWrapper&lt;FontSelectionValue&gt;(CSSPropertyFontStretch, &amp;RenderStyle::fontStretch, &amp;RenderStyle::setFontStretch),
1707         new PropertyWrapperFontStyle(),
1708         new PropertyWrapper&lt;TextDecorationThickness&gt;(CSSPropertyTextDecorationThickness, &amp;RenderStyle::textDecorationThickness, &amp;RenderStyle::setTextDecorationThickness),
1709         new PropertyWrapper&lt;TextUnderlineOffset&gt;(CSSPropertyTextUnderlineOffset, &amp;RenderStyle::textUnderlineOffset, &amp;RenderStyle::setTextUnderlineOffset),
1710     };
1711     const unsigned animatableLonghandPropertiesCount = WTF_ARRAY_LENGTH(animatableLonghandPropertyWrappers);
1712 
1713     static const CSSPropertyID animatableShorthandProperties[] = {
1714         CSSPropertyBackground, // for background-color, background-position, background-image
1715         CSSPropertyBackgroundPosition,
1716         CSSPropertyFont, // for font-size, font-weight
1717         CSSPropertyWebkitMask, // for mask-position
1718         CSSPropertyWebkitMaskPosition,
1719         CSSPropertyBorderTop, CSSPropertyBorderRight, CSSPropertyBorderBottom, CSSPropertyBorderLeft,
1720         CSSPropertyBorderColor,
1721         CSSPropertyBorderRadius,
1722         CSSPropertyBorderWidth,
1723         CSSPropertyBorder,
1724         CSSPropertyBorderImage,
1725         CSSPropertyBorderSpacing,
1726         CSSPropertyListStyle, // for list-style-image
1727         CSSPropertyMargin,
1728         CSSPropertyOutline,
1729         CSSPropertyPadding,
1730         CSSPropertyWebkitTextStroke,
1731         CSSPropertyColumnRule,
1732         CSSPropertyWebkitBorderRadius,
1733         CSSPropertyTransformOrigin
1734     };
1735     const unsigned animatableShorthandPropertiesCount = WTF_ARRAY_LENGTH(animatableShorthandProperties);
1736 
1737     // TODO:
1738     //
1739     //  CSSPropertyVerticalAlign
1740     //
1741     // Compound properties that have components that should be animatable:
1742     //
1743     //  CSSPropertyColumns
1744     //  CSSPropertyWebkitBoxReflect
1745 
1746     // Make sure unused slots have a value
1747     for (int i = 0; i &lt; numCSSProperties; ++i)
1748         m_propertyToIdMap[i] = cInvalidPropertyWrapperIndex;
1749 
1750     COMPILE_ASSERT(animatableLonghandPropertiesCount + animatableShorthandPropertiesCount &lt; UCHAR_MAX, numberOfAnimatablePropertiesMustBeLessThanUCharMax);
1751     m_propertyWrappers.reserveInitialCapacity(animatableLonghandPropertiesCount + animatableShorthandPropertiesCount);
1752 
1753     // First we put the non-shorthand property wrappers into the map, so the shorthand-building
1754     // code can find them.
1755 
1756     for (unsigned i = 0; i &lt; animatableLonghandPropertiesCount; ++i) {
1757         AnimationPropertyWrapperBase* wrapper = animatableLonghandPropertyWrappers[i];
1758         m_propertyWrappers.uncheckedAppend(std::unique_ptr&lt;AnimationPropertyWrapperBase&gt;(wrapper));
1759         indexFromPropertyID(wrapper-&gt;property()) = i;
1760     }
1761 
1762     for (size_t i = 0; i &lt; animatableShorthandPropertiesCount; ++i) {
1763         CSSPropertyID propertyID = animatableShorthandProperties[i];
1764         StylePropertyShorthand shorthand = shorthandForProperty(propertyID);
1765         if (!shorthand.length())
1766             continue;
1767 
1768         Vector&lt;AnimationPropertyWrapperBase*&gt; longhandWrappers;
1769         longhandWrappers.reserveInitialCapacity(shorthand.length());
1770         const CSSPropertyID* properties = shorthand.properties();
1771         for (unsigned j = 0; j &lt; shorthand.length(); ++j) {
1772             unsigned wrapperIndex = indexFromPropertyID(properties[j]);
1773             if (wrapperIndex == cInvalidPropertyWrapperIndex)
1774                 continue;
1775             ASSERT(m_propertyWrappers[wrapperIndex]);
1776             longhandWrappers.uncheckedAppend(m_propertyWrappers[wrapperIndex].get());
1777         }
1778 
1779         m_propertyWrappers.uncheckedAppend(makeUnique&lt;ShorthandPropertyWrapper&gt;(propertyID, WTFMove(longhandWrappers)));
1780         indexFromPropertyID(propertyID) = animatableLonghandPropertiesCount + i;
1781     }
1782 }
1783 
1784 static bool gatherEnclosingShorthandProperties(CSSPropertyID property, AnimationPropertyWrapperBase* wrapper, HashSet&lt;CSSPropertyID&gt;&amp; propertySet)
1785 {
1786     if (!wrapper-&gt;isShorthandWrapper())
1787         return false;
1788 
1789     ShorthandPropertyWrapper* shorthandWrapper = static_cast&lt;ShorthandPropertyWrapper*&gt;(wrapper);
1790     bool contained = false;
1791     for (auto&amp; currWrapper : shorthandWrapper-&gt;propertyWrappers()) {
1792         if (gatherEnclosingShorthandProperties(property, currWrapper, propertySet) || currWrapper-&gt;property() == property)
1793             contained = true;
1794     }
1795 
1796     if (contained)
1797         propertySet.add(wrapper-&gt;property());
1798 
1799     return contained;
1800 }
1801 
1802 // Returns true if we need to start animation timers
1803 void CSSPropertyAnimation::blendProperties(const CSSPropertyBlendingClient* anim, CSSPropertyID prop, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress)
1804 {
1805     ASSERT(prop != CSSPropertyInvalid);
1806 
1807     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1808     if (wrapper) {
1809         wrapper-&gt;blend(anim, dst, a, b, progress);
1810 #if !LOG_DISABLED
1811         wrapper-&gt;logBlend(a, b, dst, progress);
1812 #endif
1813     }
1814 }
1815 
1816 bool CSSPropertyAnimation::isPropertyAnimatable(CSSPropertyID prop)
1817 {
1818     return CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1819 }
1820 
1821 bool CSSPropertyAnimation::animationOfPropertyIsAccelerated(CSSPropertyID prop)
1822 {
1823     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1824     return wrapper ? wrapper-&gt;animationIsAccelerated() : false;
1825 }
1826 
1827 // Note: this is inefficient. It&#39;s only called from pauseTransitionAtTime().
1828 HashSet&lt;CSSPropertyID&gt; CSSPropertyAnimation::animatableShorthandsAffectingProperty(CSSPropertyID property)
1829 {
1830     CSSPropertyAnimationWrapperMap&amp; map = CSSPropertyAnimationWrapperMap::singleton();
1831 
1832     HashSet&lt;CSSPropertyID&gt; foundProperties;
1833     for (unsigned i = 0; i &lt; map.size(); ++i)
1834         gatherEnclosingShorthandProperties(property, map.wrapperForIndex(i), foundProperties);
1835 
1836     return foundProperties;
1837 }
1838 
1839 bool CSSPropertyAnimation::propertiesEqual(CSSPropertyID prop, const RenderStyle* a, const RenderStyle* b)
1840 {
1841     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1842     if (wrapper)
1843         return wrapper-&gt;equals(a, b);
1844     return true;
1845 }
1846 
1847 bool CSSPropertyAnimation::canPropertyBeInterpolated(CSSPropertyID prop, const RenderStyle* a, const RenderStyle* b)
1848 {
1849     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1850     if (wrapper)
1851         return wrapper-&gt;canInterpolate(a, b);
1852     return false;
1853 }
1854 
1855 CSSPropertyID CSSPropertyAnimation::getPropertyAtIndex(int i, Optional&lt;bool&gt;&amp; isShorthand)
1856 {
1857     CSSPropertyAnimationWrapperMap&amp; map = CSSPropertyAnimationWrapperMap::singleton();
1858 
1859     if (i &lt; 0 || static_cast&lt;unsigned&gt;(i) &gt;= map.size())
1860         return CSSPropertyInvalid;
1861 
1862     AnimationPropertyWrapperBase* wrapper = map.wrapperForIndex(i);
1863     isShorthand = wrapper-&gt;isShorthandWrapper();
1864     return wrapper-&gt;property();
1865 }
1866 
1867 int CSSPropertyAnimation::getNumProperties()
1868 {
1869     return CSSPropertyAnimationWrapperMap::singleton().size();
1870 }
1871 
1872 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBIndex.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBGetResult.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBIndex.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBIndex.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -45,44 +45,39 @@</span>
      : ActiveDOMObject(&amp;context)
      , m_info(info)
      , m_originalInfo(info)
      , m_objectStore(objectStore)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      suspendIfNeeded();
  }
  
  IDBIndex::~IDBIndex()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  }
  
  const char* IDBIndex::activeDOMObjectName() const
  {
      return &quot;IDBIndex&quot;;
  }
  
<span class="udiff-line-removed">- bool IDBIndex::canSuspendForDocumentSuspension() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool IDBIndex::hasPendingActivity() const
  {
<span class="udiff-line-modified-removed">-     return m_objectStore.transaction().hasPendingActivity();</span>
<span class="udiff-line-modified-added">+     return m_objectStore.hasPendingActivity();</span>
  }
  
  const String&amp; IDBIndex::name() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.name();
  }
  
  ExceptionOr&lt;void&gt; IDBIndex::setName(const String&amp; name)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted)
          return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index has been deleted.&quot;_s };
  
      if (m_objectStore.isDeleted())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -106,35 +101,35 @@</span>
      return { };
  }
  
  IDBObjectStore&amp; IDBIndex::objectStore()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_objectStore;
  }
  
  const IDBKeyPath&amp; IDBIndex::keyPath() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.keyPath();
  }
  
  bool IDBIndex::unique() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.unique();
  }
  
  bool IDBIndex::multiEntry() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
      return m_info.multiEntry();
  }
  
  void IDBIndex::rollbackInfoForVersionChangeAbort()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      // Only rollback to the original info if this index still exists in the rolled-back database info.
      auto* objectStoreInfo = m_objectStore.transaction().database().info().infoForExistingObjectStore(m_objectStore.info().identifier());
      if (!objectStoreInfo)
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -146,14 +141,14 @@</span>
  
      m_info = m_originalInfo;
      m_deleted = false;
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::openCursor&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -171,32 +166,32 @@</span>
  
      auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), rangeData, direction, IndexedDB::CursorType::KeyAndValue);
      return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [range=WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenKeyCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenKeyCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::openKeyCursor&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -209,48 +204,48 @@</span>
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
      return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
  {
      return doOpenKeyCursor(execState, direction, [range=WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
  {
      return doOpenKeyCursor(execState, direction, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(ExecState&amp; execState, IDBKeyRange* range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::count&quot;);
  
      return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(ExecState&amp; execState, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::count&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      auto* idbKeyPointer = idbKey-&gt;isValid() ? idbKey.ptr() : nullptr;
  
      return doCount(execState, IDBKeyRangeData(idbKeyPointer));
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doCount(ExecState&amp; execState, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doCount(JSGlobalObject&amp; execState, const IDBKeyRangeData&amp; range)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -261,31 +256,31 @@</span>
          return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s };
  
      return transaction.requestCount(execState, *this, range);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(ExecState&amp; execState, IDBKeyRange* range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::get&quot;);
  
      return doGet(execState, IDBKeyRangeData(range));
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(ExecState&amp; execState, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::get&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      if (!idbKey-&gt;isValid())
          return doGet(execState, Exception(DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
  
      return doGet(execState, IDBKeyRangeData(idbKey.ptr()));
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGet(ExecState&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGet(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -300,31 +295,31 @@</span>
          return Exception { DataError };
  
      return transaction.requestGetValue(execState, *this, keyRange);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(ExecState&amp; execState, IDBKeyRange* range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
  
      return doGetKey(execState, IDBKeyRangeData(range));
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(ExecState&amp; execState, JSValue key)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, JSValue key)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
  
      auto idbKey = scriptValueToIDBKey(execState, key);
      if (!idbKey-&gt;isValid())
          return doGetKey(execState, Exception(DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
  
      return doGetKey(execState, IDBKeyRangeData(idbKey.ptr()));
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetKey(ExecState&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetKey(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      auto&amp; transaction = m_objectStore.transaction();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -339,14 +334,14 @@</span>
          return Exception { DataError };
  
      return transaction.requestGetKey(execState, *this, keyRange);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAll(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAll(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getAll&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -358,32 +353,32 @@</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAll(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
  
          return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAllKeys(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAllKeys(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
  {
      LOG(IndexedDB, &quot;IDBIndex::getAllKeys&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      if (m_deleted || m_objectStore.isDeleted())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
  
      if (!m_objectStore.transaction().isActive())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -395,18 +390,18 @@</span>
  
      auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
      return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
          return range;
      });
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
  {
      return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
          auto onlyResult = IDBKeyRange::only(*state, key);
          if (onlyResult.hasException())
              return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -415,11 +410,11 @@</span>
      });
  }
  
  void IDBIndex::markAsDeleted()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
  
      ASSERT(!m_deleted);
      m_deleted = true;
  }
  
</pre>
<center><a href="IDBGetResult.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBIndex.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
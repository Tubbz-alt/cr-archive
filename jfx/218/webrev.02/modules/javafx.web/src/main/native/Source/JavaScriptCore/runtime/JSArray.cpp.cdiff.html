<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArray.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
<span class="line-new-header">--- 1,8 ---</span>
  /*
   *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *  Copyright (C) 2003 Peter Kelly (pmk@post.com)
   *  Copyright (C) 2006 Alexey Proskuryakov (ap@nypop.com)
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,11 ***</span>
          }
      } else {
          ASSERT(
              indexingType == ArrayWithSlowPutArrayStorage
              || indexingType == ArrayWithArrayStorage);
<span class="line-modified">!         static const unsigned indexBias = 0;</span>
          unsigned vectorLength = ArrayStorage::optimalVectorLength(indexBias, structure, initialLength);
          void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
              vm,
              Butterfly::totalSize(indexBias, outOfLineStorage, true, ArrayStorage::sizeFor(vectorLength)),
              deferralContext, AllocationFailureMode::ReturnNull);
<span class="line-new-header">--- 79,11 ---</span>
          }
      } else {
          ASSERT(
              indexingType == ArrayWithSlowPutArrayStorage
              || indexingType == ArrayWithArrayStorage);
<span class="line-modified">!         static constexpr unsigned indexBias = 0;</span>
          unsigned vectorLength = ArrayStorage::optimalVectorLength(indexBias, structure, initialLength);
          void* temp = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(
              vm,
              Butterfly::totalSize(indexBias, outOfLineStorage, true, ArrayStorage::sizeFor(vectorLength)),
              deferralContext, AllocationFailureMode::ReturnNull);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,81 ***</span>
              storage-&gt;m_vector[i].clear();
      }
      scope.notifyInitialized(array);
  }
  
<span class="line-modified">! void JSArray::setLengthWritable(ExecState* exec, bool writable)</span>
  {
      ASSERT(isLengthWritable() || !writable);
      if (!isLengthWritable() || writable)
          return;
  
<span class="line-modified">!     enterDictionaryIndexingMode(exec-&gt;vm());</span>
  
      SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
      ASSERT(map);
      map-&gt;setLengthIsReadOnly();
  }
  
  // Defined in ES5.1 15.4.5.1
<span class="line-modified">! bool JSArray::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSArray* array = jsCast&lt;JSArray*&gt;(object);
  
      // 3. If P is &quot;length&quot;, then
      if (propertyName == vm.propertyNames-&gt;length) {
          // All paths through length definition call the default [[DefineOwnProperty]], hence:
          // from ES5.1 8.12.9 7.a.
          if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">!             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
          // from ES5.1 8.12.9 7.b.
          if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">!             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
  
          // a. If the [[Value]] field of Desc is absent, then
          // a.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, Desc, and Throw as arguments.
          if (descriptor.isAccessorDescriptor())
<span class="line-modified">!             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
          // from ES5.1 8.12.9 10.a.
          if (!array-&gt;isLengthWritable() &amp;&amp; descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">!             return typeError(exec, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
          // This descriptor is either just making length read-only, or changing nothing!
          if (!descriptor.value()) {
              if (descriptor.writablePresent())
<span class="line-modified">!                 array-&gt;setLengthWritable(exec, descriptor.writable());</span>
              return true;
          }
  
          // b. Let newLenDesc be a copy of Desc.
          // c. Let newLen be ToUint32(Desc.[[Value]]).
<span class="line-modified">!         unsigned newLen = descriptor.value().toUInt32(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
          // d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception.
<span class="line-modified">!         double valueAsNumber = descriptor.value().toNumber(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (newLen != valueAsNumber) {
<span class="line-modified">!             JSC::throwException(exec, scope, createRangeError(exec, &quot;Invalid array length&quot;_s));</span>
              return false;
          }
  
          // Based on SameValue check in 8.12.9, this is always okay.
          // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
          if (newLen == array-&gt;length()) {
              if (descriptor.writablePresent())
<span class="line-modified">!                 array-&gt;setLengthWritable(exec, descriptor.writable());</span>
              return true;
          }
  
          // e. Set newLenDesc.[[Value] to newLen.
          // f. If newLen &gt;= oldLen, then
          // f.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
          // g. Reject if oldLenDesc.[[Writable]] is false.
          if (!array-&gt;isLengthWritable())
<span class="line-modified">!             return typeError(exec, scope, throwException, ReadonlyPropertyChangeError);</span>
  
          // h. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
          // i. Else,
          // i.i. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
          // i.ii. Let newWritable be false.
<span class="line-new-header">--- 132,81 ---</span>
              storage-&gt;m_vector[i].clear();
      }
      scope.notifyInitialized(array);
  }
  
<span class="line-modified">! void JSArray::setLengthWritable(JSGlobalObject* globalObject, bool writable)</span>
  {
      ASSERT(isLengthWritable() || !writable);
      if (!isLengthWritable() || writable)
          return;
  
<span class="line-modified">!     enterDictionaryIndexingMode(globalObject-&gt;vm());</span>
  
      SparseArrayValueMap* map = arrayStorage()-&gt;m_sparseMap.get();
      ASSERT(map);
      map-&gt;setLengthIsReadOnly();
  }
  
  // Defined in ES5.1 15.4.5.1
<span class="line-modified">! bool JSArray::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool throwException)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSArray* array = jsCast&lt;JSArray*&gt;(object);
  
      // 3. If P is &quot;length&quot;, then
      if (propertyName == vm.propertyNames-&gt;length) {
          // All paths through length definition call the default [[DefineOwnProperty]], hence:
          // from ES5.1 8.12.9 7.a.
          if (descriptor.configurablePresent() &amp;&amp; descriptor.configurable())
<span class="line-modified">!             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeConfigurabilityError);</span>
          // from ES5.1 8.12.9 7.b.
          if (descriptor.enumerablePresent() &amp;&amp; descriptor.enumerable())
<span class="line-modified">!             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeEnumerabilityError);</span>
  
          // a. If the [[Value]] field of Desc is absent, then
          // a.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, Desc, and Throw as arguments.
          if (descriptor.isAccessorDescriptor())
<span class="line-modified">!             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeAccessMechanismError);</span>
          // from ES5.1 8.12.9 10.a.
          if (!array-&gt;isLengthWritable() &amp;&amp; descriptor.writablePresent() &amp;&amp; descriptor.writable())
<span class="line-modified">!             return typeError(globalObject, scope, throwException, UnconfigurablePropertyChangeWritabilityError);</span>
          // This descriptor is either just making length read-only, or changing nothing!
          if (!descriptor.value()) {
              if (descriptor.writablePresent())
<span class="line-modified">!                 array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
              return true;
          }
  
          // b. Let newLenDesc be a copy of Desc.
          // c. Let newLen be ToUint32(Desc.[[Value]]).
<span class="line-modified">!         unsigned newLen = descriptor.value().toUInt32(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          // d. If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception.
<span class="line-modified">!         double valueAsNumber = descriptor.value().toNumber(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (newLen != valueAsNumber) {
<span class="line-modified">!             JSC::throwException(globalObject, scope, createRangeError(globalObject, &quot;Invalid array length&quot;_s));</span>
              return false;
          }
  
          // Based on SameValue check in 8.12.9, this is always okay.
          // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
          if (newLen == array-&gt;length()) {
              if (descriptor.writablePresent())
<span class="line-modified">!                 array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
              return true;
          }
  
          // e. Set newLenDesc.[[Value] to newLen.
          // f. If newLen &gt;= oldLen, then
          // f.i. Return the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and Throw as arguments.
          // g. Reject if oldLenDesc.[[Writable]] is false.
          if (!array-&gt;isLengthWritable())
<span class="line-modified">!             return typeError(globalObject, scope, throwException, ReadonlyPropertyChangeError);</span>
  
          // h. If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.
          // i. Else,
          // i.i. Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.
          // i.ii. Let newWritable be false.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,28 ***</span>
          // k. If succeeded is false, return false.
          // l. While newLen &lt; oldLen repeat,
          // l.i. Set oldLen to oldLen – 1.
          // l.ii. Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing ToString(oldLen) and false as arguments.
          // l.iii. If deleteSucceeded is false, then
<span class="line-modified">!         bool success = array-&gt;setLength(exec, newLen, throwException);</span>
          EXCEPTION_ASSERT(!scope.exception() || !success);
          if (!success) {
              // 1. Set newLenDesc.[[Value] to oldLen+1.
              // 2. If newWritable is false, set newLenDesc.[[Writable] to false.
              // 3. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and false as arguments.
              // 4. Reject.
              if (descriptor.writablePresent())
<span class="line-modified">!                 array-&gt;setLengthWritable(exec, descriptor.writable());</span>
              return false;
          }
  
          // m. If newWritable is false, then
          // i. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;,
          //    Property Descriptor{[[Writable]]: false}, and false as arguments. This call will always
          //    return true.
          if (descriptor.writablePresent())
<span class="line-modified">!             array-&gt;setLengthWritable(exec, descriptor.writable());</span>
          // n. Return true.
          return true;
      }
  
      // 4. Else if P is an array index (15.4), then
<span class="line-new-header">--- 215,28 ---</span>
          // k. If succeeded is false, return false.
          // l. While newLen &lt; oldLen repeat,
          // l.i. Set oldLen to oldLen – 1.
          // l.ii. Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing ToString(oldLen) and false as arguments.
          // l.iii. If deleteSucceeded is false, then
<span class="line-modified">!         bool success = array-&gt;setLength(globalObject, newLen, throwException);</span>
          EXCEPTION_ASSERT(!scope.exception() || !success);
          if (!success) {
              // 1. Set newLenDesc.[[Value] to oldLen+1.
              // 2. If newWritable is false, set newLenDesc.[[Writable] to false.
              // 3. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, newLenDesc, and false as arguments.
              // 4. Reject.
              if (descriptor.writablePresent())
<span class="line-modified">!                 array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
              return false;
          }
  
          // m. If newWritable is false, then
          // i. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;,
          //    Property Descriptor{[[Writable]]: false}, and false as arguments. This call will always
          //    return true.
          if (descriptor.writablePresent())
<span class="line-modified">!             array-&gt;setLengthWritable(globalObject, descriptor.writable());</span>
          // n. Return true.
          return true;
      }
  
      // 4. Else if P is an array index (15.4), then
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,97 ***</span>
      if (Optional&lt;uint32_t&gt; optionalIndex = parseIndex(propertyName)) {
          // b. Reject if index &gt;= oldLen and oldLenDesc.[[Writable]] is false.
          uint32_t index = optionalIndex.value();
          // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
          if (index &gt;= array-&gt;length() &amp;&amp; !array-&gt;isLengthWritable())
<span class="line-modified">!             return typeError(exec, scope, throwException, &quot;Attempting to define numeric property on array with non-writable length property.&quot;_s);</span>
          // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
          // d. Reject if succeeded is false.
          // e. If index &gt;= oldLen
          // e.i. Set oldLenDesc.[[Value]] to index + 1.
          // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
          // f. Return true.
<span class="line-modified">!         RELEASE_AND_RETURN(scope, array-&gt;defineOwnIndexedProperty(exec, index, descriptor, throwException));</span>
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, array-&gt;JSObject::defineOwnNonIndexProperty(exec, propertyName, descriptor, throwException));</span>
  }
  
<span class="line-modified">! bool JSArray::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
      if (propertyName == vm.propertyNames-&gt;length) {
          unsigned attributes = thisObject-&gt;isLengthWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
          slot.setValue(thisObject, attributes, jsNumber(thisObject-&gt;length()));
          return true;
      }
  
<span class="line-modified">!     return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
  }
  
  // ECMA 15.4.5.1
<span class="line-modified">! bool JSArray::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
      thisObject-&gt;ensureWritable(vm);
  
      if (propertyName == vm.propertyNames-&gt;length) {
          if (!thisObject-&gt;isLengthWritable()) {
              if (slot.isStrictMode())
<span class="line-modified">!                 throwTypeError(exec, scope, &quot;Array length is not writable&quot;_s);</span>
              return false;
          }
  
<span class="line-modified">!         unsigned newLength = value.toUInt32(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         double valueAsNumber = value.toNumber(exec);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (valueAsNumber != static_cast&lt;double&gt;(newLength)) {
<span class="line-modified">!             throwException(exec, scope, createRangeError(exec, &quot;Invalid array length&quot;_s));</span>
              return false;
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, thisObject-&gt;setLength(exec, newLength, slot.isStrictMode()));</span>
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSObject::put(thisObject, exec, propertyName, value, slot));</span>
  }
  
<span class="line-modified">! bool JSArray::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
  
      if (propertyName == vm.propertyNames-&gt;length)
          return false;
  
<span class="line-modified">!     return JSObject::deleteProperty(thisObject, exec, propertyName);</span>
  }
  
  static int compareKeysForQSort(const void* a, const void* b)
  {
      unsigned da = *static_cast&lt;const unsigned*&gt;(a);
      unsigned db = *static_cast&lt;const unsigned*&gt;(b);
      return (da &gt; db) - (da &lt; db);
  }
  
<span class="line-modified">! void JSArray::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
  
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;length);
  
<span class="line-modified">!     JSObject::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);</span>
  }
  
  // This method makes room in the vector, but leaves the new space for count slots uncleared.
  bool JSArray::unshiftCountSlowCase(const AbstractLocker&amp;, VM&amp; vm, DeferGC&amp;, bool addToFront, unsigned count)
  {
<span class="line-new-header">--- 244,97 ---</span>
      if (Optional&lt;uint32_t&gt; optionalIndex = parseIndex(propertyName)) {
          // b. Reject if index &gt;= oldLen and oldLenDesc.[[Writable]] is false.
          uint32_t index = optionalIndex.value();
          // FIXME: Nothing prevents this from being called on a RuntimeArray, and the length function will always return 0 in that case.
          if (index &gt;= array-&gt;length() &amp;&amp; !array-&gt;isLengthWritable())
<span class="line-modified">!             return typeError(globalObject, scope, throwException, &quot;Attempting to define numeric property on array with non-writable length property.&quot;_s);</span>
          // c. Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and false as arguments.
          // d. Reject if succeeded is false.
          // e. If index &gt;= oldLen
          // e.i. Set oldLenDesc.[[Value]] to index + 1.
          // e.ii. Call the default [[DefineOwnProperty]] internal method (8.12.9) on A passing &quot;length&quot;, oldLenDesc, and false as arguments. This call will always return true.
          // f. Return true.
<span class="line-modified">!         RELEASE_AND_RETURN(scope, array-&gt;defineOwnIndexedProperty(globalObject, index, descriptor, throwException));</span>
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, array-&gt;JSObject::defineOwnNonIndexProperty(globalObject, propertyName, descriptor, throwException));</span>
  }
  
<span class="line-modified">! bool JSArray::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
      if (propertyName == vm.propertyNames-&gt;length) {
          unsigned attributes = thisObject-&gt;isLengthWritable() ? PropertyAttribute::DontDelete | PropertyAttribute::DontEnum : PropertyAttribute::DontDelete | PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly;
          slot.setValue(thisObject, attributes, jsNumber(thisObject-&gt;length()));
          return true;
      }
  
<span class="line-modified">!     return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
  }
  
  // ECMA 15.4.5.1
<span class="line-modified">! bool JSArray::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
  
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));</span>
  
      thisObject-&gt;ensureWritable(vm);
  
      if (propertyName == vm.propertyNames-&gt;length) {
          if (!thisObject-&gt;isLengthWritable()) {
              if (slot.isStrictMode())
<span class="line-modified">!                 throwTypeError(globalObject, scope, &quot;Array length is not writable&quot;_s);</span>
              return false;
          }
  
<span class="line-modified">!         unsigned newLength = value.toUInt32(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         double valueAsNumber = value.toNumber(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (valueAsNumber != static_cast&lt;double&gt;(newLength)) {
<span class="line-modified">!             throwException(globalObject, scope, createRangeError(globalObject, &quot;Invalid array length&quot;_s));</span>
              return false;
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, thisObject-&gt;setLength(globalObject, newLength, slot.isStrictMode()));</span>
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSObject::put(thisObject, globalObject, propertyName, value, slot));</span>
  }
  
<span class="line-modified">! bool JSArray::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(cell);
  
      if (propertyName == vm.propertyNames-&gt;length)
          return false;
  
<span class="line-modified">!     return JSObject::deleteProperty(thisObject, globalObject, propertyName);</span>
  }
  
  static int compareKeysForQSort(const void* a, const void* b)
  {
      unsigned da = *static_cast&lt;const unsigned*&gt;(a);
      unsigned db = *static_cast&lt;const unsigned*&gt;(b);
      return (da &gt; db) - (da &lt; db);
  }
  
<span class="line-modified">! void JSArray::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSArray* thisObject = jsCast&lt;JSArray*&gt;(object);
  
      if (mode.includeDontEnumProperties())
          propertyNames.add(vm.propertyNames-&gt;length);
  
<span class="line-modified">!     JSObject::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode);</span>
  }
  
  // This method makes room in the vector, but leaves the new space for count slots uncleared.
  bool JSArray::unshiftCountSlowCase(const AbstractLocker&amp;, VM&amp; vm, DeferGC&amp;, bool addToFront, unsigned count)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 419,25 ***</span>
  
      Butterfly* newButterfly = Butterfly::fromBase(newAllocBase, preCapacity, propertyCapacity);
  
      if (addToFront) {
          ASSERT(count + usedVectorLength &lt;= newVectorLength);
<span class="line-modified">!         memmove(newButterfly-&gt;arrayStorage()-&gt;m_vector + count, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
<span class="line-modified">!         memmove(newButterfly-&gt;propertyStorage() - propertySize, butterfly-&gt;propertyStorage() - propertySize, sizeof(JSValue) * propertySize + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
  
          // We don&#39;t need to zero the pre-capacity for the concurrent GC because it is not available to use as property storage.
<span class="line-modified">!         memset(newButterfly-&gt;base(0, propertyCapacity), 0, (propertyCapacity - propertySize) * sizeof(JSValue));</span>
  
          if (allocatedNewStorage) {
              // We will set the vectorLength to newVectorLength. We populated requiredVectorLength
              // (usedVectorLength + count), which is less. Clear the difference.
              for (unsigned i = requiredVectorLength; i &lt; newVectorLength; ++i)
                  newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
          }
      } else if ((newAllocBase != butterfly-&gt;base(structure)) || (preCapacity != storage-&gt;m_indexBias)) {
<span class="line-modified">!         memmove(newButterfly-&gt;propertyStorage() - propertyCapacity, butterfly-&gt;propertyStorage() - propertyCapacity, sizeof(JSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
<span class="line-modified">!         memmove(newButterfly-&gt;arrayStorage()-&gt;m_vector, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
  
          for (unsigned i = requiredVectorLength; i &lt; newVectorLength; i++)
              newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
      }
  
<span class="line-new-header">--- 419,25 ---</span>
  
      Butterfly* newButterfly = Butterfly::fromBase(newAllocBase, preCapacity, propertyCapacity);
  
      if (addToFront) {
          ASSERT(count + usedVectorLength &lt;= newVectorLength);
<span class="line-modified">!         gcSafeMemmove(newButterfly-&gt;arrayStorage()-&gt;m_vector + count, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
<span class="line-modified">!         gcSafeMemmove(newButterfly-&gt;propertyStorage() - propertySize, butterfly-&gt;propertyStorage() - propertySize, sizeof(JSValue) * propertySize + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
  
          // We don&#39;t need to zero the pre-capacity for the concurrent GC because it is not available to use as property storage.
<span class="line-modified">!         gcSafeZeroMemory(static_cast&lt;JSValue*&gt;(newButterfly-&gt;base(0, propertyCapacity)), (propertyCapacity - propertySize) * sizeof(JSValue));</span>
  
          if (allocatedNewStorage) {
              // We will set the vectorLength to newVectorLength. We populated requiredVectorLength
              // (usedVectorLength + count), which is less. Clear the difference.
              for (unsigned i = requiredVectorLength; i &lt; newVectorLength; ++i)
                  newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
          }
      } else if ((newAllocBase != butterfly-&gt;base(structure)) || (preCapacity != storage-&gt;m_indexBias)) {
<span class="line-modified">!         gcSafeMemmove(newButterfly-&gt;propertyStorage() - propertyCapacity, butterfly-&gt;propertyStorage() - propertyCapacity, sizeof(JSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));</span>
<span class="line-modified">!         gcSafeMemmove(newButterfly-&gt;arrayStorage()-&gt;m_vector, storage-&gt;m_vector, sizeof(JSValue) * usedVectorLength);</span>
  
          for (unsigned i = requiredVectorLength; i &lt; newVectorLength; i++)
              newButterfly-&gt;arrayStorage()-&gt;m_vector[i].clear();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,24 ***</span>
      setButterfly(vm, newButterfly);
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::setLengthWithArrayStorage(ExecState* exec, unsigned newLength, bool throwException, ArrayStorage* storage)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length = storage-&gt;length();
  
      // If the length is read only then we enter sparse mode, so should enter the following &#39;if&#39;.
      ASSERT(isLengthWritable() || storage-&gt;m_sparseMap);
  
      if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
          // Fail if the length is not writable.
          if (map-&gt;lengthIsReadOnly())
<span class="line-modified">!             return typeError(exec, scope, throwException, ReadonlyPropertyWriteError);</span>
  
          if (newLength &lt; length) {
              // Copy any keys we might be interested in into a vector.
              Vector&lt;unsigned, 0, UnsafeVectorOverflow&gt; keys;
              keys.reserveInitialCapacity(std::min(map-&gt;size(), static_cast&lt;size_t&gt;(length - newLength)));
<span class="line-new-header">--- 447,24 ---</span>
      setButterfly(vm, newButterfly);
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::setLengthWithArrayStorage(JSGlobalObject* globalObject, unsigned newLength, bool throwException, ArrayStorage* storage)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length = storage-&gt;length();
  
      // If the length is read only then we enter sparse mode, so should enter the following &#39;if&#39;.
      ASSERT(isLengthWritable() || storage-&gt;m_sparseMap);
  
      if (SparseArrayValueMap* map = storage-&gt;m_sparseMap.get()) {
          // Fail if the length is not writable.
          if (map-&gt;lengthIsReadOnly())
<span class="line-modified">!             return typeError(globalObject, scope, throwException, ReadonlyPropertyWriteError);</span>
  
          if (newLength &lt; length) {
              // Copy any keys we might be interested in into a vector.
              Vector&lt;unsigned, 0, UnsafeVectorOverflow&gt; keys;
              keys.reserveInitialCapacity(std::min(map-&gt;size(), static_cast&lt;size_t&gt;(length - newLength)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 485,11 ***</span>
                      unsigned index = keys[--i];
                      SparseArrayValueMap::iterator it = map-&gt;find(index);
                      ASSERT(it != map-&gt;notFound());
                      if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete) {
                          storage-&gt;setLength(index + 1);
<span class="line-modified">!                         return typeError(exec, scope, throwException, UnableToDeletePropertyError);</span>
                      }
                      map-&gt;remove(it);
                  }
              } else {
                  for (unsigned i = 0; i &lt; keys.size(); ++i)
<span class="line-new-header">--- 485,11 ---</span>
                      unsigned index = keys[--i];
                      SparseArrayValueMap::iterator it = map-&gt;find(index);
                      ASSERT(it != map-&gt;notFound());
                      if (it-&gt;value.attributes() &amp; PropertyAttribute::DontDelete) {
                          storage-&gt;setLength(index + 1);
<span class="line-modified">!                         return typeError(globalObject, scope, throwException, UnableToDeletePropertyError);</span>
                      }
                      map-&gt;remove(it);
                  }
              } else {
                  for (unsigned i = 0; i &lt; keys.size(); ++i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,11 ***</span>
      storage-&gt;setLength(newLength);
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::appendMemcpy(ExecState* exec, VM&amp; vm, unsigned startIndex, JSC::JSArray* otherArray)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!canFastCopy(vm, otherArray))
          return false;
<span class="line-new-header">--- 514,11 ---</span>
      storage-&gt;setLength(newLength);
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::appendMemcpy(JSGlobalObject* globalObject, VM&amp; vm, unsigned startIndex, JSC::JSArray* otherArray)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!canFastCopy(vm, otherArray))
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,19 ***</span>
      Checked&lt;unsigned, RecordOverflow&gt; checkedNewLength = startIndex;
      checkedNewLength += otherLength;
  
      unsigned newLength;
      if (checkedNewLength.safeGet(newLength) == CheckedState::DidOverflow) {
<span class="line-modified">!         throwException(exec, scope, createRangeError(exec, LengthExceededTheMaximumArrayLengthError));</span>
          return false;
      }
  
      if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX)
          return false;
  
      if (!ensureLength(vm, newLength)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return false;
      }
      ASSERT(copyType == indexingType());
  
      if (UNLIKELY(otherType == ArrayWithUndecided)) {
<span class="line-new-header">--- 544,19 ---</span>
      Checked&lt;unsigned, RecordOverflow&gt; checkedNewLength = startIndex;
      checkedNewLength += otherLength;
  
      unsigned newLength;
      if (checkedNewLength.safeGet(newLength) == CheckedState::DidOverflow) {
<span class="line-modified">!         throwException(globalObject, scope, createRangeError(globalObject, LengthExceededTheMaximumArrayLengthError));</span>
          return false;
      }
  
      if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX)
          return false;
  
      if (!ensureLength(vm, newLength)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return false;
      }
      ASSERT(copyType == indexingType());
  
      if (UNLIKELY(otherType == ArrayWithUndecided)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 567,32 ***</span>
          } else {
              for (unsigned i = startIndex; i &lt; newLength; ++i)
                  butterfly-&gt;contiguousInt32().at(this, i).setWithoutWriteBarrier(JSValue());
          }
      } else if (type == ArrayWithDouble)
<span class="line-modified">!         memcpy(butterfly()-&gt;contiguousDouble().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguousDouble().data(), sizeof(JSValue) * otherLength);</span>
      else {
<span class="line-modified">!         memcpy(butterfly()-&gt;contiguous().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguous().data(), sizeof(JSValue) * otherLength);</span>
          vm.heap.writeBarrier(this);
      }
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::setLength(ExecState* exec, unsigned newLength, bool throwException)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
      switch (indexingMode()) {
      case ArrayClass:
          if (!newLength)
              return true;
          if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX) {
              RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified">!                 exec, newLength, throwException,</span>
                  ensureArrayStorage(vm)));
          }
          createInitialUndecided(vm, newLength);
          return true;
  
<span class="line-new-header">--- 567,32 ---</span>
          } else {
              for (unsigned i = startIndex; i &lt; newLength; ++i)
                  butterfly-&gt;contiguousInt32().at(this, i).setWithoutWriteBarrier(JSValue());
          }
      } else if (type == ArrayWithDouble)
<span class="line-modified">!         gcSafeMemcpy(butterfly()-&gt;contiguousDouble().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguousDouble().data(), sizeof(JSValue) * otherLength);</span>
      else {
<span class="line-modified">!         gcSafeMemcpy(butterfly()-&gt;contiguous().data() + startIndex, otherArray-&gt;butterfly()-&gt;contiguous().data(), sizeof(JSValue) * otherLength);</span>
          vm.heap.writeBarrier(this);
      }
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::setLength(JSGlobalObject* globalObject, unsigned newLength, bool throwException)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
      switch (indexingMode()) {
      case ArrayClass:
          if (!newLength)
              return true;
          if (newLength &gt;= MIN_SPARSE_ARRAY_INDEX) {
              RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified">!                 globalObject, newLength, throwException,</span>
                  ensureArrayStorage(vm)));
          }
          createInitialUndecided(vm, newLength);
          return true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 613,16 ***</span>
              return true;
          if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH // This check ensures that we can do fast push.
              || (newLength &gt;= MIN_SPARSE_ARRAY_INDEX
                  &amp;&amp; !isDenseEnoughForVector(newLength, countElements()))) {
              RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified">!                 exec, newLength, throwException,</span>
                  ensureArrayStorage(vm)));
          }
          if (newLength &gt; butterfly-&gt;publicLength()) {
              if (!ensureLength(vm, newLength)) {
<span class="line-modified">!                 throwOutOfMemoryError(exec, scope);</span>
                  return false;
              }
              return true;
          }
  
<span class="line-new-header">--- 613,16 ---</span>
              return true;
          if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH // This check ensures that we can do fast push.
              || (newLength &gt;= MIN_SPARSE_ARRAY_INDEX
                  &amp;&amp; !isDenseEnoughForVector(newLength, countElements()))) {
              RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(
<span class="line-modified">!                 globalObject, newLength, throwException,</span>
                  ensureArrayStorage(vm)));
          }
          if (newLength &gt; butterfly-&gt;publicLength()) {
              if (!ensureLength(vm, newLength)) {
<span class="line-modified">!                 throwOutOfMemoryError(globalObject, scope);</span>
                  return false;
              }
              return true;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 644,21 ***</span>
          return true;
      }
  
      case ArrayWithArrayStorage:
      case ArrayWithSlowPutArrayStorage:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(exec, newLength, throwException, arrayStorage()));</span>
  
      default:
          CRASH();
          return false;
      }
  }
  
<span class="line-modified">! JSValue JSArray::pop(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ensureWritable(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
<span class="line-new-header">--- 644,21 ---</span>
          return true;
      }
  
      case ArrayWithArrayStorage:
      case ArrayWithSlowPutArrayStorage:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, setLengthWithArrayStorage(globalObject, newLength, throwException, arrayStorage()));</span>
  
      default:
          CRASH();
          return false;
      }
  }
  
<span class="line-modified">! JSValue JSArray::pop(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ensureWritable(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 710,11 ***</span>
          ArrayStorage* storage = butterfly-&gt;arrayStorage();
  
          unsigned length = storage-&gt;length();
          if (!length) {
              if (!isLengthWritable())
<span class="line-modified">!                 throwTypeError(exec, scope, ReadonlyPropertyWriteError);</span>
              return jsUndefined();
          }
  
          unsigned index = length - 1;
          if (index &lt; storage-&gt;vectorLength()) {
<span class="line-new-header">--- 710,11 ---</span>
          ArrayStorage* storage = butterfly-&gt;arrayStorage();
  
          unsigned length = storage-&gt;length();
          if (!length) {
              if (!isLengthWritable())
<span class="line-modified">!                 throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);</span>
              return jsUndefined();
          }
  
          unsigned index = length - 1;
          if (index &lt; storage-&gt;vectorLength()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 737,37 ***</span>
          return JSValue();
      }
  
      unsigned index = getArrayLength() - 1;
      // Let element be the result of calling the [[Get]] internal method of O with argument indx.
<span class="line-modified">!     JSValue element = get(exec, index);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      // Call the [[Delete]] internal method of O with arguments indx and true.
<span class="line-modified">!     bool success = deletePropertyByIndex(this, exec, index);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (!success) {
<span class="line-modified">!         throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
          return jsUndefined();
      }
      // Call the [[Put]] internal method of O with arguments &quot;length&quot;, indx, and true.
      scope.release();
<span class="line-modified">!     setLength(exec, index, true);</span>
      // Return element.
      return element;
  }
  
  // Push &amp; putIndex are almost identical, with two small differences.
  //  - we always are writing beyond the current array bounds, so it is always necessary to update m_length &amp; m_numValuesInVector.
  //  - pushing to an array of length 2^32-1 stores the property, but throws a range error.
<span class="line-modified">! NEVER_INLINE void JSArray::push(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     pushInline(exec, value);</span>
  }
  
<span class="line-modified">! JSArray* JSArray::fastSlice(ExecState&amp; exec, unsigned startIndex, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
  
      ensureWritable(vm);
  
      auto arrayType = indexingMode();
      switch (arrayType) {
<span class="line-new-header">--- 737,37 ---</span>
          return JSValue();
      }
  
      unsigned index = getArrayLength() - 1;
      // Let element be the result of calling the [[Get]] internal method of O with argument indx.
<span class="line-modified">!     JSValue element = get(globalObject, index);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      // Call the [[Delete]] internal method of O with arguments indx and true.
<span class="line-modified">!     bool success = deletePropertyByIndex(this, globalObject, index);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      if (!success) {
<span class="line-modified">!         throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
          return jsUndefined();
      }
      // Call the [[Put]] internal method of O with arguments &quot;length&quot;, indx, and true.
      scope.release();
<span class="line-modified">!     setLength(globalObject, index, true);</span>
      // Return element.
      return element;
  }
  
  // Push &amp; putIndex are almost identical, with two small differences.
  //  - we always are writing beyond the current array bounds, so it is always necessary to update m_length &amp; m_numValuesInVector.
  //  - pushing to an array of length 2^32-1 stores the property, but throws a range error.
<span class="line-modified">! NEVER_INLINE void JSArray::push(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     pushInline(globalObject, value);</span>
  }
  
<span class="line-modified">! JSArray* JSArray::fastSlice(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      ensureWritable(vm);
  
      auto arrayType = indexingMode();
      switch (arrayType) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 775,28 ***</span>
      case ArrayWithInt32:
      case ArrayWithContiguous: {
          if (count &gt;= MIN_SPARSE_ARRAY_INDEX || structure(vm)-&gt;holesMustForwardToPrototype(vm, this))
              return nullptr;
  
<span class="line-modified">!         JSGlobalObject* lexicalGlobalObject = exec.lexicalGlobalObject();</span>
<span class="line-removed">-         Structure* resultStructure = lexicalGlobalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(arrayType);</span>
          if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
              return nullptr;
  
<span class="line-modified">!         ASSERT(!lexicalGlobalObject-&gt;isHavingABadTime());</span>
          ObjectInitializationScope scope(vm);
          JSArray* resultArray = JSArray::tryCreateUninitializedRestricted(scope, resultStructure, count);
          if (UNLIKELY(!resultArray))
              return nullptr;
  
          auto&amp; resultButterfly = *resultArray-&gt;butterfly();
          if (arrayType == ArrayWithDouble)
<span class="line-modified">!             memcpy(resultButterfly.contiguousDouble().data(), butterfly()-&gt;contiguousDouble().data() + startIndex, sizeof(JSValue) * count);</span>
          else
<span class="line-modified">!             memcpy(resultButterfly.contiguous().data(), butterfly()-&gt;contiguous().data() + startIndex, sizeof(JSValue) * count);</span>
<span class="line-removed">-         resultButterfly.setPublicLength(count);</span>
  
          return resultArray;
      }
      default:
          return nullptr;
      }
<span class="line-new-header">--- 775,27 ---</span>
      case ArrayWithInt32:
      case ArrayWithContiguous: {
          if (count &gt;= MIN_SPARSE_ARRAY_INDEX || structure(vm)-&gt;holesMustForwardToPrototype(vm, this))
              return nullptr;
  
<span class="line-modified">!         Structure* resultStructure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(arrayType);</span>
          if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
              return nullptr;
  
<span class="line-modified">!         ASSERT(!globalObject-&gt;isHavingABadTime());</span>
          ObjectInitializationScope scope(vm);
          JSArray* resultArray = JSArray::tryCreateUninitializedRestricted(scope, resultStructure, count);
          if (UNLIKELY(!resultArray))
              return nullptr;
  
          auto&amp; resultButterfly = *resultArray-&gt;butterfly();
          if (arrayType == ArrayWithDouble)
<span class="line-modified">!             gcSafeMemcpy(resultButterfly.contiguousDouble().data(), butterfly()-&gt;contiguousDouble().data() + startIndex, sizeof(JSValue) * count);</span>
          else
<span class="line-modified">!             gcSafeMemcpy(resultButterfly.contiguous().data(), butterfly()-&gt;contiguous().data() + startIndex, sizeof(JSValue) * count);</span>
  
<span class="line-added">+         ASSERT(resultButterfly.publicLength() == count);</span>
          return resultArray;
      }
      default:
          return nullptr;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,11 ***</span>
      if (numElementsBeforeShiftRegion &lt; numElementsAfterShiftRegion) {
          // The number of elements before the shift region is less than the number of elements
          // after the shift region, so we move the elements before to the right.
          if (numElementsBeforeShiftRegion) {
              RELEASE_ASSERT(count + startIndex &lt;= vectorLength);
<span class="line-modified">!             memmove(storage-&gt;m_vector + count,</span>
                  storage-&gt;m_vector,
                  sizeof(JSValue) * startIndex);
          }
          // Adjust the Butterfly and the index bias. We only need to do this here because we&#39;re changing
          // the start of the Butterfly, which needs to point at the first indexed property in the used
<span class="line-new-header">--- 847,11 ---</span>
      if (numElementsBeforeShiftRegion &lt; numElementsAfterShiftRegion) {
          // The number of elements before the shift region is less than the number of elements
          // after the shift region, so we move the elements before to the right.
          if (numElementsBeforeShiftRegion) {
              RELEASE_ASSERT(count + startIndex &lt;= vectorLength);
<span class="line-modified">!             gcSafeMemmove(storage-&gt;m_vector + count,</span>
                  storage-&gt;m_vector,
                  sizeof(JSValue) * startIndex);
          }
          // Adjust the Butterfly and the index bias. We only need to do this here because we&#39;re changing
          // the start of the Butterfly, which needs to point at the first indexed property in the used
</pre>
<hr />
<pre>
<span class="line-old-header">*** 866,11 ***</span>
          storage-&gt;setVectorLength(vectorLength - count);
          setButterfly(vm, butterfly);
      } else {
          // The number of elements before the shift region is greater than or equal to the number
          // of elements after the shift region, so we move the elements after the shift region to the left.
<span class="line-modified">!         memmove(storage-&gt;m_vector + startIndex,</span>
              storage-&gt;m_vector + firstIndexAfterShiftRegion,
              sizeof(JSValue) * numElementsAfterShiftRegion);
  
          // Clear the slots of the elements we just moved.
          unsigned startOfEmptyVectorTail = usedVectorLength - count;
<span class="line-new-header">--- 865,11 ---</span>
          storage-&gt;setVectorLength(vectorLength - count);
          setButterfly(vm, butterfly);
      } else {
          // The number of elements before the shift region is greater than or equal to the number
          // of elements after the shift region, so we move the elements after the shift region to the left.
<span class="line-modified">!         gcSafeMemmove(storage-&gt;m_vector + startIndex,</span>
              storage-&gt;m_vector + firstIndexAfterShiftRegion,
              sizeof(JSValue) * numElementsAfterShiftRegion);
  
          // Clear the slots of the elements we just moved.
          unsigned startOfEmptyVectorTail = usedVectorLength - count;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 883,20 ***</span>
      }
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::shiftCountWithAnyIndexingType(ExecState* exec, unsigned&amp; startIndex, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RELEASE_ASSERT(count &gt; 0);
  
      ensureWritable(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
  
<span class="line-modified">!     switch (indexingType()) {</span>
      case ArrayClass:
          return true;
  
      case ArrayWithUndecided:
          // Don&#39;t handle this because it&#39;s confusing and it shouldn&#39;t come up.
<span class="line-new-header">--- 882,21 ---</span>
      }
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::shiftCountWithAnyIndexingType(JSGlobalObject* globalObject, unsigned&amp; startIndex, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      RELEASE_ASSERT(count &gt; 0);
  
      ensureWritable(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
  
<span class="line-modified">!     auto indexingType = this-&gt;indexingType();</span>
<span class="line-added">+     switch (indexingType) {</span>
      case ArrayClass:
          return true;
  
      case ArrayWithUndecided:
          // Don&#39;t handle this because it&#39;s confusing and it shouldn&#39;t come up.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,11 ***</span>
                      return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
                  }
                  butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
              }
          } else {
<span class="line-modified">!             memmove(butterfly-&gt;contiguous().data() + startIndex,</span>
                  butterfly-&gt;contiguous().data() + startIndex + count,
                  sizeof(JSValue) * (end - startIndex));
          }
  
          for (unsigned i = end; i &lt; oldLength; ++i)
<span class="line-new-header">--- 925,11 ---</span>
                      return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
                  }
                  butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
              }
          } else {
<span class="line-modified">!             gcSafeMemmove(butterfly-&gt;contiguous().data() + startIndex,</span>
                  butterfly-&gt;contiguous().data() + startIndex + count,
                  sizeof(JSValue) * (end - startIndex));
          }
  
          for (unsigned i = end; i &lt; oldLength; ++i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,11 ***</span>
  
          butterfly-&gt;setPublicLength(oldLength - count);
  
          // Our memmoving of values around in the array could have concealed some of them from
          // the collector. Let&#39;s make sure that the collector scans this object again.
<span class="line-modified">!         vm.heap.writeBarrier(this);</span>
  
          return true;
      }
  
      case ArrayWithDouble: {
<span class="line-new-header">--- 937,12 ---</span>
  
          butterfly-&gt;setPublicLength(oldLength - count);
  
          // Our memmoving of values around in the array could have concealed some of them from
          // the collector. Let&#39;s make sure that the collector scans this object again.
<span class="line-modified">!         if (indexingType == ArrayWithContiguous)</span>
<span class="line-added">+             vm.heap.writeBarrier(this);</span>
  
          return true;
      }
  
      case ArrayWithDouble: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 966,11 ***</span>
                      return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
                  }
                  butterfly-&gt;contiguousDouble().at(this, i) = v;
              }
          } else {
<span class="line-modified">!             memmove(butterfly-&gt;contiguousDouble().data() + startIndex,</span>
                  butterfly-&gt;contiguousDouble().data() + startIndex + count,
                  sizeof(JSValue) * (end - startIndex));
          }
          for (unsigned i = end; i &lt; oldLength; ++i)
              butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
<span class="line-new-header">--- 967,11 ---</span>
                      return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
                  }
                  butterfly-&gt;contiguousDouble().at(this, i) = v;
              }
          } else {
<span class="line-modified">!             gcSafeMemmove(butterfly-&gt;contiguousDouble().data() + startIndex,</span>
                  butterfly-&gt;contiguousDouble().data() + startIndex + count,
                  sizeof(JSValue) * (end - startIndex));
          }
          for (unsigned i = end; i &lt; oldLength; ++i)
              butterfly-&gt;contiguousDouble().at(this, i) = PNaN;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 988,13 ***</span>
          return false;
      }
  }
  
  // Returns true if the unshift can be handled, false to fallback.
<span class="line-modified">! bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length = storage-&gt;length();
  
      RELEASE_ASSERT(startIndex &lt;= length);
<span class="line-new-header">--- 989,13 ---</span>
          return false;
      }
  }
  
  // Returns true if the unshift can be handled, false to fallback.
<span class="line-modified">! bool JSArray::unshiftCountWithArrayStorage(JSGlobalObject* globalObject, unsigned startIndex, unsigned count, ArrayStorage* storage)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length = storage-&gt;length();
  
      RELEASE_ASSERT(startIndex &lt;= length);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1022,32 ***</span>
      } else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)
          storage = storage-&gt;butterfly()-&gt;arrayStorage();
      else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
          storage = arrayStorage();
      else {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return true;
      }
  
      WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
  
      if (startIndex) {
          if (moveFront)
<span class="line-modified">!             memmove(vector, vector + count, startIndex * sizeof(JSValue));</span>
          else if (length - startIndex)
<span class="line-modified">!             memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));</span>
      }
  
      for (unsigned i = 0; i &lt; count; i++)
          vector[i + startIndex].clear();
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::unshiftCountWithAnyIndexingType(ExecState* exec, unsigned startIndex, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ensureWritable(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
<span class="line-new-header">--- 1023,32 ---</span>
      } else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)
          storage = storage-&gt;butterfly()-&gt;arrayStorage();
      else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))
          storage = arrayStorage();
      else {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return true;
      }
  
      WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;
  
      if (startIndex) {
          if (moveFront)
<span class="line-modified">!             gcSafeMemmove(vector, vector + count, startIndex * sizeof(JSValue));</span>
          else if (length - startIndex)
<span class="line-modified">!             gcSafeMemmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));</span>
      }
  
      for (unsigned i = 0; i &lt; count; i++)
          vector[i + startIndex].clear();
  
      return true;
  }
  
<span class="line-modified">! bool JSArray::unshiftCountWithAnyIndexingType(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ensureWritable(vm);
  
      Butterfly* butterfly = this-&gt;butterfly();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,33 ***</span>
          unsigned oldLength = butterfly-&gt;publicLength();
  
          // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
          // only if it&#39;s not horribly slow.
          if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
  
          Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
          checkedLength += count;
          unsigned newLength;
          if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return true;
          }
          if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
              return false;
          if (!ensureLength(vm, newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return true;
          }
          butterfly = this-&gt;butterfly();
  
          // We have to check for holes before we start moving things around so that we don&#39;t get halfway
          // through shifting and then realize we should have been in ArrayStorage mode.
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              JSValue v = butterfly-&gt;contiguous().at(this, i).get();
              if (UNLIKELY(!v))
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
          }
  
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              JSValue v = butterfly-&gt;contiguous().at(this, i).get();
              ASSERT(v);
<span class="line-new-header">--- 1064,33 ---</span>
          unsigned oldLength = butterfly-&gt;publicLength();
  
          // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
          // only if it&#39;s not horribly slow.
          if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
  
          Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
          checkedLength += count;
          unsigned newLength;
          if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return true;
          }
          if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
              return false;
          if (!ensureLength(vm, newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return true;
          }
          butterfly = this-&gt;butterfly();
  
          // We have to check for holes before we start moving things around so that we don&#39;t get halfway
          // through shifting and then realize we should have been in ArrayStorage mode.
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              JSValue v = butterfly-&gt;contiguous().at(this, i).get();
              if (UNLIKELY(!v))
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
          }
  
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              JSValue v = butterfly-&gt;contiguous().at(this, i).get();
              ASSERT(v);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1112,33 ***</span>
          unsigned oldLength = butterfly-&gt;publicLength();
  
          // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
          // only if it&#39;s not horribly slow.
          if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
  
          Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
          checkedLength += count;
          unsigned newLength;
          if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return true;
          }
          if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
              return false;
          if (!ensureLength(vm, newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return true;
          }
          butterfly = this-&gt;butterfly();
  
          // We have to check for holes before we start moving things around so that we don&#39;t get halfway
          // through shifting and then realize we should have been in ArrayStorage mode.
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              double v = butterfly-&gt;contiguousDouble().at(this, i);
              if (UNLIKELY(v != v))
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(vm)));</span>
          }
  
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              double v = butterfly-&gt;contiguousDouble().at(this, i);
              ASSERT(v == v);
<span class="line-new-header">--- 1113,33 ---</span>
          unsigned oldLength = butterfly-&gt;publicLength();
  
          // We may have to walk the entire array to do the unshift. We&#39;re willing to do so
          // only if it&#39;s not horribly slow.
          if (oldLength - startIndex &gt;= MIN_SPARSE_ARRAY_INDEX)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
  
          Checked&lt;unsigned, RecordOverflow&gt; checkedLength(oldLength);
          checkedLength += count;
          unsigned newLength;
          if (CheckedState::DidOverflow == checkedLength.safeGet(newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return true;
          }
          if (newLength &gt; MAX_STORAGE_VECTOR_LENGTH)
              return false;
          if (!ensureLength(vm, newLength)) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return true;
          }
          butterfly = this-&gt;butterfly();
  
          // We have to check for holes before we start moving things around so that we don&#39;t get halfway
          // through shifting and then realize we should have been in ArrayStorage mode.
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              double v = butterfly-&gt;contiguousDouble().at(this, i);
              if (UNLIKELY(v != v))
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(vm)));</span>
          }
  
          for (unsigned i = oldLength; i-- &gt; startIndex;) {
              double v = butterfly-&gt;contiguousDouble().at(this, i);
              ASSERT(v == v);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1153,19 ***</span>
          return true;
      }
  
      case ArrayWithArrayStorage:
      case ArrayWithSlowPutArrayStorage:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(exec, startIndex, count, arrayStorage()));</span>
  
      default:
          CRASH();
          return false;
      }
  }
  
<span class="line-modified">! void JSArray::fillArgList(ExecState* exec, MarkedArgumentBuffer&amp; args)</span>
  {
      unsigned i = 0;
      unsigned vectorEnd;
      WriteBarrier&lt;Unknown&gt;* vector;
  
<span class="line-new-header">--- 1154,19 ---</span>
          return true;
      }
  
      case ArrayWithArrayStorage:
      case ArrayWithSlowPutArrayStorage:
<span class="line-modified">!         RELEASE_AND_RETURN(scope, unshiftCountWithArrayStorage(globalObject, startIndex, count, arrayStorage()));</span>
  
      default:
          CRASH();
          return false;
      }
  }
  
<span class="line-modified">! void JSArray::fillArgList(JSGlobalObject* globalObject, MarkedArgumentBuffer&amp; args)</span>
  {
      unsigned i = 0;
      unsigned vectorEnd;
      WriteBarrier&lt;Unknown&gt;* vector;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1224,16 ***</span>
          args.append(v.get());
      }
  
      // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
      for (; i &lt; length(); ++i)
<span class="line-modified">!         args.append(get(exec, i));</span>
  }
  
<span class="line-modified">! void JSArray::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned i = offset;
      WriteBarrier&lt;Unknown&gt;* vector;
      unsigned vectorEnd;
<span class="line-new-header">--- 1225,16 ---</span>
          args.append(v.get());
      }
  
      // FIXME: What prevents this from being called with a RuntimeArray? The length function will always return 0 in that case.
      for (; i &lt; length(); ++i)
<span class="line-modified">!         args.append(get(globalObject, i));</span>
  }
  
<span class="line-modified">! void JSArray::copyToArguments(JSGlobalObject* globalObject, JSValue* firstElementDest, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned i = offset;
      WriteBarrier&lt;Unknown&gt;* vector;
      unsigned vectorEnd;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1266,11 ***</span>
          for (; i &lt; butterfly-&gt;publicLength(); ++i) {
              ASSERT(i &lt; butterfly-&gt;vectorLength());
              double v = butterfly-&gt;contiguousDouble().at(this, i);
              if (v != v)
                  break;
<span class="line-modified">!             exec-&gt;r(firstElementDest + i - offset) = JSValue(JSValue::EncodeAsDouble, v);</span>
          }
          break;
      }
  
      case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
<span class="line-new-header">--- 1267,11 ---</span>
          for (; i &lt; butterfly-&gt;publicLength(); ++i) {
              ASSERT(i &lt; butterfly-&gt;vectorLength());
              double v = butterfly-&gt;contiguousDouble().at(this, i);
              if (v != v)
                  break;
<span class="line-modified">!             firstElementDest[i - offset] = JSValue(JSValue::EncodeAsDouble, v);</span>
          }
          break;
      }
  
      case ARRAY_WITH_ARRAY_STORAGE_INDEXING_TYPES: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1291,15 ***</span>
  
      for (; i &lt; vectorEnd; ++i) {
          WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
          if (!v)
              break;
<span class="line-modified">!         exec-&gt;r(firstElementDest + i - offset) = v.get();</span>
      }
  
      for (; i &lt; length; ++i) {
<span class="line-modified">!         exec-&gt;r(firstElementDest + i - offset) = get(exec, i);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  }
  
  bool JSArray::isIteratorProtocolFastAndNonObservable()
<span class="line-new-header">--- 1292,15 ---</span>
  
      for (; i &lt; vectorEnd; ++i) {
          WriteBarrier&lt;Unknown&gt;&amp; v = vector[i];
          if (!v)
              break;
<span class="line-modified">!         firstElementDest[i - offset] = v.get();</span>
      }
  
      for (; i &lt; length; ++i) {
<span class="line-modified">!         firstElementDest[i - offset] = get(globalObject, i);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
  }
  
  bool JSArray::isIteratorProtocolFastAndNonObservable()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1343,36 ***</span>
          JSArray::eagerlyInitializeButterfly(scope, array, length);
  
      return array;
  }
  
<span class="line-modified">! JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const ArgList&amp; values)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      unsigned length = values.size();
      ObjectInitializationScope scope(vm);
  
      JSArray* array = constructArray(scope, arrayStructure, length);
      for (unsigned i = 0; i &lt; length; ++i)
          array-&gt;initializeIndex(scope, i, values.at(i));
      return array;
  }
  
<span class="line-modified">! JSArray* constructArray(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ObjectInitializationScope scope(vm);
  
      JSArray* array = constructArray(scope, arrayStructure, length);
      for (unsigned i = 0; i &lt; length; ++i)
          array-&gt;initializeIndex(scope, i, values[i]);
      return array;
  }
  
<span class="line-modified">! JSArray* constructArrayNegativeIndexed(ExecState* exec, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ObjectInitializationScope scope(vm);
  
      JSArray* array = constructArray(scope, arrayStructure, length);
      for (int i = 0; i &lt; static_cast&lt;int&gt;(length); ++i)
          array-&gt;initializeIndex(scope, i, values[-i]);
<span class="line-new-header">--- 1344,36 ---</span>
          JSArray::eagerlyInitializeButterfly(scope, array, length);
  
      return array;
  }
  
<span class="line-modified">! JSArray* constructArray(JSGlobalObject* globalObject, Structure* arrayStructure, const ArgList&amp; values)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      unsigned length = values.size();
      ObjectInitializationScope scope(vm);
  
      JSArray* array = constructArray(scope, arrayStructure, length);
      for (unsigned i = 0; i &lt; length; ++i)
          array-&gt;initializeIndex(scope, i, values.at(i));
      return array;
  }
  
<span class="line-modified">! JSArray* constructArray(JSGlobalObject* globalObject, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      ObjectInitializationScope scope(vm);
  
      JSArray* array = constructArray(scope, arrayStructure, length);
      for (unsigned i = 0; i &lt; length; ++i)
          array-&gt;initializeIndex(scope, i, values[i]);
      return array;
  }
  
<span class="line-modified">! JSArray* constructArrayNegativeIndexed(JSGlobalObject* globalObject, Structure* arrayStructure, const JSValue* values, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      ObjectInitializationScope scope(vm);
  
      JSArray* array = constructArray(scope, arrayStructure, length);
      for (int i = 0; i &lt; static_cast&lt;int&gt;(length); ++i)
          array-&gt;initializeIndex(scope, i, values[-i]);
</pre>
<center><a href="IteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArray.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
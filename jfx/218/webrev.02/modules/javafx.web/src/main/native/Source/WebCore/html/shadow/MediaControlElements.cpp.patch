diff a/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp
@@ -46,20 +46,22 @@
 #include "ImageBuffer.h"
 #include "LocalizedStrings.h"
 #include "Logging.h"
 #include "MediaControls.h"
 #include "MouseEvent.h"
+#include "PODInterval.h"
 #include "Page.h"
 #include "PageGroup.h"
 #include "RenderLayer.h"
 #include "RenderMediaControlElements.h"
 #include "RenderSlider.h"
 #include "RenderTheme.h"
 #include "RenderVideo.h"
 #include "RenderView.h"
 #include "Settings.h"
 #include "ShadowRoot.h"
+#include "TextTrackCueGeneric.h"
 #include "TextTrackList.h"
 #include "VTTRegionList.h"
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/Language.h>
 
@@ -191,14 +193,14 @@
     double left = position.x();
     double top = position.y();
 
     // Set the left and top to control the panel's position; this depends on it being absolute positioned.
     // Set the margin to zero since the position passed in will already include the effect of the margin.
-    setInlineStyleProperty(CSSPropertyLeft, left, CSSPrimitiveValue::CSS_PX);
-    setInlineStyleProperty(CSSPropertyTop, top, CSSPrimitiveValue::CSS_PX);
-    setInlineStyleProperty(CSSPropertyMarginLeft, 0.0, CSSPrimitiveValue::CSS_PX);
-    setInlineStyleProperty(CSSPropertyMarginTop, 0.0, CSSPrimitiveValue::CSS_PX);
+    setInlineStyleProperty(CSSPropertyLeft, left, CSSUnitType::CSS_PX);
+    setInlineStyleProperty(CSSPropertyTop, top, CSSUnitType::CSS_PX);
+    setInlineStyleProperty(CSSPropertyMarginLeft, 0.0, CSSUnitType::CSS_PX);
+    setInlineStyleProperty(CSSPropertyMarginTop, 0.0, CSSUnitType::CSS_PX);
 
     classList().add("dragged");
 }
 
 void MediaControlPanelElement::resetPosition()
@@ -220,12 +222,12 @@
         return;
 
     double duration = RenderTheme::singleton().mediaControlsFadeInDuration();
 
     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
-    setInlineStyleProperty(CSSPropertyTransitionDuration, duration, CSSPrimitiveValue::CSS_S);
-    setInlineStyleProperty(CSSPropertyOpacity, 1.0, CSSPrimitiveValue::CSS_NUMBER);
+    setInlineStyleProperty(CSSPropertyTransitionDuration, duration, CSSUnitType::CSS_S);
+    setInlineStyleProperty(CSSPropertyOpacity, 1.0, CSSUnitType::CSS_NUMBER);
 
     m_opaque = true;
 
     if (m_isDisplayed)
         show();
@@ -237,12 +239,12 @@
         return;
 
     Seconds duration = RenderTheme::singleton().mediaControlsFadeOutDuration();
 
     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
-    setInlineStyleProperty(CSSPropertyTransitionDuration, duration.value(), CSSPrimitiveValue::CSS_S);
-    setInlineStyleProperty(CSSPropertyOpacity, 0.0, CSSPrimitiveValue::CSS_NUMBER);
+    setInlineStyleProperty(CSSPropertyTransitionDuration, duration.value(), CSSUnitType::CSS_S);
+    setInlineStyleProperty(CSSPropertyOpacity, 0.0, CSSUnitType::CSS_NUMBER);
 
     m_opaque = false;
     startTimer();
 }
 
@@ -1123,18 +1125,17 @@
 
     auto mediaElement = parentMediaElement(this);
     // 1. If the media element is an audio element, or is another playback
     // mechanism with no rendering area, abort these steps. There is nothing to
     // render.
-    if (!mediaElement || !mediaElement->isVideo())
+    if (!mediaElement || !mediaElement->isVideo() || m_videoDisplaySize.size().isEmpty())
         return;
 
     // 2. Let video be the media element or other playback mechanism.
     HTMLVideoElement& video = downcast<HTMLVideoElement>(*mediaElement);
 
     // 3. Let output be an empty list of absolutely positioned CSS block boxes.
-    Vector<RefPtr<HTMLDivElement>> output;
 
     // 4. If the user agent is exposing a user interface for video, add to
     // output one or more completely transparent positioned CSS block boxes that
     // cover the same region as the user interface.
 
@@ -1171,59 +1172,37 @@
     // traverse all children just to check if there are less children than cues.
     if (countChildNodes() < activeCues.size())
         removeChildren();
 
     activeCues.removeAllMatching([] (CueInterval& cueInterval) {
-        if (!is<VTTCue>(cueInterval.data()))
-            return true;
-
-        Ref<VTTCue> cue = downcast<VTTCue>(*cueInterval.data());
-
-        return !cue->isRenderable()
-            || !cue->track()
+        RefPtr<TextTrackCue> cue = cueInterval.data();
+        return !cue->track()
             || !cue->track()->isRendered()
             || cue->track()->mode() == TextTrack::Mode::Disabled
             || !cue->isActive()
-            || cue->text().isEmpty();
+            || !cue->isRenderable();
     });
 
     // Sort the active cues for the appropriate display order. For example, for roll-up
     // or paint-on captions, we need to add the cues in reverse chronological order,
     // so that the newest captions appear at the bottom.
     std::sort(activeCues.begin(), activeCues.end(), &compareCueIntervalForDisplay);
 
-    // 10. For each text track cue cue in cues that has not yet had
-    // corresponding CSS boxes added to output, in text track cue order, run the
-    // following substeps:
-    for (size_t i = 0; i < activeCues.size(); ++i) {
-        if (!mediaController()->closedCaptionsVisible())
-            continue;
-
-        RefPtr<VTTCue> cue = downcast<VTTCue>(activeCues[i].data());
-
-        DEBUG_LOG(LOGIDENTIFIER, "adding and positioning cue ", i, ": \"", cue->text(), "\", start=", cue->startTime(), ", end=", cue->endTime(), ", line=", cue->line());
-        Ref<VTTCueBox> displayBox = cue->getDisplayTree(m_videoDisplaySize.size(), m_fontSize);
-        RefPtr<VTTRegion> region = cue->track()->regions()->getRegionById(cue->regionId());
-        if (!region) {
-            // If cue has an empty text track cue region identifier or there is no
-            // WebVTT region whose region identifier is identical to cue's text
-            // track cue region identifier, run the following substeps:
-            if (displayBox->hasChildNodes() && !contains(displayBox.ptr())) {
-                // Note: the display tree of a cue is removed when the active flag of the cue is unset.
-                appendChild(displayBox);
-                cue->setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
+    if (mediaController()->closedCaptionsVisible()) {
+        // 10. For each text track cue cue in cues that has not yet had
+        // corresponding CSS boxes added to output, in text track cue order, run the
+        // following substeps:
+        for (auto& interval : activeCues) {
+            auto cue = interval.data();
+            cue->setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
+            if (is<VTTCue>(cue) || is<TextTrackCueGeneric>(cue))
+                processActiveVTTCue(*toVTTCue(cue));
+            else {
+                auto displayBox = cue->getDisplayTree(m_videoDisplaySize.size(), m_fontSize);
+                if (displayBox->hasChildNodes() && !contains(displayBox.get()))
+                    appendChild(*displayBox);
             }
-        } else {
-            // Let region be the WebVTT region whose region identifier
-            // matches the text track cue region identifier of cue.
-            Ref<HTMLDivElement> regionNode = region->getDisplayTree();
-
-            // Append the region to the viewport, if it was not already.
-            if (!contains(regionNode.ptr()))
-                appendChild(region->getDisplayTree());
-
-            region->appendTextTrackCueBox(WTFMove(displayBox));
         }
     }
 
     // 11. Return output.
     if (hasChildNodes()) {
@@ -1233,10 +1212,37 @@
         hide();
         clearTextTrackRepresentation();
     }
 }
 
+void MediaControlTextTrackContainerElement::processActiveVTTCue(VTTCue& cue)
+{
+    ASSERT(is<VTTCue>(cue) || is<TextTrackCueGeneric>(cue));
+
+    DEBUG_LOG(LOGIDENTIFIER, "adding and positioning cue: \"", cue.text(), "\", start=", cue.startTime(), ", end=", cue.endTime(), ", line=", cue.line());
+    Ref<TextTrackCueBox> displayBox = *cue.getDisplayTree(m_videoDisplaySize.size(), m_fontSize);
+
+    if (auto region = cue.track()->regions()->getRegionById(cue.regionId())) {
+        // Let region be the WebVTT region whose region identifier
+        // matches the text track cue region identifier of cue.
+        Ref<HTMLDivElement> regionNode = region->getDisplayTree();
+
+        if (!contains(regionNode.ptr()))
+            appendChild(region->getDisplayTree());
+
+        region->appendTextTrackCueBox(WTFMove(displayBox));
+    } else {
+        // If cue has an empty text track cue region identifier or there is no
+        // WebVTT region whose region identifier is identical to cue's text
+        // track cue region identifier, run the following substeps:
+        if (displayBox->hasChildNodes() && !contains(displayBox.ptr())) {
+            // Note: the display tree of a cue is removed when the active flag of the cue is unset.
+            appendChild(displayBox);
+        }
+    }
+}
+
 void MediaControlTextTrackContainerElement::updateActiveCuesFontSize()
 {
     if (!document().page())
         return;
 
@@ -1248,16 +1254,13 @@
     float fontScale = document().page()->group().captionPreferences().captionFontSizeScaleAndImportance(m_fontSizeIsImportant);
     m_fontSize = lroundf(smallestDimension * fontScale);
 
     for (auto& activeCue : mediaElement->currentlyActiveCues()) {
         RefPtr<TextTrackCue> cue = activeCue.data();
-        if (!cue->isRenderable())
-            continue;
-
-        toVTTCue(cue.get())->setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
+        if (cue->isRenderable())
+            cue->setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);
     }
-
 }
 
 void MediaControlTextTrackContainerElement::updateTextStrokeStyle()
 {
     if (!document().page())
@@ -1285,18 +1288,25 @@
     float strokeWidth;
     bool important;
 
     // FIXME: find a way to set this property in the stylesheet like the other user style preferences, see <https://bugs.webkit.org/show_bug.cgi?id=169874>.
     if (document().page()->group().captionPreferences().captionStrokeWidthForFont(m_fontSize, language, strokeWidth, important))
-        setInlineStyleProperty(CSSPropertyStrokeWidth, strokeWidth, CSSPrimitiveValue::CSS_PX, important);
+        setInlineStyleProperty(CSSPropertyStrokeWidth, strokeWidth, CSSUnitType::CSS_PX, important);
 }
 
 void MediaControlTextTrackContainerElement::updateTimerFired()
 {
     if (!document().page())
         return;
 
+    auto mediaElement = parentMediaElement(this);
+    if (!mediaElement)
+        return;
+
+    for (auto& activeCue : mediaElement->currentlyActiveCues())
+        activeCue.data()->recalculateStyles();
+
     if (m_textTrackRepresentation)
         updateStyleForTextTrackRepresentation();
 
     updateActiveCuesFontSize();
     updateDisplay();
@@ -1310,11 +1320,11 @@
         return;
 
     if (!mediaElement->requiresTextTrackRepresentation()) {
         if (m_textTrackRepresentation) {
             clearTextTrackRepresentation();
-            updateSizes(true);
+            updateSizes(ForceUpdate::Yes);
         }
         return;
     }
 
     if (!m_textTrackRepresentation) {
@@ -1344,18 +1354,19 @@
 
 void MediaControlTextTrackContainerElement::updateStyleForTextTrackRepresentation()
 {
     if (!m_updateTextTrackRepresentationStyle)
         return;
+
     m_updateTextTrackRepresentationStyle = false;
 
     if (m_textTrackRepresentation) {
-        setInlineStyleProperty(CSSPropertyWidth, m_videoDisplaySize.size().width(), CSSPrimitiveValue::CSS_PX);
-        setInlineStyleProperty(CSSPropertyHeight, m_videoDisplaySize.size().height(), CSSPrimitiveValue::CSS_PX);
+        setInlineStyleProperty(CSSPropertyWidth, m_videoDisplaySize.size().width(), CSSUnitType::CSS_PX);
+        setInlineStyleProperty(CSSPropertyHeight, m_videoDisplaySize.size().height(), CSSUnitType::CSS_PX);
         setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
-        setInlineStyleProperty(CSSPropertyLeft, 0, CSSPrimitiveValue::CSS_PX);
-        setInlineStyleProperty(CSSPropertyTop, 0, CSSPrimitiveValue::CSS_PX);
+        setInlineStyleProperty(CSSPropertyLeft, 0, CSSUnitType::CSS_PX);
+        setInlineStyleProperty(CSSPropertyTop, 0, CSSUnitType::CSS_PX);
         return;
     }
 
     removeInlineStyleProperty(CSSPropertyPosition);
     removeInlineStyleProperty(CSSPropertyWidth);
@@ -1366,20 +1377,20 @@
 
 void MediaControlTextTrackContainerElement::enteredFullscreen()
 {
     if (hasChildNodes())
         updateTextTrackRepresentation();
-    updateSizes(true);
+    updateSizes(ForceUpdate::Yes);
 }
 
 void MediaControlTextTrackContainerElement::exitedFullscreen()
 {
     clearTextTrackRepresentation();
-    updateSizes(true);
+    updateSizes(ForceUpdate::Yes);
 }
 
-void MediaControlTextTrackContainerElement::updateSizes(bool forceUpdate)
+void MediaControlTextTrackContainerElement::updateSizes(ForceUpdate force)
 {
     auto mediaElement = parentMediaElement(this);
     if (!mediaElement)
         return;
 
@@ -1396,11 +1407,11 @@
         if (!is<RenderVideo>(mediaElement->renderer()))
             return;
         videoBox = downcast<RenderVideo>(*mediaElement->renderer()).videoBox();
     }
 
-    if (!forceUpdate && m_videoDisplaySize == videoBox)
+    if (force == ForceUpdate::No && m_videoDisplaySize == videoBox)
         return;
 
     m_videoDisplaySize = videoBox;
     m_updateTextTrackRepresentationStyle = true;
     mediaElement->syncTextTrackBounds();
@@ -1434,11 +1445,11 @@
         deviceScaleFactor = page->deviceScaleFactor();
 
     IntRect paintingRect = IntRect(IntPoint(), layer->size());
 
     // FIXME (149422): This buffer should not be unconditionally unaccelerated.
-    std::unique_ptr<ImageBuffer> buffer(ImageBuffer::create(paintingRect.size(), Unaccelerated, deviceScaleFactor));
+    std::unique_ptr<ImageBuffer> buffer(ImageBuffer::create(paintingRect.size(), RenderingMode::Unaccelerated, deviceScaleFactor));
     if (!buffer)
         return nullptr;
 
     layer->paint(buffer->context(), paintingRect, LayoutSize(), { PaintBehavior::FlattenCompositingLayers, PaintBehavior::Snapshotting }, nullptr, RenderLayer::paintLayerPaintingCompositingAllPhasesFlags());
 

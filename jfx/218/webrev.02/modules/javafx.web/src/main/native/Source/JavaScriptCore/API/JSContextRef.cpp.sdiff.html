<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSClassRef.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSHeapFinalizerPrivate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006, 2007, 2013, 2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 39 #include &quot;SourceProvider.h&quot;
 40 #include &quot;StackVisitor.h&quot;
 41 #include &quot;StrongInlines.h&quot;
 42 #include &quot;Watchdog.h&quot;
 43 #include &lt;wtf/text/StringBuilder.h&gt;
 44 #include &lt;wtf/text/StringHash.h&gt;
 45 
 46 #if ENABLE(REMOTE_INSPECTOR)
 47 #include &quot;JSGlobalObjectDebuggable.h&quot;
 48 #include &quot;JSGlobalObjectInspectorController.h&quot;
 49 #include &quot;JSRemoteInspector.h&quot;
 50 #endif
 51 
 52 #if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
 53 #include &quot;JSContextRefInspectorSupport.h&quot;
 54 #endif
 55 
 56 #if OS(DARWIN)
 57 #include &lt;mach-o/dyld.h&gt;
 58 
<span class="line-modified"> 59 static const int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0</span>
 60 #endif
 61 
 62 using namespace JSC;
 63 
 64 // From the API&#39;s perspective, a context group remains alive iff
 65 //     (a) it has been JSContextGroupRetained
 66 //     OR
 67 //     (b) one of its contexts has been JSContextRetained
 68 
 69 JSContextGroupRef JSContextGroupCreate()
 70 {
<span class="line-removed"> 71     WTF::initializeMainThread();</span>
 72     initializeThreading();
 73     return toRef(&amp;VM::createContextGroup().leakRef());
 74 }
 75 
 76 JSContextGroupRef JSContextGroupRetain(JSContextGroupRef group)
 77 {
 78     toJS(group)-&gt;ref();
 79     return group;
 80 }
 81 
 82 void JSContextGroupRelease(JSContextGroupRef group)
 83 {
 84     VM&amp; vm = *toJS(group);
 85 
 86     JSLockHolder locker(&amp;vm);
 87     vm.deref();
 88 }
 89 
<span class="line-modified"> 90 static bool internalScriptTimeoutCallback(ExecState* exec, void* callbackPtr, void* callbackData)</span>
 91 {
 92     JSShouldTerminateCallback callback = reinterpret_cast&lt;JSShouldTerminateCallback&gt;(callbackPtr);
<span class="line-modified"> 93     JSContextRef contextRef = toRef(exec);</span>
 94     ASSERT(callback);
 95     return callback(contextRef, callbackData);
 96 }
 97 
 98 void JSContextGroupSetExecutionTimeLimit(JSContextGroupRef group, double limit, JSShouldTerminateCallback callback, void* callbackData)
 99 {
100     VM&amp; vm = *toJS(group);
101     JSLockHolder locker(&amp;vm);
102     Watchdog&amp; watchdog = vm.ensureWatchdog();
103     if (callback) {
104         void* callbackPtr = reinterpret_cast&lt;void*&gt;(callback);
105         watchdog.setTimeLimit(Seconds { limit }, internalScriptTimeoutCallback, callbackPtr, callbackData);
106     } else
107         watchdog.setTimeLimit(Seconds { limit });
108 }
109 
110 void JSContextGroupClearExecutionTimeLimit(JSContextGroupRef group)
111 {
112     VM&amp; vm = *toJS(group);
113     JSLockHolder locker(&amp;vm);
114     if (vm.watchdog())
115         vm.watchdog()-&gt;setTimeLimit(Watchdog::noTimeLimit);
116 }
117 
118 // From the API&#39;s perspective, a global context remains alive iff it has been JSGlobalContextRetained.
119 
120 JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass)
121 {
<span class="line-removed">122     WTF::initializeMainThread();</span>
123     initializeThreading();
124 
125 #if OS(DARWIN)
126     // If the application was linked before JSGlobalContextCreate was changed to use a unique VM,
127     // we use a shared one for backwards compatibility.
128     if (NSVersionOfLinkTimeLibrary(&quot;JavaScriptCore&quot;) &lt;= webkitFirstVersionWithConcurrentGlobalContexts) {
129         return JSGlobalContextCreateInGroup(toRef(&amp;VM::sharedInstance()), globalObjectClass);
130     }
131 #endif // OS(DARWIN)
132 
133     return JSGlobalContextCreateInGroup(0, globalObjectClass);
134 }
135 
136 JSGlobalContextRef JSGlobalContextCreateInGroup(JSContextGroupRef group, JSClassRef globalObjectClass)
137 {
<span class="line-removed">138     WTF::initializeMainThread();</span>
139     initializeThreading();
140 
141     Ref&lt;VM&gt; vm = group ? Ref&lt;VM&gt;(*toJS(group)) : VM::createContextGroup();
142 
143     JSLockHolder locker(vm.ptr());
144 
145     if (!globalObjectClass) {
146         JSGlobalObject* globalObject = JSAPIGlobalObject::create(vm.get(), JSAPIGlobalObject::createStructure(vm.get(), jsNull()));
147 #if ENABLE(REMOTE_INSPECTOR)
148         if (JSRemoteInspectorGetInspectionEnabledByDefault())
149             globalObject-&gt;setRemoteDebuggingEnabled(true);
150 #endif
<span class="line-modified">151         return JSGlobalContextRetain(toGlobalRef(globalObject-&gt;globalExec()));</span>
152     }
153 
154     JSGlobalObject* globalObject = JSCallbackObject&lt;JSGlobalObject&gt;::create(vm.get(), globalObjectClass, JSCallbackObject&lt;JSGlobalObject&gt;::createStructure(vm.get(), 0, jsNull()));
<span class="line-modified">155     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">156     JSValue prototype = globalObjectClass-&gt;prototype(exec);</span>
157     if (!prototype)
158         prototype = jsNull();
159     globalObject-&gt;resetPrototype(vm.get(), prototype);
160 #if ENABLE(REMOTE_INSPECTOR)
161     if (JSRemoteInspectorGetInspectionEnabledByDefault())
162         globalObject-&gt;setRemoteDebuggingEnabled(true);
163 #endif
<span class="line-modified">164     return JSGlobalContextRetain(toGlobalRef(exec));</span>
165 }
166 
167 JSGlobalContextRef JSGlobalContextRetain(JSGlobalContextRef ctx)
168 {
<span class="line-modified">169     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">170     VM&amp; vm = exec-&gt;vm();</span>
171     JSLockHolder locker(vm);
172 
<span class="line-modified">173     gcProtect(vm.vmEntryGlobalObject(exec));</span>
174     vm.ref();
175     return ctx;
176 }
177 
178 void JSGlobalContextRelease(JSGlobalContextRef ctx)
179 {
<span class="line-modified">180     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">181     VM&amp; vm = exec-&gt;vm();</span>
182     JSLockHolder locker(vm);
183 
<span class="line-modified">184     bool protectCountIsZero = vm.heap.unprotect(vm.vmEntryGlobalObject(exec));</span>
185     if (protectCountIsZero)
186         vm.heap.reportAbandonedObjectGraph();
187     vm.deref();
188 }
189 
190 JSObjectRef JSContextGetGlobalObject(JSContextRef ctx)
191 {
192     if (!ctx) {
193         ASSERT_NOT_REACHED();
194         return 0;
195     }
<span class="line-modified">196     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">197     VM&amp; vm = exec-&gt;vm();</span>
198     JSLockHolder locker(vm);
199 
<span class="line-modified">200     return toRef(jsCast&lt;JSObject*&gt;(exec-&gt;lexicalGlobalObject()-&gt;methodTable(vm)-&gt;toThis(exec-&gt;lexicalGlobalObject(), exec, NotStrictMode)));</span>
201 }
202 
203 JSContextGroupRef JSContextGetGroup(JSContextRef ctx)
204 {
205     if (!ctx) {
206         ASSERT_NOT_REACHED();
207         return 0;
208     }
<span class="line-modified">209     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">210     return toRef(&amp;exec-&gt;vm());</span>
211 }
212 
213 JSGlobalContextRef JSContextGetGlobalContext(JSContextRef ctx)
214 {
215     if (!ctx) {
216         ASSERT_NOT_REACHED();
217         return 0;
218     }
<span class="line-modified">219     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">220     JSLockHolder locker(exec);</span>
221 
<span class="line-modified">222     return toGlobalRef(exec-&gt;lexicalGlobalObject()-&gt;globalExec());</span>
223 }
224 
225 JSStringRef JSGlobalContextCopyName(JSGlobalContextRef ctx)
226 {
227     if (!ctx) {
228         ASSERT_NOT_REACHED();
229         return 0;
230     }
231 
<span class="line-modified">232     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">233     VM&amp; vm = exec-&gt;vm();</span>
234     JSLockHolder locker(vm);
235 
<span class="line-modified">236     String name = vm.vmEntryGlobalObject(exec)-&gt;name();</span>
237     if (name.isNull())
238         return 0;
239 
240     return OpaqueJSString::tryCreate(name).leakRef();
241 }
242 
243 void JSGlobalContextSetName(JSGlobalContextRef ctx, JSStringRef name)
244 {
245     if (!ctx) {
246         ASSERT_NOT_REACHED();
247         return;
248     }
249 
<span class="line-modified">250     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">251     VM&amp; vm = exec-&gt;vm();</span>
252     JSLockHolder locker(vm);
253 
<span class="line-modified">254     vm.vmEntryGlobalObject(exec)-&gt;setName(name ? name-&gt;string() : String());</span>
255 }
256 
257 void JSGlobalContextSetUnhandledRejectionCallback(JSGlobalContextRef ctx, JSObjectRef function, JSValueRef* exception)
258 {
259     if (!ctx) {
260         ASSERT_NOT_REACHED();
261         return;
262     }
263 
<span class="line-modified">264     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">265     VM&amp; vm = exec-&gt;vm();</span>
266     JSLockHolder locker(vm);
267 
268     JSObject* object = toJS(function);
269     if (!object-&gt;isFunction(vm)) {
<span class="line-modified">270         *exception = toRef(createTypeError(exec));</span>
271         return;
272     }
273 
<span class="line-modified">274     vm.vmEntryGlobalObject(exec)-&gt;setUnhandledRejectionCallback(vm, object);</span>
275 }
276 
277 class BacktraceFunctor {
278 public:
279     BacktraceFunctor(StringBuilder&amp; builder, unsigned remainingCapacityForFrameCapture)
280         : m_builder(builder)
281         , m_remainingCapacityForFrameCapture(remainingCapacityForFrameCapture)
282     {
283     }
284 
285     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
286     {
287         if (m_remainingCapacityForFrameCapture) {
288             // If callee is unknown, but we&#39;ve not added any frame yet, we should
289             // still add the frame, because something called us, and gave us arguments.
290             if (visitor-&gt;callee().isCell()) {
291                 JSCell* callee = visitor-&gt;callee().asCell();
292                 if (!callee &amp;&amp; visitor-&gt;index())
293                     return StackVisitor::Done;
294             }
</pre>
<hr />
<pre>
313             if (!visitor-&gt;callee().rawPtr())
314                 return StackVisitor::Done;
315 
316             m_remainingCapacityForFrameCapture--;
317             return StackVisitor::Continue;
318         }
319         return StackVisitor::Done;
320     }
321 
322 private:
323     StringBuilder&amp; m_builder;
324     mutable unsigned m_remainingCapacityForFrameCapture;
325 };
326 
327 JSStringRef JSContextCreateBacktrace(JSContextRef ctx, unsigned maxStackSize)
328 {
329     if (!ctx) {
330         ASSERT_NOT_REACHED();
331         return 0;
332     }
<span class="line-modified">333     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">334     VM&amp; vm = exec-&gt;vm();</span>
335     JSLockHolder lock(vm);
336     StringBuilder builder;
337     CallFrame* frame = vm.topCallFrame;
338 
339     ASSERT(maxStackSize);
340     BacktraceFunctor functor(builder, maxStackSize);
<span class="line-modified">341     frame-&gt;iterate(functor);</span>
342 
343     return OpaqueJSString::tryCreate(builder.toString()).leakRef();
344 }
345 
346 bool JSGlobalContextGetRemoteInspectionEnabled(JSGlobalContextRef ctx)
347 {
348     if (!ctx) {
349         ASSERT_NOT_REACHED();
350         return false;
351     }
352 
<span class="line-modified">353     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">354     VM&amp; vm = exec-&gt;vm();</span>
355     JSLockHolder lock(vm);
356 
<span class="line-modified">357     return vm.vmEntryGlobalObject(exec)-&gt;remoteDebuggingEnabled();</span>
358 }
359 
360 void JSGlobalContextSetRemoteInspectionEnabled(JSGlobalContextRef ctx, bool enabled)
361 {
362     if (!ctx) {
363         ASSERT_NOT_REACHED();
364         return;
365     }
366 
<span class="line-modified">367     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">368     VM&amp; vm = exec-&gt;vm();</span>
369     JSLockHolder lock(vm);
370 
<span class="line-modified">371     vm.vmEntryGlobalObject(exec)-&gt;setRemoteDebuggingEnabled(enabled);</span>
372 }
373 
374 bool JSGlobalContextGetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx)
375 {
376 #if ENABLE(REMOTE_INSPECTOR)
377     if (!ctx) {
378         ASSERT_NOT_REACHED();
379         return false;
380     }
381 
<span class="line-modified">382     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">383     VM&amp; vm = exec-&gt;vm();</span>
384     JSLockHolder lock(vm);
385 
<span class="line-removed">386     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
387     return globalObject-&gt;inspectorController().includesNativeCallStackWhenReportingExceptions();
388 #else
389     UNUSED_PARAM(ctx);
390     return false;
391 #endif
392 }
393 
394 void JSGlobalContextSetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx, bool includesNativeCallStack)
395 {
396 #if ENABLE(REMOTE_INSPECTOR)
397     if (!ctx) {
398         ASSERT_NOT_REACHED();
399         return;
400     }
401 
<span class="line-modified">402     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">403     VM&amp; vm = exec-&gt;vm();</span>
404     JSLockHolder lock(vm);
405 
<span class="line-removed">406     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
407     globalObject-&gt;inspectorController().setIncludesNativeCallStackWhenReportingExceptions(includesNativeCallStack);
408 #else
409     UNUSED_PARAM(ctx);
410     UNUSED_PARAM(includesNativeCallStack);
411 #endif
412 }
413 
414 #if USE(CF)
415 CFRunLoopRef JSGlobalContextGetDebuggerRunLoop(JSGlobalContextRef ctx)
416 {
417 #if ENABLE(REMOTE_INSPECTOR)
418     if (!ctx) {
419         ASSERT_NOT_REACHED();
420         return nullptr;
421     }
422 
<span class="line-modified">423     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">424     VM&amp; vm = exec-&gt;vm();</span>
425     JSLockHolder lock(vm);
426 
<span class="line-modified">427     return vm.vmEntryGlobalObject(exec)-&gt;inspectorDebuggable().targetRunLoop();</span>
428 #else
429     UNUSED_PARAM(ctx);
430     return nullptr;
431 #endif
432 }
433 
434 void JSGlobalContextSetDebuggerRunLoop(JSGlobalContextRef ctx, CFRunLoopRef runLoop)
435 {
436 #if ENABLE(REMOTE_INSPECTOR)
437     if (!ctx) {
438         ASSERT_NOT_REACHED();
439         return;
440     }
441 
<span class="line-modified">442     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">443     VM&amp; vm = exec-&gt;vm();</span>
444     JSLockHolder lock(vm);
445 
<span class="line-modified">446     vm.vmEntryGlobalObject(exec)-&gt;inspectorDebuggable().setTargetRunLoop(runLoop);</span>
447 #else
448     UNUSED_PARAM(ctx);
449     UNUSED_PARAM(runLoop);
450 #endif
451 }
452 #endif // USE(CF)
453 
454 #if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
455 Inspector::AugmentableInspectorController* JSGlobalContextGetAugmentableInspectorController(JSGlobalContextRef ctx)
456 {
457     if (!ctx) {
458         ASSERT_NOT_REACHED();
459         return nullptr;
460     }
461 
<span class="line-modified">462     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">463     VM&amp; vm = exec-&gt;vm();</span>
464     JSLockHolder lock(vm);
465 
<span class="line-modified">466     return &amp;vm.vmEntryGlobalObject(exec)-&gt;inspectorController();</span>
467 }
468 #endif
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 39 #include &quot;SourceProvider.h&quot;
 40 #include &quot;StackVisitor.h&quot;
 41 #include &quot;StrongInlines.h&quot;
 42 #include &quot;Watchdog.h&quot;
 43 #include &lt;wtf/text/StringBuilder.h&gt;
 44 #include &lt;wtf/text/StringHash.h&gt;
 45 
 46 #if ENABLE(REMOTE_INSPECTOR)
 47 #include &quot;JSGlobalObjectDebuggable.h&quot;
 48 #include &quot;JSGlobalObjectInspectorController.h&quot;
 49 #include &quot;JSRemoteInspector.h&quot;
 50 #endif
 51 
 52 #if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
 53 #include &quot;JSContextRefInspectorSupport.h&quot;
 54 #endif
 55 
 56 #if OS(DARWIN)
 57 #include &lt;mach-o/dyld.h&gt;
 58 
<span class="line-modified"> 59 static constexpr int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0</span>
 60 #endif
 61 
 62 using namespace JSC;
 63 
 64 // From the API&#39;s perspective, a context group remains alive iff
 65 //     (a) it has been JSContextGroupRetained
 66 //     OR
 67 //     (b) one of its contexts has been JSContextRetained
 68 
 69 JSContextGroupRef JSContextGroupCreate()
 70 {

 71     initializeThreading();
 72     return toRef(&amp;VM::createContextGroup().leakRef());
 73 }
 74 
 75 JSContextGroupRef JSContextGroupRetain(JSContextGroupRef group)
 76 {
 77     toJS(group)-&gt;ref();
 78     return group;
 79 }
 80 
 81 void JSContextGroupRelease(JSContextGroupRef group)
 82 {
 83     VM&amp; vm = *toJS(group);
 84 
 85     JSLockHolder locker(&amp;vm);
 86     vm.deref();
 87 }
 88 
<span class="line-modified"> 89 static bool internalScriptTimeoutCallback(JSGlobalObject* globalObject, void* callbackPtr, void* callbackData)</span>
 90 {
 91     JSShouldTerminateCallback callback = reinterpret_cast&lt;JSShouldTerminateCallback&gt;(callbackPtr);
<span class="line-modified"> 92     JSContextRef contextRef = toRef(globalObject);</span>
 93     ASSERT(callback);
 94     return callback(contextRef, callbackData);
 95 }
 96 
 97 void JSContextGroupSetExecutionTimeLimit(JSContextGroupRef group, double limit, JSShouldTerminateCallback callback, void* callbackData)
 98 {
 99     VM&amp; vm = *toJS(group);
100     JSLockHolder locker(&amp;vm);
101     Watchdog&amp; watchdog = vm.ensureWatchdog();
102     if (callback) {
103         void* callbackPtr = reinterpret_cast&lt;void*&gt;(callback);
104         watchdog.setTimeLimit(Seconds { limit }, internalScriptTimeoutCallback, callbackPtr, callbackData);
105     } else
106         watchdog.setTimeLimit(Seconds { limit });
107 }
108 
109 void JSContextGroupClearExecutionTimeLimit(JSContextGroupRef group)
110 {
111     VM&amp; vm = *toJS(group);
112     JSLockHolder locker(&amp;vm);
113     if (vm.watchdog())
114         vm.watchdog()-&gt;setTimeLimit(Watchdog::noTimeLimit);
115 }
116 
117 // From the API&#39;s perspective, a global context remains alive iff it has been JSGlobalContextRetained.
118 
119 JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass)
120 {

121     initializeThreading();
122 
123 #if OS(DARWIN)
124     // If the application was linked before JSGlobalContextCreate was changed to use a unique VM,
125     // we use a shared one for backwards compatibility.
126     if (NSVersionOfLinkTimeLibrary(&quot;JavaScriptCore&quot;) &lt;= webkitFirstVersionWithConcurrentGlobalContexts) {
127         return JSGlobalContextCreateInGroup(toRef(&amp;VM::sharedInstance()), globalObjectClass);
128     }
129 #endif // OS(DARWIN)
130 
131     return JSGlobalContextCreateInGroup(0, globalObjectClass);
132 }
133 
134 JSGlobalContextRef JSGlobalContextCreateInGroup(JSContextGroupRef group, JSClassRef globalObjectClass)
135 {

136     initializeThreading();
137 
138     Ref&lt;VM&gt; vm = group ? Ref&lt;VM&gt;(*toJS(group)) : VM::createContextGroup();
139 
140     JSLockHolder locker(vm.ptr());
141 
142     if (!globalObjectClass) {
143         JSGlobalObject* globalObject = JSAPIGlobalObject::create(vm.get(), JSAPIGlobalObject::createStructure(vm.get(), jsNull()));
144 #if ENABLE(REMOTE_INSPECTOR)
145         if (JSRemoteInspectorGetInspectionEnabledByDefault())
146             globalObject-&gt;setRemoteDebuggingEnabled(true);
147 #endif
<span class="line-modified">148         return JSGlobalContextRetain(toGlobalRef(globalObject));</span>
149     }
150 
151     JSGlobalObject* globalObject = JSCallbackObject&lt;JSGlobalObject&gt;::create(vm.get(), globalObjectClass, JSCallbackObject&lt;JSGlobalObject&gt;::createStructure(vm.get(), 0, jsNull()));
<span class="line-modified">152     JSValue prototype = globalObjectClass-&gt;prototype(globalObject);</span>

153     if (!prototype)
154         prototype = jsNull();
155     globalObject-&gt;resetPrototype(vm.get(), prototype);
156 #if ENABLE(REMOTE_INSPECTOR)
157     if (JSRemoteInspectorGetInspectionEnabledByDefault())
158         globalObject-&gt;setRemoteDebuggingEnabled(true);
159 #endif
<span class="line-modified">160     return JSGlobalContextRetain(toGlobalRef(globalObject));</span>
161 }
162 
163 JSGlobalContextRef JSGlobalContextRetain(JSGlobalContextRef ctx)
164 {
<span class="line-modified">165     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">166     VM&amp; vm = globalObject-&gt;vm();</span>
167     JSLockHolder locker(vm);
168 
<span class="line-modified">169     gcProtect(globalObject);</span>
170     vm.ref();
171     return ctx;
172 }
173 
174 void JSGlobalContextRelease(JSGlobalContextRef ctx)
175 {
<span class="line-modified">176     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">177     VM&amp; vm = globalObject-&gt;vm();</span>
178     JSLockHolder locker(vm);
179 
<span class="line-modified">180     bool protectCountIsZero = vm.heap.unprotect(globalObject);</span>
181     if (protectCountIsZero)
182         vm.heap.reportAbandonedObjectGraph();
183     vm.deref();
184 }
185 
186 JSObjectRef JSContextGetGlobalObject(JSContextRef ctx)
187 {
188     if (!ctx) {
189         ASSERT_NOT_REACHED();
190         return 0;
191     }
<span class="line-modified">192     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">193     VM&amp; vm = globalObject-&gt;vm();</span>
194     JSLockHolder locker(vm);
195 
<span class="line-modified">196     return toRef(jsCast&lt;JSObject*&gt;(globalObject-&gt;methodTable(vm)-&gt;toThis(globalObject, globalObject, NotStrictMode)));</span>
197 }
198 
199 JSContextGroupRef JSContextGetGroup(JSContextRef ctx)
200 {
201     if (!ctx) {
202         ASSERT_NOT_REACHED();
203         return 0;
204     }
<span class="line-modified">205     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">206     return toRef(&amp;globalObject-&gt;vm());</span>
207 }
208 
209 JSGlobalContextRef JSContextGetGlobalContext(JSContextRef ctx)
210 {
211     if (!ctx) {
212         ASSERT_NOT_REACHED();
213         return 0;
214     }
<span class="line-modified">215     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">216     JSLockHolder locker(globalObject);</span>
217 
<span class="line-modified">218     return toGlobalRef(globalObject);</span>
219 }
220 
221 JSStringRef JSGlobalContextCopyName(JSGlobalContextRef ctx)
222 {
223     if (!ctx) {
224         ASSERT_NOT_REACHED();
225         return 0;
226     }
227 
<span class="line-modified">228     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">229     VM&amp; vm = globalObject-&gt;vm();</span>
230     JSLockHolder locker(vm);
231 
<span class="line-modified">232     String name = globalObject-&gt;name();</span>
233     if (name.isNull())
234         return 0;
235 
236     return OpaqueJSString::tryCreate(name).leakRef();
237 }
238 
239 void JSGlobalContextSetName(JSGlobalContextRef ctx, JSStringRef name)
240 {
241     if (!ctx) {
242         ASSERT_NOT_REACHED();
243         return;
244     }
245 
<span class="line-modified">246     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">247     VM&amp; vm = globalObject-&gt;vm();</span>
248     JSLockHolder locker(vm);
249 
<span class="line-modified">250     globalObject-&gt;setName(name ? name-&gt;string() : String());</span>
251 }
252 
253 void JSGlobalContextSetUnhandledRejectionCallback(JSGlobalContextRef ctx, JSObjectRef function, JSValueRef* exception)
254 {
255     if (!ctx) {
256         ASSERT_NOT_REACHED();
257         return;
258     }
259 
<span class="line-modified">260     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">261     VM&amp; vm = globalObject-&gt;vm();</span>
262     JSLockHolder locker(vm);
263 
264     JSObject* object = toJS(function);
265     if (!object-&gt;isFunction(vm)) {
<span class="line-modified">266         *exception = toRef(createTypeError(globalObject));</span>
267         return;
268     }
269 
<span class="line-modified">270     globalObject-&gt;setUnhandledRejectionCallback(vm, object);</span>
271 }
272 
273 class BacktraceFunctor {
274 public:
275     BacktraceFunctor(StringBuilder&amp; builder, unsigned remainingCapacityForFrameCapture)
276         : m_builder(builder)
277         , m_remainingCapacityForFrameCapture(remainingCapacityForFrameCapture)
278     {
279     }
280 
281     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
282     {
283         if (m_remainingCapacityForFrameCapture) {
284             // If callee is unknown, but we&#39;ve not added any frame yet, we should
285             // still add the frame, because something called us, and gave us arguments.
286             if (visitor-&gt;callee().isCell()) {
287                 JSCell* callee = visitor-&gt;callee().asCell();
288                 if (!callee &amp;&amp; visitor-&gt;index())
289                     return StackVisitor::Done;
290             }
</pre>
<hr />
<pre>
309             if (!visitor-&gt;callee().rawPtr())
310                 return StackVisitor::Done;
311 
312             m_remainingCapacityForFrameCapture--;
313             return StackVisitor::Continue;
314         }
315         return StackVisitor::Done;
316     }
317 
318 private:
319     StringBuilder&amp; m_builder;
320     mutable unsigned m_remainingCapacityForFrameCapture;
321 };
322 
323 JSStringRef JSContextCreateBacktrace(JSContextRef ctx, unsigned maxStackSize)
324 {
325     if (!ctx) {
326         ASSERT_NOT_REACHED();
327         return 0;
328     }
<span class="line-modified">329     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">330     VM&amp; vm = globalObject-&gt;vm();</span>
331     JSLockHolder lock(vm);
332     StringBuilder builder;
333     CallFrame* frame = vm.topCallFrame;
334 
335     ASSERT(maxStackSize);
336     BacktraceFunctor functor(builder, maxStackSize);
<span class="line-modified">337     frame-&gt;iterate(vm, functor);</span>
338 
339     return OpaqueJSString::tryCreate(builder.toString()).leakRef();
340 }
341 
342 bool JSGlobalContextGetRemoteInspectionEnabled(JSGlobalContextRef ctx)
343 {
344     if (!ctx) {
345         ASSERT_NOT_REACHED();
346         return false;
347     }
348 
<span class="line-modified">349     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">350     VM&amp; vm = globalObject-&gt;vm();</span>
351     JSLockHolder lock(vm);
352 
<span class="line-modified">353     return globalObject-&gt;remoteDebuggingEnabled();</span>
354 }
355 
356 void JSGlobalContextSetRemoteInspectionEnabled(JSGlobalContextRef ctx, bool enabled)
357 {
358     if (!ctx) {
359         ASSERT_NOT_REACHED();
360         return;
361     }
362 
<span class="line-modified">363     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">364     VM&amp; vm = globalObject-&gt;vm();</span>
365     JSLockHolder lock(vm);
366 
<span class="line-modified">367     globalObject-&gt;setRemoteDebuggingEnabled(enabled);</span>
368 }
369 
370 bool JSGlobalContextGetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx)
371 {
372 #if ENABLE(REMOTE_INSPECTOR)
373     if (!ctx) {
374         ASSERT_NOT_REACHED();
375         return false;
376     }
377 
<span class="line-modified">378     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">379     VM&amp; vm = globalObject-&gt;vm();</span>
380     JSLockHolder lock(vm);
381 

382     return globalObject-&gt;inspectorController().includesNativeCallStackWhenReportingExceptions();
383 #else
384     UNUSED_PARAM(ctx);
385     return false;
386 #endif
387 }
388 
389 void JSGlobalContextSetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx, bool includesNativeCallStack)
390 {
391 #if ENABLE(REMOTE_INSPECTOR)
392     if (!ctx) {
393         ASSERT_NOT_REACHED();
394         return;
395     }
396 
<span class="line-modified">397     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">398     VM&amp; vm = globalObject-&gt;vm();</span>
399     JSLockHolder lock(vm);
400 

401     globalObject-&gt;inspectorController().setIncludesNativeCallStackWhenReportingExceptions(includesNativeCallStack);
402 #else
403     UNUSED_PARAM(ctx);
404     UNUSED_PARAM(includesNativeCallStack);
405 #endif
406 }
407 
408 #if USE(CF)
409 CFRunLoopRef JSGlobalContextGetDebuggerRunLoop(JSGlobalContextRef ctx)
410 {
411 #if ENABLE(REMOTE_INSPECTOR)
412     if (!ctx) {
413         ASSERT_NOT_REACHED();
414         return nullptr;
415     }
416 
<span class="line-modified">417     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">418     VM&amp; vm = globalObject-&gt;vm();</span>
419     JSLockHolder lock(vm);
420 
<span class="line-modified">421     return globalObject-&gt;inspectorDebuggable().targetRunLoop();</span>
422 #else
423     UNUSED_PARAM(ctx);
424     return nullptr;
425 #endif
426 }
427 
428 void JSGlobalContextSetDebuggerRunLoop(JSGlobalContextRef ctx, CFRunLoopRef runLoop)
429 {
430 #if ENABLE(REMOTE_INSPECTOR)
431     if (!ctx) {
432         ASSERT_NOT_REACHED();
433         return;
434     }
435 
<span class="line-modified">436     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">437     VM&amp; vm = globalObject-&gt;vm();</span>
438     JSLockHolder lock(vm);
439 
<span class="line-modified">440     globalObject-&gt;inspectorDebuggable().setTargetRunLoop(runLoop);</span>
441 #else
442     UNUSED_PARAM(ctx);
443     UNUSED_PARAM(runLoop);
444 #endif
445 }
446 #endif // USE(CF)
447 
448 #if ENABLE(INSPECTOR_ALTERNATE_DISPATCHERS)
449 Inspector::AugmentableInspectorController* JSGlobalContextGetAugmentableInspectorController(JSGlobalContextRef ctx)
450 {
451     if (!ctx) {
452         ASSERT_NOT_REACHED();
453         return nullptr;
454     }
455 
<span class="line-modified">456     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">457     VM&amp; vm = globalObject-&gt;vm();</span>
458     JSLockHolder lock(vm);
459 
<span class="line-modified">460     return &amp;globalObject-&gt;inspectorController();</span>
461 }
462 #endif
</pre>
</td>
</tr>
</table>
<center><a href="JSClassRef.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSHeapFinalizerPrivate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/CustomElementReactionQueue.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/CustomElementReactionQueue.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/CustomElementReactionQueue.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/CustomElementReactionQueue.cpp
@@ -28,14 +28,15 @@
 
 #include "CustomElementRegistry.h"
 #include "DOMWindow.h"
 #include "Document.h"
 #include "Element.h"
+#include "EventLoop.h"
 #include "HTMLNames.h"
 #include "JSCustomElementInterface.h"
 #include "JSDOMBinding.h"
-#include "Microtasks.h"
+#include "WindowEventLoop.h"
 #include <JavaScriptCore/CatchScope.h>
 #include <JavaScriptCore/Heap.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/Optional.h>
 #include <wtf/Ref.h>
@@ -236,18 +237,18 @@
         for (auto& item : items)
             item.invoke(element, m_interface.get());
     }
 }
 
-inline void CustomElementReactionQueue::ElementQueue::add(Element& element)
+inline void CustomElementQueue::add(Element& element)
 {
     ASSERT(!m_invoking);
     // FIXME: Avoid inserting the same element multiple times.
     m_elements.append(element);
 }
 
-inline void CustomElementReactionQueue::ElementQueue::invokeAll()
+inline void CustomElementQueue::invokeAll()
 {
     RELEASE_ASSERT(!m_invoking);
     SetForScope<bool> invoking(m_invoking, true);
     unsigned originalSize = m_elements.size();
     // It's possible for more elements to be enqueued if some IDL attributes were missing CEReactions.
@@ -260,11 +261,11 @@
     }
     ASSERT_UNUSED(originalSize, m_elements.size() == originalSize);
     m_elements.clear();
 }
 
-inline void CustomElementReactionQueue::ElementQueue::processQueue(JSC::ExecState* state)
+inline void CustomElementQueue::processQueue(JSC::JSGlobalObject* state)
 {
     if (!state) {
         invokeAll();
         return;
     }
@@ -291,64 +292,35 @@
 // https://html.spec.whatwg.org/multipage/custom-elements.html#enqueue-an-element-on-the-appropriate-element-queue
 void CustomElementReactionQueue::enqueueElementOnAppropriateElementQueue(Element& element)
 {
     ASSERT(element.reactionQueue());
     if (!CustomElementReactionStack::s_currentProcessingStack) {
-        auto& queue = ensureBackupQueue();
-        queue.add(element);
+        element.document().windowEventLoop().backupElementQueue().add(element);
         return;
     }
 
     auto*& queue = CustomElementReactionStack::s_currentProcessingStack->m_queue;
     if (!queue) // We use a raw pointer to avoid genearing code to delete it in ~CustomElementReactionStack.
-        queue = new ElementQueue;
+        queue = new CustomElementQueue;
     queue->add(element);
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 unsigned CustomElementReactionDisallowedScope::s_customElementReactionDisallowedCount = 0;
 #endif
 
 CustomElementReactionStack* CustomElementReactionStack::s_currentProcessingStack = nullptr;
 
-void CustomElementReactionStack::processQueue(JSC::ExecState* state)
+void CustomElementReactionStack::processQueue(JSC::JSGlobalObject* state)
 {
     ASSERT(m_queue);
     m_queue->processQueue(state);
     delete m_queue;
     m_queue = nullptr;
 }
 
-class BackupElementQueueMicrotask final : public Microtask {
-    WTF_MAKE_FAST_ALLOCATED;
-private:
-    Result run() final
-    {
-        CustomElementReactionQueue::processBackupQueue();
-        return Result::Done;
-    }
-};
-
-static bool s_processingBackupElementQueue = false;
-
-CustomElementReactionQueue::ElementQueue& CustomElementReactionQueue::ensureBackupQueue()
-{
-    if (!s_processingBackupElementQueue) {
-        s_processingBackupElementQueue = true;
-        MicrotaskQueue::mainThreadQueue().append(makeUnique<BackupElementQueueMicrotask>());
-    }
-    return backupElementQueue();
-}
-
-void CustomElementReactionQueue::processBackupQueue()
-{
-    backupElementQueue().processQueue(nullptr);
-    s_processingBackupElementQueue = false;
-}
-
-CustomElementReactionQueue::ElementQueue& CustomElementReactionQueue::backupElementQueue()
+void CustomElementReactionQueue::processBackupQueue(CustomElementQueue& backupElementQueue)
 {
-    static NeverDestroyed<ElementQueue> queue;
-    return queue.get();
+    backupElementQueue.processQueue(nullptr);
 }
 
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3StackmapGenerationParams.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3StackmapGenerationParams.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3StackmapValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3StackmapGenerationParams.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirGenerationContext.h&quot;
 31 #include &quot;B3ValueRep.h&quot;
<span class="line-modified"> 32 #include &quot;CCallHelpers.h&quot;</span>
 33 #include &quot;RegisterSet.h&quot;
 34 #include &lt;wtf/Box.h&gt;
 35 
<span class="line-modified"> 36 namespace JSC { namespace B3 {</span>




 37 
 38 class CheckSpecial;
 39 class PatchpointSpecial;
 40 class Procedure;
 41 class StackmapValue;
 42 
 43 // NOTE: It&#39;s possible to capture StackmapGenerationParams by value, but not all of the methods will
 44 // work if you do that.
 45 class StackmapGenerationParams {
 46 public:
 47     // This is the stackmap value that we&#39;re generating.
 48     StackmapValue* value() const { return m_value; }
 49 
 50     // This tells you the actual value representations that were chosen. This is usually different
 51     // from the constraints we supplied.
 52     const Vector&lt;ValueRep&gt;&amp; reps() const { return m_reps; };
 53 
 54     // Usually we wish to access the reps. We make this easy by making ourselves appear to be a
 55     // collection of reps.
 56     unsigned size() const { return m_reps.size(); }
</pre>
<hr />
<pre>
 72     // - Scratch registers are going to be in usedRegisters() at the patchpoint. So, if you want to
 73     //   find one of your requested scratch registers using usedRegisters(), you&#39;ll have a bad time.
 74     //
 75     // This gives you the used register set that&#39;s useful for allocating scratch registers. This set
 76     // is defined as:
 77     //
 78     //     (usedRegisters() | (RegisterSet::calleeSaveRegisters() - proc.calleeSaveRegisters()))
 79     //     - gpScratchRegisters - fpScratchRegisters
 80     //
 81     // I.e. it is like usedRegisters() but also includes unsaved callee-saves and excludes scratch
 82     // registers.
 83     //
 84     // NOTE: This will report bogus information if you did proc.setNeedsUsedRegisters(false).
 85     JS_EXPORT_PRIVATE RegisterSet unavailableRegisters() const;
 86 
 87     GPRReg gpScratch(unsigned index) const { return m_gpScratch[index]; }
 88     FPRReg fpScratch(unsigned index) const { return m_fpScratch[index]; }
 89 
 90     // This is computed lazily, so it won&#39;t work if you capture StackmapGenerationParams by value.
 91     // These labels will get populated before any late paths or link tasks execute.
<span class="line-modified"> 92     JS_EXPORT_PRIVATE Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; successorLabels() const;</span>
 93 
 94     // This is computed lazily, so it won&#39;t work if you capture StackmapGenerationParams by value.
 95     // Returns true if the successor at the given index is going to be emitted right after the
 96     // patchpoint.
 97     JS_EXPORT_PRIVATE bool fallsThroughToSuccessor(unsigned successorIndex) const;
 98 
<span class="line-modified"> 99     // This is provided for convenience; it means that you don&#39;t have to capture it if you don&#39;t want to.</span>
100     JS_EXPORT_PRIVATE Procedure&amp; proc() const;

101 
102     // The Air::GenerationContext gives you even more power.
103     Air::GenerationContext&amp; context() const { return m_context; };
104 
105     template&lt;typename Functor&gt;
106     void addLatePath(const Functor&amp; functor) const
107     {
108         context().latePaths.append(
109             createSharedTask&lt;Air::GenerationContext::LatePathFunction&gt;(
110                 [=] (CCallHelpers&amp; jit, Air::GenerationContext&amp;) {
111                     functor(jit);
112                 }));
113     }
114 
115 private:
116     friend class CheckSpecial;
117     friend class PatchpointSpecial;
118 
119     StackmapGenerationParams(StackmapValue*, const Vector&lt;ValueRep&gt;&amp; reps, Air::GenerationContext&amp;);
120 
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirGenerationContext.h&quot;
 31 #include &quot;B3ValueRep.h&quot;
<span class="line-modified"> 32 #include &quot;MacroAssembler.h&quot;</span>
 33 #include &quot;RegisterSet.h&quot;
 34 #include &lt;wtf/Box.h&gt;
 35 
<span class="line-modified"> 36 namespace JSC {</span>
<span class="line-added"> 37 </span>
<span class="line-added"> 38 class CCallHelpers;</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 namespace B3 {</span>
 41 
 42 class CheckSpecial;
 43 class PatchpointSpecial;
 44 class Procedure;
 45 class StackmapValue;
 46 
 47 // NOTE: It&#39;s possible to capture StackmapGenerationParams by value, but not all of the methods will
 48 // work if you do that.
 49 class StackmapGenerationParams {
 50 public:
 51     // This is the stackmap value that we&#39;re generating.
 52     StackmapValue* value() const { return m_value; }
 53 
 54     // This tells you the actual value representations that were chosen. This is usually different
 55     // from the constraints we supplied.
 56     const Vector&lt;ValueRep&gt;&amp; reps() const { return m_reps; };
 57 
 58     // Usually we wish to access the reps. We make this easy by making ourselves appear to be a
 59     // collection of reps.
 60     unsigned size() const { return m_reps.size(); }
</pre>
<hr />
<pre>
 76     // - Scratch registers are going to be in usedRegisters() at the patchpoint. So, if you want to
 77     //   find one of your requested scratch registers using usedRegisters(), you&#39;ll have a bad time.
 78     //
 79     // This gives you the used register set that&#39;s useful for allocating scratch registers. This set
 80     // is defined as:
 81     //
 82     //     (usedRegisters() | (RegisterSet::calleeSaveRegisters() - proc.calleeSaveRegisters()))
 83     //     - gpScratchRegisters - fpScratchRegisters
 84     //
 85     // I.e. it is like usedRegisters() but also includes unsaved callee-saves and excludes scratch
 86     // registers.
 87     //
 88     // NOTE: This will report bogus information if you did proc.setNeedsUsedRegisters(false).
 89     JS_EXPORT_PRIVATE RegisterSet unavailableRegisters() const;
 90 
 91     GPRReg gpScratch(unsigned index) const { return m_gpScratch[index]; }
 92     FPRReg fpScratch(unsigned index) const { return m_fpScratch[index]; }
 93 
 94     // This is computed lazily, so it won&#39;t work if you capture StackmapGenerationParams by value.
 95     // These labels will get populated before any late paths or link tasks execute.
<span class="line-modified"> 96     JS_EXPORT_PRIVATE Vector&lt;Box&lt;MacroAssembler::Label&gt;&gt; successorLabels() const;</span>
 97 
 98     // This is computed lazily, so it won&#39;t work if you capture StackmapGenerationParams by value.
 99     // Returns true if the successor at the given index is going to be emitted right after the
100     // patchpoint.
101     JS_EXPORT_PRIVATE bool fallsThroughToSuccessor(unsigned successorIndex) const;
102 
<span class="line-modified">103     // These are provided for convenience; they mean that you don&#39;t have to capture them if you don&#39;t want to.</span>
104     JS_EXPORT_PRIVATE Procedure&amp; proc() const;
<span class="line-added">105     JS_EXPORT_PRIVATE Air::Code&amp; code() const;</span>
106 
107     // The Air::GenerationContext gives you even more power.
108     Air::GenerationContext&amp; context() const { return m_context; };
109 
110     template&lt;typename Functor&gt;
111     void addLatePath(const Functor&amp; functor) const
112     {
113         context().latePaths.append(
114             createSharedTask&lt;Air::GenerationContext::LatePathFunction&gt;(
115                 [=] (CCallHelpers&amp; jit, Air::GenerationContext&amp;) {
116                     functor(jit);
117                 }));
118     }
119 
120 private:
121     friend class CheckSpecial;
122     friend class PatchpointSpecial;
123 
124     StackmapGenerationParams(StackmapValue*, const Vector&lt;ValueRep&gt;&amp; reps, Air::GenerationContext&amp;);
125 
</pre>
</td>
</tr>
</table>
<center><a href="B3StackmapGenerationParams.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3StackmapValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
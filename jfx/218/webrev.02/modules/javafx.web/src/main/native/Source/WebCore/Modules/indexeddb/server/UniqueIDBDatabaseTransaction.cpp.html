<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabaseTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;UniqueIDBDatabaseTransaction.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBIterateCursorData.h&quot;
 32 #include &quot;IDBResultData.h&quot;
 33 #include &quot;IDBServer.h&quot;
 34 #include &quot;Logging.h&quot;
 35 #include &quot;UniqueIDBDatabase.h&quot;
 36 
 37 namespace WebCore {
 38 namespace IDBServer {
 39 
 40 Ref&lt;UniqueIDBDatabaseTransaction&gt; UniqueIDBDatabaseTransaction::create(UniqueIDBDatabaseConnection&amp; connection, const IDBTransactionInfo&amp; info)
 41 {
 42     return adoptRef(*new UniqueIDBDatabaseTransaction(connection, info));
 43 }
 44 
 45 UniqueIDBDatabaseTransaction::UniqueIDBDatabaseTransaction(UniqueIDBDatabaseConnection&amp; connection, const IDBTransactionInfo&amp; info)
 46     : m_databaseConnection(&amp;connection)
 47     , m_transactionInfo(info)
 48 {
 49     auto database = m_databaseConnection-&gt;database();
 50     ASSERT(database);
 51 
 52     if (m_transactionInfo.mode() == IDBTransactionMode::Versionchange)
 53         m_originalDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(database-&gt;info());
 54 
 55     m_databaseConnection-&gt;server()-&gt;registerTransaction(*this);
 56 }
 57 
 58 UniqueIDBDatabaseTransaction::~UniqueIDBDatabaseTransaction()
 59 {
 60     m_databaseConnection-&gt;server()-&gt;unregisterTransaction(*this);
 61 }
 62 
 63 IDBDatabaseInfo* UniqueIDBDatabaseTransaction::originalDatabaseInfo() const
 64 {
 65     ASSERT(m_transactionInfo.mode() == IDBTransactionMode::Versionchange);
 66     return m_originalDatabaseInfo.get();
 67 }
 68 
 69 void UniqueIDBDatabaseTransaction::abort()
 70 {
 71     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::abort&quot;);
 72 
 73     auto database = m_databaseConnection-&gt;database();
 74     ASSERT(database);
 75 
 76     database-&gt;abortTransaction(*this, [this](auto&amp; error) {
 77         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::abort (callback)&quot;);
 78 
 79         m_databaseConnection-&gt;didAbortTransaction(*this, error);
 80     });
 81 }
 82 
 83 void UniqueIDBDatabaseTransaction::abortWithoutCallback()
 84 {
 85     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::abortWithoutCallback&quot;);
 86 
 87     m_databaseConnection-&gt;abortTransactionWithoutCallback(*this);
 88 }
 89 
 90 bool UniqueIDBDatabaseTransaction::isVersionChange() const
 91 {
 92     return m_transactionInfo.mode() == IDBTransactionMode::Versionchange;
 93 }
 94 
 95 bool UniqueIDBDatabaseTransaction::isReadOnly() const
 96 {
 97     return m_transactionInfo.mode() == IDBTransactionMode::Readonly;
 98 }
 99 
100 void UniqueIDBDatabaseTransaction::commit()
101 {
102     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::commit&quot;);
103 
104     auto database = m_databaseConnection-&gt;database();
105 
106     database-&gt;commitTransaction(*this, [this](auto&amp; error) {
107         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::commit (callback)&quot;);
108 
109         m_databaseConnection-&gt;didCommitTransaction(*this, error);
110     });
111 }
112 
113 void UniqueIDBDatabaseTransaction::createObjectStore(const IDBRequestData&amp; requestData, const IDBObjectStoreInfo&amp; info)
114 {
115     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::createObjectStore&quot;);
116 
117     ASSERT(isVersionChange());
118     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
119 
120     auto database = m_databaseConnection-&gt;database();
121     ASSERT(database);
122 
123     database-&gt;createObjectStore(*this, info, [this, requestData](auto&amp; error) {
124         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::createObjectStore (callback)&quot;);
125 
126         if (error.isNull())
127             m_databaseConnection-&gt;didCreateObjectStore(IDBResultData::createObjectStoreSuccess(requestData.requestIdentifier()));
128         else
129             m_databaseConnection-&gt;didCreateObjectStore(IDBResultData::error(requestData.requestIdentifier(), error));
130     });
131 }
132 
133 void UniqueIDBDatabaseTransaction::deleteObjectStore(const IDBRequestData&amp; requestData, const String&amp; objectStoreName)
134 {
135     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::deleteObjectStore&quot;);
136 
137     ASSERT(isVersionChange());
138     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
139 
140     auto database = m_databaseConnection-&gt;database();
141     ASSERT(database);
142 
143     database-&gt;deleteObjectStore(*this, objectStoreName, [this, requestData](const IDBError&amp; error) {
144         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::deleteObjectStore (callback)&quot;);
145 
146         if (error.isNull())
147             m_databaseConnection-&gt;didDeleteObjectStore(IDBResultData::deleteObjectStoreSuccess(requestData.requestIdentifier()));
148         else
149             m_databaseConnection-&gt;didDeleteObjectStore(IDBResultData::error(requestData.requestIdentifier(), error));
150     });
151 }
152 
153 void UniqueIDBDatabaseTransaction::renameObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; newName)
154 {
155     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::renameObjectStore&quot;);
156 
157     ASSERT(isVersionChange());
158     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
159 
160     auto database = m_databaseConnection-&gt;database();
161     ASSERT(database);
162 
163     database-&gt;renameObjectStore(*this, objectStoreIdentifier, newName, [this, requestData](auto&amp; error) {
164         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::renameObjectStore (callback)&quot;);
165 
166         if (error.isNull())
167             m_databaseConnection-&gt;didRenameObjectStore(IDBResultData::renameObjectStoreSuccess(requestData.requestIdentifier()));
168         else
169             m_databaseConnection-&gt;didRenameObjectStore(IDBResultData::error(requestData.requestIdentifier(), error));
170     });
171 }
172 
173 void UniqueIDBDatabaseTransaction::clearObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier)
174 {
175     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::clearObjectStore&quot;);
176 
177     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
178 
179     auto database = m_databaseConnection-&gt;database();
180     ASSERT(database);
181 
182     database-&gt;clearObjectStore(*this, objectStoreIdentifier, [this, requestData](auto&amp; error) {
183         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::clearObjectStore (callback)&quot;);
184 
185         if (error.isNull())
186             m_databaseConnection-&gt;didClearObjectStore(IDBResultData::clearObjectStoreSuccess(requestData.requestIdentifier()));
187         else
188             m_databaseConnection-&gt;didClearObjectStore(IDBResultData::error(requestData.requestIdentifier(), error));
189     });
190 }
191 
192 void UniqueIDBDatabaseTransaction::createIndex(const IDBRequestData&amp; requestData, const IDBIndexInfo&amp; info)
193 {
194     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::createIndex&quot;);
195 
196     ASSERT(isVersionChange());
197     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
198 
199     auto database = m_databaseConnection-&gt;database();
200     ASSERT(database);
201 
202     database-&gt;createIndex(*this, info, [this, requestData](auto&amp; error) {
203         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::createIndex (callback)&quot;);
204 
205         if (error.isNull())
206             m_databaseConnection-&gt;didCreateIndex(IDBResultData::createIndexSuccess(requestData.requestIdentifier()));
207         else
208             m_databaseConnection-&gt;didCreateIndex(IDBResultData::error(requestData.requestIdentifier(), error));
209     });
210 }
211 
212 void UniqueIDBDatabaseTransaction::deleteIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; indexName)
213 {
214     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::deleteIndex&quot;);
215 
216     ASSERT(isVersionChange());
217     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
218 
219     auto database = m_databaseConnection-&gt;database();
220     ASSERT(database);
221 
222     database-&gt;deleteIndex(*this, objectStoreIdentifier, indexName, [this, requestData](auto&amp; error) {
223         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::createIndex (callback)&quot;);
224 
225         if (error.isNull())
226             m_databaseConnection-&gt;didDeleteIndex(IDBResultData::deleteIndexSuccess(requestData.requestIdentifier()));
227         else
228             m_databaseConnection-&gt;didDeleteIndex(IDBResultData::error(requestData.requestIdentifier(), error));
229     });
230 }
231 
232 void UniqueIDBDatabaseTransaction::renameIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
233 {
234     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::renameIndex&quot;);
235 
236     ASSERT(isVersionChange());
237     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
238 
239     auto database = m_databaseConnection-&gt;database();
240     ASSERT(database);
241 
242     database-&gt;renameIndex(*this, objectStoreIdentifier, indexIdentifier, newName, [this, requestData](auto&amp; error) {
243         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::renameIndex (callback)&quot;);
244 
245         if (error.isNull())
246             m_databaseConnection-&gt;didRenameIndex(IDBResultData::renameIndexSuccess(requestData.requestIdentifier()));
247         else
248             m_databaseConnection-&gt;didRenameIndex(IDBResultData::error(requestData.requestIdentifier(), error));
249     });
250 }
251 
252 
253 void UniqueIDBDatabaseTransaction::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
254 {
255     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::putOrAdd&quot;);
256 
257     ASSERT(!isReadOnly());
258     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
259 
260     auto database = m_databaseConnection-&gt;database();
261     ASSERT(database);
262 
263     database-&gt;putOrAdd(requestData, keyData, value, overwriteMode, [this, requestData](auto&amp; error, const IDBKeyData&amp; key) {
264         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::putOrAdd (callback)&quot;);
265 
266         if (error.isNull())
267             m_databaseConnection-&gt;connectionToClient().didPutOrAdd(IDBResultData::putOrAddSuccess(requestData.requestIdentifier(), key));
268         else
269             m_databaseConnection-&gt;connectionToClient().didPutOrAdd(IDBResultData::error(requestData.requestIdentifier(), error));
270     });
271 }
272 
273 void UniqueIDBDatabaseTransaction::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData)
274 {
275     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::getRecord&quot;);
276 
277     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
278 
279     auto database = m_databaseConnection-&gt;database();
280     ASSERT(database);
281 
282     database-&gt;getRecord(requestData, getRecordData, [this, requestData](auto&amp; error, const IDBGetResult&amp; result) {
283         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::getRecord (callback)&quot;);
284 
285         if (error.isNull())
286             m_databaseConnection-&gt;connectionToClient().didGetRecord(IDBResultData::getRecordSuccess(requestData.requestIdentifier(), result));
287         else
288             m_databaseConnection-&gt;connectionToClient().didGetRecord(IDBResultData::error(requestData.requestIdentifier(), error));
289     });
290 }
291 
292 void UniqueIDBDatabaseTransaction::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData)
293 {
294     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::getAllRecords&quot;);
295 
296     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
297 
298     auto database = m_databaseConnection-&gt;database();
299     ASSERT(database);
300 
301     database-&gt;getAllRecords(requestData, getAllRecordsData, [this, requestData](auto&amp; error, const IDBGetAllResult&amp; result) {
302         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::getAllRecords (callback)&quot;);
303 
304         if (error.isNull())
305             m_databaseConnection-&gt;connectionToClient().didGetAllRecords(IDBResultData::getAllRecordsSuccess(requestData.requestIdentifier(), result));
306         else
307             m_databaseConnection-&gt;connectionToClient().didGetAllRecords(IDBResultData::error(requestData.requestIdentifier(), error));
308     });
309 }
310 
311 void UniqueIDBDatabaseTransaction::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
312 {
313     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::getCount&quot;);
314 
315     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
316 
317     auto database = m_databaseConnection-&gt;database();
318     ASSERT(database);
319 
320     database-&gt;getCount(requestData, keyRangeData, [this, requestData](auto&amp; error, uint64_t count) {
321         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::getCount (callback)&quot;);
322 
323         if (error.isNull())
324             m_databaseConnection-&gt;connectionToClient().didGetCount(IDBResultData::getCountSuccess(requestData.requestIdentifier(), count));
325         else
326             m_databaseConnection-&gt;connectionToClient().didGetCount(IDBResultData::error(requestData.requestIdentifier(), error));
327     });
328 }
329 
330 void UniqueIDBDatabaseTransaction::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
331 {
332     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::deleteRecord&quot;);
333 
334     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
335 
336     auto database = m_databaseConnection-&gt;database();
337     ASSERT(database);
338 
339     database-&gt;deleteRecord(requestData, keyRangeData, [this, requestData](auto&amp; error) {
340         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::deleteRecord (callback)&quot;);
341 
342         if (error.isNull())
343             m_databaseConnection-&gt;connectionToClient().didDeleteRecord(IDBResultData::deleteRecordSuccess(requestData.requestIdentifier()));
344         else
345             m_databaseConnection-&gt;connectionToClient().didDeleteRecord(IDBResultData::error(requestData.requestIdentifier(), error));
346     });
347 }
348 
349 void UniqueIDBDatabaseTransaction::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info)
350 {
351     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::openCursor&quot;);
352 
353     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
354 
355     auto database = m_databaseConnection-&gt;database();
356     ASSERT(database);
357 
358     database-&gt;openCursor(requestData, info, [this, requestData](auto&amp; error, const IDBGetResult&amp; result) {
359         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::openCursor (callback)&quot;);
360 
361         if (error.isNull())
362             m_databaseConnection-&gt;connectionToClient().didOpenCursor(IDBResultData::openCursorSuccess(requestData.requestIdentifier(), result));
363         else
364             m_databaseConnection-&gt;connectionToClient().didOpenCursor(IDBResultData::error(requestData.requestIdentifier(), error));
365     });
366 }
367 
368 void UniqueIDBDatabaseTransaction::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data)
369 {
370     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::iterateCursor&quot;);
371 
372     ASSERT(m_transactionInfo.identifier() == requestData.transactionIdentifier());
373 
374     auto database = m_databaseConnection-&gt;database();
375     ASSERT(database);
376 
377     database-&gt;iterateCursor(requestData, data, [this, requestData, option = data.option](auto&amp; error, const IDBGetResult&amp; result) {
378         LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::iterateCursor (callback)&quot;);
379 
380         if (option == IndexedDB::CursorIterateOption::DoNotReply)
381             return;
382 
383         if (error.isNull())
384             m_databaseConnection-&gt;connectionToClient().didIterateCursor(IDBResultData::iterateCursorSuccess(requestData.requestIdentifier(), result));
385         else
386             m_databaseConnection-&gt;connectionToClient().didIterateCursor(IDBResultData::error(requestData.requestIdentifier(), error));
387     });
388 }
389 
390 const Vector&lt;uint64_t&gt;&amp; UniqueIDBDatabaseTransaction::objectStoreIdentifiers()
391 {
392     if (!m_objectStoreIdentifiers.isEmpty())
393         return m_objectStoreIdentifiers;
394 
395     auto&amp; info = m_databaseConnection-&gt;database()-&gt;info();
396     for (const auto&amp; objectStoreName : info.objectStoreNames()) {
397         auto objectStoreInfo = info.infoForExistingObjectStore(objectStoreName);
398         ASSERT(objectStoreInfo);
399         if (!objectStoreInfo)
400             continue;
401 
402         if (m_transactionInfo.objectStores().contains(objectStoreName))
403             m_objectStoreIdentifiers.append(objectStoreInfo-&gt;identifier());
404     }
405 
406     return m_objectStoreIdentifiers;
407 }
408 
409 void UniqueIDBDatabaseTransaction::didActivateInBackingStore(const IDBError&amp; error)
410 {
411     LOG(IndexedDB, &quot;UniqueIDBDatabaseTransaction::didActivateInBackingStore&quot;);
412 
413     m_databaseConnection-&gt;connectionToClient().didStartTransaction(m_transactionInfo.identifier(), error);
414 }
415 
416 } // namespace IDBServer
417 } // namespace WebCore
418 
419 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/DeviceResponseConverter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeviceRequestConverter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DeviceResponseConverter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/DeviceResponseConverter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;DeviceResponseConverter.h&quot;
 32 
 33 #if ENABLE(WEB_AUTHN)
 34 
 35 #include &quot;AuthenticatorSupportedOptions.h&quot;
 36 #include &quot;CBORReader.h&quot;
 37 #include &quot;CBORWriter.h&quot;
 38 #include &quot;WebAuthenticationConstants.h&quot;
 39 #include &quot;WebAuthenticationUtils.h&quot;
 40 #include &lt;wtf/StdSet.h&gt;
 41 #include &lt;wtf/Vector.h&gt;
 42 
 43 namespace fido {
 44 using namespace WebCore;
 45 using CBOR = cbor::CBORValue;
 46 
<span class="line-removed"> 47 constexpr size_t kResponseCodeLength = 1;</span>
<span class="line-removed"> 48 </span>
 49 static ProtocolVersion convertStringToProtocolVersion(const String&amp; version)
 50 {
 51     if (version == kCtap2Version)
 52         return ProtocolVersion::kCtap;
 53     if (version == kU2fVersion)
 54         return ProtocolVersion::kU2f;
 55 
 56     return ProtocolVersion::kUnknown;
 57 }
 58 
 59 CtapDeviceResponseCode getResponseCode(const Vector&lt;uint8_t&gt;&amp; buffer)
 60 {
 61     if (buffer.isEmpty())
 62         return CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;
 63 
 64     auto code = static_cast&lt;CtapDeviceResponseCode&gt;(buffer[0]);
 65     return isCtapDeviceResponseCode(code) ? code : CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;
 66 }
 67 
 68 static Vector&lt;uint8_t&gt; getCredentialId(const Vector&lt;uint8_t&gt;&amp; authenticatorData)
 69 {
 70     const size_t credentialIdLengthOffset = rpIdHashLength + flagsLength + signCounterLength + aaguidLength;
 71 
 72     if (authenticatorData.size() &lt; credentialIdLengthOffset + credentialIdLengthLength)
 73         return { };
 74     size_t credentialIdLength = (static_cast&lt;size_t&gt;(authenticatorData[credentialIdLengthOffset]) &lt;&lt; 8) | static_cast&lt;size_t&gt;(authenticatorData[credentialIdLengthOffset + 1]);
 75 
 76     if (authenticatorData.size() &lt; credentialIdLengthOffset + credentialIdLengthLength + credentialIdLength)
 77         return { };
 78     Vector&lt;uint8_t&gt; credentialId;
 79     credentialId.reserveInitialCapacity(credentialIdLength);
 80     auto beginIt = authenticatorData.begin() + credentialIdLengthOffset + credentialIdLengthLength;
 81     credentialId.appendRange(beginIt, beginIt + credentialIdLength);
 82     return credentialId;
 83 }
 84 
 85 
 86 // Decodes byte array response from authenticator to CBOR value object and
 87 // checks for correct encoding format.
<span class="line-modified"> 88 Optional&lt;PublicKeyCredentialData&gt; readCTAPMakeCredentialResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer, const WebCore::AttestationConveyancePreference&amp; attestation)</span>
 89 {
 90     if (inBuffer.size() &lt;= kResponseCodeLength)
<span class="line-modified"> 91         return WTF::nullopt;</span>
 92 
 93     Vector&lt;uint8_t&gt; buffer;
 94     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
 95     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
 96     if (!decodedResponse || !decodedResponse-&gt;isMap())
<span class="line-modified"> 97         return WTF::nullopt;</span>
 98     const auto&amp; decodedMap = decodedResponse-&gt;getMap();
 99 
100     auto it = decodedMap.find(CBOR(1));
101     if (it == decodedMap.end() || !it-&gt;second.isString())
<span class="line-modified">102         return WTF::nullopt;</span>
103     auto format = it-&gt;second.clone();
104 
105     it = decodedMap.find(CBOR(2));
106     if (it == decodedMap.end() || !it-&gt;second.isByteString())
<span class="line-modified">107         return WTF::nullopt;</span>
108     auto authenticatorData = it-&gt;second.clone();
109 
110     auto credentialId = getCredentialId(authenticatorData.getByteString());
111     if (credentialId.isEmpty())
<span class="line-modified">112         return WTF::nullopt;</span>
113 
114     it = decodedMap.find(CBOR(3));
115     if (it == decodedMap.end() || !it-&gt;second.isMap())
<span class="line-modified">116         return WTF::nullopt;</span>
117     auto attStmt = it-&gt;second.clone();
118 
119     Optional&lt;Vector&lt;uint8_t&gt;&gt; attestationObject;
120     if (attestation == AttestationConveyancePreference::None) {
121         // The reason why we can&#39;t directly pass authenticatorData/format/attStmt to buildAttestationObject
122         // is that they are CBORValue instead of the raw type.
123         // Also, format and attStmt are omitted as they are not useful in none attestation.
124         attestationObject = buildAttestationObject(Vector&lt;uint8_t&gt;(authenticatorData.getByteString()), &quot;&quot;, { }, attestation);
125     } else {
126         CBOR::MapValue attestationObjectMap;
127         attestationObjectMap[CBOR(&quot;authData&quot;)] = WTFMove(authenticatorData);
128         attestationObjectMap[CBOR(&quot;fmt&quot;)] = WTFMove(format);
129         attestationObjectMap[CBOR(&quot;attStmt&quot;)] = WTFMove(attStmt);
130         attestationObject = cbor::CBORWriter::write(CBOR(WTFMove(attestationObjectMap)));
131     }
132 
<span class="line-modified">133     return PublicKeyCredentialData { ArrayBuffer::create(credentialId.data(), credentialId.size()), true, nullptr, ArrayBuffer::create(attestationObject.value().data(), attestationObject.value().size()), nullptr, nullptr, nullptr, WTF::nullopt };</span>
134 }
135 
<span class="line-modified">136 Optional&lt;PublicKeyCredentialData&gt; readCTAPGetAssertionResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer)</span>
137 {
138     if (inBuffer.size() &lt;= kResponseCodeLength)
<span class="line-modified">139         return WTF::nullopt;</span>
140 
141     Vector&lt;uint8_t&gt; buffer;
142     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
143     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
144 
145     if (!decodedResponse || !decodedResponse-&gt;isMap())
<span class="line-modified">146         return WTF::nullopt;</span>
147 
148     auto&amp; responseMap = decodedResponse-&gt;getMap();
149 
<span class="line-removed">150     RefPtr&lt;ArrayBuffer&gt; credentialId;</span>
151     auto it = responseMap.find(CBOR(1));
<span class="line-modified">152     if (it != responseMap.end() &amp;&amp; it-&gt;second.isMap()) {</span>
<span class="line-modified">153         auto&amp; credential = it-&gt;second.getMap();</span>
<span class="line-modified">154         auto itr = credential.find(CBOR(kCredentialIdKey));</span>
<span class="line-modified">155         if (itr == credential.end() || !itr-&gt;second.isByteString())</span>
<span class="line-modified">156             return WTF::nullopt;</span>
<span class="line-modified">157         auto&amp; id = itr-&gt;second.getByteString();</span>
<span class="line-modified">158         credentialId = ArrayBuffer::create(id.data(), id.size());</span>
<span class="line-removed">159     }</span>
160 
161     it = responseMap.find(CBOR(2));
162     if (it == responseMap.end() || !it-&gt;second.isByteString())
<span class="line-modified">163         return WTF::nullopt;</span>
164     auto&amp; authData = it-&gt;second.getByteString();
165 
166     it = responseMap.find(CBOR(3));
167     if (it == responseMap.end() || !it-&gt;second.isByteString())
<span class="line-modified">168         return WTF::nullopt;</span>
169     auto&amp; signature = it-&gt;second.getByteString();
170 
<span class="line-modified">171     RefPtr&lt;ArrayBuffer&gt; userHandle;</span>
172     it = responseMap.find(CBOR(4));
173     if (it != responseMap.end() &amp;&amp; it-&gt;second.isMap()) {
174         auto&amp; user = it-&gt;second.getMap();
175         auto itr = user.find(CBOR(kEntityIdMapKey));
176         if (itr == user.end() || !itr-&gt;second.isByteString())
<span class="line-modified">177             return WTF::nullopt;</span>
<span class="line-modified">178         auto&amp; id = itr-&gt;second.getByteString();</span>
<span class="line-modified">179         userHandle = ArrayBuffer::create(id.data(), id.size());</span>
















180     }
181 
<span class="line-modified">182     return PublicKeyCredentialData { WTFMove(credentialId), false, nullptr, nullptr, ArrayBuffer::create(authData.data(), authData.size()), ArrayBuffer::create(signature.data(), signature.size()), WTFMove(userHandle), WTF::nullopt };</span>




183 }
184 
185 Optional&lt;AuthenticatorGetInfoResponse&gt; readCTAPGetInfoResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer)
186 {
187     if (inBuffer.size() &lt;= kResponseCodeLength || getResponseCode(inBuffer) != CtapDeviceResponseCode::kSuccess)
188         return WTF::nullopt;
189 
190     Vector&lt;uint8_t&gt; buffer;
191     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
192     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
193     if (!decodedResponse || !decodedResponse-&gt;isMap())
194         return WTF::nullopt;
195     const auto&amp; responseMap = decodedResponse-&gt;getMap();
196 
197     auto it = responseMap.find(CBOR(1));
<span class="line-modified">198     if (it == responseMap.end() || !it-&gt;second.isArray() || it-&gt;second.getArray().size() &gt; 2)</span>
199         return WTF::nullopt;
200     StdSet&lt;ProtocolVersion&gt; protocolVersions;
201     for (const auto&amp; version : it-&gt;second.getArray()) {
202         if (!version.isString())
203             return WTF::nullopt;
204 
205         auto protocol = convertStringToProtocolVersion(version.getString());
206         if (protocol == ProtocolVersion::kUnknown) {
207             LOG_ERROR(&quot;Unexpected protocol version received.&quot;);
208             continue;
209         }
210 
211         if (!protocolVersions.insert(protocol).second)
212             return WTF::nullopt;
213     }
214     if (protocolVersions.empty())
215         return WTF::nullopt;
216 
217     it = responseMap.find(CBOR(3));
218     if (it == responseMap.end() || !it-&gt;second.isByteString() || it-&gt;second.getByteString().size() != aaguidLength)
</pre>
</td>
<td>
<hr />
<pre>
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;DeviceResponseConverter.h&quot;
 32 
 33 #if ENABLE(WEB_AUTHN)
 34 
 35 #include &quot;AuthenticatorSupportedOptions.h&quot;
 36 #include &quot;CBORReader.h&quot;
 37 #include &quot;CBORWriter.h&quot;
 38 #include &quot;WebAuthenticationConstants.h&quot;
 39 #include &quot;WebAuthenticationUtils.h&quot;
 40 #include &lt;wtf/StdSet.h&gt;
 41 #include &lt;wtf/Vector.h&gt;
 42 
 43 namespace fido {
 44 using namespace WebCore;
 45 using CBOR = cbor::CBORValue;
 46 


 47 static ProtocolVersion convertStringToProtocolVersion(const String&amp; version)
 48 {
 49     if (version == kCtap2Version)
 50         return ProtocolVersion::kCtap;
 51     if (version == kU2fVersion)
 52         return ProtocolVersion::kU2f;
 53 
 54     return ProtocolVersion::kUnknown;
 55 }
 56 
 57 CtapDeviceResponseCode getResponseCode(const Vector&lt;uint8_t&gt;&amp; buffer)
 58 {
 59     if (buffer.isEmpty())
 60         return CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;
 61 
 62     auto code = static_cast&lt;CtapDeviceResponseCode&gt;(buffer[0]);
 63     return isCtapDeviceResponseCode(code) ? code : CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;
 64 }
 65 
 66 static Vector&lt;uint8_t&gt; getCredentialId(const Vector&lt;uint8_t&gt;&amp; authenticatorData)
 67 {
 68     const size_t credentialIdLengthOffset = rpIdHashLength + flagsLength + signCounterLength + aaguidLength;
 69 
 70     if (authenticatorData.size() &lt; credentialIdLengthOffset + credentialIdLengthLength)
 71         return { };
 72     size_t credentialIdLength = (static_cast&lt;size_t&gt;(authenticatorData[credentialIdLengthOffset]) &lt;&lt; 8) | static_cast&lt;size_t&gt;(authenticatorData[credentialIdLengthOffset + 1]);
 73 
 74     if (authenticatorData.size() &lt; credentialIdLengthOffset + credentialIdLengthLength + credentialIdLength)
 75         return { };
 76     Vector&lt;uint8_t&gt; credentialId;
 77     credentialId.reserveInitialCapacity(credentialIdLength);
 78     auto beginIt = authenticatorData.begin() + credentialIdLengthOffset + credentialIdLengthLength;
 79     credentialId.appendRange(beginIt, beginIt + credentialIdLength);
 80     return credentialId;
 81 }
 82 
 83 
 84 // Decodes byte array response from authenticator to CBOR value object and
 85 // checks for correct encoding format.
<span class="line-modified"> 86 RefPtr&lt;AuthenticatorAttestationResponse&gt; readCTAPMakeCredentialResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer, const AttestationConveyancePreference&amp; attestation)</span>
 87 {
 88     if (inBuffer.size() &lt;= kResponseCodeLength)
<span class="line-modified"> 89         return nullptr;</span>
 90 
 91     Vector&lt;uint8_t&gt; buffer;
 92     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
 93     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
 94     if (!decodedResponse || !decodedResponse-&gt;isMap())
<span class="line-modified"> 95         return nullptr;</span>
 96     const auto&amp; decodedMap = decodedResponse-&gt;getMap();
 97 
 98     auto it = decodedMap.find(CBOR(1));
 99     if (it == decodedMap.end() || !it-&gt;second.isString())
<span class="line-modified">100         return nullptr;</span>
101     auto format = it-&gt;second.clone();
102 
103     it = decodedMap.find(CBOR(2));
104     if (it == decodedMap.end() || !it-&gt;second.isByteString())
<span class="line-modified">105         return nullptr;</span>
106     auto authenticatorData = it-&gt;second.clone();
107 
108     auto credentialId = getCredentialId(authenticatorData.getByteString());
109     if (credentialId.isEmpty())
<span class="line-modified">110         return nullptr;</span>
111 
112     it = decodedMap.find(CBOR(3));
113     if (it == decodedMap.end() || !it-&gt;second.isMap())
<span class="line-modified">114         return nullptr;</span>
115     auto attStmt = it-&gt;second.clone();
116 
117     Optional&lt;Vector&lt;uint8_t&gt;&gt; attestationObject;
118     if (attestation == AttestationConveyancePreference::None) {
119         // The reason why we can&#39;t directly pass authenticatorData/format/attStmt to buildAttestationObject
120         // is that they are CBORValue instead of the raw type.
121         // Also, format and attStmt are omitted as they are not useful in none attestation.
122         attestationObject = buildAttestationObject(Vector&lt;uint8_t&gt;(authenticatorData.getByteString()), &quot;&quot;, { }, attestation);
123     } else {
124         CBOR::MapValue attestationObjectMap;
125         attestationObjectMap[CBOR(&quot;authData&quot;)] = WTFMove(authenticatorData);
126         attestationObjectMap[CBOR(&quot;fmt&quot;)] = WTFMove(format);
127         attestationObjectMap[CBOR(&quot;attStmt&quot;)] = WTFMove(attStmt);
128         attestationObject = cbor::CBORWriter::write(CBOR(WTFMove(attestationObjectMap)));
129     }
130 
<span class="line-modified">131     return AuthenticatorAttestationResponse::create(credentialId, *attestationObject);</span>
132 }
133 
<span class="line-modified">134 RefPtr&lt;AuthenticatorAssertionResponse&gt; readCTAPGetAssertionResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer)</span>
135 {
136     if (inBuffer.size() &lt;= kResponseCodeLength)
<span class="line-modified">137         return nullptr;</span>
138 
139     Vector&lt;uint8_t&gt; buffer;
140     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
141     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
142 
143     if (!decodedResponse || !decodedResponse-&gt;isMap())
<span class="line-modified">144         return nullptr;</span>
145 
146     auto&amp; responseMap = decodedResponse-&gt;getMap();
147 

148     auto it = responseMap.find(CBOR(1));
<span class="line-modified">149     if (it == responseMap.end() || !it-&gt;second.isMap())</span>
<span class="line-modified">150         return nullptr;</span>
<span class="line-modified">151     auto&amp; credential = it-&gt;second.getMap();</span>
<span class="line-modified">152     auto itr = credential.find(CBOR(kCredentialIdKey));</span>
<span class="line-modified">153     if (itr == credential.end() || !itr-&gt;second.isByteString())</span>
<span class="line-modified">154         return nullptr;</span>
<span class="line-modified">155     auto&amp; credentialId = itr-&gt;second.getByteString();</span>

156 
157     it = responseMap.find(CBOR(2));
158     if (it == responseMap.end() || !it-&gt;second.isByteString())
<span class="line-modified">159         return nullptr;</span>
160     auto&amp; authData = it-&gt;second.getByteString();
161 
162     it = responseMap.find(CBOR(3));
163     if (it == responseMap.end() || !it-&gt;second.isByteString())
<span class="line-modified">164         return nullptr;</span>
165     auto&amp; signature = it-&gt;second.getByteString();
166 
<span class="line-modified">167     RefPtr&lt;AuthenticatorAssertionResponse&gt; response;</span>
168     it = responseMap.find(CBOR(4));
169     if (it != responseMap.end() &amp;&amp; it-&gt;second.isMap()) {
170         auto&amp; user = it-&gt;second.getMap();
171         auto itr = user.find(CBOR(kEntityIdMapKey));
172         if (itr == user.end() || !itr-&gt;second.isByteString())
<span class="line-modified">173             return nullptr;</span>
<span class="line-modified">174         auto&amp; userHandle = itr-&gt;second.getByteString();</span>
<span class="line-modified">175         response = AuthenticatorAssertionResponse::create(credentialId, authData, signature, userHandle);</span>
<span class="line-added">176 </span>
<span class="line-added">177         itr = user.find(CBOR(kEntityNameMapKey));</span>
<span class="line-added">178         if (itr != user.end()) {</span>
<span class="line-added">179             if (!itr-&gt;second.isString())</span>
<span class="line-added">180                 return nullptr;</span>
<span class="line-added">181             response-&gt;setName(itr-&gt;second.getString());</span>
<span class="line-added">182         }</span>
<span class="line-added">183 </span>
<span class="line-added">184         itr = user.find(CBOR(kDisplayNameMapKey));</span>
<span class="line-added">185         if (itr != user.end()) {</span>
<span class="line-added">186             if (!itr-&gt;second.isString())</span>
<span class="line-added">187                 return nullptr;</span>
<span class="line-added">188             response-&gt;setDisplayName(itr-&gt;second.getString());</span>
<span class="line-added">189         }</span>
<span class="line-added">190     } else {</span>
<span class="line-added">191         response = AuthenticatorAssertionResponse::create(credentialId, authData, signature, { });</span>
192     }
193 
<span class="line-modified">194     it = responseMap.find(CBOR(5));</span>
<span class="line-added">195     if (it != responseMap.end() &amp;&amp; it-&gt;second.isUnsigned())</span>
<span class="line-added">196         response-&gt;setNumberOfCredentials(it-&gt;second.getUnsigned());</span>
<span class="line-added">197 </span>
<span class="line-added">198     return response;</span>
199 }
200 
201 Optional&lt;AuthenticatorGetInfoResponse&gt; readCTAPGetInfoResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer)
202 {
203     if (inBuffer.size() &lt;= kResponseCodeLength || getResponseCode(inBuffer) != CtapDeviceResponseCode::kSuccess)
204         return WTF::nullopt;
205 
206     Vector&lt;uint8_t&gt; buffer;
207     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
208     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
209     if (!decodedResponse || !decodedResponse-&gt;isMap())
210         return WTF::nullopt;
211     const auto&amp; responseMap = decodedResponse-&gt;getMap();
212 
213     auto it = responseMap.find(CBOR(1));
<span class="line-modified">214     if (it == responseMap.end() || !it-&gt;second.isArray())</span>
215         return WTF::nullopt;
216     StdSet&lt;ProtocolVersion&gt; protocolVersions;
217     for (const auto&amp; version : it-&gt;second.getArray()) {
218         if (!version.isString())
219             return WTF::nullopt;
220 
221         auto protocol = convertStringToProtocolVersion(version.getString());
222         if (protocol == ProtocolVersion::kUnknown) {
223             LOG_ERROR(&quot;Unexpected protocol version received.&quot;);
224             continue;
225         }
226 
227         if (!protocolVersions.insert(protocol).second)
228             return WTF::nullopt;
229     }
230     if (protocolVersions.empty())
231         return WTF::nullopt;
232 
233     it = responseMap.find(CBOR(3));
234     if (it == responseMap.end() || !it-&gt;second.isByteString() || it-&gt;second.getByteString().size() != aaguidLength)
</pre>
</td>
</tr>
</table>
<center><a href="DeviceRequestConverter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DeviceResponseConverter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(WEBASSEMBLY)
  29 
  30 #include &quot;WasmParser.h&quot;
  31 #include &quot;WasmSignatureInlines.h&quot;
  32 #include &lt;wtf/DataLog.h&gt;
  33 
  34 namespace JSC { namespace Wasm {
  35 
  36 enum class BlockType {
  37     If,
  38     Block,
  39     Loop,
  40     TopLevel
  41 };
  42 
<a name="2" id="anc2"></a><span class="line-added">  43 template&lt;typename EnclosingStack, typename NewStack&gt;</span>
<span class="line-added">  44 void splitStack(BlockSignature signature, EnclosingStack&amp; enclosingStack, NewStack&amp; newStack)</span>
<span class="line-added">  45 {</span>
<span class="line-added">  46     newStack.reserveInitialCapacity(signature-&gt;argumentCount());</span>
<span class="line-added">  47     ASSERT(enclosingStack.size() &gt;= signature-&gt;argumentCount());</span>
<span class="line-added">  48     unsigned offset = enclosingStack.size() - signature-&gt;argumentCount();</span>
<span class="line-added">  49     for (unsigned i = 0; i &lt; signature-&gt;argumentCount(); ++i)</span>
<span class="line-added">  50         newStack.uncheckedAppend(enclosingStack.at(i + offset));</span>
<span class="line-added">  51     enclosingStack.shrink(offset);</span>
<span class="line-added">  52 }</span>
<span class="line-added">  53 </span>
  54 template&lt;typename Context&gt;
  55 class FunctionParser : public Parser&lt;void&gt; {
  56 public:
<a name="3" id="anc3"></a><span class="line-modified">  57     struct ControlEntry;</span>
<span class="line-added">  58 </span>
  59     using ControlType = typename Context::ControlType;
<a name="4" id="anc4"></a><span class="line-modified">  60     using ExpressionType = typename Context::ExpressionType;</span>

  61 
<a name="5" id="anc5"></a><span class="line-modified">  62     class TypedExpression {</span>
<span class="line-added">  63     public:</span>
<span class="line-added">  64         TypedExpression() = default;</span>
  65 
<a name="6" id="anc6"></a><span class="line-modified">  66         TypedExpression(Type type, ExpressionType value)</span>
<span class="line-added">  67             : m_type(type)</span>
<span class="line-added">  68             , m_value(value)</span>
<span class="line-added">  69         {</span>
<span class="line-added">  70         }</span>
<span class="line-added">  71 </span>
<span class="line-added">  72         Type type() const { return m_type; }</span>
<span class="line-added">  73 </span>
<span class="line-added">  74         ExpressionType value() const { return m_value; }</span>
<span class="line-added">  75         operator ExpressionType() const { return m_value; }</span>
<span class="line-added">  76 </span>
<span class="line-added">  77         ExpressionType operator-&gt;() const { return m_value; }</span>
<span class="line-added">  78 </span>
<span class="line-added">  79     private:</span>
<span class="line-added">  80         Type m_type;</span>
<span class="line-added">  81         ExpressionType m_value;</span>
<span class="line-added">  82     };</span>
<span class="line-added">  83 </span>
<span class="line-added">  84     using ControlStack = Vector&lt;ControlEntry, 16&gt;;</span>
<span class="line-added">  85     using ResultList = Vector&lt;ExpressionType, 8&gt;;</span>
<span class="line-added">  86     using Stack = Vector&lt;TypedExpression, 16, UnsafeVectorOverflow&gt;;</span>
  87 
  88     struct ControlEntry {
  89         Stack enclosedExpressionStack;
<a name="7" id="anc7"></a><span class="line-added">  90         Stack elseBlockStack;</span>
  91         ControlType controlData;
  92     };
  93 
<a name="8" id="anc8"></a><span class="line-added">  94     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);</span>
<span class="line-added">  95 </span>
<span class="line-added">  96     Result WARN_UNUSED_RETURN parse();</span>
<span class="line-added">  97 </span>
  98     OpType currentOpcode() const { return m_currentOpcode; }
  99     size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }
<a name="9" id="anc9"></a><span class="line-added"> 100     const Signature&amp; signature() const { return m_signature; }</span>
<span class="line-added"> 101 </span>
<span class="line-added"> 102     ControlStack&amp; controlStack() { return m_controlStack; }</span>
<span class="line-added"> 103     Stack&amp; expressionStack() { return m_expressionStack; }</span>
 104 
 105 private:
<a name="10" id="anc10"></a><span class="line-modified"> 106     static constexpr bool verbose = false;</span>
 107 
 108     PartialResult WARN_UNUSED_RETURN parseBody();
 109     PartialResult WARN_UNUSED_RETURN parseExpression();
 110     PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
 111     PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);
<a name="11" id="anc11"></a><span class="line-added"> 112     PartialResult WARN_UNUSED_RETURN checkBranchTarget(const ControlType&amp;);</span>
<span class="line-added"> 113     PartialResult WARN_UNUSED_RETURN unify(const ControlType&amp;);</span>
 114 
 115 #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
 116         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
 117         result = m_expressionStack.takeLast();                                              \
<a name="12" id="anc12"></a><span class="line-modified"> 118         m_context.didPopValueFromStack();                                                   \</span>
 119     } while (0)
 120 
 121     template&lt;OpType&gt;
<a name="13" id="anc13"></a><span class="line-modified"> 122     PartialResult WARN_UNUSED_RETURN unaryCase(Type returnType, Type operandType);</span>
 123 
 124     template&lt;OpType&gt;
<a name="14" id="anc14"></a><span class="line-modified"> 125     PartialResult WARN_UNUSED_RETURN binaryCase(Type returnType, Type lhsType, Type rhsType);</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127     PartialResult WARN_UNUSED_RETURN store(Type memoryType);</span>
<span class="line-added"> 128     PartialResult WARN_UNUSED_RETURN load(Type memoryType);</span>
 129 
 130 #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
 131 
<a name="15" id="anc15"></a><span class="line-added"> 132     template &lt;typename ...Args&gt;</span>
<span class="line-added"> 133     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN validationFail(const Args&amp;... args) const</span>
<span class="line-added"> 134     {</span>
<span class="line-added"> 135         using namespace FailureHelper; // See ADL comment in WasmParser.h.</span>
<span class="line-added"> 136         if (UNLIKELY(ASSERT_ENABLED &amp;&amp; Options::crashOnFailedWebAssemblyValidate()))</span>
<span class="line-added"> 137             WTFBreakpointTrap();</span>
<span class="line-added"> 138 </span>
<span class="line-added"> 139         StringPrintStream out;</span>
<span class="line-added"> 140         out.print(&quot;WebAssembly.Module doesn&#39;t validate: &quot;_s, args...);</span>
<span class="line-added"> 141         return UnexpectedResult(out.toString());</span>
<span class="line-added"> 142     }</span>
<span class="line-added"> 143 </span>
<span class="line-added"> 144 #define WASM_VALIDATOR_FAIL_IF(condition, ...) do { \</span>
<span class="line-added"> 145         if (UNLIKELY(condition)) \</span>
<span class="line-added"> 146             return validationFail(__VA_ARGS__); \</span>
<span class="line-added"> 147     } while (0) \</span>
<span class="line-added"> 148 </span>
 149     // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
 150 
 151     Context&amp; m_context;
 152     Stack m_expressionStack;
<a name="16" id="anc16"></a><span class="line-modified"> 153     ControlStack m_controlStack;</span>
<span class="line-added"> 154     Vector&lt;Type, 16&gt; m_locals;</span>
 155     const Signature&amp; m_signature;
 156     const ModuleInformation&amp; m_info;
 157 
 158     OpType m_currentOpcode;
 159     size_t m_currentOpcodeStartingOffset { 0 };
 160 
<a name="17" id="anc17"></a>

 161     unsigned m_unreachableBlocks { 0 };
 162     unsigned m_loopIndex { 0 };
 163 };
 164 
 165 template&lt;typename Context&gt;
 166 FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
 167     : Parser(functionStart, functionLength)
 168     , m_context(context)
<a name="18" id="anc18"></a>
 169     , m_signature(signature)
 170     , m_info(info)
 171 {
 172     if (verbose)
 173         dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength, &quot; with signature: &quot;, signature);
 174     m_context.setParser(this);
 175 }
 176 
 177 template&lt;typename Context&gt;
 178 auto FunctionParser&lt;Context&gt;::parse() -&gt; Result
 179 {
 180     uint32_t localGroupsCount;
 181 
 182     WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
 183     WASM_PARSER_FAIL_IF(!parseVarUInt32(localGroupsCount), &quot;can&#39;t get local groups count&quot;);
 184 
<a name="19" id="anc19"></a><span class="line-added"> 185     WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(m_signature.argumentCount()), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, m_signature.argumentCount(), &quot; arguments&quot;);</span>
<span class="line-added"> 186     for (uint32_t i = 0; i &lt; m_signature.argumentCount(); ++i)</span>
<span class="line-added"> 187         m_locals.uncheckedAppend(m_signature.argument(i));</span>
<span class="line-added"> 188 </span>
 189     uint64_t totalNumberOfLocals = m_signature.argumentCount();
 190     for (uint32_t i = 0; i &lt; localGroupsCount; ++i) {
 191         uint32_t numberOfLocals;
 192         Type typeOfLocal;
 193 
 194         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
 195         totalNumberOfLocals += numberOfLocals;
 196         WASM_PARSER_FAIL_IF(totalNumberOfLocals &gt; maxFunctionLocals, &quot;Function&#39;s number of locals is too big &quot;, totalNumberOfLocals, &quot; maximum &quot;, maxFunctionLocals);
 197         WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);
<a name="20" id="anc20"></a><span class="line-added"> 198 </span>
<span class="line-added"> 199         WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(totalNumberOfLocals), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, totalNumberOfLocals, &quot; locals&quot;);</span>
<span class="line-added"> 200         for (uint32_t i = 0; i &lt; numberOfLocals; ++i)</span>
<span class="line-added"> 201             m_locals.uncheckedAppend(typeOfLocal);</span>
<span class="line-added"> 202 </span>
 203         WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
 204     }
 205 
<a name="21" id="anc21"></a><span class="line-added"> 206     m_context.didFinishParsingLocals();</span>
<span class="line-added"> 207 </span>
 208     WASM_FAIL_IF_HELPER_FAILS(parseBody());
 209 
 210     return { };
 211 }
 212 
 213 template&lt;typename Context&gt;
 214 auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
 215 {
<a name="22" id="anc22"></a><span class="line-modified"> 216     m_controlStack.append({ { }, { }, m_context.addTopLevel(&amp;m_signature) });</span>
<span class="line-modified"> 217     uint8_t op = 0;</span>
 218     while (m_controlStack.size()) {
<a name="23" id="anc23"></a>

 219         m_currentOpcodeStartingOffset = m_offset;
 220         WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
 221         WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
 222 
 223         m_currentOpcode = static_cast&lt;OpType&gt;(op);
 224 
 225         if (verbose) {
 226             dataLogLn(&quot;processing op (&quot;, m_unreachableBlocks, &quot;): &quot;,  RawPointer(reinterpret_cast&lt;void*&gt;(op)), &quot;, &quot;, makeString(static_cast&lt;OpType&gt;(op)), &quot; at offset: &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(m_offset)));
 227             m_context.dump(m_controlStack, &amp;m_expressionStack);
 228         }
 229 
 230         if (m_unreachableBlocks)
 231             WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
 232         else {
 233             WASM_FAIL_IF_HELPER_FAILS(parseExpression());
<a name="24" id="anc24"></a>

 234         }
 235     }
<a name="25" id="anc25"></a><span class="line-added"> 236     WASM_FAIL_IF_HELPER_FAILS(m_context.endTopLevel(&amp;m_signature, m_expressionStack));</span>
 237 
 238     ASSERT(op == OpType::End);
 239     return { };
 240 }
 241 
 242 template&lt;typename Context&gt;
 243 template&lt;OpType op&gt;
<a name="26" id="anc26"></a><span class="line-modified"> 244 auto FunctionParser&lt;Context&gt;::binaryCase(Type returnType, Type lhsType, Type rhsType) -&gt; PartialResult</span>
 245 {
<a name="27" id="anc27"></a><span class="line-modified"> 246     TypedExpression right;</span>
<span class="line-modified"> 247     TypedExpression left;</span>

 248 
 249     WASM_TRY_POP_EXPRESSION_STACK_INTO(right, &quot;binary right&quot;);
 250     WASM_TRY_POP_EXPRESSION_STACK_INTO(left, &quot;binary left&quot;);
<a name="28" id="anc28"></a>
 251 
<a name="29" id="anc29"></a><span class="line-modified"> 252     WASM_VALIDATOR_FAIL_IF(left.type() != lhsType, op, &quot; left value type mismatch&quot;);</span>
<span class="line-added"> 253     WASM_VALIDATOR_FAIL_IF(right.type() != rhsType, op, &quot; right value type mismatch&quot;);</span>
<span class="line-added"> 254 </span>
<span class="line-added"> 255     ExpressionType result;</span>
<span class="line-added"> 256     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(left, right, result));</span>
<span class="line-added"> 257     m_expressionStack.constructAndAppend(returnType, result);</span>
 258     return { };
 259 }
 260 
 261 template&lt;typename Context&gt;
 262 template&lt;OpType op&gt;
<a name="30" id="anc30"></a><span class="line-modified"> 263 auto FunctionParser&lt;Context&gt;::unaryCase(Type returnType, Type operandType) -&gt; PartialResult</span>
 264 {
<a name="31" id="anc31"></a><span class="line-modified"> 265     TypedExpression value;</span>


 266     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;unary&quot;);
<a name="32" id="anc32"></a><span class="line-added"> 267 </span>
<span class="line-added"> 268     WASM_VALIDATOR_FAIL_IF(value.type() != operandType, op, &quot; value type mismatch&quot;);</span>
<span class="line-added"> 269 </span>
<span class="line-added"> 270     ExpressionType result;</span>
 271     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(value, result));
<a name="33" id="anc33"></a><span class="line-added"> 272     m_expressionStack.constructAndAppend(returnType, result);</span>
<span class="line-added"> 273     return { };</span>
<span class="line-added"> 274 }</span>
<span class="line-added"> 275 </span>
<span class="line-added"> 276 template&lt;typename Context&gt;</span>
<span class="line-added"> 277 auto FunctionParser&lt;Context&gt;::load(Type memoryType) -&gt; PartialResult</span>
<span class="line-added"> 278 {</span>
<span class="line-added"> 279     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;load instruction without memory&quot;);</span>
<span class="line-added"> 280 </span>
<span class="line-added"> 281     uint32_t alignment;</span>
<span class="line-added"> 282     uint32_t offset;</span>
<span class="line-added"> 283     TypedExpression pointer;</span>
<span class="line-added"> 284     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get load alignment&quot;);</span>
<span class="line-added"> 285     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds load&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-added"> 286     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get load offset&quot;);</span>
<span class="line-added"> 287     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;load pointer&quot;);</span>
<span class="line-added"> 288 </span>
<span class="line-added"> 289     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);</span>
<span class="line-added"> 290 </span>
<span class="line-added"> 291     ExpressionType result;</span>
<span class="line-added"> 292     WASM_TRY_ADD_TO_CONTEXT(load(static_cast&lt;LoadOpType&gt;(m_currentOpcode), pointer, result, offset));</span>
<span class="line-added"> 293     m_expressionStack.constructAndAppend(memoryType, result);</span>
<span class="line-added"> 294     return { };</span>
<span class="line-added"> 295 }</span>
<span class="line-added"> 296 </span>
<span class="line-added"> 297 template&lt;typename Context&gt;</span>
<span class="line-added"> 298 auto FunctionParser&lt;Context&gt;::store(Type memoryType) -&gt; PartialResult</span>
<span class="line-added"> 299 {</span>
<span class="line-added"> 300     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;store instruction without memory&quot;);</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302     uint32_t alignment;</span>
<span class="line-added"> 303     uint32_t offset;</span>
<span class="line-added"> 304     TypedExpression value;</span>
<span class="line-added"> 305     TypedExpression pointer;</span>
<span class="line-added"> 306     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get store alignment&quot;);</span>
<span class="line-added"> 307     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds store&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-added"> 308     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get store offset&quot;);</span>
<span class="line-added"> 309     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;store value&quot;);</span>
<span class="line-added"> 310     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;store pointer&quot;);</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);</span>
<span class="line-added"> 313     WASM_VALIDATOR_FAIL_IF(value.type() != memoryType, m_currentOpcode, &quot; value type mismatch&quot;);</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315     WASM_TRY_ADD_TO_CONTEXT(store(static_cast&lt;StoreOpType&gt;(m_currentOpcode), pointer, value, offset));</span>
<span class="line-added"> 316     return { };</span>
<span class="line-added"> 317 }</span>
<span class="line-added"> 318 </span>
<span class="line-added"> 319 template&lt;typename Context&gt;</span>
<span class="line-added"> 320 auto FunctionParser&lt;Context&gt;::checkBranchTarget(const ControlType&amp; target) -&gt; PartialResult</span>
<span class="line-added"> 321 {</span>
<span class="line-added"> 322     if (!target.branchTargetArity())</span>
<span class="line-added"> 323         return { };</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325     WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; target.branchTargetArity(), ControlType::isTopLevel(target) ? &quot;branch out of function&quot; : &quot;branch to block&quot;, &quot; on expression stack of size &quot;, m_expressionStack.size(), &quot;, but block, &quot;, target.signature()-&gt;toString() , &quot; expects &quot;, target.branchTargetArity(), &quot; values&quot;);</span>
<span class="line-added"> 326 </span>
<span class="line-added"> 327 </span>
<span class="line-added"> 328     unsigned offset = m_expressionStack.size() - target.branchTargetArity();</span>
<span class="line-added"> 329     for (unsigned i = 0; i &lt; target.branchTargetArity(); ++i)</span>
<span class="line-added"> 330         WASM_VALIDATOR_FAIL_IF(!isSubtype(target.branchTargetType(i), m_expressionStack[offset + i].type()), &quot;branch&#39;s stack type is not a subtype of block&#39;s type branch target type. Stack value has type&quot;, m_expressionStack[offset + i].type(), &quot; but branch target expects a value with subtype of &quot;, target.branchTargetType(i), &quot; at index &quot;, i);</span>
<span class="line-added"> 331 </span>
<span class="line-added"> 332     return { };</span>
<span class="line-added"> 333 }</span>
<span class="line-added"> 334 </span>
<span class="line-added"> 335 template&lt;typename Context&gt;</span>
<span class="line-added"> 336 auto FunctionParser&lt;Context&gt;::unify(const ControlType&amp; controlData) -&gt; PartialResult</span>
<span class="line-added"> 337 {</span>
<span class="line-added"> 338     WASM_VALIDATOR_FAIL_IF(controlData.signature()-&gt;returnCount() != m_expressionStack.size(), &quot; block with type: &quot;, controlData.signature()-&gt;toString(), &quot; returns: &quot;, controlData.signature()-&gt;returnCount(), &quot; but stack has: &quot;, m_expressionStack.size(), &quot; values&quot;);</span>
<span class="line-added"> 339     for (unsigned i = 0; i &lt; controlData.signature()-&gt;returnCount(); ++i)</span>
<span class="line-added"> 340         WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[i].type(), controlData.signature()-&gt;returnType(i)), &quot;control flow returns with unexpected type. &quot;, m_expressionStack[i].type(), &quot; is not a subtype of &quot;, controlData.signature()-&gt;returnType(i));</span>
 341 
<a name="34" id="anc34"></a>
 342     return { };
 343 }
 344 
 345 template&lt;typename Context&gt;
 346 auto FunctionParser&lt;Context&gt;::parseExpression() -&gt; PartialResult
 347 {
 348     switch (m_currentOpcode) {
<a name="35" id="anc35"></a><span class="line-modified"> 349 #define CREATE_CASE(name, id, b3op, inc, lhsType, rhsType, returnType) case OpType::name: return binaryCase&lt;OpType::name&gt;(returnType, lhsType, rhsType);</span>
 350     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
 351 #undef CREATE_CASE
 352 
<a name="36" id="anc36"></a><span class="line-modified"> 353 #define CREATE_CASE(name, id, b3op, inc, operandType, returnType) case OpType::name: return unaryCase&lt;OpType::name&gt;(returnType, operandType);</span>
 354     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
 355 #undef CREATE_CASE
 356 
 357     case Select: {
<a name="37" id="anc37"></a><span class="line-modified"> 358         TypedExpression condition;</span>
<span class="line-modified"> 359         TypedExpression zero;</span>
<span class="line-modified"> 360         TypedExpression nonZero;</span>
 361 
 362         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;select condition&quot;);
 363         WASM_TRY_POP_EXPRESSION_STACK_INTO(zero, &quot;select zero&quot;);
 364         WASM_TRY_POP_EXPRESSION_STACK_INTO(nonZero, &quot;select non-zero&quot;);
 365 
<a name="38" id="anc38"></a><span class="line-added"> 366         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;select condition must be i32, got &quot;, condition.type());</span>
<span class="line-added"> 367         WASM_VALIDATOR_FAIL_IF(nonZero.type() != zero.type(), &quot;select result types must match, got &quot;, nonZero.type(), &quot; and &quot;, zero.type());</span>
<span class="line-added"> 368 </span>
 369         ExpressionType result;
 370         WASM_TRY_ADD_TO_CONTEXT(addSelect(condition, nonZero, zero, result));
 371 
<a name="39" id="anc39"></a><span class="line-modified"> 372         m_expressionStack.constructAndAppend(zero.type(), result);</span>
 373         return { };
 374     }
 375 
<a name="40" id="anc40"></a><span class="line-modified"> 376 #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return load(memoryType);</span>
<span class="line-modified"> 377 FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)</span>
<span class="line-modified"> 378 #undef CREATE_CASE</span>











 379 
<a name="41" id="anc41"></a><span class="line-modified"> 380 #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return store(memoryType);</span>
<span class="line-modified"> 381 FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE)</span>











 382 #undef CREATE_CASE
 383 
 384     case F32Const: {
 385         uint32_t constant;
 386         WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
<a name="42" id="anc42"></a><span class="line-modified"> 387         m_expressionStack.constructAndAppend(F32, m_context.addConstant(F32, constant));</span>
 388         return { };
 389     }
 390 
 391     case I32Const: {
 392         int32_t constant;
 393         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
<a name="43" id="anc43"></a><span class="line-modified"> 394         m_expressionStack.constructAndAppend(I32, m_context.addConstant(I32, constant));</span>
 395         return { };
 396     }
 397 
 398     case F64Const: {
 399         uint64_t constant;
 400         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
<a name="44" id="anc44"></a><span class="line-modified"> 401         m_expressionStack.constructAndAppend(F64, m_context.addConstant(F64, constant));</span>
 402         return { };
 403     }
 404 
 405     case I64Const: {
 406         int64_t constant;
 407         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
<a name="45" id="anc45"></a><span class="line-modified"> 408         m_expressionStack.constructAndAppend(I64, m_context.addConstant(I64, constant));</span>
 409         return { };
 410     }
 411 
 412     case TableGet: {
 413         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 414         unsigned tableIndex;
 415         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<a name="46" id="anc46"></a><span class="line-modified"> 416         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418         TypedExpression index;</span>
 419         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.get&quot;);
<a name="47" id="anc47"></a><span class="line-added"> 420         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.get index to type &quot;, index.type(), &quot; expected &quot;, I32);</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422         ExpressionType result;</span>
 423         WASM_TRY_ADD_TO_CONTEXT(addTableGet(tableIndex, index, result));
<a name="48" id="anc48"></a><span class="line-modified"> 424         Type resultType = m_info.tables[tableIndex].wasmType();</span>
<span class="line-added"> 425         m_expressionStack.constructAndAppend(resultType, result);</span>
 426         return { };
 427     }
 428 
 429     case TableSet: {
 430         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 431         unsigned tableIndex;
 432         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<a name="49" id="anc49"></a><span class="line-modified"> 433         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
<span class="line-modified"> 434         TypedExpression value, index;</span>
<span class="line-added"> 435         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;table.set&quot;);</span>
 436         WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.set&quot;);
<a name="50" id="anc50"></a><span class="line-modified"> 437         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.set index to type &quot;, index.type(), &quot; expected &quot;, I32);</span>
<span class="line-added"> 438         Type type = m_info.tables[tableIndex].wasmType();</span>
<span class="line-added"> 439         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), type), &quot;table.set value to type &quot;, value.type(), &quot; expected &quot;, type);</span>
<span class="line-added"> 440         RELEASE_ASSERT(m_info.tables[tableIndex].type() == TableElementType::Anyref || m_info.tables[tableIndex].type() == TableElementType::Funcref);</span>
<span class="line-added"> 441         WASM_TRY_ADD_TO_CONTEXT(addTableSet(tableIndex, index, value));</span>
 442         return { };
 443     }
 444 
 445     case ExtTable: {
 446         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 447         uint8_t extOp;
 448         WASM_PARSER_FAIL_IF(!parseUInt8(extOp), &quot;can&#39;t parse table extended opcode&quot;);
 449         unsigned tableIndex;
 450         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<a name="51" id="anc51"></a><span class="line-added"> 451         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
 452 
 453         switch (static_cast&lt;ExtTableOpType&gt;(extOp)) {
 454         case ExtTableOpType::TableSize: {
 455             ExpressionType result;
 456             WASM_TRY_ADD_TO_CONTEXT(addTableSize(tableIndex, result));
<a name="52" id="anc52"></a><span class="line-modified"> 457             m_expressionStack.constructAndAppend(I32, result);</span>
 458             break;
 459         }
 460         case ExtTableOpType::TableGrow: {
<a name="53" id="anc53"></a><span class="line-modified"> 461             TypedExpression fill;</span>
<span class="line-added"> 462             TypedExpression delta;</span>
 463             WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;table.grow&quot;);
 464             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.grow&quot;);
<a name="54" id="anc54"></a><span class="line-added"> 465 </span>
<span class="line-added"> 466             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.grow expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());</span>
<span class="line-added"> 467             WASM_VALIDATOR_FAIL_IF(I32 != delta.type(), &quot;table.grow expects an i32 delta value, got &quot;, delta.type());</span>
<span class="line-added"> 468 </span>
<span class="line-added"> 469             ExpressionType result;</span>
 470             WASM_TRY_ADD_TO_CONTEXT(addTableGrow(tableIndex, fill, delta, result));
<a name="55" id="anc55"></a><span class="line-modified"> 471             m_expressionStack.constructAndAppend(I32, result);</span>
 472             break;
 473         }
 474         case ExtTableOpType::TableFill: {
<a name="56" id="anc56"></a><span class="line-modified"> 475             TypedExpression offset, fill, count;</span>
 476             WASM_TRY_POP_EXPRESSION_STACK_INTO(count, &quot;table.fill&quot;);
 477             WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.fill&quot;);
 478             WASM_TRY_POP_EXPRESSION_STACK_INTO(offset, &quot;table.fill&quot;);
<a name="57" id="anc57"></a><span class="line-added"> 479 </span>
<span class="line-added"> 480             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.fill expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());</span>
<span class="line-added"> 481             WASM_VALIDATOR_FAIL_IF(I32 != offset.type(), &quot;table.fill expects an i32 offset value, got &quot;, offset.type());</span>
<span class="line-added"> 482             WASM_VALIDATOR_FAIL_IF(I32 != count.type(), &quot;table.fill expects an i32 count value, got &quot;, count.type());</span>
<span class="line-added"> 483 </span>
 484             WASM_TRY_ADD_TO_CONTEXT(addTableFill(tableIndex, offset, fill, count));
 485             break;
 486         }
 487         default:
 488             WASM_PARSER_FAIL_IF(true, &quot;invalid extended table op &quot;, extOp);
 489             break;
 490         }
 491         return { };
 492     }
 493 
 494     case RefNull: {
 495         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<a name="58" id="anc58"></a><span class="line-modified"> 496         m_expressionStack.constructAndAppend(Funcref, m_context.addConstant(Funcref, JSValue::encode(jsNull())));</span>
 497         return { };
 498     }
 499 
 500     case RefIsNull: {
 501         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<a name="59" id="anc59"></a><span class="line-modified"> 502         TypedExpression value;</span>
 503         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;ref.is_null&quot;);
<a name="60" id="anc60"></a><span class="line-added"> 504         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), Anyref), &quot;ref.is_null to type &quot;, value.type(), &quot; expected &quot;, Anyref);</span>
<span class="line-added"> 505         ExpressionType result;</span>
 506         WASM_TRY_ADD_TO_CONTEXT(addRefIsNull(value, result));
<a name="61" id="anc61"></a><span class="line-modified"> 507         m_expressionStack.constructAndAppend(I32, result);</span>
 508         return { };
 509     }
 510 
 511     case RefFunc: {
 512         uint32_t index;
 513         ExpressionType result;
 514         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 515         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for ref.func&quot;);
 516 
<a name="62" id="anc62"></a><span class="line-added"> 517         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.functionIndexSpaceSize(), &quot;ref.func index &quot;, index, &quot; is too large, max is &quot;, m_info.functionIndexSpaceSize());</span>
<span class="line-added"> 518         m_info.addReferencedFunction(index);</span>
 519         WASM_TRY_ADD_TO_CONTEXT(addRefFunc(index, result));
<a name="63" id="anc63"></a><span class="line-modified"> 520         m_expressionStack.constructAndAppend(Funcref, result);</span>
 521         return { };
 522     }
 523 
 524     case GetLocal: {
 525         uint32_t index;
 526         ExpressionType result;
 527         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);
<a name="64" id="anc64"></a><span class="line-added"> 528         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to use unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
 529         WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
<a name="65" id="anc65"></a><span class="line-modified"> 530         m_expressionStack.constructAndAppend(m_locals[index], result);</span>
 531         return { };
 532     }
 533 
 534     case SetLocal: {
 535         uint32_t index;
<a name="66" id="anc66"></a><span class="line-modified"> 536         TypedExpression value;</span>
 537         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
 538         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);
<a name="67" id="anc67"></a><span class="line-added"> 539         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to set unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
<span class="line-added"> 540         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);</span>
 541         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
 542         return { };
 543     }
 544 
 545     case TeeLocal: {
 546         uint32_t index;
 547         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for tee_local&quot;);
 548         WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t tee_local on empty expression stack&quot;);
<a name="68" id="anc68"></a><span class="line-modified"> 549         TypedExpression value = m_expressionStack.last();</span>
<span class="line-added"> 550         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to tee unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
<span class="line-added"> 551         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);</span>
<span class="line-added"> 552         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));</span>
 553         return { };
 554     }
 555 
 556     case GetGlobal: {
 557         uint32_t index;
 558         ExpressionType result;
 559         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
<a name="69" id="anc69"></a><span class="line-added"> 560         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;get_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());</span>
<span class="line-added"> 561         Type resultType = m_info.globals[index].type;</span>
<span class="line-added"> 562         ASSERT(isValueType(resultType));</span>
 563         WASM_TRY_ADD_TO_CONTEXT(getGlobal(index, result));
<a name="70" id="anc70"></a><span class="line-modified"> 564         m_expressionStack.constructAndAppend(resultType, result);</span>
 565         return { };
 566     }
 567 
 568     case SetGlobal: {
 569         uint32_t index;
<a name="71" id="anc71"></a><span class="line-modified"> 570         TypedExpression value;</span>
 571         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
 572         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);
<a name="72" id="anc72"></a><span class="line-added"> 573 </span>
<span class="line-added"> 574         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;set_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());</span>
<span class="line-added"> 575         WASM_VALIDATOR_FAIL_IF(m_info.globals[index].mutability == GlobalInformation::Immutable, &quot;set_global &quot;, index, &quot; is immutable&quot;);</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577         Type globalType = m_info.globals[index].type;</span>
<span class="line-added"> 578         ASSERT(isValueType(globalType));</span>
<span class="line-added"> 579         WASM_VALIDATOR_FAIL_IF(globalType != value.type(), &quot;set_global &quot;, index, &quot; with type &quot;, globalType, &quot; with a variable of type &quot;, value.type());</span>
<span class="line-added"> 580 </span>
 581         WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
 582         return { };
 583     }
 584 
 585     case Call: {
 586         uint32_t functionIndex;
 587         WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t parse call&#39;s function index&quot;);
 588         WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info.functionIndexSpaceSize(), &quot;call function index &quot;, functionIndex, &quot; exceeds function index space &quot;, m_info.functionIndexSpaceSize());
 589 
 590         SignatureIndex calleeSignatureIndex = m_info.signatureIndexFromFunctionIndexSpace(functionIndex);
 591         const Signature&amp; calleeSignature = SignatureInformation::get(calleeSignatureIndex);
 592         WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 593 
 594         size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
 595         Vector&lt;ExpressionType&gt; args;
 596         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
<a name="73" id="anc73"></a><span class="line-modified"> 597         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {</span>
<span class="line-modified"> 598             TypedExpression arg = m_expressionStack.at(i);</span>
<span class="line-added"> 599             WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));</span>
<span class="line-added"> 600             args.uncheckedAppend(arg);</span>
<span class="line-added"> 601             m_context.didPopValueFromStack();</span>
<span class="line-added"> 602         }</span>
 603         m_expressionStack.shrink(firstArgumentIndex);
 604 
<a name="74" id="anc74"></a><span class="line-modified"> 605         RELEASE_ASSERT(calleeSignature.argumentCount() == args.size());</span>
<span class="line-modified"> 606 </span>
<span class="line-added"> 607         ResultList results;</span>
<span class="line-added"> 608         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, results));</span>
 609 
<a name="75" id="anc75"></a><span class="line-modified"> 610         RELEASE_ASSERT(calleeSignature.returnCount() == results.size());</span>
<span class="line-modified"> 611 </span>
<span class="line-added"> 612         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)</span>
<span class="line-added"> 613             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);</span>
 614 
 615         return { };
 616     }
 617 
 618     case CallIndirect: {
 619         uint32_t signatureIndex;
 620         uint32_t tableIndex;
 621         WASM_PARSER_FAIL_IF(!m_info.tableCount(), &quot;call_indirect is only valid when a table is defined or imported&quot;);
 622         WASM_PARSER_FAIL_IF(!parseVarUInt32(signatureIndex), &quot;can&#39;t get call_indirect&#39;s signature index&quot;);
 623         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get call_indirect&#39;s table index&quot;);
 624         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;call_indirect&#39;s table index &quot;, tableIndex, &quot; invalid, limit is &quot;, m_info.tableCount());
 625         WASM_PARSER_FAIL_IF(m_info.usedSignatures.size() &lt;= signatureIndex, &quot;call_indirect&#39;s signature index &quot;, signatureIndex, &quot; exceeds known signatures &quot;, m_info.usedSignatures.size());
 626         WASM_PARSER_FAIL_IF(m_info.tables[tableIndex].type() != TableElementType::Funcref, &quot;call_indirect is only valid when a table has type funcref&quot;);
 627 
 628         const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
 629         size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
 630         WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
 631 
<a name="76" id="anc76"></a><span class="line-added"> 632         WASM_VALIDATOR_FAIL_IF(m_expressionStack.last().type() != I32, &quot;non-i32 call_indirect index &quot;, m_expressionStack.last().type());</span>
<span class="line-added"> 633 </span>
 634         Vector&lt;ExpressionType&gt; args;
 635         WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
 636         size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
<a name="77" id="anc77"></a><span class="line-modified"> 637         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {</span>
<span class="line-modified"> 638             TypedExpression arg = m_expressionStack.at(i);</span>
<span class="line-added"> 639             if (i &lt; calleeSignature.argumentCount())</span>
<span class="line-added"> 640                 WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call_indirect, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));</span>
<span class="line-added"> 641             args.uncheckedAppend(arg);</span>
<span class="line-added"> 642             m_context.didPopValueFromStack();</span>
<span class="line-added"> 643         }</span>
 644         m_expressionStack.shrink(firstArgumentIndex);
 645 
<a name="78" id="anc78"></a>

 646 
<a name="79" id="anc79"></a><span class="line-modified"> 647 </span>
<span class="line-modified"> 648         ResultList results;</span>
<span class="line-added"> 649         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(tableIndex, calleeSignature, args, results));</span>
<span class="line-added"> 650 </span>
<span class="line-added"> 651         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)</span>
<span class="line-added"> 652             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);</span>
 653 
 654         return { };
 655     }
 656 
 657     case Block: {
<a name="80" id="anc80"></a><span class="line-modified"> 658         BlockSignature inlineSignature;</span>
<span class="line-modified"> 659         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get block&#39;s signature&quot;);</span>
<span class="line-modified"> 660 </span>
<span class="line-modified"> 661         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for block. Block expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Block has inlineSignature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-added"> 662         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-added"> 663         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {</span>
<span class="line-added"> 664             Type type = m_expressionStack.at(offset + i).type();</span>
<span class="line-added"> 665             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Block expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);</span>
<span class="line-added"> 666         }</span>
<span class="line-added"> 667 </span>
<span class="line-added"> 668         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added"> 669         Stack newStack;</span>
<span class="line-added"> 670         ControlType block;</span>
<span class="line-added"> 671         WASM_TRY_ADD_TO_CONTEXT(addBlock(inlineSignature, m_expressionStack, block, newStack));</span>
<span class="line-added"> 672         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 673         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675         m_controlStack.append({ WTFMove(m_expressionStack), { },  WTFMove(block) });</span>
<span class="line-added"> 676         m_expressionStack = WTFMove(newStack);</span>
 677         return { };
 678     }
 679 
 680     case Loop: {
<a name="81" id="anc81"></a><span class="line-modified"> 681         BlockSignature inlineSignature;</span>
<span class="line-modified"> 682         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get loop&#39;s signature&quot;);</span>
<span class="line-modified"> 683 </span>
<span class="line-modified"> 684         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for loop block. Loop expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Loop has inlineSignature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-modified"> 685         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-modified"> 686         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {</span>
<span class="line-added"> 687             Type type = m_expressionStack.at(offset + i).type();</span>
<span class="line-added"> 688             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);</span>
<span class="line-added"> 689         }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added"> 692         Stack newStack;</span>
<span class="line-added"> 693         ControlType loop;</span>
<span class="line-added"> 694         WASM_TRY_ADD_TO_CONTEXT(addLoop(inlineSignature, m_expressionStack, loop, newStack, m_loopIndex++));</span>
<span class="line-added"> 695         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 696         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 697 </span>
<span class="line-added"> 698         m_controlStack.append({ WTFMove(m_expressionStack), { }, WTFMove(loop) });</span>
<span class="line-added"> 699         m_expressionStack = WTFMove(newStack);</span>
 700         return { };
 701     }
 702 
 703     case If: {
<a name="82" id="anc82"></a><span class="line-modified"> 704         BlockSignature inlineSignature;</span>
<span class="line-modified"> 705         TypedExpression condition;</span>
<span class="line-modified"> 706         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get if&#39;s signature&quot;);</span>

 707         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
<a name="83" id="anc83"></a><span class="line-modified"> 708 </span>
<span class="line-modified"> 709         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;if condition must be i32, got &quot;, condition.type());</span>
<span class="line-modified"> 710         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few arguments on stack for if block. If expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. If block has signature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-added"> 711         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-added"> 712         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i)</span>
<span class="line-added"> 713             WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[offset + i].type(), inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, m_expressionStack[i].type());</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added"> 716         Stack newStack;</span>
<span class="line-added"> 717         ControlType control;</span>
<span class="line-added"> 718         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, m_expressionStack, control, newStack));</span>
<span class="line-added"> 719         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 720         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722         m_controlStack.append({ WTFMove(m_expressionStack), newStack, WTFMove(control) });</span>
<span class="line-added"> 723         m_expressionStack = WTFMove(newStack);</span>
 724         return { };
 725     }
 726 
 727     case Else: {
 728         WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
<a name="84" id="anc84"></a><span class="line-modified"> 729 </span>
<span class="line-modified"> 730         ControlEntry&amp; controlEntry = m_controlStack.last();</span>
<span class="line-added"> 731 </span>
<span class="line-added"> 732         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(controlEntry.controlData), &quot;else block isn&#39;t associated to an if&quot;);</span>
<span class="line-added"> 733         WASM_FAIL_IF_HELPER_FAILS(unify(controlEntry.controlData));</span>
<span class="line-added"> 734         WASM_TRY_ADD_TO_CONTEXT(addElse(controlEntry.controlData, m_expressionStack));</span>
<span class="line-added"> 735         m_expressionStack = WTFMove(controlEntry.elseBlockStack);</span>
 736         return { };
 737     }
 738 
 739     case Br:
 740     case BrIf: {
 741         uint32_t target;
<a name="85" id="anc85"></a><span class="line-modified"> 742         TypedExpression condition;</span>
 743         WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
 744         WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
<a name="86" id="anc86"></a><span class="line-modified"> 745         if (m_currentOpcode == BrIf) {</span>
 746             WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
<a name="87" id="anc87"></a><span class="line-modified"> 747             WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;conditional branch with non-i32 condition &quot;, condition.type());</span>
<span class="line-added"> 748         } else {</span>
 749             m_unreachableBlocks = 1;
<a name="88" id="anc88"></a><span class="line-added"> 750             condition = TypedExpression { Void, Context::emptyExpression() };</span>
<span class="line-added"> 751         }</span>
 752 
 753         ControlType&amp; data = m_controlStack[m_controlStack.size() - 1 - target].controlData;
<a name="89" id="anc89"></a><span class="line-modified"> 754         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(data));</span>
 755         WASM_TRY_ADD_TO_CONTEXT(addBranch(data, condition, m_expressionStack));
 756         return { };
 757     }
 758 
 759     case BrTable: {
 760         uint32_t numberOfTargets;
<a name="90" id="anc90"></a><span class="line-modified"> 761         uint32_t defaultTargetIndex;</span>
<span class="line-modified"> 762         TypedExpression condition;</span>
 763         Vector&lt;ControlType*&gt; targets;
 764 
 765         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table&quot;);
 766         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 767 
 768         WASM_PARSER_FAIL_IF(!targets.tryReserveCapacity(numberOfTargets), &quot;can&#39;t allocate memory for &quot;, numberOfTargets, &quot; br_table targets&quot;);
 769         for (uint32_t i = 0; i &lt; numberOfTargets; ++i) {
 770             uint32_t target;
 771             WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get &quot;, i, &quot;th target for br_table&quot;);
 772             WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br_table&#39;s &quot;, i, &quot;th target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
 773             targets.uncheckedAppend(&amp;m_controlStack[m_controlStack.size() - 1 - target].controlData);
 774         }
 775 
<a name="91" id="anc91"></a><span class="line-modified"> 776         WASM_PARSER_FAIL_IF(!parseVarUInt32(defaultTargetIndex), &quot;can&#39;t get default target for br_table&quot;);</span>
<span class="line-modified"> 777         WASM_PARSER_FAIL_IF(defaultTargetIndex &gt;= m_controlStack.size(), &quot;br_table&#39;s default target &quot;, defaultTargetIndex, &quot; exceeds control stack size &quot;, m_controlStack.size());</span>
<span class="line-added"> 778         ControlType&amp; defaultTarget = m_controlStack[m_controlStack.size() - 1 - defaultTargetIndex].controlData;</span>
 779 
 780         WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br_table condition&quot;);
<a name="92" id="anc92"></a><span class="line-modified"> 781         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;br_table with non-i32 condition &quot;, condition.type());</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783         for (unsigned i = 0; i &lt; targets.size(); ++i) {</span>
<span class="line-added"> 784             ControlType* target = targets[i];</span>
<span class="line-added"> 785             WASM_VALIDATOR_FAIL_IF(defaultTarget.branchTargetArity() != target-&gt;branchTargetArity(), &quot;br_table target type size mismatch. Default has size: &quot;, defaultTarget.branchTargetArity(), &quot;but target: &quot;, i, &quot; has size: &quot;, target-&gt;branchTargetArity());</span>
<span class="line-added"> 786             for (unsigned type = 0; type &lt; defaultTarget.branchTargetArity(); ++type)</span>
<span class="line-added"> 787                 WASM_VALIDATOR_FAIL_IF(!isSubtype(defaultTarget.branchTargetType(type), target-&gt;branchTargetType(type)), &quot;br_table target type mismatch at offset &quot;, type, &quot; expected: &quot;, defaultTarget.branchTargetType(type), &quot; but saw: &quot;, target-&gt;branchTargetType(type), &quot; when targeting block: &quot;, target-&gt;signature()-&gt;toString());</span>
<span class="line-added"> 788         }</span>
<span class="line-added"> 789 </span>
<span class="line-added"> 790         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(defaultTarget));</span>
<span class="line-added"> 791         WASM_TRY_ADD_TO_CONTEXT(addSwitch(condition, targets, defaultTarget, m_expressionStack));</span>
 792 
 793         m_unreachableBlocks = 1;
 794         return { };
 795     }
 796 
 797     case Return: {
<a name="93" id="anc93"></a><span class="line-modified"> 798         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(m_controlStack[0].controlData));</span>
<span class="line-modified"> 799         WASM_TRY_ADD_TO_CONTEXT(addReturn(m_controlStack[0].controlData, m_expressionStack));</span>






 800         m_unreachableBlocks = 1;
 801         return { };
 802     }
 803 
 804     case End: {
 805         ControlEntry data = m_controlStack.takeLast();
<a name="94" id="anc94"></a><span class="line-added"> 806         if (ControlType::isIf(data.controlData)) {</span>
<span class="line-added"> 807             WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
<span class="line-added"> 808             WASM_TRY_ADD_TO_CONTEXT(addElse(data.controlData, m_expressionStack));</span>
<span class="line-added"> 809             m_expressionStack = WTFMove(data.elseBlockStack);</span>
<span class="line-added"> 810         }</span>
 811         // FIXME: This is a little weird in that it will modify the expressionStack for the result of the block.
 812         // That&#39;s a little too effectful for me but I don&#39;t have a better API right now.
 813         // see: https://bugs.webkit.org/show_bug.cgi?id=164353
<a name="95" id="anc95"></a><span class="line-added"> 814         WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
 815         WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));
 816         m_expressionStack.swap(data.enclosedExpressionStack);
 817         return { };
 818     }
 819 
 820     case Unreachable: {
 821         WASM_TRY_ADD_TO_CONTEXT(addUnreachable());
 822         m_unreachableBlocks = 1;
 823         return { };
 824     }
 825 
 826     case Drop: {
 827         WASM_PARSER_FAIL_IF(!m_expressionStack.size(), &quot;can&#39;t drop on empty stack&quot;);
<a name="96" id="anc96"></a><span class="line-modified"> 828         m_expressionStack.takeLast();</span>
<span class="line-modified"> 829         m_context.didPopValueFromStack();</span>
 830         return { };
 831     }
 832 
 833     case Nop: {
 834         return { };
 835     }
 836 
 837     case GrowMemory: {
 838         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;grow_memory is only valid if a memory is defined or imported&quot;);
 839 
 840         uint8_t reserved;
 841         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory&quot;);
 842         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for grow_memory must be zero&quot;);
 843 
<a name="97" id="anc97"></a><span class="line-modified"> 844         TypedExpression delta;</span>
 845         WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;expect an i32 argument to grow_memory on the stack&quot;);
<a name="98" id="anc98"></a><span class="line-added"> 846         WASM_VALIDATOR_FAIL_IF(delta.type() != I32, &quot;grow_memory with non-i32 delta argument has type: &quot;, delta.type());</span>
 847 
 848         ExpressionType result;
 849         WASM_TRY_ADD_TO_CONTEXT(addGrowMemory(delta, result));
<a name="99" id="anc99"></a><span class="line-modified"> 850         m_expressionStack.constructAndAppend(I32, result);</span>
 851 
 852         return { };
 853     }
 854 
 855     case CurrentMemory: {
 856         WASM_PARSER_FAIL_IF(!m_info.memory, &quot;current_memory is only valid if a memory is defined or imported&quot;);
 857 
 858         uint8_t reserved;
 859         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for current_memory&quot;);
 860         WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for current_memory must be zero&quot;);
 861 
 862         ExpressionType result;
 863         WASM_TRY_ADD_TO_CONTEXT(addCurrentMemory(result));
<a name="100" id="anc100"></a><span class="line-modified"> 864         m_expressionStack.constructAndAppend(I32, result);</span>
 865 
 866         return { };
 867     }
 868     }
 869 
 870     ASSERT_NOT_REACHED();
 871     return { };
 872 }
 873 
 874 // FIXME: We should try to use the same decoder function for both unreachable and reachable code. https://bugs.webkit.org/show_bug.cgi?id=165965
 875 template&lt;typename Context&gt;
 876 auto FunctionParser&lt;Context&gt;::parseUnreachableExpression() -&gt; PartialResult
 877 {
 878     ASSERT(m_unreachableBlocks);
<a name="101" id="anc101"></a><span class="line-modified"> 879 #define CREATE_CASE(name, ...) case OpType::name:</span>
 880     switch (m_currentOpcode) {
 881     case Else: {
 882         if (m_unreachableBlocks &gt; 1)
 883             return { };
 884 
 885         ControlEntry&amp; data = m_controlStack.last();
 886         m_unreachableBlocks = 0;
<a name="102" id="anc102"></a><span class="line-added"> 887         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(data.controlData), &quot;else block isn&#39;t associated to an if&quot;);</span>
 888         WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));
<a name="103" id="anc103"></a><span class="line-modified"> 889         m_expressionStack = WTFMove(data.elseBlockStack);</span>
 890         return { };
 891     }
 892 
 893     case End: {
 894         if (m_unreachableBlocks == 1) {
 895             ControlEntry data = m_controlStack.takeLast();
<a name="104" id="anc104"></a><span class="line-modified"> 896             if (ControlType::isIf(data.controlData)) {</span>
<span class="line-added"> 897                 WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));</span>
<span class="line-added"> 898                 m_expressionStack = WTFMove(data.elseBlockStack);</span>
<span class="line-added"> 899                 WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
<span class="line-added"> 900                 WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));</span>
<span class="line-added"> 901             } else</span>
<span class="line-added"> 902                 WASM_TRY_ADD_TO_CONTEXT(addEndToUnreachable(data));</span>
<span class="line-added"> 903 </span>
 904             m_expressionStack.swap(data.enclosedExpressionStack);
 905         }
 906         m_unreachableBlocks--;
 907         return { };
 908     }
 909 
 910     case Loop:
 911     case If:
 912     case Block: {
 913         m_unreachableBlocks++;
<a name="105" id="anc105"></a><span class="line-modified"> 914         BlockSignature unused;</span>
<span class="line-modified"> 915         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);</span>
 916         return { };
 917     }
 918 
 919     case BrTable: {
 920         uint32_t numberOfTargets;
 921         uint32_t unused;
 922         WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table in unreachable context&quot;);
 923         WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
 924 
 925         for (uint32_t i = 0; i &lt; numberOfTargets; ++i)
 926             WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get &quot;, i, &quot;th target for br_table in unreachable context&quot;);
 927 
 928         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get default target for br_table in unreachable context&quot;);
 929         return { };
 930     }
 931 
 932     case CallIndirect: {
 933         uint32_t unused;
 934         uint32_t unused2;
 935         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get call_indirect&#39;s signature index in unreachable context&quot;);
 936         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused2), &quot;can&#39;t get call_indirect&#39;s reserved byte in unreachable context&quot;);
 937         return { };
 938     }
 939 
 940     case F32Const: {
 941         uint32_t unused;
 942         WASM_PARSER_FAIL_IF(!parseUInt32(unused), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
 943         return { };
 944     }
 945 
 946     case F64Const: {
 947         uint64_t constant;
 948         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
 949         return { };
 950     }
 951 
 952     // two immediate cases
 953     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)
 954     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE) {
 955         uint32_t unused;
 956         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get first immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 957         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get second immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 958         return { };
 959     }
 960 
 961     // one immediate cases
 962     case SetLocal:
 963     case GetLocal:
 964     case TeeLocal:
 965     case GetGlobal:
 966     case SetGlobal:
 967     case Br:
 968     case BrIf:
 969     case Call: {
 970         uint32_t unused;
 971         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 972         return { };
 973     }
 974 
 975     case I32Const: {
 976         int32_t unused;
 977         WASM_PARSER_FAIL_IF(!parseVarInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 978         return { };
 979     }
 980 
 981     case I64Const: {
 982         int64_t unused;
 983         WASM_PARSER_FAIL_IF(!parseVarInt64(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
 984         return { };
 985     }
 986 
 987     case ExtTable:
 988     case TableGet:
 989     case TableSet: {
 990         unsigned tableIndex;
 991         WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
 992         FALLTHROUGH;
 993     }
 994     case RefIsNull:
 995     case RefNull: {
 996         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
 997         return { };
 998     }
 999 
1000     case RefFunc: {
1001         uint32_t unused;
1002         WASM_PARSER_FAIL_IF(!parseVarUInt32(unused), &quot;can&#39;t get immediate for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);
1003         WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
1004         return { };
1005     }
1006 
1007     case GrowMemory:
1008     case CurrentMemory: {
1009         uint8_t reserved;
1010         WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory/current_memory&quot;);
1011         return { };
1012     }
1013 
1014     // no immediate cases
1015     FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
1016     FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
1017     case Unreachable:
1018     case Nop:
1019     case Return:
1020     case Select:
1021     case Drop: {
1022         return { };
1023     }
1024     }
1025 #undef CREATE_CASE
1026     RELEASE_ASSERT_NOT_REACHED();
1027 }
1028 
1029 } } // namespace JSC::Wasm
1030 
<a name="106" id="anc106"></a><span class="line-added">1031 #undef WASM_TRY_POP_EXPRESSION_STACK_INTO</span>
<span class="line-added">1032 #undef WASM_TRY_ADD_TO_CONTEXT</span>
<span class="line-added">1033 #undef WASM_VALIDATOR_FAIL_IF</span>
<span class="line-added">1034 </span>
1035 #endif // ENABLE(WEBASSEMBLY)
<a name="107" id="anc107"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="107" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SQLiteIDBTransaction.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UniqueIDBDatabase.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/UniqueIDBDatabase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,11 ***</span>
  #include &quot;config.h&quot;
  #include &quot;UniqueIDBDatabase.h&quot;
  
  #if ENABLE(INDEXED_DATABASE)
  
<span class="line-removed">- #include &quot;IDBBindingUtilities.h&quot;</span>
  #include &quot;IDBCursorInfo.h&quot;
  #include &quot;IDBGetAllRecordsData.h&quot;
  #include &quot;IDBGetAllResult.h&quot;
  #include &quot;IDBGetRecordData.h&quot;
  #include &quot;IDBIterateCursorData.h&quot;
<span class="line-new-header">--- 26,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,18 ***</span>
  #include &quot;IDBResultData.h&quot;
  #include &quot;IDBServer.h&quot;
  #include &quot;IDBTransactionInfo.h&quot;
  #include &quot;IDBValue.h&quot;
  #include &quot;Logging.h&quot;
<span class="line-removed">- #include &quot;SerializedScriptValue.h&quot;</span>
  #include &quot;StorageQuotaManager.h&quot;
  #include &quot;UniqueIDBDatabaseConnection.h&quot;
<span class="line-removed">- #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;</span>
<span class="line-removed">- #include &lt;JavaScriptCore/JSCInlines.h&gt;</span>
<span class="line-removed">- #include &lt;JavaScriptCore/StrongInlines.h&gt;</span>
<span class="line-removed">- #include &lt;wtf/MainThread.h&gt;</span>
<span class="line-removed">- #include &lt;wtf/NeverDestroyed.h&gt;</span>
  #include &lt;wtf/Scope.h&gt;
  
  namespace WebCore {
  using namespace JSC;
  namespace IDBServer {
<span class="line-new-header">--- 37,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,49 ***</span>
      for (auto&amp; path : value.blobFilePaths())
          size += path.sizeInBytes();
      return size;
  }
  
  static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)
  {
      uint64_t size = 4;
      size += info.name().sizeInBytes();
      return size;
  }
  
  static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)
  {
      uint64_t size = 4;
      size += info.name().sizeInBytes();
<span class="line-modified">!     // FIXME: estimate keyPath.</span>
<span class="line-modified">!     for (auto&amp; indexInfo : info.indexMap().values())</span>
<span class="line-removed">-         size += estimateSize(indexInfo);</span>
      return size;
  }
  
  UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
      : m_server(server)
      , m_identifier(identifier)
<span class="line-removed">-     , m_operationAndTransactionTimer(*this, &amp;UniqueIDBDatabase::operationAndTransactionTimerFired)</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());</span>
  }
  
  UniqueIDBDatabase::~UniqueIDBDatabase()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.debugString().utf8().data());</span>
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     ASSERT(!hasAnyPendingCallbacks());</span>
<span class="line-modified">!     ASSERT(!hasUnfinishedTransactions());</span>
      ASSERT(m_pendingTransactions.isEmpty());
<span class="line-modified">!     ASSERT(m_openDatabaseConnections.isEmpty());</span>
<span class="line-modified">!     ASSERT(m_clientClosePendingDatabaseConnections.isEmpty());</span>
<span class="line-modified">!     ASSERT(m_serverClosePendingDatabaseConnections.isEmpty());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RELEASE_ASSERT(m_databaseQueue.isKilled());</span>
<span class="line-removed">-     RELEASE_ASSERT(m_databaseReplyQueue.isKilled());</span>
      RELEASE_ASSERT(!m_backingStore);
  }
  
  const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
  {
      RELEASE_ASSERT(m_databaseInfo);
<span class="line-new-header">--- 79,63 ---</span>
      for (auto&amp; path : value.blobFilePaths())
          size += path.sizeInBytes();
      return size;
  }
  
<span class="line-added">+ static inline uint64_t estimateSize(const IDBKeyPath&amp; keyPath)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return WTF::switchOn(keyPath, [](const String&amp; path) {</span>
<span class="line-added">+         return static_cast&lt;uint64_t&gt;(path.sizeInBytes());</span>
<span class="line-added">+     }, [](const Vector&lt;String&gt;&amp; paths) {</span>
<span class="line-added">+         uint64_t size = 0;</span>
<span class="line-added">+         for (auto path : paths)</span>
<span class="line-added">+             size += path.sizeInBytes();</span>
<span class="line-added">+         return size;</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static inline uint64_t estimateSize(const IDBIndexInfo&amp; info)
  {
      uint64_t size = 4;
      size += info.name().sizeInBytes();
<span class="line-added">+     size += estimateSize(info.keyPath());</span>
      return size;
  }
  
  static inline uint64_t estimateSize(const IDBObjectStoreInfo&amp; info)
  {
      uint64_t size = 4;
      size += info.name().sizeInBytes();
<span class="line-modified">!     if (auto keyPath = info.keyPath())</span>
<span class="line-modified">!         size += estimateSize(*keyPath);</span>
      return size;
  }
  
  UniqueIDBDatabase::UniqueIDBDatabase(IDBServer&amp; server, const IDBDatabaseIdentifier&amp; identifier)
      : m_server(server)
      , m_identifier(identifier)
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_server.addDatabase(*this);</span>
<span class="line-added">+     LOG(IndexedDB, &quot;UniqueIDBDatabase::UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.loggingString().utf8().data());</span>
  }
  
  UniqueIDBDatabase::~UniqueIDBDatabase()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::~UniqueIDBDatabase() (%p) %s&quot;, this, m_identifier.loggingString().utf8().data());</span>
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     ASSERT(m_pendingOpenDBRequests.isEmpty());</span>
<span class="line-modified">!     ASSERT(!m_currentOpenDBRequest);</span>
<span class="line-added">+     ASSERT(m_inProgressTransactions.isEmpty());</span>
      ASSERT(m_pendingTransactions.isEmpty());
<span class="line-modified">!     ASSERT(!hasAnyOpenConnections());</span>
<span class="line-modified">!     ASSERT(!m_versionChangeTransaction);</span>
<span class="line-modified">!     ASSERT(!m_versionChangeDatabaseConnection);</span>
      RELEASE_ASSERT(!m_backingStore);
<span class="line-added">+ </span>
<span class="line-added">+     m_server.removeDatabase(*this);</span>
  }
  
  const IDBDatabaseInfo&amp; UniqueIDBDatabase::info() const
  {
      RELEASE_ASSERT(m_databaseInfo);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,107 ***</span>
  }
  
  void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
<span class="line-modified">!     ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
  
      m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
  
<span class="line-removed">-     // An open operation is already in progress, so we can&#39;t possibly handle this one yet.</span>
<span class="line-removed">-     if (m_isOpeningBackingStore)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      handleDatabaseOperations();
  }
  
<span class="line-removed">- bool UniqueIDBDatabase::hasAnyPendingCallbacks() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return !m_errorCallbacks.isEmpty()</span>
<span class="line-removed">-         || !m_keyDataCallbacks.isEmpty()</span>
<span class="line-removed">-         || !m_getResultCallbacks.isEmpty()</span>
<span class="line-removed">-         || !m_getAllResultsCallbacks.isEmpty()</span>
<span class="line-removed">-         || !m_countCallbacks.isEmpty();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool UniqueIDBDatabase::isVersionChangeInProgress()</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #if !LOG_DISABLED</span>
<span class="line-removed">-     if (m_versionChangeTransaction)</span>
<span class="line-removed">-         ASSERT(m_versionChangeDatabaseConnection);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return m_versionChangeDatabaseConnection;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static inline String quotaErrorMessageName(const char* taskName)
  {
      return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);
  }
  
<span class="line-removed">- void UniqueIDBDatabase::requestSpace(uint64_t taskSize, const char* taskName, CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_server-&gt;requestSpace(m_identifier.origin(), taskSize, [weakThis = makeWeakPtr(this), this, taskName, callback = WTFMove(callback)](auto decision) mutable {</span>
<span class="line-removed">-         if (!weakThis) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (m_owningPointerForClose) {</span>
<span class="line-removed">-             // We are closing the database, there is no point in trying to modify the database at that point.</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (decision) {</span>
<span class="line-removed">-         case StorageQuotaManager::Decision::Deny:</span>
<span class="line-removed">-             callback(IDBError { QuotaExceededError, quotaErrorMessageName(taskName) });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         case StorageQuotaManager::Decision::Grant:</span>
<span class="line-removed">-             callback({ });</span>
<span class="line-removed">-         };</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::waitForRequestSpaceCompletion(CompletionHandler&lt;void(Optional&lt;IDBError&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     requestSpace(0, &quot;&quot;, WTFMove(callback));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void UniqueIDBDatabase::performCurrentOpenOperation()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);</span>
  
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
  
<span class="line-modified">!     if (!m_databaseInfo) {</span>
<span class="line-modified">!         if (!m_isOpeningBackingStore) {</span>
<span class="line-modified">!             m_isOpeningBackingStore = true;</span>
<span class="line-modified">!             // We do not know whether this is an existing or a new database.</span>
<span class="line-modified">!             // We set a small cost so that it is not possible to open an infinite number of database.</span>
<span class="line-modified">!             m_server-&gt;requestSpace(m_identifier.origin(), defaultWriteOperationCost, [this, weakThis = makeWeakPtr(this)](auto decision) mutable {</span>
<span class="line-modified">!                 if (!weakThis)</span>
<span class="line-modified">!                     return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 if (m_owningPointerForClose)</span>
<span class="line-modified">!                     return;</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 switch (decision) {</span>
<span class="line-modified">!                 case StorageQuotaManager::Decision::Deny: {</span>
<span class="line-removed">-                     auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), IDBError { QuotaExceededError, quotaErrorMessageName(&quot;openDatabase&quot;) });</span>
<span class="line-removed">-                     m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-removed">-                     m_currentOpenDBRequest = nullptr;</span>
<span class="line-removed">-                     m_isOpeningBackingStore = false;</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 case StorageQuotaManager::Decision::Grant:</span>
<span class="line-removed">-                     this-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::openBackingStore, m_identifier));</span>
<span class="line-removed">-                 };</span>
<span class="line-removed">-             });</span>
          }
          return;
      }
  
      // If we previously started a version change operation but were blocked by having open connections,
      // we might now be unblocked.
<span class="line-new-header">--- 143,51 ---</span>
  }
  
  void UniqueIDBDatabase::openDatabaseConnection(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::openDatabaseConnection&quot;);
<span class="line-modified">!     ASSERT(!isMainThread());</span>
  
      m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
  
      handleDatabaseOperations();
  }
  
  static inline String quotaErrorMessageName(const char* taskName)
  {
      return makeString(&quot;Failed to &quot;, taskName, &quot; in database because not enough space for domain&quot;);
  }
  
  void UniqueIDBDatabase::performCurrentOpenOperation()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::performCurrentOpenOperation (%p)&quot;, this);</span>
  
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
  
<span class="line-modified">!     IDBError backingStoreOpenError;</span>
<span class="line-modified">!     if (!m_backingStore) {</span>
<span class="line-modified">!         // Quota check.</span>
<span class="line-modified">!         auto decision = m_server.requestSpace(m_identifier.origin(), defaultWriteOperationCost);</span>
<span class="line-modified">!         if (decision == StorageQuotaManager::Decision::Deny)</span>
<span class="line-modified">!             backingStoreOpenError = IDBError { QuotaExceededError, quotaErrorMessageName(&quot;OpenBackingStore&quot;) };</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             m_backingStore = m_server.createBackingStore(m_identifier);</span>
<span class="line-modified">!             IDBDatabaseInfo databaseInfo;</span>
<span class="line-modified">!             backingStoreOpenError = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);</span>
<span class="line-modified">!             if (backingStoreOpenError.isNull())</span>
<span class="line-modified">!                 m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseInfo);</span>
<span class="line-modified">!             else</span>
<span class="line-modified">!                 m_backingStore = nullptr;</span>
          }
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!backingStoreOpenError.isNull()) {</span>
<span class="line-added">+         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), backingStoreOpenError);</span>
<span class="line-added">+         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-added">+         m_currentOpenDBRequest = nullptr;</span>
<span class="line-added">+ </span>
          return;
      }
  
      // If we previously started a version change operation but were blocked by having open connections,
      // we might now be unblocked.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,18 ***</span>
          m_currentOpenDBRequest = nullptr;
  
          return;
      }
  
<span class="line-removed">-     if (!m_backingStoreOpenError.isNull()) {</span>
<span class="line-removed">-         auto result = IDBResultData::error(m_currentOpenDBRequest-&gt;requestData().requestIdentifier(), m_backingStoreOpenError);</span>
<span class="line-removed">-         m_currentOpenDBRequest-&gt;connection().didOpenDatabase(result);</span>
<span class="line-removed">-         m_currentOpenDBRequest = nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      Ref&lt;UniqueIDBDatabaseConnection&gt; connection = UniqueIDBDatabaseConnection::create(*this, *m_currentOpenDBRequest);
  
      if (requestedVersion == m_databaseInfo-&gt;version()) {
          auto* rawConnection = &amp;connection.get();
          addOpenDatabaseConnection(WTFMove(connection));
<span class="line-new-header">--- 212,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,226 ***</span>
      maybeNotifyConnectionsOfVersionChange();
  }
  
  void UniqueIDBDatabase::performCurrentDeleteOperation()
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.debugString().utf8().data());</span>
  
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
  
<span class="line-removed">-     if (m_deleteBackingStoreInProgress)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      if (hasAnyOpenConnections()) {
          maybeNotifyConnectionsOfVersionChange();
          return;
      }
  
<span class="line-removed">-     if (hasUnfinishedTransactions())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(!hasAnyPendingCallbacks());</span>
      ASSERT(m_pendingTransactions.isEmpty());
      ASSERT(m_openDatabaseConnections.isEmpty());
  
      // It&#39;s possible to have multiple delete requests queued up in a row.
      // In that scenario only the first request will actually have to delete the database.
      // Subsequent requests can immediately notify their completion.
  
<span class="line-modified">!     if (!m_deleteBackingStoreInProgress) {</span>
<span class="line-modified">!         if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)</span>
<span class="line-modified">!             didDeleteBackingStore(0);</span>
<span class="line-modified">!         else {</span>
<span class="line-removed">-             m_deleteBackingStoreInProgress = true;</span>
<span class="line-removed">-             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::deleteBackingStore, m_identifier));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::deleteBackingStore(const IDBDatabaseIdentifier&amp; identifier)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::deleteBackingStore&quot;);</span>
  
      uint64_t deletedVersion = 0;
  
      if (m_backingStore) {
          m_backingStore-&gt;deleteBackingStore();
<span class="line-removed">-         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-removed">- </span>
          m_backingStore = nullptr;
<span class="line-removed">-         m_backingStoreSupportsSimultaneousTransactions = false;</span>
<span class="line-removed">-         m_backingStoreIsEphemeral = false;</span>
      } else {
<span class="line-modified">!         auto backingStore = m_server-&gt;createBackingStore(identifier);</span>
<span class="line-removed">-         m_currentDatabaseSize = backingStore-&gt;databaseSize();</span>
  
          IDBDatabaseInfo databaseInfo;
          auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
          if (!error.isNull())
<span class="line-modified">!             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, identifier.debugString().utf8().data());</span>
  
          deletedVersion = databaseInfo.version();
          backingStore-&gt;deleteBackingStore();
<span class="line-removed">-         m_newDatabaseSize = backingStore-&gt;databaseSize();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didDeleteBackingStore, deletedVersion));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performUnconditionalDeleteBackingStore()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performUnconditionalDeleteBackingStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_backingStore)</span>
<span class="line-removed">-         m_backingStore-&gt;deleteBackingStore();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     shutdownForClose();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::scheduleShutdownForClose()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_operationAndTransactionTimer.stop();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RELEASE_ASSERT(!m_owningPointerForClose);</span>
<span class="line-removed">-     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::shutdownForClose()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     ASSERT(m_owningPointerForClose.get() == this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::shutdownForClose&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_backingStore) {</span>
<span class="line-removed">-         m_backingStore-&gt;close();</span>
<span class="line-removed">-         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_backingStore = nullptr;</span>
<span class="line-removed">-     m_backingStoreSupportsSimultaneousTransactions = false;</span>
<span class="line-removed">-     m_backingStoreIsEphemeral = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_databaseQueue.isEmpty()) {</span>
<span class="line-removed">-         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::shutdownForClose));</span>
<span class="line-removed">-         return;</span>
      }
<span class="line-removed">-     m_databaseQueue.kill();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didShutdownForClose));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void UniqueIDBDatabase::didShutdownForClose()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(m_databaseReplyQueue.isEmpty());</span>
<span class="line-removed">-     m_databaseReplyQueue.kill();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     updateSpaceUsedIfNeeded();</span>
  }
  
  void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didDeleteBackingStore&quot;);</span>
  
<span class="line-modified">!     ASSERT(!hasAnyPendingCallbacks());</span>
<span class="line-removed">-     ASSERT(!hasUnfinishedTransactions());</span>
      ASSERT(m_pendingTransactions.isEmpty());
      ASSERT(m_openDatabaseConnections.isEmpty());
      ASSERT(!m_backingStore);
  
<span class="line-modified">!     // It&#39;s possible that the openDBRequest was cancelled from client-side after the delete was already dispatched to the backingstore.</span>
<span class="line-removed">-     // So it&#39;s okay if we don&#39;t have a currentOpenDBRequest, but if we do it has to be a deleteRequest.</span>
<span class="line-removed">-     ASSERT(!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;isDeleteRequest());</span>
  
      if (m_databaseInfo)
          m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
  
      // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
      // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
      // passed in deletedVersion argument.
      if (!m_mostRecentDeletedDatabaseInfo)
<span class="line-modified">!         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion);</span>
  
      if (m_currentOpenDBRequest) {
          m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
          m_currentOpenDBRequest = nullptr;
      }
<span class="line-removed">- </span>
<span class="line-removed">-     updateSpaceUsedIfNeeded();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_deleteBackingStoreInProgress = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_hardClosedForUserDelete)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     invokeOperationAndTransactionTimer();</span>
  }
  
  void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
  {
      while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
          m_pendingOpenDBRequests.removeFirst();
  }
  
  void UniqueIDBDatabase::handleDatabaseOperations()
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());</span>
<span class="line-removed">-     ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_deleteBackingStoreInProgress || m_isOpeningBackingStore)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     clearStalePendingOpenDBRequests();</span>
  
<span class="line-modified">!     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction || (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())) {</span>
          // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
<span class="line-modified">!         if (!m_currentOpenDBRequest &amp;&amp; !m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())</span>
<span class="line-modified">!             m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Some operations (such as the first open operation after a delete) require multiple passes to completely handle</span>
<span class="line-removed">-         if (m_currentOpenDBRequest)</span>
<span class="line-removed">-             handleCurrentOperation();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     if (m_pendingOpenDBRequests.isEmpty()) {</span>
<span class="line-modified">!         m_currentOpenDBRequest = nullptr;</span>
<span class="line-modified">!         return;</span>
      }
<span class="line-modified">! </span>
<span class="line-removed">-     m_currentOpenDBRequest = m_pendingOpenDBRequests.takeFirst();</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - Popped an operation, now there are %u pending&quot;, m_pendingOpenDBRequests.size());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     handleCurrentOperation();</span>
  }
  
  void UniqueIDBDatabase::handleCurrentOperation()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleCurrentOperation&quot;);</span>
<span class="line-removed">-     ASSERT(!m_hardClosedForUserDelete);</span>
      ASSERT(m_currentOpenDBRequest);
  
      if (m_currentOpenDBRequest-&gt;isOpenRequest())
          performCurrentOpenOperation();
      else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
          performCurrentDeleteOperation();
      else
          ASSERT_NOT_REACHED();
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_currentOpenDBRequest)</span>
<span class="line-removed">-         invokeOperationAndTransactionTimer();</span>
  }
  
  bool UniqueIDBDatabase::hasAnyOpenConnections() const
  {
      return !m_openDatabaseConnections.isEmpty();
<span class="line-new-header">--- 241,126 ---</span>
      maybeNotifyConnectionsOfVersionChange();
  }
  
  void UniqueIDBDatabase::performCurrentDeleteOperation()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::performCurrentDeleteOperation - %s&quot;, m_identifier.loggingString().utf8().data());</span>
  
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());
  
      if (hasAnyOpenConnections()) {
          maybeNotifyConnectionsOfVersionChange();
          return;
      }
  
      ASSERT(m_pendingTransactions.isEmpty());
      ASSERT(m_openDatabaseConnections.isEmpty());
  
      // It&#39;s possible to have multiple delete requests queued up in a row.
      // In that scenario only the first request will actually have to delete the database.
      // Subsequent requests can immediately notify their completion.
  
<span class="line-modified">!     if (!m_databaseInfo &amp;&amp; m_mostRecentDeletedDatabaseInfo)</span>
<span class="line-modified">!         didDeleteBackingStore(0);</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!         deleteBackingStore();</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::deleteBackingStore()</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteBackingStore&quot;);</span>
  
      uint64_t deletedVersion = 0;
  
      if (m_backingStore) {
          m_backingStore-&gt;deleteBackingStore();
          m_backingStore = nullptr;
      } else {
<span class="line-modified">!         auto backingStore = m_server.createBackingStore(m_identifier);</span>
  
          IDBDatabaseInfo databaseInfo;
          auto error = backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);
          if (!error.isNull())
<span class="line-modified">!             LOG_ERROR(&quot;Error getting database info from database %s that we are trying to delete&quot;, m_identifier.loggingString().utf8().data());</span>
  
          deletedVersion = databaseInfo.version();
          backingStore-&gt;deleteBackingStore();
      }
  
<span class="line-modified">!     didDeleteBackingStore(deletedVersion);</span>
  }
  
  void UniqueIDBDatabase::didDeleteBackingStore(uint64_t deletedVersion)
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::didDeleteBackingStore&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_inProgressTransactions.isEmpty());</span>
      ASSERT(m_pendingTransactions.isEmpty());
      ASSERT(m_openDatabaseConnections.isEmpty());
      ASSERT(!m_backingStore);
  
<span class="line-modified">!     ASSERT(m_currentOpenDBRequest-&gt;isDeleteRequest());</span>
  
      if (m_databaseInfo)
          m_mostRecentDeletedDatabaseInfo = WTFMove(m_databaseInfo);
  
      // If this UniqueIDBDatabase was brought into existence for the purpose of deleting the file on disk,
      // we won&#39;t have a m_mostRecentDeletedDatabaseInfo. In that case, we&#39;ll manufacture one using the
      // passed in deletedVersion argument.
      if (!m_mostRecentDeletedDatabaseInfo)
<span class="line-modified">!         m_mostRecentDeletedDatabaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), deletedVersion, 0);</span>
  
      if (m_currentOpenDBRequest) {
          m_currentOpenDBRequest-&gt;notifyDidDeleteDatabase(*m_mostRecentDeletedDatabaseInfo);
          m_currentOpenDBRequest = nullptr;
      }
  }
  
  void UniqueIDBDatabase::clearStalePendingOpenDBRequests()
  {
      while (!m_pendingOpenDBRequests.isEmpty() &amp;&amp; m_pendingOpenDBRequests.first()-&gt;connection().isClosed())
          m_pendingOpenDBRequests.removeFirst();
  }
  
  void UniqueIDBDatabase::handleDatabaseOperations()
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - There are %u pending&quot;, m_pendingOpenDBRequests.size());</span>
  
<span class="line-modified">!     if (m_versionChangeDatabaseConnection || m_versionChangeTransaction) {</span>
          // We can&#39;t start any new open-database operations right now, but we might be able to start handling a delete operation.
<span class="line-modified">!         if (!m_currentOpenDBRequest)</span>
<span class="line-modified">!             m_currentOpenDBRequest = takeNextRunnableRequest(RequestType::Delete);</span>
<span class="line-modified">!     } else if (!m_currentOpenDBRequest || m_currentOpenDBRequest-&gt;connection().isClosed())</span>
<span class="line-modified">!         m_currentOpenDBRequest = takeNextRunnableRequest();</span>
  
<span class="line-modified">!     while (m_currentOpenDBRequest) {</span>
<span class="line-modified">!         handleCurrentOperation();</span>
<span class="line-modified">!         if (!m_currentOpenDBRequest) {</span>
<span class="line-added">+             if (m_versionChangeTransaction)</span>
<span class="line-added">+                 m_currentOpenDBRequest = takeNextRunnableRequest(RequestType::Delete);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 m_currentOpenDBRequest = takeNextRunnableRequest();</span>
<span class="line-added">+         } else // Request need multiple attempts to handle.</span>
<span class="line-added">+             break;</span>
      }
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDatabaseOperations - There are %u pending after this round of handling&quot;, m_pendingOpenDBRequests.size());</span>
  }
  
  void UniqueIDBDatabase::handleCurrentOperation()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleCurrentOperation&quot;);</span>
      ASSERT(m_currentOpenDBRequest);
  
      if (m_currentOpenDBRequest-&gt;isOpenRequest())
          performCurrentOpenOperation();
      else if (m_currentOpenDBRequest-&gt;isDeleteRequest())
          performCurrentDeleteOperation();
      else
          ASSERT_NOT_REACHED();
  }
  
  bool UniqueIDBDatabase::hasAnyOpenConnections() const
  {
      return !m_openDatabaseConnections.isEmpty();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 531,111 ***</span>
      }
  
      return true;
  }
  
<span class="line-removed">- static uint64_t generateUniqueCallbackIdentifier()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     static uint64_t currentID = 0;</span>
<span class="line-removed">-     return ++currentID;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uint64_t UniqueIDBDatabase::storeCallbackOrFireError(ErrorCallback&amp;&amp; callback, uint64_t taskSize)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">-         callback(IDBError::userDeleteError());</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed">-     ASSERT(!m_errorCallbacks.contains(identifier));</span>
<span class="line-removed">-     m_errorCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (taskSize) {</span>
<span class="line-removed">-         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-removed">-         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_callbackQueue.append(identifier);</span>
<span class="line-removed">-     return identifier;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uint64_t UniqueIDBDatabase::storeCallbackOrFireError(KeyDataCallback&amp;&amp; callback, uint64_t taskSize)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">-         callback(IDBError::userDeleteError(), { });</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed">-     ASSERT(!m_keyDataCallbacks.contains(identifier));</span>
<span class="line-removed">-     m_keyDataCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (taskSize) {</span>
<span class="line-removed">-         m_server-&gt;increasePotentialSpaceUsed(m_identifier.origin(), taskSize);</span>
<span class="line-removed">-         m_pendingSpaceIncreasingTasks.add(identifier, taskSize);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_callbackQueue.append(identifier);</span>
<span class="line-removed">-     return identifier;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetResultCallback&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">-         callback(IDBError::userDeleteError(), { });</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed">-     ASSERT(!m_getResultCallbacks.contains(identifier));</span>
<span class="line-removed">-     m_getResultCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed">-     m_callbackQueue.append(identifier);</span>
<span class="line-removed">-     return identifier;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uint64_t UniqueIDBDatabase::storeCallbackOrFireError(GetAllResultsCallback&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">-         callback(IDBError::userDeleteError(), { });</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed">-     ASSERT(!m_getAllResultsCallbacks.contains(identifier));</span>
<span class="line-removed">-     m_getAllResultsCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed">-     m_callbackQueue.append(identifier);</span>
<span class="line-removed">-     return identifier;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- uint64_t UniqueIDBDatabase::storeCallbackOrFireError(CountCallback&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">-         callback(IDBError::userDeleteError(), 0);</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t identifier = generateUniqueCallbackIdentifier();</span>
<span class="line-removed">-     ASSERT(!m_countCallbacks.contains(identifier));</span>
<span class="line-removed">-     m_countCallbacks.add(identifier, WTFMove(callback));</span>
<span class="line-removed">-     m_callbackQueue.append(identifier);</span>
<span class="line-removed">-     return identifier;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::handleDelete&quot;);</span>
<span class="line-removed">-     ASSERT(!m_hardClosedForUserDelete);</span>
  
      m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
      handleDatabaseOperations();
  }
  
  void UniqueIDBDatabase::startVersionChangeTransaction()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::startVersionChangeTransaction&quot;);</span>
  
      ASSERT(!m_versionChangeTransaction);
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
      ASSERT(m_versionChangeDatabaseConnection);
<span class="line-new-header">--- 374,21 ---</span>
      }
  
      return true;
  }
  
  void UniqueIDBDatabase::handleDelete(IDBConnectionToClient&amp; connection, const IDBRequestData&amp; requestData)
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleDelete&quot;);</span>
  
      m_pendingOpenDBRequests.add(ServerOpenDBRequest::create(connection, requestData));
      handleDatabaseOperations();
  }
  
  void UniqueIDBDatabase::startVersionChangeTransaction()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::startVersionChangeTransaction&quot;);</span>
  
      ASSERT(!m_versionChangeTransaction);
      ASSERT(m_currentOpenDBRequest);
      ASSERT(m_currentOpenDBRequest-&gt;isOpenRequest());
      ASSERT(m_versionChangeDatabaseConnection);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 643,48 ***</span>
      uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
      if (!requestedVersion)
          requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
  
      m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<span class="line-modified">!     m_inProgressTransactions.set(m_versionChangeTransaction-&gt;info().identifier(), m_versionChangeTransaction);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performStartVersionChangeTransaction, m_versionChangeTransaction-&gt;info()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performStartVersionChangeTransaction(const IDBTransactionInfo&amp; info)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performStartVersionChangeTransaction&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBError error = m_backingStore-&gt;beginTransaction(info);</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformStartVersionChangeTransaction, error));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformStartVersionChangeTransaction(const IDBError&amp; error)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformStartVersionChangeTransaction&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Open request may already be canceled by client or user, or connection to client is lost.</span>
<span class="line-removed">-     if (!m_versionChangeDatabaseConnection)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     ASSERT(m_currentOpenDBRequest);</span>
<span class="line-removed">-     ASSERT(m_versionChangeTransaction);</span>
      auto operation = WTFMove(m_currentOpenDBRequest);
      IDBResultData result;
      if (error.isNull()) {
          addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
<span class="line-modified">!         m_databaseInfo-&gt;setVersion(m_versionChangeTransaction-&gt;info().newVersion());</span>
          result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);
          operation-&gt;connection().didOpenDatabase(result);
      } else {
          m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);
          m_versionChangeDatabaseConnection = nullptr;
          result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);
          operation-&gt;connection().didOpenDatabase(result);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     invokeOperationAndTransactionTimer();</span>
  }
  
  void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
  {
      ASSERT(m_currentOpenDBRequest);
<span class="line-new-header">--- 396,27 ---</span>
      uint64_t requestedVersion = m_currentOpenDBRequest-&gt;requestData().requestedVersion();
      if (!requestedVersion)
          requestedVersion = m_databaseInfo-&gt;version() ? m_databaseInfo-&gt;version() : 1;
  
      m_versionChangeTransaction = &amp;m_versionChangeDatabaseConnection-&gt;createVersionChangeTransaction(requestedVersion);
<span class="line-modified">!     auto versionChangeTransactionInfo = m_versionChangeTransaction-&gt;info();</span>
<span class="line-modified">!     m_inProgressTransactions.set(versionChangeTransactionInfo.identifier(), m_versionChangeTransaction);</span>
  
<span class="line-modified">!     auto error = m_backingStore-&gt;beginTransaction(versionChangeTransactionInfo);</span>
      auto operation = WTFMove(m_currentOpenDBRequest);
      IDBResultData result;
      if (error.isNull()) {
          addOpenDatabaseConnection(*m_versionChangeDatabaseConnection);
<span class="line-modified">!         m_databaseInfo-&gt;setVersion(versionChangeTransactionInfo.newVersion());</span>
          result = IDBResultData::openDatabaseUpgradeNeeded(operation-&gt;requestData().requestIdentifier(), *m_versionChangeTransaction);
          operation-&gt;connection().didOpenDatabase(result);
      } else {
          m_versionChangeDatabaseConnection-&gt;abortTransactionWithoutCallback(*m_versionChangeTransaction);
          m_versionChangeDatabaseConnection = nullptr;
          result = IDBResultData::error(operation-&gt;requestData().requestIdentifier(), error);
          operation-&gt;connection().didOpenDatabase(result);
      }
  }
  
  void UniqueIDBDatabase::maybeNotifyConnectionsOfVersionChange()
  {
      ASSERT(m_currentOpenDBRequest);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 693,11 ***</span>
          return;
  
      uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
      auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
  
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);</span>
  
      // 3.3.7 &quot;versionchange&quot; transaction steps
      // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
      // The event must not be fired on connections which has the closePending flag set.
      HashSet&lt;uint64_t&gt; connectionIdentifiers;
<span class="line-new-header">--- 425,11 ---</span>
          return;
  
      uint64_t newVersion = m_currentOpenDBRequest-&gt;isOpenRequest() ? m_currentOpenDBRequest-&gt;requestData().requestedVersion() : 0;
      auto requestIdentifier = m_currentOpenDBRequest-&gt;requestData().requestIdentifier();
  
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::notifyConnectionsOfVersionChange - %&quot; PRIu64, newVersion);</span>
  
      // 3.3.7 &quot;versionchange&quot; transaction steps
      // Fire a versionchange event at each connection in m_openDatabaseConnections that is open.
      // The event must not be fired on connections which has the closePending flag set.
      HashSet&lt;uint64_t&gt; connectionIdentifiers;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,28 ***</span>
  
      if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
          return;
  
      if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
<span class="line-modified">!         invokeOperationAndTransactionTimer();</span>
          return;
      }
  
      // Since all open connections have fired their version change events but not all of them have closed,
      // this request is officially blocked.
      m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
  }
  
<span class="line-modified">! void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier)</span>
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
  
      if (!m_currentOpenDBRequest)
          return;
  
      ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
  
      notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
  }
  
  void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
  {
<span class="line-new-header">--- 457,57 ---</span>
  
      if (m_currentOpenDBRequest-&gt;hasConnectionsPendingVersionChangeEvent())
          return;
  
      if (!hasAnyOpenConnections() || allConnectionsAreClosedOrClosing()) {
<span class="line-modified">!         handleDatabaseOperations();</span>
          return;
      }
  
      // Since all open connections have fired their version change events but not all of them have closed,
      // this request is officially blocked.
      m_currentOpenDBRequest-&gt;maybeNotifyRequestBlocked(m_databaseInfo-&gt;version());
  }
  
<span class="line-modified">! void UniqueIDBDatabase::clearTransactionsOnConnection(UniqueIDBDatabaseConnection&amp; connection)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;</span>
<span class="line-added">+     while (!m_pendingTransactions.isEmpty()) {</span>
<span class="line-added">+         auto transaction = m_pendingTransactions.takeFirst();</span>
<span class="line-added">+         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)</span>
<span class="line-added">+             pendingTransactions.append(WTFMove(transaction));</span>
<span class="line-added">+         else</span>
<span class="line-added">+             connection.deleteTransaction(*transaction);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!pendingTransactions.isEmpty())</span>
<span class="line-added">+         m_pendingTransactions.swap(pendingTransactions);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;</span>
<span class="line-added">+     for (auto&amp; transaction : m_inProgressTransactions.values()) {</span>
<span class="line-added">+         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)</span>
<span class="line-added">+             transactionsToAbort.append(transaction);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     for (auto&amp; transaction : transactionsToAbort)</span>
<span class="line-added">+         transaction-&gt;abortWithoutCallback();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void UniqueIDBDatabase::didFireVersionChangeEvent(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosedOnBehalfOfServer)</span>
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::didFireVersionChangeEvent&quot;);
  
      if (!m_currentOpenDBRequest)
          return;
  
      ASSERT_UNUSED(requestIdentifier, m_currentOpenDBRequest-&gt;requestData().requestIdentifier() == requestIdentifier);
  
<span class="line-added">+     if (connectionClosedOnBehalfOfServer == IndexedDB::ConnectionClosedOnBehalfOfServer::Yes) {</span>
<span class="line-added">+         if (m_openDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-added">+             clearTransactionsOnConnection(connection);</span>
<span class="line-added">+             m_openDatabaseConnections.remove(&amp;connection);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
  }
  
  void UniqueIDBDatabase::openDBRequestCancelled(const IDBResourceIdentifier&amp; requestIdentifier)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 774,1245 ***</span>
  {
      ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
      m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
  }
  
<span class="line-modified">! void UniqueIDBDatabase::openBackingStore(const IDBDatabaseIdentifier&amp; identifier)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::openBackingStore (%p)&quot;, this);</span>
  
<span class="line-modified">!     ASSERT(!m_backingStore);</span>
<span class="line-removed">-     m_backingStore = m_server-&gt;createBackingStore(identifier);</span>
<span class="line-removed">-     m_backingStoreSupportsSimultaneousTransactions = m_backingStore-&gt;supportsSimultaneousTransactions();</span>
<span class="line-removed">-     m_backingStoreIsEphemeral = m_backingStore-&gt;isEphemeral();</span>
  
<span class="line-modified">!     // QuotaUser should have initiliazed storage usage, which contains the</span>
<span class="line-modified">!     // size of this database.</span>
<span class="line-modified">!     m_currentDatabaseSize = m_backingStore-&gt;databaseSize();</span>
  
<span class="line-modified">!     IDBDatabaseInfo databaseInfo;</span>
<span class="line-modified">!     auto error = m_backingStore-&gt;getOrEstablishDatabaseInfo(databaseInfo);</span>
  
<span class="line-modified">!     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didOpenBackingStore, databaseInfo, error));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::didOpenBackingStore(const IDBDatabaseInfo&amp; info, const IDBError&amp; error)</span>
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didOpenBackingStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);</span>
<span class="line-removed">-     m_backingStoreOpenError = error;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(m_isOpeningBackingStore);</span>
<span class="line-removed">-     m_isOpeningBackingStore = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     updateSpaceUsedIfNeeded();</span>
  
<span class="line-modified">!     if (m_hardClosedForUserDelete)</span>
          return;
  
<span class="line-modified">!     handleDatabaseOperations();</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createObjectStore&quot;);</span>
  
<span class="line-modified">!     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-modified">!     requestSpace(taskSize, &quot;createObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-modified">!         if (error) {</span>
<span class="line-modified">!             callback(WTFMove(*error));</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;createObjectStoreAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void UniqueIDBDatabase::createObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">-     if (!callbackID)</span>
          return;
  
<span class="line-modified">!     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateObjectStore, callbackID, transaction.info().identifier(), info));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::performCreateObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateObjectStore&quot;);</span>
  
      ASSERT(m_backingStore);
<span class="line-modified">!     m_backingStore-&gt;createObjectStore(transactionIdentifier, info);</span>
  
<span class="line-modified">!     IDBError error;</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateObjectStore, callbackIdentifier, error, info));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::didPerformCreateObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBObjectStoreInfo&amp; info)</span>
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateObjectStore&quot;);</span>
  
<span class="line-modified">!     if (error.isNull())</span>
<span class="line-modified">!         m_databaseInfo-&gt;addExistingObjectStore(info);</span>
  
<span class="line-modified">!     performErrorCallback(callbackIdentifier, error);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;deleteObjectStoreAfterQuotaCheck(*transaction, objectStoreName, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::deleteObjectStoreAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);</span>
<span class="line-removed">-     if (!info) {</span>
<span class="line-removed">-         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteObjectStore, callbackID, transaction.info().identifier(), info-&gt;identifier()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performDeleteObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(m_backingStore);</span>
<span class="line-removed">-     m_backingStore-&gt;deleteObjectStore(transactionIdentifier, objectStoreIdentifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBError error;</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteObjectStore, callbackIdentifier, error, objectStoreIdentifier));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformDeleteObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (error.isNull())</span>
<span class="line-removed">-         m_databaseInfo-&gt;deleteObjectStore(objectStoreIdentifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-removed">-     requestSpace(taskSize, &quot;renameObjectStore&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;renameObjectStoreAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, newName, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::renameObjectStoreAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-removed">-     if (!info) {</span>
<span class="line-removed">-         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier, newName));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performRenameObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(m_backingStore);</span>
<span class="line-removed">-     m_backingStore-&gt;renameObjectStore(transactionIdentifier, objectStoreIdentifier, newName);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBError error;</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameObjectStore, callbackIdentifier, error, objectStoreIdentifier, newName));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformRenameObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, const String&amp; newName)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (error.isNull())</span>
<span class="line-removed">-         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::clearObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;clearObjectStoreAfetQuotaCheck(*transaction, objectStoreIdentifier, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::clearObjectStoreAfetQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performClearObjectStore, callbackID, transaction.info().identifier(), objectStoreIdentifier));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performClearObjectStore(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performClearObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(m_backingStore);</span>
<span class="line-removed">-     m_backingStore-&gt;clearObjectStore(transactionIdentifier, objectStoreIdentifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBError error;</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformClearObjectStore, callbackIdentifier, error));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformClearObjectStore(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformClearObjectStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::createIndex&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-removed">-     requestSpace(taskSize, &quot;createIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;createIndexAfterQuotaCheck(taskSize, *transaction, info, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::createIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCreateIndex, callbackID, transaction.info().identifier(), info));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performCreateIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCreateIndex&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBError error;</span>
<span class="line-removed">-     ASSERT(m_backingStore);</span>
<span class="line-removed">-     if (!m_backingStore) {</span>
<span class="line-removed">-         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performCreateIndex: m_backingStore is null&quot;, this);</span>
<span class="line-removed">-         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to create index&quot;_s);</span>
<span class="line-removed">-         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     error = m_backingStore-&gt;createIndex(transactionIdentifier, info);</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCreateIndex, callbackIdentifier, error, info));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformCreateIndex(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBIndexInfo&amp; info)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCreateIndex&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (error.isNull()) {</span>
<span class="line-removed">-         ASSERT(m_databaseInfo);</span>
<span class="line-removed">-         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());</span>
<span class="line-removed">-         ASSERT(objectStoreInfo);</span>
<span class="line-removed">-         objectStoreInfo-&gt;addExistingIndex(info);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteIndex&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;deleteIndexAfterQuotaCheck(*transaction, objectStoreIdentifier, indexName, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::deleteIndexAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
  
      auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
      if (!objectStoreInfo) {
<span class="line-modified">!         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });</span>
          return;
      }
  
      auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
      if (!indexInfo) {
<span class="line-modified">!         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });</span>
          return;
      }
<span class="line-modified">! </span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexInfo-&gt;identifier()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performDeleteIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const uint64_t indexIdentifier)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteIndex&quot;);</span>
  
      ASSERT(m_backingStore);
<span class="line-modified">!     m_backingStore-&gt;deleteIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     IDBError error;</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformDeleteIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteIndex&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (error.isNull()) {</span>
<span class="line-removed">-         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-removed">-         if (objectStoreInfo)</span>
<span class="line-removed">-             objectStoreInfo-&gt;deleteIndex(indexIdentifier);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     performErrorCallback(callbackIdentifier, error);</span>
  }
  
  void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::renameIndex&quot;);</span>
  
      auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
<span class="line-modified">!     requestSpace(taskSize, &quot;renameIndex&quot;, [this, taskSize, transaction = makeWeakPtr(transaction), objectStoreIdentifier, indexIdentifier, newName, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-modified">!         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;renameIndexAfterQuotaCheck(taskSize, *transaction, objectStoreIdentifier, indexIdentifier, newName, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::renameIndexAfterQuotaCheck(uint64_t taskSize, UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">-     if (!callbackID)</span>
          return;
  
      auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
      if (!objectStoreInfo) {
<span class="line-modified">!         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });</span>
          return;
      }
  
      auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
      if (!indexInfo) {
<span class="line-modified">!         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });</span>
          return;
      }
  
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performRenameIndex, callbackID, transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performRenameIndex(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performRenameIndex&quot;);</span>
<span class="line-removed">- </span>
      ASSERT(m_backingStore);
<span class="line-modified">!     m_backingStore-&gt;renameIndex(transactionIdentifier, objectStoreIdentifier, indexIdentifier, newName);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     IDBError error;</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformRenameIndex, callbackIdentifier, error, objectStoreIdentifier, indexIdentifier, newName));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformRenameIndex(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformRenameIndex&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (error.isNull()) {</span>
<span class="line-removed">-         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-removed">-         ASSERT(objectStoreInfo);</span>
<span class="line-removed">-         if (objectStoreInfo) {</span>
<span class="line-removed">-             auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);</span>
<span class="line-removed">-             ASSERT(indexInfo);</span>
<span class="line-removed">-             indexInfo-&gt;rename(newName);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     performErrorCallback(callbackIdentifier, error);</span>
  }
  
  void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::putOrAdd&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);</span>
<span class="line-removed">-     requestSpace(taskSize, &quot;putOrAdd&quot;, [this, taskSize, requestData, keyData, value, callback = WTFMove(callback), overwriteMode](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error), { });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;putOrAddAfterQuotaCheck(taskSize, requestData, keyData, value, overwriteMode, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::putOrAddAfterQuotaCheck(uint64_t taskSize, const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback), taskSize);</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPutOrAdd, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyData, value, overwriteMode));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performPutOrAdd(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, const IDBValue&amp; originalRecordValue, IndexedDB::ObjectStoreOverwriteMode overwriteMode)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPutOrAdd&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
<span class="line-removed">-     ASSERT(objectStoreIdentifier);</span>
  
      IDBKeyData usedKey;
      IDBError error;
  
<span class="line-modified">!     if (!m_backingStore) {</span>
<span class="line-modified">!         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - UniqueIDBDatabase::performPutOrAdd: m_backingStore is null&quot;, this);</span>
<span class="line-modified">!         error = IDBError(InvalidStateError, &quot;Backing store is invalid for call to put or add&quot;_s);</span>
<span class="line-modified">!         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
          return;
      }
  
<span class="line-modified">!     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);</span>
<span class="line-modified">!     if (!objectStoreInfo) {</span>
<span class="line-modified">!         error = IDBError(InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s);</span>
<span class="line-modified">!         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
          return;
      }
  
      bool usedKeyIsGenerated = false;
      uint64_t keyNumber;
      auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
          if (usedKeyIsGenerated)
              m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
      });
      if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
          error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
          if (!error.isNull()) {
<span class="line-modified">!             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
              return;
          }
<span class="line-removed">- </span>
          usedKey.setNumberValue(keyNumber);
          usedKeyIsGenerated = true;
      } else
          usedKey = keyData;
  
      if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
          bool keyExists;
          error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
          if (error.isNull() &amp;&amp; keyExists)
<span class="line-modified">!             error = IDBError(ConstraintError, &quot;Key already exists in the object store&quot;_s);</span>
  
          if (!error.isNull()) {
<span class="line-modified">!             postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
              return;
          }
      }
<span class="line-modified">! </span>
<span class="line-removed">-     // 3.4.1 Object Store Storage Operation</span>
<span class="line-removed">-     // ...If a record already exists in store ...</span>
<span class="line-removed">-     // then remove the record from store using the steps for deleting records from an object store...</span>
      // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
      error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
      if (!error.isNull()) {
<span class="line-modified">!         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
          return;
      }
  
<span class="line-modified">!     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, originalRecordValue);</span>
<span class="line-removed">- </span>
      if (!error.isNull()) {
<span class="line-modified">!         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
          return;
      }
  
      if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
          error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
  
      generatedKeyResetter.release();
<span class="line-modified">!     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformPutOrAdd, callbackIdentifier, error, usedKey));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformPutOrAdd(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformPutOrAdd&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performKeyDataCallback(callbackIdentifier, error, resultKey);</span>
  }
  
  void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getRecord&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, requestData, getRecordData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error), { });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;getRecordAfterQuotaCheck(requestData, getRecordData, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::getRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (uint64_t indexIdentifier = requestData.indexIdentifier())</span>
<span class="line-removed">-         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetIndexRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData));</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getAllRecords&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, requestData, getAllRecordsData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error), { });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;getAllRecordsAfterQuotaCheck(requestData, getAllRecordsData, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::getAllRecordsAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetAllRecords, callbackID, requestData.transactionIdentifier(), getAllRecordsData));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performGetRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; keyRangeData, IDBGetRecordDataType type)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetRecord&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(m_backingStore);</span>
  
      IDBGetResult result;
<span class="line-modified">!     IDBError error = m_backingStore-&gt;getRecord(transactionIdentifier, objectStoreIdentifier, keyRangeData, type, result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performGetIndexRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, IndexedDB::IndexRecordType recordType, const IDBKeyRangeData&amp; range)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetIndexRecord&quot;);</span>
  
      ASSERT(m_backingStore);
  
<span class="line-modified">!     IDBGetResult result;</span>
<span class="line-removed">-     IDBError error = m_backingStore-&gt;getIndexRecord(transactionIdentifier, objectStoreIdentifier, indexIdentifier, recordType, range, result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetRecord, callbackIdentifier, error, result));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformGetRecord(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetRecord&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performGetResultCallback(callbackIdentifier, error, result);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::performGetAllRecords(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetAllRecords&quot;);</span>
  
      ASSERT(m_backingStore);
<span class="line-removed">- </span>
      IDBGetAllResult result;
<span class="line-modified">!     IDBError error = m_backingStore-&gt;getAllRecords(transactionIdentifier, getAllRecordsData, result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetAllRecords, callbackIdentifier, error, WTFMove(result)));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformGetAllRecords(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; result)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetAllRecords&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performGetAllResultsCallback(callbackIdentifier, error, result);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::getCount&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, requestData, range, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error), { });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;getCountAfterQuotaCheck(requestData, range, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::getCountAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performGetCount, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performGetCount(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; keyRangeData)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performGetCount&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(m_backingStore);</span>
<span class="line-removed">-     ASSERT(objectStoreIdentifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t count;</span>
<span class="line-removed">-     IDBError error = m_backingStore-&gt;getCount(transactionIdentifier, objectStoreIdentifier, indexIdentifier, keyRangeData, count);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformGetCount, callbackIdentifier, error, count));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformGetCount(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformGetCount&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performCountCallback(callbackIdentifier, error, count);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::deleteRecord&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, requestData, keyRangeData, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;deleteRecordAfterQuotaCheck(requestData, keyRangeData, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::deleteRecordAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performDeleteRecord, callbackID, requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performDeleteRecord(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performDeleteRecord&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBError error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, range);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformDeleteRecord, callbackIdentifier, error));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformDeleteRecord(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformDeleteRecord&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performErrorCallback(callbackIdentifier, error);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::openCursor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, requestData, info, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error), { });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;openCursorAfterQuotaCheck(requestData, info, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::openCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performOpenCursor, callbackID, requestData.transactionIdentifier(), info));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performOpenCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performOpenCursor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBGetResult result;</span>
<span class="line-removed">-     IDBError error = m_backingStore-&gt;openCursor(transactionIdentifier, info, result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformOpenCursor, callbackIdentifier, error, result));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformOpenCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformOpenCursor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performGetResultCallback(callbackIdentifier, error, result);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::iterateCursor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, requestData, data, callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error), { });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;iterateCursorAfterQuotaCheck(requestData, data, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::iterateCursorAfterQuotaCheck(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performIterateCursor, callbackID, requestData.transactionIdentifier(), requestData.cursorIdentifier(), data));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performIterateCursor(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performIterateCursor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBGetResult result;</span>
<span class="line-removed">-     IDBError error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (error.isNull()) {</span>
<span class="line-removed">-         auto addResult = m_cursorPrefetches.add(cursorIdentifier);</span>
<span class="line-removed">-         if (addResult.isNewEntry)</span>
<span class="line-removed">-             postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformIterateCursor, callbackIdentifier, error, result));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performPrefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     ASSERT(m_cursorPrefetches.contains(cursorIdentifier));</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performPrefetchCursor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_hardClosedForUserDelete || !m_backingStore-&gt;prefetchCursor(transactionIdentifier, cursorIdentifier))</span>
<span class="line-removed">-         m_cursorPrefetches.remove(cursorIdentifier);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performPrefetchCursor, transactionIdentifier, cursorIdentifier));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformIterateCursor(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; result)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformIterateCursor&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     performGetResultCallback(callbackIdentifier, error, result);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool UniqueIDBDatabase::prepareToFinishTransaction(UniqueIDBDatabaseTransaction&amp; transaction, UniqueIDBDatabaseTransaction::State state)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());</span>
<span class="line-removed">-     if (!takenTransaction)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(!m_finishingTransactions.contains(transaction.info().identifier()));</span>
<span class="line-removed">-     takenTransaction-&gt;setState(state);</span>
<span class="line-removed">-     m_finishingTransactions.set(transaction.info().identifier(), WTFMove(takenTransaction));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(transaction.databaseConnection().database() == this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto error) mutable {</span>
<span class="line-removed">-         if (error) {</span>
<span class="line-removed">-             callback(WTFMove(*error));</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!transaction) {</span>
<span class="line-removed">-             callback(IDBError { UnknownError });</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         this-&gt;commitTransactionAfterQuotaCheck(*transaction, WTFMove(callback));</span>
<span class="line-removed">-     });</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::commitTransactionAfterQuotaCheck(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
  {
<span class="line-modified">!     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-modified">!     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Committing)) {</span>
<span class="line-removed">-         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {</span>
<span class="line-removed">-             // This database connection is closing or has already closed, so there is no point in messaging back to it about the commit failing.</span>
<span class="line-removed">-             forgetErrorCallback(callbackID);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to commit transaction that is already finishing&quot;_s });</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performCommitTransaction, callbackID, transaction.info().identifier()));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::performCommitTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>
  
<span class="line-modified">!     IDBError error = m_backingStore-&gt;commitTransaction(transactionIdentifier);</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformCommitTransaction, callbackIdentifier, error, transactionIdentifier));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::didPerformCommitTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformCommitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>
  
<span class="line-modified">!     IDBError result = error;</span>
<span class="line-removed">-     auto transaction = m_finishingTransactions.get(transactionIdentifier);</span>
<span class="line-removed">-     switch (transaction-&gt;state()) {</span>
<span class="line-removed">-     case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-removed">-         result = IDBError { UnknownError, &quot;Transaction is already aborted&quot;_s };</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-removed">-         result = transaction-&gt;result();</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-removed">-     case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     performErrorCallback(callbackIdentifier, result);</span>
  
<span class="line-modified">!     transactionCompleted(m_finishingTransactions.take(transactionIdentifier));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, WaitForPendingTasks waitForPendingTasks, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(transaction.databaseConnection().database() == this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (waitForPendingTasks == WaitForPendingTasks::Yes) {</span>
<span class="line-removed">-         waitForRequestSpaceCompletion([this, transaction = makeWeakPtr(transaction), callback = WTFMove(callback)](auto&amp;&amp; error) mutable {</span>
<span class="line-removed">-             if (error) {</span>
<span class="line-removed">-                 callback(WTFMove(*error));</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             if (!transaction) {</span>
<span class="line-removed">-                 callback(IDBError { UnknownError });</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             this-&gt;abortTransaction(*transaction, WaitForPendingTasks::No, WTFMove(callback));</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     if (!prepareToFinishTransaction(transaction, UniqueIDBDatabaseTransaction::State::Aborting)) {</span>
<span class="line-removed">-         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection())) {</span>
<span class="line-removed">-             // This database connection is closing or has already closed, so there is no point in messaging back to it about the abort failing.</span>
<span class="line-removed">-             forgetErrorCallback(callbackID);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         performErrorCallback(callbackID, IDBError { UnknownError, &quot;Attempt to abort transaction that is already finishing&quot;_s });</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performAbortTransaction, callbackID, transaction.info().identifier()));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);</span>
<span class="line-removed">-     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);</span>
  
<span class="line-modified">!     m_versionChangeTransaction = nullptr;</span>
<span class="line-modified">!     m_versionChangeDatabaseConnection = nullptr;</span>
  
<span class="line-modified">!     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">-         maybeFinishHardClose();</span>
          return;
      }
  
<span class="line-modified">!     invokeOperationAndTransactionTimer();</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::performAbortTransaction(uint64_t callbackIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>
  
<span class="line-modified">!     IDBError error = m_backingStore-&gt;abortTransaction(transactionIdentifier);</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformAbortTransaction, callbackIdentifier, error, transactionIdentifier));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void UniqueIDBDatabase::didPerformAbortTransaction(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformAbortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());</span>
  
<span class="line-modified">!     auto transaction = m_finishingTransactions.take(transactionIdentifier);</span>
<span class="line-modified">!     ASSERT(transaction);</span>
  
      if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
<span class="line-modified">!         ASSERT(m_versionChangeTransaction == transaction);</span>
          ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
          ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
          m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());
      }
  
<span class="line-modified">!     IDBError result = transaction-&gt;state() == UniqueIDBDatabaseTransaction::State::Aborted ? transaction-&gt;result() : error;</span>
<span class="line-removed">-     performErrorCallback(callbackIdentifier, result);</span>
  
<span class="line-modified">!     transactionCompleted(WTFMove(transaction));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::transactionDestroyed(UniqueIDBDatabaseTransaction&amp; transaction)</span>
  {
<span class="line-modified">!     if (m_versionChangeTransaction == &amp;transaction)</span>
<span class="line-modified">!         m_versionChangeTransaction = nullptr;</span>
  }
  
  void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_serverClosePendingDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-removed">-         m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-removed">-         if (m_hardClosedForUserDelete)</span>
<span class="line-removed">-             maybeFinishHardClose();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
      Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
      m_openDatabaseConnections.remove(&amp;connection);
  
      if (m_versionChangeDatabaseConnection == &amp;connection) {
          if (m_versionChangeTransaction) {
<span class="line-modified">!             m_clientClosePendingDatabaseConnections.add(WTFMove(m_versionChangeDatabaseConnection));</span>
  
<span class="line-modified">!             auto transactionIdentifier = m_versionChangeTransaction-&gt;info().identifier();</span>
<span class="line-modified">!             if (m_inProgressTransactions.contains(transactionIdentifier)) {</span>
<span class="line-modified">!                 ASSERT(!m_finishingTransactions.contains(transactionIdentifier));</span>
<span class="line-removed">-                 connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);</span>
<span class="line-removed">-             }</span>
  
              return;
          }
<span class="line-removed">- </span>
<span class="line-removed">-         m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; pendingTransactions;</span>
<span class="line-removed">-     while (!m_pendingTransactions.isEmpty()) {</span>
<span class="line-removed">-         auto transaction = m_pendingTransactions.takeFirst();</span>
<span class="line-removed">-         if (&amp;transaction-&gt;databaseConnection() != &amp;connection)</span>
<span class="line-removed">-             pendingTransactions.append(WTFMove(transaction));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!pendingTransactions.isEmpty())</span>
<span class="line-removed">-         m_pendingTransactions.swap(pendingTransactions);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; transactionsToAbort;</span>
<span class="line-removed">-     for (auto&amp; transaction : m_inProgressTransactions.values()) {</span>
<span class="line-removed">-         if (&amp;transaction-&gt;databaseConnection() == &amp;connection)</span>
<span class="line-removed">-             transactionsToAbort.append(transaction);</span>
      }
  
<span class="line-modified">!     for (auto&amp; transaction : transactionsToAbort)</span>
<span class="line-modified">!         transaction-&gt;abortWithoutCallback();</span>
  
      if (m_currentOpenDBRequest)
          notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
  
<span class="line-modified">!     if (connection.hasNonFinishedTransactions()) {</span>
<span class="line-removed">-         m_clientClosePendingDatabaseConnections.add(WTFMove(protectedConnection));</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_hardClosedForUserDelete) {</span>
<span class="line-removed">-         maybeFinishHardClose();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
      // Now that a database connection has closed, previously blocked operations might be runnable.
<span class="line-modified">!     invokeOperationAndTransactionTimer();</span>
  }
  
  void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
      LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
  
<span class="line-removed">-     if (m_clientClosePendingDatabaseConnections.contains(&amp;connection)) {</span>
<span class="line-removed">-         ASSERT(!m_openDatabaseConnections.contains(&amp;connection));</span>
<span class="line-removed">-         ASSERT(!m_serverClosePendingDatabaseConnections.contains(&amp;connection));</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);</span>
<span class="line-removed">-     m_openDatabaseConnections.remove(&amp;connection);</span>
<span class="line-removed">- </span>
      connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
  
<span class="line-modified">!     m_serverClosePendingDatabaseConnections.add(WTFMove(protectedConnection));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::confirmDidCloseFromServer(UniqueIDBDatabaseConnection&amp; connection)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;UniqueIDBDatabase::confirmDidCloseFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_serverClosePendingDatabaseConnections.contains(&amp;connection))</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     m_serverClosePendingDatabaseConnections.remove(&amp;connection);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_hardClosedForUserDelete)</span>
<span class="line-removed">-         maybeFinishHardClose();</span>
  }
  
  void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
<span class="line-removed">-     ASSERT(!m_hardClosedForUserDelete);</span>
  
      ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
  
      m_pendingTransactions.append(WTFMove(transaction));
  
<span class="line-modified">!     invokeOperationAndTransactionTimer();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool UniqueIDBDatabase::isCurrentlyInUse() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return !m_openDatabaseConnections.isEmpty() || !m_clientClosePendingDatabaseConnections.isEmpty() || !m_pendingOpenDBRequests.isEmpty() || m_currentOpenDBRequest || m_versionChangeDatabaseConnection || m_versionChangeTransaction || m_isOpeningBackingStore || m_deleteBackingStoreInProgress;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool UniqueIDBDatabase::hasUnfinishedTransactions() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return !m_inProgressTransactions.isEmpty() || !m_finishingTransactions.isEmpty();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::invokeOperationAndTransactionTimer()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;UniqueIDBDatabase::invokeOperationAndTransactionTimer()&quot;);</span>
<span class="line-removed">-     RELEASE_ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed">-     RELEASE_ASSERT(!m_owningPointerForClose);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_operationAndTransactionTimer.isActive())</span>
<span class="line-removed">-         m_operationAndTransactionTimer.startOneShot(0_s);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::operationAndTransactionTimerFired()</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::operationAndTransactionTimerFired&quot;);</span>
<span class="line-removed">-     ASSERT(!m_hardClosedForUserDelete);</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // This UniqueIDBDatabase might be no longer in use by any web page.</span>
<span class="line-removed">-     // Assuming it is not ephemeral, the server should now close it to free up resources.</span>
<span class="line-removed">-     if (!m_backingStoreIsEphemeral &amp;&amp; !isCurrentlyInUse()) {</span>
<span class="line-removed">-         ASSERT(m_pendingTransactions.isEmpty());</span>
<span class="line-removed">-         ASSERT(!hasUnfinishedTransactions());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         scheduleShutdownForClose();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The current operation might require multiple attempts to handle, so try to</span>
<span class="line-removed">-     // make further progress on it now.</span>
<span class="line-removed">-     if (m_currentOpenDBRequest &amp;&amp; !m_currentOpenDBRequest-&gt;connection().isClosed())</span>
<span class="line-removed">-         handleCurrentOperation();</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         handleDatabaseOperations();</span>
  
      bool hadDeferredTransactions = false;
      auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
  
<span class="line-modified">!     if (transaction) {</span>
          m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
          for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
              m_objectStoreTransactionCounts.add(objectStore);
              if (!transaction-&gt;isReadOnly()) {
                  m_objectStoreWriteTransactions.add(objectStore);
<span class="line-modified">!                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);</span>
              }
          }
  
          activateTransactionInBackingStore(*transaction);
<span class="line-modified">! </span>
<span class="line-modified">!         // If no transactions were deferred, it&#39;s possible we can start another transaction right now.</span>
<span class="line-modified">!         if (!hadDeferredTransactions)</span>
<span class="line-removed">-             invokeOperationAndTransactionTimer();</span>
      }
  }
  
  void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::activateTransactionInBackingStore&quot;);</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RefPtr&lt;UniqueIDBDatabaseTransaction&gt; refTransaction(&amp;transaction);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ErrorCallback callback = [refTransaction](const IDBError&amp; error) {</span>
<span class="line-removed">-         refTransaction-&gt;didActivateInBackingStore(error);</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t callbackID = storeCallbackOrFireError(WTFMove(callback));</span>
<span class="line-removed">-     if (!callbackID)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performActivateTransactionInBackingStore, callbackID, transaction.info()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBTransactionInfo&amp; info)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(db) UniqueIDBDatabase::performActivateTransactionInBackingStore&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IDBError error = m_backingStore-&gt;beginTransaction(info);</span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::didPerformActivateTransactionInBackingStore, callbackIdentifier, error));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::didPerformActivateTransactionInBackingStore(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     LOG(IndexedDB, &quot;(main) UniqueIDBDatabase::didPerformActivateTransactionInBackingStore&quot;);</span>
  
<span class="line-modified">!     if (m_hardClosedForUserDelete)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     invokeOperationAndTransactionTimer();</span>
  
<span class="line-modified">!     performErrorCallback(callbackIdentifier, error);</span>
  }
  
  template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
  {
      for (auto scope : bScopes) {
<span class="line-new-header">--- 535,494 ---</span>
  {
      ASSERT(!m_openDatabaseConnections.contains(&amp;connection.get()));
      m_openDatabaseConnections.add(adoptRef(connection.leakRef()));
  }
  
<span class="line-modified">! void UniqueIDBDatabase::createObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const IDBObjectStoreInfo&amp; info, ErrorCallback callback)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::createObjectStore&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
  
<span class="line-modified">!     // Quota check.</span>
<span class="line-modified">!     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-modified">!     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-added">+         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;CreateObjectStore&quot;) });</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     auto error = m_backingStore-&gt;createObjectStore(transaction.info().identifier(), info);</span>
<span class="line-modified">!     if (error.isNull())</span>
<span class="line-added">+         m_databaseInfo-&gt;addExistingObjectStore(info);</span>
  
<span class="line-modified">!     callback(error);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::deleteObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, const String&amp; objectStoreName, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteObjectStore&quot;);</span>
  
<span class="line-modified">!     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreName);</span>
<span class="line-added">+     if (!info) {</span>
<span class="line-added">+         callback(IDBError { UnknownError, &quot;Attempt to delete non-existant object store&quot;_s });</span>
          return;
<span class="line-added">+     }</span>
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
<span class="line-added">+     auto error = m_backingStore-&gt;deleteObjectStore(transaction.info().identifier(), info-&gt;identifier());</span>
<span class="line-added">+     if (error.isNull())</span>
<span class="line-added">+         m_databaseInfo-&gt;deleteObjectStore(info-&gt;identifier());</span>
<span class="line-added">+ </span>
<span class="line-added">+     callback(error);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::renameObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; newName, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::renameObjectStore&quot;);</span>
  
<span class="line-modified">!     // Quota check.</span>
<span class="line-modified">!     auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();</span>
<span class="line-modified">!     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-modified">!         callback(IDBError(QuotaExceededError, quotaErrorMessageName(&quot;RenameObjectStore&quot;)));</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     auto* info = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-modified">!     if (!info) {</span>
<span class="line-modified">!         callback(IDBError { UnknownError, &quot;Attempt to rename non-existant object store&quot;_s });</span>
          return;
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(m_backingStore);</span>
<span class="line-added">+     auto error = m_backingStore-&gt;renameObjectStore(transaction.info().identifier(), objectStoreIdentifier, newName);</span>
<span class="line-added">+     if (error.isNull())</span>
<span class="line-added">+         m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);</span>
  
<span class="line-modified">!     callback(error);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::clearObjectStore(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, ErrorCallback callback)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::clearObjectStore&quot;);</span>
  
      ASSERT(m_backingStore);
<span class="line-modified">!     auto error = m_backingStore-&gt;clearObjectStore(transaction.info().identifier(), objectStoreIdentifier);</span>
  
<span class="line-modified">!     callback(error);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::createIndex(UniqueIDBDatabaseTransaction&amp; transaction, const IDBIndexInfo&amp; info, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::createIndex&quot;);</span>
  
<span class="line-modified">!     // Quota check.</span>
<span class="line-modified">!     auto taskSize = defaultWriteOperationCost + estimateSize(info);</span>
<span class="line-added">+     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-added">+         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;CreateIndex&quot;) });</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(m_backingStore);</span>
<span class="line-added">+     auto error = m_backingStore-&gt;createIndex(transaction.info().identifier(), info);</span>
<span class="line-added">+     if (error.isNull()) {</span>
<span class="line-added">+         ASSERT(m_databaseInfo);</span>
<span class="line-added">+         auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added">+         ASSERT(objectStoreInfo);</span>
<span class="line-added">+         objectStoreInfo-&gt;addExistingIndex(info);</span>
<span class="line-added">+         m_databaseInfo-&gt;setMaxIndexID(info.identifier());</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     callback(error);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::deleteIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, const String&amp; indexName, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteIndex&quot;);</span>
  
      auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
      if (!objectStoreInfo) {
<span class="line-modified">!         callback(IDBError { UnknownError, &quot;Attempt to delete index from non-existant object store&quot;_s });</span>
          return;
      }
  
      auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexName);
      if (!indexInfo) {
<span class="line-modified">!         callback(IDBError { UnknownError, &quot;Attempt to delete non-existant index&quot;_s });</span>
          return;
      }
<span class="line-modified">!     auto indexIdentifier = indexInfo-&gt;identifier();</span>
  
      ASSERT(m_backingStore);
<span class="line-modified">!     auto error = m_backingStore-&gt;deleteIndex(transaction.info().identifier(), objectStoreIdentifier, indexIdentifier);</span>
<span class="line-modified">!     if (error.isNull())</span>
<span class="line-modified">!         objectStoreInfo-&gt;deleteIndex(indexIdentifier);</span>
  
<span class="line-modified">!     callback(error);</span>
  }
  
  void UniqueIDBDatabase::renameIndex(UniqueIDBDatabaseTransaction&amp; transaction, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName, ErrorCallback callback)
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::renameIndex&quot;);</span>
  
<span class="line-added">+     // Quota check.</span>
      auto taskSize = defaultWriteOperationCost + newName.sizeInBytes();
<span class="line-modified">!     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-modified">!         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;RenameIndex&quot;) });</span>
          return;
<span class="line-added">+     }</span>
  
      auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
      if (!objectStoreInfo) {
<span class="line-modified">!         callback(IDBError { UnknownError, &quot;Attempt to rename index in non-existant object store&quot;_s });</span>
          return;
      }
  
      auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
      if (!indexInfo) {
<span class="line-modified">!         callback(IDBError { UnknownError, &quot;Attempt to rename non-existant index&quot;_s });</span>
          return;
      }
  
      ASSERT(m_backingStore);
<span class="line-modified">!     auto error = m_backingStore-&gt;renameIndex(transaction.info().identifier(), objectStoreIdentifier, indexIdentifier, newName);</span>
<span class="line-modified">!     if (error.isNull())</span>
<span class="line-modified">!         indexInfo-&gt;rename(newName);</span>
  
<span class="line-modified">!     callback(error);</span>
  }
  
  void UniqueIDBDatabase::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode, KeyDataCallback callback)
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::putOrAdd&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_databaseInfo);</span>
  
      IDBKeyData usedKey;
      IDBError error;
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
<span class="line-modified">!     auto objectStoreIdentifier = requestData.objectStoreIdentifier();</span>
<span class="line-modified">!     auto* objectStoreInfo = m_backingStore-&gt;infoForObjectStore(objectStoreIdentifier);</span>
<span class="line-modified">!     if (!objectStoreInfo) {</span>
<span class="line-added">+         callback(IDBError { InvalidStateError, &quot;Object store cannot be found in the backing store&quot;_s }, usedKey);</span>
          return;
      }
  
<span class="line-modified">!     // Quota check.</span>
<span class="line-modified">!     auto taskSize = defaultWriteOperationCost + estimateSize(keyData) + estimateSize(value);</span>
<span class="line-modified">!     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-modified">!     if (objectStore)</span>
<span class="line-added">+         taskSize += objectStore-&gt;indexNames().size() * taskSize;</span>
<span class="line-added">+     if (m_server.requestSpace(m_identifier.origin(), taskSize) == StorageQuotaManager::Decision::Deny) {</span>
<span class="line-added">+         callback(IDBError { QuotaExceededError, quotaErrorMessageName(&quot;PutOrAdd&quot;) }, usedKey);</span>
          return;
      }
  
      bool usedKeyIsGenerated = false;
      uint64_t keyNumber;
<span class="line-added">+     auto transactionIdentifier = requestData.transactionIdentifier();</span>
      auto generatedKeyResetter = WTF::makeScopeExit([this, transactionIdentifier, objectStoreIdentifier, &amp;keyNumber, &amp;usedKeyIsGenerated]() {
          if (usedKeyIsGenerated)
              m_backingStore-&gt;revertGeneratedKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
      });
<span class="line-added">+ </span>
      if (objectStoreInfo-&gt;autoIncrement() &amp;&amp; !keyData.isValid()) {
          error = m_backingStore-&gt;generateKeyNumber(transactionIdentifier, objectStoreIdentifier, keyNumber);
          if (!error.isNull()) {
<span class="line-modified">!             callback(error, usedKey);</span>
              return;
          }
          usedKey.setNumberValue(keyNumber);
          usedKeyIsGenerated = true;
      } else
          usedKey = keyData;
  
      if (overwriteMode == IndexedDB::ObjectStoreOverwriteMode::NoOverwrite) {
          bool keyExists;
          error = m_backingStore-&gt;keyExistsInObjectStore(transactionIdentifier, objectStoreIdentifier, usedKey, keyExists);
          if (error.isNull() &amp;&amp; keyExists)
<span class="line-modified">!             error = IDBError { ConstraintError, &quot;Key already exists in the object store&quot;_s };</span>
  
          if (!error.isNull()) {
<span class="line-modified">!             callback(error, usedKey);</span>
              return;
          }
      }
<span class="line-modified">!     // If a record already exists in store, then remove the record from store using the steps for deleting records from an object store.</span>
      // This is important because formally deleting it from from the object store also removes it from the appropriate indexes.
      error = m_backingStore-&gt;deleteRange(transactionIdentifier, objectStoreIdentifier, usedKey);
      if (!error.isNull()) {
<span class="line-modified">!         callback(error, usedKey);</span>
          return;
      }
  
<span class="line-modified">!     error = m_backingStore-&gt;addRecord(transactionIdentifier, *objectStoreInfo, usedKey, value);</span>
      if (!error.isNull()) {
<span class="line-modified">!         callback(error, usedKey);</span>
          return;
      }
  
      if (overwriteMode != IndexedDB::ObjectStoreOverwriteMode::OverwriteForCursor &amp;&amp; objectStoreInfo-&gt;autoIncrement() &amp;&amp; keyData.type() == IndexedDB::KeyType::Number)
          error = m_backingStore-&gt;maybeUpdateKeyGeneratorNumber(transactionIdentifier, objectStoreIdentifier, keyData.number());
  
      generatedKeyResetter.release();
<span class="line-modified">!     callback(error, usedKey);</span>
  }
  
  void UniqueIDBDatabase::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData, GetResultCallback callback)
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::getRecord&quot;);</span>
  
      IDBGetResult result;
<span class="line-modified">!     IDBError error;</span>
  
      ASSERT(m_backingStore);
<span class="line-added">+     if (uint64_t indexIdentifier = requestData.indexIdentifier())</span>
<span class="line-added">+         error = m_backingStore-&gt;getIndexRecord(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), indexIdentifier, requestData.indexRecordType(), getRecordData.keyRangeData, result);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         error = m_backingStore-&gt;getRecord(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), getRecordData.keyRangeData, getRecordData.type, result);</span>
  
<span class="line-modified">!     callback(error, result);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData, GetAllResultsCallback callback)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::getAllRecords&quot;);</span>
  
      ASSERT(m_backingStore);
      IDBGetAllResult result;
<span class="line-modified">!     auto error = m_backingStore-&gt;getAllRecords(requestData.transactionIdentifier(), getAllRecordsData, result);</span>
  
<span class="line-modified">!     callback(error, result);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; range, CountCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::getCount&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
<span class="line-modified">!     uint64_t count = 0;</span>
<span class="line-modified">!     auto error = m_backingStore-&gt;getCount(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), requestData.indexIdentifier(), range, count);</span>
  
<span class="line-modified">!     callback(error, count);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData, ErrorCallback callback)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::deleteRecord&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(m_backingStore);</span>
<span class="line-added">+     auto error = m_backingStore-&gt;deleteRange(requestData.transactionIdentifier(), requestData.objectStoreIdentifier(), keyRangeData);</span>
  
<span class="line-modified">!     callback(error);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info, GetResultCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::openCursor&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
  
<span class="line-modified">!     IDBGetResult result;</span>
<span class="line-added">+     auto error = m_backingStore-&gt;openCursor(requestData.transactionIdentifier(), info, result);</span>
  
<span class="line-modified">!     callback(error, result);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data, GetResultCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::iterateCursor&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
  
<span class="line-modified">!     IDBGetResult result;</span>
<span class="line-modified">!     auto transactionIdentifier = requestData.transactionIdentifier();</span>
<span class="line-modified">!     auto cursorIdentifier = requestData.cursorIdentifier();</span>
<span class="line-added">+     auto error = m_backingStore-&gt;iterateCursor(transactionIdentifier, cursorIdentifier, data, result);</span>
  
<span class="line-modified">!     callback(error, result);</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::commitTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::commitTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>
  
<span class="line-modified">!     ASSERT(transaction.databaseConnection().database() == this);</span>
<span class="line-modified">!     ASSERT(m_backingStore);</span>
<span class="line-added">+     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());</span>
<span class="line-added">+     if (!takenTransaction) {</span>
<span class="line-added">+         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection()))</span>
<span class="line-added">+             return;</span>
  
<span class="line-modified">!         callback(IDBError { UnknownError, &quot;Attempt to commit transaction that is not running&quot;_s });</span>
          return;
      }
  
<span class="line-modified">!     auto error = m_backingStore-&gt;commitTransaction(transaction.info().identifier());</span>
<span class="line-added">+ </span>
<span class="line-added">+     callback(error);</span>
<span class="line-added">+     transactionCompleted(WTFMove(takenTransaction));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::abortTransaction(UniqueIDBDatabaseTransaction&amp; transaction, ErrorCallback callback)</span>
  {
      ASSERT(!isMainThread());
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::abortTransaction - %s&quot;, transaction.info().identifier().loggingString().utf8().data());</span>
  
<span class="line-modified">!     ASSERT(transaction.databaseConnection().database() == this);</span>
  
<span class="line-modified">!     auto takenTransaction = m_inProgressTransactions.take(transaction.info().identifier());</span>
<span class="line-modified">!     if (!takenTransaction) {</span>
<span class="line-modified">!         if (!m_openDatabaseConnections.contains(&amp;transaction.databaseConnection()))</span>
<span class="line-modified">!             return;</span>
  
<span class="line-modified">!         callback(IDBError { UnknownError, &quot;Attempt to abort transaction that is not running&quot;_s });</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If transaction is already aborted on the main thread for suspension,</span>
<span class="line-added">+     // return the result of that abort.</span>
<span class="line-added">+     if (auto existingAbortResult = takenTransaction-&gt;mainThreadAbortResult()) {</span>
<span class="line-added">+         callback(*existingAbortResult);</span>
<span class="line-added">+         transactionCompleted(WTFMove(takenTransaction));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-added">+     auto transactionIdentifier = transaction.info().identifier();</span>
      if (m_versionChangeTransaction &amp;&amp; m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier) {
<span class="line-modified">!         ASSERT(m_versionChangeTransaction == &amp;transaction);</span>
          ASSERT(!m_versionChangeDatabaseConnection || &amp;m_versionChangeTransaction-&gt;databaseConnection() == m_versionChangeDatabaseConnection);
          ASSERT(m_versionChangeTransaction-&gt;originalDatabaseInfo());
          m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(*m_versionChangeTransaction-&gt;originalDatabaseInfo());
      }
  
<span class="line-modified">!     auto error = m_backingStore-&gt;abortTransaction(transactionIdentifier);</span>
  
<span class="line-modified">!     callback(error);</span>
<span class="line-added">+     transactionCompleted(WTFMove(takenTransaction));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::didFinishHandlingVersionChange(UniqueIDBDatabaseConnection&amp; connection, const IDBResourceIdentifier&amp; transactionIdentifier)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::didFinishHandlingVersionChange&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT_UNUSED(transactionIdentifier, !m_versionChangeTransaction || m_versionChangeTransaction-&gt;info().identifier() == transactionIdentifier);</span>
<span class="line-added">+     ASSERT_UNUSED(connection, !m_versionChangeDatabaseConnection || m_versionChangeDatabaseConnection.get() == &amp;connection);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_versionChangeTransaction = nullptr;</span>
<span class="line-added">+     m_versionChangeDatabaseConnection = nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     handleDatabaseOperations();</span>
<span class="line-added">+     handleTransactions();</span>
  }
  
  void UniqueIDBDatabase::connectionClosedFromClient(UniqueIDBDatabaseConnection&amp; connection)
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromClient - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());</span>
  
      Ref&lt;UniqueIDBDatabaseConnection&gt; protectedConnection(connection);
      m_openDatabaseConnections.remove(&amp;connection);
  
      if (m_versionChangeDatabaseConnection == &amp;connection) {
<span class="line-added">+         m_versionChangeDatabaseConnection = nullptr;</span>
          if (m_versionChangeTransaction) {
<span class="line-modified">!             connection.abortTransactionWithoutCallback(*m_versionChangeTransaction);</span>
<span class="line-added">+             ASSERT(!connection.hasNonFinishedTransactions());</span>
  
<span class="line-modified">!             // Previous blocked operations or transactions may be runnable.</span>
<span class="line-modified">!             handleDatabaseOperations();</span>
<span class="line-modified">!             handleTransactions();</span>
  
              return;
          }
      }
  
<span class="line-modified">!     // Remove all pending transactions on the connection.</span>
<span class="line-modified">!     clearTransactionsOnConnection(connection);</span>
  
      if (m_currentOpenDBRequest)
          notifyCurrentRequestConnectionClosedOrFiredVersionChangeEvent(connection.identifier());
  
<span class="line-modified">!     ASSERT(!connection.hasNonFinishedTransactions());</span>
  
      // Now that a database connection has closed, previously blocked operations might be runnable.
<span class="line-modified">!     handleDatabaseOperations();</span>
<span class="line-added">+     handleTransactions();</span>
  }
  
  void UniqueIDBDatabase::connectionClosedFromServer(UniqueIDBDatabaseConnection&amp; connection)
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
      LOG(IndexedDB, &quot;UniqueIDBDatabase::connectionClosedFromServer - %s (%&quot; PRIu64 &quot;)&quot;, connection.openRequestIdentifier().loggingString().utf8().data(), connection.identifier());
  
      connection.connectionToClient().didCloseFromServer(connection, IDBError::userDeleteError());
  
<span class="line-modified">!     m_openDatabaseConnections.remove(&amp;connection);</span>
  }
  
  void UniqueIDBDatabase::enqueueTransaction(Ref&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
  {
      LOG(IndexedDB, &quot;UniqueIDBDatabase::enqueueTransaction - %s&quot;, transaction-&gt;info().loggingString().utf8().data());
  
      ASSERT(transaction-&gt;info().mode() != IDBTransactionMode::Versionchange);
  
      m_pendingTransactions.append(WTFMove(transaction));
  
<span class="line-modified">!     handleTransactions();</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::handleTransactions()</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleTransactions - There are %zu pending&quot;, m_pendingTransactions.size());</span>
  
      bool hadDeferredTransactions = false;
      auto transaction = takeNextRunnableTransaction(hadDeferredTransactions);
  
<span class="line-modified">!     while (transaction) {</span>
          m_inProgressTransactions.set(transaction-&gt;info().identifier(), transaction);
          for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
              m_objectStoreTransactionCounts.add(objectStore);
              if (!transaction-&gt;isReadOnly()) {
                  m_objectStoreWriteTransactions.add(objectStore);
<span class="line-modified">!                 ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1);</span>
              }
          }
  
          activateTransactionInBackingStore(*transaction);
<span class="line-modified">!         if (hadDeferredTransactions)</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         transaction = takeNextRunnableTransaction(hadDeferredTransactions);</span>
      }
<span class="line-added">+     LOG(IndexedDB, &quot;UniqueIDBDatabase::handleTransactions - There are %zu pending after this round of handling&quot;, m_pendingTransactions.size());</span>
  }
  
  void UniqueIDBDatabase::activateTransactionInBackingStore(UniqueIDBDatabaseTransaction&amp; transaction)
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::activateTransactionInBackingStore&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_backingStore);</span>
  
<span class="line-modified">!     auto error = m_backingStore-&gt;beginTransaction(transaction.info());</span>
  
<span class="line-modified">!     transaction.didActivateInBackingStore(error);</span>
  }
  
  template&lt;typename T&gt; bool scopesOverlap(const T&amp; aScopes, const Vector&lt;uint64_t&gt;&amp; bScopes)
  {
      for (auto scope : bScopes) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2028,11 ***</span>
      hadDeferredTransactions = false;
  
      if (m_pendingTransactions.isEmpty())
          return nullptr;
  
<span class="line-modified">!     if (!m_backingStoreSupportsSimultaneousTransactions &amp;&amp; hasUnfinishedTransactions()) {</span>
          LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
          return nullptr;
      }
  
      Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
<span class="line-new-header">--- 1038,11 ---</span>
      hadDeferredTransactions = false;
  
      if (m_pendingTransactions.isEmpty())
          return nullptr;
  
<span class="line-modified">!     if (!m_backingStore-&gt;supportsSimultaneousTransactions() &amp;&amp; !m_inProgressTransactions.isEmpty()) {</span>
          LOG(IndexedDB, &quot;UniqueIDBDatabase::takeNextRunnableTransaction - Backing store only supports 1 transaction, and we already have 1&quot;);
          return nullptr;
      }
  
      Deque&lt;RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&gt; deferredTransactions;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2088,99 ***</span>
  
  void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
  {
      ASSERT(transaction);
      ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
<span class="line-modified">!     ASSERT(!m_finishingTransactions.contains(transaction-&gt;info().identifier()));</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
  
      for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
          if (!transaction-&gt;isReadOnly()) {
              m_objectStoreWriteTransactions.remove(objectStore);
<span class="line-modified">!             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1 || m_hardClosedForUserDelete);</span>
          }
          m_objectStoreTransactionCounts.remove(objectStore);
      }
  
<span class="line-removed">-     if (!transaction-&gt;databaseConnection().hasNonFinishedTransactions())</span>
<span class="line-removed">-         m_clientClosePendingDatabaseConnections.remove(&amp;transaction-&gt;databaseConnection());</span>
<span class="line-removed">- </span>
      if (m_versionChangeTransaction == transaction)
          m_versionChangeTransaction = nullptr;
  
<span class="line-removed">-     // It&#39;s possible that this database had its backing store deleted but there were a few outstanding asynchronous operations.</span>
<span class="line-removed">-     // If this transaction completing was the last of those operations, we can finally delete this UniqueIDBDatabase.</span>
<span class="line-removed">-     if (m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_pendingOpenDBRequests.isEmpty() &amp;&amp; !m_databaseInfo) {</span>
<span class="line-removed">-         scheduleShutdownForClose();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // Previously blocked operations might be runnable.
<span class="line-modified">!     if (!m_hardClosedForUserDelete)</span>
<span class="line-modified">!         invokeOperationAndTransactionTimer();</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         maybeFinishHardClose();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::postDatabaseTask(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_databaseQueue.append(WTFMove(task));</span>
<span class="line-removed">-     m_server-&gt;postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTask));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_backingStore)</span>
<span class="line-removed">-         m_newDatabaseSize = m_backingStore-&gt;databaseSize();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_databaseReplyQueue.append(WTFMove(task));</span>
<span class="line-removed">-     m_server-&gt;postDatabaseTaskReply(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::executeNextDatabaseTaskReply));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::executeNextDatabaseTask()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     ASSERT(!m_databaseQueue.isKilled());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto task = m_databaseQueue.tryGetMessage();</span>
<span class="line-removed">-     ASSERT(task);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     task-&gt;performTask();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::executeNextDatabaseTaskReply()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     ASSERT(!m_databaseReplyQueue.isKilled());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto task = m_databaseReplyQueue.tryGetMessage();</span>
<span class="line-removed">-     ASSERT(task);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     task-&gt;performTask();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If this database was force closed (e.g. for a user delete) and there are no more</span>
<span class="line-removed">-     // cleanup tasks left, delete this.</span>
<span class="line-removed">-     maybeFinishHardClose();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::maybeFinishHardClose()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_owningPointerForClose &amp;&amp; isDoneWithHardClose()) {</span>
<span class="line-removed">-         if (m_owningPointerReleaseScheduled)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         m_owningPointerReleaseScheduled = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         callOnMainThread([this] {</span>
<span class="line-removed">-             ASSERT(isDoneWithHardClose());</span>
<span class="line-removed">-             m_owningPointerForClose = nullptr;</span>
<span class="line-removed">-         });</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool UniqueIDBDatabase::isDoneWithHardClose()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_databaseReplyQueue.isKilled() &amp;&amp; m_clientClosePendingDatabaseConnections.isEmpty() &amp;&amp; m_serverClosePendingDatabaseConnections.isEmpty();</span>
  }
  
  static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
  {
      auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
<span class="line-new-header">--- 1098,26 ---</span>
  
  void UniqueIDBDatabase::transactionCompleted(RefPtr&lt;UniqueIDBDatabaseTransaction&gt;&amp;&amp; transaction)
  {
      ASSERT(transaction);
      ASSERT(!m_inProgressTransactions.contains(transaction-&gt;info().identifier()));
<span class="line-modified">!     ASSERT(!isMainThread());</span>
  
      for (auto objectStore : transaction-&gt;objectStoreIdentifiers()) {
          if (!transaction-&gt;isReadOnly()) {
              m_objectStoreWriteTransactions.remove(objectStore);
<span class="line-modified">!             ASSERT(m_objectStoreTransactionCounts.count(objectStore) == 1);</span>
          }
          m_objectStoreTransactionCounts.remove(objectStore);
      }
  
      if (m_versionChangeTransaction == transaction)
          m_versionChangeTransaction = nullptr;
  
      // Previously blocked operations might be runnable.
<span class="line-modified">!     handleDatabaseOperations();</span>
<span class="line-modified">!     handleTransactions();</span>
  }
  
  static void errorOpenDBRequestForUserDelete(ServerOpenDBRequest&amp; request)
  {
      auto result = IDBResultData::error(request.requestData().requestIdentifier(), IDBError::userDeleteError());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2190,51 ***</span>
          request.connection().didDeleteDatabase(result);
  }
  
  void UniqueIDBDatabase::immediateCloseForUserDelete()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete - Cancelling (%i, %i, %i, %i) callbacks&quot;, m_errorCallbacks.size(), m_keyDataCallbacks.size(), m_getResultCallbacks.size(), m_countCallbacks.size());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
  
<span class="line-modified">!     m_pendingSpaceIncreasingTasks.clear();</span>
<span class="line-modified">!     m_server-&gt;resetSpaceUsed(m_identifier.origin());</span>
  
<span class="line-removed">-     // Error out all transactions</span>
      for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
          m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
  
      ASSERT(m_inProgressTransactions.isEmpty());
  
<span class="line-removed">-     for (auto&amp; transaction : m_pendingTransactions)</span>
<span class="line-removed">-         transaction-&gt;databaseConnection().deleteTransaction(*transaction);</span>
<span class="line-removed">-     m_pendingTransactions.clear();</span>
      m_objectStoreTransactionCounts.clear();
      m_objectStoreWriteTransactions.clear();
  
<span class="line-removed">-     // Error out all pending callbacks</span>
<span class="line-removed">-     IDBError error = IDBError::userDeleteError();</span>
<span class="line-removed">-     IDBKeyData keyData;</span>
<span class="line-removed">-     IDBGetResult getResult;</span>
<span class="line-removed">-     IDBGetAllResult getAllResult;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while (!m_callbackQueue.isEmpty()) {</span>
<span class="line-removed">-         auto identifier = m_callbackQueue.first();</span>
<span class="line-removed">-         if (m_errorCallbacks.contains(identifier))</span>
<span class="line-removed">-             performErrorCallback(identifier, error);</span>
<span class="line-removed">-         else if (m_keyDataCallbacks.contains(identifier))</span>
<span class="line-removed">-             performKeyDataCallback(identifier, error, keyData);</span>
<span class="line-removed">-         else if (m_getResultCallbacks.contains(identifier))</span>
<span class="line-removed">-             performGetResultCallback(identifier, error, getResult);</span>
<span class="line-removed">-         else if (m_countCallbacks.contains(identifier))</span>
<span class="line-removed">-             performCountCallback(identifier, error, 0);</span>
<span class="line-removed">-         else if (m_getAllResultsCallbacks.contains(identifier))</span>
<span class="line-removed">-             performGetAllResultsCallback(identifier, error, getAllResult);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // Error out all IDBOpenDBRequests
      if (m_currentOpenDBRequest) {
          errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
          m_currentOpenDBRequest = nullptr;
      }
<span class="line-new-header">--- 1127,27 ---</span>
          request.connection().didDeleteDatabase(result);
  }
  
  void UniqueIDBDatabase::immediateCloseForUserDelete()
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::immediateCloseForUserDelete&quot;);</span>
  
<span class="line-modified">!     // Error out all transactions.</span>
<span class="line-modified">!     // Pending transactions must be cleared before in-progress transactions,</span>
<span class="line-added">+     // or they may get started right away after aborting in-progress transactions.</span>
<span class="line-added">+     for (auto&amp; transaction : m_pendingTransactions)</span>
<span class="line-added">+         transaction-&gt;databaseConnection().deleteTransaction(*transaction);</span>
<span class="line-added">+     m_pendingTransactions.clear();</span>
  
      for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys()))
          m_inProgressTransactions.get(identifier)-&gt;abortWithoutCallback();
  
      ASSERT(m_inProgressTransactions.isEmpty());
  
      m_objectStoreTransactionCounts.clear();
      m_objectStoreWriteTransactions.clear();
  
      // Error out all IDBOpenDBRequests
      if (m_currentOpenDBRequest) {
          errorOpenDBRequestForUserDelete(*m_currentOpenDBRequest);
          m_currentOpenDBRequest = nullptr;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2252,160 ***</span>
      if (m_versionChangeDatabaseConnection) {
          connectionClosedFromServer(*m_versionChangeDatabaseConnection);
          m_versionChangeDatabaseConnection = nullptr;
      }
  
<span class="line-modified">!     // Cancel the operation timer</span>
<span class="line-removed">-     m_operationAndTransactionTimer.stop();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Set up the database to remain alive-but-inert until all of its background activity finishes and all</span>
<span class="line-removed">-     // database connections confirm that they have closed.</span>
<span class="line-removed">-     m_hardClosedForUserDelete = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If this database already owns itself, it is already closing on the background thread.</span>
<span class="line-removed">-     // After that close completes, the next database thread task will be &quot;delete all currently closed databases&quot;</span>
<span class="line-removed">-     // which will also cover this database.</span>
<span class="line-removed">-     if (m_owningPointerForClose)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     // Otherwise, this database is still potentially active.</span>
<span class="line-removed">-     // So we&#39;ll have it own itself and then perform a clean unconditional delete on the background thread.</span>
<span class="line-removed">-     m_owningPointerForClose = m_server-&gt;closeAndTakeUniqueIDBDatabase(*this);</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;UniqueIDBDatabase::performUnconditionalDeleteBackingStore));</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::updateSpaceUsedIfNeeded(Optional&lt;uint64_t&gt; optionalCallbackIdentifier)</span>
  {
      ASSERT(isMainThread());
  
<span class="line-modified">!     if (optionalCallbackIdentifier) {</span>
<span class="line-modified">!         uint64_t callbackIdentifier = optionalCallbackIdentifier.value();</span>
<span class="line-modified">!         auto iterator = m_pendingSpaceIncreasingTasks.find(callbackIdentifier);</span>
<span class="line-removed">-         if (iterator != m_pendingSpaceIncreasingTasks.end()) {</span>
<span class="line-removed">-             m_server-&gt;decreasePotentialSpaceUsed(m_identifier.origin(), iterator-&gt;value);</span>
<span class="line-removed">-             m_pendingSpaceIncreasingTasks.remove(iterator);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint64_t databaseSize = m_newDatabaseSize;</span>
<span class="line-removed">-     if (databaseSize != m_currentDatabaseSize) {</span>
<span class="line-removed">-         if (databaseSize &gt; m_currentDatabaseSize)</span>
<span class="line-removed">-             m_server-&gt;increaseSpaceUsed(m_identifier.origin(), databaseSize - m_currentDatabaseSize);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             m_server-&gt;decreaseSpaceUsed(m_identifier.origin(), m_currentDatabaseSize - databaseSize);</span>
<span class="line-removed">-         m_currentDatabaseSize = databaseSize;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performErrorCallback(uint64_t callbackIdentifier, const IDBError&amp; error)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto callback = m_errorCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">-     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">-     if (callback) {</span>
<span class="line-removed">-         callback(error);</span>
<span class="line-removed">-         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">-         m_callbackQueue.removeFirst();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performKeyDataCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBKeyData&amp; resultKey)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto callback = m_keyDataCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">-     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">-     if (callback) {</span>
<span class="line-removed">-         callback(error, resultKey);</span>
<span class="line-removed">-         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">-         m_callbackQueue.removeFirst();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::performGetResultCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetResult&amp; resultData)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto callback = m_getResultCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">-     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">-     if (callback) {</span>
<span class="line-removed">-         callback(error, resultData);</span>
<span class="line-removed">-         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">-         m_callbackQueue.removeFirst();</span>
      }
  }
  
<span class="line-modified">! void UniqueIDBDatabase::performGetAllResultsCallback(uint64_t callbackIdentifier, const IDBError&amp; error, const IDBGetAllResult&amp; resultData)</span>
  {
<span class="line-modified">!     auto callback = m_getAllResultsCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">-     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">-     if (callback) {</span>
<span class="line-removed">-         callback(error, resultData);</span>
<span class="line-removed">-         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">-         m_callbackQueue.removeFirst();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void UniqueIDBDatabase::performCountCallback(uint64_t callbackIdentifier, const IDBError&amp; error, uint64_t count)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     auto callback = m_countCallbacks.take(callbackIdentifier);</span>
<span class="line-removed">-     ASSERT(callback || m_hardClosedForUserDelete);</span>
<span class="line-removed">-     if (callback) {</span>
<span class="line-removed">-         callback(error, count);</span>
<span class="line-removed">-         ASSERT(m_callbackQueue.first() == callbackIdentifier);</span>
<span class="line-removed">-         m_callbackQueue.removeFirst();</span>
      }
  }
  
<span class="line-modified">! void UniqueIDBDatabase::forgetErrorCallback(uint64_t callbackIdentifier)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     updateSpaceUsedIfNeeded(callbackIdentifier);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(m_errorCallbacks.contains(callbackIdentifier));</span>
<span class="line-removed">-     ASSERT(m_callbackQueue.last() == callbackIdentifier);</span>
<span class="line-removed">-     m_callbackQueue.removeLast();</span>
<span class="line-removed">-     m_errorCallbacks.remove(callbackIdentifier);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::abortTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
  {
<span class="line-modified">!     transaction.setResult(m_backingStore-&gt;abortTransaction(transaction.info().identifier()));</span>
<span class="line-modified">!     transaction.setState(UniqueIDBDatabaseTransaction::State::Aborted);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::commitTransactionOnMainThread(UniqueIDBDatabaseTransaction&amp; transaction)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     transaction.setResult(m_backingStore-&gt;commitTransaction(transaction.info().identifier()));</span>
<span class="line-removed">-     transaction.setState(UniqueIDBDatabaseTransaction::State::Committed);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void UniqueIDBDatabase::finishActiveTransactions()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
  
<span class="line-modified">!     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {</span>
<span class="line-modified">!         auto transaction = m_inProgressTransactions.get(identifier);</span>
<span class="line-modified">!         abortTransactionOnMainThread(*transaction);</span>
      }
  
<span class="line-modified">!     for (auto&amp; identifier : copyToVector(m_finishingTransactions.keys())) {</span>
<span class="line-removed">-         if (!m_backingStore-&gt;hasTransaction(identifier))</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto transaction = m_finishingTransactions.get(identifier);</span>
<span class="line-removed">-         switch (transaction-&gt;state()) {</span>
<span class="line-removed">-         case UniqueIDBDatabaseTransaction::State::Aborting:</span>
<span class="line-removed">-             abortTransactionOnMainThread(*transaction);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case UniqueIDBDatabaseTransaction::State::Committing:</span>
<span class="line-removed">-             commitTransactionOnMainThread(*transaction);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case UniqueIDBDatabaseTransaction::State::Running:</span>
<span class="line-removed">-         case UniqueIDBDatabaseTransaction::State::Aborted:</span>
<span class="line-removed">-         case UniqueIDBDatabaseTransaction::State::Committed:</span>
<span class="line-removed">-             ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  }
  
  } // namespace IDBServer
  } // namespace WebCore
  
<span class="line-new-header">--- 1165,48 ---</span>
      if (m_versionChangeDatabaseConnection) {
          connectionClosedFromServer(*m_versionChangeDatabaseConnection);
          m_versionChangeDatabaseConnection = nullptr;
      }
  
<span class="line-modified">!     ASSERT(!hasAnyOpenConnections());</span>
  
<span class="line-modified">!     close();</span>
  }
  
<span class="line-modified">! void UniqueIDBDatabase::abortActiveTransactions()</span>
  {
      ASSERT(isMainThread());
<span class="line-added">+     ASSERT(m_server.lock().isHeld());</span>
  
<span class="line-modified">!     for (auto&amp; identifier : copyToVector(m_inProgressTransactions.keys())) {</span>
<span class="line-modified">!         auto transaction = m_inProgressTransactions.get(identifier);</span>
<span class="line-modified">!         transaction-&gt;setMainThreadAbortResult(m_backingStore-&gt;abortTransaction(transaction-&gt;info().identifier()));</span>
      }
  }
  
<span class="line-modified">! void UniqueIDBDatabase::close()</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;UniqueIDBDatabase::close&quot;);</span>
  
<span class="line-modified">!     if (m_backingStore) {</span>
<span class="line-modified">!         m_backingStore-&gt;close();</span>
<span class="line-modified">!         m_backingStore = nullptr;</span>
      }
  }
  
<span class="line-modified">! RefPtr&lt;ServerOpenDBRequest&gt; UniqueIDBDatabase::takeNextRunnableRequest(RequestType requestType)</span>
  {
<span class="line-modified">!     // Connection of request may be closed or lost.</span>
<span class="line-modified">!     clearStalePendingOpenDBRequests();</span>
  
<span class="line-modified">!     if (!m_pendingOpenDBRequests.isEmpty()) {</span>
<span class="line-modified">!         if (requestType == RequestType::Delete &amp;&amp; !m_pendingOpenDBRequests.first()-&gt;isDeleteRequest())</span>
<span class="line-modified">!             return nullptr;</span>
<span class="line-added">+         return m_pendingOpenDBRequests.takeFirst();</span>
      }
  
<span class="line-modified">!     return nullptr;</span>
  }
  
  } // namespace IDBServer
  } // namespace WebCore
  
</pre>
<center><a href="SQLiteIDBTransaction.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="UniqueIDBDatabase.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
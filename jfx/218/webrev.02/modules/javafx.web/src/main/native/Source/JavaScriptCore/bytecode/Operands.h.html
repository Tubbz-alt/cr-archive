<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Operands.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;VirtualRegister.h&quot;
 30 
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace JSC {
 35 
 36 template&lt;typename T&gt; struct OperandValueTraits;
 37 
 38 constexpr unsigned maxNumCheckpointTmps = 4;
 39 
 40 // A OperandKind::Tmp is one that exists for exiting to a checkpoint but does not exist between bytecodes.
 41 enum class OperandKind : uint32_t { Argument, Local, Tmp }; // Keep bit-width in sync with Operand::operandKindBits&#39; definition.
 42 static constexpr OperandKind lastOperandKind = OperandKind::Tmp;
 43 
 44 class Operand {
 45 public:
 46     static constexpr unsigned kindBits = WTF::getMSBSetConstexpr(static_cast&lt;std::underlying_type_t&lt;OperandKind&gt;&gt;(lastOperandKind)) + 1;
 47     static constexpr unsigned maxBits = 32 + kindBits;
 48     static_assert(maxBits == 34);
 49 
 50     Operand() = default;
 51     Operand(const Operand&amp;) = default;
 52 
 53     Operand(VirtualRegister operand)
 54         : Operand(operand.isLocal() ? OperandKind::Local : OperandKind::Argument, operand.offset())
 55     { }
 56 
 57     Operand(OperandKind kind, int operand)
 58 #if CPU(LITTLE_ENDIAN)
 59         : m_operand(operand)
 60         , m_kind(kind)
 61 #else
 62         : m_kind(kind)
 63         , m_operand(operand)
 64 #endif
 65     {
 66         ASSERT(kind == OperandKind::Tmp || VirtualRegister(operand).isLocal() == (kind == OperandKind::Local));
 67     }
 68     static Operand tmp(uint32_t index) { return Operand(OperandKind::Tmp, index); }
 69 
 70     OperandKind kind() const { return m_kind; }
 71     int value() const { return m_operand; }
 72     VirtualRegister virtualRegister() const
 73     {
 74         ASSERT(m_kind != OperandKind::Tmp);
 75         return VirtualRegister(m_operand);
 76     }
 77     uint64_t asBits() const
 78     {
 79         uint64_t bits = bitwise_cast&lt;uint64_t&gt;(*this);
 80         ASSERT(bits &lt; (1ULL &lt;&lt; maxBits));
 81         return bits;
 82     }
 83     static Operand fromBits(uint64_t value);
 84 
 85     bool isTmp() const { return kind() == OperandKind::Tmp; }
 86     bool isArgument() const { return kind() == OperandKind::Argument; }
 87     bool isLocal() const { return kind() == OperandKind::Local &amp;&amp; virtualRegister().isLocal(); }
 88     bool isHeader() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isHeader(); }
 89     bool isConstant() const { return kind() != OperandKind::Tmp &amp;&amp; virtualRegister().isConstant(); }
 90 
 91     int toArgument() const { ASSERT(isArgument()); return virtualRegister().toArgument(); }
 92     int toLocal() const { ASSERT(isLocal()); return virtualRegister().toLocal(); }
 93 
 94     inline bool isValid() const;
 95 
 96     inline bool operator==(const Operand&amp;) const;
 97 
 98     void dump(PrintStream&amp;) const;
 99 
100 private:
101 #if CPU(LITTLE_ENDIAN)
102     int m_operand { VirtualRegister::invalidVirtualRegister };
103     OperandKind m_kind { OperandKind::Argument };
104 #else
105     OperandKind m_kind { OperandKind::Argument };
106     int m_operand { VirtualRegister::invalidVirtualRegister };
107 #endif
108 };
109 
110 ALWAYS_INLINE bool Operand::operator==(const Operand&amp; other) const
111 {
112     if (kind() != other.kind())
113         return false;
114     if (isTmp())
115         return value() == other.value();
116     return virtualRegister() == other.virtualRegister();
117 }
118 
119 inline bool Operand::isValid() const
120 {
121     if (isTmp())
122         return value() &gt;= 0;
123     return virtualRegister().isValid();
124 }
125 
126 inline Operand Operand::fromBits(uint64_t value)
127 {
128     Operand result = bitwise_cast&lt;Operand&gt;(value);
129     ASSERT(result.isValid());
130     return result;
131 }
132 
133 static_assert(sizeof(Operand) == sizeof(uint64_t), &quot;Operand::asBits() relies on this.&quot;);
134 
135 enum OperandsLikeTag { OperandsLike };
136 
137 template&lt;typename T&gt;
138 class Operands {
139 public:
140     using Storage = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitVector, Vector&lt;T, 0, UnsafeVectorOverflow&gt;&gt;;
141     using RefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, FastBitReference, T&amp;&gt;;
142     using ConstRefType = std::conditional_t&lt;std::is_same_v&lt;T, bool&gt;, bool, const T&amp;&gt;;
143 
144     Operands() = default;
145 
146     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps)
147         : m_numArguments(numArguments)
148         , m_numLocals(numLocals)
149     {
150         size_t size = numArguments + numLocals + numTmps;
151         m_values.grow(size);
152         if (!WTF::VectorTraits&lt;T&gt;::needsInitialization)
153             m_values.fill(T());
154     }
155 
156     explicit Operands(size_t numArguments, size_t numLocals, size_t numTmps, const T&amp; initialValue)
157         : m_numArguments(numArguments)
158         , m_numLocals(numLocals)
159     {
160         m_values.grow(numArguments + numLocals + numTmps);
161         m_values.fill(initialValue);
162     }
163 
164     template&lt;typename U&gt;
165     explicit Operands(OperandsLikeTag, const Operands&lt;U&gt;&amp; other, const T&amp; initialValue = T())
166         : m_numArguments(other.numberOfArguments())
167         , m_numLocals(other.numberOfLocals())
168     {
169         m_values.grow(other.size());
170         m_values.fill(initialValue);
171     }
172 
173     size_t numberOfArguments() const { return m_numArguments; }
174     size_t numberOfLocals() const { return m_numLocals; }
175     size_t numberOfTmps() const { return m_values.size() - numberOfArguments() - numberOfLocals(); }
176 
177     size_t tmpIndex(size_t idx) const
178     {
179         ASSERT(idx &lt; numberOfTmps());
180         return idx + numberOfArguments() + numberOfLocals();
181     }
182     size_t argumentIndex(size_t idx) const
183     {
184         ASSERT(idx &lt; numberOfArguments());
185         return idx;
186     }
187 
188     size_t localIndex(size_t idx) const
189     {
190         ASSERT(idx &lt; numberOfLocals());
191         return numberOfArguments() + idx;
192     }
193 
194     RefType tmp(size_t idx) { return m_values[tmpIndex(idx)]; }
195     ConstRefType tmp(size_t idx) const { return m_values[tmpIndex(idx)]; }
196 
197     RefType argument(size_t idx) { return m_values[argumentIndex(idx)]; }
198     ConstRefType argument(size_t idx) const { return m_values[argumentIndex(idx)]; }
199 
200     RefType local(size_t idx) { return m_values[localIndex(idx)]; }
201     ConstRefType local(size_t idx) const { return m_values[localIndex(idx)]; }
202 
203     template&lt;OperandKind operandKind&gt;
204     size_t sizeFor() const
205     {
206         switch (operandKind) {
207         case OperandKind::Tmp:
208             return numberOfTmps();
209         case OperandKind::Argument:
210             return numberOfArguments();
211         case OperandKind::Local:
212             return numberOfLocals();
213         }
214         RELEASE_ASSERT_NOT_REACHED();
215         return 0;
216     }
217     template&lt;OperandKind operandKind&gt;
218     RefType atFor(size_t idx)
219     {
220         switch (operandKind) {
221         case OperandKind::Tmp:
222             return tmp(idx);
223         case OperandKind::Argument:
224             return argument(idx);
225         case OperandKind::Local:
226             return local(idx);
227         }
228         RELEASE_ASSERT_NOT_REACHED();
229         return tmp(0);
230     }
231     template&lt;OperandKind operandKind&gt;
232     ConstRefType atFor(size_t idx) const
233     {
234         switch (operandKind) {
235         case OperandKind::Tmp:
236             return tmp(idx);
237         case OperandKind::Argument:
238             return argument(idx);
239         case OperandKind::Local:
240             return local(idx);
241         }
242         RELEASE_ASSERT_NOT_REACHED();
243         return tmp(0);
244     }
245 
246     void ensureLocals(size_t size, const T&amp; ensuredValue = T())
247     {
248         if (size &lt;= numberOfLocals())
249             return;
250 
251         size_t newSize = numberOfArguments() + numberOfTmps() + size;
252         size_t oldNumLocals = numberOfLocals();
253         size_t oldNumTmps = numberOfTmps();
254         m_values.grow(newSize);
255         for (size_t i = 0; i &lt; oldNumTmps; ++i)
256             m_values[newSize - 1 - i] = m_values[tmpIndex(oldNumTmps - 1 - i)];
257 
258         m_numLocals = size;
259         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {
260             for (size_t i = 0; i &lt; size - oldNumLocals; ++i)
261                 m_values[localIndex(oldNumLocals + i)] = ensuredValue;
262         }
263     }
264 
265     void ensureTmps(size_t size, const T&amp; ensuredValue = T())
266     {
267         if (size &lt;= numberOfTmps())
268             return;
269 
270         size_t oldSize = m_values.size();
271         size_t newSize = numberOfArguments() + numberOfLocals() + size;
272         m_values.grow(newSize);
273 
274         if (ensuredValue != T() || !WTF::VectorTraits&lt;T&gt;::needsInitialization) {
275             for (size_t i = oldSize; i &lt; newSize; ++i)
276                 m_values[i] = ensuredValue;
277         }
278     }
279 
280     void setLocal(size_t idx, const T&amp; value)
281     {
282         ensureLocals(idx + 1);
283         local(idx) = value;
284     }
285 
286     T getLocal(size_t idx)
287     {
288         return idx &gt;= numberOfLocals() ? T() : local(idx);
289     }
290 
291     void setArgumentFirstTime(size_t idx, const T&amp; value)
292     {
293         ASSERT(m_values[idx] == T());
294         argument(idx) = value;
295     }
296 
297     void setLocalFirstTime(size_t idx, const T&amp; value)
298     {
299         ASSERT(idx &gt;= numberOfLocals() || local(idx) == T());
300         setLocal(idx, value);
301     }
302 
303     RefType getForOperandIndex(size_t index) { return m_values[index]; }
304     ConstRefType getForOperandIndex(size_t index) const { return const_cast&lt;Operands*&gt;(this)-&gt;getForOperandIndex(index); }
305 
306     size_t operandIndex(VirtualRegister operand) const
307     {
308         if (operand.isArgument())
309             return argumentIndex(operand.toArgument());
310         return localIndex(operand.toLocal());
311     }
312 
313     size_t operandIndex(Operand op) const
314     {
315         if (!op.isTmp())
316             return operandIndex(op.virtualRegister());
317         return tmpIndex(op.value());
318     }
319 
320     RefType operand(VirtualRegister operand)
321     {
322         if (operand.isArgument())
323             return argument(operand.toArgument());
324         return local(operand.toLocal());
325     }
326 
327     RefType operand(Operand op)
328     {
329         if (!op.isTmp())
330             return operand(op.virtualRegister());
331         return tmp(op.value());
332     }
333 
334     ConstRefType operand(VirtualRegister operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }
335     ConstRefType operand(Operand operand) const { return const_cast&lt;Operands*&gt;(this)-&gt;operand(operand); }
336 
337     bool hasOperand(VirtualRegister operand) const
338     {
339         if (operand.isArgument())
340             return true;
341         return static_cast&lt;size_t&gt;(operand.toLocal()) &lt; numberOfLocals();
342     }
343     bool hasOperand(Operand op) const
344     {
345         if (op.isTmp()) {
346             ASSERT(op.value() &gt;= 0);
347             return static_cast&lt;size_t&gt;(op.value()) &lt; numberOfTmps();
348         }
349         return hasOperand(op.virtualRegister());
350     }
351 
352     void setOperand(Operand operand, const T&amp; value)
353     {
354         this-&gt;operand(operand) = value;
355     }
356 
357     size_t size() const { return m_values.size(); }
358     ConstRefType at(size_t index) const { return m_values[index]; }
359     RefType at(size_t index) { return m_values[index]; }
360     ConstRefType operator[](size_t index) const { return at(index); }
361     RefType operator[](size_t index) { return at(index); }
362 
363     Operand operandForIndex(size_t index) const
364     {
365         if (index &lt; numberOfArguments())
366             return virtualRegisterForArgumentIncludingThis(index);
367         else if (index &lt; numberOfLocals() + numberOfArguments())
368             return virtualRegisterForLocal(index - numberOfArguments());
369         return Operand::tmp(index - (numberOfLocals() + numberOfArguments()));
370     }
371 
372     void fill(T value)
373     {
374         for (size_t i = 0; i &lt; m_values.size(); ++i)
375             m_values[i] = value;
376     }
377 
378     void clear()
379     {
380         fill(T());
381     }
382 
383     bool operator==(const Operands&amp; other) const
384     {
385         ASSERT(numberOfArguments() == other.numberOfArguments());
386         ASSERT(numberOfLocals() == other.numberOfLocals());
387         ASSERT(numberOfTmps() == other.numberOfTmps());
388 
389         return m_values == other.m_values;
390     }
391 
392     void dumpInContext(PrintStream&amp; out, DumpContext* context) const;
393     void dump(PrintStream&amp; out) const;
394 
395 private:
396     // The first m_numArguments of m_values are arguments, the next m_numLocals are locals, and the rest are tmps.
397     Storage m_values;
398     unsigned m_numArguments { 0 };
399     unsigned m_numLocals { 0 };
400 };
401 
402 } // namespace JSC
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBackwardsPropagationPhase.cpp
@@ -126,11 +126,12 @@
         case ValueBitLShift:
         case ArithBitLShift: {
             return power > 31;
         }
 
-        case BitRShift:
+        case ArithBitRShift:
+        case ValueBitRShift:
         case BitURShift: {
             if (power > 31)
                 return true;
 
             Node* shiftAmount = node->child2().node();
@@ -224,24 +225,27 @@
         case ArithBitOr:
         case ArithBitXor:
         case ValueBitAnd:
         case ValueBitOr:
         case ValueBitXor:
-        case BitRShift:
         case ValueBitLShift:
         case ArithBitLShift:
+        case ArithBitRShift:
+        case ValueBitRShift:
         case BitURShift:
         case ArithIMul: {
             flags |= NodeBytecodeUsesAsInt;
             flags &= ~(NodeBytecodeUsesAsNumber | NodeBytecodeNeedsNegZero | NodeBytecodeUsesAsOther);
             flags &= ~NodeBytecodeUsesAsArrayIndex;
             node->child1()->mergeFlags(flags);
             node->child2()->mergeFlags(flags);
             break;
         }
 
-        case StringCharCodeAt: {
+        case StringCharAt:
+        case StringCharCodeAt:
+        case StringCodePointAt: {
             node->child1()->mergeFlags(NodeBytecodeUsesAsValue);
             node->child2()->mergeFlags(NodeBytecodeUsesAsValue | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
             break;
         }
 
@@ -330,10 +334,23 @@
 
             node->child1()->mergeFlags(flags);
             break;
         }
 
+        case Inc:
+        case Dec: {
+            flags &= ~NodeBytecodeNeedsNegZero;
+            flags &= ~NodeBytecodeUsesAsOther;
+            if (!isWithinPowerOfTwo<32>(node->child1()))
+                flags |= NodeBytecodeUsesAsNumber;
+            if (!m_allowNestedOverflowingAdditions)
+                flags |= NodeBytecodeUsesAsNumber;
+
+            node->child1()->mergeFlags(flags);
+            break;
+        }
+
         case ValueMul:
         case ArithMul: {
             // As soon as a multiply happens, we can easily end up in the part
             // of the double domain where the point at which you do truncation
             // can change the outcome. So, ArithMul always forces its inputs to
@@ -388,24 +405,19 @@
             // claim here that NaN v. undefined is observable.
             node->child1()->mergeFlags(NodeBytecodeUsesAsInt | NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther | NodeBytecodeUsesAsArrayIndex);
             break;
         }
 
-        case StringCharAt: {
-            node->child1()->mergeFlags(NodeBytecodeUsesAsValue);
-            node->child2()->mergeFlags(NodeBytecodeUsesAsValue | NodeBytecodeUsesAsInt | NodeBytecodeUsesAsArrayIndex);
-            break;
-        }
-
         case ToString:
         case CallStringConstructor: {
             node->child1()->mergeFlags(NodeBytecodeUsesAsNumber | NodeBytecodeUsesAsOther);
             break;
         }
 
         case ToPrimitive:
-        case ToNumber: {
+        case ToNumber:
+        case ToNumeric: {
             node->child1()->mergeFlags(flags);
             break;
         }
 
         case CompareLess:

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSPromise.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSPromise.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSPromise.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSPromise.cpp
@@ -27,12 +27,14 @@
 #include "JSPromise.h"
 
 #include "BuiltinNames.h"
 #include "Error.h"
 #include "JSCInlines.h"
+#include "JSInternalFieldObjectImplInlines.h"
 #include "JSPromiseConstructor.h"
 #include "Microtask.h"
+#include "PromiseTimer.h"
 
 namespace JSC {
 
 const ClassInfo JSPromise::s_info = { "Promise", &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSPromise) };
 
@@ -43,74 +45,146 @@
     return promise;
 }
 
 Structure* JSPromise::createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
 {
-    return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
+    return Structure::create(vm, globalObject, prototype, TypeInfo(JSPromiseType, StructureFlags), info());
 }
 
 JSPromise::JSPromise(VM& vm, Structure* structure)
     : Base(vm, structure)
 {
 }
 
 void JSPromise::finishCreation(VM& vm)
 {
     Base::finishCreation(vm);
-    putDirect(vm, vm.propertyNames->builtinNames().promiseStatePrivateName(), jsNumber(static_cast<unsigned>(Status::Pending)));
-    putDirect(vm, vm.propertyNames->builtinNames().promiseReactionsPrivateName(), jsUndefined());
-    putDirect(vm, vm.propertyNames->builtinNames().promiseResultPrivateName(), jsUndefined());
+    internalField(static_cast<unsigned>(Field::Flags)).set(vm, this, jsNumber(static_cast<unsigned>(Status::Pending)));
+    internalField(static_cast<unsigned>(Field::ReactionsOrResult)).set(vm, this, jsUndefined());
 }
 
-void JSPromise::initialize(ExecState* exec, JSGlobalObject* globalObject, JSValue executor)
+void JSPromise::visitChildren(JSCell* cell, SlotVisitor& visitor)
 {
-    JSFunction* initializePromise = globalObject->initializePromiseFunction();
-    CallData callData;
-    CallType callType = JSC::getCallData(exec->vm(), initializePromise, callData);
-    ASSERT(callType != CallType::None);
-
-    MarkedArgumentBuffer arguments;
-    arguments.append(executor);
-    ASSERT(!arguments.hasOverflowed());
-    call(exec, initializePromise, callType, callData, this, arguments);
+    auto* thisObject = jsCast<JSPromise*>(cell);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    Base::visitChildren(thisObject, visitor);
 }
 
-auto JSPromise::status(VM& vm) const -> Status
+auto JSPromise::status(VM&) const -> Status
 {
-    JSValue value = getDirect(vm, vm.propertyNames->builtinNames().promiseStatePrivateName());
-    ASSERT(value.isUInt32());
-    return static_cast<Status>(value.asUInt32());
+    JSValue value = internalField(static_cast<unsigned>(Field::Flags)).get();
+    uint32_t flags = value.asUInt32AsAnyInt();
+    return static_cast<Status>(flags & stateMask);
 }
 
 JSValue JSPromise::result(VM& vm) const
 {
-    return getDirect(vm, vm.propertyNames->builtinNames().promiseResultPrivateName());
+    Status status = this->status(vm);
+    if (status == Status::Pending)
+        return jsUndefined();
+    return internalField(static_cast<unsigned>(Field::ReactionsOrResult)).get();
 }
 
-bool JSPromise::isHandled(VM& vm) const
+uint32_t JSPromise::flags() const
 {
-    JSValue value = getDirect(vm, vm.propertyNames->builtinNames().promiseIsHandledPrivateName());
-    ASSERT(value.isBoolean());
-    return value.asBoolean();
+    JSValue value = internalField(static_cast<unsigned>(Field::Flags)).get();
+    return value.asUInt32AsAnyInt();
 }
 
-JSPromise* JSPromise::resolve(JSGlobalObject& globalObject, JSValue value)
+bool JSPromise::isHandled(VM&) const
 {
-    auto* exec = globalObject.globalExec();
-    auto& vm = exec->vm();
+    return flags() & isHandledFlag;
+}
+
+JSPromise::DeferredData JSPromise::createDeferredData(JSGlobalObject* globalObject, JSPromiseConstructor* promiseConstructor)
+{
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    auto* promiseResolveFunction = globalObject.promiseResolveFunction();
+    JSFunction* newPromiseCapabilityFunction = globalObject->newPromiseCapabilityFunction();
     CallData callData;
-    auto callType = JSC::getCallData(vm, promiseResolveFunction, callData);
+    CallType callType = JSC::getCallData(globalObject->vm(), newPromiseCapabilityFunction, callData);
     ASSERT(callType != CallType::None);
 
     MarkedArgumentBuffer arguments;
-    arguments.append(value);
+    arguments.append(promiseConstructor);
     ASSERT(!arguments.hasOverflowed());
-    auto result = call(exec, promiseResolveFunction, callType, callData, globalObject.promiseConstructor(), arguments);
+    JSValue deferred = call(globalObject, newPromiseCapabilityFunction, callType, callData, jsUndefined(), arguments);
+    RETURN_IF_EXCEPTION(scope, { });
+
+    DeferredData result;
+    result.promise = jsCast<JSPromise*>(deferred.get(globalObject, vm.propertyNames->builtinNames().promisePrivateName()));
+    RETURN_IF_EXCEPTION(scope, { });
+    result.resolve = jsCast<JSFunction*>(deferred.get(globalObject, vm.propertyNames->builtinNames().resolvePrivateName()));
+    RETURN_IF_EXCEPTION(scope, { });
+    result.reject = jsCast<JSFunction*>(deferred.get(globalObject, vm.propertyNames->builtinNames().rejectPrivateName()));
+    RETURN_IF_EXCEPTION(scope, { });
+
+    return result;
+}
+
+JSPromise* JSPromise::resolvedPromise(JSGlobalObject* globalObject, JSValue value)
+{
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
+    JSFunction* function = globalObject->promiseResolveFunction();
+    CallData callData;
+    CallType callType = JSC::getCallData(vm, function, callData);
+    ASSERT(callType != CallType::None);
+
+    MarkedArgumentBuffer arguments;
+    arguments.append(value);
+    auto result = call(globalObject, function, callType, callData, globalObject->promiseConstructor(), arguments);
     RETURN_IF_EXCEPTION(scope, nullptr);
     ASSERT(result.inherits<JSPromise>(vm));
     return jsCast<JSPromise*>(result);
 }
 
+static inline void callFunction(JSGlobalObject* globalObject, JSValue function, JSPromise* promise, JSValue value)
+{
+    CallData callData;
+    CallType callType = getCallData(globalObject->vm(), function, callData);
+    ASSERT(callType != CallType::None);
+
+    MarkedArgumentBuffer arguments;
+    arguments.append(promise);
+    arguments.append(value);
+    ASSERT(!arguments.hasOverflowed());
+
+    call(globalObject, function, callType, callData, jsUndefined(), arguments);
+}
+
+void JSPromise::resolve(JSGlobalObject* lexicalGlobalObject, JSValue value)
+{
+    VM& vm = lexicalGlobalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+    uint32_t flags = this->flags();
+    if (!(flags & isFirstResolvingFunctionCalledFlag)) {
+        internalField(static_cast<unsigned>(Field::Flags)).set(vm, this, jsNumber(flags | isFirstResolvingFunctionCalledFlag));
+        JSGlobalObject* globalObject = this->globalObject(vm);
+        callFunction(lexicalGlobalObject, globalObject->resolvePromiseFunction(), this, value);
+        RETURN_IF_EXCEPTION(scope, void());
+    }
+    vm.promiseTimer->cancelPendingPromise(this);
+}
+
+void JSPromise::reject(JSGlobalObject* lexicalGlobalObject, JSValue value)
+{
+    VM& vm = lexicalGlobalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+    uint32_t flags = this->flags();
+    if (!(flags & isFirstResolvingFunctionCalledFlag)) {
+        internalField(static_cast<unsigned>(Field::Flags)).set(vm, this, jsNumber(flags | isFirstResolvingFunctionCalledFlag));
+        JSGlobalObject* globalObject = this->globalObject(vm);
+        callFunction(lexicalGlobalObject, globalObject->rejectPromiseFunction(), this, value);
+        RETURN_IF_EXCEPTION(scope, void());
+    }
+    vm.promiseTimer->cancelPendingPromise(this);
+}
+
+void JSPromise::reject(JSGlobalObject* lexicalGlobalObject, Exception* reason)
+{
+    reject(lexicalGlobalObject, reason->value());
+}
+
 } // namespace JSC

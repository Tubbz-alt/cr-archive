<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/CrossOriginPreflightChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Canon Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Canon Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;CrossOriginPreflightChecker.h&quot;
 33 
 34 #include &quot;CachedRawResource.h&quot;
 35 #include &quot;CachedResourceLoader.h&quot;
 36 #include &quot;CachedResourceRequest.h&quot;
 37 #include &quot;ContentSecurityPolicy.h&quot;
 38 #include &quot;CrossOriginAccessControl.h&quot;
 39 #include &quot;CrossOriginPreflightResultCache.h&quot;
 40 #include &quot;DocumentThreadableLoader.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;InspectorInstrumentation.h&quot;
 43 #include &quot;NetworkLoadMetrics.h&quot;
 44 #include &quot;RuntimeEnabledFeatures.h&quot;
 45 #include &quot;SharedBuffer.h&quot;
 46 
 47 namespace WebCore {
 48 
 49 CrossOriginPreflightChecker::CrossOriginPreflightChecker(DocumentThreadableLoader&amp; loader, ResourceRequest&amp;&amp; request)
 50     : m_loader(loader)
 51     , m_request(WTFMove(request))
 52 {
 53 }
 54 
 55 CrossOriginPreflightChecker::~CrossOriginPreflightChecker()
 56 {
 57     if (m_resource)
 58         m_resource-&gt;removeClient(*this);
 59 }
 60 
 61 void CrossOriginPreflightChecker::validatePreflightResponse(DocumentThreadableLoader&amp; loader, ResourceRequest&amp;&amp; request, unsigned long identifier, const ResourceResponse&amp; response)
 62 {
 63     auto* frame = loader.document().frame();
 64     ASSERT(frame);
 65 
 66     String errorDescription;
 67     if (!WebCore::validatePreflightResponse(request, response, loader.options().storedCredentialsPolicy, loader.securityOrigin(), errorDescription)) {
 68         if (auto* document = frame-&gt;document())
 69             document-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorDescription);
 70 
 71         loader.preflightFailure(identifier, ResourceError(errorDomainWebKitInternal, 0, request.url(), errorDescription, ResourceError::Type::AccessControl));
 72         return;
 73     }
 74 
 75     // FIXME: &lt;https://webkit.org/b/164889&gt; Web Inspector: Show Preflight Request information in inspector
 76     // This is only showing success preflight requests and responses but we should show network events
 77     // for preflight failures and distinguish them better from non-preflight requests.
 78     NetworkLoadMetrics emptyMetrics;
 79     InspectorInstrumentation::didReceiveResourceResponse(*frame, identifier, frame-&gt;loader().documentLoader(), response, nullptr);
 80     InspectorInstrumentation::didFinishLoading(frame, frame-&gt;loader().documentLoader(), identifier, emptyMetrics, nullptr);
 81 
 82     loader.preflightSuccess(WTFMove(request));
 83 }
 84 
 85 void CrossOriginPreflightChecker::notifyFinished(CachedResource&amp; resource)
 86 {
 87     ASSERT_UNUSED(resource, &amp;resource == m_resource);
 88     if (m_resource-&gt;loadFailedOrCanceled()) {
 89         ResourceError preflightError = m_resource-&gt;resourceError();
 90         // If the preflight was cancelled by underlying code, it probably means the request was blocked due to some access control policy.
 91         // FIXME:: According fetch, we should just pass the error to the layer above. But this may impact some clients like XHR or EventSource.
 92         if (preflightError.isNull() || preflightError.isCancellation() || preflightError.isGeneral())
 93             preflightError.setType(ResourceError::Type::AccessControl);
 94 
 95         if (!preflightError.isTimeout())
 96             m_loader.document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;CORS-preflight request was blocked&quot;_s);
 97         m_loader.preflightFailure(m_resource-&gt;identifier(), preflightError);
 98         return;
 99     }
100     validatePreflightResponse(m_loader, WTFMove(m_request), m_resource-&gt;identifier(), m_resource-&gt;response());
101 }
102 
103 void CrossOriginPreflightChecker::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp;, const ResourceResponse&amp; response, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
104 {
105     ASSERT_UNUSED(resource, &amp;resource == m_resource);
106     validatePreflightResponse(m_loader, WTFMove(m_request), m_resource-&gt;identifier(), response);
107     completionHandler(ResourceRequest { });
108 }
109 
110 void CrossOriginPreflightChecker::startPreflight()
111 {
112     ResourceLoaderOptions options;
113     options.referrerPolicy = m_loader.options().referrerPolicy;
114     options.contentSecurityPolicyImposition = ContentSecurityPolicyImposition::SkipPolicyCheck;
115     options.serviceWorkersMode = ServiceWorkersMode::None;
116     options.initiatorContext = m_loader.options().initiatorContext;
117 
118     CachedResourceRequest preflightRequest(createAccessControlPreflightRequest(m_request, m_loader.securityOrigin(), m_loader.referrer()), options);
119     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
120         preflightRequest.setInitiator(m_loader.options().initiator);
121 
122     ASSERT(!m_resource);
123     m_resource = m_loader.document().cachedResourceLoader().requestRawResource(WTFMove(preflightRequest)).value_or(nullptr);
124     if (m_resource)
125         m_resource-&gt;addClient(*this);
126 }
127 
128 void CrossOriginPreflightChecker::doPreflight(DocumentThreadableLoader&amp; loader, ResourceRequest&amp;&amp; request)
129 {
130     if (!loader.document().frame())
131         return;
132 
133     ResourceRequest preflightRequest = createAccessControlPreflightRequest(request, loader.securityOrigin(), loader.referrer());
134     ResourceError error;
135     ResourceResponse response;
136     RefPtr&lt;SharedBuffer&gt; data;
137 
138     unsigned identifier = loader.document().frame()-&gt;loader().loadResourceSynchronously(preflightRequest, ClientCredentialPolicy::CannotAskClientForCredentials, FetchOptions { }, { }, error, response, data);
139 
140     if (!error.isNull()) {
141         // If the preflight was cancelled by underlying code, it probably means the request was blocked due to some access control policy.
142         // FIXME:: According fetch, we should just pass the error to the layer above. But this may impact some clients like XHR or EventSource.
143         if (error.isCancellation() || error.isGeneral())
144             error.setType(ResourceError::Type::AccessControl);
145 
146         if (!error.isTimeout())
147             loader.document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;CORS-preflight request was blocked&quot;_s);
148 
149         loader.preflightFailure(identifier, error);
150         return;
151     }
152 
153     // FIXME: Ideally, we should ask platformLoadResourceSynchronously to set ResourceResponse isRedirected and use it here.
154     bool isRedirect = preflightRequest.url().strippedForUseAsReferrer() != response.url().strippedForUseAsReferrer();
155     if (isRedirect || !response.isSuccessful()) {
156         auto errorMessage = &quot;Preflight response is not successful&quot;_s;
157         loader.document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, errorMessage);
158 
159         loader.preflightFailure(identifier, ResourceError { errorDomainWebKitInternal, 0, request.url(), errorMessage, ResourceError::Type::AccessControl });
160         return;
161     }
162 
163     validatePreflightResponse(loader, WTFMove(request), identifier, response);
164 }
165 
166 void CrossOriginPreflightChecker::setDefersLoading(bool value)
167 {
168     if (m_resource)
169         m_resource-&gt;setDefersLoading(value);
170 }
171 
<a name="1" id="anc1"></a>




172 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
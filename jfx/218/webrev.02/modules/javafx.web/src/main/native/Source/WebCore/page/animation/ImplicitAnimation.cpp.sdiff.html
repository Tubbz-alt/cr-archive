<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/ImplicitAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompositeAnimation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeAnimation.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/ImplicitAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
195     // destination. If we didn&#39;t, the next time through we would think a transition had started
196     // (comparing the old unanimated style with the new final style of the transition).
197     if (auto* animation = m_compositeAnimation-&gt;animationForProperty(m_animatingProperty))
198         animation-&gt;setUnanimatedStyle(RenderStyle::clonePtr(*m_toStyle));
199 
200     sendTransitionEvent(eventNames().transitionendEvent, elapsedTime);
201     endAnimation();
202 }
203 
204 bool ImplicitAnimation::sendTransitionEvent(const AtomString&amp; eventType, double elapsedTime)
205 {
206     if (eventType == eventNames().transitionendEvent) {
207         Document::ListenerType listenerType = Document::TRANSITIONEND_LISTENER;
208 
209         if (shouldSendEventForListener(listenerType)) {
210             String propertyName = getPropertyNameString(m_animatingProperty);
211 
212             // Dispatch the event
213             auto element = makeRefPtr(this-&gt;element());
214 
<span class="line-modified">215             ASSERT(!element || element-&gt;document().pageCacheState() == Document::NotInPageCache);</span>
216             if (!element)
217                 return false;
218 
219             // Schedule event handling
220             m_compositeAnimation-&gt;animationController().addEventToDispatch(*element, eventType, propertyName, elapsedTime);
221 
222             // Restore the original (unanimated) style
223             if (eventType == eventNames().transitionendEvent &amp;&amp; element-&gt;renderer())
224                 setNeedsStyleRecalc(element.get());
225 
226             return true; // Did dispatch an event
227         }
228     }
229 
230     return false; // Didn&#39;t dispatch an event
231 }
232 
233 void ImplicitAnimation::reset(const RenderStyle&amp; to, CompositeAnimation&amp; compositeAnimation)
234 {
235     ASSERT(m_fromStyle);
</pre>
<hr />
<pre>
343         return;
344 
345     m_backdropFilterFunctionListsMatch = filterOperationsMatch(&amp;m_fromStyle-&gt;backdropFilter(), m_toStyle-&gt;backdropFilter());
346 }
347 #endif
348 
349 void ImplicitAnimation::checkForMatchingColorFilterFunctionLists()
350 {
351     m_filterFunctionListsMatch = false;
352 
353     if (!m_fromStyle || !m_toStyle)
354         return;
355 
356     m_colorFilterFunctionListsMatch = filterOperationsMatch(&amp;m_fromStyle-&gt;appleColorFilter(), m_toStyle-&gt;appleColorFilter());
357 }
358 
359 Optional&lt;Seconds&gt; ImplicitAnimation::timeToNextService()
360 {
361     Optional&lt;Seconds&gt; t = AnimationBase::timeToNextService();
362     if (!t || t.value() != 0_s || preActive())



363         return t;

364 
365     // A return value of 0 means we need service. But if this is an accelerated animation we
366     // only need service at the end of the transition.
367     if (CSSPropertyAnimation::animationOfPropertyIsAccelerated(m_animatingProperty) &amp;&amp; isAccelerated()) {
368         bool isLooping;
369         getTimeToNextEvent(t.value(), isLooping);
370     }
371     return t;
372 }
373 
374 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
195     // destination. If we didn&#39;t, the next time through we would think a transition had started
196     // (comparing the old unanimated style with the new final style of the transition).
197     if (auto* animation = m_compositeAnimation-&gt;animationForProperty(m_animatingProperty))
198         animation-&gt;setUnanimatedStyle(RenderStyle::clonePtr(*m_toStyle));
199 
200     sendTransitionEvent(eventNames().transitionendEvent, elapsedTime);
201     endAnimation();
202 }
203 
204 bool ImplicitAnimation::sendTransitionEvent(const AtomString&amp; eventType, double elapsedTime)
205 {
206     if (eventType == eventNames().transitionendEvent) {
207         Document::ListenerType listenerType = Document::TRANSITIONEND_LISTENER;
208 
209         if (shouldSendEventForListener(listenerType)) {
210             String propertyName = getPropertyNameString(m_animatingProperty);
211 
212             // Dispatch the event
213             auto element = makeRefPtr(this-&gt;element());
214 
<span class="line-modified">215             ASSERT(!element || element-&gt;document().backForwardCacheState() == Document::NotInBackForwardCache);</span>
216             if (!element)
217                 return false;
218 
219             // Schedule event handling
220             m_compositeAnimation-&gt;animationController().addEventToDispatch(*element, eventType, propertyName, elapsedTime);
221 
222             // Restore the original (unanimated) style
223             if (eventType == eventNames().transitionendEvent &amp;&amp; element-&gt;renderer())
224                 setNeedsStyleRecalc(element.get());
225 
226             return true; // Did dispatch an event
227         }
228     }
229 
230     return false; // Didn&#39;t dispatch an event
231 }
232 
233 void ImplicitAnimation::reset(const RenderStyle&amp; to, CompositeAnimation&amp; compositeAnimation)
234 {
235     ASSERT(m_fromStyle);
</pre>
<hr />
<pre>
343         return;
344 
345     m_backdropFilterFunctionListsMatch = filterOperationsMatch(&amp;m_fromStyle-&gt;backdropFilter(), m_toStyle-&gt;backdropFilter());
346 }
347 #endif
348 
349 void ImplicitAnimation::checkForMatchingColorFilterFunctionLists()
350 {
351     m_filterFunctionListsMatch = false;
352 
353     if (!m_fromStyle || !m_toStyle)
354         return;
355 
356     m_colorFilterFunctionListsMatch = filterOperationsMatch(&amp;m_fromStyle-&gt;appleColorFilter(), m_toStyle-&gt;appleColorFilter());
357 }
358 
359 Optional&lt;Seconds&gt; ImplicitAnimation::timeToNextService()
360 {
361     Optional&lt;Seconds&gt; t = AnimationBase::timeToNextService();
362     if (!t || t.value() != 0_s || preActive())
<span class="line-added">363 #if COMPILER(MSVC) &amp;&amp; _MSC_VER &gt;= 1920</span>
<span class="line-added">364         return WTFMove(t);</span>
<span class="line-added">365 #else</span>
366         return t;
<span class="line-added">367 #endif</span>
368 
369     // A return value of 0 means we need service. But if this is an accelerated animation we
370     // only need service at the end of the transition.
371     if (CSSPropertyAnimation::animationOfPropertyIsAccelerated(m_animatingProperty) &amp;&amp; isAccelerated()) {
372         bool isLooping;
373         getTimeToNextEvent(t.value(), isLooping);
374     }
375     return t;
376 }
377 
378 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="CompositeAnimation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeAnimation.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
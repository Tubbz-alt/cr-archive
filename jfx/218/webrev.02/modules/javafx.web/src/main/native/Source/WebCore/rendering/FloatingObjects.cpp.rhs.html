<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/FloatingObjects.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2007 David Smith (catfish.man@gmail.com)
  5  * Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;FloatingObjects.h&quot;
 26 
<a name="1" id="anc1"></a><span class="line-added"> 27 #include &quot;PODIntervalTree.h&quot;</span>
 28 #include &quot;RenderBlockFlow.h&quot;
 29 #include &quot;RenderBox.h&quot;
 30 #include &quot;RenderView.h&quot;
 31 #include &lt;wtf/HexNumber.h&gt;
 32 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 struct SameSizeAsFloatingObject {
 37     void* pointers[2];
 38     LayoutRect rect;
 39     int paginationStrut;
 40     LayoutSize size;
 41     uint32_t bitfields : 8;
 42 };
 43 
 44 COMPILE_ASSERT(sizeof(FloatingObject) == sizeof(SameSizeAsFloatingObject), FloatingObject_should_stay_small);
 45 
 46 FloatingObject::FloatingObject(RenderBox&amp; renderer)
 47     : m_renderer(makeWeakPtr(renderer))
 48     , m_shouldPaint(true)
 49     , m_isDescendant(false)
 50     , m_isPlaced(false)
<a name="2" id="anc2"></a><span class="line-modified"> 51 #if ASSERT_ENABLED</span>
 52     , m_isInPlacedTree(false)
 53 #endif
 54 {
 55     Float type = renderer.style().floating();
 56     ASSERT(type != Float::No);
 57     if (type == Float::Left)
 58         m_type = FloatLeft;
 59     else if (type == Float::Right)
 60         m_type = FloatRight;
 61 }
 62 
 63 FloatingObject::FloatingObject(RenderBox&amp; renderer, Type type, const LayoutRect&amp; frameRect, const LayoutSize&amp; marginOffset, bool shouldPaint, bool isDescendant)
 64     : m_renderer(makeWeakPtr(renderer))
 65     , m_frameRect(frameRect)
 66     , m_marginOffset(marginOffset)
 67     , m_type(type)
 68     , m_shouldPaint(shouldPaint)
 69     , m_isDescendant(isDescendant)
 70     , m_isPlaced(true)
<a name="3" id="anc3"></a><span class="line-modified"> 71 #if ASSERT_ENABLED</span>
 72     , m_isInPlacedTree(false)
 73 #endif
 74 {
 75 }
 76 
 77 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::create(RenderBox&amp; renderer)
 78 {
 79     auto object = makeUnique&lt;FloatingObject&gt;(renderer);
 80     object-&gt;setShouldPaint(!renderer.hasSelfPaintingLayer()); // If a layer exists, the float will paint itself. Otherwise someone else will.
 81     object-&gt;setIsDescendant(true);
 82     return object;
 83 }
 84 
 85 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::copyToNewContainer(LayoutSize offset, bool shouldPaint, bool isDescendant) const
 86 {
 87     return makeUnique&lt;FloatingObject&gt;(renderer(), type(), LayoutRect(frameRect().location() - offset, frameRect().size()), marginOffset(), shouldPaint, isDescendant);
 88 }
 89 
 90 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::cloneForNewParent() const
 91 {
 92     auto cloneObject = makeUnique&lt;FloatingObject&gt;(renderer(), type(), m_frameRect, m_marginOffset, m_shouldPaint, m_isDescendant);
 93     cloneObject-&gt;m_paginationStrut = m_paginationStrut;
 94     cloneObject-&gt;m_isPlaced = m_isPlaced;
 95     return cloneObject;
 96 }
 97 
 98 LayoutSize FloatingObject::translationOffsetToAncestor() const
 99 {
100     return locationOffsetOfBorderBox() - renderer().locationOffset();
101 }
102 
103 #ifndef NDEBUG
104 
<a name="4" id="anc4"></a><span class="line-modified">105 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const FloatingObject&amp; object)</span>
106 {
<a name="5" id="anc5"></a><span class="line-modified">107     return stream &lt;&lt; &amp;object &lt;&lt; &quot; (&quot; &lt;&lt; object.frameRect().x().toInt() &lt;&lt; &#39;x&#39; &lt;&lt; object.frameRect().y().toInt() &lt;&lt; &#39; &#39; &lt;&lt; object.frameRect().maxX().toInt() &lt;&lt; &#39;x&#39; &lt;&lt; object.frameRect().maxY().toInt() &lt;&lt; &#39;)&#39;;</span>
108 }
109 
110 #endif
111 
112 inline static bool rangesIntersect(LayoutUnit floatTop, LayoutUnit floatBottom, LayoutUnit objectTop, LayoutUnit objectBottom)
113 {
114     if (objectTop &gt;= floatBottom || objectBottom &lt; floatTop)
115         return false;
116 
117     // The top of the object overlaps the float
118     if (objectTop &gt;= floatTop)
119         return true;
120 
121     // The object encloses the float
122     if (objectTop &lt; floatTop &amp;&amp; objectBottom &gt; floatBottom)
123         return true;
124 
125     // The bottom of the object overlaps the float
126     if (objectBottom &gt; objectTop &amp;&amp; objectBottom &gt; floatTop &amp;&amp; objectBottom &lt;= floatBottom)
127         return true;
128 
129     return false;
130 }
131 
132 template &lt;FloatingObject::Type FloatTypeValue&gt;
133 class ComputeFloatOffsetAdapter {
134 public:
135     typedef FloatingObjectInterval IntervalType;
136 
137     ComputeFloatOffsetAdapter(const RenderBlockFlow&amp; renderer, LayoutUnit lineTop, LayoutUnit lineBottom, LayoutUnit offset)
138         : m_renderer(makeWeakPtr(renderer))
139         , m_lineTop(lineTop)
140         , m_lineBottom(lineBottom)
141         , m_offset(offset)
142         , m_outermostFloat(0)
143     {
144     }
145 
146     virtual ~ComputeFloatOffsetAdapter() = default;
147 
148     LayoutUnit lowValue() const { return m_lineTop; }
149     LayoutUnit highValue() const { return m_lineBottom; }
150     void collectIfNeeded(const IntervalType&amp;);
151 
152     LayoutUnit offset() const { return m_offset; }
153 
154 protected:
155     virtual bool updateOffsetIfNeeded(const FloatingObject&amp;) = 0;
156 
157     WeakPtr&lt;const RenderBlockFlow&gt; m_renderer;
158     LayoutUnit m_lineTop;
159     LayoutUnit m_lineBottom;
160     LayoutUnit m_offset;
161     const FloatingObject* m_outermostFloat;
162 };
163 
164 template &lt;FloatingObject::Type FloatTypeValue&gt;
165 class ComputeFloatOffsetForFloatLayoutAdapter : public ComputeFloatOffsetAdapter&lt;FloatTypeValue&gt; {
166 public:
167     ComputeFloatOffsetForFloatLayoutAdapter(const RenderBlockFlow&amp; renderer, LayoutUnit lineTop, LayoutUnit lineBottom, LayoutUnit offset)
168         : ComputeFloatOffsetAdapter&lt;FloatTypeValue&gt;(renderer, lineTop, lineBottom, offset)
169     {
170     }
171 
172     virtual ~ComputeFloatOffsetForFloatLayoutAdapter() = default;
173 
174     LayoutUnit heightRemaining() const;
175 
176 protected:
177     bool updateOffsetIfNeeded(const FloatingObject&amp;) final;
178 };
179 
180 template &lt;FloatingObject::Type FloatTypeValue&gt;
181 class ComputeFloatOffsetForLineLayoutAdapter : public ComputeFloatOffsetAdapter&lt;FloatTypeValue&gt; {
182 public:
183     ComputeFloatOffsetForLineLayoutAdapter(const RenderBlockFlow&amp; renderer, LayoutUnit lineTop, LayoutUnit lineBottom, LayoutUnit offset)
184         : ComputeFloatOffsetAdapter&lt;FloatTypeValue&gt;(renderer, lineTop, lineBottom, offset)
185     {
186     }
187 
188     virtual ~ComputeFloatOffsetForLineLayoutAdapter() = default;
189 
190 protected:
191     bool updateOffsetIfNeeded(const FloatingObject&amp;) final;
192 };
193 
194 class FindNextFloatLogicalBottomAdapter {
195 public:
196     typedef FloatingObjectInterval IntervalType;
197 
198     FindNextFloatLogicalBottomAdapter(const RenderBlockFlow&amp; renderer, LayoutUnit belowLogicalHeight)
199         : m_renderer(makeWeakPtr(renderer))
200         , m_belowLogicalHeight(belowLogicalHeight)
201     {
202     }
203 
204     LayoutUnit lowValue() const { return m_belowLogicalHeight; }
205     LayoutUnit highValue() const { return LayoutUnit::max(); }
206     void collectIfNeeded(const IntervalType&amp;);
207 
208     LayoutUnit nextLogicalBottom() const { return m_nextLogicalBottom.valueOr(0); }
209     LayoutUnit nextShapeLogicalBottom() const { return m_nextShapeLogicalBottom.valueOr(nextLogicalBottom()); }
210 
211 private:
212     WeakPtr&lt;const RenderBlockFlow&gt; m_renderer;
213     LayoutUnit m_belowLogicalHeight;
214     Optional&lt;LayoutUnit&gt; m_nextLogicalBottom;
215     Optional&lt;LayoutUnit&gt; m_nextShapeLogicalBottom;
216 };
217 
218 inline void FindNextFloatLogicalBottomAdapter::collectIfNeeded(const IntervalType&amp; interval)
219 {
220     const auto&amp; floatingObject = *interval.data();
221     if (!rangesIntersect(interval.low(), interval.high(), m_belowLogicalHeight, LayoutUnit::max()))
222         return;
223 
224     // All the objects returned from the tree should be already placed.
225     ASSERT(floatingObject.isPlaced());
226     ASSERT(rangesIntersect(m_renderer-&gt;logicalTopForFloat(floatingObject), m_renderer-&gt;logicalBottomForFloat(floatingObject), m_belowLogicalHeight, LayoutUnit::max()));
227 
228     LayoutUnit floatBottom = m_renderer-&gt;logicalBottomForFloat(floatingObject);
229     if (m_nextLogicalBottom &amp;&amp; m_nextLogicalBottom.value() &lt; floatBottom)
230         return;
231 
232     if (ShapeOutsideInfo* shapeOutside = floatingObject.renderer().shapeOutsideInfo()) {
233         LayoutUnit shapeBottom = m_renderer-&gt;logicalTopForFloat(floatingObject) + m_renderer-&gt;marginBeforeForChild(floatingObject.renderer()) + shapeOutside-&gt;shapeLogicalBottom();
234         // Use the shapeBottom unless it extends outside of the margin box, in which case it is clipped.
235         m_nextShapeLogicalBottom = std::min(shapeBottom, floatBottom);
236     } else
237         m_nextShapeLogicalBottom = floatBottom;
238     m_nextLogicalBottom = floatBottom;
239 }
240 
241 LayoutUnit FloatingObjects::findNextFloatLogicalBottomBelow(LayoutUnit logicalHeight)
242 {
243     FindNextFloatLogicalBottomAdapter adapter(renderer(), logicalHeight);
244     if (const FloatingObjectTree* placedFloatsTree = this-&gt;placedFloatsTree())
245         placedFloatsTree-&gt;allOverlapsWithAdapter(adapter);
246 
247     return adapter.nextShapeLogicalBottom();
248 }
249 
250 LayoutUnit FloatingObjects::findNextFloatLogicalBottomBelowForBlock(LayoutUnit logicalHeight)
251 {
252     FindNextFloatLogicalBottomAdapter adapter(renderer(), logicalHeight);
253     if (const FloatingObjectTree* placedFloatsTree = this-&gt;placedFloatsTree())
254         placedFloatsTree-&gt;allOverlapsWithAdapter(adapter);
255 
256     return adapter.nextLogicalBottom();
257 }
258 
259 FloatingObjects::FloatingObjects(const RenderBlockFlow&amp; renderer)
260     : m_leftObjectsCount(0)
261     , m_rightObjectsCount(0)
262     , m_horizontalWritingMode(renderer.isHorizontalWritingMode())
263     , m_renderer(makeWeakPtr(renderer))
264 {
265 }
266 
267 FloatingObjects::~FloatingObjects() = default;
268 
269 void FloatingObjects::clearLineBoxTreePointers()
270 {
271     // Clear references to originating lines, since the lines are being deleted
272     for (auto it = m_set.begin(), end = m_set.end(); it != end; ++it) {
273         ASSERT(!((*it)-&gt;originatingLine()) || &amp;((*it)-&gt;originatingLine()-&gt;renderer()) == &amp;renderer());
274         (*it)-&gt;clearOriginatingLine();
275     }
276 }
277 
278 void FloatingObjects::clear()
279 {
280     m_set.clear();
281     m_placedFloatsTree = nullptr;
282     m_leftObjectsCount = 0;
283     m_rightObjectsCount = 0;
284 }
285 
286 void FloatingObjects::moveAllToFloatInfoMap(RendererToFloatInfoMap&amp; map)
287 {
288     for (auto it = m_set.begin(), end = m_set.end(); it != end; ++it) {
289         auto&amp; renderer = it-&gt;get()-&gt;renderer();
290         // FIXME: The only reason it is safe to move these out of the set is that
291         // we are about to clear it. Otherwise it would break the hash table invariant.
292         // A clean way to do this would be to add a takeAll function to HashSet.
293         map.add(&amp;renderer, WTFMove(*it));
294     }
295     clear();
296 }
297 
298 void FloatingObjects::increaseObjectsCount(FloatingObject::Type type)
299 {
300     if (type == FloatingObject::FloatLeft)
301         m_leftObjectsCount++;
302     else
303         m_rightObjectsCount++;
304 }
305 
306 void FloatingObjects::decreaseObjectsCount(FloatingObject::Type type)
307 {
308     if (type == FloatingObject::FloatLeft)
309         m_leftObjectsCount--;
310     else
311         m_rightObjectsCount--;
312 }
313 
314 FloatingObjectInterval FloatingObjects::intervalForFloatingObject(FloatingObject* floatingObject)
315 {
316     // FIXME The endpoints of the floating object interval shouldn&#39;t need to be
317     // floored. See http://wkb.ug/125831 for more details.
318     if (m_horizontalWritingMode)
319         return FloatingObjectInterval(floatingObject-&gt;frameRect().y().floor(), floatingObject-&gt;frameRect().maxY().floor(), floatingObject);
320     return FloatingObjectInterval(floatingObject-&gt;frameRect().x().floor(), floatingObject-&gt;frameRect().maxX().floor(), floatingObject);
321 }
322 
323 void FloatingObjects::addPlacedObject(FloatingObject* floatingObject)
324 {
325     ASSERT(!floatingObject-&gt;isInPlacedTree());
326 
327     floatingObject-&gt;setIsPlaced(true);
328     if (m_placedFloatsTree)
329         m_placedFloatsTree-&gt;add(intervalForFloatingObject(floatingObject));
330 
<a name="6" id="anc6"></a><span class="line-modified">331 #if ASSERT_ENABLED</span>
332     floatingObject-&gt;setIsInPlacedTree(true);
333 #endif
334 }
335 
336 void FloatingObjects::removePlacedObject(FloatingObject* floatingObject)
337 {
338     ASSERT(floatingObject-&gt;isPlaced() &amp;&amp; floatingObject-&gt;isInPlacedTree());
339 
340     if (m_placedFloatsTree) {
341         bool removed = m_placedFloatsTree-&gt;remove(intervalForFloatingObject(floatingObject));
342         ASSERT_UNUSED(removed, removed);
343     }
344 
345     floatingObject-&gt;setIsPlaced(false);
<a name="7" id="anc7"></a><span class="line-modified">346 #if ASSERT_ENABLED</span>
347     floatingObject-&gt;setIsInPlacedTree(false);
348 #endif
349 }
350 
351 FloatingObject* FloatingObjects::add(std::unique_ptr&lt;FloatingObject&gt; floatingObject)
352 {
353     increaseObjectsCount(floatingObject-&gt;type());
354     if (floatingObject-&gt;isPlaced())
355         addPlacedObject(floatingObject.get());
356     return m_set.add(WTFMove(floatingObject)).iterator-&gt;get();
357 }
358 
359 void FloatingObjects::remove(FloatingObject* floatingObject)
360 {
361     ASSERT((m_set.contains(floatingObject)));
362     decreaseObjectsCount(floatingObject-&gt;type());
363     ASSERT(floatingObject-&gt;isPlaced() || !floatingObject-&gt;isInPlacedTree());
364     if (floatingObject-&gt;isPlaced())
365         removePlacedObject(floatingObject);
366     ASSERT(!floatingObject-&gt;originatingLine());
367     m_set.remove(floatingObject);
368 }
369 
370 void FloatingObjects::computePlacedFloatsTree()
371 {
372     ASSERT(!m_placedFloatsTree);
373     if (m_set.isEmpty())
374         return;
375 
376     m_placedFloatsTree = makeUnique&lt;FloatingObjectTree&gt;();
377     for (auto it = m_set.begin(), end = m_set.end(); it != end; ++it) {
378         FloatingObject* floatingObject = it-&gt;get();
379         if (floatingObject-&gt;isPlaced())
380             m_placedFloatsTree-&gt;add(intervalForFloatingObject(floatingObject));
381     }
382 }
383 
384 inline const FloatingObjectTree* FloatingObjects::placedFloatsTree()
385 {
386     if (!m_placedFloatsTree)
387         computePlacedFloatsTree();
388     return m_placedFloatsTree.get();
389 }
390 
391 LayoutUnit FloatingObjects::logicalLeftOffsetForPositioningFloat(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit *heightRemaining)
392 {
393     ComputeFloatOffsetForFloatLayoutAdapter&lt;FloatingObject::FloatLeft&gt; adapter(renderer(), logicalTop, logicalTop, fixedOffset);
394     if (const FloatingObjectTree* placedFloatsTree = this-&gt;placedFloatsTree())
395         placedFloatsTree-&gt;allOverlapsWithAdapter(adapter);
396 
397     if (heightRemaining)
398         *heightRemaining = adapter.heightRemaining();
399 
400     return adapter.offset();
401 }
402 
403 LayoutUnit FloatingObjects::logicalRightOffsetForPositioningFloat(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit *heightRemaining)
404 {
405     ComputeFloatOffsetForFloatLayoutAdapter&lt;FloatingObject::FloatRight&gt; adapter(renderer(), logicalTop, logicalTop, fixedOffset);
406     if (const FloatingObjectTree* placedFloatsTree = this-&gt;placedFloatsTree())
407         placedFloatsTree-&gt;allOverlapsWithAdapter(adapter);
408 
409     if (heightRemaining)
410         *heightRemaining = adapter.heightRemaining();
411 
412     return std::min(fixedOffset, adapter.offset());
413 }
414 
415 LayoutUnit FloatingObjects::logicalLeftOffset(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit logicalHeight)
416 {
417     ComputeFloatOffsetForLineLayoutAdapter&lt;FloatingObject::FloatLeft&gt; adapter(renderer(), logicalTop, logicalTop + logicalHeight, fixedOffset);
418     if (const FloatingObjectTree* placedFloatsTree = this-&gt;placedFloatsTree())
419         placedFloatsTree-&gt;allOverlapsWithAdapter(adapter);
420 
421     return adapter.offset();
422 }
423 
424 LayoutUnit FloatingObjects::logicalRightOffset(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit logicalHeight)
425 {
426     ComputeFloatOffsetForLineLayoutAdapter&lt;FloatingObject::FloatRight&gt; adapter(renderer(), logicalTop, logicalTop + logicalHeight, fixedOffset);
427     if (const FloatingObjectTree* placedFloatsTree = this-&gt;placedFloatsTree())
428         placedFloatsTree-&gt;allOverlapsWithAdapter(adapter);
429 
430     return std::min(fixedOffset, adapter.offset());
431 }
432 
433 template&lt;&gt;
434 inline bool ComputeFloatOffsetForFloatLayoutAdapter&lt;FloatingObject::FloatLeft&gt;::updateOffsetIfNeeded(const FloatingObject&amp; floatingObject)
435 {
436     LayoutUnit logicalRight = m_renderer-&gt;logicalRightForFloat(floatingObject);
437     if (logicalRight &gt; m_offset) {
438         m_offset = logicalRight;
439         return true;
440     }
441     return false;
442 }
443 
444 template&lt;&gt;
445 inline bool ComputeFloatOffsetForFloatLayoutAdapter&lt;FloatingObject::FloatRight&gt;::updateOffsetIfNeeded(const FloatingObject&amp; floatingObject)
446 {
447     LayoutUnit logicalLeft = m_renderer-&gt;logicalLeftForFloat(floatingObject);
448     if (logicalLeft &lt; m_offset) {
449         m_offset = logicalLeft;
450         return true;
451     }
452     return false;
453 }
454 
455 template &lt;FloatingObject::Type FloatTypeValue&gt;
456 LayoutUnit ComputeFloatOffsetForFloatLayoutAdapter&lt;FloatTypeValue&gt;::heightRemaining() const
457 {
458     return this-&gt;m_outermostFloat ? this-&gt;m_renderer-&gt;logicalBottomForFloat(*this-&gt;m_outermostFloat) - this-&gt;m_lineTop : 1_lu;
459 }
460 
461 template &lt;FloatingObject::Type FloatTypeValue&gt;
462 inline void ComputeFloatOffsetAdapter&lt;FloatTypeValue&gt;::collectIfNeeded(const IntervalType&amp; interval)
463 {
464     const auto&amp; floatingObject = *interval.data();
465     if (floatingObject.type() != FloatTypeValue || !rangesIntersect(interval.low(), interval.high(), m_lineTop, m_lineBottom))
466         return;
467 
468     // All the objects returned from the tree should be already placed.
469     ASSERT(floatingObject.isPlaced());
470     ASSERT(rangesIntersect(m_renderer-&gt;logicalTopForFloat(floatingObject), m_renderer-&gt;logicalBottomForFloat(floatingObject), m_lineTop, m_lineBottom));
471 
472     bool floatIsNewExtreme = updateOffsetIfNeeded(floatingObject);
473     if (floatIsNewExtreme)
474         m_outermostFloat = &amp;floatingObject;
475 }
476 
477 template&lt;&gt;
478 inline bool ComputeFloatOffsetForLineLayoutAdapter&lt;FloatingObject::FloatLeft&gt;::updateOffsetIfNeeded(const FloatingObject&amp; floatingObject)
479 {
480     LayoutUnit logicalRight = m_renderer-&gt;logicalRightForFloat(floatingObject);
481     if (ShapeOutsideInfo* shapeOutside = floatingObject.renderer().shapeOutsideInfo()) {
482         ShapeOutsideDeltas shapeDeltas = shapeOutside-&gt;computeDeltasForContainingBlockLine(*m_renderer, floatingObject, m_lineTop, m_lineBottom - m_lineTop);
483         if (!shapeDeltas.isValid() || !shapeDeltas.lineOverlapsShape())
484             return false;
485 
486         logicalRight += shapeDeltas.rightMarginBoxDelta();
487     }
488     if (logicalRight &gt; m_offset) {
489         m_offset = logicalRight;
490         return true;
491     }
492 
493     return false;
494 }
495 
496 template&lt;&gt;
497 inline bool ComputeFloatOffsetForLineLayoutAdapter&lt;FloatingObject::FloatRight&gt;::updateOffsetIfNeeded(const FloatingObject&amp; floatingObject)
498 {
499     LayoutUnit logicalLeft = m_renderer-&gt;logicalLeftForFloat(floatingObject);
500     if (ShapeOutsideInfo* shapeOutside = floatingObject.renderer().shapeOutsideInfo()) {
501         ShapeOutsideDeltas shapeDeltas = shapeOutside-&gt;computeDeltasForContainingBlockLine(*m_renderer, floatingObject, m_lineTop, m_lineBottom - m_lineTop);
502         if (!shapeDeltas.isValid() || !shapeDeltas.lineOverlapsShape())
503             return false;
504 
505         logicalLeft += shapeDeltas.leftMarginBoxDelta();
506     }
507     if (logicalLeft &lt; m_offset) {
508         m_offset = logicalLeft;
509         return true;
510     }
511 
512     return false;
513 }
514 
515 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
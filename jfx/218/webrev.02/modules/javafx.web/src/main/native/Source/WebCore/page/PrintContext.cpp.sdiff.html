<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/PrintContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PointerLockController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProcessWarming.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/PrintContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 72     outPageHeight = pageHeight; // this is the height of the page adjusted by margins
 73     pageHeight -= headerHeight + footerHeight;
 74 
 75     if (pageHeight &lt;= 0) {
 76         LOG_ERROR(&quot;pageHeight has bad value %.2f&quot;, pageHeight);
 77         return;
 78     }
 79 
 80     computePageRectsWithPageSizeInternal(FloatSize(pageWidth / userScaleFactor, pageHeight / userScaleFactor), allowHorizontalTiling);
 81 }
 82 
 83 FloatBoxExtent PrintContext::computedPageMargin(FloatBoxExtent printMargin)
 84 {
 85     if (!frame() || !frame()-&gt;document())
 86         return printMargin;
 87     if (!RuntimeEnabledFeatures::sharedFeatures().pageAtRuleSupportEnabled())
 88         return printMargin;
 89     // FIXME Currently no pseudo class is supported.
 90     auto style = frame()-&gt;document()-&gt;styleScope().resolver().styleForPage(0);
 91 
<span class="line-modified"> 92     float pixelToPointScaleFactor = 1 / CSSPrimitiveValue::conversionToCanonicalUnitsScaleFactor(CSSPrimitiveValue::CSS_PT);</span>
 93     return { style-&gt;marginTop().isAuto() ? printMargin.top() : style-&gt;marginTop().value() * pixelToPointScaleFactor,
 94         style-&gt;marginRight().isAuto() ? printMargin.right() : style-&gt;marginRight().value() * pixelToPointScaleFactor,
 95         style-&gt;marginBottom().isAuto() ? printMargin.bottom() : style-&gt;marginBottom().value() * pixelToPointScaleFactor,
 96         style-&gt;marginLeft().isAuto() ? printMargin.left() : style-&gt;marginLeft().value() * pixelToPointScaleFactor };
 97 }
 98 
 99 FloatSize PrintContext::computedPageSize(FloatSize pageSize, FloatBoxExtent printMargin)
100 {
101     auto computedMargin = computedPageMargin(printMargin);
102     if (computedMargin == printMargin)
103         return pageSize;
104 
105     auto horizontalMarginDelta = (printMargin.left() - computedMargin.left()) + (printMargin.right() - computedMargin.right());
106     auto verticalMarginDelta = (printMargin.top() - computedMargin.top()) + (printMargin.bottom() - computedMargin.bottom());
107     return { pageSize.width() + horizontalMarginDelta, pageSize.height() + verticalMarginDelta };
108 }
109 
110 void PrintContext::computePageRectsWithPageSize(const FloatSize&amp; pageSizeInPixels, bool allowHorizontalTiling)
111 {
112     m_pageRects.clear();
</pre>
<hr />
<pre>
213 
214     bool useViewWidth = true;
215     if (frame.document() &amp;&amp; frame.document()-&gt;renderView())
216         useViewWidth = frame.document()-&gt;renderView()-&gt;style().isHorizontalWritingMode();
217 
218     float viewLogicalWidth = useViewWidth ? frame.view()-&gt;contentsWidth() : frame.view()-&gt;contentsHeight();
219     if (viewLogicalWidth &lt; 1)
220         return 1;
221 
222     float maxShrinkToFitScaleFactor = 1 / maximumShrinkFactor();
223     float shrinkToFitScaleFactor = (useViewWidth ? availablePaperSize.width() : availablePaperSize.height()) / viewLogicalWidth;
224     return std::max(maxShrinkToFitScaleFactor, shrinkToFitScaleFactor);
225 }
226 
227 void PrintContext::spoolPage(GraphicsContext&amp; ctx, int pageNumber, float width)
228 {
229     if (!frame())
230         return;
231 
232     auto&amp; frame = *this-&gt;frame();



233     // FIXME: Not correct for vertical text.
234     IntRect pageRect = m_pageRects[pageNumber];
235     float scale = width / pageRect.width();
236 
237     ctx.save();
238     ctx.scale(scale);
239     ctx.translate(-pageRect.x(), -pageRect.y());
240     ctx.clip(pageRect);
241     frame.view()-&gt;paintContents(ctx, pageRect);
242     outputLinkedDestinations(ctx, *frame.document(), pageRect);
243     ctx.restore();
244 }
245 
246 void PrintContext::spoolRect(GraphicsContext&amp; ctx, const IntRect&amp; rect)
247 {
248     if (!frame())
249         return;
250 
251     auto&amp; frame = *this-&gt;frame();



252     // FIXME: Not correct for vertical text.
253     ctx.save();
254     ctx.translate(-rect.x(), -rect.y());
255     ctx.clip(rect);
256     frame.view()-&gt;paintContents(ctx, rect);
257     outputLinkedDestinations(ctx, *frame.document(), rect);
258     ctx.restore();
259 }
260 
261 void PrintContext::end()
262 {
263     if (!frame())
264         return;
265 
266     auto&amp; frame = *this-&gt;frame();
267     ASSERT(m_isPrinting);
268     m_isPrinting = false;
269     frame.setPrinting(false, FloatSize(), FloatSize(), 0, AdjustViewSize);
270     m_linkedDestinations = nullptr;
271 }
</pre>
</td>
<td>
<hr />
<pre>
 72     outPageHeight = pageHeight; // this is the height of the page adjusted by margins
 73     pageHeight -= headerHeight + footerHeight;
 74 
 75     if (pageHeight &lt;= 0) {
 76         LOG_ERROR(&quot;pageHeight has bad value %.2f&quot;, pageHeight);
 77         return;
 78     }
 79 
 80     computePageRectsWithPageSizeInternal(FloatSize(pageWidth / userScaleFactor, pageHeight / userScaleFactor), allowHorizontalTiling);
 81 }
 82 
 83 FloatBoxExtent PrintContext::computedPageMargin(FloatBoxExtent printMargin)
 84 {
 85     if (!frame() || !frame()-&gt;document())
 86         return printMargin;
 87     if (!RuntimeEnabledFeatures::sharedFeatures().pageAtRuleSupportEnabled())
 88         return printMargin;
 89     // FIXME Currently no pseudo class is supported.
 90     auto style = frame()-&gt;document()-&gt;styleScope().resolver().styleForPage(0);
 91 
<span class="line-modified"> 92     float pixelToPointScaleFactor = 1 / CSSPrimitiveValue::conversionToCanonicalUnitsScaleFactor(CSSUnitType::CSS_PT);</span>
 93     return { style-&gt;marginTop().isAuto() ? printMargin.top() : style-&gt;marginTop().value() * pixelToPointScaleFactor,
 94         style-&gt;marginRight().isAuto() ? printMargin.right() : style-&gt;marginRight().value() * pixelToPointScaleFactor,
 95         style-&gt;marginBottom().isAuto() ? printMargin.bottom() : style-&gt;marginBottom().value() * pixelToPointScaleFactor,
 96         style-&gt;marginLeft().isAuto() ? printMargin.left() : style-&gt;marginLeft().value() * pixelToPointScaleFactor };
 97 }
 98 
 99 FloatSize PrintContext::computedPageSize(FloatSize pageSize, FloatBoxExtent printMargin)
100 {
101     auto computedMargin = computedPageMargin(printMargin);
102     if (computedMargin == printMargin)
103         return pageSize;
104 
105     auto horizontalMarginDelta = (printMargin.left() - computedMargin.left()) + (printMargin.right() - computedMargin.right());
106     auto verticalMarginDelta = (printMargin.top() - computedMargin.top()) + (printMargin.bottom() - computedMargin.bottom());
107     return { pageSize.width() + horizontalMarginDelta, pageSize.height() + verticalMarginDelta };
108 }
109 
110 void PrintContext::computePageRectsWithPageSize(const FloatSize&amp; pageSizeInPixels, bool allowHorizontalTiling)
111 {
112     m_pageRects.clear();
</pre>
<hr />
<pre>
213 
214     bool useViewWidth = true;
215     if (frame.document() &amp;&amp; frame.document()-&gt;renderView())
216         useViewWidth = frame.document()-&gt;renderView()-&gt;style().isHorizontalWritingMode();
217 
218     float viewLogicalWidth = useViewWidth ? frame.view()-&gt;contentsWidth() : frame.view()-&gt;contentsHeight();
219     if (viewLogicalWidth &lt; 1)
220         return 1;
221 
222     float maxShrinkToFitScaleFactor = 1 / maximumShrinkFactor();
223     float shrinkToFitScaleFactor = (useViewWidth ? availablePaperSize.width() : availablePaperSize.height()) / viewLogicalWidth;
224     return std::max(maxShrinkToFitScaleFactor, shrinkToFitScaleFactor);
225 }
226 
227 void PrintContext::spoolPage(GraphicsContext&amp; ctx, int pageNumber, float width)
228 {
229     if (!frame())
230         return;
231 
232     auto&amp; frame = *this-&gt;frame();
<span class="line-added">233     if (!frame.view())</span>
<span class="line-added">234         return;</span>
<span class="line-added">235 </span>
236     // FIXME: Not correct for vertical text.
237     IntRect pageRect = m_pageRects[pageNumber];
238     float scale = width / pageRect.width();
239 
240     ctx.save();
241     ctx.scale(scale);
242     ctx.translate(-pageRect.x(), -pageRect.y());
243     ctx.clip(pageRect);
244     frame.view()-&gt;paintContents(ctx, pageRect);
245     outputLinkedDestinations(ctx, *frame.document(), pageRect);
246     ctx.restore();
247 }
248 
249 void PrintContext::spoolRect(GraphicsContext&amp; ctx, const IntRect&amp; rect)
250 {
251     if (!frame())
252         return;
253 
254     auto&amp; frame = *this-&gt;frame();
<span class="line-added">255     if (!frame.view())</span>
<span class="line-added">256         return;</span>
<span class="line-added">257 </span>
258     // FIXME: Not correct for vertical text.
259     ctx.save();
260     ctx.translate(-rect.x(), -rect.y());
261     ctx.clip(rect);
262     frame.view()-&gt;paintContents(ctx, rect);
263     outputLinkedDestinations(ctx, *frame.document(), rect);
264     ctx.restore();
265 }
266 
267 void PrintContext::end()
268 {
269     if (!frame())
270         return;
271 
272     auto&amp; frame = *this-&gt;frame();
273     ASSERT(m_isPrinting);
274     m_isPrinting = false;
275     frame.setPrinting(false, FloatSize(), FloatSize(), 0, AdjustViewSize);
276     m_linkedDestinations = nullptr;
277 }
</pre>
</td>
</tr>
</table>
<center><a href="PointerLockController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProcessWarming.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>